diff --git a/.idea/runConfigurations/FirestoreProdIntegrationTest.xml b/.idea/runConfigurations/FirestoreProdIntegrationTest.xml
new file mode 100644
index 000000000..fda38c030
--- /dev/null
+++ b/.idea/runConfigurations/FirestoreProdIntegrationTest.xml
@@ -0,0 +1,21 @@
+<component name="ProjectRunConfigurationManager">
+  <configuration default="false" name="FirestoreProdIntegrationTest" type="GradleRunConfiguration" factoryName="Gradle">
+    <ExternalSystemSettings>
+      <option name="executionName" />
+      <option name="externalProjectPath" value="$PROJECT_DIR$/firebase-firestore" />
+      <option name="externalSystemIdString" value="GRADLE" />
+      <option name="scriptParameters" value="-PuseProdBackendForTests=true" />
+      <option name="taskDescriptions">
+        <list />
+      </option>
+      <option name="taskNames">
+        <list>
+          <option value="connectedAndroidTest" />
+        </list>
+      </option>
+      <option name="vmOptions" value="" />
+    </ExternalSystemSettings>
+    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
+    <method />
+  </configuration>
+</component>
\ No newline at end of file
diff --git a/.idea/runConfigurations/Firestore_Integration_Tests.xml b/.idea/runConfigurations/Firestore_Integration_Tests__Firestore_Emulator_.xml
similarity index 86%
rename from .idea/runConfigurations/Firestore_Integration_Tests.xml
rename to .idea/runConfigurations/Firestore_Integration_Tests__Firestore_Emulator_.xml
index f9c2ad5a0..1c1053aa8 100644
--- a/.idea/runConfigurations/Firestore_Integration_Tests.xml
+++ b/.idea/runConfigurations/Firestore_Integration_Tests__Firestore_Emulator_.xml
@@ -1,5 +1,5 @@
 <component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="Firestore Integration Tests" type="AndroidTestRunConfigurationType" factoryName="Android Instrumented Tests">
+  <configuration default="false" name="Firestore Integration Tests (Firestore Emulator)" type="AndroidTestRunConfigurationType" factoryName="Android Instrumented Tests">
     <module name="firebase-firestore" />
     <option name="TESTING_TYPE" value="1" />
     <option name="INSTRUMENTATION_RUNNER_CLASS" value="" />
@@ -12,7 +12,7 @@
     <option name="SKIP_NOOP_APK_INSTALLATIONS" value="true" />
     <option name="FORCE_STOP_RUNNING_APP" value="true" />
     <option name="TARGET_SELECTION_MODE" value="SHOW_DIALOG" />
-    <option name="USE_LAST_SELECTED_DEVICE" value="false" />
+    <option name="USE_LAST_SELECTED_DEVICE" value="true" />
     <option name="PREFERRED_AVD" value="" />
     <option name="SELECTED_CLOUD_MATRIX_CONFIGURATION_ID" value="-1" />
     <option name="SELECTED_CLOUD_MATRIX_PROJECT_ID" value="" />
@@ -41,10 +41,11 @@
     </Native>
     <Profilers>
       <option name="ADVANCED_PROFILING_ENABLED" value="false" />
+      <option name="STARTUP_CPU_PROFILING_ENABLED" value="false" />
+      <option name="STARTUP_CPU_PROFILING_CONFIGURATION_NAME" value="Sample Java Methods" />
     </Profilers>
-    <method>
+    <method v="2">
       <option name="Android.Gradle.BeforeRunTask" enabled="true" />
-      <option name="com.android.instantApps.provision.BeforeRunTask" enabled="true" clearCache="false" clearProvisionedDevices="false" myTimestamp="1535475311190" />
     </method>
   </configuration>
 </component>
\ No newline at end of file
diff --git a/.opensource/project.json b/.opensource/project.json
index 1dfd5ca8d..6b5e63e03 100644
--- a/.opensource/project.json
+++ b/.opensource/project.json
@@ -8,7 +8,8 @@
     "pages": {
         "README.md": "Development Guide",
         "docs/ktx/common.md": "Common KTX",
-        "docs/ktx/firestore.md": "Firestore KTX"
+        "docs/ktx/firestore.md": "Firestore KTX",
+        "docs/ktx/functions.md": "Functions KTX"
     },
     "related": [
         "firebase/quickstart-android"
@@ -23,4 +24,4 @@
             "href": "https://firebase.github.io/firebase-android-sdk/reference/kotlin/firebase-ktx/"
         }
     ]
-}
\ No newline at end of file
+}
diff --git a/README.md b/README.md
index 1cef7ea1c..ae860561f 100644
--- a/README.md
+++ b/README.md
@@ -4,12 +4,19 @@ This repository contains a subset of the Firebase Android SDK source. It
 currently includes the following Firebase libraries, and some of their
 dependencies:
 
+  * `firebase-abt`
   * `firebase-common`
+  * `firebase-common-ktx`
   * `firebase-database`
-  * `firebase-functions`
+  * `firebase-database-collection`
+  * `firebase-datatransport`
   * `firebase-firestore`
-  * `firebase-storage`
+  * `firebase-firestore-ktx`
+  * `firebase-functions`
+  * `firebase-functions-ktx`
   * `firebase-inappmessaging-display`
+  * `firebase-remote-config`
+  * `firebase-storage`
   
 
 Firebase is an app development platform with tools to help you build, grow and
diff --git a/buildSrc/build.gradle b/buildSrc/build.gradle
index 9cea827df..7cc07ceb8 100644
--- a/buildSrc/build.gradle
+++ b/buildSrc/build.gradle
@@ -37,14 +37,14 @@ dependencies {
     implementation 'org.jsoup:jsoup:1.11.2'
     implementation 'digital.wup:android-maven-publish:3.6.2'
     implementation 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.20'
+    implementation 'org.json:json:20180813'
 
     implementation 'io.opencensus:opencensus-api:0.18.0'
     implementation 'io.opencensus:opencensus-exporter-stats-stackdriver:0.18.0'
     runtime 'io.opencensus:opencensus-impl:0.18.0'
 
-    implementation 'com.android.tools.build:gradle:3.2.1'
+    implementation 'com.android.tools.build:gradle:3.4.1'
     testImplementation 'junit:junit:4.12'
-    testImplementation 'org.json:json:20180813'
     testImplementation('org.spockframework:spock-core:1.1-groovy-2.4') {
         exclude group: 'org.codehaus.groovy'
     }
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/FirebaseLibraryExtension.java b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/FirebaseLibraryExtension.java
index aad6b97a2..67a0e024b 100644
--- a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/FirebaseLibraryExtension.java
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/FirebaseLibraryExtension.java
@@ -16,6 +16,7 @@
 
 import com.google.common.collect.ImmutableSet;
 import com.google.firebase.gradle.plugins.ci.device.FirebaseTestLabExtension;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.stream.Collectors;
@@ -38,6 +39,9 @@
   /** Indicates whether sources are published alongside the library. */
   public boolean publishSources;
 
+  /** Static analysis configuration. */
+  public final FirebaseStaticAnalysis staticAnalysis;
+
   /** Firebase Test Lab configuration/ */
   public final FirebaseTestLabExtension testLab;
 
@@ -75,6 +79,20 @@ public FirebaseLibraryExtension(Project project) {
       artifactId.set(new DefaultProvider<>(project::getName));
       groupId.set(new DefaultProvider<>(() -> project.getGroup().toString()));
     }
+    this.staticAnalysis = initializeStaticAnalysis(project);
+  }
+
+  private FirebaseStaticAnalysis initializeStaticAnalysis(Project project) {
+    return new FirebaseStaticAnalysis(
+        projectsFromProperty(project, "firebase.checks.errorproneProjects"),
+        projectsFromProperty(project, "firebase.checks.lintProjects"));
+  }
+
+  private Set<String> projectsFromProperty(Project project, String propertyName) {
+    if (!project.hasProperty(propertyName)) {
+      return Collections.emptySet();
+    }
+    return ImmutableSet.copyOf(project.property(propertyName).toString().split(",", -1));
   }
 
   /** Configure Firebase Test Lab. */
@@ -126,4 +144,8 @@ public void applyPomCustomization(MavenPom pom) {
       customizePomAction.execute(pom);
     }
   }
+
+  public void staticAnalysis(Action<FirebaseStaticAnalysis> action) {
+    action.execute(staticAnalysis);
+  }
 }
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/FirebaseLibraryPlugin.java b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/FirebaseLibraryPlugin.java
index 5950a5477..df8a66fc2 100644
--- a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/FirebaseLibraryPlugin.java
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/FirebaseLibraryPlugin.java
@@ -15,15 +15,26 @@
 package com.google.firebase.gradle.plugins;
 
 import com.android.build.gradle.LibraryExtension;
+import com.android.build.gradle.api.AndroidSourceSet;
+import com.android.build.gradle.api.LibraryVariant;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import com.google.firebase.gradle.plugins.apiinfo.GenerateApiTxtFileTask;
+import com.google.firebase.gradle.plugins.apiinfo.ApiInformationTask;
+import com.google.firebase.gradle.plugins.apiinfo.GetMetalavaJarTask;
 import com.google.firebase.gradle.plugins.ci.device.FirebaseTestServer;
+
 import org.gradle.api.Plugin;
 import org.gradle.api.Project;
-import org.gradle.api.tasks.bundling.Jar;
 import org.jetbrains.kotlin.gradle.tasks.KotlinCompile;
+import java.io.File;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
 
 public class FirebaseLibraryPlugin implements Plugin<Project> {
+
   @Override
   public void apply(Project project) {
     project.apply(ImmutableMap.of("plugin", "com.android.library"));
@@ -33,8 +44,34 @@ public void apply(Project project) {
 
     LibraryExtension android = project.getExtensions().getByType(LibraryExtension.class);
 
+    // In the case of and android library signing config only affects instrumentation test APK.
+    // We need it signed with default debug credentials in order for FTL to accept the APK.
+    android.buildTypes(
+        types ->
+            types
+                .getByName("release")
+                .setSigningConfig(types.getByName("debug").getSigningConfig()));
+
+    // skip debug tests in CI
+    // TODO(vkryachko): provide ability for teams to control this if needed
+    if (System.getenv().containsKey("FIREBASE_CI")) {
+      android.setTestBuildType("release");
+      project
+          .getTasks()
+          .all(
+              task -> {
+                if ("testDebugUnitTest".equals(task.getName())) {
+                  task.setEnabled(false);
+                }
+              });
+    }
+
+    setupApiInformationAnalysis(project, android);
+
     android.testServer(new FirebaseTestServer(project, firebaseLibrary.testLab));
 
+    setupStaticAnalysis(project, android, firebaseLibrary);
+
     // reduce the likelihood of kotlin module files colliding.
     project
         .getTasks()
@@ -47,6 +84,78 @@ public void apply(Project project) {
                         ImmutableList.of("-module-name", kotlinModuleName(project))));
   }
 
+  private static void setupApiInformationAnalysis(Project project, LibraryExtension android) {
+    File metalavaOutputJarFile = new File(project.getRootProject().getBuildDir(), "metalava.jar");
+    AndroidSourceSet mainSourceSet = android.getSourceSets().getByName("main");
+    File outputFile = project.getRootProject().file(Paths.get(
+        project.getRootProject().getBuildDir().getPath(),
+        "apiinfo",
+        project.getPath().substring(1).replace(":", "_")));
+    File outputApiFile = new File(outputFile.getAbsolutePath() + "_api.txt");
+    List<File> sourcePath = mainSourceSet.getJava().getSrcDirs().stream().collect(Collectors.toList());
+    if(mainSourceSet.getJava().getSrcDirs().stream().noneMatch(File::exists)) {
+      return;
+    }
+    project.getTasks().register("getMetalavaJar", GetMetalavaJarTask.class, task -> {
+      task.setOutputFile(metalavaOutputJarFile);
+    });
+    project.getTasks().register("apiInformation", ApiInformationTask.class, task -> {
+      task.setApiTxt(project.file("api.txt"));
+      task.setMetalavaJarPath(metalavaOutputJarFile.getAbsolutePath());
+      task.setSourcePath(sourcePath);
+      task.setOutputFile(outputFile);
+      task.setBaselineFile(project.file("baseline.txt"));
+      task.setOutputApiFile(outputApiFile);
+      if (project.hasProperty("updateBaseline")) {
+        task.setUpdateBaseline(true);
+      } else {
+        task.setUpdateBaseline(false);
+      }
+      task.dependsOn("getMetalavaJar");
+    });
+
+    project.getTasks().register("generateApiTxtFile", GenerateApiTxtFileTask.class, task -> {
+      task.setApiTxt(project.file("api.txt"));
+      task.setMetalavaJarPath(metalavaOutputJarFile.getAbsolutePath());
+      task.setSourcePath(sourcePath);
+      task.setBaselineFile(project.file("baseline.txt"));
+      if (project.hasProperty("updateBaseline")) {
+        task.setUpdateBaseline(true);
+      } else {
+        task.setUpdateBaseline(false);
+      }
+      task.dependsOn("getMetalavaJar");
+    });
+  }
+
+  private static void setupStaticAnalysis(
+      Project project, LibraryExtension android, FirebaseLibraryExtension library) {
+    project.afterEvaluate(
+        p ->
+            project
+                .getConfigurations()
+                .all(
+                    c -> {
+                      if ("annotationProcessor".equals(c.getName())) {
+                        for (String checkProject : library.staticAnalysis.errorproneCheckProjects) {
+                          project
+                              .getDependencies()
+                              .add("annotationProcessor", project.project(checkProject));
+                        }
+                      }
+                      if ("lintChecks".equals(c.getName())) {
+                        for (String checkProject :
+                            library.staticAnalysis.androidLintCheckProjects) {
+                          project
+                              .getDependencies()
+                              .add("lintChecks", project.project(checkProject));
+                        }
+                      }
+                    }));
+
+    project.getTasks().register("firebaseLint", task -> task.dependsOn("lint"));
+  }
+
   private static String kotlinModuleName(Project project) {
 
     String fullyQualifiedProjectPath = project.getPath().replaceAll(":", "-");
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/FirebaseStaticAnalysis.java b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/FirebaseStaticAnalysis.java
new file mode 100644
index 000000000..1f8da8b03
--- /dev/null
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/FirebaseStaticAnalysis.java
@@ -0,0 +1,28 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.gradle.plugins;
+
+import java.util.Set;
+
+public class FirebaseStaticAnalysis {
+  public Set<String> errorproneCheckProjects;
+  public Set<String> androidLintCheckProjects;
+
+  public FirebaseStaticAnalysis(
+      Set<String> errorproneCheckProjects, Set<String> androidLintCheckProjects) {
+    this.errorproneCheckProjects = errorproneCheckProjects;
+    this.androidLintCheckProjects = androidLintCheckProjects;
+  }
+}
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/apiinfo/ApiInformationTask.java b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/apiinfo/ApiInformationTask.java
new file mode 100644
index 000000000..5048dd24a
--- /dev/null
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/apiinfo/ApiInformationTask.java
@@ -0,0 +1,123 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.gradle.plugins.apiinfo;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collector;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import org.gradle.api.DefaultTask;
+import org.gradle.api.GradleException;
+import org.gradle.api.tasks.Input;
+import org.gradle.api.tasks.InputDirectory;
+import org.gradle.api.tasks.InputFile;
+import org.gradle.api.tasks.InputFiles;
+import org.gradle.api.tasks.OutputFile;
+import org.gradle.api.tasks.TaskAction;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.util.Arrays;
+
+/**
+    Task generates the api diff of the current source code against the api.txt file stored
+    alongside the project's src directory.
+ */
+public abstract class ApiInformationTask extends DefaultTask {
+
+    @Input
+    abstract String getMetalavaJarPath();
+
+    @InputFile
+    abstract File getApiTxt();
+
+    @InputFiles
+    abstract List<File> getSourcePath();
+
+    @OutputFile
+    abstract File getBaselineFile();
+
+    @OutputFile
+    abstract File getOutputApiFile();
+
+    @Input
+    abstract boolean getUpdateBaseline();
+
+    @OutputFile
+    abstract File getOutputFile();
+
+    public abstract void setSourcePath(List<File> value);
+
+    public abstract void setBaselineFile(File value);
+
+    public abstract void setUpdateBaseline(boolean value);
+
+    public abstract void setMetalavaJarPath(String value);
+
+    public abstract void setApiTxt(File value);
+
+    public abstract void setOutputApiFile(File value);
+
+    public abstract void setOutputFile(File value);
+
+
+    @TaskAction
+    void execute() {
+        String sourcePath = getSourcePath().stream().map(File::getAbsolutePath).collect(Collectors.joining(":"));
+        File outputFileDir = getOutputFile().getParentFile();
+        if(!outputFileDir.exists()) {
+            outputFileDir.mkdirs();
+        }
+
+        // Generate api.txt file and store it in the  build directory.
+        getProject().javaexec(spec-> {
+            spec.setMain("-jar");
+            spec.setArgs(Arrays.asList(
+                getMetalavaJarPath(),
+                "--source-path", sourcePath,
+                "--api", getOutputApiFile().getAbsolutePath(),
+                "--format=v2"
+            ));
+            spec.setIgnoreExitValue(true);
+        });
+        getProject().javaexec(spec-> {
+            spec.setMain("-jar");
+            List<String> args = new ArrayList<>(Arrays.asList(
+                getMetalavaJarPath(),
+                "--source-files", getOutputApiFile().getAbsolutePath(),
+                "--check-compatibility:api:current", getApiTxt().getAbsolutePath(),
+                "--format=v2",
+                "--no-color",
+                "--delete-empty-baselines"
+            ));
+            if(getUpdateBaseline()) {
+                args.addAll(Arrays.asList("--update-baseline", getBaselineFile().getAbsolutePath()));
+            } else if(getBaselineFile().exists()) {
+                args.addAll(Arrays.asList("--baseline", getBaselineFile().getAbsolutePath()));
+            }
+            spec.setArgs(args);
+            spec.setIgnoreExitValue(true);
+            try {
+                spec.setStandardOutput(new FileOutputStream(getOutputFile()));
+            } catch (FileNotFoundException e) {
+                throw new GradleException("Unable to run the command", e);
+            }
+        });
+
+    }
+
+}
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/apiinfo/GenerateApiTxtFileTask.java b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/apiinfo/GenerateApiTxtFileTask.java
new file mode 100644
index 000000000..7c6b8a6e5
--- /dev/null
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/apiinfo/GenerateApiTxtFileTask.java
@@ -0,0 +1,86 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.gradle.plugins.apiinfo;
+
+
+import java.util.ArrayList;
+import java.util.List;
+import org.gradle.api.DefaultTask;
+import org.gradle.api.tasks.Input;
+import org.gradle.api.tasks.InputDirectory;
+import org.gradle.api.tasks.InputFiles;
+import org.gradle.api.tasks.OutputFile;
+import org.gradle.api.tasks.TaskAction;
+import java.io.File;
+
+import java.util.Arrays;
+import java.util.stream.Collector;
+import java.util.stream.Collectors;
+
+
+public abstract class GenerateApiTxtFileTask extends DefaultTask {
+
+    @Input
+    abstract String getMetalavaJarPath();
+
+    @OutputFile
+    abstract File getApiTxt();
+
+    @InputFiles
+    abstract List<File> getSourcePath();
+
+
+    @OutputFile
+    abstract File getBaselineFile();
+
+    @Input
+    abstract boolean getUpdateBaseline();
+
+
+    public abstract void setSourcePath(List<File> value);
+
+    public abstract void setBaselineFile(File value);
+
+    public abstract void setUpdateBaseline(boolean value);
+
+    public abstract void setMetalavaJarPath(String value);
+
+    public abstract void setApiTxt(File value);
+
+    @TaskAction
+    void execute() {
+        String sourcePath =  getSourcePath().stream().map(File::getAbsolutePath).collect(Collectors.joining(":"));
+        List<String> args =  new ArrayList<String>(Arrays.asList(
+            getMetalavaJarPath(),
+            "--source-path", sourcePath,
+            "--api", getApiTxt().getAbsolutePath(),
+            "--format=v2",
+            "--delete-empty-baselines"
+        ));
+
+        if(getUpdateBaseline()) {
+            args.addAll(Arrays.asList("--update-baseline", getBaselineFile().getAbsolutePath()));
+        } else if(getBaselineFile().exists()) {
+            args.addAll(Arrays.asList("--baseline", getBaselineFile().getAbsolutePath()));
+        }
+
+        getProject().javaexec(spec -> {
+            spec.setMain("-jar");
+            spec.setArgs(args);
+            spec.setIgnoreExitValue(true);
+        });
+
+    }
+}
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/apiinfo/GetMetalavaJarTask.java b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/apiinfo/GetMetalavaJarTask.java
new file mode 100644
index 000000000..3bf849d66
--- /dev/null
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/apiinfo/GetMetalavaJarTask.java
@@ -0,0 +1,55 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.gradle.plugins.apiinfo;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.JarURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.nio.file.FileSystems;
+import java.nio.file.Files;
+import java.nio.file.StandardCopyOption;
+import org.gradle.api.DefaultTask;
+import org.gradle.api.GradleException;
+import org.gradle.api.invocation.Gradle;
+import org.gradle.api.tasks.Input;
+import org.gradle.api.tasks.OutputFile;
+import org.gradle.api.tasks.TaskAction;
+
+public abstract class GetMetalavaJarTask extends DefaultTask {
+
+
+  @OutputFile
+  abstract File getOutputFile();
+
+  public abstract void setOutputFile(File outputFile);
+
+  @TaskAction
+  void execute() {
+    if (getOutputFile().exists()) {
+      return;
+    }
+
+    try (InputStream stream = new URL("https://storage.googleapis.com/android-ci/metalava-full-1.3.0-SNAPSHOT.jar").openStream()){
+      Files.copy(stream, getOutputFile().toPath(), StandardCopyOption.REPLACE_EXISTING);
+    } catch (IOException e) {
+      throw new GradleException("Unable to read the jar file from GCS", e);
+    }
+  }
+
+}
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/AffectedProjectFinder.groovy b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/AffectedProjectFinder.groovy
index d04607189..ffe1e4309 100644
--- a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/AffectedProjectFinder.groovy
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/AffectedProjectFinder.groovy
@@ -25,6 +25,10 @@ class AffectedProjectFinder {
     Set<String> changedPaths;
 
     @Builder
+    AffectedProjectFinder(Project project, List<Pattern> ignorePaths) {
+        this(project, changedPaths(project.rootDir), ignorePaths)
+    }
+
     AffectedProjectFinder(Project project,
                           Set<String> changedPaths,
                           List<Pattern> ignorePaths) {
@@ -49,6 +53,13 @@ class AffectedProjectFinder {
         return project.subprojects
     }
 
+    private static Set<String> changedPaths(File workDir) {
+        return 'git diff --name-only --submodule=diff HEAD@{0} HEAD@{1}'
+                .execute([], workDir)
+                .text
+                .readLines()
+    }
+
     /**
      * Performs a post-order project tree traversal and returns a set of projects that own the
      * 'changedPaths'.
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/ContinuousIntegrationPlugin.groovy b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/ContinuousIntegrationPlugin.groovy
index 95334ba6d..7c44748e6 100644
--- a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/ContinuousIntegrationPlugin.groovy
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/ContinuousIntegrationPlugin.groovy
@@ -97,7 +97,6 @@ class ContinuousIntegrationPlugin implements Plugin<Project> {
 
         def affectedProjects = AffectedProjectFinder.builder()
                 .project(project)
-                .changedPaths(changedPaths(project.rootDir))
                 .ignorePaths(extension.ignorePaths)
                 .build()
                 .find()
@@ -143,13 +142,6 @@ class ContinuousIntegrationPlugin implements Plugin<Project> {
         }
     }
 
-    private static Set<String> changedPaths(File workDir) {
-        return 'git diff --name-only --submodule=diff HEAD@{0} HEAD@{1}'
-                .execute([], workDir)
-                .text
-                .readLines()
-    }
-
     private static final ANDROID_PLUGINS = ["com.android.application", "com.android.library",
                                            "com.android.test"]
 
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/SmokeTestsPlugin.groovy b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/SmokeTestsPlugin.groovy
new file mode 100644
index 000000000..01423afd3
--- /dev/null
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/SmokeTestsPlugin.groovy
@@ -0,0 +1,105 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.gradle.plugins.ci
+
+import com.google.firebase.gradle.plugins.FirebaseLibraryExtension
+import com.google.firebase.gradle.plugins.ci.AffectedProjectFinder
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+import org.gradle.api.artifacts.ProjectDependency
+import org.json.JSONArray
+import org.json.JSONObject
+
+/** Builds Firebase libraries for consumption by the smoke tests. */
+class SmokeTestsPlugin implements Plugin<Project> {
+  @Override
+  public void apply(Project project) {
+    def assembleAllTask = project.task("assembleAllForSmokeTests")
+
+    // Wait until after the projects have been evaluated or else we might skip projects.
+    project.gradle.projectsEvaluated {
+      def changedProjects = getChangedProjects(project)
+      def changedArtifacts = new HashSet<String>()
+      def allArtifacts = new HashSet<String>()
+
+      // Visit each project and add the artifacts to the appropriate sets.
+      project.subprojects {
+        def firebaseLibrary = it.extensions.findByType(FirebaseLibraryExtension)
+	if (firebaseLibrary == null) {
+	  return
+	}
+
+        def groupId = firebaseLibrary.groupId.get()
+        def artifactId = firebaseLibrary.artifactId.get()
+        def artifact = "$groupId:$artifactId:$it.version-SNAPSHOT"
+        allArtifacts.add(artifact)
+
+        if (changedProjects.contains(it)) {
+          changedArtifacts.add(artifact)
+        }
+      }
+
+      // Reuse the publish task for building the libraries.
+      def publishAllTask = project.tasks.getByPath("publishAllToBuildDir")
+      assembleAllTask.dependsOn(publishAllTask)
+
+      // Generate a JSON file listing the artifacts after everything is complete.
+      assembleAllTask.doLast {
+        def changed = new JSONArray()
+        changedArtifacts.each { changed.put(it) }
+
+        def all = new JSONArray()
+        allArtifacts.each { all.put(it) }
+
+        def json = new JSONObject()
+        json.put("headGit", all)
+        json.put("default", changed)
+
+        def path = project.buildDir.toPath()
+        path.resolve("m2repository/changed-artifacts.json").write(json.toString())
+      }
+    }
+  }
+
+  private static Set<Project> getChangedProjects(Project p) {
+    Set<Project> roots = new AffectedProjectFinder(p, []).find()
+    HashSet<Project> changed = new HashSet<>()
+
+    getChangedProjectsLoop(roots, changed)
+    return changed
+  }
+
+  private static void getChangedProjectsLoop(Collection<Project> projects, Set<Project> changed) {
+    for (Project p : projects) {
+      // Skip project if it is not a Firebase library.
+      if (p.extensions.findByType(FirebaseLibraryExtension) == null) {
+        continue;
+      }
+
+      // Skip processing and recursion if this project has already been added to the set.
+      if (!changed.add(p)) {
+        continue;
+      }
+
+      // Find all (head) dependencies to other projects in this respository.
+      def all = p.configurations.releaseRuntimeClasspath.allDependencies
+      def affected =
+          all.findAll { it instanceof ProjectDependency }.collect { it.getDependencyProject() }
+
+      // Recurse with the new dependencies.
+      getChangedProjectsLoop(affected, changed)
+    }
+  }
+}
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/device/FirebaseTestServer.groovy b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/device/FirebaseTestServer.groovy
index 9b744a139..a29c7d1f2 100644
--- a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/device/FirebaseTestServer.groovy
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/device/FirebaseTestServer.groovy
@@ -54,6 +54,7 @@ class FirebaseTestServer extends TestServer {
                     '--type=instrumentation',
                     "--app=$testedApkPath", "--test=$testApk",
                     '--no-auto-google-login', '--no-record-video', '--no-performance-metrics', '-q',
+                    "--results-history-name=$project.path",
                     *resultsArgs, *devicesCmd)
         }
     }
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/license/RemoteLicenseFetcher.groovy b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/license/RemoteLicenseFetcher.groovy
index ca4e1a931..34a900efa 100644
--- a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/license/RemoteLicenseFetcher.groovy
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/license/RemoteLicenseFetcher.groovy
@@ -21,7 +21,7 @@ import org.jsoup.nodes.Document
 
 /**
  * Parse licenses from remote urls*/
-class RemoteLicenseFetcher implements Serializable {
+abstract class RemoteLicenseFetcher implements Serializable {
   private static final HtmlToPlainText TEXT_FORMATTER = new HtmlToPlainText()
 
   private final String remoteUrl
@@ -51,7 +51,7 @@ class RemoteLicenseFetcher implements Serializable {
           Thread.sleep(i * 1000)
         }
 
-        return processDocument(Jsoup.connect(remoteUrl).get())
+        return getTextAttempt()
       } catch (IOException ex) {
         if (storedEx == null) {
           storedEx = ex
@@ -64,10 +64,8 @@ class RemoteLicenseFetcher implements Serializable {
     throw storedEx
   }
 
-  /** Extracts the license text from the rest of the document. */
-  String processDocument(Document doc) {
-    return TEXT_FORMATTER.getPlainText(doc)
-  }
+  /** Attempts to download and extract the license exactly once. */
+  abstract String getTextAttempt()
 
   static final class AndroidSdkTermsFetcher extends RemoteLicenseFetcher {
 
@@ -76,10 +74,11 @@ class RemoteLicenseFetcher implements Serializable {
     }
 
     @Override
-    String processDocument(Document doc) {
+    String getTextAttempt() {
       // TODO(vkryachko, allisonbm92): Fix this silent failure.
       // This evaluates to an empty string. The HTML for this page must have changed since this
       // filter was original written. Interestingly, this is a hard-failure if run from Java.
+      def doc = Jsoup.connect(getRemoteUrl()).get()
       return TEXT_FORMATTER.getPlainText(doc.select("#body-content > div.jd-descr > div")[0])
     }
   }
@@ -89,6 +88,11 @@ class RemoteLicenseFetcher implements Serializable {
     Apache2LicenseFetcher() {
       super("http://www.apache.org/licenses/LICENSE-2.0.txt")
     }
+
+    @Override
+    String getTextAttempt() {
+      return getRemoteUrl().toURL().getText()
+    }
   }
 
   static final class AnotherApache2LicenseFetcher extends RemoteLicenseFetcher {
@@ -98,7 +102,8 @@ class RemoteLicenseFetcher implements Serializable {
     }
 
     @Override
-    String processDocument(Document doc) {
+    String getTextAttempt() {
+      def doc = Jsoup.connect(getRemoteUrl()).get()
       return TEXT_FORMATTER.getPlainText(doc.select("#content-wrapper").get(0))
     }
   }
@@ -108,6 +113,11 @@ class RemoteLicenseFetcher implements Serializable {
     YetAnotherApache2LicenseFetcher() {
       super("http://www.apache.org/licenses/LICENSE-2.0")
     }
+
+    @Override
+    String getTextAttempt() {
+      return getRemoteUrl().toURL().getText()
+    }
   }
 
   static final class BSDLicenseFetcher extends RemoteLicenseFetcher {
@@ -117,7 +127,8 @@ class RemoteLicenseFetcher implements Serializable {
     }
 
     @Override
-    String processDocument(Document doc) {
+    String getTextAttempt() {
+      def doc = Jsoup.connect(getRemoteUrl()).get()
       return TEXT_FORMATTER.getPlainText(doc.select("#content-wrapper").get(0))
     }
   }
@@ -129,7 +140,8 @@ class RemoteLicenseFetcher implements Serializable {
     }
 
     @Override
-    String processDocument(Document doc) {
+    String getTextAttempt() {
+      def doc = Jsoup.connect(getRemoteUrl()).get()
       return TEXT_FORMATTER.getPlainText(doc.select("#deed").get(0))
     }
   }
@@ -141,7 +153,8 @@ class RemoteLicenseFetcher implements Serializable {
     }
 
     @Override
-    String processDocument(Document doc) {
+    String getTextAttempt() {
+      def doc = Jsoup.connect(getRemoteUrl()).get()
       return TEXT_FORMATTER.getPlainText(doc.select("#content-wrapper").get(0))
     }
   }
@@ -153,7 +166,8 @@ class RemoteLicenseFetcher implements Serializable {
     }
 
     @Override
-    String processDocument(Document doc) {
+    String getTextAttempt() {
+      def doc = Jsoup.connect(getRemoteUrl()).get()
       return TEXT_FORMATTER.getPlainText(doc.select("#content-wrapper").get(0))
     }
   }
@@ -166,7 +180,8 @@ class RemoteLicenseFetcher implements Serializable {
     }
 
     @Override
-    String processDocument(Document doc) {
+    String getTextAttempt() {
+      def doc = Jsoup.connect(getRemoteUrl()).get()
       return TEXT_FORMATTER.getPlainText(doc.select("body > table > tbody > tr:nth-child(2) > td:nth-child(2) > table > tbody > tr:nth-child(3) > td > en > blockquote").get(0))
     }
   }
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeJsonBuilder.groovy b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeJsonBuilder.groovy
index 3362861ec..7bd51b8ba 100644
--- a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeJsonBuilder.groovy
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeJsonBuilder.groovy
@@ -18,9 +18,9 @@ package com.google.firebase.gradle.plugins.measurement.apksize
 /** A helper class that generates the APK size measurement JSON report. */
 class ApkSizeJsonBuilder {
 
-    private static final String PULL_REQUEST_TABLE = "PullRequests"
+    private static final String PULL_REQUEST_TABLE = "AndroidPullRequests"
     private static final String PULL_REQUEST_COLUMN = "pull_request_id"
-    private static final String APK_SIZE_TABLE = "ApkSizes"
+    private static final String APK_SIZE_TABLE = "AndroidApkSizes"
     private static final String SDK_COLUMN = "sdk_id"
     private static final String APK_SIZE_COLUMN = "apk_size"
 
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeTableBuilder.groovy b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeTableBuilder.groovy
index 5aee3294b..c18e9a5de 100644
--- a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeTableBuilder.groovy
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeTableBuilder.groovy
@@ -29,11 +29,11 @@ class ApkSizeTableBuilder {
           throw new IllegalStateException("No sizes added")
         }
 
-        def table = "|------------------        APK Sizes        ------------------|\n"
-        table +=    "|--    project    --|--  build type   --|--  size in bytes  --|\n"
+        def table = "|--------------------        APK Sizes        ------------------|\n"
+        table +=    "|---    project    ---|--  build type   --|--  size in bytes  --|\n"
 
         table += sdkSizes.collect {
-            sprintf("|%-19s|%-19s|%-21s|", it.get(0), it.get(1), it.get(2))
+            sprintf("|%-21s|%-19s|%-21s|", it.get(0), it.get(1), it.get(2))
         }.join("\n")
 
         return table
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/measurement/coverage/GenerateMeasurementsTask.groovy b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/measurement/coverage/GenerateMeasurementsTask.groovy
index f040e5e0b..083968beb 100644
--- a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/measurement/coverage/GenerateMeasurementsTask.groovy
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/measurement/coverage/GenerateMeasurementsTask.groovy
@@ -15,10 +15,12 @@
 
 package com.google.firebase.gradle.plugins.measurement.coverage
 
+import groovy.json.JsonOutput
+import java.text.SimpleDateFormat
 import org.gradle.api.DefaultTask
-import org.gradle.api.Project
 import org.gradle.api.tasks.OutputFile
 import org.gradle.api.tasks.TaskAction
+import com.google.firebase.gradle.plugins.FirebaseLibraryExtension
 import org.gradle.testing.jacoco.tasks.JacocoReport
 
 
@@ -38,6 +40,8 @@ public class GenerateMeasurementsTask extends DefaultTask {
 
         assert project.tasks.withType(JacocoReport).size() == 1 : 'Found multiple tasks which generate coverage reports.'
         coverageTaskName = project.tasks.withType(JacocoReport)[0].name
+
+        dependsOn(findAllProductCoverageTasks())
     }
 
     @TaskAction
@@ -50,7 +54,11 @@ public class GenerateMeasurementsTask extends DefaultTask {
         }
     }
 
-    private def getCoveragePercentFromReport(_project) {
+    // This method was called in a closure in `generateJson` method. At runtime,
+    // the closure is bound to a synthetic child class of this class generated
+    // by Gradle.
+    // Need to mark as protected or public to be callable within the closure.
+    protected def getCoverageForProject(_project) {
         def path = "${_project.jacoco.reportsDir}/${coverageTaskName}/${coverageTaskName}.xml"
         try {
             def report = parser.parse(path)
@@ -68,63 +76,34 @@ public class GenerateMeasurementsTask extends DefaultTask {
         }
     }
 
-    private def trimProjectPathLeadingColon(path) {
-        return path.startsWith(':') ? path.drop(1) : path
+    private def findAllFirebaseProductProjects() {
+        return project.rootProject.allprojects.findAll {
+            it.extensions.findByType(FirebaseLibraryExtension) != null
+        }
+    }
+
+    private def findAllProductCoverageTasks() {
+        return findAllFirebaseProductProjects().collect {
+            it.tasks.withType(JacocoReport)
+        }.flatten()
     }
 
     private def generateJson(pullRequestNumber) {
-        def coverages = [:]
-
-        // TODO(yifany@): Consolidate mappings with apksize and iOS.
-        def sdkMap = [
-                'firebase-common': 0,
-                'firebase-common-ktx': 1,
-                'firebase-database': 2,
-                'firebase-database-collection': 3,
-                'firebase-firestore': 4,
-                'firebase-firestore-ktx': 5,
-                'firebase-functions': 6,
-                'firebase-inappmessaging-display': 7,
-                'firebase-storage': 8,
-                'firebase-datatransport': 9,
-
-                // 'firebase-common-ktx' and 'firebase-firestore-ktx' has been
-                // made a subproject of their corresponding java projects in PR
-                // #409 and #426. Old mappings are kept for backward
-                // compatibility reason.
-                'firebase-common:ktx': 10,
-                'firebase-firestore:ktx': 11
-        ]
-
-        for (Project p: project.rootProject.subprojects) {
-            def name = trimProjectPathLeadingColon(p.path)
-            if (name.startsWith('firebase')) {
-                def percent = getCoveragePercentFromReport(p)
-                if (sdkMap.containsKey(name)) {
-                    coverages[sdkMap[name]] = percent
-                } else {
-                    project.logger.warn("Find SDK with name: $name not defined in the SDK to ID mapping.")
-                }
-            }
-        }
+        def now = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date())
+        def projects = findAllFirebaseProductProjects()
 
-        def replacements = coverages.collect {
-            "[$pullRequestNumber, $it.key, $it.value]"
-        }.join(", ")
+        def replacements = projects.collect {
+            [ it.path, pullRequestNumber, getCoverageForProject(it), now ]
+        }
 
         // TODO(yifany@): Better way of formatting json. No hard code names.
         def json = """
             {
                 tables: [
                     {
-                        table_name: "PullRequests",
-                        column_names: ["pull_request_id"],
-                        replace_measurements: [[$pullRequestNumber]],
-                    },
-                    {
-                        table_name: "Coverage2",
-                        column_names: ["pull_request_id", "sdk_id", "coverage_percent"],
-                        replace_measurements: [$replacements],
+                        table_name: "AndroidCodeCoverage",
+                        column_names: ["product_name", "pull_request_id", "coverage_total", "collection_time"],
+                        replace_measurements: ${JsonOutput.toJson(replacements)},
                     },
                 ],
             }
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/publish/Publisher.groovy b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/publish/Publisher.groovy
index 51036b38c..311e16263 100644
--- a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/publish/Publisher.groovy
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/publish/Publisher.groovy
@@ -74,7 +74,7 @@ class Publisher {
         pom.dependencies.dependency.each {
             // remove multidex as it is supposed to be added by final applications and is needed for
             // some libraries only for instrumentation tests to build.
-            if (it.groupId.text() in ['com.android.support', 'androidx'] && it.artifactId.text() == 'multidex') {
+            if (it.groupId.text() in ['com.android.support', 'androidx.multidex'] && it.artifactId.text() == 'multidex') {
                 it.parent().remove(it)
             }
             it.appendNode('type', [:], deps["${it.groupId.text()}:${it.artifactId.text()}"])
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/publish/PublishingPlugin.groovy b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/publish/PublishingPlugin.groovy
index 43d82fe65..46972bc15 100644
--- a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/publish/PublishingPlugin.groovy
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/publish/PublishingPlugin.groovy
@@ -140,8 +140,10 @@ class PublishingPlugin implements Plugin<Project> {
             def buildMavenZip = project.task('buildMavenZip', type: Zip) {
                 dependsOn publishProjectsToBuildDir
 
+                archiveFileName = 'm2repository.zip'
+                destinationDirectory = project.buildDir
+
                 from "$project.buildDir/m2repository"
-                archiveName "$project.buildDir/m2repository.zip"
             }
 
             def info = project.task('publishPrintInfo') {
diff --git a/buildSrc/src/test/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeJsonBuilderTest.groovy b/buildSrc/src/test/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeJsonBuilderTest.groovy
index 2b2107bcb..5788e5d17 100644
--- a/buildSrc/src/test/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeJsonBuilderTest.groovy
+++ b/buildSrc/src/test/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeJsonBuilderTest.groovy
@@ -41,7 +41,7 @@ public class ApkSizeJsonBuilderTest {
     def prColumns = prTable.getJSONArray("column_names")
     def prMeasurements = prTable.getJSONArray("replace_measurements")
 
-    assertEquals("Bad table name", "PullRequests", prTable.getString("table_name"))
+    assertEquals("Bad table name", "AndroidPullRequests", prTable.getString("table_name"))
     assertEquals("Bad column name", "pull_request_id", prColumns.getString(0))
     assertEquals("Bad pull request number", 117, prMeasurements.getJSONArray(0).getInt(0))
     assertEquals("Too many columns", 1, prColumns.length())
@@ -59,7 +59,7 @@ public class ApkSizeJsonBuilderTest {
     def asColumns = asTable.getJSONArray("column_names")
     def asMeasurements = asTable.getJSONArray("replace_measurements")
 
-    assertEquals("Bad table name", "ApkSizes", asTable.getString("table_name"))
+    assertEquals("Bad table name", "AndroidApkSizes", asTable.getString("table_name"))
     assertEquals("Bad column name", "pull_request_id", asColumns.getString(0))
     assertEquals("Bad column name", "sdk_id", asColumns.getString(1))
     assertEquals("Bad column name", "apk_size", asColumns.getString(2))
@@ -84,7 +84,7 @@ public class ApkSizeJsonBuilderTest {
     def asMeasurements = asTable.getJSONArray("replace_measurements")
 
     // The table itself.
-    assertEquals("Bad table name", "ApkSizes", asTable.getString("table_name"))
+    assertEquals("Bad table name", "AndroidApkSizes", asTable.getString("table_name"))
     assertEquals("Bad column name", "pull_request_id", asColumns.getString(0))
     assertEquals("Bad column name", "sdk_id", asColumns.getString(1))
     assertEquals("Bad column name", "apk_size", asColumns.getString(2))
diff --git a/buildSrc/src/test/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeTableBuilderTest.groovy b/buildSrc/src/test/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeTableBuilderTest.groovy
index e37201551..3b1cf3f25 100644
--- a/buildSrc/src/test/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeTableBuilderTest.groovy
+++ b/buildSrc/src/test/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeTableBuilderTest.groovy
@@ -25,8 +25,8 @@ import org.junit.runners.JUnit4
 public class ApkSizeTableBuilderTest {
 
   private static final String HEADER =
-      "|------------------        APK Sizes        ------------------|\n" +
-      "|--    project    --|--  build type   --|--  size in bytes  --|\n"
+      "|--------------------        APK Sizes        ------------------|\n" +
+      "|---    project    ---|--  build type   --|--  size in bytes  --|\n"
 
   @Test(expected = IllegalStateException.class)
   public void toTableString_throwsWhenZeroAdded() {
@@ -37,7 +37,7 @@ public class ApkSizeTableBuilderTest {
   @Test
   public void toTableString_withOneMeasurement() {
     def expected = HEADER +
-        "|firebase foo       |debug              |255000               |"
+        "|firebase foo         |debug              |255000               |"
 
     def builder = new ApkSizeTableBuilder()
     builder.addApkSize("firebase foo", "debug", 255000)
@@ -48,9 +48,9 @@ public class ApkSizeTableBuilderTest {
   @Test
   public void toTableString_withThreeMeasurements() {
     def expected = HEADER +
-        "|firebase foo       |debug              |255000               |\n" +
-        "|google loo         |release            |4000                 |\n" +
-        "|Appy Snap App      |Snappy             |781000               |"
+        "|firebase foo         |debug              |255000               |\n" +
+        "|google loo           |release            |4000                 |\n" +
+        "|Appy Snap App        |Snappy             |781000               |"
 
     def builder = new ApkSizeTableBuilder()
     builder.addApkSize("firebase foo", "debug", 255000)
diff --git a/buildSrc/src/test/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeTestProject.groovy b/buildSrc/src/test/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeTestProject.groovy
index 14b7a9cc2..399787f51 100644
--- a/buildSrc/src/test/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeTestProject.groovy
+++ b/buildSrc/src/test/groovy/com/google/firebase/gradle/plugins/measurement/apksize/ApkSizeTestProject.groovy
@@ -157,6 +157,7 @@ class ApkSizeTestProject extends ExternalResource {
 
         Files.createDirectories(dest)
         FileUtils.copyDirectory(src.toFile(), dest.toFile())
+        FileUtils.deleteDirectory(dest.resolve("coverage").toFile())
     }
 
     /** Creates the fake project files for the temporary project. */
diff --git a/ci/fireci/fireci/commands.py b/ci/fireci/fireci/commands.py
index db5bc4e12..7922f9930 100644
--- a/ci/fireci/fireci/commands.py
+++ b/ci/fireci/fireci/commands.py
@@ -15,6 +15,8 @@
 import click
 import os
 
+from github import Github
+
 from . import gradle
 from . import ci_command
 from . import stats
@@ -61,3 +63,39 @@ def smoke_tests(app_build_variant, test_apps_dir):
             os.path.join(cwd, 'build', 'm2repository')),
         workdir=location,
     )
+
+
+@click.option('--issue_number', 'issue_number', required=True)
+@click.option('--repo_name', 'repo_name', required=True)
+@click.option('--auth_token', 'auth_token', required=True)
+@ci_command()
+def api_information(auth_token, repo_name, issue_number):
+  """Comments the api information on the pr"""
+
+  gradle.run('apiInformation')
+  dir_suffix = 'build/apiinfo'
+  comment_string = ""
+  for filename in os.listdir(dir_suffix):
+    subproject = filename
+    formatted_output_lines = []
+    with open(os.path.join(dir_suffix, filename), 'r') as f:
+      outputlines = f.readlines()
+      for line in outputlines:
+        if 'error' in line:
+          formatted_output_lines.append(line[line.find('error:'):])
+        elif 'warning' in line:
+          formatted_output_lines.append(line[line.find('warning:'):])
+          
+    if formatted_output_lines:
+      comment_string += 'The public api surface has changed for the subproject {}:\n'.format(subproject)
+      comment_string += ''.join(formatted_output_lines)
+      comment_string += '\n\n'
+  if comment_string:
+    comment_string += ('Please update the api.txt files for the subprojects being affected by this change '
+      'by running ./gradlew ${subproject}:generateApiTxtFile. Also perform a major/minor bump accordingly.\n')
+    # Comment to github.
+    github_client = Github(auth_token)
+    repo = github_client.get_repo(repo_name)
+    pr = repo.get_pull(int(issue_number))
+    pr.create_issue_comment(comment_string)
+    exit(1)
diff --git a/ci/fireci/setup.py b/ci/fireci/setup.py
index 22bb08778..f38f7c010 100755
--- a/ci/fireci/setup.py
+++ b/ci/fireci/setup.py
@@ -28,6 +28,7 @@
         'click==7.0',
         'opencensus==0.2.0',
         'google-cloud-monitoring==0.31.1',
+        'PyGithub==1.43.8'
     ],
     packages=find_packages(exclude=['tests']),
     entry_points={
diff --git a/default-preguard.txt b/default-preguard.txt
index b05cfa4f0..c8be6ed5a 100644
--- a/default-preguard.txt
+++ b/default-preguard.txt
@@ -4,13 +4,13 @@
                 SourceFile,LineNumberTable,*Annotation*,EnclosingMethod
 
 # Keep the classes/members we need for client functionality.
--keep @interface android.support.annotation.Keep
--keep @android.support.annotation.Keep class *
+-keep @interface androidx.annotation.Keep
+-keep @androidx.annotation.Keep class *
 -keepclasseswithmembers class * {
-  @android.support.annotation.Keep <fields>;
+  @androidx.annotation.Keep <fields>;
 }
 -keepclasseswithmembers class * {
-  @android.support.annotation.Keep <methods>;
+  @androidx.annotation.Keep <methods>;
 }
 
 # Keep the classes/members we need for client functionality.
@@ -34,7 +34,7 @@
 }
 
 # Keep Enum members implicitly
--keepclassmembers @android.support.annotation.Keep public class * extends java.lang.Enum {
+-keepclassmembers @androidx.annotation.Keep public class * extends java.lang.Enum {
     public <fields>;
     public static **[] values();
     public static ** valueOf(java.lang.String);
diff --git a/fiamui-app/fiamui-app.gradle b/fiamui-app/fiamui-app.gradle
index db3061c13..4624ce185 100644
--- a/fiamui-app/fiamui-app.gradle
+++ b/fiamui-app/fiamui-app.gradle
@@ -17,6 +17,7 @@ apply plugin: com.google.firebase.gradle.plugins.ci.device.FirebaseTestLabPlugin
 
 android {
   compileSdkVersion project.targetSdkVersion
+  testBuildType 'release'
 
   defaultConfig {
     applicationId "com.example.firebase.fiamui"
@@ -24,7 +25,7 @@ android {
     targetSdkVersion project.targetSdkVersion
     versionCode 1
     versionName "1.0"
-    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
     multiDexEnabled true
   }
 
@@ -32,6 +33,7 @@ android {
     release {
       minifyEnabled false
       proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
+      signingConfig debug.signingConfig
     }
   }
 
@@ -53,26 +55,32 @@ android {
 
 dependencies {
   implementation project(path: ":firebase-inappmessaging-display")
-  implementation "com.google.firebase:firebase-measurement-connector:17.0.1"
-  implementation('com.google.firebase:firebase-inappmessaging:17.0.3') {
-    exclude group: 'com.google.firebase', module: 'firebase-common'
-  }
-  implementation('com.google.firebase:firebase-analytics:16.0.4') {
+  implementation project(path: ":firebase-inappmessaging")
+  implementation "com.google.firebase:firebase-measurement-connector:18.0.0"
+
+  implementation('com.google.firebase:firebase-analytics:17.0.0') {
     exclude group: 'com.google.firebase', module: 'firebase-common'
   }
 
   implementation "com.android.installreferrer:installreferrer:1.0"
-  implementation "com.android.support:design:27.1.1"
-  implementation "com.android.support:appcompat-v7:27.1.1"
+  implementation 'com.google.android.material:material:1.0.0'
+  implementation 'androidx.appcompat:appcompat:1.0.2'
+  implementation 'androidx.annotation:annotation:1.1.0'
+  implementation 'androidx.media:media:1.0.1'
+  implementation 'androidx.legacy:legacy-support-v4:1.0.0'
+  implementation "com.google.code.findbugs:jsr305:3.0.2"
+  implementation "com.squareup.okio:okio:1.13.0"
+  implementation "com.squareup.okhttp:okhttp:2.7.5"
+  implementation "com.google.auto.value:auto-value-annotations:1.6.5"
+  implementation "com.google.android.gms:play-services-basement:17.0.0"
 
   // The following dependencies are not required to use the FIAM UI library.
   // They are used to make some aspects of the demo app implementation simpler for
   // demonstrative purposes, and you may find them useful in your own apps; YMMV.
   implementation 'me.priyesh:chroma:1.0.2'
-  implementation "com.jakewharton:butterknife:8.8.1"
-  implementation "com.jakewharton:butterknife-compiler:8.8.1"
-  annotationProcessor "com.jakewharton:butterknife-compiler:8.8.1"
+  implementation "com.jakewharton:butterknife:10.1.0"
+  annotationProcessor "com.jakewharton:butterknife-compiler:10.1.0"
 
-  androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
-  androidTestImplementation 'com.android.support.test:rules:1.0.2'
-}
\ No newline at end of file
+  androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
+  androidTestImplementation 'androidx.test:rules:1.2.0'
+}
diff --git a/fiamui-app/scripts/run-test-lab.sh b/fiamui-app/scripts/run-test-lab.sh
old mode 100755
new mode 100644
index 86a0c616d..38429acc0
--- a/fiamui-app/scripts/run-test-lab.sh
+++ b/fiamui-app/scripts/run-test-lab.sh
@@ -16,13 +16,14 @@
 
 # First, you need to create a project, and bucket to use for the FTL runs.
 
-#############################################################################################
-## Note, running this will incur any FTL-related charges.                                  ##
-## We do require manual setting of the script arguments to ensure you've read this notice. ##
-#############################################################################################
+############################################################
+## Note, running this will incur any FTL-related charges. ##
+## We do require manual setting of the script arguments   ##
+## to ensure you've read this notice.                     ##
+############################################################
 
-PROJECT_ID={{add your project id here}}
-BUCKET_NAME={{add your bucket name here}}
+PROJECT_NAME = {{add your project id here}}
+BUCKET_NAME = {{add your bucket name here}}
 
 # Assemble the app
 ./gradlew :fiamui-app:assembleDebug :fiamui-app:assembleDebugAndroidTest
@@ -56,4 +57,4 @@ gcloud firebase test android run \
   --device model=NexusLowRes,version=23,locale=en,orientation=portrait \
   --device model=NexusLowRes,version=23,locale=en,orientation=landscape \
   --device model=victara,version=19,locale=en,orientation=portrait \
-  --device model=victara,version=19,locale=en,orientation=landscape
+  --device model=victara,version=19,locale=en,orientation=landscape
\ No newline at end of file
diff --git a/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/BannerTest.java b/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/BannerTest.java
index 6a99ed8eb..91e91d4e1 100644
--- a/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/BannerTest.java
+++ b/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/BannerTest.java
@@ -14,26 +14,26 @@
 
 package com.example.firebase.fiamui;
 
-import static android.support.test.espresso.Espresso.onView;
-import static android.support.test.espresso.action.ViewActions.click;
-import static android.support.test.espresso.action.ViewActions.scrollTo;
-import static android.support.test.espresso.action.ViewActions.swipeLeft;
-import static android.support.test.espresso.assertion.ViewAssertions.matches;
-import static android.support.test.espresso.matcher.RootMatchers.withDecorView;
-import static android.support.test.espresso.matcher.ViewMatchers.isDisplayed;
-import static android.support.test.espresso.matcher.ViewMatchers.withId;
-import static android.support.test.espresso.matcher.ViewMatchers.withText;
+import static androidx.test.espresso.Espresso.onView;
+import static androidx.test.espresso.action.ViewActions.click;
+import static androidx.test.espresso.action.ViewActions.scrollTo;
+import static androidx.test.espresso.action.ViewActions.swipeLeft;
+import static androidx.test.espresso.assertion.ViewAssertions.matches;
+import static androidx.test.espresso.matcher.RootMatchers.withDecorView;
+import static androidx.test.espresso.matcher.ViewMatchers.isDisplayed;
+import static androidx.test.espresso.matcher.ViewMatchers.withId;
+import static androidx.test.espresso.matcher.ViewMatchers.withText;
 import static com.example.firebase.fiamui.TestConstants.*;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.not;
 
-import android.support.annotation.IdRes;
-import android.support.annotation.NonNull;
-import android.support.test.espresso.Root;
-import android.support.test.espresso.ViewInteraction;
-import android.support.test.filters.MediumTest;
-import android.support.test.rule.ActivityTestRule;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.annotation.IdRes;
+import androidx.annotation.NonNull;
+import androidx.test.espresso.Root;
+import androidx.test.espresso.ViewInteraction;
+import androidx.test.filters.MediumTest;
+import androidx.test.rule.ActivityTestRule;
+import androidx.test.runner.AndroidJUnit4;
 import org.hamcrest.Matcher;
 import org.junit.After;
 import org.junit.Before;
diff --git a/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/CardTest.java b/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/CardTest.java
new file mode 100644
index 000000000..06799d0d5
--- /dev/null
+++ b/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/CardTest.java
@@ -0,0 +1,280 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.example.firebase.fiamui;
+
+import static androidx.test.espresso.Espresso.onView;
+import static androidx.test.espresso.action.ViewActions.clearText;
+import static androidx.test.espresso.action.ViewActions.click;
+import static androidx.test.espresso.action.ViewActions.replaceText;
+import static androidx.test.espresso.action.ViewActions.scrollTo;
+import static androidx.test.espresso.assertion.ViewAssertions.matches;
+import static androidx.test.espresso.matcher.RootMatchers.withDecorView;
+import static androidx.test.espresso.matcher.ViewMatchers.isDisplayed;
+import static androidx.test.espresso.matcher.ViewMatchers.isRoot;
+import static androidx.test.espresso.matcher.ViewMatchers.withId;
+import static androidx.test.espresso.matcher.ViewMatchers.withText;
+import static com.example.firebase.fiamui.TestConstants.BODY_OPT_LONG;
+import static com.example.firebase.fiamui.TestConstants.BODY_OPT_NONE;
+import static com.example.firebase.fiamui.TestConstants.BODY_OPT_NORMAL;
+import static com.example.firebase.fiamui.TestConstants.BODY_TEXT_LONG;
+import static com.example.firebase.fiamui.TestConstants.BODY_TEXT_NORMAL;
+import static com.example.firebase.fiamui.TestConstants.BUTTON_TEXT_CANCEL;
+import static com.example.firebase.fiamui.TestConstants.BUTTON_TEXT_NONE;
+import static com.example.firebase.fiamui.TestConstants.BUTTON_TEXT_NORMAL;
+import static com.example.firebase.fiamui.TestConstants.TITLE_TEXT_NORMAL;
+import static com.example.firebase.fiamui.TestConstants.TITLE_TEXT_SHORT;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.CoreMatchers.not;
+
+import androidx.annotation.IdRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.StringRes;
+import androidx.test.espresso.Root;
+import androidx.test.espresso.ViewInteraction;
+import androidx.test.espresso.action.ViewActions;
+import androidx.test.filters.MediumTest;
+import androidx.test.rule.ActivityTestRule;
+import androidx.test.runner.AndroidJUnit4;
+import org.hamcrest.Matcher;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@MediumTest
+@RunWith(AndroidJUnit4.class)
+public class CardTest {
+
+  @Rule
+  public ActivityTestRule<MainActivity> mActivityRule = new ActivityTestRule<>(MainActivity.class);
+
+  @Rule public TestName name = new TestName();
+
+  private Matcher<Root> rootMatcher;
+
+  @Before
+  public void setUp() {
+    rootMatcher = withDecorView(not(is(mActivityRule.getActivity().getWindow().getDecorView())));
+
+    // Set defaults
+    setTitle(TITLE_TEXT_NORMAL);
+    selectBody(BODY_OPT_NORMAL);
+    setPortraitImageSize(600, 400); // Ideal 3:2 aspect ratio
+    setLandscapeImageSize(800, 800); // Ideal 1:1 aspect ratio
+    setButton(BUTTON_TEXT_NORMAL, R.id.action_button_text);
+    setButton(BUTTON_TEXT_CANCEL, R.id.secondary_action_button_text);
+  }
+
+  @After
+  public void tearDown() {
+    ScreenShotter.takeScreenshot(name.getMethodName());
+
+    // If we are NOT in test lab, add a 2s delay after each test. This
+    // makes bench testing easier since you can eyeball the results as they run.
+    if (!TestUtils.isInTestLab(mActivityRule.getActivity())) {
+      try {
+        Thread.sleep(2000);
+      } catch (InterruptedException e) {
+        e.printStackTrace();
+      }
+    }
+
+    close();
+  }
+
+  @Test
+  public void testCard() {
+    open();
+
+    getView(R.id.card_root).check(matches(isDisplayed()));
+    getView(R.id.message_title).check(matches(withText(TITLE_TEXT_NORMAL)));
+    getView(R.id.image_view).check(matches(isDisplayed()));
+    getView(R.id.message_body).check(matches(withText(BODY_TEXT_NORMAL)));
+    getView(R.id.primary_button).check(matches(withText(BUTTON_TEXT_NORMAL)));
+    getView(R.id.secondary_button).check(matches(withText(BUTTON_TEXT_CANCEL)));
+  }
+
+  @Test
+  public void testCard_LongBody() {
+    selectBody(BODY_OPT_LONG);
+    open();
+
+    getView(R.id.card_root).check(matches(isDisplayed()));
+    getView(R.id.message_title).check(matches(withText(TITLE_TEXT_NORMAL)));
+    getView(R.id.image_view).check(matches(isDisplayed()));
+    getView(R.id.message_body).check(matches(withText(BODY_TEXT_LONG)));
+    getView(R.id.primary_button).check(matches(withText(BUTTON_TEXT_NORMAL)));
+    getView(R.id.secondary_button).check(matches(withText(BUTTON_TEXT_CANCEL)));
+  }
+
+  @Test
+  public void testCard_NoBody() {
+    selectBody(BODY_OPT_NONE);
+    open();
+
+    getView(R.id.card_root).check(matches(isDisplayed()));
+    getView(R.id.message_title).check(matches(withText(TITLE_TEXT_NORMAL)));
+    getView(R.id.image_view).check(matches(isDisplayed()));
+    getView(R.id.message_body).check(matches(not(isDisplayed())));
+    getView(R.id.primary_button).check(matches(withText(BUTTON_TEXT_NORMAL)));
+    getView(R.id.secondary_button).check(matches(withText(BUTTON_TEXT_CANCEL)));
+  }
+
+  @Test
+  public void testCard_ShortTitle() {
+    setTitle(TITLE_TEXT_SHORT);
+    open();
+
+    getView(R.id.card_root).check(matches(isDisplayed()));
+    getView(R.id.message_title).check(matches(withText(TITLE_TEXT_SHORT)));
+    getView(R.id.image_view).check(matches(isDisplayed()));
+    getView(R.id.message_body).check(matches(withText(BODY_TEXT_NORMAL)));
+    getView(R.id.primary_button).check(matches(withText(BUTTON_TEXT_NORMAL)));
+    getView(R.id.secondary_button).check(matches(withText(BUTTON_TEXT_CANCEL)));
+  }
+
+  @Test
+  public void testCard_ShortTitleNoBody() {
+    setTitle(TITLE_TEXT_SHORT);
+    selectBody(BODY_OPT_NONE);
+    open();
+
+    getView(R.id.card_root).check(matches(isDisplayed()));
+    getView(R.id.message_title).check(matches(withText(TITLE_TEXT_SHORT)));
+    getView(R.id.image_view).check(matches(isDisplayed()));
+    getView(R.id.message_body).check(matches(not(isDisplayed())));
+    getView(R.id.primary_button).check(matches(withText(BUTTON_TEXT_NORMAL)));
+    getView(R.id.secondary_button).check(matches(withText(BUTTON_TEXT_CANCEL)));
+  }
+
+  @Test
+  public void testCard_OneButton() {
+    setButton(BUTTON_TEXT_NONE, R.id.secondary_action_button_text);
+    open();
+
+    getView(R.id.card_root).check(matches(isDisplayed()));
+    getView(R.id.message_title).check(matches(withText(TITLE_TEXT_NORMAL)));
+    getView(R.id.image_view).check(matches(isDisplayed()));
+    getView(R.id.message_body).check(matches(withText(BODY_TEXT_NORMAL)));
+    getView(R.id.primary_button).check(matches(withText(BUTTON_TEXT_NORMAL)));
+    getView(R.id.secondary_button).check(matches(not(isDisplayed())));
+  }
+
+  @Test
+  public void testCard_TinyImage() {
+    setPortraitImageSize(50, 50);
+    open();
+
+    getView(R.id.card_root).check(matches(isDisplayed()));
+    getView(R.id.message_title).check(matches(withText(TITLE_TEXT_NORMAL)));
+    getView(R.id.image_view).check(matches(isDisplayed()));
+    getView(R.id.message_body).check(matches(withText(BODY_TEXT_NORMAL)));
+    getView(R.id.primary_button).check(matches(withText(BUTTON_TEXT_NORMAL)));
+    getView(R.id.secondary_button).check(matches(withText(BUTTON_TEXT_CANCEL)));
+  }
+
+  @Test
+  public void testCard_WideImage() {
+    setPortraitImageSize(600, 400);
+    open();
+
+    getView(R.id.card_root).check(matches(isDisplayed()));
+    getView(R.id.message_title).check(matches(withText(TITLE_TEXT_NORMAL)));
+    getView(R.id.image_view).check(matches(isDisplayed()));
+    getView(R.id.message_body).check(matches(withText(BODY_TEXT_NORMAL)));
+    getView(R.id.primary_button).check(matches(withText(BUTTON_TEXT_NORMAL)));
+    getView(R.id.secondary_button).check(matches(withText(BUTTON_TEXT_CANCEL)));
+  }
+
+  @Test
+  public void testCard_MissingLandscapeImage() {
+    setPortraitImageSize(600, 400);
+    setLandscapeImageSize(0, 0);
+    open();
+
+    getView(R.id.card_root).check(matches(isDisplayed()));
+    getView(R.id.message_title).check(matches(withText(TITLE_TEXT_NORMAL)));
+    getView(R.id.image_view).check(matches(isDisplayed()));
+    getView(R.id.message_body).check(matches(withText(BODY_TEXT_NORMAL)));
+    getView(R.id.primary_button).check(matches(withText(BUTTON_TEXT_NORMAL)));
+    getView(R.id.secondary_button).check(matches(withText(BUTTON_TEXT_CANCEL)));
+  }
+
+  @Test
+  public void testCard_MissingPortraitImage() {
+    setPortraitImageSize(0, 0);
+    setLandscapeImageSize(800, 800);
+    open();
+
+    getView(R.id.card_root).check(matches(isDisplayed()));
+    getView(R.id.message_title).check(matches(withText(TITLE_TEXT_NORMAL)));
+    getView(R.id.image_view).check(matches(isDisplayed()));
+    getView(R.id.message_body).check(matches(withText(BODY_TEXT_NORMAL)));
+    getView(R.id.primary_button).check(matches(withText(BUTTON_TEXT_NORMAL)));
+    getView(R.id.secondary_button).check(matches(withText(BUTTON_TEXT_CANCEL)));
+  }
+
+  @NonNull
+  private ViewInteraction getView(@IdRes int id) {
+    return onView(withId(id)).inRoot(rootMatcher);
+  }
+
+  private void selectBody(@IdRes int radioButtonId) {
+    onView(withId(radioButtonId)).perform(scrollTo()).perform(click());
+  }
+
+  private void setTitle(@StringRes int titleRes) {
+    if (titleRes >= 0) {
+      String title = mActivityRule.getActivity().getString(titleRes);
+      onView(withId(R.id.message_title)).perform(scrollTo()).perform(replaceText(title));
+    } else {
+      onView(withId(R.id.message_title)).perform(scrollTo()).perform(clearText());
+    }
+  }
+
+  private void setButton(@StringRes int buttonRes, @IdRes int textId) {
+    if (buttonRes >= 0) {
+      String buttonString = mActivityRule.getActivity().getString(buttonRes);
+      onView(withId(textId)).perform(scrollTo()).perform(replaceText(buttonString));
+    } else {
+      onView(withId(textId)).perform(scrollTo()).perform(clearText());
+    }
+  }
+
+  private void setPortraitImageSize(int w, int h) {
+    onView(withId(R.id.image_width)).perform(scrollTo()).perform(replaceText(Integer.toString(w)));
+    onView(withId(R.id.image_height)).perform(scrollTo()).perform(replaceText(Integer.toString(h)));
+  }
+
+  private void setLandscapeImageSize(int w, int h) {
+    onView(withId(R.id.landscape_image_width))
+        .perform(scrollTo())
+        .perform(replaceText(Integer.toString(w)));
+    onView(withId(R.id.landscape_image_height))
+        .perform(scrollTo())
+        .perform(replaceText(Integer.toString(h)));
+  }
+
+  private void open() {
+    onView(withId(R.id.card_fiam)).perform(scrollTo()).perform(click());
+    onView(withId(R.id.start)).perform(scrollTo()).perform(click());
+  }
+
+  private void close() {
+    onView(isRoot()).perform(ViewActions.pressBack());
+  }
+}
diff --git a/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/ImageTest.java b/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/ImageTest.java
index dd75f8882..c2c680e74 100644
--- a/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/ImageTest.java
+++ b/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/ImageTest.java
@@ -14,23 +14,23 @@
 
 package com.example.firebase.fiamui;
 
-import static android.support.test.espresso.Espresso.onView;
-import static android.support.test.espresso.action.ViewActions.click;
-import static android.support.test.espresso.action.ViewActions.scrollTo;
-import static android.support.test.espresso.assertion.ViewAssertions.matches;
-import static android.support.test.espresso.matcher.RootMatchers.withDecorView;
-import static android.support.test.espresso.matcher.ViewMatchers.isDisplayed;
-import static android.support.test.espresso.matcher.ViewMatchers.withId;
+import static androidx.test.espresso.Espresso.onView;
+import static androidx.test.espresso.action.ViewActions.click;
+import static androidx.test.espresso.action.ViewActions.scrollTo;
+import static androidx.test.espresso.assertion.ViewAssertions.matches;
+import static androidx.test.espresso.matcher.RootMatchers.withDecorView;
+import static androidx.test.espresso.matcher.ViewMatchers.isDisplayed;
+import static androidx.test.espresso.matcher.ViewMatchers.withId;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.not;
 
-import android.support.annotation.IdRes;
-import android.support.annotation.NonNull;
-import android.support.test.espresso.Root;
-import android.support.test.espresso.ViewInteraction;
-import android.support.test.filters.MediumTest;
-import android.support.test.rule.ActivityTestRule;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.annotation.IdRes;
+import androidx.annotation.NonNull;
+import androidx.test.espresso.Root;
+import androidx.test.espresso.ViewInteraction;
+import androidx.test.filters.MediumTest;
+import androidx.test.rule.ActivityTestRule;
+import androidx.test.runner.AndroidJUnit4;
 import org.hamcrest.Matcher;
 import org.junit.After;
 import org.junit.Before;
diff --git a/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/ModalTest.java b/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/ModalTest.java
index e8ff611e6..e2884ff86 100644
--- a/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/ModalTest.java
+++ b/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/ModalTest.java
@@ -14,16 +14,16 @@
 
 package com.example.firebase.fiamui;
 
-import static android.support.test.espresso.Espresso.onView;
-import static android.support.test.espresso.action.ViewActions.clearText;
-import static android.support.test.espresso.action.ViewActions.click;
-import static android.support.test.espresso.action.ViewActions.replaceText;
-import static android.support.test.espresso.action.ViewActions.scrollTo;
-import static android.support.test.espresso.assertion.ViewAssertions.matches;
-import static android.support.test.espresso.matcher.RootMatchers.withDecorView;
-import static android.support.test.espresso.matcher.ViewMatchers.isDisplayed;
-import static android.support.test.espresso.matcher.ViewMatchers.withId;
-import static android.support.test.espresso.matcher.ViewMatchers.withText;
+import static androidx.test.espresso.Espresso.onView;
+import static androidx.test.espresso.action.ViewActions.clearText;
+import static androidx.test.espresso.action.ViewActions.click;
+import static androidx.test.espresso.action.ViewActions.replaceText;
+import static androidx.test.espresso.action.ViewActions.scrollTo;
+import static androidx.test.espresso.assertion.ViewAssertions.matches;
+import static androidx.test.espresso.matcher.RootMatchers.withDecorView;
+import static androidx.test.espresso.matcher.ViewMatchers.isDisplayed;
+import static androidx.test.espresso.matcher.ViewMatchers.withId;
+import static androidx.test.espresso.matcher.ViewMatchers.withText;
 import static com.example.firebase.fiamui.TestConstants.BODY_OPT_LONG;
 import static com.example.firebase.fiamui.TestConstants.BODY_OPT_NONE;
 import static com.example.firebase.fiamui.TestConstants.BODY_OPT_NORMAL;
@@ -36,14 +36,14 @@
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.not;
 
-import android.support.annotation.IdRes;
-import android.support.annotation.NonNull;
-import android.support.annotation.StringRes;
-import android.support.test.espresso.Root;
-import android.support.test.espresso.ViewInteraction;
-import android.support.test.filters.MediumTest;
-import android.support.test.rule.ActivityTestRule;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.annotation.IdRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.StringRes;
+import androidx.test.espresso.Root;
+import androidx.test.espresso.ViewInteraction;
+import androidx.test.filters.MediumTest;
+import androidx.test.rule.ActivityTestRule;
+import androidx.test.runner.AndroidJUnit4;
 import org.hamcrest.Matcher;
 import org.junit.After;
 import org.junit.Before;
diff --git a/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/ScreenShotter.java b/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/ScreenShotter.java
index 88d3248fe..8e070029b 100644
--- a/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/ScreenShotter.java
+++ b/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/ScreenShotter.java
@@ -15,9 +15,9 @@
 package com.example.firebase.fiamui;
 
 import android.graphics.Bitmap;
-import android.support.test.runner.screenshot.ScreenCapture;
-import android.support.test.runner.screenshot.Screenshot;
 import android.util.Log;
+import androidx.test.runner.screenshot.ScreenCapture;
+import androidx.test.runner.screenshot.Screenshot;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
diff --git a/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/TestConstants.java b/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/TestConstants.java
index dc191e37b..90e16d6b5 100644
--- a/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/TestConstants.java
+++ b/fiamui-app/src/androidTest/java/com/example/firebase/fiamui/TestConstants.java
@@ -14,13 +14,14 @@
 
 package com.example.firebase.fiamui;
 
-import android.support.annotation.IdRes;
-import android.support.annotation.StringRes;
+import androidx.annotation.IdRes;
+import androidx.annotation.StringRes;
 
 public class TestConstants {
 
   // Title text IDs
   @StringRes public static final int TITLE_TEXT_NONE = -1;
+  @StringRes public static final int TITLE_TEXT_SHORT = R.string.short_message_title;
   @StringRes public static final int TITLE_TEXT_NORMAL = R.string.default_message_title;
 
   // Body text IDs
@@ -29,6 +30,7 @@
 
   // Button text IDs
   @StringRes public static final int BUTTON_TEXT_NORMAL = R.string.view_wishlist;
+  @StringRes public static final int BUTTON_TEXT_CANCEL = R.string.button_text_cancel;
   @StringRes public static final int BUTTON_TEXT_NONE = -1;
 
   // Body radio button IDs
diff --git a/fiamui-app/src/main/AndroidManifest.xml b/fiamui-app/src/main/AndroidManifest.xml
index 8a6adf3d7..82a655f86 100644
--- a/fiamui-app/src/main/AndroidManifest.xml
+++ b/fiamui-app/src/main/AndroidManifest.xml
@@ -16,8 +16,7 @@
 
     <activity
         android:name=".MainActivity"
-        android:windowSoftInputMode="stateHidden"
-        android:exported="true">
+        android:windowSoftInputMode="stateHidden" android:exported="false">
       <intent-filter>
         <action android:name="android.intent.action.MAIN"/>
         <category android:name="android.intent.category.DEFAULT" />
diff --git a/fiamui-app/src/main/java/com/example/firebase/fiamui/MainActivity.java b/fiamui-app/src/main/java/com/example/firebase/fiamui/MainActivity.java
index f0e3631f5..60bc5df1e 100644
--- a/fiamui-app/src/main/java/com/example/firebase/fiamui/MainActivity.java
+++ b/fiamui-app/src/main/java/com/example/firebase/fiamui/MainActivity.java
@@ -16,19 +16,20 @@
 
 import android.graphics.drawable.ColorDrawable;
 import android.os.Bundle;
-import android.support.annotation.StringRes;
-import android.support.design.widget.TextInputEditText;
-import android.support.v7.app.AppCompatActivity;
+import android.text.TextUtils;
 import android.view.View;
 import android.widget.Button;
 import android.widget.RadioButton;
+import androidx.annotation.Nullable;
+import androidx.annotation.StringRes;
+import androidx.appcompat.app.AppCompatActivity;
 import butterknife.BindView;
 import butterknife.ButterKnife;
 import butterknife.OnClick;
+import com.google.android.material.textfield.TextInputEditText;
 import com.google.firebase.analytics.FirebaseAnalytics;
 import com.google.firebase.inappmessaging.display.FirebaseInAppMessagingDisplay;
-import com.google.firebase.inappmessaging.model.InAppMessage;
-import com.google.firebase.inappmessaging.model.MessageType;
+import com.google.firebase.inappmessaging.model.*;
 import me.priyesh.chroma.ChromaDialog;
 import me.priyesh.chroma.ColorMode;
 import me.priyesh.chroma.ColorSelectListener;
@@ -46,6 +47,9 @@
   @BindView(R.id.image_fiam)
   RadioButton useImageFiam;
 
+  @BindView(R.id.card_fiam)
+  RadioButton useCardFiam;
+
   @BindView(R.id.long_body_text)
   RadioButton useLongBodyText;
 
@@ -64,12 +68,21 @@
   @BindView(R.id.image_height)
   TextInputEditText imageHeight;
 
+  @BindView(R.id.landscape_image_width)
+  TextInputEditText landscapeImageWidth;
+
+  @BindView(R.id.landscape_image_height)
+  TextInputEditText landscapeImageHeight;
+
   @BindView(R.id.action_button_text)
   TextInputEditText actionButtonText;
 
   @BindView(R.id.action_button_url)
   TextInputEditText actionButtonUrl;
 
+  @BindView(R.id.secondary_action_button_text)
+  TextInputEditText secondaryActionButtonText;
+
   @BindView(R.id.fiam_ttl)
   TextInputEditText fiamTTL;
 
@@ -126,71 +139,162 @@ public void onStartClick(View v) {
 
     String bodyText = getString(getSelectedBodyText());
 
-    String w = imageWidth.getText().toString();
-    String h = imageHeight.getText().toString();
+    String imageUrlString = makeImageUrl(imageWidth, imageHeight);
+    ImageData imageData =
+        imageUrlString != null ? ImageData.builder().setImageUrl(imageUrlString).build() : null;
 
-    String imageUrlString;
-    if ("0".equals(w) && "0".equals(h)) {
-      imageUrlString = null;
-    } else {
-      imageUrlString = "https://unsplash.it/" + w + "/" + h;
-    }
+    String landscapeUrlString = makeImageUrl(landscapeImageWidth, landscapeImageHeight);
+    ImageData landscapeImageData =
+        landscapeUrlString != null
+            ? ImageData.builder().setImageUrl(landscapeUrlString).build()
+            : null;
 
     String actionButtonTextString = actionButtonText.getText().toString();
     String actionButtonUrlString = actionButtonUrl.getText().toString();
+    String secondaryActionButtonTextString = secondaryActionButtonText.getText().toString();
 
-    InAppMessage.Builder builder = InAppMessage.builder();
+    CampaignMetadata campaignMetadata = new CampaignMetadata("test_campaign", "name", true);
 
-    if (!bodyText.equals("")) {
-      InAppMessage.Text body =
-          InAppMessage.Text.builder().setText(bodyText).setHexColor(bodyTextColorString).build();
-      builder = builder.setBody(body);
-    }
+    if (useImageFiam.isChecked()) {
+      ImageOnlyMessage.Builder builder = ImageOnlyMessage.builder();
+      Action action = Action.builder().setActionUrl(actionButtonUrlString).build();
 
-    if (!actionButtonTextString.equals("")) {
-      InAppMessage.Text buttonText =
-          InAppMessage.Text.builder()
-              .setHexColor(buttonTextColorString)
-              .setText(actionButtonTextString)
-              .build();
-      InAppMessage.Action action =
-          InAppMessage.Action.builder().setActionUrl(actionButtonUrlString).build();
-      com.google.firebase.inappmessaging.model.InAppMessage.Button actionButton =
-          com.google.firebase.inappmessaging.model.InAppMessage.Button.builder()
-              .setText(buttonText)
-              .setButtonHexColor(buttonBackgroundColorString)
+      ImageOnlyMessage message =
+          builder.setImageData(imageData).setAction(action).build(campaignMetadata);
+
+      FirebaseInAppMessagingDisplay.getInstance()
+          .testMessage(this, message, new NoOpDisplayCallbacks());
+    } else if (useBannerFiam.isChecked()) {
+      BannerMessage.Builder builder = BannerMessage.builder();
+      Text body = Text.builder().setText(bodyText).setHexColor(bodyTextColorString).build();
+      Action action = Action.builder().setActionUrl(actionButtonUrlString).build();
+      Text title =
+          Text.builder()
+              .setText(messageTitle.getText().toString())
+              .setHexColor(bodyTextColorString)
               .build();
-      builder = builder.setAction(action).setActionButton(actionButton);
-    }
 
-    InAppMessage.Text title =
-        InAppMessage.Text.builder()
-            .setHexColor(bodyTextColorString)
-            .setText(messageTitle.getText().toString())
-            .build();
-
-    builder =
-        builder
-            .setCampaignId("test_campaign")
-            .setBackgroundHexColor(bodyBackgroundColorString)
-            .setCampaignName("name")
-            .setIsTestMessage(true)
-            .setTitle(title);
-
-    if (imageUrlString != null) {
-      builder = builder.setImageUrl(imageUrlString);
-    }
+      BannerMessage message =
+          builder
+              .setBackgroundHexColor(bodyBackgroundColorString)
+              .setTitle(title)
+              .setBody(body)
+              .setImageData(imageData)
+              .setAction(action)
+              .build(campaignMetadata);
+
+      FirebaseInAppMessagingDisplay.getInstance()
+          .testMessage(this, message, new NoOpDisplayCallbacks());
+    } else if (useCardFiam.isChecked()) {
+      // Setup builder
+      CardMessage.Builder builder = CardMessage.builder();
+
+      // Main text
+      Text title =
+          Text.builder()
+              .setText(messageTitle.getText().toString())
+              .setHexColor(bodyTextColorString)
+              .build();
+      Text body = Text.builder().setText(bodyText).setHexColor(bodyTextColorString).build();
+
+      // Primary button text
+      Action primaryAction;
+      if (TextUtils.isEmpty(actionButtonTextString)) {
+        primaryAction = null;
+      } else {
+        Text primaryButtonText =
+            Text.builder()
+                .setText(actionButtonTextString)
+                .setHexColor(buttonTextColorString)
+                .build();
+        com.google.firebase.inappmessaging.model.Button primaryActionButton =
+            com.google.firebase.inappmessaging.model.Button.builder()
+                .setText(primaryButtonText)
+                .setButtonHexColor(buttonBackgroundColorString)
+                .build();
+        primaryAction =
+            Action.builder()
+                .setActionUrl(actionButtonUrlString)
+                .setButton(primaryActionButton)
+                .build();
+      }
+
+      // Secondary button text
+      Action secondaryAction;
+      if (TextUtils.isEmpty(secondaryActionButtonTextString)) {
+        secondaryAction = null;
+      } else {
+        Text secondaryButtonText =
+            Text.builder()
+                .setText(secondaryActionButtonTextString)
+                .setHexColor(buttonTextColorString)
+                .build();
+        com.google.firebase.inappmessaging.model.Button secondaryActionButton =
+            com.google.firebase.inappmessaging.model.Button.builder()
+                .setText(secondaryButtonText)
+                .setButtonHexColor(buttonBackgroundColorString)
+                .build();
+        secondaryAction =
+            Action.builder()
+                .setActionUrl(actionButtonUrlString)
+                .setButton(secondaryActionButton)
+                .build();
+      }
+
+      CardMessage message =
+          builder
+              .setBackgroundHexColor(bodyBackgroundColorString)
+              .setTitle(title)
+              .setBody(body)
+              .setPortraitImageData(imageData)
+              .setLandscapeImageData(landscapeImageData)
+              .setPrimaryAction(primaryAction)
+              .setSecondaryAction(secondaryAction)
+              .build(campaignMetadata);
+
+      FirebaseInAppMessagingDisplay.getInstance()
+          .testMessage(this, message, new NoOpDisplayCallbacks());
 
-    if (useImageFiam.isChecked()) {
-      builder.setMessageType(MessageType.IMAGE_ONLY);
-    } else if (useBannerFiam.isChecked()) {
-      builder.setMessageType(MessageType.BANNER);
     } else {
-      builder.setMessageType(MessageType.MODAL);
-    }
+      ModalMessage.Builder builder = ModalMessage.builder();
 
-    FirebaseInAppMessagingDisplay.getInstance()
-        .testMessage(this, builder.build(), new NoOpDisplayCallbacks());
+      Text title =
+          Text.builder()
+              .setText(messageTitle.getText().toString())
+              .setHexColor(bodyTextColorString)
+              .build();
+      Text body = Text.builder().setText(bodyText).setHexColor(bodyTextColorString).build();
+
+      Action modalAction;
+      if (TextUtils.isEmpty(actionButtonTextString)) {
+        modalAction = null;
+      } else {
+        Text buttonText =
+            Text.builder()
+                .setText(actionButtonTextString)
+                .setHexColor(buttonTextColorString)
+                .build();
+        com.google.firebase.inappmessaging.model.Button actionButton =
+            com.google.firebase.inappmessaging.model.Button.builder()
+                .setText(buttonText)
+                .setButtonHexColor(buttonBackgroundColorString)
+                .build();
+        modalAction =
+            Action.builder().setActionUrl(actionButtonUrlString).setButton(actionButton).build();
+      }
+
+      ModalMessage message =
+          builder
+              .setBackgroundHexColor(bodyBackgroundColorString)
+              .setTitle(title)
+              .setBody(body)
+              .setImageData(imageData)
+              .setAction(modalAction)
+              .build(campaignMetadata);
+
+      FirebaseInAppMessagingDisplay.getInstance()
+          .testMessage(this, message, new NoOpDisplayCallbacks());
+    }
   }
 
   @StringRes
@@ -215,6 +319,14 @@ private String getBackgroundColorString(View view) {
     return String.format("#%06X", (0xFFFFFF & getBackgroundColor(view)));
   }
 
+  @Nullable
+  private String makeImageUrl(TextInputEditText imageWidth, TextInputEditText imageHeight) {
+    String w = imageWidth.getText().toString();
+    String h = imageHeight.getText().toString();
+
+    return "0".equals(w) && "0".equals(h) ? null : "https://unsplash.it/" + w + "/" + h;
+  }
+
   private void bindColorPicker(View container, final View preview) {
     container.setOnClickListener(
         new View.OnClickListener() {
diff --git a/fiamui-app/src/main/java/com/example/firebase/fiamui/NoOpDisplayCallbacks.java b/fiamui-app/src/main/java/com/example/firebase/fiamui/NoOpDisplayCallbacks.java
index f8aae610f..4a5db4d3c 100644
--- a/fiamui-app/src/main/java/com/example/firebase/fiamui/NoOpDisplayCallbacks.java
+++ b/fiamui-app/src/main/java/com/example/firebase/fiamui/NoOpDisplayCallbacks.java
@@ -17,6 +17,7 @@
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks;
+import com.google.firebase.inappmessaging.model.Action;
 
 public class NoOpDisplayCallbacks implements FirebaseInAppMessagingDisplayCallbacks {
   @Override
@@ -29,13 +30,18 @@
     return new TaskCompletionSource<Void>().getTask();
   }
 
-  @Override
+  @Deprecated
   public Task<Void> messageClicked() {
     return new TaskCompletionSource<Void>().getTask();
   }
 
   @Override
-  public Task<Void> displayErrorEncountered(InAppMessagingErrorReason InAppMessagingErrorReason) {
+  public Task<Void> messageClicked(Action action) {
+    return new TaskCompletionSource<Void>().getTask();
+  }
+
+  @Override
+  public Task<Void> displayErrorEncountered(InAppMessagingErrorReason inAppMessagingErrorReason) {
     return new TaskCompletionSource<Void>().getTask();
   }
 }
diff --git a/fiamui-app/src/main/java/com/example/firebase/fiamui/SampleApplication.java b/fiamui-app/src/main/java/com/example/firebase/fiamui/SampleApplication.java
index b20fdbc27..e010872a9 100644
--- a/fiamui-app/src/main/java/com/example/firebase/fiamui/SampleApplication.java
+++ b/fiamui-app/src/main/java/com/example/firebase/fiamui/SampleApplication.java
@@ -14,7 +14,7 @@
 
 package com.example.firebase.fiamui;
 
-import android.support.multidex.MultiDexApplication;
+import androidx.multidex.MultiDexApplication;
 
 public class SampleApplication extends MultiDexApplication {
   @Override
diff --git a/fiamui-app/src/main/java/com/example/firebase/fiamui/TestActivity.java b/fiamui-app/src/main/java/com/example/firebase/fiamui/TestActivity.java
index 9d514e692..ca41ac570 100644
--- a/fiamui-app/src/main/java/com/example/firebase/fiamui/TestActivity.java
+++ b/fiamui-app/src/main/java/com/example/firebase/fiamui/TestActivity.java
@@ -15,7 +15,7 @@
 package com.example.firebase.fiamui;
 
 import android.os.Bundle;
-import android.support.v7.app.AppCompatActivity;
+import androidx.appcompat.app.AppCompatActivity;
 
 public class TestActivity extends AppCompatActivity {
   @Override
diff --git a/fiamui-app/src/main/res/layout/activity_main.xml b/fiamui-app/src/main/res/layout/activity_main.xml
index a36f82bc5..2acb390c8 100644
--- a/fiamui-app/src/main/res/layout/activity_main.xml
+++ b/fiamui-app/src/main/res/layout/activity_main.xml
@@ -1,300 +1,335 @@
 <?xml version="1.0" encoding="utf-8"?>
-<android.support.design.widget.CoordinatorLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
+<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     android:id="@+id/root"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
-    tools:context="com.example.firebase.fiamui.MainActivity"
-    >
+    tools:context="com.example.firebase.fiamui.MainActivity">
 
-  <ScrollView
-      android:layout_width="match_parent"
-      android:layout_height="match_parent"
-      >
-
-    <LinearLayout
+    <ScrollView
         android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:layout_marginBottom="16dp"
-        android:layout_marginLeft="24dp"
-        android:layout_marginRight="24dp"
-        android:layout_marginTop="16dp"
-        android:orientation="vertical"
-        android:paddingBottom="32dp"
-        >
-
-      <TextView
-          android:layout_width="wrap_content"
-          android:layout_height="wrap_content"
-          android:layout_gravity="center_horizontal"
-          android:text="@string/fiam_ui_demo"
-          style="@style/Base.TextAppearance.AppCompat.Headline"
-          />
-
-      <Button
-          android:id="@+id/start"
-          android:layout_width="wrap_content"
-          android:layout_height="wrap_content"
-          android:layout_gravity="center"
-          android:layout_margin="16dp"
-          android:text="@string/start"
-          style="@style/Widget.AppCompat.Button.Colored"
-          />
-
-      <TextView
-          android:layout_width="wrap_content"
-          android:layout_height="wrap_content"
-          android:layout_marginBottom="8dp"
-          android:text="@string/fiam_type"
-          style="@style/Base.TextAppearance.AppCompat.Subhead"
-          />
-
-      <RadioGroup
-          android:layout_width="wrap_content"
-          android:layout_height="wrap_content"
-          android:orientation="vertical"
-          >
-
-        <RadioButton
-            android:id="@+id/modal_fiam"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:checked="true"
-            android:text="@string/modal"
-            />
-
-        <RadioButton
-            android:id="@+id/banner_fiam"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="@string/banner"
-            />
-
-        <RadioButton
-            android:id="@+id/image_fiam"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="@string/image"
-            />
-      </RadioGroup>
-
-      <android.support.design.widget.TextInputLayout
-          android:layout_width="match_parent"
-          android:layout_height="wrap_content"
-          android:layout_marginTop="16dp"
-          >
-
-        <android.support.design.widget.TextInputEditText
-            android:id="@+id/message_title"
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:hint="@string/message_title"
-            android:text="@string/default_message_title"
-            />
-
-      </android.support.design.widget.TextInputLayout>
-
-      <TextView
-          android:layout_width="wrap_content"
-          android:layout_height="wrap_content"
-          android:layout_marginBottom="8dp"
-          android:layout_marginTop="16dp"
-          android:text="Use body text"
-          style="@style/Base.TextAppearance.AppCompat.Subhead"
-          />
-
-      <RadioGroup
-          android:layout_width="wrap_content"
-          android:layout_height="wrap_content"
-          android:orientation="vertical"
-          >
-
-        <RadioButton
-            android:id="@+id/normal_body_text"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:checked="true"
-            android:text="@string/regular_length"
-            />
-
-        <RadioButton
-            android:id="@+id/long_body_text"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="@string/long_length"
-            />
-
-        <RadioButton
-            android:id="@+id/no_body_text"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="@string/no_length"
-            />
-      </RadioGroup>
-
-      <LinearLayout
-          android:layout_width="match_parent"
-          android:layout_height="wrap_content"
-          android:orientation="horizontal"
-          android:layout_marginTop="16dp"
-          android:weightSum="2.0">
-
-        <android.support.design.widget.TextInputLayout
-            android:layout_width="0dp"
-            android:layout_height="wrap_content"
-            android:layout_weight="1.0">
-
-          <android.support.design.widget.TextInputEditText
-              android:id="@+id/image_width"
-              android:layout_width="match_parent"
-              android:layout_height="wrap_content"
-              android:inputType="number"
-              android:hint="Image Width"
-              android:text="800" />
-
-        </android.support.design.widget.TextInputLayout>
-
-        <android.support.design.widget.TextInputLayout
-            android:layout_width="0dp"
-            android:layout_height="wrap_content"
-            android:layout_weight="1.0">
-
-          <android.support.design.widget.TextInputEditText
-              android:id="@+id/image_height"
-              android:layout_width="match_parent"
-              android:layout_height="wrap_content"
-              android:inputType="number"
-              android:hint="Image Height"
-              android:text="800" />
-
-        </android.support.design.widget.TextInputLayout>
-
-      </LinearLayout>
-
-      <android.support.design.widget.TextInputLayout
-          android:layout_width="match_parent"
-          android:layout_height="wrap_content"
-          android:layout_marginTop="16dp"
-          >
-
-        <android.support.design.widget.TextInputEditText
-            android:id="@+id/action_button_text"
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:hint="@string/action_button_text"
-            android:text="@string/view_wishlist"
-            />
+        android:layout_height="match_parent">
 
-      </android.support.design.widget.TextInputLayout>
-
-      <android.support.design.widget.TextInputLayout
-          android:layout_width="match_parent"
-          android:layout_height="wrap_content"
-          android:layout_marginTop="16dp"
-          >
-
-        <android.support.design.widget.TextInputEditText
-            android:id="@+id/action_button_url"
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:hint="@string/action_button_url"
-            android:text="https://www.google.com"
-            />
-      </android.support.design.widget.TextInputLayout>
-
-      <android.support.design.widget.TextInputLayout
-          android:layout_width="match_parent"
-          android:layout_height="wrap_content"
-          android:layout_marginTop="16dp"
-          >
-
-        <android.support.design.widget.TextInputEditText
-            android:id="@+id/fiam_ttl"
+        <LinearLayout
             android:layout_width="match_parent"
             android:layout_height="wrap_content"
-            android:hint="Time in seconds to show fiam"
-            android:inputType="number"
-            android:text="30"
-            />
-
-      </android.support.design.widget.TextInputLayout>
-
-      <TextView
-          android:layout_width="match_parent"
-          android:layout_height="wrap_content"
-          android:text="Colors"
-          android:textSize="16sp"
-          android:textStyle="bold"
-          android:layout_marginBottom="16dp"
-          android:layout_marginTop="16dp" />
-
-      <FrameLayout
-          android:id="@+id/color_body_bg_container"
-          style="@style/AppTheme.ColorContainer">
-
-        <TextView
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="Body Background" />
-
-        <View
-            android:id="@+id/color_body_bg_preview"
-            android:background="#FAFAFA"
-            style="@style/AppTheme.ColorPreview" />
-
-      </FrameLayout>
-
-      <FrameLayout
-          android:id="@+id/color_body_text_container"
-          style="@style/AppTheme.ColorContainer">
-
-        <TextView
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="Body Text" />
-
-        <View
-            android:id="@+id/color_body_text_preview"
-            android:background="#000000"
-            style="@style/AppTheme.ColorPreview" />
-
-      </FrameLayout>
-
-      <FrameLayout
-          android:id="@+id/color_button_bg_container"
-          style="@style/AppTheme.ColorContainer">
-
-        <TextView
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="Button Background" />
-
-        <View
-            android:id="@+id/color_button_bg_preview"
-            android:background="@color/colorAccent"
-            style="@style/AppTheme.ColorPreview" />
-
-      </FrameLayout>
-
-      <FrameLayout
-          android:id="@+id/color_button_text_container"
-          style="@style/AppTheme.ColorContainer">
-
-        <TextView
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="Button Text" />
-
-        <View
-            android:id="@+id/color_button_text_preview"
-            android:background="#FFFFFF"
-            style="@style/AppTheme.ColorPreview" />
-
-      </FrameLayout>
-
-    </LinearLayout>
-
-  </ScrollView>
-
-</android.support.design.widget.CoordinatorLayout>
+            android:layout_marginLeft="24dp"
+            android:layout_marginTop="16dp"
+            android:layout_marginRight="24dp"
+            android:layout_marginBottom="16dp"
+            android:orientation="vertical"
+            android:paddingBottom="32dp">
+
+            <TextView
+                style="@style/Base.TextAppearance.AppCompat.Headline"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:text="@string/fiam_ui_demo" />
+
+            <Button
+                android:id="@+id/start"
+                style="@style/Widget.AppCompat.Button.Colored"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center"
+                android:layout_margin="16dp"
+                android:text="@string/start" />
+
+            <TextView
+                style="@style/Base.TextAppearance.AppCompat.Subhead"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginBottom="8dp"
+                android:text="@string/fiam_type" />
+
+            <RadioGroup
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:orientation="vertical">
+
+                <RadioButton
+                    android:id="@+id/modal_fiam"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:checked="true"
+                    android:text="@string/modal" />
+
+                <RadioButton
+                    android:id="@+id/banner_fiam"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="@string/banner" />
+
+                <RadioButton
+                    android:id="@+id/image_fiam"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="@string/image" />
+
+                <RadioButton
+                    android:id="@+id/card_fiam"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="@string/card" />
+            </RadioGroup>
+
+            <com.google.android.material.textfield.TextInputLayout
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="16dp">
+
+                <com.google.android.material.textfield.TextInputEditText
+                    android:id="@+id/message_title"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:hint="@string/message_title"
+                    android:text="@string/default_message_title" />
+
+            </com.google.android.material.textfield.TextInputLayout>
+
+            <TextView
+                style="@style/Base.TextAppearance.AppCompat.Subhead"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="16dp"
+                android:layout_marginBottom="8dp"
+                android:text="Use body text" />
+
+            <RadioGroup
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:orientation="vertical">
+
+                <RadioButton
+                    android:id="@+id/normal_body_text"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:checked="true"
+                    android:text="@string/regular_length" />
+
+                <RadioButton
+                    android:id="@+id/long_body_text"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="@string/long_length" />
+
+                <RadioButton
+                    android:id="@+id/no_body_text"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="@string/no_length" />
+            </RadioGroup>
+
+            <LinearLayout
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="16dp"
+                android:orientation="horizontal"
+                android:weightSum="2.0">
+
+                <com.google.android.material.textfield.TextInputLayout
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1.0">
+
+                    <com.google.android.material.textfield.TextInputEditText
+                        android:id="@+id/image_width"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:hint="Image Width"
+                        android:inputType="number"
+                        android:text="800" />
+
+                </com.google.android.material.textfield.TextInputLayout>
+
+                <com.google.android.material.textfield.TextInputLayout
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1.0">
+
+                    <com.google.android.material.textfield.TextInputEditText
+                        android:id="@+id/image_height"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:hint="Image Height"
+                        android:inputType="number"
+                        android:text="800" />
+
+                </com.google.android.material.textfield.TextInputLayout>
+
+            </LinearLayout>
+
+            <LinearLayout
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="16dp"
+                android:orientation="horizontal"
+                android:weightSum="2.0">
+
+                <com.google.android.material.textfield.TextInputLayout
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1.0">
+
+                    <com.google.android.material.textfield.TextInputEditText
+                        android:id="@+id/landscape_image_width"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:hint="Landscape Width (card)"
+                        android:inputType="number"
+                        android:text="800" />
+
+                </com.google.android.material.textfield.TextInputLayout>
+
+                <com.google.android.material.textfield.TextInputLayout
+                    android:layout_width="0dp"
+                    android:layout_height="wrap_content"
+                    android:layout_weight="1.0">
+
+                    <com.google.android.material.textfield.TextInputEditText
+                        android:id="@+id/landscape_image_height"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:hint="Landscape Height (card)"
+                        android:inputType="number"
+                        android:text="800" />
+
+                </com.google.android.material.textfield.TextInputLayout>
+
+            </LinearLayout>
+
+            <com.google.android.material.textfield.TextInputLayout
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="16dp">
+
+                <com.google.android.material.textfield.TextInputEditText
+                    android:id="@+id/action_button_text"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:hint="@string/action_button_text"
+                    android:text="@string/view_wishlist" />
+
+            </com.google.android.material.textfield.TextInputLayout>
+
+            <com.google.android.material.textfield.TextInputLayout
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="16dp">
+
+                <com.google.android.material.textfield.TextInputEditText
+                    android:id="@+id/action_button_url"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:hint="@string/action_button_url"
+                    android:text="https://www.google.com" />
+            </com.google.android.material.textfield.TextInputLayout>
+
+            <com.google.android.material.textfield.TextInputLayout
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="16dp">
+
+                <com.google.android.material.textfield.TextInputEditText
+                    android:id="@+id/secondary_action_button_text"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:hint="@string/secondary_action_button_text"
+                    android:text="@string/view_wishlist" />
+
+            </com.google.android.material.textfield.TextInputLayout>
+
+            <com.google.android.material.textfield.TextInputLayout
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="16dp">
+
+                <com.google.android.material.textfield.TextInputEditText
+                    android:id="@+id/fiam_ttl"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:hint="Time in seconds to show fiam"
+                    android:inputType="number"
+                    android:text="30" />
+
+            </com.google.android.material.textfield.TextInputLayout>
+
+            <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="16dp"
+                android:layout_marginBottom="16dp"
+                android:text="Colors"
+                android:textSize="16sp"
+                android:textStyle="bold" />
+
+            <FrameLayout
+                android:id="@+id/color_body_bg_container"
+                style="@style/AppTheme.ColorContainer">
+
+                <TextView
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="Body Background" />
+
+                <View
+                    android:id="@+id/color_body_bg_preview"
+                    style="@style/AppTheme.ColorPreview"
+                    android:background="#FAFAFA" />
+
+            </FrameLayout>
+
+            <FrameLayout
+                android:id="@+id/color_body_text_container"
+                style="@style/AppTheme.ColorContainer">
+
+                <TextView
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="Body Text" />
+
+                <View
+                    android:id="@+id/color_body_text_preview"
+                    style="@style/AppTheme.ColorPreview"
+                    android:background="#000000" />
+
+            </FrameLayout>
+
+            <FrameLayout
+                android:id="@+id/color_button_bg_container"
+                style="@style/AppTheme.ColorContainer">
+
+                <TextView
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="Button Background" />
+
+                <View
+                    android:id="@+id/color_button_bg_preview"
+                    style="@style/AppTheme.ColorPreview"
+                    android:background="@color/colorAccent" />
+
+            </FrameLayout>
+
+            <FrameLayout
+                android:id="@+id/color_button_text_container"
+                style="@style/AppTheme.ColorContainer">
+
+                <TextView
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="Button Text" />
+
+                <View
+                    android:id="@+id/color_button_text_preview"
+                    style="@style/AppTheme.ColorPreview"
+                    android:background="#0000FF" />
+
+            </FrameLayout>
+
+        </LinearLayout>
+
+    </ScrollView>
+
+</androidx.coordinatorlayout.widget.CoordinatorLayout>
diff --git a/fiamui-app/src/main/res/values/google-services.xml b/fiamui-app/src/main/res/values/google-services.xml
index 07c6ccab6..1d14c18fe 100644
--- a/fiamui-app/src/main/res/values/google-services.xml
+++ b/fiamui-app/src/main/res/values/google-services.xml
@@ -2,5 +2,5 @@
 <resources>
     <string name="google_api_key" translatable="false">ABCDIAMAKEY</string>
     <string name="google_app_id" translatable="false">1:123456:android:abcd123</string>
-    <string name="project_id" translatable="false">fiamui-demo</string>
+    <string name="project_id" translatable="false">PROJECT-ABCD</string>
 </resources>
diff --git a/fiamui-app/src/main/res/values/strings.xml b/fiamui-app/src/main/res/values/strings.xml
index 85eec4a68..d5a7a5f67 100644
--- a/fiamui-app/src/main/res/values/strings.xml
+++ b/fiamui-app/src/main/res/values/strings.xml
@@ -6,6 +6,7 @@
   <string name="no_length">No Body</string>
   <string name="image_url">Image url</string>
   <string name="action_button_text">Action button text</string>
+  <string name="secondary_action_button_text">Secondary Action button text</string>
   <string name="action_button_url">Action button url</string>
   <string name="fiam_ui_demo">FIAM UI Demo</string>
   <string name="fiam_type">Fiam type</string>
@@ -13,6 +14,7 @@
   <string name="modal">Modal</string>
   <string name="banner">Banner</string>
   <string name="image">Image</string>
+  <string name="card">Card</string>
   <string name="default_image_url">https://unsplash.it/800/800</string>
   <string name="body_text_long">Lorem ipsum dolor sit amet, consectetur adipiscing elit.
     Aliquam at ipsum augue. In et dui at justo scelerisque porta quis id arcu. Nam aliquam dolor
@@ -26,8 +28,10 @@
     Donec quis nulla et turpis mattis posuere</string>
   <string name="body_text_normal">We noticed that some of your wishlist items went on sale recently. Take a look!</string>
   <string name="no_body_text"></string>
+  <string name="short_message_title">Hi thair</string>
   <string name="default_message_title">Your wishlist items are on sale!</string>
   <string name="view_wishlist">Lorem Ipsum</string>
+  <string name="button_text_cancel">Cancel</string>
   <string name="test_activity_from_where_fiam_launches">Test activity from where fiam launches</string>
   <string name="color1">#00FF00</string>
   <string name="colo2">#000000</string>
diff --git a/firebase-abt/api.txt b/firebase-abt/api.txt
new file mode 100644
index 000000000..d802177e2
--- /dev/null
+++ b/firebase-abt/api.txt
@@ -0,0 +1 @@
+// Signature format: 2.0
diff --git a/firebase-abt/firebase-abt.gradle b/firebase-abt/firebase-abt.gradle
new file mode 100644
index 000000000..ef8062aa6
--- /dev/null
+++ b/firebase-abt/firebase-abt.gradle
@@ -0,0 +1,97 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+plugins {
+    id 'firebase-library'
+    id 'com.google.protobuf'
+}
+
+firebaseLibrary {
+    testLab.enabled = false
+    publishSources = true
+}
+
+// TODO(issue/568): Remove this once legacy logic is removed from Remote Config.
+protobuf {
+    protoc {
+        artifact = 'com.google.protobuf:protoc:3.4.0'
+    }
+    plugins {
+        javalite {
+            artifact = 'com.google.protobuf:protoc-gen-javalite:3.0.0'
+        }
+    }
+    generateProtoTasks {
+        all().each { task ->
+            task.builtins {
+                remove java
+            }
+            task.plugins {
+                javalite {}
+            }
+        }
+    }
+}
+
+android {
+
+    lintOptions {
+        abortOnError false
+    }
+    sourceSets {
+        main {
+            proto {
+                srcDir 'src/proto'
+            }
+
+	    resources {
+	        srcDir 'src/proto/com/google/protos'
+	    }
+        }
+    }
+
+    compileSdkVersion project.targetSdkVersion
+    defaultConfig {
+        minSdkVersion project.minSdkVersion
+        targetSdkVersion project.targetSdkVersion
+        versionName version
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+    }
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+    testOptions {
+        unitTests {
+            includeAndroidResources = true
+        }
+    }
+}
+
+dependencies {
+    implementation project(':firebase-common')
+    implementation ('com.google.firebase:firebase-measurement-connector:18.0.0') {
+        exclude group: "com.google.firebase", module: "firebase-common"
+    }
+    implementation 'com.google.android.gms:play-services-basement:17.0.0'
+    implementation 'com.google.protobuf:protobuf-lite:3.0.1'
+    testImplementation 'org.mockito:mockito-core:2.25.0'
+    testImplementation 'com.google.truth:truth:0.44'
+    testImplementation 'junit:junit:4.13-beta-2'
+    testImplementation 'androidx.test:runner:1.2.0'
+    testImplementation 'org.robolectric:robolectric:4.2'
+    testImplementation 'io.grpc:grpc-testing:1.12.0'
+    testImplementation 'androidx.test.espresso:espresso-core:3.2.0'
+
+}
diff --git a/firebase-abt/gradle.properties b/firebase-abt/gradle.properties
new file mode 100644
index 000000000..fd3ef991e
--- /dev/null
+++ b/firebase-abt/gradle.properties
@@ -0,0 +1,2 @@
+version=19.0.1
+latestReleasedVersion=19.0.0
diff --git a/firebase-abt/src/main/AndroidManifest.xml b/firebase-abt/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..803d6a25c
--- /dev/null
+++ b/firebase-abt/src/main/AndroidManifest.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.firebase.abt">
+  <!--Although the *SdkVersion is captured in gradle build files, this is required for non gradle builds-->
+  <!--<uses-sdk android:minSdkVersion="14"/>-->
+  <application>
+    <service android:name="com.google.firebase.components.ComponentDiscoveryService">
+      <meta-data
+          android:name="com.google.firebase.components:com.google.firebase.abt.component.AbtRegistrar"
+          android:value="com.google.firebase.components.ComponentRegistrar"/>
+    </service>
+  </application>
+</manifest>
diff --git a/firebase-abt/src/main/java/com/google/firebase/abt/AbtException.java b/firebase-abt/src/main/java/com/google/firebase/abt/AbtException.java
new file mode 100644
index 000000000..2bfb45719
--- /dev/null
+++ b/firebase-abt/src/main/java/com/google/firebase/abt/AbtException.java
@@ -0,0 +1,34 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.abt;
+
+/**
+ * An exception thrown when there's an issue with a call to the {@link
+ * com.google.firebase.abt.FirebaseABTesting} API.
+ *
+ * @author Miraziz Yusupov
+ */
+public class AbtException extends Exception {
+
+  /** Creates an ABT exception with the given message. */
+  public AbtException(String message) {
+    super(message);
+  }
+
+  /** Creates an ABT exception with the given message and cause. */
+  public AbtException(String message, Exception cause) {
+    super(message, cause);
+  }
+}
diff --git a/firebase-abt/src/main/java/com/google/firebase/abt/AbtExperimentInfo.java b/firebase-abt/src/main/java/com/google/firebase/abt/AbtExperimentInfo.java
new file mode 100644
index 000000000..263f8a1b3
--- /dev/null
+++ b/firebase-abt/src/main/java/com/google/firebase/abt/AbtExperimentInfo.java
@@ -0,0 +1,252 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.abt;
+
+import androidx.annotation.VisibleForTesting;
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+
+/**
+ * A set of values describing an ABT experiment. The values are sent to the Analytics SDK for
+ * tracking when an experiment is applied on an App instance.
+ *
+ * <p>The experiment info is expected to be in a {@code {@link Map}<String, String>} format. All
+ * such maps must contain all the keys in {@link #ALL_REQUIRED_KEYS}; if a key is missing, an {@link
+ * AbtException} will be thrown. Any keys not defined in {@link #ALL_REQUIRED_KEYS} will be ignored.
+ *
+ * <p>Changes in the values returned by the ABT server and client SDKs must be reflected here
+ *
+ * @author Miraziz Yusupov
+ */
+public class AbtExperimentInfo {
+
+  /**
+   * The experiment id key.
+   *
+   * <p>An experiment id is unique within a Firebase project and is assigned by the ABT service.
+   */
+  @VisibleForTesting static final String EXPERIMENT_ID_KEY = "experimentId";
+
+  /**
+   * The variant id key.
+   *
+   * <p>A variant id determines which variant of the experiment an App instance belongs to and is
+   * assigned by the ABT service.
+   */
+  @VisibleForTesting static final String VARIANT_ID_KEY = "variantId";
+  /**
+   * The trigger event key.
+   *
+   * <p>The ABT server does not pass this key if the value is empty, so it is optional.
+   *
+   * <p>The occurrence of a trigger event activates the experiment for an App instance.
+   */
+  @VisibleForTesting static final String TRIGGER_EVENT_KEY = "triggerEvent";
+
+  /**
+   * The experiment start time key.
+   *
+   * <p>The experiment start time is the point in time when the experiment was started in the
+   * Firebase console. The start time must be in an ISO 8601 compliant format.
+   */
+  @VisibleForTesting static final String EXPERIMENT_START_TIME_KEY = "experimentStartTime";
+
+  /**
+   * The trigger timeout key.
+   *
+   * <p>A trigger timeout defines how long an experiment can run in an App instance without being
+   * triggered. The timeout must be in milliseconds and convertible into a {@code long}.
+   */
+  @VisibleForTesting static final String TRIGGER_TIMEOUT_KEY = "triggerTimeoutMillis";
+
+  /**
+   * The time to live key.
+   *
+   * <p>A time to live defines how long an experiment can run in an App instance. The time must be
+   * in milliseconds and convertible into a {@code long}.
+   */
+  @VisibleForTesting static final String TIME_TO_LIVE_KEY = "timeToLiveMillis";
+
+  /** The set of all keys required by the ABT SDK to define an experiment. */
+  private static final String[] ALL_REQUIRED_KEYS = {
+    EXPERIMENT_ID_KEY,
+    EXPERIMENT_START_TIME_KEY,
+    TIME_TO_LIVE_KEY,
+    TRIGGER_TIMEOUT_KEY,
+    VARIANT_ID_KEY,
+  };
+
+  /**
+   * The String format of a protobuf Timestamp; the format is ISO 8601 compliant.
+   *
+   * <p>The protobuf Timestamp field gets converted to an ISO 8601 string when returned as JSON. For
+   * example, the Firebase Remote Config backend sends experiment start time as a Timestamp field,
+   * which gets converted to an ISO 8601 string when sent as JSON.
+   */
+  @VisibleForTesting
+  static final DateFormat protoTimestampStringParser =
+      new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.US);
+
+  /** The experiment id as defined by the ABT backend. */
+  private final String experimentId;
+  /** The id of the variant of this experiment the current App instance has been assigned to. */
+  private final String variantId;
+  /** The name of the event that will trigger the activation of this experiment. */
+  private final String triggerEventName;
+  /** The start time of this experiment. */
+  private final Date experimentStartTime;
+  /** The amount of time, in milliseconds, before the trigger for this experiment expires. */
+  private final long triggerTimeoutInMillis;
+  /** The amount of time, in milliseconds, before the experiment expires for this App instance. */
+  private final long timeToLiveInMillis;
+
+  /** Creates an instance of {@link AbtExperimentInfo} with all the required keys. */
+  @VisibleForTesting
+  AbtExperimentInfo(
+      String experimentId,
+      String variantId,
+      String triggerEventName,
+      Date experimentStartTime,
+      long triggerTimeoutInMillis,
+      long timeToLiveInMillis) {
+
+    this.experimentId = experimentId;
+    this.variantId = variantId;
+    this.triggerEventName = triggerEventName;
+    this.experimentStartTime = experimentStartTime;
+    this.triggerTimeoutInMillis = triggerTimeoutInMillis;
+    this.timeToLiveInMillis = timeToLiveInMillis;
+  }
+
+  /**
+   * Converts a map of strings containing an ABT experiment's tracking information into an instance
+   * of {@link AbtExperimentInfo}.
+   *
+   * @param experimentInfoMap A {@link Map} that contains all the keys specified in {@link
+   *     #ALL_REQUIRED_KEYS}. The values of each key must be convertible to the appropriate type,
+   *     e.g., the value for {@link #EXPERIMENT_START_TIME_KEY} must be an ISO 8601 Date string.
+   * @return An {@link AbtExperimentInfo} with the values of the experiment in {@code
+   *     experimentInfoMap}.
+   * @throws AbtException If one of the keys is missing, or any of the values cannot be converted to
+   *     their appropriate type.
+   */
+  static AbtExperimentInfo fromMap(Map<String, String> experimentInfoMap) throws AbtException {
+
+    validateExperimentInfoMap(experimentInfoMap);
+
+    try {
+      Date experimentStartTime =
+          protoTimestampStringParser.parse(experimentInfoMap.get(EXPERIMENT_START_TIME_KEY));
+      long triggerTimeoutInMillis = Long.parseLong(experimentInfoMap.get(TRIGGER_TIMEOUT_KEY));
+      long timeToLiveInMillis = Long.parseLong(experimentInfoMap.get(TIME_TO_LIVE_KEY));
+
+      return new AbtExperimentInfo(
+          experimentInfoMap.get(EXPERIMENT_ID_KEY),
+          experimentInfoMap.get(VARIANT_ID_KEY),
+          experimentInfoMap.containsKey(TRIGGER_EVENT_KEY)
+              ? experimentInfoMap.get(TRIGGER_EVENT_KEY)
+              : "",
+          experimentStartTime,
+          triggerTimeoutInMillis,
+          timeToLiveInMillis);
+    } catch (ParseException e) {
+      throw new AbtException(
+          "Could not process experiment: parsing experiment start time failed.", e);
+    } catch (NumberFormatException e) {
+      throw new AbtException(
+          "Could not process experiment: one of the durations could not be converted into a long.",
+          e);
+    }
+  }
+
+  /** Returns the id of this experiment. */
+  String getExperimentId() {
+    return experimentId;
+  }
+
+  /** Returns the id of the variant this App instance got assigned to. */
+  String getVariantId() {
+    return variantId;
+  }
+
+  /** Returns the name of the event that will trigger the activation of this experiment. */
+  String getTriggerEventName() {
+    return triggerEventName;
+  }
+
+  /** Returns the time the experiment was started, in millis since epoch. */
+  long getStartTimeInMillisSinceEpoch() {
+    return experimentStartTime.getTime();
+  }
+
+  /** Returns the amount of time before the trigger event expires for this experiment. */
+  long getTriggerTimeoutInMillis() {
+    return triggerTimeoutInMillis;
+  }
+
+  /** Returns the amount of time before the experiment expires in this App instance. */
+  long getTimeToLiveInMillis() {
+    return timeToLiveInMillis;
+  }
+
+  /**
+   * Verifies that {@code experimentInfoMap} contains all the keys in {@link #ALL_REQUIRED_KEYS}.
+   *
+   * @throws AbtException If {@code experimentInfoMap} is missing a key.
+   */
+  private static void validateExperimentInfoMap(Map<String, String> experimentInfoMap)
+      throws AbtException {
+
+    List<String> missingKeys = new ArrayList<>();
+    for (String key : ALL_REQUIRED_KEYS) {
+      if (!experimentInfoMap.containsKey(key)) {
+        missingKeys.add(key);
+      }
+    }
+
+    if (!missingKeys.isEmpty()) {
+      throw new AbtException(
+          String.format(
+              "The following keys are missing from the experiment info map: %s", missingKeys));
+    }
+  }
+
+  /**
+   * Used for testing {@code FirebaseABTesting#replaceAllExperiments(List)} without leaking the
+   * implementation details of this class.
+   */
+  @VisibleForTesting
+  Map<String, String> toStringMap() {
+
+    Map<String, String> experimentInfoMap = new HashMap<>();
+
+    experimentInfoMap.put(EXPERIMENT_ID_KEY, experimentId);
+    experimentInfoMap.put(VARIANT_ID_KEY, variantId);
+    experimentInfoMap.put(TRIGGER_EVENT_KEY, triggerEventName);
+    experimentInfoMap.put(
+        EXPERIMENT_START_TIME_KEY, protoTimestampStringParser.format(experimentStartTime));
+    experimentInfoMap.put(TRIGGER_TIMEOUT_KEY, Long.toString(triggerTimeoutInMillis));
+    experimentInfoMap.put(TIME_TO_LIVE_KEY, Long.toString(timeToLiveInMillis));
+
+    return experimentInfoMap;
+  }
+}
diff --git a/firebase-abt/src/main/java/com/google/firebase/abt/FirebaseABTesting.java b/firebase-abt/src/main/java/com/google/firebase/abt/FirebaseABTesting.java
new file mode 100644
index 000000000..96f7989a5
--- /dev/null
+++ b/firebase-abt/src/main/java/com/google/firebase/abt/FirebaseABTesting.java
@@ -0,0 +1,329 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.abt;
+
+import static com.google.firebase.abt.FirebaseABTesting.OriginService.REMOTE_CONFIG;
+
+import android.content.Context;
+import android.text.TextUtils;
+import androidx.annotation.Nullable;
+import androidx.annotation.StringDef;
+import androidx.annotation.VisibleForTesting;
+import androidx.annotation.WorkerThread;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.analytics.connector.AnalyticsConnector.ConditionalUserProperty;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Deque;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Manages Firebase A/B Testing Experiments.
+ *
+ * <p>To register an ABT experiment in an App, the experiment's information needs to be sent to the
+ * Google Analytics for Firebase SDK. To simplify those interactions with Analytics,
+ * FirebaseABTesting's methods provide a simple interface for managing ABT experiments.
+ *
+ * <p>An instance of this class handles all experiments for a specific origin (an impact service
+ * such as Firebase Remote Config) in a specific App.
+ *
+ * <p>The clients of this class are first party teams that use ABT experiments in their SDKs.
+ *
+ * @author Miraziz Yusupov
+ */
+public class FirebaseABTesting {
+
+  @VisibleForTesting static final String ABT_PREFERENCES = "com.google.firebase.abt";
+
+  @VisibleForTesting
+  static final String ORIGIN_LAST_KNOWN_START_TIME_KEY_FORMAT = "%s_lastKnownExperimentStartTime";
+
+  /** The App's Firebase Analytics client. */
+  private final AnalyticsConnector analyticsConnector;
+
+  /** The name of an ABT client. */
+  private final String originService;
+
+  /**
+   * Select keys of fields in the experiment descriptions returned from the Firebase Remote Config
+   * server.
+   */
+  @StringDef({REMOTE_CONFIG})
+  @Retention(RetentionPolicy.SOURCE)
+  public @interface OriginService {
+    /** Must match the origin code in Google Analytics for Firebase. */
+    String REMOTE_CONFIG = "frc";
+  }
+
+  /**
+   * Maximum number of conditional user properties allowed for the origin service. Null until
+   * retrieved from Analytics.
+   */
+  @Nullable private Integer maxUserProperties;
+
+  /**
+   * Creates an instance of the ABT class for the specified App and origin service.
+   *
+   * @param unusedAppContext {@link Context} of an App.
+   * @param originService the name of an origin service.
+   */
+  public FirebaseABTesting(
+      Context unusedAppContext,
+      AnalyticsConnector analyticsConnector,
+      @OriginService String originService) {
+    this.analyticsConnector = analyticsConnector;
+    this.originService = originService;
+
+    this.maxUserProperties = null;
+  }
+
+  /**
+   * Replaces the origin's list of experiments in the App with the experiments defined in {@code
+   * replacementExperiments}, adhering to a "discard oldest" overflow policy.
+   *
+   * <p>Note: This is a blocking call and should only be called from a worker thread.
+   *
+   * <p>The maps of {@code replacementExperiments} must be in the format defined by the ABT service.
+   * The current SDK's format for experiment maps is specified in {@link
+   * AbtExperimentInfo#fromMap(Map)}.
+   *
+   * @param replacementExperiments list of experiment info {@link Map}s, where each map contains the
+   *     identifiers and metadata of a distinct experiment that is currently running. If the value
+   *     is null, this method is a no-op.
+   * @throws IllegalArgumentException If {@code replacementExperiments} is null.
+   * @throws AbtException If there is no Analytics SDK or if any experiment map in {@code
+   *     replacementExperiments} could not be parsed.
+   */
+  @WorkerThread
+  public void replaceAllExperiments(List<Map<String, String>> replacementExperiments)
+      throws AbtException {
+
+    throwAbtExceptionIfAnalyticsIsNull();
+
+    if (replacementExperiments == null) {
+      throw new IllegalArgumentException("The replacementExperiments list is null.");
+    }
+
+    replaceAllExperimentsWith(convertMapsToExperimentInfos(replacementExperiments));
+  }
+
+  /**
+   * Clears the origin service's list of experiments in the App.
+   *
+   * <p>Note: This is a blocking call and therefore should be called from a worker thread.
+   *
+   * @throws AbtException If there is no Analytics SDK.
+   */
+  @WorkerThread
+  public void removeAllExperiments() throws AbtException {
+
+    throwAbtExceptionIfAnalyticsIsNull();
+
+    removeExperiments(getAllExperimentsInAnalytics());
+  }
+
+  /**
+   * Replaces the origin's list of experiments in the App with {@code replacementExperiments}. If
+   * {@code replacementExperiments} is an empty list, then all the origin's experiments in the App
+   * are removed.
+   *
+   * <p>The replacement is done as follows:
+   *
+   * <ol>
+   *   <li>Any experiment in the origin's list that is not in {@code replacementExperiments} is
+   *       removed.
+   *   <li>Any experiment in {@code replacementExperiments} that is not already in the origin's list
+   *       is added. If the origin's list has the maximum number of experiments allowed and an
+   *       experiment needs to be added, the oldest experiment in the list is removed.
+   * </ol>
+   *
+   * <p>Experiments in {@code replacementExperiments} that have previously been discarded will be
+   * ignored. An experiment is assumed to be previously discarded if it's start time is before the
+   * last start time seen by this instance and it does not exist in the origin's list.
+   *
+   * @param replacementExperiments list of {@link AbtExperimentInfo}s, each containing the
+   *     identifiers and metadata of a distinct experiment that is currently running. Must contain
+   *     at least one valid experiment.
+   * @throws AbtException If there is no Analytics SDK.
+   */
+  private void replaceAllExperimentsWith(List<AbtExperimentInfo> replacementExperiments)
+      throws AbtException {
+
+    if (replacementExperiments.isEmpty()) {
+      removeAllExperiments();
+      return;
+    }
+
+    Set<String> replacementExperimentIds = new HashSet<>();
+    for (AbtExperimentInfo replacementExperiment : replacementExperiments) {
+      replacementExperimentIds.add(replacementExperiment.getExperimentId());
+    }
+
+    List<ConditionalUserProperty> experimentsInAnalytics = getAllExperimentsInAnalytics();
+    Set<String> idsOfExperimentsInAnalytics = new HashSet<>();
+    for (ConditionalUserProperty experimentInAnalytics : experimentsInAnalytics) {
+      idsOfExperimentsInAnalytics.add(experimentInAnalytics.name);
+    }
+
+    List<ConditionalUserProperty> experimentsToRemove =
+        getExperimentsToRemove(experimentsInAnalytics, replacementExperimentIds);
+    removeExperiments(experimentsToRemove);
+
+    List<AbtExperimentInfo> experimentsToAdd =
+        getExperimentsToAdd(replacementExperiments, idsOfExperimentsInAnalytics);
+    addExperiments(experimentsToAdd);
+  }
+
+  /** Returns this origin's experiments in Analytics that are no longer assigned to this App. */
+  private ArrayList<ConditionalUserProperty> getExperimentsToRemove(
+      List<ConditionalUserProperty> experimentsInAnalytics, Set<String> replacementExperimentIds) {
+
+    ArrayList<ConditionalUserProperty> experimentsToRemove = new ArrayList<>();
+    for (ConditionalUserProperty experimentInAnalytics : experimentsInAnalytics) {
+      if (!replacementExperimentIds.contains(experimentInAnalytics.name)) {
+        experimentsToRemove.add(experimentInAnalytics);
+      }
+    }
+    return experimentsToRemove;
+  }
+
+  /**
+   * Returns the new experiments in the specified {@link AbtExperimentInfo}s that need to be added
+   * to this origin's list of experiments in Analytics.
+   */
+  private ArrayList<AbtExperimentInfo> getExperimentsToAdd(
+      List<AbtExperimentInfo> replacementExperiments, Set<String> idsOfExperimentsInAnalytics) {
+
+    ArrayList<AbtExperimentInfo> experimentsToAdd = new ArrayList<>();
+    for (AbtExperimentInfo replacementExperiment : replacementExperiments) {
+      if (!idsOfExperimentsInAnalytics.contains(replacementExperiment.getExperimentId())) {
+        experimentsToAdd.add(replacementExperiment);
+      }
+    }
+    return experimentsToAdd;
+  }
+
+  /** Adds the given experiments to the origin's list in Analytics. */
+  private void addExperiments(List<AbtExperimentInfo> experimentsToAdd) {
+
+    Deque<ConditionalUserProperty> dequeOfExperimentsInAnalytics =
+        new ArrayDeque<>(getAllExperimentsInAnalytics());
+
+    int fetchedMaxUserProperties = getMaxUserPropertiesInAnalytics();
+
+    for (AbtExperimentInfo experimentToAdd : experimentsToAdd) {
+      while (dequeOfExperimentsInAnalytics.size() >= fetchedMaxUserProperties) {
+        removeExperimentFromAnalytics(dequeOfExperimentsInAnalytics.pollFirst().name);
+      }
+
+      ConditionalUserProperty experiment = createConditionalUserProperty(experimentToAdd);
+      addExperimentToAnalytics(experiment);
+      dequeOfExperimentsInAnalytics.offer(experiment);
+    }
+  }
+
+  private void removeExperiments(Collection<ConditionalUserProperty> experiments) {
+    for (ConditionalUserProperty experiment : experiments) {
+      removeExperimentFromAnalytics(experiment.name);
+    }
+  }
+  /**
+   * Returns the {@link ConditionalUserProperty} created from the specified {@link
+   * AbtExperimentInfo}.
+   */
+  private ConditionalUserProperty createConditionalUserProperty(AbtExperimentInfo experimentInfo) {
+
+    ConditionalUserProperty conditionalUserProperty = new ConditionalUserProperty();
+
+    conditionalUserProperty.origin = originService;
+    conditionalUserProperty.creationTimestamp = experimentInfo.getStartTimeInMillisSinceEpoch();
+    conditionalUserProperty.name = experimentInfo.getExperimentId();
+    conditionalUserProperty.value = experimentInfo.getVariantId();
+
+    // For a conditional user property to be immediately activated/triggered, its trigger
+    // event needs to be null, not just an empty string.
+    conditionalUserProperty.triggerEventName =
+        TextUtils.isEmpty(experimentInfo.getTriggerEventName())
+            ? null
+            : experimentInfo.getTriggerEventName();
+    conditionalUserProperty.triggerTimeout = experimentInfo.getTriggerTimeoutInMillis();
+    conditionalUserProperty.timeToLive = experimentInfo.getTimeToLiveInMillis();
+
+    return conditionalUserProperty;
+  }
+
+  /**
+   * Returns the {@link List} of {@link AbtExperimentInfo} converted from the {@link List} of
+   * experiment info {@link Map}s.
+   */
+  private static List<AbtExperimentInfo> convertMapsToExperimentInfos(
+      List<Map<String, String>> replacementExperimentsMaps) throws AbtException {
+
+    List<AbtExperimentInfo> replacementExperimentInfos = new ArrayList<>();
+    for (Map<String, String> replacementExperimentMap : replacementExperimentsMaps) {
+      replacementExperimentInfos.add(AbtExperimentInfo.fromMap(replacementExperimentMap));
+    }
+    return replacementExperimentInfos;
+  }
+
+  private void addExperimentToAnalytics(ConditionalUserProperty experiment) {
+    analyticsConnector.setConditionalUserProperty(experiment);
+  }
+
+  private void throwAbtExceptionIfAnalyticsIsNull() throws AbtException {
+    if (analyticsConnector == null) {
+      throw new AbtException(
+          "The Analytics SDK is not available. "
+              + "Please check that the Analytics SDK is included in your app dependencies.");
+    }
+  }
+
+  /**
+   * The method takes a String instead of a {@link ConditionalUserProperty} to make it easier to
+   * test. The method itself is tested to make it easier to figure out whether part of ABT is
+   * breaking, or if the underlying Analytics clear method is failing.
+   */
+  @VisibleForTesting
+  void removeExperimentFromAnalytics(String experimentId) {
+    analyticsConnector.clearConditionalUserProperty(
+        experimentId, /*clearEventName=*/ null, /*clearEventParams=*/ null);
+  }
+
+  @WorkerThread
+  private int getMaxUserPropertiesInAnalytics() {
+    if (maxUserProperties == null) {
+      maxUserProperties = analyticsConnector.getMaxUserProperties(originService);
+    }
+    return maxUserProperties;
+  }
+
+  /**
+   * Returns a list of all this origin's experiments in this App's Analytics SDK.
+   *
+   * <p>The list is sorted chronologically by the experiment start time, with the oldest experiment
+   * at index 0.
+   */
+  @WorkerThread
+  private List<ConditionalUserProperty> getAllExperimentsInAnalytics() {
+    return analyticsConnector.getConditionalUserProperties(
+        originService, /*propertyNamePrefix=*/ "");
+  }
+}
diff --git a/firebase-abt/src/main/java/com/google/firebase/abt/component/AbtComponent.java b/firebase-abt/src/main/java/com/google/firebase/abt/component/AbtComponent.java
new file mode 100644
index 000000000..2aebc960d
--- /dev/null
+++ b/firebase-abt/src/main/java/com/google/firebase/abt/component/AbtComponent.java
@@ -0,0 +1,65 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.abt.component;
+
+import android.content.Context;
+import androidx.annotation.GuardedBy;
+import androidx.annotation.VisibleForTesting;
+import com.google.firebase.abt.FirebaseABTesting;
+import com.google.firebase.abt.FirebaseABTesting.OriginService;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Component for providing multiple Firebase A/B Testing (ABT) instances. Firebase Android
+ * Components uses this class to retrieve instances of ABT for dependency injection.
+ *
+ * <p>A unique ABT instance is returned for each {@code originService}.
+ *
+ * @author Miraziz Yusupov
+ */
+public class AbtComponent {
+
+  @GuardedBy("this")
+  private final Map<String, FirebaseABTesting> abtOriginInstances = new HashMap<>();
+
+  private final Context appContext;
+  private final AnalyticsConnector analyticsConnector;
+
+  /** Firebase ABT Component constructor. */
+  @VisibleForTesting(otherwise = VisibleForTesting.PACKAGE_PRIVATE)
+  protected AbtComponent(Context appContext, AnalyticsConnector analyticsConnector) {
+    this.appContext = appContext;
+    this.analyticsConnector = analyticsConnector;
+  }
+
+  /**
+   * Returns the Firebase ABT instance associated with the given {@code originService}.
+   *
+   * @param originService the name of the ABT client, as defined in Analytics.
+   */
+  public synchronized FirebaseABTesting get(@OriginService String originService) {
+    if (!abtOriginInstances.containsKey(originService)) {
+      abtOriginInstances.put(originService, createAbtInstance(originService));
+    }
+    return abtOriginInstances.get(originService);
+  }
+
+  @VisibleForTesting
+  protected FirebaseABTesting createAbtInstance(@OriginService String originService) {
+    return new FirebaseABTesting(appContext, analyticsConnector, originService);
+  }
+}
diff --git a/firebase-abt/src/main/java/com/google/firebase/abt/component/AbtRegistrar.java b/firebase-abt/src/main/java/com/google/firebase/abt/component/AbtRegistrar.java
new file mode 100644
index 000000000..87200c0d8
--- /dev/null
+++ b/firebase-abt/src/main/java/com/google/firebase/abt/component/AbtRegistrar.java
@@ -0,0 +1,49 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.abt.component;
+
+import android.content.Context;
+import androidx.annotation.Keep;
+import com.google.firebase.abt.BuildConfig;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.components.Component;
+import com.google.firebase.components.ComponentRegistrar;
+import com.google.firebase.components.Dependency;
+import com.google.firebase.platforminfo.LibraryVersionComponent;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Registrar for setting up Firebase ABT's dependency injections in Firebase Android Components.
+ *
+ * @author Miraziz Yusupov
+ */
+@Keep
+public class AbtRegistrar implements ComponentRegistrar {
+
+  @Override
+  public List<Component<?>> getComponents() {
+    return Arrays.asList(
+        Component.builder(AbtComponent.class)
+            .add(Dependency.required(Context.class))
+            .add(Dependency.optional(AnalyticsConnector.class))
+            .factory(
+                container ->
+                    new AbtComponent(
+                        container.get(Context.class), container.get(AnalyticsConnector.class)))
+            .build(),
+        LibraryVersionComponent.create("fire-abt", BuildConfig.VERSION_NAME));
+  }
+}
diff --git a/firebase-abt/src/main/java/com/google/firebase/abt/component/package-info.java b/firebase-abt/src/main/java/com/google/firebase/abt/component/package-info.java
new file mode 100644
index 000000000..8a4e84c74
--- /dev/null
+++ b/firebase-abt/src/main/java/com/google/firebase/abt/component/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.firebase.abt.component;
diff --git a/firebase-abt/src/main/java/com/google/firebase/abt/package-info.java b/firebase-abt/src/main/java/com/google/firebase/abt/package-info.java
new file mode 100644
index 000000000..fe707dc44
--- /dev/null
+++ b/firebase-abt/src/main/java/com/google/firebase/abt/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.firebase.abt;
diff --git a/firebase-abt/src/proto/com/google/protos/developers/mobile/abt/proto/experiment_payload.proto b/firebase-abt/src/proto/com/google/protos/developers/mobile/abt/proto/experiment_payload.proto
new file mode 100644
index 000000000..9ff2153b4
--- /dev/null
+++ b/firebase-abt/src/proto/com/google/protos/developers/mobile/abt/proto/experiment_payload.proto
@@ -0,0 +1,109 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+package developers.mobile.abt;
+
+option java_outer_classname = "FirebaseAbt";
+
+// A lighter version of ExperimentPayload that describes an experiment
+// by only its experimentId. To be used when we don't need
+// to know all the details about the experiment, such as when sending a
+// list of all ongoing experiments.
+message ExperimentLite {
+    // A string of max length 22 characters.
+    // Format: _exp_<origin prefix>_<experiment_id>
+    // Required field.
+    string experiment_id = 1;
+}
+
+// ABT Payload for Firebase Namespace.
+message ExperimentPayload {
+    // A string of max length 22 characters.
+    // Format: _exp_<origin prefix>_<experiment_id>
+    // This is referred to as the tracking id and is different from the
+    // experiment id which is used internally by ABT.
+    // Required field.
+    string experiment_id = 1;
+
+    // A string which has numbers from 0-10.
+    // Required field.
+    string variant_id = 2;
+
+    // Epoch time in milliseconds when the experiment was started; > 0.
+    // Required field.
+    int64 experiment_start_time_millis = 3;
+
+    // The Scion event that causes the experiment to transition to ON state.
+    string trigger_event = 4;
+
+    // Duration in milliseconds that the experiment can stay in STANDBY state.
+    // Valid range is from 1ms to 6 months (current max defined by Scion).
+    // If the value is outside this range the setExperiment call on the client
+    // will fail.
+    // Required field
+    int64 trigger_timeout_millis = 5;
+
+    // Duration in milliseconds that the experiment can stay in ON state (an
+    // experiment becomes ON when it has been triggered, or when it has no
+    // trigger event).
+    // Corresponds to the attribution time in the ABT UI.
+    // Valid range is from 1ms to 6 months (current max defined by Scion).
+    // If the value is outside this range the setExperiment call on the client
+    // will fail.
+    // Required field
+    int64 time_to_live_millis = 6;
+
+    // The event logged when impact service sets the experiment.
+    // Max length = 32 chars
+    string set_event_to_log = 7;
+
+    // The event logged when an experiment goes to the ON state.
+    // Max length = 32 chars
+    string activate_event_to_log = 8;
+
+    // The event logged when an experiment is cleared.
+    // Max length = 32 chars
+    string clear_event_to_log = 9;
+
+    // The event logged when an experiment times out after trigger_timeout_millis
+    // milliseconds.
+    // Max length = 32 chars
+    string timeout_event_to_log = 10;
+
+    // The event logged when an experiment times out after time_to_live_millis
+    // milliseconds.
+    // Max length = 32 chars
+    string ttl_expiry_event_to_log = 11;
+
+    // Policy to use when there are more experiments than the Scion client can
+    // support on a single App for a single service.
+    // As of October 2016, we allow 3 experiments per instance per service
+    // (i.e. 3 each for Config and Notifications).
+    enum ExperimentOverflowPolicy {
+        POLICY_UNSPECIFIED = 0;
+        // Discard oldest experiments (by experiment_start_time) first.
+        DISCARD_OLDEST = 1;
+        // Ignore newest experiments first.
+        IGNORE_NEWEST = 2;
+    }
+    // The overflow policy enum for this experiment payload.
+    ExperimentOverflowPolicy overflow_policy = 12;
+
+    // A list of all other ongoing (started, and not yet stopped) experiments
+    // at the time this experiment was started.
+    // Does not include this experiment; only the others.
+    repeated ExperimentLite ongoing_experiments = 13;
+}
+
diff --git a/firebase-abt/src/test/java/com/google/firebase/abt/AbtExperimentInfoTest.java b/firebase-abt/src/test/java/com/google/firebase/abt/AbtExperimentInfoTest.java
new file mode 100644
index 000000000..885136825
--- /dev/null
+++ b/firebase-abt/src/test/java/com/google/firebase/abt/AbtExperimentInfoTest.java
@@ -0,0 +1,74 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.abt;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.firebase.abt.AbtExperimentInfo.EXPERIMENT_ID_KEY;
+import static com.google.firebase.abt.AbtExperimentInfo.EXPERIMENT_START_TIME_KEY;
+import static com.google.firebase.abt.AbtExperimentInfo.TIME_TO_LIVE_KEY;
+import static com.google.firebase.abt.AbtExperimentInfo.TRIGGER_EVENT_KEY;
+import static com.google.firebase.abt.AbtExperimentInfo.TRIGGER_TIMEOUT_KEY;
+import static com.google.firebase.abt.AbtExperimentInfo.VARIANT_ID_KEY;
+import static com.google.firebase.abt.AbtExperimentInfo.protoTimestampStringParser;
+
+import java.util.HashMap;
+import java.util.Map;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for {@link AbtExperimentInfo}.
+ *
+ * @author Miraziz Yusupov
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class AbtExperimentInfoTest {
+
+  @Test
+  public void fromMap_hasTriggerEvent_returnsConvertedExperiment() throws Exception {
+
+    Map<String, String> experimentInfoMap = createExperimentInfoMap("exp1", "var1", "trigger");
+
+    AbtExperimentInfo info = AbtExperimentInfo.fromMap(experimentInfoMap);
+    assertThat(info.getTriggerEventName()).isEqualTo("trigger");
+  }
+
+  @Test
+  public void fromMap_noTriggerEvent_returnsExperimentWithEmptyTriggerEvent() throws Exception {
+
+    Map<String, String> experimentInfoMap = createExperimentInfoMap("exp2", "var2", "");
+
+    AbtExperimentInfo info = AbtExperimentInfo.fromMap(experimentInfoMap);
+    assertThat(info.getTriggerEventName()).isEmpty();
+  }
+
+  private static Map<String, String> createExperimentInfoMap(
+      String experimentId, String variantId, String triggerEvent) {
+
+    Map<String, String> experimentInfoMap = new HashMap<>();
+    experimentInfoMap.put(EXPERIMENT_ID_KEY, experimentId);
+    experimentInfoMap.put(VARIANT_ID_KEY, variantId);
+    if (!triggerEvent.isEmpty()) {
+      experimentInfoMap.put(TRIGGER_EVENT_KEY, triggerEvent);
+    }
+    experimentInfoMap.put(EXPERIMENT_START_TIME_KEY, protoTimestampStringParser.format(555L));
+    experimentInfoMap.put(TRIGGER_TIMEOUT_KEY, "5");
+    experimentInfoMap.put(TIME_TO_LIVE_KEY, "5");
+    return experimentInfoMap;
+  }
+}
diff --git a/firebase-abt/src/test/java/com/google/firebase/abt/FirebaseABTWithoutAnalyticsTest.java b/firebase-abt/src/test/java/com/google/firebase/abt/FirebaseABTWithoutAnalyticsTest.java
new file mode 100644
index 000000000..ab5cd78e7
--- /dev/null
+++ b/firebase-abt/src/test/java/com/google/firebase/abt/FirebaseABTWithoutAnalyticsTest.java
@@ -0,0 +1,124 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.abt;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+
+import android.content.Context;
+import com.google.common.base.Preconditions;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.FirebaseOptions;
+import com.google.firebase.abt.FirebaseABTesting.OriginService;
+import com.google.firebase.abt.component.AbtComponent;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import java.sql.Date;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for {@link FirebaseABTesting} without the Analytics SDK {@link AnalyticsConnector}.
+ *
+ * @author Miraziz Yusupov
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class FirebaseABTWithoutAnalyticsTest {
+
+  private static final String APP_ID = "1:14368190084:android:09cb977358c6f241";
+  private static final String API_KEY = "api_key";
+
+  private static final String VARIANT_ID_VALUE = "var1";
+  private static final String TRIGGER_EVENT_NAME_VALUE = "trigger_event_value";
+  private static final long TRIGGER_TIMEOUT_IN_MILLIS_VALUE = 1000L;
+  private static final long TIME_TO_LIVE_IN_MILLIS_VALUE = 2000L;
+
+  private FirebaseABTesting firebaseAbt;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    initializeFirebaseApp(RuntimeEnvironment.application);
+
+    Preconditions.checkArgument(FirebaseApp.getInstance().get(AnalyticsConnector.class) == null);
+
+    firebaseAbt =
+        FirebaseApp.getInstance().get(AbtComponent.class).get(OriginService.REMOTE_CONFIG);
+  }
+
+  @Test
+  public void replaceAllExperimentsWithoutAnalytics_experimentsListIsNull_throwsAbtException() {
+    AbtException actualException =
+        assertThrows(
+            AbtException.class,
+            () -> firebaseAbt.replaceAllExperiments(/*replacementExperiments=*/ null));
+    assertThat(actualException).hasMessageThat().contains("Analytics");
+  }
+
+  @Test
+  public void replaceAllExperimentsWithoutAnalytics_sendsValidExperimentList_throwsAbtException() {
+
+    List<AbtExperimentInfo> experimentInfos = new ArrayList<>();
+    experimentInfos.add(
+        createExperimentInfo("expid1", /*experimentStartTimeInEpochMillis=*/ 1000L));
+    experimentInfos.add(
+        createExperimentInfo("expid2", /*experimentStartTimeInEpochMillis=*/ 2000L));
+
+    List<Map<String, String>> experimentInfoMaps = new ArrayList<>();
+    for (AbtExperimentInfo experimentInfo : experimentInfos) {
+      experimentInfoMaps.add(experimentInfo.toStringMap());
+    }
+
+    AbtException actualException =
+        assertThrows(
+            AbtException.class, () -> firebaseAbt.replaceAllExperiments(experimentInfoMaps));
+    assertThat(actualException).hasMessageThat().contains("Analytics");
+  }
+
+  @Test
+  public void removeAllExperimentsWithoutAnalytics_throwsAbtException() {
+    AbtException actualException =
+        assertThrows(AbtException.class, () -> firebaseAbt.removeAllExperiments());
+    assertThat(actualException).hasMessageThat().contains("Analytics");
+  }
+
+  private static AbtExperimentInfo createExperimentInfo(
+      String experimentId, long experimentStartTimeInEpochMillis) {
+
+    return new AbtExperimentInfo(
+        experimentId,
+        VARIANT_ID_VALUE,
+        TRIGGER_EVENT_NAME_VALUE,
+        new Date(experimentStartTimeInEpochMillis),
+        TRIGGER_TIMEOUT_IN_MILLIS_VALUE,
+        TIME_TO_LIVE_IN_MILLIS_VALUE);
+  }
+
+  private static void initializeFirebaseApp(Context context) {
+    FirebaseApp.clearInstancesForTest();
+
+    FirebaseApp.initializeApp(
+        context, new FirebaseOptions.Builder().setApiKey(API_KEY).setApplicationId(APP_ID).build());
+  }
+}
diff --git a/firebase-common/api.txt b/firebase-common/api.txt
new file mode 100644
index 000000000..7c29677a1
--- /dev/null
+++ b/firebase-common/api.txt
@@ -0,0 +1,70 @@
+// Signature format: 2.0
+package com.google.firebase {
+
+  public class FirebaseApp {
+    method public boolean equals(Object);
+    method @NonNull public Context getApplicationContext();
+    method @NonNull public static List<FirebaseApp> getApps(@NonNull Context);
+    method @NonNull public static com.google.firebase.FirebaseApp getInstance();
+    method @NonNull public static com.google.firebase.FirebaseApp getInstance(@NonNull String);
+    method @NonNull public String getName();
+    method @NonNull public com.google.firebase.FirebaseOptions getOptions();
+    method public int hashCode();
+    method @Nullable public static com.google.firebase.FirebaseApp initializeApp(@NonNull Context);
+    method @NonNull public static com.google.firebase.FirebaseApp initializeApp(@NonNull Context, @NonNull com.google.firebase.FirebaseOptions);
+    method @NonNull public static com.google.firebase.FirebaseApp initializeApp(@NonNull Context, @NonNull com.google.firebase.FirebaseOptions, @NonNull String);
+    method public void setAutomaticResourceManagementEnabled(boolean);
+    method public String toString();
+    field @NonNull public static final String DEFAULT_APP_NAME;
+  }
+
+  public class FirebaseNetworkException {
+    ctor public FirebaseNetworkException(@NonNull String);
+  }
+
+  public final class FirebaseOptions {
+    method public boolean equals(Object);
+    method @Nullable public static com.google.firebase.FirebaseOptions fromResource(@NonNull Context);
+    method @NonNull public String getApiKey();
+    method @NonNull public String getApplicationId();
+    method @Nullable public String getDatabaseUrl();
+    method @Nullable public String getGcmSenderId();
+    method @Nullable public String getProjectId();
+    method @Nullable public String getStorageBucket();
+    method public int hashCode();
+    method public String toString();
+  }
+
+  public static final class FirebaseOptions.Builder {
+    ctor public FirebaseOptions.Builder();
+    ctor public FirebaseOptions.Builder(@NonNull com.google.firebase.FirebaseOptions);
+    method @NonNull public com.google.firebase.FirebaseOptions build();
+    method @NonNull public com.google.firebase.FirebaseOptions.Builder setApiKey(@NonNull String);
+    method @NonNull public com.google.firebase.FirebaseOptions.Builder setApplicationId(@NonNull String);
+    method @NonNull public com.google.firebase.FirebaseOptions.Builder setDatabaseUrl(@Nullable String);
+    method @NonNull public com.google.firebase.FirebaseOptions.Builder setGcmSenderId(@Nullable String);
+    method @NonNull public com.google.firebase.FirebaseOptions.Builder setProjectId(@Nullable String);
+    method @NonNull public com.google.firebase.FirebaseOptions.Builder setStorageBucket(@Nullable String);
+  }
+
+  public class FirebaseTooManyRequestsException {
+    ctor public FirebaseTooManyRequestsException(@NonNull String);
+  }
+
+}
+
+package com.google.firebase.provider {
+
+  public class FirebaseInitProvider {
+    ctor public FirebaseInitProvider();
+    method public void attachInfo(@NonNull Context, @NonNull ProviderInfo);
+    method public int delete(@NonNull Uri, @Nullable String, @Nullable String[]);
+    method @Nullable public String getType(@NonNull Uri);
+    method @Nullable public Uri insert(@NonNull Uri, @Nullable ContentValues);
+    method public boolean onCreate();
+    method @Nullable public Cursor query(@NonNull Uri, @Nullable String[], @Nullable String, @Nullable String[], @Nullable String);
+    method public int update(@NonNull Uri, @Nullable ContentValues, @Nullable String, @Nullable String[]);
+  }
+
+}
+
diff --git a/firebase-common/data-collection-tests/data-collection-tests.gradle b/firebase-common/data-collection-tests/data-collection-tests.gradle
new file mode 100644
index 000000000..49001470c
--- /dev/null
+++ b/firebase-common/data-collection-tests/data-collection-tests.gradle
@@ -0,0 +1,52 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+plugins {
+    id 'com.android.application'
+}
+
+android {
+    adbOptions {
+        timeOutInMs 60 * 1000
+    }
+
+    compileSdkVersion project.targetSdkVersion
+    defaultConfig {
+        minSdkVersion project.minSdkVersion
+        targetSdkVersion project.targetSdkVersion
+        versionName version
+        multiDexEnabled true
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+    }
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+    testOptions {
+        unitTests {
+            includeAndroidResources = true
+        }
+    }
+}
+
+dependencies {
+    implementation project(':firebase-common')
+    testImplementation 'androidx.test:runner:1.2.0'
+    testImplementation 'androidx.test.ext:junit:1.1.1'
+    testImplementation "org.robolectric:robolectric:$robolectricVersion"
+    testImplementation 'com.google.auto.value:auto-value-annotations:1.6.5'
+    testImplementation 'junit:junit:4.12'
+    testImplementation "com.google.truth:truth:$googleTruthVersion"
+    testImplementation 'org.mockito:mockito-core:2.25.0'
+}
diff --git a/firebase-common/data-collection-tests/src/main/AndroidManifest.xml b/firebase-common/data-collection-tests/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..1cb551d3b
--- /dev/null
+++ b/firebase-common/data-collection-tests/src/main/AndroidManifest.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright 2019 Google LLC -->
+<!-- -->
+<!-- Licensed under the Apache License, Version 2.0 (the "License"); -->
+<!-- you may not use this file except in compliance with the License. -->
+<!-- You may obtain a copy of the License at -->
+<!-- -->
+<!--      http://www.apache.org/licenses/LICENSE-2.0 -->
+<!-- -->
+<!-- Unless required by applicable law or agreed to in writing, software -->
+<!-- distributed under the License is distributed on an "AS IS" BASIS, -->
+<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. -->
+<!-- See the License for the specific language governing permissions and -->
+<!-- limitations under the License. -->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.google.firebase.datacollectiontests">
+    <application>
+        <meta-data android:name="firebase_data_collection_default_enabled"
+            android:value="false" />
+
+        <service android:name="com.google.firebase.components.ComponentDiscoveryService" android:exported="false">
+            <meta-data
+                android:name="com.google.firebase.components:com.google.firebase.DataCollectionDefaultChangeRegistrar"
+                android:value="com.google.firebase.components.ComponentRegistrar" />
+        </service>
+    </application>
+</manifest>
diff --git a/firebase-common/data-collection-tests/src/test/java/com/google/firebase/DataCollectionDefaultChangeRegistrar.java b/firebase-common/data-collection-tests/src/test/java/com/google/firebase/DataCollectionDefaultChangeRegistrar.java
new file mode 100644
index 000000000..ba2b0a351
--- /dev/null
+++ b/firebase-common/data-collection-tests/src/test/java/com/google/firebase/DataCollectionDefaultChangeRegistrar.java
@@ -0,0 +1,44 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase;
+
+import com.google.firebase.components.Component;
+import com.google.firebase.components.ComponentRegistrar;
+import com.google.firebase.components.Dependency;
+import com.google.firebase.events.Subscriber;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public class DataCollectionDefaultChangeRegistrar implements ComponentRegistrar {
+  @Override
+  public List<Component<?>> getComponents() {
+    return Collections.singletonList(
+        Component.builder(ChangeListener.class)
+            .add(Dependency.required(Subscriber.class))
+            .alwaysEager()
+            .factory(c -> new ChangeListener(c.get(Subscriber.class)))
+            .build());
+  }
+
+  public static class ChangeListener {
+    public List<Boolean> changes = new ArrayList<>();
+
+    ChangeListener(Subscriber subscriber) {
+      subscriber.subscribe(
+          DataCollectionDefaultChange.class, change -> changes.add(change.getPayload().enabled));
+    }
+  }
+}
diff --git a/firebase-common/src/test/java/com/google/firebase/DataCollectionDefaultDisabledTest.java b/firebase-common/data-collection-tests/src/test/java/com/google/firebase/DataCollectionDefaultDisabledTest.java
similarity index 93%
rename from firebase-common/src/test/java/com/google/firebase/DataCollectionDefaultDisabledTest.java
rename to firebase-common/data-collection-tests/src/test/java/com/google/firebase/DataCollectionDefaultDisabledTest.java
index 68eeeaa79..8fce7f8bc 100644
--- a/firebase-common/src/test/java/com/google/firebase/DataCollectionDefaultDisabledTest.java
+++ b/firebase-common/data-collection-tests/src/test/java/com/google/firebase/DataCollectionDefaultDisabledTest.java
@@ -1,4 +1,4 @@
-// Copyright 2018 Google LLC
+// Copyright 2019 Google LLC
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -20,14 +20,12 @@
 import static com.google.firebase.DataCollectionTestUtil.withApp;
 
 import android.content.SharedPreferences;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.firebase.internal.DataCollectionConfigStorage;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = "NoAutoDataCollectionAndroidManifest.xml")
+@RunWith(AndroidJUnit4.class)
 public class DataCollectionDefaultDisabledTest {
 
   @Test
diff --git a/firebase-common/data-collection-tests/src/test/java/com/google/firebase/DataCollectionTestUtil.java b/firebase-common/data-collection-tests/src/test/java/com/google/firebase/DataCollectionTestUtil.java
new file mode 100644
index 000000000..3bbf72783
--- /dev/null
+++ b/firebase-common/data-collection-tests/src/test/java/com/google/firebase/DataCollectionTestUtil.java
@@ -0,0 +1,61 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import androidx.test.core.app.ApplicationProvider;
+import com.google.firebase.internal.DataCollectionConfigStorage;
+import java.util.function.Consumer;
+
+final class DataCollectionTestUtil {
+  private static final String APP_NAME = "someApp";
+  private static final String APP_ID = "appId";
+
+  private static final String FIREBASE_APP_PREFS = "com.google.firebase.common.prefs:";
+
+  private static final FirebaseOptions OPTIONS =
+      new FirebaseOptions.Builder().setApplicationId(APP_ID).build();
+
+  private DataCollectionTestUtil() {}
+
+  static void withApp(Consumer<FirebaseApp> callable) {
+    withApp(APP_NAME, callable);
+  }
+
+  static void withApp(String name, Consumer<FirebaseApp> callable) {
+    FirebaseApp app =
+        FirebaseApp.initializeApp(ApplicationProvider.getApplicationContext(), OPTIONS, name);
+    try {
+      callable.accept(app);
+    } finally {
+      app.delete();
+    }
+  }
+
+  static SharedPreferences getSharedPreferences() {
+    return ApplicationProvider.getApplicationContext()
+        .getSharedPreferences(
+            FIREBASE_APP_PREFS + FirebaseApp.getPersistenceKey(APP_NAME, OPTIONS),
+            Context.MODE_PRIVATE);
+  }
+
+  static void setSharedPreferencesTo(boolean enabled) {
+    getSharedPreferences()
+        .edit()
+        .putBoolean(DataCollectionConfigStorage.DATA_COLLECTION_DEFAULT_ENABLED, enabled)
+        .commit();
+  }
+}
diff --git a/firebase-common/firebase-common.gradle b/firebase-common/firebase-common.gradle
index 887f86554..9c7a246fa 100644
--- a/firebase-common/firebase-common.gradle
+++ b/firebase-common/firebase-common.gradle
@@ -32,7 +32,7 @@ android {
       targetSdkVersion project.targetSdkVersion
       versionName version
       multiDexEnabled true
-      testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+      testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
     }
     sourceSets {
         androidTest {
@@ -55,27 +55,34 @@ android {
             includeAndroidResources = true
         }
     }
+    lintOptions {
+        baseline file("lint-baseline.xml")
+    }
 }
 
 dependencies {
-    implementation "com.google.android.gms:play-services-basement:$playServicesVersion"
-    implementation "com.google.android.gms:play-services-tasks:$playServicesVersion"
+    implementation 'com.google.android.gms:play-services-basement:17.0.0'
+    implementation "com.google.android.gms:play-services-tasks:17.0.0"
 
-    api 'com.google.auto.value:auto-value-annotations:1.6.3'
+    api 'com.google.auto.value:auto-value-annotations:1.6.5'
     compileOnly 'com.google.code.findbugs:jsr305:3.0.2'
 
-    testImplementation 'com.android.support.test:runner:1.0.2'
+    // needed for Kotlin detection to compile, but not necessarily present at runtime.
+    compileOnly "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlinVersion"
+
+    testImplementation 'androidx.test:runner:1.2.0'
+    testImplementation 'androidx.test.ext:junit:1.1.1'
     testImplementation "org.robolectric:robolectric:$robolectricVersion"
     testImplementation 'junit:junit:4.12'
     testImplementation "com.google.truth:truth:$googleTruthVersion"
-    testImplementation 'org.mockito:mockito-core:2.21.0'
+    testImplementation 'org.mockito:mockito-core:2.25.0'
 
-    annotationProcessor 'com.google.auto.value:auto-value:1.6'
+    annotationProcessor 'com.google.auto.value:auto-value:1.6.2'
 
     androidTestImplementation 'junit:junit:4.12'
-    androidTestImplementation 'com.android.support.test:runner:1.0.2'
+    androidTestImplementation 'androidx.test:runner:1.2.0'
     androidTestImplementation "com.google.truth:truth:$googleTruthVersion"
-    androidTestImplementation 'org.mockito:mockito-core:2.21.0'
+    androidTestImplementation 'org.mockito:mockito-core:2.25.0'
     androidTestImplementation 'com.linkedin.dexmaker:dexmaker:2.25.0'
     androidTestImplementation 'com.linkedin.dexmaker:dexmaker-mockito:2.25.0'
     androidTestImplementation ('com.google.firebase:firebase-auth:17.0.0') {
@@ -85,6 +92,4 @@ dependencies {
     androidTestImplementation ('com.google.firebase:firebase-core:16.0.9') {
         exclude group: "com.google.firebase", module: "firebase-common"
     }
-
-    annotationProcessor 'com.google.auto.value:auto-value:1.6'
 }
diff --git a/firebase-common/gradle.properties b/firebase-common/gradle.properties
index 5328ce212..971c9e334 100644
--- a/firebase-common/gradle.properties
+++ b/firebase-common/gradle.properties
@@ -1,2 +1,2 @@
-version=17.1.1
-latestReleasedVersion=17.1.0
+version=19.1.1
+latestReleasedVersion=19.1.0
diff --git a/firebase-common/ktx/ktx.gradle b/firebase-common/ktx/ktx.gradle
index 3c3ebaeec..a61b3917a 100644
--- a/firebase-common/ktx/ktx.gradle
+++ b/firebase-common/ktx/ktx.gradle
@@ -27,7 +27,6 @@ android {
         minSdkVersion project.minSdkVersion
         targetSdkVersion project.targetSdkVersion
         versionName version
-        buildConfigField('String', 'KOTLIN_VERSION', "\"$kotlinVersion\"")
     }
     sourceSets {
         main.java.srcDirs += 'src/main/kotlin'
@@ -40,7 +39,7 @@ dependencies {
     implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlinVersion"
 
     implementation project(':firebase-common')
-    implementation 'com.android.support:support-annotations:28.0.0'
+    implementation 'androidx.annotation:annotation:1.1.0'
 
     testImplementation "org.robolectric:robolectric:$robolectricVersion"
     testImplementation 'junit:junit:4.12'
diff --git a/firebase-common/ktx/src/main/kotlin/com/google/firebase/ktx/Firebase.kt b/firebase-common/ktx/src/main/kotlin/com/google/firebase/ktx/Firebase.kt
index 198d86b8c..a6c3cbd07 100644
--- a/firebase-common/ktx/src/main/kotlin/com/google/firebase/ktx/Firebase.kt
+++ b/firebase-common/ktx/src/main/kotlin/com/google/firebase/ktx/Firebase.kt
@@ -14,7 +14,7 @@
 package com.google.firebase.ktx
 
 import android.content.Context
-import android.support.annotation.Keep
+import androidx.annotation.Keep
 import com.google.firebase.FirebaseApp
 import com.google.firebase.FirebaseOptions
 import com.google.firebase.components.Component
@@ -57,7 +57,6 @@ internal const val LIBRARY_NAME: String = "fire-core-ktx"
 class FirebaseCommonKtxRegistrar : ComponentRegistrar {
     override fun getComponents(): List<Component<*>> {
         return listOf(
-                LibraryVersionComponent.create(LIBRARY_NAME, BuildConfig.VERSION_NAME),
-                LibraryVersionComponent.create("kotlin", BuildConfig.KOTLIN_VERSION))
+                LibraryVersionComponent.create(LIBRARY_NAME, BuildConfig.VERSION_NAME))
     }
 }
diff --git a/firebase-common/ktx/src/test/kotlin/com/google/firebase/ktx/Tests.kt b/firebase-common/ktx/src/test/kotlin/com/google/firebase/ktx/Tests.kt
index 1b19c4ef4..4a51563b4 100644
--- a/firebase-common/ktx/src/test/kotlin/com/google/firebase/ktx/Tests.kt
+++ b/firebase-common/ktx/src/test/kotlin/com/google/firebase/ktx/Tests.kt
@@ -53,7 +53,7 @@ class KtxTests {
     @Test
     fun `Firebase#app should delegate to FirebaseApp#getInstance()`() {
         withApp(FirebaseApp.DEFAULT_APP_NAME) {
-            assertThat(Firebase.app).isSameAs(FirebaseApp.getInstance())
+            assertThat(Firebase.app).isSameInstanceAs(FirebaseApp.getInstance())
         }
     }
 
@@ -61,14 +61,14 @@ class KtxTests {
     fun `Firebase#app(String) should delegate to FirebaseApp#getInstance(String)`() {
         val appName = "testApp"
         withApp(appName) {
-            assertThat(Firebase.app(appName)).isSameAs(FirebaseApp.getInstance(appName))
+            assertThat(Firebase.app(appName)).isSameInstanceAs(FirebaseApp.getInstance(appName))
         }
     }
 
     @Test
     fun `Firebase#options should delegate to FirebaseApp#getInstance()#options`() {
         withApp(FirebaseApp.DEFAULT_APP_NAME) {
-            assertThat(Firebase.options).isSameAs(FirebaseApp.getInstance().options)
+            assertThat(Firebase.options).isSameInstanceAs(FirebaseApp.getInstance().options)
         }
     }
 
@@ -79,8 +79,8 @@ class KtxTests {
         try {
             assertThat(app).isNotNull()
             assertThat(app.name).isEqualTo(FirebaseApp.DEFAULT_APP_NAME)
-            assertThat(app.options).isSameAs(options)
-            assertThat(app.applicationContext).isSameAs(RuntimeEnvironment.application)
+            assertThat(app.options).isSameInstanceAs(options)
+            assertThat(app.applicationContext).isSameInstanceAs(RuntimeEnvironment.application)
         } finally {
             app.delete()
         }
@@ -94,8 +94,8 @@ class KtxTests {
         try {
             assertThat(app).isNotNull()
             assertThat(app.name).isEqualTo(name)
-            assertThat(app.options).isSameAs(options)
-            assertThat(app.applicationContext).isSameAs(RuntimeEnvironment.application)
+            assertThat(app.options).isSameInstanceAs(options)
+            assertThat(app.applicationContext).isSameInstanceAs(RuntimeEnvironment.application)
         } finally {
             app.delete()
         }
diff --git a/firebase-common/lint-baseline.xml b/firebase-common/lint-baseline.xml
new file mode 100644
index 000000000..ea62ca50d
--- /dev/null
+++ b/firebase-common/lint-baseline.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<issues format="5" by="lint 3.4.1" client="gradle" variant="all" version="3.4.1">
+
+</issues>
diff --git a/firebase-common/proguard.txt b/firebase-common/proguard.txt
index 25ba3354f..b0878beb0 100644
--- a/firebase-common/proguard.txt
+++ b/firebase-common/proguard.txt
@@ -1,3 +1,4 @@
 -dontwarn com.google.firebase.components.Component$Instantiation
 -dontwarn com.google.firebase.components.Component$ComponentType
+-dontwarn com.google.firebase.platforminfo.KotlinDetector
 -keep class * implements com.google.firebase.components.ComponentRegistrar
diff --git a/firebase-common/src/androidTest/java/com/google/firebase/FirebaseAppTest.java b/firebase-common/src/androidTest/java/com/google/firebase/FirebaseAppTest.java
index dd5aafff4..e6fd041cb 100644
--- a/firebase-common/src/androidTest/java/com/google/firebase/FirebaseAppTest.java
+++ b/firebase-common/src/androidTest/java/com/google/firebase/FirebaseAppTest.java
@@ -32,9 +32,9 @@
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.os.UserManager;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
-import android.support.v4.content.LocalBroadcastManager;
+import androidx.localbroadcastmanager.content.LocalBroadcastManager;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.gms.common.api.internal.BackgroundDetector;
 import com.google.common.base.Defaults;
 import com.google.firebase.auth.FirebaseAuth;
@@ -349,18 +349,18 @@ public void testInitializeApp_shouldDiscoverAndInitializeComponents() {
 
     Context appContext = mockContext.getApplicationContext();
 
-    assertThat(firebaseApp.get(Context.class)).isSameAs(appContext);
-    assertThat(firebaseApp.get(FirebaseApp.class)).isSameAs(firebaseApp);
+    assertThat(firebaseApp.get(Context.class)).isSameInstanceAs(appContext);
+    assertThat(firebaseApp.get(FirebaseApp.class)).isSameInstanceAs(firebaseApp);
 
     TestComponentOne one = firebaseApp.get(TestComponentOne.class);
     assertThat(one).isNotNull();
-    assertThat(one.getContext()).isSameAs(appContext);
+    assertThat(one.getContext()).isSameInstanceAs(appContext);
 
     TestComponentTwo two = firebaseApp.get(TestComponentTwo.class);
     assertThat(two).isNotNull();
-    assertThat(two.getApp()).isSameAs(firebaseApp);
-    assertThat(two.getOptions()).isSameAs(firebaseApp.getOptions());
-    assertThat(two.getOne()).isSameAs(one);
+    assertThat(two.getApp()).isSameInstanceAs(firebaseApp);
+    assertThat(two.getOptions()).isSameInstanceAs(firebaseApp.getOptions());
+    assertThat(two.getOne()).isSameInstanceAs(one);
   }
 
   @Test
diff --git a/firebase-common/src/androidTest/java/com/google/firebase/FirebaseOptionsTest.java b/firebase-common/src/androidTest/java/com/google/firebase/FirebaseOptionsTest.java
index 88c27c618..9140b7d5c 100644
--- a/firebase-common/src/androidTest/java/com/google/firebase/FirebaseOptionsTest.java
+++ b/firebase-common/src/androidTest/java/com/google/firebase/FirebaseOptionsTest.java
@@ -16,7 +16,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -79,7 +79,7 @@ public void createOptionsWithAppIdMissing() {
   @Test
   public void checkToBuilderCreatesNewEquivalentInstance() {
     FirebaseOptions allValuesOptionsCopy = new FirebaseOptions.Builder(ALL_VALUES_OPTIONS).build();
-    assertThat(allValuesOptionsCopy).isNotSameAs(ALL_VALUES_OPTIONS);
+    assertThat(allValuesOptionsCopy).isNotSameInstanceAs(ALL_VALUES_OPTIONS);
     assertThat(allValuesOptionsCopy).isEqualTo(ALL_VALUES_OPTIONS);
   }
 }
diff --git a/firebase-common/src/main/AndroidManifest.xml b/firebase-common/src/main/AndroidManifest.xml
index e003b1415..952ceebfb 100644
--- a/firebase-common/src/main/AndroidManifest.xml
+++ b/firebase-common/src/main/AndroidManifest.xml
@@ -1,11 +1,16 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest
     xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
     package="com.google.firebase">
   <!--Although the *SdkVersion is captured in gradle build files, this is required for non gradle builds-->
   <!--<uses-sdk android:minSdkVersion="14"/>-->
   <application>
 
+    <service android:name="com.google.firebase.components.ComponentDiscoveryService"
+        android:directBootAware="true" android:exported="false"
+        tools:targetApi="n" />
+
     <provider
         android:name="com.google.firebase.provider.FirebaseInitProvider"
         android:authorities="${applicationId}.firebaseinitprovider"
diff --git a/firebase-common/src/main/java/com/google/firebase/FirebaseApp.java b/firebase-common/src/main/java/com/google/firebase/FirebaseApp.java
index 57cd70c9c..04b26ab64 100644
--- a/firebase-common/src/main/java/com/google/firebase/FirebaseApp.java
+++ b/firebase-common/src/main/java/com/google/firebase/FirebaseApp.java
@@ -25,28 +25,29 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
-import android.support.v4.os.UserManagerCompat;
-import android.support.v4.util.ArrayMap;
 import android.text.TextUtils;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import androidx.collection.ArrayMap;
+import androidx.core.os.UserManagerCompat;
 import com.google.android.gms.common.annotation.KeepForSdk;
 import com.google.android.gms.common.api.internal.BackgroundDetector;
 import com.google.android.gms.common.internal.Objects;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.common.util.PlatformVersion;
 import com.google.android.gms.common.util.ProcessUtils;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.components.Component;
 import com.google.firebase.components.ComponentDiscovery;
 import com.google.firebase.components.ComponentRegistrar;
 import com.google.firebase.components.ComponentRuntime;
 import com.google.firebase.components.Lazy;
 import com.google.firebase.events.Publisher;
+import com.google.firebase.heartbeatinfo.DefaultHeartBeatInfo;
 import com.google.firebase.internal.DataCollectionConfigStorage;
 import com.google.firebase.platforminfo.DefaultUserAgentPublisher;
+import com.google.firebase.platforminfo.KotlinDetector;
 import com.google.firebase.platforminfo.LibraryVersionComponent;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
@@ -85,12 +86,11 @@
  * Use of Firebase in processes other than the main process is not supported and will likely cause
  * problems related to resource contention.
  */
-@PublicApi
 public class FirebaseApp {
 
   private static final String LOG_TAG = "FirebaseApp";
 
-  public static final String DEFAULT_APP_NAME = "[DEFAULT]";
+  public static final @NonNull String DEFAULT_APP_NAME = "[DEFAULT]";
 
   private static final Object LOCK = new Object();
 
@@ -102,6 +102,7 @@
 
   private static final String FIREBASE_ANDROID = "fire-android";
   private static final String FIREBASE_COMMON = "fire-core";
+  private static final String KOTLIN = "kotlin";
 
   private final Context applicationContext;
   private final String name;
@@ -121,7 +122,6 @@
 
   /** Returns the application {@link Context}. */
   @NonNull
-  @PublicApi
   public Context getApplicationContext() {
     checkNotDeleted();
     return applicationContext;
@@ -129,7 +129,6 @@ public Context getApplicationContext() {
 
   /** Returns the unique name of this app. */
   @NonNull
-  @PublicApi
   public String getName() {
     checkNotDeleted();
     return name;
@@ -137,7 +136,6 @@ public String getName() {
 
   /** Returns the specified {@link FirebaseOptions}. */
   @NonNull
-  @PublicApi
   public FirebaseOptions getOptions() {
     checkNotDeleted();
     return options;
@@ -162,8 +160,8 @@ public String toString() {
   }
 
   /** Returns a mutable list of all FirebaseApps. */
-  @PublicApi
-  public static List<FirebaseApp> getApps(Context context) {
+  @NonNull
+  public static List<FirebaseApp> getApps(@NonNull Context context) {
     synchronized (LOCK) {
       return new ArrayList<>(INSTANCES.values());
     }
@@ -175,7 +173,6 @@ public String toString() {
    * @throws IllegalStateException if the default app was not initialized.
    */
   @NonNull
-  @PublicApi
   public static FirebaseApp getInstance() {
     synchronized (LOCK) {
       FirebaseApp defaultApp = INSTANCES.get(DEFAULT_APP_NAME);
@@ -199,7 +196,6 @@ public static FirebaseApp getInstance() {
    *     #initializeApp(Context, FirebaseOptions, String)}.
    */
   @NonNull
-  @PublicApi
   public static FirebaseApp getInstance(@NonNull String name) {
     synchronized (LOCK) {
       FirebaseApp firebaseApp = INSTANCES.get(normalize(name));
@@ -239,7 +235,6 @@ public static FirebaseApp getInstance(@NonNull String name) {
    *     keys are present in string resources. Returns null otherwise.
    */
   @Nullable
-  @PublicApi
   public static FirebaseApp initializeApp(@NonNull Context context) {
     synchronized (LOCK) {
       if (INSTANCES.containsKey(DEFAULT_APP_NAME)) {
@@ -267,7 +262,6 @@ public static FirebaseApp initializeApp(@NonNull Context context) {
    * initialization that way is the expected situation.
    */
   @NonNull
-  @PublicApi
   public static FirebaseApp initializeApp(
       @NonNull Context context, @NonNull FirebaseOptions options) {
     return initializeApp(context, options, DEFAULT_APP_NAME);
@@ -284,7 +278,6 @@ public static FirebaseApp initializeApp(
    * @return an instance of {@link FirebaseApp}
    */
   @NonNull
-  @PublicApi
   public static FirebaseApp initializeApp(
       @NonNull Context context, @NonNull FirebaseOptions options, @NonNull String name) {
     GlobalBackgroundStateListener.ensureBackgroundStateListenerRegistered(context);
@@ -319,7 +312,6 @@ public static FirebaseApp initializeApp(
    *
    * @hide
    */
-  @PublicApi
   public void delete() {
     boolean valueChanged = deleted.compareAndSet(false /* expected */, true);
     if (!valueChanged) {
@@ -348,7 +340,6 @@ public void delete() {
    * If set to true it indicates that Firebase should close database connections automatically when
    * the app is in the background. Disabled by default.
    */
-  @PublicApi
   public void setAutomaticResourceManagementEnabled(boolean enabled) {
     checkNotDeleted();
     boolean updated =
@@ -409,6 +400,8 @@ protected FirebaseApp(Context applicationContext, String name, FirebaseOptions o
 
     List<ComponentRegistrar> registrars =
         ComponentDiscovery.forContext(applicationContext).discover();
+
+    String kotlinVersion = KotlinDetector.detectVersion();
     componentRuntime =
         new ComponentRuntime(
             UI_EXECUTOR,
@@ -418,7 +411,10 @@ protected FirebaseApp(Context applicationContext, String name, FirebaseOptions o
             Component.of(options, FirebaseOptions.class),
             LibraryVersionComponent.create(FIREBASE_ANDROID, ""),
             LibraryVersionComponent.create(FIREBASE_COMMON, BuildConfig.VERSION_NAME),
-            DefaultUserAgentPublisher.component());
+            kotlinVersion != null ? LibraryVersionComponent.create(KOTLIN, kotlinVersion) : null,
+            DefaultUserAgentPublisher.component(),
+            DefaultHeartBeatInfo.component());
+
     dataCollectionConfigStorage =
         new Lazy<>(
             () ->
diff --git a/firebase-common/src/main/java/com/google/firebase/FirebaseNetworkException.java b/firebase-common/src/main/java/com/google/firebase/FirebaseNetworkException.java
index 1eabf9df3..2db817f70 100644
--- a/firebase-common/src/main/java/com/google/firebase/FirebaseNetworkException.java
+++ b/firebase-common/src/main/java/com/google/firebase/FirebaseNetworkException.java
@@ -14,17 +14,14 @@
 
 package com.google.firebase;
 
-import android.support.annotation.NonNull;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
 
 /**
  * Exception thrown when a request to a Firebase service has failed due to a network error. Inspect
  * the device's network connectivity state or retry later to resolve.
  */
-@PublicApi
 public class FirebaseNetworkException extends FirebaseException {
 
-  @PublicApi
   public FirebaseNetworkException(@NonNull String detailMessage) {
     super(detailMessage);
   }
diff --git a/firebase-common/src/main/java/com/google/firebase/FirebaseOptions.java b/firebase-common/src/main/java/com/google/firebase/FirebaseOptions.java
index c2e578f97..3d35bbce3 100644
--- a/firebase-common/src/main/java/com/google/firebase/FirebaseOptions.java
+++ b/firebase-common/src/main/java/com/google/firebase/FirebaseOptions.java
@@ -18,17 +18,15 @@
 import static com.google.android.gms.common.util.Strings.isEmptyOrWhitespace;
 
 import android.content.Context;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.annotation.KeepForSdk;
 import com.google.android.gms.common.internal.Objects;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.common.internal.StringResourceValueReader;
-import com.google.firebase.annotations.PublicApi;
 
 /** Configurable Firebase options. */
-@PublicApi
 public final class FirebaseOptions {
 
   // TODO: deprecate and remove it once we can fetch these from Remote Config.
@@ -50,7 +48,6 @@
   private final String projectId;
 
   /** Builder for constructing FirebaseOptions. */
-  @PublicApi
   public static final class Builder {
     private String apiKey;
     private String applicationId;
@@ -61,7 +58,6 @@
     private String projectId;
 
     /** Constructs an empty builder. */
-    @PublicApi
     public Builder() {}
 
     /**
@@ -70,8 +66,7 @@ public Builder() {}
      * <p>The new builder is not backed by this objects values, that is changes made to the new
      * builder don't change the values of the origin object.
      */
-    @PublicApi
-    public Builder(FirebaseOptions options) {
+    public Builder(@NonNull FirebaseOptions options) {
       applicationId = options.applicationId;
       apiKey = options.apiKey;
       databaseUrl = options.databaseUrl;
@@ -81,19 +76,19 @@ public Builder(FirebaseOptions options) {
       projectId = options.projectId;
     }
 
-    @PublicApi
+    @NonNull
     public Builder setApiKey(@NonNull String apiKey) {
       this.apiKey = checkNotEmpty(apiKey, "ApiKey must be set.");
       return this;
     }
 
-    @PublicApi
+    @NonNull
     public Builder setApplicationId(@NonNull String applicationId) {
       this.applicationId = checkNotEmpty(applicationId, "ApplicationId must be set.");
       return this;
     }
 
-    @PublicApi
+    @NonNull
     public Builder setDatabaseUrl(@Nullable String databaseUrl) {
       this.databaseUrl = databaseUrl;
       return this;
@@ -101,31 +96,32 @@ public Builder setDatabaseUrl(@Nullable String databaseUrl) {
 
     /** @hide */
     // TODO: unhide once an API (AppInvite) starts reading it.
+    @NonNull
     @KeepForSdk
     public Builder setGaTrackingId(@Nullable String gaTrackingId) {
       this.gaTrackingId = gaTrackingId;
       return this;
     }
 
-    @PublicApi
+    @NonNull
     public Builder setGcmSenderId(@Nullable String gcmSenderId) {
       this.gcmSenderId = gcmSenderId;
       return this;
     }
 
-    @PublicApi
+    @NonNull
     public Builder setStorageBucket(@Nullable String storageBucket) {
       this.storageBucket = storageBucket;
       return this;
     }
 
-    @PublicApi
+    @NonNull
     public Builder setProjectId(@Nullable String projectId) {
       this.projectId = projectId;
       return this;
     }
 
-    @PublicApi
+    @NonNull
     public FirebaseOptions build() {
       return new FirebaseOptions(
           applicationId, apiKey, databaseUrl, gaTrackingId, gcmSenderId, storageBucket, projectId);
@@ -155,8 +151,8 @@ private FirebaseOptions(
    *
    * @return The populated options or null if applicationId is missing from resources.
    */
-  @PublicApi
-  public static FirebaseOptions fromResource(Context context) {
+  @Nullable
+  public static FirebaseOptions fromResource(@NonNull Context context) {
     StringResourceValueReader reader = new StringResourceValueReader(context);
     String applicationId = reader.getString(APP_ID_RESOURCE_NAME);
     if (TextUtils.isEmpty(applicationId)) {
@@ -176,19 +172,19 @@ public static FirebaseOptions fromResource(Context context) {
    * API key used for authenticating requests from your app, e.g.
    * AIzaSyDdVgKwhZl0sTTTLZ7iTmt1r3N2cJLnaDk, used to identify your app to Google servers.
    */
-  @PublicApi
+  @NonNull
   public String getApiKey() {
     return apiKey;
   }
 
   /** The Google App ID that is used to uniquely identify an instance of an app. */
-  @PublicApi
+  @NonNull
   public String getApplicationId() {
     return applicationId;
   }
 
   /** The database root URL, e.g. http://abc-xyz-123.firebaseio.com. */
-  @PublicApi
+  @Nullable
   public String getDatabaseUrl() {
     return databaseUrl;
   }
@@ -199,6 +195,7 @@ public String getDatabaseUrl() {
    * @hide
    */
   // TODO: unhide once an API (AppInvite) starts reading it.
+  @Nullable
   @KeepForSdk
   public String getGaTrackingId() {
     return gaTrackingId;
@@ -208,19 +205,19 @@ public String getGaTrackingId() {
    * The Project Number from the Google Developer's console, for example 012345678901, used to
    * configure Google Cloud Messaging.
    */
-  @PublicApi
+  @Nullable
   public String getGcmSenderId() {
     return gcmSenderId;
   }
 
   /** The Google Cloud Storage bucket name, e.g. abc-xyz-123.storage.firebase.com. */
-  @PublicApi
+  @Nullable
   public String getStorageBucket() {
     return storageBucket;
   }
 
   /** The Google Cloud project ID, e.g. my-project-1234 */
-  @PublicApi
+  @Nullable
   public String getProjectId() {
     return projectId;
   }
diff --git a/firebase-common/src/main/java/com/google/firebase/FirebaseTooManyRequestsException.java b/firebase-common/src/main/java/com/google/firebase/FirebaseTooManyRequestsException.java
index 8fbadb624..c1c82e1d5 100644
--- a/firebase-common/src/main/java/com/google/firebase/FirebaseTooManyRequestsException.java
+++ b/firebase-common/src/main/java/com/google/firebase/FirebaseTooManyRequestsException.java
@@ -14,17 +14,15 @@
 
 package com.google.firebase;
 
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
 
 /**
  * Exception thrown when a request to a Firebase service has been blocked due to having received too
  * many consecutive requests from the same device. Retry the request later to resolve.
  */
-@PublicApi
 public class FirebaseTooManyRequestsException extends FirebaseException {
 
-  @PublicApi
-  public FirebaseTooManyRequestsException(String message) {
+  public FirebaseTooManyRequestsException(@NonNull String message) {
     super(message);
   }
 }
diff --git a/firebase-common/src/main/java/com/google/firebase/annotations/package-info.java b/firebase-common/src/main/java/com/google/firebase/annotations/package-info.java
index fda9481b9..c9bcd5b8b 100644
--- a/firebase-common/src/main/java/com/google/firebase/annotations/package-info.java
+++ b/firebase-common/src/main/java/com/google/firebase/annotations/package-info.java
@@ -13,4 +13,4 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.annotations;
\ No newline at end of file
+package com.google.firebase.annotations;
diff --git a/firebase-common/src/main/java/com/google/firebase/components/Component.java b/firebase-common/src/main/java/com/google/firebase/components/Component.java
index 234455a41..3885f4f4d 100644
--- a/firebase-common/src/main/java/com/google/firebase/components/Component.java
+++ b/firebase-common/src/main/java/com/google/firebase/components/Component.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.components;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import com.google.android.gms.common.annotation.KeepForSdk;
 import com.google.android.gms.common.internal.Preconditions;
 import java.lang.annotation.Retention;
diff --git a/firebase-common/src/main/java/com/google/firebase/components/ComponentDiscovery.java b/firebase-common/src/main/java/com/google/firebase/components/ComponentDiscovery.java
index e9a2552ec..9a488c312 100644
--- a/firebase-common/src/main/java/com/google/firebase/components/ComponentDiscovery.java
+++ b/firebase-common/src/main/java/com/google/firebase/components/ComponentDiscovery.java
@@ -19,8 +19,8 @@
 import android.content.pm.PackageManager;
 import android.content.pm.ServiceInfo;
 import android.os.Bundle;
-import android.support.annotation.VisibleForTesting;
 import android.util.Log;
+import androidx.annotation.VisibleForTesting;
 import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.Collections;
diff --git a/firebase-common/src/main/java/com/google/firebase/components/ComponentDiscoveryService.java b/firebase-common/src/main/java/com/google/firebase/components/ComponentDiscoveryService.java
index 71ba5b4c6..216c5c79f 100644
--- a/firebase-common/src/main/java/com/google/firebase/components/ComponentDiscoveryService.java
+++ b/firebase-common/src/main/java/com/google/firebase/components/ComponentDiscoveryService.java
@@ -17,7 +17,7 @@
 import android.app.Service;
 import android.content.Intent;
 import android.os.IBinder;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.annotation.KeepForSdk;
 
 /** Container for component definition in <meta-data/>. */
diff --git a/firebase-common/src/main/java/com/google/firebase/components/ComponentRuntime.java b/firebase-common/src/main/java/com/google/firebase/components/ComponentRuntime.java
index 41b5b9bd4..77ab7a039 100644
--- a/firebase-common/src/main/java/com/google/firebase/components/ComponentRuntime.java
+++ b/firebase-common/src/main/java/com/google/firebase/components/ComponentRuntime.java
@@ -55,7 +55,11 @@ public ComponentRuntime(
     for (ComponentRegistrar registrar : registrars) {
       componentsToAdd.addAll(registrar.getComponents());
     }
-    Collections.addAll(componentsToAdd, additionalComponents);
+    for (Component<?> additionalComponent : additionalComponents) {
+      if (additionalComponent != null) {
+        componentsToAdd.add(additionalComponent);
+      }
+    }
 
     CycleDetector.detect(componentsToAdd);
 
diff --git a/firebase-common/src/main/java/com/google/firebase/components/Dependency.java b/firebase-common/src/main/java/com/google/firebase/components/Dependency.java
index 14f03a372..5fe86fee9 100644
--- a/firebase-common/src/main/java/com/google/firebase/components/Dependency.java
+++ b/firebase-common/src/main/java/com/google/firebase/components/Dependency.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.components;
 
-import android.support.annotation.IntDef;
+import androidx.annotation.IntDef;
 import com.google.android.gms.common.annotation.KeepForSdk;
 import com.google.android.gms.common.internal.Preconditions;
 import java.lang.annotation.Retention;
diff --git a/firebase-common/src/main/java/com/google/firebase/components/EventBus.java b/firebase-common/src/main/java/com/google/firebase/components/EventBus.java
index 929b4d432..70a0bf07a 100644
--- a/firebase-common/src/main/java/com/google/firebase/components/EventBus.java
+++ b/firebase-common/src/main/java/com/google/firebase/components/EventBus.java
@@ -16,7 +16,7 @@
 
 import static com.google.android.gms.common.internal.Preconditions.checkNotNull;
 
-import android.support.annotation.GuardedBy;
+import androidx.annotation.GuardedBy;
 import com.google.firebase.events.Event;
 import com.google.firebase.events.EventHandler;
 import com.google.firebase.events.Publisher;
diff --git a/firebase-common/src/main/java/com/google/firebase/components/Lazy.java b/firebase-common/src/main/java/com/google/firebase/components/Lazy.java
index 4db2ffc17..07498eaab 100644
--- a/firebase-common/src/main/java/com/google/firebase/components/Lazy.java
+++ b/firebase-common/src/main/java/com/google/firebase/components/Lazy.java
@@ -14,8 +14,8 @@
 
 package com.google.firebase.components;
 
-import android.support.annotation.RestrictTo;
-import android.support.annotation.VisibleForTesting;
+import androidx.annotation.RestrictTo;
+import androidx.annotation.VisibleForTesting;
 import com.google.firebase.inject.Provider;
 
 /**
diff --git a/firebase-common/src/main/java/com/google/firebase/heartbeatinfo/DefaultHeartBeatInfo.java b/firebase-common/src/main/java/com/google/firebase/heartbeatinfo/DefaultHeartBeatInfo.java
new file mode 100644
index 000000000..dfb81bf5c
--- /dev/null
+++ b/firebase-common/src/main/java/com/google/firebase/heartbeatinfo/DefaultHeartBeatInfo.java
@@ -0,0 +1,60 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.heartbeatinfo;
+
+import android.content.Context;
+import androidx.annotation.NonNull;
+import androidx.annotation.RestrictTo;
+import androidx.annotation.VisibleForTesting;
+import com.google.firebase.components.Component;
+import com.google.firebase.components.Dependency;
+
+/** Provides information as whether to send heart beat or not. */
+public class DefaultHeartBeatInfo implements HeartBeatInfo {
+
+  private HeartBeatInfoStorage storage;
+
+  private DefaultHeartBeatInfo(Context context) {
+    storage = HeartBeatInfoStorage.getInstance(context);
+  }
+
+  @VisibleForTesting
+  @RestrictTo(RestrictTo.Scope.TESTS)
+  DefaultHeartBeatInfo(HeartBeatInfoStorage testStorage) {
+    storage = testStorage;
+  }
+
+  @Override
+  public @NonNull HeartBeat getHeartBeatCode(@NonNull String heartBeatTag) {
+    long presentTime = System.currentTimeMillis();
+    boolean shouldSendSdkHB = storage.shouldSendSdkHeartBeat(heartBeatTag, presentTime);
+    boolean shouldSendGlobalHB = storage.shouldSendGlobalHeartBeat(presentTime);
+    if (shouldSendSdkHB && shouldSendGlobalHB) {
+      return HeartBeat.COMBINED;
+    } else if (shouldSendGlobalHB) {
+      return HeartBeat.GLOBAL;
+    } else if (shouldSendSdkHB) {
+      return HeartBeat.SDK;
+    }
+    return HeartBeat.NONE;
+  }
+
+  public static @NonNull Component<HeartBeatInfo> component() {
+    return Component.builder(HeartBeatInfo.class)
+        .add(Dependency.required(Context.class))
+        .factory(c -> new DefaultHeartBeatInfo(c.get(Context.class)))
+        .build();
+  }
+}
diff --git a/firebase-common/src/main/java/com/google/firebase/heartbeatinfo/HeartBeatInfo.java b/firebase-common/src/main/java/com/google/firebase/heartbeatinfo/HeartBeatInfo.java
new file mode 100644
index 000000000..0f961431d
--- /dev/null
+++ b/firebase-common/src/main/java/com/google/firebase/heartbeatinfo/HeartBeatInfo.java
@@ -0,0 +1,47 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.heartbeatinfo;
+
+import androidx.annotation.NonNull;
+
+/**
+ * Class provides information about heartbeats.
+ *
+ * <p>This exposes a function which returns the `HeartBeatCode` if both sdk heartbeat and global
+ * heartbeat needs to sent then HeartBeat.COMBINED is returned. if only sdk heart beat needs to be
+ * sent then HeartBeat.SDK is returned. if only global heart beat needs to be sent then
+ * HeartBeat.GLOBAL is returned. if no heart beat needs to be sent then HeartBeat.NONE is returned.
+ */
+public interface HeartBeatInfo {
+  enum HeartBeat {
+    NONE(0),
+    SDK(1),
+    GLOBAL(2),
+    COMBINED(3);
+
+    private final int code;
+
+    HeartBeat(int code) {
+      this.code = code;
+    }
+
+    public int getCode() {
+      return this.code;
+    }
+  }
+
+  @NonNull
+  HeartBeat getHeartBeatCode(@NonNull String heartBeatTag);
+}
diff --git a/firebase-common/src/main/java/com/google/firebase/heartbeatinfo/HeartBeatInfoStorage.java b/firebase-common/src/main/java/com/google/firebase/heartbeatinfo/HeartBeatInfoStorage.java
new file mode 100644
index 000000000..e3a665447
--- /dev/null
+++ b/firebase-common/src/main/java/com/google/firebase/heartbeatinfo/HeartBeatInfoStorage.java
@@ -0,0 +1,79 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.heartbeatinfo;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import androidx.annotation.RestrictTo;
+import androidx.annotation.VisibleForTesting;
+
+/**
+ * Class responsible for storing all heartbeat related information.
+ *
+ * <p>This exposes functions to check if there is a need to send global/sdk heartbeat.
+ */
+class HeartBeatInfoStorage {
+  private static HeartBeatInfoStorage instance = null;
+  private static final String GLOBAL = "fire-global";
+
+  private static final String preferencesName = "FirebaseAppHeartBeat";
+
+  private final SharedPreferences sharedPreferences;
+
+  private HeartBeatInfoStorage(Context applicationContext) {
+    this.sharedPreferences =
+        applicationContext.getSharedPreferences(preferencesName, Context.MODE_PRIVATE);
+  }
+
+  @VisibleForTesting
+  @RestrictTo(RestrictTo.Scope.TESTS)
+  HeartBeatInfoStorage(SharedPreferences preferences) {
+    this.sharedPreferences = preferences;
+  }
+
+  static synchronized HeartBeatInfoStorage getInstance(Context applicationContext) {
+    if (instance == null) {
+      instance = new HeartBeatInfoStorage(applicationContext);
+    }
+    return instance;
+  }
+
+  /*
+   Indicates whether or not we have to send a sdk heartbeat.
+   A sdk heartbeat is sent either when there is no heartbeat sent ever for the sdk or
+   when the last heartbeat send for the sdk was later than a day before.
+  */
+  synchronized boolean shouldSendSdkHeartBeat(String heartBeatTag, long millis) {
+    if (sharedPreferences.contains(heartBeatTag)) {
+      long timeElapsed = millis - sharedPreferences.getLong(heartBeatTag, -1);
+      if (timeElapsed >= (long) 1000 * 60 * 60 * 24) {
+        sharedPreferences.edit().putLong(heartBeatTag, millis).apply();
+        return true;
+      }
+      return false;
+    } else {
+      sharedPreferences.edit().putLong(heartBeatTag, millis).apply();
+      return true;
+    }
+  }
+
+  /*
+   Indicates whether or not we have to send a global heartbeat.
+   A global heartbeat is set only once per day.
+  */
+  synchronized boolean shouldSendGlobalHeartBeat(long millis) {
+    return shouldSendSdkHeartBeat(GLOBAL, millis);
+  }
+}
diff --git a/firebase-common/src/main/java/com/google/firebase/heartbeatinfo/package-info.java b/firebase-common/src/main/java/com/google/firebase/heartbeatinfo/package-info.java
new file mode 100644
index 000000000..a699490e3
--- /dev/null
+++ b/firebase-common/src/main/java/com/google/firebase/heartbeatinfo/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.firebase.heartbeatinfo;
diff --git a/firebase-common/src/main/java/com/google/firebase/internal/DataCollectionConfigStorage.java b/firebase-common/src/main/java/com/google/firebase/internal/DataCollectionConfigStorage.java
index de55ef27e..a408bb987 100644
--- a/firebase-common/src/main/java/com/google/firebase/internal/DataCollectionConfigStorage.java
+++ b/firebase-common/src/main/java/com/google/firebase/internal/DataCollectionConfigStorage.java
@@ -19,8 +19,8 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.os.Build;
-import android.support.annotation.VisibleForTesting;
-import android.support.v4.content.ContextCompat;
+import androidx.annotation.VisibleForTesting;
+import androidx.core.content.ContextCompat;
 import com.google.firebase.DataCollectionDefaultChange;
 import com.google.firebase.events.Event;
 import com.google.firebase.events.Publisher;
diff --git a/firebase-common/src/main/java/com/google/firebase/internal/package-info.java b/firebase-common/src/main/java/com/google/firebase/internal/package-info.java
new file mode 100644
index 000000000..3de193717
--- /dev/null
+++ b/firebase-common/src/main/java/com/google/firebase/internal/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.firebase.internal;
diff --git a/firebase-common/src/main/java/com/google/firebase/platforminfo/KotlinDetector.java b/firebase-common/src/main/java/com/google/firebase/platforminfo/KotlinDetector.java
new file mode 100644
index 000000000..74359aaeb
--- /dev/null
+++ b/firebase-common/src/main/java/com/google/firebase/platforminfo/KotlinDetector.java
@@ -0,0 +1,36 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.platforminfo;
+
+import androidx.annotation.Nullable;
+
+/**
+ * Detects presence of Kotlin stdlib on the classpath.
+ *
+ * <p>If it is present, it is inferred that the application or its subset is written in Kotlin.
+ */
+public final class KotlinDetector {
+  private KotlinDetector() {}
+
+  /** Returns the version of Kotlin stdlib if found, {@code null} otherwise. */
+  @Nullable
+  public static String detectVersion() {
+    try {
+      return kotlin.KotlinVersion.CURRENT.toString();
+    } catch (NoClassDefFoundError ex) {
+      return null;
+    }
+  }
+}
diff --git a/firebase-common/src/main/java/com/google/firebase/provider/FirebaseInitProvider.java b/firebase-common/src/main/java/com/google/firebase/provider/FirebaseInitProvider.java
index f8ce1f2f3..e4db850fa 100644
--- a/firebase-common/src/main/java/com/google/firebase/provider/FirebaseInitProvider.java
+++ b/firebase-common/src/main/java/com/google/firebase/provider/FirebaseInitProvider.java
@@ -21,16 +21,14 @@
 import android.content.pm.ProviderInfo;
 import android.database.Cursor;
 import android.net.Uri;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.firebase.FirebaseApp;
-import com.google.firebase.annotations.PublicApi;
 
 /** Initializes Firebase APIs at app startup time. */
-@PublicApi
 public class FirebaseInitProvider extends ContentProvider {
 
   private static final String TAG = "FirebaseInitProvider";
@@ -41,7 +39,7 @@
       "com.google.firebase.firebaseinitprovider";
 
   @Override
-  public void attachInfo(Context context, ProviderInfo info) {
+  public void attachInfo(@NonNull Context context, @NonNull ProviderInfo info) {
     // super.attachInfo calls onCreate. Fail as early as possible.
     checkContentProviderAuthority(info);
     super.attachInfo(context, info);
@@ -74,29 +72,38 @@ private static void checkContentProviderAuthority(@NonNull ProviderInfo info) {
   @Nullable
   @Override
   public Cursor query(
-      Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
+      @NonNull Uri uri,
+      @Nullable String[] projection,
+      @Nullable String selection,
+      @Nullable String[] selectionArgs,
+      @Nullable String sortOrder) {
     return null;
   }
 
   @Nullable
   @Override
-  public String getType(Uri uri) {
+  public String getType(@NonNull Uri uri) {
     return null;
   }
 
   @Nullable
   @Override
-  public Uri insert(Uri uri, ContentValues values) {
+  public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {
     return null;
   }
 
   @Override
-  public int delete(Uri uri, String selection, String[] selectionArgs) {
+  public int delete(
+      @NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {
     return 0;
   }
 
   @Override
-  public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+  public int update(
+      @NonNull Uri uri,
+      @Nullable ContentValues values,
+      @Nullable String selection,
+      @Nullable String[] selectionArgs) {
     return 0;
   }
 }
diff --git a/firebase-common/src/test/java/com/google/firebase/DataCollectionDefaultEnabledTest.java b/firebase-common/src/test/java/com/google/firebase/DataCollectionDefaultEnabledTest.java
index 8deb12309..9f9cf5d7b 100644
--- a/firebase-common/src/test/java/com/google/firebase/DataCollectionDefaultEnabledTest.java
+++ b/firebase-common/src/test/java/com/google/firebase/DataCollectionDefaultEnabledTest.java
@@ -20,12 +20,12 @@
 import static com.google.firebase.DataCollectionTestUtil.withApp;
 
 import android.content.SharedPreferences;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.firebase.internal.DataCollectionConfigStorage;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(AndroidJUnit4.class)
 public class DataCollectionDefaultEnabledTest {
 
   @Test
diff --git a/firebase-common/src/test/java/com/google/firebase/DataCollectionTestUtil.java b/firebase-common/src/test/java/com/google/firebase/DataCollectionTestUtil.java
index 878227913..4942d6cc7 100644
--- a/firebase-common/src/test/java/com/google/firebase/DataCollectionTestUtil.java
+++ b/firebase-common/src/test/java/com/google/firebase/DataCollectionTestUtil.java
@@ -16,9 +16,9 @@
 
 import android.content.Context;
 import android.content.SharedPreferences;
+import androidx.test.core.app.ApplicationProvider;
 import com.google.firebase.internal.DataCollectionConfigStorage;
 import java.util.function.Consumer;
-import org.robolectric.RuntimeEnvironment;
 
 final class DataCollectionTestUtil {
   private static final String APP_NAME = "someApp";
@@ -37,8 +37,7 @@ static void withApp(Consumer<FirebaseApp> callable) {
 
   static void withApp(String name, Consumer<FirebaseApp> callable) {
     FirebaseApp app =
-        FirebaseApp.initializeApp(
-            RuntimeEnvironment.application.getApplicationContext(), OPTIONS, name);
+        FirebaseApp.initializeApp(ApplicationProvider.getApplicationContext(), OPTIONS, name);
     try {
       callable.accept(app);
     } finally {
@@ -47,9 +46,10 @@ static void withApp(String name, Consumer<FirebaseApp> callable) {
   }
 
   static SharedPreferences getSharedPreferences() {
-    return RuntimeEnvironment.application.getSharedPreferences(
-        FIREBASE_APP_PREFS + FirebaseApp.getPersistenceKey(APP_NAME, OPTIONS),
-        Context.MODE_PRIVATE);
+    return ApplicationProvider.getApplicationContext()
+        .getSharedPreferences(
+            FIREBASE_APP_PREFS + FirebaseApp.getPersistenceKey(APP_NAME, OPTIONS),
+            Context.MODE_PRIVATE);
   }
 
   static void setSharedPreferencesTo(boolean enabled) {
diff --git a/firebase-common/src/test/java/com/google/firebase/components/ComponentRuntimeTest.java b/firebase-common/src/test/java/com/google/firebase/components/ComponentRuntimeTest.java
index ba081e8ab..42265dbf6 100644
--- a/firebase-common/src/test/java/com/google/firebase/components/ComponentRuntimeTest.java
+++ b/firebase-common/src/test/java/com/google/firebase/components/ComponentRuntimeTest.java
@@ -114,7 +114,7 @@ public void container_withValidDependencyGraph_shouldProperlyInjectComponents()
 
     ComponentTwo componentTwo = runtime.get(ComponentTwo.class);
     assertThat(componentTwo.getOne()).isNotNull();
-    assertThat(componentTwo.getOne().getTracker()).isSameAs(initTracker);
+    assertThat(componentTwo.getOne().getTracker()).isSameInstanceAs(initTracker);
 
     assertThat(initTracker.isInitialized()).isTrue();
   }
@@ -193,7 +193,7 @@ public void container_withCyclicProviderDependency_shouldProperlyInitialize() {
     assertThat(one.cyclicTwo).isNotNull();
     Provider<CyclicOne> oneProvider = one.cyclicTwo.cyclicOne;
     assertThat(oneProvider).isNotNull();
-    assertThat(oneProvider.get()).isSameAs(one);
+    assertThat(oneProvider.get()).isSameInstanceAs(one);
   }
 
   @Test
@@ -230,8 +230,8 @@ public void container_shouldExposeAllProvidedInterfacesOfAComponent() {
     Provider<Parent> parent = runtime.getProvider(Parent.class);
     assertThat(parent).isNotNull();
 
-    assertThat(child).isSameAs(parent);
-    assertThat(child.get()).isSameAs(parent.get());
+    assertThat(child).isSameInstanceAs(parent);
+    assertThat(child.get()).isSameInstanceAs(parent.get());
   }
 
   @Test
diff --git a/firebase-common/src/test/java/com/google/firebase/components/ComponentTest.java b/firebase-common/src/test/java/com/google/firebase/components/ComponentTest.java
index 33cb06b8d..a9f34cd79 100644
--- a/firebase-common/src/test/java/com/google/firebase/components/ComponentTest.java
+++ b/firebase-common/src/test/java/com/google/firebase/components/ComponentTest.java
@@ -42,7 +42,7 @@ public void of_withMultipleInterfaces_shouldSetCorrectDefaults() {
     assertThat(component.isAlwaysEager()).isFalse();
     assertThat(component.isEagerInDefaultApp()).isFalse();
     assertThat(component.getDependencies()).isEmpty();
-    assertThat(component.getFactory().create(null)).isSameAs(testClass);
+    assertThat(component.getFactory().create(null)).isSameInstanceAs(testClass);
   }
 
   @Test
@@ -193,6 +193,6 @@ public void build_withNoFactoryProvided_shouldThrow() {
   public void getFactory_shouldReturnFactorySetInBuilder() {
     Component<TestClass> component =
         Component.builder(TestClass.class).factory(nullFactory).build();
-    assertThat(component.getFactory()).isSameAs(nullFactory);
+    assertThat(component.getFactory()).isSameInstanceAs(nullFactory);
   }
 }
diff --git a/firebase-common/src/test/java/com/google/firebase/components/EventBusTest.java b/firebase-common/src/test/java/com/google/firebase/components/EventBusTest.java
index 60761cf10..1bde260cb 100644
--- a/firebase-common/src/test/java/com/google/firebase/components/EventBusTest.java
+++ b/firebase-common/src/test/java/com/google/firebase/components/EventBusTest.java
@@ -21,7 +21,7 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.google.firebase.events.Event;
 import com.google.firebase.events.EventHandler;
 import java.util.concurrent.Executor;
diff --git a/firebase-common/src/test/java/com/google/firebase/components/LazyTest.java b/firebase-common/src/test/java/com/google/firebase/components/LazyTest.java
index 6b5ef83d6..4f93378b6 100644
--- a/firebase-common/src/test/java/com/google/firebase/components/LazyTest.java
+++ b/firebase-common/src/test/java/com/google/firebase/components/LazyTest.java
@@ -46,7 +46,7 @@ public void get_whenLazyIsInitializedWithValue_shouldReturnTheValue() {
     Object instance = new Object();
     Lazy<Object> lazy = new Lazy<>(instance);
 
-    assertThat(lazy.get()).isSameAs(instance);
+    assertThat(lazy.get()).isSameInstanceAs(instance);
   }
 
   @Test
@@ -56,7 +56,7 @@ public void get_shouldDelegateToFactory() {
 
     when(mockProvider.get()).thenReturn(instance);
 
-    assertThat(lazy.get()).isSameAs(instance);
+    assertThat(lazy.get()).isSameInstanceAs(instance);
 
     verify(mockProvider, times(1)).get();
   }
diff --git a/firebase-common/src/test/java/com/google/firebase/components/RestrictedComponentContainerTest.java b/firebase-common/src/test/java/com/google/firebase/components/RestrictedComponentContainerTest.java
index 6989e440a..6edb19ff1 100644
--- a/firebase-common/src/test/java/com/google/firebase/components/RestrictedComponentContainerTest.java
+++ b/firebase-common/src/test/java/com/google/firebase/components/RestrictedComponentContainerTest.java
@@ -57,7 +57,7 @@ public void get_withAllowedClass_shouldReturnAnInstanceOfThatClass() {
     Float value = 1.0f;
     when(delegate.get(Float.class)).thenReturn(value);
 
-    assertThat(container.get(Float.class)).isSameAs(value);
+    assertThat(container.get(Float.class)).isSameInstanceAs(value);
     verify(delegate).get(Float.class);
   }
 
@@ -96,7 +96,7 @@ public void getProvider_withAllowedClass_shouldReturnAnInstanceOfThatClass() {
     Double value = 3.0d;
     when(delegate.getProvider(Double.class)).thenReturn(new Lazy<>(value));
 
-    assertThat(container.getProvider(Double.class).get()).isSameAs(value);
+    assertThat(container.getProvider(Double.class).get()).isSameInstanceAs(value);
     verify(delegate).getProvider(Double.class);
   }
 
@@ -125,7 +125,7 @@ public void setOf_withAllowedClass_shouldReturnExpectedSet() {
     Set<Long> set = Collections.emptySet();
     when(delegate.setOf(Long.class)).thenReturn(set);
 
-    assertThat(container.setOf(Long.class)).isSameAs(set);
+    assertThat(container.setOf(Long.class)).isSameInstanceAs(set);
     verify(delegate).setOf(Long.class);
   }
 
@@ -144,7 +144,7 @@ public void setOfProvider_withAllowedClass_shouldReturnExpectedSet() {
     Set<Boolean> set = Collections.emptySet();
     when(delegate.setOfProvider(Boolean.class)).thenReturn(new Lazy<>(set));
 
-    assertThat(container.setOfProvider(Boolean.class).get()).isSameAs(set);
+    assertThat(container.setOfProvider(Boolean.class).get()).isSameInstanceAs(set);
     verify(delegate).setOfProvider(Boolean.class);
   }
 
diff --git a/firebase-common/src/test/java/com/google/firebase/heartbeatinfo/DefaultHeartBeatInfoTest.java b/firebase-common/src/test/java/com/google/firebase/heartbeatinfo/DefaultHeartBeatInfoTest.java
new file mode 100644
index 000000000..ff1e6222a
--- /dev/null
+++ b/firebase-common/src/test/java/com/google/firebase/heartbeatinfo/DefaultHeartBeatInfoTest.java
@@ -0,0 +1,63 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.heartbeatinfo;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class DefaultHeartBeatInfoTest {
+  private String testSdk = "fire-test";
+  private HeartBeatInfoStorage storage = mock(HeartBeatInfoStorage.class);
+  private DefaultHeartBeatInfo heartBeatInfo = new DefaultHeartBeatInfo(storage);
+
+  @Test
+  public void getHeartBeatCode_noHeartBeat() {
+    when(storage.shouldSendSdkHeartBeat(anyString(), anyLong())).thenReturn(Boolean.FALSE);
+    heartBeatInfo.getHeartBeatCode(testSdk);
+    assertThat(heartBeatInfo.getHeartBeatCode(testSdk).getCode()).isEqualTo(0);
+  }
+
+  @Test
+  public void getHeartBeatCode_sdkHeartBeat() {
+    when(storage.shouldSendSdkHeartBeat(anyString(), anyLong())).thenReturn(Boolean.TRUE);
+    when(storage.shouldSendGlobalHeartBeat(anyLong())).thenReturn(Boolean.FALSE);
+    heartBeatInfo.getHeartBeatCode(testSdk);
+    assertThat(heartBeatInfo.getHeartBeatCode(testSdk).getCode()).isEqualTo(1);
+  }
+
+  @Test
+  public void getHeartBeatCode_globalHeartBeat() {
+    when(storage.shouldSendSdkHeartBeat(anyString(), anyLong())).thenReturn(Boolean.FALSE);
+    when(storage.shouldSendGlobalHeartBeat(anyLong())).thenReturn(Boolean.TRUE);
+    heartBeatInfo.getHeartBeatCode(testSdk);
+    assertThat(heartBeatInfo.getHeartBeatCode(testSdk).getCode()).isEqualTo(2);
+  }
+
+  @Test
+  public void getHeartBeatCode_combinedHeartBeat() {
+    when(storage.shouldSendSdkHeartBeat(anyString(), anyLong())).thenReturn(Boolean.TRUE);
+    when(storage.shouldSendGlobalHeartBeat(anyLong())).thenReturn(Boolean.TRUE);
+    heartBeatInfo.getHeartBeatCode(testSdk);
+    assertThat(heartBeatInfo.getHeartBeatCode(testSdk).getCode()).isEqualTo(3);
+  }
+}
diff --git a/firebase-common/src/test/java/com/google/firebase/heartbeatinfo/HeartBeatInfoStorageTest.java b/firebase-common/src/test/java/com/google/firebase/heartbeatinfo/HeartBeatInfoStorageTest.java
new file mode 100644
index 000000000..6e9c639b1
--- /dev/null
+++ b/firebase-common/src/test/java/com/google/firebase/heartbeatinfo/HeartBeatInfoStorageTest.java
@@ -0,0 +1,70 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.heartbeatinfo;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.runner.AndroidJUnit4;
+import org.junit.After;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class HeartBeatInfoStorageTest {
+  private final String testSdk = "testSdk";
+  private final String GLOBAL = "fire-global";
+  private static Context applicationContext = ApplicationProvider.getApplicationContext();
+  private static SharedPreferences sharedPreferences =
+      applicationContext.getSharedPreferences("test", Context.MODE_PRIVATE);
+  private HeartBeatInfoStorage heartBeatInfoStorage = new HeartBeatInfoStorage(sharedPreferences);
+
+  @After
+  public void tearDown() {
+    sharedPreferences.edit().clear().apply();
+  }
+
+  @Test
+  public void shouldSendSdkHeartBeat_answerIsNo() {
+    sharedPreferences.edit().putLong(testSdk, 1).apply();
+    assertThat(heartBeatInfoStorage.shouldSendSdkHeartBeat(testSdk, 1)).isFalse();
+  }
+
+  @Test
+  public void shouldSendSdkHeartBeat_answerIsYes() {
+    long currentTime = System.currentTimeMillis();
+    assertThat(heartBeatInfoStorage.shouldSendSdkHeartBeat(testSdk, 1)).isTrue();
+    assertThat(sharedPreferences.getLong(testSdk, -1)).isEqualTo(1);
+    assertThat(heartBeatInfoStorage.shouldSendSdkHeartBeat(testSdk, currentTime)).isTrue();
+    assertThat(sharedPreferences.getLong(testSdk, -1)).isEqualTo(currentTime);
+  }
+
+  @Test
+  public void shouldSendGlobalHeartBeat_answerIsNo() {
+    sharedPreferences.edit().putLong(GLOBAL, 1).apply();
+    assertThat(heartBeatInfoStorage.shouldSendGlobalHeartBeat(1)).isFalse();
+  }
+
+  @Test
+  public void shouldSendGlobalHeartBeat_answerIsYes() {
+    long currentTime = System.currentTimeMillis();
+    assertThat(heartBeatInfoStorage.shouldSendGlobalHeartBeat(1)).isTrue();
+    assertThat(sharedPreferences.getLong(GLOBAL, -1)).isEqualTo(1);
+    assertThat(heartBeatInfoStorage.shouldSendGlobalHeartBeat(currentTime)).isTrue();
+    assertThat(sharedPreferences.getLong(GLOBAL, -1)).isEqualTo(currentTime);
+  }
+}
diff --git a/firebase-common/src/test/resources/NoAutoDataCollectionAndroidManifest.xml b/firebase-common/src/test/resources/NoAutoDataCollectionAndroidManifest.xml
deleted file mode 100644
index 08fea8b39..000000000
--- a/firebase-common/src/test/resources/NoAutoDataCollectionAndroidManifest.xml
+++ /dev/null
@@ -1,14 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.google.firebase">
-    <uses-sdk android:minSdkVersion="14" />
-    <application>
-        <meta-data android:name="firebase_data_collection_default_enabled"
-            android:value="false" />
-
-        <service android:name="com.google.firebase.components.ComponentDiscoveryService">
-            <meta-data
-                android:name="com.google.firebase.components:com.google.firebase.DataCollectionDefaultChangeRegistrar"
-                android:value="com.google.firebase.components.ComponentRegistrar" />
-        </service>
-    </application>
-</manifest>
diff --git a/firebase-config/api.txt b/firebase-config/api.txt
new file mode 100644
index 000000000..46d97f36a
--- /dev/null
+++ b/firebase-config/api.txt
@@ -0,0 +1,100 @@
+// Signature format: 2.0
+package com.google.firebase.remoteconfig {
+
+  public class FirebaseRemoteConfig {
+    method @NonNull public Task<Boolean> activate();
+    method @Deprecated public boolean activateFetched();
+    method @NonNull public Task<FirebaseRemoteConfigInfo> ensureInitialized();
+    method @NonNull public Task<Void> fetch();
+    method @NonNull public Task<Void> fetch(long);
+    method @NonNull public Task<Boolean> fetchAndActivate();
+    method @NonNull public Map<String,FirebaseRemoteConfigValue> getAll();
+    method public boolean getBoolean(@NonNull String);
+    method @NonNull public byte[] getByteArray(@NonNull String);
+    method public double getDouble(@NonNull String);
+    method @NonNull public com.google.firebase.remoteconfig.FirebaseRemoteConfigInfo getInfo();
+    method @NonNull public static com.google.firebase.remoteconfig.FirebaseRemoteConfig getInstance();
+    method @NonNull public static com.google.firebase.remoteconfig.FirebaseRemoteConfig getInstance(@NonNull FirebaseApp);
+    method @NonNull public Set<String> getKeysByPrefix(@NonNull String);
+    method public long getLong(@NonNull String);
+    method @NonNull public String getString(@NonNull String);
+    method @NonNull public com.google.firebase.remoteconfig.FirebaseRemoteConfigValue getValue(@NonNull String);
+    method @NonNull public Task<Void> reset();
+    method @Deprecated public void setConfigSettings(@NonNull com.google.firebase.remoteconfig.FirebaseRemoteConfigSettings);
+    method @NonNull public Task<Void> setConfigSettingsAsync(@NonNull com.google.firebase.remoteconfig.FirebaseRemoteConfigSettings);
+    method @Deprecated public void setDefaults(@NonNull Map<String,Object>);
+    method @Deprecated public void setDefaults(int);
+    method @NonNull public Task<Void> setDefaultsAsync(@NonNull Map<String,Object>);
+    method @NonNull public Task<Void> setDefaultsAsync(int);
+    field public static final boolean DEFAULT_VALUE_FOR_BOOLEAN = false;
+    field public static final byte[] DEFAULT_VALUE_FOR_BYTE_ARRAY;
+    field public static final double DEFAULT_VALUE_FOR_DOUBLE = 0.0;
+    field public static final long DEFAULT_VALUE_FOR_LONG = 0L; // 0x0L
+    field public static final String DEFAULT_VALUE_FOR_STRING;
+    field public static final int LAST_FETCH_STATUS_FAILURE = 1; // 0x1
+    field public static final int LAST_FETCH_STATUS_NO_FETCH_YET = 0; // 0x0
+    field public static final int LAST_FETCH_STATUS_SUCCESS = -1; // 0xffffffff
+    field public static final int LAST_FETCH_STATUS_THROTTLED = 2; // 0x2
+    field public static final int VALUE_SOURCE_DEFAULT = 1; // 0x1
+    field public static final int VALUE_SOURCE_REMOTE = 2; // 0x2
+    field public static final int VALUE_SOURCE_STATIC = 0; // 0x0
+  }
+
+  public class FirebaseRemoteConfigClientException extends com.google.firebase.remoteconfig.FirebaseRemoteConfigException {
+    ctor public FirebaseRemoteConfigClientException(@NonNull String);
+    ctor public FirebaseRemoteConfigClientException(@NonNull String, @Nullable Throwable);
+  }
+
+  public class FirebaseRemoteConfigException {
+    ctor public FirebaseRemoteConfigException(@NonNull String);
+    ctor public FirebaseRemoteConfigException(@NonNull String, @Nullable Throwable);
+  }
+
+  @Deprecated public class FirebaseRemoteConfigFetchException extends com.google.firebase.remoteconfig.FirebaseRemoteConfigException {
+    ctor @Deprecated public FirebaseRemoteConfigFetchException(@NonNull String);
+    ctor @Deprecated public FirebaseRemoteConfigFetchException(@NonNull String, @Nullable Throwable);
+  }
+
+  public class FirebaseRemoteConfigFetchThrottledException extends com.google.firebase.remoteconfig.FirebaseRemoteConfigFetchException {
+    ctor public FirebaseRemoteConfigFetchThrottledException(long);
+    method public long getThrottleEndTimeMillis();
+  }
+
+  public interface FirebaseRemoteConfigInfo {
+    method @NonNull public com.google.firebase.remoteconfig.FirebaseRemoteConfigSettings getConfigSettings();
+    method public long getFetchTimeMillis();
+    method public int getLastFetchStatus();
+  }
+
+  public class FirebaseRemoteConfigServerException extends com.google.firebase.remoteconfig.FirebaseRemoteConfigException {
+    ctor public FirebaseRemoteConfigServerException(int, @NonNull String);
+    ctor public FirebaseRemoteConfigServerException(int, @NonNull String, @Nullable Throwable);
+    method public int getHttpStatusCode();
+  }
+
+  public class FirebaseRemoteConfigSettings {
+    method public long getFetchTimeoutInSeconds();
+    method public long getMinimumFetchIntervalInSeconds();
+    method @Deprecated public boolean isDeveloperModeEnabled();
+    method @NonNull public com.google.firebase.remoteconfig.FirebaseRemoteConfigSettings.Builder toBuilder();
+  }
+
+  public static class FirebaseRemoteConfigSettings.Builder {
+    ctor public FirebaseRemoteConfigSettings.Builder();
+    method @NonNull public com.google.firebase.remoteconfig.FirebaseRemoteConfigSettings build();
+    method @Deprecated @NonNull public com.google.firebase.remoteconfig.FirebaseRemoteConfigSettings.Builder setDeveloperModeEnabled(boolean);
+    method @NonNull public com.google.firebase.remoteconfig.FirebaseRemoteConfigSettings.Builder setFetchTimeoutInSeconds(long);
+    method @NonNull public com.google.firebase.remoteconfig.FirebaseRemoteConfigSettings.Builder setMinimumFetchIntervalInSeconds(long);
+  }
+
+  public interface FirebaseRemoteConfigValue {
+    method public boolean asBoolean();
+    method @NonNull public byte[] asByteArray();
+    method public double asDouble();
+    method public long asLong();
+    method @NonNull public String asString();
+    method public int getSource();
+  }
+
+}
+
diff --git a/firebase-config/bandwagoner/.gitignore b/firebase-config/bandwagoner/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/firebase-config/bandwagoner/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/firebase-config/bandwagoner/bandwagoner.gradle b/firebase-config/bandwagoner/bandwagoner.gradle
new file mode 100644
index 000000000..0fd925d38
--- /dev/null
+++ b/firebase-config/bandwagoner/bandwagoner.gradle
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2018 Google LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+apply plugin: 'com.android.application'
+apply plugin: com.google.firebase.gradle.plugins.ci.device.FirebaseTestLabPlugin
+
+android {
+    compileSdkVersion 28
+    lintOptions {
+        abortOnError false
+    }
+    defaultConfig {
+        applicationId "com.googletest.firebase.remoteconfig.bandwagoner"
+        minSdkVersion 16
+        targetSdkVersion 28
+        versionCode 1
+        versionName "1.0"
+        multiDexEnabled true
+
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+    }
+
+    testOptions {
+        animationsDisabled = true
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
+        }
+    }
+
+    // Required for lambda expressions.
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+}
+
+firebaseTestLab {
+    device 'model=walleye,version=26,locale=en,orientation=portrait'
+
+}
+
+dependencies {
+    implementation project(":firebase-config")
+    // This is required since a project dependency on frc does not expose the Apis of its "implementation" dependencies.
+    // The alternative would be to make common an "api" dep of remote-config.
+    // It should not matter for released artifacts.
+    implementation project(":firebase-common")
+
+    implementation('com.google.firebase:firebase-iid:18.0.0') {
+        exclude group: 'com.google.firebase', module: 'firebase-common'
+    }
+
+    implementation 'com.google.android.gms:play-services-basement:17.0.0'
+    implementation 'com.google.android.gms:play-services-tasks:17.0.0'
+
+    // Support Libraries
+    implementation 'com.google.guava:guava:27.1-android'
+    implementation 'androidx.legacy:legacy-support-v4:1.0.0'
+
+    implementation 'androidx.appcompat:appcompat:1.0.2'
+    implementation 'androidx.annotation:annotation:1.1.0'
+    implementation 'androidx.core:core:1.0.2'
+    implementation 'com.google.android.material:material:1.0.0'
+    api 'com.google.auto.value:auto-value-annotations:1.6.5'
+    annotationProcessor 'com.google.auto.value:auto-value:1.6.2'
+    implementation 'androidx.test.espresso:espresso-idling-resource:3.2.0'
+
+    androidTestImplementation 'androidx.test.espresso:espresso-idling-resource:3.2.0'
+    androidTestImplementation 'androidx.test:rules:1.2.0'
+    androidTestImplementation 'androidx.test:runner:1.2.0'
+    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
+}
+
+ext.packageName = "com.googletest.firebase.remoteconfig.bandwagoner"
+apply from: '../../gradle/googleServices.gradle'
diff --git a/firebase-config/bandwagoner/proguard-rules.pro b/firebase-config/bandwagoner/proguard-rules.pro
new file mode 100644
index 000000000..db68ab40f
--- /dev/null
+++ b/firebase-config/bandwagoner/proguard-rules.pro
@@ -0,0 +1,21 @@
+# Add project specific ProGuard rules here.
+# You can control the set of applied configuration files using the
+# proguardFiles setting in bandwagoneragoner.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
diff --git a/test-apps/database-test-app/src/main/AndroidManifest.xml b/firebase-config/bandwagoner/src/androidTest/AndroidManifest.xml
similarity index 59%
rename from test-apps/database-test-app/src/main/AndroidManifest.xml
rename to firebase-config/bandwagoner/src/androidTest/AndroidManifest.xml
index 487771c30..8e37b4c31 100644
--- a/test-apps/database-test-app/src/main/AndroidManifest.xml
+++ b/firebase-config/bandwagoner/src/androidTest/AndroidManifest.xml
@@ -16,16 +16,19 @@
   -->
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.google.firebase.testapps.database">
-    <application
-        android:allowBackup="true"
-        android:name="android.support.multidex.MultiDexApplication">
-        <activity
-            android:name=".TestActivity">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
+    package="com.googletest.firebase.remoteconfig.bandwagoner.test"
+    android:versionCode="1"
+    android:versionName="1.0" >
+
+  <uses-sdk
+      android:minSdkVersion="16"
+      android:targetSdkVersion="26" />
+
+  <application>
+    <uses-library android:name="android.test.runner" />
+  </application>
+
+  <instrumentation
+      android:name="com.google.android.apps.common.testing.testrunner.Google3InstrumentationTestRunner"
+      android:targetPackage="com.googletest.firebase.remoteconfig.bandwagoner"/>
 </manifest>
diff --git a/firebase-config/bandwagoner/src/androidTest/java/com/googletest/firebase/remoteconfig/bandwagoner/BandwagonerEspressoTest.java b/firebase-config/bandwagoner/src/androidTest/java/com/googletest/firebase/remoteconfig/bandwagoner/BandwagonerEspressoTest.java
new file mode 100644
index 000000000..7063f5bf3
--- /dev/null
+++ b/firebase-config/bandwagoner/src/androidTest/java/com/googletest/firebase/remoteconfig/bandwagoner/BandwagonerEspressoTest.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2018 Google LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.googletest.firebase.remoteconfig.bandwagoner;
+
+import static androidx.test.espresso.Espresso.onView;
+import static androidx.test.espresso.action.ViewActions.clearText;
+import static androidx.test.espresso.action.ViewActions.click;
+import static androidx.test.espresso.action.ViewActions.typeText;
+import static androidx.test.espresso.assertion.ViewAssertions.matches;
+import static androidx.test.espresso.matcher.ViewMatchers.withId;
+import static androidx.test.espresso.matcher.ViewMatchers.withText;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.containsString;
+
+import android.content.Context;
+import androidx.test.espresso.IdlingRegistry;
+import androidx.test.espresso.IdlingResource;
+import androidx.test.rule.ActivityTestRule;
+import androidx.test.runner.AndroidJUnit4;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * All the Firebase Remote Config (FRC) SDK integration tests that can be run with just the 3P API.
+ *
+ * @author Miraziz Yusupov
+ */
+@RunWith(AndroidJUnit4.class)
+public class BandwagonerEspressoTest {
+  private static final String KEY_FOR_STRING = "string_key";
+  private static final String STRING_TYPE = "String";
+  private static final String STRING_STATIC_DEFAULT_VALUE = "";
+  private static final String STRING_REMOTE_DEFAULT_VALUE = "default_v1_remote_string_value";
+
+  private IdlingResource idlingResource;
+
+  @Rule
+  public ActivityTestRule<MainActivity> activityTestRule =
+      new ActivityTestRule<>(MainActivity.class);
+
+  @Before
+  public void setUp() {
+    idlingResource = IdlingResourceManager.getInstance();
+    IdlingRegistry.getInstance().register(idlingResource);
+
+    onView(withId(R.id.reset_frc_button)).perform(click());
+  }
+
+  @Test
+  public void getDataTypes_returnsStaticDefaults() throws InterruptedException {
+    verifyKeyValuePair(KEY_FOR_STRING, STRING_TYPE, "");
+  }
+
+  @Test
+  public void activateFetchedWithoutFetching_activateFetchedReturnsFalse()
+      throws InterruptedException {
+
+    onView(withId(R.id.activate_fetched_button)).perform(click());
+    onView(withId(R.id.api_call_results))
+        .check(
+            matches(withText(allOf(containsString("activateFetched"), containsString("false!")))));
+  }
+
+  @Test
+  public void fetchAndActivateFetchedTwice_activateFetchedReturnsFalse()
+      throws InterruptedException {
+
+    onView(withId(R.id.fetch_button)).perform(click());
+
+    onView(withId(R.id.activate_fetched_button)).perform(click());
+    onView(withId(R.id.api_call_results))
+        .check(
+            matches(
+                withText(allOf(containsString("activateFetched"), containsString("successful!")))));
+
+    onView(withId(R.id.activate_fetched_button)).perform(click());
+    onView(withId(R.id.api_call_results))
+        .check(
+            matches(withText(allOf(containsString("activateFetched"), containsString("false!")))));
+  }
+
+  @Test
+  public void fetchAndGetString_returnsStaticDefault() throws InterruptedException {
+
+    verifyKeyValuePair(KEY_FOR_STRING, STRING_TYPE, STRING_STATIC_DEFAULT_VALUE);
+
+    onView(withId(R.id.fetch_button)).perform(click());
+
+    verifyKeyValuePair(KEY_FOR_STRING, STRING_TYPE, STRING_STATIC_DEFAULT_VALUE);
+  }
+
+  @Test
+  public void fetchActivateFetchedAndGetString_returnsRemoteValue() throws InterruptedException {
+
+    verifyKeyValuePair(KEY_FOR_STRING, STRING_TYPE, STRING_STATIC_DEFAULT_VALUE);
+
+    onView(withId(R.id.fetch_button)).perform(click());
+    onView(withId(R.id.activate_fetched_button)).perform(click());
+
+    verifyKeyValuePair(KEY_FOR_STRING, STRING_TYPE, STRING_REMOTE_DEFAULT_VALUE);
+  }
+
+  private void verifyKeyValuePair(String key, String dataType, String expectedValue)
+      throws InterruptedException {
+
+    onView(withId(R.id.frc_parameter_key)).perform(click(), clearText(), typeText(key));
+    onView(withText("Get " + dataType)).perform(click());
+
+    String expectedResult = String.format("%s: (%s, %s)", dataType, key, expectedValue);
+    onView(withId(R.id.frc_parameter_value))
+        .check(matches(withText(containsString(expectedResult))));
+  }
+
+  @After
+  public void cleanUp() {
+    clearIdlingResources();
+    clearCacheFiles();
+  }
+
+  private void clearIdlingResources() {
+    IdlingRegistry.getInstance().unregister(idlingResource);
+  }
+
+  private void clearCacheFiles() {
+    Context context = activityTestRule.getActivity().getApplicationContext();
+
+    for (String fileName : context.fileList()) {
+      context.deleteFile(fileName);
+    }
+  }
+}
diff --git a/firebase-config/bandwagoner/src/main/AndroidManifest.xml b/firebase-config/bandwagoner/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..4b53a6c5b
--- /dev/null
+++ b/firebase-config/bandwagoner/src/main/AndroidManifest.xml
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright 2018 Google LLC
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<!-- The first number in the version name distinguishes this as the 3P app version. -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.googletest.firebase.remoteconfig.bandwagoner"
+    android:versionCode="1"
+    android:versionName="3.0.0">
+
+
+  <!--Needed for Firebase IID's getToken method.-->
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+  <uses-permission android:name="com.google.android.c2dm.permission.RECEIVE"/>
+
+  <uses-permission android:name="android.permission.INTERNET"/>
+  <uses-permission android:name="android.permission.WAKE_LOCK"/>
+
+  <application
+      android:name=".MainApplication"
+      android:label="Bandwagoner"
+      android:theme="@style/LightNoActionBarTheme">
+
+    <activity android:exported="true" android:name=".MainActivity">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN" />
+        <category android:name="android.intent.category.LAUNCHER" />
+      </intent-filter>
+    </activity>
+
+    <service android:exported="false" android:name="com.google.firebase.components.ComponentDiscoveryService">
+      <meta-data
+          android:name="com.google.firebase.components:com.google.firebase.iid.Registrar"
+          android:value="com.google.firebase.components.ComponentRegistrar"/>
+    </service>
+
+  </application>
+
+</manifest>
diff --git a/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/ApiFragment.java b/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/ApiFragment.java
new file mode 100644
index 000000000..8b2aea379
--- /dev/null
+++ b/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/ApiFragment.java
@@ -0,0 +1,247 @@
+/*
+ * Copyright 2018 Google LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.googletest.firebase.remoteconfig.bandwagoner;
+
+import static com.googletest.firebase.remoteconfig.bandwagoner.Constants.TAG;
+import static com.googletest.firebase.remoteconfig.bandwagoner.TimeFormatHelper.getCurrentTimeString;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewGroup;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.EditText;
+import android.widget.TextView;
+import android.widget.ToggleButton;
+import androidx.annotation.IdRes;
+import androidx.fragment.app.Fragment;
+import com.google.android.gms.tasks.Task;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfig;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigSettings;
+
+/**
+ * The main layout and logic for running Firebase Remote Config (FRC) API calls and displaying their
+ * results.
+ *
+ * @author Miraziz Yusupov
+ */
+public class ApiFragment extends Fragment {
+
+  private FirebaseRemoteConfig frc;
+  private View rootView;
+  private EditText minimumFetchIntervalText;
+  private EditText parameterKeyText;
+  private TextView parameterValueText;
+  private TextView apiCallProgressText;
+  private TextView apiCallResultsText;
+
+  @Override
+  public void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+
+    frc = FirebaseRemoteConfig.getInstance();
+    frc.setConfigSettings(
+        new FirebaseRemoteConfigSettings.Builder().setDeveloperModeEnabled(true).build());
+  }
+
+  @Override
+  public View onCreateView(
+      LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+    super.onCreateView(inflater, container, savedInstanceState);
+
+    rootView = inflater.inflate(R.layout.api_fragment, container, false);
+
+    addListenerToButton(R.id.fetch_button, this::onFetch);
+    addListenerToButton(R.id.activate_fetched_button, this::onActivateFetched);
+    addListenerToButton(R.id.get_string_button, this::onGetString);
+    addListenerToButton(R.id.reset_frc_button, this::onReset);
+
+    minimumFetchIntervalText = rootView.findViewById(R.id.frc_minimum_fetch_interval);
+    parameterKeyText = rootView.findViewById(R.id.frc_parameter_key);
+    parameterValueText = rootView.findViewById(R.id.frc_parameter_value);
+    apiCallProgressText = rootView.findViewById(R.id.api_call_progress);
+    apiCallResultsText = rootView.findViewById(R.id.api_call_results);
+
+    ToggleButton devModeButton = rootView.findViewById(R.id.dev_mode_toggle_button);
+    devModeButton.setOnCheckedChangeListener((unusedView, isChecked) -> onDevModeToggle(isChecked));
+    devModeButton.toggle();
+
+    TextView sdkVersionText = rootView.findViewById(R.id.sdk_version_text);
+
+    TextView iidText = rootView.findViewById(R.id.iid_text);
+    iidText.setText("IID: " + FirebaseInstanceId.getInstance().getId());
+
+    apiCallResultsText.setText(FirebaseInstanceId.getInstance().getToken());
+
+    return rootView;
+  }
+
+  /** Adds the given {@link OnClickListener} to the button specified by {@code buttonResourceId}. */
+  private void addListenerToButton(@IdRes int buttonResourceId, OnClickListener onClickListener) {
+    rootView.findViewById(buttonResourceId).setOnClickListener(onClickListener);
+  }
+
+  /** Sets the version of the FRC server the SDK fetches from. */
+  @SuppressWarnings("FirebaseUseExplicitDependencies")
+  private void onDevModeToggle(boolean isChecked) {
+    hideSoftKeyboard();
+
+    frc.setConfigSettings(
+        new FirebaseRemoteConfigSettings.Builder().setDeveloperModeEnabled(isChecked).build());
+  }
+
+  /**
+   * Fetches configs from the FRC server.
+   *
+   * <p>Logs the result of the operation in the {@code api_call_results} {@link TextView}.
+   */
+  private void onFetch(View unusedView) {
+    hideSoftKeyboard();
+
+    IdlingResourceManager.getInstance().increment();
+
+    String minimumFetchIntervalString = minimumFetchIntervalText.getText().toString();
+
+    apiCallProgressText.setText("Fetching...");
+    Task<Void> fetchTask;
+    if (!minimumFetchIntervalString.isEmpty()) {
+      fetchTask =
+          frc.fetch(
+              /* minimumFetchIntervalInSeconds= */ Integer.valueOf(minimumFetchIntervalString));
+    } else {
+      fetchTask = frc.fetch();
+    }
+
+    fetchTask.addOnCompleteListener(
+        (completedFetchTask) -> {
+          if (isFragmentDestroyed()) {
+            Log.w(TAG, "Fragment was destroyed before fetch was completed.");
+            IdlingResourceManager.getInstance().decrement();
+            return;
+          }
+
+          String currentTimeString = getCurrentTimeString();
+          if (completedFetchTask.isSuccessful()) {
+            apiCallResultsText.setText(
+                String.format("%s - Fetch was successful!", currentTimeString));
+            Log.i(TAG, "Fetch was successful!");
+          } else {
+            apiCallResultsText.setText(
+                String.format(
+                    "%s - Fetch failed with exception: %s",
+                    currentTimeString, completedFetchTask.getException()));
+            Log.e(TAG, "Fetch failed!", completedFetchTask.getException());
+          }
+
+          apiCallProgressText.setText("");
+          IdlingResourceManager.getInstance().decrement();
+        });
+  }
+
+  /**
+   * Activates the most recently fetched configs.
+   *
+   * <p>Logs the result of the operation in the {@code api_call_results} {@link TextView}.
+   */
+  private void onActivateFetched(View unusedView) {
+    hideSoftKeyboard();
+
+    boolean activated = frc.activateFetched();
+    apiCallResultsText.setText(
+        String.format(
+            "%s - activateFetched %s!",
+            getCurrentTimeString(), activated ? "was successful" : "returned false"));
+  }
+
+  /**
+   * Gets an FRC parameter value in a {@link String} format.
+   *
+   * <p>Sets the {@code frc_parameter_value} {@link TextView} to the value of the FRC parameter for
+   * the key in the {@code frc_parameter_key} {@link EditText}.
+   */
+  private void onGetString(View unusedView) {
+    hideSoftKeyboard();
+
+    String paramKey = parameterKeyText.getText().toString();
+    String paramValue = frc.getString(paramKey);
+
+    parameterValueText.setText(
+        String.format("%s - String: (%s, %s)", getCurrentTimeString(), paramKey, paramValue));
+  }
+
+  /** Resets all FRC configs and settings, both in memory and disk. */
+  private void onReset(View unusedView) {
+    hideSoftKeyboard();
+
+    IdlingResourceManager.getInstance().increment();
+
+    apiCallProgressText.setText("Resetting...");
+    frc.reset()
+        .addOnCompleteListener(
+            (resetTask) -> {
+              if (isFragmentDestroyed()) {
+                Log.w(TAG, "Fragment was destroyed before fetch was completed.");
+                IdlingResourceManager.getInstance().decrement();
+                return;
+              }
+
+              String currentTimeString = getCurrentTimeString();
+              if (resetTask.isSuccessful()) {
+                // Reset means dev mode was turned off.
+                ((ToggleButton) rootView.findViewById(R.id.dev_mode_toggle_button))
+                    .setChecked(false);
+
+                apiCallResultsText.setText(
+                    String.format("%s - Reset was successful!", currentTimeString));
+                Log.i(TAG, "Reset was successful!");
+              } else {
+                apiCallResultsText.setText(
+                    String.format(
+                        "%s - Reset failed with exception: %s",
+                        currentTimeString, resetTask.getException()));
+                Log.e(TAG, "Reset failed!", resetTask.getException());
+              }
+
+              apiCallProgressText.setText("");
+              IdlingResourceManager.getInstance().decrement();
+            });
+  }
+
+  /** Hides the soft keyboard, usually after clicking a button. */
+  public void hideSoftKeyboard() {
+    Activity activity = getActivity();
+    if (activity == null || activity.getCurrentFocus() == null) {
+      return;
+    }
+
+    InputMethodManager inputMethodManager =
+        (InputMethodManager) activity.getSystemService(Activity.INPUT_METHOD_SERVICE);
+    inputMethodManager.hideSoftInputFromWindow(activity.getCurrentFocus().getWindowToken(), 0);
+  }
+
+  private boolean isFragmentDestroyed() {
+    return this.isRemoving()
+        || this.getActivity() == null
+        || this.isDetached()
+        || !this.isAdded()
+        || this.getView() == null;
+  }
+}
diff --git a/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/BandwagonerFragment.java b/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/BandwagonerFragment.java
new file mode 100644
index 000000000..6cb853039
--- /dev/null
+++ b/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/BandwagonerFragment.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2018 Google LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.googletest.firebase.remoteconfig.bandwagoner;
+
+import android.widget.TextView;
+import androidx.fragment.app.Fragment;
+
+/**
+ * Fragment with text views for showing results of async operations.
+ *
+ * @author Miraziz Yusupov
+ */
+public class BandwagonerFragment extends Fragment {
+  TextView callProgressText;
+  TextView callResultsText;
+}
diff --git a/test-apps/settings.gradle b/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/Constants.java
similarity index 71%
rename from test-apps/settings.gradle
rename to firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/Constants.java
index 2c93137fa..e795c79d4 100644
--- a/test-apps/settings.gradle
+++ b/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/Constants.java
@@ -14,7 +14,13 @@
  * limitations under the License.
  */
 
-include ":firestore-test-app"
-include ":functions-test-app"
-include ":database-test-app"
-include "storage-test-app"
+package com.googletest.firebase.remoteconfig.bandwagoner;
+
+/**
+ * Constants shared between all Firebase Remote Config (FRC) SDK classes.
+ *
+ * @author Miraziz Yusupov
+ */
+class Constants {
+  public static final String TAG = "Bandwagoner";
+}
diff --git a/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/IdlingResourceManager.java b/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/IdlingResourceManager.java
new file mode 100644
index 000000000..7418c80e1
--- /dev/null
+++ b/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/IdlingResourceManager.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2018 Google LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.googletest.firebase.remoteconfig.bandwagoner;
+
+import androidx.test.espresso.idling.CountingIdlingResource;
+
+/**
+ * Manager for a singleton instance of {@link CountingIdlingResource}.
+ *
+ * @author Miraziz Yusupov
+ */
+public class IdlingResourceManager {
+  private static CountingIdlingResource idlingResource;
+
+  public static CountingIdlingResource getInstance() {
+    if (idlingResource == null) {
+      idlingResource =
+          new CountingIdlingResource("BandwagonerIdlingResource", /*debugCounting=*/ true);
+    }
+    return idlingResource;
+  }
+}
diff --git a/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/MainActivity.java b/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/MainActivity.java
new file mode 100644
index 000000000..3fee1b213
--- /dev/null
+++ b/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/MainActivity.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2018 Google LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.googletest.firebase.remoteconfig.bandwagoner;
+
+import android.os.Bundle;
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.appcompat.widget.Toolbar;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentPagerAdapter;
+import androidx.viewpager.widget.PagerAdapter;
+import androidx.viewpager.widget.ViewPager;
+import com.google.android.material.tabs.TabLayout;
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+
+/**
+ * A tabbed activity that has a primary tab with a {@link ApiFragment} for testing the Firebase
+ * Remote Config (FRC) SDK API.
+ *
+ * @author Miraziz Yusupov
+ */
+public class MainActivity extends AppCompatActivity {
+
+  private static final ImmutableList<Tab> TABS =
+      ImmutableList.of(Tab.create("Api", new ApiFragment()));
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.activity_main);
+
+    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
+    toolbar.setTitle(R.string.app_name);
+    setSupportActionBar(toolbar);
+
+    setupTabs();
+  }
+
+  private void setupTabs() {
+
+    PagerAdapter pagerAdapter =
+        new FragmentPagerAdapter(getSupportFragmentManager()) {
+          @Override
+          public int getCount() {
+            return TABS.size();
+          }
+
+          @Override
+          public Fragment getItem(int position) {
+            return TABS.get(position).fragment();
+          }
+
+          @Override
+          public CharSequence getPageTitle(int position) {
+            return TABS.get(position).name();
+          }
+        };
+
+    ViewPager pages = (ViewPager) findViewById(R.id.view_pager);
+    pages.setAdapter(pagerAdapter);
+    pages.setCurrentItem(0);
+
+    TabLayout tabLayout = (TabLayout) findViewById(R.id.tab_layout);
+    tabLayout.setupWithViewPager(pages);
+  }
+
+  @AutoValue
+  abstract static class Tab {
+    static Tab create(String name, Fragment fragment) {
+      return new AutoValue_MainActivity_Tab(name, fragment);
+    }
+
+    abstract String name();
+
+    abstract Fragment fragment();
+  }
+}
diff --git a/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/MainApplication.java b/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/MainApplication.java
new file mode 100644
index 000000000..3675a36a0
--- /dev/null
+++ b/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/MainApplication.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2018 Google LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.googletest.firebase.remoteconfig.bandwagoner;
+
+import android.app.Application;
+import com.google.firebase.FirebaseApp;
+
+/**
+ * Initial logic for the App; used to start the {@link FirebaseApp} when the App starts.
+ *
+ * @author Miraziz Yusupov
+ */
+public class MainApplication extends Application {
+  @Override
+  public void onCreate() {
+    super.onCreate();
+    FirebaseApp.initializeApp(this);
+  }
+}
diff --git a/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/TaskHelper.java b/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/TaskHelper.java
new file mode 100644
index 000000000..692fd9aa3
--- /dev/null
+++ b/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/TaskHelper.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2018 Google LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.googletest.firebase.remoteconfig.bandwagoner;
+
+import static com.googletest.firebase.remoteconfig.bandwagoner.Constants.TAG;
+import static com.googletest.firebase.remoteconfig.bandwagoner.TimeFormatHelper.getCurrentTimeString;
+
+import android.util.Log;
+import androidx.fragment.app.Fragment;
+import com.google.android.gms.tasks.Task;
+
+/**
+ * Helper methods for dealing with the interactions between Tasks and Views.
+ *
+ * @author Miraziz Yusupov
+ */
+public class TaskHelper {
+
+  static void addDebugOnCompleteListener(
+      Task<?> task, BandwagonerFragment fragment, String taskName) {
+
+    task.addOnCompleteListener(
+        (unusedVoid) -> {
+          if (isFragmentDestroyed(fragment)) {
+            Log.w(TAG, "Fragment was destroyed before " + taskName + " was completed.");
+            IdlingResourceManager.getInstance().decrement();
+            return;
+          }
+
+          String currentTimeString = getCurrentTimeString();
+          if (task.isSuccessful()) {
+            fragment.callResultsText.setText(
+                String.format(
+                    "%s - %s task was successful with return value: %s!",
+                    currentTimeString, taskName, task.getResult()));
+            Log.i(TAG, taskName + " task was successful! Return value: " + task.getResult());
+          } else {
+            fragment.callResultsText.setText(
+                String.format(
+                    "%s - %s task failed with exception: %s",
+                    currentTimeString, taskName, task.getException()));
+            Log.e(TAG, taskName + " task failed!", task.getException());
+          }
+
+          fragment.callProgressText.setText("");
+          IdlingResourceManager.getInstance().decrement();
+        });
+  }
+
+  static boolean isFragmentDestroyed(Fragment fragment) {
+    return fragment.isRemoving()
+        || fragment.getActivity() == null
+        || fragment.isDetached()
+        || !fragment.isAdded()
+        || fragment.getView() == null;
+  }
+}
diff --git a/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/TimeFormatHelper.java b/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/TimeFormatHelper.java
new file mode 100644
index 000000000..dc393103f
--- /dev/null
+++ b/firebase-config/bandwagoner/src/main/java/com/googletest/firebase/remoteconfig/bandwagoner/TimeFormatHelper.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2018 Google LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.googletest.firebase.remoteconfig.bandwagoner;
+
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+
+/**
+ * Utility class for time-related helper methods.
+ *
+ * @author Miraziz Yusupov
+ */
+final class TimeFormatHelper {
+
+  private static final SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm:ss");
+
+  private TimeFormatHelper() {}
+
+  /** Returns the current time in a human readable format. */
+  static String getCurrentTimeString() {
+    return timeFormat.format(Calendar.getInstance().getTime());
+  }
+}
diff --git a/test-apps/storage-test-app/src/main/res/layout/test_activity.xml b/firebase-config/bandwagoner/src/main/res/layout/activity_main.xml
similarity index 57%
rename from test-apps/storage-test-app/src/main/res/layout/test_activity.xml
rename to firebase-config/bandwagoner/src/main/res/layout/activity_main.xml
index dfeeb24e0..ea8de8610 100644
--- a/test-apps/storage-test-app/src/main/res/layout/test_activity.xml
+++ b/firebase-config/bandwagoner/src/main/res/layout/activity_main.xml
@@ -17,10 +17,24 @@
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="match_parent"
-    android:layout_height="match_parent">
-  <TextView
-      android:id="@+id/restaurant"
+    android:layout_height="match_parent"
+    android:focusable="true"
+    android:focusableInTouchMode="true"
+    android:orientation="vertical">
+
+  <androidx.appcompat.widget.Toolbar
+      android:id="@+id/toolbar"
+      style="@style/DarkToolbar"/>
+
+  <com.google.android.material.tabs.TabLayout
+      android:id="@+id/tab_layout"
+      style="@style/DarkToolbar"
       android:layout_width="match_parent"
-      android:layout_height="wrap_content"
-      />
-</LinearLayout>
\ No newline at end of file
+      android:layout_height="wrap_content"/>
+
+  <androidx.viewpager.widget.ViewPager
+      android:id="@+id/view_pager"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"/>
+
+</LinearLayout>
diff --git a/firebase-config/bandwagoner/src/main/res/layout/analytics_fragment.xml b/firebase-config/bandwagoner/src/main/res/layout/analytics_fragment.xml
new file mode 100644
index 000000000..06ad13318
--- /dev/null
+++ b/firebase-config/bandwagoner/src/main/res/layout/analytics_fragment.xml
@@ -0,0 +1,211 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright 2018 Google LLC
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin">
+
+  <LinearLayout
+      android:id="@+id/analytics_actions_layout"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:orientation="vertical">
+
+    <TextView
+        android:id="@+id/analytics_disclaimer"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_centerHorizontal="true"
+        android:gravity="center"
+        android:scrollbars="vertical"
+        android:text="This tab does not work in 3P (AnalyticsConnector is not documented)"
+        android:textAlignment="center"
+        android:textAppearance="?android:attr/textAppearanceLarge"/>
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="10dp">
+      <EditText
+          android:id="@+id/get_user_property_key"
+          android:layout_width="150dp"
+          android:layout_height="wrap_content"
+          android:layout_gravity="center"
+          android:gravity="center"
+          android:hint="User property key"
+          android:inputType="textAutoComplete"
+          android:textAlignment="center"/>
+
+      <Space
+          android:layout_width="50dp"
+          android:layout_height="match_parent"/>
+
+      <Button
+          android:id="@+id/get_user_property_button"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_gravity="center"
+          android:enabled="false"
+          android:text="Get User Property"/>
+    </LinearLayout>
+
+    <TextView
+        android:id="@+id/get_user_property_result"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="20dp"
+        android:gravity="center"
+        android:text=""
+        android:textAlignment="center"
+        android:textAppearance="?android:attr/textAppearanceLarge"/>
+
+    <View
+        android:layout_width="match_parent"
+        android:layout_height="1dp"
+        android:layout_marginBottom="10dp"
+        android:background="@android:color/darker_gray"/>
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="10dp">
+      <LinearLayout
+          android:layout_width="150dp"
+          android:layout_height="wrap_content"
+          android:orientation="vertical">
+        <EditText
+            android:id="@+id/set_user_property_key"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:gravity="center"
+            android:hint="User property key"
+            android:inputType="textAutoComplete"
+            android:textAlignment="center"/>
+        <EditText
+            android:id="@+id/set_user_property_value"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:gravity="center"
+            android:hint="User property value"
+            android:inputType="textAutoComplete"
+            android:textAlignment="center"/>
+      </LinearLayout>
+
+      <Space
+          android:layout_width="50dp"
+          android:layout_height="match_parent"/>
+
+      <Button
+          android:id="@+id/set_user_property_button"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_gravity="center"
+          android:enabled="false"
+          android:text="Set User Property"
+          android:textAlignment="center"/>
+    </LinearLayout>
+
+
+    <View
+        android:layout_width="match_parent"
+        android:layout_height="1dp"
+        android:layout_marginBottom="10dp"
+        android:background="@android:color/darker_gray"/>
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="10dp">
+
+      <TextView
+          android:id="@+id/conditional_user_properties"
+          android:layout_width="100dp"
+          android:layout_height="wrap_content"
+          android:layout_gravity="center"
+          android:gravity="center"
+          android:scrollbars="vertical"
+          android:textAlignment="center"
+          android:textAppearance="?android:attr/textAppearanceMedium"/>
+
+      <Space
+          android:layout_width="50dp"
+          android:layout_height="match_parent"/>
+
+      <TextView
+          android:id="@+id/conditional_user_properties_title"
+          android:layout_width="50dp"
+          android:layout_height="wrap_content"
+          android:layout_gravity="center"
+          android:gravity="center"
+          android:scrollbars="vertical"
+          android:text="Conditional User Properties"
+          android:textAlignment="center"
+          android:textAppearance="?android:attr/textAppearanceSmall"/>
+
+      <LinearLayout
+          android:layout_width="match_parent"
+          android:layout_height="wrap_content"
+          android:orientation="vertical">
+
+        <Button
+            android:id="@+id/get_conditional_user_properties_button"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center"
+            android:enabled="true"
+            android:text="Get"/>
+
+        <Button
+            android:id="@+id/clear_conditional_user_properties_button"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center"
+            android:enabled="true"
+            android:text="Clear"/>
+      </LinearLayout>
+    </LinearLayout>
+
+    <View
+        android:layout_width="match_parent"
+        android:layout_height="1dp"
+        android:layout_marginBottom="10dp"
+        android:background="@android:color/darker_gray"/>
+
+    <TextView
+        android:id="@+id/analytics_call_progress"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:gravity="center"
+        android:textAlignment="center"
+        android:textAppearance="?android:attr/textAppearanceMedium"/>
+  </LinearLayout>
+
+  <TextView
+      android:id="@+id/analytics_results"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:layout_below="@+id/analytics_actions_layout"
+      android:layout_centerHorizontal="true"
+      android:gravity="center"
+      android:scrollbars="vertical"
+      android:textAlignment="center"
+      android:textAppearance="?android:attr/textAppearanceLarge"/>
+</RelativeLayout>
diff --git a/firebase-config/bandwagoner/src/main/res/layout/api_fragment.xml b/firebase-config/bandwagoner/src/main/res/layout/api_fragment.xml
new file mode 100644
index 000000000..ce5287f28
--- /dev/null
+++ b/firebase-config/bandwagoner/src/main/res/layout/api_fragment.xml
@@ -0,0 +1,178 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright 2018 Google LLC
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin">
+
+  <LinearLayout
+      android:id="@+id/actions_layout"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:orientation="vertical">
+
+    <EditText
+        android:id="@+id/frc_parameter_key"
+        android:layout_width="200dp"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center"
+        android:gravity="center"
+        android:hint="parameter key"
+        android:inputType="textAutoComplete"
+        android:textAlignment="center"/>
+
+    <Button
+        android:id="@+id/get_string_button"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center"
+        android:text="Get String"
+        android:textSize="12sp"/>
+
+    <TextView
+        android:id="@+id/frc_parameter_value"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="5dp"
+        android:gravity="center"
+        android:text=""
+        android:textAlignment="center"
+        android:textAppearance="?android:attr/textAppearanceMedium"
+        android:textIsSelectable="true"/>
+
+    <View
+        android:layout_width="match_parent"
+        android:layout_height="1dp"
+        android:layout_marginBottom="5dp"
+        android:background="@android:color/darker_gray"/>
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="5dp">
+      <EditText
+          android:id="@+id/frc_minimum_fetch_interval"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_weight="1"
+          android:hint="fetch interval in seconds"
+          android:inputType="number"
+          android:textAlignment="center"
+          android:textSize="12sp"/>
+
+      <Button
+          android:id="@+id/fetch_button"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_weight="0"
+          android:text="Fetch"
+          android:textSize="12sp"/>
+    </LinearLayout>
+
+    <View
+        android:layout_width="match_parent"
+        android:layout_height="1dp"
+        android:layout_marginBottom="5dp"
+        android:background="@android:color/darker_gray"/>
+
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="5dp">
+      <Button
+          android:id="@+id/reset_frc_button"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_weight="1"
+          android:text="Reset All"
+          android:textSize="12sp"/>
+
+      <Space
+          android:layout_width="50dp"
+          android:layout_height="match_parent"/>
+
+
+      <ToggleButton
+          android:id="@+id/dev_mode_toggle_button"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_weight="1"
+          android:checked="false"
+          android:textOff="Dev OFF"
+          android:textOn="Dev ON"
+          android:textSize="12sp"/>
+
+      <Button
+          android:id="@+id/activate_fetched_button"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_weight="1"
+          android:text="Activate Fetched"
+          android:textSize="12sp"/>
+    </LinearLayout>
+
+    <View
+        android:layout_width="match_parent"
+        android:layout_height="1dp"
+        android:layout_marginBottom="5dp"
+        android:background="@android:color/darker_gray"/>
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+      <TextView
+          android:id="@+id/iid_text"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_alignParentStart="true"
+          android:textIsSelectable="true"
+          android:layout_alignParentLeft="true" />
+
+      <TextView
+          android:id="@+id/sdk_version_text"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_alignParentEnd="true"
+          android:textIsSelectable="true"
+          android:layout_alignParentRight="true" />
+    </RelativeLayout>
+
+    <TextView
+        android:id="@+id/api_call_progress"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:gravity="center"
+        android:textAlignment="center"
+        android:textAppearance="?android:attr/textAppearanceSmall"/>
+  </LinearLayout>
+
+  <TextView
+      android:id="@+id/api_call_results"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:layout_below="@+id/actions_layout"
+      android:layout_centerHorizontal="true"
+      android:gravity="center"
+      android:textAlignment="center"
+      android:textAppearance="?android:attr/textAppearanceMedium"
+      android:textIsSelectable="true"/>
+</RelativeLayout>
diff --git a/firebase-config/bandwagoner/src/main/res/layout/settings_fragment.xml b/firebase-config/bandwagoner/src/main/res/layout/settings_fragment.xml
new file mode 100644
index 000000000..a9fef679e
--- /dev/null
+++ b/firebase-config/bandwagoner/src/main/res/layout/settings_fragment.xml
@@ -0,0 +1,169 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright 2018 Google LLC
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin">
+
+  <LinearLayout
+      android:id="@+id/actions_layout"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:orientation="vertical">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="5dp">
+      <EditText
+          android:id="@+id/frc_namespace"
+          android:layout_width="0dp"
+          android:layout_height="wrap_content"
+          android:layout_weight="1"
+          android:hint="namespace"
+          android:inputType="textAutoComplete"
+          android:textAlignment="center"
+          android:textSize="12sp"/>
+
+      <Space
+          android:layout_width="50dp"
+          android:layout_height="match_parent"/>
+
+      <Button
+          android:id="@+id/set_namespace_button"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_weight="0"
+          android:text="Set Namespace"
+          android:textAlignment="center"
+          android:textSize="12sp"/>
+    </LinearLayout>
+
+    <View
+        android:layout_width="match_parent"
+        android:layout_height="1dp"
+        android:layout_marginBottom="5dp"
+        android:background="@android:color/darker_gray"/>
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="5dp">
+
+      <EditText
+          android:id="@+id/frc_minimum_fetch_interval"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_weight="1"
+          android:hint="minimum fetch interval (secs)"
+          android:inputType="numberSigned"
+          android:textAlignment="center"
+          android:textSize="12sp"/>
+
+      <Space
+          android:layout_width="50dp"
+          android:layout_height="match_parent"/>
+
+      <Button
+          android:id="@+id/set_fetch_interval_button"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_weight="0"
+          android:text="Set Fetch Interval"
+          android:textAlignment="center"
+          android:textSize="12sp"/>
+
+    </LinearLayout>
+
+    <View
+        android:layout_width="match_parent"
+        android:layout_height="1dp"
+        android:layout_marginBottom="5dp"
+        android:background="@android:color/darker_gray"/>
+
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="5dp">
+
+      <ToggleButton
+          android:id="@+id/fetch_version_toggle_button"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_weight="0"
+          android:checked="false"
+          android:textOff="V2 OFF"
+          android:textOn="V2 ON"
+          android:textSize="12sp"/>
+
+      <Space
+          android:layout_width="10dp"
+          android:layout_height="match_parent"/>
+
+      <ToggleButton
+          android:id="@+id/dev_mode_toggle_button"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_weight="1"
+          android:checked="false"
+          android:textOff="Dev OFF"
+          android:textOn="Dev ON"
+          android:textSize="12sp"/>
+    </LinearLayout>
+
+    <View
+        android:layout_width="match_parent"
+        android:layout_height="1dp"
+        android:layout_marginBottom="5dp"
+        android:background="@android:color/darker_gray"/>
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+      <TextView
+          android:id="@+id/iid_text"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_alignParentStart="true"
+          android:textIsSelectable="true"/>
+    </RelativeLayout>
+
+    <TextView
+        android:id="@+id/settings_call_progress"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:gravity="center"
+        android:textAlignment="center"
+        android:textAppearance="?android:attr/textAppearanceSmall"/>
+  </LinearLayout>
+
+  <TextView
+      android:id="@+id/settings_call_results"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:layout_below="@+id/actions_layout"
+      android:layout_centerHorizontal="true"
+      android:gravity="center"
+      android:textAlignment="center"
+      android:textAppearance="?android:attr/textAppearanceMedium"
+      android:textIsSelectable="true"/>
+</RelativeLayout>
diff --git a/firebase-config/bandwagoner/src/main/res/values/.gitignore b/firebase-config/bandwagoner/src/main/res/values/.gitignore
new file mode 100644
index 000000000..f69770c7d
--- /dev/null
+++ b/firebase-config/bandwagoner/src/main/res/values/.gitignore
@@ -0,0 +1 @@
+google-services.xml
diff --git a/test-apps/firestore-test-app/src/androidTest/AndroidManifest.xml b/firebase-config/bandwagoner/src/main/res/values/colors.xml
similarity index 74%
rename from test-apps/firestore-test-app/src/androidTest/AndroidManifest.xml
rename to firebase-config/bandwagoner/src/main/res/values/colors.xml
index 40b5b63c8..711b80641 100644
--- a/test-apps/firestore-test-app/src/androidTest/AndroidManifest.xml
+++ b/firebase-config/bandwagoner/src/main/res/values/colors.xml
@@ -1,3 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
 <!--
   ~ Copyright 2018 Google LLC
   ~
@@ -14,9 +15,8 @@
   ~ limitations under the License.
   -->
 
-<manifest package="com.google.firebase.testapps.firestore"
-    xmlns:tools="http://schemas.android.com/tools">
-
-  <uses-sdk tools:overrideLibrary="android.support.test.uiautomator.v18"/>
-
-</manifest>
+<resources>
+  <color name="color_primary">#3F51B5</color>
+  <color name="color_primary_dark">#303F9F</color>
+  <color name="color_accent">#FF4081</color>
+</resources>
diff --git a/firebase-config/bandwagoner/src/main/res/values/dimens.xml b/firebase-config/bandwagoner/src/main/res/values/dimens.xml
new file mode 100644
index 000000000..72172a5de
--- /dev/null
+++ b/firebase-config/bandwagoner/src/main/res/values/dimens.xml
@@ -0,0 +1,23 @@
+<!--
+  ~ Copyright 2018 Google LLC
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<resources>
+  <!-- Default screen margins, per the Android Design guidelines. -->
+  <dimen name="activity_horizontal_margin">16dp</dimen>
+  <dimen name="activity_vertical_margin">16dp</dimen>
+  <dimen name="fab_margin">16dp</dimen>
+  <dimen name="appbar_padding_top">8dp</dimen>
+</resources>
diff --git a/test-apps/storage-test-app/src/androidTest/AndroidManifest.xml b/firebase-config/bandwagoner/src/main/res/values/strings.xml
similarity index 75%
rename from test-apps/storage-test-app/src/androidTest/AndroidManifest.xml
rename to firebase-config/bandwagoner/src/main/res/values/strings.xml
index 3ea729445..2d122cd2a 100644
--- a/test-apps/storage-test-app/src/androidTest/AndroidManifest.xml
+++ b/firebase-config/bandwagoner/src/main/res/values/strings.xml
@@ -1,3 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
 <!--
   ~ Copyright 2018 Google LLC
   ~
@@ -14,7 +15,6 @@
   ~ limitations under the License.
   -->
 
-<manifest package="com.google.firebase.testapps.storage"
-    xmlns:tools="http://schemas.android.com/tools">
-  <uses-sdk tools:overrideLibrary="android.support.test.uiautomator.v18"/>
-</manifest>
+<resources>
+  <string name="app_name">Bandwagoner 3P</string>
+</resources>
diff --git a/firebase-config/bandwagoner/src/main/res/values/styles.xml b/firebase-config/bandwagoner/src/main/res/values/styles.xml
new file mode 100644
index 000000000..f12925e09
--- /dev/null
+++ b/firebase-config/bandwagoner/src/main/res/values/styles.xml
@@ -0,0 +1,32 @@
+<!--
+  ~ Copyright 2018 Google LLC
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<resources>
+
+  <style name="LightNoActionBarTheme" parent="Theme.AppCompat.Light.NoActionBar">
+    <item name="colorPrimary">@color/color_primary</item>
+    <item name="colorPrimaryDark">@color/color_primary_dark</item>
+    <item name="colorAccent">@color/color_accent</item>
+  </style>
+
+  <style name="DarkToolbar" parent="ThemeOverlay.AppCompat.Dark.ActionBar">
+    <item name="android:layout_width">match_parent</item>
+    <item name="android:layout_height">@dimen/abc_action_bar_default_height_material</item>
+    <item name="android:background">?attr/colorPrimary</item>
+    <item name="theme">@style/ThemeOverlay.AppCompat.Dark.ActionBar</item>
+  </style>
+
+</resources>
diff --git a/firebase-config/firebase-config.gradle b/firebase-config/firebase-config.gradle
new file mode 100644
index 000000000..c2ae397f2
--- /dev/null
+++ b/firebase-config/firebase-config.gradle
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2018 Google LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ *
+ * You may obtain a copy of the License at
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+plugins {
+    id 'firebase-library'
+    id 'com.google.protobuf'
+}
+
+firebaseLibrary {
+    testLab.enabled = true
+    publishSources = true
+}
+
+protobuf {
+    // Configure the protoc executable
+    protoc {
+        // Download from repositories
+        artifact = 'com.google.protobuf:protoc:3.4.0'
+    }
+    plugins {
+        javalite {
+            // The codegen for lite comes as a separate artifact
+            artifact = 'com.google.protobuf:protoc-gen-javalite:3.0.0'
+        }
+    }
+    generateProtoTasks {
+        all().each { task ->
+            task.builtins {
+                // In most cases you don't need the full Java output
+                // if you use the lite output.
+                remove java
+            }
+            task.plugins {
+                javalite {}
+            }
+        }
+    }
+}
+
+android {
+    compileSdkVersion project.targetSdkVersion
+    defaultConfig {
+      minSdkVersion 16
+      targetSdkVersion project.targetSdkVersion
+      multiDexEnabled true
+      versionName version
+      testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+    }
+
+    sourceSets {
+        main {
+            proto {
+                srcDir 'src/proto'
+            }
+        }
+
+        androidTest.resources.srcDirs += ['src/androidTest/res']
+    }
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
+    testOptions {
+        unitTests {
+            includeAndroidResources = true
+        }
+    }
+}
+
+dependencies {
+    implementation project(':firebase-common')
+    implementation project (':firebase-abt')
+
+    implementation ('com.google.firebase:firebase-iid:18.0.0') {
+        exclude group: "com.google.firebase", module: "firebase-common"
+    }
+    implementation 'com.google.firebase:firebase-measurement-connector:18.0.0'
+    implementation 'com.google.protobuf:protobuf-lite:3.0.1'
+
+    compileOnly 'com.google.code.findbugs:jsr305:3.0.2'
+
+    testImplementation 'org.mockito:mockito-core:2.25.0'
+    testImplementation 'com.google.truth:truth:0.44'
+    testImplementation 'junit:junit:4.12'
+    testImplementation 'org.robolectric:robolectric:4.2'
+    testImplementation "org.skyscreamer:jsonassert:1.5.0"
+
+    androidTestImplementation 'androidx.test:runner:1.2.0'
+    androidTestImplementation 'org.mockito:mockito-core:2.25.0'
+    androidTestImplementation 'com.google.truth:truth:0.44'
+
+    androidTestImplementation 'com.linkedin.dexmaker:dexmaker:2.25.0'
+    androidTestImplementation 'com.linkedin.dexmaker:dexmaker-mockito:2.25.0'
+    androidTestImplementation 'junit:junit:4.12'
+    androidTestImplementation "org.skyscreamer:jsonassert:1.5.0"
+}
diff --git a/firebase-config/gradle.properties b/firebase-config/gradle.properties
new file mode 100644
index 000000000..d5684d1b9
--- /dev/null
+++ b/firebase-config/gradle.properties
@@ -0,0 +1,20 @@
+#
+# Copyright 2018 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+#
+# You may obtain a copy of the License at
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+version=19.0.1
+latestReleasedVersion=19.0.0
+android.enableUnitTestBinaryResources=true
+
diff --git a/firebase-config/ktx/gradle.properties b/firebase-config/ktx/gradle.properties
new file mode 100644
index 000000000..016fa887b
--- /dev/null
+++ b/firebase-config/ktx/gradle.properties
@@ -0,0 +1,2 @@
+android.enableUnitTestBinaryResources=true
+
diff --git a/firebase-config/ktx/ktx.gradle b/firebase-config/ktx/ktx.gradle
new file mode 100644
index 000000000..7d268abb8
--- /dev/null
+++ b/firebase-config/ktx/ktx.gradle
@@ -0,0 +1,57 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+plugins {
+    id 'firebase-library'
+    id 'kotlin-android'
+}
+
+firebaseLibrary {
+    releaseWith project(':firebase-config')
+    publishJavadoc = false
+    publishSources = true
+}
+
+android {
+    compileSdkVersion project.targetSdkVersion
+    defaultConfig {
+        minSdkVersion 16
+        multiDexEnabled true
+        targetSdkVersion project.targetSdkVersion
+        versionName version
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+    }
+    sourceSets {
+        main.java.srcDirs += 'src/main/kotlin'
+        test.java {
+            srcDir 'src/test/kotlin'
+        }
+    }
+    testOptions.unitTests.includeAndroidResources = true
+}
+
+dependencies {
+    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlinVersion"
+
+    implementation project(':firebase-common')
+    implementation project(':firebase-common:ktx')
+    implementation project(':firebase-config')
+    implementation project (':firebase-abt')
+    implementation 'androidx.annotation:annotation:1.1.0'
+
+    testImplementation "org.robolectric:robolectric:$robolectricVersion"
+    testImplementation 'junit:junit:4.12'
+    testImplementation "com.google.truth:truth:$googleTruthVersion"
+    testImplementation 'org.mockito:mockito-core:2.25.0'
+}
diff --git a/firebase-config/ktx/src/main/AndroidManifest.xml b/firebase-config/ktx/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..cc225fee9
--- /dev/null
+++ b/firebase-config/ktx/src/main/AndroidManifest.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.google.firebase.remoteconfig.ktx">
+    <!--Although the *SdkVersion is captured in gradle build files, this is required for non gradle builds-->
+    <!--<uses-sdk android:minSdkVersion="16"/>-->
+    <application>
+        <service android:name="com.google.firebase.components.ComponentDiscoveryService" android:exported="false">
+            <meta-data android:name="com.google.firebase.components:com.google.firebase.remoteconfig.ktx.FirebaseConfigKtxRegistrar"
+                android:value="com.google.firebase.components.ComponentRegistrar" />
+        </service>
+    </application>
+</manifest>
diff --git a/firebase-config/ktx/src/main/kotlin/com/google/firebase/remoteconfig/ktx/RemoteConfig.kt b/firebase-config/ktx/src/main/kotlin/com/google/firebase/remoteconfig/ktx/RemoteConfig.kt
new file mode 100644
index 000000000..a817f1dbb
--- /dev/null
+++ b/firebase-config/ktx/src/main/kotlin/com/google/firebase/remoteconfig/ktx/RemoteConfig.kt
@@ -0,0 +1,46 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.ktx
+
+import androidx.annotation.Keep
+import com.google.firebase.FirebaseApp
+import com.google.firebase.remoteconfig.FirebaseRemoteConfig
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigValue
+import com.google.firebase.components.Component
+import com.google.firebase.components.ComponentRegistrar
+
+import com.google.firebase.ktx.Firebase
+import com.google.firebase.platforminfo.LibraryVersionComponent
+
+/** Returns the [FirebaseRemoteConfig] instance of the default [FirebaseApp]. */
+val Firebase.remoteConfig: FirebaseRemoteConfig
+    get() = FirebaseRemoteConfig.getInstance()
+
+/** Returns the [FirebaseRemoteConfig] instance of a given [FirebaseApp]. */
+fun Firebase.remoteConfig(app: FirebaseApp): FirebaseRemoteConfig = FirebaseRemoteConfig.getInstance(app)
+
+/** See [FirebaseRemoteConfig#getValue] */
+operator fun FirebaseRemoteConfig.get(key: String): FirebaseRemoteConfigValue {
+    return this.getValue(key)
+}
+
+internal const val LIBRARY_NAME: String = "fire-cfg-ktx"
+
+/** @suppress */
+@Keep
+class FirebaseRemoteConfigKtxRegistrar : ComponentRegistrar {
+    override fun getComponents(): List<Component<*>> =
+            listOf(LibraryVersionComponent.create(LIBRARY_NAME, BuildConfig.VERSION_NAME))
+}
diff --git a/firebase-config/ktx/src/test/kotlin/com/google/firebase/remoteconfig/TestConstructorUtil.kt b/firebase-config/ktx/src/test/kotlin/com/google/firebase/remoteconfig/TestConstructorUtil.kt
new file mode 100644
index 000000000..e5b1acfbc
--- /dev/null
+++ b/firebase-config/ktx/src/test/kotlin/com/google/firebase/remoteconfig/TestConstructorUtil.kt
@@ -0,0 +1,52 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig
+
+import android.content.Context
+import com.google.firebase.FirebaseApp
+import com.google.firebase.remoteconfig.internal.ConfigCacheClient
+import com.google.firebase.remoteconfig.internal.ConfigFetchHandler
+import com.google.firebase.remoteconfig.internal.ConfigGetParameterHandler
+import com.google.firebase.remoteconfig.internal.ConfigMetadataClient
+import java.util.concurrent.Executor
+import com.google.firebase.abt.FirebaseABTesting
+
+// This method is a workaround for testing. It enable us to create a FirebaseRemoteConfig object
+// with mocks using the package-private constructor.
+fun createRemoteConfig(
+    context: Context?,
+    firebaseApp: FirebaseApp,
+    firebaseAbt: FirebaseABTesting?,
+    executor: Executor,
+    fetchedConfigsCache: ConfigCacheClient,
+    activatedConfigsCache: ConfigCacheClient,
+    defaultConfigsCache: ConfigCacheClient,
+    fetchHandler: ConfigFetchHandler,
+    getHandler: ConfigGetParameterHandler,
+    frcMetadata: ConfigMetadataClient
+): FirebaseRemoteConfig {
+        return FirebaseRemoteConfig(
+            context,
+            firebaseApp,
+            firebaseAbt,
+            executor,
+            fetchedConfigsCache,
+            activatedConfigsCache,
+            defaultConfigsCache,
+            fetchHandler,
+            getHandler,
+            frcMetadata
+    )
+}
diff --git a/firebase-config/ktx/src/test/kotlin/com/google/firebase/remoteconfig/ktx/RemoteConfigTests.kt b/firebase-config/ktx/src/test/kotlin/com/google/firebase/remoteconfig/ktx/RemoteConfigTests.kt
new file mode 100644
index 000000000..00689021e
--- /dev/null
+++ b/firebase-config/ktx/src/test/kotlin/com/google/firebase/remoteconfig/ktx/RemoteConfigTests.kt
@@ -0,0 +1,130 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.ktx
+
+import com.google.common.truth.Truth.assertThat
+import com.google.firebase.FirebaseApp
+import com.google.firebase.FirebaseOptions
+import com.google.firebase.remoteconfig.FirebaseRemoteConfig
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigValue
+import com.google.firebase.remoteconfig.createRemoteConfig
+import com.google.firebase.ktx.Firebase
+import com.google.firebase.remoteconfig.internal.ConfigCacheClient
+import com.google.firebase.remoteconfig.internal.ConfigFetchHandler
+import com.google.firebase.remoteconfig.internal.ConfigGetParameterHandler
+import com.google.firebase.remoteconfig.internal.ConfigMetadataClient
+import com.google.common.util.concurrent.MoreExecutors
+import com.google.firebase.ktx.app
+import com.google.firebase.ktx.initialize
+import org.junit.After
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.RobolectricTestRunner
+import org.robolectric.RuntimeEnvironment
+import org.mockito.Mockito.mock
+import org.mockito.Mockito.`when`
+
+const val APP_ID = "APP_ID"
+const val API_KEY = "API_KEY"
+
+const val EXISTING_APP = "existing"
+
+open class DefaultFirebaseRemoteConfigValue : FirebaseRemoteConfigValue {
+    override fun asLong(): Long = TODO("Unimplementend")
+    override fun asDouble(): Double = TODO("Unimplementend")
+    override fun asString(): String = TODO("Unimplementend")
+    override fun asByteArray(): ByteArray = TODO("Unimplementend")
+    override fun asBoolean(): Boolean = TODO("Unimplementend")
+    override fun getSource(): Int = TODO("Unimplementend")
+}
+
+class StringRemoteConfigValue(val value: String) : DefaultFirebaseRemoteConfigValue() {
+    override fun asString() = value
+}
+
+abstract class BaseTestCase {
+    @Before
+    fun setUp() {
+        Firebase.initialize(
+                RuntimeEnvironment.application,
+                FirebaseOptions.Builder()
+                        .setApplicationId(APP_ID)
+                        .setApiKey(API_KEY)
+                        .setProjectId("123")
+                        .build()
+        )
+
+        Firebase.initialize(
+                RuntimeEnvironment.application,
+                FirebaseOptions.Builder()
+                        .setApplicationId(APP_ID)
+                        .setApiKey(API_KEY)
+                        .setProjectId("123")
+                        .build(),
+                EXISTING_APP
+        )
+    }
+
+    @After
+    fun cleanUp() {
+        FirebaseApp.clearInstancesForTest()
+    }
+}
+
+@RunWith(RobolectricTestRunner::class)
+class ConfigTests : BaseTestCase() {
+
+    @Test
+    fun `Firebase#remoteConfig should delegate to FirebaseRemoteConfig#getInstance()`() {
+        assertThat(Firebase.remoteConfig).isSameInstanceAs(FirebaseRemoteConfig.getInstance())
+    }
+
+    @Test
+    fun `Firebase#remoteConfig should delegate to FirebaseRemoteConfig#getInstance(FirebaseApp, region)`() {
+        val app = Firebase.app(EXISTING_APP)
+        assertThat(Firebase.remoteConfig(app)).isSameInstanceAs(FirebaseRemoteConfig.getInstance(app))
+    }
+
+    @Test
+    fun `Overloaded get() operator returns default value when key doesn't exist`() {
+        val remoteConfig = Firebase.remoteConfig
+        assertThat(remoteConfig["non_existing_key"].asString())
+                .isEqualTo(FirebaseRemoteConfig.DEFAULT_VALUE_FOR_STRING)
+        assertThat(remoteConfig["another_non_exisiting_key"].asDouble())
+                .isEqualTo(FirebaseRemoteConfig.DEFAULT_VALUE_FOR_DOUBLE)
+    }
+
+    @Test
+    fun `Overloaded get() operator returns value when key exists`() {
+        val mockGetHandler = mock(ConfigGetParameterHandler::class.java)
+        val directExecutor = MoreExecutors.directExecutor()
+
+        val remoteConfig = createRemoteConfig(
+            context = null,
+            firebaseApp = Firebase.app(EXISTING_APP),
+            firebaseAbt = null,
+            executor = directExecutor,
+            fetchedConfigsCache = mock(ConfigCacheClient::class.java),
+            activatedConfigsCache = mock(ConfigCacheClient::class.java),
+            defaultConfigsCache = mock(ConfigCacheClient::class.java),
+            fetchHandler = mock(ConfigFetchHandler::class.java),
+            getHandler = mockGetHandler,
+            frcMetadata = mock(ConfigMetadataClient::class.java))
+
+        `when`(mockGetHandler.getValue("KEY")).thenReturn(StringRemoteConfigValue("non default value"))
+        assertThat(remoteConfig["KEY"].asString()).isEqualTo("non default value")
+    }
+}
diff --git a/test-apps/functions-test-app/src/main/AndroidManifest.xml b/firebase-config/src/androidTest/AndroidManifest.xml
similarity index 59%
rename from test-apps/functions-test-app/src/main/AndroidManifest.xml
rename to firebase-config/src/androidTest/AndroidManifest.xml
index 8450b8ef6..8dfe46a38 100644
--- a/test-apps/functions-test-app/src/main/AndroidManifest.xml
+++ b/firebase-config/src/androidTest/AndroidManifest.xml
@@ -1,10 +1,10 @@
-<?xml version="1.0" encoding="utf-8"?><!--
+<!--
   ~ Copyright 2018 Google LLC
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
   ~
+  ~ You may obtain a copy of the License at
   ~      http://www.apache.org/licenses/LICENSE-2.0
   ~
   ~ Unless required by applicable law or agreed to in writing, software
@@ -13,16 +13,18 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
+
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.google.firebase.testapps.functions">
-    <application
-        android:allowBackup="true"
-        android:supportsRtl="true">
-        <activity android:name=".TestActivity">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
+    package="com.google.firebase.inappmessaging">
+
+    <uses-sdk
+        android:targetSdkVersion="23"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <application>
+        <uses-library android:name="android.test.runner"/>
     </application>
-</manifest>
\ No newline at end of file
+
+    <instrumentation
+        android:name="com.google.android.apps.common.testing.testrunner.Google3InstrumentationTestRunner"
+        android:targetPackage="com.google.firebase.remoteconfig"/>
+</manifest>
diff --git a/firebase-config/src/androidTest/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigIntegrationTest.java b/firebase-config/src/androidTest/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigIntegrationTest.java
new file mode 100644
index 000000000..e42de0121
--- /dev/null
+++ b/firebase-config/src/androidTest/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigIntegrationTest.java
@@ -0,0 +1,177 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.content.res.Resources;
+import androidx.test.runner.AndroidJUnit4;
+import com.google.android.gms.tasks.Task;
+import com.google.android.gms.tasks.Tasks;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.FirebaseOptions;
+import com.google.firebase.abt.FirebaseABTesting;
+import com.google.firebase.remoteconfig.internal.ConfigCacheClient;
+import com.google.firebase.remoteconfig.internal.ConfigContainer;
+import com.google.firebase.remoteconfig.internal.ConfigFetchHandler;
+import com.google.firebase.remoteconfig.internal.ConfigGetParameterHandler;
+import com.google.firebase.remoteconfig.internal.ConfigMetadataClient;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Executor;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.skyscreamer.jsonassert.JSONAssert;
+
+@RunWith(AndroidJUnit4.class)
+public class FirebaseRemoteConfigIntegrationTest {
+  private static final String API_KEY = "api_key";
+  private static final String APP_ID = "1:14368190084:android:09cb977358c6f241";
+
+  @Mock private ConfigCacheClient mockFetchedCache;
+  @Mock private ConfigCacheClient mockActivatedCache;
+  @Mock private ConfigCacheClient mockDefaultsCache;
+  @Mock private ConfigFetchHandler mockFetchHandler;
+  @Mock private ConfigGetParameterHandler mockGetHandler;
+  @Mock private ConfigMetadataClient metadataClient;
+
+  @Mock private ConfigCacheClient mockFireperfFetchedCache;
+  @Mock private ConfigCacheClient mockFireperfActivatedCache;
+
+  @Mock private FirebaseABTesting mockFirebaseAbt;
+  private FirebaseRemoteConfig frc;
+
+  // We use a HashMap so that Mocking is easier.
+  private static final HashMap<String, String> DEFAULTS_MAP = Maps.newHashMap();
+
+  @Before
+  public void setUp() {
+    DEFAULTS_MAP.put("first_default_key", "first_default_value");
+    DEFAULTS_MAP.put("second_default_key", "second_default_value");
+    DEFAULTS_MAP.put("third_default_key", "third_default_value");
+
+    MockitoAnnotations.initMocks(this);
+    Executor directExecutor = MoreExecutors.directExecutor();
+
+    Context context = getInstrumentation().getTargetContext();
+    FirebaseApp.clearInstancesForTest();
+    FirebaseApp firebaseApp =
+        FirebaseApp.initializeApp(
+            context,
+            new FirebaseOptions.Builder().setApiKey(API_KEY).setApplicationId(APP_ID).build());
+
+    // Catch all to avoid NPEs (the getters should never return null).
+    when(mockFetchedCache.get()).thenReturn(Tasks.forResult(null));
+    when(mockActivatedCache.get()).thenReturn(Tasks.forResult(null));
+    when(mockFireperfFetchedCache.get()).thenReturn(Tasks.forResult(null));
+    when(mockFireperfActivatedCache.get()).thenReturn(Tasks.forResult(null));
+
+    frc =
+        new FirebaseRemoteConfig(
+            context,
+            firebaseApp,
+            mockFirebaseAbt,
+            directExecutor,
+            mockFetchedCache,
+            mockActivatedCache,
+            mockDefaultsCache,
+            mockFetchHandler,
+            mockGetHandler,
+            metadataClient);
+  }
+
+  @Test
+  public void setDefaults_goodXml_setsDefaults() throws Exception {
+    ConfigContainer goodDefaultsXmlContainer = newDefaultsContainer(DEFAULTS_MAP);
+
+    frc.setDefaults(getResourceId("frc_good_defaults"));
+
+    ArgumentCaptor<ConfigContainer> captor = ArgumentCaptor.forClass(ConfigContainer.class);
+    verify(mockDefaultsCache).putWithoutWaitingForDiskWrite(captor.capture());
+
+    JSONAssert.assertEquals(
+        captor.getValue().toString(), goodDefaultsXmlContainer.toString(), false);
+  }
+
+  @Test
+  public void setDefaultsAsync_goodXml_setsDefaults() throws Exception {
+    ConfigContainer goodDefaultsXmlContainer = newDefaultsContainer(DEFAULTS_MAP);
+    cachePutReturnsConfig(mockDefaultsCache, goodDefaultsXmlContainer);
+
+    Task<Void> task = frc.setDefaultsAsync(getResourceId("frc_good_defaults"));
+    Tasks.await(task);
+
+    // Assert defaults were set correctly.
+    ArgumentCaptor<ConfigContainer> captor = ArgumentCaptor.forClass(ConfigContainer.class);
+    verify(mockDefaultsCache).put(captor.capture());
+    assertThat(captor.getValue()).isEqualTo(goodDefaultsXmlContainer);
+  }
+
+  @Test
+  public void setDefaults_emptyXml_setsEmptyDefaults() throws Exception {
+    ConfigContainer emptyDefaultsXmlContainer = newDefaultsContainer(ImmutableMap.of());
+
+    frc.setDefaults(getResourceId("frc_empty_defaults"));
+
+    ArgumentCaptor<ConfigContainer> captor = ArgumentCaptor.forClass(ConfigContainer.class);
+    verify(mockDefaultsCache).putWithoutWaitingForDiskWrite(captor.capture());
+
+    assertThat(captor.getValue()).isEqualTo(emptyDefaultsXmlContainer);
+  }
+
+  @Test
+  public void setDefaults_badXml_ignoresBadEntries() throws Exception {
+    ConfigContainer badDefaultsXmlContainer =
+        newDefaultsContainer(ImmutableMap.of("second_default_key", "second_default_value"));
+
+    frc.setDefaults(getResourceId("frc_bad_defaults"));
+
+    ArgumentCaptor<ConfigContainer> captor = ArgumentCaptor.forClass(ConfigContainer.class);
+    verify(mockDefaultsCache).putWithoutWaitingForDiskWrite(captor.capture());
+
+    assertThat(captor.getValue()).isEqualTo(badDefaultsXmlContainer);
+  }
+
+  private static void cachePutReturnsConfig(
+      ConfigCacheClient cacheClient, ConfigContainer container) {
+    when(cacheClient.put(container)).thenReturn(Tasks.forResult(container));
+  }
+
+  private static ConfigContainer newDefaultsContainer(Map<String, String> configsMap)
+      throws Exception {
+    return ConfigContainer.newBuilder()
+        .replaceConfigsWith(configsMap)
+        .withFetchTime(new Date(0L))
+        .build();
+  }
+
+  private static int getResourceId(String xmlResourceName) {
+    Resources r = getInstrumentation().getTargetContext().getResources();
+    return r.getIdentifier(
+        xmlResourceName, "xml", getInstrumentation().getTargetContext().getPackageName());
+  }
+}
diff --git a/firebase-config/src/androidTest/res/xml/frc_bad_defaults.xml b/firebase-config/src/androidTest/res/xml/frc_bad_defaults.xml
new file mode 100644
index 000000000..91d5baacf
--- /dev/null
+++ b/firebase-config/src/androidTest/res/xml/frc_bad_defaults.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright 2018 Google LLC
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~
+  ~ You may obtain a copy of the License at
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<!-- START xml_defaults -->
+<defaultsMap>
+    <bad_entry>
+        <key>first_default_key</key>
+        <value>first_default_value</value>
+    </bad_entry>
+    <entry>
+        <key>second_default_key</key>
+        <value>second_default_value</value>
+    </entry>
+    <entry>
+        <bad_key>third_default_key</bad_key>
+        <value>third_default_value</value>
+    </entry>
+    <entry>
+        <key>fourth_default_key</key>
+        <bad_value>fourth_default_value</bad_value>
+    </entry>
+    <entry>
+        <key>
+            <value>fifth_default_value</value>
+            fifth_default_key
+        </key>
+    </entry>
+</defaultsMap>
+    <!-- END xml_defaults -->
+
diff --git a/test-apps/database-test-app/src/androidTest/AndroidManifest.xml b/firebase-config/src/androidTest/res/xml/frc_empty_defaults.xml
similarity index 75%
rename from test-apps/database-test-app/src/androidTest/AndroidManifest.xml
rename to firebase-config/src/androidTest/res/xml/frc_empty_defaults.xml
index 275a9f476..93d536767 100644
--- a/test-apps/database-test-app/src/androidTest/AndroidManifest.xml
+++ b/firebase-config/src/androidTest/res/xml/frc_empty_defaults.xml
@@ -1,10 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
 <!--
   ~ Copyright 2018 Google LLC
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
   ~
+  ~ You may obtain a copy of the License at
   ~      http://www.apache.org/licenses/LICENSE-2.0
   ~
   ~ Unless required by applicable law or agreed to in writing, software
@@ -14,7 +15,8 @@
   ~ limitations under the License.
   -->
 
-<manifest package="com.google.firebase.testapps.database"
-    xmlns:tools="http://schemas.android.com/tools">
-  <uses-sdk tools:overrideLibrary="android.support.test.uiautomator.v18"/>
-</manifest>
+<!-- START xml_defaults -->
+<defaultsMap>
+</defaultsMap>
+    <!-- END xml_defaults -->
+
diff --git a/test-apps/firestore-test-app/src/main/res/layout/test_activity.xml b/firebase-config/src/androidTest/res/xml/frc_good_defaults.xml
similarity index 58%
rename from test-apps/firestore-test-app/src/main/res/layout/test_activity.xml
rename to firebase-config/src/androidTest/res/xml/frc_good_defaults.xml
index b56c2066d..787026c49 100644
--- a/test-apps/firestore-test-app/src/main/res/layout/test_activity.xml
+++ b/firebase-config/src/androidTest/res/xml/frc_good_defaults.xml
@@ -1,11 +1,10 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
+<?xml version="1.0" encoding="utf-8"?><!--
   ~ Copyright 2018 Google LLC
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
   ~
+  ~ You may obtain a copy of the License at
   ~      http://www.apache.org/licenses/LICENSE-2.0
   ~
   ~ Unless required by applicable law or agreed to in writing, software
@@ -15,13 +14,18 @@
   ~ limitations under the License.
   -->
 
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent">
-  <TextView
-      android:id="@+id/restaurant"
-      android:layout_width="match_parent"
-      android:layout_height="wrap_content"
-      />
-
-</LinearLayout>
\ No newline at end of file
+<!-- START xml_defaults -->
+<defaults>
+    <entry>
+        <key>first_default_key</key>
+        <value>first_default_value</value>
+    </entry>
+    <entry>
+        <key>second_default_key</key>
+        <value>second_default_value</value>
+    </entry>
+    <entry>
+        <key>third_default_key</key>
+        <value>third_default_value</value>
+    </entry>
+</defaults><!-- END xml_defaults -->
\ No newline at end of file
diff --git a/firebase-config/src/main/AndroidManifest.xml b/firebase-config/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..bd731ed65
--- /dev/null
+++ b/firebase-config/src/main/AndroidManifest.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  ~ Copyright 2018 Google LLC
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~
+  ~ You may obtain a copy of the License at
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.firebase.remoteconfig">
+
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+    <uses-permission android:name="android.permission.INTERNET" />
+
+    <!--<uses-sdk android:minSdkVersion="16" />-->
+
+    <application>
+        <service
+            android:name="com.google.firebase.components.ComponentDiscoveryService"
+            android:exported="false">
+            <meta-data
+                android:name="com.google.firebase.components:com.google.firebase.remoteconfig.RemoteConfigRegistrar"
+                android:value="com.google.firebase.components.ComponentRegistrar" />
+        </service>
+    </application>
+</manifest>
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfig.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfig.java
new file mode 100644
index 000000000..572015180
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfig.java
@@ -0,0 +1,760 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import android.content.Context;
+import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import androidx.annotation.WorkerThread;
+import androidx.annotation.XmlRes;
+import com.google.android.gms.tasks.Task;
+import com.google.android.gms.tasks.Tasks;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.abt.AbtException;
+import com.google.firebase.abt.FirebaseABTesting;
+import com.google.firebase.remoteconfig.internal.ConfigCacheClient;
+import com.google.firebase.remoteconfig.internal.ConfigContainer;
+import com.google.firebase.remoteconfig.internal.ConfigFetchHandler;
+import com.google.firebase.remoteconfig.internal.ConfigFetchHandler.FetchResponse;
+import com.google.firebase.remoteconfig.internal.ConfigGetParameterHandler;
+import com.google.firebase.remoteconfig.internal.ConfigMetadataClient;
+import com.google.firebase.remoteconfig.internal.DefaultsXmlParser;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.Executor;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Entry point for the Firebase Remote Config (FRC) API.
+ *
+ * <p>Callers should first get the singleton object using {@link #getInstance()}, and then call
+ * operations on that singleton object. The singleton contains the complete set of FRC parameter
+ * values available to your app. The singleton also stores values fetched from the FRC Server until
+ * they are made available for use with a call to {@link #activate()}.
+ *
+ * @author Miraziz Yusupov
+ */
+public class FirebaseRemoteConfig {
+  // -------------------------------------------------------------------------------
+  // Firebase Android Components logic.
+
+  /**
+   * Returns a singleton instance of Firebase Remote Config.
+   *
+   * <p>{@link FirebaseRemoteConfig} uses the default {@link FirebaseApp}, so if no {@link
+   * FirebaseApp} has been initialized yet, this method throws an {@link IllegalStateException}.
+   *
+   * <p>To identify the current app instance, the fetch request creates a Firebase Instance ID
+   * token, which periodically sends data to the Firebase backend. To stop the periodic sync, call
+   * {@link com.google.firebase.iid.FirebaseInstanceId#deleteInstanceId}. To create a new token and
+   * resume the periodic sync, call {@code fetchConfig} again.
+   *
+   * @return A singleton instance of {@link FirebaseRemoteConfig} for the default {@link
+   *     FirebaseApp}.
+   */
+  @NonNull
+  public static FirebaseRemoteConfig getInstance() {
+    return getInstance(FirebaseApp.getInstance());
+  }
+
+  /** Returns an instance of Firebase Remote Config for the given {@link FirebaseApp}. */
+  @NonNull
+  public static FirebaseRemoteConfig getInstance(@NonNull FirebaseApp app) {
+    return app.get(RemoteConfigComponent.class).getDefault();
+  }
+
+  // -------------------------------------------------------------------------------
+  // Firebase Remote Config logic.
+
+  /** The static default string value for any given key. */
+  public static final String DEFAULT_VALUE_FOR_STRING = "";
+  /** The static default long value for any given key. */
+  public static final long DEFAULT_VALUE_FOR_LONG = 0L;
+  /** The static default double value for any given key. */
+  public static final double DEFAULT_VALUE_FOR_DOUBLE = 0D;
+  /** The static default boolean value for any given key. */
+  public static final boolean DEFAULT_VALUE_FOR_BOOLEAN = false;
+  /** The static default byte array value for any given key. */
+  public static final byte[] DEFAULT_VALUE_FOR_BYTE_ARRAY = new byte[0];
+
+  /** Indicates that the value returned is the static default value. */
+  public static final int VALUE_SOURCE_STATIC = 0;
+  /** Indicates that the value returned was retrieved from the defaults set by the client. */
+  public static final int VALUE_SOURCE_DEFAULT = 1;
+  /** Indicates that the value returned was retrieved from the Firebase Remote Config Server. */
+  public static final int VALUE_SOURCE_REMOTE = 2;
+
+  /**
+   * Indicates that the most recent fetch of parameter values from the Firebase Remote Config Server
+   * was completed successfully.
+   */
+  public static final int LAST_FETCH_STATUS_SUCCESS = -1;
+  /**
+   * Indicates that the FirebaseRemoteConfig singleton object has not yet attempted to fetch
+   * parameter values from the Firebase Remote Config Server.
+   */
+  public static final int LAST_FETCH_STATUS_NO_FETCH_YET = 0;
+  /**
+   * Indicates that the most recent attempt to fetch parameter values from the Firebase Remote
+   * Config Server has failed.
+   */
+  public static final int LAST_FETCH_STATUS_FAILURE = 1;
+  /**
+   * Indicates that the most recent attempt to fetch parameter values from the Firebase Remote
+   * Config Server was throttled.
+   */
+  public static final int LAST_FETCH_STATUS_THROTTLED = 2;
+
+  /**
+   * The general logging tag for all Firebase Remote Config logs.
+   *
+   * @hide
+   */
+  public static final String TAG = "FirebaseRemoteConfig";
+
+  private final Context context;
+  private final FirebaseApp firebaseApp;
+  /**
+   * Firebase A/B Testing (ABT) is only valid for the 3P namespace, so the ABT variable will be null
+   * if the current instance of Firebase Remote Config is using a non-3P namespace.
+   */
+  @Nullable private final FirebaseABTesting firebaseAbt;
+
+  private final Executor executor;
+  private final ConfigCacheClient fetchedConfigsCache;
+  private final ConfigCacheClient activatedConfigsCache;
+  private final ConfigCacheClient defaultConfigsCache;
+  private final ConfigFetchHandler fetchHandler;
+  private final ConfigGetParameterHandler getHandler;
+  private final ConfigMetadataClient frcMetadata;
+
+  /**
+   * Firebase Remote Config constructor.
+   *
+   * @hide
+   */
+  FirebaseRemoteConfig(
+      Context context,
+      FirebaseApp firebaseApp,
+      @Nullable FirebaseABTesting firebaseAbt,
+      Executor executor,
+      ConfigCacheClient fetchedConfigsCache,
+      ConfigCacheClient activatedConfigsCache,
+      ConfigCacheClient defaultConfigsCache,
+      ConfigFetchHandler fetchHandler,
+      ConfigGetParameterHandler getHandler,
+      ConfigMetadataClient frcMetadata) {
+    this.context = context;
+    this.firebaseApp = firebaseApp;
+    this.firebaseAbt = firebaseAbt;
+    this.executor = executor;
+    this.fetchedConfigsCache = fetchedConfigsCache;
+    this.activatedConfigsCache = activatedConfigsCache;
+    this.defaultConfigsCache = defaultConfigsCache;
+    this.fetchHandler = fetchHandler;
+    this.getHandler = getHandler;
+    this.frcMetadata = frcMetadata;
+  }
+
+  /**
+   * Returns a {@link Task} representing the initialization status of this Firebase Remote Config
+   * instance.
+   */
+  @NonNull
+  public Task<FirebaseRemoteConfigInfo> ensureInitialized() {
+    Task<ConfigContainer> activatedConfigsTask = activatedConfigsCache.get();
+    Task<ConfigContainer> defaultsConfigsTask = defaultConfigsCache.get();
+    Task<ConfigContainer> fetchedConfigsTask = fetchedConfigsCache.get();
+    Task<FirebaseRemoteConfigInfo> metadataTask = Tasks.call(executor, this::getInfo);
+
+    return Tasks.whenAllComplete(
+            activatedConfigsTask, defaultsConfigsTask, fetchedConfigsTask, metadataTask)
+        .continueWith(executor, (unusedListOfCompletedTasks) -> metadataTask.getResult());
+  }
+
+  /**
+   * Asynchronously fetches and then activates the fetched configs.
+   *
+   * <p>If the time elapsed since the last fetch from the Firebase Remote Config backend is more
+   * than the default minimum fetch interval, configs are fetched from the backend.
+   *
+   * <p>After the fetch is complete, the configs are activated so that the fetched key value pairs
+   * take effect.
+   *
+   * @return {@link Task} with a {@code true} result if the current call activated the fetched
+   *     configs; if no configs were fetched from the backend and the local fetched configs have
+   *     already been activated, returns a {@link Task} with a {@code false} result.
+   */
+  @NonNull
+  public Task<Boolean> fetchAndActivate() {
+    return fetch().onSuccessTask(executor, (unusedVoid) -> activate());
+  }
+
+  /**
+   * Activates the most recently fetched configs, so that the fetched key value pairs take effect.
+   *
+   * @return True if the current call activated the fetched configs; false if the fetched configs
+   *     were already activated by a previous call.
+   * @deprecated Use {@link #activate()} instead.
+   */
+  @Deprecated
+  @WorkerThread
+  public boolean activateFetched() {
+    @Nullable ConfigContainer fetchedContainer = fetchedConfigsCache.getBlocking();
+    if (fetchedContainer == null) {
+      return false;
+    }
+
+    // If the activated configs exist, verify that the fetched configs are fresher.
+    @Nullable ConfigContainer activatedContainer = activatedConfigsCache.getBlocking();
+    if (!isFetchedFresh(fetchedContainer, activatedContainer)) {
+      return false;
+    }
+
+    // Write the newly activated configs to disk, and then clear the fetched configs from disk.
+    // Fire and forget call, so consistency between disk and memory is not guaranteed.
+    activatedConfigsCache
+        .putWithoutWaitingForDiskWrite(fetchedContainer)
+        .addOnSuccessListener(
+            executor,
+            newlyActivatedContainer -> {
+              fetchedConfigsCache.clear();
+              updateAbtWithActivatedExperiments(newlyActivatedContainer.getAbtExperiments());
+            });
+    return true;
+  }
+
+  /**
+   * Asynchronously activates the most recently fetched configs, so that the fetched key value pairs
+   * take effect.
+   *
+   * @return {@link Task} with a {@code true} result if the current call activated the fetched
+   *     configs; if the fetched configs were already activated by a previous call, returns a {@link
+   *     Task} with a {@code false} result.
+   */
+  @NonNull
+  public Task<Boolean> activate() {
+    Task<ConfigContainer> fetchedConfigsTask = fetchedConfigsCache.get();
+    Task<ConfigContainer> activatedConfigsTask = activatedConfigsCache.get();
+
+    return Tasks.whenAllComplete(fetchedConfigsTask, activatedConfigsTask)
+        .continueWithTask(
+            executor,
+            (unusedListOfCompletedTasks) -> {
+              if (!fetchedConfigsTask.isSuccessful() || fetchedConfigsTask.getResult() == null) {
+                return Tasks.forResult(false);
+              }
+              ConfigContainer fetchedContainer = fetchedConfigsTask.getResult();
+
+              // If the activated configs exist, verify that the fetched configs are fresher.
+              if (activatedConfigsTask.isSuccessful()) {
+                @Nullable ConfigContainer activatedContainer = activatedConfigsTask.getResult();
+                if (!isFetchedFresh(fetchedContainer, activatedContainer)) {
+                  return Tasks.forResult(false);
+                }
+              }
+
+              return activatedConfigsCache
+                  .put(fetchedContainer)
+                  .continueWith(executor, this::processActivatePutTask);
+            });
+  }
+
+  /**
+   * Starts fetching configs, adhering to the default minimum fetch interval.
+   *
+   * <p>The fetched configs only take effect after the next {@link #activate} call.
+   *
+   * <p>Depending on the time elapsed since the last fetch from the Firebase Remote Config backend,
+   * configs are either served from local storage, or fetched from the backend. The default minimum
+   * fetch interval can be set with {@code
+   * FirebaseRemoteConfigSettings.Builder#setMinimumFetchIntervalInSeconds(long)}; the static
+   * default is 12 hours.
+   *
+   * <p>To identify the current app instance, the fetch request creates a Firebase Instance ID
+   * token, which periodically sends data to the Firebase backend. To stop the periodic sync, call
+   * {@link com.google.firebase.iid.FirebaseInstanceId#deleteInstanceId}. To create a new token and
+   * resume the periodic sync, call {@code fetchConfig} again.
+   *
+   * @return {@link Task} representing the {@code fetch} call.
+   */
+  @NonNull
+  public Task<Void> fetch() {
+    Task<FetchResponse> fetchTask = fetchHandler.fetch();
+
+    // Convert Task type to Void.
+    return fetchTask.onSuccessTask((unusedFetchResponse) -> Tasks.forResult(null));
+  }
+
+  /**
+   * Starts fetching configs, adhering to the specified minimum fetch interval.
+   *
+   * <p>The fetched configs only take effect after the next {@link #activate()} call.
+   *
+   * <p>Depending on the time elapsed since the last fetch from the Firebase Remote Config backend,
+   * configs are either served from local storage, or fetched from the backend.
+   *
+   * <p>To identify the current app instance, the fetch request creates a Firebase Instance ID
+   * token, which periodically sends data to the Firebase backend. To stop the periodic sync, call
+   * {@link com.google.firebase.iid.FirebaseInstanceId#deleteInstanceId}. To create a new token and
+   * resume the periodic sync, call {@code fetchConfig} again.
+   *
+   * @param minimumFetchIntervalInSeconds If configs in the local storage were fetched more than
+   *     this many seconds ago, configs are served from the backend instead of local storage.
+   * @return {@link Task} representing the {@code fetch} call.
+   */
+  @NonNull
+  public Task<Void> fetch(long minimumFetchIntervalInSeconds) {
+    Task<FetchResponse> fetchTask = fetchHandler.fetch(minimumFetchIntervalInSeconds);
+
+    // Convert Task type to Void.
+    return fetchTask.onSuccessTask((unusedFetchResponse) -> Tasks.forResult(null));
+  }
+
+  /**
+   * Returns the parameter value for the given key as a {@link String}.
+   *
+   * <p>Evaluates the value of the parameter in the following order:
+   *
+   * <ol>
+   *   <li>The activated value, if the last successful {@link #activate()} contained the key.
+   *   <li>The default value, if the key was set with {@link #setDefaultsAsync}.
+   *   <li>{@link #DEFAULT_VALUE_FOR_STRING}.
+   * </ol>
+   *
+   * @param key A Firebase Remote Config parameter key.
+   * @return {@link String} representing the value of the Firebase Remote Config parameter with the
+   *     given key.
+   */
+  @NonNull
+  public String getString(@NonNull String key) {
+    return getHandler.getString(key);
+  }
+
+  /**
+   * Returns the parameter value for the given key as a {@code boolean}.
+   *
+   * <p>Evaluates the value of the parameter in the following order:
+   *
+   * <ol>
+   *   <li>The activated value, if the last successful {@link #activate()} contained the key, and
+   *       the value can be converted into a {@code boolean}.
+   *   <li>The default value, if the key was set with {@link #setDefaultsAsync}, and the value can
+   *       be converted into a {@code boolean}.
+   *   <li>{@link #DEFAULT_VALUE_FOR_BOOLEAN}.
+   * </ol>
+   *
+   * <p>"1", "true", "t", "yes", "y", and "on" are strings that are interpreted (case insensitive)
+   * as {@code true}, and "0", "false", "f", "no", "n", "off", and empty string are interpreted
+   * (case insensitive) as {@code false}.
+   *
+   * @param key A Firebase Remote Config parameter key with a {@code boolean} parameter value.
+   * @return {@code boolean} representing the value of the Firebase Remote Config parameter with the
+   *     given key.
+   */
+  public boolean getBoolean(@NonNull String key) {
+    return getHandler.getBoolean(key);
+  }
+
+  /**
+   * Returns the parameter value for the given key as a {@code byte[]}.
+   *
+   * <p>Evaluates the value of the parameter in the following order:
+   *
+   * <ol>
+   *   <li>The activated value, if the last successful {@link #activate()} contained the key.
+   *   <li>The default value, if the key was set with {@link #setDefaultsAsync}.
+   *   <li>{@link #DEFAULT_VALUE_FOR_BYTE_ARRAY}.
+   * </ol>
+   *
+   * @param key A Firebase Remote Config parameter key.
+   * @return {@code byte[]} representing the value of the Firebase Remote Config parameter with the
+   *     given key.
+   */
+  @NonNull
+  @Deprecated
+  public byte[] getByteArray(@NonNull String key) {
+    return getHandler.getByteArray(key);
+  }
+
+  /**
+   * Returns the parameter value for the given key as a {@code double}.
+   *
+   * <p>Evaluates the value of the parameter in the following order:
+   *
+   * <ol>
+   *   <li>The activated value, if the last successful {@link #activate()} contained the key, and
+   *       the value can be converted into a {@code double}.
+   *   <li>The default value, if the key was set with {@link #setDefaultsAsync}, and the value can
+   *       be converted into a {@code double}.
+   *   <li>{@link #DEFAULT_VALUE_FOR_DOUBLE}.
+   * </ol>
+   *
+   * @param key A Firebase Remote Config parameter key with a {@code double} parameter value.
+   * @return {@code double} representing the value of the Firebase Remote Config parameter with the
+   *     given key.
+   */
+  public double getDouble(@NonNull String key) {
+    return getHandler.getDouble(key);
+  }
+
+  /**
+   * Returns the parameter value for the given key as a {@code long}.
+   *
+   * <p>Evaluates the value of the parameter in the following order:
+   *
+   * <ol>
+   *   <li>The activated value, if the last successful {@link #activate()} contained the key, and
+   *       the value can be converted into a {@code long}.
+   *   <li>The default value, if the key was set with {@link #setDefaultsAsync}, and the value can
+   *       be converted into a {@code long}.
+   *   <li>{@link #DEFAULT_VALUE_FOR_LONG}.
+   * </ol>
+   *
+   * @param key A Firebase Remote Config parameter key with a {@code long} parameter value.
+   * @return {@code long} representing the value of the Firebase Remote Config parameter with the
+   *     given key.
+   */
+  public long getLong(@NonNull String key) {
+    return getHandler.getLong(key);
+  }
+
+  /**
+   * Returns the parameter value for the given key as a {@link FirebaseRemoteConfigValue}.
+   *
+   * <p>Evaluates the value of the parameter in the following order:
+   *
+   * <ol>
+   *   <li>The activated value, if the last successful {@link #activate()} contained the key.
+   *   <li>The default value, if the key was set with {@link #setDefaultsAsync}.
+   *   <li>A {@link FirebaseRemoteConfigValue} that returns the static value for each type.
+   * </ol>
+   *
+   * @param key A Firebase Remote Config parameter key.
+   * @return {@link FirebaseRemoteConfigValue} representing the value of the Firebase Remote Config
+   *     parameter with the given key.
+   */
+  @NonNull
+  public FirebaseRemoteConfigValue getValue(@NonNull String key) {
+    return getHandler.getValue(key);
+  }
+
+  /**
+   * Returns a {@link Set} of all Firebase Remote Config parameter keys with the given prefix.
+   *
+   * @param prefix The key prefix to look for. If the prefix is empty, all keys are returned.
+   * @return {@link Set} of Remote Config parameter keys that start with the specified prefix.
+   */
+  @NonNull
+  public Set<String> getKeysByPrefix(@NonNull String prefix) {
+    return getHandler.getKeysByPrefix(prefix);
+  }
+
+  /**
+   * Returns a {@link Map} of Firebase Remote Config key value pairs.
+   *
+   * <p>Evaluates the values of the parameters in the following order:
+   *
+   * <ol>
+   *   <li>The activated value, if the last successful {@link #activate()} contained the key.
+   *   <li>The default value, if the key was set with {@link #setDefaultsAsync}.
+   * </ol>
+   */
+  @NonNull
+  public Map<String, FirebaseRemoteConfigValue> getAll() {
+    return getHandler.getAll();
+  }
+
+  /**
+   * Returns the state of this {@link FirebaseRemoteConfig} instance as a {@link
+   * FirebaseRemoteConfigInfo}.
+   */
+  @NonNull
+  public FirebaseRemoteConfigInfo getInfo() {
+    return frcMetadata.getInfo();
+  }
+
+  /**
+   * Changes the settings for this {@link FirebaseRemoteConfig} instance.
+   *
+   * @param settings The new settings to be applied.
+   * @deprecated Use {@link #setConfigSettingsAsync(FirebaseRemoteConfigSettings)} instead.
+   */
+  @Deprecated
+  public void setConfigSettings(@NonNull FirebaseRemoteConfigSettings settings) {
+    frcMetadata.setConfigSettingsWithoutWaitingOnDiskWrite(settings);
+  }
+
+  /**
+   * Asynchronously changes the settings for this {@link FirebaseRemoteConfig} instance.
+   *
+   * @param settings The new settings to be applied.
+   */
+  @NonNull
+  public Task<Void> setConfigSettingsAsync(@NonNull FirebaseRemoteConfigSettings settings) {
+    return Tasks.call(
+        executor,
+        () -> {
+          frcMetadata.setConfigSettings(settings);
+
+          // Return value required; return null for Void.
+          return null;
+        });
+  }
+
+  /**
+   * Sets default configs using the given {@link Map}.
+   *
+   * <p>The values in {@code defaults} must be one of the following types:
+   *
+   * <ul>
+   *   <li><code>Long</code>
+   *   <li><code>String</code>
+   *   <li><code>Double</code>
+   *   <li><code>byte[]</code>
+   *   <li><code>Boolean</code>
+   * </ul>
+   *
+   * @param defaults Map of key value pairs representing Firebase Remote Config parameter keys and
+   *     values.
+   * @deprecated Use {@link #setDefaultsAsync} instead.
+   */
+  @Deprecated
+  public void setDefaults(@NonNull Map<String, Object> defaults) {
+    // Fetch values from the server are in the Map<String, String> format, so match that here.
+    Map<String, String> defaultsStringMap = new HashMap<>();
+    for (Map.Entry<String, Object> defaultsEntry : defaults.entrySet()) {
+      defaultsStringMap.put(defaultsEntry.getKey(), defaultsEntry.getValue().toString());
+    }
+
+    setDefaultsWithStringsMap(defaultsStringMap);
+  }
+
+  /**
+   * Asynchronously sets default configs using the given {@link Map}.
+   *
+   * <p>The values in {@code defaults} must be one of the following types:
+   *
+   * <ul>
+   *   <li><code>byte[]</code>
+   *   <li><code>Boolean</code>
+   *   <li><code>Double</code>
+   *   <li><code>Long</code>
+   *   <li><code>String</code>
+   * </ul>
+   *
+   * @param defaults {@link Map} of key value pairs representing Firebase Remote Config parameter
+   *     keys and values.
+   */
+  @NonNull
+  public Task<Void> setDefaultsAsync(@NonNull Map<String, Object> defaults) {
+    // Fetch values from the server are in the Map<String, String> format, so match that here.
+    Map<String, String> defaultsStringMap = new HashMap<>();
+    for (Map.Entry<String, Object> defaultsEntry : defaults.entrySet()) {
+      defaultsStringMap.put(defaultsEntry.getKey(), defaultsEntry.getValue().toString());
+    }
+
+    return setDefaultsWithStringsMapAsync(defaultsStringMap);
+  }
+
+  /**
+   * Sets default configs using an XML resource.
+   *
+   * @param resourceId Id for the XML resource, which should be in your application's {@code
+   *     res/xml} folder.
+   * @deprecated Use {@link #setDefaultsAsync} instead.
+   */
+  @Deprecated
+  public void setDefaults(@XmlRes int resourceId) {
+    Map<String, String> xmlDefaults = DefaultsXmlParser.getDefaultsFromXml(context, resourceId);
+    setDefaultsWithStringsMap(xmlDefaults);
+  }
+
+  /**
+   * Sets default configs using an XML resource.
+   *
+   * @param resourceId Id for the XML resource, which should be in your application's {@code
+   *     res/xml} folder.
+   */
+  @NonNull
+  public Task<Void> setDefaultsAsync(@XmlRes int resourceId) {
+    Map<String, String> xmlDefaults = DefaultsXmlParser.getDefaultsFromXml(context, resourceId);
+    return setDefaultsWithStringsMapAsync(xmlDefaults);
+  }
+
+  /**
+   * Deletes all activated, fetched and defaults configs and resets all Firebase Remote Config
+   * settings.
+   *
+   * @return {@link Task} representing the {@code clear} call.
+   */
+  @NonNull
+  public Task<Void> reset() {
+    // Use a Task to avoid throwing potential file I/O errors to the caller and because
+    // frcMetadata's clear call is blocking.
+    return Tasks.call(
+        executor,
+        () -> {
+          activatedConfigsCache.clear();
+          fetchedConfigsCache.clear();
+          defaultConfigsCache.clear();
+          frcMetadata.clear();
+          return null;
+        });
+  }
+
+  /**
+   * Loads all the configs from disk by calling {@link ConfigCacheClient#get} on each cache client.
+   *
+   * @hide
+   */
+  void startLoadingConfigsFromDisk() {
+    activatedConfigsCache.get();
+    defaultConfigsCache.get();
+    fetchedConfigsCache.get();
+  }
+
+  /**
+   * Processes the result of the put task that persists activated configs. If the task is
+   * successful, clears the fetched cache and updates the ABT SDK with the current experiments.
+   *
+   * @param putTask the {@link Task} returned by a {@link ConfigCacheClient#put(ConfigContainer)}
+   *     call on {@link #activatedConfigsCache}.
+   * @return True if {@code putTask} was successful, false otherwise.
+   */
+  private boolean processActivatePutTask(Task<ConfigContainer> putTask) {
+    if (putTask.isSuccessful()) {
+      fetchedConfigsCache.clear();
+
+      // An activate call should only be made if there are fetched values to activate, which are
+      // then put into the activated cache. So, if the put is called and succeeds, then the returned
+      // values from the put task must be non-null.
+      if (putTask.getResult() != null) {
+        updateAbtWithActivatedExperiments(putTask.getResult().getAbtExperiments());
+      } else {
+        // Should never happen.
+        Log.e(TAG, "Activated configs written to disk are null.");
+      }
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * Asynchronously sets the defaults cache to the given default values, and persists the values to
+   * disk.
+   */
+  private void setDefaultsWithStringsMap(Map<String, String> defaultsStringMap) {
+    try {
+      ConfigContainer defaultConfigs =
+          ConfigContainer.newBuilder().replaceConfigsWith(defaultsStringMap).build();
+      defaultConfigsCache.putWithoutWaitingForDiskWrite(defaultConfigs);
+    } catch (JSONException e) {
+      Log.e(TAG, "The provided defaults map could not be processed.", e);
+    }
+  }
+
+  /**
+   * Asynchronously sets the defaults cache to the given default values, and persists the values to
+   * disk.
+   *
+   * @return A task with result {@code null} on failure.
+   */
+  private Task<Void> setDefaultsWithStringsMapAsync(Map<String, String> defaultsStringMap) {
+    ConfigContainer defaultConfigs = null;
+    try {
+      defaultConfigs = ConfigContainer.newBuilder().replaceConfigsWith(defaultsStringMap).build();
+    } catch (JSONException e) {
+      Log.e(TAG, "The provided defaults map could not be processed.", e);
+      return Tasks.forResult(null);
+    }
+
+    Task<ConfigContainer> putTask = defaultConfigsCache.put(defaultConfigs);
+    // Convert Task type to Void.
+    return putTask.onSuccessTask((unusedContainer) -> Tasks.forResult(null));
+  }
+
+  /**
+   * Notifies the Firebase A/B Testing SDK about activated experiments.
+   *
+   * @hide
+   */
+  // TODO(issues/255): Find a cleaner way to test ABT component dependency without
+  // having to make this method visible.
+  @VisibleForTesting
+  void updateAbtWithActivatedExperiments(@NonNull JSONArray abtExperiments) {
+    if (firebaseAbt == null) {
+      // If there is no firebaseAbt instance, then this FRC is either in a non-3P namespace or
+      // in a non-main FirebaseApp, so there is no reason to call ABT.
+      // For more info: RemoteConfigComponent#isAbtSupported.
+      return;
+    }
+
+    try {
+      List<Map<String, String>> experimentInfoMaps = toExperimentInfoMaps(abtExperiments);
+      firebaseAbt.replaceAllExperiments(experimentInfoMaps);
+    } catch (JSONException e) {
+      Log.e(TAG, "Could not parse ABT experiments from the JSON response.", e);
+    } catch (AbtException e) {
+      // TODO(issues/256): Find a way to log errors for all non-Analytics related exceptions
+      // without coupling the FRC and ABT SDKs.
+      Log.w(TAG, "Could not update ABT experiments.", e);
+    }
+  }
+
+  /**
+   * Converts a JSON array of Firebase A/B Testing experiments into a Java list of String maps.
+   *
+   * @param abtExperimentsJson A {@link JSONArray} of {@link JSONObject}s, where each object
+   *     represents a single experiment. Each {@link JSONObject} should only contain {@link String}
+   *     values.
+   * @return A {@link List} of {@code {@link Map}<String, String>}s, where each map represents a
+   *     single experiment.
+   * @throws JSONException If the {@code abtExperimentsJson} could not be converted into a list of
+   *     String maps.
+   */
+  @VisibleForTesting
+  static List<Map<String, String>> toExperimentInfoMaps(JSONArray abtExperimentsJson)
+      throws JSONException {
+    List<Map<String, String>> experimentInfoMaps = new ArrayList<>();
+    for (int index = 0; index < abtExperimentsJson.length(); index++) {
+      Map<String, String> experimentInfo = new HashMap<>();
+
+      JSONObject abtExperimentJson = abtExperimentsJson.getJSONObject(index);
+      Iterator<String> experimentJsonKeyIterator = abtExperimentJson.keys();
+      while (experimentJsonKeyIterator.hasNext()) {
+        String key = experimentJsonKeyIterator.next();
+        experimentInfo.put(key, abtExperimentJson.getString(key));
+      }
+
+      experimentInfoMaps.add(experimentInfo);
+    }
+    return experimentInfoMaps;
+  }
+
+  /** Returns true if the fetched configs are fresher than the activated configs. */
+  private static boolean isFetchedFresh(
+      ConfigContainer fetched, @Nullable ConfigContainer activated) {
+    return activated == null || !fetched.getFetchTime().equals(activated.getFetchTime());
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigClientException.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigClientException.java
new file mode 100644
index 000000000..269373025
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigClientException.java
@@ -0,0 +1,37 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+/**
+ * A Firebase Remote Config internal issue that isn't caused by an interaction with the Firebase
+ * Remote Config server.
+ *
+ * @author Miraziz Yusupov
+ */
+public class FirebaseRemoteConfigClientException extends FirebaseRemoteConfigException {
+  /** Creates a Firebase Remote Config client exception with the given message. */
+  public FirebaseRemoteConfigClientException(@NonNull String detailMessage) {
+    super(detailMessage);
+  }
+
+  /** Creates a Firebase Remote Config client exception with the given message and cause. */
+  public FirebaseRemoteConfigClientException(
+      @NonNull String detailMessage, @Nullable Throwable cause) {
+    super(detailMessage, cause);
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigException.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigException.java
new file mode 100644
index 000000000..edba0cb94
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigException.java
@@ -0,0 +1,32 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.google.firebase.FirebaseException;
+
+/** Base class for {@link FirebaseRemoteConfig} exceptions. */
+public class FirebaseRemoteConfigException extends FirebaseException {
+  /** Creates a Firebase Remote Config exception with the given message. */
+  public FirebaseRemoteConfigException(@NonNull String detailMessage) {
+    super(detailMessage);
+  }
+
+  /** Creates a Firebase Remote Config exception with the given message and cause. */
+  public FirebaseRemoteConfigException(@NonNull String detailMessage, @Nullable Throwable cause) {
+    super(detailMessage, cause);
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigFetchException.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigFetchException.java
new file mode 100644
index 000000000..6479012f3
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigFetchException.java
@@ -0,0 +1,39 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+/**
+ * Exception thrown when the {@link FirebaseRemoteConfig#fetch()} operation cannot be completed
+ * successfully.
+ *
+ * @deprecated Use {@link FirebaseRemoteConfigServerException} or {@link
+ *     FirebaseRemoteConfigClientException} instead.
+ */
+@Deprecated
+public class FirebaseRemoteConfigFetchException extends FirebaseRemoteConfigException {
+  /** Creates a Firebase Remote Config fetch exception with the given message. */
+  public FirebaseRemoteConfigFetchException(@NonNull String detailMessage) {
+    super(detailMessage);
+  }
+
+  /** Creates a Firebase Remote Config fetch exception with the given message and cause. */
+  public FirebaseRemoteConfigFetchException(
+      @NonNull String detailMessage, @Nullable Throwable cause) {
+    super(detailMessage, cause);
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigFetchThrottledException.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigFetchThrottledException.java
new file mode 100644
index 000000000..a715319da
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigFetchThrottledException.java
@@ -0,0 +1,52 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+/** An exception thrown when a {@link FirebaseRemoteConfig#fetch()} call is throttled. */
+public class FirebaseRemoteConfigFetchThrottledException
+    extends FirebaseRemoteConfigFetchException {
+  private final long throttleEndTimeMillis;
+
+  /**
+   * Creates a throttled exception with the earliest time that a fetch call might be made without
+   * being throttled.
+   *
+   * @param throttleEndTimeMillis the time, in millis since epoch, until which all fetch calls will
+   *     be throttled.
+   */
+  public FirebaseRemoteConfigFetchThrottledException(long throttleEndTimeMillis) {
+    this("Fetch was throttled.", throttleEndTimeMillis);
+  }
+
+  /**
+   * Creates a throttled exception with the given message and the earliest time that a fetch call
+   * might be made without being throttled.
+   *
+   * @param message The error message to display to callers.
+   * @param throttledEndTimeInMillis the time, in millis since epoch, until which all fetch calls
+   *     will be throttled.
+   * @hide
+   */
+  public FirebaseRemoteConfigFetchThrottledException(
+      String message, long throttledEndTimeInMillis) {
+    super(message);
+    throttleEndTimeMillis = throttledEndTimeInMillis;
+  }
+
+  /** Returns the time, in millis since epoch, until which all fetch calls will be throttled. */
+  public long getThrottleEndTimeMillis() {
+    return throttleEndTimeMillis;
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigInfo.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigInfo.java
new file mode 100644
index 000000000..00b32bf29
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigInfo.java
@@ -0,0 +1,47 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import androidx.annotation.NonNull;
+
+/** Wraps the current state of the FirebaseRemoteConfig singleton object. */
+public interface FirebaseRemoteConfigInfo {
+  /**
+   * Gets the timestamp (milliseconds since epoch) of the last successful fetch, regardless of
+   * whether the fetch was activated or not.
+   *
+   * @return -1 if no fetch attempt has been made yet. Otherwise, returns the timestamp of the last
+   *     successful fetch operation.
+   */
+  long getFetchTimeMillis();
+
+  /**
+   * Gets the status of the most recent fetch attempt.
+   *
+   * @return Will return one of {@link FirebaseRemoteConfig#LAST_FETCH_STATUS_SUCCESS}, {@link
+   *     FirebaseRemoteConfig#LAST_FETCH_STATUS_FAILURE}, {@link
+   *     FirebaseRemoteConfig#LAST_FETCH_STATUS_THROTTLED}, or {@link
+   *     FirebaseRemoteConfig#LAST_FETCH_STATUS_NO_FETCH_YET}.
+   */
+  int getLastFetchStatus();
+
+  /**
+   * Gets the current settings of the FirebaseRemoteConfig singleton object.
+   *
+   * @return A {@link FirebaseRemoteConfigSettings} object indicating the current settings.
+   */
+  @NonNull
+  FirebaseRemoteConfigSettings getConfigSettings();
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigServerException.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigServerException.java
new file mode 100644
index 000000000..723ddd6a5
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigServerException.java
@@ -0,0 +1,50 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+/**
+ * A Firebase Remote Config internal issue caused by an interaction with the Firebase Remote Config
+ * server.
+ *
+ * @author Miraziz Yusupov
+ */
+public class FirebaseRemoteConfigServerException extends FirebaseRemoteConfigException {
+  private final int httpStatusCode;
+
+  /**
+   * Creates a Firebase Remote Config server exception with the given message and HTTP status code.
+   */
+  public FirebaseRemoteConfigServerException(int httpStatusCode, @NonNull String detailMessage) {
+    super(detailMessage);
+    this.httpStatusCode = httpStatusCode;
+  }
+
+  /**
+   * Creates a Firebase Remote Config server exception with the given message, HTTP status code and
+   */
+  public FirebaseRemoteConfigServerException(
+      int httpStatusCode, @NonNull String detailMessage, @Nullable Throwable cause) {
+    super(detailMessage, cause);
+    this.httpStatusCode = httpStatusCode;
+  }
+
+  /** Gets the HTTP status code of the failed Firebase Remote Config server operation. */
+  public int getHttpStatusCode() {
+    return httpStatusCode;
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigSettings.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigSettings.java
new file mode 100644
index 000000000..e1b32dfc9
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigSettings.java
@@ -0,0 +1,145 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import static com.google.firebase.remoteconfig.RemoteConfigComponent.NETWORK_CONNECTION_TIMEOUT_IN_SECONDS;
+import static com.google.firebase.remoteconfig.internal.ConfigFetchHandler.DEFAULT_MINIMUM_FETCH_INTERVAL_IN_SECONDS;
+
+import androidx.annotation.NonNull;
+
+/**
+ * Wraps the settings for {@link FirebaseRemoteConfig} operations.
+ *
+ * @author Lucas Png
+ */
+public class FirebaseRemoteConfigSettings {
+  private final boolean enableDeveloperMode;
+  private final long fetchTimeoutInSeconds;
+  private final long minimumFetchInterval;
+
+  private FirebaseRemoteConfigSettings(Builder builder) {
+    enableDeveloperMode = builder.enableDeveloperMode;
+    fetchTimeoutInSeconds = builder.fetchTimeoutInSeconds;
+    minimumFetchInterval = builder.minimumFetchInterval;
+  }
+
+  /**
+   * Indicates the status of the developer mode setting.
+   *
+   * @return <code>true</code> if the developer mode is enabled, <code>false</code> otherwise.
+   * @deprecated Use {@link #getMinimumFetchIntervalInSeconds()} instead.
+   */
+  @Deprecated
+  public boolean isDeveloperModeEnabled() {
+    return enableDeveloperMode;
+  }
+
+  /**
+   * Returns the fetch timeout in seconds.
+   *
+   * <p>The timeout specifies how long the client should wait for a connection to the Firebase
+   * Remote Config servers.
+   */
+  public long getFetchTimeoutInSeconds() {
+    return fetchTimeoutInSeconds;
+  }
+
+  /** Returns the minimum interval between successive fetches calls in seconds. */
+  public long getMinimumFetchIntervalInSeconds() {
+    return minimumFetchInterval;
+  }
+
+  /** Constructs a builder initialized with the current FirebaseRemoteConfigSettings. */
+  @NonNull
+  public FirebaseRemoteConfigSettings.Builder toBuilder() {
+    FirebaseRemoteConfigSettings.Builder frcBuilder = new FirebaseRemoteConfigSettings.Builder();
+    frcBuilder.setDeveloperModeEnabled(this.isDeveloperModeEnabled());
+    frcBuilder.setFetchTimeoutInSeconds(this.getFetchTimeoutInSeconds());
+    frcBuilder.setMinimumFetchIntervalInSeconds(this.getMinimumFetchIntervalInSeconds());
+    return frcBuilder;
+  }
+
+  /** Builder for a {@link FirebaseRemoteConfigSettings}. */
+  public static class Builder {
+    private boolean enableDeveloperMode = false;
+    // TODO(issues/257): Move constants to Constants file.
+    private long fetchTimeoutInSeconds = NETWORK_CONNECTION_TIMEOUT_IN_SECONDS;
+    private long minimumFetchInterval = DEFAULT_MINIMUM_FETCH_INTERVAL_IN_SECONDS;
+
+    /**
+     * Turns the developer mode setting on or off.
+     *
+     * @param enabled Should be <code>true</code> to enable, or <code>false</code> to disable this
+     *     setting.
+     * @deprecated Use {@link #setMinimumFetchIntervalInSeconds(long)} instead.
+     */
+    @NonNull
+    @Deprecated
+    public Builder setDeveloperModeEnabled(boolean enabled) {
+      enableDeveloperMode = enabled;
+      return this;
+    }
+
+    /**
+     * Sets the connection timeout for fetch requests to the Firebase Remote Config servers in
+     * seconds.
+     *
+     * <p>A fetch call will fail if it takes longer than the specified timeout to connect to the
+     * Remote Config servers.
+     *
+     * @param duration Timeout duration in seconds. Should be a non-negative number.
+     */
+    @NonNull
+    public Builder setFetchTimeoutInSeconds(long duration) throws IllegalArgumentException {
+      if (duration < 0) {
+        throw new IllegalArgumentException(
+            String.format(
+                "Fetch connection timeout has to be a non-negative number. "
+                    + "%d is an invalid argument",
+                duration));
+      }
+      fetchTimeoutInSeconds = duration;
+      return this;
+    }
+
+    /**
+     * Sets the minimum interval between successive fetch calls.
+     *
+     * <p>Fetches less than {@code duration} seconds after the last fetch from the Firebase Remote
+     * Config server would use values returned during the last fetch.
+     *
+     * @param duration Interval duration in seconds. Should be a non-negative number.
+     */
+    @NonNull
+    public Builder setMinimumFetchIntervalInSeconds(long duration) {
+      if (duration < 0) {
+        throw new IllegalArgumentException(
+            "Minimum interval between fetches has to be a non-negative number. "
+                + duration
+                + " is an invalid argument");
+      }
+      minimumFetchInterval = duration;
+      return this;
+    }
+
+    /**
+     * Returns a {@link FirebaseRemoteConfigSettings} with the settings provided to this builder.
+     */
+    @NonNull
+    public FirebaseRemoteConfigSettings build() {
+      return new FirebaseRemoteConfigSettings(this);
+    }
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigValue.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigValue.java
new file mode 100644
index 000000000..0106f2622
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigValue.java
@@ -0,0 +1,68 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import androidx.annotation.NonNull;
+
+/** Wrapper for a Remote Config parameter value, with methods to get it as different types. */
+public interface FirebaseRemoteConfigValue {
+  /**
+   * Gets the value as a <code>long</code>.
+   *
+   * @return <code>long</code> representation of this parameter value.
+   * @throws IllegalArgumentException If the value cannot be converted to a <code>long</code>.
+   */
+  long asLong() throws IllegalArgumentException;
+  /**
+   * Gets the value as a <code>double</code>.
+   *
+   * @return <code>double</code> representation of this parameter value.
+   * @throws IllegalArgumentException If the value cannot be converted to a <code>double</code>.
+   */
+  double asDouble() throws IllegalArgumentException;
+
+  /**
+   * Gets the value as a <code>String</code>.
+   *
+   * @return <code>String</code> representation of this parameter value.
+   */
+  @NonNull
+  String asString();
+
+  /**
+   * Gets the value as a <code>byte[]</code>.
+   *
+   * @return <code>byte[]</code> representation of this parameter value.
+   */
+  @NonNull
+  byte[] asByteArray();
+  /**
+   * Gets the value as a <code>boolean</code>.
+   *
+   * @return <code>boolean</code> representation of this parameter value.
+   * @throws IllegalArgumentException If the value cannot be converted to a <code>boolean</code>.
+   */
+  boolean asBoolean() throws IllegalArgumentException;
+
+  /**
+   * Indicates at which source this value came from.
+   *
+   * @return {@link FirebaseRemoteConfig#VALUE_SOURCE_REMOTE} if the value was retrieved from the
+   *     server, {@link FirebaseRemoteConfig#VALUE_SOURCE_DEFAULT} if the value was set as a
+   *     default, or {@link FirebaseRemoteConfig#VALUE_SOURCE_STATIC} if no value was found and a
+   *     static default value was returned instead.
+   */
+  int getSource();
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/RemoteConfigComponent.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/RemoteConfigComponent.java
new file mode 100644
index 000000000..178e9a3bf
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/RemoteConfigComponent.java
@@ -0,0 +1,292 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import androidx.annotation.GuardedBy;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import com.google.android.gms.common.annotation.KeepForSdk;
+import com.google.android.gms.common.util.Clock;
+import com.google.android.gms.common.util.DefaultClock;
+import com.google.android.gms.tasks.Tasks;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.abt.FirebaseABTesting;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.remoteconfig.internal.ConfigCacheClient;
+import com.google.firebase.remoteconfig.internal.ConfigFetchHandler;
+import com.google.firebase.remoteconfig.internal.ConfigFetchHttpClient;
+import com.google.firebase.remoteconfig.internal.ConfigGetParameterHandler;
+import com.google.firebase.remoteconfig.internal.ConfigMetadataClient;
+import com.google.firebase.remoteconfig.internal.ConfigStorageClient;
+import com.google.firebase.remoteconfig.internal.LegacyConfigsHandler;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+/**
+ * Component for providing multiple Firebase Remote Config (FRC) instances. Firebase Android
+ * Components uses this class to retrieve instances of FRC for dependency injection.
+ *
+ * <p>A unique FRC instance is returned for each {{@link FirebaseApp}, {@code namespace}}
+ * combination.
+ *
+ * @author Miraziz Yusupov
+ * @hide
+ */
+@KeepForSdk
+public class RemoteConfigComponent {
+  /** Name of the file where activated configs are stored. */
+  public static final String ACTIVATE_FILE_NAME = "activate";
+  /** Name of the file where fetched configs are stored. */
+  public static final String FETCH_FILE_NAME = "fetch";
+  /** Name of the file where defaults configs are stored. */
+  public static final String DEFAULTS_FILE_NAME = "defaults";
+  /** Timeout for the call to the Firebase Remote Config servers in second. */
+  public static final long NETWORK_CONNECTION_TIMEOUT_IN_SECONDS = 60;
+
+  private static final String FIREBASE_REMOTE_CONFIG_FILE_NAME_PREFIX = "frc";
+  private static final String PREFERENCES_FILE_NAME = "settings";
+
+  @VisibleForTesting public static final String DEFAULT_NAMESPACE = "firebase";
+
+  private static final Clock DEFAULT_CLOCK = DefaultClock.getInstance();
+  private static final Random DEFAULT_RANDOM = new Random();
+
+  @GuardedBy("this")
+  private final Map<String, FirebaseRemoteConfig> frcNamespaceInstances = new HashMap<>();
+
+  private final Context context;
+  private final ExecutorService executorService;
+  private final FirebaseApp firebaseApp;
+  private final FirebaseInstanceId firebaseInstanceId;
+  private final FirebaseABTesting firebaseAbt;
+  @Nullable private final AnalyticsConnector analyticsConnector;
+
+  private final String appId;
+
+  @GuardedBy("this")
+  private Map<String, String> customHeaders = new HashMap<>();
+
+  /** Firebase Remote Config Component constructor. */
+  RemoteConfigComponent(
+      Context context,
+      FirebaseApp firebaseApp,
+      FirebaseInstanceId firebaseInstanceId,
+      FirebaseABTesting firebaseAbt,
+      @Nullable AnalyticsConnector analyticsConnector) {
+    this(
+        context,
+        Executors.newCachedThreadPool(),
+        firebaseApp,
+        firebaseInstanceId,
+        firebaseAbt,
+        analyticsConnector,
+        new LegacyConfigsHandler(context, firebaseApp.getOptions().getApplicationId()),
+        /* loadGetDefault= */ true);
+  }
+
+  /** Firebase Remote Config Component constructor for testing component logic. */
+  @VisibleForTesting
+  protected RemoteConfigComponent(
+      Context context,
+      ExecutorService executorService,
+      FirebaseApp firebaseApp,
+      FirebaseInstanceId firebaseInstanceId,
+      FirebaseABTesting firebaseAbt,
+      @Nullable AnalyticsConnector analyticsConnector,
+      LegacyConfigsHandler legacyConfigsHandler,
+      boolean loadGetDefault) {
+    this.context = context;
+    this.executorService = executorService;
+    this.firebaseApp = firebaseApp;
+    this.firebaseInstanceId = firebaseInstanceId;
+    this.firebaseAbt = firebaseAbt;
+    this.analyticsConnector = analyticsConnector;
+
+    this.appId = firebaseApp.getOptions().getApplicationId();
+
+    // When the component is first loaded, it will use a cached executor.
+    // The getDefault call creates race conditions in tests, where the getDefault might be executing
+    // while another test has already cleared the component but hasn't gotten a new one yet.
+    if (loadGetDefault) {
+      // Loads the default namespace's configs from disk on App startup.
+      Tasks.call(executorService, this::getDefault);
+      Tasks.call(executorService, legacyConfigsHandler::saveLegacyConfigsIfNecessary);
+    }
+  }
+
+  /**
+   * Returns the default Firebase Remote Config instance for this component's {@link FirebaseApp}.
+   */
+  FirebaseRemoteConfig getDefault() {
+    return get(DEFAULT_NAMESPACE);
+  }
+
+  /**
+   * Returns the Firebase Remote Config instance associated with the given {@code namespace} and
+   * this component's {@link FirebaseApp}.
+   *
+   * @param namespace a 2P's namespace, or, for the 3P App, the default namespace.
+   */
+  @VisibleForTesting
+  @KeepForSdk
+  public synchronized FirebaseRemoteConfig get(String namespace) {
+    ConfigCacheClient fetchedCacheClient = getCacheClient(namespace, FETCH_FILE_NAME);
+    ConfigCacheClient activatedCacheClient = getCacheClient(namespace, ACTIVATE_FILE_NAME);
+    ConfigCacheClient defaultsCacheClient = getCacheClient(namespace, DEFAULTS_FILE_NAME);
+    ConfigMetadataClient metadataClient = getMetadataClient(context, appId, namespace);
+    return get(
+        firebaseApp,
+        namespace,
+        firebaseAbt,
+        executorService,
+        fetchedCacheClient,
+        activatedCacheClient,
+        defaultsCacheClient,
+        getFetchHandler(namespace, fetchedCacheClient, metadataClient),
+        getGetHandler(activatedCacheClient, defaultsCacheClient),
+        metadataClient);
+  }
+
+  @VisibleForTesting
+  synchronized FirebaseRemoteConfig get(
+      FirebaseApp firebaseApp,
+      String namespace,
+      FirebaseABTesting firebaseAbt,
+      Executor executor,
+      ConfigCacheClient fetchedClient,
+      ConfigCacheClient activatedClient,
+      ConfigCacheClient defaultsClient,
+      ConfigFetchHandler fetchHandler,
+      ConfigGetParameterHandler getHandler,
+      ConfigMetadataClient metadataClient) {
+    if (!frcNamespaceInstances.containsKey(namespace)) {
+      FirebaseRemoteConfig in =
+          new FirebaseRemoteConfig(
+              context,
+              firebaseApp,
+              isAbtSupported(firebaseApp, namespace) ? firebaseAbt : null,
+              executor,
+              fetchedClient,
+              activatedClient,
+              defaultsClient,
+              fetchHandler,
+              getHandler,
+              metadataClient);
+      in.startLoadingConfigsFromDisk();
+      frcNamespaceInstances.put(namespace, in);
+    }
+    return frcNamespaceInstances.get(namespace);
+  }
+
+  @VisibleForTesting
+  public synchronized void setCustomHeaders(Map<String, String> customHeaders) {
+    this.customHeaders = customHeaders;
+  }
+
+  private ConfigCacheClient getCacheClient(String namespace, String configStoreType) {
+    return getCacheClient(context, appId, namespace, configStoreType);
+  }
+
+  /**
+   * The {@link LegacyConfigsHandler} needs access to multiple cache clients, and the simplest way
+   * to provide it access is to keep this method public and static.
+   */
+  public static ConfigCacheClient getCacheClient(
+      Context context, String appId, String namespace, String configStoreType) {
+    String fileName =
+        String.format(
+            "%s_%s_%s_%s.json",
+            FIREBASE_REMOTE_CONFIG_FILE_NAME_PREFIX, appId, namespace, configStoreType);
+    return ConfigCacheClient.getInstance(
+        Executors.newCachedThreadPool(), ConfigStorageClient.getInstance(context, fileName));
+  }
+
+  @VisibleForTesting
+  ConfigFetchHttpClient getFrcBackendApiClient(
+      String apiKey, String namespace, ConfigMetadataClient metadataClient) {
+    String appId = firebaseApp.getOptions().getApplicationId();
+    return new ConfigFetchHttpClient(
+        context,
+        appId,
+        apiKey,
+        namespace,
+        metadataClient.getFetchTimeoutInSeconds(),
+        NETWORK_CONNECTION_TIMEOUT_IN_SECONDS);
+  }
+
+  @VisibleForTesting
+  synchronized ConfigFetchHandler getFetchHandler(
+      String namespace, ConfigCacheClient fetchedCacheClient, ConfigMetadataClient metadataClient) {
+    return new ConfigFetchHandler(
+        firebaseInstanceId,
+        isPrimaryApp(firebaseApp) ? analyticsConnector : null,
+        executorService,
+        DEFAULT_CLOCK,
+        DEFAULT_RANDOM,
+        fetchedCacheClient,
+        getFrcBackendApiClient(firebaseApp.getOptions().getApiKey(), namespace, metadataClient),
+        metadataClient,
+        this.customHeaders);
+  }
+
+  private ConfigGetParameterHandler getGetHandler(
+      ConfigCacheClient activatedCacheClient, ConfigCacheClient defaultsCacheClient) {
+    return new ConfigGetParameterHandler(activatedCacheClient, defaultsCacheClient);
+  }
+
+  @VisibleForTesting
+  static ConfigMetadataClient getMetadataClient(Context context, String appId, String namespace) {
+    String fileName =
+        String.format(
+            "%s_%s_%s_%s",
+            FIREBASE_REMOTE_CONFIG_FILE_NAME_PREFIX, appId, namespace, PREFERENCES_FILE_NAME);
+    SharedPreferences preferences = context.getSharedPreferences(fileName, Context.MODE_PRIVATE);
+    return new ConfigMetadataClient(preferences);
+  }
+
+  /**
+   * Checks if ABT can be used in the given {@code firebaseApp} and {@code namespace}.
+   *
+   * <p>The Firebase A/B Testing SDK uses Analytics to update experiments, so, since Analytics does
+   * not work outside the primary {@link FirebaseApp}, ABT should not be used outside the primary
+   * App.
+   *
+   * <p>The ABT product is only available to 3P developers and does not work for other Firebase
+   * SDKs, so ABT should not be used outside the 3P namespace.
+   *
+   * @return True if {@code firebaseApp} is the main {@link FirebaseApp} and {@code namespace} is
+   *     the 3P namespace.
+   */
+  private static boolean isAbtSupported(FirebaseApp firebaseApp, String namespace) {
+    return namespace.equals(DEFAULT_NAMESPACE) && isPrimaryApp(firebaseApp);
+  }
+
+  /**
+   * Returns true if {@code firebaseApp} is the main {@link FirebaseApp}.
+   *
+   * <p>Analytics and, by extension, Firebase A/B Testing only support the primary {@link
+   * FirebaseApp}.
+   */
+  private static boolean isPrimaryApp(FirebaseApp firebaseApp) {
+    return firebaseApp.getName().equals(FirebaseApp.DEFAULT_APP_NAME);
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/RemoteConfigConstants.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/RemoteConfigConstants.java
new file mode 100644
index 000000000..9a49bf7a5
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/RemoteConfigConstants.java
@@ -0,0 +1,101 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ExperimentDescriptionFieldKey.EXPERIMENT_ID;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ExperimentDescriptionFieldKey.VARIANT_ID;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.ANALYTICS_USER_PROPERTIES;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.APP_ID;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.APP_VERSION;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.COUNTRY_CODE;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.INSTANCE_ID;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.INSTANCE_ID_TOKEN;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.LANGUAGE_CODE;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.PACKAGE_NAME;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.PLATFORM_VERSION;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.SDK_VERSION;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.TIME_ZONE;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ResponseFieldKey.ENTRIES;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ResponseFieldKey.EXPERIMENT_DESCRIPTIONS;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ResponseFieldKey.STATE;
+
+import androidx.annotation.StringDef;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Constants used throughout the Firebase Remote Config SDK.
+ *
+ * @author Lucas Png
+ * @hide
+ */
+public class RemoteConfigConstants {
+  public static final String FETCH_REGEX_URL =
+      "https://firebaseremoteconfig.googleapis.com/v1/projects/%s/namespaces/%s:fetch";
+
+  /**
+   * Keys of fields in the Fetch request body that the client sends to the Firebase Remote Config
+   * server.
+   */
+  @StringDef({
+    INSTANCE_ID,
+    INSTANCE_ID_TOKEN,
+    APP_ID,
+    COUNTRY_CODE,
+    LANGUAGE_CODE,
+    PLATFORM_VERSION,
+    TIME_ZONE,
+    APP_VERSION,
+    PACKAGE_NAME,
+    SDK_VERSION,
+    ANALYTICS_USER_PROPERTIES
+  })
+  @Retention(RetentionPolicy.SOURCE)
+  public @interface RequestFieldKey {
+    String INSTANCE_ID = "appInstanceId";
+    String INSTANCE_ID_TOKEN = "appInstanceIdToken";
+    String APP_ID = "appId";
+    String COUNTRY_CODE = "countryCode";
+    String LANGUAGE_CODE = "languageCode";
+    String PLATFORM_VERSION = "platformVersion";
+    String TIME_ZONE = "timeZone";
+    String APP_VERSION = "appVersion";
+    String PACKAGE_NAME = "packageName";
+    String SDK_VERSION = "sdkVersion";
+    String ANALYTICS_USER_PROPERTIES = "analyticsUserProperties";
+  }
+
+  /** Keys of fields in the Fetch response body from the Firebase Remote Config server. */
+  @StringDef({ENTRIES, EXPERIMENT_DESCRIPTIONS, STATE})
+  @Retention(RetentionPolicy.SOURCE)
+  public @interface ResponseFieldKey {
+    String ENTRIES = "entries";
+    String EXPERIMENT_DESCRIPTIONS = "experimentDescriptions";
+    String STATE = "state";
+  }
+
+  /**
+   * Select keys of fields in the experiment descriptions returned from the Firebase Remote Config
+   * server.
+   */
+  @StringDef({EXPERIMENT_ID, VARIANT_ID})
+  @Retention(RetentionPolicy.SOURCE)
+  public @interface ExperimentDescriptionFieldKey {
+    String EXPERIMENT_ID = "experimentId";
+    String VARIANT_ID = "variantId";
+  }
+
+  private RemoteConfigConstants() {}
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/RemoteConfigRegistrar.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/RemoteConfigRegistrar.java
new file mode 100644
index 000000000..62bf8087f
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/RemoteConfigRegistrar.java
@@ -0,0 +1,61 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import android.content.Context;
+import androidx.annotation.Keep;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.abt.FirebaseABTesting.OriginService;
+import com.google.firebase.abt.component.AbtComponent;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.components.Component;
+import com.google.firebase.components.ComponentRegistrar;
+import com.google.firebase.components.Dependency;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.platforminfo.LibraryVersionComponent;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Registrar for setting up Firebase Remote Config's dependency injections in Firebase Android
+ * Components.
+ *
+ * @author Miraziz Yusupov
+ * @hide
+ */
+@Keep
+public class RemoteConfigRegistrar implements ComponentRegistrar {
+  @Override
+  public List<Component<?>> getComponents() {
+    return Arrays.asList(
+        Component.builder(RemoteConfigComponent.class)
+            .add(Dependency.required(Context.class))
+            .add(Dependency.required(FirebaseApp.class))
+            .add(Dependency.required(FirebaseInstanceId.class))
+            .add(Dependency.required(AbtComponent.class))
+            .add(Dependency.optional(AnalyticsConnector.class))
+            .factory(
+                container ->
+                    new RemoteConfigComponent(
+                        container.get(Context.class),
+                        container.get(FirebaseApp.class),
+                        container.get(FirebaseInstanceId.class),
+                        container.get(AbtComponent.class).get(OriginService.REMOTE_CONFIG),
+                        container.get(AnalyticsConnector.class)))
+            .alwaysEager()
+            .build(),
+        LibraryVersionComponent.create("fire-rc", BuildConfig.VERSION_NAME));
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/Code.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/Code.java
new file mode 100644
index 000000000..63d79363e
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/Code.java
@@ -0,0 +1,143 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.firebase.remoteconfig.internal.Code.ABORTED;
+import static com.google.firebase.remoteconfig.internal.Code.ALREADY_EXISTS;
+import static com.google.firebase.remoteconfig.internal.Code.CANCELLED;
+import static com.google.firebase.remoteconfig.internal.Code.DATA_LOSS;
+import static com.google.firebase.remoteconfig.internal.Code.DEADLINE_EXCEEDED;
+import static com.google.firebase.remoteconfig.internal.Code.FAILED_PRECONDITION;
+import static com.google.firebase.remoteconfig.internal.Code.INTERNAL;
+import static com.google.firebase.remoteconfig.internal.Code.INVALID_ARGUMENT;
+import static com.google.firebase.remoteconfig.internal.Code.NOT_FOUND;
+import static com.google.firebase.remoteconfig.internal.Code.OK;
+import static com.google.firebase.remoteconfig.internal.Code.OUT_OF_RANGE;
+import static com.google.firebase.remoteconfig.internal.Code.PERMISSION_DENIED;
+import static com.google.firebase.remoteconfig.internal.Code.RESOURCE_EXHAUSTED;
+import static com.google.firebase.remoteconfig.internal.Code.UNAUTHENTICATED;
+import static com.google.firebase.remoteconfig.internal.Code.UNAVAILABLE;
+import static com.google.firebase.remoteconfig.internal.Code.UNIMPLEMENTED;
+import static com.google.firebase.remoteconfig.internal.Code.UNKNOWN;
+
+import androidx.annotation.IntDef;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * The set of Firebase Remote Config status codes. The codes are based on <a
+ * href="https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto">Canonical error
+ * codes for Google APIs</a>.
+ *
+ * @author Miraziz Yusupov
+ */
+@IntDef({
+  OK,
+  CANCELLED,
+  UNKNOWN,
+  INVALID_ARGUMENT,
+  DEADLINE_EXCEEDED,
+  NOT_FOUND,
+  ALREADY_EXISTS,
+  PERMISSION_DENIED,
+  UNAUTHENTICATED,
+  RESOURCE_EXHAUSTED,
+  FAILED_PRECONDITION,
+  ABORTED,
+  OUT_OF_RANGE,
+  UNIMPLEMENTED,
+  INTERNAL,
+  UNAVAILABLE,
+  DATA_LOSS
+})
+@Retention(RetentionPolicy.SOURCE)
+public @interface Code {
+  /**
+   * The operation completed successfully. FirebaseRemoteConfigServerException will never have a
+   * status of OK.
+   */
+  int OK = 0;
+
+  /** The operation was cancelled (typically by the caller). */
+  int CANCELLED = 1;
+
+  /** Unknown error or an error from a different error domain. */
+  int UNKNOWN = 2;
+
+  /**
+   * Client specified an invalid argument. Note that this differs from FAILED_PRECONDITION.
+   * INVALID_ARGUMENT indicates arguments that are problematic regardless of the state of the system
+   * (e.g., an invalid field name).
+   */
+  int INVALID_ARGUMENT = 3;
+
+  /**
+   * Deadline expired before operation could complete. For operations that change the state of the
+   * system, this error may be returned even if the operation has completed successfully. For
+   * example, a successful response from a server could have been delayed long enough for the
+   * deadline to expire.
+   */
+  int DEADLINE_EXCEEDED = 4;
+
+  /** Some requested resource was not found. */
+  int NOT_FOUND = 5;
+
+  /** Some resource that we attempted to create already exists. */
+  int ALREADY_EXISTS = 6;
+
+  /** The caller does not have permission to execute the specified operation. */
+  int PERMISSION_DENIED = 7;
+
+  /** The request does not have valid authentication credentials for the operation. */
+  int UNAUTHENTICATED = 16;
+
+  /**
+   * Some resource has been exhausted, perhaps a per-user quota, or perhaps the entire file system
+   * is out of space.
+   */
+  int RESOURCE_EXHAUSTED = 8;
+
+  /**
+   * Operation was rejected because the system is not in a state required for the operation's
+   * execution.
+   */
+  int FAILED_PRECONDITION = 9;
+
+  /**
+   * The operation was aborted, typically due to a concurrency issue like transaction aborts, etc.
+   */
+  int ABORTED = 10;
+
+  /** Operation was attempted past the valid range. */
+  int OUT_OF_RANGE = 11;
+
+  /** Operation is not implemented or not supported/enabled. */
+  int UNIMPLEMENTED = 12;
+
+  /**
+   * Internal errors. Means some invariants expected by underlying system has been broken. If you
+   * see one of these errors, something is very broken.
+   */
+  int INTERNAL = 13;
+
+  /**
+   * The service is currently unavailable. This is a most likely a transient condition and may be
+   * corrected by retrying with a backoff.
+   */
+  int UNAVAILABLE = 14;
+
+  /** Unrecoverable data loss or corruption. */
+  int DATA_LOSS = 15;
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigCacheClient.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigCacheClient.java
new file mode 100644
index 000000000..35f50bb44
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigCacheClient.java
@@ -0,0 +1,287 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.TAG;
+
+import android.util.Log;
+import androidx.annotation.AnyThread;
+import androidx.annotation.GuardedBy;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import com.google.android.gms.tasks.OnCanceledListener;
+import com.google.android.gms.tasks.OnFailureListener;
+import com.google.android.gms.tasks.OnSuccessListener;
+import com.google.android.gms.tasks.Task;
+import com.google.android.gms.tasks.Tasks;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+/**
+ * Cache client for managing an in-memory {@link ConfigContainer} backed by disk.
+ *
+ * <p>The in-memory and file {@link ConfigContainer}s are always synced by the client, so the
+ * in-memory container returned by the client will be the same as the container stored in disk.
+ *
+ * <p>Since there's a one to one mapping between files and storage clients, as well between files
+ * and cache clients, and every method in both clients is synchronized, two threads in the same
+ * process should never write to the same file simultaneously.
+ *
+ * @author Miraziz Yusupov
+ */
+@AnyThread
+public class ConfigCacheClient {
+  /** How long a method should block on a file read. */
+  static final long DISK_READ_TIMEOUT_IN_SECONDS = 5L;
+
+  @GuardedBy("ConfigCacheClient.class")
+  private static final Map<String, ConfigCacheClient> clientInstances = new HashMap<>();
+
+  private final ExecutorService executorService;
+  private final ConfigStorageClient storageClient;
+
+  /**
+   * Represents the {@link ConfigContainer} stored in disk. If the value is null, then there have
+   * been no file reads or writes yet.
+   */
+  @GuardedBy("this")
+  @Nullable
+  private Task<ConfigContainer> cachedContainerTask;
+
+  /**
+   * Creates a new cache client that executes async calls through {@code executorService} and is
+   * backed by {@code storageClient}.
+   */
+  private ConfigCacheClient(ExecutorService executorService, ConfigStorageClient storageClient) {
+    this.executorService = executorService;
+    this.storageClient = storageClient;
+
+    cachedContainerTask = null;
+  }
+
+  /**
+   * Sets the in-memory {@link ConfigContainer} to {@code configContainer} and then starts the file
+   * write to save the new config to disk.
+   *
+   * @return A {@link Task} representing the write to disk.
+   */
+  public Task<ConfigContainer> putWithoutWaitingForDiskWrite(ConfigContainer configContainer) {
+    updateInMemoryConfigContainer(configContainer);
+    return put(configContainer, /*shouldUpdateInMemoryContainer=*/ false);
+  }
+
+  /**
+   * Returns the cached {@link ConfigContainer}, blocking on a file read if necessary.
+   *
+   * <p>If no {@link ConfigContainer} has been read from disk yet, blocks on a {@link #get()} call.
+   * Returns null if the file read does not succeed within {@link #DISK_READ_TIMEOUT_IN_SECONDS}.
+   */
+  @Nullable
+  public ConfigContainer getBlocking() {
+    return getBlocking(DISK_READ_TIMEOUT_IN_SECONDS);
+  }
+
+  @VisibleForTesting
+  @Nullable
+  ConfigContainer getBlocking(long diskReadTimeoutInSeconds) {
+    synchronized (this) {
+      if (cachedContainerTask != null && cachedContainerTask.isSuccessful()) {
+        return cachedContainerTask.getResult();
+      }
+    }
+
+    try {
+      return await(get(), diskReadTimeoutInSeconds, TimeUnit.SECONDS);
+    } catch (InterruptedException | ExecutionException | TimeoutException e) {
+      Log.d(TAG, "Reading from storage file failed.", e);
+      return null;
+    }
+  }
+
+  /**
+   * Writes {@code configContainer} to disk and caches it to memory if the write is successful.
+   *
+   * @param configContainer the container to write to disk.
+   * @return A {@link Task} with the {@link ConfigContainer} that was written to disk.
+   */
+  public Task<ConfigContainer> put(ConfigContainer configContainer) {
+    return put(configContainer, /*shouldUpdateInMemoryContainer=*/ true);
+  }
+
+  /**
+   * Writes {@code configContainer} to disk and caches it to memory if the write is successful.
+   *
+   * @param configContainer the container to write to disk.
+   * @param shouldUpdateInMemoryContainer whether the in-memory container should be updated on a
+   *     successful file write.
+   * @return A {@link Task} with the {@link ConfigContainer} that was written to disk.
+   */
+  public Task<ConfigContainer> put(
+      ConfigContainer configContainer, boolean shouldUpdateInMemoryContainer) {
+    return Tasks.call(executorService, () -> storageClient.write(configContainer))
+        .onSuccessTask(
+            executorService,
+            (unusedVoid) -> {
+              if (shouldUpdateInMemoryContainer) {
+                updateInMemoryConfigContainer(configContainer);
+              }
+              return Tasks.forResult(configContainer);
+            });
+  }
+
+  /**
+   * Returns the cached {@link Task} that contains a {@link ConfigContainer}.
+   *
+   * <p>If no {@link Task} is cached or the cached {@link Task} has failed, makes an async call to
+   * read the container in disk and sets the cache to the resulting {@link Task}.
+   */
+  public synchronized Task<ConfigContainer> get() {
+    /*
+     * The first call to this method will encounter a null cachedContainerTask, so the code below
+     * will start an async task and assign the result to cachedContainerTask. Since this method is
+     * synchronized, all subsequent calls to get() will be blocked on the first call, after which
+     * point cachedContainerTask will be non-null. So, instead of starting their own async tasks,
+     * the subsequent get() calls will simply return the ongoing cachedContainerTask.
+     *
+     * In the case of file I/O failure, the first get() method to recognize that the current
+     * cachedContainerTask failed will start a new async task. All other get() calls will be
+     * blocked on that first get(), after which point cachedContainerTask will be a non-null
+     * non-failing task again.
+     *
+     * If clear() is called, the next get() call will see a null cachedContainerTask and start
+     * an async task as described above.
+     *
+     * If no clears are called, there will never be more than 1 call to storageClient::read from
+     * this instance. Otherwise, in all cases, the number of active async calls to
+     * storageClient::read will be at most one higher than the number of clear() calls made so far.
+     */
+    if (cachedContainerTask == null
+        || (cachedContainerTask.isComplete() && !cachedContainerTask.isSuccessful())) {
+      cachedContainerTask = Tasks.call(executorService, storageClient::read);
+    }
+    return cachedContainerTask;
+  }
+
+  /** Clears the cache and the {@link ConfigContainer} stored in disk. */
+  public void clear() {
+    synchronized (this) {
+      /*
+       * A null Task means the file has not been loaded yet, which will cause the get() method to
+       * start a new file read. So, to prevent unnecessary reads of an empty file, set to a Task
+       * with a null value, which will simply return a null container when get() is called.
+       */
+      cachedContainerTask = Tasks.forResult(null);
+    }
+    storageClient.clear();
+  }
+
+  /** Sets {@link #cachedContainerTask} to a {@link Task} containing {@code configContainer}. */
+  private synchronized void updateInMemoryConfigContainer(ConfigContainer configContainer) {
+    cachedContainerTask = Tasks.forResult(configContainer);
+  }
+
+  @VisibleForTesting
+  @Nullable
+  synchronized Task<ConfigContainer> getCachedContainerTask() {
+    return cachedContainerTask;
+  }
+
+  /**
+   * Returns an instance of {@link ConfigCacheClient} for the given {@link Executor} and {@link
+   * ConfigStorageClient}. The same instance is always returned for all calls with the same
+   * underlying file name.
+   */
+  public static synchronized ConfigCacheClient getInstance(
+      ExecutorService executorService, ConfigStorageClient storageClient) {
+    String fileName = storageClient.getFileName();
+    if (!clientInstances.containsKey(fileName)) {
+      clientInstances.put(fileName, new ConfigCacheClient(executorService, storageClient));
+    }
+    return clientInstances.get(fileName);
+  }
+
+  @VisibleForTesting
+  public static synchronized void clearInstancesForTest() {
+    clientInstances.clear();
+  }
+
+  /**
+   * Reimplementation of {@link Tasks#await(Task, long, TimeUnit)} because that method has a
+   * precondition that fails when run on the main thread.
+   *
+   * <p>This blocking method is required because the current FRC API has synchronous getters that
+   * read from a cache that is loaded from disk. In other words, the synchronous methods rely on an
+   * async task, so the getters have to block at some point.
+   *
+   * <p>Until the next breaking change in the API, this use case must be implemented, even though it
+   * is against Android best practices.
+   */
+  private static <TResult> TResult await(Task<TResult> task, long timeout, TimeUnit unit)
+      throws ExecutionException, InterruptedException, TimeoutException {
+    AwaitListener<TResult> waiter = new AwaitListener<>();
+
+    task.addOnSuccessListener(DIRECT_EXECUTOR, waiter);
+    task.addOnFailureListener(DIRECT_EXECUTOR, waiter);
+    task.addOnCanceledListener(DIRECT_EXECUTOR, waiter);
+
+    if (!waiter.await(timeout, unit)) {
+      throw new TimeoutException("Task await timed out.");
+    }
+
+    if (task.isSuccessful()) {
+      return task.getResult();
+    } else {
+      throw new ExecutionException(task.getException());
+    }
+  }
+
+  /** An Executor that uses the calling thread. */
+  private static final Executor DIRECT_EXECUTOR = Runnable::run;
+
+  private static class AwaitListener<TResult>
+      implements OnSuccessListener<TResult>, OnFailureListener, OnCanceledListener {
+    private final CountDownLatch latch = new CountDownLatch(1);
+
+    @Override
+    public void onSuccess(TResult o) {
+      latch.countDown();
+    }
+
+    @Override
+    public void onFailure(@NonNull Exception e) {
+      latch.countDown();
+    }
+
+    @Override
+    public void onCanceled() {
+      latch.countDown();
+    }
+
+    public void await() throws InterruptedException {
+      latch.await();
+    }
+
+    public boolean await(long timeout, TimeUnit unit) throws InterruptedException {
+      return latch.await(timeout, unit);
+    }
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigContainer.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigContainer.java
new file mode 100644
index 000000000..daa7afb95
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigContainer.java
@@ -0,0 +1,195 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import java.util.Date;
+import java.util.Map;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * The wrapper class for a JSON object that contains Firebase Remote Config (FRC) configs as well as
+ * their metadata.
+ *
+ * @author Miraziz Yusupov
+ */
+public class ConfigContainer {
+  private static final String CONFIGS_KEY = "configs_key";
+  private static final String FETCH_TIME_KEY = "fetch_time_key";
+  private static final String ABT_EXPERIMENTS_KEY = "abt_experiments_key";
+
+  private static final Date DEFAULTS_FETCH_TIME = new Date(0L);
+
+  /**
+   * The object stored in disk and wrapped by this class; contains a set of configs and any relevant
+   * metadata.
+   *
+   * <p>Used by the storage client to write this container to file.
+   */
+  private JSONObject containerJson;
+
+  /**
+   * Cached value of the container's config key-value pairs.
+   *
+   * <p>Used by the FRC client to retrieve config values.
+   */
+  private JSONObject configsJson;
+  /** Cached value of the time when this container's values were fetched. */
+  private Date fetchTime;
+
+  private JSONArray abtExperiments;
+
+  /**
+   * Creates a new container with the specified configs and fetch time.
+   *
+   * <p>The {@code configsJson} must not be modified.
+   */
+  private ConfigContainer(JSONObject configsJson, Date fetchTime, JSONArray abtExperiments)
+      throws JSONException {
+    JSONObject containerJson = new JSONObject();
+    containerJson.put(CONFIGS_KEY, configsJson);
+    containerJson.put(FETCH_TIME_KEY, fetchTime.getTime());
+    containerJson.put(ABT_EXPERIMENTS_KEY, abtExperiments);
+
+    this.configsJson = configsJson;
+    this.fetchTime = fetchTime;
+    this.abtExperiments = abtExperiments;
+
+    this.containerJson = containerJson;
+  }
+
+  /**
+   * Returns a {@link ConfigContainer} that wraps the {@code containerJson}.
+   *
+   * <p>The {@code containerJson} must not be modified.
+   */
+  static ConfigContainer copyOf(JSONObject containerJson) throws JSONException {
+    return new ConfigContainer(
+        containerJson.getJSONObject(CONFIGS_KEY),
+        new Date(containerJson.getLong(FETCH_TIME_KEY)),
+        containerJson.getJSONArray(ABT_EXPERIMENTS_KEY));
+  }
+
+  /**
+   * Returns the FRC configs.
+   *
+   * <p>The returned {@link JSONObject} must not be modified.
+   */
+  public JSONObject getConfigs() {
+    return configsJson;
+  }
+
+  /**
+   * Returns the time the configs of this instance were fetched. The fetch time is epoch for
+   * defaults containers.
+   */
+  public Date getFetchTime() {
+    return fetchTime;
+  }
+
+  public JSONArray getAbtExperiments() {
+    return abtExperiments;
+  }
+
+  @Override
+  public String toString() {
+    return containerJson.toString();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
+    }
+    if (!(o instanceof ConfigContainer)) {
+      return false;
+    }
+    ConfigContainer that = (ConfigContainer) o;
+    // TODO(issues/285): Use an equality comparison that is guaranteed to be deterministic.
+    return containerJson.toString().equals(that.toString());
+  }
+
+  @Override
+  public int hashCode() {
+    return containerJson.hashCode();
+  }
+
+  /** Builder for creating an instance of {@link ConfigContainer}. */
+  public static class Builder {
+    private JSONObject builderConfigsJson;
+    private Date builderFetchTime;
+    private JSONArray builderAbtExperiments;
+
+    private Builder() {
+      builderConfigsJson = new JSONObject();
+      builderFetchTime = DEFAULTS_FETCH_TIME;
+      builderAbtExperiments = new JSONArray();
+    }
+
+    public Builder(ConfigContainer otherContainer) {
+      this.builderConfigsJson = otherContainer.getConfigs();
+      this.builderFetchTime = otherContainer.getFetchTime();
+      this.builderAbtExperiments = otherContainer.getAbtExperiments();
+    }
+
+    public Builder replaceConfigsWith(Map<String, String> configsMap) {
+      this.builderConfigsJson = new JSONObject(configsMap);
+      return this;
+    }
+
+    public Builder replaceConfigsWith(JSONObject configsJson) {
+      try {
+        this.builderConfigsJson = new JSONObject(configsJson.toString());
+      } catch (JSONException e) {
+        // We serialize and deserialize the JSONObject to guarantee that it cannot be mutated after
+        // being set in the builder.
+        // A JSONException should never occur because the JSON that is being deserialized is
+        // guaranteed to be valid.
+      }
+      return this;
+    }
+
+    public Builder withFetchTime(Date fetchTime) {
+      this.builderFetchTime = fetchTime;
+      return this;
+    }
+
+    public Builder withAbtExperiments(JSONArray abtExperiments) {
+      try {
+        this.builderAbtExperiments = new JSONArray(abtExperiments.toString());
+      } catch (JSONException e) {
+        // We serialize and deserialize the JSONArray to guarantee that it cannot be mutated after
+        // being set in the builder.
+        // A JSONException should never occur because the JSON that is being deserialized is
+        // guaranteed to be valid.
+      }
+      return this;
+    }
+
+    /** If a fetch time is not provided, the defaults container fetch time is used. */
+    public ConfigContainer build() throws JSONException {
+      return new ConfigContainer(builderConfigsJson, builderFetchTime, builderAbtExperiments);
+    }
+  }
+
+  public static Builder newBuilder() {
+    return new Builder();
+  }
+
+  public static Builder newBuilder(ConfigContainer otherContainer) {
+    return new Builder(otherContainer);
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigFetchHandler.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigFetchHandler.java
new file mode 100644
index 000000000..138d75a97
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigFetchHandler.java
@@ -0,0 +1,569 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.firebase.remoteconfig.internal.ConfigMetadataClient.LAST_FETCH_TIME_NO_FETCH_YET;
+import static java.net.HttpURLConnection.HTTP_BAD_GATEWAY;
+import static java.net.HttpURLConnection.HTTP_FORBIDDEN;
+import static java.net.HttpURLConnection.HTTP_GATEWAY_TIMEOUT;
+import static java.net.HttpURLConnection.HTTP_INTERNAL_ERROR;
+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static java.net.HttpURLConnection.HTTP_UNAVAILABLE;
+import static java.util.concurrent.TimeUnit.HOURS;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.MINUTES;
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+import android.text.format.DateUtils;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import androidx.annotation.WorkerThread;
+import com.google.android.gms.common.util.Clock;
+import com.google.android.gms.tasks.Task;
+import com.google.android.gms.tasks.Tasks;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigClientException;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigException;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigFetchThrottledException;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigServerException;
+import com.google.firebase.remoteconfig.internal.ConfigFetchHandler.FetchResponse.Status;
+import com.google.firebase.remoteconfig.internal.ConfigMetadataClient.BackoffMetadata;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.net.HttpURLConnection;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.Executor;
+
+/**
+ * A handler for fetch requests to the Firebase Remote Config backend.
+ *
+ * <p>Checks cache and throttling status before sending a request to the backend.
+ *
+ * @author Miraziz Yusupov
+ */
+public class ConfigFetchHandler {
+  /** The default minimum interval between fetch requests to the Firebase Remote Config server. */
+  public static final long DEFAULT_MINIMUM_FETCH_INTERVAL_IN_SECONDS = HOURS.toSeconds(12);
+
+  /**
+   * The exponential backoff intervals, up to ~4 hours.
+   *
+   * <p>Every value must be even.
+   */
+  @VisibleForTesting
+  static final int[] BACKOFF_TIME_DURATIONS_IN_MINUTES = {2, 4, 8, 16, 32, 64, 128, 256};
+
+  /**
+   * HTTP status code for a throttled request.
+   *
+   * <p>Defined here since {@link HttpURLConnection} does not provide this code.
+   */
+  @VisibleForTesting static final int HTTP_TOO_MANY_REQUESTS = 429;
+
+  private final FirebaseInstanceId firebaseInstanceId;
+  @Nullable private final AnalyticsConnector analyticsConnector;
+
+  private final Executor executor;
+  private final Clock clock;
+  private final Random randomGenerator;
+  private final ConfigCacheClient fetchedConfigsCache;
+  private final ConfigFetchHttpClient frcBackendApiClient;
+  private final ConfigMetadataClient frcMetadata;
+
+  private final Map<String, String> customHttpHeaders;
+
+  /** FRC Fetch Handler constructor. */
+  public ConfigFetchHandler(
+      FirebaseInstanceId firebaseInstanceId,
+      @Nullable AnalyticsConnector analyticsConnector,
+      Executor executor,
+      Clock clock,
+      Random randomGenerator,
+      ConfigCacheClient fetchedConfigsCache,
+      ConfigFetchHttpClient frcBackendApiClient,
+      ConfigMetadataClient frcMetadata,
+      Map<String, String> customHttpHeaders) {
+    this.firebaseInstanceId = firebaseInstanceId;
+    this.analyticsConnector = analyticsConnector;
+    this.executor = executor;
+    this.clock = clock;
+    this.randomGenerator = randomGenerator;
+    this.fetchedConfigsCache = fetchedConfigsCache;
+    this.frcBackendApiClient = frcBackendApiClient;
+    this.frcMetadata = frcMetadata;
+
+    this.customHttpHeaders = customHttpHeaders;
+  }
+
+  /**
+   * Calls {@link #fetch(long)} with the {@link
+   * ConfigMetadataClient#getMinimumFetchIntervalInSeconds()}.
+   */
+  public Task<FetchResponse> fetch() {
+    return fetch(frcMetadata.getMinimumFetchIntervalInSeconds());
+  }
+
+  /**
+   * Starts fetching configs from the Firebase Remote Config server.
+   *
+   * <p>Guarantees consistency between memory and disk; fetched configs are saved to memory only
+   * after they have been written to disk.
+   *
+   * <p>Fetches even if the read of the fetch cache fails (assumes there are no cached fetched
+   * configs in that case).
+   *
+   * <p>If the fetch request could not be created or there was error connecting to the server, the
+   * returned Task throws a {@link FirebaseRemoteConfigClientException}.
+   *
+   * <p>If the server responds with an error, the returned Task throws a {@link
+   * FirebaseRemoteConfigServerException}.
+   *
+   * <p>If any of the following is true, then the returned Task throws a {@link
+   * FirebaseRemoteConfigFetchThrottledException}:
+   *
+   * <ul>
+   *   <li>The backoff duration from a previous throttled exception has not expired,
+   *   <li>The backend responded with a throttled error, or
+   *   <li>The backend responded with unavailable errors for the last two fetch requests.
+   * </ul>
+   *
+   * @return A {@link Task} representing the fetch call that returns a {@link FetchResponse} with
+   *     the configs fetched from the backend. If the backend was not called or the backend had no
+   *     updates, the {@link FetchResponse}'s configs will be {@code null}.
+   */
+  public Task<FetchResponse> fetch(long minimumFetchIntervalInSeconds) {
+    long fetchIntervalInSeconds =
+        frcMetadata.isDeveloperModeEnabled() ? 0L : minimumFetchIntervalInSeconds;
+
+    return fetchedConfigsCache
+        .get()
+        .continueWithTask(
+            executor,
+            (cachedFetchConfigsTask) ->
+                fetchIfCacheExpiredAndNotThrottled(cachedFetchConfigsTask, fetchIntervalInSeconds));
+  }
+
+  /**
+   * Fetches from the backend if the fetched configs cache has expired and the client is not
+   * currently throttled.
+   *
+   * <p>If a fetch request is made to the backend, updates the last fetch status, last successful
+   * fetch time and {@link BackoffMetadata} in {@link ConfigMetadataClient}.
+   */
+  private Task<FetchResponse> fetchIfCacheExpiredAndNotThrottled(
+      Task<ConfigContainer> cachedFetchConfigsTask, long minimumFetchIntervalInSeconds) {
+    Date currentTime = new Date(clock.currentTimeMillis());
+    if (cachedFetchConfigsTask.isSuccessful()
+        && areCachedFetchConfigsValid(minimumFetchIntervalInSeconds, currentTime)) {
+      // Keep the cached fetch values if the cache has not expired yet.
+      return Tasks.forResult(FetchResponse.forLocalStorageUsed(currentTime));
+    }
+
+    Task<FetchResponse> fetchResponseTask;
+
+    Date backoffEndTime = getBackoffEndTimeInMillis(currentTime);
+    if (backoffEndTime != null) {
+      // TODO(issues/260): Provide a way for users to check for throttled status so exceptions
+      // aren't the only way for users to determine if they're throttled.
+      fetchResponseTask =
+          Tasks.forException(
+              new FirebaseRemoteConfigFetchThrottledException(
+                  createThrottledMessage(backoffEndTime.getTime() - currentTime.getTime()),
+                  backoffEndTime.getTime()));
+    } else {
+      fetchResponseTask = fetchFromBackendAndCacheResponse(currentTime);
+    }
+
+    return fetchResponseTask.continueWithTask(
+        executor,
+        (completedFetchTask) -> {
+          updateLastFetchStatusAndTime(completedFetchTask, currentTime);
+          return completedFetchTask;
+        });
+  }
+
+  /**
+   * Returns true if the last successfully fetched configs are not stale, or if developer mode is
+   * on.
+   */
+  private boolean areCachedFetchConfigsValid(long cacheExpirationInSeconds, Date newFetchTime) {
+    Date lastSuccessfulFetchTime = frcMetadata.getLastSuccessfulFetchTime();
+    // RC always fetches if the client has not previously had a successful fetch.
+
+    if (lastSuccessfulFetchTime.equals(LAST_FETCH_TIME_NO_FETCH_YET)) {
+      return false;
+    }
+
+    Date cacheExpirationTime =
+        new Date(lastSuccessfulFetchTime.getTime() + SECONDS.toMillis(cacheExpirationInSeconds));
+
+    return newFetchTime.before(cacheExpirationTime);
+  }
+
+  /**
+   * Returns the earliest possible time, in millis since epoch, when a fetch request won't be
+   * throttled by the server, or {@code null} if the client is not currently throttled by the
+   * server.
+   */
+  @Nullable
+  private Date getBackoffEndTimeInMillis(Date currentTime) {
+    Date backoffEndTime = frcMetadata.getBackoffMetadata().getBackoffEndTime();
+    if (currentTime.before(backoffEndTime)) {
+      return backoffEndTime;
+    }
+
+    return null;
+  }
+
+  /**
+   * Returns a human-readable throttled message with how long the client has to wait before fetching
+   * again.
+   */
+  private String createThrottledMessage(long throttledDurationInMillis) {
+    return String.format(
+        "Fetch is throttled. Please wait before calling fetch again: %s",
+        DateUtils.formatElapsedTime(MILLISECONDS.toSeconds(throttledDurationInMillis)));
+  }
+
+  /**
+   * Fetches configs from the FRC backend. If there are any updates, writes the configs to the
+   * {@code fetchedConfigsCache}.
+   */
+  private Task<FetchResponse> fetchFromBackendAndCacheResponse(Date fetchTime) {
+    try {
+      FetchResponse fetchResponse = fetchFromBackend(fetchTime);
+      if (fetchResponse.getStatus() != Status.BACKEND_UPDATES_FETCHED) {
+        return Tasks.forResult(fetchResponse);
+      }
+      return fetchedConfigsCache
+          .put(fetchResponse.getFetchedConfigs())
+          .onSuccessTask(executor, (putContainer) -> Tasks.forResult(fetchResponse));
+    } catch (FirebaseRemoteConfigException frce) {
+      return Tasks.forException(frce);
+    }
+  }
+
+  /**
+   * Creates a fetch request, sends it to the FRC backend and converts the server's response into a
+   * {@link FetchResponse}.
+   *
+   * @return The {@link FetchResponse} from the FRC backend.
+   * @throws FirebaseRemoteConfigServerException if the server returned an error.
+   * @throws FirebaseRemoteConfigClientException if the request could not be created or there's an
+   *     error connecting to the server.
+   */
+  @WorkerThread
+  private FetchResponse fetchFromBackend(Date currentTime) throws FirebaseRemoteConfigException {
+    try {
+      HttpURLConnection urlConnection = frcBackendApiClient.createHttpURLConnection();
+
+      FetchResponse response =
+          frcBackendApiClient.fetch(
+              urlConnection,
+              firebaseInstanceId.getId(),
+              firebaseInstanceId.getToken(),
+              getUserProperties(),
+              frcMetadata.getLastFetchETag(),
+              customHttpHeaders,
+              currentTime);
+
+      if (response.getLastFetchETag() != null) {
+        frcMetadata.setLastFetchETag(response.getLastFetchETag());
+      }
+      // If the execute method did not throw exceptions, then the server sent a successful response
+      // and the client can stop backing off.
+      frcMetadata.resetBackoff();
+
+      return response;
+    } catch (FirebaseRemoteConfigServerException serverHttpError) {
+      BackoffMetadata backoffMetadata =
+          updateAndReturnBackoffMetadata(serverHttpError.getHttpStatusCode(), currentTime);
+
+      if (shouldThrottle(backoffMetadata, serverHttpError.getHttpStatusCode())) {
+        throw new FirebaseRemoteConfigFetchThrottledException(
+            backoffMetadata.getBackoffEndTime().getTime());
+      }
+      // TODO(issues/264): Move the generic message logic to the ConfigFetchHttpClient.
+      throw createExceptionWithGenericMessage(serverHttpError);
+    }
+  }
+
+  /**
+   * Returns a {@link FirebaseRemoteConfigServerException} with a generic message based on the
+   * {@code statusCode}.
+   *
+   * @throws FirebaseRemoteConfigClientException if {@code statusCode} is {@link
+   *     #HTTP_TOO_MANY_REQUESTS}. Throttled responses should be handled before calls to this
+   *     method.
+   */
+  private FirebaseRemoteConfigServerException createExceptionWithGenericMessage(
+      FirebaseRemoteConfigServerException httpError) throws FirebaseRemoteConfigClientException {
+    String errorMessage;
+    switch (httpError.getHttpStatusCode()) {
+      case HTTP_UNAUTHORIZED:
+        // The 401 HTTP Code is mapped from UNAUTHENTICATED in the gRPC world.
+        errorMessage =
+            "The request did not have the required credentials. "
+                + "Please make sure your google-services.json is valid.";
+        break;
+      case HTTP_FORBIDDEN:
+        errorMessage =
+            "The user is not authorized to access the project. Please make sure "
+                + "you are using the API key that corresponds to your Firebase project.";
+        break;
+      case HTTP_INTERNAL_ERROR:
+        errorMessage = "There was an internal server error.";
+        break;
+      case HTTP_BAD_GATEWAY:
+      case HTTP_UNAVAILABLE:
+      case HTTP_GATEWAY_TIMEOUT:
+        // The 504 HTTP Code is mapped from DEADLINE_EXCEEDED in the gRPC world.
+        errorMessage = "The server is unavailable. Please try again later.";
+        break;
+      case HTTP_TOO_MANY_REQUESTS:
+        // Should never happen.
+        // The throttled response should be handled before the call to this method.
+        throw new FirebaseRemoteConfigClientException(
+            "The throttled response from the server was not handled correctly by the FRC SDK.");
+      default:
+        errorMessage = "The server returned an unexpected error.";
+        break;
+    }
+
+    return new FirebaseRemoteConfigServerException(
+        httpError.getHttpStatusCode(), "Fetch failed: " + errorMessage, httpError);
+  }
+
+  /**
+   * Updates and returns the backoff metadata if the server returned a throttle-able error.
+   *
+   * <p>The list of throttle-able errors:
+   *
+   * <ul>
+   *   <li>{@link #HTTP_TOO_MANY_REQUESTS},
+   *   <li>{@link HttpURLConnection#HTTP_BAD_GATEWAY},
+   *   <li>{@link HttpURLConnection#HTTP_UNAVAILABLE},
+   *   <li>{@link HttpURLConnection#HTTP_GATEWAY_TIMEOUT}.
+   * </ul>
+   */
+  private BackoffMetadata updateAndReturnBackoffMetadata(int statusCode, Date currentTime) {
+    if (isThrottleableServerError(statusCode)) {
+      updateBackoffMetadataWithLastFailedFetchTime(currentTime);
+    }
+    return frcMetadata.getBackoffMetadata();
+  }
+
+  /**
+   * Returns true for server errors that are throttle-able.
+   *
+   * <p>The {@link HttpURLConnection#HTTP_GATEWAY_TIMEOUT} error is included here since it is
+   * similar to the other unavailable errors in the previously linked doc.
+   */
+  private boolean isThrottleableServerError(int httpStatusCode) {
+    return httpStatusCode == HTTP_TOO_MANY_REQUESTS
+        || httpStatusCode == HttpURLConnection.HTTP_BAD_GATEWAY
+        || httpStatusCode == HttpURLConnection.HTTP_UNAVAILABLE
+        || httpStatusCode == HttpURLConnection.HTTP_GATEWAY_TIMEOUT;
+  }
+
+  // TODO(issues/265): Make this an atomic operation within the Metadata class to avoid possible
+  // concurrency issues.
+  /**
+   * Increment the number of failed fetch attempts, increase the backoff duration, set the backoff
+   * end time to "backoff duration" after {@code lastFailedFetchTime} and persist the new values to
+   * disk-backed metadata.
+   */
+  private void updateBackoffMetadataWithLastFailedFetchTime(Date lastFailedFetchTime) {
+    int numFailedFetches = frcMetadata.getBackoffMetadata().getNumFailedFetches();
+
+    numFailedFetches++;
+
+    long backoffDurationInMillis = getRandomizedBackoffDurationInMillis(numFailedFetches);
+    Date backoffEndTime = new Date(lastFailedFetchTime.getTime() + backoffDurationInMillis);
+
+    frcMetadata.setBackoffMetadata(numFailedFetches, backoffEndTime);
+  }
+
+  /**
+   * Returns a random backoff duration from the range {@code timeoutDuration} +/- 50% of {@code
+   * timeoutDuration}, where {@code timeoutDuration = }{@link
+   * #BACKOFF_TIME_DURATIONS_IN_MINUTES}{@code [numFailedFetches-1]}.
+   */
+  private long getRandomizedBackoffDurationInMillis(int numFailedFetches) {
+    // The backoff duration length after numFailedFetches.
+    long timeOutDurationInMillis =
+        MINUTES.toMillis(
+            BACKOFF_TIME_DURATIONS_IN_MINUTES[
+                Math.min(numFailedFetches, BACKOFF_TIME_DURATIONS_IN_MINUTES.length) - 1]);
+
+    // A random duration that is in the range: timeOutDuration +/- 50% of timeOutDuration.
+    return timeOutDurationInMillis / 2 + randomGenerator.nextInt((int) timeOutDurationInMillis);
+  }
+
+  /**
+   * Determines whether a given {@code httpStatusCode} should be throttled based on recent fetch
+   * results.
+   *
+   * <p>A fetch is considered throttle-able if the {@code httpStatusCode} is {@link
+   * #HTTP_TOO_MANY_REQUESTS}, or if the fetch is the second consecutive request to receive an
+   * unavailable response from the server.
+   *
+   * <p>The two fetch requirement guards against the possibility of a transient error from the
+   * server. In such cases, an immediate retry should fix the problem. If the retry also fails, then
+   * the error is probably not transient and the client should enter exponential backoff mode.
+   *
+   * <p>So, unless the server explicitly responds with a throttled error, the client should not
+   * throttle on the first throttle-able error from the server.
+   *
+   * @return True if the current fetch request should be throttled.
+   */
+  private boolean shouldThrottle(BackoffMetadata backoffMetadata, int httpStatusCode) {
+    return backoffMetadata.getNumFailedFetches() > 1 || httpStatusCode == HTTP_TOO_MANY_REQUESTS;
+  }
+
+  /**
+   * Updates last fetch status and last successful fetch time in FRC metadata based on the result of
+   * {@code completedFetchTask}.
+   */
+  private void updateLastFetchStatusAndTime(
+      Task<FetchResponse> completedFetchTask, Date fetchTime) {
+    if (completedFetchTask.isSuccessful()) {
+      frcMetadata.updateLastFetchAsSuccessfulAt(fetchTime);
+      return;
+    }
+
+    Exception fetchException = completedFetchTask.getException();
+    if (fetchException == null) {
+      // Fetch was cancelled, which should never happen.
+      return;
+    }
+
+    if (fetchException instanceof FirebaseRemoteConfigFetchThrottledException) {
+      frcMetadata.updateLastFetchAsThrottled();
+    } else {
+      frcMetadata.updateLastFetchAsFailed();
+    }
+  }
+
+  /**
+   * Returns the list of user properties in Analytics. If the Analytics SDK is not available,
+   * returns an empty list.
+   */
+  @WorkerThread
+  private Map<String, String> getUserProperties() {
+    Map<String, String> userPropertiesMap = new HashMap<>();
+    if (analyticsConnector == null) {
+      return userPropertiesMap;
+    }
+
+    for (Map.Entry<String, Object> userPropertyEntry :
+        analyticsConnector.getUserProperties(/*includeInternal=*/ false).entrySet()) {
+      userPropertiesMap.put(userPropertyEntry.getKey(), userPropertyEntry.getValue().toString());
+    }
+    return userPropertiesMap;
+  }
+
+  /** Used to verify that the fetch handler is getting Analytics as expected. */
+  @VisibleForTesting
+  @Nullable
+  public AnalyticsConnector getAnalyticsConnector() {
+    return analyticsConnector;
+  }
+
+  /**
+   * The response of a fetch call that contains the configs fetched from the backend as well as
+   * metadata about the fetch operation.
+   */
+  public static class FetchResponse {
+    private final Date fetchTime;
+    @Status private final int status;
+    private final ConfigContainer fetchedConfigs;
+    @Nullable private final String lastFetchETag;
+
+    /** Creates a fetch response with the given parameters. */
+    private FetchResponse(
+        Date fetchTime,
+        @Status int status,
+        ConfigContainer fetchedConfigs,
+        @Nullable String lastFetchETag) {
+      this.fetchTime = fetchTime;
+      this.status = status;
+      this.fetchedConfigs = fetchedConfigs;
+      this.lastFetchETag = lastFetchETag;
+    }
+
+    public static FetchResponse forBackendUpdatesFetched(
+        ConfigContainer fetchedConfigs, String lastFetchETag) {
+      return new FetchResponse(
+          fetchedConfigs.getFetchTime(),
+          Status.BACKEND_UPDATES_FETCHED,
+          fetchedConfigs,
+          lastFetchETag);
+    }
+
+    public static FetchResponse forBackendHasNoUpdates(Date fetchTime) {
+      return new FetchResponse(
+          fetchTime,
+          Status.BACKEND_HAS_NO_UPDATES,
+          /*fetchedConfigs=*/ null,
+          /*lastFetchETag=*/ null);
+    }
+
+    public static FetchResponse forLocalStorageUsed(Date fetchTime) {
+      return new FetchResponse(
+          fetchTime, Status.LOCAL_STORAGE_USED, /*fetchedConfigs=*/ null, /*lastFetchETag=*/ null);
+    }
+
+    Date getFetchTime() {
+      return fetchTime;
+    }
+
+    @Nullable
+    String getLastFetchETag() {
+      return lastFetchETag;
+    }
+
+    @Status
+    int getStatus() {
+      return status;
+    }
+
+    /**
+     * Returns the configs fetched from the backend, or {@code null} if the backend wasn't called or
+     * there were no updates from the backend.
+     */
+    public ConfigContainer getFetchedConfigs() {
+      return fetchedConfigs;
+    }
+
+    /** The response status of a fetch operation. */
+    @IntDef({
+      Status.BACKEND_UPDATES_FETCHED,
+      Status.BACKEND_HAS_NO_UPDATES,
+      Status.LOCAL_STORAGE_USED
+    })
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface Status {
+      int BACKEND_UPDATES_FETCHED = 0;
+      int BACKEND_HAS_NO_UPDATES = 1;
+      int LOCAL_STORAGE_USED = 2;
+    }
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigFetchHttpClient.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigFetchHttpClient.java
new file mode 100644
index 000000000..33a3bf714
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigFetchHttpClient.java
@@ -0,0 +1,385 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.TAG;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.FETCH_REGEX_URL;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.ANALYTICS_USER_PROPERTIES;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.APP_ID;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.APP_VERSION;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.COUNTRY_CODE;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.INSTANCE_ID;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.INSTANCE_ID_TOKEN;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.LANGUAGE_CODE;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.PACKAGE_NAME;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.PLATFORM_VERSION;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.SDK_VERSION;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.TIME_ZONE;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ResponseFieldKey.ENTRIES;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ResponseFieldKey.EXPERIMENT_DESCRIPTIONS;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ResponseFieldKey.STATE;
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+import android.content.Context;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.util.Log;
+import androidx.annotation.Keep;
+import androidx.annotation.VisibleForTesting;
+import com.google.android.gms.common.util.AndroidUtilsLight;
+import com.google.android.gms.common.util.Hex;
+import com.google.firebase.remoteconfig.BuildConfig;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigClientException;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigException;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigServerException;
+import com.google.firebase.remoteconfig.internal.ConfigFetchHandler.FetchResponse;
+import java.io.BufferedOutputStream;
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TimeZone;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Lightweight client for fetching data from the Firebase Remote Config server.
+ *
+ * @author Lucas Png
+ */
+public class ConfigFetchHttpClient {
+  private static final String API_KEY_HEADER = "X-Goog-Api-Key";
+  private static final String ETAG_HEADER = "ETag";
+  private static final String IF_NONE_MATCH_HEADER = "If-None-Match";
+  private static final String X_ANDROID_PACKAGE_HEADER = "X-Android-Package";
+  private static final String X_ANDROID_CERT_HEADER = "X-Android-Cert";
+  private static final String X_GOOGLE_GFE_CAN_RETRY = "X-Google-GFE-Can-Retry";
+
+  private final Context context;
+  private final String appId;
+  private final String apiKey;
+  private final String projectNumber;
+  private final String namespace;
+  private final long connectTimeoutInSeconds;
+  private final long readTimeoutInSeconds;
+
+  /** Creates a client for {@link #fetch}ing data from the Firebase Remote Config server. */
+  public ConfigFetchHttpClient(
+      Context context,
+      String appId,
+      String apiKey,
+      String namespace,
+      long connectTimeoutInSeconds,
+      long readTimeoutInSeconds) {
+    this.context = context;
+    this.appId = appId;
+    this.apiKey = apiKey;
+    this.projectNumber = extractProjectNumberFromAppId(appId);
+    this.namespace = namespace;
+    this.connectTimeoutInSeconds = connectTimeoutInSeconds;
+    this.readTimeoutInSeconds = readTimeoutInSeconds;
+  }
+
+  /** Used to verify that the timeout is being set correctly. */
+  @VisibleForTesting
+  public long getConnectTimeoutInSeconds() {
+    return connectTimeoutInSeconds;
+  }
+
+  /** Used to verify that the timeout is being set correctly. */
+  @VisibleForTesting
+  public long getReadTimeoutInSeconds() {
+    return readTimeoutInSeconds;
+  }
+
+  /**
+   * A regular expression for the GMP App Id format. The first group (index 1) is the project
+   * number.
+   */
+  private static final Pattern GMP_APP_ID_PATTERN =
+      Pattern.compile("^[^:]+:([0-9]+):(android|ios|web):([0-9a-f]+)");
+
+  private static String extractProjectNumberFromAppId(String gmpAppId) {
+    Matcher matcher = GMP_APP_ID_PATTERN.matcher(gmpAppId);
+    return matcher.matches() ? matcher.group(1) : null;
+  }
+
+  /**
+   * Initializes a {@link HttpURLConnection} for fetching data from the Firebase Remote Config
+   * server.
+   */
+  HttpURLConnection createHttpURLConnection() throws FirebaseRemoteConfigException {
+    try {
+      URL url = new URL(getFetchUrl(projectNumber, namespace));
+      return (HttpURLConnection) url.openConnection();
+    } catch (IOException e) {
+      throw new FirebaseRemoteConfigException(e.getMessage());
+    }
+  }
+
+  /**
+   * Returns a {@link JSONObject} that contains the latest fetched ETag and a status field that
+   * denotes if the Firebase Remote Config (FRC) server has updated configs or A/B Testing
+   * experiments. If there has been a change since the last fetch, the {@link JSONObject} also
+   * contains an "entries" field with parameters fetched from the FRC server.
+   *
+   * @param urlConnection a {@link HttpURLConnection} created by a call to {@link
+   *     #createHttpURLConnection}.
+   * @param instanceId the Firebase Instance ID that identifies a Firebase App Instance.
+   * @param instanceIdToken a valid Firebase Instance ID Token that authenticates a Firebase App
+   *     Instance.
+   * @param analyticsUserProperties a map of Google Analytics User Properties and the device's
+   *     corresponding values.
+   * @param lastFetchETag the ETag returned by the last successful fetch call to the FRC server. The
+   *     server uses this ETag to determine if there has been a change in the response body since
+   *     the last fetch.
+   * @param customHeaders custom HTTP headers that will be sent to the FRC server.
+   * @param currentTime the current time on the device that is performing the fetch.
+   */
+  // TODO(issues/263): Set custom headers in ConfigFetchHttpClient's constructor.
+  @Keep
+  FetchResponse fetch(
+      HttpURLConnection urlConnection,
+      String instanceId,
+      String instanceIdToken,
+      Map<String, String> analyticsUserProperties,
+      String lastFetchETag,
+      Map<String, String> customHeaders,
+      Date currentTime)
+      throws FirebaseRemoteConfigException {
+    setUpUrlConnection(urlConnection, lastFetchETag, customHeaders);
+
+    String fetchResponseETag;
+    JSONObject fetchResponse;
+    try {
+      byte[] requestBody =
+          createFetchRequestBody(instanceId, instanceIdToken, analyticsUserProperties)
+              .toString()
+              .getBytes("utf-8");
+      setFetchRequestBody(urlConnection, requestBody);
+
+      urlConnection.connect();
+
+      int responseCode = urlConnection.getResponseCode();
+      if (responseCode != 200) {
+        throw new FirebaseRemoteConfigServerException(
+            responseCode, urlConnection.getResponseMessage());
+      }
+      fetchResponseETag = urlConnection.getHeaderField(ETAG_HEADER);
+      fetchResponse = getFetchResponseBody(urlConnection);
+    } catch (IOException | JSONException e) {
+      throw new FirebaseRemoteConfigClientException(
+          "The client had an error while calling the backend!", e);
+    } finally {
+      urlConnection.disconnect();
+    }
+
+    if (!backendHasUpdates(fetchResponse)) {
+      return FetchResponse.forBackendHasNoUpdates(currentTime);
+    }
+
+    ConfigContainer fetchedConfigs = extractConfigs(fetchResponse, currentTime);
+    return FetchResponse.forBackendUpdatesFetched(fetchedConfigs, fetchResponseETag);
+  }
+
+  private void setUpUrlConnection(
+      HttpURLConnection urlConnection, String lastFetchEtag, Map<String, String> customHeaders) {
+    urlConnection.setDoOutput(true);
+    urlConnection.setConnectTimeout((int) SECONDS.toMillis(connectTimeoutInSeconds));
+    urlConnection.setReadTimeout((int) SECONDS.toMillis(readTimeoutInSeconds));
+
+    // Send the last successful Fetch ETag to the FRC Server to calculate if there has been any
+    // change in the Fetch Response since the last fetch call.
+    urlConnection.setRequestProperty(IF_NONE_MATCH_HEADER, lastFetchEtag);
+
+    setCommonRequestHeaders(urlConnection);
+    setCustomRequestHeaders(urlConnection, customHeaders);
+  }
+
+  private String getFetchUrl(String projectNumber, String namespace) {
+    return String.format(FETCH_REGEX_URL, projectNumber, namespace);
+  }
+
+  private void setCommonRequestHeaders(HttpURLConnection urlConnection) {
+    urlConnection.setRequestProperty(API_KEY_HEADER, apiKey);
+
+    // Headers required for Android API Key Restrictions.
+    urlConnection.setRequestProperty(X_ANDROID_PACKAGE_HEADER, context.getPackageName());
+    urlConnection.setRequestProperty(X_ANDROID_CERT_HEADER, getFingerprintHashForPackage());
+
+    // Header to denote request is retryable on the server.
+    urlConnection.setRequestProperty(X_GOOGLE_GFE_CAN_RETRY, "yes");
+
+    // Headers to denote that the request body is a JSONObject.
+    urlConnection.setRequestProperty("Content-Type", "application/json");
+    urlConnection.setRequestProperty("Accept", "application/json");
+  }
+
+  /** Sends developer specified custom headers to the Remote Config server. */
+  private void setCustomRequestHeaders(
+      HttpURLConnection urlConnection, Map<String, String> customHeaders) {
+    for (Map.Entry<String, String> customHeaderEntry : customHeaders.entrySet()) {
+      urlConnection.setRequestProperty(customHeaderEntry.getKey(), customHeaderEntry.getValue());
+    }
+  }
+
+  /** Gets the Android package's SHA-1 fingerprint. */
+  private String getFingerprintHashForPackage() {
+    byte[] hash;
+
+    try {
+      hash = AndroidUtilsLight.getPackageCertificateHashBytes(context, context.getPackageName());
+
+      if (hash == null) {
+        Log.e(TAG, "Could not get fingerprint hash for package: " + context.getPackageName());
+        return null;
+      } else {
+        return Hex.bytesToStringUppercase(hash, /* zeroTerminated= */ false);
+      }
+    } catch (PackageManager.NameNotFoundException e) {
+      Log.e(TAG, "No such package: " + context.getPackageName(), e);
+      return null;
+    }
+  }
+
+  /**
+   * Returns a request body serialized as a {@link JSONObject}.
+   *
+   * <p>The FRC server's fetch endpoint expects a POST request with a request body, which can be
+   * serialized as a JSON.
+   */
+  private JSONObject createFetchRequestBody(
+      String instanceId, String instanceIdToken, Map<String, String> analyticsUserProperties)
+      throws FirebaseRemoteConfigClientException {
+    Map<String, Object> requestBodyMap = new HashMap<>();
+
+    if (instanceId == null) {
+      throw new FirebaseRemoteConfigClientException("Fetch failed: Firebase instance id is null.");
+    }
+    requestBodyMap.put(INSTANCE_ID, instanceId);
+
+    requestBodyMap.put(INSTANCE_ID_TOKEN, instanceIdToken);
+    requestBodyMap.put(APP_ID, appId);
+
+    Locale locale = context.getResources().getConfiguration().locale;
+    requestBodyMap.put(COUNTRY_CODE, locale.getCountry());
+    requestBodyMap.put(LANGUAGE_CODE, locale.toString());
+
+    requestBodyMap.put(PLATFORM_VERSION, Integer.toString(android.os.Build.VERSION.SDK_INT));
+
+    requestBodyMap.put(TIME_ZONE, TimeZone.getDefault().getID());
+
+    try {
+      PackageInfo packageInfo =
+          context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
+      if (packageInfo != null) {
+        requestBodyMap.put(APP_VERSION, packageInfo.versionName);
+      }
+    } catch (NameNotFoundException e) {
+      // Leave app version blank if package cannot be found.
+    }
+
+    requestBodyMap.put(PACKAGE_NAME, context.getPackageName());
+    requestBodyMap.put(SDK_VERSION, BuildConfig.VERSION_NAME);
+
+    requestBodyMap.put(ANALYTICS_USER_PROPERTIES, analyticsUserProperties);
+
+    return new JSONObject(requestBodyMap);
+  }
+
+  private void setFetchRequestBody(HttpURLConnection urlConnection, byte[] requestBody)
+      throws IOException {
+    urlConnection.setFixedLengthStreamingMode(requestBody.length);
+    OutputStream out = new BufferedOutputStream(urlConnection.getOutputStream());
+    out.write(requestBody);
+    out.flush();
+    out.close();
+  }
+
+  private JSONObject getFetchResponseBody(URLConnection urlConnection)
+      throws IOException, JSONException {
+    BufferedReader br =
+        new BufferedReader(new InputStreamReader(urlConnection.getInputStream(), "utf-8"));
+    StringBuilder responseStringBuilder = new StringBuilder();
+    int current = 0;
+    while ((current = br.read()) != -1) {
+      responseStringBuilder.append((char) current);
+    }
+
+    return new JSONObject(responseStringBuilder.toString());
+  }
+
+  /** Returns true if the backend has updated fetch values. */
+  private boolean backendHasUpdates(JSONObject response) {
+    try {
+      return !response.get(STATE).equals("NO_CHANGE");
+    } catch (JSONException e) {
+      // The V2 server does not return a state, so assume a null state means there is a valid
+      // update.
+      return true;
+    }
+  }
+
+  /**
+   * Converts the given {@link JSONObject} Fetch response into a {@link ConfigContainer}.
+   *
+   * @param fetchResponse The fetch response from the FRC server.
+   * @param fetchTime The time, in millis since epoch, when the fetch request was made.
+   * @return A {@link ConfigContainer} representing the fetch response from the server.
+   */
+  private static ConfigContainer extractConfigs(JSONObject fetchResponse, Date fetchTime)
+      throws FirebaseRemoteConfigClientException {
+    try {
+      ConfigContainer.Builder containerBuilder =
+          ConfigContainer.newBuilder().withFetchTime(fetchTime);
+
+      JSONObject entries = null;
+      try {
+        entries = fetchResponse.getJSONObject(ENTRIES);
+      } catch (JSONException e) {
+        // Do nothing if entries do not exist.
+      }
+      if (entries != null) {
+        containerBuilder.replaceConfigsWith(entries);
+      }
+
+      JSONArray experimentDescriptions = null;
+      try {
+        experimentDescriptions = fetchResponse.getJSONArray(EXPERIMENT_DESCRIPTIONS);
+      } catch (JSONException e) {
+        // Do nothing if entries do not exist.
+      }
+      if (experimentDescriptions != null) {
+        containerBuilder.withAbtExperiments(experimentDescriptions);
+      }
+
+      return containerBuilder.build();
+    } catch (JSONException e) {
+      throw new FirebaseRemoteConfigClientException(
+          "Fetch failed: fetch response could not be parsed.", e);
+    }
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigGetParameterHandler.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigGetParameterHandler.java
new file mode 100644
index 000000000..284adc392
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigGetParameterHandler.java
@@ -0,0 +1,414 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_BOOLEAN;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_BYTE_ARRAY;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_DOUBLE;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_LONG;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_STRING;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.TAG;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.VALUE_SOURCE_DEFAULT;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.VALUE_SOURCE_REMOTE;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.VALUE_SOURCE_STATIC;
+
+import android.util.Log;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfig;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigValue;
+import java.nio.charset.Charset;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.regex.Pattern;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * A handler for getting values stored in the Firebase Remote Config (FRC) SDK.
+ *
+ * <p>Provides methods to return parameter values as one of the six types supported by FRC: {@code
+ * booolean}, {@code byte[]}, {@code double}, {@code long}, {@link FirebaseRemoteConfigValue}, and
+ * {@link String}.
+ *
+ * <p>Evaluates the value of a parameter in the following order:
+ *
+ * <ol>
+ *   <li>The activated value, if the activated {@link ConfigCacheClient} contains the key.
+ *   <li>The default value, if the defaults {@link ConfigCacheClient} contains the key.
+ *   <li>The static default value for the given type, as defined in the static constants of {@link
+ *       FirebaseRemoteConfig}.
+ * </ol>
+ *
+ * @author Miraziz Yusupov
+ */
+public class ConfigGetParameterHandler {
+  /** Byte arrays in FRC are encoded as UTF-8 Strings. */
+  @VisibleForTesting(otherwise = VisibleForTesting.PACKAGE_PRIVATE)
+  public static final Charset FRC_BYTE_ARRAY_ENCODING = Charset.forName("UTF-8");
+  /** Regular expressions that will evaluate to a "true" boolean. */
+  static final Pattern TRUE_REGEX =
+      Pattern.compile("^(1|true|t|yes|y|on)$", Pattern.CASE_INSENSITIVE);
+  /** Regular expressions that will evaluate to a "false" boolean. */
+  static final Pattern FALSE_REGEX =
+      Pattern.compile("^(0|false|f|no|n|off|)$", Pattern.CASE_INSENSITIVE);
+
+  private final ConfigCacheClient activatedConfigsCache;
+  private final ConfigCacheClient defaultConfigsCache;
+
+  public ConfigGetParameterHandler(
+      ConfigCacheClient activatedConfigsCache, ConfigCacheClient defaultConfigsCache) {
+    this.activatedConfigsCache = activatedConfigsCache;
+    this.defaultConfigsCache = defaultConfigsCache;
+  }
+
+  /**
+   * Returns the parameter value of the given parameter key as a {@link String}.
+   *
+   * <p>Evaluates the value of the parameter in the following order:
+   *
+   * <ol>
+   *   <li>The value in the activated cache, if the key exists.
+   *   <li>The value in the defaults cache, if the key exists.
+   *   <li>{@link FirebaseRemoteConfig#DEFAULT_VALUE_FOR_STRING}.
+   * </ol>
+   *
+   * @param key A Firebase Remote Config parameter key.
+   */
+  public String getString(String key) {
+    String activatedString = getStringFromCache(activatedConfigsCache, key);
+    if (activatedString != null) {
+      return activatedString;
+    }
+
+    String defaultsString = getStringFromCache(defaultConfigsCache, key);
+    if (defaultsString != null) {
+      return defaultsString;
+    }
+
+    logParameterValueDoesNotExist(key, "String");
+    return DEFAULT_VALUE_FOR_STRING;
+  }
+
+  /**
+   * Returns the parameter value of the given parameter key as a {@code boolean}.
+   *
+   * <p>Evaluates the value of the parameter in the following order:
+   *
+   * <ol>
+   *   <li>The value in the activated cache, if the key exists and the value can be converted into a
+   *       {@code boolean}.
+   *   <li>The value in the defaults cache, if the key exists and the value can be converted into a
+   *       {@code boolean}.
+   *   <li>{@link FirebaseRemoteConfig#DEFAULT_VALUE_FOR_BOOLEAN}.
+   * </ol>
+   *
+   * @param key A Firebase Remote Config parameter key with a {@code boolean} parameter value.
+   */
+  public boolean getBoolean(String key) {
+    String activatedString = getStringFromCache(activatedConfigsCache, key);
+    if (activatedString != null) {
+      if (TRUE_REGEX.matcher(activatedString).matches()) {
+        return true;
+      } else if (FALSE_REGEX.matcher(activatedString).matches()) {
+        return false;
+      }
+    }
+
+    String defaultsString = getStringFromCache(defaultConfigsCache, key);
+    if (defaultsString != null) {
+      if (TRUE_REGEX.matcher(defaultsString).matches()) {
+        return true;
+      } else if (FALSE_REGEX.matcher(defaultsString).matches()) {
+        return false;
+      }
+    }
+
+    logParameterValueDoesNotExist(key, "Boolean");
+    return DEFAULT_VALUE_FOR_BOOLEAN;
+  }
+
+  /**
+   * Returns the parameter value of the given parameter key as a {@code byte[]}.
+   *
+   * <p>Evaluates the value of the parameter in the following order:
+   *
+   * <ol>
+   *   <li>The value in the activated cache, if the key exists.
+   *   <li>The value in the defaults cache, if the key exists.
+   *   <li>{@link FirebaseRemoteConfig#DEFAULT_VALUE_FOR_BYTE_ARRAY}.
+   * </ol>
+   *
+   * @param key A Firebase Remote Config parameter key.
+   */
+  public byte[] getByteArray(String key) {
+    String activatedString = getStringFromCache(activatedConfigsCache, key);
+    if (activatedString != null) {
+      return activatedString.getBytes(FRC_BYTE_ARRAY_ENCODING);
+    }
+
+    String defaultsString = getStringFromCache(defaultConfigsCache, key);
+    if (defaultsString != null) {
+      return defaultsString.getBytes(FRC_BYTE_ARRAY_ENCODING);
+    }
+
+    logParameterValueDoesNotExist(key, "ByteArray");
+    return DEFAULT_VALUE_FOR_BYTE_ARRAY;
+  }
+
+  /**
+   * Returns the parameter value of the given parameter key as a {@code double}.
+   *
+   * <p>Evaluates the value of the parameter in the following order:
+   *
+   * <ol>
+   *   <li>The value in the activated cache, if the key exists and the value can be converted into a
+   *       {@code double}.
+   *   <li>The value in the defaults cache, if the key exists and the value can be converted into a
+   *       {@code double}.
+   *   <li>{@link FirebaseRemoteConfig#DEFAULT_VALUE_FOR_DOUBLE}.
+   * </ol>
+   *
+   * @param key A Firebase Remote Config parameter key with a {@code double} parameter value.
+   */
+  public double getDouble(String key) {
+    Double activatedDouble = getDoubleFromCache(activatedConfigsCache, key);
+    if (activatedDouble != null) {
+      return activatedDouble;
+    }
+
+    Double defaultsDouble = getDoubleFromCache(defaultConfigsCache, key);
+    if (defaultsDouble != null) {
+      return defaultsDouble;
+    }
+
+    logParameterValueDoesNotExist(key, "Double");
+    return DEFAULT_VALUE_FOR_DOUBLE;
+  }
+
+  /**
+   * Returns the parameter value of the given parameter key as a {@code long}.
+   *
+   * <p>Evaluates the value of the parameter in the following order:
+   *
+   * <ol>
+   *   <li>The value in the activated cache, if the key exists and the value can be converted into a
+   *       {@code long}.
+   *   <li>The value in the defaults cache, if the key exists and the value can be converted into a
+   *       {@code long}.
+   *   <li>{@link FirebaseRemoteConfig#DEFAULT_VALUE_FOR_LONG}.
+   * </ol>
+   *
+   * @param key A Firebase Remote Config parameter key with a {@code long} parameter value.
+   */
+  public long getLong(String key) {
+    Long activatedLong = getLongFromCache(activatedConfigsCache, key);
+    if (activatedLong != null) {
+      return activatedLong;
+    }
+
+    Long defaultsLong = getLongFromCache(defaultConfigsCache, key);
+    if (defaultsLong != null) {
+      return defaultsLong;
+    }
+
+    logParameterValueDoesNotExist(key, "Long");
+    return DEFAULT_VALUE_FOR_LONG;
+  }
+
+  /**
+   * Returns the parameter value of the given parameter key as a {@link FirebaseRemoteConfigValue}.
+   *
+   * <p>Evaluates the value of the parameter in the following order:
+   *
+   * <ol>
+   *   <li>The value in the activated cache, if the key exists.
+   *   <li>The value in the defaults cache, if the key exists.
+   *   <li>A {@link FirebaseRemoteConfigValue} that returns the static value for each type.
+   * </ol>
+   *
+   * @param key A Firebase Remote Config parameter key.
+   */
+  public FirebaseRemoteConfigValue getValue(String key) {
+    String activatedString = getStringFromCache(activatedConfigsCache, key);
+    if (activatedString != null) {
+      return new FirebaseRemoteConfigValueImpl(activatedString, VALUE_SOURCE_REMOTE);
+    }
+
+    String defaultsString = getStringFromCache(defaultConfigsCache, key);
+    if (defaultsString != null) {
+      return new FirebaseRemoteConfigValueImpl(defaultsString, VALUE_SOURCE_DEFAULT);
+    }
+
+    logParameterValueDoesNotExist(key, "FirebaseRemoteConfigValue");
+    return new FirebaseRemoteConfigValueImpl(DEFAULT_VALUE_FOR_STRING, VALUE_SOURCE_STATIC);
+  }
+
+  /**
+   * Returns an ordered {@link Set} of all the FRC keys with the given prefix.
+   *
+   * <p>The set will contain all the keys in the activated and defaults configs with the given
+   * prefix.
+   *
+   * @param prefix A prefix for FRC keys. If the prefix is empty, all keys are returned.
+   */
+  public Set<String> getKeysByPrefix(String prefix) {
+    if (prefix == null) {
+      prefix = "";
+    }
+
+    TreeSet<String> keysWithPrefix = new TreeSet<>();
+
+    ConfigContainer activatedConfigs = getConfigsFromCache(activatedConfigsCache);
+    if (activatedConfigs != null) {
+      keysWithPrefix.addAll(getKeysByPrefix(prefix, activatedConfigs));
+    }
+
+    ConfigContainer defaultsConfigs = getConfigsFromCache(defaultConfigsCache);
+    if (defaultsConfigs != null) {
+      keysWithPrefix.addAll(getKeysByPrefix(prefix, defaultsConfigs));
+    }
+
+    return keysWithPrefix;
+  }
+
+  /** Returns a {@link TreeSet} of the keys in {@code configs} with the given prefix. */
+  private static TreeSet<String> getKeysByPrefix(String prefix, ConfigContainer configs) {
+    TreeSet<String> keysWithPrefix = new TreeSet<>();
+
+    Iterator<String> stringIterator = configs.getConfigs().keys();
+    while (stringIterator.hasNext()) {
+      String currentKey = stringIterator.next();
+      if (currentKey.startsWith(prefix)) {
+        keysWithPrefix.add(currentKey);
+      }
+    }
+
+    return keysWithPrefix;
+  }
+
+  /**
+   * Returns {@link Map} of FRC key value pairs.
+   *
+   * <p>Evaluates the values of the parameters in the following order:
+   *
+   * <ol>
+   *   <li>The value in the activated cache, if the key exists.
+   *   <li>The value in the defaults cache, if the key exists.
+   * </ol>
+   */
+  public Map<String, FirebaseRemoteConfigValue> getAll() {
+    Set<String> keySet = new HashSet<>();
+    keySet.addAll(getKeySetFromCache(activatedConfigsCache));
+    keySet.addAll(getKeySetFromCache(defaultConfigsCache));
+
+    HashMap<String, FirebaseRemoteConfigValue> allConfigs = new HashMap<>();
+    for (String key : keySet) {
+      allConfigs.put(key, getValue(key));
+    }
+    return allConfigs;
+  }
+
+  /**
+   * Returns the FRC parameter value for the given key in the given cache as a {@link String}, or
+   * {@code null} if the key does not exist in the cache.
+   *
+   * @param cacheClient the cache client the parameter is stored in.
+   * @param key the FRC parameter key.
+   */
+  @Nullable
+  private static String getStringFromCache(ConfigCacheClient cacheClient, String key) {
+    ConfigContainer cachedContainer = getConfigsFromCache(cacheClient);
+    if (cachedContainer == null) {
+      return null;
+    }
+
+    try {
+      return cachedContainer.getConfigs().getString(key);
+    } catch (JSONException ignored) {
+      return null;
+    }
+  }
+
+  /**
+   * Returns the FRC parameter value for the given key in the given cache as a {@link Double}, or
+   * {@code null} if the key does not have a {@code double} value in the cache.
+   */
+  @Nullable
+  private static Double getDoubleFromCache(ConfigCacheClient cacheClient, String key) {
+    ConfigContainer cachedContainer = getConfigsFromCache(cacheClient);
+    if (cachedContainer == null) {
+      return null;
+    }
+
+    try {
+      return cachedContainer.getConfigs().getDouble(key);
+    } catch (JSONException ignored) {
+      return null;
+    }
+  }
+
+  /**
+   * Returns the FRC parameter value for the given key in the given cache as a {@link Long}, or
+   * {@code null} if the key does not have a {@code long} value in the cache.
+   */
+  @Nullable
+  private static Long getLongFromCache(ConfigCacheClient cacheClient, String key) {
+    ConfigContainer cachedContainer = getConfigsFromCache(cacheClient);
+    if (cachedContainer == null) {
+      return null;
+    }
+
+    try {
+      return cachedContainer.getConfigs().getLong(key);
+    } catch (JSONException ignored) {
+      return null;
+    }
+  }
+
+  /** Returns all FRC parameter keys in the given cache. */
+  private static Set<String> getKeySetFromCache(ConfigCacheClient cacheClient) {
+    Set<String> keySet = new HashSet<>();
+    ConfigContainer configContainer = getConfigsFromCache(cacheClient);
+    if (configContainer == null) {
+      return keySet;
+    }
+
+    JSONObject configs = configContainer.getConfigs();
+    Iterator<String> keyIterator = configs.keys();
+    while (keyIterator.hasNext()) {
+      keySet.add(keyIterator.next());
+    }
+    return keySet;
+  }
+
+  /**
+   * Returns the FRC configs in the given cache as {@link ConfigContainer} or {@code null} if there
+   * are no configs in the cache.
+   */
+  @Nullable
+  private static ConfigContainer getConfigsFromCache(ConfigCacheClient cacheClient) {
+    return cacheClient.getBlocking();
+  }
+
+  private static void logParameterValueDoesNotExist(String key, String valueType) {
+    Log.w(
+        TAG, String.format("No value of type '%s' exists for parameter key '%s'.", valueType, key));
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigMetadataClient.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigMetadataClient.java
new file mode 100644
index 000000000..50c91b41a
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigMetadataClient.java
@@ -0,0 +1,269 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.LAST_FETCH_STATUS_FAILURE;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.LAST_FETCH_STATUS_NO_FETCH_YET;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.LAST_FETCH_STATUS_SUCCESS;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.LAST_FETCH_STATUS_THROTTLED;
+import static com.google.firebase.remoteconfig.RemoteConfigComponent.NETWORK_CONNECTION_TIMEOUT_IN_SECONDS;
+import static com.google.firebase.remoteconfig.internal.ConfigFetchHandler.DEFAULT_MINIMUM_FETCH_INTERVAL_IN_SECONDS;
+import static java.lang.annotation.RetentionPolicy.SOURCE;
+
+import android.content.SharedPreferences;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import androidx.annotation.WorkerThread;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigInfo;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigSettings;
+import java.lang.annotation.Retention;
+import java.util.Date;
+
+/**
+ * Client for handling Firebase Remote Config (FRC) metadata that is saved to disk and persisted
+ * across App life cycles.
+ *
+ * @author Miraziz Yusupov
+ */
+public class ConfigMetadataClient {
+  @Retention(SOURCE)
+  @IntDef({
+    LAST_FETCH_STATUS_SUCCESS,
+    LAST_FETCH_STATUS_NO_FETCH_YET,
+    LAST_FETCH_STATUS_FAILURE,
+    LAST_FETCH_STATUS_THROTTLED
+  })
+  @interface LastFetchStatus {}
+
+  /** Indicates that there have been no successful fetch attempts yet. */
+  @VisibleForTesting public static final long LAST_FETCH_TIME_IN_MILLIS_NO_FETCH_YET = -1L;
+
+  static final Date LAST_FETCH_TIME_NO_FETCH_YET = new Date(LAST_FETCH_TIME_IN_MILLIS_NO_FETCH_YET);
+
+  @VisibleForTesting static final int NO_FAILED_FETCHES = 0;
+  private static final long NO_BACKOFF_TIME_IN_MILLIS = -1L;
+  @VisibleForTesting static final Date NO_BACKOFF_TIME = new Date(NO_BACKOFF_TIME_IN_MILLIS);
+
+  private static final String DEVELOPER_MODE_KEY = "is_developer_mode_enabled";
+  private static final String FETCH_TIMEOUT_IN_SECONDS_KEY = "fetch_timeout_in_seconds";
+  private static final String MINIMUM_FETCH_INTERVAL_IN_SECONDS_KEY =
+      "minimum_fetch_interval_in_seconds";
+  private static final String LAST_FETCH_STATUS_KEY = "last_fetch_status";
+  private static final String LAST_SUCCESSFUL_FETCH_TIME_IN_MILLIS_KEY =
+      "last_fetch_time_in_millis";
+  private static final String LAST_FETCH_ETAG_KEY = "last_fetch_etag";
+  private static final String BACKOFF_END_TIME_IN_MILLIS_KEY = "backoff_end_time_in_millis";
+  private static final String NUM_FAILED_FETCHES_KEY = "num_failed_fetches";
+
+  private final SharedPreferences frcMetadata;
+
+  private final Object frcInfoLock;
+  private final Object backoffMetadataLock;
+
+  public ConfigMetadataClient(SharedPreferences frcMetadata) {
+    this.frcMetadata = frcMetadata;
+    this.frcInfoLock = new Object();
+    this.backoffMetadataLock = new Object();
+  }
+
+  public boolean isDeveloperModeEnabled() {
+    return frcMetadata.getBoolean(DEVELOPER_MODE_KEY, false);
+  }
+
+  public long getFetchTimeoutInSeconds() {
+    return frcMetadata.getLong(FETCH_TIMEOUT_IN_SECONDS_KEY, NETWORK_CONNECTION_TIMEOUT_IN_SECONDS);
+  }
+
+  public long getMinimumFetchIntervalInSeconds() {
+    return frcMetadata.getLong(
+        MINIMUM_FETCH_INTERVAL_IN_SECONDS_KEY, DEFAULT_MINIMUM_FETCH_INTERVAL_IN_SECONDS);
+  }
+
+  @LastFetchStatus
+  int getLastFetchStatus() {
+    return frcMetadata.getInt(LAST_FETCH_STATUS_KEY, LAST_FETCH_STATUS_NO_FETCH_YET);
+  }
+
+  Date getLastSuccessfulFetchTime() {
+    return new Date(
+        frcMetadata.getLong(
+            LAST_SUCCESSFUL_FETCH_TIME_IN_MILLIS_KEY, LAST_FETCH_TIME_IN_MILLIS_NO_FETCH_YET));
+  }
+
+  @Nullable
+  String getLastFetchETag() {
+    return frcMetadata.getString(LAST_FETCH_ETAG_KEY, null);
+  }
+
+  public FirebaseRemoteConfigInfo getInfo() {
+    // A lock is used here to prevent the setters in this class from changing the state of
+    // frcMetadata during a getInfo call.
+    synchronized (frcInfoLock) {
+      long lastSuccessfulFetchTimeInMillis =
+          frcMetadata.getLong(
+              LAST_SUCCESSFUL_FETCH_TIME_IN_MILLIS_KEY, LAST_FETCH_TIME_IN_MILLIS_NO_FETCH_YET);
+      @LastFetchStatus
+      int lastFetchStatus =
+          frcMetadata.getInt(LAST_FETCH_STATUS_KEY, LAST_FETCH_STATUS_NO_FETCH_YET);
+
+      FirebaseRemoteConfigSettings settings =
+          new FirebaseRemoteConfigSettings.Builder()
+              .setDeveloperModeEnabled(frcMetadata.getBoolean(DEVELOPER_MODE_KEY, false))
+              .setFetchTimeoutInSeconds(
+                  frcMetadata.getLong(
+                      FETCH_TIMEOUT_IN_SECONDS_KEY, NETWORK_CONNECTION_TIMEOUT_IN_SECONDS))
+              .setMinimumFetchIntervalInSeconds(
+                  frcMetadata.getLong(
+                      MINIMUM_FETCH_INTERVAL_IN_SECONDS_KEY,
+                      DEFAULT_MINIMUM_FETCH_INTERVAL_IN_SECONDS))
+              .build();
+
+      return FirebaseRemoteConfigInfoImpl.newBuilder()
+          .withLastFetchStatus(lastFetchStatus)
+          .withLastSuccessfulFetchTimeInMillis(lastSuccessfulFetchTimeInMillis)
+          .withConfigSettings(settings)
+          .build();
+    }
+  }
+
+  /**
+   * Clears all metadata values from memory and disk.
+   *
+   * <p>The method is blocking and returns only when the values in disk are also cleared.
+   */
+  @WorkerThread
+  public void clear() {
+    synchronized (frcInfoLock) {
+      frcMetadata.edit().clear().commit();
+    }
+  }
+
+  /**
+   * Updates the stored settings with the given {@link FirebaseRemoteConfigSettings}, and blocks
+   * until the changes are persisted to disk.
+   *
+   * @param settings the new settings to apply.
+   */
+  @WorkerThread
+  public void setConfigSettings(FirebaseRemoteConfigSettings settings) {
+    synchronized (frcInfoLock) {
+      frcMetadata
+          .edit()
+          .putBoolean(DEVELOPER_MODE_KEY, settings.isDeveloperModeEnabled())
+          .putLong(FETCH_TIMEOUT_IN_SECONDS_KEY, settings.getFetchTimeoutInSeconds())
+          .putLong(
+              MINIMUM_FETCH_INTERVAL_IN_SECONDS_KEY, settings.getMinimumFetchIntervalInSeconds())
+          .commit();
+    }
+  }
+
+  /**
+   * Updates the stored settings with the given {@link FirebaseRemoteConfigSettings} and returns
+   * before waiting on the disk write to complete.
+   *
+   * @param settings the new settings to apply.
+   */
+  public void setConfigSettingsWithoutWaitingOnDiskWrite(FirebaseRemoteConfigSettings settings) {
+    synchronized (frcInfoLock) {
+      frcMetadata
+          .edit()
+          .putBoolean(DEVELOPER_MODE_KEY, settings.isDeveloperModeEnabled())
+          .putLong(FETCH_TIMEOUT_IN_SECONDS_KEY, settings.getFetchTimeoutInSeconds())
+          .putLong(
+              MINIMUM_FETCH_INTERVAL_IN_SECONDS_KEY, settings.getMinimumFetchIntervalInSeconds())
+          .apply();
+    }
+  }
+
+  void updateLastFetchAsSuccessfulAt(Date fetchTime) {
+    synchronized (frcInfoLock) {
+      frcMetadata
+          .edit()
+          .putInt(LAST_FETCH_STATUS_KEY, LAST_FETCH_STATUS_SUCCESS)
+          .putLong(LAST_SUCCESSFUL_FETCH_TIME_IN_MILLIS_KEY, fetchTime.getTime())
+          .apply();
+    }
+  }
+
+  void updateLastFetchAsFailed() {
+    synchronized (frcInfoLock) {
+      frcMetadata.edit().putInt(LAST_FETCH_STATUS_KEY, LAST_FETCH_STATUS_FAILURE).apply();
+    }
+  }
+
+  void updateLastFetchAsThrottled() {
+    synchronized (frcInfoLock) {
+      frcMetadata.edit().putInt(LAST_FETCH_STATUS_KEY, LAST_FETCH_STATUS_THROTTLED).apply();
+    }
+  }
+
+  void setLastFetchETag(String eTag) {
+    synchronized (frcInfoLock) {
+      frcMetadata.edit().putString(LAST_FETCH_ETAG_KEY, eTag).apply();
+    }
+  }
+
+  // -----------------------------------------------------------------
+  // Exponential backoff logic.
+  // -----------------------------------------------------------------
+
+  BackoffMetadata getBackoffMetadata() {
+    synchronized (backoffMetadataLock) {
+      return new BackoffMetadata(
+          frcMetadata.getInt(NUM_FAILED_FETCHES_KEY, NO_FAILED_FETCHES),
+          new Date(frcMetadata.getLong(BACKOFF_END_TIME_IN_MILLIS_KEY, NO_BACKOFF_TIME_IN_MILLIS)));
+    }
+  }
+
+  void setBackoffMetadata(int numFailedFetches, Date backoffEndTime) {
+    synchronized (backoffMetadataLock) {
+      frcMetadata
+          .edit()
+          .putInt(NUM_FAILED_FETCHES_KEY, numFailedFetches)
+          .putLong(BACKOFF_END_TIME_IN_MILLIS_KEY, backoffEndTime.getTime())
+          .apply();
+    }
+  }
+
+  void resetBackoff() {
+    setBackoffMetadata(NO_FAILED_FETCHES, NO_BACKOFF_TIME);
+  }
+
+  /**
+   * Container for backoff metadata values such as the number of failed fetches and the backoff end
+   * time.
+   *
+   * <p>The purpose of this class is to avoid race conditions when retrieving backoff metadata
+   * values separately.
+   */
+  static class BackoffMetadata {
+    private int numFailedFetches;
+    private Date backoffEndTime;
+
+    BackoffMetadata(int numFailedFetches, Date backoffEndTime) {
+      this.numFailedFetches = numFailedFetches;
+      this.backoffEndTime = backoffEndTime;
+    }
+
+    int getNumFailedFetches() {
+      return numFailedFetches;
+    }
+
+    Date getBackoffEndTime() {
+      return backoffEndTime;
+    }
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigStorageClient.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigStorageClient.java
new file mode 100644
index 000000000..74b68469f
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/ConfigStorageClient.java
@@ -0,0 +1,145 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import android.content.Context;
+import androidx.annotation.AnyThread;
+import androidx.annotation.GuardedBy;
+import androidx.annotation.VisibleForTesting;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Callable;
+import javax.annotation.Nullable;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * File-backed storage client for managing {@link ConfigContainer}s in disk.
+ *
+ * <p>At most one instance of this class exists for any given file, so all calls to {@link
+ * #getInstance(Context, String)} with the same context and file name will return the same instance.
+ *
+ * <p>Since there's a one to one mapping between files and storage clients, and every method in the
+ * client is synchronized, two threads in the same process should never write to the same file
+ * simultaneously.
+ *
+ * @author Miraziz Yusupov
+ */
+@AnyThread
+public class ConfigStorageClient {
+  @GuardedBy("ConfigStorageClient.class")
+  private static final Map<String, ConfigStorageClient> clientInstances = new HashMap<>();
+
+  private static final String JSON_STRING_ENCODING = "UTF-8";
+
+  private final Context context;
+  private final String fileName;
+
+  /** Creates a new storage client backed by the specified file. */
+  private ConfigStorageClient(Context context, String fileName) {
+    this.context = context;
+    this.fileName = fileName;
+  }
+
+  /**
+   * Writes the {@link ConfigContainer} to disk.
+   *
+   * <p>Writes are non-atomic, so, if the write fails, the disk will likely be corrupted.
+   *
+   * <p>Possible reasons for failures while writing include:
+   *
+   * <ul>
+   *   <li>Out of disk space
+   *   <li>Power outage
+   *   <li>Process termination
+   * </ul>
+   *
+   * @return {@link Void} because {@link com.google.android.gms.tasks.Tasks#call(Callable)} requires
+   *     a non-void return value.
+   * @throws IOException if the file write fails.
+   */
+  public synchronized Void write(ConfigContainer container) throws IOException {
+    // TODO(issues/262): Consider using the AtomicFile class instead.
+    FileOutputStream outputStream = context.openFileOutput(fileName, Context.MODE_PRIVATE);
+    try {
+      outputStream.write(container.toString().getBytes(JSON_STRING_ENCODING));
+    } finally {
+      outputStream.close();
+    }
+    return null;
+  }
+
+  /**
+   * Reads and returns the {@link ConfigContainer} stored in disk.
+   *
+   * @return a valid {@link ConfigContainer} or null if the file was corrupt or not found.
+   * @throws IOException if the file read fails.
+   */
+  @Nullable
+  public synchronized ConfigContainer read() throws IOException {
+
+    FileInputStream fileInputStream = null;
+    try {
+      fileInputStream = context.openFileInput(fileName);
+      byte[] bytes = new byte[fileInputStream.available()];
+      fileInputStream.read(bytes, 0, bytes.length);
+      String containerJsonString = new String(bytes, JSON_STRING_ENCODING);
+
+      JSONObject containerJson = new JSONObject(containerJsonString);
+      return ConfigContainer.copyOf(containerJson);
+    } catch (JSONException | FileNotFoundException e) {
+      // File might not have been written to yet, so this not an irrecoverable error.
+      return null;
+    } finally {
+      if (fileInputStream != null) fileInputStream.close();
+    }
+  }
+
+  /**
+   * Clears the {@link ConfigContainer} in disk.
+   *
+   * @return {@link Void} because {@link com.google.android.gms.tasks.Tasks#call(Callable)} requires
+   *     a non-void return value.
+   */
+  public synchronized Void clear() {
+    context.deleteFile(fileName);
+    return null;
+  }
+
+  /**
+   * Returns an instance of {@link ConfigStorageClient} for the given context and file name. The
+   * same instance is always returned for all calls with the same file name.
+   */
+  public static synchronized ConfigStorageClient getInstance(Context context, String fileName) {
+    if (!clientInstances.containsKey(fileName)) {
+      clientInstances.put(fileName, new ConfigStorageClient(context, fileName));
+    }
+    return clientInstances.get(fileName);
+  }
+
+  @VisibleForTesting
+  public static synchronized void clearInstancesForTest() {
+    clientInstances.clear();
+  }
+
+  /** Returns the name of the file associated with this storage client. */
+  String getFileName() {
+    return fileName;
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/DefaultsXmlParser.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/DefaultsXmlParser.java
new file mode 100644
index 000000000..e71074419
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/DefaultsXmlParser.java
@@ -0,0 +1,132 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.TAG;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.content.res.XmlResourceParser;
+import android.util.Log;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import org.xmlpull.v1.XmlPullParserException;
+
+/**
+ * Parser for the defaults XML file.
+ *
+ * <p>Firebase Remote Config (FRC) users can provide an XML file with a map of default values to be
+ * used when no fetched values are available. This class helps parse that XML into a Java {@link
+ * Map}.
+ *
+ * <p>The parser saves the texts of the {@code XML_TAG_KEY} and {@code XML_TAG_VALUE} tags inside
+ * each {@code XML_TAG_ENTRY} as a key-value pair and returns a map of all such pairs.
+ *
+ * <p>For example, consider the following XML file:
+ *
+ * <pre>{@code
+ * <defaults>
+ *   <bad_entry>
+ *     <key>first_default_key</key>
+ *     <value>first_default_value</value>
+ *   </bad_entry>
+ *   <entry>
+ *     <key>second_default_key</key>
+ *     <value>second_default_value</value>
+ *   </entry>
+ *   <entry>
+ *     <bad_key>third_default_key</bad_key>
+ *     <value>third_default_value</value>
+ *   </entry>
+ *   <entry>
+ *     <key>fourth_default_key</key>
+ *     <bad_value>fourth_default_value</bad_value>
+ *   </entry>
+ * }</pre>
+ *
+ * Only the "second_default_key, second_default_value" pair would be recorded, since the remaining
+ * tags are malformed.
+ *
+ * @author Miraziz Yusupov
+ */
+public class DefaultsXmlParser {
+  private static final String XML_TAG_ENTRY = "entry";
+  private static final String XML_TAG_KEY = "key";
+  private static final String XML_TAG_VALUE = "value";
+
+  /**
+   * Returns a {@link Map} of default FRC values parsed from the defaults XML file.
+   *
+   * @param context the application context.
+   * @param resourceId the resource id of the defaults XML file.
+   */
+  public static Map<String, String> getDefaultsFromXml(Context context, int resourceId) {
+    Map<String, String> defaultsMap = new HashMap<>();
+
+    try {
+      Resources resources = context.getResources();
+      if (resources == null) {
+        Log.e(
+            TAG,
+            "Could not find the resources of the current context "
+                + "while trying to set defaults from an XML.");
+        return defaultsMap;
+      }
+
+      XmlResourceParser xmlParser = resources.getXml(resourceId);
+
+      String curTag = null;
+      String key = null;
+      String value = null;
+
+      int eventType = xmlParser.getEventType();
+      while (eventType != XmlResourceParser.END_DOCUMENT) {
+        if (eventType == XmlResourceParser.START_TAG) {
+          curTag = xmlParser.getName();
+        } else if (eventType == XmlResourceParser.END_TAG) {
+          if (xmlParser.getName().equals(XML_TAG_ENTRY)) {
+            if (key != null && value != null) {
+              defaultsMap.put(key, value);
+            } else {
+              Log.w(TAG, "An entry in the defaults XML has an invalid key and/or value tag.");
+            }
+            key = null;
+            value = null;
+          }
+          curTag = null;
+        } else if (eventType == XmlResourceParser.TEXT) {
+          if (curTag != null) {
+            switch (curTag) {
+              case XML_TAG_KEY:
+                key = xmlParser.getText();
+                break;
+              case XML_TAG_VALUE:
+                value = xmlParser.getText();
+                break;
+              default:
+                Log.w(TAG, "Encountered an unexpected tag while parsing the defaults XML.");
+                break;
+            }
+          }
+        }
+        eventType = xmlParser.next();
+      }
+    } catch (XmlPullParserException | IOException e) {
+      Log.e(TAG, "Encountered an error while parsing the defaults XML file.", e);
+    }
+    return defaultsMap;
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/FirebaseRemoteConfigInfoImpl.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/FirebaseRemoteConfigInfoImpl.java
new file mode 100644
index 000000000..15f0bb000
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/FirebaseRemoteConfigInfoImpl.java
@@ -0,0 +1,88 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigInfo;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigSettings;
+import com.google.firebase.remoteconfig.internal.ConfigMetadataClient.LastFetchStatus;
+
+/**
+ * Impl class for FirebaseRemoteConfigInfo.
+ *
+ * @author Miraziz Yusupov
+ * @hide
+ */
+public class FirebaseRemoteConfigInfoImpl implements FirebaseRemoteConfigInfo {
+  private final long lastSuccessfulFetchTimeInMillis;
+  @LastFetchStatus private final int lastFetchStatus;
+  private final FirebaseRemoteConfigSettings configSettings;
+
+  private FirebaseRemoteConfigInfoImpl(
+      long lastSuccessfulFetchTimeInMillis,
+      int lastFetchStatus,
+      FirebaseRemoteConfigSettings configSettings) {
+    this.lastSuccessfulFetchTimeInMillis = lastSuccessfulFetchTimeInMillis;
+    this.lastFetchStatus = lastFetchStatus;
+    this.configSettings = configSettings;
+  }
+
+  @Override
+  public long getFetchTimeMillis() {
+    return lastSuccessfulFetchTimeInMillis;
+  }
+
+  @Override
+  public int getLastFetchStatus() {
+    return lastFetchStatus;
+  }
+
+  @Override
+  public FirebaseRemoteConfigSettings getConfigSettings() {
+    return configSettings;
+  }
+
+  /** Builder for creating an instance of {@link FirebaseRemoteConfigInfo}. */
+  public static class Builder {
+    private Builder() {}
+
+    private long builderLastSuccessfulFetchTimeInMillis;
+    @LastFetchStatus private int builderLastFetchStatus;
+    private FirebaseRemoteConfigSettings builderConfigSettings;
+
+    public Builder withLastSuccessfulFetchTimeInMillis(long fetchTimeInMillis) {
+      this.builderLastSuccessfulFetchTimeInMillis = fetchTimeInMillis;
+      return this;
+    }
+
+    Builder withLastFetchStatus(@LastFetchStatus int lastFetchStatus) {
+      this.builderLastFetchStatus = lastFetchStatus;
+      return this;
+    }
+
+    Builder withConfigSettings(FirebaseRemoteConfigSettings configSettings) {
+      this.builderConfigSettings = configSettings;
+      return this;
+    }
+
+    public FirebaseRemoteConfigInfoImpl build() {
+      return new FirebaseRemoteConfigInfoImpl(
+          builderLastSuccessfulFetchTimeInMillis, builderLastFetchStatus, builderConfigSettings);
+    }
+  }
+
+  static Builder newBuilder() {
+    return new Builder();
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/FirebaseRemoteConfigValueImpl.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/FirebaseRemoteConfigValueImpl.java
new file mode 100644
index 000000000..1326165f7
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/FirebaseRemoteConfigValueImpl.java
@@ -0,0 +1,121 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.firebase.remoteconfig.internal.ConfigGetParameterHandler.FALSE_REGEX;
+import static com.google.firebase.remoteconfig.internal.ConfigGetParameterHandler.FRC_BYTE_ARRAY_ENCODING;
+import static com.google.firebase.remoteconfig.internal.ConfigGetParameterHandler.TRUE_REGEX;
+
+import com.google.firebase.remoteconfig.FirebaseRemoteConfig;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigValue;
+
+/**
+ * Implementation of {@link FirebaseRemoteConfigValue}.
+ *
+ * @author Miraziz Yusupov
+ */
+public class FirebaseRemoteConfigValueImpl implements FirebaseRemoteConfigValue {
+  private static final String ILLEGAL_ARGUMENT_STRING_FORMAT =
+      "[Value: %s] cannot be converted to a %s.";
+
+  private final String value;
+  private final int source;
+
+  FirebaseRemoteConfigValueImpl(String value, int source) {
+    this.value = value;
+    this.source = source;
+  }
+
+  @Override
+  public long asLong() {
+    if (source == FirebaseRemoteConfig.VALUE_SOURCE_STATIC) {
+      return FirebaseRemoteConfig.DEFAULT_VALUE_FOR_LONG;
+    }
+
+    String valueAsString = asTrimmedString();
+    try {
+      return Long.valueOf(valueAsString);
+    } catch (NumberFormatException e) {
+      throw new IllegalArgumentException(
+          String.format(ILLEGAL_ARGUMENT_STRING_FORMAT, valueAsString, "long"), e);
+    }
+  }
+
+  @Override
+  public double asDouble() {
+    if (source == FirebaseRemoteConfig.VALUE_SOURCE_STATIC) {
+      return FirebaseRemoteConfig.DEFAULT_VALUE_FOR_DOUBLE;
+    }
+
+    String valueAsString = asTrimmedString();
+    try {
+      return Double.valueOf(valueAsString);
+    } catch (NumberFormatException e) {
+      throw new IllegalArgumentException(
+          String.format(ILLEGAL_ARGUMENT_STRING_FORMAT, valueAsString, "double"), e);
+    }
+  }
+
+  @Override
+  public String asString() {
+    if (source == FirebaseRemoteConfig.VALUE_SOURCE_STATIC) {
+      return FirebaseRemoteConfig.DEFAULT_VALUE_FOR_STRING;
+    }
+
+    throwIfNullValue();
+    return value;
+  }
+
+  @Override
+  public byte[] asByteArray() {
+    if (source == FirebaseRemoteConfig.VALUE_SOURCE_STATIC) {
+      return FirebaseRemoteConfig.DEFAULT_VALUE_FOR_BYTE_ARRAY;
+    }
+    return value.getBytes(FRC_BYTE_ARRAY_ENCODING);
+  }
+
+  @Override
+  public boolean asBoolean() throws IllegalArgumentException {
+    if (source == FirebaseRemoteConfig.VALUE_SOURCE_STATIC) {
+      return FirebaseRemoteConfig.DEFAULT_VALUE_FOR_BOOLEAN;
+    }
+
+    String valueAsString = asTrimmedString();
+    if (TRUE_REGEX.matcher(valueAsString).matches()) {
+      return true;
+    } else if (FALSE_REGEX.matcher(valueAsString).matches()) {
+      return false;
+    }
+    throw new IllegalArgumentException(
+        String.format(ILLEGAL_ARGUMENT_STRING_FORMAT, valueAsString, "boolean"));
+  }
+
+  @Override
+  public int getSource() {
+    return source;
+  }
+
+  private void throwIfNullValue() {
+    if (value == null) {
+      throw new IllegalArgumentException(
+          "Value is null, and cannot be converted to the desired type.");
+    }
+  }
+
+  /** Returns a trimmed version of {@link #asString}. */
+  private String asTrimmedString() {
+    return asString().trim();
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/LegacyConfigsHandler.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/LegacyConfigsHandler.java
new file mode 100644
index 000000000..74515ccf7
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/LegacyConfigsHandler.java
@@ -0,0 +1,399 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//  TODO(issues/261): Remove with the next major change release of FRC.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.TAG;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.util.Log;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import androidx.annotation.WorkerThread;
+import com.google.firebase.remoteconfig.RemoteConfigComponent;
+import com.google.firebase.remoteconfig.proto.ConfigPersistence.ConfigHolder;
+import com.google.firebase.remoteconfig.proto.ConfigPersistence.KeyValue;
+import com.google.firebase.remoteconfig.proto.ConfigPersistence.NamespaceKeyValue;
+import com.google.firebase.remoteconfig.proto.ConfigPersistence.PersistedConfig;
+import com.google.protobuf.ByteString;
+import com.google.protobuf.InvalidProtocolBufferException;
+import developers.mobile.abt.FirebaseAbt.ExperimentPayload;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Handler for reading and converting configs stored as protos by the older versions of the FRC SDK,
+ * as well as writing those protos to the appropriate {@link ConfigCacheClient}s.
+ *
+ * <p>The legacy SDK stores configs in the App's disk space as a {@link PersistedConfig}. The new
+ * SDK stores values as JSON, so clients will lose their state after updating to the new SDK. To
+ * avoid such a breaking change, this class reads the proto in the old SDK's file and writes it to
+ * the new SDK's files.
+ *
+ * <p>To prevent the legacy configs from overwriting new fetched values, the legacy configs will
+ * only be written to the new SDK once. After the first write in the new SDK, legacy configs will be
+ * permanently ignored.
+ *
+ * @author Miraziz Yusupov
+ */
+public class LegacyConfigsHandler {
+  @VisibleForTesting public static final String EXPERIMENT_ID_KEY = "experimentId";
+  @VisibleForTesting public static final String EXPERIMENT_VARIANT_ID_KEY = "variantId";
+  @VisibleForTesting public static final String EXPERIMENT_START_TIME_KEY = "experimentStartTime";
+  @VisibleForTesting public static final String EXPERIMENT_TRIGGER_EVENT_KEY = "triggerEvent";
+
+  @VisibleForTesting
+  public static final String EXPERIMENT_TRIGGER_TIMEOUT_KEY = "triggerTimeoutMillis";
+
+  @VisibleForTesting public static final String EXPERIMENT_TIME_TO_LIVE_KEY = "timeToLiveMillis";
+
+  /** Name of the file with the legacy configs proto. */
+  @VisibleForTesting static final String LEGACY_CONFIGS_FILE_NAME = "persisted_config";
+  /**
+   * Name of the file with the flag to determine if legacy configs should be read and saved to the
+   * new SDK.
+   */
+  private static final String LEGACY_SETTINGS_FILE_NAME =
+      "com.google.firebase.remoteconfig_legacy_settings";
+
+  private static final String SAVE_LEGACY_CONFIGS_FLAG_NAME = "save_legacy_configs";
+
+  /**
+   * The legacy FRC server prepended all namespaces with "configns:", while the current FRC server
+   * does not. The legacy proto will have namespaces with the legacy format, but the converted
+   * configs need to be saved to namespaces without the prefix.
+   */
+  @VisibleForTesting static final String LEGACY_FRC_NAMESPACE_PREFIX = "configns:";
+
+  /** The default namespace for all 3P configs. */
+  private static final String FRC_3P_NAMESPACE = "firebase";
+
+  /** The encoding used to serialize the legacy FRC and ABT protos. */
+  private static final Charset PROTO_BYTE_ARRAY_ENCODING = Charset.forName("UTF-8");
+
+  /** Name of the file where activate configs are stored. */
+  @VisibleForTesting
+  static final String ACTIVATE_FILE_NAME = RemoteConfigComponent.ACTIVATE_FILE_NAME;
+
+  /** Name of the file where fetched configs are stored. */
+  @VisibleForTesting static final String FETCH_FILE_NAME = RemoteConfigComponent.FETCH_FILE_NAME;
+
+  /** Name of the file where defaults configs are stored. */
+  @VisibleForTesting
+  static final String DEFAULTS_FILE_NAME = RemoteConfigComponent.DEFAULTS_FILE_NAME;
+
+  /**
+   * The String format of a protobuf Timestamp; the format is ISO 8601 compliant.
+   *
+   * <p>The protobuf Timestamp field gets converted to an ISO 8601 string when returned as JSON. For
+   * example, the Firebase Remote Config backend sends experiment start time as a Timestamp field,
+   * which gets converted to an ISO 8601 string when sent as JSON.
+   */
+  @VisibleForTesting
+  static final ThreadLocal<DateFormat> protoTimestampStringParser =
+      new ThreadLocal<DateFormat>() {
+        @Override
+        protected DateFormat initialValue() {
+          return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.US);
+        }
+      };
+
+  private final Context context;
+  private final String appId;
+  private final SharedPreferences legacySettings;
+
+  /** The Legacy Configs Handler constructor. */
+  public LegacyConfigsHandler(Context context, String appId) {
+    this.context = context;
+    this.appId = appId;
+
+    this.legacySettings =
+        context.getSharedPreferences(LEGACY_SETTINGS_FILE_NAME, Context.MODE_PRIVATE);
+  }
+
+  /**
+   * The first time this method is ever called, any existing legacy configs are read and saved to
+   * disk. At the end of the first invocation of this method, a persisted flag will be switched to
+   * false and all subsequent calls to this method will be ignored.
+   */
+  @WorkerThread
+  public boolean saveLegacyConfigsIfNecessary() {
+    if (legacySettings.getBoolean(SAVE_LEGACY_CONFIGS_FLAG_NAME, true)) {
+      saveLegacyConfigs(getConvertedLegacyConfigs());
+      legacySettings.edit().putBoolean(SAVE_LEGACY_CONFIGS_FLAG_NAME, false).commit();
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * Saves all the configs in {@code legacyConfigsByNamespace} to disk.
+   *
+   * @param legacyConfigsByNamespace a map from namespaces to {@link NamespaceLegacyConfigs}, each
+   *     of which contains the activated, fetched and defaults legacy configs for a single
+   *     namespace.
+   */
+  @WorkerThread
+  private void saveLegacyConfigs(Map<String, NamespaceLegacyConfigs> legacyConfigsByNamespace) {
+    for (Map.Entry<String, NamespaceLegacyConfigs> legacyConfigsByNamespaceEntry :
+        legacyConfigsByNamespace.entrySet()) {
+      String namespace = legacyConfigsByNamespaceEntry.getKey();
+      NamespaceLegacyConfigs legacyConfigs = legacyConfigsByNamespaceEntry.getValue();
+
+      ConfigCacheClient fetchedCacheClient = getCacheClient(namespace, FETCH_FILE_NAME);
+      ConfigCacheClient activatedCacheClient = getCacheClient(namespace, ACTIVATE_FILE_NAME);
+      ConfigCacheClient defaultsCacheClient = getCacheClient(namespace, DEFAULTS_FILE_NAME);
+
+      if (legacyConfigs.getFetchedConfigs() != null) {
+        fetchedCacheClient.put(legacyConfigs.getFetchedConfigs());
+      }
+      if (legacyConfigs.getActivatedConfigs() != null) {
+        activatedCacheClient.put(legacyConfigs.getActivatedConfigs());
+      }
+      if (legacyConfigs.getDefaultsConfigs() != null) {
+        defaultsCacheClient.put(legacyConfigs.getDefaultsConfigs());
+      }
+    }
+  }
+
+  /**
+   * Reads all legacy configs from disk and converts them into {@link ConfigContainer}s.
+   *
+   * @return A {@link Map} from namespaces to {@link NamespaceLegacyConfigs}, each of which contains
+   *     the activated, fetched and defaults legacy configs for a single namespace.
+   */
+  @WorkerThread
+  private Map<String, NamespaceLegacyConfigs> getConvertedLegacyConfigs() {
+    PersistedConfig allLegacyConfigs = readPersistedConfig();
+
+    Map<String, NamespaceLegacyConfigs> allConfigsMap = new HashMap<>();
+    if (allLegacyConfigs == null) {
+      return allConfigsMap;
+    }
+
+    Map<String, ConfigContainer> activatedConfigsByNamespace =
+        convertConfigHolder(allLegacyConfigs.getActiveConfigHolder());
+    Map<String, ConfigContainer> fetchedConfigsByNamespace =
+        convertConfigHolder(allLegacyConfigs.getFetchedConfigHolder());
+    Map<String, ConfigContainer> defaultsConfigsByNamespace =
+        convertConfigHolder(allLegacyConfigs.getDefaultsConfigHolder());
+
+    Set<String> allNamespaces = new HashSet<>();
+    allNamespaces.addAll(activatedConfigsByNamespace.keySet());
+    allNamespaces.addAll(fetchedConfigsByNamespace.keySet());
+    allNamespaces.addAll(defaultsConfigsByNamespace.keySet());
+
+    for (String namespace : allNamespaces) {
+      NamespaceLegacyConfigs namespaceLegacyConfigs = new NamespaceLegacyConfigs();
+      if (activatedConfigsByNamespace.containsKey(namespace)) {
+        namespaceLegacyConfigs.setActivatedConfigs(activatedConfigsByNamespace.get(namespace));
+      }
+      if (fetchedConfigsByNamespace.containsKey(namespace)) {
+        namespaceLegacyConfigs.setFetchedConfigs(fetchedConfigsByNamespace.get(namespace));
+      }
+      if (defaultsConfigsByNamespace.containsKey(namespace)) {
+        namespaceLegacyConfigs.setDefaultsConfigs(defaultsConfigsByNamespace.get(namespace));
+      }
+      allConfigsMap.put(namespace, namespaceLegacyConfigs);
+    }
+    return allConfigsMap;
+  }
+
+  /** Converts {@link ConfigHolder} into a map from namespaces to their corresponding configs. */
+  private Map<String, ConfigContainer> convertConfigHolder(ConfigHolder allNamespaceLegacyConfigs) {
+    Map<String, ConfigContainer> convertedLegacyConfigs = new HashMap<>();
+
+    Date fetchTime = new Date(allNamespaceLegacyConfigs.getTimestamp());
+    JSONArray abtExperiments =
+        convertLegacyAbtExperiments(allNamespaceLegacyConfigs.getExperimentPayloadList());
+
+    List<NamespaceKeyValue> namespaceLegacyConfigsArray =
+        allNamespaceLegacyConfigs.getNamespaceKeyValueList();
+    for (NamespaceKeyValue namespaceLegacyConfigs : namespaceLegacyConfigsArray) {
+      String namespace = namespaceLegacyConfigs.getNamespace();
+      if (namespace.startsWith(LEGACY_FRC_NAMESPACE_PREFIX)) {
+        namespace = namespace.substring(LEGACY_FRC_NAMESPACE_PREFIX.length());
+      }
+
+      ConfigContainer.Builder configsBuilder =
+          ConfigContainer.newBuilder()
+              .replaceConfigsWith(convertKeyValueList(namespaceLegacyConfigs.getKeyValueList()))
+              .withFetchTime(fetchTime);
+      if (namespace.equals(FRC_3P_NAMESPACE)) {
+        configsBuilder.withAbtExperiments(abtExperiments);
+      }
+
+      try {
+        convertedLegacyConfigs.put(namespace, configsBuilder.build());
+      } catch (JSONException e) {
+        // Skip configs that cannot be parsed.
+        Log.d(TAG, "A set of legacy configs could not be converted.");
+      }
+    }
+    return convertedLegacyConfigs;
+  }
+
+  /**
+   * Deserializes ABT experiment payloads and converts them into a {@link JSONArray} of {@link
+   * JSONObject}s.
+   */
+  private JSONArray convertLegacyAbtExperiments(List<ByteString> legacyExperimentPayloads) {
+    JSONArray abtExperiments = new JSONArray();
+    for (ByteString legacyExperimentPayload : legacyExperimentPayloads) {
+      ExperimentPayload deserializedPayload = deserializePayload(legacyExperimentPayload);
+      if (deserializedPayload != null) {
+        try {
+          abtExperiments.put(convertLegacyAbtExperiment(deserializedPayload));
+        } catch (JSONException e) {
+          // Ignore ABT experiments that cannot be parsed.
+          Log.d(TAG, "A legacy ABT experiment could not be parsed.", e);
+        }
+      }
+    }
+    return abtExperiments;
+  }
+
+  @Nullable
+  private ExperimentPayload deserializePayload(ByteString legacyExperimentPayload) {
+    try {
+      Iterator<Byte> byteIterator = legacyExperimentPayload.iterator();
+      byte[] payloadArray = new byte[legacyExperimentPayload.size()];
+      for (int index = 0; index < payloadArray.length; index++) {
+        payloadArray[index] = byteIterator.next();
+      }
+      return ExperimentPayload.parseFrom(payloadArray);
+    } catch (InvalidProtocolBufferException e) {
+      Log.d(TAG, "Payload was not defined or could not be deserialized.", e);
+      return null;
+    }
+  }
+
+  /** Converts {@link ExperimentPayload} into a {@link JSONObject}. */
+  private JSONObject convertLegacyAbtExperiment(ExperimentPayload deserializedLegacyPayload)
+      throws JSONException {
+    JSONObject abtExperiment = new JSONObject();
+
+    abtExperiment.put(EXPERIMENT_ID_KEY, deserializedLegacyPayload.getExperimentId());
+    abtExperiment.put(EXPERIMENT_VARIANT_ID_KEY, deserializedLegacyPayload.getVariantId());
+    abtExperiment.put(
+        EXPERIMENT_START_TIME_KEY,
+        protoTimestampStringParser
+            .get()
+            .format(new Date(deserializedLegacyPayload.getExperimentStartTimeMillis())));
+    abtExperiment.put(EXPERIMENT_TRIGGER_EVENT_KEY, deserializedLegacyPayload.getTriggerEvent());
+    abtExperiment.put(
+        EXPERIMENT_TRIGGER_TIMEOUT_KEY, deserializedLegacyPayload.getTriggerTimeoutMillis());
+    abtExperiment.put(EXPERIMENT_TIME_TO_LIVE_KEY, deserializedLegacyPayload.getTimeToLiveMillis());
+
+    return abtExperiment;
+  }
+
+  /** Converts a {@link List} of {@link KeyValue}s into a {@link Map} of {@link String} configs. */
+  private Map<String, String> convertKeyValueList(List<KeyValue> legacyConfigs) {
+    Map<String, String> legacyConfigsMap = new HashMap<>();
+    for (KeyValue legacyConfig : legacyConfigs) {
+      legacyConfigsMap.put(
+          legacyConfig.getKey(), legacyConfig.getValue().toString(PROTO_BYTE_ARRAY_ENCODING));
+    }
+    return legacyConfigsMap;
+  }
+
+  /** Reads the legacy configs, converts them into a proto, and returns the result. */
+  @WorkerThread
+  private PersistedConfig readPersistedConfig() {
+    if (context == null) {
+      return null;
+    }
+    PersistedConfig persistedConfig;
+    FileInputStream fileInputStream = null;
+    try {
+      fileInputStream = context.openFileInput(LEGACY_CONFIGS_FILE_NAME);
+      persistedConfig = PersistedConfig.parseFrom(fileInputStream);
+    } catch (FileNotFoundException fileNotFoundException) {
+      Log.d(TAG, "Persisted config file was not found.", fileNotFoundException);
+      return null;
+    } catch (IOException ioException) {
+      Log.d(TAG, "Cannot initialize from persisted config.", ioException);
+      return null;
+    } finally {
+      try {
+        if (fileInputStream != null) {
+          fileInputStream.close();
+        }
+      } catch (IOException ioException) {
+        Log.d(TAG, "Failed to close persisted config file.", ioException);
+      }
+    }
+    return persistedConfig;
+  }
+
+  /**
+   * Gets the cache client for the given {@code namespace} and config storage type (one of {@link
+   * #ACTIVATE_FILE_NAME}, {@link #FETCH_FILE_NAME} or {@link #DEFAULTS_FILE_NAME}).
+   */
+  ConfigCacheClient getCacheClient(String namespace, String configStoreType) {
+    return RemoteConfigComponent.getCacheClient(context, appId, namespace, configStoreType);
+  }
+
+  /** Container for all the configs in a single namespace. */
+  private static class NamespaceLegacyConfigs {
+    private ConfigContainer fetchedConfigs;
+    private ConfigContainer activatedConfigs;
+    private ConfigContainer defaultsConfigs;
+
+    private NamespaceLegacyConfigs() {}
+
+    private void setFetchedConfigs(ConfigContainer fetchedConfigs) {
+      this.fetchedConfigs = fetchedConfigs;
+    }
+
+    private void setActivatedConfigs(ConfigContainer activatedConfigs) {
+      this.activatedConfigs = activatedConfigs;
+    }
+
+    private void setDefaultsConfigs(ConfigContainer defaultsConfigs) {
+      this.defaultsConfigs = defaultsConfigs;
+    }
+
+    private ConfigContainer getFetchedConfigs() {
+      return fetchedConfigs;
+    }
+
+    private ConfigContainer getActivatedConfigs() {
+      return activatedConfigs;
+    }
+
+    private ConfigContainer getDefaultsConfigs() {
+      return defaultsConfigs;
+    }
+  }
+}
diff --git a/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/package-info.java b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/package-info.java
new file mode 100644
index 000000000..e9c77b425
--- /dev/null
+++ b/firebase-config/src/main/java/com/google/firebase/remoteconfig/internal/package-info.java
@@ -0,0 +1,19 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+
+package com.google.firebase.remoteconfig.internal;
+
+
diff --git a/firebase-config/src/proto/com/google/android/gms/config/proto/config.proto b/firebase-config/src/proto/com/google/android/gms/config/proto/config.proto
new file mode 100644
index 000000000..4dc91056f
--- /dev/null
+++ b/firebase-config/src/proto/com/google/android/gms/config/proto/config.proto
@@ -0,0 +1,402 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+syntax = "proto2";
+
+package com.google.android.gms.config.proto;
+
+import "com/google/android/gms/config/proto/config_logs.proto";
+
+option java_package = "com.google.android.gms.config.proto";
+option java_outer_classname = "Config";
+
+// This proto defines the request and response objects of a config fetch from
+// the Config Service backend.
+
+// The model of a config fetch has changed in GmsCore-Tala. We consider the
+// original config fetch model as v1, and the new model in Tala as v2. Fields
+// that were added in v2 and fields that were deprecated in v2 are marked
+// correspondingly.
+
+// The ConfigFetchRequest proto has a client_version field, which will indicate
+// if it is v2. Lack of that field indicates that the request is coming from
+// a v1 client.
+
+message PackageData {
+    ////////////////////
+    // v1 only fields //
+    ////////////////////
+
+    // version code of the app/package. (as it appears in the app manifest with
+    // <version-code> tag) deprecated - v1 only - should be populated
+    // for v1 - android only.
+    optional int32 version_code = 2;
+
+    // deprecated - v1 only - should be populated for v1
+    // digest of the config table on the device. will be used to diff against
+    // the digest at the server, to see if server needs to send an updated table.
+    optional bytes digest = 3;
+
+    // hash of the certificate with which this package was signed.
+    // android only - v1 only - ignored by server
+    optional bytes cert_hash = 4;
+
+    // deprecated - v1 only - server ignores this
+    optional string config_id = 5;
+
+    /////////////////////////
+    // v1&v2 common fields //
+    /////////////////////////
+
+    // name of the package for which the device is fetching config from the
+    // backend.
+    // for v1: this field must be populated, otherwise the server
+    // will reject the request.
+    // for v2:
+    //   this field must be populated for first party clients.
+    //   this field should be populated for third party clients. without that,
+    // client will not be able to get rules based on the package name.
+    // for clients other than android, this should be populated with
+    // corresponding entity, such as bundle name in ios.
+    optional string package_name = 1;
+
+    ////////////////////
+    // v2 only fields //
+    ////////////////////
+
+    // project id retrieved from GMP, if the app is tied to a GMP project id.
+    // v2 only.
+    // should be populated in v2, as without it, client won't be able to get
+    // configuration from the gmp namespace.
+    optional string gmp_project_id = 6;
+
+    // project id retrieved using the games-project-id tag (in android,
+    // from the manifest file), if the app is tied to a games app id.
+    // v2 only.
+    // should be populated in v2 (if the app has it), as without it, the client
+    // won't be able to get configuration from the games namespace.
+    optional string games_project_id = 7;
+
+    // per namespace digests of the local config table of the app, in
+    // the format of: NamedValue(name=namespace, value=digest)
+    // v2 only.
+    // must be populated for v2, as lack of it would cause the server to send
+    // the whole config table back, even when there are no changes.
+    repeated NamedValue namespace_digest = 8;
+
+    // custom variables as defined by the client app.
+    // v2 only.
+    // if not populated, client won't be able to get rules defined using their
+    // custom variables.
+    repeated NamedValue custom_variable = 9;
+
+    // hash of the certificate with which this app/package was signed.
+    // not in use right now, but should still be populated, as in the future, we
+    // will start to use this to authenticate the app.
+    // android only, as we don't have a way to validate ios signatures.
+    optional bytes app_cert_hash = 10;
+
+    // version code of the app
+    // for android, it is the value of the <version-code> tag within
+    // an app's manifest.
+    // must be populated in v2, otherwise the config rules against app versions
+    // will not work.
+    //
+    // This field is now deprecated. New version of the client should not populate
+    // this and populate app_version instead. For backward compatability with
+    // older
+    // clients, if the server doesn't find a value for app_version and finds a
+    // value > 0 here, it will use the decimal of the value here as the
+    // app version (e.g. 123 -> "123").
+    optional int32 app_version_code = 11;
+
+    // App version, using the native app version format on the client's  OS.
+    // The recommended version format is in decimal dot notation
+    // \d{1,6}(\.\d{1,6})*
+    //
+    // Valid examples:
+    //   0, 123, 0123, 1.2.3, 0001.33.043.321.55
+    optional string app_version = 13;
+
+    // The instance id of the app (the client app, not gmscore).
+    optional string app_instance_id = 12;
+
+    // The instance id token of the app, that is retrieved by using
+    // the default scope.
+    optional string app_instance_id_token = 14;
+
+    // Requested hidden namespaces.
+    // This is a list of namespaces that are hidden from the developer.
+    // Configuration in these namespaces are for configuring SDKs.
+    // Regular API methods won't return the values in these namespaces.
+    // When the server receives a fetch request with this field set, it should
+    // only reply for the namespaces in this field.
+    // Example value: "confighns:firebase-system"
+    repeated string requested_hidden_namespace = 15;
+
+    // version of the firebase remote config sdk. constructed by a major version,
+    // a minor version, and a patch version, using the formula:
+    // (major * 10000) + (minor * 100) + patch
+    // must be set by each client.
+    // the major version will indicate the API version, and has to be the same for
+    // both Android and iOS.
+    // the minor version will indicate the feature set. in other words, it needs
+    // to be incremented with each feature we add. must be the same for both
+    // Android and iOS.
+    // the patch version needs to be updated each time we release a change. can
+    // be different between Android and iOS.
+    // these versions will be hardcoded constants in both clients.
+    optional int32 sdk_version = 16;
+
+    // list of all scion (analytics) external properties set on this app. clients
+    // need to report these at each config fetch, so that the server can use user
+    // properties as a targeting condition, enabling more integration with scion.
+    repeated NamedValue analytics_user_property = 17;
+
+    // the cache expiration seconds specified while calling fetch()
+    // in seconds
+    optional int32 requested_cache_expiration_seconds = 18;
+
+    // the age of the fetched config: now() - last time fetch() was called
+    // in seconds
+    // if there was no fetched config, the value will be set to -1
+    optional int32 fetched_config_age_seconds = 19;
+
+    // the age of the active config:
+    // now() - last time activateFetched() was called
+    // in seconds
+    // if there was no active config, the value will be set to -1
+    optional int32 active_config_age_seconds = 20;
+}
+
+// Corresponds to each entry in a config table. common for v1 & v2.
+message KeyValue {
+    optional string key = 1;
+    optional bytes value = 2;
+}
+
+/////////////////
+// added in v2 //
+/////////////////
+message NamedValue {
+    optional string name = 1;
+    optional string value = 2;
+}
+
+// represents a config fetch request from a single device for the config(s) of
+// one or more apps.
+// in v2, the fetch request is only for a single app.
+// in v1, the fetch request can be batched for multiple apps.
+message ConfigFetchRequest {
+    ////////////////////
+    // v1-only fields //
+    ////////////////////
+
+    // from logs proto, tracking fetch reason.
+    // v1 only - android only
+    optional AndroidConfigFetchProto config = 5;
+
+    /////////////////////////
+    // v1&v2 common fields //
+    /////////////////////////
+
+    // android_id of the device.
+    // must be populated in v1: for v1 requests, server fetches all data from
+    // checkin, so the fetch operation won't work at all without an android id.
+    // for v2, this field is only necessary if any of the rules for this package
+    // needs checkin data. (for instance, first party clients using the extended
+    // atoms within the perforce namespace).
+    // if populated, security_token field should also be populated, as the server
+    // will authenticate the android_id if it needs to access Kansas data.
+    optional fixed64 android_id = 1;
+
+    // holds package specific information. for v1, it can be a repeated set of
+    // packages.
+    // in v2, there will only be a single entry, as we only do individual fetches
+    // per package.
+    // must be populated in both v1 and v2.
+    repeated PackageData package_data = 2;
+
+    // corresponds to the Kansas version info for the android checkin columns,
+    // which can be used by
+    // the server to retrieve the most up-to-date data from Kansas.
+    // not needed for third party clients.
+    // for first party clients (which might have rules depending on checkin data),
+    // this should be populated for both v1 and v2, if possible. without it, the
+    // server is subject to reading stale checkin data from Kansas.
+    optional string device_data_version_info = 3;
+
+    // password of the android id.
+    // for v1, this field must be populated.
+    // for v2, if the android_id field is populated, this needs to be populated
+    // as well, as the server will authenticate the android id if it needs to
+    // access Kansas data.
+    optional fixed64 security_token = 4;
+
+    ////////////////////
+    // v2-only fields //
+    ////////////////////
+
+    // version of the config fetch client on the device. must be populated in v2.
+    optional int32 client_version = 6;  // 1 is GmsCore-Orla, 2 is GmsCore-Tala
+
+    // version of the Google Play Services on the device.
+    // must be populated in v2, android only.
+    optional int32 gms_core_version = 7;
+
+    // API level of the device (for android, 19, 20, 21, etc.).
+    // must be populated in v2.
+    // android only for now. ios (or others) can either reuse this field, or add
+    // another.
+    optional int32 api_level = 8;
+
+    // the country which this device resides in, according to checkin.
+    // all country codes should be 2 lowercase letters, such as us, tr, or gb.
+    // must be populated in v2.
+    optional string device_country = 9;
+
+    // the default locale of the device.
+    // format is 'en_US'.
+    // must be populated in v2, otherwise rules written against locale or locale
+    // language will not work.
+    optional string device_locale = 10;
+
+    // indicates the type of the device, such as android, ios, chromeos, etc.
+    // must be populated in v2
+    optional int32 device_type = 11;
+
+    // indicates the device subtype, such as phone, tablet, wearable, etc.
+    // must be populated in v2
+    optional int32 device_subtype = 12;
+
+    // The version string of the device.
+    // Android devices will have a version corresponding to the bandwagoner version
+    // code. For example "21" for Lollipop.
+    // iOS devices will have a string version containing three non-negative,
+    // period seperated integers. eg. "9.0.0". See CFBundleVersion for more info.
+    optional string os_version = 13;
+
+    // The timezone id of the device in Olson Id format.
+    // Example "America/Los_Angeles"
+    // Android => getID: Returns the ID of this TimeZone, such as
+    // America/Los_Angeles, GMT-08:00 or UTC.
+    optional string device_timezone_id = 14;
+}
+
+// Holds the configuration data withing the v1 server response.
+message PackageTable {
+    // android only - the name of the package to which the configuration belongs
+    // to. must be filled in, so that the client can identify the owner package.
+    optional string package_name = 1;
+
+    // holds configuration key-value pairs, belonging to the app with the
+    // specified package name.
+    repeated KeyValue entry = 2;
+
+    // ignored by the server - unused
+    optional string config_id = 3;
+}
+
+//////////////////
+// Added in V2. //
+//////////////////
+// Holds configuration data belonging to a single namespace of an app.
+message AppNamespaceConfigTable {
+    // namespace is the source of the configuration included in this message.
+    // can be "configns:gmp", "configns:games", or "configns:p4".
+    // must be populated.
+    optional string namespace = 1;
+
+    // server computed digest of the config entries.
+    // will be stored by the client to be included in future requests, so that
+    // the server can tell if there are any changes and the device needs an
+    // update.
+    optional string digest = 2;
+
+    // holds configuration key value pairs. each entry is a pair within a
+    // package-namespace realm.
+    repeated KeyValue entry = 3;
+
+    enum NamespaceStatus {
+        UPDATE = 0;
+        NO_TEMPLATE = 1;
+        NO_CHANGE = 2;
+        EMPTY_CONFIG = 3;
+        NOT_AUTHORIZED = 4;
+    }
+
+    // holds the status for the namespace, which tells the client how the
+    // response should be handled.
+    optional NamespaceStatus status = 4;
+}
+
+//////////////////
+// Added in V2. //
+//////////////////
+// Holds configuration data within the v2 server response.
+message AppConfigTable {
+    // in android, app name is the package name of the app.
+    // for ios, it is the bundle name.
+    // must be populated, so that the client can identify which package the
+    // included config belongs to.
+    optional string app_name = 1;
+
+    // holds per namespace configuration for this app. if the app has
+    // configuration coming from multiple sources, then there will be more than
+    // one entry in this field.
+    // if the app has no configuration defined, then this field will be empty.
+    repeated AppNamespaceConfigTable namespace_config = 2;
+
+    // each experiment payload represents a single experiment and its variant,
+    // along with metadata specific to this experiment. this field holds the
+    // serialized bytes of an experiment payload proto object.
+    // the experiment payload can be found at:
+    // developers/mobile/abt/proto/experiment_payload.proto
+    repeated bytes experiment_payload = 3;
+}
+
+// represents the response of the config backend server to the device's config
+// fetch request.
+message ConfigFetchResponse {
+    /////////////////////////////
+    // v1-only response fields //
+    /////////////////////////////
+
+    // holds the config table of the package, as a separate PackageTable per
+    // config key-value pair in a namespace.
+    repeated PackageTable package_table = 1;
+
+    /////////////////////////////
+    // v2-only response fields //
+    /////////////////////////////
+
+    enum ResponseStatus {
+        SUCCESS = 0;
+        NO_PACKAGES_IN_REQUEST = 1;
+    }
+
+    // indicates the server's response status
+    optional ResponseStatus status = 2;
+
+    // holds information that is sent by the server, but won't be visible to
+    // the client. will be used to configure connection timeouts, or throttling
+    // parameters from the server.
+    // added in v2.
+    repeated KeyValue internal_metadata = 3;
+
+    // holds all configuration data to be sent to the fetching device.
+    // in v2, there should only be one entry. however, the field is marked as
+    // repeated, in case we handle more than one package within the same
+    // request-response in the future.
+    repeated AppConfigTable app_config = 4;
+}
\ No newline at end of file
diff --git a/firebase-config/src/proto/com/google/android/gms/config/proto/config_logs.proto b/firebase-config/src/proto/com/google/android/gms/config/proto/config_logs.proto
new file mode 100644
index 000000000..8c704a217
--- /dev/null
+++ b/firebase-config/src/proto/com/google/android/gms/config/proto/config_logs.proto
@@ -0,0 +1,40 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto2";
+
+package com.google.android.gms.config.proto;
+
+option java_package = "com.google.android.gms.config.proto";
+option java_outer_classname = "Logs";
+
+message ConfigFetchReason {
+    enum AndroidConfigFetchType {
+        UNKNOWN = 0;
+        SCHEDULED = 1;
+        BOOT_COMPLETED = 2;
+        PACKAGE_ADDED = 3;
+        PACKAGE_REMOVED = 4;
+        GMS_CORE_UPDATED = 5;
+        SECRET_CODE = 6;
+    }
+
+    optional AndroidConfigFetchType type = 1;
+}
+
+// Information sent by the device in a ConfigFetch request.
+message AndroidConfigFetchProto {
+    // The reason why this ConfigFetch is triggered.
+    optional ConfigFetchReason reason = 1;
+}
\ No newline at end of file
diff --git a/firebase-config/src/proto/com/google/android/gms/config/proto/config_persistence.proto b/firebase-config/src/proto/com/google/android/gms/config/proto/config_persistence.proto
new file mode 100644
index 000000000..d5dfd91c6
--- /dev/null
+++ b/firebase-config/src/proto/com/google/android/gms/config/proto/config_persistence.proto
@@ -0,0 +1,55 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+syntax = "proto2";
+
+package com.google.firebase.remoteconfig.proto;
+
+option java_package = "com.google.firebase.remoteconfig.proto";
+option java_outer_classname = "ConfigPersistence";
+
+message PersistedConfig {
+    optional ConfigHolder fetched_config_holder = 1;
+    optional ConfigHolder active_config_holder = 2;
+    optional ConfigHolder defaults_config_holder = 3;
+    optional Metadata metadata = 4;
+    repeated Resource applied_resource = 5;
+}
+
+message KeyValue {
+    optional string key = 1;
+    optional bytes value = 2;
+}
+
+message NamespaceKeyValue {
+    optional string namespace = 1;
+    repeated KeyValue key_value = 2;
+}
+
+message ConfigHolder {
+    repeated NamespaceKeyValue namespace_key_value = 1;
+    optional fixed64 timestamp = 2;
+    repeated bytes experiment_payload = 3;
+}
+
+message Metadata {
+    optional int32 last_fetch_status = 1;
+    optional bool developer_mode_enabled = 2;
+    optional fixed64 last_known_experiment_start_time = 3;
+}
+
+message Resource {
+    optional int32 resource_id = 1;
+    optional fixed64 app_update_time = 2;
+    optional string namespace = 3;
+}
\ No newline at end of file
diff --git a/test-apps/storage-test-app/src/main/AndroidManifest.xml b/firebase-config/src/test/AndroidManifest.xml
similarity index 60%
rename from test-apps/storage-test-app/src/main/AndroidManifest.xml
rename to firebase-config/src/test/AndroidManifest.xml
index 7d312565d..c9e66890a 100644
--- a/test-apps/storage-test-app/src/main/AndroidManifest.xml
+++ b/firebase-config/src/test/AndroidManifest.xml
@@ -4,8 +4,8 @@
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
   ~
+  ~ You may obtain a copy of the License at
   ~      http://www.apache.org/licenses/LICENSE-2.0
   ~
   ~ Unless required by applicable law or agreed to in writing, software
@@ -16,16 +16,19 @@
   -->
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.google.firebase.testapps.storage">
-    <application
-        android:allowBackup="true"
-        android:name="android.support.multidex.MultiDexApplication">
-        <activity
-            android:name=".TestActivity">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.google.firebase.remoteconfig"
+    android:versionCode="1"
+    android:versionName="1">
+
+
+  <!--<uses-sdk android:minSdkVersion="16"/>-->
+
+  <application android:label="FirebaseCommonTests" >
+    <uses-library android:name="android.test.runner" />
+    <service android:name="com.google.firebase.components.ComponentDiscoveryService">
+
+    </service>
+  </application>
+
 </manifest>
diff --git a/firebase-config/src/test/java/com/google/android/gms/common/util/MockClock.java b/firebase-config/src/test/java/com/google/android/gms/common/util/MockClock.java
new file mode 100644
index 000000000..eb4423d06
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/android/gms/common/util/MockClock.java
@@ -0,0 +1,73 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.gms.common.util;
+
+import android.os.SystemClock;
+import com.google.android.gms.common.internal.Preconditions;
+
+/**
+ * Simple clock implementation that returns a controllable time value.
+ *
+ * @author tomwilson@google.com (Tom Wilson)
+ */
+public class MockClock implements Clock {
+  private long mCurrentTimeMs;
+  private long mCurrentElapsedRealtime;
+  private long mNanoTime;
+
+  public MockClock(long currentTimeMs) {
+    setCurrentTime(currentTimeMs);
+  }
+
+  @Override
+  public long currentTimeMillis() {
+    return mCurrentTimeMs;
+  }
+
+  public void setCurrentTime(long currentTimeMs) {
+    Preconditions.checkState(currentTimeMs >= 0);
+    mCurrentTimeMs = currentTimeMs;
+  }
+
+  @Override
+  public long elapsedRealtime() {
+    return mCurrentElapsedRealtime;
+  }
+
+  public void setElapsedRealtime(long timeInMillis) {
+    mCurrentElapsedRealtime = timeInMillis;
+  }
+
+  public void advance(long incrementMillis) {
+    setCurrentTime(currentTimeMillis() + incrementMillis);
+    setElapsedRealtime(elapsedRealtime() + incrementMillis);
+  }
+
+  @Override
+  public long nanoTime() {
+    return mNanoTime;
+  }
+
+  public void setNanoTime(long nanoTime) {
+    Preconditions.checkState(nanoTime >= 0);
+    mNanoTime = nanoTime;
+  }
+
+  @SuppressWarnings("StaticOrDefaultInterfaceMethod")
+  @Override
+  public long currentThreadTimeMillis() {
+    return SystemClock.currentThreadTimeMillis();
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/android/gms/shadows/common/internal/ShadowPreconditions.java b/firebase-config/src/test/java/com/google/android/gms/shadows/common/internal/ShadowPreconditions.java
new file mode 100644
index 000000000..0c8695bc7
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/android/gms/shadows/common/internal/ShadowPreconditions.java
@@ -0,0 +1,47 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.gms.shadows.common.internal;
+
+import android.os.Handler;
+import com.google.android.gms.common.internal.Preconditions;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+
+/**
+ * Shadow for {@link Preconditions} that disables threading checks. Since Robolectric fakes various
+ * threading constructs, these would otherwise cause tests to fail.
+ */
+@Implements(Preconditions.class)
+public class ShadowPreconditions {
+  @Implementation
+  public static void checkNotMainThread() {
+    // Do nothing
+  }
+
+  @Implementation
+  public static void checkNotMainThread(String errorMessage) {
+    // Do nothing
+  }
+
+  @Implementation
+  public static void checkHandlerThread(Handler handler) {
+    // Do nothing
+  }
+
+  @Implementation
+  public static void checkHandlerThread(Handler handler, String errorMessage) {
+    // Do nothing
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/AbtExperimentHelper.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/AbtExperimentHelper.java
new file mode 100644
index 000000000..ebad34187
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/AbtExperimentHelper.java
@@ -0,0 +1,57 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.EXPERIMENT_ID_KEY;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.EXPERIMENT_START_TIME_KEY;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.EXPERIMENT_TIME_TO_LIVE_KEY;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.EXPERIMENT_TRIGGER_EVENT_KEY;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.EXPERIMENT_TRIGGER_TIMEOUT_KEY;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.EXPERIMENT_VARIANT_ID_KEY;
+
+import java.sql.Date;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Set of utility methods for dealing with Firebase A/B Testing (ABT) experiments in tests.
+ *
+ * @author Miraziz Yusupov
+ */
+public class AbtExperimentHelper {
+  /**
+   * Returns a {@link JSONArray} containing a list of {@link JSONObject}s representing ABT
+   * experiments.
+   */
+  static JSONArray createAbtExperiments(JSONObject... abtExperiments) throws JSONException {
+    return new JSONArray(abtExperiments);
+  }
+
+  /**
+   * Returns a {@link JSONObject} representing an ABT Experiment with the given experiment id and
+   * variant id.
+   */
+  static JSONObject createAbtExperiment(String experimentId) throws JSONException {
+    JSONObject abtExperiment = new JSONObject();
+    abtExperiment.put(EXPERIMENT_ID_KEY, experimentId);
+    abtExperiment.put(EXPERIMENT_VARIANT_ID_KEY, "var1");
+    abtExperiment.put(EXPERIMENT_START_TIME_KEY, new Date(1L));
+    abtExperiment.put(EXPERIMENT_TRIGGER_EVENT_KEY, "trigger event");
+    abtExperiment.put(EXPERIMENT_TRIGGER_TIMEOUT_KEY, 5000L);
+    abtExperiment.put(EXPERIMENT_TIME_TO_LIVE_KEY, 10000L);
+    return abtExperiment;
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigSettingsTest.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigSettingsTest.java
new file mode 100644
index 000000000..f6bb21993
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigSettingsTest.java
@@ -0,0 +1,41 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Unit tests for FRC settings.
+ *
+ * @author Lucas Png
+ */
+@RunWith(JUnit4.class)
+public final class FirebaseRemoteConfigSettingsTest {
+  @Test
+  public void toBuilder_withFieldsSet_buildsObjectWithFieldsSet() {
+    FirebaseRemoteConfigSettings.Builder expectedBuilder =
+        new FirebaseRemoteConfigSettings.Builder().setDeveloperModeEnabled(true);
+    FirebaseRemoteConfigSettings settings = expectedBuilder.build();
+
+    FirebaseRemoteConfigSettings.Builder actualBuilder = settings.toBuilder();
+
+    assertThat(actualBuilder.build().isDeveloperModeEnabled())
+        .isEqualTo(settings.isDeveloperModeEnabled());
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigTest.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigTest.java
new file mode 100644
index 000000000..714b8b4b8
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/FirebaseRemoteConfigTest.java
@@ -0,0 +1,1195 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+import static com.google.firebase.remoteconfig.AbtExperimentHelper.createAbtExperiment;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_BOOLEAN;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_BYTE_ARRAY;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_DOUBLE;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_LONG;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_STRING;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.LAST_FETCH_STATUS_THROTTLED;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.toExperimentInfoMaps;
+import static com.google.firebase.remoteconfig.internal.ConfigGetParameterHandler.FRC_BYTE_ARRAY_ENCODING;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.content.res.Resources;
+import com.google.android.gms.shadows.common.internal.ShadowPreconditions;
+import com.google.android.gms.tasks.Task;
+import com.google.android.gms.tasks.TaskCompletionSource;
+import com.google.android.gms.tasks.Tasks;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.FirebaseOptions;
+import com.google.firebase.abt.AbtException;
+import com.google.firebase.abt.FirebaseABTesting;
+import com.google.firebase.remoteconfig.internal.ConfigCacheClient;
+import com.google.firebase.remoteconfig.internal.ConfigContainer;
+import com.google.firebase.remoteconfig.internal.ConfigFetchHandler;
+import com.google.firebase.remoteconfig.internal.ConfigFetchHandler.FetchResponse;
+import com.google.firebase.remoteconfig.internal.ConfigGetParameterHandler;
+import com.google.firebase.remoteconfig.internal.ConfigMetadataClient;
+import java.io.IOException;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.Executor;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.skyscreamer.jsonassert.JSONAssert;
+
+/**
+ * Unit tests for the Firebase Remote Config API.
+ *
+ * @author Miraziz Yusupov
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(
+    manifest = Config.NONE,
+    shadows = {ShadowPreconditions.class})
+public final class FirebaseRemoteConfigTest {
+  private static final String APP_ID = "1:14368190084:android:09cb977358c6f241";
+  private static final String API_KEY = "api_key";
+
+  private static final String FIREPERF_NAMESPACE = "fireperf";
+
+  private static final String STRING_KEY = "string_key";
+  private static final String BOOLEAN_KEY = "boolean_key";
+  private static final String BYTE_ARRAY_KEY = "byte_array_key";
+  private static final String DOUBLE_KEY = "double_key";
+  private static final String LONG_KEY = "long_key";
+
+  private static final String ETAG = "ETag";
+
+  // We use a HashMap so that Mocking is easier.
+  private static final HashMap<String, String> DEFAULTS_MAP = new HashMap<>();
+
+  @Mock private ConfigCacheClient mockFetchedCache;
+  @Mock private ConfigCacheClient mockActivatedCache;
+  @Mock private ConfigCacheClient mockDefaultsCache;
+  @Mock private ConfigFetchHandler mockFetchHandler;
+  @Mock private ConfigGetParameterHandler mockGetHandler;
+  @Mock private ConfigMetadataClient metadataClient;
+
+  @Mock private ConfigCacheClient mockFireperfFetchedCache;
+  @Mock private ConfigCacheClient mockFireperfActivatedCache;
+  @Mock private ConfigCacheClient mockFireperfDefaultsCache;
+  @Mock private ConfigFetchHandler mockFireperfFetchHandler;
+  @Mock private ConfigGetParameterHandler mockFireperfGetHandler;
+
+  @Mock private FirebaseRemoteConfigInfo mockFrcInfo;
+
+  @Mock private FirebaseABTesting mockFirebaseAbt;
+
+  private FirebaseRemoteConfig frc;
+  private FirebaseRemoteConfig fireperfFrc;
+  private ConfigContainer firstFetchedContainer;
+  private ConfigContainer secondFetchedContainer;
+
+  private FetchResponse firstFetchedContainerResponse;
+
+  @Before
+  public void setUp() throws Exception {
+    DEFAULTS_MAP.put("first_default_key", "first_default_value");
+    DEFAULTS_MAP.put("second_default_key", "second_default_value");
+    DEFAULTS_MAP.put("third_default_key", "third_default_value");
+
+    MockitoAnnotations.initMocks(this);
+
+    Executor directExecutor = MoreExecutors.directExecutor();
+    Context context = RuntimeEnvironment.application;
+    FirebaseApp firebaseApp = initializeFirebaseApp(context);
+
+    // Catch all to avoid NPEs (the getters should never return null).
+    when(mockFetchedCache.get()).thenReturn(Tasks.forResult(null));
+    when(mockActivatedCache.get()).thenReturn(Tasks.forResult(null));
+    when(mockFireperfFetchedCache.get()).thenReturn(Tasks.forResult(null));
+    when(mockFireperfActivatedCache.get()).thenReturn(Tasks.forResult(null));
+
+    frc =
+        new FirebaseRemoteConfig(
+            context,
+            firebaseApp,
+            mockFirebaseAbt,
+            directExecutor,
+            mockFetchedCache,
+            mockActivatedCache,
+            mockDefaultsCache,
+            mockFetchHandler,
+            mockGetHandler,
+            metadataClient);
+
+    // Set up an FRC instance for the Fireperf namespace that uses mocked clients.
+    fireperfFrc =
+        FirebaseApp.getInstance()
+            .get(RemoteConfigComponent.class)
+            .get(
+                firebaseApp,
+                FIREPERF_NAMESPACE,
+                /*firebaseAbt=*/ null,
+                directExecutor,
+                mockFireperfFetchedCache,
+                mockFireperfActivatedCache,
+                mockFireperfDefaultsCache,
+                mockFireperfFetchHandler,
+                mockFireperfGetHandler,
+                RemoteConfigComponent.getMetadataClient(context, APP_ID, FIREPERF_NAMESPACE));
+
+    firstFetchedContainer =
+        ConfigContainer.newBuilder()
+            .replaceConfigsWith(ImmutableMap.of("long_param", "1L", "string_param", "string_value"))
+            .withFetchTime(new Date(1000L))
+            .build();
+
+    secondFetchedContainer =
+        ConfigContainer.newBuilder()
+            .replaceConfigsWith(
+                ImmutableMap.of("string_param", "string_value", "double_param", "0.1"))
+            .withFetchTime(new Date(5000L))
+            .build();
+
+    firstFetchedContainerResponse =
+        FetchResponse.forBackendUpdatesFetched(firstFetchedContainer, ETAG);
+  }
+
+  @Test
+  public void ensureInitialized_notInitialized_isNotComplete() {
+    loadCacheWithConfig(mockFetchedCache, /*container=*/ null);
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+    loadActivatedCacheWithIncompleteTask();
+
+    Task<FirebaseRemoteConfigInfo> initStatus = frc.ensureInitialized();
+
+    assertWithMessage("FRC is initialized even though activated configs have not loaded!")
+        .that(initStatus.isComplete())
+        .isFalse();
+  }
+
+  @Test
+  public void ensureInitialized_initialized_returnsCorrectFrcInfo() {
+    loadCacheWithConfig(mockFetchedCache, /*container=*/ null);
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+
+    Task<FirebaseRemoteConfigInfo> initStatus = frc.ensureInitialized();
+
+    assertWithMessage("FRC is not initialized even though everything is loaded!")
+        .that(initStatus.isComplete())
+        .isTrue();
+  }
+
+  @Test
+  public void fetchAndActivate_hasNetworkError_taskReturnsException() {
+    when(mockFetchHandler.fetch())
+        .thenReturn(Tasks.forException(new IOException("Network call failed.")));
+
+    Task<Boolean> task = frc.fetchAndActivate();
+
+    assertThat(task.isComplete()).isTrue();
+    assertWithMessage("Fetch succeeded even though there's a network error!")
+        .that(task.getException())
+        .isNotNull();
+  }
+
+  @Test
+  public void fetchAndActivate_getFetchedFailed_returnsFalse() {
+    loadFetchHandlerWithResponse();
+    loadCacheWithIoException(mockFetchedCache);
+    loadCacheWithConfig(mockActivatedCache, null);
+
+    Task<Boolean> task = frc.fetchAndActivate();
+
+    assertWithMessage("fetchAndActivate() succeeded with no fetched values!")
+        .that(getTaskResult(task))
+        .isFalse();
+
+    verify(mockActivatedCache, never()).put(any());
+    verify(mockFetchedCache, never()).clear();
+  }
+
+  @Test
+  public void fetchAndActivate_noFetchedConfigs_returnsFalse() {
+    loadFetchHandlerWithResponse();
+    loadCacheWithConfig(mockFetchedCache, null);
+    loadCacheWithConfig(mockActivatedCache, null);
+
+    Task<Boolean> task = frc.fetchAndActivate();
+
+    assertWithMessage("fetchAndActivate() succeeded with no fetched values!")
+        .that(getTaskResult(task))
+        .isFalse();
+
+    verify(mockActivatedCache, never()).put(any());
+    verify(mockFetchedCache, never()).clear();
+  }
+
+  @Test
+  public void fetchAndActivate_staleFetchedConfigs_returnsFalse() {
+    loadFetchHandlerWithResponse();
+    loadCacheWithConfig(mockFetchedCache, firstFetchedContainer);
+    loadCacheWithConfig(mockActivatedCache, firstFetchedContainer);
+
+    Task<Boolean> task = frc.fetchAndActivate();
+
+    assertWithMessage("fetchAndActivate() succeeded with stale values!")
+        .that(getTaskResult(task))
+        .isFalse();
+
+    verify(mockActivatedCache, never()).put(any());
+    verify(mockFetchedCache, never()).clear();
+  }
+
+  @Test
+  public void fetchAndActivate_noActivatedConfigs_activatesAndClearsFetched() {
+    loadFetchHandlerWithResponse();
+    loadCacheWithConfig(mockFetchedCache, firstFetchedContainer);
+    loadCacheWithConfig(mockActivatedCache, null);
+
+    cachePutReturnsConfig(mockActivatedCache, firstFetchedContainer);
+
+    Task<Boolean> task = frc.fetchAndActivate();
+
+    assertWithMessage("fetchAndActivate() failed with no activated values!")
+        .that(getTaskResult(task))
+        .isTrue();
+
+    verify(mockActivatedCache).put(firstFetchedContainer);
+    verify(mockFetchedCache).clear();
+  }
+
+  @Test
+  public void fetchAndActivate_getActivatedFailed_activatesAndClearsFetched() {
+    loadFetchHandlerWithResponse();
+    loadCacheWithConfig(mockFetchedCache, firstFetchedContainer);
+    loadCacheWithIoException(mockActivatedCache);
+
+    cachePutReturnsConfig(mockActivatedCache, firstFetchedContainer);
+
+    Task<Boolean> task = frc.fetchAndActivate();
+
+    assertWithMessage("fetchAndActivate() failed with no activated values!")
+        .that(getTaskResult(task))
+        .isTrue();
+
+    verify(mockActivatedCache).put(firstFetchedContainer);
+    verify(mockFetchedCache).clear();
+  }
+
+  @Test
+  public void fetchAndActivate_freshFetchedConfigs_activatesAndClearsFetched() {
+    loadFetchHandlerWithResponse();
+    loadCacheWithConfig(mockFetchedCache, secondFetchedContainer);
+    loadCacheWithConfig(mockActivatedCache, firstFetchedContainer);
+
+    cachePutReturnsConfig(mockActivatedCache, secondFetchedContainer);
+
+    Task<Boolean> task = frc.fetchAndActivate();
+
+    assertWithMessage("fetchAndActivate() failed!").that(getTaskResult(task)).isTrue();
+
+    verify(mockActivatedCache).put(secondFetchedContainer);
+    verify(mockFetchedCache).clear();
+  }
+
+  @Test
+  public void fetchAndActivate_fileWriteFails_doesNotClearFetchedAndReturnsFalse() {
+    loadFetchHandlerWithResponse();
+    loadCacheWithConfig(mockFetchedCache, secondFetchedContainer);
+    loadCacheWithConfig(mockActivatedCache, firstFetchedContainer);
+
+    when(mockActivatedCache.put(secondFetchedContainer))
+        .thenReturn(Tasks.forException(new IOException("Should have handled disk error.")));
+
+    Task<Boolean> task = frc.fetchAndActivate();
+
+    assertWithMessage("fetchAndActivate() succeeded even though file write failed!")
+        .that(getTaskResult(task))
+        .isFalse();
+
+    verify(mockActivatedCache).put(secondFetchedContainer);
+    verify(mockFetchedCache, never()).clear();
+  }
+
+  @Test
+  public void fetchAndActivate_hasNoAbtExperiments_sendsEmptyListToAbt() throws Exception {
+    loadFetchHandlerWithResponse();
+    ConfigContainer containerWithNoAbtExperiments =
+        ConfigContainer.newBuilder().withFetchTime(new Date(1000L)).build();
+
+    loadCacheWithConfig(mockFetchedCache, containerWithNoAbtExperiments);
+    cachePutReturnsConfig(mockActivatedCache, containerWithNoAbtExperiments);
+
+    Task<Boolean> task = frc.fetchAndActivate();
+
+    assertWithMessage("fetchAndActivate() failed!").that(getTaskResult(task)).isTrue();
+
+    verify(mockFirebaseAbt).replaceAllExperiments(ImmutableList.of());
+  }
+
+  @Test
+  public void fetchAndActivate_callToAbtFails_activateStillSucceeds() throws Exception {
+    loadFetchHandlerWithResponse();
+    ConfigContainer containerWithAbtExperiments =
+        ConfigContainer.newBuilder(firstFetchedContainer)
+            .withAbtExperiments(generateAbtExperiments())
+            .build();
+
+    loadCacheWithConfig(mockFetchedCache, containerWithAbtExperiments);
+    cachePutReturnsConfig(mockActivatedCache, containerWithAbtExperiments);
+
+    doThrow(new AbtException("Abt failure!")).when(mockFirebaseAbt).replaceAllExperiments(any());
+
+    Task<Boolean> task = frc.fetchAndActivate();
+
+    assertWithMessage("fetchAndActivate() failed!").that(getTaskResult(task)).isTrue();
+  }
+
+  @Test
+  public void fetchAndActivate_hasAbtExperiments_sendsExperimentsToAbt() throws Exception {
+    loadFetchHandlerWithResponse();
+    ConfigContainer containerWithAbtExperiments =
+        ConfigContainer.newBuilder(firstFetchedContainer)
+            .withAbtExperiments(generateAbtExperiments())
+            .build();
+
+    loadCacheWithConfig(mockFetchedCache, containerWithAbtExperiments);
+    cachePutReturnsConfig(mockActivatedCache, containerWithAbtExperiments);
+
+    Task<Boolean> task = frc.fetchAndActivate();
+
+    assertWithMessage("fetchAndActivate() failed!").that(getTaskResult(task)).isTrue();
+
+    List<Map<String, String>> expectedExperimentInfoMaps =
+        toExperimentInfoMaps(containerWithAbtExperiments.getAbtExperiments());
+    verify(mockFirebaseAbt).replaceAllExperiments(expectedExperimentInfoMaps);
+  }
+
+  @Test
+  public void fetchAndActivate2p_hasNoAbtExperiments_doesNotCallAbt() throws Exception {
+    load2pFetchHandlerWithResponse();
+    ConfigContainer containerWithNoAbtExperiments =
+        ConfigContainer.newBuilder().withFetchTime(new Date(1000L)).build();
+
+    loadCacheWithConfig(mockFireperfFetchedCache, containerWithNoAbtExperiments);
+    cachePutReturnsConfig(mockFireperfActivatedCache, containerWithNoAbtExperiments);
+
+    Task<Boolean> task = fireperfFrc.fetchAndActivate();
+
+    assertWithMessage("2p fetchAndActivate() failed!").that(getTaskResult(task)).isTrue();
+
+    verify(mockFirebaseAbt, never()).replaceAllExperiments(any());
+  }
+
+  @Test
+  public void fetchAndActivate2p_hasAbtExperiments_doesNotCallAbt() throws Exception {
+    load2pFetchHandlerWithResponse();
+    ConfigContainer containerWithAbtExperiments =
+        ConfigContainer.newBuilder(firstFetchedContainer)
+            .withAbtExperiments(generateAbtExperiments())
+            .build();
+
+    loadCacheWithConfig(mockFireperfFetchedCache, containerWithAbtExperiments);
+    cachePutReturnsConfig(mockFireperfActivatedCache, containerWithAbtExperiments);
+
+    Task<Boolean> task = fireperfFrc.fetchAndActivate();
+
+    assertWithMessage("2p fetchAndActivate() failed!").that(getTaskResult(task)).isTrue();
+
+    verify(mockFirebaseAbt, never()).replaceAllExperiments(any());
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void activateFetched_noFetchedConfigs_returnsFalse() {
+    loadCacheWithConfig(mockFetchedCache, /*container=*/ null);
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+
+    assertWithMessage("activateFetched() succeeded with no fetched values!")
+        .that(frc.activateFetched())
+        .isFalse();
+
+    verify(mockActivatedCache, never()).put(any());
+    verify(mockFetchedCache, never()).clear();
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void activateFetched_staleFetchedConfigs_returnsFalse() {
+    loadCacheWithConfig(mockFetchedCache, firstFetchedContainer);
+    loadCacheWithConfig(mockActivatedCache, firstFetchedContainer);
+
+    assertWithMessage("activateFetched() succeeded with stale fetched values!")
+        .that(frc.activateFetched())
+        .isFalse();
+
+    verify(mockActivatedCache, never()).put(any());
+    verify(mockFetchedCache, never()).clear();
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void activateFetched_freshFetchedConfigs_activatesAndClearsFetched() {
+    loadCacheWithConfig(mockFetchedCache, secondFetchedContainer);
+    loadCacheWithConfig(mockActivatedCache, firstFetchedContainer);
+    // When the fetched values are activated, they should be put into the activated cache.
+    when(mockActivatedCache.putWithoutWaitingForDiskWrite(secondFetchedContainer))
+        .thenReturn(Tasks.forResult(secondFetchedContainer));
+
+    assertWithMessage("activateFetched() failed!").that(frc.activateFetched()).isTrue();
+
+    verify(mockActivatedCache).putWithoutWaitingForDiskWrite(secondFetchedContainer);
+    verify(mockFetchedCache).clear();
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void activateFetched_fileWriteFails_doesNotClearFetchedAndReturnsTrue() {
+    loadCacheWithConfig(mockFetchedCache, secondFetchedContainer);
+    loadCacheWithConfig(mockActivatedCache, firstFetchedContainer);
+    when(mockActivatedCache.putWithoutWaitingForDiskWrite(secondFetchedContainer))
+        .thenReturn(Tasks.forException(new IOException("Should have handled disk error.")));
+
+    assertWithMessage("activateFetched() failed!").that(frc.activateFetched()).isTrue();
+
+    verify(mockActivatedCache).putWithoutWaitingForDiskWrite(secondFetchedContainer);
+    verify(mockFetchedCache, never()).clear();
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void activateFetched_hasNoAbtExperiments_sendsEmptyListToAbt() throws Exception {
+    ConfigContainer containerWithNoAbtExperiments =
+        ConfigContainer.newBuilder().withFetchTime(new Date(1000L)).build();
+    loadCacheWithConfig(mockFetchedCache, containerWithNoAbtExperiments);
+
+    // When the fetched values are activated, they should be put into the activated cache.
+    when(mockActivatedCache.putWithoutWaitingForDiskWrite(containerWithNoAbtExperiments))
+        .thenReturn(Tasks.forResult(containerWithNoAbtExperiments));
+
+    assertWithMessage("activateFetched() failed!").that(frc.activateFetched()).isTrue();
+
+    verify(mockFirebaseAbt).replaceAllExperiments(ImmutableList.of());
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void activateFetched_callToAbtFails_activateStillSucceeds() throws Exception {
+    ConfigContainer containerWithAbtExperiments =
+        ConfigContainer.newBuilder(firstFetchedContainer)
+            .withAbtExperiments(generateAbtExperiments())
+            .build();
+    loadCacheWithConfig(mockFetchedCache, containerWithAbtExperiments);
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+
+    // When the fetched values are activated, they should be put into the activated cache.
+    when(mockActivatedCache.putWithoutWaitingForDiskWrite(containerWithAbtExperiments))
+        .thenReturn(Tasks.forResult(containerWithAbtExperiments));
+
+    doThrow(new AbtException("Abt failure!")).when(mockFirebaseAbt).replaceAllExperiments(any());
+
+    assertWithMessage("activateFetched() failed!").that(frc.activateFetched()).isTrue();
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void activateFetched_hasAbtExperiments_sendsExperimentsToAbt() throws Exception {
+    ConfigContainer containerWithAbtExperiments =
+        ConfigContainer.newBuilder(firstFetchedContainer)
+            .withAbtExperiments(generateAbtExperiments())
+            .build();
+    loadCacheWithConfig(mockFetchedCache, containerWithAbtExperiments);
+
+    // When the fetched values are activated, they should be put into the activated cache.
+    when(mockActivatedCache.putWithoutWaitingForDiskWrite(containerWithAbtExperiments))
+        .thenReturn(Tasks.forResult(containerWithAbtExperiments));
+
+    assertWithMessage("activateFetched() failed!").that(frc.activateFetched()).isTrue();
+
+    List<Map<String, String>> expectedExperimentInfoMaps =
+        toExperimentInfoMaps(containerWithAbtExperiments.getAbtExperiments());
+    verify(mockFirebaseAbt).replaceAllExperiments(expectedExperimentInfoMaps);
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void activateFetched_fireperfNamespace_noFetchedConfigs_returnsFalse() {
+    loadCacheWithConfig(mockFireperfFetchedCache, /*container=*/ null);
+    loadCacheWithConfig(mockFireperfActivatedCache, /*container=*/ null);
+
+    assertWithMessage("activateFetched(fireperf) succeeded with no fetched values!")
+        .that(fireperfFrc.activateFetched())
+        .isFalse();
+
+    verify(mockFireperfActivatedCache, never()).put(any());
+    verify(mockFireperfFetchedCache, never()).clear();
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void activateFetched_fireperfNamespace_freshFetchedConfigs_activatesAndClearsFetched() {
+    loadCacheWithConfig(mockFireperfFetchedCache, secondFetchedContainer);
+    loadCacheWithConfig(mockFireperfActivatedCache, firstFetchedContainer);
+    // When the fetched values are activated, they should be put into the activated cache.
+    when(mockFireperfActivatedCache.putWithoutWaitingForDiskWrite(secondFetchedContainer))
+        .thenReturn(Tasks.forResult(secondFetchedContainer));
+
+    assertWithMessage("activateFetched(fireperf) failed!")
+        .that(fireperfFrc.activateFetched())
+        .isTrue();
+
+    verify(mockFireperfActivatedCache).putWithoutWaitingForDiskWrite(secondFetchedContainer);
+    verify(mockFireperfFetchedCache).clear();
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void activateFetched2p_hasNoAbtExperiments_doesNotCallAbt() throws Exception {
+    ConfigContainer containerWithNoAbtExperiments =
+        ConfigContainer.newBuilder().withFetchTime(new Date(1000L)).build();
+    loadCacheWithConfig(mockFireperfFetchedCache, containerWithNoAbtExperiments);
+
+    // When the fetched values are activated, they should be put into the activated cache.
+    when(mockFireperfActivatedCache.putWithoutWaitingForDiskWrite(containerWithNoAbtExperiments))
+        .thenReturn(Tasks.forResult(containerWithNoAbtExperiments));
+
+    assertWithMessage("activateFetched(fireperf) failed!")
+        .that(fireperfFrc.activateFetched())
+        .isTrue();
+
+    verify(mockFirebaseAbt, never()).replaceAllExperiments(any());
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void activateFetched2p_hasAbtExperiments_doesNotCallAbt() throws Exception {
+    ConfigContainer containerWithAbtExperiments =
+        ConfigContainer.newBuilder(firstFetchedContainer)
+            .withAbtExperiments(generateAbtExperiments())
+            .build();
+    loadCacheWithConfig(mockFireperfFetchedCache, containerWithAbtExperiments);
+
+    // When the fetched values are activated, they should be put into the activated cache.
+    when(mockFireperfActivatedCache.putWithoutWaitingForDiskWrite(containerWithAbtExperiments))
+        .thenReturn(Tasks.forResult(containerWithAbtExperiments));
+
+    assertWithMessage("activateFetched(fireperf) failed!")
+        .that(fireperfFrc.activateFetched())
+        .isTrue();
+
+    verify(mockFirebaseAbt, never()).replaceAllExperiments(any());
+  }
+
+  @Test
+  public void activate_getFetchedFailed_returnsFalse() {
+    loadCacheWithIoException(mockFetchedCache);
+    loadCacheWithConfig(mockActivatedCache, null);
+
+    Task<Boolean> activateTask = frc.activate();
+
+    assertWithMessage("activate() succeeded with no fetched values!")
+        .that(activateTask.getResult())
+        .isFalse();
+
+    verify(mockActivatedCache, never()).put(any());
+    verify(mockFetchedCache, never()).clear();
+  }
+
+  @Test
+  public void activate_noFetchedConfigs_returnsFalse() {
+    loadCacheWithConfig(mockFetchedCache, null);
+    loadCacheWithConfig(mockActivatedCache, null);
+
+    Task<Boolean> activateTask = frc.activate();
+
+    assertWithMessage("activate() succeeded with no fetched values!")
+        .that(activateTask.getResult())
+        .isFalse();
+
+    verify(mockActivatedCache, never()).put(any());
+    verify(mockFetchedCache, never()).clear();
+  }
+
+  @Test
+  public void activate_staleFetchedConfigs_returnsFalse() {
+    loadCacheWithConfig(mockFetchedCache, firstFetchedContainer);
+    loadCacheWithConfig(mockActivatedCache, firstFetchedContainer);
+
+    Task<Boolean> activateTask = frc.activate();
+
+    assertWithMessage("activate() succeeded with stale values!")
+        .that(activateTask.getResult())
+        .isFalse();
+
+    verify(mockActivatedCache, never()).put(any());
+    verify(mockFetchedCache, never()).clear();
+  }
+
+  @Test
+  public void activate_noActivatedConfigs_activatesAndClearsFetched() {
+    loadCacheWithConfig(mockFetchedCache, firstFetchedContainer);
+    loadCacheWithConfig(mockActivatedCache, null);
+
+    cachePutReturnsConfig(mockActivatedCache, firstFetchedContainer);
+
+    Task<Boolean> activateTask = frc.activate();
+
+    assertWithMessage("activate() failed with no activated values!")
+        .that(activateTask.getResult())
+        .isTrue();
+
+    verify(mockActivatedCache).put(firstFetchedContainer);
+    verify(mockFetchedCache).clear();
+  }
+
+  @Test
+  public void activate_getActivatedFailed_activatesAndClearsFetched() {
+    loadCacheWithConfig(mockFetchedCache, firstFetchedContainer);
+    loadCacheWithIoException(mockActivatedCache);
+
+    cachePutReturnsConfig(mockActivatedCache, firstFetchedContainer);
+
+    Task<Boolean> activateTask = frc.activate();
+
+    assertWithMessage("activate() failed with no activated values!")
+        .that(activateTask.getResult())
+        .isTrue();
+
+    verify(mockActivatedCache).put(firstFetchedContainer);
+    verify(mockFetchedCache).clear();
+  }
+
+  @Test
+  public void activate_freshFetchedConfigs_activatesAndClearsFetched() {
+    loadCacheWithConfig(mockFetchedCache, secondFetchedContainer);
+    loadCacheWithConfig(mockActivatedCache, firstFetchedContainer);
+
+    cachePutReturnsConfig(mockActivatedCache, secondFetchedContainer);
+
+    Task<Boolean> activateTask = frc.activate();
+
+    assertWithMessage("activate() failed!").that(activateTask.getResult()).isTrue();
+
+    verify(mockActivatedCache).put(secondFetchedContainer);
+    verify(mockFetchedCache).clear();
+  }
+
+  @Test
+  public void activate_fileWriteFails_doesNotClearFetchedAndReturnsFalse() {
+    loadCacheWithConfig(mockFetchedCache, secondFetchedContainer);
+    loadCacheWithConfig(mockActivatedCache, firstFetchedContainer);
+
+    when(mockActivatedCache.put(secondFetchedContainer))
+        .thenReturn(Tasks.forException(new IOException("Should have handled disk error.")));
+
+    Task<Boolean> activateTask = frc.activate();
+
+    assertWithMessage("activate() succeeded even though file write failed!")
+        .that(activateTask.getResult())
+        .isFalse();
+
+    verify(mockActivatedCache).put(secondFetchedContainer);
+    verify(mockFetchedCache, never()).clear();
+  }
+
+  @Test
+  public void activate_hasNoAbtExperiments_sendsEmptyListToAbt() throws Exception {
+    ConfigContainer containerWithNoAbtExperiments =
+        ConfigContainer.newBuilder().withFetchTime(new Date(1000L)).build();
+
+    loadCacheWithConfig(mockFetchedCache, containerWithNoAbtExperiments);
+    cachePutReturnsConfig(mockActivatedCache, containerWithNoAbtExperiments);
+
+    Task<Boolean> activateTask = frc.activate();
+
+    assertWithMessage("activate() failed!").that(activateTask.getResult()).isTrue();
+
+    verify(mockFirebaseAbt).replaceAllExperiments(ImmutableList.of());
+  }
+
+  @Test
+  public void activate_callToAbtFails_activateStillSucceeds() throws Exception {
+    ConfigContainer containerWithAbtExperiments =
+        ConfigContainer.newBuilder(firstFetchedContainer)
+            .withAbtExperiments(generateAbtExperiments())
+            .build();
+
+    loadCacheWithConfig(mockFetchedCache, containerWithAbtExperiments);
+    cachePutReturnsConfig(mockActivatedCache, containerWithAbtExperiments);
+
+    doThrow(new AbtException("Abt failure!")).when(mockFirebaseAbt).replaceAllExperiments(any());
+
+    Task<Boolean> activateTask = frc.activate();
+
+    assertWithMessage("activate() failed!").that(activateTask.getResult()).isTrue();
+  }
+
+  @Test
+  public void activate_hasAbtExperiments_sendsExperimentsToAbt() throws Exception {
+    ConfigContainer containerWithAbtExperiments =
+        ConfigContainer.newBuilder(firstFetchedContainer)
+            .withAbtExperiments(generateAbtExperiments())
+            .build();
+
+    loadCacheWithConfig(mockFetchedCache, containerWithAbtExperiments);
+    cachePutReturnsConfig(mockActivatedCache, containerWithAbtExperiments);
+
+    Task<Boolean> activateTask = frc.activate();
+
+    assertWithMessage("activate() failed!").that(activateTask.getResult()).isTrue();
+
+    List<Map<String, String>> expectedExperimentInfoMaps =
+        toExperimentInfoMaps(containerWithAbtExperiments.getAbtExperiments());
+    verify(mockFirebaseAbt).replaceAllExperiments(expectedExperimentInfoMaps);
+  }
+
+  @Test
+  public void activate2p_hasNoAbtExperiments_doesNotCallAbt() throws Exception {
+    ConfigContainer containerWithNoAbtExperiments =
+        ConfigContainer.newBuilder().withFetchTime(new Date(1000L)).build();
+
+    loadCacheWithConfig(mockFireperfFetchedCache, containerWithNoAbtExperiments);
+    cachePutReturnsConfig(mockFireperfActivatedCache, containerWithNoAbtExperiments);
+
+    Task<Boolean> activateTask = fireperfFrc.activate();
+
+    assertWithMessage("Fireperf activate() failed!").that(activateTask.getResult()).isTrue();
+
+    verify(mockFirebaseAbt, never()).replaceAllExperiments(any());
+  }
+
+  @Test
+  public void activate2p_hasAbtExperiments_doesNotCallAbt() throws Exception {
+    ConfigContainer containerWithAbtExperiments =
+        ConfigContainer.newBuilder(firstFetchedContainer)
+            .withAbtExperiments(generateAbtExperiments())
+            .build();
+
+    loadCacheWithConfig(mockFireperfFetchedCache, containerWithAbtExperiments);
+    cachePutReturnsConfig(mockFireperfActivatedCache, containerWithAbtExperiments);
+
+    Task<Boolean> activateTask = fireperfFrc.activate();
+
+    assertWithMessage("Fireperf activate() failed!").that(activateTask.getResult()).isTrue();
+
+    verify(mockFirebaseAbt, never()).replaceAllExperiments(any());
+  }
+
+  @Test
+  public void fetch_hasNoErrors_taskReturnsSuccess() {
+    when(mockFetchHandler.fetch()).thenReturn(Tasks.forResult(firstFetchedContainerResponse));
+
+    Task<Void> fetchTask = frc.fetch();
+
+    assertWithMessage("Fetch failed!").that(fetchTask.isSuccessful()).isTrue();
+  }
+
+  @Test
+  public void fetch_hasNetworkError_taskReturnsException() {
+    when(mockFetchHandler.fetch())
+        .thenReturn(
+            Tasks.forException(new FirebaseRemoteConfigClientException("Network call failed.")));
+
+    Task<Void> fetchTask = frc.fetch();
+
+    assertWithMessage("Fetch succeeded even though there's a network error!")
+        .that(fetchTask.isSuccessful())
+        .isFalse();
+  }
+
+  @Test
+  public void fetchWithInterval_hasNoErrors_taskReturnsSuccess() {
+    long minimumFetchIntervalInSeconds = 600L;
+    when(mockFetchHandler.fetch(minimumFetchIntervalInSeconds))
+        .thenReturn(Tasks.forResult(firstFetchedContainerResponse));
+
+    Task<Void> fetchTask = frc.fetch(minimumFetchIntervalInSeconds);
+
+    assertWithMessage("Fetch failed!").that(fetchTask.isSuccessful()).isTrue();
+  }
+
+  @Test
+  public void fetchWithInterval_hasNetworkError_taskReturnsException() {
+    long minimumFetchIntervalInSeconds = 600L;
+    when(mockFetchHandler.fetch(minimumFetchIntervalInSeconds))
+        .thenReturn(
+            Tasks.forException(new FirebaseRemoteConfigClientException("Network call failed.")));
+
+    Task<Void> fetchTask = frc.fetch(minimumFetchIntervalInSeconds);
+
+    assertWithMessage("Fetch succeeded even though there's a network error!")
+        .that(fetchTask.isSuccessful())
+        .isFalse();
+  }
+
+  @Test
+  public void getKeysByPrefix_noKeysWithPrefix_returnsEmptySet() {
+    when(mockGetHandler.getKeysByPrefix("pre")).thenReturn(ImmutableSet.of());
+
+    assertThat(frc.getKeysByPrefix("pre")).isEmpty();
+  }
+
+  @Test
+  public void getKeysByPrefix_hasKeysWithPrefix_returnsKeysWithPrefix() {
+    Set<String> keysWithPrefix = ImmutableSet.of("pre11", "pre12");
+    when(mockGetHandler.getKeysByPrefix("pre")).thenReturn(keysWithPrefix);
+
+    assertThat(frc.getKeysByPrefix("pre")).containsExactlyElementsIn(keysWithPrefix);
+  }
+
+  @Test
+  public void getString_keyDoesNotExist_returnsDefaultValue() {
+    when(mockGetHandler.getString(STRING_KEY)).thenReturn(DEFAULT_VALUE_FOR_STRING);
+
+    assertThat(frc.getString(STRING_KEY)).isEqualTo(DEFAULT_VALUE_FOR_STRING);
+  }
+
+  @Test
+  public void getString_keyExists_returnsRemoteValue() {
+    String remoteValue = "remote value";
+    when(mockGetHandler.getString(STRING_KEY)).thenReturn(remoteValue);
+
+    assertThat(frc.getString(STRING_KEY)).isEqualTo(remoteValue);
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void getString_fireperfNamespace_keyDoesNotExist_returnsDefaultValue() {
+    when(mockFireperfGetHandler.getString(STRING_KEY)).thenReturn(DEFAULT_VALUE_FOR_STRING);
+
+    assertThat(fireperfFrc.getString(STRING_KEY)).isEqualTo(DEFAULT_VALUE_FOR_STRING);
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void getString_fireperfNamespace_keyExists_returnsRemoteValue() {
+    String remoteValue = "remote value";
+    when(mockFireperfGetHandler.getString(STRING_KEY)).thenReturn(remoteValue);
+
+    assertThat(fireperfFrc.getString(STRING_KEY)).isEqualTo(remoteValue);
+  }
+
+  @Test
+  public void getBoolean_keyDoesNotExist_returnsDefaultValue() {
+    when(mockGetHandler.getBoolean(BOOLEAN_KEY)).thenReturn(DEFAULT_VALUE_FOR_BOOLEAN);
+
+    assertThat(frc.getBoolean(BOOLEAN_KEY)).isEqualTo(DEFAULT_VALUE_FOR_BOOLEAN);
+  }
+
+  @Test
+  public void getBoolean_keyExists_returnsRemoteValue() {
+    when(mockGetHandler.getBoolean(BOOLEAN_KEY)).thenReturn(true);
+
+    assertThat(frc.getBoolean(BOOLEAN_KEY)).isTrue();
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void getBoolean_fireperfNamespace_keyDoesNotExist_returnsDefaultValue() {
+    when(mockFireperfGetHandler.getBoolean(BOOLEAN_KEY)).thenReturn(DEFAULT_VALUE_FOR_BOOLEAN);
+
+    assertThat(fireperfFrc.getBoolean(BOOLEAN_KEY)).isEqualTo(DEFAULT_VALUE_FOR_BOOLEAN);
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void getBoolean_fireperfNamespace_keyExists_returnsRemoteValue() {
+    when(mockFireperfGetHandler.getBoolean(BOOLEAN_KEY)).thenReturn(true);
+
+    assertThat(fireperfFrc.getBoolean(BOOLEAN_KEY)).isTrue();
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void getByteArray_keyDoesNotExist_returnsDefaultValue() {
+    when(mockGetHandler.getByteArray(BYTE_ARRAY_KEY)).thenReturn(DEFAULT_VALUE_FOR_BYTE_ARRAY);
+
+    assertThat(frc.getByteArray(BYTE_ARRAY_KEY)).isEqualTo(DEFAULT_VALUE_FOR_BYTE_ARRAY);
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void getByteArray_keyExists_returnsRemoteValue() {
+    byte[] remoteValue = "remote value".getBytes(FRC_BYTE_ARRAY_ENCODING);
+    when(mockGetHandler.getByteArray(BYTE_ARRAY_KEY)).thenReturn(remoteValue);
+
+    assertThat(frc.getByteArray(BYTE_ARRAY_KEY)).isEqualTo(remoteValue);
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void getByteArray_fireperfNamespace_keyDoesNotExist_returnsDefaultValue() {
+    when(mockFireperfGetHandler.getByteArray(BYTE_ARRAY_KEY))
+        .thenReturn(DEFAULT_VALUE_FOR_BYTE_ARRAY);
+
+    assertThat(fireperfFrc.getByteArray(BYTE_ARRAY_KEY)).isEqualTo(DEFAULT_VALUE_FOR_BYTE_ARRAY);
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void getByteArray_fireperfNamespace_keyExists_returnsRemoteValue() {
+    byte[] remoteValue = "remote value".getBytes(FRC_BYTE_ARRAY_ENCODING);
+    when(mockFireperfGetHandler.getByteArray(BYTE_ARRAY_KEY)).thenReturn(remoteValue);
+
+    assertThat(fireperfFrc.getByteArray(BYTE_ARRAY_KEY)).isEqualTo(remoteValue);
+  }
+
+  @Test
+  public void getDouble_keyDoesNotExist_returnsDefaultValue() {
+    when(mockGetHandler.getDouble(DOUBLE_KEY)).thenReturn(DEFAULT_VALUE_FOR_DOUBLE);
+
+    assertThat(frc.getDouble(DOUBLE_KEY)).isEqualTo(DEFAULT_VALUE_FOR_DOUBLE);
+  }
+
+  @Test
+  public void getDouble_keyExists_returnsRemoteValue() {
+    double remoteValue = 555.5;
+    when(mockGetHandler.getDouble(DOUBLE_KEY)).thenReturn(remoteValue);
+
+    assertThat(frc.getDouble(DOUBLE_KEY)).isEqualTo(remoteValue);
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void getDouble_fireperfNamespace_keyDoesNotExist_returnsDefaultValue() {
+    when(mockFireperfGetHandler.getDouble(DOUBLE_KEY)).thenReturn(DEFAULT_VALUE_FOR_DOUBLE);
+
+    assertThat(fireperfFrc.getDouble(DOUBLE_KEY)).isEqualTo(DEFAULT_VALUE_FOR_DOUBLE);
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void getDouble_fireperfNamespace_keyExists_returnsRemoteValue() {
+    double remoteValue = 555.5;
+    when(mockFireperfGetHandler.getDouble(DOUBLE_KEY)).thenReturn(remoteValue);
+
+    assertThat(fireperfFrc.getDouble(DOUBLE_KEY)).isEqualTo(remoteValue);
+  }
+
+  @Test
+  public void getLong_keyDoesNotExist_returnsDefaultValue() {
+    when(mockGetHandler.getLong(LONG_KEY)).thenReturn(DEFAULT_VALUE_FOR_LONG);
+
+    assertThat(frc.getLong(LONG_KEY)).isEqualTo(DEFAULT_VALUE_FOR_LONG);
+  }
+
+  @Test
+  public void getLong_keyExists_returnsRemoteValue() {
+    long remoteValue = 555L;
+    when(mockGetHandler.getLong(LONG_KEY)).thenReturn(remoteValue);
+
+    assertThat(frc.getLong(LONG_KEY)).isEqualTo(remoteValue);
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void getLong_fireperfNamespace_keyDoesNotExist_returnsDefaultValue() {
+    when(mockFireperfGetHandler.getLong(LONG_KEY)).thenReturn(DEFAULT_VALUE_FOR_LONG);
+
+    assertThat(fireperfFrc.getLong(LONG_KEY)).isEqualTo(DEFAULT_VALUE_FOR_LONG);
+  }
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void getLong_fireperfNamespace_keyExists_returnsRemoteValue() {
+    long remoteValue = 555L;
+    when(mockFireperfGetHandler.getLong(LONG_KEY)).thenReturn(remoteValue);
+
+    assertThat(fireperfFrc.getLong(LONG_KEY)).isEqualTo(remoteValue);
+  }
+
+  @Test
+  public void getInfo_returnsInfo() {
+    when(metadataClient.getInfo()).thenReturn(mockFrcInfo);
+
+    long fetchTimeInMillis = 100L;
+    int lastFetchStatus = LAST_FETCH_STATUS_THROTTLED;
+    long fetchTimeoutInSeconds = 10L;
+    long minimumFetchIntervalInSeconds = 100L;
+    when(mockFrcInfo.getFetchTimeMillis()).thenReturn(fetchTimeInMillis);
+    when(mockFrcInfo.getLastFetchStatus()).thenReturn(lastFetchStatus);
+    when(mockFrcInfo.getConfigSettings())
+        .thenReturn(
+            new FirebaseRemoteConfigSettings.Builder()
+                .setDeveloperModeEnabled(true)
+                .setFetchTimeoutInSeconds(fetchTimeoutInSeconds)
+                .setMinimumFetchIntervalInSeconds(minimumFetchIntervalInSeconds)
+                .build());
+
+    FirebaseRemoteConfigInfo info = frc.getInfo();
+
+    assertThat(info.getFetchTimeMillis()).isEqualTo(fetchTimeInMillis);
+    assertThat(info.getLastFetchStatus()).isEqualTo(lastFetchStatus);
+    assertThat(info.getConfigSettings().isDeveloperModeEnabled()).isEqualTo(true);
+    assertThat(info.getConfigSettings().getFetchTimeoutInSeconds())
+        .isEqualTo(fetchTimeoutInSeconds);
+    assertThat(info.getConfigSettings().getMinimumFetchIntervalInSeconds())
+        .isEqualTo(minimumFetchIntervalInSeconds);
+  }
+
+  @Test
+  public void setDefaults_withMap_setsDefaults() throws Exception {
+    frc.setDefaults(ImmutableMap.copyOf(DEFAULTS_MAP));
+
+    ConfigContainer defaultsContainer = newDefaultsContainer(DEFAULTS_MAP);
+    ArgumentCaptor<ConfigContainer> captor = ArgumentCaptor.forClass(ConfigContainer.class);
+
+    verify(mockDefaultsCache).putWithoutWaitingForDiskWrite(captor.capture());
+    JSONAssert.assertEquals(defaultsContainer.toString(), captor.getValue().toString(), false);
+  }
+
+  @Test
+  public void setDefaultsAsync_withMap_setsDefaults() throws Exception {
+    ConfigContainer defaultsContainer = newDefaultsContainer(DEFAULTS_MAP);
+    ArgumentCaptor<ConfigContainer> captor = ArgumentCaptor.forClass(ConfigContainer.class);
+    cachePutReturnsConfig(mockDefaultsCache, defaultsContainer);
+
+    boolean isComplete = frc.setDefaultsAsync(ImmutableMap.copyOf(DEFAULTS_MAP)).isComplete();
+
+    assertThat(isComplete).isTrue();
+    // Assert defaults were set correctly.
+    verify(mockDefaultsCache).put(captor.capture());
+
+    JSONAssert.assertEquals(defaultsContainer.toString(), captor.getValue().toString(), false);
+  }
+
+  @Test
+  public void clear_hasSettings_clearsEverything() {
+    frc.reset();
+
+    verify(mockActivatedCache).clear();
+    verify(mockFetchedCache).clear();
+    verify(mockDefaultsCache).clear();
+    verify(metadataClient).clear();
+  }
+
+  @Test
+  public void setConfigSettings_updatesMetadata() {
+    long fetchTimeout = 13L;
+    long minimumFetchInterval = 666L;
+    FirebaseRemoteConfigSettings frcSettings =
+        new FirebaseRemoteConfigSettings.Builder()
+            .setDeveloperModeEnabled(true)
+            .setFetchTimeoutInSeconds(fetchTimeout)
+            .setMinimumFetchIntervalInSeconds(minimumFetchInterval)
+            .build();
+
+    frc.setConfigSettings(frcSettings);
+
+    verify(metadataClient).setConfigSettingsWithoutWaitingOnDiskWrite(frcSettings);
+  }
+
+  @Test
+  public void setConfigSettingsAsync_updatesMetadata() {
+    long fetchTimeout = 13L;
+    long minimumFetchInterval = 666L;
+    FirebaseRemoteConfigSettings frcSettings =
+        new FirebaseRemoteConfigSettings.Builder()
+            .setDeveloperModeEnabled(true)
+            .setFetchTimeoutInSeconds(fetchTimeout)
+            .setMinimumFetchIntervalInSeconds(minimumFetchInterval)
+            .build();
+
+    Task<Void> setterTask = frc.setConfigSettingsAsync(frcSettings);
+
+    assertThat(setterTask.isSuccessful()).isTrue();
+    verify(metadataClient).setConfigSettings(frcSettings);
+  }
+
+  private static void loadCacheWithConfig(
+      ConfigCacheClient cacheClient, ConfigContainer container) {
+    when(cacheClient.getBlocking()).thenReturn(container);
+    when(cacheClient.get()).thenReturn(Tasks.forResult(container));
+  }
+
+  private static void loadCacheWithIoException(ConfigCacheClient cacheClient) {
+    when(cacheClient.getBlocking()).thenReturn(null);
+    when(cacheClient.get())
+        .thenReturn(Tasks.forException(new IOException("Should have handled disk error.")));
+  }
+
+  private void loadActivatedCacheWithIncompleteTask() {
+    TaskCompletionSource<ConfigContainer> taskSource = new TaskCompletionSource<>();
+    when(mockActivatedCache.get()).thenReturn(taskSource.getTask());
+  }
+
+  private static void cachePutReturnsConfig(
+      ConfigCacheClient cacheClient, ConfigContainer container) {
+    when(cacheClient.put(container)).thenReturn(Tasks.forResult(container));
+  }
+
+  private void loadFetchHandlerWithResponse() {
+    when(mockFetchHandler.fetch()).thenReturn(Tasks.forResult(firstFetchedContainerResponse));
+  }
+
+  private void load2pFetchHandlerWithResponse() {
+    when(mockFireperfFetchHandler.fetch())
+        .thenReturn(Tasks.forResult(firstFetchedContainerResponse));
+  }
+
+  private static int getResourceId(String xmlResourceName) {
+    Resources r = RuntimeEnvironment.application.getResources();
+    return r.getIdentifier(xmlResourceName, "xml", RuntimeEnvironment.application.getPackageName());
+  }
+
+  private static ConfigContainer newDefaultsContainer(Map<String, String> configsMap)
+      throws Exception {
+    return ConfigContainer.newBuilder()
+        .replaceConfigsWith(configsMap)
+        .withFetchTime(new Date(0L))
+        .build();
+  }
+
+  private <T> T getTaskResult(Task<T> task) {
+    assertThat(task.isComplete()).isTrue();
+    assertThat(task.getResult()).isNotNull();
+    return task.getResult();
+  }
+
+  private static JSONArray generateAbtExperiments() throws JSONException {
+    JSONArray experiments = new JSONArray();
+    for (int experimentNum = 1; experimentNum <= 5; experimentNum++) {
+      experiments.put(createAbtExperiment("exp" + experimentNum));
+    }
+    return experiments;
+  }
+
+  private static FirebaseApp initializeFirebaseApp(Context context) {
+    FirebaseApp.clearInstancesForTest();
+
+    return FirebaseApp.initializeApp(
+        context, new FirebaseOptions.Builder().setApiKey(API_KEY).setApplicationId(APP_ID).build());
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/MockAnalyticsConnectorRegistrar.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/MockAnalyticsConnectorRegistrar.java
new file mode 100644
index 000000000..2cd7b7ef8
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/MockAnalyticsConnectorRegistrar.java
@@ -0,0 +1,40 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import static org.mockito.Mockito.mock;
+
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.components.Component;
+import com.google.firebase.components.ComponentRegistrar;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Mock {@link AnalyticsConnector} for testing purposes.
+ *
+ * @author Miraziz Yusupov
+ */
+public class MockAnalyticsConnectorRegistrar implements ComponentRegistrar {
+  @Override
+  public List<Component<?>> getComponents() {
+    Component<AnalyticsConnector> mockAnalyticsConnector =
+        Component.builder(AnalyticsConnector.class)
+            .factory(container -> mock(AnalyticsConnector.class))
+            .build();
+
+    return Arrays.asList(mockAnalyticsConnector);
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/MockFirebaseAbtRegistrar.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/MockFirebaseAbtRegistrar.java
new file mode 100644
index 000000000..ea298c6f8
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/MockFirebaseAbtRegistrar.java
@@ -0,0 +1,43 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import com.google.firebase.abt.FirebaseABTesting;
+import com.google.firebase.abt.component.AbtComponent;
+import com.google.firebase.components.Component;
+import com.google.firebase.components.ComponentRegistrar;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Mock {@link FirebaseABTesting} for testing purposes.
+ *
+ * @author Miraziz Yusupov
+ */
+public class MockFirebaseAbtRegistrar implements ComponentRegistrar {
+  @Override
+  public List<Component<?>> getComponents() {
+    Component<AbtComponent> mockFirebaseAbt =
+        Component.builder(AbtComponent.class).factory(container -> new FakeAbtComponent()).build();
+
+    return Arrays.asList(mockFirebaseAbt);
+  }
+
+  private static class FakeAbtComponent extends AbtComponent {
+    FakeAbtComponent() {
+      super(/*appContext=*/ null, /*analyticsConnector=*/ null);
+    }
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/MockFirebaseIidRegistrar.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/MockFirebaseIidRegistrar.java
new file mode 100644
index 000000000..6af49e4bc
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/MockFirebaseIidRegistrar.java
@@ -0,0 +1,40 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import static org.mockito.Mockito.mock;
+
+import com.google.firebase.components.Component;
+import com.google.firebase.components.ComponentRegistrar;
+import com.google.firebase.iid.FirebaseInstanceId;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Mock {@link FirebaseInstanceId} for testing purposes.
+ *
+ * @author Miraziz Yusupov
+ */
+public class MockFirebaseIidRegistrar implements ComponentRegistrar {
+  @Override
+  public List<Component<?>> getComponents() {
+    Component<FirebaseInstanceId> mockFirebaseInstanceId =
+        Component.builder(FirebaseInstanceId.class)
+            .factory(container -> mock(FirebaseInstanceId.class))
+            .build();
+
+    return Arrays.asList(mockFirebaseInstanceId);
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/RemoteConfigComponentTest.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/RemoteConfigComponentTest.java
new file mode 100644
index 000000000..fa21b7184
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/RemoteConfigComponentTest.java
@@ -0,0 +1,242 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+import static com.google.firebase.remoteconfig.AbtExperimentHelper.createAbtExperiment;
+import static com.google.firebase.remoteconfig.AbtExperimentHelper.createAbtExperiments;
+import static com.google.firebase.remoteconfig.RemoteConfigComponent.DEFAULT_NAMESPACE;
+import static com.google.firebase.remoteconfig.RemoteConfigComponent.NETWORK_CONNECTION_TIMEOUT_IN_SECONDS;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import com.google.android.gms.tasks.Tasks;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.FirebaseOptions;
+import com.google.firebase.abt.FirebaseABTesting;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.remoteconfig.internal.ConfigCacheClient;
+import com.google.firebase.remoteconfig.internal.ConfigContainer;
+import com.google.firebase.remoteconfig.internal.ConfigFetchHandler;
+import com.google.firebase.remoteconfig.internal.ConfigFetchHttpClient;
+import com.google.firebase.remoteconfig.internal.ConfigGetParameterHandler;
+import com.google.firebase.remoteconfig.internal.ConfigMetadataClient;
+import com.google.firebase.remoteconfig.internal.LegacyConfigsHandler;
+import java.util.concurrent.ExecutorService;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for the Firebase Remote Config Component.
+ *
+ * @author Miraziz Yusupov
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class RemoteConfigComponentTest {
+  private static final String API_KEY = "api_key";
+  private static final String APP_ID = "1:14368190084:android:09cb977358c6f241";
+  private static final String DUMMY_API_KEY = "api_key";
+
+  @Mock private FirebaseApp mockFirebaseApp;
+  @Mock private FirebaseInstanceId mockFirebaseIid;
+  @Mock private FirebaseABTesting mockFirebaseAbt;
+  @Mock private AnalyticsConnector mockAnalyticsConnector;
+  @Mock private LegacyConfigsHandler mockLegacyConfigsHandler;
+  @Mock private ConfigCacheClient mockFetchedCache;
+  @Mock private ConfigCacheClient mockActivatedCache;
+  @Mock private ConfigCacheClient mockDefaultsCache;
+  @Mock private ConfigFetchHandler mockFetchHandler;
+  @Mock private ConfigGetParameterHandler mockGetParameterHandler;
+  @Mock private ConfigMetadataClient mockMetadataClient;
+
+  private Context context;
+  private ExecutorService directExecutor;
+  private FirebaseApp defaultApp;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    context = RuntimeEnvironment.application;
+    directExecutor = MoreExecutors.newDirectExecutorService();
+
+    defaultApp = initializeFirebaseApp(context);
+
+    when(mockFirebaseApp.getOptions())
+        .thenReturn(new FirebaseOptions.Builder().setApplicationId(APP_ID).build());
+    when(mockFirebaseApp.getName()).thenReturn(FirebaseApp.DEFAULT_APP_NAME);
+  }
+
+  @Test
+  public void constructor_callsLegacyConfigHandler() {
+    getNewFrcComponent();
+    verify(mockLegacyConfigsHandler).saveLegacyConfigsIfNecessary();
+  }
+
+  @Test
+  public void frc2p_doesNotCallAbt() throws Exception {
+
+    FirebaseRemoteConfig fireperfFrc =
+        getFrcInstanceFromComponent(getNewFrcComponent(), /* namespace= */ "fireperf");
+    loadConfigsWithExperimentsForActivate();
+
+    assertWithMessage("Fireperf fetch and activate failed!")
+        .that(fireperfFrc.activate().getResult())
+        .isTrue();
+
+    verify(mockFirebaseAbt, never()).replaceAllExperiments(any());
+  }
+
+  @Test
+  public void frcNonMainFirebaseApp_doesNotCallAbt() throws Exception {
+
+    when(mockFirebaseApp.getName()).thenReturn("secondary");
+    FirebaseRemoteConfig frc =
+        getFrcInstanceFromComponent(getNewFrcComponentWithoutLoadingDefault(), DEFAULT_NAMESPACE);
+    loadConfigsWithExperimentsForActivate();
+
+    assertWithMessage("Fetch and activate failed!").that(frc.activate().getResult()).isTrue();
+
+    verify(mockFirebaseAbt, never()).replaceAllExperiments(any());
+  }
+
+  @Test
+  public void getFetchHandler_nonMainFirebaseApp_doesNotUseAnalytics() {
+
+    when(mockFirebaseApp.getName()).thenReturn("secondary");
+
+    ConfigFetchHandler fetchHandler =
+        getNewFrcComponent()
+            .getFetchHandler(DEFAULT_NAMESPACE, mockFetchedCache, mockMetadataClient);
+
+    assertThat(fetchHandler.getAnalyticsConnector()).isNull();
+  }
+
+  @Test
+  public void
+      getFrcBackendApiClient_fetchTimeoutIsNotSet_buildsConfigFetchHttpClientWithDefaultConnectionTimeout() {
+
+    RemoteConfigComponent frcComponent = defaultApp.get(RemoteConfigComponent.class);
+    when(mockMetadataClient.getFetchTimeoutInSeconds())
+        .thenReturn(NETWORK_CONNECTION_TIMEOUT_IN_SECONDS);
+
+    ConfigFetchHttpClient frcBackendClient =
+        frcComponent.getFrcBackendApiClient(DUMMY_API_KEY, DEFAULT_NAMESPACE, mockMetadataClient);
+
+    int actualConnectTimeout = getConnectTimeoutInSeconds(frcBackendClient);
+    int actualReadTimeout = getReadTimeoutInSeconds(frcBackendClient);
+    assertThat(actualConnectTimeout).isEqualTo(NETWORK_CONNECTION_TIMEOUT_IN_SECONDS);
+    assertThat(actualReadTimeout).isEqualTo(NETWORK_CONNECTION_TIMEOUT_IN_SECONDS);
+  }
+
+  @Test
+  public void
+      getFrcBackendApiClient_fetchTimeoutIsSetToDoubleDefault_buildsConfigFetchHttpClientWithDoubleDefaultConnectionTimeout() {
+
+    RemoteConfigComponent frcComponent = defaultApp.get(RemoteConfigComponent.class);
+
+    long customNetworkConnectionTimeoutInSeconds = 2 * NETWORK_CONNECTION_TIMEOUT_IN_SECONDS;
+    when(mockMetadataClient.getFetchTimeoutInSeconds())
+        .thenReturn(customNetworkConnectionTimeoutInSeconds);
+
+    ConfigFetchHttpClient frcBackendClient =
+        frcComponent.getFrcBackendApiClient(DUMMY_API_KEY, DEFAULT_NAMESPACE, mockMetadataClient);
+
+    int actualConnectTimeout = getConnectTimeoutInSeconds(frcBackendClient);
+    int actualReadTimeout = getReadTimeoutInSeconds(frcBackendClient);
+    assertThat(actualConnectTimeout).isEqualTo(customNetworkConnectionTimeoutInSeconds);
+    assertThat(actualReadTimeout).isEqualTo(NETWORK_CONNECTION_TIMEOUT_IN_SECONDS);
+  }
+
+  private RemoteConfigComponent getNewFrcComponent() {
+    return new RemoteConfigComponent(
+        context,
+        directExecutor,
+        mockFirebaseApp,
+        mockFirebaseIid,
+        mockFirebaseAbt,
+        mockAnalyticsConnector,
+        mockLegacyConfigsHandler,
+        /* loadGetDefault= */ true);
+  }
+
+  private RemoteConfigComponent getNewFrcComponentWithoutLoadingDefault() {
+    return new RemoteConfigComponent(
+        context,
+        directExecutor,
+        mockFirebaseApp,
+        mockFirebaseIid,
+        mockFirebaseAbt,
+        mockAnalyticsConnector,
+        mockLegacyConfigsHandler,
+        /* loadGetDefault= */ false);
+  }
+
+  private FirebaseRemoteConfig getFrcInstanceFromComponent(
+      RemoteConfigComponent frcComponent, String namespace) {
+    return frcComponent.get(
+        mockFirebaseApp,
+        namespace,
+        mockFirebaseAbt,
+        directExecutor,
+        mockFetchedCache,
+        mockActivatedCache,
+        mockDefaultsCache,
+        mockFetchHandler,
+        mockGetParameterHandler,
+        mockMetadataClient);
+  }
+
+  private void loadConfigsWithExperimentsForActivate() throws Exception {
+    ConfigContainer containerWithAbtExperiments =
+        ConfigContainer.newBuilder()
+            .withAbtExperiments(createAbtExperiments(createAbtExperiment("exp1")))
+            .build();
+
+    when(mockFetchedCache.get()).thenReturn(Tasks.forResult(containerWithAbtExperiments));
+    when(mockActivatedCache.get()).thenReturn(Tasks.forResult(null));
+
+    when(mockActivatedCache.put(containerWithAbtExperiments))
+        .thenReturn(Tasks.forResult(containerWithAbtExperiments));
+  }
+
+  private int getConnectTimeoutInSeconds(ConfigFetchHttpClient frcBackendClient) {
+    return (int) frcBackendClient.getConnectTimeoutInSeconds();
+  }
+
+  private int getReadTimeoutInSeconds(ConfigFetchHttpClient frcBackendClient) {
+    return (int) frcBackendClient.getReadTimeoutInSeconds();
+  }
+
+  private static FirebaseApp initializeFirebaseApp(Context context) {
+    FirebaseApp.clearInstancesForTest();
+
+    return FirebaseApp.initializeApp(
+        context, new FirebaseOptions.Builder().setApiKey(API_KEY).setApplicationId(APP_ID).build());
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigCacheClientTest.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigCacheClientTest.java
new file mode 100644
index 000000000..dddc300cb
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigCacheClientTest.java
@@ -0,0 +1,352 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.firebase.remoteconfig.testutil.Assert.assertThrows;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.google.android.gms.common.internal.Preconditions;
+import com.google.android.gms.shadows.common.internal.ShadowPreconditions;
+import com.google.android.gms.tasks.Task;
+import com.google.android.gms.tasks.Tasks;
+import com.google.common.collect.ImmutableMap;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for the {@link ConfigCacheClient}.
+ *
+ * @author Miraziz Yusupov
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(
+    manifest = Config.NONE,
+    shadows = {ShadowPreconditions.class})
+public class ConfigCacheClientTest {
+  private static final IOException IO_EXCEPTION = new IOException("File I/O failed.");
+
+  @Mock private ConfigStorageClient mockStorageClient;
+
+  private ExecutorService testingThreadPool;
+  private ExecutorService cacheThreadPool;
+  private ConfigCacheClient cacheClient;
+  private ConfigContainer configContainer;
+  private ConfigContainer configContainer2;
+
+  @Before
+  public void setUp() throws Exception {
+    MockitoAnnotations.initMocks(this);
+
+    cacheThreadPool = Executors.newFixedThreadPool(/*nThreads=*/ 2);
+    testingThreadPool = Executors.newFixedThreadPool(/*nThreads=*/ 3);
+
+    ConfigCacheClient.clearInstancesForTest();
+    when(mockStorageClient.getFileName()).thenReturn("FILE_NAME");
+    cacheClient = ConfigCacheClient.getInstance(cacheThreadPool, mockStorageClient);
+
+    configContainer =
+        ConfigContainer.newBuilder()
+            .replaceConfigsWith(ImmutableMap.of("long_param", "1L", "string_param", "string_value"))
+            .withFetchTime(new Date(1000L))
+            .build();
+
+    configContainer2 =
+        ConfigContainer.newBuilder()
+            .replaceConfigsWith(
+                ImmutableMap.of("string_param", "string_value", "double_param", "0.1"))
+            .withFetchTime(new Date(2000L))
+            .build();
+  }
+
+  @Test
+  public void put_validContainer_writesToFileAndSetsCache() throws Exception {
+    ConfigContainer putContainer = Tasks.await(cacheClient.put(configContainer));
+
+    verifyFileWrites(configContainer);
+
+    assertThat(putContainer).isEqualTo(configContainer);
+    assertThat(cacheClient.getCachedContainerTask().getResult()).isEqualTo(configContainer);
+  }
+
+  @Test
+  public void put_fileWriteFails_keepsCacheNull() throws Exception {
+    when(mockStorageClient.write(configContainer)).thenThrow(IO_EXCEPTION);
+
+    Task<ConfigContainer> putTask = cacheClient.put(configContainer);
+    assertThrows(ExecutionException.class, () -> Tasks.await(putTask));
+
+    assertThat(putTask.getException()).isInstanceOf(IOException.class);
+    assertThat(cacheClient.getCachedContainerTask()).isNull();
+  }
+
+  @Test
+  public void put_secondFileWriteFails_keepsFirstContainerInCache() throws Exception {
+    when(mockStorageClient.write(configContainer2)).thenThrow(IO_EXCEPTION);
+
+    Tasks.await(cacheClient.put(configContainer));
+    Preconditions.checkArgument(
+        cacheClient.getCachedContainerTask().getResult().equals(configContainer));
+
+    Task<ConfigContainer> failedPutTask = cacheClient.put(configContainer2);
+    assertThrows(ExecutionException.class, () -> Tasks.await(failedPutTask));
+
+    verifyFileWrites(configContainer, configContainer2);
+
+    assertThat(failedPutTask.getException()).isInstanceOf(IOException.class);
+    assertThat(cacheClient.getCachedContainerTask().getResult()).isEqualTo(configContainer);
+  }
+
+  @Test
+  public void get_hasCachedValue_returnsCache() throws Exception {
+    Tasks.await(cacheClient.put(configContainer));
+    Preconditions.checkArgument(
+        cacheClient.getCachedContainerTask().getResult().equals(configContainer));
+
+    ConfigContainer getContainer = Tasks.await(cacheClient.get());
+
+    verify(mockStorageClient, never()).read();
+    assertThat(getContainer).isEqualTo(configContainer);
+  }
+
+  @Test
+  public void get_hasNoCachedValue_readsFileAndSetsCache() throws Exception {
+    when(mockStorageClient.read()).thenReturn(configContainer);
+
+    ConfigContainer getContainer = Tasks.await(cacheClient.get());
+    assertThat(getContainer).isEqualTo(configContainer);
+
+    assertThat(cacheClient.getCachedContainerTask().getResult()).isEqualTo(configContainer);
+  }
+
+  @Test
+  public void get_hasNoCachedValueAndFileReadFails_throwsIOException() throws Exception {
+    when(mockStorageClient.read()).thenThrow(IO_EXCEPTION);
+
+    Task<ConfigContainer> getTask = cacheClient.get();
+    assertThrows(ExecutionException.class, () -> Tasks.await(getTask));
+
+    assertThat(getTask.getException()).isInstanceOf(IOException.class);
+  }
+
+  @Test
+  public void get_hasFailedCacheValue_readsFileAndSetsCache() throws Exception {
+    when(mockStorageClient.read()).thenThrow(IO_EXCEPTION);
+    Task<ConfigContainer> getTask = cacheClient.get();
+    assertThrows(ExecutionException.class, () -> Tasks.await(getTask));
+    Preconditions.checkArgument(getTask.getException() instanceof IOException);
+
+    doReturn(configContainer).when(mockStorageClient).read();
+
+    ConfigContainer getContainer = Tasks.await(cacheClient.get());
+
+    assertThat(getContainer).isEqualTo(configContainer);
+  }
+
+  @Test
+  public void get_hasMultipleGetCallsInDifferentThreads_readsFileAndSetsCacheOnce()
+      throws Exception {
+    when(mockStorageClient.read()).thenReturn(configContainer);
+
+    List<Task<ConfigContainer>> getTasks = new ArrayList<>();
+    for (int i = 0; i < 10; i++) {
+      getTasks.add(Tasks.call(testingThreadPool, () -> Tasks.await(cacheClient.get())));
+    }
+
+    for (Task<ConfigContainer> getTask : getTasks) {
+      assertThat(Tasks.await(getTask)).isEqualTo(configContainer);
+    }
+    verify(mockStorageClient, times(1)).read();
+  }
+
+  @Test
+  public void get_firstTwoFileReadsFail_readsFileAndSetsCacheThreeTimes() throws Exception {
+    doThrow(IO_EXCEPTION).when(mockStorageClient).read();
+    assertThrows(ExecutionException.class, () -> Tasks.await(cacheClient.get()));
+    assertThrows(ExecutionException.class, () -> Tasks.await(cacheClient.get()));
+
+    doReturn(configContainer).when(mockStorageClient).read();
+    for (int getCallIndex = 0; getCallIndex < 5; getCallIndex++) {
+      assertThat(Tasks.await(cacheClient.get())).isEqualTo(configContainer);
+    }
+
+    // Three file reads: 2 failures and 1 success.
+    verify(mockStorageClient, times(3)).read();
+  }
+
+  @Test
+  public void getBlocking_hasCachedValue_returnsCache() throws Exception {
+    Tasks.await(cacheClient.put(configContainer));
+    Preconditions.checkArgument(
+        cacheClient.getCachedContainerTask().getResult().equals(configContainer));
+
+    ConfigContainer readConfig = cacheClient.getBlocking();
+
+    assertThat(readConfig).isEqualTo(configContainer);
+
+    verify(mockStorageClient, never()).read();
+  }
+
+  @Test
+  public void getBlocking_hasNoCachedValueAndFileReadTimesOut_returnsNull() throws Exception {
+    when(mockStorageClient.read()).thenReturn(configContainer);
+
+    ConfigContainer container = cacheClient.getBlocking(/*diskReadTimeoutInSeconds=*/ 0L);
+
+    assertThat(container).isNull();
+  }
+
+  @Test
+  public void getBlocking_hasNoCachedValueAndFileReadFails_returnsNull() throws Exception {
+    when(mockStorageClient.read()).thenThrow(IO_EXCEPTION);
+
+    ConfigContainer container = cacheClient.getBlocking();
+
+    assertThat(container).isNull();
+  }
+
+  @Test
+  public void getBlocking_hasFailedCacheValue_blocksOnFileReadAndReturnsFileContainer()
+      throws Exception {
+    when(mockStorageClient.read()).thenThrow(IO_EXCEPTION);
+    Task<ConfigContainer> getTask = cacheClient.get();
+    assertThrows(ExecutionException.class, () -> Tasks.await(getTask));
+    Preconditions.checkArgument(getTask.getException() instanceof IOException);
+
+    doReturn(configContainer).when(mockStorageClient).read();
+
+    ConfigContainer container = cacheClient.getBlocking();
+
+    assertThat(container).isEqualTo(configContainer);
+  }
+
+  @Test
+  public void getBlocking_hasNoCachedValue_blocksOnFileReadAndReturnsFileContainer()
+      throws Exception {
+    when(mockStorageClient.read()).thenReturn(configContainer);
+
+    ConfigContainer container = cacheClient.getBlocking();
+
+    assertThat(container).isEqualTo(configContainer);
+  }
+
+  @Test
+  public void getBlocking_firstTwoFileReadsFail_readsFileAndSetsCacheThreeTimes() throws Exception {
+    doThrow(IO_EXCEPTION).when(mockStorageClient).read();
+    assertThat(cacheClient.getBlocking()).isNull();
+    assertThat(cacheClient.getBlocking()).isNull();
+
+    doReturn(configContainer).when(mockStorageClient).read();
+    for (int getCallIndex = 0; getCallIndex < 5; getCallIndex++) {
+      assertThat(cacheClient.getBlocking()).isEqualTo(configContainer);
+    }
+
+    verify(mockStorageClient, times(3)).read();
+  }
+
+  @Test
+  public void putWithoutWaitingForDiskWrite_fileWriteFails_setsCache() throws Exception {
+    when(mockStorageClient.write(configContainer)).thenThrow(IO_EXCEPTION);
+
+    Task<ConfigContainer> putTask = cacheClient.putWithoutWaitingForDiskWrite(configContainer);
+    assertThrows(ExecutionException.class, () -> Tasks.await(putTask));
+
+    assertThat(putTask.getException()).isEqualTo(IO_EXCEPTION);
+    assertThat(cacheClient.getCachedContainerTask().getResult()).isEqualTo(configContainer);
+  }
+
+  @Test
+  public void putWithoutWaitingForDiskWrite_fileWriteSucceeds_setsCache() throws Exception {
+    ConfigContainer putContainer =
+        Tasks.await(cacheClient.putWithoutWaitingForDiskWrite(configContainer));
+
+    assertThat(putContainer).isEqualTo(configContainer);
+    assertThat(cacheClient.getCachedContainerTask().getResult()).isEqualTo(configContainer);
+  }
+
+  @Test
+  public void clear_hasNoCachedValue_setsCacheContainerToNull() {
+    Preconditions.checkArgument(cacheClient.getCachedContainerTask() == null);
+
+    cacheClient.clear();
+
+    verify(mockStorageClient).clear();
+
+    assertThat(cacheClient.getCachedContainerTask().getResult()).isNull();
+  }
+
+  @Test
+  public void clear_hasCachedValue_setsCacheContainerToNull() throws Exception {
+    Tasks.await(cacheClient.put(configContainer));
+    Preconditions.checkArgument(
+        cacheClient.getCachedContainerTask().getResult().equals(configContainer));
+
+    cacheClient.clear();
+
+    verify(mockStorageClient).clear();
+
+    assertThat(cacheClient.getCachedContainerTask().getResult()).isNull();
+    assertThat(Tasks.await(cacheClient.get())).isNull();
+  }
+
+  @Test
+  public void clear_hasOngoingGetCall_setsCacheContainerToNull() throws Exception {
+    when(mockStorageClient.read()).thenReturn(configContainer);
+    Tasks.call(testingThreadPool, () -> Tasks.await(cacheClient.get()));
+
+    cacheClient.clear();
+
+    verify(mockStorageClient).clear();
+
+    assertThat(cacheClient.getCachedContainerTask().getResult()).isNull();
+    assertThat(Tasks.await(cacheClient.get())).isNull();
+  }
+
+  private void verifyFileWrites(ConfigContainer... containers) throws Exception {
+    int numContainers = containers.length;
+    ArgumentCaptor<ConfigContainer> captor = ArgumentCaptor.forClass(ConfigContainer.class);
+    verify(mockStorageClient, times(numContainers)).write(captor.capture());
+
+    List<ConfigContainer> capturedContainers = captor.getAllValues();
+    for (int i = 0; i < numContainers; i++) {
+      assertThat(capturedContainers.get(i)).isEqualTo(containers[i]);
+    }
+  }
+
+  @After
+  public void cleanUp() {
+    cacheThreadPool.shutdownNow();
+    testingThreadPool.shutdownNow();
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigFetchHandlerTest.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigFetchHandlerTest.java
new file mode 100644
index 000000000..494666026
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigFetchHandlerTest.java
@@ -0,0 +1,967 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.LAST_FETCH_STATUS_FAILURE;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.LAST_FETCH_STATUS_SUCCESS;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.LAST_FETCH_STATUS_THROTTLED;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ExperimentDescriptionFieldKey.EXPERIMENT_ID;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ExperimentDescriptionFieldKey.VARIANT_ID;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ResponseFieldKey.ENTRIES;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ResponseFieldKey.EXPERIMENT_DESCRIPTIONS;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ResponseFieldKey.STATE;
+import static com.google.firebase.remoteconfig.internal.ConfigFetchHandler.BACKOFF_TIME_DURATIONS_IN_MINUTES;
+import static com.google.firebase.remoteconfig.internal.ConfigFetchHandler.DEFAULT_MINIMUM_FETCH_INTERVAL_IN_SECONDS;
+import static com.google.firebase.remoteconfig.internal.ConfigFetchHandler.HTTP_TOO_MANY_REQUESTS;
+import static com.google.firebase.remoteconfig.internal.ConfigMetadataClient.LAST_FETCH_TIME_NO_FETCH_YET;
+import static com.google.firebase.remoteconfig.internal.ConfigMetadataClient.NO_BACKOFF_TIME;
+import static com.google.firebase.remoteconfig.internal.ConfigMetadataClient.NO_FAILED_FETCHES;
+import static com.google.firebase.remoteconfig.testutil.Assert.assertThrows;
+import static java.net.HttpURLConnection.HTTP_BAD_GATEWAY;
+import static java.net.HttpURLConnection.HTTP_FORBIDDEN;
+import static java.net.HttpURLConnection.HTTP_GATEWAY_TIMEOUT;
+import static java.net.HttpURLConnection.HTTP_INTERNAL_ERROR;
+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;
+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static java.net.HttpURLConnection.HTTP_UNAVAILABLE;
+import static java.util.concurrent.TimeUnit.HOURS;
+import static java.util.concurrent.TimeUnit.MINUTES;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import androidx.annotation.Nullable;
+import com.google.android.gms.common.util.MockClock;
+import com.google.android.gms.tasks.Task;
+import com.google.android.gms.tasks.Tasks;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigClientException;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigFetchThrottledException;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigServerException;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigSettings;
+import com.google.firebase.remoteconfig.internal.ConfigFetchHandler.FetchResponse;
+import com.google.firebase.remoteconfig.internal.ConfigMetadataClient.BackoffMetadata;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.Executor;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.skyscreamer.jsonassert.JSONAssert;
+
+/**
+ * Unit tests for the Firebase Remote Config (FRC) Fetch handler.
+ *
+ * @author Miraziz Yusupov
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ConfigFetchHandlerTest {
+  private static final String INSTANCE_ID_STRING = "fake instance id";
+  private static final String INSTANCE_ID_TOKEN_STRING = "fake instance id token";
+  private static final long DEFAULT_CACHE_EXPIRATION_IN_MILLISECONDS =
+      SECONDS.toMillis(DEFAULT_MINIMUM_FETCH_INTERVAL_IN_SECONDS);
+
+  private static final Date FIRST_FETCH_TIME = new Date(HOURS.toMillis(1L));
+  private static final Date SECOND_FETCH_TIME = new Date(HOURS.toMillis(12L));
+
+  private Executor directExecutor;
+  private MockClock mockClock;
+  @Mock private Random mockRandom;
+  @Mock private ConfigCacheClient mockFetchedCache;
+
+  @Mock private ConfigFetchHttpClient mockBackendFetchApiClient;
+
+  private Context context;
+  @Mock private FirebaseInstanceId mockFirebaseInstanceId;
+  private ConfigMetadataClient metadataClient;
+
+  private ConfigFetchHandler fetchHandler;
+
+  private ConfigContainer firstFetchedContainer;
+  private ConfigContainer secondFetchedContainer;
+  private String responseETag = "";
+
+  @Before
+  public void setUp() throws Exception {
+    MockitoAnnotations.initMocks(this);
+
+    directExecutor = MoreExecutors.directExecutor();
+    context = RuntimeEnvironment.application.getApplicationContext();
+    mockClock = new MockClock(0L);
+    metadataClient =
+        new ConfigMetadataClient(context.getSharedPreferences("test_file", Context.MODE_PRIVATE));
+
+    loadBackendApiClient();
+    loadInstanceIdAndToken();
+
+    /*
+     * Every fetch starts with a call to retrieve the cached fetch values. Return successfully in
+     * the base case.
+     */
+    when(mockFetchedCache.get()).thenReturn(Tasks.forResult(null));
+
+    // Assume there is no analytics SDK for most of the tests.
+    fetchHandler = getNewFetchHandler(/*analyticsConnector=*/ null);
+
+    firstFetchedContainer =
+        ConfigContainer.newBuilder()
+            .replaceConfigsWith(
+                new JSONObject(ImmutableMap.of("string_param", "string_value", "long_param", "1L")))
+            .withFetchTime(FIRST_FETCH_TIME)
+            .build();
+
+    secondFetchedContainer =
+        ConfigContainer.newBuilder()
+            .replaceConfigsWith(
+                new JSONObject(
+                    ImmutableMap.of("string_param", "string_value", "double_param", "0.1")))
+            .withFetchTime(SECOND_FETCH_TIME)
+            .build();
+  }
+
+  @Test
+  public void fetch_noPreviousSuccessfulFetch_fetchesFromBackend() throws Exception {
+    fetchCallToHttpClientReturnsConfigWithCurrentTime(secondFetchedContainer);
+
+    assertWithMessage("Fetch() failed for first fetch!")
+        .that(fetchHandler.fetch().isSuccessful())
+        .isTrue();
+
+    verifyBackendIsCalled();
+  }
+
+  @Test
+  public void fetch_cacheHasNotExpired_doesNotFetchFromBackend() throws Exception {
+    loadCacheAndClockWithConfig(mockFetchedCache, firstFetchedContainer);
+
+    // Don't wait long enough for cache to expire.
+    mockClock.advance(DEFAULT_CACHE_EXPIRATION_IN_MILLISECONDS - 1);
+
+    assertWithMessage("Fetch() failed even though cache has not expired!")
+        .that(fetchHandler.fetch().isSuccessful())
+        .isTrue();
+
+    verifyBackendIsNeverCalled();
+  }
+
+  @Test
+  public void fetch_cacheHasNotExpiredAndEmptyFetchCache_doesNotFetchFromBackend()
+      throws Exception {
+    simulateFetchAndActivate(mockFetchedCache, firstFetchedContainer);
+
+    // Don't wait long enough for cache to expire.
+    mockClock.advance(DEFAULT_CACHE_EXPIRATION_IN_MILLISECONDS - 1);
+
+    assertWithMessage("Fetch() failed even though cache has not expired!")
+        .that(fetchHandler.fetch().isSuccessful())
+        .isTrue();
+
+    verifyBackendIsNeverCalled();
+  }
+
+  @Test
+  public void fetch_cacheHasExpired_fetchesFromBackend() throws Exception {
+    loadCacheAndClockWithConfig(mockFetchedCache, firstFetchedContainer);
+
+    // Wait long enough for cache to expire.
+    mockClock.advance(DEFAULT_CACHE_EXPIRATION_IN_MILLISECONDS);
+    fetchCallToHttpClientReturnsConfigWithCurrentTime(secondFetchedContainer);
+
+    assertWithMessage("Fetch() failed after cache expired!")
+        .that(fetchHandler.fetch().isSuccessful())
+        .isTrue();
+
+    verifyBackendIsCalled();
+  }
+
+  @Test
+  public void fetch_cacheHasExpiredAndEmptyFetchCache_fetchesFromBackend() throws Exception {
+    simulateFetchAndActivate(mockFetchedCache, firstFetchedContainer);
+
+    // Wait long enough for cache to expire.
+    mockClock.advance(DEFAULT_CACHE_EXPIRATION_IN_MILLISECONDS);
+    fetchCallToHttpClientReturnsConfigWithCurrentTime(secondFetchedContainer);
+
+    assertWithMessage("Fetch() failed after cache expired!")
+        .that(fetchHandler.fetch().isSuccessful())
+        .isTrue();
+
+    verifyBackendIsCalled();
+  }
+
+  @Test
+  public void fetch_userSetMinimumFetchIntervalHasPassed_fetchesFromBackend() throws Exception {
+    long minimumFetchIntervalInSeconds = 600L;
+    setMinimumFetchIntervalInMetadata(minimumFetchIntervalInSeconds);
+
+    simulateFetchAndActivate(mockFetchedCache, firstFetchedContainer);
+    // Wait long enough for cache to expire.
+    mockClock.advance(SECONDS.toMillis(minimumFetchIntervalInSeconds));
+
+    fetchCallToHttpClientReturnsConfigWithCurrentTime(secondFetchedContainer);
+    assertWithMessage("Fetch() failed after cache expired!")
+        .that(fetchHandler.fetch().isSuccessful())
+        .isTrue();
+
+    verifyBackendIsCalled();
+  }
+
+  @Test
+  public void fetch_userSetMinimumFetchIntervalHasNotPassed_doesNotFetchFromBackend()
+      throws Exception {
+    long minimumFetchIntervalInSeconds = 600L;
+    setMinimumFetchIntervalInMetadata(minimumFetchIntervalInSeconds);
+
+    loadCacheAndClockWithConfig(mockFetchedCache, firstFetchedContainer);
+    // Don't wait long enough for cache to expire.
+    mockClock.advance(SECONDS.toMillis(minimumFetchIntervalInSeconds) - 1);
+
+    assertWithMessage("Fetch() failed even though cache has not expired!")
+        .that(fetchHandler.fetch().isSuccessful())
+        .isTrue();
+
+    verifyBackendIsNeverCalled();
+  }
+
+  @Test
+  public void fetchWithExpiration_noPreviousSuccessfulFetch_fetchesFromBackend() throws Exception {
+    // Wait long enough for cache to expire.
+    long cacheExpirationInHours = 1;
+    fetchCallToHttpClientReturnsConfigWithCurrentTime(secondFetchedContainer);
+
+    assertWithMessage("Fetch() failed for first fetch!")
+        .that(fetchHandler.fetch(HOURS.toSeconds(cacheExpirationInHours)).isSuccessful())
+        .isTrue();
+
+    verifyBackendIsCalled();
+  }
+
+  @Test
+  public void fetchWithExpiration_cacheHasNotExpired_doesNotFetchFromBackend() throws Exception {
+    loadCacheAndClockWithConfig(mockFetchedCache, firstFetchedContainer);
+
+    // Don't wait long enough for cache to expire.
+    long cacheExpirationInHours = 1;
+    mockClock.advance(HOURS.toMillis(cacheExpirationInHours) - 1);
+
+    assertWithMessage("Fetch() failed even though cache has not expired!")
+        .that(fetchHandler.fetch(HOURS.toSeconds(cacheExpirationInHours)).isSuccessful())
+        .isTrue();
+
+    verifyBackendIsNeverCalled();
+  }
+
+  @Test
+  public void fetchWithExpiration_cacheHasNotExpiredAndEmptyFetchCache_doesNotFetchFromBackend()
+      throws Exception {
+    simulateFetchAndActivate(mockFetchedCache, firstFetchedContainer);
+
+    // Don't wait long enough for cache to expire.
+    long cacheExpirationInHours = 1;
+    mockClock.advance(HOURS.toMillis(cacheExpirationInHours) - 1);
+
+    assertWithMessage("Fetch() failed even though cache has not expired!")
+        .that(fetchHandler.fetch(HOURS.toSeconds(cacheExpirationInHours)).isSuccessful())
+        .isTrue();
+    verifyBackendIsNeverCalled();
+  }
+
+  @Test
+  public void fetchWithExpiration_cacheHasExpired_fetchesFromBackend() throws Exception {
+    loadCacheAndClockWithConfig(mockFetchedCache, firstFetchedContainer);
+
+    // Wait long enough for cache to expire.
+    long cacheExpirationInHours = 1;
+    mockClock.advance(HOURS.toMillis(cacheExpirationInHours));
+    fetchCallToHttpClientReturnsConfigWithCurrentTime(secondFetchedContainer);
+
+    assertWithMessage("Fetch() failed after cache expired!")
+        .that(fetchHandler.fetch(HOURS.toSeconds(cacheExpirationInHours)).isSuccessful())
+        .isTrue();
+
+    verifyBackendIsCalled();
+  }
+
+  @Test
+  public void fetchWithExpiration_cacheHasExpiredAndEmptyFetchCache_fetchesFromBackend()
+      throws Exception {
+    simulateFetchAndActivate(mockFetchedCache, firstFetchedContainer);
+
+    // Wait long enough for cache to expire.
+    long cacheExpirationInHours = 1;
+    mockClock.advance(HOURS.toMillis(cacheExpirationInHours));
+    fetchCallToHttpClientReturnsConfigWithCurrentTime(secondFetchedContainer);
+
+    assertWithMessage("Fetch() failed after cache expired!")
+        .that(fetchHandler.fetch(HOURS.toSeconds(cacheExpirationInHours)).isSuccessful())
+        .isTrue();
+
+    verifyBackendIsCalled();
+  }
+
+  @Test
+  public void fetch_gettingFetchCacheFails_doesNotThrowException() throws Exception {
+    when(mockFetchedCache.get())
+        .thenReturn(Tasks.forException(new IOException("Disk read failed.")));
+
+    fetchCallToHttpClientUpdatesClockAndReturnsConfig(firstFetchedContainer);
+
+    assertWithMessage("Fetch() failed when fetch cache could not be read!")
+        .that(fetchHandler.fetch().isSuccessful())
+        .isTrue();
+  }
+
+  @Test
+  public void fetch_fetchBackendCallFails_taskThrowsException() throws Exception {
+    when(mockBackendFetchApiClient.fetch(any(), any(), any(), any(), any(), any(), any()))
+        .thenThrow(
+            new FirebaseRemoteConfigClientException("Fetch failed due to an unexpected error."));
+
+    Task<FetchResponse> fetchTask = fetchHandler.fetch();
+
+    assertThrowsClientException(fetchTask, "unexpected error");
+  }
+
+  @Test
+  public void fetch_noChangeSinceLastFetch_doesNotUpdateCache() throws Exception {
+    setBackendResponseToNoChange(new Date(mockClock.currentTimeMillis()));
+
+    assertWithMessage("Fetch() failed after no changes were returned from backend!")
+        .that(fetchHandler.fetch().isSuccessful())
+        .isTrue();
+
+    verify(mockFetchedCache, never()).put(any());
+  }
+
+  @Test
+  public void fetch_fetchedCachePutFails_taskThrowsException() throws Exception {
+    IOException expectedException = new IOException("Network call failed.");
+    setBackendResponseConfigsTo(firstFetchedContainer);
+    when(mockFetchedCache.put(any())).thenReturn(Tasks.forException(expectedException));
+
+    Task<FetchResponse> fetchTask = fetchHandler.fetch();
+
+    IOException actualException =
+        assertThrows(IOException.class, () -> fetchTask.getResult(IOException.class));
+    assertThat(actualException).isEqualTo(expectedException);
+  }
+
+  @Test
+  public void fetch_HasNoErrors_everythingWorks() throws Exception {
+    fetchCallToHttpClientUpdatesClockAndReturnsConfig(firstFetchedContainer);
+
+    assertWithMessage("Fetch() failed!").that(fetchHandler.fetch().isSuccessful()).isTrue();
+
+    verify(mockFetchedCache).put(firstFetchedContainer);
+  }
+
+  @Test
+  public void fetch_HasETag_sendsETagAndSavesResponseETag() throws Exception {
+    String requestETag = "Request eTag";
+    String responseETag = "Response eTag";
+    loadETags(requestETag, responseETag);
+    fetchCallToHttpClientUpdatesClockAndReturnsConfig(firstFetchedContainer);
+
+    assertWithMessage("Fetch() failed!").that(fetchHandler.fetch().isSuccessful()).isTrue();
+
+    verifyETags(requestETag, responseETag);
+  }
+
+  @Test
+  public void fetch_HasNoETag_doesNotSendETagAndSavesResponseETag() throws Exception {
+    String responseETag = "Response eTag";
+    loadETags(/*requestETag=*/ null, responseETag);
+    fetchCallToHttpClientUpdatesClockAndReturnsConfig(firstFetchedContainer);
+
+    assertWithMessage("Fetch() failed!").that(fetchHandler.fetch().isSuccessful()).isTrue();
+
+    verifyETags(/*requestETag=*/ null, responseETag);
+  }
+
+  @Test
+  public void fetch_hasAbtExperiments_storesExperiments() throws Exception {
+    ConfigContainer containerWithExperiments =
+        ConfigContainer.newBuilder(firstFetchedContainer)
+            .withAbtExperiments(generateAbtExperiments(/*numExperiments=*/ 5))
+            .build();
+    ArgumentCaptor<ConfigContainer> captor = ArgumentCaptor.forClass(ConfigContainer.class);
+
+    fetchCallToHttpClientUpdatesClockAndReturnsConfig(containerWithExperiments);
+    fetchHandler.fetch();
+
+    verify(mockFetchedCache).put(captor.capture());
+
+    JSONAssert.assertEquals(
+        containerWithExperiments.toString(), captor.getValue().toString(), false);
+  }
+
+  @Test
+  public void fetch_getsThrottledResponseFromServer_backsOffOnSecondCall() throws Exception {
+    fetchCallToBackendThrowsException(HTTP_TOO_MANY_REQUESTS);
+    long backoffDurationInMillis = loadAndGetNextBackoffDuration(/*numFailedFetches=*/ 1);
+
+    FirebaseRemoteConfigFetchThrottledException actualException =
+        getThrottledException(fetchHandler.fetch(/*minimumFetchIntervalInSeconds=*/ 0L));
+
+    assertThat(actualException.getThrottleEndTimeMillis())
+        .isEqualTo(mockClock.currentTimeMillis() + backoffDurationInMillis);
+  }
+
+  @Test
+  public void fetch_getsMultipleThrottledResponsesFromServer_exponentiallyBacksOff()
+      throws Exception {
+    for (int numFetch = 1; numFetch <= BACKOFF_TIME_DURATIONS_IN_MINUTES.length; numFetch++) {
+      fetchCallToBackendThrowsException(HTTP_TOO_MANY_REQUESTS);
+      long backoffDurationInMillis = loadAndGetNextBackoffDuration(numFetch);
+
+      assertThrowsThrottledException(
+          fetchHandler.fetch(/*minimumFetchIntervalInSeconds=*/ 0L),
+          mockClock.currentTimeMillis() + backoffDurationInMillis);
+
+      // Wait long enough for throttling to clear.
+      mockClock.advance(backoffDurationInMillis);
+    }
+  }
+
+  @Test
+  public void fetch_getsMultipleFailedResponsesFromServer_resetsBackoffAfterSuccessfulFetch()
+      throws Exception {
+    callFetchAssertThrottledAndAdvanceClock(HTTP_TOO_MANY_REQUESTS);
+    callFetchAssertThrottledAndAdvanceClock(HTTP_BAD_GATEWAY);
+    callFetchAssertThrottledAndAdvanceClock(HTTP_UNAVAILABLE);
+    callFetchAssertThrottledAndAdvanceClock(HTTP_GATEWAY_TIMEOUT);
+
+    fetchCallToHttpClientReturnsConfigWithCurrentTime(firstFetchedContainer);
+
+    Task<FetchResponse> fetchTask = fetchHandler.fetch(/*minimumFetchIntervalInSeconds=*/ 0L);
+
+    assertWithMessage("Fetch() failed!").that(fetchTask.isSuccessful()).isTrue();
+
+    BackoffMetadata backoffMetadata = metadataClient.getBackoffMetadata();
+    assertThat(backoffMetadata.getNumFailedFetches()).isEqualTo(NO_FAILED_FETCHES);
+    assertThat(backoffMetadata.getBackoffEndTime()).isEqualTo(NO_BACKOFF_TIME);
+  }
+
+  @Test
+  public void getRandomizedBackoffDuration_callOverMaxTimes_returnsUpToMaxInterval()
+      throws Exception {
+    int backoffDurationsLength = BACKOFF_TIME_DURATIONS_IN_MINUTES.length;
+    for (int numFetch = 1; numFetch <= backoffDurationsLength + 2; numFetch++) {
+      long backoffDurationInterval =
+          MINUTES.toMillis(
+              BACKOFF_TIME_DURATIONS_IN_MINUTES[Math.min(numFetch, backoffDurationsLength) - 1]);
+
+      fetchCallToBackendThrowsException(HTTP_TOO_MANY_REQUESTS);
+      when(mockRandom.nextInt((int) backoffDurationInterval))
+          .thenReturn(new Random().nextInt((int) backoffDurationInterval));
+
+      FirebaseRemoteConfigFetchThrottledException actualException =
+          getThrottledException(fetchHandler.fetch(/*minimumFetchIntervalInSeconds=*/ 0L));
+
+      long actualBackoffDuration =
+          actualException.getThrottleEndTimeMillis() - mockClock.currentTimeMillis();
+      assertThat(actualBackoffDuration)
+          .isAtLeast(backoffDurationInterval - backoffDurationInterval / 2);
+      assertThat(actualBackoffDuration)
+          .isLessThan(backoffDurationInterval + backoffDurationInterval / 2);
+
+      // Wait long enough for throttling to clear.
+      mockClock.advance(actualBackoffDuration);
+    }
+  }
+
+  @Test
+  public void fetch_serverReturnsUnauthorizedCode_throwsServerUnauthenticatedException()
+      throws Exception {
+    // The 401 HTTP Code is mapped from UNAUTHENTICATED in the gRPC world.
+    fetchCallToBackendThrowsException(HTTP_UNAUTHORIZED);
+
+    assertThrowsServerException(
+        fetchHandler.fetch(), HTTP_UNAUTHORIZED, "did not have the required credentials");
+  }
+
+  @Test
+  public void fetch_serverReturnsForbiddenCode_throwsServerUnauthorizedException()
+      throws Exception {
+    fetchCallToBackendThrowsException(HTTP_FORBIDDEN);
+
+    assertThrowsServerException(fetchHandler.fetch(), HTTP_FORBIDDEN, "is not authorized");
+  }
+
+  @Test
+  public void fetch_serverReturnsBadGatewayCode_throwsServerUnavailableException()
+      throws Exception {
+    fetchCallToBackendThrowsException(HTTP_BAD_GATEWAY);
+
+    Task<FetchResponse> fetchTask = fetchHandler.fetch();
+
+    assertThrowsServerException(fetchTask, HTTP_BAD_GATEWAY, "unavailable");
+  }
+
+  @Test
+  public void fetch_serverReturnsUnavailableCode_throwsServerUnavailableException()
+      throws Exception {
+    fetchCallToBackendThrowsException(HTTP_UNAVAILABLE);
+
+    Task<FetchResponse> fetchTask = fetchHandler.fetch();
+
+    assertThrowsServerException(fetchTask, HTTP_UNAVAILABLE, "unavailable");
+  }
+
+  @Test
+  public void fetch_serverReturnsGatewayTimeoutCode_throwsServerUnavailableException()
+      throws Exception {
+    fetchCallToBackendThrowsException(HTTP_GATEWAY_TIMEOUT);
+
+    Task<FetchResponse> fetchTask = fetchHandler.fetch();
+
+    assertThrowsServerException(fetchTask, HTTP_GATEWAY_TIMEOUT, "unavailable");
+  }
+
+  @Test
+  public void fetch_serverReturnsThrottleableErrorTwice_throwsThrottledException()
+      throws Exception {
+    fetchCallToBackendThrowsException(HTTP_UNAVAILABLE);
+    fetchHandler.fetch();
+
+    fetchCallToBackendThrowsException(HTTP_UNAVAILABLE);
+
+    Task<FetchResponse> fetchTask = fetchHandler.fetch();
+
+    assertThrowsThrottledException(fetchTask);
+  }
+
+  @Test
+  public void fetch_serverReturnsInternalErrorCode_throwsServerInternalException()
+      throws Exception {
+    fetchCallToBackendThrowsException(HTTP_INTERNAL_ERROR);
+
+    assertThrowsServerException(fetchHandler.fetch(), HTTP_INTERNAL_ERROR, "internal server error");
+  }
+
+  @Test
+  public void fetch_serverReturnsUnexpectedCode_throwsServerException() throws Exception {
+    fetchCallToBackendThrowsException(HTTP_NOT_FOUND);
+
+    assertThrowsServerException(fetchHandler.fetch(), HTTP_NOT_FOUND, "unexpected error");
+  }
+
+  @Test
+  public void fetch_hasAnalyticsSdk_sendsUserProperties() throws Exception {
+    // Provide the mock Analytics SDK.
+    AnalyticsConnector mockAnalyticsConnector = mock(AnalyticsConnector.class);
+    fetchHandler = getNewFetchHandler(mockAnalyticsConnector);
+
+    Map<String, String> userProperties =
+        ImmutableMap.of("up_key1", "up_val1", "up_key2", "up_val2");
+    when(mockAnalyticsConnector.getUserProperties(/*includeInternal=*/ false))
+        .thenReturn(ImmutableMap.copyOf(userProperties));
+
+    fetchCallToHttpClientUpdatesClockAndReturnsConfig(firstFetchedContainer);
+
+    assertWithMessage("Fetch() failed!").that(fetchHandler.fetch().isSuccessful()).isTrue();
+
+    verifyBackendIsCalled(userProperties);
+  }
+
+  @Test
+  public void fetch_firstAndOnlyFetchFails_metadataFailStatusAndNoFetchYetTime() throws Exception {
+    fetchCallToBackendThrowsException(HTTP_NOT_FOUND);
+
+    fetchHandler.fetch();
+
+    assertThat(metadataClient.getLastFetchStatus()).isEqualTo(LAST_FETCH_STATUS_FAILURE);
+    assertThat(metadataClient.getLastSuccessfulFetchTime()).isEqualTo(LAST_FETCH_TIME_NO_FETCH_YET);
+  }
+
+  @Test
+  public void fetch_fetchSucceeds_metadataSuccessStatusAndFetchTimeUpdated() throws Exception {
+    fetchCallToHttpClientUpdatesClockAndReturnsConfig(firstFetchedContainer);
+
+    fetchHandler.fetch();
+
+    assertThat(metadataClient.getLastFetchStatus()).isEqualTo(LAST_FETCH_STATUS_SUCCESS);
+    assertThat(metadataClient.getLastSuccessfulFetchTime())
+        .isEqualTo(firstFetchedContainer.getFetchTime());
+  }
+
+  @Test
+  public void fetch_firstFetchSucceedsSecondFetchFails_failStatusAndFirstFetchTime()
+      throws Exception {
+    fetchCallToHttpClientUpdatesClockAndReturnsConfig(firstFetchedContainer);
+    fetchHandler.fetch();
+
+    fetchCallToBackendThrowsException(HTTP_NOT_FOUND);
+
+    fetchHandler.fetch(/*minimumFetchIntervalInSeconds=*/ 0);
+
+    assertThat(metadataClient.getLastFetchStatus()).isEqualTo(LAST_FETCH_STATUS_FAILURE);
+    assertThat(metadataClient.getLastSuccessfulFetchTime())
+        .isEqualTo(firstFetchedContainer.getFetchTime());
+  }
+
+  @Test
+  public void getInfo_twoFetchesSucceed_successStatusAndSecondFetchTime() throws Exception {
+    fetchCallToHttpClientUpdatesClockAndReturnsConfig(firstFetchedContainer);
+    fetchHandler.fetch();
+
+    fetchCallToHttpClientUpdatesClockAndReturnsConfig(secondFetchedContainer);
+
+    fetchHandler.fetch(/*minimumFetchIntervalInSeconds=*/ 0);
+
+    assertThat(metadataClient.getLastFetchStatus()).isEqualTo(LAST_FETCH_STATUS_SUCCESS);
+    assertThat(metadataClient.getLastSuccessfulFetchTime())
+        .isEqualTo(secondFetchedContainer.getFetchTime());
+  }
+
+  @Test
+  public void getInfo_hitsThrottleLimit_throttledStatus() throws Exception {
+    fetchCallToHttpClientUpdatesClockAndReturnsConfig(firstFetchedContainer);
+    fetchHandler.fetch();
+
+    fetchCallToBackendThrowsException(HTTP_TOO_MANY_REQUESTS);
+
+    fetchHandler.fetch(/*minimumFetchIntervalInSeconds=*/ 0);
+
+    assertThat(metadataClient.getLastFetchStatus()).isEqualTo(LAST_FETCH_STATUS_THROTTLED);
+    assertThat(metadataClient.getLastSuccessfulFetchTime())
+        .isEqualTo(firstFetchedContainer.getFetchTime());
+  }
+
+  private ConfigFetchHandler getNewFetchHandler(AnalyticsConnector analyticsConnector) {
+    ConfigFetchHandler fetchHandler =
+        spy(
+            new ConfigFetchHandler(
+                mockFirebaseInstanceId,
+                analyticsConnector,
+                directExecutor,
+                mockClock,
+                mockRandom,
+                mockFetchedCache,
+                mockBackendFetchApiClient,
+                metadataClient,
+                /* customHttpHeaders= */ ImmutableMap.of()));
+    return fetchHandler;
+  }
+
+  private void setBackendResponseConfigsTo(ConfigContainer container) throws Exception {
+    Map<String, String> configEntries = new HashMap<>();
+
+    Iterator<String> keyIt = container.getConfigs().keys();
+    while (keyIt.hasNext()) {
+      String key = keyIt.next();
+      configEntries.put(key, container.getConfigs().getString(key));
+    }
+
+    JSONArray experiments = container.getAbtExperiments();
+
+    doReturn(
+            toFetchResponse(
+                "UPDATE",
+                new JSONObject(configEntries),
+                experiments,
+                responseETag,
+                container.getFetchTime()))
+        .when(mockBackendFetchApiClient)
+        .fetch(
+            any(HttpURLConnection.class),
+            /* instanceId= */ any(),
+            /* instanceIdToken= */ any(),
+            /* analyticsUserProperties= */ any(),
+            /* lastFetchETag= */ any(),
+            /* customHeaders= */ any(),
+            /* currentTime= */ any());
+  }
+
+  private void setBackendResponseToNoChange(Date date) throws Exception {
+    when(mockBackendFetchApiClient.fetch(
+            any(HttpURLConnection.class),
+            /* instanceId= */ any(),
+            /* instanceIdToken= */ any(),
+            /* analyticsUserProperties= */ any(),
+            /* lastFetchETag= */ any(),
+            /* customHeaders= */ any(),
+            /* currentTime= */ any()))
+        .thenReturn(FetchResponse.forBackendHasNoUpdates(date));
+  }
+
+  private void fetchCallToBackendThrowsException(int httpErrorCode) throws Exception {
+    doThrow(new FirebaseRemoteConfigServerException(httpErrorCode, "Server error"))
+        .when(mockBackendFetchApiClient)
+        .fetch(
+            any(HttpURLConnection.class),
+            /* instanceId= */ any(),
+            /* instanceIdToken= */ any(),
+            /* analyticsUserProperties= */ any(),
+            /* lastFetchETag= */ any(),
+            /* customHeaders= */ any(),
+            /* currentTime= */ any());
+  }
+
+  /**
+   * Sets the {@link ConfigContainer} to be returned by the backend to {@code container}, with the
+   * fetch time set to the current time in {@link #mockClock}.
+   */
+  private void fetchCallToHttpClientReturnsConfigWithCurrentTime(ConfigContainer container)
+      throws Exception {
+    ConfigContainer containerToBeReturned =
+        ConfigContainer.newBuilder(container)
+            .withFetchTime(new Date(mockClock.currentTimeMillis()))
+            .build();
+    setBackendResponseConfigsTo(containerToBeReturned);
+    cachePutReturnsConfig(mockFetchedCache, containerToBeReturned);
+  }
+
+  /**
+   * Sets the {@link ConfigContainer} to be returned by the backend to {@code container}, and
+   * updates {@link #mockClock}'s current time to {@code container}'s {@code fetchTime}.
+   */
+  private void fetchCallToHttpClientUpdatesClockAndReturnsConfig(ConfigContainer container)
+      throws Exception {
+    setBackendResponseConfigsTo(container);
+    cachePutReturnsConfig(mockFetchedCache, container);
+    mockClock.setCurrentTime(container.getFetchTime().getTime());
+  }
+
+  /**
+   * Sets the server error response to {@code httpCode}, calls fetch, asserts that the fetch returns
+   * a throttled exception, and then advances the clock so the next call will not be throttled.
+   *
+   * <p>The first server response is always {@link ConfigFetchHandler#HTTP_TOO_MANY_REQUESTS}.
+   */
+  private void callFetchAssertThrottledAndAdvanceClock(int httpCode) throws Exception {
+    fetchCallToBackendThrowsException(httpCode);
+
+    long backoffDurationInMillis =
+        loadAndGetNextBackoffDuration(
+            /*numFailedFetches=*/ metadataClient.getBackoffMetadata().getNumFailedFetches() + 1);
+
+    assertThrowsThrottledException(fetchHandler.fetch(/*minimumFetchIntervalInSeconds=*/ 0L));
+
+    // Wait long enough for throttling to clear.
+    mockClock.advance(backoffDurationInMillis);
+  }
+
+  private long loadAndGetNextBackoffDuration(int numFailedFetches) {
+    int numOfBackoffDurations = BACKOFF_TIME_DURATIONS_IN_MINUTES.length;
+    int backoffDurationInterval =
+        (int)
+            MINUTES.toMillis(
+                BACKOFF_TIME_DURATIONS_IN_MINUTES[
+                    Math.min(numFailedFetches, numOfBackoffDurations) - 1]);
+
+    // The backoff Duration is equal to "backoffDurationInterval/2 + randomVal", so make randomVal
+    // equal to "backoffDurationInterval/2" to have the actual backoffDuration be
+    // backoffDurationInterval.
+    when(mockRandom.nextInt(backoffDurationInterval)).thenReturn(backoffDurationInterval / 2);
+
+    return backoffDurationInterval;
+  }
+
+  private void setMinimumFetchIntervalInMetadata(long minimumFetchIntervalInSeconds) {
+    metadataClient.setConfigSettings(
+        new FirebaseRemoteConfigSettings.Builder()
+            .setMinimumFetchIntervalInSeconds(minimumFetchIntervalInSeconds)
+            .build());
+  }
+
+  private void verifyBackendIsCalled() throws Exception {
+    verify(mockBackendFetchApiClient)
+        .fetch(
+            any(HttpURLConnection.class),
+            /* instanceId= */ any(),
+            /* instanceIdToken= */ any(),
+            /* analyticsUserProperties= */ any(),
+            /* lastFetchETag= */ any(),
+            /* customHeaders= */ any(),
+            /* currentTime= */ any());
+  }
+
+  private void verifyBackendIsCalled(Map<String, String> userProperties) throws Exception {
+    verify(mockBackendFetchApiClient)
+        .fetch(
+            any(HttpURLConnection.class),
+            /* instanceId= */ any(),
+            /* instanceIdToken= */ any(),
+            /* analyticsUserProperties= */ eq(userProperties),
+            /* lastFetchETag= */ any(),
+            /* customHeaders= */ any(),
+            /* currentTime= */ any());
+  }
+
+  private void verifyBackendIsNeverCalled() throws Exception {
+    verify(mockBackendFetchApiClient, never())
+        .fetch(
+            any(HttpURLConnection.class),
+            /* instanceId= */ any(),
+            /* instanceIdToken= */ any(),
+            /* analyticsUserProperties= */ any(),
+            /* lastFetchETag= */ any(),
+            /* customHeaders= */ any(),
+            /* currentTime= */ any());
+  }
+
+  private void verifyETags(@Nullable String requestETag, String responseETag) throws Exception {
+    verify(mockBackendFetchApiClient)
+        .fetch(
+            any(HttpURLConnection.class),
+            /* instanceId= */ any(),
+            /* instanceIdToken= */ any(),
+            /* analyticsUserProperties= */ any(),
+            /* lastFetchETag= */ eq(requestETag),
+            /* customHeaders= */ any(),
+            /* currentTime= */ any());
+    assertThat(metadataClient.getLastFetchETag()).isEqualTo(responseETag);
+  }
+
+  private void loadBackendApiClient() throws Exception {
+    when(mockBackendFetchApiClient.createHttpURLConnection())
+        .thenReturn(new FakeHttpURLConnection(new URL("https://firebase.google.com")));
+  }
+
+  private void loadETags(String requestETag, String responseETag) {
+    metadataClient.setLastFetchETag(requestETag);
+    this.responseETag = responseETag;
+  }
+
+  private void loadInstanceIdAndToken() {
+    when(mockFirebaseInstanceId.getId()).thenReturn(INSTANCE_ID_STRING);
+    when(mockFirebaseInstanceId.getToken()).thenReturn(INSTANCE_ID_TOKEN_STRING);
+  }
+
+  private void loadCacheAndClockWithConfig(
+      ConfigCacheClient cacheClient, ConfigContainer container) {
+    when(cacheClient.getBlocking()).thenReturn(container);
+    when(cacheClient.get()).thenReturn(Tasks.forResult(container));
+    mockClock.setCurrentTime(container.getFetchTime().getTime());
+    metadataClient.updateLastFetchAsSuccessfulAt(container.getFetchTime());
+  }
+
+  private static void cachePutReturnsConfig(
+      ConfigCacheClient cacheClient, ConfigContainer container) {
+    when(cacheClient.put(container)).thenReturn(Tasks.forResult(container));
+  }
+
+  private void simulateFetchAndActivate(ConfigCacheClient cacheClient, ConfigContainer container) {
+    loadCacheAndClockWithConfig(cacheClient, container);
+    // During a successful activateFetched() call, the fetch cache is cleared.
+    when(cacheClient.getBlocking()).thenReturn(container);
+    when(cacheClient.get()).thenReturn(Tasks.forResult(null));
+  }
+
+  private static FirebaseRemoteConfigFetchThrottledException getThrottledException(
+      Task<FetchResponse> fetchTask) {
+    return assertThrows(
+        FirebaseRemoteConfigFetchThrottledException.class,
+        () -> fetchTask.getResult(FirebaseRemoteConfigFetchThrottledException.class));
+  }
+
+  private static void assertThrowsClientException(Task<FetchResponse> fetchTask, String message) {
+    FirebaseRemoteConfigClientException frcException =
+        assertThrows(
+            FirebaseRemoteConfigClientException.class,
+            () -> fetchTask.getResult(FirebaseRemoteConfigClientException.class));
+
+    assertThat(frcException).hasMessageThat().contains(message);
+  }
+
+  private void assertThrowsThrottledException(Task<FetchResponse> fetchTask) {
+    assertThrows(
+        FirebaseRemoteConfigFetchThrottledException.class,
+        () -> fetchTask.getResult(FirebaseRemoteConfigFetchThrottledException.class));
+  }
+
+  private void assertThrowsThrottledException(
+      Task<FetchResponse> fetchTask, long backoffEndTimeInMillis) {
+    FirebaseRemoteConfigFetchThrottledException actualException = getThrottledException(fetchTask);
+    assertThat(actualException.getThrottleEndTimeMillis()).isEqualTo(backoffEndTimeInMillis);
+  }
+
+  private static void assertThrowsServerException(
+      Task<FetchResponse> fetchTask, int httpStatusCode, @Nullable String httpStatusMessage) {
+    FirebaseRemoteConfigServerException frcException =
+        assertThrows(
+            FirebaseRemoteConfigServerException.class,
+            () -> fetchTask.getResult(FirebaseRemoteConfigServerException.class));
+
+    if (httpStatusMessage != null) {
+      assertThat(frcException.getHttpStatusCode()).isEqualTo(httpStatusCode);
+      assertThat(frcException).hasMessageThat().contains(httpStatusMessage);
+    }
+  }
+
+  private static JSONArray generateAbtExperiments(int numExperiments) throws JSONException {
+    JSONArray experiments = new JSONArray();
+    for (int experimentNum = 1; experimentNum <= numExperiments; experimentNum++) {
+      experiments.put(
+          new JSONObject().put(EXPERIMENT_ID, "exp" + experimentNum).put(VARIANT_ID, "var1"));
+    }
+    return experiments;
+  }
+
+  private static FetchResponse toFetchResponse(
+      String status, JSONObject entries, JSONArray experiments, String eTag, Date currentTime)
+      throws Exception {
+    JSONObject fetchResponse = new JSONObject();
+    fetchResponse.put(STATE, status);
+    fetchResponse.put(ENTRIES, entries);
+    fetchResponse.put(EXPERIMENT_DESCRIPTIONS, experiments);
+    ConfigContainer fetchedConfigs = extractConfigs(fetchResponse, currentTime);
+    return FetchResponse.forBackendUpdatesFetched(fetchedConfigs, eTag);
+  }
+
+  private static ConfigContainer extractConfigs(JSONObject fetchResponse, Date fetchTime)
+      throws Exception {
+    ConfigContainer.Builder containerBuilder =
+        ConfigContainer.newBuilder().withFetchTime(fetchTime);
+
+    JSONObject entries = fetchResponse.getJSONObject(ENTRIES);
+    containerBuilder.replaceConfigsWith(entries);
+
+    JSONArray experimentDescriptions = fetchResponse.getJSONArray(EXPERIMENT_DESCRIPTIONS);
+    containerBuilder.withAbtExperiments(experimentDescriptions);
+
+    return containerBuilder.build();
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigFetchHttpClientTest.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigFetchHttpClientTest.java
new file mode 100644
index 000000000..f9fbb18f1
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigFetchHttpClientTest.java
@@ -0,0 +1,324 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ExperimentDescriptionFieldKey.EXPERIMENT_ID;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ExperimentDescriptionFieldKey.VARIANT_ID;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.FETCH_REGEX_URL;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.ANALYTICS_USER_PROPERTIES;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.APP_ID;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.COUNTRY_CODE;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.INSTANCE_ID;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.INSTANCE_ID_TOKEN;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.LANGUAGE_CODE;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.PACKAGE_NAME;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.PLATFORM_VERSION;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.SDK_VERSION;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.RequestFieldKey.TIME_ZONE;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ResponseFieldKey.ENTRIES;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ResponseFieldKey.EXPERIMENT_DESCRIPTIONS;
+import static com.google.firebase.remoteconfig.RemoteConfigConstants.ResponseFieldKey.STATE;
+import static com.google.firebase.remoteconfig.testutil.Assert.assertThrows;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.content.Context;
+import com.google.android.gms.common.util.MockClock;
+import com.google.common.base.Charsets;
+import com.google.common.collect.ImmutableMap;
+import com.google.firebase.remoteconfig.BuildConfig;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigClientException;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigException;
+import com.google.firebase.remoteconfig.RemoteConfigComponent;
+import com.google.firebase.remoteconfig.internal.ConfigFetchHandler.FetchResponse;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TimeZone;
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for the {@link ConfigFetchHttpClient}.
+ *
+ * @author Lucas Png
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ConfigFetchHttpClientTest {
+  private static final String API_KEY = "fake_api_key";
+  private static final String FAKE_APP_ID = "1:14368190084:android:09cb977358c6f241";
+  private static final String PROJECT_NUMBER = "14368190084";
+  private static final String INSTANCE_ID_STRING = "fake instance id";
+  private static final String INSTANCE_ID_TOKEN_STRING = "fake instance id token";
+  private static final String DEFAULT_NAMESPACE = RemoteConfigComponent.DEFAULT_NAMESPACE;
+  private static final String ETAG_FORMAT =
+      "etag-" + PROJECT_NUMBER + "-" + DEFAULT_NAMESPACE + "-fetch-%d";
+  private static final String FIRST_ETAG = String.format(ETAG_FORMAT, 1);
+  private static final String SECOND_ETAG = String.format(ETAG_FORMAT, 2);
+
+  private Context context;
+  private ConfigFetchHttpClient configFetchHttpClient;
+  private JSONObject hasChangeResponseBody;
+  private JSONObject noChangeResponseBody;
+  private FakeHttpURLConnection fakeHttpURLConnection;
+
+  private MockClock mockClock;
+
+  @Before
+  public void setUp() throws Exception {
+    initMocks(this);
+    context = RuntimeEnvironment.application;
+    configFetchHttpClient =
+        new ConfigFetchHttpClient(
+            context,
+            FAKE_APP_ID,
+            API_KEY,
+            DEFAULT_NAMESPACE,
+            /* connectTimeoutInSeconds= */ 10L,
+            /* readTimeoutInSeconds= */ 10L);
+
+    hasChangeResponseBody =
+        new JSONObject()
+            .put(STATE, "UPDATE")
+            .put(
+                ENTRIES,
+                new JSONObject()
+                    .put("key_1", "value_1")
+                    .put("key2", "value_2")
+                    .put("key_emoji", "\uD83C\uDDFA\uD83C\uDDF3"))
+            .put(
+                EXPERIMENT_DESCRIPTIONS,
+                new JSONArray()
+                    .put(
+                        new JSONObject()
+                            .put(EXPERIMENT_ID, "Experiment1")
+                            .put(VARIANT_ID, "variant_1")
+                            .put("trigger_event", "event_trigger_1")
+                            .put("experiment_start_time", "2017-10-30T21:46:40Z")
+                            .put("trigger_timeout", "15552000s")
+                            .put("time_to_live", "7776000s")));
+    noChangeResponseBody = new JSONObject().put(STATE, "NO_CHANGE");
+
+    fakeHttpURLConnection =
+        new FakeHttpURLConnection(
+            new URL(String.format(FETCH_REGEX_URL, PROJECT_NUMBER, DEFAULT_NAMESPACE)));
+
+    mockClock = new MockClock(0L);
+  }
+
+  @Test
+  public void createHttpURLConnection_returnsHttpURLConnectionWithValidFetchURL() throws Exception {
+    HttpURLConnection urlConnection = configFetchHttpClient.createHttpURLConnection();
+
+    assertThat(urlConnection.getURL().toString())
+        .isEqualTo(String.format(FETCH_REGEX_URL, PROJECT_NUMBER, DEFAULT_NAMESPACE));
+  }
+
+  @Test
+  public void fetch_newValues_responseSet() throws Exception {
+    setServerResponseTo(hasChangeResponseBody, SECOND_ETAG);
+
+    FetchResponse response = fetch(FIRST_ETAG);
+
+    assertThat(response.getFetchTime()).isEqualTo(new Date(mockClock.currentTimeMillis()));
+    assertThat(response.getLastFetchETag()).isEqualTo(SECOND_ETAG);
+    assertThat(response.getFetchedConfigs().getConfigs().toString())
+        .isEqualTo(hasChangeResponseBody.getJSONObject(ENTRIES).toString());
+    assertThat(response.getFetchedConfigs().getAbtExperiments().toString())
+        .isEqualTo(hasChangeResponseBody.getJSONArray(EXPERIMENT_DESCRIPTIONS).toString());
+    assertThat(response.getFetchedConfigs().getFetchTime())
+        .isEqualTo(new Date(mockClock.currentTimeMillis()));
+  }
+
+  @Test
+  public void fetch_noChange_responseNotSet() throws Exception {
+    setServerResponseTo(noChangeResponseBody, SECOND_ETAG);
+
+    FetchResponse response = fetch(SECOND_ETAG);
+
+    assertThat(response.getLastFetchETag()).isNull();
+    assertThat(response.getFetchedConfigs()).isNull();
+  }
+
+  @Test
+  public void fetch_setsAllHeaders_sendsAllHeadersToServer() throws Exception {
+    setServerResponseTo(noChangeResponseBody, SECOND_ETAG);
+    Map<String, String> customHeaders = ImmutableMap.of("x-enable-fetch", "true");
+
+    Map<String, String> expectedHeaders = new HashMap<>();
+    // eTag header for diffing.
+    expectedHeaders.put("If-None-Match", FIRST_ETAG);
+    // Common headers.
+    expectedHeaders.put("X-Goog-Api-Key", API_KEY);
+    expectedHeaders.put("X-Android-Package", context.getPackageName());
+    expectedHeaders.put("X-Android-Cert", null);
+    expectedHeaders.put("X-Google-GFE-Can-Retry", "yes");
+    expectedHeaders.put("Content-Type", "application/json");
+    expectedHeaders.put("Accept", "application/json");
+    // Custom user-defined headers.
+    expectedHeaders.putAll(customHeaders);
+
+    fetch(FIRST_ETAG, /* userProperties= */ ImmutableMap.of(), customHeaders);
+
+    assertThat(fakeHttpURLConnection.getRequestHeaders()).isEqualTo(expectedHeaders);
+  }
+
+  @Test
+  public void fetch_setsAllElementsOfRequestBody_sendsRequestBodyToServer() throws Exception {
+    setServerResponseTo(noChangeResponseBody, SECOND_ETAG);
+    Map<String, String> userProperties = ImmutableMap.of("up1", "hello", "up2", "world");
+
+    fetch(FIRST_ETAG, userProperties);
+
+    JSONObject requestBody = new JSONObject(fakeHttpURLConnection.getOutputStream().toString());
+    assertThat(requestBody.get(INSTANCE_ID)).isEqualTo(INSTANCE_ID_STRING);
+    assertThat(requestBody.get(INSTANCE_ID_TOKEN)).isEqualTo(INSTANCE_ID_TOKEN_STRING);
+    assertThat(requestBody.get(APP_ID)).isEqualTo(FAKE_APP_ID);
+    Locale locale = context.getResources().getConfiguration().locale;
+    assertThat(requestBody.get(COUNTRY_CODE)).isEqualTo(locale.getCountry());
+    assertThat(requestBody.get(LANGUAGE_CODE)).isEqualTo(locale.toString());
+    assertThat(requestBody.getInt(PLATFORM_VERSION)).isEqualTo(android.os.Build.VERSION.SDK_INT);
+    assertThat(requestBody.get(TIME_ZONE)).isEqualTo(TimeZone.getDefault().getID());
+    assertThat(requestBody.get(PACKAGE_NAME)).isEqualTo(context.getPackageName());
+    assertThat(requestBody.get(SDK_VERSION)).isEqualTo(BuildConfig.VERSION_NAME);
+    assertThat(requestBody.getJSONObject(ANALYTICS_USER_PROPERTIES).toString())
+        .isEqualTo(new JSONObject(userProperties).toString());
+  }
+
+  @Test
+  public void fetch_instanceIdIsNull_throwsFRCClientException() throws Exception {
+    setServerResponseTo(noChangeResponseBody, SECOND_ETAG);
+
+    FirebaseRemoteConfigClientException frcException =
+        assertThrows(FirebaseRemoteConfigClientException.class, () -> fetchWithoutIid());
+
+    assertThat(frcException).hasMessageThat().contains("instance id is null");
+  }
+
+  @Test
+  public void fetch_instanceIdTokenIsNull_doesNotThrowException() throws Exception {
+    setServerResponseTo(noChangeResponseBody, SECOND_ETAG);
+
+    FetchResponse fetchResponse = fetchWithoutIidToken();
+
+    assertWithMessage("Fetch() failed with null instance id token!")
+        .that(fetchResponse)
+        .isNotNull();
+  }
+
+  @Test
+  public void fetch_setsTimeouts_urlConnectionHasTimeouts() throws Exception {
+    configFetchHttpClient =
+        new ConfigFetchHttpClient(
+            context,
+            APP_ID,
+            API_KEY,
+            DEFAULT_NAMESPACE,
+            /* connectTimeoutInSeconds= */ 15L,
+            /* readTimeoutInSeconds= */ 20L);
+    setServerResponseTo(noChangeResponseBody, SECOND_ETAG);
+
+    fetch(FIRST_ETAG);
+
+    assertThat(fakeHttpURLConnection.getConnectTimeout()).isEqualTo(15000L);
+    assertThat(fakeHttpURLConnection.getReadTimeout()).isEqualTo(20000L);
+  }
+
+  @Test
+  public void fetch_serverReturnsException_throwsFirebaseRemoteConfigException() {
+    setServerResponseTo404Error();
+
+    FirebaseRemoteConfigException exception =
+        assertThrows(FirebaseRemoteConfigException.class, () -> fetch(FIRST_ETAG));
+
+    assertThat(exception).hasMessageThat().isEqualTo("Bad Request");
+  }
+
+  private FetchResponse fetch(String eTag) throws Exception {
+    return configFetchHttpClient.fetch(
+        fakeHttpURLConnection,
+        INSTANCE_ID_STRING,
+        INSTANCE_ID_TOKEN_STRING,
+        /* analyticsUserProperties= */ ImmutableMap.of(),
+        eTag,
+        /* customHeaders= */ ImmutableMap.of(),
+        /* currentTime= */ new Date(mockClock.currentTimeMillis()));
+  }
+
+  private FetchResponse fetch(String eTag, Map<String, String> userProperties) throws Exception {
+    return configFetchHttpClient.fetch(
+        fakeHttpURLConnection,
+        INSTANCE_ID_STRING,
+        INSTANCE_ID_TOKEN_STRING,
+        userProperties,
+        eTag,
+        /* customHeaders= */ ImmutableMap.of(),
+        new Date(mockClock.currentTimeMillis()));
+  }
+
+  private FetchResponse fetch(
+      String eTag, Map<String, String> userProperties, Map<String, String> customHeaders)
+      throws Exception {
+    return configFetchHttpClient.fetch(
+        fakeHttpURLConnection,
+        INSTANCE_ID_STRING,
+        INSTANCE_ID_TOKEN_STRING,
+        userProperties,
+        eTag,
+        customHeaders,
+        new Date(mockClock.currentTimeMillis()));
+  }
+
+  private FetchResponse fetchWithoutIid() throws Exception {
+    return configFetchHttpClient.fetch(
+        fakeHttpURLConnection,
+        /* instanceId= */ null,
+        INSTANCE_ID_TOKEN_STRING,
+        /* analyticsUserProperties= */ ImmutableMap.of(),
+        /* lastFetchETag= */ "bogus-etag",
+        /* customHeaders= */ ImmutableMap.of(),
+        new Date(mockClock.currentTimeMillis()));
+  }
+
+  private FetchResponse fetchWithoutIidToken() throws Exception {
+    return configFetchHttpClient.fetch(
+        fakeHttpURLConnection,
+        INSTANCE_ID_STRING,
+        /* instanceIdToken= */ null,
+        /* analyticsUserProperties= */ ImmutableMap.of(),
+        /* lastFetchETag= */ "bogus-etag",
+        /* customHeaders= */ ImmutableMap.of(),
+        new Date(mockClock.currentTimeMillis()));
+  }
+
+  private void setServerResponseTo(JSONObject requestBody, String eTag) {
+    fakeHttpURLConnection.setFakeResponse(requestBody.toString().getBytes(Charsets.UTF_8), eTag);
+  }
+
+  private void setServerResponseTo404Error() {
+    // If no response is set, the fakeHttpURLConnection returns the 404 status code.
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigGetParameterHandlerTest.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigGetParameterHandlerTest.java
new file mode 100644
index 000000000..4bf3216f7
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigGetParameterHandlerTest.java
@@ -0,0 +1,736 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_BOOLEAN;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_BYTE_ARRAY;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_DOUBLE;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_LONG;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_STRING;
+import static com.google.firebase.remoteconfig.internal.ConfigGetParameterHandler.FRC_BYTE_ARRAY_ENCODING;
+import static org.mockito.Mockito.when;
+
+import com.google.android.gms.tasks.TaskCompletionSource;
+import com.google.android.gms.tasks.Tasks;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigValue;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for the {@link ConfigGetParameterHandler}.
+ *
+ * @author Miraziz Yusupov
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ConfigGetParameterHandlerTest {
+  private static final String STRING_KEY = "string_key";
+  private static final String ACTIVATED_STRING_VALUE = "activated_string_value";
+  private static final String DEFAULTS_STRING_VALUE = "defaults_string_value";
+
+  private static final String BOOLEAN_KEY = "boolean_key";
+  private static final String ACTIVATED_BOOLEAN_STRING_VALUE = "y";
+  private static final String DEFAULTS_BOOLEAN_STRING_VALUE = "no";
+  private static final boolean ACTIVATED_BOOLEAN_VALUE = true;
+  private static final boolean DEFAULTS_BOOLEAN_VALUE = false;
+
+  private static final String BYTE_ARRAY_KEY = "byte_array_key";
+  private static final String ACTIVATED_BYTE_ARRAY_STRING_VALUE = "Activated";
+  private static final String DEFAULTS_BYTE_ARRAY_STRING_VALUE = "Defaults";
+  private static final byte[] ACTIVATED_BYTE_ARRAY_VALUE =
+      ACTIVATED_BYTE_ARRAY_STRING_VALUE.getBytes(FRC_BYTE_ARRAY_ENCODING);
+  private static final byte[] DEFAULTS_BYTE_ARRAY_VALUE =
+      DEFAULTS_BYTE_ARRAY_STRING_VALUE.getBytes(FRC_BYTE_ARRAY_ENCODING);
+
+  private static final String DOUBLE_KEY = "double_key";
+  private static final double ACTIVATED_DOUBLE_VALUE = 555.0D;
+  private static final double DEFAULTS_DOUBLE_VALUE = 277.5D;
+
+  private static final String LONG_KEY = "long_key";
+  private static final long ACTIVATED_LONG_VALUE = 500;
+  private static final long DEFAULTS_LONG_VALUE = 250;
+
+  @Mock private ConfigCacheClient mockActivatedCache;
+  @Mock private ConfigCacheClient mockDefaultsCache;
+
+  private ConfigGetParameterHandler getHandler;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    getHandler = new ConfigGetParameterHandler(mockActivatedCache, mockDefaultsCache);
+  }
+
+  @Test
+  public void getString_getBlockingFails_returnsEmptyString() {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    String stringValue = getHandler.getString(STRING_KEY);
+
+    assertThat(stringValue).isEmpty();
+  }
+
+  @Test
+  public void getString_activatedAndDefaultsKeysExist_returnsActivatedValue() throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of(STRING_KEY, ACTIVATED_STRING_VALUE));
+    loadDefaultsCacheWithMap(ImmutableMap.of(STRING_KEY, DEFAULTS_STRING_VALUE));
+
+    String stringValue = getHandler.getString(STRING_KEY);
+
+    assertThat(stringValue).isEqualTo(ACTIVATED_STRING_VALUE);
+  }
+
+  @Test
+  public void getString_noActivatedKeyButDefaultsKeyExists_returnsDefaultsValue() throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of());
+    loadDefaultsCacheWithMap(ImmutableMap.of(STRING_KEY, DEFAULTS_STRING_VALUE));
+
+    String stringValue = getHandler.getString(STRING_KEY);
+
+    assertThat(stringValue).isEqualTo(DEFAULTS_STRING_VALUE);
+  }
+
+  @Test
+  public void getString_activatedAndDefaultsKeysDoNotExist_returnsStaticDefault() throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of());
+    loadDefaultsCacheWithMap(ImmutableMap.of());
+
+    String stringValue = getHandler.getString(STRING_KEY);
+
+    assertThat(stringValue).isEqualTo(DEFAULT_VALUE_FOR_STRING);
+  }
+
+  @Test
+  public void getString_activatedKeyExistsAndNoDefaultsConfigs_returnsActivatedValue()
+      throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of(STRING_KEY, ACTIVATED_STRING_VALUE));
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    String stringValue = getHandler.getString(STRING_KEY);
+
+    assertThat(stringValue).isEqualTo(ACTIVATED_STRING_VALUE);
+  }
+
+  @Test
+  public void getString_noActivatedConfigsButDefaultsKeyExists_returnsDefaultsValue()
+      throws Exception {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadDefaultsCacheWithMap(ImmutableMap.of(STRING_KEY, DEFAULTS_STRING_VALUE));
+
+    String stringValue = getHandler.getString(STRING_KEY);
+
+    assertThat(stringValue).isEqualTo(DEFAULTS_STRING_VALUE);
+  }
+
+  @Test
+  public void getString_activatedAndDefaultsConfigsDoNotExist_returnsStaticDefault() {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    String stringValue = getHandler.getString(STRING_KEY);
+
+    assertThat(stringValue).isEqualTo(DEFAULT_VALUE_FOR_STRING);
+  }
+
+  @Test
+  public void getString_activatedStillLoadingFromDisk_blocksAndReturnsActivatedValue()
+      throws Exception {
+    loadActivatedAsyncCacheWithIncompleteTask();
+    loadActivatedBlockingCacheWith(ImmutableMap.of(STRING_KEY, ACTIVATED_STRING_VALUE));
+
+    String stringValue = getHandler.getString(STRING_KEY);
+
+    assertThat(stringValue).isEqualTo(ACTIVATED_STRING_VALUE);
+  }
+
+  @Test
+  public void getBoolean_activatedAndDefaultsKeysExist_returnsActivatedValue() throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of(BOOLEAN_KEY, ACTIVATED_BOOLEAN_STRING_VALUE));
+    loadDefaultsCacheWithMap(ImmutableMap.of(BOOLEAN_KEY, DEFAULTS_BOOLEAN_STRING_VALUE));
+
+    boolean booleanValue = getHandler.getBoolean(BOOLEAN_KEY);
+
+    assertThat(booleanValue).isEqualTo(ACTIVATED_BOOLEAN_VALUE);
+  }
+
+  @Test
+  public void getBoolean_noActivatedKeyButDefaultsKeyExists_returnsDefaultsValue()
+      throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of());
+    loadDefaultsCacheWithMap(ImmutableMap.of(BOOLEAN_KEY, DEFAULTS_BOOLEAN_STRING_VALUE));
+
+    boolean booleanValue = getHandler.getBoolean(BOOLEAN_KEY);
+
+    assertThat(booleanValue).isEqualTo(DEFAULTS_BOOLEAN_VALUE);
+  }
+
+  @Test
+  public void getBoolean_activatedAndDefaultsKeysDoNotExist_returnsStaticDefault()
+      throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of());
+    loadDefaultsCacheWithMap(ImmutableMap.of());
+
+    boolean booleanValue = getHandler.getBoolean(BOOLEAN_KEY);
+
+    assertThat(booleanValue).isEqualTo(DEFAULT_VALUE_FOR_BOOLEAN);
+  }
+
+  @Test
+  public void getBoolean_activatedKeyExistsAndNoDefaultsConfigs_returnsActivatedValue()
+      throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of(BOOLEAN_KEY, ACTIVATED_BOOLEAN_STRING_VALUE));
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    boolean booleanValue = getHandler.getBoolean(BOOLEAN_KEY);
+
+    assertThat(booleanValue).isEqualTo(ACTIVATED_BOOLEAN_VALUE);
+  }
+
+  @Test
+  public void getBoolean_noActivatedConfigsButDefaultsKeyExists_returnsDefaultsValue()
+      throws Exception {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadDefaultsCacheWithMap(ImmutableMap.of(BOOLEAN_KEY, DEFAULTS_BOOLEAN_STRING_VALUE));
+
+    boolean booleanValue = getHandler.getBoolean(BOOLEAN_KEY);
+
+    assertThat(booleanValue).isEqualTo(DEFAULTS_BOOLEAN_VALUE);
+  }
+
+  @Test
+  public void getBoolean_activatedAndDefaultsConfigsDoNotExist_returnsStaticDefault() {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    boolean booleanValue = getHandler.getBoolean(BOOLEAN_KEY);
+
+    assertThat(booleanValue).isEqualTo(DEFAULT_VALUE_FOR_BOOLEAN);
+  }
+
+  @Test
+  public void getBoolean_activatedStillLoadingFromDisk_blocksAndReturnsActivatedValue()
+      throws Exception {
+    loadActivatedAsyncCacheWithIncompleteTask();
+    loadActivatedBlockingCacheWith(ImmutableMap.of(BOOLEAN_KEY, ACTIVATED_BOOLEAN_STRING_VALUE));
+
+    boolean booleanValue = getHandler.getBoolean(BOOLEAN_KEY);
+
+    assertThat(booleanValue).isEqualTo(ACTIVATED_BOOLEAN_VALUE);
+  }
+
+  @Test
+  public void getByteArray_activatedAndDefaultsKeysExist_returnsActivatedValue() throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of(BYTE_ARRAY_KEY, ACTIVATED_BYTE_ARRAY_STRING_VALUE));
+    loadDefaultsCacheWithMap(ImmutableMap.of(BYTE_ARRAY_KEY, DEFAULTS_BYTE_ARRAY_STRING_VALUE));
+
+    byte[] byteArrayValue = getHandler.getByteArray(BYTE_ARRAY_KEY);
+
+    assertThat(byteArrayValue).isEqualTo(ACTIVATED_BYTE_ARRAY_VALUE);
+  }
+
+  @Test
+  public void getByteArray_noActivatedKeyButDefaultsKeyExists_returnsDefaultsValue()
+      throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of());
+    loadDefaultsCacheWithMap(ImmutableMap.of(BYTE_ARRAY_KEY, DEFAULTS_BYTE_ARRAY_STRING_VALUE));
+
+    byte[] byteArrayValue = getHandler.getByteArray(BYTE_ARRAY_KEY);
+
+    assertThat(byteArrayValue).isEqualTo(DEFAULTS_BYTE_ARRAY_VALUE);
+  }
+
+  @Test
+  public void getByteArray_activatedAndDefaultsKeysDoNotExist_returnsStaticDefault()
+      throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of());
+    loadDefaultsCacheWithMap(ImmutableMap.of());
+
+    byte[] byteArrayValue = getHandler.getByteArray(BYTE_ARRAY_KEY);
+
+    assertThat(byteArrayValue).isEqualTo(DEFAULT_VALUE_FOR_BYTE_ARRAY);
+  }
+
+  @Test
+  public void getByteArray_activatedKeyExistsAndNoDefaultsConfigs_returnsActivatedValue()
+      throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of(BYTE_ARRAY_KEY, ACTIVATED_BYTE_ARRAY_STRING_VALUE));
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    byte[] byteArrayValue = getHandler.getByteArray(BYTE_ARRAY_KEY);
+
+    assertThat(byteArrayValue).isEqualTo(ACTIVATED_BYTE_ARRAY_VALUE);
+  }
+
+  @Test
+  public void getByteArray_noActivatedConfigsButDefaultsKeyExists_returnsDefaultsValue()
+      throws Exception {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadDefaultsCacheWithMap(ImmutableMap.of(BYTE_ARRAY_KEY, DEFAULTS_BYTE_ARRAY_STRING_VALUE));
+
+    byte[] byteArrayValue = getHandler.getByteArray(BYTE_ARRAY_KEY);
+
+    assertThat(byteArrayValue).isEqualTo(DEFAULTS_BYTE_ARRAY_VALUE);
+  }
+
+  @Test
+  public void getByteArray_activatedAndDefaultsConfigsDoNotExist_returnsStaticDefault() {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    byte[] byteArrayValue = getHandler.getByteArray(BYTE_ARRAY_KEY);
+
+    assertThat(byteArrayValue).isEqualTo(DEFAULT_VALUE_FOR_BYTE_ARRAY);
+  }
+
+  @Test
+  public void getByteArray_activatedStillLoadingFromDisk_blocksAndReturnsActivatedValue()
+      throws Exception {
+    loadActivatedAsyncCacheWithIncompleteTask();
+    loadActivatedBlockingCacheWith(
+        ImmutableMap.of(BYTE_ARRAY_KEY, ACTIVATED_BYTE_ARRAY_STRING_VALUE));
+
+    byte[] byteArrayValue = getHandler.getByteArray(BYTE_ARRAY_KEY);
+
+    assertThat(byteArrayValue).isEqualTo(ACTIVATED_BYTE_ARRAY_VALUE);
+  }
+
+  @Test
+  public void getDouble_activatedAndDefaultsKeysExist_returnsActivatedValue() throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of(DOUBLE_KEY, ACTIVATED_DOUBLE_VALUE));
+    loadDefaultsCacheWithMap(ImmutableMap.of(DOUBLE_KEY, DEFAULTS_DOUBLE_VALUE));
+
+    double doubleValue = getHandler.getDouble(DOUBLE_KEY);
+
+    assertThat(doubleValue).isEqualTo(ACTIVATED_DOUBLE_VALUE);
+  }
+
+  @Test
+  public void getDouble_noActivatedKeyButDefaultsKeyExists_returnsDefaultsValue() throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of());
+    loadDefaultsCacheWithMap(ImmutableMap.of(DOUBLE_KEY, DEFAULTS_DOUBLE_VALUE));
+
+    double doubleValue = getHandler.getDouble(DOUBLE_KEY);
+
+    assertThat(doubleValue).isEqualTo(DEFAULTS_DOUBLE_VALUE);
+  }
+
+  @Test
+  public void getDouble_activatedAndDefaultsKeysDoNotExist_returnsStaticDefault() throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of());
+    loadDefaultsCacheWithMap(ImmutableMap.of());
+
+    double doubleValue = getHandler.getDouble(DOUBLE_KEY);
+
+    assertThat(doubleValue).isEqualTo(DEFAULT_VALUE_FOR_DOUBLE);
+  }
+
+  @Test
+  public void getDouble_activatedKeyExistsAndNoDefaultsConfigs_returnsActivatedValue()
+      throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of(DOUBLE_KEY, ACTIVATED_DOUBLE_VALUE));
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    double doubleValue = getHandler.getDouble(DOUBLE_KEY);
+
+    assertThat(doubleValue).isEqualTo(ACTIVATED_DOUBLE_VALUE);
+  }
+
+  @Test
+  public void getDouble_noActivatedConfigsButDefaultsKeyExists_returnsDefaultsValue()
+      throws Exception {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadDefaultsCacheWithMap(ImmutableMap.of(DOUBLE_KEY, DEFAULTS_DOUBLE_VALUE));
+
+    double doubleValue = getHandler.getDouble(DOUBLE_KEY);
+
+    assertThat(doubleValue).isEqualTo(DEFAULTS_DOUBLE_VALUE);
+  }
+
+  @Test
+  public void getDouble_activatedAndDefaultsConfigsDoNotExist_returnsStaticDefault() {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    double doubleValue = getHandler.getDouble(DOUBLE_KEY);
+
+    assertThat(doubleValue).isEqualTo(DEFAULT_VALUE_FOR_DOUBLE);
+  }
+
+  @Test
+  public void getDouble_activatedStillLoadingFromDisk_blocksAndReturnsActivatedValue()
+      throws Exception {
+    loadActivatedAsyncCacheWithIncompleteTask();
+    loadActivatedBlockingCacheWith(ImmutableMap.of(DOUBLE_KEY, ACTIVATED_DOUBLE_VALUE));
+
+    double doubleValue = getHandler.getDouble(DOUBLE_KEY);
+
+    assertThat(doubleValue).isEqualTo(ACTIVATED_DOUBLE_VALUE);
+  }
+
+  @Test
+  public void getLong_activatedAndDefaultsKeysExist_returnsActivatedValue() throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of(LONG_KEY, ACTIVATED_LONG_VALUE));
+    loadDefaultsCacheWithMap(ImmutableMap.of(LONG_KEY, DEFAULTS_LONG_VALUE));
+
+    long longValue = getHandler.getLong(LONG_KEY);
+
+    assertThat(longValue).isEqualTo(ACTIVATED_LONG_VALUE);
+  }
+
+  @Test
+  public void getLong_noActivatedKeyButDefaultsKeyExists_returnsDefaultsValue() throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of());
+    loadDefaultsCacheWithMap(ImmutableMap.of(LONG_KEY, DEFAULTS_LONG_VALUE));
+
+    long longValue = getHandler.getLong(LONG_KEY);
+
+    assertThat(longValue).isEqualTo(DEFAULTS_LONG_VALUE);
+  }
+
+  @Test
+  public void getLong_activatedAndDefaultsKeysDoNotExist_returnsStaticDefault() throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of());
+    loadDefaultsCacheWithMap(ImmutableMap.of());
+
+    long longValue = getHandler.getLong(LONG_KEY);
+
+    assertThat(longValue).isEqualTo(DEFAULT_VALUE_FOR_LONG);
+  }
+
+  @Test
+  public void getLong_activatedKeyExistsAndNoDefaultsConfigs_returnsActivatedValue()
+      throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of(LONG_KEY, ACTIVATED_LONG_VALUE));
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    long longValue = getHandler.getLong(LONG_KEY);
+
+    assertThat(longValue).isEqualTo(ACTIVATED_LONG_VALUE);
+  }
+
+  @Test
+  public void getLong_noActivatedConfigsButDefaultsKeyExists_returnsDefaultsValue()
+      throws Exception {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadDefaultsCacheWithMap(ImmutableMap.of(LONG_KEY, DEFAULTS_LONG_VALUE));
+
+    long longValue = getHandler.getLong(LONG_KEY);
+
+    assertThat(longValue).isEqualTo(DEFAULTS_LONG_VALUE);
+  }
+
+  @Test
+  public void getLong_activatedAndDefaultsConfigsDoNotExist_returnsStaticDefault() {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    long longValue = getHandler.getLong(LONG_KEY);
+
+    assertThat(longValue).isEqualTo(DEFAULT_VALUE_FOR_LONG);
+  }
+
+  @Test
+  public void getLong_activatedStillLoadingFromDisk_blocksAndReturnsActivatedValue()
+      throws Exception {
+    loadActivatedAsyncCacheWithIncompleteTask();
+    loadActivatedBlockingCacheWith(ImmutableMap.of(LONG_KEY, ACTIVATED_LONG_VALUE));
+
+    long longValue = getHandler.getLong(LONG_KEY);
+
+    assertThat(longValue).isEqualTo(ACTIVATED_LONG_VALUE);
+  }
+
+  @Test
+  public void getValue_activatedAndDefaultsKeysExist_returnsActivatedValue() throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of(STRING_KEY, ACTIVATED_STRING_VALUE));
+    loadDefaultsCacheWithMap(ImmutableMap.of(STRING_KEY, DEFAULTS_STRING_VALUE));
+
+    FirebaseRemoteConfigValue frcValue = getHandler.getValue(STRING_KEY);
+
+    assertThat(frcValue.asString()).isEqualTo(ACTIVATED_STRING_VALUE);
+  }
+
+  @Test
+  public void getValue_noActivatedKeyButDefaultsKeyExists_returnsDefaultsValue() throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of());
+    loadDefaultsCacheWithMap(ImmutableMap.of(STRING_KEY, DEFAULTS_STRING_VALUE));
+
+    FirebaseRemoteConfigValue frcValue = getHandler.getValue(STRING_KEY);
+
+    assertThat(frcValue.asString()).isEqualTo(DEFAULTS_STRING_VALUE);
+  }
+
+  @Test
+  public void getValue_activatedAndDefaultsKeysDoNotExist_returnsStaticDefault() throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of());
+    loadDefaultsCacheWithMap(ImmutableMap.of());
+
+    FirebaseRemoteConfigValue frcValue = getHandler.getValue(STRING_KEY);
+
+    assertThat(frcValue.asString()).isEqualTo(DEFAULT_VALUE_FOR_STRING);
+  }
+
+  @Test
+  public void getValue_activatedKeyExistsAndNoDefaultsConfigs_returnsActivatedValue()
+      throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of(STRING_KEY, ACTIVATED_STRING_VALUE));
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    FirebaseRemoteConfigValue frcValue = getHandler.getValue(STRING_KEY);
+
+    assertThat(frcValue.asString()).isEqualTo(ACTIVATED_STRING_VALUE);
+  }
+
+  @Test
+  public void getValue_noActivatedConfigsButDefaultsKeyExists_returnsDefaultsValue()
+      throws Exception {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadDefaultsCacheWithMap(ImmutableMap.of(STRING_KEY, DEFAULTS_STRING_VALUE));
+
+    FirebaseRemoteConfigValue frcValue = getHandler.getValue(STRING_KEY);
+
+    assertThat(frcValue.asString()).isEqualTo(DEFAULTS_STRING_VALUE);
+  }
+
+  @Test
+  public void getValue_activatedAndDefaultsConfigsDoNotExist_returnsStaticDefault() {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    FirebaseRemoteConfigValue frcValue = getHandler.getValue(STRING_KEY);
+
+    assertThat(frcValue.asString()).isEqualTo(DEFAULT_VALUE_FOR_STRING);
+  }
+
+  @Test
+  public void getValue_activatedStillLoadingFromDisk_blocksAndReturnsActivatedValue()
+      throws Exception {
+    loadActivatedAsyncCacheWithIncompleteTask();
+    loadActivatedBlockingCacheWith(ImmutableMap.of(STRING_KEY, ACTIVATED_STRING_VALUE));
+
+    FirebaseRemoteConfigValue frcValue = getHandler.getValue(STRING_KEY);
+
+    assertThat(frcValue.asString()).isEqualTo(ACTIVATED_STRING_VALUE);
+  }
+
+  @Test
+  public void getKeysByPrefix_nullPrefix_returnsAllKeys() throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of("pre11", "", "pre21", "", "pre222", ""));
+    loadDefaultsCacheWithMap(ImmutableMap.of("pre31", "", "pre122", "", "pre2333", ""));
+
+    Set<String> keys = getHandler.getKeysByPrefix(null);
+
+    assertThat(keys).containsExactly("pre11", "pre122", "pre21", "pre222", "pre2333", "pre31");
+  }
+
+  @Test
+  public void getKeysByPrefix_emptyPrefix_returnsAllKeys() throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of("pre11", "", "pre21", "", "pre222", ""));
+    loadDefaultsCacheWithMap(ImmutableMap.of("pre31", "", "pre122", "", "pre2333", ""));
+
+    Set<String> keys = getHandler.getKeysByPrefix("");
+
+    assertThat(keys).containsExactly("pre11", "pre122", "pre21", "pre222", "pre2333", "pre31");
+  }
+
+  @Test
+  public void getKeysByPrefix_activatedAndDefaultsKeysExist_returnsAllKeysWithPrefix()
+      throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of("pa", "", "pre11", "", "pre21", "", "pre222", ""));
+    loadDefaultsCacheWithMap(ImmutableMap.of("pre31", "", "pre122", "", "no", "", "pre2333", ""));
+
+    Set<String> keys = getHandler.getKeysByPrefix("pre2");
+
+    assertThat(keys).containsExactly("pre21", "pre222", "pre2333");
+  }
+
+  @Test
+  public void getKeysByPrefix_noActivatedKeysButDefaultsKeysExist_returnsDefaultsKeys()
+      throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of());
+    loadDefaultsCacheWithMap(ImmutableMap.of("pre11", "", "pre21", "", "pre122", ""));
+
+    Set<String> keys = getHandler.getKeysByPrefix("pre2");
+
+    assertThat(keys).containsExactly("pre21");
+  }
+
+  @Test
+  public void getKeysByPrefix_activatedAndDefaultsKeysDoNotExist_returnsEmptySet()
+      throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of());
+    loadDefaultsCacheWithMap(ImmutableMap.of());
+
+    Set<String> keys = getHandler.getKeysByPrefix("pre2");
+
+    assertThat(keys).isEmpty();
+  }
+
+  @Test
+  public void getKeysByPrefix_activatedKeysExistAndNoDefaultsConfigs_returnsActivatedKeys()
+      throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of("pre11", "", "pre21", "", "pre122", ""));
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    Set<String> keys = getHandler.getKeysByPrefix("pre2");
+
+    assertThat(keys).containsExactly("pre21");
+  }
+
+  @Test
+  public void getKeysByPrefix_noActivatedConfigsButDefaultsKeysExist_returnsDefaultsKeys()
+      throws Exception {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadDefaultsCacheWithMap(ImmutableMap.of("pre11", "", "pre21", "", "pre12", ""));
+
+    Set<String> keys = getHandler.getKeysByPrefix("pre2");
+
+    assertThat(keys).containsExactly("pre21");
+  }
+
+  @Test
+  public void getKeysByPrefix_activatedAndDefaultsConfigsDoNotExist_returnsEmptySet() {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    Set<String> keys = getHandler.getKeysByPrefix("pre2");
+
+    assertThat(keys).isEmpty();
+  }
+
+  @Test
+  public void getKeysByPrefix_activatedStillLoadingFromDisk_blocksAndReturnsActivatedValue()
+      throws Exception {
+    loadActivatedAsyncCacheWithIncompleteTask();
+    loadActivatedBlockingCacheWith(ImmutableMap.of("pre11", "", "pre21", "", "pre122", ""));
+
+    loadDefaultsCacheWithMap(ImmutableMap.of("pre13", "", "pre31", ""));
+
+    Set<String> keys = getHandler.getKeysByPrefix("pre1");
+
+    assertThat(keys).containsExactly("pre11", "pre122", "pre13");
+  }
+
+  @Test
+  public void getAll_activatedAndDefaultsConfigsDoNotExist_returnsEmptyMap() {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    Map<String, FirebaseRemoteConfigValue> configs = getHandler.getAll();
+
+    assertThat(configs.keySet()).isEmpty();
+  }
+
+  @Test
+  public void getAll_activatedKeyExistsAndNoDefaultsConfigs_returnsActivatedValues()
+      throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of("pre11", "activated_foo", "pre21", "activated_bar"));
+    loadCacheWithConfig(mockDefaultsCache, /*container=*/ null);
+
+    Map<String, FirebaseRemoteConfigValue> configs = getHandler.getAll();
+
+    assertThat(configs.keySet()).isEqualTo(ImmutableSet.of("pre11", "pre21"));
+    assertThat(configs.get("pre11").asString()).isEqualTo("activated_foo");
+    assertThat(configs.get("pre21").asString()).isEqualTo("activated_bar");
+  }
+
+  @Test
+  public void getAll_noActivatedConfigsButDefaultsKeysExist_returnsDefaultsValuess()
+      throws Exception {
+    loadCacheWithConfig(mockActivatedCache, /*container=*/ null);
+    loadDefaultsCacheWithMap(ImmutableMap.of("pre11", "default_foo", "pre21", "default_bar"));
+
+    Map<String, FirebaseRemoteConfigValue> configs = getHandler.getAll();
+
+    assertThat(configs.keySet()).isEqualTo(ImmutableSet.of("pre11", "pre21"));
+    assertThat(configs.get("pre11").asString()).isEqualTo("default_foo");
+    assertThat(configs.get("pre21").asString()).isEqualTo("default_bar");
+  }
+
+  @Test
+  public void getAll_activatedAndDefaultKeysExist_returnsCorrectlyPrioritizedValues()
+      throws Exception {
+    loadActivatedCacheWithMap(ImmutableMap.of("pre11", "activated_foo"));
+    loadDefaultsCacheWithMap(ImmutableMap.of("pre11", "default_foo", "pre21", "default_bar"));
+
+    Map<String, FirebaseRemoteConfigValue> configs = getHandler.getAll();
+    assertThat(configs.keySet()).containsAtLeastElementsIn(ImmutableSet.of("pre11", "pre21"));
+    assertThat(configs.get("pre11").asString()).isEqualTo("activated_foo");
+    assertThat(configs.get("pre21").asString()).isEqualTo("default_bar");
+  }
+
+  private void loadActivatedCacheWithMap(ImmutableMap<String, Object> configsMap) throws Exception {
+    loadCacheWithConfig(mockActivatedCache, newContainer(convertToStringsMap(configsMap)));
+  }
+
+  private void loadDefaultsCacheWithMap(ImmutableMap<String, Object> configsMap) throws Exception {
+    loadCacheWithConfig(
+        mockDefaultsCache, newDefaultsStringContainer(convertToStringsMap(configsMap)));
+  }
+
+  private void loadActivatedBlockingCacheWith(ImmutableMap<String, Object> configsMap)
+      throws Exception {
+    when(mockActivatedCache.getBlocking())
+        .thenReturn(newContainer(convertToStringsMap(configsMap)));
+  }
+
+  private void loadActivatedAsyncCacheWithIncompleteTask() {
+    TaskCompletionSource<ConfigContainer> taskSource = new TaskCompletionSource<>();
+    when(mockActivatedCache.get()).thenReturn(taskSource.getTask());
+  }
+
+  private static void loadCacheWithConfig(
+      ConfigCacheClient cacheClient, ConfigContainer container) {
+    when(cacheClient.getBlocking()).thenReturn(container);
+    when(cacheClient.get()).thenReturn(Tasks.forResult(container));
+  }
+
+  private static ConfigContainer newContainer(Map<String, String> configsMap) throws Exception {
+    return ConfigContainer.newBuilder()
+        .replaceConfigsWith(configsMap)
+        .withFetchTime(new Date(555L))
+        .build();
+  }
+
+  private static ConfigContainer newDefaultsStringContainer(Map<String, String> configsMap)
+      throws Exception {
+    return ConfigContainer.newBuilder()
+        .replaceConfigsWith(configsMap)
+        .withFetchTime(new Date(0L))
+        .build();
+  }
+
+  private static Map<String, String> convertToStringsMap(Map<String, Object> objectsMap) {
+    Map<String, String> stringsMap = new HashMap<>();
+    for (Map.Entry<String, Object> objectEntry : objectsMap.entrySet()) {
+      stringsMap.put(objectEntry.getKey(), objectEntry.getValue().toString());
+    }
+    return stringsMap;
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigMetadataClientTest.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigMetadataClientTest.java
new file mode 100644
index 000000000..9a133fd00
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigMetadataClientTest.java
@@ -0,0 +1,318 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.LAST_FETCH_STATUS_FAILURE;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.LAST_FETCH_STATUS_NO_FETCH_YET;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.LAST_FETCH_STATUS_SUCCESS;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.LAST_FETCH_STATUS_THROTTLED;
+import static com.google.firebase.remoteconfig.RemoteConfigComponent.NETWORK_CONNECTION_TIMEOUT_IN_SECONDS;
+import static com.google.firebase.remoteconfig.internal.ConfigFetchHandler.DEFAULT_MINIMUM_FETCH_INTERVAL_IN_SECONDS;
+import static com.google.firebase.remoteconfig.internal.ConfigMetadataClient.LAST_FETCH_TIME_IN_MILLIS_NO_FETCH_YET;
+import static com.google.firebase.remoteconfig.internal.ConfigMetadataClient.LAST_FETCH_TIME_NO_FETCH_YET;
+import static com.google.firebase.remoteconfig.internal.ConfigMetadataClient.NO_BACKOFF_TIME;
+import static com.google.firebase.remoteconfig.internal.ConfigMetadataClient.NO_FAILED_FETCHES;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import com.google.common.base.Preconditions;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigInfo;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigSettings;
+import com.google.firebase.remoteconfig.internal.ConfigMetadataClient.BackoffMetadata;
+import com.google.firebase.remoteconfig.internal.ConfigMetadataClient.LastFetchStatus;
+import java.util.Date;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for the {@link ConfigMetadataClient}.
+ *
+ * @author Miraziz Yusupov
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ConfigMetadataClientTest {
+  private ConfigMetadataClient metadataClient;
+  private FirebaseRemoteConfigSettings.Builder settingsBuilder;
+
+  @Before
+  public void setUp() {
+    SharedPreferences metadata =
+        RuntimeEnvironment.application.getSharedPreferences("TEST_FILE_NAME", Context.MODE_PRIVATE);
+
+    metadata.edit().clear().commit();
+
+    metadataClient = new ConfigMetadataClient(metadata);
+
+    settingsBuilder = new FirebaseRemoteConfigSettings.Builder();
+  }
+
+  @Test
+  public void getIsDeveloperModeEnabled_isNotSet_returnsFalse() {
+    assertThat(metadataClient.isDeveloperModeEnabled()).isFalse();
+  }
+
+  @Test
+  public void getIsDeveloperModeEnabled_isSetToTrue_returnsTrue() {
+    metadataClient.setConfigSettings(settingsBuilder.setDeveloperModeEnabled(true).build());
+
+    boolean isDeveloperModeEnabled = metadataClient.isDeveloperModeEnabled();
+
+    assertThat(isDeveloperModeEnabled).isTrue();
+  }
+
+  @Test
+  public void getFetchTimeoutInSeconds_isNotSet_returnsDefault() {
+    assertThat(metadataClient.getFetchTimeoutInSeconds())
+        .isEqualTo(NETWORK_CONNECTION_TIMEOUT_IN_SECONDS);
+  }
+
+  @Test
+  public void getFetchTimeoutInSeconds_isSetTo10Seconds_returns10Seconds() {
+    long expectedFetchTimeout = 10L;
+    metadataClient.setConfigSettings(
+        settingsBuilder.setFetchTimeoutInSeconds(expectedFetchTimeout).build());
+
+    long fetchTimeout = metadataClient.getFetchTimeoutInSeconds();
+
+    assertThat(fetchTimeout).isEqualTo(expectedFetchTimeout);
+  }
+
+  @Test
+  public void getMinimumFetchIntervalInSeconds_isNotSet_returnsDefault() {
+    assertThat(metadataClient.getMinimumFetchIntervalInSeconds())
+        .isEqualTo(DEFAULT_MINIMUM_FETCH_INTERVAL_IN_SECONDS);
+  }
+
+  @Test
+  public void getMinimumFetchIntervalInSeconds_isSetTo10Seconds_returns10Seconds() {
+    long expectedMinimumFetchInterval = 10L;
+    metadataClient.setConfigSettings(
+        settingsBuilder.setMinimumFetchIntervalInSeconds(expectedMinimumFetchInterval).build());
+
+    long minimumFetchInterval = metadataClient.getMinimumFetchIntervalInSeconds();
+
+    assertThat(minimumFetchInterval).isEqualTo(expectedMinimumFetchInterval);
+  }
+
+  @Test
+  public void getLastFetchStatus_isNotSet_returnsZero() {
+    assertThat(metadataClient.getLastFetchStatus()).isEqualTo(LAST_FETCH_STATUS_NO_FETCH_YET);
+  }
+
+  @Test
+  public void getLastFetchStatus_isSetToSuccess_returnsSuccess() {
+    metadataClient.updateLastFetchAsSuccessfulAt(new Date(100L));
+
+    @LastFetchStatus int lastFetchStatus = metadataClient.getLastFetchStatus();
+
+    assertThat(lastFetchStatus).isEqualTo(LAST_FETCH_STATUS_SUCCESS);
+  }
+
+  @Test
+  public void getLastSuccessfulFetchTime_isNotSet_returnsZero() {
+    assertThat(metadataClient.getLastSuccessfulFetchTime()).isEqualTo(LAST_FETCH_TIME_NO_FETCH_YET);
+  }
+
+  @Test
+  public void getLastSuccessfulFetchTime_isSet_returnsTime() {
+    Date fetchTime = new Date(1000L);
+    metadataClient.updateLastFetchAsSuccessfulAt(fetchTime);
+
+    Date lastSuccessfulFetchTime = metadataClient.getLastSuccessfulFetchTime();
+
+    assertThat(lastSuccessfulFetchTime).isEqualTo(fetchTime);
+  }
+
+  @Test
+  public void getLastFetchETag_isNotSet_returnsEmptyString() {
+    assertThat(metadataClient.getLastFetchETag()).isNull();
+  }
+
+  @Test
+  public void getLastFetchETag_isSet_returnsETag() {
+    String expectedETag = "an etag";
+    metadataClient.setLastFetchETag(expectedETag);
+
+    String eTag = metadataClient.getLastFetchETag();
+
+    assertThat(eTag).isEqualTo(expectedETag);
+  }
+
+  @Test
+  public void getBackoffMetadata_isNotSet_returnsNoFailedFetchesAndNotThrottled() {
+    BackoffMetadata defaultBackoffMetadata = metadataClient.getBackoffMetadata();
+
+    assertThat(defaultBackoffMetadata.getNumFailedFetches()).isEqualTo(NO_FAILED_FETCHES);
+    assertThat(defaultBackoffMetadata.getBackoffEndTime()).isEqualTo(NO_BACKOFF_TIME);
+  }
+
+  @Test
+  public void getBackoffMetadata_hasValues_returnsValues() {
+    int numFailedFetches = 5;
+    Date backoffEndTime = new Date(1000L);
+    metadataClient.setBackoffMetadata(numFailedFetches, backoffEndTime);
+
+    BackoffMetadata backoffMetadata = metadataClient.getBackoffMetadata();
+
+    assertThat(backoffMetadata.getNumFailedFetches()).isEqualTo(numFailedFetches);
+    assertThat(backoffMetadata.getBackoffEndTime()).isEqualTo(backoffEndTime);
+  }
+
+  @Test
+  public void resetBackoff_hasValues_clearsAllValues() {
+    metadataClient.setBackoffMetadata(/*numFailedFetches=*/ 5, /*backoffEndTime=*/ new Date(1000L));
+
+    BackoffMetadata backoffMetadata = metadataClient.getBackoffMetadata();
+    Preconditions.checkArgument(backoffMetadata.getNumFailedFetches() != NO_FAILED_FETCHES);
+    Preconditions.checkArgument(!backoffMetadata.getBackoffEndTime().equals(NO_BACKOFF_TIME));
+
+    metadataClient.resetBackoff();
+
+    BackoffMetadata resetMetadata = metadataClient.getBackoffMetadata();
+    assertThat(resetMetadata.getNumFailedFetches()).isEqualTo(NO_FAILED_FETCHES);
+    assertThat(resetMetadata.getBackoffEndTime()).isEqualTo(NO_BACKOFF_TIME);
+  }
+
+  @Test
+  public void getInfo_hasNoSetValues_returnsDefaults() {
+    FirebaseRemoteConfigInfo info = metadataClient.getInfo();
+
+    assertThat(info.getFetchTimeMillis()).isEqualTo(LAST_FETCH_TIME_IN_MILLIS_NO_FETCH_YET);
+    assertThat(info.getLastFetchStatus()).isEqualTo(LAST_FETCH_STATUS_NO_FETCH_YET);
+    assertThat(info.getConfigSettings().isDeveloperModeEnabled()).isFalse();
+    assertThat(info.getConfigSettings().getFetchTimeoutInSeconds())
+        .isEqualTo(NETWORK_CONNECTION_TIMEOUT_IN_SECONDS);
+    assertThat(info.getConfigSettings().getMinimumFetchIntervalInSeconds())
+        .isEqualTo(DEFAULT_MINIMUM_FETCH_INTERVAL_IN_SECONDS);
+  }
+
+  @Test
+  public void getInfo_hasSetValues_returnsValues() {
+    Date lastSuccessfulFetchTime = new Date(1000L);
+    metadataClient.updateLastFetchAsSuccessfulAt(lastSuccessfulFetchTime);
+    metadataClient.updateLastFetchAsFailed();
+
+    long fetchTimeout = 666L;
+    long minimumFetchInterval = 666L;
+    metadataClient.setConfigSettings(
+        new FirebaseRemoteConfigSettings.Builder()
+            .setDeveloperModeEnabled(true)
+            .setFetchTimeoutInSeconds(fetchTimeout)
+            .setMinimumFetchIntervalInSeconds(minimumFetchInterval)
+            .build());
+
+    FirebaseRemoteConfigInfo info = metadataClient.getInfo();
+
+    assertThat(info.getFetchTimeMillis()).isEqualTo(lastSuccessfulFetchTime.getTime());
+    assertThat(info.getLastFetchStatus()).isEqualTo(LAST_FETCH_STATUS_FAILURE);
+    assertThat(info.getConfigSettings().isDeveloperModeEnabled()).isTrue();
+    assertThat(info.getConfigSettings().getFetchTimeoutInSeconds()).isEqualTo(fetchTimeout);
+    assertThat(info.getConfigSettings().getMinimumFetchIntervalInSeconds())
+        .isEqualTo(minimumFetchInterval);
+  }
+
+  @Test
+  public void getInfo_firstAndOnlyFetchFails_failStatusAndNoFetchYetTime() {
+    metadataClient.updateLastFetchAsFailed();
+
+    FirebaseRemoteConfigInfo info = metadataClient.getInfo();
+
+    assertThat(info.getLastFetchStatus()).isEqualTo(LAST_FETCH_STATUS_FAILURE);
+    assertThat(info.getFetchTimeMillis()).isEqualTo(LAST_FETCH_TIME_IN_MILLIS_NO_FETCH_YET);
+  }
+
+  @Test
+  public void getInfo_fetchSucceeds_successStatusAndFetchTimeUpdated() {
+    Date fetchTime = new Date(100L);
+    metadataClient.updateLastFetchAsSuccessfulAt(fetchTime);
+
+    FirebaseRemoteConfigInfo info = metadataClient.getInfo();
+
+    assertThat(info.getLastFetchStatus()).isEqualTo(LAST_FETCH_STATUS_SUCCESS);
+    assertThat(info.getFetchTimeMillis()).isEqualTo(fetchTime.getTime());
+  }
+
+  @Test
+  public void getInfo_firstFetchSucceedsSecondFetchFails_failStatusAndFirstFetchTime() {
+    Date fetchTime = new Date(100L);
+    metadataClient.updateLastFetchAsSuccessfulAt(fetchTime);
+
+    metadataClient.updateLastFetchAsFailed();
+
+    FirebaseRemoteConfigInfo info = metadataClient.getInfo();
+
+    assertThat(info.getLastFetchStatus()).isEqualTo(LAST_FETCH_STATUS_FAILURE);
+    assertThat(info.getFetchTimeMillis()).isEqualTo(fetchTime.getTime());
+  }
+
+  @Test
+  public void getInfo_twoFetchesSucceed_successStatusAndSecondFetchTime() {
+    Date fetchTime = new Date(100L);
+    metadataClient.updateLastFetchAsSuccessfulAt(fetchTime);
+
+    Date secondFetchTime = new Date(200L);
+    metadataClient.updateLastFetchAsSuccessfulAt(secondFetchTime);
+
+    FirebaseRemoteConfigInfo info = metadataClient.getInfo();
+
+    assertThat(info.getLastFetchStatus()).isEqualTo(LAST_FETCH_STATUS_SUCCESS);
+    assertThat(info.getFetchTimeMillis()).isEqualTo(secondFetchTime.getTime());
+  }
+
+  @Test
+  public void getInfo_hitsThrottleLimit_throttledStatus() {
+    Date fetchTime = new Date(100L);
+    metadataClient.updateLastFetchAsSuccessfulAt(fetchTime);
+
+    metadataClient.updateLastFetchAsThrottled();
+
+    FirebaseRemoteConfigInfo info = metadataClient.getInfo();
+
+    assertThat(info.getLastFetchStatus()).isEqualTo(LAST_FETCH_STATUS_THROTTLED);
+    assertThat(info.getFetchTimeMillis()).isEqualTo(fetchTime.getTime());
+  }
+
+  @Test
+  public void clear_hasSetValues_clearsAll() {
+    Date lastSuccessfulFetchTime = new Date(1000L);
+    metadataClient.updateLastFetchAsSuccessfulAt(lastSuccessfulFetchTime);
+
+    long fetchTimeout = 666L;
+    long minimumFetchInterval = 666L;
+    metadataClient.setConfigSettings(
+        new FirebaseRemoteConfigSettings.Builder()
+            .setDeveloperModeEnabled(true)
+            .setFetchTimeoutInSeconds(fetchTimeout)
+            .setMinimumFetchIntervalInSeconds(minimumFetchInterval)
+            .build());
+
+    metadataClient.clear();
+
+    FirebaseRemoteConfigInfo info = metadataClient.getInfo();
+    assertThat(info.getFetchTimeMillis()).isEqualTo(LAST_FETCH_TIME_IN_MILLIS_NO_FETCH_YET);
+    assertThat(info.getLastFetchStatus()).isEqualTo(LAST_FETCH_STATUS_NO_FETCH_YET);
+    assertThat(info.getConfigSettings().isDeveloperModeEnabled()).isFalse();
+    assertThat(info.getConfigSettings().getFetchTimeoutInSeconds())
+        .isEqualTo(NETWORK_CONNECTION_TIMEOUT_IN_SECONDS);
+    assertThat(info.getConfigSettings().getMinimumFetchIntervalInSeconds())
+        .isEqualTo(DEFAULT_MINIMUM_FETCH_INTERVAL_IN_SECONDS);
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigStorageClientTest.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigStorageClientTest.java
new file mode 100644
index 000000000..dd29a2b99
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/ConfigStorageClientTest.java
@@ -0,0 +1,125 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.firebase.remoteconfig.testutil.Assert.assertThrows;
+
+import android.content.Context;
+import com.google.android.gms.common.internal.Preconditions;
+import com.google.common.collect.ImmutableMap;
+import java.io.BufferedReader;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.InputStreamReader;
+import java.util.Date;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for the {@link ConfigStorageClient}.
+ *
+ * @author Miraziz Yusupov
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ConfigStorageClientTest {
+  private static final String FILE_NAME = "FILE_NAME";
+
+  private Context context;
+  private ConfigStorageClient storageClient;
+
+  private ConfigContainer configContainer;
+
+  @Before
+  public void setUp() throws Exception {
+    context = RuntimeEnvironment.application.getApplicationContext();
+
+    ConfigStorageClient.clearInstancesForTest();
+    storageClient = ConfigStorageClient.getInstance(context, FILE_NAME);
+
+    configContainer =
+        ConfigContainer.newBuilder()
+            .replaceConfigsWith(ImmutableMap.of("long_param", "1L", "string_param", "string_value"))
+            .withFetchTime(new Date(1000L))
+            .build();
+  }
+
+  @Test
+  public void write_validContainer_writesContainerToFile() throws Exception {
+    storageClient.write(configContainer);
+    assertThat(getFileAsString()).isEqualTo(configContainer.toString());
+  }
+
+  @Test
+  public void write_nullContainer_throwsNullPointerException() throws Exception {
+    assertThrows(NullPointerException.class, () -> storageClient.write(null));
+    assertThat(getFileAsString()).isEmpty();
+  }
+
+  @Test
+  public void read_validContainer_returnsContainer() throws Exception {
+    storageClient.write(configContainer);
+    Preconditions.checkArgument(getFileAsString().equals(configContainer.toString()));
+
+    ConfigContainer container = storageClient.read();
+    assertThat(container).isEqualTo(configContainer);
+  }
+
+  @Test
+  public void read_emptyFile_returnsNull() throws Exception {
+    ConfigContainer container = storageClient.read();
+
+    assertThat(container).isNull();
+  }
+
+  @Test
+  public void clear_fileExists_deletesFile() throws Exception {
+    storageClient.write(configContainer);
+    Preconditions.checkArgument(getFileAsString().equals(configContainer.toString()));
+
+    storageClient.clear();
+
+    assertThat(getFileAsString()).isEmpty();
+  }
+
+  @Test
+  public void clear_emptyFile_doesNothing() throws Exception {
+    storageClient.clear();
+
+    assertThat(getFileAsString()).isEmpty();
+  }
+
+  private String getFileAsString() throws Exception {
+    try (FileInputStream inputStream = context.openFileInput(FILE_NAME)) {
+      BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
+      String nextString = bufferedReader.readLine();
+
+      StringBuilder stringBuilder = new StringBuilder();
+      while (nextString != null) {
+        stringBuilder.append(nextString);
+        nextString = bufferedReader.readLine();
+      }
+
+      return stringBuilder.toString();
+    } catch (FileNotFoundException e) {
+      return "";
+    }
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/FakeHttpURLConnection.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/FakeHttpURLConnection.java
new file mode 100644
index 000000000..91a25de9a
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/FakeHttpURLConnection.java
@@ -0,0 +1,104 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Fake {@link HttpURLConnection} for Firebase Remote Config Android SDK testing purposes.
+ *
+ * @author Lucas Png
+ */
+public class FakeHttpURLConnection extends HttpURLConnection {
+  private byte[] response;
+
+  /** A stream that collects the POST body that the caller might give us. */
+  private final ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+  private final Map<String, String> requestHeaders = new HashMap<>();
+  private final Map<String, String> responseHeaders = new HashMap<>();
+
+  public FakeHttpURLConnection(URL url) {
+    super(url);
+  }
+
+  void setFakeResponse(byte[] response, String responseETag) {
+    responseHeaders.put("ETag", responseETag);
+    this.response = response;
+  }
+
+  /** Registers the given URL as hit. */
+  @Override
+  public void connect() {}
+
+  @Override
+  public boolean usingProxy() {
+    return false;
+  }
+
+  @Override
+  public void disconnect() {}
+
+  /** Intercept any headers that are set, for testing. */
+  @Override
+  public void setRequestProperty(String header, String value) {
+    requestHeaders.put(header, value);
+    super.setRequestProperty(header, value);
+  }
+
+  public Map<String, String> getRequestHeaders() {
+    return requestHeaders;
+  }
+
+  /** Returns a subverted output stream that the caller will write their POST body into. */
+  @Override
+  public OutputStream getOutputStream() {
+    return out;
+  }
+
+  /** Returns the body of the response, which is empty if there was no response for us. */
+  @Override
+  public InputStream getInputStream() {
+    if (response == null) {
+      response = new byte[0];
+    }
+
+    return new ByteArrayInputStream(response);
+  }
+
+  /** Returns 200 if there is a response or 404 if there isn't. */
+  @Override
+  public int getResponseCode() {
+    return response != null ? 200 : 404;
+  }
+
+  @Override
+  public String getHeaderField(String headerName) {
+    return responseHeaders.get(headerName);
+  }
+
+  @Override
+  public String getResponseMessage() {
+    return response != null ? Arrays.toString(response) : "Bad Request";
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/FirebaseRemoteConfigValueImplTest.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/FirebaseRemoteConfigValueImplTest.java
new file mode 100644
index 000000000..c19cbfd93
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/FirebaseRemoteConfigValueImplTest.java
@@ -0,0 +1,144 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_BOOLEAN;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_DOUBLE;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_LONG;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.DEFAULT_VALUE_FOR_STRING;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.VALUE_SOURCE_REMOTE;
+import static com.google.firebase.remoteconfig.FirebaseRemoteConfig.VALUE_SOURCE_STATIC;
+import static com.google.firebase.remoteconfig.testutil.Assert.assertThrows;
+
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigValue;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for the {@link FirebaseRemoteConfigValueImpl}.
+ *
+ * @author Miraziz Yusupov
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class FirebaseRemoteConfigValueImplTest {
+  @Before
+  public void setUp() throws Exception {}
+
+  @Test
+  public void asString_isStaticValue_returnsStaticString() throws Exception {
+    FirebaseRemoteConfigValue value =
+        new FirebaseRemoteConfigValueImpl(DEFAULT_VALUE_FOR_STRING, VALUE_SOURCE_STATIC);
+
+    assertThat(value.asString()).isEqualTo(DEFAULT_VALUE_FOR_STRING);
+  }
+
+  @Test
+  public void asString_isNonStaticValue_returnsString() throws Exception {
+    String stringValue = "string value";
+    FirebaseRemoteConfigValue value =
+        new FirebaseRemoteConfigValueImpl(stringValue, VALUE_SOURCE_REMOTE);
+
+    assertThat(value.asString()).isEqualTo(stringValue);
+  }
+
+  @Test
+  public void asLong_isStaticValue_returnsStaticLong() throws Exception {
+    FirebaseRemoteConfigValue value =
+        new FirebaseRemoteConfigValueImpl(
+            Long.toString(DEFAULT_VALUE_FOR_LONG), VALUE_SOURCE_STATIC);
+
+    assertThat(value.asLong()).isEqualTo(DEFAULT_VALUE_FOR_LONG);
+  }
+
+  @Test
+  public void asLong_isNotLongValue_throwsException() throws Exception {
+    FirebaseRemoteConfigValue value =
+        new FirebaseRemoteConfigValueImpl("not a long", VALUE_SOURCE_REMOTE);
+
+    IllegalArgumentException exception =
+        assertThrows(IllegalArgumentException.class, value::asLong);
+
+    assertThat(exception).hasMessageThat().contains("cannot be converted to a long");
+  }
+
+  @Test
+  public void asLong_isLongValue_returnsLong() throws Exception {
+    long longValue = 555L;
+    FirebaseRemoteConfigValue value =
+        new FirebaseRemoteConfigValueImpl(Long.toString(longValue), VALUE_SOURCE_REMOTE);
+
+    assertThat(value.asLong()).isEqualTo(longValue);
+  }
+
+  @Test
+  public void asDouble_isStaticValue_returnsStaticDouble() throws Exception {
+    FirebaseRemoteConfigValue value =
+        new FirebaseRemoteConfigValueImpl(
+            Double.toString(DEFAULT_VALUE_FOR_DOUBLE), VALUE_SOURCE_STATIC);
+
+    assertThat(value.asDouble()).isEqualTo(DEFAULT_VALUE_FOR_DOUBLE);
+  }
+
+  @Test
+  public void asDouble_isNotDoubleValue_throwsException() throws Exception {
+    FirebaseRemoteConfigValue value =
+        new FirebaseRemoteConfigValueImpl("not a double", VALUE_SOURCE_REMOTE);
+
+    IllegalArgumentException exception =
+        assertThrows(IllegalArgumentException.class, value::asDouble);
+
+    assertThat(exception).hasMessageThat().contains("cannot be converted to a double");
+  }
+
+  @Test
+  public void asDouble_isDoubleValue_returnsDouble() throws Exception {
+    double doubleValue = 555.5D;
+    FirebaseRemoteConfigValue value =
+        new FirebaseRemoteConfigValueImpl(Double.toString(doubleValue), VALUE_SOURCE_REMOTE);
+
+    assertThat(value.asDouble()).isEqualTo(doubleValue);
+  }
+
+  @Test
+  public void asBoolean_isStaticValue_returnsStaticBoolean() throws Exception {
+    FirebaseRemoteConfigValue value =
+        new FirebaseRemoteConfigValueImpl(
+            Boolean.toString(DEFAULT_VALUE_FOR_BOOLEAN), VALUE_SOURCE_STATIC);
+
+    assertThat(value.asBoolean()).isEqualTo(DEFAULT_VALUE_FOR_BOOLEAN);
+  }
+
+  @Test
+  public void asBoolean_isNotBooleanValue_throwsException() throws Exception {
+    FirebaseRemoteConfigValue value = new FirebaseRemoteConfigValueImpl("si", VALUE_SOURCE_REMOTE);
+
+    IllegalArgumentException exception =
+        assertThrows(IllegalArgumentException.class, value::asBoolean);
+
+    assertThat(exception).hasMessageThat().contains("cannot be converted to a boolean");
+  }
+
+  @Test
+  public void asBoolean_isBooleanValue_returnsBoolean() throws Exception {
+    FirebaseRemoteConfigValue value = new FirebaseRemoteConfigValueImpl("yes", VALUE_SOURCE_REMOTE);
+
+    assertThat(value.asBoolean()).isTrue();
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/LegacyConfigsHandlerTest.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/LegacyConfigsHandlerTest.java
new file mode 100644
index 000000000..d5649f74d
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/internal/LegacyConfigsHandlerTest.java
@@ -0,0 +1,399 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.ACTIVATE_FILE_NAME;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.DEFAULTS_FILE_NAME;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.EXPERIMENT_ID_KEY;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.EXPERIMENT_START_TIME_KEY;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.EXPERIMENT_TIME_TO_LIVE_KEY;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.EXPERIMENT_TRIGGER_EVENT_KEY;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.EXPERIMENT_TRIGGER_TIMEOUT_KEY;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.EXPERIMENT_VARIANT_ID_KEY;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.FETCH_FILE_NAME;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.LEGACY_CONFIGS_FILE_NAME;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.LEGACY_FRC_NAMESPACE_PREFIX;
+import static com.google.firebase.remoteconfig.internal.LegacyConfigsHandler.protoTimestampStringParser;
+import static java.util.concurrent.TimeUnit.DAYS;
+import static java.util.concurrent.TimeUnit.MINUTES;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import com.google.common.collect.ImmutableList;
+import com.google.firebase.remoteconfig.proto.ConfigPersistence.ConfigHolder;
+import com.google.firebase.remoteconfig.proto.ConfigPersistence.KeyValue;
+import com.google.firebase.remoteconfig.proto.ConfigPersistence.NamespaceKeyValue;
+import com.google.firebase.remoteconfig.proto.ConfigPersistence.PersistedConfig;
+import com.google.protobuf.ByteString;
+import developers.mobile.abt.FirebaseAbt.ExperimentPayload;
+import java.io.FileOutputStream;
+import java.sql.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+/**
+ * Unit tests for the {@link LegacyConfigsHandler}.
+ *
+ * @author Miraziz Yusupov
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class LegacyConfigsHandlerTest {
+  private static final String APP_ID = "1:14368190084:android:09cb977358c6f241";
+
+  private static final String FIRST_EXPERIMENT_ID = "55555";
+  private static final String SECOND_EXPERIMENT_ID = "22";
+
+  private static final String FIREBASE_NAMESPACE = "firebase";
+  private static final String FIREPERF_NAMESPACE = "fireperf";
+  private static final String SOVIET_NAMESPACE = "soviet";
+  private static final String[] ALL_NAMESPACES = {
+    FIREBASE_NAMESPACE, FIREPERF_NAMESPACE, SOVIET_NAMESPACE
+  };
+  private static final String[] ALL_FILE_NAMES = {
+    ACTIVATE_FILE_NAME, FETCH_FILE_NAME, DEFAULTS_FILE_NAME
+  };
+
+  private static final String KEY1 = "key1";
+  private static final String KEY2 = "key2";
+  private static final String SOVIET_ACTIVE_VALUE1 = "soviet_activate_value1";
+  private static final String SOVIET_ACTIVE_VALUE2 = "2.0";
+  private static final String FIREBASE_FETCHED_VALUE1 = "firebase_fetched_value1";
+  private static final String FIREPERF_FETCHED_VALUE1 = "true";
+  private static final String SOVIET_FETCHED_VALUE1 = "soviet_fetched_value1";
+  private static final String FIREBASE_DEFAULTS_VALUE1 = "50000000000";
+  private static final String FIREBASE_DEFAULTS_VALUE2 = "firebase_defaults_value2";
+
+  private static final Date ACTIVATED_TIMESTAMP = new Date(SECONDS.toMillis(20L));
+  private static final Date FETCHED_TIMESTAMP = new Date(SECONDS.toMillis(200L));
+  private static final Date DEFAULTS_TIMESTAMP = new Date(0L);
+
+  private Context context;
+  private LegacyConfigsHandler legacyConfigsHandler;
+
+  private PersistedConfig legacyConfigs;
+
+  /** Used for comparing lists of experiments where order may not match. */
+  private Map<String, ExperimentPayload> expectedAbtExperiments;
+
+  private Map<String, Map<String, ConfigCacheClient>> allCacheClientsMaps;
+
+  @Before
+  public void setUp() {
+    context = RuntimeEnvironment.application;
+
+    expectedAbtExperiments = new HashMap<>();
+
+    ExperimentPayload firstExperiment =
+        newExperiment(
+            FIRST_EXPERIMENT_ID,
+            "1",
+            DAYS.toMillis(100L),
+            "trigger1",
+            MINUTES.toMillis(10L),
+            MINUTES.toMillis(100L));
+    expectedAbtExperiments.put(FIRST_EXPERIMENT_ID, firstExperiment);
+
+    ExperimentPayload secondExperiment =
+        newExperiment(
+            SECOND_EXPERIMENT_ID,
+            "3",
+            DAYS.toMillis(1000L),
+            "trigger2",
+            MINUTES.toMillis(20L),
+            MINUTES.toMillis(200L));
+    expectedAbtExperiments.put(SECOND_EXPERIMENT_ID, secondExperiment);
+
+    legacyConfigs =
+        newConfigs(
+            /*activeHolder=*/ newHolder(
+                ACTIVATED_TIMESTAMP.getTime(),
+                ImmutableList.of(firstExperiment),
+                newNamespace(
+                    LEGACY_FRC_NAMESPACE_PREFIX + SOVIET_NAMESPACE,
+                    newKeyValue(KEY1, SOVIET_ACTIVE_VALUE1),
+                    newKeyValue(KEY2, SOVIET_ACTIVE_VALUE2))),
+            /*fetchedHolder=*/ newHolder(
+                FETCHED_TIMESTAMP.getTime(),
+                ImmutableList.of(secondExperiment, firstExperiment),
+                newNamespace(
+                    LEGACY_FRC_NAMESPACE_PREFIX + FIREBASE_NAMESPACE,
+                    newKeyValue(KEY1, FIREBASE_FETCHED_VALUE1)),
+                newNamespace(
+                    LEGACY_FRC_NAMESPACE_PREFIX + FIREPERF_NAMESPACE,
+                    newKeyValue(KEY1, FIREPERF_FETCHED_VALUE1)),
+                newNamespace(
+                    LEGACY_FRC_NAMESPACE_PREFIX + SOVIET_NAMESPACE,
+                    newKeyValue(KEY1, SOVIET_FETCHED_VALUE1))),
+            /*defaultsHolder=*/ newHolder(
+                DEFAULTS_TIMESTAMP.getTime(),
+                ImmutableList.of(),
+                newNamespace(
+                    LEGACY_FRC_NAMESPACE_PREFIX + FIREBASE_NAMESPACE,
+                    newKeyValue(KEY1, FIREBASE_DEFAULTS_VALUE1),
+                    newKeyValue(KEY2, FIREBASE_DEFAULTS_VALUE2))));
+
+    legacyConfigsHandler = spy(new LegacyConfigsHandler(context, APP_ID));
+
+    allCacheClientsMaps = new HashMap<>();
+    for (String namespace : ALL_NAMESPACES) {
+      Map<String, ConfigCacheClient> namespaceCacheClients = new HashMap<>();
+      for (String fileName : ALL_FILE_NAMES) {
+        ConfigCacheClient mockCacheClient = mock(ConfigCacheClient.class);
+        namespaceCacheClients.put(fileName, mockCacheClient);
+        when(legacyConfigsHandler.getCacheClient(namespace, fileName)).thenReturn(mockCacheClient);
+      }
+      allCacheClientsMaps.put(namespace, namespaceCacheClients);
+    }
+  }
+
+  @Test
+  public void saveLegacyConfigsIfNecessary_hasNoLegacyConfigs_doesNotWriteToCacheClients() {
+    assertWithMessage("Did not save legacy configs!")
+        .that(legacyConfigsHandler.saveLegacyConfigsIfNecessary())
+        .isTrue();
+
+    verifyNoWritesToAnyClient();
+  }
+
+  @Test
+  public void saveLegacyConfigsIfNecessary_hasLegacyConfigs_writesConfigsToCacheClients()
+      throws Exception {
+    writeTestDataToLegacyConfigsFile();
+
+    assertWithMessage("Did not save legacy configs!")
+        .that(legacyConfigsHandler.saveLegacyConfigsIfNecessary())
+        .isTrue();
+
+    validateFirebaseNamespaceConfigs();
+    validateSovietNamespaceConfigs();
+    validateFireperfNamespaceConfigs();
+  }
+
+  @Test
+  public void saveLegacyConfigsIfNecessary_calledMultipleTimes_onlyFirstCallWritesToClients()
+      throws Exception {
+    writeTestDataToLegacyConfigsFile();
+
+    assertWithMessage("Did not save legacy configs!")
+        .that(legacyConfigsHandler.saveLegacyConfigsIfNecessary())
+        .isTrue();
+
+    assertWithMessage("Saved legacy configs on second call!")
+        .that(legacyConfigsHandler.saveLegacyConfigsIfNecessary())
+        .isFalse();
+    assertWithMessage("Saved legacy configs on third call!")
+        .that(legacyConfigsHandler.saveLegacyConfigsIfNecessary())
+        .isFalse();
+  }
+
+  private void validateFirebaseNamespaceConfigs() throws Exception {
+    String namespace = FIREBASE_NAMESPACE;
+
+    verifyNoWriteToClient(namespace, ACTIVATE_FILE_NAME);
+
+    ConfigContainer fetchedConfigsContainer = getCapturedContainer(namespace, FETCH_FILE_NAME);
+    JSONObject fetchedConfigs = fetchedConfigsContainer.getConfigs();
+    assertThat(fetchedConfigs.length()).isEqualTo(1);
+    assertThat(fetchedConfigs.getString(KEY1)).isEqualTo(FIREBASE_FETCHED_VALUE1);
+    assertThat(fetchedConfigsContainer.getFetchTime()).isEqualTo(FETCHED_TIMESTAMP);
+    validateExperiments(
+        fetchedConfigsContainer.getAbtExperiments(), FIRST_EXPERIMENT_ID, SECOND_EXPERIMENT_ID);
+
+    ConfigContainer defaultsConfigsContainer = getCapturedContainer(namespace, DEFAULTS_FILE_NAME);
+    JSONObject defaultsConfigs = defaultsConfigsContainer.getConfigs();
+    assertThat(defaultsConfigs.length()).isEqualTo(2);
+    assertThat(defaultsConfigs.getLong(KEY1)).isEqualTo(Long.valueOf(FIREBASE_DEFAULTS_VALUE1));
+    assertThat(defaultsConfigs.getString(KEY2)).isEqualTo(FIREBASE_DEFAULTS_VALUE2);
+    assertThat(defaultsConfigsContainer.getFetchTime()).isEqualTo(DEFAULTS_TIMESTAMP);
+    validateExperiments(defaultsConfigsContainer.getAbtExperiments());
+  }
+
+  private void validateSovietNamespaceConfigs() throws Exception {
+    String namespace = SOVIET_NAMESPACE;
+
+    ConfigContainer activatedConfigsContainer = getCapturedContainer(namespace, ACTIVATE_FILE_NAME);
+    JSONObject activatedConfigs = activatedConfigsContainer.getConfigs();
+    assertThat(activatedConfigs.length()).isEqualTo(2);
+    assertThat(activatedConfigs.getString(KEY1)).isEqualTo(SOVIET_ACTIVE_VALUE1);
+    assertThat(activatedConfigs.getDouble(KEY2)).isEqualTo(Double.valueOf(SOVIET_ACTIVE_VALUE2));
+    assertThat(activatedConfigsContainer.getFetchTime()).isEqualTo(ACTIVATED_TIMESTAMP);
+    assertThat(activatedConfigsContainer.getAbtExperiments().length()).isEqualTo(0);
+
+    ConfigContainer fetchedConfigsContainer = getCapturedContainer(namespace, FETCH_FILE_NAME);
+    JSONObject fetchedConfigs = fetchedConfigsContainer.getConfigs();
+    assertThat(fetchedConfigs.length()).isEqualTo(1);
+    assertThat(fetchedConfigs.getString(KEY1)).isEqualTo(SOVIET_FETCHED_VALUE1);
+    assertThat(fetchedConfigsContainer.getFetchTime()).isEqualTo(FETCHED_TIMESTAMP);
+    assertThat(fetchedConfigsContainer.getAbtExperiments().length()).isEqualTo(0);
+
+    verifyNoWriteToClient(namespace, DEFAULTS_FILE_NAME);
+  }
+
+  private void validateFireperfNamespaceConfigs() throws Exception {
+    String namespace = FIREPERF_NAMESPACE;
+
+    verifyNoWriteToClient(namespace, ACTIVATE_FILE_NAME);
+
+    ConfigContainer fetchedConfigsContainer = getCapturedContainer(namespace, FETCH_FILE_NAME);
+    JSONObject fetchedConfigs = fetchedConfigsContainer.getConfigs();
+    assertThat(fetchedConfigs.length()).isEqualTo(1);
+
+    assertThat(fetchedConfigs.getBoolean(KEY1)).isEqualTo(Boolean.valueOf(FIREPERF_FETCHED_VALUE1));
+    assertThat(fetchedConfigsContainer.getFetchTime()).isEqualTo(FETCHED_TIMESTAMP);
+    assertThat(fetchedConfigsContainer.getAbtExperiments().length()).isEqualTo(0);
+
+    verifyNoWriteToClient(namespace, DEFAULTS_FILE_NAME);
+  }
+
+  private void validateExperiments(JSONArray abtExperiments, String... expectedExperimentIds)
+      throws Exception {
+    int numExpectedExperiments = expectedExperimentIds.length;
+    assertThat(abtExperiments.length()).isEqualTo(numExpectedExperiments);
+
+    Set<String> visitedExperimentIds = new HashSet<>();
+    for (int experimentIndex = 0; experimentIndex < numExpectedExperiments; experimentIndex++) {
+      JSONObject abtExperiment = abtExperiments.getJSONObject(experimentIndex);
+      String experimentId = abtExperiment.getString(EXPERIMENT_ID_KEY);
+
+      assertThatExperimentsAreEqual(abtExperiment, expectedAbtExperiments.get(experimentId));
+      visitedExperimentIds.add(experimentId);
+    }
+    assertThat(visitedExperimentIds).containsAtLeastElementsIn(expectedExperimentIds);
+  }
+
+  private ConfigContainer getCapturedContainer(String namespace, String fileName) {
+    ConfigCacheClient mockCacheClient = allCacheClientsMaps.get(namespace).get(fileName);
+    ArgumentCaptor<ConfigContainer> containerCaptor =
+        ArgumentCaptor.forClass(ConfigContainer.class);
+    verify(mockCacheClient).put(containerCaptor.capture());
+    return containerCaptor.getValue();
+  }
+
+  private void verifyNoWriteToClient(String namespace, String fileName) {
+    verify(allCacheClientsMaps.get(namespace).get(fileName), never()).put(any());
+  }
+
+  private void verifyNoWritesToAnyClient() {
+    for (String namespace : ALL_NAMESPACES) {
+      for (String fileName : ALL_FILE_NAMES) {
+        verifyNoWriteToClient(namespace, fileName);
+      }
+    }
+  }
+
+  private void assertThatExperimentsAreEqual(
+      JSONObject abtExperiment, ExperimentPayload expectedExperiment) throws Exception {
+    assertThat(abtExperiment.getString(EXPERIMENT_ID_KEY))
+        .isEqualTo(expectedExperiment.getExperimentId());
+    assertThat(abtExperiment.getString(EXPERIMENT_VARIANT_ID_KEY))
+        .isEqualTo(expectedExperiment.getVariantId());
+    assertThat(
+            protoTimestampStringParser
+                .get()
+                .parse(abtExperiment.getString(EXPERIMENT_START_TIME_KEY))
+                .getTime())
+        .isEqualTo(expectedExperiment.getExperimentStartTimeMillis());
+    assertThat(abtExperiment.getString(EXPERIMENT_TRIGGER_EVENT_KEY))
+        .isEqualTo(expectedExperiment.getTriggerEvent());
+    assertThat(abtExperiment.getLong(EXPERIMENT_TRIGGER_TIMEOUT_KEY))
+        .isEqualTo(expectedExperiment.getTriggerTimeoutMillis());
+    assertThat(abtExperiment.getLong(EXPERIMENT_TIME_TO_LIVE_KEY))
+        .isEqualTo(expectedExperiment.getTimeToLiveMillis());
+  }
+
+  private ExperimentPayload newExperiment(
+      String experimentId,
+      String variantId,
+      long startTimeInMillis,
+      String triggerEvent,
+      long triggerTimeoutInMillis,
+      long timeToLiveInMillis) {
+    ExperimentPayload.Builder secondExperimentBuilder = ExperimentPayload.newBuilder();
+    secondExperimentBuilder.setExperimentId(experimentId);
+    secondExperimentBuilder.setVariantId(variantId);
+    secondExperimentBuilder.setExperimentStartTimeMillis(startTimeInMillis);
+    secondExperimentBuilder.setTriggerEvent(triggerEvent);
+    secondExperimentBuilder.setTriggerTimeoutMillis(triggerTimeoutInMillis);
+    secondExperimentBuilder.setTimeToLiveMillis(timeToLiveInMillis);
+    return secondExperimentBuilder.build();
+  }
+
+  private PersistedConfig newConfigs(
+      ConfigHolder activeHolder, ConfigHolder fetchedHolder, ConfigHolder defaultsHolder) {
+    PersistedConfig.Builder persistedConfigs = PersistedConfig.newBuilder();
+    persistedConfigs.setActiveConfigHolder(activeHolder);
+    persistedConfigs.setFetchedConfigHolder(fetchedHolder);
+    persistedConfigs.setDefaultsConfigHolder(defaultsHolder);
+    return persistedConfigs.build();
+  }
+
+  private ConfigHolder newHolder(
+      long timestamp, List<ExperimentPayload> experiments, NamespaceKeyValue... namespaces) {
+    ConfigHolder.Builder holder = ConfigHolder.newBuilder();
+
+    holder.setTimestamp(timestamp);
+    for (ExperimentPayload experiment : experiments) {
+      holder.addExperimentPayload(experiment.toByteString());
+    }
+    for (NamespaceKeyValue namespace : namespaces) {
+      holder.addNamespaceKeyValue(namespace);
+    }
+
+    return holder.build();
+  }
+
+  private NamespaceKeyValue newNamespace(String namespace, KeyValue... values) {
+    NamespaceKeyValue.Builder namespaceValues = NamespaceKeyValue.newBuilder();
+
+    namespaceValues.setNamespace(namespace);
+    for (KeyValue value : values) {
+      namespaceValues.addKeyValue(value);
+    }
+
+    return namespaceValues.build();
+  }
+
+  private KeyValue newKeyValue(String key, String value) {
+    return KeyValue.newBuilder().setKey(key).setValue(ByteString.copyFromUtf8(value)).build();
+  }
+
+  private void writeTestDataToLegacyConfigsFile() throws Exception {
+    try (FileOutputStream outputStream =
+        context.openFileOutput(LEGACY_CONFIGS_FILE_NAME, Context.MODE_PRIVATE)) {
+      legacyConfigs.writeTo(outputStream);
+    }
+  }
+}
diff --git a/test-apps/firestore-test-app/src/main/AndroidManifest.xml b/firebase-config/src/test/java/com/google/firebase/remoteconfig/res/xml/frc_bad_defaults.xml
similarity index 52%
rename from test-apps/firestore-test-app/src/main/AndroidManifest.xml
rename to firebase-config/src/test/java/com/google/firebase/remoteconfig/res/xml/frc_bad_defaults.xml
index 6c0a6a31f..63b1775c4 100644
--- a/test-apps/firestore-test-app/src/main/AndroidManifest.xml
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/res/xml/frc_bad_defaults.xml
@@ -4,8 +4,8 @@
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
   ~
+  ~ You may obtain a copy of the License at
   ~      http://www.apache.org/licenses/LICENSE-2.0
   ~
   ~ Unless required by applicable law or agreed to in writing, software
@@ -15,18 +15,29 @@
   ~ limitations under the License.
   -->
 
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.google.firebase.testapps.firestore">
-    <application
-        android:allowBackup="true"
-        android:supportsRtl="true"
-        android:name="android.support.multidex.MultiDexApplication">
-        <activity
-            android:name=".TestActivity">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-</manifest>
+<!-- START xml_defaults -->
+<defaultsMap>
+  <bad_entry>
+    <key>first_default_key</key>
+    <value>first_default_value</value>
+  </bad_entry>
+  <entry>
+    <key>second_default_key</key>
+    <value>second_default_value</value>
+  </entry>
+  <entry>
+    <bad_key>third_default_key</bad_key>
+    <value>third_default_value</value>
+  </entry>
+  <entry>
+    <key>fourth_default_key</key>
+    <bad_value>fourth_default_value</bad_value>
+  </entry>
+  <entry>
+    <key>
+      <value>fifth_default_value</value>
+      fifth_default_key
+    </key>
+  </entry>
+</defaultsMap>
+    <!-- END xml_defaults -->
diff --git a/test-apps/functions-test-app/src/androidTest/AndroidManifest.xml b/firebase-config/src/test/java/com/google/firebase/remoteconfig/res/xml/frc_empty_defaults.xml
similarity index 75%
rename from test-apps/functions-test-app/src/androidTest/AndroidManifest.xml
rename to firebase-config/src/test/java/com/google/firebase/remoteconfig/res/xml/frc_empty_defaults.xml
index 276c3c428..6c5d348ee 100644
--- a/test-apps/functions-test-app/src/androidTest/AndroidManifest.xml
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/res/xml/frc_empty_defaults.xml
@@ -1,10 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
 <!--
   ~ Copyright 2018 Google LLC
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
   ~
+  ~ You may obtain a copy of the License at
   ~      http://www.apache.org/licenses/LICENSE-2.0
   ~
   ~ Unless required by applicable law or agreed to in writing, software
@@ -14,9 +15,7 @@
   ~ limitations under the License.
   -->
 
-<manifest package="com.google.firebase.testapps.functions"
-    xmlns:tools="http://schemas.android.com/tools">
-
-  <uses-sdk tools:overrideLibrary="android.support.test.uiautomator.v18"/>
-
-</manifest>
+<!-- START xml_defaults -->
+<defaultsMap>
+</defaultsMap>
+    <!-- END xml_defaults -->
diff --git a/test-apps/functions-test-app/src/main/res/layout/test_activity.xml b/firebase-config/src/test/java/com/google/firebase/remoteconfig/res/xml/frc_good_defaults.xml
similarity index 64%
rename from test-apps/functions-test-app/src/main/res/layout/test_activity.xml
rename to firebase-config/src/test/java/com/google/firebase/remoteconfig/res/xml/frc_good_defaults.xml
index 4b2852e62..75106f51f 100644
--- a/test-apps/functions-test-app/src/main/res/layout/test_activity.xml
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/res/xml/frc_good_defaults.xml
@@ -4,8 +4,8 @@
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
   ~
+  ~ You may obtain a copy of the License at
   ~      http://www.apache.org/licenses/LICENSE-2.0
   ~
   ~ Unless required by applicable law or agreed to in writing, software
@@ -15,12 +15,19 @@
   ~ limitations under the License.
   -->
 
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent">
-  <TextView
-      android:id="@+id/sum"
-      android:layout_width="match_parent"
-      android:layout_height="wrap_content"
-      />
-</LinearLayout>
\ No newline at end of file
+<!-- START xml_defaults -->
+<defaults>
+  <entry>
+    <key>first_default_key</key>
+    <value>first_default_value</value>
+  </entry>
+  <entry>
+    <key>second_default_key</key>
+    <value>second_default_value</value>
+  </entry>
+  <entry>
+    <key>third_default_key</key>
+    <value>third_default_value</value>
+  </entry>
+</defaults>
+    <!-- END xml_defaults -->
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/testutil/Assert.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/testutil/Assert.java
new file mode 100644
index 000000000..ec313f581
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/testutil/Assert.java
@@ -0,0 +1,952 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.testutil;
+
+// REMOVED FOR J2CL
+// import org.hamcrest.Matcher;
+// import org.hamcrest.MatcherAssert;
+import org.junit.ComparisonFailure;
+import org.junit.internal.ArrayComparisonFailure;
+import org.junit.internal.ExactComparisonCriteria;
+import org.junit.internal.InexactComparisonCriteria;
+
+/**
+ * A set of assertion methods useful for writing tests. Only failed assertions are recorded. These
+ * methods can be used directly: <code>Assert.assertEquals(...)</code>, however, they read better if
+ * they are referenced through static import:
+ *
+ * <pre>
+ * import static org.junit.Assert.*;
+ *    ...
+ *    assertEquals(...);
+ * </pre>
+ *
+ * @see AssertionError
+ * @since 4.0
+ */
+public class Assert {
+  /** Protect constructor since it is a static only class */
+  protected Assert() {}
+
+  /**
+   * Asserts that a condition is true. If it isn't it throws an {@link AssertionError} with the
+   * given message.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param condition condition to be checked
+   */
+  public static void assertTrue(String message, boolean condition) {
+    if (!condition) {
+      fail(message);
+    }
+  }
+
+  /**
+   * Asserts that a condition is true. If it isn't it throws an {@link AssertionError} without a
+   * message.
+   *
+   * @param condition condition to be checked
+   */
+  public static void assertTrue(boolean condition) {
+    assertTrue(null, condition);
+  }
+
+  /**
+   * Asserts that a condition is false. If it isn't it throws an {@link AssertionError} with the
+   * given message.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param condition condition to be checked
+   */
+  public static void assertFalse(String message, boolean condition) {
+    assertTrue(message, !condition);
+  }
+
+  /**
+   * Asserts that a condition is false. If it isn't it throws an {@link AssertionError} without a
+   * message.
+   *
+   * @param condition condition to be checked
+   */
+  public static void assertFalse(boolean condition) {
+    assertFalse(null, condition);
+  }
+
+  /**
+   * Fails a test with the given message.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @see AssertionError
+   */
+  public static void fail(String message) {
+    if (message == null) {
+      throw new AssertionError();
+    }
+    throw new AssertionError(message);
+  }
+
+  /** Fails a test with no message. */
+  public static void fail() {
+    fail(null);
+  }
+
+  /**
+   * Asserts that two objects are equal. If they are not, an {@link AssertionError} is thrown with
+   * the given message. If <code>expected</code> and <code>actual</code> are <code>null</code>, they
+   * are considered equal.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param expected expected value
+   * @param actual actual value
+   */
+  public static void assertEquals(String message, Object expected, Object actual) {
+    if (equalsRegardingNull(expected, actual)) {
+      return;
+    }
+    if (expected instanceof String && actual instanceof String) {
+      String cleanMessage = message == null ? "" : message;
+      throw new ComparisonFailure(cleanMessage, (String) expected, (String) actual);
+    } else {
+      failNotEquals(message, expected, actual);
+    }
+  }
+
+  private static boolean equalsRegardingNull(Object expected, Object actual) {
+    if (expected == null) {
+      return actual == null;
+    }
+
+    return isEquals(expected, actual);
+  }
+
+  private static boolean isEquals(Object expected, Object actual) {
+    return expected.equals(actual);
+  }
+
+  /**
+   * Asserts that two objects are equal. If they are not, an {@link AssertionError} without a
+   * message is thrown. If <code>expected</code> and <code>actual</code> are <code>null</code>, they
+   * are considered equal.
+   *
+   * @param expected expected value
+   * @param actual the value to check against <code>expected</code>
+   */
+  public static void assertEquals(Object expected, Object actual) {
+    assertEquals(null, expected, actual);
+  }
+
+  /**
+   * Asserts that two objects are <b>not</b> equals. If they are, an {@link AssertionError} is
+   * thrown with the given message. If <code>unexpected</code> and <code>actual</code> are <code>
+   * null</code>, they are considered equal.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param unexpected unexpected value to check
+   * @param actual the value to check against <code>unexpected</code>
+   */
+  public static void assertNotEquals(String message, Object unexpected, Object actual) {
+    if (equalsRegardingNull(unexpected, actual)) {
+      failEquals(message, actual);
+    }
+  }
+
+  /**
+   * Asserts that two objects are <b>not</b> equals. If they are, an {@link AssertionError} without
+   * a message is thrown. If <code>unexpected</code> and <code>actual</code> are <code>null</code>,
+   * they are considered equal.
+   *
+   * @param unexpected unexpected value to check
+   * @param actual the value to check against <code>unexpected</code>
+   */
+  public static void assertNotEquals(Object unexpected, Object actual) {
+    assertNotEquals(null, unexpected, actual);
+  }
+
+  private static void failEquals(String message, Object actual) {
+    String formatted = "Values should be different. ";
+    if (message != null) {
+      formatted = message + ". ";
+    }
+
+    formatted += "Actual: " + actual;
+    fail(formatted);
+  }
+
+  /**
+   * Asserts that two longs are <b>not</b> equals. If they are, an {@link AssertionError} is thrown
+   * with the given message.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param unexpected unexpected value to check
+   * @param actual the value to check against <code>unexpected</code>
+   */
+  public static void assertNotEquals(String message, long unexpected, long actual) {
+    if (unexpected == actual) {
+      failEquals(message, Long.valueOf(actual));
+    }
+  }
+
+  /**
+   * Asserts that two longs are <b>not</b> equals. If they are, an {@link AssertionError} without a
+   * message is thrown.
+   *
+   * @param unexpected unexpected value to check
+   * @param actual the value to check against <code>unexpected</code>
+   */
+  public static void assertNotEquals(long unexpected, long actual) {
+    assertNotEquals(null, unexpected, actual);
+  }
+
+  /**
+   * Asserts that two doubles are <b>not</b> equal to within a positive delta. If they are, an
+   * {@link AssertionError} is thrown with the given message. If the unexpected value is infinity
+   * then the delta value is ignored. NaNs are considered equal: <code>
+   * assertNotEquals(Double.NaN, Double.NaN, *)</code> fails
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param unexpected unexpected value
+   * @param actual the value to check against <code>unexpected</code>
+   * @param delta the maximum delta between <code>unexpected</code> and <code>actual</code> for
+   *     which both numbers are still considered equal.
+   */
+  public static void assertNotEquals(
+      String message, double unexpected, double actual, double delta) {
+    if (!doubleIsDifferent(unexpected, actual, delta)) {
+      failEquals(message, Double.valueOf(actual));
+    }
+  }
+
+  /**
+   * Asserts that two doubles are <b>not</b> equal to within a positive delta. If they are, an
+   * {@link AssertionError} is thrown. If the unexpected value is infinity then the delta value is
+   * ignored.NaNs are considered equal: <code>assertNotEquals(Double.NaN, Double.NaN, *)</code>
+   * fails
+   *
+   * @param unexpected unexpected value
+   * @param actual the value to check against <code>unexpected</code>
+   * @param delta the maximum delta between <code>unexpected</code> and <code>actual</code> for
+   *     which both numbers are still considered equal.
+   */
+  public static void assertNotEquals(double unexpected, double actual, double delta) {
+    assertNotEquals(null, unexpected, actual, delta);
+  }
+
+  /**
+   * Asserts that two floats are <b>not</b> equal to within a positive delta. If they are, an {@link
+   * AssertionError} is thrown. If the unexpected value is infinity then the delta value is
+   * ignored.NaNs are considered equal: <code>assertNotEquals(Float.NaN, Float.NaN, *)</code> fails
+   *
+   * @param unexpected unexpected value
+   * @param actual the value to check against <code>unexpected</code>
+   * @param delta the maximum delta between <code>unexpected</code> and <code>actual</code> for
+   *     which both numbers are still considered equal.
+   */
+  public static void assertNotEquals(float unexpected, float actual, float delta) {
+    assertNotEquals(null, unexpected, actual, delta);
+  }
+
+  /**
+   * Asserts that two object arrays are equal. If they are not, an {@link AssertionError} is thrown
+   * with the given message. If <code>expecteds</code> and <code>actuals</code> are <code>null
+   * </code>, they are considered equal.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param expecteds Object array or array of arrays (multi-dimensional array) with expected
+   *     values.
+   * @param actuals Object array or array of arrays (multi-dimensional array) with actual values
+   */
+  public static void assertArrayEquals(String message, Object[] expecteds, Object[] actuals)
+      throws ArrayComparisonFailure {
+    internalArrayEquals(message, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two object arrays are equal. If they are not, an {@link AssertionError} is thrown.
+   * If <code>expected</code> and <code>actual</code> are <code>null</code>, they are considered
+   * equal.
+   *
+   * @param expecteds Object array or array of arrays (multi-dimensional array) with expected values
+   * @param actuals Object array or array of arrays (multi-dimensional array) with actual values
+   */
+  public static void assertArrayEquals(Object[] expecteds, Object[] actuals) {
+    assertArrayEquals(null, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two boolean arrays are equal. If they are not, an {@link AssertionError} is thrown
+   * with the given message. If <code>expecteds</code> and <code>actuals</code> are <code>null
+   * </code>, they are considered equal.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param expecteds boolean array with expected values.
+   * @param actuals boolean array with expected values.
+   */
+  public static void assertArrayEquals(String message, boolean[] expecteds, boolean[] actuals)
+      throws ArrayComparisonFailure {
+    internalArrayEquals(message, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two boolean arrays are equal. If they are not, an {@link AssertionError} is
+   * thrown. If <code>expected</code> and <code>actual</code> are <code>null</code>, they are
+   * considered equal.
+   *
+   * @param expecteds boolean array with expected values.
+   * @param actuals boolean array with expected values.
+   */
+  public static void assertArrayEquals(boolean[] expecteds, boolean[] actuals) {
+    assertArrayEquals(null, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two byte arrays are equal. If they are not, an {@link AssertionError} is thrown
+   * with the given message.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param expecteds byte array with expected values.
+   * @param actuals byte array with actual values
+   */
+  public static void assertArrayEquals(String message, byte[] expecteds, byte[] actuals)
+      throws ArrayComparisonFailure {
+    internalArrayEquals(message, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two byte arrays are equal. If they are not, an {@link AssertionError} is thrown.
+   *
+   * @param expecteds byte array with expected values.
+   * @param actuals byte array with actual values
+   */
+  public static void assertArrayEquals(byte[] expecteds, byte[] actuals) {
+    assertArrayEquals(null, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two char arrays are equal. If they are not, an {@link AssertionError} is thrown
+   * with the given message.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param expecteds char array with expected values.
+   * @param actuals char array with actual values
+   */
+  public static void assertArrayEquals(String message, char[] expecteds, char[] actuals)
+      throws ArrayComparisonFailure {
+    internalArrayEquals(message, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two char arrays are equal. If they are not, an {@link AssertionError} is thrown.
+   *
+   * @param expecteds char array with expected values.
+   * @param actuals char array with actual values
+   */
+  public static void assertArrayEquals(char[] expecteds, char[] actuals) {
+    assertArrayEquals(null, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two short arrays are equal. If they are not, an {@link AssertionError} is thrown
+   * with the given message.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param expecteds short array with expected values.
+   * @param actuals short array with actual values
+   */
+  public static void assertArrayEquals(String message, short[] expecteds, short[] actuals)
+      throws ArrayComparisonFailure {
+    internalArrayEquals(message, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two short arrays are equal. If they are not, an {@link AssertionError} is thrown.
+   *
+   * @param expecteds short array with expected values.
+   * @param actuals short array with actual values
+   */
+  public static void assertArrayEquals(short[] expecteds, short[] actuals) {
+    assertArrayEquals(null, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two int arrays are equal. If they are not, an {@link AssertionError} is thrown
+   * with the given message.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param expecteds int array with expected values.
+   * @param actuals int array with actual values
+   */
+  public static void assertArrayEquals(String message, int[] expecteds, int[] actuals)
+      throws ArrayComparisonFailure {
+    internalArrayEquals(message, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two int arrays are equal. If they are not, an {@link AssertionError} is thrown.
+   *
+   * @param expecteds int array with expected values.
+   * @param actuals int array with actual values
+   */
+  public static void assertArrayEquals(int[] expecteds, int[] actuals) {
+    assertArrayEquals(null, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two long arrays are equal. If they are not, an {@link AssertionError} is thrown
+   * with the given message.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param expecteds long array with expected values.
+   * @param actuals long array with actual values
+   */
+  public static void assertArrayEquals(String message, long[] expecteds, long[] actuals)
+      throws ArrayComparisonFailure {
+    internalArrayEquals(message, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two long arrays are equal. If they are not, an {@link AssertionError} is thrown.
+   *
+   * @param expecteds long array with expected values.
+   * @param actuals long array with actual values
+   */
+  public static void assertArrayEquals(long[] expecteds, long[] actuals) {
+    assertArrayEquals(null, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two double arrays are equal. If they are not, an {@link AssertionError} is thrown
+   * with the given message.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param expecteds double array with expected values.
+   * @param actuals double array with actual values
+   * @param delta the maximum delta between <code>expecteds[i]</code> and <code>actuals[i]</code>
+   *     for which both numbers are still considered equal.
+   */
+  public static void assertArrayEquals(
+      String message, double[] expecteds, double[] actuals, double delta)
+      throws ArrayComparisonFailure {
+    new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two double arrays are equal. If they are not, an {@link AssertionError} is thrown.
+   *
+   * @param expecteds double array with expected values.
+   * @param actuals double array with actual values
+   * @param delta the maximum delta between <code>expecteds[i]</code> and <code>actuals[i]</code>
+   *     for which both numbers are still considered equal.
+   */
+  public static void assertArrayEquals(double[] expecteds, double[] actuals, double delta) {
+    assertArrayEquals(null, expecteds, actuals, delta);
+  }
+
+  /**
+   * Asserts that two float arrays are equal. If they are not, an {@link AssertionError} is thrown
+   * with the given message.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param expecteds float array with expected values.
+   * @param actuals float array with actual values
+   * @param delta the maximum delta between <code>expecteds[i]</code> and <code>actuals[i]</code>
+   *     for which both numbers are still considered equal.
+   */
+  public static void assertArrayEquals(
+      String message, float[] expecteds, float[] actuals, float delta)
+      throws ArrayComparisonFailure {
+    new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two float arrays are equal. If they are not, an {@link AssertionError} is thrown.
+   *
+   * @param expecteds float array with expected values.
+   * @param actuals float array with actual values
+   * @param delta the maximum delta between <code>expecteds[i]</code> and <code>actuals[i]</code>
+   *     for which both numbers are still considered equal.
+   */
+  public static void assertArrayEquals(float[] expecteds, float[] actuals, float delta) {
+    assertArrayEquals(null, expecteds, actuals, delta);
+  }
+
+  /**
+   * Asserts that two object arrays are equal. If they are not, an {@link AssertionError} is thrown
+   * with the given message. If <code>expecteds</code> and <code>actuals</code> are <code>null
+   * </code>, they are considered equal.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param expecteds Object array or array of arrays (multi-dimensional array) with expected
+   *     values.
+   * @param actuals Object array or array of arrays (multi-dimensional array) with actual values
+   */
+  private static void internalArrayEquals(String message, Object expecteds, Object actuals)
+      throws ArrayComparisonFailure {
+    new ExactComparisonCriteria().arrayEquals(message, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two doubles are equal to within a positive delta. If they are not, an {@link
+   * AssertionError} is thrown with the given message. If the expected value is infinity then the
+   * delta value is ignored. NaNs are considered equal: <code>
+   * assertEquals(Double.NaN, Double.NaN, *)</code> passes
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param expected expected value
+   * @param actual the value to check against <code>expected</code>
+   * @param delta the maximum delta between <code>expected</code> and <code>actual</code> for which
+   *     both numbers are still considered equal.
+   */
+  public static void assertEquals(String message, double expected, double actual, double delta) {
+    if (doubleIsDifferent(expected, actual, delta)) {
+      failNotEquals(message, Double.valueOf(expected), Double.valueOf(actual));
+    }
+  }
+
+  /**
+   * Asserts that two floats are equal to within a positive delta. If they are not, an {@link
+   * AssertionError} is thrown with the given message. If the expected value is infinity then the
+   * delta value is ignored. NaNs are considered equal: <code>assertEquals(Float.NaN, Float.NaN, *)
+   * </code> passes
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param expected expected value
+   * @param actual the value to check against <code>expected</code>
+   * @param delta the maximum delta between <code>expected</code> and <code>actual</code> for which
+   *     both numbers are still considered equal.
+   */
+  public static void assertEquals(String message, float expected, float actual, float delta) {
+    if (floatIsDifferent(expected, actual, delta)) {
+      failNotEquals(message, Float.valueOf(expected), Float.valueOf(actual));
+    }
+  }
+
+  /**
+   * Asserts that two floats are <b>not</b> equal to within a positive delta. If they are, an {@link
+   * AssertionError} is thrown with the given message. If the unexpected value is infinity then the
+   * delta value is ignored. NaNs are considered equal: <code>
+   * assertNotEquals(Float.NaN, Float.NaN, *)</code> fails
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param unexpected unexpected value
+   * @param actual the value to check against <code>unexpected</code>
+   * @param delta the maximum delta between <code>unexpected</code> and <code>actual</code> for
+   *     which both numbers are still considered equal.
+   */
+  public static void assertNotEquals(String message, float unexpected, float actual, float delta) {
+    if (!floatIsDifferent(unexpected, actual, delta)) {
+      failEquals(message, actual);
+    }
+  }
+
+  private static boolean doubleIsDifferent(double d1, double d2, double delta) {
+    if (Double.compare(d1, d2) == 0) {
+      return false;
+    }
+    if ((Math.abs(d1 - d2) <= delta)) {
+      return false;
+    }
+
+    return true;
+  }
+
+  private static boolean floatIsDifferent(float f1, float f2, float delta) {
+    if (Float.compare(f1, f2) == 0) {
+      return false;
+    }
+    if ((Math.abs(f1 - f2) <= delta)) {
+      return false;
+    }
+
+    return true;
+  }
+
+  /**
+   * Asserts that two longs are equal. If they are not, an {@link AssertionError} is thrown.
+   *
+   * @param expected expected long value.
+   * @param actual actual long value
+   */
+  public static void assertEquals(long expected, long actual) {
+    assertEquals(null, expected, actual);
+  }
+
+  /**
+   * Asserts that two longs are equal. If they are not, an {@link AssertionError} is thrown with the
+   * given message.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param expected long expected value.
+   * @param actual long actual value
+   */
+  public static void assertEquals(String message, long expected, long actual) {
+    if (expected != actual) {
+      failNotEquals(message, Long.valueOf(expected), Long.valueOf(actual));
+    }
+  }
+
+  /**
+   * @deprecated Use <code>assertEquals(double expected, double actual, double delta)</code> instead
+   */
+  @Deprecated
+  public static void assertEquals(double expected, double actual) {
+    assertEquals(null, expected, actual);
+  }
+
+  /**
+   * @deprecated Use <code>
+   *     assertEquals(String message, double expected, double actual, double delta)</code> instead
+   */
+  @Deprecated
+  public static void assertEquals(String message, double expected, double actual) {
+    fail("Use assertEquals(expected, actual, delta) to compare floating-point numbers");
+  }
+
+  /**
+   * Asserts that two doubles are equal to within a positive delta. If they are not, an {@link
+   * AssertionError} is thrown. If the expected value is infinity then the delta value is
+   * ignored.NaNs are considered equal: <code>assertEquals(Double.NaN, Double.NaN, *)</code> passes
+   *
+   * @param expected expected value
+   * @param actual the value to check against <code>expected</code>
+   * @param delta the maximum delta between <code>expected</code> and <code>actual</code> for which
+   *     both numbers are still considered equal.
+   */
+  public static void assertEquals(double expected, double actual, double delta) {
+    assertEquals(null, expected, actual, delta);
+  }
+
+  /**
+   * Asserts that two floats are equal to within a positive delta. If they are not, an {@link
+   * AssertionError} is thrown. If the expected value is infinity then the delta value is ignored.
+   * NaNs are considered equal: <code>assertEquals(Float.NaN, Float.NaN, *)</code> passes
+   *
+   * @param expected expected value
+   * @param actual the value to check against <code>expected</code>
+   * @param delta the maximum delta between <code>expected</code> and <code>actual</code> for which
+   *     both numbers are still considered equal.
+   */
+  public static void assertEquals(float expected, float actual, float delta) {
+    assertEquals(null, expected, actual, delta);
+  }
+
+  /**
+   * Asserts that an object isn't null. If it is an {@link AssertionError} is thrown with the given
+   * message.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param object Object to check or <code>null</code>
+   */
+  public static void assertNotNull(String message, Object object) {
+    assertTrue(message, object != null);
+  }
+
+  /**
+   * Asserts that an object isn't null. If it is an {@link AssertionError} is thrown.
+   *
+   * @param object Object to check or <code>null</code>
+   */
+  public static void assertNotNull(Object object) {
+    assertNotNull(null, object);
+  }
+
+  /**
+   * Asserts that an object is null. If it is not, an {@link AssertionError} is thrown with the
+   * given message.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param object Object to check or <code>null</code>
+   */
+  public static void assertNull(String message, Object object) {
+    if (object == null) {
+      return;
+    }
+    failNotNull(message, object);
+  }
+
+  /**
+   * Asserts that an object is null. If it isn't an {@link AssertionError} is thrown.
+   *
+   * @param object Object to check or <code>null</code>
+   */
+  public static void assertNull(Object object) {
+    assertNull(null, object);
+  }
+
+  private static void failNotNull(String message, Object actual) {
+    String formatted = "";
+    if (message != null) {
+      formatted = message + " ";
+    }
+    fail(formatted + "expected null, but was:<" + actual + ">");
+  }
+
+  /**
+   * Asserts that two objects refer to the same object. If they are not, an {@link AssertionError}
+   * is thrown with the given message.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param expected the expected object
+   * @param actual the object to compare to <code>expected</code>
+   */
+  public static void assertSame(String message, Object expected, Object actual) {
+    if (expected == actual) {
+      return;
+    }
+    failNotSame(message, expected, actual);
+  }
+
+  /**
+   * Asserts that two objects refer to the same object. If they are not the same, an {@link
+   * AssertionError} without a message is thrown.
+   *
+   * @param expected the expected object
+   * @param actual the object to compare to <code>expected</code>
+   */
+  public static void assertSame(Object expected, Object actual) {
+    assertSame(null, expected, actual);
+  }
+
+  /**
+   * Asserts that two objects do not refer to the same object. If they do refer to the same object,
+   * an {@link AssertionError} is thrown with the given message.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param unexpected the object you don't expect
+   * @param actual the object to compare to <code>unexpected</code>
+   */
+  public static void assertNotSame(String message, Object unexpected, Object actual) {
+    if (unexpected == actual) {
+      failSame(message);
+    }
+  }
+
+  /**
+   * Asserts that two objects do not refer to the same object. If they do refer to the same object,
+   * an {@link AssertionError} without a message is thrown.
+   *
+   * @param unexpected the object you don't expect
+   * @param actual the object to compare to <code>unexpected</code>
+   */
+  public static void assertNotSame(Object unexpected, Object actual) {
+    assertNotSame(null, unexpected, actual);
+  }
+
+  private static void failSame(String message) {
+    String formatted = "";
+    if (message != null) {
+      formatted = message + " ";
+    }
+    fail(formatted + "expected not same");
+  }
+
+  private static void failNotSame(String message, Object expected, Object actual) {
+    String formatted = "";
+    if (message != null) {
+      formatted = message + " ";
+    }
+    fail(formatted + "expected same:<" + expected + "> was not:<" + actual + ">");
+  }
+
+  private static void failNotEquals(String message, Object expected, Object actual) {
+    fail(format(message, expected, actual));
+  }
+
+  static String format(String message, Object expected, Object actual) {
+    String formatted = "";
+    if (message != null && !"".equals(message)) {
+      formatted = message + " ";
+    }
+    String expectedString = String.valueOf(expected);
+    String actualString = String.valueOf(actual);
+    if (expectedString.equals(actualString)) {
+      return formatted
+          + "expected: "
+          + formatClassAndValue(expected, expectedString)
+          + " but was: "
+          + formatClassAndValue(actual, actualString);
+    } else {
+      return formatted + "expected:<" + expectedString + "> but was:<" + actualString + ">";
+    }
+  }
+
+  private static String formatClassAndValue(Object value, String valueString) {
+    String className = value == null ? "null" : value.getClass().getName();
+    return className + "<" + valueString + ">";
+  }
+
+  /**
+   * Asserts that two object arrays are equal. If they are not, an {@link AssertionError} is thrown
+   * with the given message. If <code>expecteds</code> and <code>actuals</code> are <code>null
+   * </code>, they are considered equal.
+   *
+   * @param message the identifying message for the {@link AssertionError} (<code>null</code> okay)
+   * @param expecteds Object array or array of arrays (multi-dimensional array) with expected
+   *     values.
+   * @param actuals Object array or array of arrays (multi-dimensional array) with actual values
+   * @deprecated use assertArrayEquals
+   */
+  @Deprecated
+  public static void assertEquals(String message, Object[] expecteds, Object[] actuals) {
+    assertArrayEquals(message, expecteds, actuals);
+  }
+
+  /**
+   * Asserts that two object arrays are equal. If they are not, an {@link AssertionError} is thrown.
+   * If <code>expected</code> and <code>actual</code> are <code>null</code>, they are considered
+   * equal.
+   *
+   * @param expecteds Object array or array of arrays (multi-dimensional array) with expected values
+   * @param actuals Object array or array of arrays (multi-dimensional array) with actual values
+   * @deprecated use assertArrayEquals
+   */
+  @Deprecated
+  public static void assertEquals(Object[] expecteds, Object[] actuals) {
+    assertArrayEquals(expecteds, actuals);
+  }
+
+  /**
+   * Asserts that <code>actual</code> satisfies the condition specified by <code>matcher</code>. If
+   * not, an {@link AssertionError} is thrown with information about the matcher and failing value.
+   * Example:
+   *
+   * <pre>
+   *   assertThat(0, is(1)); // fails:
+   *     // failure message:
+   *     // expected: is &lt;1&gt;
+   *     // got value: &lt;0&gt;
+   *   assertThat(0, is(not(1))) // passes
+   * </pre>
+   *
+   * <code>org.hamcrest.Matcher</code> does not currently document the meaning of its type parameter
+   * <code>T</code>. This method assumes that a matcher typed as <code>Matcher&lt;T&gt;</code> can
+   * be meaningfully applied only to values that could be assigned to a variable of type <code>T
+   * </code>.
+   *
+   * @param <T> the static type accepted by the matcher (this can flag obvious compile-time problems
+   *     such as {@code assertThat(1, is("a"))}
+   * @param actual the computed value being compared
+   * @param matcher an expression, built of {@link Matcher}s, specifying allowed values
+   * @see org.hamcrest.CoreMatchers
+   * @see org.hamcrest.MatcherAssert
+   */
+  // REMOVED FOR J2CL
+  // public static <T> void assertThat(T actual, Matcher<? super T> matcher) {
+  //     assertThat("", actual, matcher);
+  // }
+
+  /**
+   * Asserts that <code>actual</code> satisfies the condition specified by <code>matcher</code>. If
+   * not, an {@link AssertionError} is thrown with the reason and information about the matcher and
+   * failing value. Example:
+   *
+   * <pre>
+   *   assertThat(&quot;Help! Integers don't work&quot;, 0, is(1)); // fails:
+   *     // failure message:
+   *     // Help! Integers don't work
+   *     // expected: is &lt;1&gt;
+   *     // got value: &lt;0&gt;
+   *   assertThat(&quot;Zero is one&quot;, 0, is(not(1))) // passes
+   * </pre>
+   *
+   * <code>org.hamcrest.Matcher</code> does not currently document the meaning of its type parameter
+   * <code>T</code>. This method assumes that a matcher typed as <code>Matcher&lt;T&gt;</code> can
+   * be meaningfully applied only to values that could be assigned to a variable of type <code>T
+   * </code>.
+   *
+   * @param reason additional information about the error
+   * @param <T> the static type accepted by the matcher (this can flag obvious compile-time problems
+   *     such as {@code assertThat(1, is("a"))}
+   * @param actual the computed value being compared
+   * @param matcher an expression, built of {@link Matcher}s, specifying allowed values
+   * @see org.hamcrest.CoreMatchers
+   * @see org.hamcrest.MatcherAssert
+   */
+  // REMOVED FOR J2CL
+  // public static <T> void assertThat(String reason, T actual,
+  //         Matcher<? super T> matcher) {
+  //     MatcherAssert.assertThat(reason, actual, matcher);
+  // }
+
+  // ADDED FOR J2CL (adapted from 4.13)
+  /**
+   * Asserts that {@code runnable} throws an exception of type {@code expectedThrowable} when
+   * executed. If it does not throw an exception, an {@link AssertionError} is thrown. If it throws
+   * the wrong type of exception, an {@code AssertionError} is thrown describing the mismatch; the
+   * exception that was actually thrown can be obtained by calling {@link AssertionError#getCause}.
+   *
+   * @param expectedThrowable the expected type of the exception
+   * @param runnable a function that is expected to throw an exception when executed
+   * @since 4.13
+   */
+  public static <T extends Throwable> T assertThrows(
+      Class<T> expectedThrowable, ThrowingRunnable runnable) {
+    return expectThrows(expectedThrowable, runnable);
+  }
+
+  // ADDED FOR J2CL (adapted from 4.13)
+  /**
+   * Asserts that {@code runnable} throws an exception of type {@code expectedThrowable} when
+   * executed. If it does, the exception object is returned. If it does not throw an exception, an
+   * {@link AssertionError} is thrown. If it throws the wrong type of exception, an {@code
+   * AssertionError} is thrown describing the mismatch; the exception that was actually thrown can
+   * be obtained by calling {@link AssertionError#getCause}.
+   *
+   * @param expectedThrowable the expected type of the exception
+   * @param runnable a function that is expected to throw an exception when executed
+   * @return the exception thrown by {@code runnable}
+   * @since 4.13
+   */
+  public static <T extends Throwable> T expectThrows(
+      Class<T> expectedThrowable, ThrowingRunnable runnable) {
+    // Sanity check due to b/31386321.
+    assertFalse("Class metadata is corrupt", isInstanceOfTypeJ2cl(new Object(), String.class));
+
+    try {
+      runnable.run();
+    } catch (Throwable actualThrown) {
+      if (isInstanceOfTypeJ2cl(actualThrown, expectedThrowable)) {
+        @SuppressWarnings("unchecked")
+        T retVal = (T) actualThrown;
+        return retVal;
+      } else {
+        String mismatchMessage =
+            format(
+                "unexpected exception type thrown;",
+                expectedThrowable.getSimpleName(),
+                actualThrown.getClass().getSimpleName());
+        throw new AssertionError(mismatchMessage, actualThrown);
+      }
+    }
+    String message =
+        "expected " + expectedThrowable.getSimpleName() + " to be thrown, but nothing was thrown";
+    throw new AssertionError(message);
+  }
+
+  // ADDED FOR J2CL
+  /**
+   * Returns true if the {@code instance} is assignable to the type {@code clazz}. In J2CL, {@code
+   * clazz} can only be a concrete type, not an interface. For the purposes of {@link
+   * #expectThrows}, this is sufficient, since exceptions are never interfaces.
+   */
+  private static boolean isInstanceOfTypeJ2cl(Object instance, Class<?> clazz) {
+    String className = clazz.getName();
+    for (Class<?> type = instance.getClass(); type != null; type = type.getSuperclass()) {
+      if (type.getName().equals(className)) {
+        return true;
+      }
+    }
+    return false;
+  }
+}
diff --git a/firebase-config/src/test/java/com/google/firebase/remoteconfig/testutil/ThrowingRunnable.java b/firebase-config/src/test/java/com/google/firebase/remoteconfig/testutil/ThrowingRunnable.java
new file mode 100644
index 000000000..badf6cab0
--- /dev/null
+++ b/firebase-config/src/test/java/com/google/firebase/remoteconfig/testutil/ThrowingRunnable.java
@@ -0,0 +1,26 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+//
+// You may obtain a copy of the License at
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.remoteconfig.testutil;
+
+// JUnit 4.13 class lifted from https://github.com/junit-team/junit4 with thanks.
+
+/**
+ * This interface facilitates the use of expectThrows from Java 8. It allows method references to
+ * void methods (that declare checked exceptions) to be passed directly into expectThrows without
+ * wrapping. It is not meant to be implemented directly.
+ */
+public interface ThrowingRunnable {
+  void run() throws Throwable;
+}
diff --git a/test-apps/database-test-app/src/main/res/layout/test_activity.xml b/firebase-config/src/test/resources/xml/frc_foo.xml
similarity index 52%
rename from test-apps/database-test-app/src/main/res/layout/test_activity.xml
rename to firebase-config/src/test/resources/xml/frc_foo.xml
index dfeeb24e0..afc40b15b 100644
--- a/test-apps/database-test-app/src/main/res/layout/test_activity.xml
+++ b/firebase-config/src/test/resources/xml/frc_foo.xml
@@ -4,8 +4,8 @@
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
   ~
+  ~ You may obtain a copy of the License at
   ~      http://www.apache.org/licenses/LICENSE-2.0
   ~
   ~ Unless required by applicable law or agreed to in writing, software
@@ -15,12 +15,22 @@
   ~ limitations under the License.
   -->
 
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent">
-  <TextView
-      android:id="@+id/restaurant"
-      android:layout_width="match_parent"
-      android:layout_height="wrap_content"
-      />
-</LinearLayout>
\ No newline at end of file
+<resources>
+    <color name="deimachia">#ff9e9e9e</color>
+    <xml name = "dai">
+        <defaults>
+            <entry>
+                <key>first_default_key</key>
+                <value>first_default_value</value>
+            </entry>
+            <entry>
+                <key>second_default_key</key>
+                <value>second_default_value</value>
+            </entry>
+            <entry>
+                <key>third_default_key</key>
+                <value>third_default_value</value>
+            </entry>
+        </defaults><!-- END xml_defaults -->
+    </xml>
+</resources>
\ No newline at end of file
diff --git a/firebase-database-collection/api.txt b/firebase-database-collection/api.txt
new file mode 100644
index 000000000..d802177e2
--- /dev/null
+++ b/firebase-database-collection/api.txt
@@ -0,0 +1 @@
+// Signature format: 2.0
diff --git a/firebase-database-collection/firebase-database-collection.gradle b/firebase-database-collection/firebase-database-collection.gradle
index d2c893053..a9d5af2f3 100644
--- a/firebase-database-collection/firebase-database-collection.gradle
+++ b/firebase-database-collection/firebase-database-collection.gradle
@@ -29,7 +29,7 @@ android {
 }
 
 dependencies {
-    implementation "com.google.android.gms:play-services-base:$playServicesVersion"
+    implementation 'com.google.android.gms:play-services-base:17.0.0'
 
     testImplementation 'junit:junit:4.12'
     testImplementation 'net.java:quickcheck:0.6'
diff --git a/firebase-database-collection/gradle.properties b/firebase-database-collection/gradle.properties
index c763f6446..54be3eb47 100644
--- a/firebase-database-collection/gradle.properties
+++ b/firebase-database-collection/gradle.properties
@@ -1,2 +1,2 @@
-version=16.0.2
-latestReleasedVersion=16.0.1
+version=17.0.1
+latestReleasedVersion=17.0.0
diff --git a/firebase-database-collection/src/main/java/com/google/firebase/database/collection/package-info.java b/firebase-database-collection/src/main/java/com/google/firebase/database/collection/package-info.java
index 149650472..219809342 100644
--- a/firebase-database-collection/src/main/java/com/google/firebase/database/collection/package-info.java
+++ b/firebase-database-collection/src/main/java/com/google/firebase/database/collection/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.collection;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/CHANGELOG.md b/firebase-database/CHANGELOG.md
index 4d78b5421..92d4113f8 100644
--- a/firebase-database/CHANGELOG.md
+++ b/firebase-database/CHANGELOG.md
@@ -1,11 +1,30 @@
-# Unreleased
+# 19.1.1
+- [fixed] Fixed a crash that occurred when we attempted to start a network
+  connection during app shutdown (#672).
+
+# 19.1.0
+- [feature] Added support for the Firebase Database Emulator. To connect to
+  the emulator, specify "http://<emulatorHost>/?ns=<projectId>" as your
+  Database URL (via `FirebaseDatabase.getInstance(String)`).
+  Note that if you are running the Database Emulator on "localhost" and
+  connecting from an app that is running inside an Android Emulator, the
+  emulator host will be "10.0.2.2" followed by its port.
+
+# 18.0.1
+- [changed] The SDK now reports the correct version number (via
+  `FirebaseDatabase.getSdkVersion()`).
+
+# 17.0.0
 - [changed] Added `@RestrictTo` annotations to discourage the use of APIs that
   are not public. This affects internal APIs that were previously obfuscated
   and are not mentioned in our documentation.
 - [changed] Improved error messages for certain Number types that are not
   supported by our serialization layer (#272).
 - [internal] Updated the SDK initialization process and removed usages of
-  deprecated method
+  deprecated method.
+- [changed] Added missing nullability annotations for better Kotlin interop.
+- [internal] Removed ``@PublicApi` annotations as they are no longer enforced
+  and have no semantic meaning.
 
 # 16.0.6  
 - [fixed] Fixed an issue that could cause a NullPointerException during the
diff --git a/firebase-database/api.txt b/firebase-database/api.txt
new file mode 100644
index 000000000..0b8eaa4ea
--- /dev/null
+++ b/firebase-database/api.txt
@@ -0,0 +1,224 @@
+// Signature format: 2.0
+package com.google.firebase.database {
+
+  public interface ChildEventListener {
+    method public void onCancelled(@NonNull com.google.firebase.database.DatabaseError);
+    method public void onChildAdded(@NonNull com.google.firebase.database.DataSnapshot, @Nullable String);
+    method public void onChildChanged(@NonNull com.google.firebase.database.DataSnapshot, @Nullable String);
+    method public void onChildMoved(@NonNull com.google.firebase.database.DataSnapshot, @Nullable String);
+    method public void onChildRemoved(@NonNull com.google.firebase.database.DataSnapshot);
+  }
+
+  public class DataSnapshot {
+    method @NonNull public com.google.firebase.database.DataSnapshot child(@NonNull String);
+    method public boolean exists();
+    method @NonNull public Iterable<DataSnapshot> getChildren();
+    method public long getChildrenCount();
+    method @Nullable public String getKey();
+    method @Nullable public Object getPriority();
+    method @NonNull public com.google.firebase.database.DatabaseReference getRef();
+    method @Nullable public Object getValue();
+    method @Nullable public Object getValue(boolean);
+    method @Nullable public <T> T getValue(@NonNull Class<T>);
+    method @Nullable public <T> T getValue(@NonNull com.google.firebase.database.GenericTypeIndicator<T>);
+    method public boolean hasChild(@NonNull String);
+    method public boolean hasChildren();
+    method public String toString();
+  }
+
+  public class DatabaseError {
+    method @NonNull public static com.google.firebase.database.DatabaseError fromException(@NonNull Throwable);
+    method public int getCode();
+    method @NonNull public String getDetails();
+    method @NonNull public String getMessage();
+    method @NonNull public com.google.firebase.database.DatabaseException toException();
+    method public String toString();
+    field public static final int DATA_STALE = -1; // 0xffffffff
+    field public static final int DISCONNECTED = -4; // 0xfffffffc
+    field public static final int EXPIRED_TOKEN = -6; // 0xfffffffa
+    field public static final int INVALID_TOKEN = -7; // 0xfffffff9
+    field public static final int MAX_RETRIES = -8; // 0xfffffff8
+    field public static final int NETWORK_ERROR = -24; // 0xffffffe8
+    field public static final int OPERATION_FAILED = -2; // 0xfffffffe
+    field public static final int OVERRIDDEN_BY_SET = -9; // 0xfffffff7
+    field public static final int PERMISSION_DENIED = -3; // 0xfffffffd
+    field public static final int UNAVAILABLE = -10; // 0xfffffff6
+    field public static final int UNKNOWN_ERROR = -999; // 0xfffffc19
+    field public static final int USER_CODE_EXCEPTION = -11; // 0xfffffff5
+    field public static final int WRITE_CANCELED = -25; // 0xffffffe7
+  }
+
+  public class DatabaseException {
+  }
+
+  public class DatabaseReference extends com.google.firebase.database.Query {
+    method @NonNull public com.google.firebase.database.DatabaseReference child(@NonNull String);
+    method public boolean equals(Object);
+    method @NonNull public com.google.firebase.database.FirebaseDatabase getDatabase();
+    method @Nullable public String getKey();
+    method @Nullable public com.google.firebase.database.DatabaseReference getParent();
+    method @NonNull public com.google.firebase.database.DatabaseReference getRoot();
+    method public static void goOffline();
+    method public static void goOnline();
+    method public int hashCode();
+    method @NonNull public com.google.firebase.database.OnDisconnect onDisconnect();
+    method @NonNull public com.google.firebase.database.DatabaseReference push();
+    method @NonNull public Task<Void> removeValue();
+    method public void removeValue(@Nullable com.google.firebase.database.DatabaseReference.CompletionListener);
+    method public void runTransaction(@NonNull com.google.firebase.database.Transaction.Handler);
+    method public void runTransaction(@NonNull com.google.firebase.database.Transaction.Handler, boolean);
+    method @NonNull public Task<Void> setPriority(@Nullable Object);
+    method public void setPriority(@Nullable Object, @Nullable com.google.firebase.database.DatabaseReference.CompletionListener);
+    method @NonNull public Task<Void> setValue(@Nullable Object);
+    method @NonNull public Task<Void> setValue(@Nullable Object, @Nullable Object);
+    method public void setValue(@Nullable Object, @Nullable com.google.firebase.database.DatabaseReference.CompletionListener);
+    method public void setValue(@Nullable Object, @Nullable Object, @Nullable com.google.firebase.database.DatabaseReference.CompletionListener);
+    method public String toString();
+    method @NonNull public Task<Void> updateChildren(@NonNull Map<String,Object>);
+    method public void updateChildren(@NonNull Map<String,Object>, @Nullable com.google.firebase.database.DatabaseReference.CompletionListener);
+  }
+
+  public static interface DatabaseReference.CompletionListener {
+    method public void onComplete(@Nullable com.google.firebase.database.DatabaseError, @NonNull com.google.firebase.database.DatabaseReference);
+  }
+
+  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface Exclude {
+  }
+
+  public class FirebaseDatabase {
+    method @NonNull public FirebaseApp getApp();
+    method @NonNull public static com.google.firebase.database.FirebaseDatabase getInstance();
+    method @NonNull public static com.google.firebase.database.FirebaseDatabase getInstance(@NonNull String);
+    method @NonNull public static com.google.firebase.database.FirebaseDatabase getInstance(@NonNull FirebaseApp);
+    method @NonNull public static com.google.firebase.database.FirebaseDatabase getInstance(@NonNull FirebaseApp, @NonNull String);
+    method @NonNull public com.google.firebase.database.DatabaseReference getReference();
+    method @NonNull public com.google.firebase.database.DatabaseReference getReference(@NonNull String);
+    method @NonNull public com.google.firebase.database.DatabaseReference getReferenceFromUrl(@NonNull String);
+    method @NonNull public static String getSdkVersion();
+    method public void goOffline();
+    method public void goOnline();
+    method public void purgeOutstandingWrites();
+    method public void setLogLevel(@NonNull com.google.firebase.database.Logger.Level);
+    method public void setPersistenceCacheSizeBytes(long);
+    method public void setPersistenceEnabled(boolean);
+  }
+
+  public abstract class GenericTypeIndicator<T> {
+    ctor public GenericTypeIndicator();
+  }
+
+  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface IgnoreExtraProperties {
+  }
+
+  public interface Logger {
+  }
+
+  public enum Logger.Level {
+    enum_constant public static final com.google.firebase.database.Logger.Level DEBUG;
+    enum_constant public static final com.google.firebase.database.Logger.Level ERROR;
+    enum_constant public static final com.google.firebase.database.Logger.Level INFO;
+    enum_constant public static final com.google.firebase.database.Logger.Level NONE;
+    enum_constant public static final com.google.firebase.database.Logger.Level WARN;
+  }
+
+  public class MutableData {
+    method @NonNull public com.google.firebase.database.MutableData child(@NonNull String);
+    method public boolean equals(Object);
+    method @NonNull public Iterable<MutableData> getChildren();
+    method public long getChildrenCount();
+    method @Nullable public String getKey();
+    method @Nullable public Object getPriority();
+    method @Nullable public Object getValue();
+    method @Nullable public <T> T getValue(@NonNull Class<T>);
+    method @Nullable public <T> T getValue(@NonNull com.google.firebase.database.GenericTypeIndicator<T>);
+    method public boolean hasChild(@NonNull String);
+    method public boolean hasChildren();
+    method public void setPriority(@Nullable Object);
+    method public void setValue(@Nullable Object) throws com.google.firebase.database.DatabaseException;
+    method public String toString();
+  }
+
+  public class OnDisconnect {
+    method @NonNull public Task<Void> cancel();
+    method public void cancel(@NonNull com.google.firebase.database.DatabaseReference.CompletionListener);
+    method @NonNull public Task<Void> removeValue();
+    method public void removeValue(@Nullable com.google.firebase.database.DatabaseReference.CompletionListener);
+    method @NonNull public Task<Void> setValue(@Nullable Object);
+    method @NonNull public Task<Void> setValue(@Nullable Object, @Nullable String);
+    method @NonNull public Task<Void> setValue(@Nullable Object, double);
+    method public void setValue(@Nullable Object, @Nullable com.google.firebase.database.DatabaseReference.CompletionListener);
+    method public void setValue(@Nullable Object, @Nullable String, @Nullable com.google.firebase.database.DatabaseReference.CompletionListener);
+    method public void setValue(@Nullable Object, double, @Nullable com.google.firebase.database.DatabaseReference.CompletionListener);
+    method public void setValue(@Nullable Object, @Nullable Map, @Nullable com.google.firebase.database.DatabaseReference.CompletionListener);
+    method @NonNull public Task<Void> updateChildren(@NonNull Map<String,Object>);
+    method public void updateChildren(@NonNull Map<String,Object>, @Nullable com.google.firebase.database.DatabaseReference.CompletionListener);
+  }
+
+  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface PropertyName {
+    method public abstract String value();
+  }
+
+  public class Query {
+    method @NonNull public com.google.firebase.database.ChildEventListener addChildEventListener(@NonNull com.google.firebase.database.ChildEventListener);
+    method public void addListenerForSingleValueEvent(@NonNull com.google.firebase.database.ValueEventListener);
+    method @NonNull public com.google.firebase.database.ValueEventListener addValueEventListener(@NonNull com.google.firebase.database.ValueEventListener);
+    method @NonNull public com.google.firebase.database.Query endAt(@Nullable String);
+    method @NonNull public com.google.firebase.database.Query endAt(double);
+    method @NonNull public com.google.firebase.database.Query endAt(boolean);
+    method @NonNull public com.google.firebase.database.Query endAt(@Nullable String, @Nullable String);
+    method @NonNull public com.google.firebase.database.Query endAt(double, @Nullable String);
+    method @NonNull public com.google.firebase.database.Query endAt(boolean, @Nullable String);
+    method @NonNull public com.google.firebase.database.Query equalTo(@Nullable String);
+    method @NonNull public com.google.firebase.database.Query equalTo(double);
+    method @NonNull public com.google.firebase.database.Query equalTo(boolean);
+    method @NonNull public com.google.firebase.database.Query equalTo(@Nullable String, @Nullable String);
+    method @NonNull public com.google.firebase.database.Query equalTo(double, @Nullable String);
+    method @NonNull public com.google.firebase.database.Query equalTo(boolean, @Nullable String);
+    method @NonNull public com.google.firebase.database.DatabaseReference getRef();
+    method public void keepSynced(boolean);
+    method @NonNull public com.google.firebase.database.Query limitToFirst(int);
+    method @NonNull public com.google.firebase.database.Query limitToLast(int);
+    method @NonNull public com.google.firebase.database.Query orderByChild(@NonNull String);
+    method @NonNull public com.google.firebase.database.Query orderByKey();
+    method @NonNull public com.google.firebase.database.Query orderByPriority();
+    method @NonNull public com.google.firebase.database.Query orderByValue();
+    method public void removeEventListener(@NonNull com.google.firebase.database.ValueEventListener);
+    method public void removeEventListener(@NonNull com.google.firebase.database.ChildEventListener);
+    method @NonNull public com.google.firebase.database.Query startAt(@Nullable String);
+    method @NonNull public com.google.firebase.database.Query startAt(double);
+    method @NonNull public com.google.firebase.database.Query startAt(boolean);
+    method @NonNull public com.google.firebase.database.Query startAt(@Nullable String, @Nullable String);
+    method @NonNull public com.google.firebase.database.Query startAt(double, @Nullable String);
+    method @NonNull public com.google.firebase.database.Query startAt(boolean, @Nullable String);
+  }
+
+  public class ServerValue {
+    ctor public ServerValue();
+    field @NonNull public static final Map<String,String> TIMESTAMP;
+  }
+
+  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface ThrowOnExtraProperties {
+  }
+
+  public class Transaction {
+    ctor public Transaction();
+    method @NonNull public static com.google.firebase.database.Transaction.Result abort();
+    method @NonNull public static com.google.firebase.database.Transaction.Result success(@NonNull com.google.firebase.database.MutableData);
+  }
+
+  public static interface Transaction.Handler {
+    method @NonNull public com.google.firebase.database.Transaction.Result doTransaction(@NonNull com.google.firebase.database.MutableData);
+    method public void onComplete(@Nullable com.google.firebase.database.DatabaseError, boolean, @Nullable com.google.firebase.database.DataSnapshot);
+  }
+
+  public static class Transaction.Result {
+    method public boolean isSuccess();
+  }
+
+  public interface ValueEventListener {
+    method public void onCancelled(@NonNull com.google.firebase.database.DatabaseError);
+    method public void onDataChange(@NonNull com.google.firebase.database.DataSnapshot);
+  }
+
+}
+
diff --git a/firebase-database/firebase-database.gradle b/firebase-database/firebase-database.gradle
index 374491084..6c39dfd01 100644
--- a/firebase-database/firebase-database.gradle
+++ b/firebase-database/firebase-database.gradle
@@ -32,7 +32,7 @@ android {
         minSdkVersion project.minSdkVersion
         versionName version
         multiDexEnabled true
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
     }
 
     buildTypes {
@@ -73,19 +73,20 @@ dependencies {
     implementation project(':firebase-common')
     implementation project(':firebase-database-collection')
 
-    implementation "com.google.android.gms:play-services-basement:$playServicesVersion"
-    implementation "com.google.android.gms:play-services-base:$playServicesVersion"
-    implementation "com.google.android.gms:play-services-tasks:$playServicesVersion"
-    implementation('com.google.firebase:firebase-auth-interop:17.0.0') {
+    implementation 'androidx.annotation:annotation:1.1.0'
+    implementation 'com.google.android.gms:play-services-basement:17.0.0'
+    implementation 'com.google.android.gms:play-services-base:17.0.0'
+    implementation 'com.google.android.gms:play-services-tasks:17.0.0'
+    implementation('com.google.firebase:firebase-auth-interop:18.0.0') {
         exclude group: "com.google.firebase", module: "firebase-common"
     }
 
-    androidTestImplementation "com.android.support:support-annotations:$supportAnnotationsVersion"
-    androidTestImplementation 'com.android.support.test:rules:1.0.2'
-    androidTestImplementation 'com.android.support.test:runner:1.0.2'
+    androidTestImplementation "androidx.annotation:annotation:1.1.0"
+    androidTestImplementation 'androidx.test:rules:1.2.0'
+    androidTestImplementation 'androidx.test:runner:1.2.0'
     androidTestImplementation "com.google.truth:truth:$googleTruthVersion"
-    androidTestImplementation 'com.fasterxml.jackson.core:jackson-core:2.9.6'
-    androidTestImplementation 'com.fasterxml.jackson.core:jackson-databind:2.9.6'
+    androidTestImplementation 'com.fasterxml.jackson.core:jackson-core:2.9.8'
+    androidTestImplementation 'com.fasterxml.jackson.core:jackson-databind:2.9.8'
     androidTestImplementation 'junit:junit:4.12'
     androidTestImplementation 'net.java:quickcheck:0.6'
     androidTestAnnotationProcessor 'net.java:quickcheck-src-generator:0.6'
@@ -93,14 +94,14 @@ dependencies {
 
 
     testImplementation 'junit:junit:4.12'
-    testImplementation 'org.mockito:mockito-core:2.21.0'
+    testImplementation 'org.mockito:mockito-core:2.25.0'
     testImplementation "org.robolectric:robolectric:$robolectricVersion"
     testImplementation 'com.firebase:firebase-token-generator:2.0.0'
-    testImplementation 'com.fasterxml.jackson.core:jackson-core:2.9.6'
-    testImplementation 'com.fasterxml.jackson.core:jackson-databind:2.9.6'
+    testImplementation 'com.fasterxml.jackson.core:jackson-core:2.9.8'
+    testImplementation 'com.fasterxml.jackson.core:jackson-databind:2.9.8'
     testImplementation 'net.java.quickcheck:quickcheck:0.6'
     testImplementation "com.google.truth:truth:$googleTruthVersion"
-    testImplementation 'com.android.support.test:rules:1.0.2'
+    testImplementation 'androidx.test:rules:1.2.0'
 
 }
 
diff --git a/firebase-database/gradle.properties b/firebase-database/gradle.properties
index f4ae1a575..96e814439 100644
--- a/firebase-database/gradle.properties
+++ b/firebase-database/gradle.properties
@@ -12,6 +12,6 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-version=17.0.0
-latestReleasedVersion=16.1.0
+version=19.1.0
+latestReleasedVersion=19.0.0
 android.enableUnitTestBinaryResources=true
diff --git a/firebase-database/src/androidTest/AndroidManifest.xml b/firebase-database/src/androidTest/AndroidManifest.xml
index 78a493dfb..3df3c947f 100644
--- a/firebase-database/src/androidTest/AndroidManifest.xml
+++ b/firebase-database/src/androidTest/AndroidManifest.xml
@@ -28,6 +28,6 @@
     </application>
 
     <instrumentation
-        android:name="android.support.test.runner.AndroidJUnitRunner"
+        android:name="androidx.test.runner.AndroidJUnitRunner"
         android:targetPackage="com.google.firebase.database.android" />
 </manifest>
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/DataTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/DataTest.java
index cad2393d6..36b5ccbd5 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/DataTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/DataTest.java
@@ -22,7 +22,7 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.core.DatabaseConfig;
 import com.google.firebase.database.core.Path;
 import com.google.firebase.database.core.RepoManager;
@@ -1081,9 +1081,9 @@ public void urlEncodingAndDecodingWorks()
         new DatabaseReference(
             IntegrationTestValues.getNamespace() + "/a%b&c@d/space: /non-ascii:", ctx);
     String result = ref.toString();
-    String expected =
+    String encoded =
         IntegrationTestValues.getNamespace() + "/a%25b%26c%40d/space%3A%20/non-ascii%3A%C3%B8";
-    assertEquals(expected, result);
+    assertEquals(encoded, result);
 
     String child = "" + new Random().nextInt(100000000);
     new WriteFuture(ref.child(child), "testdata").timedGet();
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/EventTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/EventTest.java
index 2ef116394..09b4e9478 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/EventTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/EventTest.java
@@ -19,7 +19,7 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.core.ZombieVerifier;
 import com.google.firebase.database.core.view.Event;
 import com.google.firebase.database.future.ReadFuture;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/FirebaseDatabaseTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/FirebaseDatabaseTest.java
index 73d4048d6..b62753659 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/FirebaseDatabaseTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/FirebaseDatabaseTest.java
@@ -20,8 +20,8 @@
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.fail;
 
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.FirebaseOptions;
 import com.google.firebase.database.core.DatabaseConfig;
@@ -170,7 +170,7 @@ public void persistenceSettings() {
     config.setPersistenceCacheSizeBytes(1 * 1024 * 1024);
 
     try {
-      FirebaseDatabase db = new DatabaseReference("", config).getDatabase();
+      FirebaseDatabase db = new DatabaseReference("http://localhost", config).getDatabase();
       db.setPersistenceCacheSizeBytes(1 * 1024 * 1024);
       fail("should throw - can't modify after init");
     } catch (DatabaseException e) {
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/InfoTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/InfoTest.java
index 6b1fef1dd..6a98da64f 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/InfoTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/InfoTest.java
@@ -19,7 +19,7 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.core.DatabaseConfig;
 import com.google.firebase.database.core.RepoManager;
 import com.google.firebase.database.future.ReadFuture;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/IntegrationTestValues.java b/firebase-database/src/androidTest/java/com/google/firebase/database/IntegrationTestValues.java
index 70db005d2..71e877985 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/IntegrationTestValues.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/IntegrationTestValues.java
@@ -15,7 +15,7 @@
 package com.google.firebase.database;
 
 import android.content.Context;
-import android.support.test.InstrumentationRegistry;
+import androidx.test.InstrumentationRegistry;
 
 public class IntegrationTestValues {
   private static final String TEST_ALT_NAMESPACE = "https://test.firebaseio.com";
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/ObjectMapTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/ObjectMapTest.java
index 33ca479bf..901b15e39 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/ObjectMapTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/ObjectMapTest.java
@@ -18,7 +18,7 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.snapshot.EmptyNode;
 import java.io.IOException;
 import java.util.ArrayList;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/OrderByTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/OrderByTest.java
index 50c4d5e58..d704dd43b 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/OrderByTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/OrderByTest.java
@@ -16,7 +16,7 @@
 
 import static org.junit.Assert.assertEquals;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.future.ReadFuture;
 import com.google.firebase.database.future.WriteFuture;
 import java.util.ArrayList;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/OrderTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/OrderTest.java
index e0cc95621..5572a0e53 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/OrderTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/OrderTest.java
@@ -19,7 +19,7 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.core.view.Event;
 import com.google.firebase.database.future.ReadFuture;
 import com.google.firebase.database.future.WriteFuture;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/QueryTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/QueryTest.java
index d3eef2aeb..c9bd4da5f 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/QueryTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/QueryTest.java
@@ -21,7 +21,7 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.core.DatabaseConfig;
 import com.google.firebase.database.core.Path;
 import com.google.firebase.database.core.RepoManager;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/RealtimeTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/RealtimeTest.java
index 898db04ab..1f590d274 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/RealtimeTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/RealtimeTest.java
@@ -20,11 +20,9 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.core.DatabaseConfig;
 import com.google.firebase.database.core.RepoManager;
-import com.google.firebase.database.core.utilities.ParsedUrl;
-import com.google.firebase.database.core.utilities.Utilities;
 import com.google.firebase.database.future.ReadFuture;
 import com.google.firebase.database.future.WriteFuture;
 import java.util.List;
@@ -48,21 +46,6 @@ public void tearDown() {
     IntegrationTestHelpers.failOnFirstUncaughtException();
   }
 
-  @Test
-  public void testUrlParsing() throws DatabaseException {
-    ParsedUrl parsed = Utilities.parseUrl("http://gsoltis.fblocal.com:9000");
-    assertEquals(parsed.path.toString(), "/");
-    assertEquals(parsed.repoInfo.host, "gsoltis.fblocal.com:9000");
-    assertEquals(parsed.repoInfo.internalHost, "gsoltis.fblocal.com:9000");
-    assertEquals(parsed.repoInfo.secure, false);
-
-    parsed = Utilities.parseUrl("http://gsoltis.firebaseio.com/foo/bar");
-    assertEquals(parsed.path.toString(), "/foo/bar");
-    assertEquals(parsed.repoInfo.host, "gsoltis.firebaseio.com");
-    assertEquals(parsed.repoInfo.internalHost, "gsoltis.firebaseio.com");
-    assertEquals(parsed.repoInfo.secure, true);
-  }
-
   @Test
   public void testOnDisconnectSetWorks()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/TransactionTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/TransactionTest.java
index 823395988..38a1b409a 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/TransactionTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/TransactionTest.java
@@ -22,7 +22,7 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.DatabaseReference.CompletionListener;
 import com.google.firebase.database.core.AuthTokenProvider;
 import com.google.firebase.database.core.DatabaseConfig;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/connection/ConnectionTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/connection/ConnectionTest.java
index 870fc902e..12c7ccf33 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/connection/ConnectionTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/connection/ConnectionTest.java
@@ -16,7 +16,7 @@
 
 import static org.junit.Assert.assertFalse;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.IntegrationTestHelpers;
 import com.google.firebase.database.IntegrationTestValues;
 import com.google.firebase.database.RetryRule;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/core/AndroidPlatformTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/core/AndroidPlatformTest.java
index 620889044..0add8f5ae 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/core/AndroidPlatformTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/core/AndroidPlatformTest.java
@@ -17,7 +17,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.FirebaseDatabase;
 import com.google.firebase.database.IntegrationTestHelpers;
 import org.junit.Test;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/KeepSyncedTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/KeepSyncedTest.java
index dd4baf477..b3c20a544 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/KeepSyncedTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/KeepSyncedTest.java
@@ -16,7 +16,7 @@
 
 import static org.junit.Assert.assertEquals;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.DatabaseReference;
 import com.google.firebase.database.EventRecord;
 import com.google.firebase.database.IntegrationTestHelpers;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/PersistenceTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/PersistenceTest.java
index ac7467043..e8b6ab528 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/PersistenceTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/PersistenceTest.java
@@ -31,7 +31,7 @@
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertTrue;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.DataSnapshot;
 import com.google.firebase.database.DatabaseError;
 import com.google.firebase.database.DatabaseReference;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/PruningTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/PruningTest.java
index 555e5d885..4046e30d8 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/PruningTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/PruningTest.java
@@ -20,8 +20,8 @@
 import static com.google.firebase.database.IntegrationTestHelpers.path;
 import static org.junit.Assert.assertEquals;
 
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.RetryRule;
 import com.google.firebase.database.android.SqlPersistenceStorageEngine;
 import com.google.firebase.database.core.DatabaseConfig;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/SqlPersistenceStorageEngineTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/SqlPersistenceStorageEngineTest.java
index db264ef38..091d070d1 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/SqlPersistenceStorageEngineTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/SqlPersistenceStorageEngineTest.java
@@ -27,8 +27,8 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.DatabaseException;
 import com.google.firebase.database.RetryRule;
 import com.google.firebase.database.android.SqlPersistenceStorageEngine;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/integration/ShutdownExample.java b/firebase-database/src/androidTest/java/com/google/firebase/database/integration/ShutdownExample.java
index dc4456ae2..7c3329025 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/integration/ShutdownExample.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/integration/ShutdownExample.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.database.integration;
 
-import android.support.test.InstrumentationRegistry;
+import androidx.test.InstrumentationRegistry;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.FirebaseOptions;
 import com.google.firebase.database.DataSnapshot;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/snapshot/CompoundHashTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/snapshot/CompoundHashTest.java
index 8a0b50e5e..8db272e18 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/snapshot/CompoundHashTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/snapshot/CompoundHashTest.java
@@ -20,7 +20,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.MapBuilder;
 import com.google.firebase.database.RetryRule;
 import com.google.firebase.database.core.Path;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/snapshot/CompoundHashingIntegrationTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/snapshot/CompoundHashingIntegrationTest.java
index f9d0d38c3..3a9a8190e 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/snapshot/CompoundHashingIntegrationTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/snapshot/CompoundHashingIntegrationTest.java
@@ -17,7 +17,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.database.IntegrationTestValues;
 import com.google.firebase.database.RetryRule;
 import com.google.firebase.database.core.Path;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/ChildEventListener.java b/firebase-database/src/main/java/com/google/firebase/database/ChildEventListener.java
index 80c6df88a..d8843c6fc 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/ChildEventListener.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/ChildEventListener.java
@@ -14,9 +14,8 @@
 
 package com.google.firebase.database;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 
 /**
  * Classes implementing this interface can be used to receive events about changes in the child
@@ -24,7 +23,6 @@
  * location using {@link DatabaseReference#addChildEventListener(ChildEventListener)} and the
  * appropriate method will be triggered when changes occur.
  */
-@PublicApi
 public interface ChildEventListener {
 
   /**
@@ -35,7 +33,6 @@
    * @param previousChildName The key name of sibling location ordered before the new child. This
    *     will be null for the first child node of a location.
    */
-  @PublicApi
   public void onChildAdded(@NonNull DataSnapshot snapshot, @Nullable String previousChildName);
 
   /**
@@ -45,7 +42,6 @@
    * @param previousChildName The key name of sibling location ordered before the child. This will
    *     be null for the first child node of a location.
    */
-  @PublicApi
   public void onChildChanged(@NonNull DataSnapshot snapshot, @Nullable String previousChildName);
 
   /**
@@ -54,7 +50,6 @@
    *
    * @param snapshot An immutable snapshot of the data at the child that was removed.
    */
-  @PublicApi
   public void onChildRemoved(@NonNull DataSnapshot snapshot);
 
   /**
@@ -67,7 +62,6 @@
    * @param previousChildName The key name of the sibling location ordered before the child
    *     location. This will be null if this location is ordered first.
    */
-  @PublicApi
   public void onChildMoved(@NonNull DataSnapshot snapshot, @Nullable String previousChildName);
 
   /**
@@ -78,6 +72,5 @@
    *
    * @param error A description of the error that occurred
    */
-  @PublicApi
   public void onCancelled(@NonNull DatabaseError error);
 }
diff --git a/firebase-database/src/main/java/com/google/firebase/database/DataSnapshot.java b/firebase-database/src/main/java/com/google/firebase/database/DataSnapshot.java
index 6283c992d..11db5a93b 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/DataSnapshot.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/DataSnapshot.java
@@ -14,9 +14,8 @@
 
 package com.google.firebase.database;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.database.core.Path;
 import com.google.firebase.database.core.utilities.Validation;
 import com.google.firebase.database.core.utilities.encoding.CustomClassMapper;
@@ -39,7 +38,6 @@
  * DatabaseReference DatabaseReference} reference (e.g. with {@link
  * DatabaseReference#setValue(Object)}).
  */
-@PublicApi
 public class DataSnapshot {
 
   private final IndexedNode node;
@@ -63,7 +61,6 @@
    * @return The DataSnapshot for the child location
    */
   @NonNull
-  @PublicApi
   public DataSnapshot child(@NonNull String path) {
     DatabaseReference childRef = query.child(path);
     Node childNode = this.node.getNode().getChild(new Path(path));
@@ -76,7 +73,6 @@ public DataSnapshot child(@NonNull String path) {
    * @param path A relative path to the location of child data
    * @return Whether or not the specified child location has data
    */
-  @PublicApi
   public boolean hasChild(@NonNull String path) {
     if (query.getParent() == null) {
       Validation.validateRootPathString(path);
@@ -91,7 +87,6 @@ public boolean hasChild(@NonNull String path) {
    *
    * @return True if the snapshot has any children, otherwise false
    */
-  @PublicApi
   public boolean hasChildren() {
     return node.getNode().getChildCount() > 0;
   }
@@ -101,7 +96,6 @@ public boolean hasChildren() {
    *
    * @return True if the snapshot contains a non-null value, otherwise false
    */
-  @PublicApi
   public boolean exists() {
     return !node.getNode().isEmpty();
   }
@@ -126,7 +120,6 @@ public boolean exists() {
    *     location.
    */
   @Nullable
-  @PublicApi
   public Object getValue() {
     return node.getNode().getValue();
   }
@@ -156,7 +149,6 @@ public Object getValue() {
    *     location.
    */
   @Nullable
-  @PublicApi
   public Object getValue(boolean useExportFormat) {
     return node.getNode().getValue(useExportFormat);
   }
@@ -206,7 +198,6 @@ public Object getValue(boolean useExportFormat) {
    *     if there is no data at this location.
    */
   @Nullable
-  @PublicApi
   public <T> T getValue(@NonNull Class<T> valueType) {
     Object value = node.getNode().getValue();
     return CustomClassMapper.convertToCustomClass(value, valueType);
@@ -233,14 +224,12 @@ public Object getValue(boolean useExportFormat) {
    *     there is no data at this location.
    */
   @Nullable
-  @PublicApi
   public <T> T getValue(@NonNull GenericTypeIndicator<T> t) {
     Object value = node.getNode().getValue();
     return CustomClassMapper.convertToCustomClass(value, t);
   }
 
   /** @return The number of immediate children in the this snapshot */
-  @PublicApi
   public long getChildrenCount() {
     return node.getNode().getChildCount();
   }
@@ -251,7 +240,6 @@ public long getChildrenCount() {
    * @return A DatabaseReference corresponding to the location that this snapshot came from
    */
   @NonNull
-  @PublicApi
   public DatabaseReference getRef() {
     return query;
   }
@@ -261,7 +249,6 @@ public DatabaseReference getRef() {
    *     to the database root.
    */
   @Nullable
-  @PublicApi
   public String getKey() {
     return query.getKey();
   }
@@ -277,7 +264,6 @@ public String getKey() {
    * @return The immediate children of this snapshot
    */
   @NonNull
-  @PublicApi
   public Iterable<DataSnapshot> getChildren() {
     final Iterator<NamedNode> iter = node.iterator();
     return new Iterable<DataSnapshot>() {
@@ -321,7 +307,6 @@ public void remove() {
    * @return the priority of the data contained in this snapshot as a native type
    */
   @Nullable
-  @PublicApi
   public Object getPriority() {
     Object priority = node.getNode().getPriority().getValue();
     if (priority instanceof Long) {
diff --git a/firebase-database/src/main/java/com/google/firebase/database/DatabaseError.java b/firebase-database/src/main/java/com/google/firebase/database/DatabaseError.java
index 37a788435..7bc03f938 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/DatabaseError.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/DatabaseError.java
@@ -14,9 +14,8 @@
 
 package com.google.firebase.database;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.RestrictTo;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
+import androidx.annotation.RestrictTo;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.HashMap;
@@ -26,49 +25,48 @@
  * Instances of DatabaseError are passed to callbacks when an operation failed. They contain a
  * description of the specific error that occurred.
  */
-@PublicApi
 public class DatabaseError {
 
   /** <strong>Internal use</strong> */
-  @PublicApi public static final int DATA_STALE = -1;
+  public static final int DATA_STALE = -1;
   /** The server indicated that this operation failed */
-  @PublicApi public static final int OPERATION_FAILED = -2;
+  public static final int OPERATION_FAILED = -2;
   /** This client does not have permission to perform this operation */
-  @PublicApi public static final int PERMISSION_DENIED = -3;
+  public static final int PERMISSION_DENIED = -3;
   /** The operation had to be aborted due to a network disconnect */
-  @PublicApi public static final int DISCONNECTED = -4;
+  public static final int DISCONNECTED = -4;
 
   // Preempted was removed, this is for here for completeness and history
   // public static final int PREEMPTED = -5;
 
   /** The supplied auth token has expired */
-  @PublicApi public static final int EXPIRED_TOKEN = -6;
+  public static final int EXPIRED_TOKEN = -6;
   /**
    * The specified authentication token is invalid. This can occur when the token is malformed,
    * expired, or the secret that was used to generate it has been revoked.
    */
-  @PublicApi public static final int INVALID_TOKEN = -7;
+  public static final int INVALID_TOKEN = -7;
   /** The transaction had too many retries */
-  @PublicApi public static final int MAX_RETRIES = -8;
+  public static final int MAX_RETRIES = -8;
   /** The transaction was overridden by a subsequent set */
-  @PublicApi public static final int OVERRIDDEN_BY_SET = -9;
+  public static final int OVERRIDDEN_BY_SET = -9;
   /** The service is unavailable */
-  @PublicApi public static final int UNAVAILABLE = -10;
+  public static final int UNAVAILABLE = -10;
   /** An exception occurred in user code */
-  @PublicApi public static final int USER_CODE_EXCEPTION = -11;
+  public static final int USER_CODE_EXCEPTION = -11;
 
   // client codes
   /** The operation could not be performed due to a network error. */
-  @PublicApi public static final int NETWORK_ERROR = -24;
+  public static final int NETWORK_ERROR = -24;
 
   /** The write was canceled locally */
-  @PublicApi public static final int WRITE_CANCELED = -25;
+  public static final int WRITE_CANCELED = -25;
 
   /**
    * An unknown error occurred. Please refer to the error message and error details for more
    * information.
    */
-  @PublicApi public static final int UNKNOWN_ERROR = -999;
+  public static final int UNKNOWN_ERROR = -999;
 
   private static final Map<Integer, String> errorReasons = new HashMap<Integer, String>();
 
@@ -175,8 +173,8 @@ public static DatabaseError fromStatus(String status, String reason, String deta
     return new DatabaseError(code, message, details);
   }
 
-  @PublicApi
-  public static DatabaseError fromException(Throwable e) {
+  @NonNull
+  public static DatabaseError fromException(@NonNull Throwable e) {
     StringWriter stringWriter = new StringWriter();
     PrintWriter printWriter = new PrintWriter(stringWriter);
     e.printStackTrace(printWriter);
@@ -199,21 +197,18 @@ private DatabaseError(int code, String message, String details) {
   }
 
   /** @return One of the defined status codes, depending on the error */
-  @PublicApi
   public int getCode() {
     return code;
   }
 
   /** @return A human-readable description of the error */
   @NonNull
-  @PublicApi
   public String getMessage() {
     return message;
   }
 
   /** @return Human-readable details on the error and additional information, e.g. links to docs; */
   @NonNull
-  @PublicApi
   public String getDetails() {
     return details;
   }
@@ -229,7 +224,7 @@ public String toString() {
    *
    * @return An exception wrapping this error, with an appropriate message and no stack trace.
    */
-  @PublicApi
+  @NonNull
   public DatabaseException toException() {
     return new DatabaseException("Firebase Database error: " + message);
   }
diff --git a/firebase-database/src/main/java/com/google/firebase/database/DatabaseException.java b/firebase-database/src/main/java/com/google/firebase/database/DatabaseException.java
index 1d9992ab6..e362414cb 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/DatabaseException.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/DatabaseException.java
@@ -14,14 +14,12 @@
 
 package com.google.firebase.database;
 
-import android.support.annotation.RestrictTo;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.RestrictTo;
 
 /**
  * This error is thrown when the Firebase Database library is unable to operate on the input it has
  * been given.
  */
-@PublicApi
 public class DatabaseException extends RuntimeException {
 
   /**
diff --git a/firebase-database/src/main/java/com/google/firebase/database/DatabaseReference.java b/firebase-database/src/main/java/com/google/firebase/database/DatabaseReference.java
index 8140e0b08..85e511041 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/DatabaseReference.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/DatabaseReference.java
@@ -14,10 +14,9 @@
 
 package com.google.firebase.database;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.tasks.Task;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.database.core.CompoundWrite;
 import com.google.firebase.database.core.DatabaseConfig;
 import com.google.firebase.database.core.Path;
@@ -45,7 +44,6 @@
  * <p>This class is the starting point for all Database operations. After you've initialized it with
  * a URL, you can use it to read data, write data, and to create new DatabaseReferences.
  */
-@PublicApi
 public class DatabaseReference extends Query {
 
   private static DatabaseConfig defaultConfig;
@@ -56,7 +54,6 @@
    *
    * @since 1.1
    */
-  @PublicApi
   public interface CompletionListener {
 
     /**
@@ -66,7 +63,6 @@
      * @param error A description of any errors that occurred or null on success
      * @param ref A reference to the specified Firebase Database location
      */
-    @PublicApi
     public void onComplete(
         @Nullable final DatabaseError error, @NonNull final DatabaseReference ref);
   }
@@ -95,7 +91,6 @@ private DatabaseReference(ParsedUrl parsedUrl, DatabaseConfig config) {
    * @return A new DatabaseReference to the given path
    */
   @NonNull
-  @PublicApi
   public DatabaseReference child(@NonNull String pathString) {
     if (pathString == null) {
       throw new NullPointerException("Can't pass null for argument 'pathString' in child()");
@@ -119,7 +114,6 @@ public DatabaseReference child(@NonNull String pathString) {
    * @return A DatabaseReference pointing to the new location
    */
   @NonNull
-  @PublicApi
   public DatabaseReference push() {
     String childNameStr = PushIdGenerator.generatePushChildName(repo.getServerTime());
     ChildKey childKey = ChildKey.fromString(childNameStr);
@@ -161,7 +155,6 @@ public DatabaseReference push() {
    * @return The {@link Task} for this operation.
    */
   @NonNull
-  @PublicApi
   public Task<Void> setValue(@Nullable Object value) {
     return setValueInternal(value, PriorityUtilities.parsePriority(this.path, null), null);
   }
@@ -202,7 +195,6 @@ public DatabaseReference push() {
    * @return The {@link Task} for this operation.
    */
   @NonNull
-  @PublicApi
   public Task<Void> setValue(@Nullable Object value, @Nullable Object priority) {
     return setValueInternal(value, PriorityUtilities.parsePriority(this.path, priority), null);
   }
@@ -241,7 +233,6 @@ public DatabaseReference push() {
    * @param value The value to set at this location or null to delete the existing data
    * @param listener A listener that will be triggered with the results of the operation
    */
-  @PublicApi
   public void setValue(@Nullable Object value, @Nullable CompletionListener listener) {
     setValueInternal(value, PriorityUtilities.parsePriority(this.path, null), listener);
   }
@@ -280,7 +271,6 @@ public void setValue(@Nullable Object value, @Nullable CompletionListener listen
    * @param priority The priority to set at this location or null to clear the existing priority
    * @param listener A listener that will be triggered with the results of the operation
    */
-  @PublicApi
   public void setValue(
       @Nullable Object value, @Nullable Object priority, @Nullable CompletionListener listener) {
     setValueInternal(value, PriorityUtilities.parsePriority(this.path, priority), listener);
@@ -335,7 +325,6 @@ public void run() {
    * @return The {@link Task} for this operation.
    */
   @NonNull
-  @PublicApi
   public Task<Void> setPriority(@Nullable Object priority) {
     return setPriorityInternal(PriorityUtilities.parsePriority(this.path, priority), null);
   }
@@ -370,7 +359,6 @@ public void run() {
    *     priority
    * @param listener A listener that will be triggered with results of the operation
    */
-  @PublicApi
   public void setPriority(@Nullable Object priority, @Nullable CompletionListener listener) {
     setPriorityInternal(PriorityUtilities.parsePriority(this.path, priority), listener);
   }
@@ -400,7 +388,6 @@ public void run() {
    * @return The {@link Task} for this operation.
    */
   @NonNull
-  @PublicApi
   public Task<Void> updateChildren(@NonNull Map<String, Object> update) {
     return updateChildrenInternal(update, null);
   }
@@ -412,7 +399,6 @@ public void run() {
    * @param update The paths to update and their new values
    * @param listener A listener that will be triggered with results of the operation
    */
-  @PublicApi
   public void updateChildren(
       @NonNull final Map<String, Object> update, @Nullable final CompletionListener listener) {
     updateChildrenInternal(update, listener);
@@ -447,7 +433,6 @@ public void run() {
    * @return The {@link Task} for this operation.
    */
   @NonNull
-  @PublicApi
   public Task<Void> removeValue() {
     return setValue(null);
   }
@@ -457,7 +442,6 @@ public void run() {
    *
    * @param listener A listener that will be triggered when the operation is complete
    */
-  @PublicApi
   public void removeValue(@Nullable CompletionListener listener) {
     setValue(null, listener);
   }
@@ -469,7 +453,6 @@ public void removeValue(@Nullable CompletionListener listener) {
    *
    * @return An object for managing disconnect operations at this location
    */
-  @PublicApi
   @NonNull
   public OnDisconnect onDisconnect() {
     Validation.validateWritablePath(getPath());
@@ -484,7 +467,6 @@ public OnDisconnect onDisconnect() {
    *
    * @param handler An object to handle running the transaction
    */
-  @PublicApi
   public void runTransaction(@NonNull Transaction.Handler handler) {
     runTransaction(handler, true);
   }
@@ -497,7 +479,6 @@ public void runTransaction(@NonNull Transaction.Handler handler) {
    * @param fireLocalEvents Defaults to true. If set to false, events will only be fired for the
    *     final result state of the transaction, and not for any intermediate states
    */
-  @PublicApi
   public void runTransaction(
       @NonNull final Transaction.Handler handler, final boolean fireLocalEvents) {
     if (handler == null) {
@@ -538,7 +519,6 @@ public void run() {
    *
    * <p>Note: Invoking this method will impact all Firebase Database connections.
    */
-  @PublicApi
   public static void goOffline() {
     goOffline(getDefaultConfig());
   }
@@ -553,7 +533,6 @@ static void goOffline(DatabaseConfig config) {
    *
    * <p>Note: Invoking this method will impact all Firebase Database connections.
    */
-  @PublicApi
   public static void goOnline() {
     goOnline(getDefaultConfig());
   }
@@ -570,7 +549,6 @@ static void goOnline(DatabaseConfig config) {
    * @return The Database object for this reference.
    */
   @NonNull
-  @PublicApi
   public FirebaseDatabase getDatabase() {
     return this.repo.getDatabase();
   }
@@ -595,7 +573,6 @@ public String toString() {
    *     root location
    */
   @Nullable
-  @PublicApi
   public DatabaseReference getParent() {
     Path parentPath = getPath().getParent();
     if (parentPath != null) {
@@ -607,7 +584,6 @@ public DatabaseReference getParent() {
 
   /** @return A reference to the root location of this Firebase Database */
   @NonNull
-  @PublicApi
   public DatabaseReference getRoot() {
     return new DatabaseReference(repo, new Path(""));
   }
@@ -617,7 +593,6 @@ public DatabaseReference getRoot() {
    *     points to the database root
    */
   @Nullable
-  @PublicApi
   public String getKey() {
     if (getPath().isEmpty()) {
       return null;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/DatabaseRegistrar.java b/firebase-database/src/main/java/com/google/firebase/database/DatabaseRegistrar.java
index 32a67e369..3928bce8a 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/DatabaseRegistrar.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/DatabaseRegistrar.java
@@ -14,8 +14,8 @@
 
 package com.google.firebase.database;
 
-import android.support.annotation.Keep;
-import android.support.annotation.RestrictTo;
+import androidx.annotation.Keep;
+import androidx.annotation.RestrictTo;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.auth.internal.InternalAuthProvider;
 import com.google.firebase.components.Component;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/Exclude.java b/firebase-database/src/main/java/com/google/firebase/database/Exclude.java
index cf41e3f29..7c4d42277 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/Exclude.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/Exclude.java
@@ -14,7 +14,6 @@
 
 package com.google.firebase.database;
 
-import com.google.firebase.annotations.PublicApi;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -23,5 +22,4 @@
 /** Marks a field as excluded from the Database. */
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.FIELD})
-@PublicApi
 public @interface Exclude {}
diff --git a/firebase-database/src/main/java/com/google/firebase/database/FirebaseDatabase.java b/firebase-database/src/main/java/com/google/firebase/database/FirebaseDatabase.java
index 84b6a1f9c..d9a79a3d4 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/FirebaseDatabase.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/FirebaseDatabase.java
@@ -16,11 +16,10 @@
 
 import static com.google.android.gms.common.internal.Preconditions.checkNotNull;
 
-import android.support.annotation.NonNull;
 import android.text.TextUtils;
+import androidx.annotation.NonNull;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.FirebaseOptions;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.database.core.DatabaseConfig;
 import com.google.firebase.database.core.Path;
 import com.google.firebase.database.core.Repo;
@@ -35,10 +34,9 @@
  * FirebaseDatabase#getInstance()}. To access a location in the database and read or write data, use
  * {@link FirebaseDatabase#getReference()}.
  */
-@PublicApi
 public class FirebaseDatabase {
 
-  private static final String SDK_VERSION = "3.0.0";
+  private static final String SDK_VERSION = BuildConfig.VERSION_NAME;
 
   private final FirebaseApp app;
   private final RepoInfo repoInfo;
@@ -51,7 +49,6 @@
    * @return A FirebaseDatabase instance.
    */
   @NonNull
-  @PublicApi
   public static FirebaseDatabase getInstance() {
     FirebaseApp instance = FirebaseApp.getInstance();
     if (instance == null) {
@@ -67,7 +64,6 @@ public static FirebaseDatabase getInstance() {
    * @return A FirebaseDatabase instance.
    */
   @NonNull
-  @PublicApi
   public static FirebaseDatabase getInstance(@NonNull String url) {
     FirebaseApp instance = FirebaseApp.getInstance();
     if (instance == null) {
@@ -83,7 +79,6 @@ public static FirebaseDatabase getInstance(@NonNull String url) {
    * @return A FirebaseDatabase instance.
    */
   @NonNull
-  @PublicApi
   public static FirebaseDatabase getInstance(@NonNull FirebaseApp app) {
     return getInstance(app, app.getOptions().getDatabaseUrl());
   }
@@ -96,7 +91,6 @@ public static FirebaseDatabase getInstance(@NonNull FirebaseApp app) {
    * @return A FirebaseDatabase instance.
    */
   @NonNull
-  @PublicApi
   public static synchronized FirebaseDatabase getInstance(
       @NonNull FirebaseApp app, @NonNull String url) {
     if (TextUtils.isEmpty(url)) {
@@ -141,7 +135,6 @@ static FirebaseDatabase createForTests(
    * @return The FirebaseApp instance to which this FirebaseDatabase belongs.
    */
   @NonNull
-  @PublicApi
   public FirebaseApp getApp() {
     return this.app;
   }
@@ -152,7 +145,6 @@ public FirebaseApp getApp() {
    * @return A DatabaseReference pointing to the root node.
    */
   @NonNull
-  @PublicApi
   public DatabaseReference getReference() {
     ensureRepo();
     return new DatabaseReference(this.repo, Path.getEmptyPath());
@@ -165,7 +157,6 @@ public DatabaseReference getReference() {
    * @return A DatabaseReference pointing to the specified path.
    */
   @NonNull
-  @PublicApi
   public DatabaseReference getReference(@NonNull String path) {
     ensureRepo();
 
@@ -189,7 +180,6 @@ public DatabaseReference getReference(@NonNull String path) {
    * @return A DatabaseReference for the provided URL.
    */
   @NonNull
-  @PublicApi
   public DatabaseReference getReferenceFromUrl(@NonNull String url) {
     ensureRepo();
 
@@ -221,7 +211,6 @@ public DatabaseReference getReferenceFromUrl(@NonNull String url) {
    * writes. The writes will be rolled back locally, perhaps triggering events for affected event
    * listeners, and the client will not (re-)send them to the Firebase backend.
    */
-  @PublicApi
   public void purgeOutstandingWrites() {
     ensureRepo();
     this.repo.scheduleNow(
@@ -237,7 +226,6 @@ public void run() {
    * Resumes our connection to the Firebase Database backend after a previous {@link #goOffline()}
    * call.
    */
-  @PublicApi
   public void goOnline() {
     ensureRepo();
     RepoManager.resume(this.repo);
@@ -246,7 +234,6 @@ public void goOnline() {
   /**
    * Shuts down our connection to the Firebase Database backend until {@link #goOnline()} is called.
    */
-  @PublicApi
   public void goOffline() {
     ensureRepo();
     RepoManager.interrupt(this.repo);
@@ -260,7 +247,6 @@ public void goOffline() {
    *
    * @param logLevel The desired minimum log level
    */
-  @PublicApi
   public synchronized void setLogLevel(@NonNull Logger.Level logLevel) {
     assertUnfrozen("setLogLevel");
     this.config.setLogLevel(logLevel);
@@ -279,7 +265,6 @@ public synchronized void setLogLevel(@NonNull Logger.Level logLevel) {
    *
    * @param isEnabled Set to true to enable disk persistence, set to false to disable it.
    */
-  @PublicApi
   public synchronized void setPersistenceEnabled(boolean isEnabled) {
     assertUnfrozen("setPersistenceEnabled");
     this.config.setPersistenceEnabled(isEnabled);
@@ -298,7 +283,6 @@ public synchronized void setPersistenceEnabled(boolean isEnabled) {
    *
    * @param cacheSizeInBytes The new size of the cache in bytes.
    */
-  @PublicApi
   public synchronized void setPersistenceCacheSizeBytes(long cacheSizeInBytes) {
     assertUnfrozen("setPersistenceCacheSizeBytes");
     this.config.setPersistenceCacheSizeBytes(cacheSizeInBytes);
@@ -306,7 +290,6 @@ public synchronized void setPersistenceCacheSizeBytes(long cacheSizeInBytes) {
 
   /** @return The semver version for this build of the Firebase Database client */
   @NonNull
-  @PublicApi
   public static String getSdkVersion() {
     return SDK_VERSION;
   }
diff --git a/firebase-database/src/main/java/com/google/firebase/database/FirebaseDatabaseComponent.java b/firebase-database/src/main/java/com/google/firebase/database/FirebaseDatabaseComponent.java
index eee2681a2..0704d1652 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/FirebaseDatabaseComponent.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/FirebaseDatabaseComponent.java
@@ -14,8 +14,8 @@
 
 package com.google.firebase.database;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.auth.internal.InternalAuthProvider;
 import com.google.firebase.database.android.AndroidAuthTokenProvider;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/GenericTypeIndicator.java b/firebase-database/src/main/java/com/google/firebase/database/GenericTypeIndicator.java
index fb7fb0b9f..0d6d099e6 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/GenericTypeIndicator.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/GenericTypeIndicator.java
@@ -14,8 +14,6 @@
 
 package com.google.firebase.database;
 
-import com.google.firebase.annotations.PublicApi;
-
 /**
  * Due to the way that Java implements generics (type-erasure), it is necessary to use a slightly
  * more complicated method to properly resolve types for generic collections at runtime. To solve
@@ -57,7 +55,6 @@
  *
  * @param <T> The type of generic collection that this instance servers as an indicator for
  */
-@PublicApi
 public abstract class GenericTypeIndicator<T> {
   // TODO: This is a legacy class that inherited from TypeIndicator from Jackson to be
   // able to resolve generic types. We need a new solution going forward.
diff --git a/firebase-database/src/main/java/com/google/firebase/database/IgnoreExtraProperties.java b/firebase-database/src/main/java/com/google/firebase/database/IgnoreExtraProperties.java
index 19099e83c..731bb3fae 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/IgnoreExtraProperties.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/IgnoreExtraProperties.java
@@ -14,7 +14,6 @@
 
 package com.google.firebase.database;
 
-import com.google.firebase.annotations.PublicApi;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -26,5 +25,4 @@
  */
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE})
-@PublicApi
 public @interface IgnoreExtraProperties {}
diff --git a/firebase-database/src/main/java/com/google/firebase/database/InternalHelpers.java b/firebase-database/src/main/java/com/google/firebase/database/InternalHelpers.java
index 05ae4f9d2..d17bdd974 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/InternalHelpers.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/InternalHelpers.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.database;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.database.core.DatabaseConfig;
 import com.google.firebase.database.core.Path;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/Logger.java b/firebase-database/src/main/java/com/google/firebase/database/Logger.java
index 8b7e4d47f..b7e6663d5 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/Logger.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/Logger.java
@@ -14,14 +14,10 @@
 
 package com.google.firebase.database;
 
-import com.google.firebase.annotations.PublicApi;
-
 /** This interface is used to setup logging for Firebase Database. */
-@PublicApi
 public interface Logger {
 
   /** The log levels used by the Firebase Database library */
-  @PublicApi
   enum Level {
     DEBUG,
     INFO,
diff --git a/firebase-database/src/main/java/com/google/firebase/database/MutableData.java b/firebase-database/src/main/java/com/google/firebase/database/MutableData.java
index 6a8ebb21d..fda1c2a7c 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/MutableData.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/MutableData.java
@@ -14,9 +14,8 @@
 
 package com.google.firebase.database;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.database.core.Path;
 import com.google.firebase.database.core.SnapshotHolder;
 import com.google.firebase.database.core.ValidationPath;
@@ -39,7 +38,6 @@
  * Note that changes made to a child MutableData instance will be visible to the parent and vice
  * versa.
  */
-@PublicApi
 public class MutableData {
 
   private final SnapshotHolder holder;
@@ -61,7 +59,6 @@ Node getNode() {
   }
 
   /** @return True if the data at this location has children, false otherwise */
-  @PublicApi
   public boolean hasChildren() {
     Node node = getNode();
     return !node.isLeafNode() && !node.isEmpty();
@@ -71,8 +68,7 @@ public boolean hasChildren() {
    * @param path A relative path
    * @return True if data exists at the given path, otherwise false
    */
-  @PublicApi
-  public boolean hasChild(String path) {
+  public boolean hasChild(@NonNull String path) {
     return !getNode().getChild(new Path(path)).isEmpty();
   }
 
@@ -84,14 +80,12 @@ public boolean hasChild(String path) {
    * @return An instance encapsulating the data and priority at the given path
    */
   @NonNull
-  @PublicApi
   public MutableData child(@NonNull String path) {
     Validation.validatePathString(path);
     return new MutableData(holder, prefixPath.child(new Path(path)));
   }
 
   /** @return The number of immediate children at this location */
-  @PublicApi
   public long getChildrenCount() {
     return getNode().getChildCount();
   }
@@ -106,7 +100,6 @@ public long getChildrenCount() {
    * @return The immediate children at this location
    */
   @NonNull
-  @PublicApi
   public Iterable<MutableData> getChildren() {
     Node node = getNode();
     if (node.isEmpty() || node.isLeafNode()) {
@@ -162,7 +155,6 @@ public void remove() {
 
   /** @return The key name of this location, or null if it is the top-most location */
   @Nullable
-  @PublicApi
   public String getKey() {
     return prefixPath.getBack() != null ? prefixPath.getBack().asString() : null;
   }
@@ -187,7 +179,6 @@ public String getKey() {
    *     this location.
    */
   @Nullable
-  @PublicApi
   public Object getValue() {
     return getNode().getValue();
   }
@@ -237,7 +228,6 @@ public Object getValue() {
    *     if there is no data at this location.
    */
   @Nullable
-  @PublicApi
   public <T> T getValue(@NonNull Class<T> valueType) {
     Object value = getNode().getValue();
     return CustomClassMapper.convertToCustomClass(value, valueType);
@@ -265,7 +255,6 @@ public Object getValue() {
    *     there is no data at this location.
    */
   @Nullable
-  @PublicApi
   public <T> T getValue(@NonNull GenericTypeIndicator<T> t) {
     Object value = getNode().getValue();
     return CustomClassMapper.convertToCustomClass(value, t);
@@ -304,7 +293,6 @@ public Object getValue() {
    *
    * @param value The value to set at this location or null to delete the existing data
    */
-  @PublicApi
   public void setValue(@Nullable Object value) throws DatabaseException {
     ValidationPath.validateWithObject(prefixPath, value);
     Object bouncedValue = CustomClassMapper.convertToPlainJavaTypes(value);
@@ -317,7 +305,6 @@ public void setValue(@Nullable Object value) throws DatabaseException {
    *
    * @param priority The desired priority or null to clear the existing priority
    */
-  @PublicApi
   public void setPriority(@Nullable Object priority) {
     holder.update(
         prefixPath,
@@ -336,7 +323,6 @@ public void setPriority(@Nullable Object priority) {
    *
    * @return The priority at this location as a native type or null if no priority was set
    */
-  @PublicApi
   @Nullable
   public Object getPriority() {
     return getNode().getPriority().getValue();
diff --git a/firebase-database/src/main/java/com/google/firebase/database/OnDisconnect.java b/firebase-database/src/main/java/com/google/firebase/database/OnDisconnect.java
index e3d697065..3bd19fd7d 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/OnDisconnect.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/OnDisconnect.java
@@ -16,10 +16,9 @@
 
 import static com.google.firebase.database.DatabaseReference.CompletionListener;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.tasks.Task;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.database.core.Path;
 import com.google.firebase.database.core.Repo;
 import com.google.firebase.database.core.ValidationPath;
@@ -40,7 +39,6 @@
  * Instances of this class are obtained by calling {@link DatabaseReference#onDisconnect()
  * onDisconnect} on a Firebase Database ref.
  */
-@PublicApi
 public class OnDisconnect {
 
   private Repo repo;
@@ -62,7 +60,6 @@
    * @return The {@link Task} for this operation.
    */
   @NonNull
-  @PublicApi
   public Task<Void> setValue(@Nullable Object value) {
     return onDisconnectSetInternal(value, PriorityUtilities.NullPriority(), null);
   }
@@ -80,7 +77,6 @@
    * @return The {@link Task} for this operation.
    */
   @NonNull
-  @PublicApi
   public Task<Void> setValue(@Nullable Object value, @Nullable String priority) {
     return onDisconnectSetInternal(value, PriorityUtilities.parsePriority(path, priority), null);
   }
@@ -97,7 +93,6 @@
    * @return The {@link Task} for this operation.
    */
   @NonNull
-  @PublicApi
   public Task<Void> setValue(@Nullable Object value, double priority) {
     return onDisconnectSetInternal(value, PriorityUtilities.parsePriority(path, priority), null);
   }
@@ -112,7 +107,6 @@
    * @param value The value to be set when a disconnect occurs or null to delete the existing value
    * @param listener A listener that will be triggered once the server has queued up the operation
    */
-  @PublicApi
   public void setValue(@Nullable Object value, @Nullable CompletionListener listener) {
     onDisconnectSetInternal(value, PriorityUtilities.NullPriority(), listener);
   }
@@ -129,7 +123,6 @@ public void setValue(@Nullable Object value, @Nullable CompletionListener listen
    *     priority
    * @param listener A listener that will be triggered once the server has queued up the operation
    */
-  @PublicApi
   public void setValue(
       @Nullable Object value, @Nullable String priority, @Nullable CompletionListener listener) {
     onDisconnectSetInternal(value, PriorityUtilities.parsePriority(path, priority), listener);
@@ -146,7 +139,6 @@ public void setValue(
    * @param priority The priority to be set when a disconnect occurs
    * @param listener A listener that will be triggered once the server has queued up the operation
    */
-  @PublicApi
   public void setValue(
       @Nullable Object value, double priority, @Nullable CompletionListener listener) {
     onDisconnectSetInternal(value, PriorityUtilities.parsePriority(path, priority), listener);
@@ -163,7 +155,6 @@ public void setValue(
    * @param priority The priority to be set when a disconnect occurs
    * @param listener A listener that will be triggered once the server has queued up the operation
    */
-  @PublicApi
   public void setValue(
       @Nullable Object value, @Nullable Map priority, @Nullable CompletionListener listener) {
     onDisconnectSetInternal(value, PriorityUtilities.parsePriority(path, priority), listener);
@@ -196,7 +187,6 @@ public void run() {
    * @return The {@link Task} for this operation.
    */
   @NonNull
-  @PublicApi
   public Task<Void> updateChildren(@NonNull Map<String, Object> update) {
     return updateChildrenInternal(update, null);
   }
@@ -207,7 +197,6 @@ public void run() {
    * @param update The paths to update, along with their desired values
    * @param listener A listener that will be triggered once the server has queued up the operation
    */
-  @PublicApi
   public void updateChildren(
       @NonNull final Map<String, Object> update, @Nullable final CompletionListener listener) {
     updateChildrenInternal(update, listener);
@@ -235,7 +224,6 @@ public void run() {
    * @return The {@link Task} for this operation.
    */
   @NonNull
-  @PublicApi
   public Task<Void> removeValue() {
     return setValue(null);
   }
@@ -245,7 +233,6 @@ public void run() {
    *
    * @param listener A listener that will be triggered once the server has queued up the operation
    */
-  @PublicApi
   public void removeValue(@Nullable CompletionListener listener) {
     setValue(null, listener);
   }
@@ -258,7 +245,6 @@ public void removeValue(@Nullable CompletionListener listener) {
    * @return The {@link Task} for this operation.
    */
   @NonNull
-  @PublicApi
   public Task<Void> cancel() {
     return cancelInternal(null);
   }
@@ -268,7 +254,6 @@ public void removeValue(@Nullable CompletionListener listener) {
    *
    * @param listener A listener that will be triggered once the server has cancelled the operations
    */
-  @PublicApi
   public void cancel(@NonNull final CompletionListener listener) {
     cancelInternal(listener);
   }
diff --git a/firebase-database/src/main/java/com/google/firebase/database/PropertyName.java b/firebase-database/src/main/java/com/google/firebase/database/PropertyName.java
index 224ad155a..e07927906 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/PropertyName.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/PropertyName.java
@@ -14,7 +14,6 @@
 
 package com.google.firebase.database;
 
-import com.google.firebase.annotations.PublicApi;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -23,8 +22,7 @@
 /** Marks a field to be renamed when serialized. */
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.FIELD})
-@PublicApi
 public @interface PropertyName {
-  @PublicApi
+
   String value();
 }
diff --git a/firebase-database/src/main/java/com/google/firebase/database/Query.java b/firebase-database/src/main/java/com/google/firebase/database/Query.java
index d3f61fe04..901a05ebe 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/Query.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/Query.java
@@ -16,11 +16,10 @@
 
 import static com.google.firebase.database.core.utilities.Utilities.hardAssert;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.RestrictTo;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RestrictTo;
 import com.google.android.gms.common.internal.Objects;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.database.core.ChildEventRegistration;
 import com.google.firebase.database.core.EventRegistration;
 import com.google.firebase.database.core.Path;
@@ -49,7 +48,6 @@
  * <br>
  * Instances of Query are obtained by calling startAt(), endAt(), or limit() on a DatabaseReference.
  */
-@PublicApi
 public class Query {
 
   /** @hide */
@@ -145,7 +143,6 @@ private void validateNoOrderByCall() {
    * @return A reference to the listener provided. Save this to remove the listener later.
    */
   @NonNull
-  @PublicApi
   public ValueEventListener addValueEventListener(@NonNull ValueEventListener listener) {
     addEventRegistration(new ValueEventRegistration(repo, listener, getSpec()));
     return listener;
@@ -159,7 +156,6 @@ public ValueEventListener addValueEventListener(@NonNull ValueEventListener list
    * @return A reference to the listener provided. Save this to remove the listener later.
    */
   @NonNull
-  @PublicApi
   public ChildEventListener addChildEventListener(@NonNull ChildEventListener listener) {
     addEventRegistration(new ChildEventRegistration(repo, listener, getSpec()));
     return listener;
@@ -171,7 +167,6 @@ public ChildEventListener addChildEventListener(@NonNull ChildEventListener list
    *
    * @param listener The listener to be called with the data
    */
-  @PublicApi
   public void addListenerForSingleValueEvent(@NonNull final ValueEventListener listener) {
     addEventRegistration(
         new ValueEventRegistration(
@@ -197,7 +192,6 @@ public void onCancelled(DatabaseError error) {
    *
    * @param listener The listener to remove
    */
-  @PublicApi
   public void removeEventListener(@NonNull final ValueEventListener listener) {
     if (listener == null) {
       throw new NullPointerException("listener must not be null");
@@ -210,7 +204,6 @@ public void removeEventListener(@NonNull final ValueEventListener listener) {
    *
    * @param listener The listener to remove
    */
-  @PublicApi
   public void removeEventListener(@NonNull final ChildEventListener listener) {
     if (listener == null) {
       throw new NullPointerException("listener must not be null");
@@ -250,7 +243,6 @@ public void run() {
    * @param keepSynced Pass `true` to keep this location synchronized, pass `false` to stop
    *     synchronization.
    */
-  @PublicApi
   public void keepSynced(final boolean keepSynced) {
     if (!this.path.isEmpty() && this.path.getFront().equals(ChildKey.getInfoKey())) {
       throw new DatabaseException("Can't call keepSynced() on .info paths.");
@@ -284,7 +276,6 @@ public void run() {
    * @return A Query with the new constraint
    */
   @NonNull
-  @PublicApi
   public Query startAt(@Nullable String value) {
     return startAt(value, null);
   }
@@ -297,7 +288,6 @@ public Query startAt(@Nullable String value) {
    * @return A Query with the new constraint
    */
   @NonNull
-  @PublicApi
   public Query startAt(double value) {
     return startAt(value, null);
   }
@@ -311,7 +301,6 @@ public Query startAt(double value) {
    * @since 2.0
    */
   @NonNull
-  @PublicApi
   public Query startAt(boolean value) {
     return startAt(value, null);
   }
@@ -326,7 +315,6 @@ public Query startAt(boolean value) {
    * @return A Query with the new constraint
    */
   @NonNull
-  @PublicApi
   public Query startAt(@Nullable String value, @Nullable String key) {
     Node node =
         value != null ? new StringNode(value, PriorityUtilities.NullPriority()) : EmptyNode.Empty();
@@ -343,7 +331,6 @@ public Query startAt(@Nullable String value, @Nullable String key) {
    * @return A Query with the new constraint
    */
   @NonNull
-  @PublicApi
   public Query startAt(double value, @Nullable String key) {
     return startAt(new DoubleNode(value, PriorityUtilities.NullPriority()), key);
   }
@@ -359,7 +346,6 @@ public Query startAt(double value, @Nullable String key) {
    * @since 2.0
    */
   @NonNull
-  @PublicApi
   public Query startAt(boolean value, @Nullable String key) {
     return startAt(new BooleanNode(value, PriorityUtilities.NullPriority()), key);
   }
@@ -388,7 +374,6 @@ private Query startAt(Node node, String key) {
    * @return A Query with the new constraint
    */
   @NonNull
-  @PublicApi
   public Query endAt(@Nullable String value) {
     return endAt(value, null);
   }
@@ -401,7 +386,6 @@ public Query endAt(@Nullable String value) {
    * @return A Query with the new constraint
    */
   @NonNull
-  @PublicApi
   public Query endAt(double value) {
     return endAt(value, null);
   }
@@ -415,7 +399,6 @@ public Query endAt(double value) {
    * @since 2.0
    */
   @NonNull
-  @PublicApi
   public Query endAt(boolean value) {
     return endAt(value, null);
   }
@@ -430,7 +413,6 @@ public Query endAt(boolean value) {
    * @return A Query with the new constraint
    */
   @NonNull
-  @PublicApi
   public Query endAt(@Nullable String value, @Nullable String key) {
     Node node =
         value != null ? new StringNode(value, PriorityUtilities.NullPriority()) : EmptyNode.Empty();
@@ -447,7 +429,6 @@ public Query endAt(@Nullable String value, @Nullable String key) {
    * @return A Query with the new constraint
    */
   @NonNull
-  @PublicApi
   public Query endAt(double value, @Nullable String key) {
     return endAt(new DoubleNode(value, PriorityUtilities.NullPriority()), key);
   }
@@ -463,7 +444,6 @@ public Query endAt(double value, @Nullable String key) {
    * @since 2.0
    */
   @NonNull
-  @PublicApi
   public Query endAt(boolean value, @Nullable String key) {
     return endAt(new BooleanNode(value, PriorityUtilities.NullPriority()), key);
   }
@@ -491,7 +471,6 @@ private Query endAt(Node node, String key) {
    * @return A query with the new constraint
    */
   @NonNull
-  @PublicApi
   public Query equalTo(@Nullable String value) {
     validateEqualToCall();
     return this.startAt(value).endAt(value);
@@ -504,7 +483,6 @@ public Query equalTo(@Nullable String value) {
    * @return A query with the new constraint
    */
   @NonNull
-  @PublicApi
   public Query equalTo(double value) {
     validateEqualToCall();
     return this.startAt(value).endAt(value);
@@ -518,7 +496,6 @@ public Query equalTo(double value) {
    * @since 2.0
    */
   @NonNull
-  @PublicApi
   public Query equalTo(boolean value) {
     validateEqualToCall();
     return this.startAt(value).endAt(value);
@@ -533,7 +510,6 @@ public Query equalTo(boolean value) {
    * @return A query with the new constraint
    */
   @NonNull
-  @PublicApi
   public Query equalTo(@Nullable String value, @Nullable String key) {
     validateEqualToCall();
     return this.startAt(value, key).endAt(value, key);
@@ -548,7 +524,6 @@ public Query equalTo(@Nullable String value, @Nullable String key) {
    * @return A query with the new constraint
    */
   @NonNull
-  @PublicApi
   public Query equalTo(double value, @Nullable String key) {
     validateEqualToCall();
     return this.startAt(value, key).endAt(value, key);
@@ -563,7 +538,6 @@ public Query equalTo(double value, @Nullable String key) {
    * @return A query with the new constraint
    */
   @NonNull
-  @PublicApi
   public Query equalTo(boolean value, @Nullable String key) {
     validateEqualToCall();
     return this.startAt(value, key).endAt(value, key);
@@ -577,7 +551,6 @@ public Query equalTo(boolean value, @Nullable String key) {
    * @since 2.0
    */
   @NonNull
-  @PublicApi
   public Query limitToFirst(int limit) {
     if (limit <= 0) {
       throw new IllegalArgumentException("Limit must be a positive integer!");
@@ -597,7 +570,6 @@ public Query limitToFirst(int limit) {
    * @since 2.0
    */
   @NonNull
-  @PublicApi
   public Query limitToLast(int limit) {
     if (limit <= 0) {
       throw new IllegalArgumentException("Limit must be a positive integer!");
@@ -617,7 +589,6 @@ public Query limitToLast(int limit) {
    * @since 2.0
    */
   @NonNull
-  @PublicApi
   public Query orderByChild(@NonNull String path) {
     if (path == null) {
       throw new NullPointerException("Key can't be null");
@@ -651,7 +622,6 @@ public Query orderByChild(@NonNull String path) {
    * @since 2.0
    */
   @NonNull
-  @PublicApi
   public Query orderByPriority() {
     validateNoOrderByCall();
     QueryParams newParams = params.orderBy(PriorityIndex.getInstance());
@@ -666,7 +636,6 @@ public Query orderByPriority() {
    * @since 2.0
    */
   @NonNull
-  @PublicApi
   public Query orderByKey() {
     validateNoOrderByCall();
     QueryParams newParams = this.params.orderBy(KeyIndex.getInstance());
@@ -681,7 +650,6 @@ public Query orderByKey() {
    * @since 2.2
    */
   @NonNull
-  @PublicApi
   public Query orderByValue() {
     validateNoOrderByCall();
     return new Query(repo, path, params.orderBy(ValueIndex.getInstance()), true);
@@ -689,7 +657,6 @@ public Query orderByValue() {
 
   /** @return A DatabaseReference to this location */
   @NonNull
-  @PublicApi
   public DatabaseReference getRef() {
     return new DatabaseReference(repo, getPath());
   }
diff --git a/firebase-database/src/main/java/com/google/firebase/database/ServerValue.java b/firebase-database/src/main/java/com/google/firebase/database/ServerValue.java
index e1089b3bd..82cded000 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/ServerValue.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/ServerValue.java
@@ -16,22 +16,20 @@
 
 // Server values
 
-import android.support.annotation.NonNull;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
 import com.google.firebase.database.core.ServerValues;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 
 /** Contains placeholder values to use when writing data to the Firebase Database. */
-@PublicApi
 public class ServerValue {
 
   /**
    * A placeholder value for auto-populating the current timestamp (time since the Unix epoch, in
    * milliseconds) by the Firebase Database servers.
    */
-  @NonNull @PublicApi
+  @NonNull
   public static final Map<String, String> TIMESTAMP = createServerValuePlaceholder("timestamp");
 
   private static Map<String, String> createServerValuePlaceholder(String key) {
diff --git a/firebase-database/src/main/java/com/google/firebase/database/ThrowOnExtraProperties.java b/firebase-database/src/main/java/com/google/firebase/database/ThrowOnExtraProperties.java
index 2ec1cae25..b9f23d490 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/ThrowOnExtraProperties.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/ThrowOnExtraProperties.java
@@ -14,7 +14,6 @@
 
 package com.google.firebase.database;
 
-import com.google.firebase.annotations.PublicApi;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -26,5 +25,4 @@
  */
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE})
-@PublicApi
 public @interface ThrowOnExtraProperties {}
diff --git a/firebase-database/src/main/java/com/google/firebase/database/Transaction.java b/firebase-database/src/main/java/com/google/firebase/database/Transaction.java
index 13c984d97..1d78cae95 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/Transaction.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/Transaction.java
@@ -14,10 +14,9 @@
 
 package com.google.firebase.database;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.RestrictTo;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RestrictTo;
 import com.google.firebase.database.snapshot.Node;
 
 /**
@@ -30,7 +29,6 @@
  * Result} can be created using either {@link Transaction#success(MutableData)} or {@link
  * com.google.firebase.database.Transaction#abort()}.
  */
-@PublicApi
 public class Transaction {
 
   /**
@@ -45,7 +43,6 @@
    * Instances are created using {@link Transaction#success(MutableData)} or {@link
    * com.google.firebase.database.Transaction#abort()}.
    */
-  @PublicApi
   public static class Result {
 
     private boolean success;
@@ -57,7 +54,6 @@ private Result(boolean success, Node data) {
     }
 
     /** @return Whether or not this result is a success */
-    @PublicApi
     public boolean isSuccess() {
       return success;
     }
@@ -78,7 +74,6 @@ public Node getNode() {
    * An object implementing this interface is used to run a transaction, and will be notified of the
    * results of the transaction.
    */
-  @PublicApi
   public interface Handler {
 
     /**
@@ -99,7 +94,6 @@ public Node getNode() {
      * @return Either the new data, or an indication to abort the transaction
      */
     @NonNull
-    @PublicApi
     public Result doTransaction(@NonNull MutableData currentData);
 
     /**
@@ -110,14 +104,12 @@ public Node getNode() {
      *     an error occurred
      * @param currentData The current data at the location or null if an error occurred
      */
-    @PublicApi
     public void onComplete(
         @Nullable DatabaseError error, boolean committed, @Nullable DataSnapshot currentData);
   }
 
   /** @return A {@link Result} that aborts the transaction */
   @NonNull
-  @PublicApi
   public static Result abort() {
     return new Result(false, null);
   }
@@ -127,7 +119,6 @@ public static Result abort() {
    * @return A {@link Result} indicating the new data to be stored at the location
    */
   @NonNull
-  @PublicApi
   public static Result success(@NonNull MutableData resultData) {
     return new Result(true, resultData.getNode());
   }
diff --git a/firebase-database/src/main/java/com/google/firebase/database/ValueEventListener.java b/firebase-database/src/main/java/com/google/firebase/database/ValueEventListener.java
index af1e33fa5..48a06ff40 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/ValueEventListener.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/ValueEventListener.java
@@ -14,15 +14,13 @@
 
 package com.google.firebase.database;
 
-import android.support.annotation.NonNull;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
 
 /**
  * Classes implementing this interface can be used to receive events about data changes at a
  * location. Attach the listener to a location user {@link
  * DatabaseReference#addValueEventListener(ValueEventListener)}.
  */
-@PublicApi
 public interface ValueEventListener {
 
   /**
@@ -31,7 +29,6 @@
    *
    * @param snapshot The current data at the location
    */
-  @PublicApi
   public void onDataChange(@NonNull DataSnapshot snapshot);
 
   /**
@@ -43,6 +40,5 @@
    *
    * @param error A description of the error that occurred
    */
-  @PublicApi
   public void onCancelled(@NonNull DatabaseError error);
 }
diff --git a/firebase-database/src/main/java/com/google/firebase/database/android/AndroidAuthTokenProvider.java b/firebase-database/src/main/java/com/google/firebase/database/android/AndroidAuthTokenProvider.java
index 5d98d1d4b..c2e7ae347 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/android/AndroidAuthTokenProvider.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/android/AndroidAuthTokenProvider.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.database.android;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.google.android.gms.tasks.Task;
 import com.google.firebase.FirebaseApiNotAvailableException;
 import com.google.firebase.auth.GetTokenResult;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/android/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/android/package-info.java
index 7d630d98f..a41de86ed 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/android/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/android/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.android;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/annotations/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/annotations/package-info.java
index c34cad31e..010549d4b 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/annotations/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/annotations/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.annotations;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/connection/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/connection/package-info.java
index 77c4f5650..814577623 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/connection/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/connection/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.connection;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/connection/util/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/connection/util/package-info.java
index 9ae55cc22..5bccd595b 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/connection/util/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/connection/util/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.connection.util;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/operation/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/core/operation/package-info.java
index 3e9a203a2..d16816568 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/operation/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/operation/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.core.operation;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/core/package-info.java
index 22de4242a..ebbc1ade1 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.core;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/persistence/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/core/persistence/package-info.java
index 267d1dfdc..44e748d9d 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/persistence/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/persistence/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.core.persistence;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/DefaultRunLoop.java b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/DefaultRunLoop.java
index b2ae52044..a98fd4a41 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/DefaultRunLoop.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/DefaultRunLoop.java
@@ -128,13 +128,20 @@ public static String messageForException(Throwable t) {
           + "https://firebase.google.com/docs/database/ios/structure-data#best_practices_for_data_structure"
           + " and "
           + "https://firebase.google.com/docs/database/android/retrieve-data#filtering_data";
+    } else if (t instanceof NoClassDefFoundError) {
+      return "A symbol that the Firebase Database SDK depends on failed to load. This usually "
+          + "indicates that your project includes an incompatible version of another Firebase "
+          + "dependency. If updating your dependencies to the latest version does not resolve "
+          + "this issue, please file a report at https://github.com/firebase/firebase-android-sdk";
     } else if (t instanceof DatabaseException) {
       // Exception should be self-explanatory and they shouldn't contact support.
       return "";
     } else {
       return "Uncaught exception in Firebase Database runloop ("
           + FirebaseDatabase.getSdkVersion()
-          + "). Please report to firebase-database-client@google.com";
+          + "). If you are not already on the latest version of the Firebase SDKs, try updating "
+          + "your dependencies. Should this problem persist, please file a report at "
+          + "https://github.com/firebase/firebase-android-sdk";
     }
   }
 }
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/ParsedUrl.java b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/ParsedUrl.java
index b05c28acc..549be841b 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/ParsedUrl.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/ParsedUrl.java
@@ -21,4 +21,15 @@
 
   public RepoInfo repoInfo;
   public Path path;
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+
+    ParsedUrl parsedUrl = (ParsedUrl) o;
+
+    if (!repoInfo.equals(parsedUrl.repoInfo)) return false;
+    return path.equals(parsedUrl.path);
+  }
 }
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/Utilities.java b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/Utilities.java
index 69f367855..8327f5766 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/Utilities.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/Utilities.java
@@ -14,6 +14,7 @@
 
 package com.google.firebase.database.core.utilities;
 
+import android.net.Uri;
 import android.util.Base64;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
@@ -23,83 +24,85 @@
 import com.google.firebase.database.core.Path;
 import com.google.firebase.database.core.RepoInfo;
 import java.io.UnsupportedEncodingException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URLEncoder;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
 import java.util.Map;
 
 public class Utilities {
   private static final char[] HEX_CHARACTERS = "0123456789abcdef".toCharArray();
 
   public static ParsedUrl parseUrl(String url) throws DatabaseException {
-    String original = url;
     try {
-      int schemeOffset = original.indexOf("//");
-      if (schemeOffset == -1) {
-        throw new URISyntaxException(original, "Invalid scheme specified");
-      }
-      int pathOffset = original.substring(schemeOffset + 2).indexOf("/");
-      if (pathOffset != -1) {
-        pathOffset += schemeOffset + 2;
-        String[] pathSegments = original.substring(pathOffset).split("/", -1);
-        StringBuilder builder = new StringBuilder();
-        for (int i = 0; i < pathSegments.length; ++i) {
-          if (!pathSegments[i].equals("")) {
-            builder.append("/");
-            builder.append(URLEncoder.encode(pathSegments[i], "UTF-8"));
-          }
-        }
-        original = original.substring(0, pathOffset) + builder.toString();
-      }
+      Uri uri = Uri.parse(url);
 
-      URI uri = new URI(original);
-      // URLEncoding a space turns it into a '+', which is different
-      // from our expected behavior. Do a manual replace to fix it.
-      String pathString = uri.getPath().replace("+", " ");
-      Validation.validateRootPathString(pathString);
-      Path path = new Path(pathString);
       String scheme = uri.getScheme();
+      if (scheme == null) {
+        throw new IllegalArgumentException("Database URL does not specify a URL scheme");
+      }
+
+      String host = uri.getHost();
+      if (host == null) {
+        throw new IllegalArgumentException("Database URL does not specify a valid host");
+      }
 
       RepoInfo repoInfo = new RepoInfo();
-      repoInfo.host = uri.getHost().toLowerCase();
+      repoInfo.host = host.toLowerCase();
 
       int port = uri.getPort();
       if (port != -1) {
-        repoInfo.secure = scheme.equals("https");
+        repoInfo.secure = scheme.equals("https") || scheme.equals("wss");
         repoInfo.host += ":" + port;
       } else {
         repoInfo.secure = true;
       }
-      String[] parts = repoInfo.host.split("\\.", -1);
 
-      repoInfo.namespace = parts[0].toLowerCase();
+      String namespaceParam = uri.getQueryParameter("ns");
+      if (namespaceParam != null) {
+        repoInfo.namespace = namespaceParam;
+      } else {
+        String[] parts = host.split("\\.", -1);
+        repoInfo.namespace = parts[0].toLowerCase();
+      }
+
       repoInfo.internalHost = repoInfo.host;
+
+      String originalPathString = extractPathString(url);
+      // URLEncoding a space turns it into a '+', which is different
+      // from our expected behavior. Do a manual replace to fix it.
+      originalPathString = originalPathString.replace("+", " ");
+      Validation.validateRootPathString(originalPathString);
+
       ParsedUrl parsedUrl = new ParsedUrl();
-      parsedUrl.path = path;
+      parsedUrl.path = new Path(originalPathString);
       parsedUrl.repoInfo = repoInfo;
-      return parsedUrl;
 
-    } catch (URISyntaxException e) {
-      throw new DatabaseException("Invalid Firebase Database url specified", e);
-    } catch (UnsupportedEncodingException e) {
-      throw new DatabaseException("Failed to URLEncode the path", e);
+      return parsedUrl;
+    } catch (Exception e) {
+      throw new DatabaseException("Invalid Firebase Database url specified: " + url, e);
     }
   }
 
-  public static String[] splitIntoFrames(String src, int maxFrameSize) {
-    if (src.length() <= maxFrameSize) {
-      return new String[] {src};
-    } else {
-      ArrayList<String> segs = new ArrayList<String>();
-      for (int i = 0; i < src.length(); i += maxFrameSize) {
-        int end = Math.min(i + maxFrameSize, src.length());
-        String seg = src.substring(i, end);
-        segs.add(seg);
+  /**
+   * Extracts the path string from the original URL without changing the encoding (unlike
+   * Uri.getPath()).
+   */
+  private static String extractPathString(String originalUrl) {
+    int schemeOffset = originalUrl.indexOf("//");
+    if (schemeOffset == -1) {
+      throw new DatabaseException("Firebase Database URL is missing URL scheme");
+    }
+
+    String urlWithoutScheme = originalUrl.substring(schemeOffset + 2);
+    int pathOffset = urlWithoutScheme.indexOf("/");
+    if (pathOffset != -1) {
+      int queryOffset = urlWithoutScheme.indexOf("?");
+      if (queryOffset != -1) {
+        return urlWithoutScheme.substring(pathOffset + 1, queryOffset);
+      } else {
+        return urlWithoutScheme.substring(pathOffset + 1);
       }
-      return segs.toArray(new String[segs.size()]);
+    } else {
+      return "";
     }
   }
 
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/encoding/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/encoding/package-info.java
index 444de4155..2631b7d69 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/encoding/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/encoding/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.core.utilities.encoding;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/package-info.java
index a41d53077..312c1e490 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.core.utilities;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/tuple/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/tuple/package-info.java
index c8005c372..f20f52318 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/tuple/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/tuple/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.core.utilities.tuple;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/view/filter/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/core/view/filter/package-info.java
index 62bf7dbaa..00e2dd638 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/view/filter/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/view/filter/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.core.view.filter;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/view/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/core/view/package-info.java
index 9249b4d04..5ea6545ff 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/view/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/view/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.core.view;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/logging/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/logging/package-info.java
index af2f867b1..237cb8f3e 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/logging/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/logging/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.logging;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/snapshot/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/snapshot/package-info.java
index 4f4ee7a5a..b4ac8fff4 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/snapshot/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/snapshot/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.snapshot;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/tubesock/WebSocket.java b/firebase-database/src/main/java/com/google/firebase/database/tubesock/WebSocket.java
index d4a391268..c996a16bf 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/tubesock/WebSocket.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/tubesock/WebSocket.java
@@ -16,7 +16,7 @@
 
 import android.net.SSLCertificateSocketFactory;
 import android.net.SSLSessionCache;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.firebase.database.connection.ConnectionContext;
 import com.google.firebase.database.logging.LogWrapper;
 import java.io.DataInputStream;
@@ -427,9 +427,8 @@ private void runReader() {
       receiver.run();
     } catch (WebSocketException wse) {
       eventHandler.onError(wse);
-    } catch (IOException ioe) {
-      eventHandler.onError(
-          new WebSocketException("error while connecting: " + ioe.getMessage(), ioe));
+    } catch (Throwable t) {
+      eventHandler.onError(new WebSocketException("error while connecting: " + t.getMessage(), t));
     } finally {
       close();
     }
diff --git a/firebase-database/src/main/java/com/google/firebase/database/tubesock/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/tubesock/package-info.java
index 6bec8c0ef..3c1ecad3e 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/tubesock/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/tubesock/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.tubesock;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/util/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/util/package-info.java
index 477bb7085..66f43452f 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/util/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/util/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.util;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-database/src/test/java/com/google/firebase/database/MapperTest.java b/firebase-database/src/test/java/com/google/firebase/database/MapperTest.java
index 324fb2500..e1d197aca 100644
--- a/firebase-database/src/test/java/com/google/firebase/database/MapperTest.java
+++ b/firebase-database/src/test/java/com/google/firebase/database/MapperTest.java
@@ -19,7 +19,7 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
-import android.support.annotation.Keep;
+import androidx.annotation.Keep;
 import com.google.firebase.database.core.utilities.encoding.CustomClassMapper;
 import java.util.ArrayList;
 import java.util.Arrays;
diff --git a/firebase-database/src/test/java/com/google/firebase/database/core/utilities/ParseUrlTest.java b/firebase-database/src/test/java/com/google/firebase/database/core/utilities/ParseUrlTest.java
new file mode 100644
index 000000000..9e902d0eb
--- /dev/null
+++ b/firebase-database/src/test/java/com/google/firebase/database/core/utilities/ParseUrlTest.java
@@ -0,0 +1,93 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.database.core.utilities;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import com.google.firebase.database.DatabaseException;
+import org.junit.Test;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@org.junit.runner.RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ParseUrlTest {
+
+  @Test
+  public void testUrlParsing() throws DatabaseException {
+    ParsedUrl parsed = Utilities.parseUrl("http://gsoltis.fblocal.com:9000");
+    assertEquals("/", parsed.path.toString());
+    assertEquals("gsoltis.fblocal.com:9000", parsed.repoInfo.host);
+    assertEquals("gsoltis.fblocal.com:9000", parsed.repoInfo.internalHost);
+
+    parsed = Utilities.parseUrl("http://gsoltis.firebaseio.com/foo/bar");
+    assertEquals("/foo/bar", parsed.path.toString());
+    assertEquals("gsoltis.firebaseio.com", parsed.repoInfo.host);
+    assertEquals("gsoltis.firebaseio.com", parsed.repoInfo.internalHost);
+
+    parsed = Utilities.parseUrl("http://gsoltis.firebaseio.com/foo/empty space");
+    assertEquals("/foo/empty space", parsed.path.toString());
+    assertEquals("gsoltis.firebaseio.com", parsed.repoInfo.host);
+    assertEquals("gsoltis.firebaseio.com", parsed.repoInfo.internalHost);
+
+    parsed = Utilities.parseUrl("http://gsoltis.firebaseio.com/foo/\\;:@\uD83D\uDE00");
+    assertEquals("/foo/\\;:@\uD83D\uDE00", parsed.path.toString());
+    assertEquals("gsoltis.firebaseio.com", parsed.repoInfo.host);
+    assertEquals("gsoltis.firebaseio.com", parsed.repoInfo.internalHost);
+  }
+
+  @Test
+  public void testUrlParsingTurnsPlusIntoSpace() throws DatabaseException {
+    ParsedUrl parsed = Utilities.parseUrl("http://gsoltis.firebaseio.com/+");
+    assertEquals("/ ", parsed.path.toString());
+  }
+
+  @Test
+  public void testUrlParsingSpecialCharacters() throws DatabaseException {
+    ParsedUrl parsed =
+        Utilities.parseUrl("http://gsoltis.firebaseio.com/a%b&c@d/+space: /non-ascii:");
+    assertEquals("/a%b&c@d/ space: /non-ascii:", parsed.path.toString());
+  }
+
+  @Test
+  public void testUrlParsingIgnoresTrailingSlash() throws DatabaseException {
+    ParsedUrl parsed1 = Utilities.parseUrl("http://gsoltis.firebaseio.com/");
+    ParsedUrl parsed2 = Utilities.parseUrl("http://gsoltis.firebaseio.com");
+    assertEquals(parsed1, parsed2);
+  }
+
+  @Test
+  public void testUrlParsingWithNamespace() throws DatabaseException {
+    ParsedUrl parsed = Utilities.parseUrl("http://localhost/foo/bar?ns=mrschmidt");
+    assertEquals("mrschmidt", parsed.repoInfo.namespace);
+
+    parsed = Utilities.parseUrl("http://10.0.2.2:9000/foo/bar?ns=mrschmidt");
+    assertEquals(parsed.path.toString(), "/foo/bar");
+    assertEquals("mrschmidt", parsed.repoInfo.namespace);
+  }
+
+  @Test
+  public void testUrlParsingSslDetection() throws DatabaseException {
+    // Hosts with custom ports are considered non-secure
+    ParsedUrl parsed = Utilities.parseUrl("http://gsoltis.fblocal.com:9000");
+    assertFalse(parsed.repoInfo.secure);
+
+    // Hosts with the default ports are considered secure
+    parsed = Utilities.parseUrl("http://gsoltis.firebaseio.com");
+    assertTrue(parsed.repoInfo.secure);
+  }
+}
diff --git a/firebase-datatransport/api.txt b/firebase-datatransport/api.txt
new file mode 100644
index 000000000..d802177e2
--- /dev/null
+++ b/firebase-datatransport/api.txt
@@ -0,0 +1 @@
+// Signature format: 2.0
diff --git a/firebase-datatransport/firebase-datatransport.gradle b/firebase-datatransport/firebase-datatransport.gradle
index 03a1e579c..92bb6dd9f 100644
--- a/firebase-datatransport/firebase-datatransport.gradle
+++ b/firebase-datatransport/firebase-datatransport.gradle
@@ -31,7 +31,7 @@ android {
         minSdkVersion project.minSdkVersion
         targetSdkVersion project.targetSdkVersion
         versionName version
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
     }
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_8
@@ -49,9 +49,9 @@ dependencies {
     implementation project(':transport:transport-api')
     implementation project(':transport:transport-runtime')
     implementation project(':transport:transport-backend-cct')
-    implementation 'com.android.support:support-annotations:28.0.0'
+    implementation 'androidx.annotation:annotation:1.1.0'
 
-    testImplementation 'com.android.support.test:runner:1.0.2'
+    testImplementation 'androidx.test:runner:1.2.0'
     testImplementation "org.robolectric:robolectric:$robolectricVersion"
     testImplementation 'junit:junit:4.12'
     testImplementation "com.google.truth:truth:$googleTruthVersion"
diff --git a/firebase-datatransport/gradle.properties b/firebase-datatransport/gradle.properties
index 03f6ea190..23519378a 100644
--- a/firebase-datatransport/gradle.properties
+++ b/firebase-datatransport/gradle.properties
@@ -1,3 +1,3 @@
-version=16.0.1
-latestReleasedVersion=16.0.0
+version=17.0.3
+latestReleasedVersion=17.0.2
 android.enableUnitTestBinaryResources=true
diff --git a/firebase-datatransport/src/main/java/com/google/firebase/datatransport/TransportRegistrar.java b/firebase-datatransport/src/main/java/com/google/firebase/datatransport/TransportRegistrar.java
index b85ed832e..b963d30d3 100644
--- a/firebase-datatransport/src/main/java/com/google/firebase/datatransport/TransportRegistrar.java
+++ b/firebase-datatransport/src/main/java/com/google/firebase/datatransport/TransportRegistrar.java
@@ -15,7 +15,7 @@
 package com.google.firebase.datatransport;
 
 import android.content.Context;
-import android.support.annotation.Keep;
+import androidx.annotation.Keep;
 import com.google.android.datatransport.TransportFactory;
 import com.google.android.datatransport.runtime.TransportRuntime;
 import com.google.firebase.components.Component;
diff --git a/firebase-datatransport/src/test/java/com/google/firebase/datatransport/TransportRegistrationTest.java b/firebase-datatransport/src/test/java/com/google/firebase/datatransport/TransportRegistrationTest.java
index cbd66f819..edf9327e9 100644
--- a/firebase-datatransport/src/test/java/com/google/firebase/datatransport/TransportRegistrationTest.java
+++ b/firebase-datatransport/src/test/java/com/google/firebase/datatransport/TransportRegistrationTest.java
@@ -16,7 +16,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.datatransport.TransportFactory;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.FirebaseOptions;
diff --git a/firebase-firestore/CHANGELOG.md b/firebase-firestore/CHANGELOG.md
index cf3a17214..60befeeea 100644
--- a/firebase-firestore/CHANGELOG.md
+++ b/firebase-firestore/CHANGELOG.md
@@ -1,13 +1,58 @@
 # Unreleased
+
+# 21.1.0
+- [feature] Added a `terminate()` method to `FirebaseFirestore` which
+  terminates the instance, releasing any held resources. Once it completes, you
+  can optionally call `clearPersistence()` to wipe persisted Firestore data from
+  disk.
+- [feature] Added a `waitForPendingWrites()` method to `FirebaseFirestore`
+  which allows users to wait on a promise that resolves when all pending writes
+  are acknowledged by the Firestore backend.
+- [changed] Transactions now perform exponential backoff before retrying. This
+  means transactions on highly contended documents are more likely to succeed.
+
+# 21.0.0
+- [changed] Transactions are now more flexible. Some sequences of operations
+  that were previously incorrectly disallowed are now allowed. For example,
+  after reading a document that doesn't exist, you can now set it multiple
+  times successfully in a transaction.
+- [fixed] Fixed an issue where query results were temporarily missing documents
+  that previously had not matched but had been updated to now match the
+  query (#155).
+
+# 20.2.0
+- [feature] Added a `@DocumentId` annotation which can be used on a
+  `DocumentReference` or `String` property in a POJO to indicate that the SDK
+  should automatically populate it with the document's ID.
+- [fixed] Fixed an internal assertion that was triggered when an update
+  with a `FieldValue.serverTimestamp()` and an update with a
+  `FieldValue.increment()` were pending for the same document (#491).
+- [changed] Improved performance of queries with large result sets.
+- [changed] Improved performance for queries with filters that only return a
+  small subset of the documents in a collection.
+- [changed] Instead of failing silently, Firestore now crashes the client app
+  if it fails to load SSL Ciphers. To avoid these crashes, you must bundle 
+  Conscrypt to support non-GMSCore devices on Android API level 19 (KitKat) or
+  earlier (for more information, refer to
+  https://github.com/grpc/grpc-java/blob/master/SECURITY.md#tls-on-android).
+- [changed] Failed transactions now fail with the exception from the last 
+  attempt instead of always failing with an exception with code `ABORTED`.
+
+# 20.1.0
 - [changed] SSL and gRPC initialization now happens on a separate thread, which
   reduces the time taken to produce the first query result.
-- [fixed] Updated gRPC to 1.21.0. A bug in the prior version would occasionally
-  cause a crash if a network state change occurred concurrently with an RPC.
-  (#428)
 - [feature] Added `clearPersistence()`, which clears the persistent storage
   including pending writes and cached documents. This is intended to help
   write reliable tests (https://github.com/firebase/firebase-js-sdk/issues/449).
 
+# 20.0.0
+- [changed] Migrated from the Android Support Libraries to the Jetpack
+  (AndroidX) Libraries.
+
+# 19.0.2
+- [fixed] Updated gRPC to 1.21.0. A bug in the prior version would occasionally
+  cause a crash if a network state change occurred concurrently with an RPC.
+  (#428)
 
 # 19.0.1
 - [fixed] Fixed an issue that prevented schema migrations for clients with
diff --git a/firebase-firestore/README.md b/firebase-firestore/README.md
index afe9ab9dc..997ab2c35 100644
--- a/firebase-firestore/README.md
+++ b/firebase-firestore/README.md
@@ -41,7 +41,33 @@ the source root.
 Make sure you have created a Firestore instance for your project, before
 you proceed.
 
-### Run on Local Emulator
+By default, integration tests run against the Firestore emulator.
+
+### Setting up the Firestore Emulator
+
+The integration tests require that the Firestore emulator is running on port
+8080, which is default when running it via CLI.
+
+  * [Install the Firebase CLI](https://firebase.google.com/docs/cli/).
+    ```
+    npm install -g firebase-tools
+    ```
+  * [Install the Firestore
+    emulator](https://firebase.google.com/docs/firestore/security/test-rules-emulator#install_the_emulator).
+    ```
+    firebase setup:emulators:firestore
+    ```
+  * Run the emulator
+    ```
+    firebase serve --only firestore
+    ```
+  * Select the `Firestore Integration Tests (Firestore Emulator)` run
+    configuration to run all integration tests.
+
+To run the integration tests against prod, select `FirestoreProdIntegrationTest`
+run configuration.
+
+### Run on Local Android Emulator
 
 Then simply run:
 ```bash
diff --git a/firebase-firestore/api.txt b/firebase-firestore/api.txt
new file mode 100644
index 000000000..c724219b1
--- /dev/null
+++ b/firebase-firestore/api.txt
@@ -0,0 +1,367 @@
+// Signature format: 2.0
+package com.google.firebase {
+
+  public final class Timestamp {
+    ctor public Timestamp(long, int);
+    ctor protected Timestamp(@NonNull Parcel);
+    ctor public Timestamp(@NonNull Date);
+    method public int compareTo(@NonNull com.google.firebase.Timestamp);
+    method public int describeContents();
+    method public boolean equals(Object);
+    method public int getNanoseconds();
+    method public long getSeconds();
+    method public int hashCode();
+    method @NonNull public static com.google.firebase.Timestamp now();
+    method @NonNull public Date toDate();
+    method public String toString();
+    method public void writeToParcel(@NonNull Parcel, int);
+    field @NonNull public static final Parcelable.Creator<Timestamp> CREATOR;
+  }
+
+}
+
+package com.google.firebase.firestore {
+
+  public class Blob {
+    method public int compareTo(@NonNull com.google.firebase.firestore.Blob);
+    method public boolean equals(@Nullable Object);
+    method @NonNull public static com.google.firebase.firestore.Blob fromBytes(@NonNull byte[]);
+    method public int hashCode();
+    method @NonNull public byte[] toBytes();
+    method @NonNull public String toString();
+  }
+
+  public class CollectionReference extends com.google.firebase.firestore.Query {
+    method @NonNull public Task<DocumentReference> add(@NonNull Object);
+    method @NonNull public com.google.firebase.firestore.DocumentReference document();
+    method @NonNull public com.google.firebase.firestore.DocumentReference document(@NonNull String);
+    method @NonNull public String getId();
+    method @Nullable public com.google.firebase.firestore.DocumentReference getParent();
+    method @NonNull public String getPath();
+  }
+
+  public class DocumentChange {
+    method public boolean equals(@Nullable Object);
+    method @NonNull public com.google.firebase.firestore.QueryDocumentSnapshot getDocument();
+    method public int getNewIndex();
+    method public int getOldIndex();
+    method @NonNull public com.google.firebase.firestore.DocumentChange.Type getType();
+    method public int hashCode();
+  }
+
+  public enum DocumentChange.Type {
+    enum_constant public static final com.google.firebase.firestore.DocumentChange.Type ADDED;
+    enum_constant public static final com.google.firebase.firestore.DocumentChange.Type MODIFIED;
+    enum_constant public static final com.google.firebase.firestore.DocumentChange.Type REMOVED;
+  }
+
+  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface DocumentId {
+  }
+
+  public class DocumentReference {
+    method @NonNull public com.google.firebase.firestore.ListenerRegistration addSnapshotListener(@NonNull com.google.firebase.firestore.EventListener<com.google.firebase.firestore.DocumentSnapshot>);
+    method @NonNull public com.google.firebase.firestore.ListenerRegistration addSnapshotListener(@NonNull Executor, @NonNull com.google.firebase.firestore.EventListener<com.google.firebase.firestore.DocumentSnapshot>);
+    method @NonNull public com.google.firebase.firestore.ListenerRegistration addSnapshotListener(@NonNull Activity, @NonNull com.google.firebase.firestore.EventListener<com.google.firebase.firestore.DocumentSnapshot>);
+    method @NonNull public com.google.firebase.firestore.ListenerRegistration addSnapshotListener(@NonNull com.google.firebase.firestore.MetadataChanges, @NonNull com.google.firebase.firestore.EventListener<com.google.firebase.firestore.DocumentSnapshot>);
+    method @NonNull public com.google.firebase.firestore.ListenerRegistration addSnapshotListener(@NonNull Executor, @NonNull com.google.firebase.firestore.MetadataChanges, @NonNull com.google.firebase.firestore.EventListener<com.google.firebase.firestore.DocumentSnapshot>);
+    method @NonNull public com.google.firebase.firestore.ListenerRegistration addSnapshotListener(@NonNull Activity, @NonNull com.google.firebase.firestore.MetadataChanges, @NonNull com.google.firebase.firestore.EventListener<com.google.firebase.firestore.DocumentSnapshot>);
+    method @NonNull public com.google.firebase.firestore.CollectionReference collection(@NonNull String);
+    method @NonNull public Task<Void> delete();
+    method public boolean equals(Object);
+    method @NonNull public Task<DocumentSnapshot> get();
+    method @NonNull public Task<DocumentSnapshot> get(@NonNull com.google.firebase.firestore.Source);
+    method @NonNull public com.google.firebase.firestore.FirebaseFirestore getFirestore();
+    method @NonNull public String getId();
+    method @NonNull public com.google.firebase.firestore.CollectionReference getParent();
+    method @NonNull public String getPath();
+    method public int hashCode();
+    method @NonNull public Task<Void> set(@NonNull Object);
+    method @NonNull public Task<Void> set(@NonNull Object, @NonNull com.google.firebase.firestore.SetOptions);
+    method @NonNull public Task<Void> update(@NonNull Map<String,Object>);
+    method @NonNull public Task<Void> update(@NonNull String, @Nullable Object, Object...);
+    method @NonNull public Task<Void> update(@NonNull com.google.firebase.firestore.FieldPath, @Nullable Object, Object...);
+  }
+
+  public class DocumentSnapshot {
+    method public boolean contains(@NonNull String);
+    method public boolean contains(@NonNull com.google.firebase.firestore.FieldPath);
+    method public boolean equals(@Nullable Object);
+    method public boolean exists();
+    method @Nullable public Object get(@NonNull String);
+    method @Nullable public Object get(@NonNull String, @NonNull com.google.firebase.firestore.DocumentSnapshot.ServerTimestampBehavior);
+    method @Nullable public Object get(@NonNull com.google.firebase.firestore.FieldPath);
+    method @Nullable public Object get(@NonNull com.google.firebase.firestore.FieldPath, @NonNull com.google.firebase.firestore.DocumentSnapshot.ServerTimestampBehavior);
+    method @Nullable public <T> T get(@NonNull String, @NonNull Class<T>);
+    method @Nullable public <T> T get(@NonNull String, @NonNull Class<T>, @NonNull com.google.firebase.firestore.DocumentSnapshot.ServerTimestampBehavior);
+    method @Nullable public <T> T get(@NonNull com.google.firebase.firestore.FieldPath, @NonNull Class<T>);
+    method @Nullable public <T> T get(@NonNull com.google.firebase.firestore.FieldPath, @NonNull Class<T>, @NonNull com.google.firebase.firestore.DocumentSnapshot.ServerTimestampBehavior);
+    method @Nullable public com.google.firebase.firestore.Blob getBlob(@NonNull String);
+    method @Nullable public Boolean getBoolean(@NonNull String);
+    method @Nullable public Map<String,Object> getData();
+    method @Nullable public Map<String,Object> getData(@NonNull com.google.firebase.firestore.DocumentSnapshot.ServerTimestampBehavior);
+    method @Nullable public Date getDate(@NonNull String);
+    method @Nullable public Date getDate(@NonNull String, @NonNull com.google.firebase.firestore.DocumentSnapshot.ServerTimestampBehavior);
+    method @Nullable public com.google.firebase.firestore.DocumentReference getDocumentReference(@NonNull String);
+    method @Nullable public Double getDouble(@NonNull String);
+    method @Nullable public com.google.firebase.firestore.GeoPoint getGeoPoint(@NonNull String);
+    method @NonNull public String getId();
+    method @Nullable public Long getLong(@NonNull String);
+    method @NonNull public com.google.firebase.firestore.SnapshotMetadata getMetadata();
+    method @NonNull public com.google.firebase.firestore.DocumentReference getReference();
+    method @Nullable public String getString(@NonNull String);
+    method @Nullable public com.google.firebase.Timestamp getTimestamp(@NonNull String);
+    method @Nullable public com.google.firebase.Timestamp getTimestamp(@NonNull String, @NonNull com.google.firebase.firestore.DocumentSnapshot.ServerTimestampBehavior);
+    method public int hashCode();
+    method @Nullable public <T> T toObject(@NonNull Class<T>);
+    method @Nullable public <T> T toObject(@NonNull Class<T>, @NonNull com.google.firebase.firestore.DocumentSnapshot.ServerTimestampBehavior);
+    method public String toString();
+  }
+
+  public enum DocumentSnapshot.ServerTimestampBehavior {
+    enum_constant public static final com.google.firebase.firestore.DocumentSnapshot.ServerTimestampBehavior ESTIMATE;
+    enum_constant public static final com.google.firebase.firestore.DocumentSnapshot.ServerTimestampBehavior NONE;
+    enum_constant public static final com.google.firebase.firestore.DocumentSnapshot.ServerTimestampBehavior PREVIOUS;
+  }
+
+  public interface EventListener<T> {
+    method public void onEvent(@Nullable T, @Nullable com.google.firebase.firestore.FirebaseFirestoreException);
+  }
+
+  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface Exclude {
+  }
+
+  public final class FieldPath {
+    method @NonNull public static com.google.firebase.firestore.FieldPath documentId();
+    method public boolean equals(Object);
+    method public int hashCode();
+    method @NonNull public static com.google.firebase.firestore.FieldPath of(String...);
+    method public String toString();
+  }
+
+  public abstract class FieldValue {
+    method @NonNull public static com.google.firebase.firestore.FieldValue arrayRemove(Object...);
+    method @NonNull public static com.google.firebase.firestore.FieldValue arrayUnion(Object...);
+    method @NonNull public static com.google.firebase.firestore.FieldValue delete();
+    method @NonNull public static com.google.firebase.firestore.FieldValue increment(long);
+    method @NonNull public static com.google.firebase.firestore.FieldValue increment(double);
+    method @NonNull public static com.google.firebase.firestore.FieldValue serverTimestamp();
+  }
+
+  public class FirebaseFirestore {
+    method @NonNull public com.google.firebase.firestore.WriteBatch batch();
+    method @NonNull public Task<Void> clearPersistence();
+    method @NonNull public com.google.firebase.firestore.CollectionReference collection(@NonNull String);
+    method @NonNull public com.google.firebase.firestore.Query collectionGroup(@NonNull String);
+    method @NonNull public Task<Void> disableNetwork();
+    method @NonNull public com.google.firebase.firestore.DocumentReference document(@NonNull String);
+    method @NonNull public Task<Void> enableNetwork();
+    method @NonNull public FirebaseApp getApp();
+    method @NonNull public com.google.firebase.firestore.FirebaseFirestoreSettings getFirestoreSettings();
+    method @NonNull public static com.google.firebase.firestore.FirebaseFirestore getInstance();
+    method @NonNull public static com.google.firebase.firestore.FirebaseFirestore getInstance(@NonNull FirebaseApp);
+    method @NonNull public Task<Void> runBatch(@NonNull com.google.firebase.firestore.WriteBatch.Function);
+    method @NonNull public <TResult> Task<TResult> runTransaction(@NonNull com.google.firebase.firestore.Transaction.Function<TResult>);
+    method public void setFirestoreSettings(@NonNull com.google.firebase.firestore.FirebaseFirestoreSettings);
+    method public static void setLoggingEnabled(boolean);
+    method @NonNull public Task<Void> terminate();
+    method @NonNull public Task<Void> waitForPendingWrites();
+  }
+
+  public class FirebaseFirestoreException {
+    ctor public FirebaseFirestoreException(@NonNull String, @NonNull com.google.firebase.firestore.FirebaseFirestoreException.Code);
+    ctor public FirebaseFirestoreException(@NonNull String, @NonNull com.google.firebase.firestore.FirebaseFirestoreException.Code, @Nullable Throwable);
+    method @NonNull public com.google.firebase.firestore.FirebaseFirestoreException.Code getCode();
+  }
+
+  public enum FirebaseFirestoreException.Code {
+    method @NonNull public static com.google.firebase.firestore.FirebaseFirestoreException.Code fromValue(int);
+    method public int value();
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code ABORTED;
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code ALREADY_EXISTS;
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code CANCELLED;
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code DATA_LOSS;
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code DEADLINE_EXCEEDED;
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code FAILED_PRECONDITION;
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code INTERNAL;
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code INVALID_ARGUMENT;
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code NOT_FOUND;
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code OK;
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code OUT_OF_RANGE;
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code PERMISSION_DENIED;
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code RESOURCE_EXHAUSTED;
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code UNAUTHENTICATED;
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code UNAVAILABLE;
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code UNIMPLEMENTED;
+    enum_constant public static final com.google.firebase.firestore.FirebaseFirestoreException.Code UNKNOWN;
+  }
+
+  public final class FirebaseFirestoreSettings {
+    method public boolean areTimestampsInSnapshotsEnabled();
+    method public boolean equals(@Nullable Object);
+    method public long getCacheSizeBytes();
+    method @NonNull public String getHost();
+    method public int hashCode();
+    method public boolean isPersistenceEnabled();
+    method public boolean isSslEnabled();
+    method @NonNull public String toString();
+    field public static final long CACHE_SIZE_UNLIMITED = -1L; // 0xffffffffffffffffL
+  }
+
+  public static final class FirebaseFirestoreSettings.Builder {
+    ctor public FirebaseFirestoreSettings.Builder();
+    ctor public FirebaseFirestoreSettings.Builder(@NonNull com.google.firebase.firestore.FirebaseFirestoreSettings);
+    method @NonNull public com.google.firebase.firestore.FirebaseFirestoreSettings build();
+    method @NonNull public com.google.firebase.firestore.FirebaseFirestoreSettings.Builder setCacheSizeBytes(long);
+    method @NonNull public com.google.firebase.firestore.FirebaseFirestoreSettings.Builder setHost(@NonNull String);
+    method @NonNull public com.google.firebase.firestore.FirebaseFirestoreSettings.Builder setPersistenceEnabled(boolean);
+    method @NonNull public com.google.firebase.firestore.FirebaseFirestoreSettings.Builder setSslEnabled(boolean);
+    method @Deprecated @NonNull public com.google.firebase.firestore.FirebaseFirestoreSettings.Builder setTimestampsInSnapshotsEnabled(boolean);
+  }
+
+  public class GeoPoint {
+    ctor public GeoPoint(double, double);
+    method public int compareTo(@NonNull com.google.firebase.firestore.GeoPoint);
+    method public boolean equals(@Nullable Object);
+    method public double getLatitude();
+    method public double getLongitude();
+    method public int hashCode();
+    method @NonNull public String toString();
+  }
+
+  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface IgnoreExtraProperties {
+  }
+
+  public interface ListenerRegistration {
+    method public void remove();
+  }
+
+  public enum MetadataChanges {
+    enum_constant public static final com.google.firebase.firestore.MetadataChanges EXCLUDE;
+    enum_constant public static final com.google.firebase.firestore.MetadataChanges INCLUDE;
+  }
+
+  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface PropertyName {
+    method public abstract String value();
+  }
+
+  public class Query {
+    method @NonNull public com.google.firebase.firestore.ListenerRegistration addSnapshotListener(@NonNull com.google.firebase.firestore.EventListener<com.google.firebase.firestore.QuerySnapshot>);
+    method @NonNull public com.google.firebase.firestore.ListenerRegistration addSnapshotListener(@NonNull Executor, @NonNull com.google.firebase.firestore.EventListener<com.google.firebase.firestore.QuerySnapshot>);
+    method @NonNull public com.google.firebase.firestore.ListenerRegistration addSnapshotListener(@NonNull Activity, @NonNull com.google.firebase.firestore.EventListener<com.google.firebase.firestore.QuerySnapshot>);
+    method @NonNull public com.google.firebase.firestore.ListenerRegistration addSnapshotListener(@NonNull com.google.firebase.firestore.MetadataChanges, @NonNull com.google.firebase.firestore.EventListener<com.google.firebase.firestore.QuerySnapshot>);
+    method @NonNull public com.google.firebase.firestore.ListenerRegistration addSnapshotListener(@NonNull Executor, @NonNull com.google.firebase.firestore.MetadataChanges, @NonNull com.google.firebase.firestore.EventListener<com.google.firebase.firestore.QuerySnapshot>);
+    method @NonNull public com.google.firebase.firestore.ListenerRegistration addSnapshotListener(@NonNull Activity, @NonNull com.google.firebase.firestore.MetadataChanges, @NonNull com.google.firebase.firestore.EventListener<com.google.firebase.firestore.QuerySnapshot>);
+    method @NonNull public com.google.firebase.firestore.Query endAt(@NonNull com.google.firebase.firestore.DocumentSnapshot);
+    method @NonNull public com.google.firebase.firestore.Query endAt(Object...);
+    method @NonNull public com.google.firebase.firestore.Query endBefore(@NonNull com.google.firebase.firestore.DocumentSnapshot);
+    method @NonNull public com.google.firebase.firestore.Query endBefore(Object...);
+    method public boolean equals(Object);
+    method @NonNull public Task<QuerySnapshot> get();
+    method @NonNull public Task<QuerySnapshot> get(@NonNull com.google.firebase.firestore.Source);
+    method @NonNull public com.google.firebase.firestore.FirebaseFirestore getFirestore();
+    method public int hashCode();
+    method @NonNull public com.google.firebase.firestore.Query limit(long);
+    method @NonNull public com.google.firebase.firestore.Query orderBy(@NonNull String);
+    method @NonNull public com.google.firebase.firestore.Query orderBy(@NonNull com.google.firebase.firestore.FieldPath);
+    method @NonNull public com.google.firebase.firestore.Query orderBy(@NonNull String, @NonNull com.google.firebase.firestore.Query.Direction);
+    method @NonNull public com.google.firebase.firestore.Query orderBy(@NonNull com.google.firebase.firestore.FieldPath, @NonNull com.google.firebase.firestore.Query.Direction);
+    method @NonNull public com.google.firebase.firestore.Query startAfter(@NonNull com.google.firebase.firestore.DocumentSnapshot);
+    method @NonNull public com.google.firebase.firestore.Query startAfter(Object...);
+    method @NonNull public com.google.firebase.firestore.Query startAt(@NonNull com.google.firebase.firestore.DocumentSnapshot);
+    method @NonNull public com.google.firebase.firestore.Query startAt(Object...);
+    method @NonNull public com.google.firebase.firestore.Query whereArrayContains(@NonNull String, @NonNull Object);
+    method @NonNull public com.google.firebase.firestore.Query whereArrayContains(@NonNull com.google.firebase.firestore.FieldPath, @NonNull Object);
+    method @NonNull public com.google.firebase.firestore.Query whereEqualTo(@NonNull String, @Nullable Object);
+    method @NonNull public com.google.firebase.firestore.Query whereEqualTo(@NonNull com.google.firebase.firestore.FieldPath, @Nullable Object);
+    method @NonNull public com.google.firebase.firestore.Query whereGreaterThan(@NonNull String, @NonNull Object);
+    method @NonNull public com.google.firebase.firestore.Query whereGreaterThan(@NonNull com.google.firebase.firestore.FieldPath, @NonNull Object);
+    method @NonNull public com.google.firebase.firestore.Query whereGreaterThanOrEqualTo(@NonNull String, @NonNull Object);
+    method @NonNull public com.google.firebase.firestore.Query whereGreaterThanOrEqualTo(@NonNull com.google.firebase.firestore.FieldPath, @NonNull Object);
+    method @NonNull public com.google.firebase.firestore.Query whereLessThan(@NonNull String, @NonNull Object);
+    method @NonNull public com.google.firebase.firestore.Query whereLessThan(@NonNull com.google.firebase.firestore.FieldPath, @NonNull Object);
+    method @NonNull public com.google.firebase.firestore.Query whereLessThanOrEqualTo(@NonNull String, @NonNull Object);
+    method @NonNull public com.google.firebase.firestore.Query whereLessThanOrEqualTo(@NonNull com.google.firebase.firestore.FieldPath, @NonNull Object);
+  }
+
+  public enum Query.Direction {
+    enum_constant public static final com.google.firebase.firestore.Query.Direction ASCENDING;
+    enum_constant public static final com.google.firebase.firestore.Query.Direction DESCENDING;
+  }
+
+  public class QueryDocumentSnapshot extends com.google.firebase.firestore.DocumentSnapshot {
+  }
+
+  public class QuerySnapshot {
+    method public boolean equals(@Nullable Object);
+    method @NonNull public List<DocumentChange> getDocumentChanges();
+    method @NonNull public List<DocumentChange> getDocumentChanges(@NonNull com.google.firebase.firestore.MetadataChanges);
+    method @NonNull public List<DocumentSnapshot> getDocuments();
+    method @NonNull public com.google.firebase.firestore.SnapshotMetadata getMetadata();
+    method @NonNull public com.google.firebase.firestore.Query getQuery();
+    method public int hashCode();
+    method public boolean isEmpty();
+    method @NonNull public Iterator<QueryDocumentSnapshot> iterator();
+    method public int size();
+    method @NonNull public <T> List<T> toObjects(@NonNull Class<T>);
+    method @NonNull public <T> List<T> toObjects(@NonNull Class<T>, @NonNull com.google.firebase.firestore.DocumentSnapshot.ServerTimestampBehavior);
+  }
+
+  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface ServerTimestamp {
+  }
+
+  public final class SetOptions {
+    method public boolean equals(Object);
+    method public int hashCode();
+    method @NonNull public static com.google.firebase.firestore.SetOptions merge();
+    method @NonNull public static com.google.firebase.firestore.SetOptions mergeFieldPaths(@NonNull List<FieldPath>);
+    method @NonNull public static com.google.firebase.firestore.SetOptions mergeFields(@NonNull List<String>);
+    method @NonNull public static com.google.firebase.firestore.SetOptions mergeFields(String...);
+  }
+
+  public class SnapshotMetadata {
+    method public boolean equals(@Nullable Object);
+    method public boolean hasPendingWrites();
+    method public int hashCode();
+    method public boolean isFromCache();
+    method public String toString();
+  }
+
+  public enum Source {
+    enum_constant public static final com.google.firebase.firestore.Source CACHE;
+    enum_constant public static final com.google.firebase.firestore.Source DEFAULT;
+    enum_constant public static final com.google.firebase.firestore.Source SERVER;
+  }
+
+  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface ThrowOnExtraProperties {
+  }
+
+  public class Transaction {
+    method @NonNull public com.google.firebase.firestore.Transaction delete(@NonNull com.google.firebase.firestore.DocumentReference);
+    method @NonNull public com.google.firebase.firestore.DocumentSnapshot get(@NonNull com.google.firebase.firestore.DocumentReference) throws com.google.firebase.firestore.FirebaseFirestoreException;
+    method @NonNull public com.google.firebase.firestore.Transaction set(@NonNull com.google.firebase.firestore.DocumentReference, @NonNull Object);
+    method @NonNull public com.google.firebase.firestore.Transaction set(@NonNull com.google.firebase.firestore.DocumentReference, @NonNull Object, @NonNull com.google.firebase.firestore.SetOptions);
+    method @NonNull public com.google.firebase.firestore.Transaction update(@NonNull com.google.firebase.firestore.DocumentReference, @NonNull Map<String,Object>);
+    method @NonNull public com.google.firebase.firestore.Transaction update(@NonNull com.google.firebase.firestore.DocumentReference, @NonNull String, @Nullable Object, Object...);
+    method @NonNull public com.google.firebase.firestore.Transaction update(@NonNull com.google.firebase.firestore.DocumentReference, @NonNull com.google.firebase.firestore.FieldPath, @Nullable Object, Object...);
+  }
+
+  public static interface Transaction.Function<TResult> {
+    method @Nullable public TResult apply(@NonNull com.google.firebase.firestore.Transaction) throws com.google.firebase.firestore.FirebaseFirestoreException;
+  }
+
+  public class WriteBatch {
+    method @NonNull public Task<Void> commit();
+    method @NonNull public com.google.firebase.firestore.WriteBatch delete(@NonNull com.google.firebase.firestore.DocumentReference);
+    method @NonNull public com.google.firebase.firestore.WriteBatch set(@NonNull com.google.firebase.firestore.DocumentReference, @NonNull Object);
+    method @NonNull public com.google.firebase.firestore.WriteBatch set(@NonNull com.google.firebase.firestore.DocumentReference, @NonNull Object, @NonNull com.google.firebase.firestore.SetOptions);
+    method @NonNull public com.google.firebase.firestore.WriteBatch update(@NonNull com.google.firebase.firestore.DocumentReference, @NonNull Map<String,Object>);
+    method @NonNull public com.google.firebase.firestore.WriteBatch update(@NonNull com.google.firebase.firestore.DocumentReference, @NonNull String, @Nullable Object, Object...);
+    method @NonNull public com.google.firebase.firestore.WriteBatch update(@NonNull com.google.firebase.firestore.DocumentReference, @NonNull com.google.firebase.firestore.FieldPath, @Nullable Object, Object...);
+  }
+
+  public static interface WriteBatch.Function {
+    method public void apply(@NonNull com.google.firebase.firestore.WriteBatch);
+  }
+
+}
+
diff --git a/firebase-firestore/firebase-firestore.gradle b/firebase-firestore/firebase-firestore.gradle
index 6ec06af52..8e3c6eca0 100644
--- a/firebase-firestore/firebase-firestore.gradle
+++ b/firebase-firestore/firebase-firestore.gradle
@@ -64,7 +64,7 @@ android {
         minSdkVersion project.minSdkVersion
         versionName version
         multiDexEnabled true
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
     }
 
     sourceSets {
@@ -92,6 +92,25 @@ android {
         targetCompatibility JavaVersion.VERSION_1_8
     }
     testOptions.unitTests.includeAndroidResources = true
+    ext.useProdBackendForTests = false
+}
+
+android.libraryVariants.all { variant ->
+    if (findProperty("useProdBackendForTests")) {
+        variant.buildConfigField("boolean", "USE_EMULATOR_FOR_TESTS", "false")
+    } else {
+        variant.buildConfigField("boolean", "USE_EMULATOR_FOR_TESTS", "true")
+    }
+
+}
+
+configurations.all {
+    if(it.name.contains('AndroidTestRuntimeClasspath')) {
+        it.resolutionStrategy {
+            force 'org.checkerframework:checker-compat-qual:2.5.5'
+            force 'com.google.guava:guava:27.0.1-android'
+        }
+    }
 }
 
 dependencies {
@@ -99,44 +118,47 @@ dependencies {
     implementation project(':protolite-well-known-types')
     implementation project(':firebase-database-collection')
 
+
     //To provide @Generated annotations
     compileOnly 'javax.annotation:jsr250-api:1.0'
 
+    implementation 'androidx.annotation:annotation:1.1.0'
     implementation 'io.grpc:grpc-stub:1.21.0'
     implementation 'io.grpc:grpc-protobuf-lite:1.21.0'
     implementation 'io.grpc:grpc-okhttp:1.21.0'
     implementation 'io.grpc:grpc-android:1.21.0'
-    implementation "com.google.android.gms:play-services-basement:$playServicesVersion"
-    implementation "com.google.android.gms:play-services-tasks:$playServicesVersion"
-    implementation "com.google.android.gms:play-services-base:$playServicesVersion"
-
+    implementation 'com.google.android.gms:play-services-basement:17.0.0'
+    implementation 'com.google.android.gms:play-services-tasks:17.0.0'
+    implementation 'com.google.android.gms:play-services-base:17.0.0'
     implementation 'com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava'
 
     implementation 'com.squareup.okhttp:okhttp:2.7.5'
-    implementation('com.google.firebase:firebase-auth-interop:17.0.0') {
+    implementation('com.google.firebase:firebase-auth-interop:18.0.0') {
         exclude group: "com.google.firebase", module: "firebase-common"
     }
 
     testImplementation 'junit:junit:4.12'
-    testImplementation 'org.mockito:mockito-core:2.21.0'
+    testImplementation 'androidx.test:core:1.2.0'
+    testImplementation 'org.mockito:mockito-core:2.25.0'
     testImplementation "org.robolectric:robolectric:$robolectricVersion"
     testImplementation "com.google.truth:truth:$googleTruthVersion"
-    testImplementation 'com.fasterxml.jackson.core:jackson-databind:2.9.6'
+    testImplementation 'com.fasterxml.jackson.core:jackson-databind:2.9.8'
     testImplementation 'com.google.guava:guava-testlib:12.0-rc2'
 
     androidTestImplementation 'junit:junit:4.12'
     androidTestImplementation "com.google.truth:truth:$googleTruthVersion"
-    androidTestImplementation 'com.fasterxml.jackson.core:jackson-databind:2.9.6'
-    androidTestImplementation "com.android.support:support-annotations:$supportAnnotationsVersion"
-    androidTestImplementation 'com.android.support.test:runner:1.0.2'
-    androidTestImplementation 'com.android.support.test:rules:1.0.2'
+    androidTestImplementation 'com.fasterxml.jackson.core:jackson-databind:2.9.8'
+    androidTestImplementation "androidx.annotation:annotation:1.1.0"
+    androidTestImplementation 'androidx.test:runner:1.2.0'
+    androidTestImplementation 'androidx.test:rules:1.2.0'
+    androidTestImplementation 'androidx.test.ext:junit:1.1.1'
 }
 
 gradle.projectsEvaluated {
     tasks.withType(JavaCompile) {
-        // TODO(rsgowman): Also add "-Xlint:unchecked". But currently that
+        // TODO(wuandy): Also add "-Xlint:unchecked". But currently that
         // enables 100+ warnings due to our generated source code.
-        options.compilerArgs << "-Xlint:deprecation"
+        options.compilerArgs << "-Xlint:deprecation" << "-Werror"
     }
 }
 
diff --git a/firebase-firestore/gradle.properties b/firebase-firestore/gradle.properties
index 04d7bc444..d6489217d 100644
--- a/firebase-firestore/gradle.properties
+++ b/firebase-firestore/gradle.properties
@@ -1,2 +1,2 @@
-version=19.0.2
-latestReleasedVersion=19.0.1
+version=21.1.0
+latestReleasedVersion=21.0.0
diff --git a/firebase-firestore/ktx/ktx.gradle b/firebase-firestore/ktx/ktx.gradle
index fb7e8debd..ffbfb8f65 100644
--- a/firebase-firestore/ktx/ktx.gradle
+++ b/firebase-firestore/ktx/ktx.gradle
@@ -19,10 +19,11 @@ plugins {
 
 firebaseLibrary {
     releaseWith project(':firebase-firestore')
+    publishSources = true
 }
 
 android {
-    compileSdkVersion project.targetSdkVersion
+    compileSdkVersion 28
     defaultConfig {
         minSdkVersion project.minSdkVersion
         multiDexEnabled true
@@ -33,24 +34,25 @@ android {
         main.java.srcDirs += 'src/main/kotlin'
         test.java {
             srcDir 'src/test/kotlin'
-            srcDir '../src/testUtil/java'
-            srcDir '../src/roboUtil/java'
+            srcDir 'src/test/java'
         }
     }
     testOptions.unitTests.includeAndroidResources = true
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
 }
 
 dependencies {
     implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlinVersion"
-
     implementation project(':firebase-common')
     implementation project(':firebase-common:ktx')
     implementation project(':firebase-firestore')
-    implementation 'com.android.support:support-annotations:28.0.0'
-
+    implementation 'androidx.annotation:annotation:1.1.0'
     testImplementation project(':firebase-database-collection')
-    testImplementation 'org.mockito:mockito-core:2.21.0'
-    testImplementation 'com.fasterxml.jackson.core:jackson-databind:2.9.6'
+    testImplementation 'org.mockito:mockito-core:2.25.0'
+    testImplementation 'com.fasterxml.jackson.core:jackson-databind:2.9.8'
     testImplementation 'com.google.android.gms:play-services-tasks:16.0.1'
     testImplementation 'com.google.protobuf:protobuf-lite:3.0.1'
     testImplementation "org.robolectric:robolectric:$robolectricVersion"
diff --git a/firebase-firestore/ktx/src/main/kotlin/com/google/firebase/firestore/ktx/Firestore.kt b/firebase-firestore/ktx/src/main/kotlin/com/google/firebase/firestore/ktx/Firestore.kt
index a552954b1..c609215de 100644
--- a/firebase-firestore/ktx/src/main/kotlin/com/google/firebase/firestore/ktx/Firestore.kt
+++ b/firebase-firestore/ktx/src/main/kotlin/com/google/firebase/firestore/ktx/Firestore.kt
@@ -14,7 +14,7 @@
 
 package com.google.firebase.firestore.ktx
 
-import android.support.annotation.Keep
+import androidx.annotation.Keep
 import com.google.firebase.FirebaseApp
 import com.google.firebase.components.Component
 import com.google.firebase.components.ComponentRegistrar
diff --git a/firebase-firestore/ktx/src/test/java/com/google/firebase/firestore/TestUtil.java b/firebase-firestore/ktx/src/test/java/com/google/firebase/firestore/TestUtil.java
new file mode 100644
index 000000000..0fe99e0c7
--- /dev/null
+++ b/firebase-firestore/ktx/src/test/java/com/google/firebase/firestore/TestUtil.java
@@ -0,0 +1,124 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore;
+
+import static com.google.firebase.firestore.testutil.TestUtil.doc;
+import static com.google.firebase.firestore.testutil.TestUtil.docSet;
+import static com.google.firebase.firestore.testutil.TestUtil.key;
+import static org.mockito.Mockito.mock;
+
+import com.google.firebase.database.collection.ImmutableSortedSet;
+import com.google.firebase.firestore.core.DocumentViewChange;
+import com.google.firebase.firestore.core.DocumentViewChange.Type;
+import com.google.firebase.firestore.core.ViewSnapshot;
+import com.google.firebase.firestore.model.Document;
+import com.google.firebase.firestore.model.DocumentKey;
+import com.google.firebase.firestore.model.DocumentSet;
+import com.google.firebase.firestore.model.value.ObjectValue;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+public class TestUtil {
+
+  private static final FirebaseFirestore FIRESTORE = mock(FirebaseFirestore.class);
+
+  public static FirebaseFirestore firestore() {
+    return FIRESTORE;
+  }
+
+  public static DocumentSnapshot documentSnapshot(
+      String path, Map<String, Object> data, boolean isFromCache) {
+    if (data == null) {
+      return DocumentSnapshot.fromNoDocument(
+          FIRESTORE, key(path), isFromCache, /*hasPendingWrites=*/ false);
+    } else {
+      return DocumentSnapshot.fromDocument(
+          FIRESTORE, doc(path, 1L, data), isFromCache, /*hasPendingWrites=*/ false);
+    }
+  }
+
+  public static Query query(String path) {
+    return new Query(com.google.firebase.firestore.testutil.TestUtil.query(path), FIRESTORE);
+  }
+
+  /**
+   * A convenience method for creating a particular query snapshot for tests.
+   *
+   * @param path To be used in constructing the query.
+   * @param oldDocs Provides the prior set of documents in the QuerySnapshot. Each entry maps to a
+   *     document, with the key being the document id, and the value being the document contents.
+   * @param docsToAdd Specifies data to be added into the query snapshot as of now. Each entry maps
+   *     to a document, with the key being the document id, and the value being the document
+   *     contents.
+   * @param isFromCache Whether the query snapshot is cache result.
+   * @return A query snapshot that consists of both sets of documents.
+   */
+  public static QuerySnapshot querySnapshot(
+      String path,
+      Map<String, ObjectValue> oldDocs,
+      Map<String, ObjectValue> docsToAdd,
+      boolean hasPendingWrites,
+      boolean isFromCache) {
+    DocumentSet oldDocuments = docSet(Document.keyComparator());
+    ImmutableSortedSet<DocumentKey> mutatedKeys = DocumentKey.emptyKeySet();
+    for (Map.Entry<String, ObjectValue> pair : oldDocs.entrySet()) {
+      String docKey = path + "/" + pair.getKey();
+      oldDocuments =
+          oldDocuments.add(
+              doc(
+                  docKey,
+                  1L,
+                  pair.getValue(),
+                  hasPendingWrites
+                      ? Document.DocumentState.SYNCED
+                      : Document.DocumentState.LOCAL_MUTATIONS));
+
+      if (hasPendingWrites) {
+        mutatedKeys = mutatedKeys.insert(key(docKey));
+      }
+    }
+    DocumentSet newDocuments = docSet(Document.keyComparator());
+    List<DocumentViewChange> documentChanges = new ArrayList<>();
+    for (Map.Entry<String, ObjectValue> pair : docsToAdd.entrySet()) {
+      String docKey = path + "/" + pair.getKey();
+      Document docToAdd =
+          doc(
+              docKey,
+              1L,
+              pair.getValue(),
+              hasPendingWrites
+                  ? Document.DocumentState.SYNCED
+                  : Document.DocumentState.LOCAL_MUTATIONS);
+      newDocuments = newDocuments.add(docToAdd);
+      documentChanges.add(DocumentViewChange.create(Type.ADDED, docToAdd));
+
+      if (hasPendingWrites) {
+        mutatedKeys = mutatedKeys.insert(key(docKey));
+      }
+    }
+    ViewSnapshot viewSnapshot =
+        new ViewSnapshot(
+            com.google.firebase.firestore.testutil.TestUtil.query(path),
+            newDocuments,
+            oldDocuments,
+            documentChanges,
+            isFromCache,
+            mutatedKeys,
+            /* didSyncStateChange= */ true,
+            /* excludesMetadataChanges= */ false);
+    return new QuerySnapshot(query(path), viewSnapshot, FIRESTORE);
+  }
+}
diff --git a/firebase-firestore/ktx/src/test/java/com/google/firebase/firestore/testutil/TestUtil.java b/firebase-firestore/ktx/src/test/java/com/google/firebase/firestore/testutil/TestUtil.java
new file mode 100644
index 000000000..37776a3d0
--- /dev/null
+++ b/firebase-firestore/ktx/src/test/java/com/google/firebase/firestore/testutil/TestUtil.java
@@ -0,0 +1,91 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.testutil;
+
+import com.google.firebase.Timestamp;
+import com.google.firebase.firestore.UserDataConverter;
+import com.google.firebase.firestore.core.Query;
+import com.google.firebase.firestore.model.DatabaseId;
+import com.google.firebase.firestore.model.Document;
+import com.google.firebase.firestore.model.DocumentKey;
+import com.google.firebase.firestore.model.DocumentSet;
+import com.google.firebase.firestore.model.ResourcePath;
+import com.google.firebase.firestore.model.SnapshotVersion;
+import com.google.firebase.firestore.model.value.FieldValue;
+import com.google.firebase.firestore.model.value.ObjectValue;
+import java.util.Comparator;
+import java.util.Map;
+
+/** A set of utilities for tests */
+public class TestUtil {
+
+  public static FieldValue wrap(Object value) {
+    DatabaseId databaseId = DatabaseId.forProject("project");
+    UserDataConverter dataConverter = new UserDataConverter(databaseId);
+    // HACK: We use parseQueryValue() since it accepts scalars as well as arrays / objects, and
+    // our tests currently use wrap() pretty generically so we don't know the intent.
+    return dataConverter.parseQueryValue(value);
+  }
+
+  public static ObjectValue wrapObject(Map<String, Object> value) {
+    // Cast is safe here because value passed in is a map
+    return (ObjectValue) wrap(value);
+  }
+
+  public static DocumentKey key(String key) {
+    return DocumentKey.fromPathString(key);
+  }
+
+  public static ResourcePath path(String key) {
+    return ResourcePath.fromString(key);
+  }
+
+  public static Query query(String path) {
+    return Query.atPath(path(path));
+  }
+
+  public static SnapshotVersion version(long versionMicros) {
+    long seconds = versionMicros / 1000000;
+    int nanos = (int) (versionMicros % 1000000L) * 1000;
+    return new SnapshotVersion(new Timestamp(seconds, nanos));
+  }
+
+  public static Document doc(String key, long version, Map<String, Object> data) {
+    return new Document(
+        key(key), version(version), Document.DocumentState.SYNCED, wrapObject(data));
+  }
+
+  public static Document doc(DocumentKey key, long version, Map<String, Object> data) {
+    return new Document(key, version(version), Document.DocumentState.SYNCED, wrapObject(data));
+  }
+
+  public static Document doc(
+      String key, long version, ObjectValue data, Document.DocumentState documentState) {
+    return new Document(key(key), version(version), documentState, data);
+  }
+
+  public static Document doc(
+      String key, long version, Map<String, Object> data, Document.DocumentState documentState) {
+    return new Document(key(key), version(version), documentState, wrapObject(data));
+  }
+
+  public static DocumentSet docSet(Comparator<Document> comparator, Document... documents) {
+    DocumentSet set = DocumentSet.emptySet(comparator);
+    for (Document document : documents) {
+      set = set.add(document);
+    }
+    return set;
+  }
+}
diff --git a/firebase-firestore/ktx/src/test/kotlin/com/google/firebase/firestore/ktx/FirestoreTests.kt b/firebase-firestore/ktx/src/test/kotlin/com/google/firebase/firestore/ktx/FirestoreTests.kt
index ffb44440c..1f00da59c 100644
--- a/firebase-firestore/ktx/src/test/kotlin/com/google/firebase/firestore/ktx/FirestoreTests.kt
+++ b/firebase-firestore/ktx/src/test/kotlin/com/google/firebase/firestore/ktx/FirestoreTests.kt
@@ -75,13 +75,13 @@ class FirestoreTests : BaseTestCase() {
 
     @Test
     fun `firestore should delegate to FirebaseFirestore#getInstance()`() {
-        assertThat(Firebase.firestore).isSameAs(FirebaseFirestore.getInstance())
+        assertThat(Firebase.firestore).isSameInstanceAs(FirebaseFirestore.getInstance())
     }
 
     @Test
     fun `FirebaseApp#firestore should delegate to FirebaseFirestore#getInstance(FirebaseApp)`() {
         val app = Firebase.app(EXISTING_APP)
-        assertThat(Firebase.firestore(app)).isSameAs(FirebaseFirestore.getInstance(app))
+        assertThat(Firebase.firestore(app)).isSameInstanceAs(FirebaseFirestore.getInstance(app))
     }
 }
 
diff --git a/firebase-firestore/src/androidTest/AndroidManifest.xml b/firebase-firestore/src/androidTest/AndroidManifest.xml
index 8755b2b60..89bee0097 100644
--- a/firebase-firestore/src/androidTest/AndroidManifest.xml
+++ b/firebase-firestore/src/androidTest/AndroidManifest.xml
@@ -11,6 +11,6 @@
   </application>
 
   <instrumentation
-    android:name="android.support.test.runner.AndroidJUnitRunner"
+    android:name="androidx.test.runner.AndroidJUnitRunner"
     android:targetPackage="com.google.firebase.firestore" />
 </manifest>
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/AccessHelper.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/AccessHelper.java
index 557c2728e..30c4e0ecb 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/AccessHelper.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/AccessHelper.java
@@ -31,14 +31,16 @@ public static FirebaseFirestore newFirebaseFirestore(
       String persistenceKey,
       CredentialsProvider credentialsProvider,
       AsyncQueue asyncQueue,
-      FirebaseApp firebaseApp) {
+      FirebaseApp firebaseApp,
+      FirebaseFirestore.InstanceRegistry instanceRegistry) {
     return new FirebaseFirestore(
-        context, databaseId, persistenceKey, credentialsProvider, asyncQueue, firebaseApp);
-  }
-
-  /** Makes the shutdown method accessible. */
-  public static Task<Void> shutdown(FirebaseFirestore firestore) {
-    return firestore.shutdown();
+        context,
+        databaseId,
+        persistenceKey,
+        credentialsProvider,
+        asyncQueue,
+        firebaseApp,
+        instanceRegistry);
   }
 
   public static AsyncQueue getAsyncQueue(FirebaseFirestore firestore) {
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ArrayTransformsServerApplicationTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ArrayTransformsServerApplicationTest.java
index 436dc5946..cc680a05a 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ArrayTransformsServerApplicationTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ArrayTransformsServerApplicationTest.java
@@ -20,9 +20,9 @@
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitForException;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
 import static java.util.Arrays.asList;
-import static junit.framework.Assert.assertEquals;
+import static org.junit.Assert.assertEquals;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.firebase.firestore.FirebaseFirestoreException.Code;
 import org.junit.Before;
 import org.junit.Test;
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ArrayTransformsTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ArrayTransformsTest.java
index 46de87b87..db874dde4 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ArrayTransformsTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ArrayTransformsTest.java
@@ -18,10 +18,10 @@
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitFor;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
 import static java.util.Arrays.asList;
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.firebase.firestore.testutil.EventAccumulator;
 import com.google.firebase.firestore.testutil.IntegrationTestUtil;
 import java.util.Map;
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/CursorTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/CursorTest.java
index 803b668f1..c225a60b8 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/CursorTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/CursorTest.java
@@ -23,10 +23,10 @@
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.writeAllDocs;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
 import static java.util.Arrays.asList;
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertTrue;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.Query.Direction;
 import com.google.firebase.firestore.testutil.IntegrationTestUtil;
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/FieldsTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/FieldsTest.java
index 42cc33f08..2e731a8d1 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/FieldsTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/FieldsTest.java
@@ -22,10 +22,10 @@
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitFor;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
 import static com.google.firebase.firestore.util.Util.autoId;
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertNull;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.Tasks;
 import com.google.firebase.Timestamp;
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/FirestoreTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/FirestoreTest.java
index 649931986..405db0826 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/FirestoreTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/FirestoreTest.java
@@ -17,40 +17,47 @@
 import static com.google.firebase.firestore.AccessHelper.getAsyncQueue;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.newTestSettings;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.provider;
+import static com.google.firebase.firestore.testutil.IntegrationTestUtil.testChangeUserTo;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.testCollection;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.testCollectionWithDocs;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.testDocument;
+import static com.google.firebase.firestore.testutil.IntegrationTestUtil.testFirebaseApp;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.testFirestore;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitFor;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitForException;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitForOnlineSnapshot;
 import static com.google.firebase.firestore.testutil.TestUtil.expectError;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertNull;
-import static junit.framework.Assert.assertSame;
-import static junit.framework.Assert.assertTrue;
-import static junit.framework.Assert.fail;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
-
-import android.support.test.runner.AndroidJUnit4;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
+import com.google.firebase.FirebaseApp;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.FirebaseFirestoreException.Code;
 import com.google.firebase.firestore.Query.Direction;
+import com.google.firebase.firestore.auth.User;
 import com.google.firebase.firestore.testutil.EventAccumulator;
 import com.google.firebase.firestore.testutil.IntegrationTestUtil;
 import com.google.firebase.firestore.util.AsyncQueue.TimerId;
 import com.google.firebase.firestore.util.Logger.Level;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Semaphore;
 import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -504,31 +511,83 @@ public void testAddingToACollectionYieldsTheCorrectDocumentReference() {
     assertEquals(data, document.getData());
   }
 
+  @Test
+  public void testSnapshotsInSyncListenerFiresAfterListenersInSync() {
+    Map<String, Object> data = map("foo", 1.0);
+    CollectionReference collection = testCollection();
+    DocumentReference documentReference = waitFor(collection.add(data));
+    List<String> events = new ArrayList<>();
+
+    Semaphore gotInitialSnapshot = new Semaphore(0);
+    Semaphore done = new Semaphore(0);
+
+    ListenerRegistration listenerRegistration = null;
+
+    documentReference.addSnapshotListener(
+        (value, error) -> {
+          events.add("doc");
+          gotInitialSnapshot.release();
+        });
+    waitFor(gotInitialSnapshot);
+    events.clear();
+
+    try {
+      listenerRegistration =
+          documentReference
+              .getFirestore()
+              .addSnapshotsInSyncListener(
+                  () -> {
+                    events.add("snapshots-in-sync");
+                    if (events.size() == 3) {
+                      // We should have an initial snapshots-in-sync event, then a snapshot event
+                      // for set(), then another event to indicate we're in sync again.
+                      assertEquals(
+                          Arrays.asList("snapshots-in-sync", "doc", "snapshots-in-sync"), events);
+                      done.release();
+                    }
+                  });
+      waitFor(documentReference.set(map("foo", 3.0)));
+      waitFor(done);
+    } finally {
+      if (listenerRegistration != null) {
+        listenerRegistration.remove();
+      }
+    }
+  }
+
   @Test
   public void testQueriesAreValidatedOnClient() {
     // NOTE: Failure cases are validated in ValidationTest.
     CollectionReference collection = testCollection();
     final Query query = collection.whereGreaterThanOrEqualTo("x", 32);
-    // Same inequality field works;
+    // Same inequality field works.
     query.whereLessThanOrEqualTo("x", "cat");
-    // Equality on different field works;
+    // Equality on different field works.
     query.whereEqualTo("y", "cat");
-    // Array contains on different field works;
+    // Array contains on different field works.
     query.whereArrayContains("y", "cat");
+    // Array contains any on different field works.
+    query.whereArrayContainsAny("y", Arrays.asList("cat"));
+    // In on different field works.
+    query.whereIn("y", Arrays.asList("cat"));
 
     // Ordering by inequality field succeeds.
     query.orderBy("x");
     collection.orderBy("x").whereGreaterThanOrEqualTo("x", 32);
 
-    // inequality same as first order by works
+    // Inequality same as first order by works.
     query.orderBy("x").orderBy("y");
     collection.orderBy("x").orderBy("y").whereGreaterThanOrEqualTo("x", 32);
     collection.orderBy("x", Direction.DESCENDING).whereEqualTo("y", "true");
 
-    // Equality different than orderBy works
+    // Equality different than orderBy works.
     collection.orderBy("x").whereEqualTo("y", "cat");
-    // Array contains different than orderBy works
+    // Array contains different than orderBy works.
     collection.orderBy("x").whereArrayContains("y", "cat");
+    // Array contains any different than orderBy works.
+    collection.orderBy("x").whereArrayContainsAny("y", Arrays.asList("cat"));
+    // In different than orderBy works.
+    collection.orderBy("x").whereIn("y", Arrays.asList("cat"));
   }
 
   @Test
@@ -958,10 +1017,11 @@ public void testCanDisableAndEnableNetworking() {
   }
 
   @Test
-  public void testClientCallsAfterShutdownFails() {
+  public void testClientCallsAfterTerminateFails() {
     FirebaseFirestore firestore = testFirestore();
-    waitFor(firestore.shutdown());
-    expectError(() -> waitFor(firestore.disableNetwork()), "The client has already been shutdown");
+    waitFor(firestore.terminate());
+    expectError(
+        () -> waitFor(firestore.disableNetwork()), "The client has already been terminated");
   }
 
   @Test
@@ -970,7 +1030,7 @@ public void testMaintainsPersistenceAfterRestarting() {
         testFirestore(provider().projectId(), Level.DEBUG, newTestSettings(), "dbPersistenceKey");
     DocumentReference docRef = firestore.collection("col1").document("doc1");
     waitFor(docRef.set(map("foo", "bar")));
-    waitFor(AccessHelper.shutdown(firestore));
+    waitFor(firestore.terminate());
     IntegrationTestUtil.removeFirestore(firestore);
 
     // We restart the app with the same name and options to check that the previous instance's
@@ -989,7 +1049,7 @@ public void testCanClearPersistenceAfterRestarting() throws Exception {
         testFirestore(provider().projectId(), Level.DEBUG, newTestSettings(), "dbPersistenceKey");
     DocumentReference docRef = firestore.collection("col1").document("doc1");
     waitFor(docRef.set(map("foo", "bar")));
-    waitFor(AccessHelper.shutdown(firestore));
+    waitFor(firestore.terminate());
     IntegrationTestUtil.removeFirestore(firestore);
     waitFor(AccessHelper.clearPersistence(firestore));
 
@@ -1015,4 +1075,151 @@ public void testClearPersistenceWhileRunningFails() {
     FirebaseFirestoreException firestoreException = (FirebaseFirestoreException) e;
     assertEquals(Code.FAILED_PRECONDITION, firestoreException.getCode());
   }
+
+  @Test
+  public void testRestartFirestoreLeadsToNewInstance() {
+    FirebaseApp app = testFirebaseApp();
+    FirebaseFirestore instance = FirebaseFirestore.getInstance(app);
+    instance.setFirestoreSettings(newTestSettings());
+    FirebaseFirestore sameInstance = FirebaseFirestore.getInstance(app);
+
+    assertSame(instance, sameInstance);
+    waitFor(instance.document("abc/123").set(Collections.singletonMap("field", 100L)));
+
+    instance.terminate();
+    FirebaseFirestore newInstance = FirebaseFirestore.getInstance(app);
+    newInstance.setFirestoreSettings(newTestSettings());
+
+    // Verify new instance works.
+    DocumentSnapshot doc = waitFor(newInstance.document("abc/123").get());
+    assertEquals(doc.get("field"), 100L);
+    waitFor(newInstance.document("abc/123").delete());
+
+    // Verify it is different instance.
+    assertNotSame(instance, newInstance);
+  }
+
+  @Test
+  public void testAppDeleteLeadsToFirestoreTerminate() {
+    FirebaseApp app = testFirebaseApp();
+    FirebaseFirestore instance = FirebaseFirestore.getInstance(app);
+    instance.setFirestoreSettings(newTestSettings());
+    waitFor(instance.document("abc/123").set(Collections.singletonMap("Field", 100)));
+
+    app.delete();
+
+    assertTrue(instance.getClient().isTerminated());
+  }
+
+  @Test
+  public void testNewOperationThrowsAfterFirestoreTerminate() {
+    FirebaseFirestore instance = testFirestore();
+    DocumentReference reference = instance.document("abc/123");
+    waitFor(reference.set(Collections.singletonMap("Field", 100)));
+
+    instance.terminate();
+
+    final String expectedMessage = "The client has already been terminated";
+    expectError(() -> waitFor(reference.get()), expectedMessage);
+    expectError(() -> waitFor(reference.update("Field", 1)), expectedMessage);
+    expectError(
+        () -> waitFor(reference.set(Collections.singletonMap("Field", 1))), expectedMessage);
+    expectError(
+        () -> waitFor(instance.runBatch((batch) -> batch.update(reference, "Field", 1))),
+        expectedMessage);
+    expectError(
+        () -> waitFor(instance.runTransaction(transaction -> transaction.get(reference))),
+        expectedMessage);
+  }
+
+  @Test
+  public void testTerminateCalledMultipleTimes() {
+    FirebaseFirestore instance = testFirestore();
+    DocumentReference reference = instance.document("abc/123");
+    waitFor(reference.set(Collections.singletonMap("Field", 100)));
+
+    instance.terminate();
+
+    final String expectedMessage = "The client has already been terminated";
+    expectError(() -> waitFor(reference.get()), expectedMessage);
+
+    // Calling a second time should go through and change nothing.
+    instance.terminate();
+
+    expectError(() -> waitFor(reference.get()), expectedMessage);
+  }
+
+  @Test
+  public void testCanStopListeningAfterTerminate() {
+    FirebaseFirestore instance = testFirestore();
+    DocumentReference reference = instance.document("abc/123");
+    EventAccumulator<DocumentSnapshot> eventAccumulator = new EventAccumulator<>();
+    ListenerRegistration registration = reference.addSnapshotListener(eventAccumulator.listener());
+    eventAccumulator.await();
+
+    waitFor(instance.terminate());
+
+    // This should proceed without error.
+    registration.remove();
+    // Multiple calls should proceed as an effectively no-op.
+    registration.remove();
+  }
+
+  @Test
+  public void testWaitForPendingWritesResolves() {
+    DocumentReference documentReference = testCollection("abc").document("123");
+    FirebaseFirestore firestore = documentReference.getFirestore();
+    Map<String, Object> data = map("foo", "bar");
+
+    waitFor(firestore.disableNetwork());
+    Task<Void> awaitsPendingWrites1 = firestore.waitForPendingWrites();
+    Task<Void> pendingWrite = documentReference.set(data);
+    Task<Void> awaitsPendingWrites2 = firestore.waitForPendingWrites();
+
+    // `awaitsPendingWrites1` completes immediately because there are no pending writes at
+    // the time it is created.
+    waitFor(awaitsPendingWrites1);
+    assertTrue(awaitsPendingWrites1.isComplete() && awaitsPendingWrites1.isSuccessful());
+    assertTrue(!pendingWrite.isComplete());
+    assertTrue(!awaitsPendingWrites2.isComplete());
+
+    firestore.enableNetwork();
+    waitFor(awaitsPendingWrites2);
+    assertTrue(awaitsPendingWrites2.isComplete() && awaitsPendingWrites2.isSuccessful());
+  }
+
+  @Test
+  public void testWaitForPendingWritesFailsWhenUserChanges() {
+    DocumentReference documentReference = testCollection("abc").document("123");
+    FirebaseFirestore firestore = documentReference.getFirestore();
+    Map<String, Object> data = map("foo", "bar");
+
+    // Prevent pending writes receiving acknowledgement.
+    waitFor(firestore.disableNetwork());
+    Task<Void> pendingWrite = documentReference.set(data);
+    Task<Void> awaitsPendingWrites = firestore.waitForPendingWrites();
+    assertTrue(!pendingWrite.isComplete());
+    assertTrue(!awaitsPendingWrites.isComplete());
+
+    testChangeUserTo(new User("new user"));
+
+    assertTrue(!pendingWrite.isComplete());
+    assertEquals(
+        "'waitForPendingWrites' task is cancelled due to User change.",
+        waitForException(awaitsPendingWrites).getMessage());
+  }
+
+  @Test
+  public void testPendingWriteTaskResolveWhenOfflineIfThereIsNoPending() {
+    DocumentReference documentReference = testCollection("abc").document("123");
+    FirebaseFirestore firestore = documentReference.getFirestore();
+    Map<String, Object> data = map("foo", "bar");
+
+    // Prevent pending writes receiving acknowledgement.
+    waitFor(firestore.disableNetwork());
+    Task<Void> awaitsPendingWrites = firestore.waitForPendingWrites();
+    waitFor(awaitsPendingWrites);
+
+    assertTrue(awaitsPendingWrites.isComplete() && awaitsPendingWrites.isSuccessful());
+  }
 }
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ListenerRegistrationTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ListenerRegistrationTest.java
index d6018365b..157fc5647 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ListenerRegistrationTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ListenerRegistrationTest.java
@@ -17,13 +17,13 @@
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.testCollection;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitFor;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertNull;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 import android.app.Activity;
-import android.support.test.rule.ActivityTestRule;
-import android.support.test.runner.AndroidJUnit4;
-import android.support.v4.app.FragmentActivity;
+import androidx.fragment.app.FragmentActivity;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.rule.ActivityTestRule;
 import com.google.firebase.firestore.testutil.IntegrationTestUtil;
 import java.util.concurrent.Semaphore;
 import org.junit.After;
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/NumericTransformsTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/NumericTransformsTest.java
index 3f22d3562..b16ba390a 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/NumericTransformsTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/NumericTransformsTest.java
@@ -17,10 +17,11 @@
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.testDocument;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitFor;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.gms.tasks.Tasks;
 import com.google.firebase.firestore.testutil.EventAccumulator;
 import com.google.firebase.firestore.testutil.IntegrationTestUtil;
@@ -158,4 +159,55 @@ public void multipleDoubleIncrements() throws ExecutionException, InterruptedExc
     snap = accumulator.awaitRemoteEvent();
     assertEquals(0.111D, snap.getDouble("sum"), DOUBLE_EPSILON);
   }
+
+  @Test
+  public void incrementTwiceInABatch() {
+    writeInitialData(map("sum", "overwrite"));
+    waitFor(
+        docRef
+            .getFirestore()
+            .batch()
+            .update(docRef, "sum", FieldValue.increment(1))
+            .update(docRef, "sum", FieldValue.increment(1))
+            .commit());
+    expectLocalAndRemoteValue(2L);
+  }
+
+  @Test
+  public void incrementDeleteIncrementInABatch() {
+    writeInitialData(map("sum", "overwrite"));
+    waitFor(
+        docRef
+            .getFirestore()
+            .batch()
+            .update(docRef, "sum", FieldValue.increment(1))
+            .update(docRef, "sum", FieldValue.delete())
+            .update(docRef, "sum", FieldValue.increment(3))
+            .commit());
+    expectLocalAndRemoteValue(3L);
+  }
+
+  @Test
+  public void serverTimestampAndIncrement() throws ExecutionException, InterruptedException {
+    // This test stacks two pending transforms (a ServerTimestamp and an Increment transform) and
+    // reproduces the setup that was reported in
+    // https://github.com/firebase/firebase-android-sdk/issues/491
+    // In our original code, a NumericIncrementTransformOperation could cause us to decode the
+    // ServerTimestamp as part of a PatchMutation, which triggered an assertion failure.
+    Tasks.await(docRef.getFirestore().disableNetwork());
+
+    docRef.set(map("val", FieldValue.serverTimestamp()));
+    docRef.set(map("val", FieldValue.increment(1)));
+
+    DocumentSnapshot snap = accumulator.awaitLocalEvent();
+    assertNotNull(snap.getTimestamp("val", DocumentSnapshot.ServerTimestampBehavior.ESTIMATE));
+
+    snap = accumulator.awaitLocalEvent();
+    assertEquals(1, (long) snap.getLong("val"));
+
+    Tasks.await(docRef.getFirestore().enableNetwork());
+
+    snap = accumulator.awaitRemoteEvent();
+    assertEquals(1, (long) snap.getLong("val"));
+  }
 }
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/POJOTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/POJOTest.java
index 6bbf00fb6..8cceddb71 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/POJOTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/POJOTest.java
@@ -19,9 +19,9 @@
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitFor;
 import static com.google.firebase.firestore.testutil.TestUtil.expectError;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
-import static junit.framework.Assert.assertEquals;
+import static org.junit.Assert.assertEquals;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.Tasks;
 import com.google.firebase.Timestamp;
@@ -38,7 +38,7 @@
 
 @RunWith(AndroidJUnit4.class)
 public class POJOTest {
-  public static class POJO {
+  public static final class POJO {
 
     double number;
     String str;
@@ -123,7 +123,7 @@ public boolean equals(Object o) {
       if (this == o) {
         return true;
       }
-      if (o == null || getClass() != o.getClass()) {
+      if (o == null || !(o instanceof POJO)) {
         return false;
       }
 
@@ -201,6 +201,34 @@ public void setShortValue(@Nullable Short shortValue) {
     }
   }
 
+  public static final class POJOWithDocumentIdAnnotation {
+    String str;
+    @DocumentId public DocumentReference autoPopulatedReference;
+    @DocumentId String docReferenceId;
+
+    static class NestedPOJO {
+      @DocumentId public DocumentReference autoPopulatedReference;
+    }
+
+    public NestedPOJO nested = new NestedPOJO();
+
+    public String getDocReferenceId() {
+      return docReferenceId;
+    }
+
+    public void setDocReferenceId(String id) {
+      this.docReferenceId = id;
+    }
+
+    public String getStr() {
+      return str;
+    }
+
+    public void setStr(String str) {
+      this.str = str;
+    }
+  }
+
   @After
   public void tearDown() {
     IntegrationTestUtil.tearDown();
@@ -216,6 +244,20 @@ public void testWriteAndRead() {
     assertEquals(data, otherData);
   }
 
+  @Test
+  public void testDocumentIdAnnotation() {
+    CollectionReference collection = testCollection();
+    POJOWithDocumentIdAnnotation data = new POJOWithDocumentIdAnnotation();
+    data.setStr("name");
+    DocumentReference reference = waitFor(collection.add(data));
+    DocumentSnapshot doc = waitFor(reference.get());
+    POJOWithDocumentIdAnnotation readFromStore = doc.toObject(POJOWithDocumentIdAnnotation.class);
+    assertEquals("name", readFromStore.getStr());
+    assertEquals(reference, readFromStore.autoPopulatedReference);
+    assertEquals(reference, readFromStore.nested.autoPopulatedReference);
+    assertEquals(reference.getId(), readFromStore.getDocReferenceId());
+  }
+
   @Test
   public void testSetMerge() {
     CollectionReference collection = testCollection();
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/QueryTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/QueryTest.java
index 09c02ec58..bde84061e 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/QueryTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/QueryTest.java
@@ -14,6 +14,7 @@
 
 package com.google.firebase.firestore;
 
+import static com.google.firebase.firestore.testutil.IntegrationTestUtil.isRunningAgainstEmulator;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.querySnapshotToIds;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.querySnapshotToValues;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.testCollection;
@@ -23,12 +24,12 @@
 import static com.google.firebase.firestore.testutil.TestUtil.map;
 import static java.util.Arrays.asList;
 import static java.util.Collections.singletonList;
-import static junit.framework.Assert.assertEquals;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.gms.tasks.Task;
 import com.google.firebase.firestore.Query.Direction;
 import com.google.firebase.firestore.testutil.EventAccumulator;
@@ -38,6 +39,7 @@
 import java.util.Map;
 import java.util.concurrent.Semaphore;
 import org.junit.After;
+import org.junit.Assume;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -427,6 +429,78 @@ public void testQueriesCanUseArrayContainsFilters() {
     // much of anything else interesting to test.
   }
 
+  @Test
+  public void testQueriesCanUseInFilters() {
+    // TODO(in-queries): Re-enable in prod once feature lands in backend.
+    Assume.assumeTrue(isRunningAgainstEmulator());
+
+    Map<String, Object> docA = map("zip", 98101L);
+    Map<String, Object> docB = map("zip", 91102L);
+    Map<String, Object> docC = map("zip", 98103L);
+    Map<String, Object> docD = map("zip", asList(98101L));
+    Map<String, Object> docE = map("zip", asList("98101", map("zip", 98101L)));
+    Map<String, Object> docF = map("zip", map("code", 500L));
+    CollectionReference collection =
+        testCollectionWithDocs(
+            map("a", docA, "b", docB, "c", docC, "d", docD, "e", docE, "f", docF));
+
+    // Search for zips matching [98101, 98103].
+    QuerySnapshot snapshot = waitFor(collection.whereIn("zip", asList(98101L, 98103L)).get());
+    assertEquals(asList(docA, docC), querySnapshotToValues(snapshot));
+
+    // With objects.
+    snapshot = waitFor(collection.whereIn("zip", asList(map("code", 500L))).get());
+    assertEquals(asList(docF), querySnapshotToValues(snapshot));
+  }
+
+  @Test
+  public void testQueriesCanUseInFiltersWithDocIds() {
+    // TODO(in-queries): Re-enable in prod once feature lands in backend.
+    Assume.assumeTrue(isRunningAgainstEmulator());
+
+    Map<String, String> docA = map("key", "aa");
+    Map<String, String> docB = map("key", "ab");
+    Map<String, String> docC = map("key", "ba");
+    Map<String, String> docD = map("key", "bb");
+    Map<String, Map<String, Object>> testDocs =
+        map(
+            "aa", docA,
+            "ab", docB,
+            "ba", docC,
+            "bb", docD);
+    CollectionReference collection = testCollectionWithDocs(testDocs);
+    QuerySnapshot docs =
+        waitFor(collection.whereIn(FieldPath.documentId(), asList("aa", "ab")).get());
+    assertEquals(asList(docA, docB), querySnapshotToValues(docs));
+  }
+
+  @Test
+  public void testQueriesCanUseArrayContainsAnyFilters() {
+    // TODO(in-queries): Re-enable in prod once feature lands in backend.
+    Assume.assumeTrue(isRunningAgainstEmulator());
+
+    Map<String, Object> docA = map("array", asList(42L));
+    Map<String, Object> docB = map("array", asList("a", 42L, "c"));
+    Map<String, Object> docC = map("array", asList(41.999, "42", map("a", asList(42))));
+    Map<String, Object> docD = map("array", asList(42L), "array2", asList("bingo"));
+    Map<String, Object> docE = map("array", asList(43L));
+    Map<String, Object> docF = map("array", asList(map("a", 42L)));
+    Map<String, Object> docG = map("array", 42L);
+
+    CollectionReference collection =
+        testCollectionWithDocs(
+            map("a", docA, "b", docB, "c", docC, "d", docD, "e", docE, "f", docF));
+
+    // Search for "array" to contain [42, 43].
+    QuerySnapshot snapshot =
+        waitFor(collection.whereArrayContainsAny("array", asList(42L, 43L)).get());
+    assertEquals(asList(docA, docB, docD, docE), querySnapshotToValues(snapshot));
+
+    // With objects.
+    snapshot = waitFor(collection.whereArrayContainsAny("array", asList(map("a", 42L))).get());
+    assertEquals(asList(docF), querySnapshotToValues(snapshot));
+  }
+
   @Test
   public void testCollectionGroupQueries() {
     FirebaseFirestore db = testFirestore();
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ServerTimestampTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ServerTimestampTest.java
index 3fb396565..4fcc6f4f6 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ServerTimestampTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ServerTimestampTest.java
@@ -19,14 +19,14 @@
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitFor;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitForException;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertNull;
-import static junit.framework.Assert.assertTrue;
-import static junit.framework.Assert.fail;
-
-import android.support.test.runner.AndroidJUnit4;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.gms.tasks.Task;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.DocumentSnapshot.ServerTimestampBehavior;
@@ -181,6 +181,12 @@ public void testServerTimestampsCanReturnPreviousValue() {
     DocumentSnapshot previousSnapshot = accumulator.awaitRemoteEvent();
     verifyTimestampsAreResolved(previousSnapshot);
 
+    // The following update includes an update of the nested map "deep", which updates it to contain
+    // a single ServerTimestamp. As such, the update is split into two mutations: One that sets
+    // "deep" to an empty map and overwrites the previous ServerTimestamp value and a second
+    // transform that writes the new ServerTimestamp. This step in the test verifies that we can
+    // still access the old ServerTimestamp value (from `previousSnapshot`) even though it was
+    // removed in an intermediate step.
     waitFor(docRef.update(updateData));
     verifyTimestampsUsePreviousValue(accumulator.awaitLocalEvent(), previousSnapshot);
     verifyTimestampsAreResolved(accumulator.awaitRemoteEvent());
@@ -319,9 +325,7 @@ public void testServerTimestampsFailViaTransactionUpdateOnNonexistentDocument()
     Exception e = waitForException(completion);
     assertNotNull(e);
     assertTrue(e instanceof FirebaseFirestoreException);
-    // TODO: This should be a NOT_FOUND, but right now we retry transactions on any
-    // error and so this turns into ABORTED instead.
-    assertEquals(Code.ABORTED, ((FirebaseFirestoreException) e).getCode());
+    assertEquals(Code.NOT_FOUND, ((FirebaseFirestoreException) e).getCode());
   }
 
   @Test
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/SmokeTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/SmokeTest.java
index 2e77c338a..1289f4239 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/SmokeTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/SmokeTest.java
@@ -17,11 +17,11 @@
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.testCollection;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitFor;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertTrue;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.Tasks;
 import com.google.firebase.firestore.Query.Direction;
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/SourceTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/SourceTest.java
index d3e8d7278..fd6ed1652 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/SourceTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/SourceTest.java
@@ -22,12 +22,12 @@
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitFor;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitForException;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
-import static junit.framework.Assert.assertNull;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.firebase.firestore.testutil.IntegrationTestUtil;
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/TransactionTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/TransactionTest.java
index e7a0615ce..b900492c5 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/TransactionTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/TransactionTest.java
@@ -18,19 +18,22 @@
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitFor;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitForException;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertTrue;
-import static junit.framework.Assert.fail;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.android.gms.tasks.Tasks;
 import com.google.firebase.firestore.FirebaseFirestoreException.Code;
 import com.google.firebase.firestore.testutil.IntegrationTestUtil;
+import com.google.firebase.firestore.util.AsyncQueue.TimerId;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
 import java.util.Map;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -40,6 +43,160 @@
 
 @RunWith(AndroidJUnit4.class)
 public class TransactionTest {
+  interface TransactionStage {
+    void runStage(Transaction transaction, DocumentReference docRef)
+        throws FirebaseFirestoreException;
+  }
+
+  private static TransactionStage delete1 = Transaction::delete;
+
+  private static TransactionStage update1 =
+      (Transaction transaction, DocumentReference docRef) ->
+          transaction.update(docRef, map("foo", "bar1"));
+
+  private static TransactionStage update2 =
+      (Transaction transaction, DocumentReference docRef) ->
+          transaction.update(docRef, map("foo", "bar2"));
+
+  private static TransactionStage set1 =
+      (Transaction transaction, DocumentReference docRef) ->
+          transaction.set(docRef, map("foo", "bar1"));
+
+  private static TransactionStage set2 =
+      (Transaction transaction, DocumentReference docRef) ->
+          transaction.set(docRef, map("foo", "bar2"));
+
+  private static TransactionStage get = Transaction::get;
+
+  /**
+   * Used for testing that all possible combinations of executing transactions result in the desired
+   * document value or error.
+   *
+   * <p>`run()`, `withExistingDoc()`, and `withNonexistentDoc()` don't actually do anything except
+   * assign variables into the TransactionTester.
+   *
+   * <p>`expectDoc()`, `expectNoDoc()`, and `expectError()` will trigger the transaction to run and
+   * assert that the end result matches the input.
+   */
+  private static class TransactionTester {
+    private FirebaseFirestore db;
+    private DocumentReference docRef;
+    private boolean fromExistingDoc = false;
+    private List<TransactionStage> stages = new ArrayList<>();
+
+    TransactionTester(FirebaseFirestore inputDb) {
+      db = inputDb;
+    }
+
+    public TransactionTester withExistingDoc() {
+      fromExistingDoc = true;
+      return this;
+    }
+
+    public TransactionTester withNonexistentDoc() {
+      fromExistingDoc = false;
+      return this;
+    }
+
+    public TransactionTester run(TransactionStage... inputStages) {
+      stages = Arrays.asList(inputStages);
+      return this;
+    }
+
+    public void expectDoc(Object expected) {
+      try {
+        prepareDoc();
+        waitFor(runTransaction());
+        DocumentSnapshot snapshot = waitFor(docRef.get());
+        assertTrue(snapshot.exists());
+        assertEquals(expected, snapshot.getData());
+      } catch (Exception e) {
+        fail(
+            "Expected the sequence ("
+                + listStages(stages)
+                + ") to succeed, but got "
+                + e.toString());
+      }
+      cleanupTester();
+    }
+
+    private void expectNoDoc() {
+      try {
+        prepareDoc();
+        waitFor(runTransaction());
+        DocumentSnapshot snapshot = waitFor(docRef.get());
+        assertFalse(snapshot.exists());
+      } catch (Exception e) {
+        fail(
+            "Expected the sequence ("
+                + listStages(stages)
+                + ") to succeed, but got "
+                + e.toString());
+      }
+      cleanupTester();
+    }
+
+    private void expectError(Code expected) {
+      prepareDoc();
+      Task<Void> transactionTask = runTransaction();
+      try {
+        waitForException(transactionTask);
+      } catch (Exception e) {
+        throw new AssertionError(
+            "Expected the sequence ("
+                + listStages(stages)
+                + ") to fail with the error "
+                + expected.toString());
+      }
+      assertFalse(transactionTask.isSuccessful());
+      Exception e = transactionTask.getException();
+      assertEquals(expected, ((FirebaseFirestoreException) e).getCode());
+      cleanupTester();
+    }
+
+    private void prepareDoc() {
+      docRef = db.collection("tester-docref").document();
+      if (fromExistingDoc) {
+        waitFor(docRef.set(map("foo", "bar0")));
+        DocumentSnapshot docSnap = waitFor(docRef.get());
+        assertTrue(docSnap.exists());
+      }
+    }
+
+    private Task<Void> runTransaction() {
+      return db.runTransaction(
+          transaction -> {
+            for (TransactionStage stage : stages) {
+              stage.runStage(transaction, docRef);
+            }
+            return null;
+          });
+    }
+
+    private void cleanupTester() {
+      stages = new ArrayList<>();
+      // Set the docRef to something else to lose the original reference.
+      docRef = db.collection("reset").document();
+    }
+
+    private static String listStages(List<TransactionStage> stages) {
+      List<String> seqList = new ArrayList<>();
+      for (TransactionStage stage : stages) {
+        if (stage == delete1) {
+          seqList.add("delete");
+        } else if (stage == update1 || stage == update2) {
+          seqList.add("update");
+        } else if (stage == set1 || stage == set2) {
+          seqList.add("set");
+        } else if (stage == get) {
+          seqList.add("get");
+        } else {
+          throw new IllegalArgumentException("Stage not recognized");
+        }
+      }
+      return seqList.toString();
+    }
+  }
 
   @After
   public void tearDown() {
@@ -55,56 +212,80 @@ public void testGetDocuments() {
     Exception e = waitForException(firestore.runTransaction(transaction -> transaction.get(doc)));
     // We currently require every document read to also be written.
     // TODO: Fix this check once we drop that requirement.
-    assertEquals("Transaction failed all retries.", e.getMessage());
-    assertEquals(
-        "Every document read in a transaction must also be written.", e.getCause().getMessage());
+    assertEquals(Code.INVALID_ARGUMENT, ((FirebaseFirestoreException) e).getCode());
+    assertEquals("Every document read in a transaction must also be written.", e.getMessage());
   }
 
   @Test
-  public void testDeleteDocument() {
+  public void testRunsTransactionsAfterGettingExistingDoc() {
     FirebaseFirestore firestore = testFirestore();
-    DocumentReference doc = firestore.collection("towns").document();
-    waitFor(doc.set(map("foo", "bar")));
-    DocumentSnapshot snapshot = waitFor(doc.get());
-    assertEquals("bar", snapshot.getString("foo"));
-    waitFor(
-        firestore.runTransaction(
-            transaction -> {
-              transaction.delete(doc);
-              return null;
-            }));
-    snapshot = waitFor(doc.get());
-    assertFalse(snapshot.exists());
+    TransactionTester tt = new TransactionTester(firestore);
+
+    tt.withExistingDoc().run(get, delete1, delete1).expectNoDoc();
+    tt.withExistingDoc().run(get, delete1, update2).expectError(Code.INVALID_ARGUMENT);
+    tt.withExistingDoc().run(get, delete1, set2).expectDoc(map("foo", "bar2"));
+
+    tt.withExistingDoc().run(get, update1, delete1).expectNoDoc();
+    tt.withExistingDoc().run(get, update1, update2).expectDoc(map("foo", "bar2"));
+    tt.withExistingDoc().run(get, update1, set2).expectDoc(map("foo", "bar2"));
+
+    tt.withExistingDoc().run(get, set1, delete1).expectNoDoc();
+    tt.withExistingDoc().run(get, set1, update2).expectDoc(map("foo", "bar2"));
+    tt.withExistingDoc().run(get, set1, set2).expectDoc(map("foo", "bar2"));
   }
 
   @Test
-  public void testGetNonexistentDocumentThenCreate() {
+  public void testRunsTransactionsAfterGettingNonexistentDoc() {
     FirebaseFirestore firestore = testFirestore();
-    DocumentReference docRef = firestore.collection("towns").document();
-    waitFor(
-        firestore.runTransaction(
-            transaction -> {
-              DocumentSnapshot docSnap = transaction.get(docRef);
-              assertFalse(docSnap.exists());
-              transaction.set(docRef, map("foo", "bar"));
-              return null;
-            }));
-    DocumentSnapshot snapshot = waitFor(docRef.get());
-    assertEquals("bar", snapshot.getString("foo"));
+    TransactionTester tt = new TransactionTester(firestore);
+
+    tt.withNonexistentDoc().run(get, delete1, delete1).expectNoDoc();
+    tt.withNonexistentDoc().run(get, delete1, update2).expectError(Code.INVALID_ARGUMENT);
+    tt.withNonexistentDoc().run(get, delete1, set2).expectDoc(map("foo", "bar2"));
+
+    tt.withNonexistentDoc().run(get, update1, delete1).expectError(Code.INVALID_ARGUMENT);
+    tt.withNonexistentDoc().run(get, update1, update2).expectError(Code.INVALID_ARGUMENT);
+    tt.withNonexistentDoc().run(get, update1, set2).expectError(Code.INVALID_ARGUMENT);
+
+    tt.withNonexistentDoc().run(get, set1, delete1).expectNoDoc();
+    tt.withNonexistentDoc().run(get, set1, update2).expectDoc(map("foo", "bar2"));
+    tt.withNonexistentDoc().run(get, set1, set2).expectDoc(map("foo", "bar2"));
   }
 
   @Test
-  public void testWriteDocumentTwice() {
+  public void testRunsTransactionsOnExistingDoc() {
     FirebaseFirestore firestore = testFirestore();
-    DocumentReference doc = firestore.collection("towns").document();
-    waitFor(
-        firestore.runTransaction(
-            transaction -> {
-              transaction.set(doc, map("a", "b")).set(doc, map("c", "d"));
-              return null;
-            }));
-    DocumentSnapshot snapshot = waitFor(doc.get());
-    assertEquals(map("c", "d"), snapshot.getData());
+    TransactionTester tt = new TransactionTester(firestore);
+
+    tt.withExistingDoc().run(delete1, delete1).expectNoDoc();
+    tt.withExistingDoc().run(delete1, update2).expectError(Code.INVALID_ARGUMENT);
+    tt.withExistingDoc().run(delete1, set2).expectDoc(map("foo", "bar2"));
+
+    tt.withExistingDoc().run(update1, delete1).expectNoDoc();
+    tt.withExistingDoc().run(update1, update2).expectDoc(map("foo", "bar2"));
+    tt.withExistingDoc().run(update1, set2).expectDoc(map("foo", "bar2"));
+
+    tt.withExistingDoc().run(set1, delete1).expectNoDoc();
+    tt.withExistingDoc().run(set1, update2).expectDoc(map("foo", "bar2"));
+    tt.withExistingDoc().run(set1, set2).expectDoc(map("foo", "bar2"));
+  }
+
+  @Test
+  public void testRunsTransactionsOnNonexistentDoc() {
+    FirebaseFirestore firestore = testFirestore();
+    TransactionTester tt = new TransactionTester(firestore);
+
+    tt.withNonexistentDoc().run(delete1, delete1).expectNoDoc();
+    tt.withNonexistentDoc().run(delete1, update2).expectError(Code.INVALID_ARGUMENT);
+    tt.withNonexistentDoc().run(delete1, set2).expectDoc(map("foo", "bar2"));
+
+    tt.withNonexistentDoc().run(update1, delete1).expectError(Code.NOT_FOUND);
+    tt.withNonexistentDoc().run(update1, update2).expectError(Code.NOT_FOUND);
+    tt.withNonexistentDoc().run(update1, set2).expectError(Code.NOT_FOUND);
+
+    tt.withNonexistentDoc().run(set1, delete1).expectNoDoc();
+    tt.withNonexistentDoc().run(set1, update2).expectDoc(map("foo", "bar2"));
+    tt.withNonexistentDoc().run(set1, set2).expectDoc(map("foo", "bar2"));
   }
 
   @Test
@@ -133,6 +314,7 @@ public void testIncrementTransactionally() {
     AtomicInteger started = new AtomicInteger(0);
 
     FirebaseFirestore firestore = testFirestore();
+    firestore.getAsyncQueue().skipDelaysForTimerId(TimerId.RETRY_TRANSACTION);
     DocumentReference doc = firestore.collection("counters").document();
     waitFor(doc.set(map("count", 5.0)));
 
@@ -164,85 +346,6 @@ public void testIncrementTransactionally() {
     assertEquals(8, snapshot.getDouble("count").intValue());
   }
 
-  @Test
-  public void testTransactionRejectsUpdatesForNonexistentDocuments() {
-    final FirebaseFirestore firestore = testFirestore();
-
-    // Make a transaction that will fail
-    Task<Void> transactionTask =
-        firestore.runTransaction(
-            transaction -> {
-              // Get and update a document that doesn't exist so that the transaction fails
-              DocumentSnapshot doc =
-                  transaction.get(firestore.collection("nonexistent").document());
-              transaction.update(doc.getReference(), "foo", "bar");
-              return null;
-            });
-
-    // Let all of the transactions fetch the old value and stop once.
-    waitForException(transactionTask);
-    assertFalse(transactionTask.isSuccessful());
-    Exception e = transactionTask.getException();
-    // TODO: should this really be raised as a FirebaseFirestoreException?
-    // Note that this test might change if transaction.get throws a FirebaseFirestoreException.
-    assertTrue(e instanceof IllegalStateException);
-  }
-
-  @Test
-  public void testCantDeleteDocumentThenPatch() {
-    final FirebaseFirestore firestore = testFirestore();
-    final DocumentReference docRef = firestore.collection("docs").document();
-    waitFor(docRef.set(map("foo", "bar")));
-
-    // Make a transaction that will fail
-    Task<Void> transactionTask =
-        firestore.runTransaction(
-            transaction -> {
-              DocumentSnapshot doc = transaction.get(docRef);
-              assertTrue(doc.exists());
-              transaction.delete(docRef);
-              // Since we deleted the doc, the update will fail
-              transaction.update(docRef, "foo", "bar");
-              return null;
-            });
-
-    // Let all of the transactions fetch the old value and stop once.
-    waitForException(transactionTask);
-    assertFalse(transactionTask.isSuccessful());
-    Exception e = transactionTask.getException();
-    // TODO: should this really be raised as a FirebaseFirestoreException?
-    // Note that this test might change if transaction.update throws a FirebaseFirestoreException.
-    assertTrue(e instanceof IllegalStateException);
-  }
-
-  @Test
-  public void testCantDeleteDocumentThenSet() {
-    final FirebaseFirestore firestore = testFirestore();
-    final DocumentReference docRef = firestore.collection("docs").document();
-    waitFor(docRef.set(map("foo", "bar")));
-
-    // Make a transaction that will fail
-    Task<Void> transactionTask =
-        firestore.runTransaction(
-            transaction -> {
-              DocumentSnapshot doc = transaction.get(docRef);
-              assertTrue(doc.exists());
-              transaction.delete(docRef);
-              // TODO: In theory this should work, but it's complex to make it work, so
-              // instead we just let the transaction fail and verify it's unsupported for now
-              transaction.set(docRef, map("foo", "new-bar"));
-              return null;
-            });
-
-    // Let all of the transactions fetch the old value and stop once.
-    waitForException(transactionTask);
-    assertFalse(transactionTask.isSuccessful());
-    Exception e = transactionTask.getException();
-    assertTrue(e instanceof FirebaseFirestoreException);
-    assertEquals(
-        FirebaseFirestoreException.Code.ABORTED, ((FirebaseFirestoreException) e).getCode());
-  }
-
   @Test
   public void testTransactionRaisesErrorsForInvalidUpdates() {
     final FirebaseFirestore firestore = testFirestore();
@@ -263,7 +366,6 @@ public void testTransactionRaisesErrorsForInvalidUpdates() {
     assertFalse(transactionTask.isSuccessful());
     Exception e = transactionTask.getException();
     assertNotNull(e);
-    assertTrue(e instanceof FirebaseFirestoreException);
     FirebaseFirestoreException firestoreException = (FirebaseFirestoreException) e;
     assertEquals(Code.INVALID_ARGUMENT, firestoreException.getCode());
   }
@@ -275,9 +377,10 @@ public void testUpdateTransactionally() {
     ArrayList<Task<Void>> readTasks = new ArrayList<>();
     // A barrier to make sure every transaction reaches the same spot.
     TaskCompletionSource<Void> barrier = new TaskCompletionSource<>();
-    AtomicInteger started = new AtomicInteger(0);
+    AtomicInteger counter = new AtomicInteger(0);
 
     FirebaseFirestore firestore = testFirestore();
+    firestore.getAsyncQueue().skipDelaysForTimerId(TimerId.RETRY_TRANSACTION);
     DocumentReference doc = firestore.collection("counters").document();
     waitFor(doc.set(map("count", 5.0, "other", "yes")));
 
@@ -288,9 +391,9 @@ public void testUpdateTransactionally() {
       transactionTasks.add(
           firestore.runTransaction(
               transaction -> {
+                counter.incrementAndGet();
                 DocumentSnapshot snapshot = transaction.get(doc);
                 assertNotNull(snapshot);
-                started.incrementAndGet();
                 resolveRead.trySetResult(null);
                 waitFor(barrier.getTask());
                 transaction.update(doc, map("count", snapshot.getDouble("count") + 1.0));
@@ -300,10 +403,12 @@ public void testUpdateTransactionally() {
 
     // Let all of the transactions fetch the old value and stop once.
     waitFor(Tasks.whenAll(readTasks));
-    assertEquals(3, started.intValue());
-    // Let all of the transactions continue and wait for them to finish.
+    // There should be 3 initial transaction runs.
+    assertEquals(3, counter.get());
     barrier.setResult(null);
     waitFor(Tasks.whenAll(transactionTasks));
+    // There should be a maximum of 3 retries: once for the 2nd update, and twice for the 3rd update
+    assertTrue(counter.get() <= 6);
     // Now all transaction should be completed, so check the result.
     DocumentSnapshot snapshot = waitFor(doc.get());
     assertEquals(8, snapshot.getDouble("count").intValue());
@@ -370,6 +475,7 @@ public void testUpdatePOJOTransactionally() {
     AtomicInteger started = new AtomicInteger(0);
 
     FirebaseFirestore firestore = testFirestore();
+    firestore.getAsyncQueue().skipDelaysForTimerId(TimerId.RETRY_TRANSACTION);
     DocumentReference doc = firestore.collection("counters").document();
     waitFor(doc.set(new POJO(5.0, "no", "clean")));
 
@@ -437,33 +543,35 @@ public void testHandleReadingOneDocAndWritingAnother() {
     // assertEquals(1234, snapshot.getDouble("count"));
     // snapshot = waitFor(doc2.get());
     // assertEquals(16, snapshot.getDouble("count"));
-    assertEquals("Transaction failed all retries.", e.getMessage());
-    assertEquals(
-        "Every document read in a transaction must also be written.", e.getCause().getMessage());
+    assertEquals(Code.INVALID_ARGUMENT, ((FirebaseFirestoreException) e).getCode());
+    assertEquals("Every document read in a transaction must also be written.", e.getMessage());
   }
 
   @Test
   public void testReadingADocTwiceWithDifferentVersions() {
     FirebaseFirestore firestore = testFirestore();
+    firestore.getAsyncQueue().skipDelaysForTimerId(TimerId.RETRY_TRANSACTION);
     DocumentReference doc = firestore.collection("counters").document();
     waitFor(doc.set(map("count", 15.0)));
-    waitForException(
-        firestore.runTransaction(
-            transaction -> {
-              // Get the doc once.
-              DocumentSnapshot snapshot1 = transaction.get(doc);
-              assertEquals(15, snapshot1.getDouble("count").intValue());
-              // Do a write outside of the transaction.
-              waitFor(doc.set(map("count", 1234.0)));
-              // Get the doc again in the transaction with the new version.
-              DocumentSnapshot snapshot2 = transaction.get(doc);
-              // The get itself will fail, because we already read an earlier version of this
-              // document.
-              fail("Should have thrown exception");
-              return null;
-            }));
-    DocumentSnapshot snapshot = waitFor(doc.get());
-    assertEquals(1234, snapshot.getDouble("count").intValue());
+    AtomicInteger counter = new AtomicInteger(0);
+    Exception e =
+        waitForException(
+            firestore.runTransaction(
+                transaction -> {
+                  counter.incrementAndGet();
+                  // Get the doc once.
+                  DocumentSnapshot snapshot1 = transaction.get(doc);
+                  // Do a write outside of the transaction. Because the transaction will retry, set
+                  // the document to a different value each time.
+                  waitFor(doc.set(map("count", 1234.0 + counter.get())));
+                  // Get the doc again in the transaction with the new version.
+                  DocumentSnapshot snapshot2 = transaction.get(doc);
+                  // The get itself will fail, because we already read an earlier version of this
+                  // document.
+                  fail("Should have thrown exception");
+                  return null;
+                }));
+    assertEquals(Code.ABORTED, ((FirebaseFirestoreException) e).getCode());
   }
 
   @Test
@@ -480,18 +588,67 @@ public void testCannotReadAfterWriting() {
     assertNotNull(e);
   }
 
+  @Test
+  public void testReadAndUpdateNonExistentDocumentWithExternalWrite() {
+    FirebaseFirestore firestore = testFirestore();
+
+    // Make a transaction that will fail
+    Task<Void> transactionTask =
+        firestore.runTransaction(
+            transaction -> {
+              // Get and update a document that doesn't exist so that the transaction fails.
+              DocumentReference doc = firestore.collection("nonexistent").document();
+              transaction.get(doc);
+              // Do a write outside of the transaction.
+              doc.set(map("count", 1234));
+              // Now try to update the other doc from within the transaction.
+              // This should fail, because the document didn't exist at the
+              // start of the transaction.
+              transaction.update(doc, "count", 16);
+              return null;
+            });
+
+    waitForException(transactionTask);
+    assertFalse(transactionTask.isSuccessful());
+    Exception e = transactionTask.getException();
+    assertEquals(Code.INVALID_ARGUMENT, ((FirebaseFirestoreException) e).getCode());
+    assertEquals("Can't update a document that doesn't exist.", e.getMessage());
+  }
+
   @Test
   public void testCannotHaveAGetWithoutMutations() {
     FirebaseFirestore firestore = testFirestore();
     DocumentReference doc = firestore.collection("foo").document();
     waitFor(doc.set(map("foo", "bar")));
+
     Exception e = waitForException(firestore.runTransaction(transaction -> transaction.get(doc)));
     // We currently require every document read to also be written.
     // TODO: Add this check back once we drop that.
     // assertEquals("bar", snapshot.getString("foo"));
-    assertEquals("Transaction failed all retries.", e.getMessage());
-    assertEquals(
-        "Every document read in a transaction must also be written.", e.getCause().getMessage());
+    assertEquals(Code.INVALID_ARGUMENT, ((FirebaseFirestoreException) e).getCode());
+    assertEquals("Every document read in a transaction must also be written.", e.getMessage());
+  }
+
+  @Test
+  public void testDoesNotRetryOnPermanentError() {
+    final FirebaseFirestore firestore = testFirestore();
+    AtomicInteger count = new AtomicInteger(0);
+    // Make a transaction that should fail with a permanent error
+    Task<Void> transactionTask =
+        firestore.runTransaction(
+            transaction -> {
+              count.incrementAndGet();
+              // Get and update a document that doesn't exist so that the transaction fails
+              DocumentSnapshot doc =
+                  transaction.get(firestore.collection("nonexistent").document());
+              transaction.update(doc.getReference(), "foo", "bar");
+              return null;
+            });
+
+    // Let all of the transactions fetch the old value and stop once.
+    Exception e = waitForException(transactionTask);
+    assertEquals(Code.INVALID_ARGUMENT, ((FirebaseFirestoreException) e).getCode());
+    assertEquals(1, count.get());
   }
 
   @Test
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/TypeTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/TypeTest.java
index b86f25be6..664c22078 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/TypeTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/TypeTest.java
@@ -22,7 +22,7 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.testutil.IntegrationTestUtil;
 import java.util.Arrays;
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ValidationTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ValidationTest.java
index 87dc07b70..aea7acae8 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ValidationTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ValidationTest.java
@@ -22,6 +22,7 @@
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.testDocument;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.testFirestore;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitFor;
+import static com.google.firebase.firestore.testutil.TestUtil.assertDoesNotThrow;
 import static com.google.firebase.firestore.testutil.TestUtil.expectError;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
 import static java.util.Arrays.asList;
@@ -30,8 +31,8 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.FirebaseOptions;
@@ -98,7 +99,7 @@ public void firestoreGetInstanceWithNonNullAppReturnsNonNullInstance() {
   private static void withApp(String name, Consumer<FirebaseApp> toRun) {
     FirebaseApp app =
         FirebaseApp.initializeApp(
-            InstrumentationRegistry.getContext(),
+            ApplicationProvider.getApplicationContext(),
             new FirebaseOptions.Builder()
                 .setApiKey("key")
                 .setApplicationId("appId")
@@ -239,23 +240,31 @@ public void writesMustNotContainReferencesToADifferentDatabase() {
 
   @Test
   public void writesMustNotContainReservedFieldNames() {
+    expectWriteSuccess(map("__bar", 1));
+    expectWriteSuccess(map("bar__", 1));
+
     expectWriteError(
         map("__baz__", 1),
-        "Invalid data. Document fields cannot begin and end with __ (found in field __baz__)");
+        "Invalid data. Document fields cannot begin and end with \"__\" (found in field __baz__)");
     expectWriteError(
         map("foo", map("__baz__", 1)),
-        "Invalid data. Document fields cannot begin and end with __ (found in field foo.__baz__)");
+        "Invalid data. Document fields cannot begin and end with \"__\" (found in field foo.__baz__)");
     expectWriteError(
         map("__baz__", map("foo", 1)),
-        "Invalid data. Document fields cannot begin and end with __ (found in field __baz__)");
+        "Invalid data. Document fields cannot begin and end with \"__\" (found in field __baz__)");
 
     expectUpdateError(
         map("__baz__", 1),
-        "Invalid data. Document fields cannot begin and end with __ (found in field __baz__)");
+        "Invalid data. Document fields cannot begin and end with \"__\" (found in field __baz__)");
     expectUpdateError(
         map("baz.__foo__", 1),
-        "Invalid data. Document fields cannot begin and end with "
-            + "__ (found in field baz.__foo__)");
+        "Invalid data. Document fields cannot begin and end with \"__\" (found in field baz.__foo__)");
+  }
+
+  @Test
+  public void writesMustNotContainEmptyFieldNames() {
+    expectSetError(
+        map("", "foo"), "Invalid data. Document fields must not be empty (found in field ``)");
   }
 
   @Test
@@ -277,7 +286,7 @@ public void updatesMustNotContainNestedFieldValueDeletes() {
   @Test
   public void batchWritesRequireCorrectDocumentReferences() {
     DocumentReference badRef = testAlternateFirestore().document("foo/bar");
-    String reason = "Provided document reference is from a different Firestore instance.";
+    String reason = "Provided document reference is from a different Cloud Firestore instance.";
     Map<String, Object> data = map("foo", 1);
     WriteBatch batch = testFirestore().batch();
     expectError(() -> batch.set(badRef, data), reason);
@@ -288,7 +297,7 @@ public void batchWritesRequireCorrectDocumentReferences() {
   @Test
   public void transactionsRequireCorrectDocumentReferences() {
     DocumentReference badRef = testAlternateFirestore().document("foo/bar");
-    String reason = "Provided document reference is from a different Firestore instance.";
+    String reason = "Provided document reference is from a different Cloud Firestore instance.";
     Map<String, Object> data = map("foo", 1);
     waitFor(
         testFirestore()
@@ -298,8 +307,7 @@ public void transactionsRequireCorrectDocumentReferences() {
                       expectError(
                           () -> {
                             // Because .get() throws a checked exception for missing docs, we have
-                            // to
-                            // try/catch it.
+                            // to try/catch it.
                             try {
                               transaction.get(badRef);
                             } catch (FirebaseFirestoreException e) {
@@ -332,11 +340,7 @@ public void fieldPathsMustNotHaveInvalidSegments() {
     List<String> badFieldPaths =
         asList("foo~bar", "foo*bar", "foo/bar", "foo[1", "foo]1", "foo[1]");
     for (String fieldPath : badFieldPaths) {
-      String reason =
-          "Invalid field path ("
-              + fieldPath
-              + "). Paths must not contain '~', '*', '/', '[', or ']'";
-      verifyFieldPathThrows(fieldPath, reason);
+      verifyFieldPathThrows(fieldPath, "Use FieldPath.of() for field names containing '~*/[]'.");
     }
   }
 
@@ -404,17 +408,23 @@ public void queriesWithNullOrNaNFiltersOtherThanEqualityFail() {
     CollectionReference collection = testCollection();
     expectError(
         () -> collection.whereGreaterThan("a", null),
-        "Invalid Query. You can only perform equality comparisons on null (via whereEqualTo()).");
+        "Invalid Query. Null supports only equality comparisons (via whereEqualTo()).");
     expectError(
         () -> collection.whereArrayContains("a", null),
-        "Invalid Query. You can only perform equality comparisons on null (via whereEqualTo()).");
+        "Invalid Query. Null supports only equality comparisons (via whereEqualTo()).");
+    expectError(
+        () -> collection.whereArrayContainsAny("a", null),
+        "Invalid Query. A non-empty array is required for 'array_contains_any' filters.");
+    expectError(
+        () -> collection.whereIn("a", null),
+        "Invalid Query. A non-empty array is required for 'in' filters.");
 
     expectError(
         () -> collection.whereGreaterThan("a", Double.NaN),
-        "Invalid Query. You can only perform equality comparisons on NaN (via whereEqualTo()).");
+        "Invalid Query. NaN supports only equality comparisons (via whereEqualTo()).");
     expectError(
         () -> collection.whereArrayContains("a", Double.NaN),
-        "Invalid Query. You can only perform equality comparisons on NaN (via whereEqualTo()).");
+        "Invalid Query. NaN supports only equality comparisons (via whereEqualTo()).");
   }
 
   @Test
@@ -539,10 +549,129 @@ public void queriesWithInequalityDifferentThanFirstOrderByFail() {
   }
 
   @Test
-  public void queriesWithMultipleArrayContainsFiltersFail() {
+  public void queriesWithMultipleArrayFiltersFail() {
     expectError(
         () -> testCollection().whereArrayContains("foo", 1).whereArrayContains("foo", 2),
-        "Invalid Query. Queries only support having a single array-contains filter.");
+        "Invalid Query. You cannot use more than one 'array_contains' filter.");
+
+    expectError(
+        () ->
+            testCollection()
+                .whereArrayContains("foo", 1)
+                .whereArrayContainsAny("foo", asList(1, 2)),
+        "Invalid Query. You cannot use 'array_contains_any' filters with 'array_contains' filters.");
+
+    expectError(
+        () ->
+            testCollection()
+                .whereArrayContainsAny("foo", asList(1, 2))
+                .whereArrayContains("foo", 1),
+        "Invalid Query. You cannot use 'array_contains' filters with 'array_contains_any' filters.");
+  }
+
+  @Test
+  public void queriesWithMultipleDisjunctiveFiltersFail() {
+    expectError(
+        () -> testCollection().whereIn("foo", asList(1, 2)).whereIn("bar", asList(1, 2)),
+        "Invalid Query. You cannot use more than one 'in' filter.");
+
+    expectError(
+        () ->
+            testCollection()
+                .whereArrayContainsAny("foo", asList(1, 2))
+                .whereArrayContainsAny("bar", asList(1, 2)),
+        "Invalid Query. You cannot use more than one 'array_contains_any' filter.");
+
+    expectError(
+        () ->
+            testCollection()
+                .whereArrayContainsAny("foo", asList(1, 2))
+                .whereIn("bar", asList(1, 2)),
+        "Invalid Query. You cannot use 'in' filters with 'array_contains_any' filters.");
+
+    expectError(
+        () ->
+            testCollection()
+                .whereIn("bar", asList(1, 2))
+                .whereArrayContainsAny("foo", asList(1, 2)),
+        "Invalid Query. You cannot use 'array_contains_any' filters with 'in' filters.");
+
+    // This is redundant with the above tests, but makes sure our validation doesn't get confused.
+    expectError(
+        () ->
+            testCollection()
+                .whereIn("bar", asList(1, 2))
+                .whereArrayContains("foo", 1)
+                .whereArrayContainsAny("foo", asList(1, 2)),
+        "Invalid Query. You cannot use 'array_contains_any' filters with 'in' filters.");
+
+    expectError(
+        () ->
+            testCollection()
+                .whereArrayContains("foo", 1)
+                .whereIn("bar", asList(1, 2))
+                .whereArrayContainsAny("foo", asList(1, 2)),
+        "Invalid Query. You cannot use 'array_contains_any' filters with 'in' filters.");
+  }
+
+  @Test
+  public void queriesCanUseInWithArrayContains() {
+    testCollection().whereArrayContains("foo", 1).whereIn("bar", asList(1, 2));
+    testCollection().whereIn("bar", asList(1, 2)).whereArrayContains("foo", 1);
+
+    expectError(
+        () ->
+            testCollection()
+                .whereIn("bar", asList(1, 2))
+                .whereArrayContains("foo", 1)
+                .whereArrayContains("foo", 1),
+        "Invalid Query. You cannot use more than one 'array_contains' filter.");
+
+    expectError(
+        () ->
+            testCollection()
+                .whereArrayContains("foo", 1)
+                .whereIn("bar", asList(1, 2))
+                .whereIn("bar", asList(1, 2)),
+        "Invalid Query. You cannot use more than one 'in' filter.");
+  }
+
+  @Test
+  public void queriesInAndArrayContainsAnyArrayRules() {
+    expectError(
+        () -> testCollection().whereIn("bar", asList()),
+        "Invalid Query. A non-empty array is required for 'in' filters.");
+
+    expectError(
+        () -> testCollection().whereArrayContainsAny("bar", asList()),
+        "Invalid Query. A non-empty array is required for 'array_contains_any' filters.");
+
+    expectError(
+        // The 10 element max includes duplicates.
+        () -> testCollection().whereIn("bar", asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 9)),
+        "Invalid Query. 'in' filters support a maximum of 10 elements in the value array.");
+
+    expectError(
+        // The 10 element max includes duplicates.
+        () ->
+            testCollection().whereArrayContainsAny("bar", asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 9)),
+        "Invalid Query. 'array_contains_any' filters support a maximum of 10 elements in the value array.");
+
+    expectError(
+        () -> testCollection().whereIn("bar", asList("foo", null)),
+        "Invalid Query. 'in' filters cannot contain 'null' in the value array.");
+
+    expectError(
+        () -> testCollection().whereArrayContainsAny("bar", asList("foo", null)),
+        "Invalid Query. 'array_contains_any' filters cannot contain 'null' in the value array.");
+
+    expectError(
+        () -> testCollection().whereIn("bar", asList("foo", Double.NaN)),
+        "Invalid Query. 'in' filters cannot contain 'NaN' in the value array.");
+
+    expectError(
+        () -> testCollection().whereArrayContainsAny("bar", asList("foo", Float.NaN)),
+        "Invalid Query. 'array_contains_any' filters cannot contain 'NaN' in the value array.");
   }
 
   @Test
@@ -591,14 +720,114 @@ public void queriesFilteredByDocumentIDMustUseStringsOrDocumentReferences() {
                 .whereGreaterThanOrEqualTo(FieldPath.documentId(), "foo"),
         reason);
 
-    reason =
-        "Invalid query. You can't perform array-contains queries on FieldPath.documentId() since "
-            + "document IDs are not arrays.";
+    reason = "Invalid query. You can't perform 'array_contains' queries on FieldPath.documentId().";
     expectError(() -> collection.whereArrayContains(FieldPath.documentId(), 1), reason);
+
+    reason =
+        "Invalid query. You can't perform 'array_contains_any' queries on FieldPath.documentId().";
+    expectError(
+        () -> collection.whereArrayContainsAny(FieldPath.documentId(), asList(1, 2)), reason);
+  }
+
+  @Test
+  public void queriesUsingInAndDocumentIdMustHaveProperDocumentReferencesInArray() {
+    CollectionReference collection = testCollection();
+    collection.whereIn(FieldPath.documentId(), asList(collection.getPath()));
+
+    String reason =
+        "Invalid query. When querying with FieldPath.documentId() you must provide "
+            + "a valid document ID, but it was an empty string.";
+    expectError(() -> collection.whereIn(FieldPath.documentId(), asList("")), reason);
+
+    reason =
+        "Invalid query. When querying a collection by FieldPath.documentId() you must provide "
+            + "a plain document ID, but 'foo/bar/baz' contains a '/' character.";
+    expectError(() -> collection.whereIn(FieldPath.documentId(), asList("foo/bar/baz")), reason);
+
+    reason =
+        "Invalid query. When querying with FieldPath.documentId() you must provide "
+            + "a valid String or DocumentReference, but it was of type: java.lang.Integer";
+    expectError(() -> collection.whereIn(FieldPath.documentId(), asList(1, 2)), reason);
+
+    reason =
+        "Invalid query. When querying a collection group by FieldPath.documentId(), the value "
+            + "provided must result in a valid document path, but 'foo' is not because it has "
+            + "an odd number of segments (1).";
+    expectError(
+        () ->
+            testFirestore()
+                .collectionGroup("collection")
+                .whereIn(FieldPath.documentId(), asList("foo")),
+        reason);
   }
 
   // Helpers
 
+  /** Performs a write using each write API and makes sure it succeeds. */
+  private static void expectWriteSuccess(Object data) {
+    expectWriteSuccess(data, /*includeSets=*/ true, /*includeUpdates=*/ true);
+  }
+
+  /** Performs a write using each update API and makes sure it succeeds. */
+  private static void expectUpdateSuccess(Map<String, Object> data) {
+    expectWriteSuccess(data, /*includeSets=*/ false, /*includeUpdates=*/ true);
+  }
+
+  /** Performs a write using each set API and makes sure it succeeds. */
+  private static void expectSetSuccess(Object data) {
+    expectWriteSuccess(data, /*includeSets=*/ true, /*includeUpdates=*/ false);
+  }
+
+  /**
+   * Performs a write using each set and/or update API and makes sure it fails with the expected
+   * reason.
+   */
+  private static void expectWriteSuccess(Object data, boolean includeSets, boolean includeUpdates) {
+    DocumentReference ref = testDocument();
+
+    if (includeSets) {
+      assertDoesNotThrow(() -> ref.set(data));
+      assertDoesNotThrow(() -> ref.getFirestore().batch().set(ref, data));
+    }
+
+    if (includeUpdates) {
+      assertTrue("update() only support Maps.", data instanceof Map);
+      assertDoesNotThrow(
+          () -> {
+            @SuppressWarnings("unchecked")
+            Map<String, Object> updateMap = (Map<String, Object>) data;
+            ref.update(updateMap);
+          });
+      assertDoesNotThrow(
+          () -> {
+            @SuppressWarnings("unchecked")
+            Map<String, Object> updateMap = (Map<String, Object>) data;
+            ref.getFirestore().batch().update(ref, updateMap);
+          });
+    }
+
+    waitFor(
+        ref.getFirestore()
+            .runTransaction(
+                (Function<Void>)
+                    transaction -> {
+                      if (includeSets) {
+                        assertDoesNotThrow(() -> transaction.set(ref, data));
+                      }
+                      if (includeUpdates) {
+                        assertTrue("update() only support Maps.", data instanceof Map);
+                        assertDoesNotThrow(
+                            () -> {
+                              @SuppressWarnings("unchecked")
+                              Map<String, Object> updateMap = (Map<String, Object>) data;
+                              transaction.update(ref, updateMap);
+                            });
+                      }
+
+                      return null;
+                    }));
+  }
+
   /** Performs a write using each write API and makes sure it fails with the expected reason. */
   private static void expectWriteError(Object data, String reason) {
     expectWriteError(data, reason, /*includeSets=*/ true, /*includeUpdates=*/ true);
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/WriteBatchTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/WriteBatchTest.java
index 51ecefcf3..2a94e7f54 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/WriteBatchTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/WriteBatchTest.java
@@ -22,12 +22,12 @@
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitForException;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
 import static java.util.Arrays.asList;
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertTrue;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.FirebaseFirestoreException.Code;
 import com.google.firebase.firestore.testutil.EventAccumulator;
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/remote/RemoteStoreTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/remote/RemoteStoreTest.java
index 6cad0e582..da03bc225 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/remote/RemoteStoreTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/remote/RemoteStoreTest.java
@@ -16,14 +16,15 @@
 
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitFor;
 
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.firebase.database.collection.ImmutableSortedSet;
 import com.google.firebase.firestore.auth.User;
 import com.google.firebase.firestore.core.OnlineState;
 import com.google.firebase.firestore.local.LocalStore;
 import com.google.firebase.firestore.local.MemoryPersistence;
 import com.google.firebase.firestore.local.Persistence;
+import com.google.firebase.firestore.local.SimpleQueryEngine;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.mutation.MutationBatchResult;
 import com.google.firebase.firestore.testutil.IntegrationTestUtil;
@@ -44,31 +45,38 @@ public void testRemoteStoreStreamStopsWhenNetworkUnreachable() {
             IntegrationTestUtil.testEnvDatabaseInfo(),
             testQueue,
             null,
-            InstrumentationRegistry.getContext());
+            ApplicationProvider.getApplicationContext());
     Semaphore networkChangeSemaphore = new Semaphore(0);
     RemoteStore.RemoteStoreCallback callback =
         new RemoteStore.RemoteStoreCallback() {
+          @Override
           public void handleRemoteEvent(RemoteEvent remoteEvent) {}
 
+          @Override
           public void handleRejectedListen(int targetId, Status error) {}
 
+          @Override
           public void handleSuccessfulWrite(MutationBatchResult successfulWrite) {}
 
+          @Override
           public void handleRejectedWrite(int batchId, Status error) {}
 
+          @Override
           public void handleOnlineStateChange(OnlineState onlineState) {
             networkChangeSemaphore.release();
           }
 
+          @Override
           public ImmutableSortedSet<DocumentKey> getRemoteKeysForTarget(int targetId) {
             return null;
           }
         };
 
     FakeConnectivityMonitor connectivityMonitor = new FakeConnectivityMonitor();
+    SimpleQueryEngine queryEngine = new SimpleQueryEngine();
     Persistence persistence = MemoryPersistence.createEagerGcMemoryPersistence();
     persistence.start();
-    LocalStore localStore = new LocalStore(persistence, User.UNAUTHENTICATED);
+    LocalStore localStore = new LocalStore(persistence, queryEngine, User.UNAUTHENTICATED);
     RemoteStore remoteStore =
         new RemoteStore(callback, localStore, datastore, testQueue, connectivityMonitor);
 
@@ -90,7 +98,7 @@ private void drain(AsyncQueue testQueue) {
     waitFor(testQueue.enqueue(() -> {}));
   }
 
-  class FakeConnectivityMonitor implements ConnectivityMonitor {
+  static class FakeConnectivityMonitor implements ConnectivityMonitor {
     private Consumer<NetworkStatus> callback = null;
 
     @Override
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/remote/StreamTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/remote/StreamTest.java
index f7dd90476..6712b54ab 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/remote/StreamTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/remote/StreamTest.java
@@ -22,8 +22,8 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.gms.tasks.Task;
 import com.google.firebase.firestore.auth.EmptyCredentialsProvider;
 import com.google.firebase.firestore.model.SnapshotVersion;
@@ -109,7 +109,7 @@ private WriteStream createAndOpenWriteStream(
             IntegrationTestUtil.testEnvDatabaseInfo(),
             testQueue,
             new EmptyCredentialsProvider(),
-            InstrumentationRegistry.getContext());
+            ApplicationProvider.getApplicationContext());
     final WriteStream writeStream = datastore.createWriteStream(callback);
     waitForWriteStreamOpen(testQueue, writeStream, callback);
     return writeStream;
@@ -132,7 +132,7 @@ public void testWatchStreamStopBeforeHandshake() throws Exception {
             IntegrationTestUtil.testEnvDatabaseInfo(),
             testQueue,
             new EmptyCredentialsProvider(),
-            InstrumentationRegistry.getContext());
+            ApplicationProvider.getApplicationContext());
     StreamStatusCallback streamCallback = new StreamStatusCallback() {};
     final WatchStream watchStream = datastore.createWatchStream(streamCallback);
 
@@ -152,7 +152,7 @@ public void testWriteStreamStopAfterHandshake() throws Exception {
             IntegrationTestUtil.testEnvDatabaseInfo(),
             testQueue,
             new EmptyCredentialsProvider(),
-            InstrumentationRegistry.getContext());
+            ApplicationProvider.getApplicationContext());
     final WriteStream[] writeStreamWrapper = new WriteStream[1];
     StreamStatusCallback streamCallback =
         new StreamStatusCallback() {
@@ -198,7 +198,7 @@ public void testWriteStreamStopPartial() throws Exception {
             IntegrationTestUtil.testEnvDatabaseInfo(),
             testQueue,
             new EmptyCredentialsProvider(),
-            InstrumentationRegistry.getContext());
+            ApplicationProvider.getApplicationContext());
     StreamStatusCallback streamCallback = new StreamStatusCallback() {};
     final WriteStream writeStream = datastore.createWriteStream(streamCallback);
 
@@ -277,7 +277,7 @@ public void testStreamRefreshesTokenUponExpiration() throws Exception {
             IntegrationTestUtil.testEnvDatabaseInfo(),
             testQueue,
             mockCredentialsProvider,
-            InstrumentationRegistry.getContext());
+            ApplicationProvider.getApplicationContext());
     StreamStatusCallback callback = new StreamStatusCallback();
     WriteStream writeStream = datastore.createWriteStream(callback);
     waitForWriteStreamOpen(testQueue, writeStream, callback);
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/testutil/IntegrationTestUtil.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/testutil/IntegrationTestUtil.java
index ef6b3be42..4df5e7239 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/testutil/IntegrationTestUtil.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/testutil/IntegrationTestUtil.java
@@ -16,16 +16,18 @@
 
 import static com.google.firebase.firestore.testutil.TestUtil.map;
 import static com.google.firebase.firestore.util.Util.autoId;
-import static junit.framework.Assert.assertNull;
+import static org.junit.Assert.assertNull;
 
 import android.content.Context;
-import android.net.SSLCertificateSocketFactory;
 import android.os.StrictMode;
-import android.support.test.InstrumentationRegistry;
+import androidx.test.core.app.ApplicationProvider;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.android.gms.tasks.Tasks;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.FirebaseOptions;
 import com.google.firebase.firestore.AccessHelper;
+import com.google.firebase.firestore.BuildConfig;
 import com.google.firebase.firestore.CollectionReference;
 import com.google.firebase.firestore.DocumentReference;
 import com.google.firebase.firestore.DocumentSnapshot;
@@ -35,15 +37,15 @@
 import com.google.firebase.firestore.MetadataChanges;
 import com.google.firebase.firestore.QuerySnapshot;
 import com.google.firebase.firestore.auth.EmptyCredentialsProvider;
+import com.google.firebase.firestore.auth.User;
 import com.google.firebase.firestore.core.DatabaseInfo;
 import com.google.firebase.firestore.local.Persistence;
 import com.google.firebase.firestore.model.DatabaseId;
-import com.google.firebase.firestore.remote.GrpcCallProvider;
 import com.google.firebase.firestore.testutil.provider.FirestoreProvider;
 import com.google.firebase.firestore.util.AsyncQueue;
+import com.google.firebase.firestore.util.Listener;
 import com.google.firebase.firestore.util.Logger;
 import com.google.firebase.firestore.util.Logger.Level;
-import io.grpc.okhttp.OkHttpChannelBuilder;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -54,15 +56,40 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
+class MockCredentialsProvider extends EmptyCredentialsProvider {
+
+  private static MockCredentialsProvider instance;
+  private Listener<User> listener;
+
+  public static MockCredentialsProvider instance() {
+    if (MockCredentialsProvider.instance == null) {
+      MockCredentialsProvider.instance = new MockCredentialsProvider();
+    }
+    return MockCredentialsProvider.instance;
+  }
+
+  private MockCredentialsProvider() {}
+
+  @Override
+  public void setChangeListener(Listener<User> changeListener) {
+    super.setChangeListener(changeListener);
+    this.listener = changeListener;
+  }
+
+  public void changeUserTo(User user) {
+    listener.onValue(user);
+  }
+}
+
 /** A set of helper methods for tests */
 public class IntegrationTestUtil {
 
   // Whether the integration tests should run against a local Firestore emulator instead of the
   // Production environment. Note that the Android Emulator treats "10.0.2.2" as its host machine.
   // TODO(mrschmidt): Support multiple envrionments (Emulator, QA, Nightly, Production)
-  private static final boolean CONNECT_TO_EMULATOR = false;
+  private static final boolean CONNECT_TO_EMULATOR = BuildConfig.USE_EMULATOR_FOR_TESTS;
   private static final String EMULATOR_HOST = "10.0.2.2";
-  private static final int EMULATOR_PORT = 8081;
+  private static final int EMULATOR_PORT = 8080;
 
   // Alternate project ID for creating "bad" references. Doesn't actually need to work.
   public static final String BAD_PROJECT_ID = "test-project-2";
@@ -84,6 +111,13 @@
   private static boolean strictModeEnabled = false;
   private static boolean backendPrimed = false;
 
+  // FirebaseOptions needed to create a test FirebaseApp.
+  private static final FirebaseOptions OPTIONS =
+      new FirebaseOptions.Builder()
+          .setApplicationId(":123:android:123ab")
+          .setProjectId(provider.projectId())
+          .build();
+
   public static FirestoreProvider provider() {
     return provider;
   }
@@ -94,7 +128,7 @@ public static DatabaseInfo testEnvDatabaseInfo() {
           DatabaseId.forProject(provider.projectId()),
           "test-persistenceKey",
           String.format("%s:%d", EMULATOR_HOST, EMULATOR_PORT),
-          /*sslEnabled=*/ true);
+          /*sslEnabled=*/ false);
     } else {
       return new DatabaseInfo(
           DatabaseId.forProject(provider.projectId()),
@@ -115,25 +149,7 @@ public static FirebaseFirestoreSettings newTestSettingsWithSnapshotTimestampsEna
 
     if (CONNECT_TO_EMULATOR) {
       settings.setHost(String.format("%s:%d", EMULATOR_HOST, EMULATOR_PORT));
-
-      // The `sslEnabled` flag in DatabaseInfo currently does not in fact disable all SSL checks.
-      // Instead, we manually disable the SSL certificate check and the hostname verification for
-      // connections to the emulator.
-      // TODO(mrschmidt): Update the client to respect the `sslEnabled` flag and remove these
-      // channel overrides.
-      OkHttpChannelBuilder channelBuilder =
-          new OkHttpChannelBuilder(EMULATOR_HOST, EMULATOR_PORT) {
-            @Override
-            protected String checkAuthority(String authority) {
-              return authority;
-            }
-          };
-      channelBuilder.hostnameVerifier((hostname, session) -> true);
-      SSLCertificateSocketFactory insecureFactory =
-          (SSLCertificateSocketFactory) SSLCertificateSocketFactory.getInsecure(0, null);
-      channelBuilder.sslSocketFactory(insecureFactory);
-
-      GrpcCallProvider.overrideChannelBuilder(() -> channelBuilder);
+      settings.setSslEnabled(false);
     } else {
       settings.setHost(provider.firestoreHost());
     }
@@ -144,6 +160,14 @@ protected String checkAuthority(String authority) {
     return settings.build();
   }
 
+  public static FirebaseApp testFirebaseApp() {
+    try {
+      return FirebaseApp.getInstance(FirebaseApp.DEFAULT_APP_NAME);
+    } catch (IllegalStateException e) {
+      return FirebaseApp.initializeApp(ApplicationProvider.getApplicationContext(), OPTIONS);
+    }
+  }
+
   /** Initializes a new Firestore instance that uses the default project. */
   public static FirebaseFirestore testFirestore() {
     return testFirestore(newTestSettings());
@@ -242,23 +266,22 @@ public static FirebaseFirestore testFirestore(
     // TODO: Remove this once this is ready to ship.
     Persistence.INDEXING_SUPPORT_ENABLED = true;
 
-    Context context = InstrumentationRegistry.getContext();
+    Context context = ApplicationProvider.getApplicationContext();
     DatabaseId databaseId = DatabaseId.forDatabase(projectId, DatabaseId.DEFAULT_DATABASE_ID);
 
     ensureStrictMode();
 
-    AsyncQueue asyncQueue = null;
-
-    asyncQueue = new AsyncQueue();
+    AsyncQueue asyncQueue = new AsyncQueue();
 
     FirebaseFirestore firestore =
         AccessHelper.newFirebaseFirestore(
             context,
             databaseId,
             persistenceKey,
-            new EmptyCredentialsProvider(),
+            MockCredentialsProvider.instance(),
             asyncQueue,
-            /*firebaseApp=*/ null);
+            /*firebaseApp=*/ null,
+            /*instanceRegistry=*/ (dbId) -> {});
     waitFor(AccessHelper.clearPersistence(firestore));
     firestore.setFirestoreSettings(settings);
     firestoreStatus.put(firestore, true);
@@ -269,7 +292,7 @@ public static FirebaseFirestore testFirestore(
   public static void tearDown() {
     try {
       for (FirebaseFirestore firestore : firestoreStatus.keySet()) {
-        Task<Void> result = AccessHelper.shutdown(firestore);
+        Task<Void> result = firestore.terminate();
         waitFor(result);
       }
     } finally {
@@ -421,4 +444,12 @@ public static void removeFirestore(FirebaseFirestore firestore) {
     }
     return result;
   }
+
+  public static boolean isRunningAgainstEmulator() {
+    return CONNECT_TO_EMULATOR;
+  }
+
+  public static void testChangeUserTo(User user) {
+    MockCredentialsProvider.instance().changeUserTo(user);
+  }
 }
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/testutil/prod_provider/FirestoreProvider.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/testutil/prod_provider/FirestoreProvider.java
index 36f26418d..a34bfefe8 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/testutil/prod_provider/FirestoreProvider.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/testutil/prod_provider/FirestoreProvider.java
@@ -15,7 +15,7 @@
 package com.google.firebase.firestore.testutil.provider;
 
 import android.content.Context;
-import android.support.test.InstrumentationRegistry;
+import androidx.test.core.app.ApplicationProvider;
 import com.google.firebase.firestore.R;
 
 /**
@@ -28,7 +28,7 @@
   private final Context context;
 
   public FirestoreProvider() {
-    this(InstrumentationRegistry.getContext());
+    this(ApplicationProvider.getApplicationContext());
   }
 
   public FirestoreProvider(Context context) {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/Timestamp.java b/firebase-firestore/src/main/java/com/google/firebase/Timestamp.java
index 74770bdad..d7074a883 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/Timestamp.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/Timestamp.java
@@ -18,8 +18,7 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.support.annotation.NonNull;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
 import java.util.Date;
 
 /**
@@ -35,10 +34,9 @@
  *     https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto">The
  *     reference timestamp definition</a>
  */
-@PublicApi
 public final class Timestamp implements Comparable<Timestamp>, Parcelable {
 
-  @PublicApi @NonNull
+  @NonNull
   public static final Parcelable.Creator<Timestamp> CREATOR =
       new Parcelable.Creator<Timestamp>() {
         @Override
@@ -61,21 +59,19 @@ public Timestamp createFromParcel(Parcel source) {
    *     Negative second values with fractions must still have non-negative nanoseconds values that
    *     count forward in time. Must be from 0 to 999,999,999 inclusive.
    */
-  @PublicApi
   public Timestamp(long seconds, int nanoseconds) {
     validateRange(seconds, nanoseconds);
     this.seconds = seconds;
     this.nanoseconds = nanoseconds;
   }
 
-  protected Timestamp(Parcel in) {
+  protected Timestamp(@NonNull Parcel in) {
     this.seconds = in.readLong();
     this.nanoseconds = in.readInt();
   }
 
   /** Creates a new timestamp from the given date. */
-  @PublicApi
-  public Timestamp(Date date) {
+  public Timestamp(@NonNull Date date) {
     long millis = date.getTime();
     long seconds = millis / 1000;
     int nanoseconds = (int) (millis % 1000) * 1000000;
@@ -89,26 +85,22 @@ public Timestamp(Date date) {
   }
 
   /** Creates a new timestamp with the current date, with millisecond precision. */
-  @PublicApi
   @NonNull
   public static Timestamp now() {
     return new Timestamp(new Date());
   }
 
   /** Returns the seconds part of the timestamp. */
-  @PublicApi
   public long getSeconds() {
     return seconds;
   }
 
   /** Returns the sub-second part of the timestamp, in nanoseconds. */
-  @PublicApi
   public int getNanoseconds() {
     return nanoseconds;
   }
 
   /** Returns a new Date corresponding to this timestamp. This may lose precision. */
-  @PublicApi
   @NonNull
   public Date toDate() {
     return new Date(seconds * 1000 + (nanoseconds / 1000000));
@@ -120,14 +112,13 @@ public int describeContents() {
   }
 
   @Override
-  public void writeToParcel(Parcel dest, int flags) {
+  public void writeToParcel(@NonNull Parcel dest, int flags) {
     dest.writeLong(this.seconds);
     dest.writeInt(this.nanoseconds);
   }
 
   @Override
-  @PublicApi
-  public int compareTo(Timestamp other) {
+  public int compareTo(@NonNull Timestamp other) {
     if (seconds == other.seconds) {
       return Integer.signum(nanoseconds - other.nanoseconds);
     }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/Blob.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/Blob.java
index 3de2959ea..55a561dee 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/Blob.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/Blob.java
@@ -16,15 +16,13 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.RestrictTo;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RestrictTo;
 import com.google.firebase.firestore.util.Util;
 import com.google.protobuf.ByteString;
 
-/** Immutable class representing an array of bytes in Firestore. */
-@PublicApi
+/** Immutable class representing an array of bytes in Cloud Firestore. */
 public class Blob implements Comparable<Blob> {
   private final ByteString bytes;
 
@@ -33,13 +31,13 @@ private Blob(ByteString bytes) {
   }
 
   /**
-   * Creates a new Blob instance from the provided bytes. Will make a copy of the bytes passed in.
+   * Creates a new {@code Blob} instance from the provided bytes. Will make a copy of the bytes
+   * passed in.
    *
-   * @param bytes The bytes to use for this Blob instance.
-   * @return The new Blob instance
+   * @param bytes The bytes to use for this {@code Blob} instance.
+   * @return The new {@code Blob} instance
    */
   @NonNull
-  @PublicApi
   public static Blob fromBytes(@NonNull byte[] bytes) {
     checkNotNull(bytes, "Provided bytes array must not be null.");
     return new Blob(ByteString.copyFrom(bytes));
@@ -55,7 +53,6 @@ public static Blob fromByteString(@NonNull ByteString bytes) {
 
   /** @return The bytes of this blob as a new byte[] array. */
   @NonNull
-  @PublicApi
   public byte[] toBytes() {
     return bytes.toByteArray();
   }
@@ -84,7 +81,6 @@ public int hashCode() {
   }
 
   @Override
-  @PublicApi
   public int compareTo(@NonNull Blob other) {
     int size = Math.min(bytes.size(), other.bytes.size());
     for (int i = 0; i < size; i++) {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/CollectionReference.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/CollectionReference.java
index c8364f7a7..b4ec9ee9a 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/CollectionReference.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/CollectionReference.java
@@ -16,24 +16,22 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.tasks.Task;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.ResourcePath;
 import com.google.firebase.firestore.util.Executors;
 import com.google.firebase.firestore.util.Util;
-import javax.annotation.Nullable;
 
 /**
- * A CollectionReference can be used for adding documents, getting document references, and querying
- * for documents (using the methods inherited from Query).
+ * A {@code CollectionReference} can be used for adding documents, getting document references, and
+ * querying for documents (using the methods inherited from {@code Query}).
  *
- * <p><b>Subclassing Note</b>: Firestore classes are not meant to be subclassed except for use in
- * test mocks. Subclassing is not supported in production code and new SDK releases may break code
- * that does so.
+ * <p><b>Subclassing Note</b>: Cloud Firestore classes are not meant to be subclassed except for use
+ * in test mocks. Subclassing is not supported in production code and new SDK releases may break
+ * code that does so.
  */
-@PublicApi
 public class CollectionReference extends Query {
 
   CollectionReference(ResourcePath path, FirebaseFirestore firestore) {
@@ -50,20 +48,18 @@
 
   /** @return The ID of the collection. */
   @NonNull
-  @PublicApi
   public String getId() {
     return query.getPath().getLastSegment();
   }
 
   /**
-   * Gets a DocumentReference to the document that contains this collection. Only subcollections are
-   * contained in a document. For root collections, returns null.
+   * Gets a {@code DocumentReference} to the document that contains this collection. Only
+   * subcollections are contained in a document. For root collections, returns {@code null}.
    *
-   * @return The DocumentReference that contains this collection or null if this is a root
-   *     collection.
+   * @return The {@code DocumentReference} that contains this collection or {@code null} if this is
+   *     a root collection.
    */
   @Nullable
-  @PublicApi
   public DocumentReference getParent() {
     ResourcePath parentPath = query.getPath().popLast();
     if (parentPath.isEmpty()) {
@@ -80,32 +76,29 @@ public DocumentReference getParent() {
    * @return The path of this collection.
    */
   @NonNull
-  @PublicApi
   public String getPath() {
     return query.getPath().canonicalString();
   }
 
   /**
-   * Returns a DocumentReference pointing to a new document with an auto-generated ID within this
-   * collection.
+   * Returns a {@code DocumentReference} pointing to a new document with an auto-generated ID within
+   * this collection.
    *
-   * @return A DocumentReference pointing to a new document with an auto-generated ID.
+   * @return A {@code DocumentReference} pointing to a new document with an auto-generated ID.
    */
   @NonNull
-  @PublicApi
   public DocumentReference document() {
     return document(Util.autoId());
   }
 
   /**
-   * Gets a DocumentReference instance that refers to the document at the specified path within this
-   * collection.
+   * Gets a {@code DocumentReference} instance that refers to the document at the specified path
+   * within this collection.
    *
    * @param documentPath A slash-separated relative path to a document.
-   * @return The DocumentReference instance.
+   * @return The {@code DocumentReference} instance.
    */
   @NonNull
-  @PublicApi
   public DocumentReference document(@NonNull String documentPath) {
     checkNotNull(documentPath, "Provided document path must not be null.");
     return DocumentReference.forPath(
@@ -118,10 +111,10 @@ public DocumentReference document(@NonNull String documentPath) {
    *
    * @param data The data to write to the document (e.g. a Map or a POJO containing the desired
    *     document contents).
-   * @return A Task that will be resolved with the DocumentReference of the newly created document.
+   * @return A Task that will be resolved with the {@code DocumentReference} of the newly created
+   *     document.
    */
   @NonNull
-  @PublicApi
   public Task<DocumentReference> add(@NonNull Object data) {
     checkNotNull(data, "Provided data must not be null.");
     final DocumentReference ref = document();
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentChange.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentChange.java
index f439dbea9..35480a629 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentChange.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentChange.java
@@ -16,29 +16,26 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.VisibleForTesting;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.google.firebase.firestore.core.DocumentViewChange;
 import com.google.firebase.firestore.core.ViewSnapshot;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentSet;
 import java.util.ArrayList;
 import java.util.List;
-import javax.annotation.Nullable;
 
 /**
- * A DocumentChange represents a change to the documents matching a query. It contains the document
- * affected and a the type of change that occurred (added, modified, or removed).
+ * A {@code DocumentChange} represents a change to the documents matching a query. It contains the
+ * document affected and a the type of change that occurred (added, modified, or removed).
  *
- * <p><b>Subclassing Note</b>: Firestore classes are not meant to be subclassed except for use in
- * test mocks. Subclassing is not supported in production code and new SDK releases may break code
- * that does so.
+ * <p><b>Subclassing Note</b>: Cloud Firestore classes are not meant to be subclassed except for use
+ * in test mocks. Subclassing is not supported in production code and new SDK releases may break
+ * code that does so.
  */
-@PublicApi
 public class DocumentChange {
   /** An enumeration of snapshot diff types. */
-  @PublicApi
   public enum Type {
     /** Indicates a new document was added to the set of documents matching the query. */
     ADDED,
@@ -91,45 +88,42 @@ public int hashCode() {
   }
 
   @NonNull
-  @PublicApi
   public Type getType() {
     return type;
   }
 
   /**
-   * Returns the newly added or modified document if this DocumentChange is for an updated document.
-   * Returns the deleted document if this document change represents a removal.
+   * Returns the newly added or modified document if this {@code DocumentChange} is for an updated
+   * document. Returns the deleted document if this document change represents a removal.
    *
-   * @return A snapshot of the new data (for Type.ADDED or Type.MODIFIED) or the removed data (for
-   *     Type.REMOVED).
+   * @return A snapshot of the new data (for {@link DocumentChange.Type#ADDED} or {@link
+   *     DocumentChange.Type#MODIFIED}) or the removed data (for {@link
+   *     DocumentChange.Type.REMOVED}).
    */
   @NonNull
-  @PublicApi
   public QueryDocumentSnapshot getDocument() {
     return document;
   }
 
   /**
-   * The index of the changed document in the result set immediately prior to this DocumentChange
-   * (i.e. supposing that all prior DocumentChange objects have been applied). Returns -1 for
-   * 'added' events.
+   * The index of the changed document in the result set immediately prior to this {@code
+   * DocumentChange} (assuming that all prior {@code DocumentChange} objects have been applied).
+   * Returns -1 for 'added' events.
    */
-  @PublicApi
   public int getOldIndex() {
     return oldIndex;
   }
 
   /**
-   * The index of the changed document in the result set immediately after this DocumentChange (i.e.
-   * supposing that all prior DocumentChange objects and the current DocumentChange object have been
-   * applied). Returns -1 for 'removed' events.
+   * The index of the changed document in the result set immediately after this {@code
+   * DocumentChange} (assuming that all prior {@code DocumentChange} objects and the current {@code
+   * DocumentChange} object have been applied). Returns -1 for 'removed' events.
    */
-  @PublicApi
   public int getNewIndex() {
     return newIndex;
   }
 
-  /** Creates the list of DocumentChanges from a ViewSnapshot. */
+  /** Creates the list of document changes from a {@code ViewSnapshot}. */
   static List<DocumentChange> changesFromSnapshot(
       FirebaseFirestore firestore, MetadataChanges metadataChanges, ViewSnapshot snapshot) {
     List<DocumentChange> documentChanges = new ArrayList<>();
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentId.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentId.java
new file mode 100644
index 000000000..a6cc384c2
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentId.java
@@ -0,0 +1,47 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Annotation used to mark a POJO property to be automatically populated with the document's ID when
+ * the POJO is created from a Cloud Firestore document (for example, via {@link
+ * DocumentSnapshot#toObject}).
+ *
+ * <ul>
+ *   Any of the following will throw a runtime exception:
+ *   <li>This annotation is applied to a property of a type other than String or {@link
+ *       DocumentReference}.
+ *   <li>This annotation is applied to a property that is not writable (for example, a Java Bean
+ *       getter without a backing field).
+ *   <li>This annotation is applied to a property with a name that conflicts with a read document
+ *       field. For example, if a POJO has a field `firstName` annotated by {@code @DocumentId}, and
+ *       there is a property from the document named `firstName` as well, an exception is thrown
+ *       when you try to read the document into the POJO via {@link DocumentSnapshot#toObject} or
+ *       {@link DocumentReference#get}.
+ *   <li>
+ * </ul>
+ *
+ * <p>When using a POJO to write to a document (via {@link DocumentReference#set} or @{@link
+ * WriteBatch#set}), the property annotated by {@code @DocumentId} is ignored, which allows writing
+ * the POJO back to any document, even if it's not the origin of the POJO.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.FIELD, ElementType.METHOD})
+public @interface DocumentId {}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentReference.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentReference.java
index 1d54149a6..a43f1159e 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentReference.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentReference.java
@@ -20,11 +20,11 @@
 import static java.util.Collections.singletonList;
 
 import android.app.Activity;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.android.gms.tasks.Tasks;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.firestore.FirebaseFirestoreException.Code;
 import com.google.firebase.firestore.core.ActivityScope;
 import com.google.firebase.firestore.core.AsyncEventListener;
@@ -45,19 +45,17 @@
 import java.util.Map;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
-import javax.annotation.Nullable;
 
 /**
- * A DocumentReference refers to a document location in a Firestore database and can be used to
- * write, read, or listen to the location. There may or may not exist a document at the referenced
- * location. A DocumentReference can also be used to create a CollectionReference to a
- * subcollection.
+ * A {@code DocumentReference} refers to a document location in a Cloud Firestore database and can
+ * be used to write, read, or listen to the location. There may or may not exist a document at the
+ * referenced location. A {@code DocumentReference} can also be used to create a {@link
+ * CollectionReference} to a subcollection.
  *
- * <p><b>Subclassing Note</b>: Firestore classes are not meant to be subclassed except for use in
- * test mocks. Subclassing is not supported in production code and new SDK releases may break code
- * that does so.
+ * <p><b>Subclassing Note</b>: Cloud Firestore classes are not meant to be subclassed except for use
+ * in test mocks. Subclassing is not supported in production code and new SDK releases may break
+ * code that does so.
  */
-@PublicApi
 public class DocumentReference {
 
   private final DocumentKey key;
@@ -89,26 +87,23 @@ DocumentKey getKey() {
     return key;
   }
 
-  /** Gets the Firestore instance associated with this document reference. */
+  /** Gets the Cloud Firestore instance associated with this document reference. */
   @NonNull
-  @PublicApi
   public FirebaseFirestore getFirestore() {
     return firestore;
   }
 
   @NonNull
-  @PublicApi
   public String getId() {
     return key.getPath().getLastSegment();
   }
 
   /**
-   * Gets a CollectionReference to the collection that contains this document.
+   * Gets a {@code CollectionReference} to the collection that contains this document.
    *
-   * @return The CollectionReference that contains this document.
+   * @return The {@code CollectionReference} that contains this document.
    */
   @NonNull
-  @PublicApi
   public CollectionReference getParent() {
     return new CollectionReference(key.getPath().popLast(), firestore);
   }
@@ -120,20 +115,18 @@ public CollectionReference getParent() {
    * @return The path of this document.
    */
   @NonNull
-  @PublicApi
   public String getPath() {
     return key.getPath().canonicalString();
   }
 
   /**
-   * Gets a CollectionReference instance that refers to the subcollection at the specified path
-   * relative to this document.
+   * Gets a {@code CollectionReference} instance that refers to the subcollection at the specified
+   * path relative to this document.
    *
    * @param collectionPath A slash-separated relative path to a subcollection.
-   * @return The CollectionReference instance.
+   * @return The {@code CollectionReference} instance.
    */
   @NonNull
-  @PublicApi
   public CollectionReference collection(@NonNull String collectionPath) {
     checkNotNull(collectionPath, "Provided collection path must not be null.");
     return new CollectionReference(
@@ -141,23 +134,22 @@ public CollectionReference collection(@NonNull String collectionPath) {
   }
 
   /**
-   * Overwrites the document referred to by this DocumentReference. If the document does not yet
-   * exist, it will be created. If a document already exists, it will be overwritten.
+   * Overwrites the document referred to by this {@code DocumentReference}. If the document does not
+   * yet exist, it will be created. If a document already exists, it will be overwritten.
    *
    * @param data The data to write to the document (e.g. a Map or a POJO containing the desired
    *     document contents).
    * @return A Task that will be resolved when the write finishes.
    */
   @NonNull
-  @PublicApi
   public Task<Void> set(@NonNull Object data) {
     return set(data, SetOptions.OVERWRITE);
   }
 
   /**
-   * Writes to the document referred to by this DocumentReference. If the document does not yet
-   * exist, it will be created. If you pass {@link SetOptions}, the provided data can be merged into
-   * an existing document.
+   * Writes to the document referred to by this {@code DocumentReference}. If the document does not
+   * yet exist, it will be created. If you pass {@code SetOptions}, the provided data can be merged
+   * into an existing document.
    *
    * @param data The data to write to the document (e.g. a Map or a POJO containing the desired
    *     document contents).
@@ -165,7 +157,6 @@ public CollectionReference collection(@NonNull String collectionPath) {
    * @return A Task that will be resolved when the write finishes.
    */
   @NonNull
-  @PublicApi
   public Task<Void> set(@NonNull Object data, @NonNull SetOptions options) {
     checkNotNull(data, "Provided data must not be null.");
     checkNotNull(options, "Provided options must not be null.");
@@ -180,23 +171,22 @@ public CollectionReference collection(@NonNull String collectionPath) {
   }
 
   /**
-   * Updates fields in the document referred to by this DocumentReference. If no document exists
-   * yet, the update will fail.
+   * Updates fields in the document referred to by this {@code DocumentReference}. If no document
+   * exists yet, the update will fail.
    *
    * @param data A map of field / value pairs to update. Fields can contain dots to reference nested
    *     fields within the document.
    * @return A Task that will be resolved when the write finishes.
    */
   @NonNull
-  @PublicApi
   public Task<Void> update(@NonNull Map<String, Object> data) {
     ParsedUpdateData parsedData = firestore.getDataConverter().parseUpdateData(data);
     return update(parsedData);
   }
 
   /**
-   * Updates fields in the document referred to by this DocumentReference. If no document exists
-   * yet, the update will fail.
+   * Updates fields in the document referred to by this {@code DocumentReference}. If no document
+   * exists yet, the update will fail.
    *
    * @param field The first field to update. Fields can contain dots to reference a nested field
    *     within the document.
@@ -205,7 +195,6 @@ public CollectionReference collection(@NonNull String collectionPath) {
    * @return A Task that will be resolved when the write finishes.
    */
   @NonNull
-  @PublicApi
   public Task<Void> update(
       @NonNull String field, @Nullable Object value, Object... moreFieldsAndValues) {
     ParsedUpdateData parsedData =
@@ -218,8 +207,8 @@ public CollectionReference collection(@NonNull String collectionPath) {
   }
 
   /**
-   * Updates fields in the document referred to by this DocumentReference. If no document exists
-   * yet, the update will fail.
+   * Updates fields in the document referred to by this {@code DocumentReference}. If no document
+   * exists yet, the update will fail.
    *
    * @param fieldPath The first field to update.
    * @param value The first value
@@ -227,7 +216,6 @@ public CollectionReference collection(@NonNull String collectionPath) {
    * @return A Task that will be resolved when the write finishes.
    */
   @NonNull
-  @PublicApi
   public Task<Void> update(
       @NonNull FieldPath fieldPath, @Nullable Object value, Object... moreFieldsAndValues) {
     ParsedUpdateData parsedData =
@@ -247,12 +235,11 @@ public CollectionReference collection(@NonNull String collectionPath) {
   }
 
   /**
-   * Deletes the document referred to by this DocumentReference.
+   * Deletes the document referred to by this {@code DocumentReference}.
    *
    * @return A Task that will be resolved when the delete completes.
    */
   @NonNull
-  @PublicApi
   public Task<Void> delete() {
     return firestore
         .getClient()
@@ -261,30 +248,28 @@ public CollectionReference collection(@NonNull String collectionPath) {
   }
 
   /**
-   * Reads the document referenced by this DocumentReference.
+   * Reads the document referenced by this {@code DocumentReference}.
    *
-   * @return A Task that will be resolved with the contents of the Document at this
-   *     DocumentReference.
+   * @return A Task that will be resolved with the contents of the Document at this {@code
+   *     DocumentReference}.
    */
   @NonNull
-  @PublicApi
   public Task<DocumentSnapshot> get() {
     return get(Source.DEFAULT);
   }
 
   /**
-   * Reads the document referenced by this DocumentReference.
+   * Reads the document referenced by this {@code DocumentReference}.
    *
    * <p>By default, {@code get()} attempts to provide up-to-date data when possible by waiting for
    * data from the server, but it may return cached data or fail if you are offline and the server
-   * cannot be reached. This behavior can be altered via the {@link Source} parameter.
+   * cannot be reached. This behavior can be altered via the {@code Source} parameter.
    *
    * @param source A value to configure the get behavior.
-   * @return A Task that will be resolved with the contents of the Document at this
-   *     DocumentReference.
+   * @return A Task that will be resolved with the contents of the Document at this {@code
+   *     DocumentReference}.
    */
   @NonNull
-  @PublicApi
   public Task<DocumentSnapshot> get(@NonNull Source source) {
     if (source == Source.CACHE) {
       return firestore
@@ -372,35 +357,33 @@ public CollectionReference collection(@NonNull String collectionPath) {
   }
 
   /**
-   * Starts listening to the document referenced by this DocumentReference.
+   * Starts listening to the document referenced by this {@code DocumentReference}.
    *
    * @param listener The event listener that will be called with the snapshots.
    * @return A registration object that can be used to remove the listener.
    */
   @NonNull
-  @PublicApi
   public ListenerRegistration addSnapshotListener(
       @NonNull EventListener<DocumentSnapshot> listener) {
     return addSnapshotListener(MetadataChanges.EXCLUDE, listener);
   }
 
   /**
-   * Starts listening to the document referenced by this DocumentReference.
+   * Starts listening to the document referenced by this {@code DocumentReference}.
    *
    * @param executor The executor to use to call the listener.
    * @param listener The event listener that will be called with the snapshots.
    * @return A registration object that can be used to remove the listener.
    */
   @NonNull
-  @PublicApi
   public ListenerRegistration addSnapshotListener(
       @NonNull Executor executor, @NonNull EventListener<DocumentSnapshot> listener) {
     return addSnapshotListener(executor, MetadataChanges.EXCLUDE, listener);
   }
 
   /**
-   * Starts listening to the document referenced by this DocumentReference using an Activity-scoped
-   * listener.
+   * Starts listening to the document referenced by this {@code DocumentReference} using an
+   * Activity-scoped listener.
    *
    * <p>The listener will be automatically removed during {@link Activity#onStop}.
    *
@@ -409,14 +392,14 @@ public ListenerRegistration addSnapshotListener(
    * @return A registration object that can be used to remove the listener.
    */
   @NonNull
-  @PublicApi
   public ListenerRegistration addSnapshotListener(
       @NonNull Activity activity, @NonNull EventListener<DocumentSnapshot> listener) {
     return addSnapshotListener(activity, MetadataChanges.EXCLUDE, listener);
   }
 
   /**
-   * Starts listening to the document referenced by this DocumentReference with the given options.
+   * Starts listening to the document referenced by this {@code DocumentReference} with the given
+   * options.
    *
    * @param metadataChanges Indicates whether metadata-only changes (i.e. only {@code
    *     DocumentSnapshot.getMetadata()} changed) should trigger snapshot events.
@@ -424,14 +407,14 @@ public ListenerRegistration addSnapshotListener(
    * @return A registration object that can be used to remove the listener.
    */
   @NonNull
-  @PublicApi
   public ListenerRegistration addSnapshotListener(
       @NonNull MetadataChanges metadataChanges, @NonNull EventListener<DocumentSnapshot> listener) {
     return addSnapshotListener(Executors.DEFAULT_CALLBACK_EXECUTOR, metadataChanges, listener);
   }
 
   /**
-   * Starts listening to the document referenced by this DocumentReference with the given options.
+   * Starts listening to the document referenced by this {@code DocumentReference} with the given
+   * options.
    *
    * @param executor The executor to use to call the listener.
    * @param metadataChanges Indicates whether metadata-only changes (i.e. only {@code
@@ -440,7 +423,6 @@ public ListenerRegistration addSnapshotListener(
    * @return A registration object that can be used to remove the listener.
    */
   @NonNull
-  @PublicApi
   public ListenerRegistration addSnapshotListener(
       @NonNull Executor executor,
       @NonNull MetadataChanges metadataChanges,
@@ -452,8 +434,8 @@ public ListenerRegistration addSnapshotListener(
   }
 
   /**
-   * Starts listening to the document referenced by this DocumentReference with the given options
-   * using an Activity-scoped listener.
+   * Starts listening to the document referenced by this {@code DocumentReference} with the given
+   * options using an Activity-scoped listener.
    *
    * <p>The listener will be automatically removed during {@link Activity#onStop}.
    *
@@ -464,7 +446,6 @@ public ListenerRegistration addSnapshotListener(
    * @return A registration object that can be used to remove the listener.
    */
   @NonNull
-  @PublicApi
   public ListenerRegistration addSnapshotListener(
       @NonNull Activity activity,
       @NonNull MetadataChanges metadataChanges,
@@ -479,7 +460,7 @@ public ListenerRegistration addSnapshotListener(
   /**
    * Internal helper method to create add a snapshot listener.
    *
-   * <p>Will be Activity scoped if the activity parameter is non-null.
+   * <p>Will be Activity scoped if the activity parameter is non-{@code null}.
    *
    * @param userExecutor The executor to use to call the listener.
    * @param options The options to use for this listen.
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentSnapshot.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentSnapshot.java
index abb4a7ab8..55efc8f22 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentSnapshot.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentSnapshot.java
@@ -16,17 +16,18 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.Timestamp;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.firestore.model.DatabaseId;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.value.ArrayValue;
 import com.google.firebase.firestore.model.value.FieldValue;
-import com.google.firebase.firestore.model.value.FieldValueOptions;
 import com.google.firebase.firestore.model.value.ObjectValue;
 import com.google.firebase.firestore.model.value.ReferenceValue;
+import com.google.firebase.firestore.model.value.ServerTimestampValue;
+import com.google.firebase.firestore.model.value.TimestampValue;
 import com.google.firebase.firestore.util.CustomClassMapper;
 import com.google.firebase.firestore.util.Logger;
 import java.util.ArrayList;
@@ -34,31 +35,28 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import javax.annotation.Nullable;
 
 /**
- * A DocumentSnapshot contains data read from a document in your Firestore database. The data can be
- * extracted with the getData() or get() methods.
+ * A {@code DocumentSnapshot} contains data read from a document in your Cloud Firestore database.
+ * The data can be extracted with the {@link #getData()} or {@link #get(String)} methods.
  *
- * <p>If the DocumentSnapshot points to a non-existing document, getData() and its corresponding
- * methods will return null. You can always explicitly check for a document's existence by calling
- * exists().
+ * <p>If the {@code DocumentSnapshot} points to a non-existing document, {@link #getData()} and its
+ * corresponding methods will return {@code null}. You can always explicitly check for a document's
+ * existence by calling {@link #exists()}.
  *
- * <p><b>Subclassing Note</b>: Firestore classes are not meant to be subclassed except for use in
- * test mocks. Subclassing is not supported in production code and new SDK releases may break code
- * that does so.
+ * <p><b>Subclassing Note</b>: Cloud Firestore classes are not meant to be subclassed except for use
+ * in test mocks. Subclassing is not supported in production code and new SDK releases may break
+ * code that does so.
  */
-@PublicApi
 public class DocumentSnapshot {
 
   /**
    * Controls the return value for server timestamps that have not yet been set to their final
    * value.
    */
-  @PublicApi
   public enum ServerTimestampBehavior {
     /**
-     * Return 'null' for {@link com.google.firebase.firestore.FieldValue#serverTimestamp
+     * Return {@code null} for {@link com.google.firebase.firestore.FieldValue#serverTimestamp
      * ServerTimestamps} that have not yet been set to their final value.
      */
     NONE,
@@ -80,11 +78,23 @@
     static final ServerTimestampBehavior DEFAULT = ServerTimestampBehavior.NONE;
   }
 
+  /** Holds settings that define field value deserialization options. */
+  static class FieldValueOptions {
+    final ServerTimestampBehavior serverTimestampBehavior;
+    final boolean timestampsInSnapshotsEnabled;
+
+    private FieldValueOptions(
+        ServerTimestampBehavior serverTimestampBehavior, boolean timestampsInSnapshotsEnabled) {
+      this.serverTimestampBehavior = serverTimestampBehavior;
+      this.timestampsInSnapshotsEnabled = timestampsInSnapshotsEnabled;
+    }
+  }
+
   private final FirebaseFirestore firestore;
 
   private final DocumentKey key;
 
-  /** Is null if the document doesn't exist */
+  /** Is {@code null} if the document doesn't exist */
   private final @Nullable Document doc;
 
   private final SnapshotMetadata metadata;
@@ -113,20 +123,17 @@ static DocumentSnapshot fromNoDocument(
 
   /** @return The id of the document. */
   @NonNull
-  @PublicApi
   public String getId() {
     return key.getPath().getLastSegment();
   }
 
   /** @return The metadata for this document snapshot. */
   @NonNull
-  @PublicApi
   public SnapshotMetadata getMetadata() {
     return metadata;
   }
 
   /** @return true if the document existed in this snapshot. */
-  @PublicApi
   public boolean exists() {
     return doc != null;
   }
@@ -137,27 +144,25 @@ Document getDocument() {
   }
 
   /**
-   * Returns the fields of the document as a Map or null if the document doesn't exist. Field values
-   * will be converted to their native Java representation.
+   * Returns the fields of the document as a Map or {@code null} if the document doesn't exist.
+   * Field values will be converted to their native Java representation.
    *
-   * @return The fields of the document as a Map or null if the document doesn't exist.
+   * @return The fields of the document as a Map or {@code null} if the document doesn't exist.
    */
   @Nullable
-  @PublicApi
   public Map<String, Object> getData() {
     return getData(ServerTimestampBehavior.DEFAULT);
   }
 
   /**
-   * Returns the fields of the document as a Map or null if the document doesn't exist. Field values
-   * will be converted to their native Java representation.
+   * Returns the fields of the document as a Map or {@code null} if the document doesn't exist.
+   * Field values will be converted to their native Java representation.
    *
    * @param serverTimestampBehavior Configures the behavior for server timestamps that have not yet
    *     been set to their final value.
-   * @return The fields of the document as a Map or null if the document doesn't exist.
+   * @return The fields of the document as a Map or {@code null} if the document doesn't exist.
    */
   @Nullable
-  @PublicApi
   public Map<String, Object> getData(@NonNull ServerTimestampBehavior serverTimestampBehavior) {
     checkNotNull(
         serverTimestampBehavior, "Provided serverTimestampBehavior value must not be null.");
@@ -165,35 +170,35 @@ Document getDocument() {
         ? null
         : convertObject(
             doc.getData(),
-            FieldValueOptions.create(
+            new FieldValueOptions(
                 serverTimestampBehavior,
                 firestore.getFirestoreSettings().areTimestampsInSnapshotsEnabled()));
   }
 
   /**
-   * Returns the contents of the document converted to a POJO or null if the document doesn't exist.
+   * Returns the contents of the document converted to a POJO or {@code null} if the document
+   * doesn't exist.
    *
    * @param valueType The Java class to create
-   * @return The contents of the document in an object of type T or null if the document doesn't
-   *     exist.
+   * @return The contents of the document in an object of type T or {@code null} if the document
+   *     doesn't exist.
    */
   @Nullable
-  @PublicApi
   public <T> T toObject(@NonNull Class<T> valueType) {
     return toObject(valueType, ServerTimestampBehavior.DEFAULT);
   }
 
   /**
-   * Returns the contents of the document converted to a POJO or null if the document doesn't exist.
+   * Returns the contents of the document converted to a POJO or {@code null} if the document
+   * doesn't exist.
    *
    * @param valueType The Java class to create
    * @param serverTimestampBehavior Configures the behavior for server timestamps that have not yet
    *     been set to their final value.
-   * @return The contents of the document in an object of type T or null if the document doesn't
-   *     exist.
+   * @return The contents of the document in an object of type T or {@code null} if the document
+   *     doesn't exist.
    */
   @Nullable
-  @PublicApi
   public <T> T toObject(
       @NonNull Class<T> valueType, @NonNull ServerTimestampBehavior serverTimestampBehavior) {
     checkNotNull(valueType, "Provided POJO type must not be null.");
@@ -212,7 +217,6 @@ Document getDocument() {
    * @param field the path to the field.
    * @return true iff the field exists.
    */
-  @PublicApi
   public boolean contains(@NonNull String field) {
     return contains(FieldPath.fromDotSeparatedPath(field));
   }
@@ -224,61 +228,56 @@ public boolean contains(@NonNull String field) {
    * @param fieldPath the path to the field.
    * @return true iff the field exists.
    */
-  @PublicApi
   public boolean contains(@NonNull FieldPath fieldPath) {
     checkNotNull(fieldPath, "Provided field path must not be null.");
     return (doc != null) && (doc.getField(fieldPath.getInternalPath()) != null);
   }
 
   /**
-   * Returns the value at the field or null if the field doesn't exist.
+   * Returns the value at the field or {@code null} if the field doesn't exist.
    *
    * @param field The path to the field
-   * @return The value at the given field or null.
+   * @return The value at the given field or {@code null}.
    */
   @Nullable
-  @PublicApi
   public Object get(@NonNull String field) {
     return get(FieldPath.fromDotSeparatedPath(field), ServerTimestampBehavior.DEFAULT);
   }
 
   /**
-   * Returns the value at the field or null if the field doesn't exist.
+   * Returns the value at the field or {@code null} if the field doesn't exist.
    *
    * @param field The path to the field
    * @param serverTimestampBehavior Configures the behavior for server timestamps that have not yet
    *     been set to their final value.
-   * @return The value at the given field or null.
+   * @return The value at the given field or {@code null}.
    */
   @Nullable
-  @PublicApi
   public Object get(
       @NonNull String field, @NonNull ServerTimestampBehavior serverTimestampBehavior) {
     return get(FieldPath.fromDotSeparatedPath(field), serverTimestampBehavior);
   }
 
   /**
-   * Returns the value at the field or null if the field or document doesn't exist.
+   * Returns the value at the field or {@code null} if the field or document doesn't exist.
    *
    * @param fieldPath The path to the field
-   * @return The value at the given field or null.
+   * @return The value at the given field or {@code null}.
    */
   @Nullable
-  @PublicApi
   public Object get(@NonNull FieldPath fieldPath) {
     return get(fieldPath, ServerTimestampBehavior.DEFAULT);
   }
 
   /**
-   * Returns the value at the field or null if the field or document doesn't exist.
+   * Returns the value at the field or {@code null} if the field or document doesn't exist.
    *
    * @param fieldPath The path to the field
    * @param serverTimestampBehavior Configures the behavior for server timestamps that have not yet
    *     been set to their final value.
-   * @return The value at the given field or null.
+   * @return The value at the given field or {@code null}.
    */
   @Nullable
-  @PublicApi
   public Object get(
       @NonNull FieldPath fieldPath, @NonNull ServerTimestampBehavior serverTimestampBehavior) {
     checkNotNull(fieldPath, "Provided field path must not be null.");
@@ -286,37 +285,35 @@ public Object get(
         serverTimestampBehavior, "Provided serverTimestampBehavior value must not be null.");
     return getInternal(
         fieldPath.getInternalPath(),
-        FieldValueOptions.create(
+        new FieldValueOptions(
             serverTimestampBehavior,
             firestore.getFirestoreSettings().areTimestampsInSnapshotsEnabled()));
   }
 
   /**
-   * Returns the value at the field, converted to a POJO, or null if the field or document doesn't
-   * exist.
+   * Returns the value at the field, converted to a POJO, or {@code null} if the field or document
+   * doesn't exist.
    *
    * @param field The path to the field
    * @param valueType The Java class to convert the field value to.
-   * @return The value at the given field or null.
+   * @return The value at the given field or {@code null}.
    */
   @Nullable
-  @PublicApi
   public <T> T get(@NonNull String field, @NonNull Class<T> valueType) {
     return get(FieldPath.fromDotSeparatedPath(field), valueType, ServerTimestampBehavior.DEFAULT);
   }
 
   /**
-   * Returns the value at the field, converted to a POJO, or null if the field or document doesn't
-   * exist.
+   * Returns the value at the field, converted to a POJO, or {@code null} if the field or document
+   * doesn't exist.
    *
    * @param field The path to the field
    * @param valueType The Java class to convert the field value to.
    * @param serverTimestampBehavior Configures the behavior for server timestamps that have not yet
    *     been set to their final value.
-   * @return The value at the given field or null.
+   * @return The value at the given field or {@code null}.
    */
   @Nullable
-  @PublicApi
   public <T> T get(
       @NonNull String field,
       @NonNull Class<T> valueType,
@@ -325,31 +322,29 @@ public Object get(
   }
 
   /**
-   * Returns the value at the field, converted to a POJO, or null if the field or document doesn't
-   * exist.
+   * Returns the value at the field, converted to a POJO, or {@code null} if the field or document
+   * doesn't exist.
    *
    * @param fieldPath The path to the field
    * @param valueType The Java class to convert the field value to.
-   * @return The value at the given field or null.
+   * @return The value at the given field or {@code null}.
    */
   @Nullable
-  @PublicApi
   public <T> T get(@NonNull FieldPath fieldPath, @NonNull Class<T> valueType) {
     return get(fieldPath, valueType, ServerTimestampBehavior.DEFAULT);
   }
 
   /**
-   * Returns the value at the field, converted to a POJO, or null if the field or document doesn't
-   * exist.
+   * Returns the value at the field, converted to a POJO, or {@code null} if the field or document
+   * doesn't exist.
    *
    * @param fieldPath The path to the field
    * @param valueType The Java class to convert the field value to.
    * @param serverTimestampBehavior Configures the behavior for server timestamps that have not yet
    *     been set to their final value.
-   * @return The value at the given field or null.
+   * @return The value at the given field or {@code null}.
    */
   @Nullable
-  @PublicApi
   public <T> T get(
       @NonNull FieldPath fieldPath,
       @NonNull Class<T> valueType,
@@ -368,7 +363,6 @@ public Object get(
    * @return The value of the field
    */
   @Nullable
-  @PublicApi
   public Boolean getBoolean(@NonNull String field) {
     return getTypedValue(field, Boolean.class);
   }
@@ -381,7 +375,6 @@ public Boolean getBoolean(@NonNull String field) {
    * @return The value of the field
    */
   @Nullable
-  @PublicApi
   public Double getDouble(@NonNull String field) {
     Number val = getTypedValue(field, Number.class);
     return val != null ? val.doubleValue() : null;
@@ -395,7 +388,6 @@ public Double getDouble(@NonNull String field) {
    * @return The value of the field
    */
   @Nullable
-  @PublicApi
   public String getString(@NonNull String field) {
     return getTypedValue(field, String.class);
   }
@@ -408,7 +400,6 @@ public String getString(@NonNull String field) {
    * @return The value of the field
    */
   @Nullable
-  @PublicApi
   public Long getLong(@NonNull String field) {
     Number val = getTypedValue(field, Number.class);
     return val != null ? val.longValue() : null;
@@ -422,7 +413,6 @@ public Long getLong(@NonNull String field) {
    * @return The value of the field
    */
   @Nullable
-  @PublicApi
   public Date getDate(@NonNull String field) {
     return getDate(field, ServerTimestampBehavior.DEFAULT);
   }
@@ -440,7 +430,6 @@ public Date getDate(@NonNull String field) {
    * @return The value of the field
    */
   @Nullable
-  @PublicApi
   public Date getDate(
       @NonNull String field, @NonNull ServerTimestampBehavior serverTimestampBehavior) {
     checkNotNull(field, "Provided field path must not be null.");
@@ -449,13 +438,13 @@ public Date getDate(
     Object maybeDate =
         getInternal(
             FieldPath.fromDotSeparatedPath(field).getInternalPath(),
-            FieldValueOptions.create(
+            new FieldValueOptions(
                 serverTimestampBehavior, /*timestampsInSnapshotsEnabled=*/ false));
     return castTypedValue(maybeDate, field, Date.class);
   }
 
   /**
-   * Returns the value of the field as a {@link com.google.firebase.Timestamp}.
+   * Returns the value of the field as a {@code com.google.firebase.Timestamp}.
    *
    * <p>This method ignores the global setting {@link
    * FirebaseFirestoreSettings#areTimestampsInSnapshotsEnabled}.
@@ -465,13 +454,12 @@ public Date getDate(
    * @return The value of the field
    */
   @Nullable
-  @PublicApi
   public Timestamp getTimestamp(@NonNull String field) {
     return getTimestamp(field, ServerTimestampBehavior.DEFAULT);
   }
 
   /**
-   * Returns the value of the field as a {@link com.google.firebase.Timestamp}.
+   * Returns the value of the field as a {@code com.google.firebase.Timestamp}.
    *
    * <p>This method ignores the global setting {@link
    * FirebaseFirestoreSettings#areTimestampsInSnapshotsEnabled}.
@@ -483,7 +471,6 @@ public Timestamp getTimestamp(@NonNull String field) {
    * @return The value of the field
    */
   @Nullable
-  @PublicApi
   public Timestamp getTimestamp(
       @NonNull String field, @NonNull ServerTimestampBehavior serverTimestampBehavior) {
     checkNotNull(field, "Provided field path must not be null.");
@@ -492,8 +479,7 @@ public Timestamp getTimestamp(
     Object maybeTimestamp =
         getInternal(
             FieldPath.fromDotSeparatedPath(field).getInternalPath(),
-            FieldValueOptions.create(
-                serverTimestampBehavior, /*timestampsInSnapshotsEnabled=*/ true));
+            new FieldValueOptions(serverTimestampBehavior, /*timestampsInSnapshotsEnabled=*/ true));
     return castTypedValue(maybeTimestamp, field, Timestamp.class);
   }
 
@@ -505,7 +491,6 @@ public Timestamp getTimestamp(
    * @return The value of the field
    */
   @Nullable
-  @PublicApi
   public Blob getBlob(@NonNull String field) {
     return getTypedValue(field, Blob.class);
   }
@@ -518,7 +503,6 @@ public Blob getBlob(@NonNull String field) {
    * @return The value of the field
    */
   @Nullable
-  @PublicApi
   public GeoPoint getGeoPoint(@NonNull String field) {
     return getTypedValue(field, GeoPoint.class);
   }
@@ -531,7 +515,6 @@ public GeoPoint getGeoPoint(@NonNull String field) {
    * @return The value of the field
    */
   @Nullable
-  @PublicApi
   public DocumentReference getDocumentReference(@NonNull String field) {
     return getTypedValue(field, DocumentReference.class);
   }
@@ -542,7 +525,6 @@ public DocumentReference getDocumentReference(@NonNull String field) {
    * @return The reference to the document.
    */
   @NonNull
-  @PublicApi
   public DocumentReference getReference() {
     return new DocumentReference(key, firestore);
   }
@@ -571,29 +553,56 @@ private Object convertValue(FieldValue value, FieldValueOptions options) {
     } else if (value instanceof ArrayValue) {
       return convertArray((ArrayValue) value, options);
     } else if (value instanceof ReferenceValue) {
-      ReferenceValue referenceValue = (ReferenceValue) value;
-      DocumentKey key = (DocumentKey) referenceValue.value(options);
-      DatabaseId refDatabase = ((ReferenceValue) value).getDatabaseId();
-      DatabaseId database = this.firestore.getDatabaseId();
-      if (!refDatabase.equals(database)) {
-        // TODO: Somehow support foreign references.
-        Logger.warn(
-            "DocumentSnapshot",
-            "Document %s contains a document reference within a different database "
-                + "(%s/%s) which is not supported. It will be treated as a reference in "
-                + "the current database (%s/%s) instead.",
-            key.getPath(),
-            refDatabase.getProjectId(),
-            refDatabase.getDatabaseId(),
-            database.getProjectId(),
-            database.getDatabaseId());
-      }
-      return new DocumentReference(key, firestore);
+      return convertReference((ReferenceValue) value);
+    } else if (value instanceof TimestampValue) {
+      return convertTimestamp((TimestampValue) value, options);
+    } else if (value instanceof ServerTimestampValue) {
+      return convertServerTimestamp((ServerTimestampValue) value, options);
+    } else {
+      return value.value();
+    }
+  }
+
+  private Object convertServerTimestamp(ServerTimestampValue value, FieldValueOptions options) {
+    switch (options.serverTimestampBehavior) {
+      case PREVIOUS:
+        return value.getPreviousValue();
+      case ESTIMATE:
+        return value.getLocalWriteTime();
+      default:
+        return value.value();
+    }
+  }
+
+  private Object convertTimestamp(TimestampValue value, FieldValueOptions options) {
+    Timestamp timestamp = value.value();
+    if (options.timestampsInSnapshotsEnabled) {
+      return timestamp;
     } else {
-      return value.value(options);
+      return timestamp.toDate();
     }
   }
 
+  private Object convertReference(ReferenceValue value) {
+    DocumentKey key = value.value();
+    DatabaseId refDatabase = value.getDatabaseId();
+    DatabaseId database = this.firestore.getDatabaseId();
+    if (!refDatabase.equals(database)) {
+      // TODO: Somehow support foreign references.
+      Logger.warn(
+          "DocumentSnapshot",
+          "Document %s contains a document reference within a different database "
+              + "(%s/%s) which is not supported. It will be treated as a reference in "
+              + "the current database (%s/%s) instead.",
+          key.getPath(),
+          refDatabase.getProjectId(),
+          refDatabase.getDatabaseId(),
+          database.getProjectId(),
+          database.getDatabaseId());
+    }
+    return new DocumentReference(key, firestore);
+  }
+
   private Map<String, Object> convertObject(ObjectValue objectValue, FieldValueOptions options) {
     Map<String, Object> result = new HashMap<>();
     for (Map.Entry<String, FieldValue> entry : objectValue.getInternalValue()) {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/EventListener.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/EventListener.java
index dfde9eae8..a6dbea8f4 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/EventListener.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/EventListener.java
@@ -14,20 +14,17 @@
 
 package com.google.firebase.firestore;
 
-import com.google.firebase.annotations.PublicApi;
-import javax.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 /** An interface for event listeners. */
-@PublicApi
 public interface EventListener<T> {
 
   /**
-   * onEvent will be called with the new value or the error if an error occurred. It's guaranteed
-   * that exactly one of value or error will be non-null.
+   * {@code onEvent} will be called with the new value or the error if an error occurred. It's
+   * guaranteed that exactly one of value or error will be non-{@code null}.
    *
-   * @param value The value of the event. null if there was an error.
-   * @param error The error if there was error. null otherwise.
+   * @param value The value of the event. {@code null} if there was an error.
+   * @param error The error if there was error. {@code null} otherwise.
    */
-  @PublicApi
   void onEvent(@Nullable T value, @Nullable FirebaseFirestoreException error);
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/Exclude.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/Exclude.java
index 21a484a2b..248bd856c 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/Exclude.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/Exclude.java
@@ -14,14 +14,12 @@
 
 package com.google.firebase.firestore;
 
-import com.google.firebase.annotations.PublicApi;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-/** Marks a field as excluded from the Database. */
-@PublicApi
+/** Marks a field as excluded from the database instance. */
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.FIELD})
 public @interface Exclude {}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/FieldPath.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/FieldPath.java
index 6bfd80619..3f93bc1e7 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/FieldPath.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/FieldPath.java
@@ -17,8 +17,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import android.support.annotation.NonNull;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
 import java.util.Arrays;
 import java.util.List;
 import java.util.regex.Pattern;
@@ -28,7 +27,6 @@
  * (referring to a top level field in the document), or a list of field names (referring to a nested
  * field in the document).
  */
-@PublicApi
 public final class FieldPath {
   /** Matches any characters in a field path string that are reserved. */
   private static final Pattern RESERVED = Pattern.compile("[~*/\\[\\]]");
@@ -48,14 +46,14 @@ private FieldPath(com.google.firebase.firestore.model.FieldPath internalPath) {
   }
 
   /**
-   * Creates a FieldPath from the provided field names. If more than one field name is provided, the
-   * path will point to a nested field in a document.
+   * Creates a {@code FieldPath} from the provided field names. If more than one field name is
+   * provided, the path will point to a nested field in a document.
    *
    * @param fieldNames A list of field names.
    * @return A {@code FieldPath} that points to a field location in a document.
    */
-  @PublicApi
-  public static FieldPath of(@NonNull String... fieldNames) {
+  @NonNull
+  public static FieldPath of(String... fieldNames) {
     checkArgument(fieldNames.length > 0, "Invalid field path. Provided path must not be empty.");
 
     for (int i = 0; i < fieldNames.length; ++i) {
@@ -71,11 +69,10 @@ public static FieldPath of(@NonNull String... fieldNames) {
       new FieldPath(com.google.firebase.firestore.model.FieldPath.KEY_PATH);
 
   /**
-   * Returns A special sentinel FieldPath to refer to the ID of a document. It can be used in
-   * queries to sort or filter by the document ID.
+   * Returns A special sentinel {@code FieldPath} to refer to the ID of a document. It can be used
+   * in queries to sort or filter by the document ID.
    */
   @NonNull
-  @PublicApi
   public static FieldPath documentId() {
     return DOCUMENT_ID_INSTANCE;
   }
@@ -84,8 +81,7 @@ public static FieldPath documentId() {
   static FieldPath fromDotSeparatedPath(@NonNull String path) {
     checkNotNull(path, "Provided field path must not be null.");
     checkArgument(
-        !RESERVED.matcher(path).find(),
-        "Invalid field path (" + path + "). Paths must not contain '~', '*', '/', '[', or ']'");
+        !RESERVED.matcher(path).find(), "Use FieldPath.of() for field names containing '~*/[]'.");
     try {
       // By default, split() doesn't return empty leading and trailing segments. This can be enabled
       // by passing "-1" as the  limit.
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/FieldValue.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/FieldValue.java
index d65788ecb..985ef6fd8 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/FieldValue.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/FieldValue.java
@@ -14,24 +14,25 @@
 
 package com.google.firebase.firestore;
 
-import android.support.annotation.NonNull;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
 import java.util.Arrays;
 import java.util.List;
 
-/** Sentinel values that can be used when writing document fields with set() or update(). */
-@PublicApi
+/**
+ * Sentinel values that can be used when writing document fields with {@code set()} or {@code
+ * update()}.
+ */
 public abstract class FieldValue {
 
   FieldValue() {}
 
   /**
-   * Returns the method name (e.g. "FieldValue.delete") that was used to create this FieldValue
-   * instance, for use in error messages, etc.
+   * Returns the method name (for example, "FieldValue.delete") that was used to create this {@code
+   * FieldValue} instance, for use in error messages, etc.
    */
   abstract String getMethodName();
 
-  /* FieldValue class for field deletes. */
+  /* {@code FieldValue} class for field deletes. */
   static class DeleteFieldValue extends FieldValue {
     @Override
     String getMethodName() {
@@ -39,7 +40,7 @@ String getMethodName() {
     }
   }
 
-  /* FieldValue class for server timestamps. */
+  /* {@code FieldValue} class for server timestamps. */
   static class ServerTimestampFieldValue extends FieldValue {
     @Override
     String getMethodName() {
@@ -47,7 +48,7 @@ String getMethodName() {
     }
   }
 
-  /* FieldValue class for arrayUnion() transforms. */
+  /* {@code FieldValue} class for {@link #arrayUnion()} transforms. */
   static class ArrayUnionFieldValue extends FieldValue {
     private final List<Object> elements;
 
@@ -65,7 +66,7 @@ String getMethodName() {
     }
   }
 
-  /* FieldValue class for arrayRemove() transforms. */
+  /* {@code FieldValue} class for {@link #arrayRemove()} transforms. */
   static class ArrayRemoveFieldValue extends FieldValue {
     private final List<Object> elements;
 
@@ -83,7 +84,7 @@ String getMethodName() {
     }
   }
 
-  /* FieldValue class for increment() transforms. */
+  /* {@code FieldValue} class for {@link #increment()} transforms. */
   static class NumericIncrementFieldValue extends FieldValue {
     private final Number operand;
 
@@ -105,57 +106,53 @@ Number getOperand() {
   private static final ServerTimestampFieldValue SERVER_TIMESTAMP_INSTANCE =
       new ServerTimestampFieldValue();
 
-  /** Returns a sentinel for use with update() to mark a field for deletion. */
+  /** Returns a sentinel for use with {@code update()} to mark a field for deletion. */
   @NonNull
-  @PublicApi
   public static FieldValue delete() {
     return DELETE_INSTANCE;
   }
 
   /**
-   * Returns a sentinel for use with set() or update() to include a server-generated timestamp in
-   * the written data.
+   * Returns a sentinel for use with {@code set()} or {@code update()} to include a server-generated
+   * timestamp in the written data.
    */
   @NonNull
-  @PublicApi
   public static FieldValue serverTimestamp() {
     return SERVER_TIMESTAMP_INSTANCE;
   }
 
   /**
-   * Returns a special value that can be used with set() or update() that tells the server to union
-   * the given elements with any array value that already exists on the server. Each specified
-   * element that doesn't already exist in the array will be added to the end. If the field being
-   * modified is not already an array it will be overwritten with an array containing exactly the
-   * specified elements.
+   * Returns a special value that can be used with {@code set()} or {@code update()} that tells the
+   * server to union the given elements with any array value that already exists on the server. Each
+   * specified element that doesn't already exist in the array will be added to the end. If the
+   * field being modified is not already an array it will be overwritten with an array containing
+   * exactly the specified elements.
    *
    * @param elements The elements to union into the array.
-   * @return The FieldValue sentinel for use in a call to set() or update().
+   * @return The {@code FieldValue} sentinel for use in a call to {@code set()} or {@code update()}.
    */
   @NonNull
-  @PublicApi
-  public static FieldValue arrayUnion(@NonNull Object... elements) {
+  public static FieldValue arrayUnion(Object... elements) {
     return new ArrayUnionFieldValue(Arrays.asList(elements));
   }
 
   /**
-   * Returns a special value that can be used with set() or update() that tells the server to remove
-   * the given elements from any array value that already exists on the server. All instances of
-   * each element specified will be removed from the array. If the field being modified is not
-   * already an array it will be overwritten with an empty array.
+   * Returns a special value that can be used with {@code set()} or {@code update()} that tells the
+   * server to remove the given elements from any array value that already exists on the server. All
+   * instances of each element specified will be removed from the array. If the field being modified
+   * is not already an array it will be overwritten with an empty array.
    *
    * @param elements The elements to remove from the array.
-   * @return The FieldValue sentinel for use in a call to set() or update().
+   * @return The {@code FieldValue} sentinel for use in a call to {@code set()} or {@code update()}.
    */
   @NonNull
-  @PublicApi
-  public static FieldValue arrayRemove(@NonNull Object... elements) {
+  public static FieldValue arrayRemove(Object... elements) {
     return new ArrayRemoveFieldValue(Arrays.asList(elements));
   }
 
   /**
-   * Returns a special value that can be used with set() or update() that tells the server to
-   * increment the field's current value by the given value.
+   * Returns a special value that can be used with {@code set()} or {@code update()} that tells the
+   * server to increment the field's current value by the given value.
    *
    * <p>If the current field value is an integer, possible integer overflows are resolved to
    * Long.MAX_VALUE or Long.MIN_VALUE. If the current field value is a double, both values will be
@@ -164,26 +161,24 @@ public static FieldValue arrayRemove(@NonNull Object... elements) {
    * <p>If the current field is not an integer or double, or if the field does not yet exist, the
    * transformation will set the field to the given value.
    *
-   * @return The FieldValue sentinel for use in a call to set() or update().
+   * @return The {@code FieldValue} sentinel for use in a call to {@code set()} or {@code update()}.
    */
   @NonNull
-  @PublicApi
   public static FieldValue increment(long l) {
     return new NumericIncrementFieldValue(l);
   }
 
   /**
-   * Returns a special value that can be used with set() or update() that tells the server to
-   * increment the field's current value by the given value.
+   * Returns a special value that can be used with {@code set()} or {@code update()} that tells the
+   * server to increment the field's current value by the given value.
    *
    * <p>If the current value is an integer or a double, both the current and the given value will be
    * interpreted as doubles and all arithmetic will follow IEEE 754 semantics. Otherwise, the
    * transformation will set the field to the given value.
    *
-   * @return The FieldValue sentinel for use in a call to set() or update().
+   * @return The {@code FieldValue} sentinel for use in a call to {@code set()} or {@code update()}.
    */
   @NonNull
-  @PublicApi
   public static FieldValue increment(double l) {
     return new NumericIncrementFieldValue(l);
   }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/FirebaseFirestore.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/FirebaseFirestore.java
index bc8a32796..1124fc7bb 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/FirebaseFirestore.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/FirebaseFirestore.java
@@ -15,42 +15,55 @@
 package com.google.firebase.firestore;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import android.app.Activity;
 import android.content.Context;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.android.gms.tasks.Tasks;
 import com.google.common.base.Function;
 import com.google.firebase.FirebaseApp;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.auth.internal.InternalAuthProvider;
 import com.google.firebase.firestore.FirebaseFirestoreException.Code;
 import com.google.firebase.firestore.auth.CredentialsProvider;
 import com.google.firebase.firestore.auth.EmptyCredentialsProvider;
 import com.google.firebase.firestore.auth.FirebaseAuthCredentialsProvider;
+import com.google.firebase.firestore.core.ActivityScope;
+import com.google.firebase.firestore.core.AsyncEventListener;
 import com.google.firebase.firestore.core.DatabaseInfo;
 import com.google.firebase.firestore.core.FirestoreClient;
 import com.google.firebase.firestore.local.SQLitePersistence;
 import com.google.firebase.firestore.model.DatabaseId;
 import com.google.firebase.firestore.model.ResourcePath;
 import com.google.firebase.firestore.util.AsyncQueue;
+import com.google.firebase.firestore.util.Executors;
 import com.google.firebase.firestore.util.Logger;
 import com.google.firebase.firestore.util.Logger.Level;
 import java.util.concurrent.Executor;
 
 /**
- * Represents a Firestore Database and is the entry point for all Firestore operations
+ * Represents a Cloud Firestore database and is the entry point for all Cloud Firestore operations.
  *
- * <p><b>Subclassing Note</b>: Firestore classes are not meant to be subclassed except for use in
- * test mocks. Subclassing is not supported in production code and new SDK releases may break code
- * that does so.
+ * <p><b>Subclassing Note</b>: Cloud Firestore classes are not meant to be subclassed except for use
+ * in test mocks. Subclassing is not supported in production code and new SDK releases may break
+ * code that does so.
  */
-@PublicApi
 public class FirebaseFirestore {
 
+  /**
+   * Provides a registry management interface for {@code FirebaseFirestore} instances.
+   *
+   * @hide
+   */
+  public interface InstanceRegistry {
+    /** Removes the Cloud Firestore instance with given name from registry. */
+    void remove(@NonNull String databaseId);
+  }
+
   private static final String TAG = "FirebaseFirestore";
   private final Context context;
   // This is also used as private lock object for this instance. There is nothing inherent about
@@ -61,11 +74,13 @@
   private final AsyncQueue asyncQueue;
   private final FirebaseApp firebaseApp;
   private final UserDataConverter dataConverter;
+  // When user requests to terminate, use this to notify `FirestoreMultiDbComponent` to deregister
+  // this instance.
+  private final InstanceRegistry instanceRegistry;
   private FirebaseFirestoreSettings settings;
   private volatile FirestoreClient client;
 
   @NonNull
-  @PublicApi
   public static FirebaseFirestore getInstance() {
     FirebaseApp app = FirebaseApp.getInstance();
     if (app == null) {
@@ -75,7 +90,6 @@ public static FirebaseFirestore getInstance() {
   }
 
   @NonNull
-  @PublicApi
   public static FirebaseFirestore getInstance(@NonNull FirebaseApp app) {
     return getInstance(app, DatabaseId.DEFAULT_DATABASE_ID);
   }
@@ -94,7 +108,8 @@ static FirebaseFirestore newInstance(
       @NonNull Context context,
       @NonNull FirebaseApp app,
       @Nullable InternalAuthProvider authProvider,
-      @NonNull String database) {
+      @NonNull String database,
+      @NonNull InstanceRegistry instanceRegistry) {
     String projectId = app.getOptions().getProjectId();
     if (projectId == null) {
       throw new IllegalArgumentException("FirebaseOptions.getProjectId() cannot be null");
@@ -117,7 +132,10 @@ static FirebaseFirestore newInstance(
     // so there is no need to include it in the persistence key.
     String persistenceKey = app.getName();
 
-    return new FirebaseFirestore(context, databaseId, persistenceKey, provider, queue, app);
+    FirebaseFirestore firestore =
+        new FirebaseFirestore(
+            context, databaseId, persistenceKey, provider, queue, app, instanceRegistry);
+    return firestore;
   }
 
   @VisibleForTesting
@@ -127,7 +145,8 @@ static FirebaseFirestore newInstance(
       String persistenceKey,
       CredentialsProvider credentialsProvider,
       AsyncQueue asyncQueue,
-      @Nullable FirebaseApp firebaseApp) {
+      @Nullable FirebaseApp firebaseApp,
+      InstanceRegistry instanceRegistry) {
     this.context = checkNotNull(context);
     this.databaseId = checkNotNull(checkNotNull(databaseId));
     this.dataConverter = new UserDataConverter(databaseId);
@@ -136,22 +155,21 @@ static FirebaseFirestore newInstance(
     this.asyncQueue = checkNotNull(asyncQueue);
     // NOTE: We allow firebaseApp to be null in tests only.
     this.firebaseApp = firebaseApp;
+    this.instanceRegistry = instanceRegistry;
 
     settings = new FirebaseFirestoreSettings.Builder().build();
   }
 
-  /** Returns the settings used by this FirebaseFirestore object. */
+  /** Returns the settings used by this {@code FirebaseFirestore} object. */
   @NonNull
-  @PublicApi
   public FirebaseFirestoreSettings getFirestoreSettings() {
     return settings;
   }
 
   /**
-   * Sets any custom settings used to configure this FirebaseFirestore object. This method can only
-   * be called before calling any other methods on this object.
+   * Sets any custom settings used to configure this {@code FirebaseFirestore} object. This method
+   * can only be called before calling any other methods on this object.
    */
-  @PublicApi
   public void setFirestoreSettings(@NonNull FirebaseFirestoreSettings settings) {
     synchronized (databaseId) {
       checkNotNull(settings, "Provided settings must not be null.");
@@ -184,26 +202,20 @@ private void ensureClientConfigured() {
     }
   }
 
-  /**
-   * Returns the FirebaseApp instance to which this FirebaseFirestore belongs.
-   *
-   * @return The FirebaseApp instance to which this FirebaseFirestore belongs.
-   */
+  /** Returns the FirebaseApp instance to which this {@code FirebaseFirestore} belongs. */
   @NonNull
-  @PublicApi
   public FirebaseApp getApp() {
     return firebaseApp;
   }
 
   /**
-   * Gets a CollectionReference instance that refers to the collection at the specified path within
-   * the database.
+   * Gets a {@code CollectionReference} instance that refers to the collection at the specified path
+   * within the database.
    *
    * @param collectionPath A slash-separated path to a collection.
-   * @return The CollectionReference instance.
+   * @return The {@code CollectionReference} instance.
    */
   @NonNull
-  @PublicApi
   public CollectionReference collection(@NonNull String collectionPath) {
     checkNotNull(collectionPath, "Provided collection path must not be null.");
     ensureClientConfigured();
@@ -218,7 +230,6 @@ public CollectionReference collection(@NonNull String collectionPath) {
    * @return The DocumentReference instance.
    */
   @NonNull
-  @PublicApi
   public DocumentReference document(@NonNull String documentPath) {
     checkNotNull(documentPath, "Provided document path must not be null.");
     ensureClientConfigured();
@@ -226,15 +237,14 @@ public DocumentReference document(@NonNull String documentPath) {
   }
 
   /**
-   * Creates and returns a new @link{Query} that includes all documents in the database that are
-   * contained in a collection or subcollection with the given @code{collectionId}.
+   * Creates and returns a new {@code Query} that includes all documents in the database that are
+   * contained in a collection or subcollection with the given {@code collectionId}.
    *
    * @param collectionId Identifies the collections to query over. Every collection or subcollection
    *     with this ID as the last segment of its path will be included. Cannot contain a slash.
    * @return The created Query.
    */
   @NonNull
-  @PublicApi
   public Query collectionGroup(@NonNull String collectionId) {
     checkNotNull(collectionId, "Provided collection ID must not be null.");
     if (collectionId.contains("/")) {
@@ -254,22 +264,23 @@ public Query collectionGroup(@NonNull String collectionId) {
    * be retried. If it fails to commit after 5 attempts, the transaction will fail.
    *
    * <p>The maximum number of writes allowed in a single transaction is 500, but note that each
-   * usage of FieldValue.serverTimestamp(), FieldValue.arrayUnion(), FieldValue.arrayRemove(), or
-   * FieldValue.increment() inside a transaction counts as an additional write.
+   * usage of {@link FieldValue#serverTimestamp()}, {@link FieldValue#arrayUnion(Object...)}, {@link
+   * FieldValue#arrayRemove(Object...)}, or {@link FieldValue#increment(long)} inside a transaction
+   * counts as an additional write.
    *
    * @param updateFunction The function to execute within the transaction context.
    * @param executor The executor to run the transaction callback on.
    * @return The task returned from the updateFunction.
    */
-  private <TResult> Task<TResult> runTransaction(
-      Transaction.Function<TResult> updateFunction, Executor executor) {
+  private <ResultT> Task<ResultT> runTransaction(
+      Transaction.Function<ResultT> updateFunction, Executor executor) {
     ensureClientConfigured();
 
     // We wrap the function they provide in order to
     // 1. Use internal implementation classes for Transaction,
     // 2. Convert exceptions they throw into Tasks, and
     // 3. Run the user callback on the user queue.
-    Function<com.google.firebase.firestore.core.Transaction, Task<TResult>> wrappedUpdateFunction =
+    Function<com.google.firebase.firestore.core.Transaction, Task<ResultT>> wrappedUpdateFunction =
         internalTransaction ->
             Tasks.call(
                 executor,
@@ -289,7 +300,6 @@ public Query collectionGroup(@NonNull String collectionId) {
    * @return The task returned from the updateFunction.
    */
   @NonNull
-  @PublicApi
   public <TResult> Task<TResult> runTransaction(
       @NonNull Transaction.Function<TResult> updateFunction) {
     checkNotNull(updateFunction, "Provided transaction update function must not be null.");
@@ -301,13 +311,13 @@ public Query collectionGroup(@NonNull String collectionId) {
    * Creates a write batch, used for performing multiple writes as a single atomic operation.
    *
    * <p>The maximum number of writes allowed in a single batch is 500, but note that each usage of
-   * FieldValue.serverTimestamp(), FieldValue.arrayUnion(), FieldValue.arrayRemove(), or
-   * FieldValue.increment() inside a transaction counts as an additional write.
+   * {@link FieldValue#serverTimestamp()}, {@link FieldValue#arrayUnion(Object...)}, {@link
+   * FieldValue#arrayRemove(Object...)}, or {@link FieldValue#increment(long)} inside a transaction
+   * counts as an additional write.
    *
    * @return The created WriteBatch object.
    */
   @NonNull
-  @PublicApi
   public WriteBatch batch() {
     ensureClientConfigured();
 
@@ -322,18 +332,61 @@ public WriteBatch batch() {
    * @return A Task that will be resolved when the batch has been committed.
    */
   @NonNull
-  @PublicApi
   public Task<Void> runBatch(@NonNull WriteBatch.Function batchFunction) {
     WriteBatch batch = batch();
     batchFunction.apply(batch);
     return batch.commit();
   }
 
-  @VisibleForTesting
-  Task<Void> shutdown() {
+  Task<Void> terminateInternal() {
     // The client must be initialized to ensure that all subsequent API usage throws an exception.
     this.ensureClientConfigured();
-    return client.shutdown();
+    return client.terminate();
+  }
+
+  /**
+   * Terminates this {@code FirebaseFirestore} instance.
+   *
+   * <p>After calling {@code terminate()} only the {@link #clearPersistence()} method may be used.
+   * Any other method will throw an {@link IllegalStateException}.
+   *
+   * <p>To restart after termination, simply create a new instance of {@code FirebaseFirestore} with
+   * {@link #getInstance()} or {@link #getInstance(FirebaseApp)}.
+   *
+   * <p>{@code terminate()} does not cancel any pending writes and any tasks that are awaiting a
+   * response from the server will not be resolved. The next time you start this instance, it will
+   * resume attempting to send these writes to the server.
+   *
+   * <p>Note: Under normal circumstances, calling {@code terminate()} is not required. This method
+   * is useful only when you want to force this instance to release all of its resources or in
+   * combination with {@link #clearPersistence} to ensure that all local state is destroyed between
+   * test runs.
+   *
+   * @return A {@code Task} that is resolved when the instance has been successfully terminated.
+   */
+  @NonNull
+  public Task<Void> terminate() {
+    instanceRegistry.remove(this.getDatabaseId().getDatabaseId());
+    return terminateInternal();
+  }
+
+  /**
+   * Waits until all currently pending writes for the active user have been acknowledged by the
+   * backend.
+   *
+   * <p>The returned Task completes immediately if there are no outstanding writes. Otherwise, the
+   * Task waits for all previously issued writes (including those written in a previous app
+   * session), but it does not wait for writes that were added after the method is called. If you
+   * wish to wait for additional writes, you have to call {@code waitForPendingWrites()} again.
+   *
+   * <p>Any outstanding {@code waitForPendingWrites()} Tasks are cancelled during user changes.
+   *
+   * @return A {@code Task} which resolves when all currently pending writes have been acknowledged
+   *     by the backend.
+   */
+  @NonNull
+  public Task<Void> waitForPendingWrites() {
+    return client.waitForPendingWrites();
   }
 
   @VisibleForTesting
@@ -342,11 +395,11 @@ AsyncQueue getAsyncQueue() {
   }
 
   /**
-   * Re-enables network usage for this instance after a prior call to disableNetwork().
+   * Re-enables network usage for this instance after a prior call to {@link #disableNetwork()}.
    *
    * @return A Task that will be completed once networking is enabled.
    */
-  @PublicApi
+  @NonNull
   public Task<Void> enableNetwork() {
     ensureClientConfigured();
     return client.enableNetwork();
@@ -354,19 +407,18 @@ AsyncQueue getAsyncQueue() {
 
   /**
    * Disables network access for this instance. While the network is disabled, any snapshot
-   * listeners or get() calls will return results from cache, and any write operations will be
-   * queued until network usage is re-enabled via a call to enableNetwork().
+   * listeners or {@code get()} calls will return results from cache, and any write operations will
+   * be queued until network usage is re-enabled via a call to {@link #enableNetwork()}.
    *
    * @return A Task that will be completed once networking is disabled.
    */
-  @PublicApi
+  @NonNull
   public Task<Void> disableNetwork() {
     ensureClientConfigured();
     return client.disableNetwork();
   }
 
-  /** Globally enables / disables Firestore logging for the SDK. */
-  @PublicApi
+  /** Globally enables / disables Cloud Firestore logging for the SDK. */
   public static void setLoggingEnabled(boolean loggingEnabled) {
     if (loggingEnabled) {
       Logger.setLogLevel(Level.DEBUG);
@@ -376,29 +428,30 @@ public static void setLoggingEnabled(boolean loggingEnabled) {
   }
 
   /**
-   * Clears the persistent storage. This includes pending writes and cached documents.
+   * Clears the persistent storage, including pending writes and cached documents.
    *
-   * <p>Must be called while the firestore instance is not started (after the app is shutdown or
-   * when the app is first initialized). On startup, this method must be called before other methods
-   * (other than setFirestoreSettings()). If the firestore instance is still running, the Task will
-   * fail with an error code of FAILED_PRECONDITION.
+   * <p>Must be called while the {@code FirebaseFirestore} instance is not started (after the app is
+   * shutdown or when the app is first initialized). On startup, this method must be called before
+   * other methods (other than {@link #setFirestoreSettings(FirebaseFirestoreSettings)}). If the
+   * {@code FirebaseFirestore} instance is still running, the {@code Task} will fail with an error
+   * code of {@code FAILED_PRECONDITION}.
    *
-   * <p>Note: clearPersistence() is primarily intended to help write reliable tests that use
-   * Firestore. It uses the most efficient mechanism possible for dropping existing data but does
-   * not attempt to securely overwrite or otherwise make cached data unrecoverable. For applications
-   * that are sensitive to the disclosure of cache data in between user sessions we strongly
-   * recommend not to enable persistence in the first place.
+   * <p>Note: {@code clearPersistence()} is primarily intended to help write reliable tests that use
+   * Cloud Firestore. It uses an efficient mechanism for dropping existing data but does not attempt
+   * to securely overwrite or otherwise make cached data unrecoverable. For applications that are
+   * sensitive to the disclosure of cached data in between user sessions, we strongly recommend not
+   * enabling persistence at all.
    *
-   * @return A Task that is resolved once the persistent storage has been cleared. Otherwise, the
-   *     Task is rejected with an error.
+   * @return A {@code Task} that is resolved when the persistent storage is cleared. Otherwise, the
+   *     {@code Task} is rejected with an error.
    */
-  @PublicApi
+  @NonNull
   public Task<Void> clearPersistence() {
     final TaskCompletionSource<Void> source = new TaskCompletionSource<>();
-    asyncQueue.enqueueAndForget(
+    asyncQueue.enqueueAndForgetEvenAfterShutdown(
         () -> {
           try {
-            if (client != null && !client.isShutdown()) {
+            if (client != null && !client.isTerminated()) {
               throw new FirebaseFirestoreException(
                   "Persistence cannot be cleared while the firestore instance is running.",
                   Code.FAILED_PRECONDITION);
@@ -412,6 +465,94 @@ public static void setLoggingEnabled(boolean loggingEnabled) {
     return source.getTask();
   }
 
+  /**
+   * Attaches a listener for a snapshots-in-sync event. The snapshots-in-sync event indicates that
+   * all listeners affected by a given change have fired, even if a single server-generated change
+   * affects multiple listeners.
+   *
+   * <p>NOTE: The snapshots-in-sync event only indicates that listeners are in sync with each other,
+   * but does not relate to whether those snapshots are in sync with the server. Use
+   * SnapshotMetadata in the individual listeners to determine if a snapshot is from the cache or
+   * the server.
+   *
+   * @param runnable A callback to be called every time all snapshot listeners are in sync with each
+   *     other.
+   * @return A registration object that can be used to remove the listener.
+   */
+  ListenerRegistration addSnapshotsInSyncListener(@NonNull Runnable runnable) {
+    return addSnapshotsInSyncListener(Executors.DEFAULT_CALLBACK_EXECUTOR, runnable);
+  }
+
+  /**
+   * Attaches a listener for a snapshots-in-sync event. The snapshots-in-sync event indicates that
+   * all listeners affected by a given change have fired, even if a single server-generated change
+   * affects multiple listeners.
+   *
+   * <p>NOTE: The snapshots-in-sync event only indicates that listeners are in sync with each other,
+   * but does not relate to whether those snapshots are in sync with the server. Use
+   * SnapshotMetadata in the individual listeners to determine if a snapshot is from the cache or
+   * the server.
+   *
+   * @param activity The activity to scope the listener to.
+   * @param runnable A callback to be called every time all snapshot listeners are in sync with each
+   *     other.
+   * @return A registration object that can be used to remove the listener.
+   */
+  @NonNull
+  ListenerRegistration addSnapshotsInSyncListener(Activity activity, @NonNull Runnable runnable) {
+    return addSnapshotsInSyncListener(Executors.DEFAULT_CALLBACK_EXECUTOR, activity, runnable);
+  }
+
+  /**
+   * Attaches a listener for a snapshots-in-sync event. The snapshots-in-sync event indicates that
+   * all listeners affected by a given change have fired, even if a single server-generated change
+   * affects multiple listeners.
+   *
+   * <p>NOTE: The snapshots-in-sync event only indicates that listeners are in sync with each other,
+   * but does not relate to whether those snapshots are in sync with the server. Use
+   * SnapshotMetadata in the individual listeners to determine if a snapshot is from the cache or
+   * the server.
+   *
+   * @param executor The executor to use to call the listener.
+   * @param runnable A callback to be called every time all snapshot listeners are in sync with each
+   *     other.
+   * @return A registration object that can be used to remove the listener.
+   */
+  @NonNull
+  ListenerRegistration addSnapshotsInSyncListener(Executor executor, @NonNull Runnable runnable) {
+    return addSnapshotsInSyncListener(executor, null, runnable);
+  }
+
+  /**
+   * Internal helper method to add a snapshotsInSync listener.
+   *
+   * <p>Will be Activity scoped if the activity parameter is non-{@code null}.
+   *
+   * @param userExecutor The executor to use to call the listener.
+   * @param activity Optional activity this listener is scoped to.
+   * @param runnable A callback to be called every time all snapshot listeners are in sync with each
+   *     other.
+   * @return A registration object that can be used to remove the listener.
+   */
+  private ListenerRegistration addSnapshotsInSyncListener(
+      Executor userExecutor, @Nullable Activity activity, @NonNull Runnable runnable) {
+    ensureClientConfigured();
+    EventListener<Void> eventListener =
+        (Void v, FirebaseFirestoreException error) -> {
+          hardAssert(error == null, "snapshots-in-sync listeners should never get errors.");
+          runnable.run();
+        };
+    AsyncEventListener<Void> asyncListener =
+        new AsyncEventListener<Void>(userExecutor, eventListener);
+    client.addSnapshotsInSyncListener(asyncListener);
+    return ActivityScope.bind(
+        activity,
+        () -> {
+          asyncListener.mute();
+          client.removeSnapshotsInSyncListener(asyncListener);
+        });
+  }
+
   FirestoreClient getClient() {
     return client;
   }
@@ -424,12 +565,15 @@ UserDataConverter getDataConverter() {
     return dataConverter;
   }
 
-  /** Helper to validate a DocumentReference. Used by WriteBatch and Transaction. */
+  /**
+   * Helper to validate a {@code DocumentReference}. Used by {@link WriteBatch} and {@link
+   * Transaction}.
+   */
   void validateReference(DocumentReference docRef) {
     checkNotNull(docRef, "Provided DocumentReference must not be null.");
     if (docRef.getFirestore() != this) {
       throw new IllegalArgumentException(
-          "Provided document reference is from a different Firestore instance.");
+          "Provided document reference is from a different Cloud Firestore instance.");
     }
   }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/FirebaseFirestoreException.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/FirebaseFirestoreException.java
index e1ce6a9bd..683a48aff 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/FirebaseFirestoreException.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/FirebaseFirestoreException.java
@@ -16,24 +16,22 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import android.support.annotation.NonNull;
 import android.util.SparseArray;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.FirebaseException;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.firestore.util.Assert;
 
-/** A class of exceptions thrown by Firestore */
-@PublicApi
+/** A class of exceptions thrown by Cloud Firestore. */
 public class FirebaseFirestoreException extends FirebaseException {
   /**
-   * The set of Firestore status codes. The codes are the same at the ones exposed by gRPC here:
-   * https://github.com/grpc/grpc/blob/master/doc/statuscodes.md
+   * The set of Cloud Firestore status codes. The codes are the same at the ones exposed by gRPC
+   * here: https://github.com/grpc/grpc/blob/master/doc/statuscodes.md
    */
-  @PublicApi
   public enum Code {
     /**
-     * The operation completed successfully. FirebaseFirestoreException will never have a status of
-     * OK.
+     * The operation completed successfully. {@code FirebaseFirestoreException} will never have a
+     * status of {@code OK}.
      */
     OK(0),
 
@@ -44,9 +42,9 @@
     UNKNOWN(2),
 
     /**
-     * Client specified an invalid argument. Note that this differs from FAILED_PRECONDITION.
-     * INVALID_ARGUMENT indicates arguments that are problematic regardless of the state of the
-     * system (e.g., an invalid field name).
+     * Client specified an invalid argument. Note that this differs from {@link
+     * #FAILED_PRECONDITION}. {@code INVALID_ARGUMENT} indicates arguments that are problematic
+     * regardless of the state of the system (e.g., an invalid field name).
      */
     INVALID_ARGUMENT(3),
 
@@ -115,7 +113,6 @@
     }
 
     /** The numerical value of the code. */
-    @PublicApi
     public int value() {
       return value;
     }
@@ -137,7 +134,6 @@ public int value() {
     }
 
     @NonNull
-    @PublicApi
     public static Code fromValue(int value) {
       return STATUS_LIST.get(value, Code.UNKNOWN);
     }
@@ -145,7 +141,6 @@ public static Code fromValue(int value) {
 
   @NonNull private final Code code;
 
-  @PublicApi
   public FirebaseFirestoreException(@NonNull String detailMessage, @NonNull Code code) {
     super(detailMessage);
     checkNotNull(detailMessage, "Provided message must not be null.");
@@ -154,9 +149,8 @@ public FirebaseFirestoreException(@NonNull String detailMessage, @NonNull Code c
     this.code = checkNotNull(code, "Provided code must not be null.");
   }
 
-  @PublicApi
   public FirebaseFirestoreException(
-      @NonNull String detailMessage, @NonNull Code code, Throwable cause) {
+      @NonNull String detailMessage, @NonNull Code code, @Nullable Throwable cause) {
     super(detailMessage, cause);
     checkNotNull(detailMessage, "Provided message must not be null.");
     Assert.hardAssert(
@@ -165,12 +159,11 @@ public FirebaseFirestoreException(
   }
 
   /**
-   * Gets the error code for the Firestore operation that failed.
+   * Gets the error code for the Cloud Firestore operation that failed.
    *
-   * @return the code for the FirebaseFirestoreException
+   * @return the code for the {@code FirebaseFirestoreException}.
    */
   @NonNull
-  @PublicApi
   public Code getCode() {
     return code;
   }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/FirebaseFirestoreSettings.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/FirebaseFirestoreSettings.java
index e870c0278..773bb8eb7 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/FirebaseFirestoreSettings.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/FirebaseFirestoreSettings.java
@@ -16,27 +16,24 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.common.base.MoreObjects;
-import com.google.firebase.annotations.PublicApi;
 
-/** Settings used to configure a FirebaseFirestore instance. */
-@PublicApi
+/** Settings used to configure a {@link FirebaseFirestore} instance. */
 public final class FirebaseFirestoreSettings {
   /**
    * Constant to use with {@link FirebaseFirestoreSettings.Builder#setCacheSizeBytes(long)} to
    * disable garbage collection.
    */
-  @PublicApi public static final long CACHE_SIZE_UNLIMITED = -1;
+  public static final long CACHE_SIZE_UNLIMITED = -1;
 
   private static final long MINIMUM_CACHE_BYTES = 1 * 1024 * 1024; // 1 MB
   private static final long DEFAULT_CACHE_SIZE_BYTES = 100 * 1024 * 1024; // 100 MB
   private static final String DEFAULT_HOST = "firestore.googleapis.com";
   private static final boolean DEFAULT_TIMESTAMPS_IN_SNAPSHOTS_ENABLED = true;
 
-  /** A Builder for creating {@link FirebaseFirestoreSettings}. */
-  @PublicApi
+  /** A Builder for creating {@code FirebaseFirestoreSettings}. */
   public static final class Builder {
     private String host;
     private boolean sslEnabled;
@@ -44,8 +41,7 @@
     private boolean timestampsInSnapshotsEnabled;
     private long cacheSizeBytes;
 
-    /** Constructs a new FirebaseFirestoreSettings Builder object. */
-    @PublicApi
+    /** Constructs a new {@code FirebaseFirestoreSettings} Builder object. */
     public Builder() {
       host = DEFAULT_HOST;
       sslEnabled = true;
@@ -55,10 +51,9 @@ public Builder() {
     }
 
     /**
-     * Constructs a new FirebaseFirestoreSettings Builder based on an existing
-     * FirebaseFirestoreSettings object.
+     * Constructs a new {@code FirebaseFirestoreSettings} Builder based on an existing {@code
+     * FirebaseFirestoreSettings} object.
      */
-    @PublicApi
     public Builder(@NonNull FirebaseFirestoreSettings settings) {
       checkNotNull(settings, "Provided settings must not be null.");
       host = settings.host;
@@ -68,13 +63,12 @@ public Builder(@NonNull FirebaseFirestoreSettings settings) {
     }
 
     /**
-     * Sets the host of the Firestore backend.
+     * Sets the host of the Cloud Firestore backend.
      *
      * @param host The host string
      * @return A settings object with the host set.
      */
     @NonNull
-    @PublicApi
     public Builder setHost(@NonNull String host) {
       this.host = checkNotNull(host, "Provided host must not be null.");
       return this;
@@ -86,7 +80,6 @@ public Builder setHost(@NonNull String host) {
      * @return A settings object that uses SSL as specified by the <tt>value</tt>.
      */
     @NonNull
-    @PublicApi
     public Builder setSslEnabled(boolean value) {
       this.sslEnabled = value;
       return this;
@@ -99,7 +92,6 @@ public Builder setSslEnabled(boolean value) {
      *     <tt>value</tt>.
      */
     @NonNull
-    @PublicApi
     public Builder setPersistenceEnabled(boolean value) {
       this.persistenceEnabled = value;
       return this;
@@ -110,12 +102,12 @@ public Builder setPersistenceEnabled(boolean value) {
      * fields in {@link DocumentSnapshot DocumentSnapshots}. This is now enabled by default and
      * should not be disabled.
      *
-     * <p>Previously, Firestore returned timestamp fields as {@link java.util.Date} but {@link
+     * <p>Previously, Cloud Firestore returned timestamp fields as {@link java.util.Date} but {@link
      * java.util.Date} only supports millisecond precision, which leads to truncation and causes
      * unexpected behavior when using a timestamp from a snapshot as a part of a subsequent query.
      *
-     * <p>So now Firestore returns {@link com.google.firebase.Timestamp Timestamp} values instead of
-     * {@link java.util.Date}, avoiding this kind of problem.
+     * <p>So now Cloud Firestore returns {@link com.google.firebase.Timestamp Timestamp} values
+     * instead of {@link java.util.Date}, avoiding this kind of problem.
      *
      * <p>To opt into the old behavior of returning {@link java.util.Date Dates}, you can
      * temporarily set {@link FirebaseFirestoreSettings#areTimestampsInSnapshotsEnabled} to false.
@@ -127,7 +119,6 @@ public Builder setPersistenceEnabled(boolean value) {
      */
     @NonNull
     @Deprecated
-    @PublicApi
     public Builder setTimestampsInSnapshotsEnabled(boolean value) {
       this.timestampsInSnapshotsEnabled = value;
       return this;
@@ -135,9 +126,9 @@ public Builder setTimestampsInSnapshotsEnabled(boolean value) {
 
     /**
      * Sets an approximate cache size threshold for the on-disk data. If the cache grows beyond this
-     * size, Firestore will start removing data that hasn't been recently used. The size is not a
-     * guarantee that the cache will stay below that size, only that if the cache exceeds the given
-     * size, cleanup will be attempted.
+     * size, Cloud Firestore will start removing data that hasn't been recently used. The size is
+     * not a guarantee that the cache will stay below that size, only that if the cache exceeds the
+     * given size, cleanup will be attempted.
      *
      * <p>By default, collection is enabled with a cache size of 100 MB. The minimum value is 1 MB.
      *
@@ -145,7 +136,6 @@ public Builder setTimestampsInSnapshotsEnabled(boolean value) {
      *     {@code value}.
      */
     @NonNull
-    @PublicApi
     public Builder setCacheSizeBytes(long value) {
       if (value != CACHE_SIZE_UNLIMITED && value < MINIMUM_CACHE_BYTES) {
         throw new IllegalArgumentException(
@@ -156,7 +146,6 @@ public Builder setCacheSizeBytes(long value) {
     }
 
     @NonNull
-    @PublicApi
     public FirebaseFirestoreSettings build() {
       if (!this.sslEnabled && this.host.equals(DEFAULT_HOST)) {
         throw new IllegalStateException(
@@ -172,7 +161,7 @@ public FirebaseFirestoreSettings build() {
   private final boolean timestampsInSnapshotsEnabled;
   private final long cacheSizeBytes;
 
-  /** Constructs a FirebaseFirestoreSettings object based on the values in the Builder. */
+  /** Constructs a {@code FirebaseFirestoreSettings} object based on the values in the Builder. */
   private FirebaseFirestoreSettings(Builder builder) {
     host = builder.host;
     sslEnabled = builder.sslEnabled;
@@ -219,21 +208,18 @@ public String toString() {
         .toString();
   }
 
-  /** Returns the host of the Firestore backend. */
+  /** Returns the host of the Cloud Firestore backend. */
   @NonNull
-  @PublicApi
   public String getHost() {
     return host;
   }
 
   /** Returns whether or not to use SSL for communication. */
-  @PublicApi
   public boolean isSslEnabled() {
     return sslEnabled;
   }
 
   /** Returns whether or not to use local persistent storage. */
-  @PublicApi
   public boolean isPersistenceEnabled() {
     return persistenceEnabled;
   }
@@ -242,7 +228,6 @@ public boolean isPersistenceEnabled() {
    * Returns whether or not {@link DocumentSnapshot DocumentSnapshots} return timestamp fields as
    * {@link com.google.firebase.Timestamp Timestamps}.
    */
-  @PublicApi
   public boolean areTimestampsInSnapshotsEnabled() {
     return timestampsInSnapshotsEnabled;
   }
@@ -251,7 +236,6 @@ public boolean areTimestampsInSnapshotsEnabled() {
    * Returns the threshold for the cache size above which the SDK will attempt to collect the least
    * recently used documents.
    */
-  @PublicApi
   public long getCacheSizeBytes() {
     return cacheSizeBytes;
   }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/FirestoreMultiDbComponent.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/FirestoreMultiDbComponent.java
index 1edca98ec..6edfe9076 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/FirestoreMultiDbComponent.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/FirestoreMultiDbComponent.java
@@ -15,15 +15,19 @@
 package com.google.firebase.firestore;
 
 import android.content.Context;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.FirebaseApp;
+import com.google.firebase.FirebaseAppLifecycleListener;
+import com.google.firebase.FirebaseOptions;
 import com.google.firebase.auth.internal.InternalAuthProvider;
 import java.util.HashMap;
 import java.util.Map;
 
-/** Multi-resource container for Firestore. */
-class FirestoreMultiDbComponent {
+/** Multi-resource container for Cloud Firestore. */
+class FirestoreMultiDbComponent
+    implements FirebaseAppLifecycleListener, FirebaseFirestore.InstanceRegistry {
+
   /**
    * A static map from instance key to FirebaseFirestore instances. Instance keys are database
    * names.
@@ -41,16 +45,38 @@
     this.context = context;
     this.app = app;
     this.authProvider = authProvider;
+    this.app.addLifecycleEventListener(this);
   }
 
-  /** Provides instances of Firestore for given database names. */
+  /** Provides instances of Cloud Firestore for given database IDs. */
   @NonNull
-  synchronized FirebaseFirestore get(@NonNull String databaseName) {
-    FirebaseFirestore firestore = instances.get(databaseName);
+  synchronized FirebaseFirestore get(@NonNull String databaseId) {
+    FirebaseFirestore firestore = instances.get(databaseId);
     if (firestore == null) {
-      firestore = FirebaseFirestore.newInstance(context, app, authProvider, databaseName);
-      instances.put(databaseName, firestore);
+      firestore = FirebaseFirestore.newInstance(context, app, authProvider, databaseId, this);
+      instances.put(databaseId, firestore);
     }
     return firestore;
   }
+
+  /**
+   * Remove the instance of a given database ID from this component, such that if {@link
+   * FirestoreMultiDbComponent#get(String)} is called again with the same name, a new instance of
+   * {@link FirebaseFirestore} is created.
+   *
+   * <p>It is a no-op if there is no instance associated with the given database name.
+   */
+  @Override
+  public synchronized void remove(@NonNull String databaseId) {
+    instances.remove(databaseId);
+  }
+
+  @Override
+  public synchronized void onDeleted(String firebaseAppName, FirebaseOptions options) {
+    // Shuts down all database instances and remove them from registry map when App is deleted.
+    for (Map.Entry<String, FirebaseFirestore> entry : instances.entrySet()) {
+      entry.getValue().terminateInternal();
+      instances.remove(entry.getKey());
+    }
+  }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/FirestoreRegistrar.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/FirestoreRegistrar.java
index 6d551ee7b..5e7fbd60a 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/FirestoreRegistrar.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/FirestoreRegistrar.java
@@ -15,8 +15,8 @@
 package com.google.firebase.firestore;
 
 import android.content.Context;
-import android.support.annotation.Keep;
-import android.support.annotation.RestrictTo;
+import androidx.annotation.Keep;
+import androidx.annotation.RestrictTo;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.auth.internal.InternalAuthProvider;
 import com.google.firebase.components.Component;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/GeoPoint.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/GeoPoint.java
index a857e533a..a989189a1 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/GeoPoint.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/GeoPoint.java
@@ -14,24 +14,21 @@
 
 package com.google.firebase.firestore;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.firestore.util.Util;
 
-/** Immutable class representing a GeoPoint in Firestore */
-@PublicApi
+/** Immutable class representing a {@code GeoPoint} in Cloud Firestore */
 public class GeoPoint implements Comparable<GeoPoint> {
   private final double latitude;
   private final double longitude;
 
   /**
-   * Construct a new GeoPoint using the provided latitude and longitude values.
+   * Construct a new {@code GeoPoint} using the provided latitude and longitude values.
    *
-   * @param latitude The latitude of this GeoPoint in the range [-90, 90].
-   * @param longitude The longitude of this GeoPoint in the range [-180, 180].
+   * @param latitude The latitude of this {@code GeoPoint} in the range [-90, 90].
+   * @param longitude The longitude of this {@code GeoPoint} in the range [-180, 180].
    */
-  @PublicApi
   public GeoPoint(double latitude, double longitude) {
     if (Double.isNaN(latitude) || latitude < -90 || latitude > 90) {
       throw new IllegalArgumentException("Latitude must be in the range of [-90, 90]");
@@ -43,20 +40,17 @@ public GeoPoint(double latitude, double longitude) {
     this.longitude = longitude;
   }
 
-  /** @return The latitude value of this GeoPoint. */
-  @PublicApi
+  /** @return The latitude value of this {@code GeoPoint}. */
   public double getLatitude() {
     return latitude;
   }
 
-  /** @return The longitude value of this GeoPoint. */
-  @PublicApi
+  /** @return The longitude value of this {@code GeoPoint}. */
   public double getLongitude() {
     return longitude;
   }
 
   @Override
-  @PublicApi
   public int compareTo(@NonNull GeoPoint other) {
     int comparison = Util.compareDoubles(latitude, other.latitude);
     if (comparison == 0) {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/IgnoreExtraProperties.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/IgnoreExtraProperties.java
index bc11755bc..ca13a00d2 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/IgnoreExtraProperties.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/IgnoreExtraProperties.java
@@ -14,7 +14,6 @@
 
 package com.google.firebase.firestore;
 
-import com.google.firebase.annotations.PublicApi;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -24,7 +23,6 @@
  * Properties that don't map to class fields are ignored when serializing to a class annotated with
  * this annotation.
  */
-@PublicApi
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE})
 public @interface IgnoreExtraProperties {}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/ListenerRegistration.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/ListenerRegistration.java
index 45ec0d21e..8d5c2bd00 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/ListenerRegistration.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/ListenerRegistration.java
@@ -14,16 +14,12 @@
 
 package com.google.firebase.firestore;
 
-import com.google.firebase.annotations.PublicApi;
-
-/** Represents a listener that can be removed by calling remove(). */
-@PublicApi
+/** Represents a listener that can be removed by calling {@link #remove()}. */
 public interface ListenerRegistration {
 
   /**
-   * Removes the listener being tracked by this ListenerRegistration. After the initial call,
-   * subsequent calls have no effect.
+   * Removes the listener being tracked by this {@code ListenerRegistration}. After the initial
+   * call, subsequent calls have no effect.
    */
-  @PublicApi
   void remove();
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/MetadataChanges.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/MetadataChanges.java
index 5451057c8..2899505c7 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/MetadataChanges.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/MetadataChanges.java
@@ -14,13 +14,10 @@
 
 package com.google.firebase.firestore;
 
-import com.google.firebase.annotations.PublicApi;
-
 /**
- * Indicates whether metadata-only changes (i.e. only {@code DocumentSnapshot.getMetadata()} or
+ * Indicates whether metadata-only changes (that is, only {@code DocumentSnapshot.getMetadata()} or
  * {@code Query.getMetadata()} changed) should trigger snapshot events.
  */
-@PublicApi
 public enum MetadataChanges {
   EXCLUDE,
   INCLUDE
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/PropertyName.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/PropertyName.java
index ef4674bc0..7e46c0f4c 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/PropertyName.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/PropertyName.java
@@ -14,14 +14,12 @@
 
 package com.google.firebase.firestore;
 
-import com.google.firebase.annotations.PublicApi;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
 /** Marks a field to be renamed when serialized. */
-@PublicApi
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.FIELD})
 public @interface PropertyName {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/Query.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/Query.java
index 633789d7f..cb00fa688 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/Query.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/Query.java
@@ -19,53 +19,52 @@
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
 import android.app.Activity;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.android.gms.tasks.Tasks;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.firestore.FirebaseFirestoreException.Code;
 import com.google.firebase.firestore.core.ActivityScope;
 import com.google.firebase.firestore.core.AsyncEventListener;
 import com.google.firebase.firestore.core.Bound;
 import com.google.firebase.firestore.core.EventManager.ListenOptions;
+import com.google.firebase.firestore.core.FieldFilter;
 import com.google.firebase.firestore.core.Filter;
 import com.google.firebase.firestore.core.Filter.Operator;
 import com.google.firebase.firestore.core.ListenerRegistrationImpl;
 import com.google.firebase.firestore.core.OrderBy;
 import com.google.firebase.firestore.core.QueryListener;
-import com.google.firebase.firestore.core.RelationFilter;
 import com.google.firebase.firestore.core.ViewSnapshot;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.ResourcePath;
+import com.google.firebase.firestore.model.value.ArrayValue;
 import com.google.firebase.firestore.model.value.FieldValue;
 import com.google.firebase.firestore.model.value.ReferenceValue;
 import com.google.firebase.firestore.model.value.ServerTimestampValue;
 import com.google.firebase.firestore.util.Executors;
 import com.google.firebase.firestore.util.Util;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
-import javax.annotation.Nullable;
 
 /**
- * A Query which you can read or listen to. You can also construct refined Query objects by adding
- * filters and ordering.
+ * A {@code Query} which you can read or listen to. You can also construct refined {@code Query}
+ * objects by adding filters and ordering.
  *
- * <p><b>Subclassing Note</b>: Firestore classes are not meant to be subclassed except for use in
- * test mocks. Subclassing is not supported in production code and new SDK releases may break code
- * that does so.
+ * <p><b>Subclassing Note</b>: Cloud Firestore classes are not meant to be subclassed except for use
+ * in test mocks. Subclassing is not supported in production code and new SDK releases may break
+ * code that does so.
  */
-@PublicApi
 public class Query {
   final com.google.firebase.firestore.core.Query query;
 
   final FirebaseFirestore firestore;
 
   /** An enum for the direction of a sort. */
-  @PublicApi
   public enum Direction {
     ASCENDING,
     DESCENDING
@@ -76,239 +75,255 @@
     this.firestore = checkNotNull(firestore);
   }
 
-  /** Gets the Firestore instance associated with this query. */
+  /** Gets the Cloud Firestore instance associated with this query. */
   @NonNull
-  @PublicApi
   public FirebaseFirestore getFirestore() {
     return firestore;
   }
 
-  private void validateOrderByFieldMatchesInequality(
-      com.google.firebase.firestore.model.FieldPath orderBy,
-      com.google.firebase.firestore.model.FieldPath inequality) {
-    if (!orderBy.equals(inequality)) {
-      String inequalityString = inequality.canonicalString();
-      throw new IllegalArgumentException(
-          String.format(
-              "Invalid query. You have an inequality where filter (whereLessThan(), "
-                  + "whereGreaterThan(), etc.) on field '%s' and so you must also have '%s' as "
-                  + "your first orderBy() field, but your first orderBy() is currently on field "
-                  + "'%s' instead.",
-              inequalityString, inequalityString, orderBy.canonicalString()));
-    }
-  }
-
-  private void validateNewFilter(Filter filter) {
-    if (filter instanceof RelationFilter) {
-      RelationFilter relationFilter = (RelationFilter) filter;
-      if (relationFilter.isInequality()) {
-        com.google.firebase.firestore.model.FieldPath existingInequality = query.inequalityField();
-        com.google.firebase.firestore.model.FieldPath newInequality = filter.getField();
-
-        if (existingInequality != null && !existingInequality.equals(newInequality)) {
-          throw new IllegalArgumentException(
-              String.format(
-                  "All where filters other than whereEqualTo() must be on the same field. But you "
-                      + "have filters on '%s' and '%s'",
-                  existingInequality.canonicalString(), newInequality.canonicalString()));
-        }
-        com.google.firebase.firestore.model.FieldPath firstOrderByField =
-            query.getFirstOrderByField();
-        if (firstOrderByField != null) {
-          validateOrderByFieldMatchesInequality(firstOrderByField, newInequality);
-        }
-      } else if (relationFilter.getOperator() == Operator.ARRAY_CONTAINS) {
-        if (query.hasArrayContainsFilter()) {
-          throw new IllegalArgumentException(
-              "Invalid Query. Queries only support having a single array-contains filter.");
-        }
-      }
-    }
-  }
-
   /**
-   * Creates and returns a new Query with the additional filter that documents must contain the
-   * specified field and the value should be equal to the specified value.
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field and the value should be equal to the specified value.
    *
    * @param field The name of the field to compare
    * @param value The value for comparison
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query whereEqualTo(@NonNull String field, @Nullable Object value) {
     return whereHelper(FieldPath.fromDotSeparatedPath(field), Operator.EQUAL, value);
   }
 
   /**
-   * Creates and returns a new Query with the additional filter that documents must contain the
-   * specified field and the value should be equal to the specified value.
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field and the value should be equal to the specified value.
    *
    * @param fieldPath The path of the field to compare
    * @param value The value for comparison
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query whereEqualTo(@NonNull FieldPath fieldPath, @Nullable Object value) {
     return whereHelper(fieldPath, Operator.EQUAL, value);
   }
 
   /**
-   * Creates and returns a new Query with the additional filter that documents must contain the
-   * specified field and the value should be less than the specified value.
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field and the value should be less than the specified value.
    *
    * @param field The name of the field to compare
    * @param value The value for comparison
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query whereLessThan(@NonNull String field, @NonNull Object value) {
     return whereHelper(FieldPath.fromDotSeparatedPath(field), Operator.LESS_THAN, value);
   }
 
   /**
-   * Creates and returns a new Query with the additional filter that documents must contain the
-   * specified field and the value should be less than the specified value.
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field and the value should be less than the specified value.
    *
    * @param fieldPath The path of the field to compare
    * @param value The value for comparison
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query whereLessThan(@NonNull FieldPath fieldPath, @NonNull Object value) {
     return whereHelper(fieldPath, Operator.LESS_THAN, value);
   }
 
   /**
-   * Creates and returns a new Query with the additional filter that documents must contain the
-   * specified field and the value should be less than or equal to the specified value.
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field and the value should be less than or equal to the specified value.
    *
    * @param field The name of the field to compare
    * @param value The value for comparison
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query whereLessThanOrEqualTo(@NonNull String field, @NonNull Object value) {
     return whereHelper(FieldPath.fromDotSeparatedPath(field), Operator.LESS_THAN_OR_EQUAL, value);
   }
 
   /**
-   * Creates and returns a new Query with the additional filter that documents must contain the
-   * specified field and the value should be less than or equal to the specified value.
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field and the value should be less than or equal to the specified value.
    *
    * @param fieldPath The path of the field to compare
    * @param value The value for comparison
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query whereLessThanOrEqualTo(@NonNull FieldPath fieldPath, @NonNull Object value) {
     return whereHelper(fieldPath, Operator.LESS_THAN_OR_EQUAL, value);
   }
 
   /**
-   * Creates and returns a new Query with the additional filter that documents must contain the
-   * specified field and the value should be greater than the specified value.
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field and the value should be greater than the specified value.
    *
    * @param field The name of the field to compare
    * @param value The value for comparison
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query whereGreaterThan(@NonNull String field, @NonNull Object value) {
     return whereHelper(FieldPath.fromDotSeparatedPath(field), Operator.GREATER_THAN, value);
   }
 
   /**
-   * Creates and returns a new Query with the additional filter that documents must contain the
-   * specified field and the value should be greater than the specified value.
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field and the value should be greater than the specified value.
    *
    * @param fieldPath The path of the field to compare
    * @param value The value for comparison
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query whereGreaterThan(@NonNull FieldPath fieldPath, @NonNull Object value) {
     return whereHelper(fieldPath, Operator.GREATER_THAN, value);
   }
 
   /**
-   * Creates and returns a new Query with the additional filter that documents must contain the
-   * specified field and the value should be greater than or equal to the specified value.
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field and the value should be greater than or equal to the specified value.
    *
    * @param field The name of the field to compare
    * @param value The value for comparison
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query whereGreaterThanOrEqualTo(@NonNull String field, @NonNull Object value) {
     return whereHelper(
         FieldPath.fromDotSeparatedPath(field), Operator.GREATER_THAN_OR_EQUAL, value);
   }
 
   /**
-   * Creates and returns a new Query with the additional filter that documents must contain the
-   * specified field and the value should be greater than or equal to the specified value.
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field and the value should be greater than or equal to the specified value.
    *
    * @param fieldPath The path of the field to compare
    * @param value The value for comparison
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query whereGreaterThanOrEqualTo(@NonNull FieldPath fieldPath, @NonNull Object value) {
     return whereHelper(fieldPath, Operator.GREATER_THAN_OR_EQUAL, value);
   }
 
   /**
-   * Creates and returns a new Query with the additional filter that documents must contain the
-   * specified field, the value must be an array, and that the array must contain the provided
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field, the value must be an array, and that the array must contain the provided
    * value.
    *
-   * <p>A Query can have only one whereArrayContains() filter.
+   * <p>A {@code Query} can have only one {@code whereArrayContains()} filter and it cannot be
+   * combined with {@code whereArrayContainsAny()}.
    *
-   * @param field The name of the field containing an array to search
+   * @param field The name of the field containing an array to search.
    * @param value The value that must be contained in the array
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query whereArrayContains(@NonNull String field, @NonNull Object value) {
     return whereHelper(FieldPath.fromDotSeparatedPath(field), Operator.ARRAY_CONTAINS, value);
   }
 
   /**
-   * Creates and returns a new Query with the additional filter that documents must contain the
-   * specified field, the value must be an array, and that the array must contain the provided
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field, the value must be an array, and that the array must contain the provided
    * value.
    *
-   * <p>A Query can have only one whereArrayContains() filter.
+   * <p>A {@code Query} can have only one {@code whereArrayContains()} filter and it cannot be
+   * combined with {@code whereArrayContainsAny()}.
    *
-   * @param fieldPath The path of the field containing an array to search
+   * @param fieldPath The path of the field containing an array to search.
    * @param value The value that must be contained in the array
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query whereArrayContains(@NonNull FieldPath fieldPath, @NonNull Object value) {
     return whereHelper(fieldPath, Operator.ARRAY_CONTAINS, value);
   }
 
   /**
-   * Creates and returns a new Query with the additional filter that documents must contain the
-   * specified field and the value should satisfy the relation constraint provided.
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field, the value must be an array, and that the array must contain at least one
+   * value from the provided array.
+   *
+   * <p>A {@code Query} can have only one {@code whereArrayContainsAny()} filter and it cannot be
+   * combined with {@code whereArrayContains()} or {@code whereIn()}.
+   *
+   * @param field The name of the field containing an array to search.
+   * @param value The array that contains the values to match.
+   * @return The created {@code Query}.
+   */
+  // TODO(in-queries): Expose to public once backend is ready.
+  @NonNull
+  Query whereArrayContainsAny(@NonNull String field, @NonNull List<Object> value) {
+    return whereHelper(FieldPath.fromDotSeparatedPath(field), Operator.ARRAY_CONTAINS_ANY, value);
+  }
+
+  /**
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field, the value must be an array, and that the array must contain at least one
+   * value from the provided array.
+   *
+   * <p>A {@code Query} can have only one {@code whereArrayContainsAny()} filter and it cannot be
+   * combined with {@code whereArrayContains()} or {@code whereIn()}.
+   *
+   * @param fieldPath The path of the field containing an array to search.
+   * @param value The array that contains the values to match.
+   * @return The created {@code Query}.
+   */
+  // TODO(in-queries): Expose to public once backend is ready.
+  @NonNull
+  Query whereArrayContainsAny(@NonNull FieldPath fieldPath, @NonNull List<Object> value) {
+    return whereHelper(fieldPath, Operator.ARRAY_CONTAINS_ANY, value);
+  }
+
+  /**
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field and the value must equal one of the values from the provided array.
+   *
+   * <p>A {@code Query} can have only one {@code whereIn()} filter, and it cannot be combined with
+   * {@code whereArrayContainsAny()}.
+   *
+   * @param field The name of the field to search.
+   * @param value The array that contains the values to match.
+   * @return The created {@code Query}.
+   */
+  // TODO(in-queries): Expose to public once backend is ready.
+  @NonNull
+  Query whereIn(@NonNull String field, @NonNull List<Object> value) {
+    return whereHelper(FieldPath.fromDotSeparatedPath(field), Operator.IN, value);
+  }
+
+  /**
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field and the value must equal one of the values from the provided array.
+   *
+   * <p>A {@code Query} can have only one {@code whereIn()} filter, and it cannot be combined with
+   * {@code whereArrayContainsAny()}.
+   *
+   * @param fieldPath The path of the field to search.
+   * @param value The array that contains the values to match.
+   * @return The created {@code Query}.
+   */
+  // TODO(in-queries): Expose to public once backend is ready.
+  @NonNull
+  Query whereIn(@NonNull FieldPath fieldPath, @NonNull List<Object> value) {
+    return whereHelper(fieldPath, Operator.IN, value);
+  }
+
+  /**
+   * Creates and returns a new {@code Query} with the additional filter that documents must contain
+   * the specified field and the value should satisfy the relation constraint provided.
    *
    * @param fieldPath The field to compare
    * @param op The operator
    * @param value The value for comparison
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   private Query whereHelper(@NonNull FieldPath fieldPath, Operator op, Object value) {
     checkNotNull(fieldPath, "Provided field path must not be null.");
@@ -316,50 +331,28 @@ private Query whereHelper(@NonNull FieldPath fieldPath, Operator op, Object valu
     FieldValue fieldValue;
     com.google.firebase.firestore.model.FieldPath internalPath = fieldPath.getInternalPath();
     if (internalPath.isKeyField()) {
-      if (op == Operator.ARRAY_CONTAINS) {
+      if (op == Operator.ARRAY_CONTAINS || op == Operator.ARRAY_CONTAINS_ANY) {
         throw new IllegalArgumentException(
-            "Invalid query. You can't perform array-contains queries on FieldPath.documentId() "
-                + "since document IDs are not arrays.");
-      }
-      if (value instanceof String) {
-        String documentKey = (String) value;
-        if (documentKey.isEmpty()) {
-          throw new IllegalArgumentException(
-              "Invalid query. When querying with FieldPath.documentId() you must provide a valid "
-                  + "document ID, but it was an empty string.");
-        }
-        if (!query.isCollectionGroupQuery() && documentKey.contains("/")) {
-          throw new IllegalArgumentException(
-              "Invalid query. When querying a collection by FieldPath.documentId() you must "
-                  + "provide a plain document ID, but '"
-                  + documentKey
-                  + "' contains a '/' character.");
+            "Invalid query. You can't perform '"
+                + op.toString()
+                + "' queries on FieldPath.documentId().");
+      } else if (op == Operator.IN) {
+        validateDisjunctiveFilterElements(value, op);
+        List<FieldValue> referenceList = new ArrayList<>();
+        for (Object arrayValue : (List) value) {
+          referenceList.add(parseDocumentIdValue(arrayValue));
         }
-        ResourcePath path = query.getPath().append(ResourcePath.fromString(documentKey));
-        if (!DocumentKey.isDocumentKey(path)) {
-          throw new IllegalArgumentException(
-              "Invalid query. When querying a collection group by FieldPath.documentId(), the "
-                  + "value provided must result in a valid document path, but '"
-                  + path
-                  + "' is not because it has an odd number of segments ("
-                  + path.length()
-                  + ").");
-        }
-        fieldValue =
-            ReferenceValue.valueOf(this.getFirestore().getDatabaseId(), DocumentKey.fromPath(path));
-      } else if (value instanceof DocumentReference) {
-        DocumentReference ref = (DocumentReference) value;
-        fieldValue = ReferenceValue.valueOf(this.getFirestore().getDatabaseId(), ref.getKey());
+        fieldValue = ArrayValue.fromList(referenceList);
       } else {
-        throw new IllegalArgumentException(
-            "Invalid query. When querying with FieldPath.documentId() you must provide a valid "
-                + "String or DocumentReference, but it was of type: "
-                + Util.typeName(value));
+        fieldValue = parseDocumentIdValue(value);
       }
     } else {
+      if (op == Operator.IN || op == Operator.ARRAY_CONTAINS_ANY) {
+        validateDisjunctiveFilterElements(value, op);
+      }
       fieldValue = firestore.getDataConverter().parseQueryValue(value);
     }
-    Filter filter = Filter.create(fieldPath.getInternalPath(), op, fieldValue);
+    Filter filter = FieldFilter.create(fieldPath.getInternalPath(), op, fieldValue);
     validateNewFilter(filter);
     return new Query(query.filter(filter), firestore);
   }
@@ -373,54 +366,188 @@ private void validateOrderByField(com.google.firebase.firestore.model.FieldPath
   }
 
   /**
-   * Creates and returns a new Query that's additionally sorted by the specified field.
+   * Parses the given documentIdValue into a ReferenceValue, throwing appropriate errors if the
+   * value is anything other than a DocumentReference or String, or if the string is malformed.
+   */
+  private ReferenceValue parseDocumentIdValue(Object documentIdValue) {
+    if (documentIdValue instanceof String) {
+      String documentId = (String) documentIdValue;
+      if (documentId.isEmpty()) {
+        throw new IllegalArgumentException(
+            "Invalid query. When querying with FieldPath.documentId() you must provide a valid "
+                + "document ID, but it was an empty string.");
+      }
+      if (!query.isCollectionGroupQuery() && documentId.contains("/")) {
+        throw new IllegalArgumentException(
+            "Invalid query. When querying a collection by FieldPath.documentId() you must "
+                + "provide a plain document ID, but '"
+                + documentId
+                + "' contains a '/' character.");
+      }
+      ResourcePath path = query.getPath().append(ResourcePath.fromString(documentId));
+      if (!DocumentKey.isDocumentKey(path)) {
+        throw new IllegalArgumentException(
+            "Invalid query. When querying a collection group by FieldPath.documentId(), the "
+                + "value provided must result in a valid document path, but '"
+                + path
+                + "' is not because it has an odd number of segments ("
+                + path.length()
+                + ").");
+      }
+      return ReferenceValue.valueOf(
+          this.getFirestore().getDatabaseId(), DocumentKey.fromPath(path));
+    } else if (documentIdValue instanceof DocumentReference) {
+      DocumentReference ref = (DocumentReference) documentIdValue;
+      return ReferenceValue.valueOf(this.getFirestore().getDatabaseId(), ref.getKey());
+    } else {
+      throw new IllegalArgumentException(
+          "Invalid query. When querying with FieldPath.documentId() you must provide a valid "
+              + "String or DocumentReference, but it was of type: "
+              + Util.typeName(documentIdValue));
+    }
+  }
+
+  /** Validates that the value passed into a disjunctive filter satisfies all array requirements. */
+  private void validateDisjunctiveFilterElements(Object value, Operator op) {
+    if (!(value instanceof List) || ((List) value).size() == 0) {
+      throw new IllegalArgumentException(
+          "Invalid Query. A non-empty array is required for '" + op.toString() + "' filters.");
+    }
+    if (((List) value).size() > 10) {
+      throw new IllegalArgumentException(
+          "Invalid Query. '"
+              + op.toString()
+              + "' filters support a maximum of 10 elements in the value array.");
+    }
+    if (((List) value).contains(null)) {
+      throw new IllegalArgumentException(
+          "Invalid Query. '"
+              + op.toString()
+              + "' filters cannot contain 'null' in the value array.");
+    }
+    if (((List) value).contains(Double.NaN) || ((List) value).contains(Float.NaN)) {
+      throw new IllegalArgumentException(
+          "Invalid Query. '"
+              + op.toString()
+              + "' filters cannot contain 'NaN' in the value array.");
+    }
+  }
+
+  private void validateOrderByFieldMatchesInequality(
+      com.google.firebase.firestore.model.FieldPath orderBy,
+      com.google.firebase.firestore.model.FieldPath inequality) {
+    if (!orderBy.equals(inequality)) {
+      String inequalityString = inequality.canonicalString();
+      throw new IllegalArgumentException(
+          String.format(
+              "Invalid query. You have an inequality where filter (whereLessThan(), "
+                  + "whereGreaterThan(), etc.) on field '%s' and so you must also have '%s' as "
+                  + "your first orderBy() field, but your first orderBy() is currently on field "
+                  + "'%s' instead.",
+              inequalityString, inequalityString, orderBy.canonicalString()));
+    }
+  }
+
+  private void validateNewFilter(Filter filter) {
+    if (filter instanceof FieldFilter) {
+      FieldFilter fieldFilter = (FieldFilter) filter;
+      Operator filterOp = fieldFilter.getOperator();
+      List<Operator> arrayOps = Arrays.asList(Operator.ARRAY_CONTAINS, Operator.ARRAY_CONTAINS_ANY);
+      List<Operator> disjunctiveOps = Arrays.asList(Operator.ARRAY_CONTAINS_ANY, Operator.IN);
+      boolean isArrayOp = arrayOps.contains(filterOp);
+      boolean isDisjunctiveOp = disjunctiveOps.contains(filterOp);
+
+      if (fieldFilter.isInequality()) {
+        com.google.firebase.firestore.model.FieldPath existingInequality = query.inequalityField();
+        com.google.firebase.firestore.model.FieldPath newInequality = filter.getField();
+
+        if (existingInequality != null && !existingInequality.equals(newInequality)) {
+          throw new IllegalArgumentException(
+              String.format(
+                  "All where filters other than whereEqualTo() must be on the same field. But you "
+                      + "have filters on '%s' and '%s'",
+                  existingInequality.canonicalString(), newInequality.canonicalString()));
+        }
+        com.google.firebase.firestore.model.FieldPath firstOrderByField =
+            query.getFirstOrderByField();
+        if (firstOrderByField != null) {
+          validateOrderByFieldMatchesInequality(firstOrderByField, newInequality);
+        }
+      } else if (isDisjunctiveOp || isArrayOp) {
+        // You can have at most 1 disjunctive filter and 1 array filter. Check if the new filter
+        // conflicts with an existing one.
+        Operator conflictingOp = null;
+        if (isDisjunctiveOp) {
+          conflictingOp = this.query.findFilterOperator(disjunctiveOps);
+        }
+        if (conflictingOp == null && isArrayOp) {
+          conflictingOp = this.query.findFilterOperator(arrayOps);
+        }
+        if (conflictingOp != null) {
+          // We special case when it's a duplicate op to give a slightly clearer error message.
+          if (conflictingOp == filterOp) {
+            throw new IllegalArgumentException(
+                "Invalid Query. You cannot use more than one '"
+                    + filterOp.toString()
+                    + "' filter.");
+          } else {
+            throw new IllegalArgumentException(
+                "Invalid Query. You cannot use '"
+                    + filterOp.toString()
+                    + "' filters with '"
+                    + conflictingOp.toString()
+                    + "' filters.");
+          }
+        }
+      }
+    }
+  }
+
+  /**
+   * Creates and returns a new {@code Query} that's additionally sorted by the specified field.
    *
    * @param field The field to sort by.
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query orderBy(@NonNull String field) {
     return orderBy(FieldPath.fromDotSeparatedPath(field), Direction.ASCENDING);
   }
 
   /**
-   * Creates and returns a new Query that's additionally sorted by the specified field.
+   * Creates and returns a new {@code Query} that's additionally sorted by the specified field.
    *
    * @param fieldPath The field to sort by.
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query orderBy(@NonNull FieldPath fieldPath) {
     checkNotNull(fieldPath, "Provided field path must not be null.");
     return orderBy(fieldPath.getInternalPath(), Direction.ASCENDING);
   }
 
   /**
-   * Creates and returns a new Query that's additionally sorted by the specified field, optionally
-   * in descending order instead of ascending.
+   * Creates and returns a new {@code Query} that's additionally sorted by the specified field,
+   * optionally in descending order instead of ascending.
    *
    * @param field The field to sort by.
    * @param direction The direction to sort.
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query orderBy(@NonNull String field, @NonNull Direction direction) {
     return orderBy(FieldPath.fromDotSeparatedPath(field), direction);
   }
 
   /**
-   * Creates and returns a new Query that's additionally sorted by the specified field, optionally
-   * in descending order instead of ascending.
+   * Creates and returns a new {@code Query} that's additionally sorted by the specified field,
+   * optionally in descending order instead of ascending.
    *
    * @param fieldPath The field to sort by.
    * @param direction The direction to sort.
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query orderBy(@NonNull FieldPath fieldPath, @NonNull Direction direction) {
     checkNotNull(fieldPath, "Provided field path must not be null.");
     return orderBy(fieldPath.getInternalPath(), direction);
@@ -449,14 +576,13 @@ private Query orderBy(
   }
 
   /**
-   * Creates and returns a new Query that's additionally limited to only return up to the specified
-   * number of documents.
+   * Creates and returns a new {@code Query} that's additionally limited to only return up to the
+   * specified number of documents.
    *
    * @param limit The maximum number of items to return.
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query limit(long limit) {
     if (limit <= 0) {
       throw new IllegalArgumentException(
@@ -466,119 +592,113 @@ public Query limit(long limit) {
   }
 
   /**
-   * Creates and returns a new Query that starts at the provided document (inclusive). The starting
-   * position is relative to the order of the query. The document must contain all of the fields
-   * provided in the orderBy of this query.
+   * Creates and returns a new {@code Query} that starts at the provided document (inclusive). The
+   * starting position is relative to the order of the query. The document must contain all of the
+   * fields provided in the orderBy of this query.
    *
    * @param snapshot The snapshot of the document to start at.
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query startAt(@NonNull DocumentSnapshot snapshot) {
     Bound bound = boundFromDocumentSnapshot("startAt", snapshot, /*before=*/ true);
     return new Query(query.startAt(bound), firestore);
   }
 
   /**
-   * Creates and returns a new Query that starts at the provided fields relative to the order of the
-   * query. The order of the field values must match the order of the order by clauses of the query.
+   * Creates and returns a new {@code Query} that starts at the provided fields relative to the
+   * order of the query. The order of the field values must match the order of the order by clauses
+   * of the query.
    *
    * @param fieldValues The field values to start this query at, in order of the query's order by.
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query startAt(Object... fieldValues) {
     Bound bound = boundFromFields("startAt", fieldValues, /*before=*/ true);
     return new Query(query.startAt(bound), firestore);
   }
 
   /**
-   * Creates and returns a new Query that starts after the provided document (exclusive). The
-   * starting position is relative to the order of the query. The document must contain all of the
-   * fields provided in the orderBy of this query.
+   * Creates and returns a new {@code Query} that starts after the provided document (exclusive).
+   * The starting position is relative to the order of the query. The document must contain all of
+   * the fields provided in the orderBy of this query.
    *
    * @param snapshot The snapshot of the document to start after.
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query startAfter(@NonNull DocumentSnapshot snapshot) {
     Bound bound = boundFromDocumentSnapshot("startAfter", snapshot, /*before=*/ false);
     return new Query(query.startAt(bound), firestore);
   }
 
   /**
-   * Creates and returns a new Query that starts after the provided fields relative to the order of
-   * the query. The order of the field values must match the order of the order by clauses of the
-   * query.
+   * Creates and returns a new {@code Query} that starts after the provided fields relative to the
+   * order of the query. The order of the field values must match the order of the order by clauses
+   * of the query.
    *
    * @param fieldValues The field values to start this query after, in order of the query's order
    *     by.
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query startAfter(Object... fieldValues) {
     Bound bound = boundFromFields("startAfter", fieldValues, /*before=*/ false);
     return new Query(query.startAt(bound), firestore);
   }
 
   /**
-   * Creates and returns a new Query that ends before the provided document (exclusive). The end
-   * position is relative to the order of the query. The document must contain all of the fields
+   * Creates and returns a new {@code Query} that ends before the provided document (exclusive). The
+   * end position is relative to the order of the query. The document must contain all of the fields
    * provided in the orderBy of this query.
    *
    * @param snapshot The snapshot of the document to end before.
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query endBefore(@NonNull DocumentSnapshot snapshot) {
     Bound bound = boundFromDocumentSnapshot("endBefore", snapshot, /*before=*/ true);
     return new Query(query.endAt(bound), firestore);
   }
 
   /**
-   * Creates and returns a new Query that ends before the provided fields relative to the order of
-   * the query. The order of the field values must match the order of the order by clauses of the
-   * query.
+   * Creates and returns a new {@code Query} that ends before the provided fields relative to the
+   * order of the query. The order of the field values must match the order of the order by clauses
+   * of the query.
    *
    * @param fieldValues The field values to end this query before, in order of the query's order by.
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query endBefore(Object... fieldValues) {
     Bound bound = boundFromFields("endBefore", fieldValues, /*before=*/ true);
     return new Query(query.endAt(bound), firestore);
   }
 
   /**
-   * Creates and returns a new Query that ends at the provided document (inclusive). The end
+   * Creates and returns a new {@code Query} that ends at the provided document (inclusive). The end
    * position is relative to the order of the query. The document must contain all of the fields
    * provided in the orderBy of this query.
    *
    * @param snapshot The snapshot of the document to end at.
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query endAt(@NonNull DocumentSnapshot snapshot) {
     Bound bound = boundFromDocumentSnapshot("endAt", snapshot, /*before=*/ false);
     return new Query(query.endAt(bound), firestore);
   }
 
   /**
-   * Creates and returns a new Query that ends at the provided fields relative to the order of the
-   * query. The order of the field values must match the order of the order by clauses of the query.
+   * Creates and returns a new {@code Query} that ends at the provided fields relative to the order
+   * of the query. The order of the field values must match the order of the order by clauses of the
+   * query.
    *
    * @param fieldValues The field values to end this query at, in order of the query's order by.
-   * @return The created Query.
+   * @return The created {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Query endAt(Object... fieldValues) {
     Bound bound = boundFromFields("endAt", fieldValues, /*before=*/ false);
     return new Query(query.endAt(bound), firestore);
@@ -693,29 +813,27 @@ private Bound boundFromFields(String methodName, Object[] values, boolean before
   }
 
   /**
-   * Executes the query and returns the results as a QuerySnapshot.
+   * Executes the query and returns the results as a {@code QuerySnapshot}.
    *
-   * @return A Task that will be resolved with the results of the Query.
+   * @return A Task that will be resolved with the results of the {@code Query}.
    */
   @NonNull
-  @PublicApi
   public Task<QuerySnapshot> get() {
     return get(Source.DEFAULT);
   }
 
   /**
-   * Executes the query and returns the results as a QuerySnapshot.
+   * Executes the query and returns the results as a {@code QuerySnapshot}.
    *
-   * <p>By default, get() attempts to provide up-to-date data when possible by waiting for data from
-   * the server, but it may return cached data or fail if you are offline and the server cannot be
-   * reached. This behavior can be altered via the {@link Source} parameter.
+   * <p>By default, {@code get()} attempts to provide up-to-date data when possible by waiting for
+   * data from the server, but it may return cached data or fail if you are offline and the server
+   * cannot be reached. This behavior can be altered via the {@code Source} parameter.
    *
    * @param source A value to configure the get behavior.
-   * @return A Task that will be resolved with the results of the Query.
+   * @return A Task that will be resolved with the results of the {@code Query}.
    */
   @NonNull
-  @PublicApi
-  public Task<QuerySnapshot> get(Source source) {
+  public Task<QuerySnapshot> get(@NonNull Source source) {
     if (source == Source.CACHE) {
       return firestore
           .getClient()
@@ -789,7 +907,6 @@ private Bound boundFromFields(String methodName, Object[] values, boolean before
    * @return A registration object that can be used to remove the listener.
    */
   @NonNull
-  @PublicApi
   public ListenerRegistration addSnapshotListener(@NonNull EventListener<QuerySnapshot> listener) {
     return addSnapshotListener(MetadataChanges.EXCLUDE, listener);
   }
@@ -802,7 +919,6 @@ public ListenerRegistration addSnapshotListener(@NonNull EventListener<QuerySnap
    * @return A registration object that can be used to remove the listener.
    */
   @NonNull
-  @PublicApi
   public ListenerRegistration addSnapshotListener(
       @NonNull Executor executor, @NonNull EventListener<QuerySnapshot> listener) {
     return addSnapshotListener(executor, MetadataChanges.EXCLUDE, listener);
@@ -818,7 +934,6 @@ public ListenerRegistration addSnapshotListener(
    * @return A registration object that can be used to remove the listener.
    */
   @NonNull
-  @PublicApi
   public ListenerRegistration addSnapshotListener(
       @NonNull Activity activity, @NonNull EventListener<QuerySnapshot> listener) {
     return addSnapshotListener(activity, MetadataChanges.EXCLUDE, listener);
@@ -833,7 +948,6 @@ public ListenerRegistration addSnapshotListener(
    * @return A registration object that can be used to remove the listener.
    */
   @NonNull
-  @PublicApi
   public ListenerRegistration addSnapshotListener(
       @NonNull MetadataChanges metadataChanges, @NonNull EventListener<QuerySnapshot> listener) {
     return addSnapshotListener(Executors.DEFAULT_CALLBACK_EXECUTOR, metadataChanges, listener);
@@ -849,7 +963,6 @@ public ListenerRegistration addSnapshotListener(
    * @return A registration object that can be used to remove the listener.
    */
   @NonNull
-  @PublicApi
   public ListenerRegistration addSnapshotListener(
       @NonNull Executor executor,
       @NonNull MetadataChanges metadataChanges,
@@ -872,7 +985,6 @@ public ListenerRegistration addSnapshotListener(
    * @return A registration object that can be used to remove the listener.
    */
   @NonNull
-  @PublicApi
   public ListenerRegistration addSnapshotListener(
       @NonNull Activity activity,
       @NonNull MetadataChanges metadataChanges,
@@ -887,7 +999,7 @@ public ListenerRegistration addSnapshotListener(
   /**
    * Internal helper method to create add a snapshot listener.
    *
-   * <p>Will be Activity scoped if the activity parameter is non-null.
+   * <p>Will be Activity scoped if the activity parameter is non-{@code null}.
    *
    * @param executor The executor to use to call the listener.
    * @param options The options to use for this listen.
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/QueryDocumentSnapshot.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/QueryDocumentSnapshot.java
index 1b9e7a495..aed0ded10 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/QueryDocumentSnapshot.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/QueryDocumentSnapshot.java
@@ -16,28 +16,27 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import android.support.annotation.NonNull;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.util.Assert;
 import java.util.Map;
-import javax.annotation.Nullable;
 
 /**
- * A QueryDocumentSnapshot contains data read from a document in your Firestore database as part of
- * a query. The document is guaranteed to exist and its data can be extracted using the getData() or
- * get() methods.
+ * A {@code QueryDocumentSnapshot} contains data read from a document in your Cloud Firestore
+ * database as part of a query. The document is guaranteed to exist and its data can be extracted
+ * using the {@link #getData()} or the various {@code get()} methods in {@link DocumentSnapshot}
+ * (such as {@link DocumentSnapshot#get(String)}).
  *
- * <p>QueryDocumentSnapshot offers the same API surface as {@link DocumentSnapshot}. Since query
- * results contain only existing documents, the exists() method will always return true and
- * getData() will never be null.
+ * <p>{@code QueryDocumentSnapshot} offers the same API surface as {@code DocumentSnapshot}. Since
+ * query results contain only existing documents, the {@link #exists()} method will always return
+ * true and {@link #getData()} will never be {@code null}.
  *
- * <p><b>Subclassing Note</b>: Firestore classes are not meant to be subclassed except for use in
- * test mocks. Subclassing is not supported in production code and new SDK releases may break code
- * that does so.
+ * <p><b>Subclassing Note</b>: Cloud Firestore classes are not meant to be subclassed except for use
+ * in test mocks. Subclassing is not supported in production code and new SDK releases may break
+ * code that does so.
  */
-@PublicApi
 public class QueryDocumentSnapshot extends DocumentSnapshot {
 
   private QueryDocumentSnapshot(
@@ -62,7 +61,6 @@ static QueryDocumentSnapshot fromDocument(
    */
   @NonNull
   @Override
-  @PublicApi
   public Map<String, Object> getData() {
     Map<String, Object> result = super.getData();
     Assert.hardAssert(result != null, "Data in a QueryDocumentSnapshot should be non-null");
@@ -75,11 +73,10 @@ static QueryDocumentSnapshot fromDocument(
    *
    * @param serverTimestampBehavior Configures the behavior for server timestamps that have not yet
    *     been set to their final value.
-   * @return The fields of the document as a Map or null if the document doesn't exist.
+   * @return The fields of the document as a Map or {@code null} if the document doesn't exist.
    */
   @NonNull
   @Override
-  @PublicApi
   public Map<String, Object> getData(@NonNull ServerTimestampBehavior serverTimestampBehavior) {
     checkNotNull(
         serverTimestampBehavior, "Provided serverTimestampBehavior value must not be null.");
@@ -96,7 +93,6 @@ static QueryDocumentSnapshot fromDocument(
    */
   @NonNull
   @Override
-  @PublicApi
   public <T> T toObject(@NonNull Class<T> valueType) {
     T result = super.toObject(valueType);
     Assert.hardAssert(result != null, "Object in a QueryDocumentSnapshot should be non-null");
@@ -113,7 +109,6 @@ static QueryDocumentSnapshot fromDocument(
    */
   @NonNull
   @Override
-  @PublicApi
   public <T> T toObject(
       @NonNull Class<T> valueType, @NonNull ServerTimestampBehavior serverTimestampBehavior) {
     checkNotNull(
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/QuerySnapshot.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/QuerySnapshot.java
index fbb841d52..4412582d7 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/QuerySnapshot.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/QuerySnapshot.java
@@ -16,25 +16,23 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import android.support.annotation.NonNull;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.firestore.core.ViewSnapshot;
 import com.google.firebase.firestore.model.Document;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
-import javax.annotation.Nullable;
 
 /**
- * A QuerySnapshot contains the results of a query. It can contain zero or more DocumentSnapshot
- * objects.
+ * A {@code QuerySnapshot} contains the results of a query. It can contain zero or more {@link
+ * DocumentSnapshot} objects.
  *
- * <p><b>Subclassing Note</b>: Firestore classes are not meant to be subclassed except for use in
- * test mocks. Subclassing is not supported in production code and new SDK releases may break code
- * that does so.
+ * <p><b>Subclassing Note</b>: Cloud Firestore classes are not meant to be subclassed except for use
+ * in test mocks. Subclassing is not supported in production code and new SDK releases may break
+ * code that does so.
  */
-@PublicApi
 public class QuerySnapshot implements Iterable<QueryDocumentSnapshot> {
 
   private final Query originalQuery;
@@ -80,14 +78,12 @@ public void remove() {
   }
 
   @NonNull
-  @PublicApi
   public Query getQuery() {
     return originalQuery;
   }
 
-  /** @return The metadata for this document snapshot. */
+  /** @return The metadata for this query snapshot. */
   @NonNull
-  @PublicApi
   public SnapshotMetadata getMetadata() {
     return metadata;
   }
@@ -101,7 +97,6 @@ public SnapshotMetadata getMetadata() {
    * @return The list of document changes since the last snapshot.
    */
   @NonNull
-  @PublicApi
   public List<DocumentChange> getDocumentChanges() {
     return getDocumentChanges(MetadataChanges.EXCLUDE);
   }
@@ -115,7 +110,6 @@ public SnapshotMetadata getMetadata() {
    * @return The list of document changes since the last snapshot.
    */
   @NonNull
-  @PublicApi
   public List<DocumentChange> getDocumentChanges(@NonNull MetadataChanges metadataChanges) {
     if (MetadataChanges.INCLUDE.equals(metadataChanges) && snapshot.excludesMetadataChanges()) {
       throw new IllegalArgumentException(
@@ -132,12 +126,11 @@ public SnapshotMetadata getMetadata() {
   }
 
   /**
-   * Returns the documents in this QuerySnapshot as a List in order of the query.
+   * Returns the documents in this {@code QuerySnapshot} as a List in order of the query.
    *
    * @return The list of documents.
    */
   @NonNull
-  @PublicApi
   public List<DocumentSnapshot> getDocuments() {
     List<DocumentSnapshot> res = new ArrayList<>(snapshot.getDocuments().size());
     for (com.google.firebase.firestore.model.Document doc : snapshot.getDocuments()) {
@@ -146,47 +139,42 @@ public SnapshotMetadata getMetadata() {
     return res;
   }
 
-  /** Returns true if there are no documents in the QuerySnapshot. */
-  @PublicApi
+  /** Returns true if there are no documents in the {@code QuerySnapshot}. */
   public boolean isEmpty() {
     return snapshot.getDocuments().isEmpty();
   }
 
-  /** Returns the number of documents in the QuerySnapshot. */
-  @PublicApi
+  /** Returns the number of documents in the {@code QuerySnapshot}. */
   public int size() {
     return snapshot.getDocuments().size();
   }
 
   @Override
   @NonNull
-  @PublicApi
   public Iterator<QueryDocumentSnapshot> iterator() {
     return new QuerySnapshotIterator(snapshot.getDocuments().iterator());
   }
 
   /**
-   * Returns the contents of the documents in the QuerySnapshot, converted to the provided class, as
-   * a list.
+   * Returns the contents of the documents in the {@code QuerySnapshot}, converted to the provided
+   * class, as a list.
    *
    * @param clazz The POJO type used to convert the documents in the list.
    */
   @NonNull
-  @PublicApi
   public <T> List<T> toObjects(@NonNull Class<T> clazz) {
     return toObjects(clazz, DocumentSnapshot.ServerTimestampBehavior.DEFAULT);
   }
 
   /**
-   * Returns the contents of the documents in the QuerySnapshot, converted to the provided class, as
-   * a list.
+   * Returns the contents of the documents in the {@code QuerySnapshot}, converted to the provided
+   * class, as a list.
    *
    * @param clazz The POJO type used to convert the documents in the list.
    * @param serverTimestampBehavior Configures the behavior for server timestamps that have not yet
    *     been set to their final value.
    */
   @NonNull
-  @PublicApi
   public <T> List<T> toObjects(
       @NonNull Class<T> clazz,
       @NonNull DocumentSnapshot.ServerTimestampBehavior serverTimestampBehavior) {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/ServerTimestamp.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/ServerTimestamp.java
index bba882933..72d5848a1 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/ServerTimestamp.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/ServerTimestamp.java
@@ -14,7 +14,6 @@
 
 package com.google.firebase.firestore;
 
-import com.google.firebase.annotations.PublicApi;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -22,10 +21,9 @@
 
 /**
  * Annotation used to mark a timestamp field to be populated with a server timestamp. If a POJO
- * being written contains null for a @ServerTimestamp-annotated field, it will be replaced with a
- * server-generated timestamp.
+ * being written contains {@code null} for a @ServerTimestamp-annotated field, it will be replaced
+ * with a server-generated timestamp.
  */
-@PublicApi
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.FIELD})
 public @interface ServerTimestamp {}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/SetOptions.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/SetOptions.java
index 273c6b056..f0dd15281 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/SetOptions.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/SetOptions.java
@@ -16,22 +16,21 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.RestrictTo;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RestrictTo;
 import com.google.firebase.firestore.model.mutation.FieldMask;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
 /**
- * An options object that configures the behavior of set() calls. By providing one of the SetOptions
- * objects returned by {@link #merge}, {@link #mergeFields} and {@link #mergeFieldPaths}, the set()
- * calls in {@link DocumentReference}, {@link WriteBatch} and {@link Transaction} can be configured
- * to perform granular merges instead of overwriting the target documents in their entirety.
+ * An options object that configures the behavior of {@code set()} calls. By providing one of the
+ * SetOptions objects returned by {@link #merge}, {@link #mergeFields} and {@link #mergeFieldPaths},
+ * the {@code set()} calls in {@link DocumentReference}, {@link WriteBatch} and {@link Transaction}
+ * can be configured to perform granular merges instead of overwriting the target documents in their
+ * entirety.
  */
-@PublicApi
 public final class SetOptions {
 
   static final SetOptions OVERWRITE = new SetOptions(false, null);
@@ -59,27 +58,25 @@ public FieldMask getFieldMask() {
   }
 
   /**
-   * Changes the behavior of set() calls to only replace the values specified in its data argument.
-   * Fields omitted from the set() call will remain untouched.
+   * Changes the behavior of {@code set()} calls to only replace the values specified in its data
+   * argument. Fields omitted from the {@code set()} call will remain untouched.
    */
   @NonNull
-  @PublicApi
   public static SetOptions merge() {
     return MERGE_ALL_FIELDS;
   }
 
   /**
-   * Changes the behavior of set() calls to only replace the fields under fieldPaths. Any field that
-   * is not specified in fieldPaths is ignored and remains untouched.
+   * Changes the behavior of {@code set()} calls to only replace the given fields. Any field that is
+   * not specified in {@code fields} is ignored and remains untouched.
    *
-   * <p>It is an error to pass a SetOptions object to a set() call that is missing a value for any
-   * of the fields specified here.
+   * <p>It is an error to pass a {@code SetOptions} object to a {@code set()} call that is missing a
+   * value for any of the fields specified here.
    *
    * @param fields The list of fields to merge. Fields can contain dots to reference nested fields
    *     within the document.
    */
   @NonNull
-  @PublicApi
   public static SetOptions mergeFields(@NonNull List<String> fields) {
     Set<com.google.firebase.firestore.model.FieldPath> fieldPaths = new HashSet<>();
 
@@ -91,17 +88,16 @@ public static SetOptions mergeFields(@NonNull List<String> fields) {
   }
 
   /**
-   * Changes the behavior of set() calls to only replace the fields under fieldPaths. Any field that
-   * is not specified in fieldPaths is ignored and remains untouched.
+   * Changes the behavior of {@code set()} calls to only replace the given fields. Any field that is
+   * not specified in {@code fields} is ignored and remains untouched.
    *
-   * <p>It is an error to pass a SetOptions object to a set() call that is missing a value for any
-   * of the fields specified here.
+   * <p>It is an error to pass a {@code SetOptions} object to a {@code set()} call that is missing a
+   * value for any of the fields specified here.
    *
    * @param fields The list of fields to merge. Fields can contain dots to reference nested fields
    *     within the document.
    */
   @NonNull
-  @PublicApi
   public static SetOptions mergeFields(String... fields) {
     Set<com.google.firebase.firestore.model.FieldPath> fieldPaths = new HashSet<>();
 
@@ -113,16 +109,15 @@ public static SetOptions mergeFields(String... fields) {
   }
 
   /**
-   * Changes the behavior of set() calls to only replace the fields under fieldPaths. Any field that
-   * is not specified in fieldPaths is ignored and remains untouched.
+   * Changes the behavior of {@code set()} calls to only replace the given fields. Any field that is
+   * not specified in {@code fields} is ignored and remains untouched.
    *
-   * <p>It is an error to pass a SetOptions object to a set() call that is missing a value for any
-   * of the fields specified here in its to data argument.
+   * <p>It is an error to pass a {@code SetOptions} object to a {@code set()} call that is missing a
+   * value for any of the fields specified here in its to data argument.
    *
    * @param fields The list of fields to merge.
    */
   @NonNull
-  @PublicApi
   public static SetOptions mergeFieldPaths(@NonNull List<FieldPath> fields) {
     Set<com.google.firebase.firestore.model.FieldPath> fieldPaths = new HashSet<>();
 
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/SnapshotMetadata.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/SnapshotMetadata.java
index ded3a298c..27475edc4 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/SnapshotMetadata.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/SnapshotMetadata.java
@@ -14,17 +14,15 @@
 
 package com.google.firebase.firestore;
 
-import com.google.firebase.annotations.PublicApi;
-import javax.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 /**
  * Metadata about a snapshot, describing the state of the snapshot.
  *
- * <p><b>Subclassing Note</b>: Firestore classes are not meant to be subclassed except for use in
- * test mocks. Subclassing is not supported in production code and new SDK releases may break code
- * that does so.
+ * <p><b>Subclassing Note</b>: Cloud Firestore classes are not meant to be subclassed except for use
+ * in test mocks. Subclassing is not supported in production code and new SDK releases may break
+ * code that does so.
  */
-@PublicApi
 public class SnapshotMetadata {
   private final boolean hasPendingWrites;
   private final boolean isFromCache;
@@ -35,23 +33,22 @@
   }
 
   /**
-   * @return true if the snapshot contains the result of local writes (e.g. set() or update() calls)
-   *     that have not yet been committed to the backend. If your listener has opted into metadata
-   *     updates (via `MetadataChanges.INCLUDE`) you will receive another snapshot with
-   *     `hasPendingWrites()` equal to false once the writes have been committed to the backend.
+   * @return true if the snapshot contains the result of local writes (for example, {@code set()} or
+   *     {@code update()} calls) that have not yet been committed to the backend. If your listener
+   *     has opted into metadata updates (via {@link MetadataChanges#INCLUDE}) you will receive
+   *     another snapshot with {@code hasPendingWrites()} equal to false once the writes have been
+   *     committed to the backend.
    */
-  @PublicApi
   public boolean hasPendingWrites() {
     return hasPendingWrites;
   }
 
   /**
    * @return true if the snapshot was created from cached data rather than guaranteed up-to-date
-   *     server data. If your listener has opted into metadata updates (via
-   *     `MetadataChanges.INCLUDE`) you will receive another snapshot with `isFomCache()` equal to
-   *     false once the client has received up-to-date data from the backend.
+   *     server data. If your listener has opted into metadata updates (via {@link
+   *     MetadataChanges#INCLUDE}) you will receive another snapshot with {@code isFromCache()}
+   *     equal to false once the client has received up-to-date data from the backend.
    */
-  @PublicApi
   public boolean isFromCache() {
     return isFromCache;
   }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/Source.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/Source.java
index 335b7099d..8431b62fb 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/Source.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/Source.java
@@ -14,34 +14,31 @@
 
 package com.google.firebase.firestore;
 
-import com.google.firebase.annotations.PublicApi;
-
 /**
  * Configures the behavior of {@code get()} calls on {@link DocumentReference} and {@link Query}. By
- * providing a Source value, these methods can be configured to fetch results only from the server,
- * only from the local cache, or attempt to fetch results from the server and fall back to the cache
- * (which is the default).
+ * providing a {@code Source} value, these methods can be configured to fetch results only from the
+ * server, only from the local cache, or attempt to fetch results from the server and fall back to
+ * the cache (which is the default).
  */
-@PublicApi
 public enum Source {
   /**
-   * Causes Firestore to try to retrieve an up-to-date (server-retrieved) snapshot, but fall back to
-   * returning cached data if the server can't be reached.
+   * Causes Cloud Firestore to try to retrieve an up-to-date (server-retrieved) snapshot, but fall
+   * back to returning cached data if the server can't be reached.
    */
   DEFAULT,
 
   /**
-   * Causes Firestore to avoid the cache, generating an error if the server cannot be reached. Note
-   * that the cache will still be updated if the server request succeeds. Also note that
+   * Causes Cloud Firestore to avoid the cache, generating an error if the server cannot be reached.
+   * Note that the cache will still be updated if the server request succeeds. Also note that
    * latency-compensation still takes effect, so any pending write operations will be visible in the
    * returned data (merged into the server-provided data).
    */
   SERVER,
 
   /**
-   * Causes Firestore to immediately return a value from the cache, ignoring the server completely
-   * (implying that the returned value may be stale with respect to the value on the server). If
-   * there is no data in the cache to satisfy the {@code get()} call, {@link
+   * Causes Cloud Firestore to immediately return a value from the cache, ignoring the server
+   * completely (implying that the returned value may be stale with respect to the value on the
+   * server). If there is no data in the cache to satisfy the {@code get()} call, {@link
    * DocumentReference#get()} will return an error and {@link Query#get()} will return an empty
    * {@link QuerySnapshot} with no documents.
    */
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/ThrowOnExtraProperties.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/ThrowOnExtraProperties.java
index 9eb5db6fc..be00e1e39 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/ThrowOnExtraProperties.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/ThrowOnExtraProperties.java
@@ -14,7 +14,6 @@
 
 package com.google.firebase.firestore;
 
-import com.google.firebase.annotations.PublicApi;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -24,7 +23,6 @@
  * Properties that don't map to class fields when serializing to a class annotated with this
  * annotation cause an exception to be thrown.
  */
-@PublicApi
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE})
 public @interface ThrowOnExtraProperties {}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/Transaction.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/Transaction.java
index 8951d3c4b..f7a0e04f7 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/Transaction.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/Transaction.java
@@ -17,11 +17,10 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.firebase.firestore.util.Assert.fail;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.Tasks;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.firestore.core.UserData.ParsedSetData;
 import com.google.firebase.firestore.core.UserData.ParsedUpdateData;
 import com.google.firebase.firestore.model.Document;
@@ -35,16 +34,15 @@
 import java.util.concurrent.ExecutionException;
 
 /**
- * A Transaction is passed to a Function to provide the methods to read and write data within the
- * transaction context.
+ * A {@code Transaction} is passed to a Function to provide the methods to read and write data
+ * within the transaction context.
  *
- * <p><b>Subclassing Note</b>: Firestore classes are not meant to be subclassed except for use in
- * test mocks. Subclassing is not supported in production code and new SDK releases may break code
- * that does so.
+ * <p><b>Subclassing Note</b>: Cloud Firestore classes are not meant to be subclassed except for use
+ * in test mocks. Subclassing is not supported in production code and new SDK releases may break
+ * code that does so.
  *
  * @see FirebaseFirestore#runTransaction(Function)
  */
-@PublicApi
 public class Transaction {
   private final com.google.firebase.firestore.core.Transaction transaction;
   private final FirebaseFirestore firestore;
@@ -56,33 +54,31 @@
   }
 
   /**
-   * Overwrites the document referred to by the provided DocumentReference. If the document does not
-   * yet exist, it will be created. If a document already exists, it will be overwritten.
+   * Overwrites the document referred to by the provided {@code DocumentReference}. If the document
+   * does not yet exist, it will be created. If a document already exists, it will be overwritten.
    *
-   * @param documentRef The DocumentReference to overwrite.
+   * @param documentRef The {@code DocumentReference} to overwrite.
    * @param data The data to write to the document (e.g. a Map or a POJO containing the desired
    *     document contents).
-   * @return This Transaction instance. Used for chaining method calls.
+   * @return This {@code Transaction} instance. Used for chaining method calls.
    */
   @NonNull
-  @PublicApi
   public Transaction set(@NonNull DocumentReference documentRef, @NonNull Object data) {
     return set(documentRef, data, SetOptions.OVERWRITE);
   }
 
   /**
    * Writes to the document referred to by the provided DocumentReference. If the document does not
-   * yet exist, it will be created. If you pass {@link SetOptions}, the provided data can be merged
+   * yet exist, it will be created. If you pass {@code SetOptions}, the provided data can be merged
    * into an existing document.
    *
-   * @param documentRef The DocumentReference to overwrite.
+   * @param documentRef The {@code DocumentReference} to overwrite.
    * @param data The data to write to the document (e.g. a Map or a POJO containing the desired
    *     document contents).
    * @param options An object to configure the set behavior.
-   * @return This Transaction instance. Used for chaining method calls.
+   * @return This {@code Transaction} instance. Used for chaining method calls.
    */
   @NonNull
-  @PublicApi
   public Transaction set(
       @NonNull DocumentReference documentRef, @NonNull Object data, @NonNull SetOptions options) {
     firestore.validateReference(documentRef);
@@ -97,16 +93,15 @@ public Transaction set(
   }
 
   /**
-   * Updates fields in the document referred to by the provided DocumentReference. If no document
-   * exists yet, the update will fail.
+   * Updates fields in the document referred to by the provided {@code DocumentReference}. If no
+   * document exists yet, the update will fail.
    *
-   * @param documentRef The DocumentReference to update.
+   * @param documentRef The {@code DocumentReference} to update.
    * @param data A map of field / value pairs to update. Fields can contain dots to reference nested
    *     fields within the document.
-   * @return This Transaction instance. Used for chaining method calls.
+   * @return This {@code Transaction} instance. Used for chaining method calls.
    */
   @NonNull
-  @PublicApi
   public Transaction update(
       @NonNull DocumentReference documentRef, @NonNull Map<String, Object> data) {
     ParsedUpdateData parsedData = firestore.getDataConverter().parseUpdateData(data);
@@ -114,18 +109,17 @@ public Transaction update(
   }
 
   /**
-   * Updates fields in the document referred to by the provided DocumentReference. If no document
-   * exists yet, the update will fail.
+   * Updates fields in the document referred to by the provided {@code DocumentReference}. If no
+   * document exists yet, the update will fail.
    *
-   * @param documentRef The DocumentReference to update.
+   * @param documentRef The {@code DocumentReference} to update.
    * @param field The first field to update. Fields can contain dots to reference a nested field
    *     within the document.
    * @param value The first value
    * @param moreFieldsAndValues Additional field/value pairs.
-   * @return This Transaction instance. Used for chaining method calls.
+   * @return This {@code Transaction} instance. Used for chaining method calls.
    */
   @NonNull
-  @PublicApi
   public Transaction update(
       @NonNull DocumentReference documentRef,
       @NonNull String field,
@@ -141,17 +135,16 @@ public Transaction update(
   }
 
   /**
-   * Updates fields in the document referred to by the provided DocumentReference. If no document
-   * exists yet, the update will fail.
+   * Updates fields in the document referred to by the provided {@code DocumentReference}. If no
+   * document exists yet, the update will fail.
    *
-   * @param documentRef The DocumentReference to update.
+   * @param documentRef The {@code DocumentReference} to update.
    * @param fieldPath The first field to update.
    * @param value The first value
    * @param moreFieldsAndValues Additional field/value pairs.
-   * @return This Transaction instance. Used for chaining method calls.
+   * @return This {@code Transaction} instance. Used for chaining method calls.
    */
   @NonNull
-  @PublicApi
   public Transaction update(
       @NonNull DocumentReference documentRef,
       @NonNull FieldPath fieldPath,
@@ -174,13 +167,12 @@ private Transaction update(
   }
 
   /**
-   * Deletes the document referred to by the provided DocumentReference.
+   * Deletes the document referred to by the provided {@code DocumentReference}.
    *
-   * @param documentRef The DocumentReference to delete.
-   * @return This Transaction instance. Used for chaining method calls.
+   * @param documentRef The {@code DocumentReference} to delete.
+   * @return This {@code Transaction} instance. Used for chaining method calls.
    */
   @NonNull
-  @PublicApi
   public Transaction delete(@NonNull DocumentReference documentRef) {
     firestore.validateReference(documentRef);
     transaction.delete(documentRef.getKey());
@@ -188,11 +180,11 @@ public Transaction delete(@NonNull DocumentReference documentRef) {
   }
 
   /**
-   * Reads the document referenced by the provided DocumentReference
+   * Reads the document referenced by the provided {@code DocumentReference}
    *
-   * @param documentRef The DocumentReference to read.
-   * @return A Task that will be resolved with the contents of the Document at this
-   *     DocumentReference.
+   * @param documentRef The {@code DocumentReference} to read.
+   * @return A Task that will be resolved with the contents of the Document at this {@code
+   *     DocumentReference}.
    */
   private Task<DocumentSnapshot> getAsync(DocumentReference documentRef) {
     return transaction
@@ -223,13 +215,12 @@ public Transaction delete(@NonNull DocumentReference documentRef) {
   }
 
   /**
-   * Reads the document referenced by this DocumentReference
+   * Reads the document referenced by this {@code DocumentReference}
    *
-   * @param documentRef The DocumentReference to read.
-   * @return The contents of the Document at this DocumentReference.
+   * @param documentRef The {@code DocumentReference} to read.
+   * @return The contents of the Document at this {@code DocumentReference}.
    */
   @NonNull
-  @PublicApi
   public DocumentSnapshot get(@NonNull DocumentReference documentRef)
       throws FirebaseFirestoreException {
     firestore.validateReference(documentRef);
@@ -250,10 +241,8 @@ public DocumentSnapshot get(@NonNull DocumentReference documentRef)
    *
    * @see FirebaseFirestore#runTransaction(Function)
    */
-  @PublicApi
   public interface Function<TResult> {
     @Nullable
-    @PublicApi
     TResult apply(@NonNull Transaction transaction) throws FirebaseFirestoreException;
   }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/UserDataConverter.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/UserDataConverter.java
index 642796c07..628cf9d8b 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/UserDataConverter.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/UserDataConverter.java
@@ -17,7 +17,8 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.Nullable;
+import androidx.annotation.RestrictTo;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.FieldValue.ArrayRemoveFieldValue;
 import com.google.firebase.firestore.FieldValue.ArrayUnionFieldValue;
@@ -57,7 +58,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
-import javax.annotation.Nullable;
 
 /**
  * Helper for parsing raw user input (provided via the API) into internal model classes.
@@ -74,7 +74,7 @@ public UserDataConverter(DatabaseId databaseId) {
   }
 
   /**
-   * Parse document data from a non-merge set() call.
+   * Parse document data from a non-merge {@code set()} call.
    *
    * @param input A map or POJO object representing document data.
    */
@@ -85,10 +85,10 @@ public ParsedSetData parseSetData(Object input) {
   }
 
   /**
-   * Parse document data from a set() call with SetOptions.merge() set.
+   * Parse document data from a {@code set()} call with {@link SetOptions#merge()} set.
    *
    * @param input A map or POJO object representing document data.
-   * @param fieldMask A {@link FieldMask} object representing the fields to be merged.
+   * @param fieldMask A {@code FieldMask} object representing the fields to be merged.
    */
   public ParsedSetData parseMergeData(Object input, @Nullable FieldMask fieldMask) {
     ParseAccumulator accumulator = new ParseAccumulator(UserData.Source.MergeSet);
@@ -111,7 +111,7 @@ public ParsedSetData parseMergeData(Object input, @Nullable FieldMask fieldMask)
     }
   }
 
-  /** Parse update data from an update() call. */
+  /** Parse update data from an {@code update()} call. */
   public ParsedUpdateData parseUpdateData(Map<String, Object> data) {
     checkNotNull(data, "Provided update data must not be null.");
 
@@ -241,8 +241,8 @@ private ObjectValue convertAndParseDocumentData(Object input, ParseContext conte
    * @param input Data to be parsed.
    * @param context A context object representing the current path being parsed, the source of the
    *     data being parsed, etc.
-   * @return The parsed value, or null if the value was a FieldValue sentinel that should not be
-   *     included in the resulting parsed data.
+   * @return The parsed value, or {@code null} if the value was a FieldValue sentinel that should
+   *     not be included in the resulting parsed data.
    */
   @Nullable
   private FieldValue parseData(Object input, ParseContext context) {
@@ -380,8 +380,8 @@ private void parseSentinelFieldValue(
   /**
    * Helper to parse a scalar value (i.e. not a Map or List)
    *
-   * @return The parsed value, or null if the value was a FieldValue sentinel that should not be
-   *     included in the resulting parsed data.
+   * @return The parsed value, or {@code null} if the value was a FieldValue sentinel that should
+   *     not be included in the resulting parsed data.
    */
   @Nullable
   private FieldValue parseScalarValue(Object input, ParseContext context) {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/WriteBatch.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/WriteBatch.java
index 21e368ef8..9667c15a2 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/WriteBatch.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/WriteBatch.java
@@ -16,11 +16,10 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.Tasks;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.firestore.core.UserData.ParsedSetData;
 import com.google.firebase.firestore.core.UserData.ParsedUpdateData;
 import com.google.firebase.firestore.model.mutation.DeleteMutation;
@@ -40,11 +39,10 @@
  * <p>Unlike transactions, write batches are persisted offline and therefore are preferable when you
  * don't need to condition your writes on read data.
  *
- * <p><b>Subclassing Note</b>: Firestore classes are not meant to be subclassed except for use in
- * test mocks. Subclassing is not supported in production code and new SDK releases may break code
- * that does so.
+ * <p><b>Subclassing Note</b>: Cloud Firestore classes are not meant to be subclassed except for use
+ * in test mocks. Subclassing is not supported in production code and new SDK releases may break
+ * code that does so.
  */
-@PublicApi
 public class WriteBatch {
   private final FirebaseFirestore firestore;
   private final ArrayList<Mutation> mutations = new ArrayList<>();
@@ -55,33 +53,31 @@
   }
 
   /**
-   * Overwrites the document referred to by the provided DocumentReference. If the document does not
-   * yet exist, it will be created. If a document already exists, it will be overwritten.
+   * Overwrites the document referred to by the provided {@code DocumentReference}. If the document
+   * does not yet exist, it will be created. If a document already exists, it will be overwritten.
    *
-   * @param documentRef The DocumentReference to overwrite.
+   * @param documentRef The {@code DocumentReference} to overwrite.
    * @param data The data to write to the document (e.g. a Map or a POJO containing the desired
    *     document contents).
-   * @return This WriteBatch instance. Used for chaining method calls.
+   * @return This {@code WriteBatch} instance. Used for chaining method calls.
    */
   @NonNull
-  @PublicApi
   public WriteBatch set(@NonNull DocumentReference documentRef, @NonNull Object data) {
     return set(documentRef, data, SetOptions.OVERWRITE);
   }
 
   /**
-   * Writes to the document referred to by the provided DocumentReference. If the document does not
-   * yet exist, it will be created. If you pass {@link SetOptions}, the provided data can be merged
-   * into an existing document.
+   * Writes to the document referred to by the provided {@code DocumentReference}. If the document
+   * does not yet exist, it will be created. If you pass {@code SetOptions}, the provided data can
+   * be merged into an existing document.
    *
-   * @param documentRef The DocumentReference to overwrite.
+   * @param documentRef The {@code DocumentReference} to overwrite.
    * @param data The data to write to the document (e.g. a Map or a POJO containing the desired
    *     document contents).
    * @param options An object to configure the set behavior.
-   * @return This WriteBatch instance. Used for chaining method calls.
+   * @return This {@code WriteBatch} instance. Used for chaining method calls.
    */
   @NonNull
-  @PublicApi
   public WriteBatch set(
       @NonNull DocumentReference documentRef, @NonNull Object data, @NonNull SetOptions options) {
     firestore.validateReference(documentRef);
@@ -97,16 +93,15 @@ public WriteBatch set(
   }
 
   /**
-   * Updates fields in the document referred to by the provided DocumentReference. If no document
-   * exists yet, the update will fail.
+   * Updates fields in the document referred to by the provided {@code DocumentReference}. If no
+   * document exists yet, the update will fail.
    *
-   * @param documentRef The DocumentReference to update.
+   * @param documentRef The {@code DocumentReference} to update.
    * @param data A map of field / value pairs to update. Fields can contain dots to reference nested
    *     fields within the document.
-   * @return This WriteBatch instance. Used for chaining method calls.
+   * @return This {@code WriteBatch} instance. Used for chaining method calls.
    */
   @NonNull
-  @PublicApi
   public WriteBatch update(
       @NonNull DocumentReference documentRef, @NonNull Map<String, Object> data) {
     ParsedUpdateData parsedData = firestore.getDataConverter().parseUpdateData(data);
@@ -114,18 +109,17 @@ public WriteBatch update(
   }
 
   /**
-   * Updates field in the document referred to by the provided DocumentReference. If no document
-   * exists yet, the update will fail.
+   * Updates field in the document referred to by the provided {@code DocumentReference}. If no
+   * document exists yet, the update will fail.
    *
-   * @param documentRef The DocumentReference to update.
+   * @param documentRef The {@code DocumentReference} to update.
    * @param field The first field to update. Fields can contain dots to reference a nested field
    *     within the document.
    * @param value The first value
    * @param moreFieldsAndValues Additional field/value pairs.
-   * @return This WriteBatch instance. Used for chaining method calls.
+   * @return This {@code WriteBatch} instance. Used for chaining method calls.
    */
   @NonNull
-  @PublicApi
   public WriteBatch update(
       @NonNull DocumentReference documentRef,
       @NonNull String field,
@@ -141,17 +135,16 @@ public WriteBatch update(
   }
 
   /**
-   * Updates fields in the document referred to by the provided DocumentReference. If no document
-   * exists yet, the update will fail.
+   * Updates fields in the document referred to by the provided {@code DocumentReference}. If no
+   * document exists yet, the update will fail.
    *
-   * @param documentRef The DocumentReference to update.
+   * @param documentRef The {@code DocumentReference} to update.
    * @param fieldPath The first field to update.
    * @param value The first value
    * @param moreFieldsAndValues Additional field/value pairs.
-   * @return This WriteBatch instance. Used for chaining method calls.
+   * @return This {@code WriteBatch} instance. Used for chaining method calls.
    */
   @NonNull
-  @PublicApi
   public WriteBatch update(
       @NonNull DocumentReference documentRef,
       @NonNull FieldPath fieldPath,
@@ -175,13 +168,12 @@ private WriteBatch update(
   }
 
   /**
-   * Deletes the document referred to by the provided DocumentReference.
+   * Deletes the document referred to by the provided {@code DocumentReference}.
    *
-   * @param documentRef The DocumentReference to delete.
-   * @return This WriteBatch instance. Used for chaining method calls.
+   * @param documentRef The {@code DocumentReference} to delete.
+   * @return This {@code WriteBatch} instance. Used for chaining method calls.
    */
   @NonNull
-  @PublicApi
   public WriteBatch delete(@NonNull DocumentReference documentRef) {
     firestore.validateReference(documentRef);
     verifyNotCommitted();
@@ -195,7 +187,6 @@ public WriteBatch delete(@NonNull DocumentReference documentRef) {
    * @return A Task that will be resolved when the write finishes.
    */
   @NonNull
-  @PublicApi
   public Task<Void> commit() {
     verifyNotCommitted();
     committed = true;
@@ -214,13 +205,12 @@ private void verifyNotCommitted() {
   }
 
   /**
-   * An interface for providing code to be executed within a {@link WriteBatch} context.
+   * An interface for providing code to be executed within a {@code WriteBatch} context.
    *
    * @see FirebaseFirestore#runBatch(WriteBatch.Function)
    */
-  @PublicApi
   public interface Function {
-    @PublicApi
+
     void apply(@NonNull WriteBatch batch);
   }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/FirebaseAuthCredentialsProvider.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/FirebaseAuthCredentialsProvider.java
index 52daf58ae..d02569884 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/FirebaseAuthCredentialsProvider.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/FirebaseAuthCredentialsProvider.java
@@ -14,7 +14,8 @@
 
 package com.google.firebase.firestore.auth;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.tasks.Task;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.auth.GetTokenResult;
@@ -23,7 +24,6 @@
 import com.google.firebase.firestore.FirebaseFirestoreException;
 import com.google.firebase.firestore.FirebaseFirestoreException.Code;
 import com.google.firebase.firestore.util.Listener;
-import javax.annotation.Nullable;
 
 /**
  * FirebaseAuthCredentialsProvider uses Firebase Auth via {@link FirebaseApp} to get an auth token.
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/Token.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/Token.java
index 7fddfea52..960f08232 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/Token.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/Token.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.firestore.auth;
 
-import javax.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 /**
  * The current User and the authentication token provided by the underlying authentication
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/User.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/User.java
index a074384e8..4aea25430 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/User.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/User.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.firestore.auth;
 
-import javax.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 /**
  * Simple wrapper around a nullable UID. Mostly exists to make code more readable and for use as a
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/package-info.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/package-info.java
index b7f9539ac..9f6721e3a 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/package-info.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.firestore.auth;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/ActivityScope.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/ActivityScope.java
index 37633325c..f18e15c27 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/ActivityScope.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/ActivityScope.java
@@ -17,11 +17,12 @@
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
 import android.app.Activity;
-import android.support.v4.app.FragmentActivity;
+import androidx.annotation.Nullable;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentActivity;
 import com.google.firebase.firestore.ListenerRegistration;
 import java.util.ArrayList;
 import java.util.List;
-import javax.annotation.Nullable;
 
 /**
  * Scopes the lifetime of a ListenerRegistration to an Activity.
@@ -63,7 +64,7 @@ synchronized void add(Runnable callback) {
     private final List<Runnable> callbacks = new ArrayList<>();
   }
 
-  public static class StopListenerSupportFragment extends android.support.v4.app.Fragment {
+  public static class StopListenerSupportFragment extends Fragment {
     CallbackList callbacks = new CallbackList();
 
     @Override
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/ArrayContainsAnyFilter.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/ArrayContainsAnyFilter.java
new file mode 100644
index 000000000..4caefac30
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/ArrayContainsAnyFilter.java
@@ -0,0 +1,42 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.core;
+
+import com.google.firebase.firestore.model.Document;
+import com.google.firebase.firestore.model.FieldPath;
+import com.google.firebase.firestore.model.value.ArrayValue;
+import com.google.firebase.firestore.model.value.FieldValue;
+
+/** A Filter that implements the array-contains-any operator. */
+public class ArrayContainsAnyFilter extends FieldFilter {
+  ArrayContainsAnyFilter(FieldPath field, FieldValue value) {
+    super(field, Operator.ARRAY_CONTAINS_ANY, value);
+  }
+
+  @Override
+  public boolean matches(Document doc) {
+    ArrayValue arrayValue = (ArrayValue) getValue();
+    FieldValue other = doc.getField(getField());
+    if (!(other instanceof ArrayValue)) {
+      return false;
+    }
+    for (FieldValue val : ((ArrayValue) other).getInternalValue()) {
+      if (arrayValue.getInternalValue().contains(val)) {
+        return true;
+      }
+    }
+    return false;
+  }
+}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/ArrayContainsFilter.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/ArrayContainsFilter.java
new file mode 100644
index 000000000..3a3a404d0
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/ArrayContainsFilter.java
@@ -0,0 +1,34 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.core;
+
+import com.google.firebase.firestore.model.Document;
+import com.google.firebase.firestore.model.FieldPath;
+import com.google.firebase.firestore.model.value.ArrayValue;
+import com.google.firebase.firestore.model.value.FieldValue;
+
+/** A Filter that implements the array-contains operator. */
+public class ArrayContainsFilter extends FieldFilter {
+  ArrayContainsFilter(FieldPath field, FieldValue value) {
+    super(field, Operator.ARRAY_CONTAINS, value);
+  }
+
+  @Override
+  public boolean matches(Document doc) {
+    FieldValue other = doc.getField(getField());
+    return other instanceof ArrayValue
+        && ((ArrayValue) other).getInternalValue().contains(getValue());
+  }
+}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/AsyncEventListener.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/AsyncEventListener.java
index 536e075d6..fb281a7eb 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/AsyncEventListener.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/AsyncEventListener.java
@@ -14,10 +14,10 @@
 
 package com.google.firebase.firestore.core;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.firestore.EventListener;
 import com.google.firebase.firestore.FirebaseFirestoreException;
 import java.util.concurrent.Executor;
-import javax.annotation.Nullable;
 
 /**
  * A wrapper event listener that uses an Executor to dispatch events. Exposes a mute() call to
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/EventManager.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/EventManager.java
index 38665628a..09c77c42d 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/EventManager.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/EventManager.java
@@ -14,13 +14,18 @@
 
 package com.google.firebase.firestore.core;
 
+import static com.google.firebase.firestore.util.Assert.hardAssert;
+
+import com.google.firebase.firestore.EventListener;
 import com.google.firebase.firestore.core.SyncEngine.SyncEngineCallback;
 import com.google.firebase.firestore.util.Util;
 import io.grpc.Status;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 /**
  * EventManager is responsible for mapping queries to query event listeners. It handles "fan-out."
@@ -54,6 +59,8 @@
 
   private final Map<Query, QueryListenersInfo> queries;
 
+  private final Set<EventListener<Void>> snapshotsInSyncListeners = new HashSet<>();
+
   private OnlineState onlineState = OnlineState.UNKNOWN;
 
   public EventManager(SyncEngine syncEngine) {
@@ -81,10 +88,16 @@ public int addQueryListener(QueryListener queryListener) {
 
     queryInfo.listeners.add(queryListener);
 
-    queryListener.onOnlineStateChanged(onlineState);
+    // Run global snapshot listeners if a consistent snapshot has been emitted.
+    boolean raisedEvent = queryListener.onOnlineStateChanged(onlineState);
+    hardAssert(
+        !raisedEvent, "onOnlineStateChanged() shouldn't raise an event for brand-new listeners.");
 
     if (queryInfo.viewSnapshot != null) {
-      queryListener.onViewSnapshot(queryInfo.viewSnapshot);
+      raisedEvent = queryListener.onViewSnapshot(queryInfo.viewSnapshot);
+      if (raisedEvent) {
+        raiseSnapshotsInSyncEvent();
+      }
     }
 
     if (firstListen) {
@@ -93,14 +106,13 @@ public int addQueryListener(QueryListener queryListener) {
     return queryInfo.targetId;
   }
 
-  /** Removes a previously added listener and returns true if the listener was found. */
-  public boolean removeQueryListener(QueryListener listener) {
+  /** Removes a previously added listener. It's a no-op if the listener is not found. */
+  public void removeQueryListener(QueryListener listener) {
     Query query = listener.getQuery();
     QueryListenersInfo queryInfo = queries.get(query);
     boolean lastListen = false;
-    boolean found = false;
     if (queryInfo != null) {
-      found = queryInfo.listeners.remove(listener);
+      queryInfo.listeners.remove(listener);
       lastListen = queryInfo.listeners.isEmpty();
     }
 
@@ -108,22 +120,42 @@ public boolean removeQueryListener(QueryListener listener) {
       queries.remove(query);
       syncEngine.stopListening(query);
     }
+  }
+
+  public void addSnapshotsInSyncListener(EventListener<Void> listener) {
+    snapshotsInSyncListeners.add(listener);
+    listener.onEvent(null, null);
+  }
 
-    return found;
+  public void removeSnapshotsInSyncListener(EventListener<Void> listener) {
+    snapshotsInSyncListeners.remove(listener);
+  }
+
+  /** Call all global snapshot listeners that have been set. */
+  private void raiseSnapshotsInSyncEvent() {
+    for (EventListener<Void> listener : snapshotsInSyncListeners) {
+      listener.onEvent(null, null);
+    }
   }
 
   @Override
   public void onViewSnapshots(List<ViewSnapshot> snapshotList) {
+    boolean raisedEvent = false;
     for (ViewSnapshot viewSnapshot : snapshotList) {
       Query query = viewSnapshot.getQuery();
       QueryListenersInfo info = queries.get(query);
       if (info != null) {
         for (QueryListener listener : info.listeners) {
-          listener.onViewSnapshot(viewSnapshot);
+          if (listener.onViewSnapshot(viewSnapshot)) {
+            raisedEvent = true;
+          }
         }
         info.viewSnapshot = viewSnapshot;
       }
     }
+    if (raisedEvent) {
+      raiseSnapshotsInSyncEvent();
+    }
   }
 
   @Override
@@ -139,11 +171,17 @@ public void onError(Query query, Status error) {
 
   @Override
   public void handleOnlineStateChange(OnlineState onlineState) {
+    boolean raisedEvent = false;
     this.onlineState = onlineState;
     for (QueryListenersInfo info : queries.values()) {
       for (QueryListener listener : info.listeners) {
-        listener.onOnlineStateChanged(onlineState);
+        if (listener.onOnlineStateChanged(onlineState)) {
+          raisedEvent = true;
+        }
       }
     }
+    if (raisedEvent) {
+      raiseSnapshotsInSyncEvent();
+    }
   }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/FieldFilter.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/FieldFilter.java
new file mode 100644
index 000000000..df30a5a4f
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/FieldFilter.java
@@ -0,0 +1,173 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.core;
+
+import static com.google.firebase.firestore.util.Assert.hardAssert;
+
+import com.google.firebase.firestore.model.Document;
+import com.google.firebase.firestore.model.FieldPath;
+import com.google.firebase.firestore.model.value.ArrayValue;
+import com.google.firebase.firestore.model.value.DoubleValue;
+import com.google.firebase.firestore.model.value.FieldValue;
+import com.google.firebase.firestore.model.value.NullValue;
+import com.google.firebase.firestore.model.value.ReferenceValue;
+import com.google.firebase.firestore.util.Assert;
+import java.util.Arrays;
+
+/** Represents a filter to be applied to query. */
+public class FieldFilter extends Filter {
+  private final Operator operator;
+
+  private final FieldValue value;
+
+  private final FieldPath field;
+
+  /**
+   * Creates a new filter that compares fields and values. Only intended to be called from
+   * Filter.create().
+   */
+  protected FieldFilter(FieldPath field, Operator operator, FieldValue value) {
+    this.field = field;
+    this.operator = operator;
+    this.value = value;
+  }
+
+  public Operator getOperator() {
+    return operator;
+  }
+
+  @Override
+  public FieldPath getField() {
+    return field;
+  }
+
+  public FieldValue getValue() {
+    return value;
+  }
+
+  /**
+   * Gets a Filter instance for the provided path, operator, and value.
+   *
+   * <p>Note that if the relation operator is EQUAL and the value is null or NaN, this will return
+   * the appropriate NullFilter or NaNFilter class instead of a FieldFilter.
+   */
+  public static FieldFilter create(FieldPath path, Operator operator, FieldValue value) {
+    if (path.isKeyField()) {
+      if (operator == Operator.IN) {
+        hardAssert(
+            value instanceof ArrayValue,
+            "Comparing on key with IN, but the value was not an ArrayValue");
+        return new KeyFieldInFilter(path, (ArrayValue) value);
+      } else {
+        hardAssert(
+            value instanceof ReferenceValue,
+            "Comparing on key, but filter value not a ReferenceValue");
+        hardAssert(
+            operator != Operator.ARRAY_CONTAINS && operator != Operator.ARRAY_CONTAINS_ANY,
+            operator.toString() + "queries don't make sense on document keys");
+        return new KeyFieldFilter(path, operator, (ReferenceValue) value);
+      }
+    } else if (value.equals(NullValue.nullValue())) {
+      if (operator != Filter.Operator.EQUAL) {
+        throw new IllegalArgumentException(
+            "Invalid Query. Null supports only equality comparisons (via whereEqualTo()).");
+      }
+      return new FieldFilter(path, operator, value);
+    } else if (value.equals(DoubleValue.NaN)) {
+      if (operator != Filter.Operator.EQUAL) {
+        throw new IllegalArgumentException(
+            "Invalid Query. NaN supports only equality comparisons (via whereEqualTo()).");
+      }
+      return new FieldFilter(path, operator, value);
+    } else if (operator == Operator.ARRAY_CONTAINS) {
+      return new ArrayContainsFilter(path, value);
+    } else if (operator == Operator.IN) {
+      hardAssert(value instanceof ArrayValue, "IN filter has invalid value: " + value.toString());
+      return new InFilter(path, (ArrayValue) value);
+    } else if (operator == Operator.ARRAY_CONTAINS_ANY) {
+      hardAssert(
+          value instanceof ArrayValue,
+          "ARRAY_CONTAINS_ANY filter has invalid value: " + value.toString());
+      return new ArrayContainsAnyFilter(path, (ArrayValue) value);
+    } else {
+      return new FieldFilter(path, operator, value);
+    }
+  }
+
+  @Override
+  public boolean matches(Document doc) {
+    FieldValue other = doc.getField(field);
+    // Only compare types with matching backend order (such as double and int).
+    return other != null
+        && value.typeOrder() == other.typeOrder()
+        && this.matchesComparison(other.compareTo(value));
+  }
+
+  protected boolean matchesComparison(int comp) {
+    switch (operator) {
+      case LESS_THAN:
+        return comp < 0;
+      case LESS_THAN_OR_EQUAL:
+        return comp <= 0;
+      case EQUAL:
+        return comp == 0;
+      case GREATER_THAN:
+        return comp > 0;
+      case GREATER_THAN_OR_EQUAL:
+        return comp >= 0;
+      default:
+        throw Assert.fail("Unknown FieldFilter operator: %s", operator);
+    }
+  }
+
+  public boolean isInequality() {
+    return Arrays.asList(
+            Operator.LESS_THAN,
+            Operator.LESS_THAN_OR_EQUAL,
+            Operator.GREATER_THAN,
+            Operator.GREATER_THAN_OR_EQUAL)
+        .contains(operator);
+  }
+
+  @Override
+  public String getCanonicalId() {
+    // TODO: Technically, this won't be unique if two values have the same description,
+    // such as the int 3 and the string "3". So we should add the types in here somehow, too.
+    return getField().canonicalString() + getOperator().toString() + getValue().toString();
+  }
+
+  @Override
+  public String toString() {
+    return field.canonicalString() + " " + operator + " " + value;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o == null || !(o instanceof FieldFilter)) {
+      return false;
+    }
+    FieldFilter other = (FieldFilter) o;
+    return operator == other.operator && field.equals(other.field) && value.equals(other.value);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 37;
+    result = 31 * result + operator.hashCode();
+    result = 31 * result + field.hashCode();
+    result = 31 * result + value.hashCode();
+    return result;
+  }
+}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/Filter.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/Filter.java
index 1687fc1ee..f1487ff8a 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/Filter.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/Filter.java
@@ -16,9 +16,6 @@
 
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.FieldPath;
-import com.google.firebase.firestore.model.value.DoubleValue;
-import com.google.firebase.firestore.model.value.FieldValue;
-import com.google.firebase.firestore.model.value.NullValue;
 
 /** Interface used for all query filters. */
 public abstract class Filter {
@@ -28,7 +25,9 @@
     EQUAL("=="),
     GREATER_THAN(">"),
     GREATER_THAN_OR_EQUAL(">="),
-    ARRAY_CONTAINS("array_contains");
+    ARRAY_CONTAINS("array_contains"),
+    ARRAY_CONTAINS_ANY("array_contains_any"),
+    IN("in");
 
     private final String text;
 
@@ -42,32 +41,6 @@ public String toString() {
     }
   }
 
-  /**
-   * Gets a Filter instance for the provided path, operator, and value.
-   *
-   * <p>Note that if the relation operator is EQUAL and the value is null or NaN, this will return
-   * the appropriate NullFilter or NaNFilter class instead of a RelationFilter.
-   */
-  public static Filter create(FieldPath path, Operator operator, FieldValue value) {
-    if (value.equals(NullValue.nullValue())) {
-      if (operator != Filter.Operator.EQUAL) {
-        throw new IllegalArgumentException(
-            "Invalid Query. You can only perform equality comparisons on null (via "
-                + "whereEqualTo()).");
-      }
-      return new NullFilter(path);
-    } else if (value.equals(DoubleValue.NaN)) {
-      if (operator != Filter.Operator.EQUAL) {
-        throw new IllegalArgumentException(
-            "Invalid Query. You can only perform equality comparisons on NaN (via "
-                + "whereEqualTo()).");
-      }
-      return new NaNFilter(path);
-    } else {
-      return new RelationFilter(path, operator, value);
-    }
-  }
-
   /** Returns the field the Filter operates over. */
   public abstract FieldPath getField();
 
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/FirestoreClient.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/FirestoreClient.java
index b856cedff..09560da2a 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/FirestoreClient.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/FirestoreClient.java
@@ -17,7 +17,7 @@
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
 import android.content.Context;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.android.gms.tasks.Tasks;
@@ -37,7 +37,9 @@
 import com.google.firebase.firestore.local.LruGarbageCollector;
 import com.google.firebase.firestore.local.MemoryPersistence;
 import com.google.firebase.firestore.local.Persistence;
+import com.google.firebase.firestore.local.QueryEngine;
 import com.google.firebase.firestore.local.SQLitePersistence;
+import com.google.firebase.firestore.local.SimpleQueryEngine;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.MaybeDocument;
@@ -75,7 +77,6 @@
   private RemoteStore remoteStore;
   private SyncEngine syncEngine;
   private EventManager eventManager;
-  private volatile boolean clientShutdown = false;
 
   // LRU-related
   @Nullable private LruGarbageCollector.Scheduler lruScheduler;
@@ -126,39 +127,39 @@ public FirestoreClient(
   }
 
   public Task<Void> disableNetwork() {
-    this.verifyNotShutdown();
+    this.verifyNotTerminated();
     return asyncQueue.enqueue(() -> remoteStore.disableNetwork());
   }
 
   public Task<Void> enableNetwork() {
-    this.verifyNotShutdown();
+    this.verifyNotTerminated();
     return asyncQueue.enqueue(() -> remoteStore.enableNetwork());
   }
 
-  /** Shuts down this client, cancels all writes / listeners, and releases all resources. */
-  public Task<Void> shutdown() {
+  /** Terminates this client, cancels all writes / listeners, and releases all resources. */
+  public Task<Void> terminate() {
     credentialsProvider.removeChangeListener();
-    return asyncQueue.enqueue(
+    return asyncQueue.enqueueAndInitiateShutdown(
         () -> {
-          if (!this.clientShutdown) {
-            remoteStore.shutdown();
-            persistence.shutdown();
-            if (lruScheduler != null) {
-              lruScheduler.stop();
-            }
-            this.clientShutdown = true;
+          remoteStore.shutdown();
+          persistence.shutdown();
+          if (lruScheduler != null) {
+            lruScheduler.stop();
           }
         });
   }
 
-  public boolean isShutdown() {
-    return this.clientShutdown;
+  /** Returns true if this client has been terminated. */
+  public boolean isTerminated() {
+    // Technically, the asyncQueue is still running, but only accepting tasks related to terminating
+    // or supposed to be run after terminate(). It is effectively terminated to the eyes of users.
+    return this.asyncQueue.isShuttingDown();
   }
 
   /** Starts listening to a query. */
   public QueryListener listen(
       Query query, ListenOptions options, EventListener<ViewSnapshot> listener) {
-    this.verifyNotShutdown();
+    this.verifyNotTerminated();
     QueryListener queryListener = new QueryListener(query, options, listener);
     asyncQueue.enqueueAndForget(() -> eventManager.addQueryListener(queryListener));
     return queryListener;
@@ -166,12 +167,16 @@ public QueryListener listen(
 
   /** Stops listening to a query previously listened to. */
   public void stopListening(QueryListener listener) {
-    this.verifyNotShutdown();
+    // Checks for terminate but does not raise error, allowing it to be a no-op if client is already
+    // terminated.
+    if (this.isTerminated()) {
+      return;
+    }
     asyncQueue.enqueueAndForget(() -> eventManager.removeQueryListener(listener));
   }
 
   public Task<Document> getDocumentFromLocalCache(DocumentKey docKey) {
-    this.verifyNotShutdown();
+    this.verifyNotTerminated();
     return asyncQueue
         .enqueue(() -> localStore.readDocument(docKey))
         .continueWith(
@@ -193,7 +198,7 @@ public void stopListening(QueryListener listener) {
   }
 
   public Task<ViewSnapshot> getDocumentsFromLocalCache(Query query) {
-    this.verifyNotShutdown();
+    this.verifyNotTerminated();
     return asyncQueue.enqueue(
         () -> {
           ImmutableSortedMap<DocumentKey, Document> docs = localStore.executeQuery(query);
@@ -210,7 +215,7 @@ public void stopListening(QueryListener listener) {
 
   /** Writes mutations. The returned task will be notified when it's written to the backend. */
   public Task<Void> write(final List<Mutation> mutations) {
-    this.verifyNotShutdown();
+    this.verifyNotTerminated();
     final TaskCompletionSource<Void> source = new TaskCompletionSource<>();
     asyncQueue.enqueueAndForget(() -> syncEngine.writeMutations(mutations, source));
     return source.getTask();
@@ -219,10 +224,21 @@ public void stopListening(QueryListener listener) {
   /** Tries to execute the transaction in updateFunction up to retries times. */
   public <TResult> Task<TResult> transaction(
       Function<Transaction, Task<TResult>> updateFunction, int retries) {
-    this.verifyNotShutdown();
+    this.verifyNotTerminated();
     return AsyncQueue.callTask(
-        asyncQueue.getExecutor(),
-        () -> syncEngine.transaction(asyncQueue, updateFunction, retries));
+        asyncQueue.getExecutor(), () -> syncEngine.transaction(asyncQueue, updateFunction));
+  }
+
+  /**
+   * Returns a task resolves when all the pending writes at the time when this method is called
+   * received server acknowledgement. An acknowledgement can be either acceptance or rejections.
+   */
+  public Task<Void> waitForPendingWrites() {
+    this.verifyNotTerminated();
+
+    final TaskCompletionSource<Void> source = new TaskCompletionSource<>();
+    asyncQueue.enqueueAndForget(() -> syncEngine.registerPendingWritesTask(source));
+    return source.getTask();
   }
 
   private void initialize(Context context, User user, boolean usePersistence, long cacheSizeBytes) {
@@ -252,7 +268,9 @@ private void initialize(Context context, User user, boolean usePersistence, long
     }
 
     persistence.start();
-    localStore = new LocalStore(persistence, user);
+    // TODO(index-free): Use IndexFreeQueryEngine/IndexedQueryEngine as appropriate.
+    QueryEngine queryEngine = new SimpleQueryEngine();
+    localStore = new LocalStore(persistence, queryEngine, user);
     if (gc != null) {
       lruScheduler = gc.newScheduler(asyncQueue, localStore);
       lruScheduler.start();
@@ -271,9 +289,21 @@ private void initialize(Context context, User user, boolean usePersistence, long
     remoteStore.start();
   }
 
-  private void verifyNotShutdown() {
-    if (this.clientShutdown) {
-      throw new IllegalArgumentException("The client has already been shutdown");
+  public void addSnapshotsInSyncListener(EventListener<Void> listener) {
+    verifyNotTerminated();
+    asyncQueue.enqueueAndForget(() -> eventManager.addSnapshotsInSyncListener(listener));
+  }
+
+  public void removeSnapshotsInSyncListener(EventListener<Void> listener) {
+    if (isTerminated()) {
+      return;
+    }
+    eventManager.removeSnapshotsInSyncListener(listener);
+  }
+
+  private void verifyNotTerminated() {
+    if (this.isTerminated()) {
+      throw new IllegalStateException("The client has already been terminated");
     }
   }
 
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/InFilter.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/InFilter.java
new file mode 100644
index 000000000..539d566db
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/InFilter.java
@@ -0,0 +1,34 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.core;
+
+import com.google.firebase.firestore.model.Document;
+import com.google.firebase.firestore.model.FieldPath;
+import com.google.firebase.firestore.model.value.ArrayValue;
+import com.google.firebase.firestore.model.value.FieldValue;
+
+/** A Filter that implements the IN operator. */
+public class InFilter extends FieldFilter {
+  InFilter(FieldPath field, ArrayValue value) {
+    super(field, Operator.IN, value);
+  }
+
+  @Override
+  public boolean matches(Document doc) {
+    ArrayValue arrayValue = (ArrayValue) getValue();
+    FieldValue other = doc.getField(getField());
+    return other != null && arrayValue.getInternalValue().contains(other);
+  }
+}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/IndexRange.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/IndexRange.java
index df360c3ca..18b0b569b 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/IndexRange.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/IndexRange.java
@@ -16,7 +16,7 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.firebase.firestore.model.FieldPath;
 import com.google.firebase.firestore.model.value.FieldValue;
 
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/KeyFieldFilter.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/KeyFieldFilter.java
new file mode 100644
index 000000000..3307d6760
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/KeyFieldFilter.java
@@ -0,0 +1,33 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.core;
+
+import com.google.firebase.firestore.model.Document;
+import com.google.firebase.firestore.model.FieldPath;
+import com.google.firebase.firestore.model.value.ReferenceValue;
+
+/** Filter that matches on key fields (i.e. '__name__'). */
+public class KeyFieldFilter extends FieldFilter {
+  KeyFieldFilter(FieldPath field, Operator operator, ReferenceValue value) {
+    super(field, operator, value);
+  }
+
+  @Override
+  public boolean matches(Document doc) {
+    ReferenceValue referenceValue = (ReferenceValue) getValue();
+    int comparator = doc.getKey().compareTo(referenceValue.value());
+    return this.matchesComparison(comparator);
+  }
+}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/KeyFieldInFilter.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/KeyFieldInFilter.java
new file mode 100644
index 000000000..2931e7418
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/KeyFieldInFilter.java
@@ -0,0 +1,46 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.core;
+
+import static com.google.firebase.firestore.util.Assert.hardAssert;
+
+import com.google.firebase.firestore.model.Document;
+import com.google.firebase.firestore.model.FieldPath;
+import com.google.firebase.firestore.model.value.ArrayValue;
+import com.google.firebase.firestore.model.value.FieldValue;
+import com.google.firebase.firestore.model.value.ReferenceValue;
+
+public class KeyFieldInFilter extends FieldFilter {
+  KeyFieldInFilter(FieldPath field, ArrayValue value) {
+    super(field, Operator.IN, value);
+    ArrayValue arrayValue = (ArrayValue) getValue();
+    for (FieldValue refValue : arrayValue.getInternalValue()) {
+      hardAssert(
+          refValue instanceof ReferenceValue,
+          "Comparing on key with IN, but an array value was not a ReferenceValue");
+    }
+  }
+
+  @Override
+  public boolean matches(Document doc) {
+    ArrayValue arrayValue = (ArrayValue) getValue();
+    for (FieldValue refValue : arrayValue.getInternalValue()) {
+      if (doc.getKey().equals(((ReferenceValue) refValue).value())) {
+        return true;
+      }
+    }
+    return false;
+  }
+}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/NaNFilter.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/NaNFilter.java
deleted file mode 100644
index acc26e6bf..000000000
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/NaNFilter.java
+++ /dev/null
@@ -1,66 +0,0 @@
-// Copyright 2018 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.google.firebase.firestore.core;
-
-import com.google.firebase.firestore.model.Document;
-import com.google.firebase.firestore.model.FieldPath;
-import com.google.firebase.firestore.model.value.DoubleValue;
-import com.google.firebase.firestore.model.value.FieldValue;
-
-/** Filter that matches NaN (not-a-number) fields. */
-public class NaNFilter extends Filter {
-  private final FieldPath fieldPath;
-
-  public NaNFilter(FieldPath fieldPath) {
-    this.fieldPath = fieldPath;
-  }
-
-  @Override
-  public FieldPath getField() {
-    return fieldPath;
-  }
-
-  @Override
-  public boolean matches(Document doc) {
-    FieldValue fieldValue = doc.getField(fieldPath);
-    return fieldValue != null && fieldValue.equals(DoubleValue.NaN);
-  }
-
-  @Override
-  public String getCanonicalId() {
-    return fieldPath.canonicalString() + " IS NaN";
-  }
-
-  @Override
-  public String toString() {
-    return getCanonicalId();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (o == null || !(o instanceof NaNFilter)) {
-      return false;
-    }
-    NaNFilter other = (NaNFilter) o;
-    return fieldPath.equals(other.fieldPath);
-  }
-
-  @Override
-  public int hashCode() {
-    int result = 41;
-    result = 31 * result + fieldPath.hashCode();
-    return result;
-  }
-}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/NullFilter.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/NullFilter.java
deleted file mode 100644
index d16ab24f0..000000000
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/NullFilter.java
+++ /dev/null
@@ -1,66 +0,0 @@
-// Copyright 2018 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.google.firebase.firestore.core;
-
-import com.google.firebase.firestore.model.Document;
-import com.google.firebase.firestore.model.FieldPath;
-import com.google.firebase.firestore.model.value.FieldValue;
-import com.google.firebase.firestore.model.value.NullValue;
-
-/** Filter that matches NULL values. */
-public class NullFilter extends Filter {
-  private final FieldPath fieldPath;
-
-  public NullFilter(FieldPath fieldPath) {
-    this.fieldPath = fieldPath;
-  }
-
-  @Override
-  public FieldPath getField() {
-    return fieldPath;
-  }
-
-  @Override
-  public boolean matches(Document doc) {
-    FieldValue fieldValue = doc.getField(fieldPath);
-    return fieldValue != null && fieldValue.equals(NullValue.nullValue());
-  }
-
-  @Override
-  public String getCanonicalId() {
-    return fieldPath.canonicalString() + " IS NULL";
-  }
-
-  @Override
-  public String toString() {
-    return getCanonicalId();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (o == null || !(o instanceof NullFilter)) {
-      return false;
-    }
-    NullFilter other = (NullFilter) o;
-    return fieldPath.equals(other.fieldPath);
-  }
-
-  @Override
-  public int hashCode() {
-    int result = 37;
-    result = 31 * result + fieldPath.hashCode();
-    return result;
-  }
-}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/Query.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/Query.java
index 9dac58d9c..b42064855 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/Query.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/Query.java
@@ -16,6 +16,7 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.firestore.core.Filter.Operator;
 import com.google.firebase.firestore.core.OrderBy.Direction;
 import com.google.firebase.firestore.model.Document;
@@ -28,7 +29,6 @@
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
-import javax.annotation.Nullable;
 
 /** Represents the internal structure of a Firestore Query */
 public final class Query {
@@ -117,6 +117,18 @@ public boolean isCollectionGroupQuery() {
     return collectionGroup != null;
   }
 
+  /**
+   * Returns true if this query does not specify any query constraints that could remove results.
+   */
+  public boolean matchesAllDocuments() {
+    return filters.isEmpty()
+        && limit == NO_LIMIT
+        && startAt == null
+        && endAt == null
+        && (getExplicitOrderBy().isEmpty()
+            || (getExplicitOrderBy().size() == 1 && getFirstOrderByField().isKeyField()));
+  }
+
   /** The filters on the documents returned by the query. */
   public List<Filter> getFilters() {
     return filters;
@@ -157,26 +169,31 @@ public FieldPath getFirstOrderByField() {
   @Nullable
   public FieldPath inequalityField() {
     for (Filter filter : filters) {
-      if (filter instanceof RelationFilter) {
-        RelationFilter relationFilter = (RelationFilter) filter;
-        if (relationFilter.isInequality()) {
-          return relationFilter.getField();
+      if (filter instanceof FieldFilter) {
+        FieldFilter fieldfilter = (FieldFilter) filter;
+        if (fieldfilter.isInequality()) {
+          return fieldfilter.getField();
         }
       }
     }
     return null;
   }
 
-  public boolean hasArrayContainsFilter() {
+  /**
+   * Checks if any of the provided filter operators are included in the query and returns the first
+   * one that is, or null if none are.
+   */
+  @Nullable
+  public Operator findFilterOperator(List<Operator> operators) {
     for (Filter filter : filters) {
-      if (filter instanceof RelationFilter) {
-        RelationFilter relationFilter = (RelationFilter) filter;
-        if (relationFilter.getOperator() == Operator.ARRAY_CONTAINS) {
-          return true;
+      if (filter instanceof FieldFilter) {
+        Operator filterOp = ((FieldFilter) filter).getOperator();
+        if (operators.contains(filterOp)) {
+          return filterOp;
         }
       }
     }
-    return false;
+    return null;
   }
 
   /**
@@ -188,7 +205,7 @@ public boolean hasArrayContainsFilter() {
   public Query filter(Filter filter) {
     hardAssert(!isDocumentQuery(), "No filter is allowed for document query");
     FieldPath newInequalityField = null;
-    if (filter instanceof RelationFilter && ((RelationFilter) filter).isInequality()) {
+    if (filter instanceof FieldFilter && ((FieldFilter) filter).isInequality()) {
       newInequalityField = filter.getField();
     }
 
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/QueryListener.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/QueryListener.java
index 4c5944293..b5201cfda 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/QueryListener.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/QueryListener.java
@@ -16,12 +16,12 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.firestore.EventListener;
 import com.google.firebase.firestore.FirebaseFirestoreException;
 import com.google.firebase.firestore.core.DocumentViewChange.Type;
 import java.util.ArrayList;
 import java.util.List;
-import javax.annotation.Nullable;
 
 /**
  * QueryListener takes a series of internal view snapshots and determines when to raise events.
@@ -59,11 +59,17 @@ public Query getQuery() {
     return query;
   }
 
-  public void onViewSnapshot(ViewSnapshot newSnapshot) {
+  /**
+   * Applies the new ViewSnapshot to this listener, raising a user-facing event if applicable
+   * (depending on what changed, whether the user has opted into metadata-only changes, etc.).
+   * Returns true if a user-facing event was indeed raised.
+   */
+  public boolean onViewSnapshot(ViewSnapshot newSnapshot) {
     hardAssert(
         !newSnapshot.getChanges().isEmpty() || newSnapshot.didSyncStateChange(),
         "We got a new snapshot with no changes?");
 
+    boolean raisedEvent = false;
     if (!options.includeDocumentMetadataChanges) {
       // Remove the metadata only changes
       List<DocumentViewChange> documentChanges = new ArrayList<>();
@@ -87,23 +93,30 @@ public void onViewSnapshot(ViewSnapshot newSnapshot) {
     if (!raisedInitialEvent) {
       if (shouldRaiseInitialEvent(newSnapshot, onlineState)) {
         raiseInitialEvent(newSnapshot);
+        raisedEvent = true;
       }
     } else if (shouldRaiseEvent(newSnapshot)) {
       listener.onEvent(newSnapshot, null);
+      raisedEvent = true;
     }
 
     this.snapshot = newSnapshot;
+    return raisedEvent;
   }
 
   public void onError(FirebaseFirestoreException error) {
     listener.onEvent(null, error);
   }
 
-  public void onOnlineStateChanged(OnlineState onlineState) {
+  /** Returns whether a snapshot was raised. */
+  public boolean onOnlineStateChanged(OnlineState onlineState) {
     this.onlineState = onlineState;
+    boolean raisedEvent = false;
     if (snapshot != null && !raisedInitialEvent && shouldRaiseInitialEvent(snapshot, onlineState)) {
       raiseInitialEvent(snapshot);
+      raisedEvent = true;
     }
+    return raisedEvent;
   }
 
   private boolean shouldRaiseInitialEvent(ViewSnapshot snapshot, OnlineState onlineState) {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/RelationFilter.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/RelationFilter.java
deleted file mode 100644
index 4a68b4322..000000000
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/RelationFilter.java
+++ /dev/null
@@ -1,134 +0,0 @@
-// Copyright 2018 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.google.firebase.firestore.core;
-
-import static com.google.firebase.firestore.util.Assert.hardAssert;
-
-import com.google.firebase.firestore.model.Document;
-import com.google.firebase.firestore.model.DocumentKey;
-import com.google.firebase.firestore.model.FieldPath;
-import com.google.firebase.firestore.model.value.ArrayValue;
-import com.google.firebase.firestore.model.value.FieldValue;
-import com.google.firebase.firestore.util.Assert;
-
-/** Represents a filter to be applied to query. */
-public class RelationFilter extends Filter {
-  private final Operator operator;
-
-  private final FieldValue value;
-
-  private final FieldPath field;
-
-  /**
-   * Creates a new filter that compares fields and values. Only intended to be called from
-   * Filter.create().
-   */
-  RelationFilter(FieldPath field, Operator operator, FieldValue value) {
-    this.field = field;
-    this.operator = operator;
-    this.value = value;
-  }
-
-  public Operator getOperator() {
-    return operator;
-  }
-
-  @Override
-  public FieldPath getField() {
-    return field;
-  }
-
-  public FieldValue getValue() {
-    return value;
-  }
-
-  @Override
-  public boolean matches(Document doc) {
-    if (this.field.isKeyField()) {
-      Object refValue = value.value();
-      hardAssert(
-          refValue instanceof DocumentKey, "Comparing on key, but filter value not a DocumentKey");
-      hardAssert(
-          operator != Operator.ARRAY_CONTAINS,
-          "ARRAY_CONTAINS queries don't make sense on document keys.");
-      int comparison = DocumentKey.comparator().compare(doc.getKey(), (DocumentKey) refValue);
-      return matchesComparison(comparison);
-    } else {
-      FieldValue value = doc.getField(field);
-      return value != null && matchesValue(doc.getField(field));
-    }
-  }
-
-  private boolean matchesValue(FieldValue other) {
-    if (operator == Operator.ARRAY_CONTAINS) {
-      return other instanceof ArrayValue && ((ArrayValue) other).getInternalValue().contains(value);
-    } else {
-      // Only compare types with matching backend order (such as double and int).
-      return value.typeOrder() == other.typeOrder()
-          && matchesComparison(other.compareTo(this.value));
-    }
-  }
-
-  private boolean matchesComparison(int comp) {
-    switch (operator) {
-      case LESS_THAN:
-        return comp < 0;
-      case LESS_THAN_OR_EQUAL:
-        return comp <= 0;
-      case EQUAL:
-        return comp == 0;
-      case GREATER_THAN:
-        return comp > 0;
-      case GREATER_THAN_OR_EQUAL:
-        return comp >= 0;
-      default:
-        throw Assert.fail("Unknown operator: %s", operator);
-    }
-  }
-
-  public boolean isInequality() {
-    return operator != Operator.EQUAL && operator != Operator.ARRAY_CONTAINS;
-  }
-
-  @Override
-  public String getCanonicalId() {
-    // TODO: Technically, this won't be unique if two values have the same description,
-    // such as the int 3 and the string "3". So we should add the types in here somehow, too.
-    return getField().canonicalString() + getOperator().toString() + getValue().toString();
-  }
-
-  @Override
-  public String toString() {
-    return field.canonicalString() + " " + operator + " " + value;
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (o == null || !(o instanceof RelationFilter)) {
-      return false;
-    }
-    RelationFilter other = (RelationFilter) o;
-    return operator == other.operator && field.equals(other.field) && value.equals(other.value);
-  }
-
-  @Override
-  public int hashCode() {
-    int result = 37;
-    result = 31 * result + operator.hashCode();
-    result = 31 * result + field.hashCode();
-    result = 31 * result + value.hashCode();
-    return result;
-  }
-}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/SyncEngine.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/SyncEngine.java
index 026ca5a2d..869bb92c7 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/SyncEngine.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/SyncEngine.java
@@ -17,15 +17,15 @@
 import static com.google.firebase.firestore.util.Assert.fail;
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
-import android.support.annotation.VisibleForTesting;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
-import com.google.android.gms.tasks.Tasks;
 import com.google.common.base.Function;
+import com.google.common.collect.Lists;
 import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.database.collection.ImmutableSortedSet;
 import com.google.firebase.firestore.FirebaseFirestoreException;
-import com.google.firebase.firestore.FirebaseFirestoreException.Code;
 import com.google.firebase.firestore.auth.User;
 import com.google.firebase.firestore.local.LocalStore;
 import com.google.firebase.firestore.local.LocalViewChanges;
@@ -39,6 +39,7 @@
 import com.google.firebase.firestore.model.NoDocument;
 import com.google.firebase.firestore.model.SnapshotVersion;
 import com.google.firebase.firestore.model.mutation.Mutation;
+import com.google.firebase.firestore.model.mutation.MutationBatch;
 import com.google.firebase.firestore.model.mutation.MutationBatchResult;
 import com.google.firebase.firestore.remote.RemoteEvent;
 import com.google.firebase.firestore.remote.RemoteStore;
@@ -53,7 +54,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import javax.annotation.Nullable;
 
 /**
  * SyncEngine is the central controller in the client SDK architecture. It is the glue code between
@@ -133,6 +133,9 @@
   /** Stores user completion blocks, indexed by user and batch ID. */
   private final Map<User, Map<Integer, TaskCompletionSource<Void>>> mutationUserCallbacks;
 
+  /** Stores user callbacks waiting for all pending writes to be acknowledged. */
+  private final Map<Integer, List<TaskCompletionSource<Void>>> pendingWritesCallbacks;
+
   /** Used for creating the target IDs for the listens used to resolve limbo documents. */
   private final TargetIdGenerator targetIdGenerator;
 
@@ -154,6 +157,8 @@ public SyncEngine(LocalStore localStore, RemoteStore remoteStore, User initialUs
     mutationUserCallbacks = new HashMap<>();
     targetIdGenerator = TargetIdGenerator.forSyncEngine();
     currentUser = initialUser;
+
+    pendingWritesCallbacks = new HashMap<>();
   }
 
   public void setCallback(SyncEngineCallback callback) {
@@ -186,9 +191,10 @@ public int listen(Query query) {
   private ViewSnapshot initializeViewAndComputeSnapshot(QueryData queryData) {
     Query query = queryData.getQuery();
 
-    ImmutableSortedMap<DocumentKey, Document> docs = localStore.executeQuery(query);
     ImmutableSortedSet<DocumentKey> remoteKeys =
         localStore.getRemoteDocumentKeys(queryData.getTargetId());
+    ImmutableSortedMap<DocumentKey, Document> docs =
+        localStore.executeQuery(query, queryData, remoteKeys);
 
     View view = new View(query, remoteKeys);
     View.DocumentChanges viewDocChanges = view.computeDocChanges(docs);
@@ -243,9 +249,10 @@ private void addUserCallback(int batchId, TaskCompletionSource<Void> userTask) {
   /**
    * Takes an updateFunction in which a set of reads and writes can be performed atomically. In the
    * updateFunction, the client can read and write values using the supplied transaction object.
-   * After the updateFunction, all changes will be committed. If some other client has changed any
-   * of the data referenced, then the updateFunction will be called again. If the updateFunction
-   * still fails after the given number of retries, then the transaction will be rejected.
+   * After the updateFunction, all changes will be committed. If a retryable error occurs (ex: some
+   * other client has changed any of the data referenced), then the updateFunction will be called
+   * again after a backoff. If the updateFunction still fails after all retries, then the
+   * transaction will be rejected.
    *
    * <p>The transaction object passed to the updateFunction contains methods for accessing documents
    * and collections. Unlike other datastore access, data accessed with the transaction will not
@@ -255,37 +262,8 @@ private void addUserCallback(int batchId, TaskCompletionSource<Void> userTask) {
    * <p>The Task returned is resolved when the transaction is fully committed.
    */
   public <TResult> Task<TResult> transaction(
-      AsyncQueue asyncQueue, Function<Transaction, Task<TResult>> updateFunction, int retries) {
-    hardAssert(retries >= 0, "Got negative number of retries for transaction.");
-    final Transaction transaction = remoteStore.createTransaction();
-    return updateFunction
-        .apply(transaction)
-        .continueWithTask(
-            asyncQueue.getExecutor(),
-            userTask -> {
-              if (!userTask.isSuccessful()) {
-                return userTask;
-              }
-              return transaction
-                  .commit()
-                  .continueWithTask(
-                      asyncQueue.getExecutor(),
-                      commitTask -> {
-                        if (commitTask.isSuccessful()) {
-                          return Tasks.forResult(userTask.getResult());
-                        }
-                        // TODO: Only retry on real transaction failures.
-                        if (retries == 0) {
-                          Exception e =
-                              new FirebaseFirestoreException(
-                                  "Transaction failed all retries.",
-                                  Code.ABORTED,
-                                  commitTask.getException());
-                          return Tasks.forException(e);
-                        }
-                        return transaction(asyncQueue, updateFunction, retries - 1);
-                      });
-            });
+      AsyncQueue asyncQueue, Function<Transaction, Task<TResult>> updateFunction) {
+    return new TransactionRunner<TResult>(asyncQueue, remoteStore, updateFunction).run();
   }
 
   /** Called by FirestoreClient to notify us of a new remote event. */
@@ -331,6 +309,7 @@ public void handleRemoteEvent(RemoteEvent event) {
   /** Applies an OnlineState change to the sync engine and notifies any views of the change. */
   @Override
   public void handleOnlineStateChange(OnlineState onlineState) {
+    assertCallback("handleOnlineStateChange");
     ArrayList<ViewSnapshot> newViewSnapshots = new ArrayList<>();
     for (Map.Entry<Query, QueryView> entry : queryViewsByQuery.entrySet()) {
       View view = entry.getValue().getView();
@@ -409,6 +388,8 @@ public void handleSuccessfulWrite(MutationBatchResult mutationBatchResult) {
     // they consistently happen before listen events.
     notifyUser(mutationBatchResult.getBatch().getBatchId(), /*status=*/ null);
 
+    resolvePendingWriteTasks(mutationBatchResult.getBatch().getBatchId());
+
     ImmutableSortedMap<DocumentKey, MaybeDocument> changes =
         localStore.acknowledgeBatch(mutationBatchResult);
 
@@ -429,9 +410,63 @@ public void handleRejectedWrite(int batchId, Status status) {
     // they consistently happen before listen events.
     notifyUser(batchId, status);
 
+    resolvePendingWriteTasks(batchId);
+
     emitNewSnapsAndNotifyLocalStore(changes, /*remoteEvent=*/ null);
   }
 
+  /**
+   * Takes a snapshot of current mutation queue, and register a user task which will resolve when
+   * all those mutations are either accepted or rejected by the server.
+   */
+  public void registerPendingWritesTask(TaskCompletionSource<Void> userTask) {
+    if (!remoteStore.canUseNetwork()) {
+      Logger.debug(
+          TAG,
+          "The network is disabled. The task returned by 'awaitPendingWrites()' will not "
+              + "complete until the network is enabled.");
+    }
+
+    int largestPendingBatchId = localStore.getHighestUnacknowledgedBatchId();
+
+    if (largestPendingBatchId == MutationBatch.UNKNOWN) {
+      // Complete the task right away if there is no pending writes at the moment.
+      userTask.setResult(null);
+      return;
+    }
+
+    if (pendingWritesCallbacks.containsKey(largestPendingBatchId)) {
+      pendingWritesCallbacks.get(largestPendingBatchId).add(userTask);
+    } else {
+      pendingWritesCallbacks.put(largestPendingBatchId, Lists.newArrayList(userTask));
+    }
+  }
+
+  /** Resolves tasks waiting for this batch id to get acknowledged by server, if there are any. */
+  private void resolvePendingWriteTasks(int batchId) {
+    if (pendingWritesCallbacks.containsKey(batchId)) {
+      for (TaskCompletionSource<Void> task : pendingWritesCallbacks.get(batchId)) {
+        task.setResult(null);
+      }
+
+      pendingWritesCallbacks.remove(batchId);
+    }
+  }
+
+  private void failOutstandingPendingWritesAwaitingTasks() {
+    for (Map.Entry<Integer, List<TaskCompletionSource<Void>>> entry :
+        pendingWritesCallbacks.entrySet()) {
+      for (TaskCompletionSource<Void> task : entry.getValue()) {
+        task.setException(
+            new FirebaseFirestoreException(
+                "'waitForPendingWrites' task is cancelled due to User change.",
+                FirebaseFirestoreException.Code.CANCELLED));
+      }
+    }
+
+    pendingWritesCallbacks.clear();
+  }
+
   /** Resolves the task corresponding to this write result. */
   private void notifyUser(int batchId, @Nullable Status status) {
     Map<Integer, TaskCompletionSource<Void>> userTasks = mutationUserCallbacks.get(currentUser);
@@ -496,7 +531,8 @@ private void emitNewSnapsAndNotifyLocalStore(
         // against the local store to make sure we didn't lose any good docs that had been past the
         // limit.
         ImmutableSortedMap<DocumentKey, Document> docs =
-            localStore.executeQuery(queryView.getQuery());
+            localStore.executeQuery(
+                queryView.getQuery(), /* queryData= */ null, DocumentKey.emptyKeySet());
         viewDocChanges = view.computeDocChanges(docs, viewDocChanges);
       }
       TargetChange targetChange =
@@ -564,6 +600,8 @@ public void handleCredentialChange(User user) {
     currentUser = user;
 
     if (userChanged) {
+      // Fails tasks waiting for pending writes requested by previous user.
+      failOutstandingPendingWritesAwaitingTasks();
       // Notify local store and emit any resulting events from swapping out the mutation queue.
       ImmutableSortedMap<DocumentKey, MaybeDocument> changes = localStore.handleUserChange(user);
       emitNewSnapsAndNotifyLocalStore(changes, /*remoteEvent=*/ null);
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/Transaction.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/Transaction.java
index 1986fef30..77abb13c7 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/Transaction.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/Transaction.java
@@ -15,7 +15,9 @@
 package com.google.firebase.firestore.core;
 
 import static com.google.firebase.firestore.util.Assert.fail;
+import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import androidx.annotation.Nullable;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.Tasks;
 import com.google.firebase.firestore.FirebaseFirestoreException;
@@ -37,11 +39,11 @@
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
 
 /**
  * Internal transaction object responsible for accumulating the mutations to perform and the base
@@ -53,31 +55,22 @@
   private final ArrayList<Mutation> mutations = new ArrayList<>();
   private boolean committed;
 
-  public Transaction(Datastore d) {
-    datastore = d;
-  }
+  /**
+   * A deferred usage error that occurred previously in this transaction that will cause the
+   * transaction to fail once it actually commits.
+   */
+  private FirebaseFirestoreException lastWriteError;
 
-  private void recordVersion(MaybeDocument doc) throws FirebaseFirestoreException {
-    SnapshotVersion docVersion;
-    if (doc instanceof Document) {
-      docVersion = doc.getVersion();
-    } else if (doc instanceof NoDocument) {
-      // For nonexistent docs, we must use precondition with version 0 when we overwrite them.
-      docVersion = SnapshotVersion.NONE;
-    } else {
-      throw fail("Unexpected document type in transaction: " + doc.getClass().getCanonicalName());
-    }
+  /**
+   * Set of documents that have been written in the transaction.
+   *
+   * <p>When there's more than one write to the same key in a transaction, any writes after the
+   * first are handled differently.
+   */
+  private Set<DocumentKey> writtenDocs = new HashSet<>();
 
-    if (readVersions.containsKey(doc.getKey())) {
-      SnapshotVersion existingVersion = readVersions.get(doc.getKey());
-      if (!existingVersion.equals(doc.getVersion())) {
-        // This transaction will fail no matter what.
-        throw new FirebaseFirestoreException(
-            "Document version changed between two reads.", Code.FAILED_PRECONDITION);
-      }
-    } else {
-      readVersions.put(doc.getKey(), docVersion);
-    }
+  public Transaction(Datastore d) {
+    datastore = d;
   }
 
   /**
@@ -85,15 +78,13 @@ private void recordVersion(MaybeDocument doc) throws FirebaseFirestoreException
    * ignoring any local changes.
    */
   public Task<List<MaybeDocument>> lookup(List<DocumentKey> keys) {
-    if (committed) {
-      return Tasks.forException(
-          new FirebaseFirestoreException(
-              "Transaction has already completed.", Code.FAILED_PRECONDITION));
-    }
+    ensureCommitNotCalled();
+
     if (mutations.size() != 0) {
       return Tasks.forException(
           new FirebaseFirestoreException(
-              "Transactions lookups are invalid after writes.", Code.FAILED_PRECONDITION));
+              "Firestore transactions require all reads to be executed before all writes.",
+              Code.INVALID_ARGUMENT));
     }
     return datastore
         .lookup(keys)
@@ -109,47 +100,10 @@ private void recordVersion(MaybeDocument doc) throws FirebaseFirestoreException
             });
   }
 
-  private void write(List<Mutation> mutations) {
-    if (committed) {
-      throw new IllegalStateException("Transaction has already completed.");
-    }
-    this.mutations.addAll(mutations);
-  }
-
-  /**
-   * Returns version of this doc when it was read in this transaction as a precondition, or no
-   * precondition if it was not read.
-   */
-  private Precondition precondition(DocumentKey key) {
-    @Nullable SnapshotVersion version = readVersions.get(key);
-    if (version != null) {
-      return Precondition.updateTime(version);
-    } else {
-      return Precondition.NONE;
-    }
-  }
-
-  /**
-   * Returns the precondition for a document if the operation is an update, based on the provided
-   * UpdateOptions.
-   */
-  private Precondition preconditionForUpdate(DocumentKey key) {
-    @Nullable SnapshotVersion version = this.readVersions.get(key);
-    if (version != null && version.equals(SnapshotVersion.NONE)) {
-      // The document to update doesn't exist, so fail the transaction.
-      throw new IllegalStateException("Can't update a document that doesn't exist.");
-    } else if (version != null) {
-      // Document exists, base precondition on document update time.
-      return Precondition.updateTime(version);
-    } else {
-      // Document was not read, so we just use the preconditions for a blind write.
-      return Precondition.exists(true);
-    }
-  }
-
   /** Stores a set mutation for the given key and value, to be committed when commit() is called. */
   public void set(DocumentKey key, ParsedSetData data) {
     write(data.toMutationList(key, precondition(key)));
+    writtenDocs.add(key);
   }
 
   /**
@@ -157,22 +111,26 @@ public void set(DocumentKey key, ParsedSetData data) {
    * called.
    */
   public void update(DocumentKey key, ParsedUpdateData data) {
-    write(data.toMutationList(key, preconditionForUpdate(key)));
+    try {
+      write(data.toMutationList(key, preconditionForUpdate(key)));
+    } catch (FirebaseFirestoreException e) {
+      lastWriteError = e;
+    }
+    this.writtenDocs.add(key);
   }
 
   public void delete(DocumentKey key) {
     write(Collections.singletonList(new DeleteMutation(key, precondition(key))));
-    // Since the delete will be applied before all following writes, we need to ensure that the
-    // precondition for the next write will be exists: false.
-    readVersions.put(key, SnapshotVersion.NONE);
+    writtenDocs.add(key);
   }
 
   public Task<Void> commit() {
-    if (committed) {
-      return Tasks.forException(
-          new FirebaseFirestoreException(
-              "Transaction has already completed.", Code.FAILED_PRECONDITION));
+    ensureCommitNotCalled();
+
+    if (lastWriteError != null) {
+      return Tasks.forException(lastWriteError);
     }
+
     HashSet<DocumentKey> unwritten = new HashSet<>(readVersions.keySet());
     // For each mutation, note that the doc was written.
     for (Mutation mutation : mutations) {
@@ -181,8 +139,7 @@ public void delete(DocumentKey key) {
     if (unwritten.size() > 0) {
       return Tasks.forException(
           new FirebaseFirestoreException(
-              "Every document read in a transaction must also be written.",
-              Code.FAILED_PRECONDITION));
+              "Every document read in a transaction must also be written.", Code.INVALID_ARGUMENT));
     }
     committed = true;
     return datastore
@@ -214,6 +171,83 @@ private static Executor createDefaultExecutor() {
     return executor;
   }
 
+  private void recordVersion(MaybeDocument doc) throws FirebaseFirestoreException {
+    SnapshotVersion docVersion;
+    if (doc instanceof Document) {
+      docVersion = doc.getVersion();
+    } else if (doc instanceof NoDocument) {
+      // For nonexistent docs, we must use precondition with version 0 when we overwrite them.
+      docVersion = SnapshotVersion.NONE;
+    } else {
+      throw fail("Unexpected document type in transaction: " + doc.getClass().getCanonicalName());
+    }
+
+    if (readVersions.containsKey(doc.getKey())) {
+      SnapshotVersion existingVersion = readVersions.get(doc.getKey());
+      if (!existingVersion.equals(doc.getVersion())) {
+        // This transaction will fail no matter what.
+        throw new FirebaseFirestoreException(
+            "Document version changed between two reads.", Code.ABORTED);
+      }
+    } else {
+      readVersions.put(doc.getKey(), docVersion);
+    }
+  }
+
+  /**
+   * Returns version of this doc when it was read in this transaction as a precondition, or no
+   * precondition if it was not read.
+   */
+  private Precondition precondition(DocumentKey key) {
+    @Nullable SnapshotVersion version = readVersions.get(key);
+    if (!writtenDocs.contains(key) && version != null) {
+      return Precondition.updateTime(version);
+    } else {
+      return Precondition.NONE;
+    }
+  }
+
+  /**
+   * Returns the precondition for a document if the operation is an update, based on the provided
+   * UpdateOptions.
+   */
+  private Precondition preconditionForUpdate(DocumentKey key) throws FirebaseFirestoreException {
+    @Nullable SnapshotVersion version = this.readVersions.get(key);
+    // The first time a document is written, we want to take into account the read time and
+    // existence.
+    if (!writtenDocs.contains(key) && version != null) {
+      if (version != null && version.equals(SnapshotVersion.NONE)) {
+        // The document to update doesn't exist, so fail the transaction.
+        //
+        // This has to be validated locally because you can't send a precondition that a document
+        // does not exist without changing the semantics of the backend write to be an insert. This
+        // is the reverse of what we want, since we want to assert that the document doesn't exist
+        // but then send the update and have it fail. Since we can't express that to the backend, we
+        // have to validate locally.
+        //
+        // Note: this can change once we can send separate verify writes in the transaction.
+        throw new FirebaseFirestoreException(
+            "Can't update a document that doesn't exist.", Code.INVALID_ARGUMENT);
+      }
+      // Document exists, base precondition on document update time.
+      return Precondition.updateTime(version);
+    } else {
+      // Document was not read, so we just use the preconditions for a blind write.
+      return Precondition.exists(true);
+    }
+  }
+
+  private void write(List<Mutation> mutations) {
+    ensureCommitNotCalled();
+    this.mutations.addAll(mutations);
+  }
+
+  private void ensureCommitNotCalled() {
+    hardAssert(
+        !committed,
+        "A transaction object cannot be used after its update callback has been invoked.");
+  }
+
   public static Executor getDefaultExecutor() {
     return defaultExecutor;
   }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/TransactionRunner.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/TransactionRunner.java
new file mode 100644
index 000000000..b0d5d8338
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/TransactionRunner.java
@@ -0,0 +1,106 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.core;
+
+import androidx.annotation.NonNull;
+import com.google.android.gms.tasks.Task;
+import com.google.android.gms.tasks.TaskCompletionSource;
+import com.google.common.base.Function;
+import com.google.firebase.firestore.FirebaseFirestoreException;
+import com.google.firebase.firestore.remote.Datastore;
+import com.google.firebase.firestore.remote.RemoteStore;
+import com.google.firebase.firestore.util.AsyncQueue;
+import com.google.firebase.firestore.util.AsyncQueue.TimerId;
+import com.google.firebase.firestore.util.ExponentialBackoff;
+
+/** TransactionRunner encapsulates the logic needed to run and retry transactions with backoff. */
+public class TransactionRunner<TResult> {
+  private static final int RETRY_COUNT = 5;
+  private AsyncQueue asyncQueue;
+  private RemoteStore remoteStore;
+  private Function<Transaction, Task<TResult>> updateFunction;
+  private int retriesLeft;
+
+  private ExponentialBackoff backoff;
+  private TaskCompletionSource<TResult> taskSource = new TaskCompletionSource<>();
+
+  public TransactionRunner(
+      AsyncQueue asyncQueue,
+      RemoteStore remoteStore,
+      Function<Transaction, Task<TResult>> updateFunction) {
+
+    this.asyncQueue = asyncQueue;
+    this.remoteStore = remoteStore;
+    this.updateFunction = updateFunction;
+    this.retriesLeft = RETRY_COUNT;
+
+    backoff = new ExponentialBackoff(asyncQueue, TimerId.RETRY_TRANSACTION);
+  }
+
+  /** Runs the transaction and returns a Task containing the result. */
+  public Task<TResult> run() {
+    runWithBackoff();
+    return taskSource.getTask();
+  }
+
+  private void runWithBackoff() {
+    backoff.backoffAndRun(
+        () -> {
+          final Transaction transaction = remoteStore.createTransaction();
+          updateFunction
+              .apply(transaction)
+              .addOnCompleteListener(
+                  asyncQueue.getExecutor(),
+                  (@NonNull Task<TResult> userTask) -> {
+                    if (!userTask.isSuccessful()) {
+                      handleTransactionError(userTask);
+                    } else {
+                      transaction
+                          .commit()
+                          .addOnCompleteListener(
+                              asyncQueue.getExecutor(),
+                              (@NonNull Task<Void> commitTask) -> {
+                                if (commitTask.isSuccessful()) {
+                                  taskSource.setResult(userTask.getResult());
+                                } else {
+                                  handleTransactionError(commitTask);
+                                }
+                              });
+                    }
+                  });
+        });
+  }
+
+  private void handleTransactionError(Task task) {
+    if (retriesLeft > 0 && isRetryableTransactionError(task.getException())) {
+      retriesLeft -= 1;
+      runWithBackoff();
+    } else {
+      taskSource.setException(task.getException());
+    }
+  }
+
+  private static boolean isRetryableTransactionError(Exception e) {
+    if (e instanceof FirebaseFirestoreException) {
+      // In transactions, the backend will fail outdated reads with FAILED_PRECONDITION and
+      // non-matching document versions with ABORTED. These errors should be retried.
+      FirebaseFirestoreException.Code code = ((FirebaseFirestoreException) e).getCode();
+      return code == FirebaseFirestoreException.Code.ABORTED
+          || code == FirebaseFirestoreException.Code.FAILED_PRECONDITION
+          || !Datastore.isPermanentError(((FirebaseFirestoreException) e).getCode());
+    }
+    return false;
+  }
+}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/UserData.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/UserData.java
index 0cb0f6149..495165341 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/UserData.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/UserData.java
@@ -16,6 +16,7 @@
 
 import static java.util.Collections.unmodifiableList;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.FieldPath;
 import com.google.firebase.firestore.model.mutation.FieldMask;
@@ -32,8 +33,6 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-import java.util.regex.Pattern;
-import javax.annotation.Nullable;
 
 public class UserData {
   private UserData() {} // Do not instantiate
@@ -192,8 +191,6 @@ public ParsedUpdateData toUpdateData(ObjectValue data) {
    */
   public static class ParseContext {
 
-    private final Pattern reservedFieldRegex = Pattern.compile("^__.*__$");
-
     private final ParseAccumulator accumulator;
 
     /** The current path being parsed. */
@@ -235,6 +232,7 @@ public Source getDataSource() {
       return accumulator.dataSource;
     }
 
+    @Nullable
     public FieldPath getPath() {
       return path;
     }
@@ -303,9 +301,17 @@ private void validatePath() {
       }
     }
 
+    private static final String RESERVED_FIELD_DESIGNATOR = "__";
+
     private void validatePathSegment(String segment) {
-      if (isWrite() && reservedFieldRegex.matcher(segment).find()) {
-        throw this.createError("Document fields cannot begin and end with __");
+      if (segment.isEmpty()) {
+        throw this.createError("Document fields must not be empty");
+      }
+
+      if (isWrite()
+          && segment.startsWith(RESERVED_FIELD_DESIGNATOR)
+          && segment.endsWith(RESERVED_FIELD_DESIGNATOR)) {
+        throw this.createError("Document fields cannot begin and end with \"__\"");
       }
     }
   }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/View.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/View.java
index db8c0194b..32d5e2a68 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/View.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/View.java
@@ -17,6 +17,7 @@
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 import static com.google.firebase.firestore.util.Util.compareIntegers;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.database.collection.ImmutableSortedSet;
 import com.google.firebase.firestore.core.DocumentViewChange.Type;
@@ -30,7 +31,6 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import javax.annotation.Nullable;
 
 /**
  * View is responsible for computing the final merged truth of what docs are in a query. It gets
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/package-info.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/package-info.java
index 5964e75c0..00e7bf033 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/package-info.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.firestore.core;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/IndexFreeQueryEngine.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/IndexFreeQueryEngine.java
new file mode 100644
index 000000000..5091667ae
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/IndexFreeQueryEngine.java
@@ -0,0 +1,180 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.local;
+
+import static com.google.firebase.firestore.util.Assert.hardAssert;
+
+import androidx.annotation.Nullable;
+import com.google.firebase.database.collection.ImmutableSortedMap;
+import com.google.firebase.database.collection.ImmutableSortedSet;
+import com.google.firebase.firestore.core.Query;
+import com.google.firebase.firestore.model.Document;
+import com.google.firebase.firestore.model.DocumentKey;
+import com.google.firebase.firestore.model.MaybeDocument;
+import com.google.firebase.firestore.model.SnapshotVersion;
+import com.google.firebase.firestore.util.Logger;
+import java.util.Collections;
+import java.util.Map;
+
+/**
+ * A query engine that takes advantage of the target document mapping in the QueryCache. The
+ * IndexFreeQueryEngine optimizes query execution by only reading the documents previously matched a
+ * query plus any documents that were edited after the query was last listened to.
+ *
+ * <p>There are some cases where Index-Free queries are not guaranteed to produce to the same
+ * results as full collection scans. In these case, the IndexFreeQueryEngine falls back to a full
+ * query processing. These cases are:
+ *
+ * <ol>
+ *   <li>Limit queries where a document that matched the query previously no longer matches the
+ *       query. In this case, we have to scan all local documents since a document that was sent to
+ *       us as part of a different query result may now fall into the limit.
+ *   <li>Limit queries that include edits that occurred after the last remote snapshot (both
+ *       latency-compensated or committed). Even if an edited document continues to match the query,
+ *       an edit may cause a document to sort below another document that is in the local cache.
+ *   <li>Queries where the last snapshot contained Limbo documents. Even though a Limbo document is
+ *       not part of the backend result set, we need to include Limbo documents in local views to
+ *       ensure consistency between different Query views. If there exists a previous query snapshot
+ *       that contained no limbo documents, we can instead use the older snapshot version for
+ *       Index-Free processing.
+ * </ol>
+ */
+public class IndexFreeQueryEngine implements QueryEngine {
+  private static final String LOG_TAG = "IndexFreeQueryEngine";
+
+  private LocalDocumentsView localDocumentsView;
+
+  @Override
+  public void setLocalDocumentsView(LocalDocumentsView localDocuments) {
+    this.localDocumentsView = localDocuments;
+  }
+
+  @Override
+  public ImmutableSortedMap<DocumentKey, Document> getDocumentsMatchingQuery(
+      Query query, @Nullable QueryData queryData, ImmutableSortedSet<DocumentKey> remoteKeys) {
+    hardAssert(localDocumentsView != null, "setLocalDocumentsView() not called");
+
+    // Queries that match all document don't benefit from using IndexFreeQueries. It is more
+    // efficient to scan all documents in a collection, rather than to perform individual lookups.
+    if (query.matchesAllDocuments()) {
+      return executeFullCollectionScan(query);
+    }
+
+    // Queries that have never seen a snapshot without limbo free documents should also be run as a
+    // full collection scan.
+    if (queryData == null
+        || queryData.getLastLimboFreeSnapshotVersion().equals(SnapshotVersion.NONE)) {
+      return executeFullCollectionScan(query);
+    }
+
+    ImmutableSortedSet<Document> previousResults = getSortedPreviousResults(query, remoteKeys);
+
+    if (query.hasLimit()
+        && needsRefill(previousResults, remoteKeys, queryData.getLastLimboFreeSnapshotVersion())) {
+      return executeFullCollectionScan(query);
+    }
+
+    if (Logger.isDebugEnabled()) {
+      Logger.debug(
+          LOG_TAG,
+          "Re-using previous result from %s to execute query: %s",
+          queryData.getLastLimboFreeSnapshotVersion().toString(),
+          query.toString());
+    }
+
+    // Retrieve all results for documents that were updated since the last limbo-document free
+    // remote snapshot.
+    ImmutableSortedMap<DocumentKey, Document> updatedResults =
+        localDocumentsView.getDocumentsMatchingQuery(
+            query, queryData.getLastLimboFreeSnapshotVersion());
+    for (Document result : previousResults) {
+      updatedResults = updatedResults.insert(result.getKey(), result);
+    }
+
+    return updatedResults;
+  }
+
+  /**
+   * Returns the documents for the specified remote keys if they still match the query, sorted by
+   * the query's comparator.
+   */
+  private ImmutableSortedSet<Document> getSortedPreviousResults(
+      Query query, ImmutableSortedSet<DocumentKey> remoteKeys) {
+    // Fetch the documents that matched the query at the last snapshot.
+    ImmutableSortedMap<DocumentKey, MaybeDocument> previousResults =
+        localDocumentsView.getDocuments(remoteKeys);
+
+    // Sort the documents and re-apply the query filter since previously matching documents do not
+    // necessarily still match the query.
+    ImmutableSortedSet<Document> results =
+        new ImmutableSortedSet<>(Collections.emptyList(), query.comparator());
+    for (Map.Entry<DocumentKey, MaybeDocument> entry : previousResults) {
+      MaybeDocument maybeDoc = entry.getValue();
+      if (maybeDoc instanceof Document && query.matches((Document) maybeDoc)) {
+        Document doc = (Document) maybeDoc;
+        results = results.insert(doc);
+      }
+    }
+    return results;
+  }
+
+  /**
+   * Determines if a limit query needs to be refilled from cache, making it ineligible for
+   * index-free execution.
+   *
+   * @param sortedPreviousResults The documents that matched the query when it was last
+   *     synchronized, sorted by the query's comparator.
+   * @param remoteKeys The document keys that matched the query at the last snapshot.
+   * @param limboFreeSnapshotVersion The version of the snapshot when the query was last
+   *     synchronized.
+   */
+  private boolean needsRefill(
+      ImmutableSortedSet<Document> sortedPreviousResults,
+      ImmutableSortedSet<DocumentKey> remoteKeys,
+      SnapshotVersion limboFreeSnapshotVersion) {
+    // The query needs to be refilled if a previously matching document no longer matches.
+    if (remoteKeys.size() != sortedPreviousResults.size()) {
+      return true;
+    }
+
+    // We don't need to find a better match from cache if no documents matched the query.
+    if (sortedPreviousResults.isEmpty()) {
+      return false;
+    }
+
+    // Limit queries are not eligible for index-free query execution if there is a potential that an
+    // older document from cache now sorts before a document that was previously part of the limit.
+    // This, however, can only happen if the last document of the limit sorts lower than it did when
+    // the query was last synchronized. If a document that is not the limit boundary sorts
+    // differently, the boundary of the limit itself did not change and documents from cache will
+    // continue to be "rejected" by this boundary. Therefore, we can ignore any modifications that
+    // don't affect the last document.
+    Document lastDocumentInLimit = sortedPreviousResults.getMaxEntry();
+    return lastDocumentInLimit.hasPendingWrites()
+        || lastDocumentInLimit.getVersion().compareTo(limboFreeSnapshotVersion) > 0;
+  }
+
+  @Override
+  public void handleDocumentChange(MaybeDocument oldDocument, MaybeDocument newDocument) {
+    // No indexes to update.
+  }
+
+  private ImmutableSortedMap<DocumentKey, Document> executeFullCollectionScan(Query query) {
+    if (Logger.isDebugEnabled()) {
+      Logger.debug(LOG_TAG, "Using full collection scan to execute query: %s", query.toString());
+    }
+    return localDocumentsView.getDocumentsMatchingQuery(query, SnapshotVersion.NONE);
+  }
+}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/IndexedQueryEngine.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/IndexedQueryEngine.java
index ab734d95e..fd54260f4 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/IndexedQueryEngine.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/IndexedQueryEngine.java
@@ -16,26 +16,25 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.google.firebase.database.collection.ImmutableSortedMap;
+import com.google.firebase.database.collection.ImmutableSortedSet;
+import com.google.firebase.firestore.core.FieldFilter;
 import com.google.firebase.firestore.core.Filter;
 import com.google.firebase.firestore.core.Filter.Operator;
 import com.google.firebase.firestore.core.IndexRange;
-import com.google.firebase.firestore.core.NaNFilter;
-import com.google.firebase.firestore.core.NullFilter;
 import com.google.firebase.firestore.core.Query;
-import com.google.firebase.firestore.core.RelationFilter;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentCollections;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.FieldPath;
 import com.google.firebase.firestore.model.MaybeDocument;
+import com.google.firebase.firestore.model.SnapshotVersion;
 import com.google.firebase.firestore.model.value.ArrayValue;
 import com.google.firebase.firestore.model.value.BooleanValue;
 import com.google.firebase.firestore.model.value.DoubleValue;
 import com.google.firebase.firestore.model.value.FieldValue;
-import com.google.firebase.firestore.model.value.NullValue;
 import com.google.firebase.firestore.model.value.ObjectValue;
 import com.google.firebase.firestore.util.Assert;
 import java.util.Arrays;
@@ -90,19 +89,25 @@
   private static final List<Class> lowCardinalityTypes =
       Arrays.asList(BooleanValue.class, ArrayValue.class, ObjectValue.class);
 
-  private final LocalDocumentsView localDocuments;
   private final SQLiteCollectionIndex collectionIndex;
+  private LocalDocumentsView localDocuments;
 
-  public IndexedQueryEngine(
-      LocalDocumentsView localDocuments, SQLiteCollectionIndex collectionIndex) {
-    this.localDocuments = localDocuments;
+  public IndexedQueryEngine(SQLiteCollectionIndex collectionIndex) {
     this.collectionIndex = collectionIndex;
   }
 
   @Override
-  public ImmutableSortedMap<DocumentKey, Document> getDocumentsMatchingQuery(Query query) {
+  public void setLocalDocumentsView(LocalDocumentsView localDocuments) {
+    this.localDocuments = localDocuments;
+  }
+
+  @Override
+  public ImmutableSortedMap<DocumentKey, Document> getDocumentsMatchingQuery(
+      Query query, @Nullable QueryData queryData, ImmutableSortedSet<DocumentKey> remoteKeys) {
+    hardAssert(localDocuments != null, "setLocalDocumentsView() not called");
+
     return query.isDocumentQuery()
-        ? localDocuments.getDocumentsMatchingQuery(query)
+        ? localDocuments.getDocumentsMatchingQuery(query, SnapshotVersion.NONE)
         : performCollectionQuery(query);
   }
 
@@ -121,7 +126,7 @@ public IndexedQueryEngine(
           "If there are any filters, we should be able to use an index.");
       // TODO: Call overlay.getCollectionDocuments(query.getPath()) and filter the
       // results (there may still be startAt/endAt bounds that apply).
-      filteredResults = localDocuments.getDocumentsMatchingQuery(query);
+      filteredResults = localDocuments.getDocumentsMatchingQuery(query, SnapshotVersion.NONE);
     }
 
     return filteredResults;
@@ -156,18 +161,15 @@ public IndexedQueryEngine(
    * @return a number from 0.0 to 1.0 (inclusive), where higher numbers indicate higher selectivity
    */
   private static double estimateFilterSelectivity(Filter filter) {
-    if (filter instanceof NullFilter) {
-      return HIGH_SELECTIVITY;
-    } else if (filter instanceof NaNFilter) {
+    hardAssert(filter instanceof FieldFilter, "Filter type expected to be FieldFilter");
+    FieldFilter fieldFilter = (FieldFilter) filter;
+    if (fieldFilter.getValue().equals(null) || fieldFilter.getValue().equals(DoubleValue.NaN)) {
       return HIGH_SELECTIVITY;
     } else {
-      hardAssert(filter instanceof RelationFilter, "Filter type expected to be RelationFilter");
-      RelationFilter relationFilter = (RelationFilter) filter;
-
       double operatorSelectivity =
-          relationFilter.getOperator().equals(Operator.EQUAL) ? HIGH_SELECTIVITY : LOW_SELECTIVITY;
+          fieldFilter.getOperator().equals(Operator.EQUAL) ? HIGH_SELECTIVITY : LOW_SELECTIVITY;
       double typeSelectivity =
-          lowCardinalityTypes.contains(relationFilter.getValue().getClass())
+          lowCardinalityTypes.contains(fieldFilter.getValue().getClass())
               ? LOW_SELECTIVITY
               : HIGH_SELECTIVITY;
 
@@ -216,10 +218,10 @@ static IndexRange extractBestIndexRange(Query query) {
    */
   private static IndexRange convertFilterToIndexRange(Filter filter) {
     IndexRange.Builder indexRange = IndexRange.builder().setFieldPath(filter.getField());
-    if (filter instanceof RelationFilter) {
-      RelationFilter relationFilter = (RelationFilter) filter;
-      FieldValue filterValue = relationFilter.getValue();
-      switch (relationFilter.getOperator()) {
+    if (filter instanceof FieldFilter) {
+      FieldFilter fieldFilter = (FieldFilter) filter;
+      FieldValue filterValue = fieldFilter.getValue();
+      switch (fieldFilter.getOperator()) {
         case EQUAL:
           indexRange.setStart(filterValue).setEnd(filterValue);
           break;
@@ -235,10 +237,6 @@ private static IndexRange convertFilterToIndexRange(Filter filter) {
           // TODO: Add support for ARRAY_CONTAINS.
           throw Assert.fail("Unexpected operator in query filter");
       }
-    } else if (filter instanceof NaNFilter) {
-      indexRange.setStart(DoubleValue.NaN).setEnd(DoubleValue.NaN);
-    } else if (filter instanceof NullFilter) {
-      indexRange.setStart(NullValue.nullValue()).setEnd(NullValue.nullValue());
     }
     return indexRange.build();
   }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalDocumentsView.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalDocumentsView.java
index e718129e5..99858b8d5 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalDocumentsView.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalDocumentsView.java
@@ -18,6 +18,7 @@
 import static com.google.firebase.firestore.model.DocumentCollections.emptyMaybeDocumentMap;
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.firestore.core.Query;
 import com.google.firebase.firestore.model.Document;
@@ -28,9 +29,10 @@
 import com.google.firebase.firestore.model.SnapshotVersion;
 import com.google.firebase.firestore.model.mutation.Mutation;
 import com.google.firebase.firestore.model.mutation.MutationBatch;
+import com.google.firebase.firestore.model.mutation.PatchMutation;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
-import javax.annotation.Nullable;
 
 /**
  * A readonly view of the local state of all documents we're tracking (i.e. we have a cached version
@@ -38,7 +40,7 @@
  * mutations in the MutationQueue to the RemoteDocumentCache.
  */
 // TODO: Turn this into the UnifiedDocumentCache / whatever.
-final class LocalDocumentsView {
+class LocalDocumentsView {
 
   private final RemoteDocumentCache remoteDocumentCache;
   private final MutationQueue mutationQueue;
@@ -129,15 +131,22 @@ private MaybeDocument getDocument(DocumentKey key, List<MutationBatch> inBatches
   // documents in a given collection so that SimpleQueryEngine can do that and then filter in
   // memory.
 
-  /** Performs a query against the local view of all documents. */
-  ImmutableSortedMap<DocumentKey, Document> getDocumentsMatchingQuery(Query query) {
+  /**
+   * Performs a query against the local view of all documents.
+   *
+   * @param query The query to match documents against.
+   * @param sinceReadTime If not set to SnapshotVersion.MIN, return only documents that have been
+   *     read since this snapshot version (exclusive).
+   */
+  ImmutableSortedMap<DocumentKey, Document> getDocumentsMatchingQuery(
+      Query query, SnapshotVersion sinceReadTime) {
     ResourcePath path = query.getPath();
     if (query.isDocumentQuery()) {
       return getDocumentsMatchingDocumentQuery(path);
     } else if (query.isCollectionGroupQuery()) {
-      return getDocumentsMatchingCollectionGroupQuery(query);
+      return getDocumentsMatchingCollectionGroupQuery(query, sinceReadTime);
     } else {
-      return getDocumentsMatchingCollectionQuery(query);
+      return getDocumentsMatchingCollectionQuery(query, sinceReadTime);
     }
   }
 
@@ -154,7 +163,7 @@ private MaybeDocument getDocument(DocumentKey key, List<MutationBatch> inBatches
   }
 
   private ImmutableSortedMap<DocumentKey, Document> getDocumentsMatchingCollectionGroupQuery(
-      Query query) {
+      Query query, SnapshotVersion sinceReadTime) {
     hardAssert(
         query.getPath().isEmpty(),
         "Currently we only support collection group queries at the root.");
@@ -167,7 +176,7 @@ private MaybeDocument getDocument(DocumentKey key, List<MutationBatch> inBatches
     for (ResourcePath parent : parents) {
       Query collectionQuery = query.asCollectionQueryAtPath(parent.append(collectionId));
       ImmutableSortedMap<DocumentKey, Document> collectionResults =
-          getDocumentsMatchingCollectionQuery(collectionQuery);
+          getDocumentsMatchingCollectionQuery(collectionQuery, sinceReadTime);
       for (Map.Entry<DocumentKey, Document> docEntry : collectionResults) {
         results = results.insert(docEntry.getKey(), docEntry.getValue());
       }
@@ -177,11 +186,14 @@ private MaybeDocument getDocument(DocumentKey key, List<MutationBatch> inBatches
 
   /** Queries the remote documents and overlays mutations. */
   private ImmutableSortedMap<DocumentKey, Document> getDocumentsMatchingCollectionQuery(
-      Query query) {
+      Query query, SnapshotVersion sinceReadTime) {
     ImmutableSortedMap<DocumentKey, Document> results =
-        remoteDocumentCache.getAllDocumentsMatchingQuery(query);
+        remoteDocumentCache.getAllDocumentsMatchingQuery(query, sinceReadTime);
 
     List<MutationBatch> matchingBatches = mutationQueue.getAllMutationBatchesAffectingQuery(query);
+
+    results = addMissingBaseDocuments(matchingBatches, results);
+
     for (MutationBatch batch : matchingBatches) {
       for (Mutation mutation : batch.getMutations()) {
         // Only process documents belonging to the collection.
@@ -210,4 +222,34 @@ private MaybeDocument getDocument(DocumentKey key, List<MutationBatch> inBatches
 
     return results;
   }
+
+  /**
+   * It is possible that a {@code PatchMutation} can make a document match a query, even if the
+   * version in the {@code RemoteDocumentCache} is not a match yet (waiting for server to ack). To
+   * handle this, we find all document keys affected by the {@code PatchMutation}s that are not in
+   * {@code existingDocs} yet, and back fill them via {@code remoteDocumentCache.getAll}, otherwise
+   * those {@code PatchMutation}s will be ignored because no base document can be found, and lead to
+   * missing results for the query.
+   */
+  private ImmutableSortedMap<DocumentKey, Document> addMissingBaseDocuments(
+      List<MutationBatch> matchingBatches, ImmutableSortedMap<DocumentKey, Document> existingDocs) {
+    HashSet<DocumentKey> missingDocKeys = new HashSet<>();
+    for (MutationBatch batch : matchingBatches) {
+      for (Mutation mutation : batch.getMutations()) {
+        if (mutation instanceof PatchMutation && !existingDocs.containsKey(mutation.getKey())) {
+          missingDocKeys.add(mutation.getKey());
+        }
+      }
+    }
+
+    ImmutableSortedMap<DocumentKey, Document> mergedDocs = existingDocs;
+    Map<DocumentKey, MaybeDocument> missingDocs = remoteDocumentCache.getAll(missingDocKeys);
+    for (Map.Entry<DocumentKey, MaybeDocument> entry : missingDocs.entrySet()) {
+      if (entry.getValue() != null && (entry.getValue() instanceof Document)) {
+        mergedDocs = mergedDocs.insert(entry.getKey(), (Document) entry.getValue());
+      }
+    }
+
+    return mergedDocs;
+  }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalSerializer.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalSerializer.java
index 5a07249ac..8ca8bdf1e 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalSerializer.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalSerializer.java
@@ -112,15 +112,15 @@ MaybeDocument decodeMaybeDocument(com.google.firebase.firestore.proto.MaybeDocum
   private Document decodeDocument(
       com.google.firestore.v1.Document document, boolean hasCommittedMutations) {
     DocumentKey key = rpcSerializer.decodeKey(document.getName());
-    ObjectValue value = rpcSerializer.decodeFields(document.getFieldsMap());
     SnapshotVersion version = rpcSerializer.decodeVersion(document.getUpdateTime());
     return new Document(
         key,
         version,
-        value,
         hasCommittedMutations
             ? Document.DocumentState.COMMITTED_MUTATIONS
-            : Document.DocumentState.SYNCED);
+            : Document.DocumentState.SYNCED,
+        document,
+        rpcSerializer::decodeValue);
   }
 
   /** Encodes a NoDocument value to the equivalent proto. */
@@ -205,6 +205,8 @@ MutationBatch decodeMutationBatch(com.google.firebase.firestore.proto.WriteBatch
     result
         .setTargetId(queryData.getTargetId())
         .setLastListenSequenceNumber(queryData.getSequenceNumber())
+        .setLastLimboFreeSnapshotVersion(
+            rpcSerializer.encodeVersion(queryData.getLastLimboFreeSnapshotVersion()))
         .setSnapshotVersion(rpcSerializer.encodeVersion(queryData.getSnapshotVersion()))
         .setResumeToken(queryData.getResumeToken());
 
@@ -221,6 +223,8 @@ MutationBatch decodeMutationBatch(com.google.firebase.firestore.proto.WriteBatch
   QueryData decodeQueryData(com.google.firebase.firestore.proto.Target target) {
     int targetId = target.getTargetId();
     SnapshotVersion version = rpcSerializer.decodeVersion(target.getSnapshotVersion());
+    SnapshotVersion lastLimboFreeSnapshotVersion =
+        rpcSerializer.decodeVersion(target.getLastLimboFreeSnapshotVersion());
     ByteString resumeToken = target.getResumeToken();
     long sequenceNumber = target.getLastListenSequenceNumber();
 
@@ -239,6 +243,12 @@ QueryData decodeQueryData(com.google.firebase.firestore.proto.Target target) {
     }
 
     return new QueryData(
-        query, targetId, sequenceNumber, QueryPurpose.LISTEN, version, resumeToken);
+        query,
+        targetId,
+        sequenceNumber,
+        QueryPurpose.LISTEN,
+        version,
+        lastLimboFreeSnapshotVersion,
+        resumeToken);
   }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalStore.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalStore.java
index 8406483bb..6e1cfa426 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalStore.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalStore.java
@@ -18,6 +18,8 @@
 import static java.util.Arrays.asList;
 
 import android.util.SparseArray;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.google.firebase.Timestamp;
 import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.database.collection.ImmutableSortedSet;
@@ -27,8 +29,8 @@
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.MaybeDocument;
+import com.google.firebase.firestore.model.NoDocument;
 import com.google.firebase.firestore.model.SnapshotVersion;
-import com.google.firebase.firestore.model.mutation.FieldMask;
 import com.google.firebase.firestore.model.mutation.Mutation;
 import com.google.firebase.firestore.model.mutation.MutationBatch;
 import com.google.firebase.firestore.model.mutation.MutationBatchResult;
@@ -47,7 +49,6 @@
 import java.util.Map.Entry;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
 
 /**
  * Local storage in the Firestore client. Coordinates persistence components like the mutation queue
@@ -125,7 +126,7 @@
   /** Used to generate targetIds for queries tracked locally. */
   private final TargetIdGenerator targetIdGenerator;
 
-  public LocalStore(Persistence persistence, User initialUser) {
+  public LocalStore(Persistence persistence, QueryEngine queryEngine, User initialUser) {
     hardAssert(
         persistence.isStarted(), "LocalStore was passed an unstarted persistence implementation");
     this.persistence = persistence;
@@ -135,8 +136,9 @@ public LocalStore(Persistence persistence, User initialUser) {
     remoteDocuments = persistence.getRemoteDocumentCache();
     localDocuments =
         new LocalDocumentsView(remoteDocuments, mutationQueue, persistence.getIndexManager());
-    // TODO: Use IndexedQueryEngine as appropriate.
-    queryEngine = new SimpleQueryEngine(localDocuments);
+
+    this.queryEngine = queryEngine;
+    queryEngine.setLocalDocumentsView(localDocuments);
 
     localViewReferences = new ReferenceSet();
     persistence.getReferenceDelegate().setInMemoryPins(localViewReferences);
@@ -170,8 +172,7 @@ private void startMutationQueue() {
     // Recreate our LocalDocumentsView using the new MutationQueue.
     localDocuments =
         new LocalDocumentsView(remoteDocuments, mutationQueue, persistence.getIndexManager());
-    // TODO: Use IndexedQueryEngine as appropriate.
-    queryEngine = new SimpleQueryEngine(localDocuments);
+    queryEngine.setLocalDocumentsView(localDocuments);
 
     // Union the old/new changed keys.
     ImmutableSortedSet<DocumentKey> changedKeys = DocumentKey.emptyKeySet();
@@ -212,24 +213,17 @@ public LocalWriteResult writeLocally(List<Mutation> mutations) {
           // transform.
           List<Mutation> baseMutations = new ArrayList<>();
           for (Mutation mutation : mutations) {
-            MaybeDocument maybeDocument = existingDocuments.get(mutation.getKey());
-            if (!mutation.isIdempotent()) {
-              // Theoretically, we should only include non-idempotent fields in this field mask as
-              // this mask is used to populate the base state for all DocumentTransforms.  By
-              // including all fields, we incorrectly prevent rebasing of idempotent transforms
-              // (such as `arrayUnion()`) when any non-idempotent transforms are present.
-              FieldMask fieldMask = mutation.getFieldMask();
-              if (fieldMask != null) {
-                ObjectValue baseValues =
-                    (maybeDocument instanceof Document)
-                        ? fieldMask.applyTo(((Document) maybeDocument).getData())
-                        : ObjectValue.emptyObject();
-                // NOTE: The base state should only be applied if there's some existing
-                // document to override, so use a Precondition of exists=true
-                baseMutations.add(
-                    new PatchMutation(
-                        mutation.getKey(), baseValues, fieldMask, Precondition.exists(true)));
-              }
+            ObjectValue baseValue =
+                mutation.extractBaseValue(existingDocuments.get(mutation.getKey()));
+            if (baseValue != null) {
+              // NOTE: The base state should only be applied if there's some existing
+              // document to override, so use a Precondition of exists=true
+              baseMutations.add(
+                  new PatchMutation(
+                      mutation.getKey(),
+                      baseValue,
+                      baseValue.getFieldMask(),
+                      Precondition.exists(true)));
             }
           }
 
@@ -290,6 +284,14 @@ public LocalWriteResult writeLocally(List<Mutation> mutations) {
         });
   }
 
+  /**
+   * Returns the largest (latest) batch id in mutation queue that is pending server response.
+   * Returns {@link MutationBatch#UNKNOWN} if the queue is empty.
+   */
+  public int getHighestUnacknowledgedBatchId() {
+    return mutationQueue.getHighestUnacknowledgedBatchId();
+  }
+
   /** Returns the last recorded stream token for the current user. */
   public ByteString getLastStreamToken() {
     return mutationQueue.getLastStreamToken();
@@ -324,54 +326,43 @@ public SnapshotVersion getLastRemoteSnapshotVersion() {
    * <p>LocalDocuments are re-calculated if there are remaining mutations in the queue.
    */
   public ImmutableSortedMap<DocumentKey, MaybeDocument> applyRemoteEvent(RemoteEvent remoteEvent) {
+    SnapshotVersion remoteVersion = remoteEvent.getSnapshotVersion();
+
     // TODO: Call queryEngine.handleDocumentChange() appropriately.
     return persistence.runTransaction(
         "Apply remote event",
         () -> {
+          Map<Integer, TargetChange> targetChanges = remoteEvent.getTargetChanges();
           long sequenceNumber = persistence.getReferenceDelegate().getCurrentSequenceNumber();
-          Set<DocumentKey> authoritativeUpdates = new HashSet<>();
 
-          Map<Integer, TargetChange> targetChanges = remoteEvent.getTargetChanges();
           for (Map.Entry<Integer, TargetChange> entry : targetChanges.entrySet()) {
             Integer boxedTargetId = entry.getKey();
             int targetId = boxedTargetId;
             TargetChange change = entry.getValue();
 
-            // Do not ref/unref unassigned targetIds - it may lead to leaks.
-            QueryData queryData = targetIds.get(targetId);
-            if (queryData == null) {
+            QueryData oldQueryData = targetIds.get(targetId);
+            if (oldQueryData == null) {
+              // We don't update the remote keys if the query is not active. This ensures that
+              // we persist the updated query data along with the updated assignment.
               continue;
             }
 
-            // When a global snapshot contains updates (either add or modify) we can completely
-            // trust these updates as authoritative and blindly apply them to our cache (as a
-            // defensive measure to promote self-healing in the unfortunate case that our cache
-            // is ever somehow corrupted / out-of-sync).
-            //
-            // If the document is only updated while removing it from a target then watch isn't
-            // obligated to send the absolute latest version: it can send the first version that
-            // caused the document not to match.
-            for (DocumentKey key : change.getAddedDocuments()) {
-              authoritativeUpdates.add(key);
-            }
-            for (DocumentKey key : change.getModifiedDocuments()) {
-              authoritativeUpdates.add(key);
-            }
-
             queryCache.removeMatchingKeys(change.getRemovedDocuments(), targetId);
             queryCache.addMatchingKeys(change.getAddedDocuments(), targetId);
 
-            // Update the resume token if the change includes one. Don't clear any preexisting
-            // value.
             ByteString resumeToken = change.getResumeToken();
+            // Update the resume token if the change includes one.
             if (!resumeToken.isEmpty()) {
-              QueryData oldQueryData = queryData;
-              queryData =
-                  queryData.copy(remoteEvent.getSnapshotVersion(), resumeToken, sequenceNumber);
-              targetIds.put(boxedTargetId, queryData);
-
-              if (shouldPersistQueryData(oldQueryData, queryData, change)) {
-                queryCache.updateQueryData(queryData);
+              QueryData newQueryData =
+                  oldQueryData
+                      .withResumeToken(resumeToken, remoteEvent.getSnapshotVersion())
+                      .withSequenceNumber(sequenceNumber);
+              targetIds.put(boxedTargetId, newQueryData);
+
+              // Update the query data if there are target changes (or if sufficient time has
+              // passed since the last update).
+              if (shouldPersistQueryData(oldQueryData, newQueryData, change)) {
+                queryCache.updateQueryData(newQueryData);
               }
             }
           }
@@ -389,16 +380,17 @@ public SnapshotVersion getLastRemoteSnapshotVersion() {
             MaybeDocument doc = entry.getValue();
             MaybeDocument existingDoc = existingDocs.get(key);
 
-            // If a document update isn't authoritative, make sure we don't
-            // apply an old document version to the remote cache. We make an
-            // exception for SnapshotVersion.MIN which can happen for
-            // manufactured events (e.g. in the case of a limbo document
-            // resolution failing).
             if (existingDoc == null
-                || doc.getVersion().equals(SnapshotVersion.NONE)
-                || (authoritativeUpdates.contains(doc.getKey()) && !existingDoc.hasPendingWrites())
-                || doc.getVersion().compareTo(existingDoc.getVersion()) >= 0) {
-              remoteDocuments.add(doc);
+                || doc.getVersion().compareTo(existingDoc.getVersion()) > 0
+                || (doc.getVersion().compareTo(existingDoc.getVersion()) == 0
+                    && existingDoc.hasPendingWrites())) {
+              remoteDocuments.add(doc, remoteEvent.getSnapshotVersion());
+              changedDocs.put(key, doc);
+            } else if (doc instanceof NoDocument && doc.getVersion().equals(SnapshotVersion.NONE)) {
+              // NoDocuments with SnapshotVersion.MIN are used in manufactured events (e.g. in the
+              // case of a limbo document resolution failing). We remove these documents from cache
+              // since we lost access.
+              remoteDocuments.remove(doc.getKey());
               changedDocs.put(key, doc);
             } else {
               Logger.debug(
@@ -419,7 +411,6 @@ public SnapshotVersion getLastRemoteSnapshotVersion() {
           // remote events when we get permission denied errors while trying to resolve the
           // state of a locally cached document that is in limbo.
           SnapshotVersion lastRemoteVersion = queryCache.getLastRemoteSnapshotVersion();
-          SnapshotVersion remoteVersion = remoteEvent.getSnapshotVersion();
           if (!remoteVersion.equals(SnapshotVersion.NONE)) {
             hardAssert(
                 remoteVersion.compareTo(lastRemoteVersion) >= 0,
@@ -445,10 +436,11 @@ public SnapshotVersion getLastRemoteSnapshotVersion() {
    */
   private static boolean shouldPersistQueryData(
       QueryData oldQueryData, QueryData newQueryData, TargetChange change) {
-    // Avoid clearing any existing value
-    if (newQueryData.getResumeToken().isEmpty()) return false;
+    hardAssert(
+        !newQueryData.getResumeToken().isEmpty(),
+        "Attempted to persist query data with empty resume token");
 
-    // Any resume token is interesting if there isn't one already.
+    // Always persist query data if we don't already have a resume token.
     if (oldQueryData.getResumeToken().isEmpty()) return true;
 
     // Don't allow resume token changes to be buffered indefinitely. This allows us to be reasonably
@@ -477,12 +469,28 @@ public void notifyLocalViewChanges(List<LocalViewChanges> viewChanges) {
         "notifyLocalViewChanges",
         () -> {
           for (LocalViewChanges viewChange : viewChanges) {
-            localViewReferences.addReferences(viewChange.getAdded(), viewChange.getTargetId());
+            int targetId = viewChange.getTargetId();
+
+            localViewReferences.addReferences(viewChange.getAdded(), targetId);
             ImmutableSortedSet<DocumentKey> removed = viewChange.getRemoved();
             for (DocumentKey key : removed) {
               persistence.getReferenceDelegate().removeReference(key);
             }
-            localViewReferences.removeReferences(removed, viewChange.getTargetId());
+            localViewReferences.removeReferences(removed, targetId);
+
+            if (!viewChange.isFromCache()) {
+              QueryData queryData = targetIds.get(targetId);
+              hardAssert(
+                  queryData != null,
+                  "Can't set limbo-free snapshot version for unknown target: %s",
+                  targetId);
+
+              // Advance the last limbo free snapshot version
+              SnapshotVersion lastLimboFreeSnapshotVersion = queryData.getSnapshotVersion();
+              QueryData updatedQueryData =
+                  queryData.withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion);
+              targetIds.put(targetId, updatedQueryData);
+            }
           }
         });
   }
@@ -540,6 +548,21 @@ public QueryData allocateQuery(Query query) {
     return cached;
   }
 
+  /**
+   * Returns the QueryData as seen by the LocalStore, including updates that may have not yet been
+   * persisted to the QueryCache.
+   */
+  @VisibleForTesting
+  @Nullable
+  QueryData getQueryData(Query query) {
+    QueryData queryData = queryCache.getQueryData(query);
+    if (queryData == null) {
+      return null;
+    }
+    QueryData updatedQueryData = targetIds.get(queryData.getTargetId());
+    return updatedQueryData != null ? updatedQueryData : queryData;
+  }
+
   /** Mutable state for the transaction in allocateQuery. */
   private static class AllocateQueryHolder {
     QueryData cached;
@@ -551,19 +574,9 @@ public void releaseQuery(Query query) {
     persistence.runTransaction(
         "Release query",
         () -> {
-          QueryData queryData = queryCache.getQueryData(query);
+          QueryData queryData = getQueryData(query);
           hardAssert(queryData != null, "Tried to release nonexistent query: %s", query);
 
-          int targetId = queryData.getTargetId();
-          QueryData cachedQueryData = targetIds.get(targetId);
-          if (cachedQueryData.getSnapshotVersion().compareTo(queryData.getSnapshotVersion()) > 0) {
-            // If we've been avoiding persisting the resumeToken (see shouldPersistQueryData for
-            // conditions and rationale) we need to persist the token now because there will no
-            // longer be an in-memory version to fall back on.
-            queryData = cachedQueryData;
-            queryCache.updateQueryData(queryData);
-          }
-
           // References for documents sent via Watch are automatically removed when we delete a
           // query's target data from the reference delegate. Since this does not remove references
           // for locally mutated documents, we have to remove the target associations for these
@@ -573,6 +586,8 @@ public void releaseQuery(Query query) {
           for (DocumentKey key : removedReferences) {
             persistence.getReferenceDelegate().removeReference(key);
           }
+
+          // Note: This also updates the query cache
           persistence.getReferenceDelegate().removeTarget(queryData);
           targetIds.remove(queryData.getTargetId());
         });
@@ -580,7 +595,23 @@ public void releaseQuery(Query query) {
 
   /** Runs the given query against all the documents in the local store and returns the results. */
   public ImmutableSortedMap<DocumentKey, Document> executeQuery(Query query) {
-    return queryEngine.getDocumentsMatchingQuery(query);
+    QueryData queryData = getQueryData(query);
+    if (queryData != null) {
+      ImmutableSortedSet<DocumentKey> remoteKeys =
+          this.queryCache.getMatchingKeysForTargetId(queryData.getTargetId());
+      return executeQuery(query, queryData, remoteKeys);
+    } else {
+      return executeQuery(query, null, DocumentKey.emptyKeySet());
+    }
+  }
+
+  /**
+   * Runs the given query against the local store and returns the results, potentially taking
+   * advantage of the provided query data and the set of remote document keys.
+   */
+  public ImmutableSortedMap<DocumentKey, Document> executeQuery(
+      Query query, @Nullable QueryData queryData, ImmutableSortedSet<DocumentKey> remoteKeys) {
+    return queryEngine.getDocumentsMatchingQuery(query, queryData, remoteKeys);
   }
 
   /**
@@ -609,7 +640,7 @@ private void applyWriteToRemoteDocuments(MutationBatchResult batchResult) {
               batch,
               remoteDoc);
         } else {
-          remoteDocuments.add(doc);
+          remoteDocuments.add(doc, batchResult.getCommitVersion());
         }
       }
     }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalViewChanges.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalViewChanges.java
index 541f3f444..09ba35206 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalViewChanges.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalViewChanges.java
@@ -49,19 +49,22 @@ public static LocalViewChanges fromViewSnapshot(int targetId, ViewSnapshot snaps
       }
     }
 
-    return new LocalViewChanges(targetId, addedKeys, removedKeys);
+    return new LocalViewChanges(targetId, snapshot.isFromCache(), addedKeys, removedKeys);
   }
 
   private final int targetId;
+  private final boolean fromCache;
 
   private final ImmutableSortedSet<DocumentKey> added;
   private final ImmutableSortedSet<DocumentKey> removed;
 
   public LocalViewChanges(
       int targetId,
+      boolean fromCache,
       ImmutableSortedSet<DocumentKey> added,
       ImmutableSortedSet<DocumentKey> removed) {
     this.targetId = targetId;
+    this.fromCache = fromCache;
     this.added = added;
     this.removed = removed;
   }
@@ -70,6 +73,10 @@ public int getTargetId() {
     return targetId;
   }
 
+  public boolean isFromCache() {
+    return fromCache;
+  }
+
   public ImmutableSortedSet<DocumentKey> getAdded() {
     return added;
   }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LruGarbageCollector.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LruGarbageCollector.java
index d423ca602..2bc7ae90b 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LruGarbageCollector.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LruGarbageCollector.java
@@ -14,8 +14,8 @@
 
 package com.google.firebase.firestore.local;
 
-import android.support.annotation.Nullable;
 import android.util.SparseArray;
+import androidx.annotation.Nullable;
 import com.google.firebase.firestore.FirebaseFirestoreSettings;
 import com.google.firebase.firestore.core.ListenSequence;
 import com.google.firebase.firestore.util.AsyncQueue;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryLruReferenceDelegate.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryLruReferenceDelegate.java
index 6ff4cb74d..860eb5385 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryLruReferenceDelegate.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryLruReferenceDelegate.java
@@ -117,8 +117,8 @@ public int removeTargets(long upperBound, SparseArray<?> activeTargetIds) {
   public int removeOrphanedDocuments(long upperBound) {
     int count = 0;
     MemoryRemoteDocumentCache cache = persistence.getRemoteDocumentCache();
-    for (Map.Entry<DocumentKey, MaybeDocument> entry : cache.getDocuments()) {
-      DocumentKey key = entry.getKey();
+    for (MaybeDocument doc : cache.getDocuments()) {
+      DocumentKey key = doc.getKey();
       if (!isPinned(key, upperBound)) {
         cache.remove(key);
         orphanedSequenceNumbers.remove(key);
@@ -135,9 +135,7 @@ public void removeMutationReference(DocumentKey key) {
 
   @Override
   public void removeTarget(QueryData queryData) {
-    QueryData updated =
-        queryData.copy(
-            queryData.getSnapshotVersion(), queryData.getResumeToken(), getCurrentSequenceNumber());
+    QueryData updated = queryData.withSequenceNumber(getCurrentSequenceNumber());
     persistence.getQueryCache().updateQueryData(updated);
   }
 
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryMutationQueue.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryMutationQueue.java
index 82f734467..f113580f4 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryMutationQueue.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryMutationQueue.java
@@ -18,6 +18,7 @@
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 import static java.util.Collections.emptyList;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.Timestamp;
 import com.google.firebase.database.collection.ImmutableSortedSet;
 import com.google.firebase.firestore.core.Query;
@@ -32,7 +33,6 @@
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
-import javax.annotation.Nullable;
 
 final class MemoryMutationQueue implements MutationQueue {
 
@@ -69,9 +69,11 @@
   private ByteString lastStreamToken;
 
   private final MemoryPersistence persistence;
+  private final StatsCollector statsCollector;
 
-  MemoryMutationQueue(MemoryPersistence persistence) {
+  MemoryMutationQueue(MemoryPersistence persistence, StatsCollector statsCollector) {
     this.persistence = persistence;
+    this.statsCollector = statsCollector;
     queue = new ArrayList<>();
 
     batchesByDocumentKey = new ImmutableSortedSet<>(emptyList(), DocumentReference.BY_KEY);
@@ -154,12 +156,16 @@ public MutationBatch addMutationBatch(
           .addToCollectionParentIndex(mutation.getKey().getPath().popLast());
     }
 
+    statsCollector.recordRowsWritten(STATS_TAG, 1);
+
     return batch;
   }
 
   @Nullable
   @Override
   public MutationBatch lookupMutationBatch(int batchId) {
+    statsCollector.recordRowsRead(STATS_TAG, 1);
+
     int index = indexOfBatchId(batchId);
     if (index < 0 || index >= queue.size()) {
       return null;
@@ -181,6 +187,11 @@ public MutationBatch getNextMutationBatchAfterBatchId(int batchId) {
     return queue.size() > index ? queue.get(index) : null;
   }
 
+  @Override
+  public int getHighestUnacknowledgedBatchId() {
+    return queue.isEmpty() ? MutationBatch.UNKNOWN : nextBatchId - 1;
+  }
+
   @Override
   public List<MutationBatch> getAllMutationBatches() {
     return Collections.unmodifiableList(queue);
@@ -203,6 +214,8 @@ public MutationBatch getNextMutationBatchAfterBatchId(int batchId) {
       result.add(batch);
     }
 
+    statsCollector.recordRowsRead(STATS_TAG, result.size());
+
     return result;
   }
 
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryPersistence.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryPersistence.java
index f43a3a71a..8d9744b50 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryPersistence.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryPersistence.java
@@ -35,30 +35,38 @@
   private final MemoryIndexManager indexManager;
   private final MemoryQueryCache queryCache;
   private final MemoryRemoteDocumentCache remoteDocumentCache;
+  private final StatsCollector statsCollector;
   private ReferenceDelegate referenceDelegate;
 
   private boolean started;
 
   public static MemoryPersistence createEagerGcMemoryPersistence() {
-    MemoryPersistence persistence = new MemoryPersistence();
+    return createEagerGcMemoryPersistence(StatsCollector.NO_OP_STATS_COLLECTOR);
+  }
+
+  public static MemoryPersistence createEagerGcMemoryPersistence(StatsCollector statsCollector) {
+    MemoryPersistence persistence = new MemoryPersistence(statsCollector);
     persistence.setReferenceDelegate(new MemoryEagerReferenceDelegate(persistence));
     return persistence;
   }
 
   public static MemoryPersistence createLruGcMemoryPersistence(
-      LruGarbageCollector.Params params, LocalSerializer serializer) {
-    MemoryPersistence persistence = new MemoryPersistence();
+      LruGarbageCollector.Params params,
+      StatsCollector statsCollector,
+      LocalSerializer serializer) {
+    MemoryPersistence persistence = new MemoryPersistence(statsCollector);
     persistence.setReferenceDelegate(
         new MemoryLruReferenceDelegate(persistence, params, serializer));
     return persistence;
   }
 
   /** Use static helpers to instantiate */
-  private MemoryPersistence() {
+  private MemoryPersistence(StatsCollector statsCollector) {
+    this.statsCollector = statsCollector;
     mutationQueues = new HashMap<>();
     indexManager = new MemoryIndexManager();
     queryCache = new MemoryQueryCache(this);
-    remoteDocumentCache = new MemoryRemoteDocumentCache(this);
+    remoteDocumentCache = new MemoryRemoteDocumentCache(this, statsCollector);
   }
 
   @Override
@@ -93,7 +101,7 @@ private void setReferenceDelegate(ReferenceDelegate delegate) {
   MutationQueue getMutationQueue(User user) {
     MemoryMutationQueue queue = mutationQueues.get(user);
     if (queue == null) {
-      queue = new MemoryMutationQueue(this);
+      queue = new MemoryMutationQueue(this, statsCollector);
       mutationQueues.put(user, queue);
     }
     return queue;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryQueryCache.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryQueryCache.java
index 7c0315dc3..68ef30d1b 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryQueryCache.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryQueryCache.java
@@ -15,6 +15,7 @@
 package com.google.firebase.firestore.local;
 
 import android.util.SparseArray;
+import androidx.annotation.Nullable;
 import com.google.firebase.database.collection.ImmutableSortedSet;
 import com.google.firebase.firestore.core.Query;
 import com.google.firebase.firestore.model.DocumentKey;
@@ -23,7 +24,6 @@
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
-import javax.annotation.Nullable;
 
 /**
  * An implementation of the QueryCache protocol that merely keeps queries in memory, suitable for
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryRemoteDocumentCache.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryRemoteDocumentCache.java
index 4bdf0b6dc..47324c6fc 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryRemoteDocumentCache.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryRemoteDocumentCache.java
@@ -15,49 +15,59 @@
 package com.google.firebase.firestore.local;
 
 import static com.google.firebase.firestore.model.DocumentCollections.emptyDocumentMap;
-import static com.google.firebase.firestore.model.DocumentCollections.emptyMaybeDocumentMap;
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import android.util.Pair;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.firestore.core.Query;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.MaybeDocument;
 import com.google.firebase.firestore.model.ResourcePath;
+import com.google.firebase.firestore.model.SnapshotVersion;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
-import javax.annotation.Nullable;
 
 /** In-memory cache of remote documents. */
 final class MemoryRemoteDocumentCache implements RemoteDocumentCache {
 
-  /** Underlying cache of documents. */
-  private ImmutableSortedMap<DocumentKey, MaybeDocument> docs;
+  /** Underlying cache of documents and their read times. */
+  private ImmutableSortedMap<DocumentKey, Pair<MaybeDocument, SnapshotVersion>> docs;
 
   private final MemoryPersistence persistence;
+  private StatsCollector statsCollector;
 
-  MemoryRemoteDocumentCache(MemoryPersistence persistence) {
-    docs = emptyMaybeDocumentMap();
+  MemoryRemoteDocumentCache(MemoryPersistence persistence, StatsCollector statsCollector) {
+    docs = ImmutableSortedMap.Builder.emptyMap(DocumentKey.comparator());
+    this.statsCollector = statsCollector;
     this.persistence = persistence;
   }
 
   @Override
-  public void add(MaybeDocument document) {
-    docs = docs.insert(document.getKey(), document);
+  public void add(MaybeDocument document, SnapshotVersion readTime) {
+    hardAssert(
+        !readTime.equals(SnapshotVersion.NONE),
+        "Cannot add document to the RemoteDocumentCache with a read time of zero");
+    docs = docs.insert(document.getKey(), new Pair<>(document, readTime));
 
     persistence.getIndexManager().addToCollectionParentIndex(document.getKey().getPath().popLast());
   }
 
   @Override
   public void remove(DocumentKey key) {
+    statsCollector.recordRowsDeleted(STATS_TAG, 1);
     docs = docs.remove(key);
   }
 
   @Nullable
   @Override
   public MaybeDocument get(DocumentKey key) {
-    return docs.get(key);
+    statsCollector.recordRowsRead(STATS_TAG, 1);
+    Pair<MaybeDocument, SnapshotVersion> entry = docs.get(key);
+    return entry != null ? entry.first : null;
   }
 
   @Override
@@ -70,11 +80,13 @@ public MaybeDocument get(DocumentKey key) {
       result.put(key, get(key));
     }
 
+    statsCollector.recordRowsRead(STATS_TAG, result.size());
     return result;
   }
 
   @Override
-  public ImmutableSortedMap<DocumentKey, Document> getAllDocumentsMatchingQuery(Query query) {
+  public ImmutableSortedMap<DocumentKey, Document> getAllDocumentsMatchingQuery(
+      Query query, SnapshotVersion sinceReadTime) {
     hardAssert(
         !query.isCollectionGroupQuery(),
         "CollectionGroup queries should be handled in LocalDocumentsView");
@@ -84,53 +96,74 @@ public MaybeDocument get(DocumentKey key) {
     // we need to match the query against.
     ResourcePath queryPath = query.getPath();
     DocumentKey prefix = DocumentKey.fromPath(queryPath.append(""));
-    Iterator<Map.Entry<DocumentKey, MaybeDocument>> iterator = docs.iteratorFrom(prefix);
+    Iterator<Map.Entry<DocumentKey, Pair<MaybeDocument, SnapshotVersion>>> iterator =
+        docs.iteratorFrom(prefix);
+
+    int rowsRead = 0;
+
     while (iterator.hasNext()) {
-      Map.Entry<DocumentKey, MaybeDocument> entry = iterator.next();
+      Map.Entry<DocumentKey, Pair<MaybeDocument, SnapshotVersion>> entry = iterator.next();
+
+      ++rowsRead;
+
       DocumentKey key = entry.getKey();
       if (!queryPath.isPrefixOf(key.getPath())) {
         break;
       }
 
-      MaybeDocument maybeDoc = entry.getValue();
+      MaybeDocument maybeDoc = entry.getValue().first;
       if (!(maybeDoc instanceof Document)) {
         continue;
       }
 
+      SnapshotVersion readTime = entry.getValue().second;
+      if (readTime.compareTo(sinceReadTime) <= 0) {
+        continue;
+      }
+
       Document doc = (Document) maybeDoc;
       if (query.matches(doc)) {
         result = result.insert(doc.getKey(), doc);
       }
     }
 
+    statsCollector.recordRowsRead(STATS_TAG, rowsRead);
+
     return result;
   }
 
-  ImmutableSortedMap<DocumentKey, MaybeDocument> getDocuments() {
-    return docs;
+  Iterable<MaybeDocument> getDocuments() {
+    return new DocumentIterable();
   }
 
-  /**
-   * Returns an estimate of the number of bytes used to store the given document key in memory. This
-   * is only an estimate and includes the size of the segments of the path, but not any object
-   * overhead or path separators.
-   */
-  private static long getKeySize(DocumentKey key) {
-    ResourcePath path = key.getPath();
+  long getByteSize(LocalSerializer serializer) {
     long count = 0;
-    for (int i = 0; i < path.length(); i++) {
-      // Strings in java are utf-16, each character is two bytes in memory
-      count += path.getSegment(i).length() * 2;
+    for (MaybeDocument doc : new DocumentIterable()) {
+      count += serializer.encodeMaybeDocument(doc).getSerializedSize();
     }
     return count;
   }
 
-  long getByteSize(LocalSerializer serializer) {
-    long count = 0;
-    for (Map.Entry<DocumentKey, MaybeDocument> entry : docs) {
-      count += getKeySize(entry.getKey());
-      count += serializer.encodeMaybeDocument(entry.getValue()).getSerializedSize();
+  /**
+   * A proxy that exposes an iterator over the current set of documents in the RemoteDocumentCache.
+   */
+  private class DocumentIterable implements Iterable<MaybeDocument> {
+    @NonNull
+    @Override
+    public Iterator<MaybeDocument> iterator() {
+      Iterator<Map.Entry<DocumentKey, Pair<MaybeDocument, SnapshotVersion>>> iterator =
+          MemoryRemoteDocumentCache.this.docs.iterator();
+      return new Iterator<MaybeDocument>() {
+        @Override
+        public boolean hasNext() {
+          return iterator.hasNext();
+        }
+
+        @Override
+        public MaybeDocument next() {
+          return iterator.next().getValue().first;
+        }
+      };
     }
-    return count;
   }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MutationQueue.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MutationQueue.java
index 0dbab22b1..c400845a4 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MutationQueue.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MutationQueue.java
@@ -14,6 +14,7 @@
 
 package com.google.firebase.firestore.local;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.core.Query;
 import com.google.firebase.firestore.model.DocumentKey;
@@ -21,10 +22,12 @@
 import com.google.firebase.firestore.model.mutation.MutationBatch;
 import com.google.protobuf.ByteString;
 import java.util.List;
-import javax.annotation.Nullable;
 
 /** A queue of mutations to apply to the remote store. */
 interface MutationQueue {
+  /** The tag used by the StatsCollector. */
+  String STATS_TAG = "mutations";
+
   /**
    * Starts the mutation queue, performing any initial reads that might be required to establish
    * invariants, etc.
@@ -70,6 +73,12 @@ MutationBatch addMutationBatch(
   @Nullable
   MutationBatch getNextMutationBatchAfterBatchId(int batchId);
 
+  /**
+   * @return The largest (latest) batch id in mutation queue for the current user that is pending
+   *     server response, {@link MutationBatch#UNKNOWN} if the queue is empty.
+   */
+  int getHighestUnacknowledgedBatchId();
+
   /** Returns all mutation batches in the mutation queue. */
   // TODO: PERF: Current consumer only needs mutated keys; if we can provide that
   // cheaply, we should replace this.
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/QueryCache.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/QueryCache.java
index 9e51249a1..7b3adc3ae 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/QueryCache.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/QueryCache.java
@@ -14,12 +14,12 @@
 
 package com.google.firebase.firestore.local;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.database.collection.ImmutableSortedSet;
 import com.google.firebase.firestore.core.Query;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.SnapshotVersion;
 import com.google.firebase.firestore.util.Consumer;
-import javax.annotation.Nullable;
 
 /**
  * Represents cached queries received from the remote backend. This contains both a mapping between
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/QueryData.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/QueryData.java
index ab52bb221..0c6361f1e 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/QueryData.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/QueryData.java
@@ -28,6 +28,7 @@
   private final long sequenceNumber;
   private final QueryPurpose purpose;
   private final SnapshotVersion snapshotVersion;
+  private final SnapshotVersion lastLimboFreeSnapshotVersion;
   private final ByteString resumeToken;
 
   /**
@@ -36,23 +37,27 @@
    * @param query The query being listened to.
    * @param targetId The target to which the query corresponds, assigned by the LocalStore for user
    *     queries or the SyncEngine for limbo queries.
+   * @param sequenceNumber The sequence number, denoting the last time this query was used.
    * @param purpose The purpose of the query.
    * @param snapshotVersion The latest snapshot version seen for this target.
+   * @param lastLimboFreeSnapshotVersion The maximum snapshot version at which the associated query
+   *     view contained no limbo documents.
    * @param resumeToken An opaque, server-assigned token that allows watching a query to be resumed
    *     after disconnecting without retransmitting all the data that matches the query. The resume
    *     token essentially identifies a point in time from which the server should resume sending
-   *     results.
    */
-  public QueryData(
+  QueryData(
       Query query,
       int targetId,
       long sequenceNumber,
       QueryPurpose purpose,
       SnapshotVersion snapshotVersion,
+      SnapshotVersion lastLimboFreeSnapshotVersion,
       ByteString resumeToken) {
     this.query = checkNotNull(query);
     this.targetId = targetId;
     this.sequenceNumber = sequenceNumber;
+    this.lastLimboFreeSnapshotVersion = lastLimboFreeSnapshotVersion;
     this.purpose = purpose;
     this.snapshotVersion = checkNotNull(snapshotVersion);
     this.resumeToken = checkNotNull(resumeToken);
@@ -66,9 +71,46 @@ public QueryData(Query query, int targetId, long sequenceNumber, QueryPurpose pu
         sequenceNumber,
         purpose,
         SnapshotVersion.NONE,
+        SnapshotVersion.NONE,
         WatchStream.EMPTY_RESUME_TOKEN);
   }
 
+  /** Creates a new query data instance with an updated sequence number. */
+  public QueryData withSequenceNumber(long sequenceNumber) {
+    return new QueryData(
+        query,
+        targetId,
+        sequenceNumber,
+        purpose,
+        snapshotVersion,
+        lastLimboFreeSnapshotVersion,
+        resumeToken);
+  }
+
+  /** Creates a new query data instance with an updated resume token and snapshot version. */
+  public QueryData withResumeToken(ByteString resumeToken, SnapshotVersion snapshotVersion) {
+    return new QueryData(
+        query,
+        targetId,
+        sequenceNumber,
+        purpose,
+        snapshotVersion,
+        lastLimboFreeSnapshotVersion,
+        resumeToken);
+  }
+
+  /** Creates a new query data instance with an updated last limbo free snapshot version number. */
+  public QueryData withLastLimboFreeSnapshotVersion(SnapshotVersion lastLimboFreeSnapshotVersion) {
+    return new QueryData(
+        query,
+        targetId,
+        sequenceNumber,
+        purpose,
+        snapshotVersion,
+        lastLimboFreeSnapshotVersion,
+        resumeToken);
+  }
+
   public Query getQuery() {
     return query;
   }
@@ -93,6 +135,13 @@ public ByteString getResumeToken() {
     return resumeToken;
   }
 
+  /**
+   * Returns the last snapshot version for which the associated view contained no limbo documents.
+   */
+  public SnapshotVersion getLastLimboFreeSnapshotVersion() {
+    return lastLimboFreeSnapshotVersion;
+  }
+
   @Override
   public boolean equals(Object o) {
     if (this == o) {
@@ -108,6 +157,7 @@ public boolean equals(Object o) {
         && sequenceNumber == queryData.sequenceNumber
         && purpose.equals(queryData.purpose)
         && snapshotVersion.equals(queryData.snapshotVersion)
+        && lastLimboFreeSnapshotVersion.equals(queryData.lastLimboFreeSnapshotVersion)
         && resumeToken.equals(queryData.resumeToken);
   }
 
@@ -118,6 +168,7 @@ public int hashCode() {
     result = 31 * result + (int) sequenceNumber;
     result = 31 * result + purpose.hashCode();
     result = 31 * result + snapshotVersion.hashCode();
+    result = 31 * result + lastLimboFreeSnapshotVersion.hashCode();
     result = 31 * result + resumeToken.hashCode();
     return result;
   }
@@ -135,14 +186,10 @@ public String toString() {
         + purpose
         + ", snapshotVersion="
         + snapshotVersion
+        + ", lastLimboFreeSnapshotVersion="
+        + lastLimboFreeSnapshotVersion
         + ", resumeToken="
         + resumeToken
         + '}';
   }
-
-  /** Creates a new query data instance with an updated snapshot version and resume token. */
-  public QueryData copy(
-      SnapshotVersion snapshotVersion, ByteString resumeToken, long sequenceNumber) {
-    return new QueryData(query, targetId, sequenceNumber, purpose, snapshotVersion, resumeToken);
-  }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/QueryEngine.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/QueryEngine.java
index 45e7afc78..a4477dc59 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/QueryEngine.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/QueryEngine.java
@@ -14,17 +14,26 @@
 
 package com.google.firebase.firestore.local;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.database.collection.ImmutableSortedMap;
+import com.google.firebase.database.collection.ImmutableSortedSet;
 import com.google.firebase.firestore.core.Query;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.MaybeDocument;
 
-/** Represents a query engine capable of performing queries over the local document cache. */
-interface QueryEngine {
+/**
+ * Represents a query engine capable of performing queries over the local document cache. You must
+ * call setLocalDocumentsView() before using.
+ */
+public interface QueryEngine {
+
+  /** Sets the document view to query against. */
+  void setLocalDocumentsView(LocalDocumentsView localDocuments);
 
   /** Returns all local documents matching the specified query. */
-  ImmutableSortedMap<DocumentKey, Document> getDocumentsMatchingQuery(Query query);
+  ImmutableSortedMap<DocumentKey, Document> getDocumentsMatchingQuery(
+      Query query, @Nullable QueryData queryData, ImmutableSortedSet<DocumentKey> remoteKeys);
 
   /**
    * Notifies the query engine of a document change in case it would like to update indexes and the
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/RemoteDocumentCache.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/RemoteDocumentCache.java
index 1acd0de8d..c79ca10ea 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/RemoteDocumentCache.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/RemoteDocumentCache.java
@@ -14,13 +14,14 @@
 
 package com.google.firebase.firestore.local;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.firestore.core.Query;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.MaybeDocument;
+import com.google.firebase.firestore.model.SnapshotVersion;
 import java.util.Map;
-import javax.annotation.Nullable;
 
 /**
  * Represents cached documents received from the remote backend.
@@ -30,6 +31,9 @@
  * instances (indicating that the document is known to not exist).
  */
 interface RemoteDocumentCache {
+  /** The tag used by the StatsCollector. */
+  String STATS_TAG = "remote_documents";
+
   /**
    * Adds or replaces an entry in the cache.
    *
@@ -37,8 +41,9 @@
    * for the key, it will be replaced.
    *
    * @param maybeDocument A Document or NoDocument to put in the cache.
+   * @param readTime The time at which the document was read or committed.
    */
-  void add(MaybeDocument maybeDocument);
+  void add(MaybeDocument maybeDocument, SnapshotVersion readTime);
 
   /** Removes the cached entry for the given key (no-op if no entry exists). */
   void remove(DocumentKey documentKey);
@@ -70,7 +75,10 @@
    * <p>Cached NoDocument entries have no bearing on query results.
    *
    * @param query The query to match documents against.
+   * @param sinceReadTime If not set to SnapshotVersion.MIN, return only documents that have been
+   *     read since this snapshot version (exclusive).
    * @return The set of matching documents.
    */
-  ImmutableSortedMap<DocumentKey, Document> getAllDocumentsMatchingQuery(Query query);
+  ImmutableSortedMap<DocumentKey, Document> getAllDocumentsMatchingQuery(
+      Query query, SnapshotVersion sinceReadTime);
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteLruReferenceDelegate.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteLruReferenceDelegate.java
index d2823ac39..1793c6e73 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteLruReferenceDelegate.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteLruReferenceDelegate.java
@@ -167,9 +167,7 @@ public int removeOrphanedDocuments(long upperBound) {
 
   @Override
   public void removeTarget(QueryData queryData) {
-    QueryData updated =
-        queryData.copy(
-            queryData.getSnapshotVersion(), queryData.getResumeToken(), getCurrentSequenceNumber());
+    QueryData updated = queryData.withSequenceNumber(getCurrentSequenceNumber());
     persistence.getQueryCache().updateQueryData(updated);
   }
 
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteMutationQueue.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteMutationQueue.java
index 951442b34..3f7fe49c7 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteMutationQueue.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteMutationQueue.java
@@ -20,6 +20,7 @@
 
 import android.database.Cursor;
 import android.database.sqlite.SQLiteStatement;
+import androidx.annotation.Nullable;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.auth.User;
 import com.google.firebase.firestore.core.Query;
@@ -39,7 +40,6 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-import javax.annotation.Nullable;
 
 /** A mutation queue for a specific user, backed by SQLite. */
 final class SQLiteMutationQueue implements MutationQueue {
@@ -58,6 +58,7 @@
 
   private final SQLitePersistence db;
   private final LocalSerializer serializer;
+  private final StatsCollector statsCollector;
 
   /** The normalized uid (e.g. null => "") used in the uid column. */
   private final String uid;
@@ -86,11 +87,17 @@
    * persistence interface.
    *
    * @param persistence The SQLite database in which to create the queue.
+   * @param statsCollector The stats collector for all mutation queue operations.
    * @param user The user for which to create a mutation queue.
    */
-  SQLiteMutationQueue(SQLitePersistence persistence, LocalSerializer serializer, User user) {
+  SQLiteMutationQueue(
+      SQLitePersistence persistence,
+      LocalSerializer serializer,
+      StatsCollector statsCollector,
+      User user) {
     this.db = persistence;
     this.serializer = serializer;
+    this.statsCollector = statsCollector;
     this.uid = user.isAuthenticated() ? user.getUid() : "";
     this.lastStreamToken = WriteStream.EMPTY_STREAM_TOKEN;
   }
@@ -212,12 +219,16 @@ public MutationBatch addMutationBatch(
       db.getIndexManager().addToCollectionParentIndex(key.getPath().popLast());
     }
 
+    statsCollector.recordRowsWritten(STATS_TAG, mutations.size());
+
     return batch;
   }
 
   @Nullable
   @Override
   public MutationBatch lookupMutationBatch(int batchId) {
+    statsCollector.recordRowsRead(STATS_TAG, 1);
+
     return db.query("SELECT SUBSTR(mutations, 1, ?) FROM mutations WHERE uid = ? AND batch_id = ?")
         .binding(BLOB_MAX_INLINE_LENGTH, uid, batchId)
         .firstValue(row -> decodeInlineMutationBatch(batchId, row.getBlob(0)));
@@ -226,6 +237,8 @@ public MutationBatch lookupMutationBatch(int batchId) {
   @Nullable
   @Override
   public MutationBatch getNextMutationBatchAfterBatchId(int batchId) {
+    statsCollector.recordRowsRead(STATS_TAG, 1);
+
     int nextBatchId = batchId + 1;
 
     return db.query(
@@ -236,15 +249,26 @@ public MutationBatch getNextMutationBatchAfterBatchId(int batchId) {
         .firstValue(row -> decodeInlineMutationBatch(row.getInt(0), row.getBlob(1)));
   }
 
+  @Override
+  public int getHighestUnacknowledgedBatchId() {
+    return db.query("SELECT IFNULL(MAX(batch_id), ?) FROM mutations WHERE uid = ?")
+        .binding(MutationBatch.UNKNOWN, uid)
+        .firstValue(row -> row.getInt(0));
+  }
+
   @Override
   public List<MutationBatch> getAllMutationBatches() {
     List<MutationBatch> result = new ArrayList<>();
-    db.query(
-            "SELECT batch_id, SUBSTR(mutations, 1, ?) "
-                + "FROM mutations "
-                + "WHERE uid = ? ORDER BY batch_id ASC")
-        .binding(BLOB_MAX_INLINE_LENGTH, uid)
-        .forEach(row -> result.add(decodeInlineMutationBatch(row.getInt(0), row.getBlob(1))));
+    int rowsProcessed =
+        db.query(
+                "SELECT batch_id, SUBSTR(mutations, 1, ?) "
+                    + "FROM mutations "
+                    + "WHERE uid = ? ORDER BY batch_id ASC")
+            .binding(BLOB_MAX_INLINE_LENGTH, uid)
+            .forEach(row -> result.add(decodeInlineMutationBatch(row.getInt(0), row.getBlob(1))));
+
+    statsCollector.recordRowsRead(STATS_TAG, rowsProcessed);
+
     return result;
   }
 
@@ -253,16 +277,20 @@ public MutationBatch getNextMutationBatchAfterBatchId(int batchId) {
     String path = EncodedPath.encode(documentKey.getPath());
 
     List<MutationBatch> result = new ArrayList<>();
-    db.query(
-            "SELECT m.batch_id, SUBSTR(m.mutations, 1, ?) "
-                + "FROM document_mutations dm, mutations m "
-                + "WHERE dm.uid = ? "
-                + "AND dm.path = ? "
-                + "AND dm.uid = m.uid "
-                + "AND dm.batch_id = m.batch_id "
-                + "ORDER BY dm.batch_id")
-        .binding(BLOB_MAX_INLINE_LENGTH, uid, path)
-        .forEach(row -> result.add(decodeInlineMutationBatch(row.getInt(0), row.getBlob(1))));
+    int rowsProcessed =
+        db.query(
+                "SELECT m.batch_id, SUBSTR(m.mutations, 1, ?) "
+                    + "FROM document_mutations dm, mutations m "
+                    + "WHERE dm.uid = ? "
+                    + "AND dm.path = ? "
+                    + "AND dm.uid = m.uid "
+                    + "AND dm.batch_id = m.batch_id "
+                    + "ORDER BY dm.batch_id")
+            .binding(BLOB_MAX_INLINE_LENGTH, uid, path)
+            .forEach(row -> result.add(decodeInlineMutationBatch(row.getInt(0), row.getBlob(1))));
+
+    statsCollector.recordRowsRead(STATS_TAG, rowsProcessed);
+
     return result;
   }
 
@@ -288,21 +316,26 @@ public MutationBatch getNextMutationBatchAfterBatchId(int batchId) {
                 + "AND dm.batch_id = m.batch_id "
                 + "ORDER BY dm.batch_id");
 
+    int rowsProcessed = 0;
+
     List<MutationBatch> result = new ArrayList<>();
     Set<Integer> uniqueBatchIds = new HashSet<>();
     while (longQuery.hasMoreSubqueries()) {
-      longQuery
-          .performNextSubquery()
-          .forEach(
-              row -> {
-                int batchId = row.getInt(0);
-                if (!uniqueBatchIds.contains(batchId)) {
-                  uniqueBatchIds.add(batchId);
-                  result.add(decodeInlineMutationBatch(batchId, row.getBlob(1)));
-                }
-              });
+      rowsProcessed +=
+          longQuery
+              .performNextSubquery()
+              .forEach(
+                  row -> {
+                    int batchId = row.getInt(0);
+                    if (!uniqueBatchIds.contains(batchId)) {
+                      uniqueBatchIds.add(batchId);
+                      result.add(decodeInlineMutationBatch(batchId, row.getBlob(1)));
+                    }
+                  });
     }
 
+    statsCollector.recordRowsRead(STATS_TAG, rowsProcessed);
+
     // If more than one query was issued, batches might be in an unsorted order (batches are ordered
     // within one query's results, but not across queries). It's likely to be rare, so don't impose
     // performance penalty on the normal case.
@@ -342,39 +375,43 @@ public MutationBatch getNextMutationBatchAfterBatchId(int batchId) {
     String prefixSuccessorPath = EncodedPath.prefixSuccessor(prefixPath);
 
     List<MutationBatch> result = new ArrayList<>();
-    db.query(
-            "SELECT dm.batch_id, dm.path, SUBSTR(m.mutations, 1, ?) "
-                + "FROM document_mutations dm, mutations m "
-                + "WHERE dm.uid = ? "
-                + "AND dm.path >= ? "
-                + "AND dm.path < ? "
-                + "AND dm.uid = m.uid "
-                + "AND dm.batch_id = m.batch_id "
-                + "ORDER BY dm.batch_id")
-        .binding(BLOB_MAX_INLINE_LENGTH, uid, prefixPath, prefixSuccessorPath)
-        .forEach(
-            row -> {
-              // Ensure unique batches only. This works because the batches come out in order so we
-              // only need to ensure that the batchId of this row is different from the preceding
-              // one.
-              int batchId = row.getInt(0);
-              int size = result.size();
-              if (size > 0 && batchId == result.get(size - 1).getBatchId()) {
-                return;
-              }
-
-              // The query is actually returning any path that starts with the query path prefix
-              // which may include documents in subcollections. For example, a query on 'rooms'
-              // will return rooms/abc/messages/xyx but we shouldn't match it. Fix this by
-              // discarding rows with document keys more than one segment longer than the query
-              // path.
-              ResourcePath path = EncodedPath.decodeResourcePath(row.getString(1));
-              if (path.length() != immediateChildrenPathLength) {
-                return;
-              }
-
-              result.add(decodeInlineMutationBatch(batchId, row.getBlob(2)));
-            });
+
+    int rowsProcessed =
+        db.query(
+                "SELECT dm.batch_id, dm.path, SUBSTR(m.mutations, 1, ?) "
+                    + "FROM document_mutations dm, mutations m "
+                    + "WHERE dm.uid = ? "
+                    + "AND dm.path >= ? "
+                    + "AND dm.path < ? "
+                    + "AND dm.uid = m.uid "
+                    + "AND dm.batch_id = m.batch_id "
+                    + "ORDER BY dm.batch_id")
+            .binding(BLOB_MAX_INLINE_LENGTH, uid, prefixPath, prefixSuccessorPath)
+            .forEach(
+                row -> {
+                  // Ensure unique batches only. This works because the batches come out in order so
+                  // we only need to ensure that the batchId of this row is different from the
+                  // preceding one.
+                  int batchId = row.getInt(0);
+                  int size = result.size();
+                  if (size > 0 && batchId == result.get(size - 1).getBatchId()) {
+                    return;
+                  }
+
+                  // The query is actually returning any path that starts with the query path prefix
+                  // which may include documents in subcollections. For example, a query on 'rooms'
+                  // will return rooms/abc/messages/xyx but we shouldn't match it. Fix this by
+                  // discarding rows with document keys more than one segment longer than the query
+                  // path.
+                  ResourcePath path = EncodedPath.decodeResourcePath(row.getString(1));
+                  if (path.length() != immediateChildrenPathLength) {
+                    return;
+                  }
+
+                  result.add(decodeInlineMutationBatch(batchId, row.getBlob(2)));
+                });
+
+    statsCollector.recordRowsRead(STATS_TAG, rowsProcessed);
 
     return result;
   }
@@ -397,6 +434,8 @@ public void removeMutationBatch(MutationBatch batch) {
       db.execute(indexDeleter, uid, path, batchId);
       db.getReferenceDelegate().removeMutationReference(key);
     }
+
+    statsCollector.recordRowsDeleted(STATS_TAG, batch.getMutations().size());
   }
 
   @Override
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLitePersistence.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLitePersistence.java
index dec418371..0ffc415d8 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLitePersistence.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLitePersistence.java
@@ -27,7 +27,8 @@
 import android.database.sqlite.SQLiteProgram;
 import android.database.sqlite.SQLiteStatement;
 import android.database.sqlite.SQLiteTransactionListener;
-import android.support.annotation.VisibleForTesting;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.google.common.base.Function;
 import com.google.firebase.firestore.FirebaseFirestoreException;
 import com.google.firebase.firestore.FirebaseFirestoreException.Code;
@@ -45,7 +46,6 @@
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
-import javax.annotation.Nullable;
 
 /**
  * A SQLite-backed instance of Persistence.
@@ -54,7 +54,6 @@
  * helper routines that make dealing with SQLite much more pleasant.
  */
 public final class SQLitePersistence extends Persistence {
-
   /**
    * Creates the database name that is used to identify the database to be used with a Firestore
    * instance. Note that this needs to stay stable across releases. The database is uniquely
@@ -78,10 +77,9 @@ public static String databaseName(String persistenceKey, DatabaseId databaseId)
     }
   }
 
-  private final OpenHelper opener;
+  private final SQLiteOpenHelper opener;
   private final LocalSerializer serializer;
-  private SQLiteDatabase db;
-  private boolean started;
+  private final StatsCollector statsCollector;
   private final SQLiteQueryCache queryCache;
   private final SQLiteIndexManager indexManager;
   private final SQLiteRemoteDocumentCache remoteDocumentCache;
@@ -102,18 +100,49 @@ public void onCommit() {
         public void onRollback() {}
       };
 
+  private SQLiteDatabase db;
+  private boolean started;
+
   public SQLitePersistence(
       Context context,
       String persistenceKey,
       DatabaseId databaseId,
       LocalSerializer serializer,
       LruGarbageCollector.Params params) {
-    String databaseName = databaseName(persistenceKey, databaseId);
-    this.opener = new OpenHelper(context, databaseName);
+    this(
+        context,
+        persistenceKey,
+        databaseId,
+        serializer,
+        StatsCollector.NO_OP_STATS_COLLECTOR,
+        params);
+  }
+
+  public SQLitePersistence(
+      Context context,
+      String persistenceKey,
+      DatabaseId databaseId,
+      LocalSerializer serializer,
+      StatsCollector statsCollector,
+      LruGarbageCollector.Params params) {
+    this(
+        serializer,
+        statsCollector,
+        params,
+        new OpenHelper(context, databaseName(persistenceKey, databaseId)));
+  }
+
+  public SQLitePersistence(
+      LocalSerializer serializer,
+      StatsCollector statsCollector,
+      LruGarbageCollector.Params params,
+      SQLiteOpenHelper openHelper) {
+    this.opener = openHelper;
     this.serializer = serializer;
+    this.statsCollector = statsCollector;
     this.queryCache = new SQLiteQueryCache(this, this.serializer);
     this.indexManager = new SQLiteIndexManager(this);
-    this.remoteDocumentCache = new SQLiteRemoteDocumentCache(this, this.serializer);
+    this.remoteDocumentCache = new SQLiteRemoteDocumentCache(this, this.serializer, statsCollector);
     this.referenceDelegate = new SQLiteLruReferenceDelegate(this, params);
   }
 
@@ -126,13 +155,13 @@ public void start() {
     } catch (SQLiteDatabaseLockedException e) {
       // TODO: Use a better exception type
       throw new RuntimeException(
-          "Failed to gain exclusive lock to the Firestore client's offline persistence. This"
-              + " generally means you are using Firestore from multiple processes in your app."
-              + " Keep in mind that multi-process Android apps execute the code in your"
+          "Failed to gain exclusive lock to the Cloud Firestore client's offline persistence. This"
+              + " generally means you are using Cloud Firestore from multiple processes in your"
+              + " app. Keep in mind that multi-process Android apps execute the code in your"
               + " Application class in all processes, so you may need to avoid initializing"
-              + " Firestore in your Application class. If you are intentionally using Firestore"
-              + " from multiple processes, you can only enable offline persistence (i.e. call"
-              + " setPersistenceEnabled(true)) in one of them.",
+              + " Cloud Firestore in your Application class. If you are intentionally using Cloud"
+              + " Firestore from multiple processes, you can only enable offline persistence (that"
+              + " is, call setPersistenceEnabled(true)) in one of them.",
           e);
     }
     queryCache.start();
@@ -159,7 +188,7 @@ public SQLiteLruReferenceDelegate getReferenceDelegate() {
 
   @Override
   MutationQueue getMutationQueue(User user) {
-    return new SQLiteMutationQueue(this, serializer, user);
+    return new SQLiteMutationQueue(this, serializer, statsCollector, user);
   }
 
   @Override
@@ -332,8 +361,7 @@ public void onOpen(SQLiteDatabase db) {
   }
 
   /**
-   * Execute the given non-query SQL statement. Equivalent to <code>execute(prepare(sql), args)
-   * </code>.
+   * Execute the given non-query SQL statement. Equivalent to {@code execute(prepare(sql), args)}.
    */
   void execute(String sql, Object... args) {
     // Note that unlike db.query and friends, execSQL already takes Object[] bindArgs so there's no
@@ -447,19 +475,17 @@ Query binding(Object... args) {
      * Runs the query, calling the consumer once for each row in the results.
      *
      * @param consumer A consumer that will receive the first row.
+     * @return The number of rows processed
      */
-    void forEach(Consumer<Cursor> consumer) {
-      Cursor cursor = null;
-      try {
-        cursor = startQuery();
+    int forEach(Consumer<Cursor> consumer) {
+      int rowsProcessed = 0;
+      try (Cursor cursor = startQuery()) {
         while (cursor.moveToNext()) {
+          ++rowsProcessed;
           consumer.accept(cursor);
         }
-      } finally {
-        if (cursor != null) {
-          cursor.close();
-        }
       }
+      return rowsProcessed;
     }
 
     /**
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteQueryCache.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteQueryCache.java
index 571b30213..fb266a844 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteQueryCache.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteQueryCache.java
@@ -19,6 +19,7 @@
 
 import android.database.sqlite.SQLiteStatement;
 import android.util.SparseArray;
+import androidx.annotation.Nullable;
 import com.google.firebase.Timestamp;
 import com.google.firebase.database.collection.ImmutableSortedSet;
 import com.google.firebase.firestore.core.Query;
@@ -27,7 +28,6 @@
 import com.google.firebase.firestore.proto.Target;
 import com.google.firebase.firestore.util.Consumer;
 import com.google.protobuf.InvalidProtocolBufferException;
-import javax.annotation.Nullable;
 
 /** Cached Queries backed by SQLite. */
 final class SQLiteQueryCache implements QueryCache {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteRemoteDocumentCache.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteRemoteDocumentCache.java
index 79fb238e0..c1270ef0d 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteRemoteDocumentCache.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteRemoteDocumentCache.java
@@ -17,38 +17,58 @@
 import static com.google.firebase.firestore.util.Assert.fail;
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import androidx.annotation.Nullable;
+import com.google.firebase.Timestamp;
 import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.firestore.core.Query;
 import com.google.firebase.firestore.model.Document;
+import com.google.firebase.firestore.model.DocumentCollections;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.MaybeDocument;
 import com.google.firebase.firestore.model.ResourcePath;
+import com.google.firebase.firestore.model.SnapshotVersion;
+import com.google.firebase.firestore.util.BackgroundQueue;
+import com.google.firebase.firestore.util.Executors;
 import com.google.protobuf.InvalidProtocolBufferException;
 import com.google.protobuf.MessageLite;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import javax.annotation.Nullable;
+import java.util.concurrent.Executor;
 
 final class SQLiteRemoteDocumentCache implements RemoteDocumentCache {
 
   private final SQLitePersistence db;
   private final LocalSerializer serializer;
+  private final StatsCollector statsCollector;
 
-  SQLiteRemoteDocumentCache(SQLitePersistence persistence, LocalSerializer serializer) {
+  SQLiteRemoteDocumentCache(
+      SQLitePersistence persistence, LocalSerializer serializer, StatsCollector statsCollector) {
     this.db = persistence;
     this.serializer = serializer;
+    this.statsCollector = statsCollector;
   }
 
   @Override
-  public void add(MaybeDocument maybeDocument) {
+  public void add(MaybeDocument maybeDocument, SnapshotVersion readTime) {
+    hardAssert(
+        !readTime.equals(SnapshotVersion.NONE),
+        "Cannot add document to the RemoteDocumentCache with a read time of zero");
+
     String path = pathForKey(maybeDocument.getKey());
+    Timestamp timestamp = readTime.getTimestamp();
     MessageLite message = serializer.encodeMaybeDocument(maybeDocument);
 
+    statsCollector.recordRowsWritten(STATS_TAG, 1);
+
     db.execute(
-        "INSERT OR REPLACE INTO remote_documents (path, contents) VALUES (?, ?)",
+        "INSERT OR REPLACE INTO remote_documents "
+            + "(path, read_time_seconds, read_time_nanos, contents) "
+            + "VALUES (?, ?, ?, ?)",
         path,
+        timestamp.getSeconds(),
+        timestamp.getNanoseconds(),
         message.toByteArray());
 
     db.getIndexManager().addToCollectionParentIndex(maybeDocument.getKey().getPath().popLast());
@@ -58,6 +78,8 @@ public void add(MaybeDocument maybeDocument) {
   public void remove(DocumentKey documentKey) {
     String path = pathForKey(documentKey);
 
+    statsCollector.recordRowsDeleted(STATS_TAG, 1);
+
     db.execute("DELETE FROM remote_documents WHERE path = ?", path);
   }
 
@@ -66,6 +88,8 @@ public void remove(DocumentKey documentKey) {
   public MaybeDocument get(DocumentKey documentKey) {
     String path = pathForKey(documentKey);
 
+    statsCollector.recordRowsRead(STATS_TAG, 1);
+
     return db.query("SELECT contents FROM remote_documents WHERE path = ?")
         .binding(path)
         .firstValue(row -> decodeMaybeDocument(row.getBlob(0)));
@@ -92,21 +116,27 @@ public MaybeDocument get(DocumentKey documentKey) {
             args,
             ") ORDER BY path");
 
+    int rowsProcessed = 0;
+
     while (longQuery.hasMoreSubqueries()) {
-      longQuery
-          .performNextSubquery()
-          .forEach(
-              row -> {
-                MaybeDocument decoded = decodeMaybeDocument(row.getBlob(0));
-                results.put(decoded.getKey(), decoded);
-              });
+      rowsProcessed +=
+          longQuery
+              .performNextSubquery()
+              .forEach(
+                  row -> {
+                    MaybeDocument decoded = decodeMaybeDocument(row.getBlob(0));
+                    results.put(decoded.getKey(), decoded);
+                  });
     }
 
+    statsCollector.recordRowsRead(STATS_TAG, rowsProcessed);
+
     return results;
   }
 
   @Override
-  public ImmutableSortedMap<DocumentKey, Document> getAllDocumentsMatchingQuery(Query query) {
+  public ImmutableSortedMap<DocumentKey, Document> getAllDocumentsMatchingQuery(
+      Query query, SnapshotVersion sinceReadTime) {
     hardAssert(
         !query.isCollectionGroupQuery(),
         "CollectionGroup queries should be handled in LocalDocumentsView");
@@ -117,12 +147,37 @@ public MaybeDocument get(DocumentKey documentKey) {
 
     String prefixPath = EncodedPath.encode(prefix);
     String prefixSuccessorPath = EncodedPath.prefixSuccessor(prefixPath);
+    Timestamp readTime = sinceReadTime.getTimestamp();
+
+    BackgroundQueue backgroundQueue = new BackgroundQueue();
+
+    ImmutableSortedMap<DocumentKey, Document>[] matchingDocuments =
+        (ImmutableSortedMap<DocumentKey, Document>[])
+            new ImmutableSortedMap[] {DocumentCollections.emptyDocumentMap()};
+
+    SQLitePersistence.Query sqlQuery;
+    if (sinceReadTime.equals(SnapshotVersion.NONE)) {
+      sqlQuery =
+          db.query("SELECT path, contents FROM remote_documents WHERE path >= ? AND path < ?")
+              .binding(prefixPath, prefixSuccessorPath);
+    } else {
+      // Execute an index-free query and filter by read time. This is safe since all document
+      // changes to queries that have a lastLimboFreeSnapshotVersion (`sinceReadTime`) have a read
+      // time set.
+      sqlQuery =
+          db.query(
+                  "SELECT path, contents FROM remote_documents WHERE path >= ? AND path < ?"
+                      + "AND (read_time_seconds > ? OR (read_time_seconds = ? AND read_time_nanos > ?))")
+              .binding(
+                  prefixPath,
+                  prefixSuccessorPath,
+                  readTime.getSeconds(),
+                  readTime.getSeconds(),
+                  readTime.getNanoseconds());
+    }
 
-    Map<DocumentKey, Document> results = new HashMap<>();
-
-    db.query("SELECT path, contents FROM remote_documents WHERE path >= ? AND path < ?")
-        .binding(prefixPath, prefixSuccessorPath)
-        .forEach(
+    int rowsProcessed =
+        sqlQuery.forEach(
             row -> {
               // TODO: Actually implement a single-collection query
               //
@@ -136,20 +191,33 @@ public MaybeDocument get(DocumentKey documentKey) {
                 return;
               }
 
-              MaybeDocument maybeDoc = decodeMaybeDocument(row.getBlob(1));
-              if (!(maybeDoc instanceof Document)) {
-                return;
-              }
+              byte[] rawDocument = row.getBlob(1);
+
+              // Since scheduling background tasks incurs overhead, we only dispatch to a
+              // background thread if there are still some documents remaining.
+              Executor executor = row.isLast() ? Executors.DIRECT_EXECUTOR : backgroundQueue;
+              executor.execute(
+                  () -> {
+                    MaybeDocument maybeDoc = decodeMaybeDocument(rawDocument);
+
+                    if (maybeDoc instanceof Document && query.matches((Document) maybeDoc)) {
+                      synchronized (SQLiteRemoteDocumentCache.this) {
+                        matchingDocuments[0] =
+                            matchingDocuments[0].insert(maybeDoc.getKey(), (Document) maybeDoc);
+                      }
+                    }
+                  });
+            });
 
-              Document doc = (Document) maybeDoc;
-              if (!query.matches(doc)) {
-                return;
-              }
+    statsCollector.recordRowsRead(STATS_TAG, rowsProcessed);
 
-              results.put(doc.getKey(), doc);
-            });
+    try {
+      backgroundQueue.drain();
+    } catch (InterruptedException e) {
+      fail("Interrupted while deserializing documents", e);
+    }
 
-    return ImmutableSortedMap.Builder.fromMap(results, DocumentKey.comparator());
+    return matchingDocuments[0];
   }
 
   private String pathForKey(DocumentKey key) {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java
index 19766d3aa..132737445 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java
@@ -14,6 +14,7 @@
 
 package com.google.firebase.firestore.local;
 
+import static com.google.firebase.firestore.util.Assert.fail;
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
 import android.content.ContentValues;
@@ -21,12 +22,14 @@
 import android.database.DatabaseUtils;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteStatement;
-import android.support.annotation.VisibleForTesting;
 import android.text.TextUtils;
 import android.util.Log;
+import androidx.annotation.VisibleForTesting;
 import com.google.common.base.Preconditions;
 import com.google.firebase.firestore.model.ResourcePath;
+import com.google.firebase.firestore.proto.Target;
 import com.google.firebase.firestore.util.Consumer;
+import com.google.protobuf.InvalidProtocolBufferException;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -46,7 +49,8 @@
    * The version of the schema. Increase this by one for each migration added to runMigrations
    * below.
    */
-  static final int VERSION = 8;
+  static final int VERSION = 9;
+
   // Remove this constant and increment VERSION to enable indexing support
   static final int INDEXING_SUPPORT_VERSION = VERSION + 1;
 
@@ -127,6 +131,19 @@ void runMigrations(int fromVersion, int toVersion) {
       createV8CollectionParentsIndex();
     }
 
+    if (fromVersion < 9 && toVersion >= 9) {
+      if (!hasReadTime()) {
+        addReadTime();
+      } else {
+        // Index-free queries rely on the fact that documents updated after a query's last limbo
+        // free snapshot version are persisted with their read-time. If a customer upgrades to
+        // schema version 9, downgrades and then upgrades again, some queries may have a last limbo
+        // free snapshot version despite the fact that not all updated document have an associated
+        // read time.
+        dropLastLimboFreeSnapshotVersion();
+      }
+    }
+
     /*
      * Adding a new migration? READ THIS FIRST!
      *
@@ -351,6 +368,41 @@ private void addSequenceNumber() {
     }
   }
 
+  private boolean hasReadTime() {
+    boolean hasReadTimeSeconds = tableContainsColumn("remote_documents", "read_time_seconds");
+    boolean hasReadTimeNanos = tableContainsColumn("remote_documents", "read_time_nanos");
+
+    hardAssert(
+        hasReadTimeSeconds == hasReadTimeNanos,
+        "Table contained just one of read_time_seconds or read_time_nanos");
+
+    return hasReadTimeSeconds && hasReadTimeNanos;
+  }
+
+  private void addReadTime() {
+    db.execSQL("ALTER TABLE remote_documents ADD COLUMN read_time_seconds INTEGER");
+    db.execSQL("ALTER TABLE remote_documents ADD COLUMN read_time_nanos INTEGER");
+  }
+
+  private void dropLastLimboFreeSnapshotVersion() {
+    new SQLitePersistence.Query(db, "SELECT target_id, target_proto FROM targets")
+        .forEach(
+            cursor -> {
+              int targetId = cursor.getInt(0);
+              byte[] targetProtoBytes = cursor.getBlob(1);
+
+              try {
+                Target targetProto = Target.parseFrom(targetProtoBytes);
+                targetProto = targetProto.toBuilder().clearLastLimboFreeSnapshotVersion().build();
+                db.execSQL(
+                    "UPDATE targets SET target_proto = ? WHERE target_id = ?",
+                    new Object[] {targetProto.toByteArray(), targetId});
+              } catch (InvalidProtocolBufferException e) {
+                throw fail("Failed to decode Query data for target %s", targetId);
+              }
+            });
+  }
+
   /**
    * Ensures that each entry in the remote document cache has a corresponding sentinel row. Any
    * entries that lack a sentinel row are given one with the sequence number set to the highest
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SimpleQueryEngine.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SimpleQueryEngine.java
index 983445a56..998aba3bb 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SimpleQueryEngine.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SimpleQueryEngine.java
@@ -14,11 +14,16 @@
 
 package com.google.firebase.firestore.local;
 
+import static com.google.firebase.firestore.util.Assert.hardAssert;
+
+import androidx.annotation.Nullable;
 import com.google.firebase.database.collection.ImmutableSortedMap;
+import com.google.firebase.database.collection.ImmutableSortedSet;
 import com.google.firebase.firestore.core.Query;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.MaybeDocument;
+import com.google.firebase.firestore.model.SnapshotVersion;
 
 /**
  * A naive implementation of QueryEngine that just loads all the documents in the queried collection
@@ -26,17 +31,21 @@
  */
 public class SimpleQueryEngine implements QueryEngine {
 
-  private final LocalDocumentsView localDocumentsView;
+  private LocalDocumentsView localDocumentsView;
 
-  public SimpleQueryEngine(LocalDocumentsView localDocumentsView) {
-    this.localDocumentsView = localDocumentsView;
+  @Override
+  public void setLocalDocumentsView(LocalDocumentsView localDocuments) {
+    this.localDocumentsView = localDocuments;
   }
 
   @Override
-  public ImmutableSortedMap<DocumentKey, Document> getDocumentsMatchingQuery(Query query) {
+  public ImmutableSortedMap<DocumentKey, Document> getDocumentsMatchingQuery(
+      Query query, @Nullable QueryData queryData, ImmutableSortedSet<DocumentKey> remoteKeys) {
+    hardAssert(localDocumentsView != null, "setLocalDocumentsView() not called");
+
     // TODO: Once LocalDocumentsView provides a getCollectionDocuments() method, we
     // should call that here and then filter the results.
-    return localDocumentsView.getDocumentsMatchingQuery(query);
+    return localDocumentsView.getDocumentsMatchingQuery(query, SnapshotVersion.NONE);
   }
 
   @Override
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/StatsCollector.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/StatsCollector.java
new file mode 100644
index 000000000..04b5c0bec
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/StatsCollector.java
@@ -0,0 +1,36 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.local;
+
+/**
+ * Collects the operation count from the persistence layer. Implementing subclasses can expose this
+ * information to measure the efficiency of persistence operations.
+ *
+ * <p>The only consumer of operation counts is currently the LocalStoreTestCase (via {@link
+ * com.google.firebase.firestore.local.AccumulatingStatsCollector}). If you are not interested in
+ * the stats, you can use `NO_OP_STATS_COLLECTOR` for the default empty stats collector.
+ */
+class StatsCollector {
+  static final StatsCollector NO_OP_STATS_COLLECTOR = new StatsCollector();
+
+  /** Records the number of rows read for the given tag. */
+  void recordRowsRead(String tag, int count) {}
+
+  /** Records the number of rows deleted for the given tag. */
+  void recordRowsDeleted(String tag, int count) {}
+
+  /** Records the number of rows written for the given tag. */
+  void recordRowsWritten(String tag, int count) {}
+}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/package-info.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/package-info.java
index d9b77cfa6..71ae86398 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/package-info.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.firestore.local;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/BasePath.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/BasePath.java
index 4da80b39d..67ad87f09 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/BasePath.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/BasePath.java
@@ -16,7 +16,7 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.google.firebase.firestore.util.Util;
 import java.util.ArrayList;
 import java.util.List;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/DatabaseId.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/DatabaseId.java
index 034bacc13..7e67ece31 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/DatabaseId.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/DatabaseId.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.firestore.model;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 
 /** Represents a particular database in Firestore */
 public final class DatabaseId implements Comparable<DatabaseId> {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/Document.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/Document.java
index 4485c5df1..f12441594 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/Document.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/Document.java
@@ -14,10 +14,17 @@
 
 package com.google.firebase.firestore.model;
 
+import static com.google.firebase.firestore.util.Assert.hardAssert;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.google.common.base.Function;
 import com.google.firebase.firestore.model.value.FieldValue;
 import com.google.firebase.firestore.model.value.ObjectValue;
+import com.google.firestore.v1.Value;
 import java.util.Comparator;
-import javax.annotation.Nullable;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 /**
  * Represents a document in Firestore with a key, version, data and whether the data has local
@@ -36,58 +43,107 @@
   }
 
   private static final Comparator<Document> KEY_COMPARATOR =
-      new Comparator<Document>() {
-        @Override
-        public int compare(Document left, Document right) {
-          return left.getKey().compareTo(right.getKey());
-        }
-      };
+      (left, right) -> left.getKey().compareTo(right.getKey());
 
   /** A document comparator that returns document by key and key only. */
   public static Comparator<Document> keyComparator() {
     return KEY_COMPARATOR;
   }
 
-  private final ObjectValue data;
-
   private final DocumentState documentState;
+  private @Nullable final com.google.firestore.v1.Document proto;
+  private @Nullable final Function<Value, FieldValue> converter;
+  private @Nullable ObjectValue objectValue;
 
-  /**
-   * Memoized serialized form of the document for optimization purposes (avoids repeated
-   * serialization). Might be null.
-   */
-  private final com.google.firestore.v1.Document proto;
-
-  public @Nullable com.google.firestore.v1.Document getProto() {
-    return proto;
-  }
+  /** A cache for FieldValues that have already been deserialized in `getField()`. */
+  private @Nullable Map<FieldPath, FieldValue> fieldValueCache;
 
   public Document(
-      DocumentKey key, SnapshotVersion version, ObjectValue data, DocumentState documentState) {
+      DocumentKey key,
+      SnapshotVersion version,
+      DocumentState documentState,
+      ObjectValue objectValue) {
     super(key, version);
-    this.data = data;
     this.documentState = documentState;
+    this.objectValue = objectValue;
     this.proto = null;
+    this.converter = null;
   }
 
   public Document(
       DocumentKey key,
       SnapshotVersion version,
-      ObjectValue data,
       DocumentState documentState,
-      com.google.firestore.v1.Document proto) {
+      com.google.firestore.v1.Document proto,
+      Function<com.google.firestore.v1.Value, FieldValue> converter) {
     super(key, version);
-    this.data = data;
     this.documentState = documentState;
     this.proto = proto;
+    this.converter = converter;
   }
 
+  /**
+   * Memoized serialized form of the document for optimization purposes (avoids repeated
+   * serialization). Might be null.
+   */
+  public @Nullable com.google.firestore.v1.Document getProto() {
+    return proto;
+  }
+
+  @NonNull
   public ObjectValue getData() {
-    return data;
+    if (objectValue == null) {
+      hardAssert(proto != null && converter != null, "Expected proto and converter to be non-null");
+
+      ObjectValue result = ObjectValue.emptyObject();
+      for (Map.Entry<String, com.google.firestore.v1.Value> entry :
+          proto.getFieldsMap().entrySet()) {
+        FieldPath path = FieldPath.fromSingleSegment(entry.getKey());
+        FieldValue value = converter.apply(entry.getValue());
+        result = result.set(path, value);
+      }
+      objectValue = result;
+
+      // Once objectValue is computed, values inside the fieldValueCache are no longer accessed.
+      fieldValueCache = null;
+    }
+
+    return objectValue;
   }
 
   public @Nullable FieldValue getField(FieldPath path) {
-    return data.get(path);
+    if (objectValue != null) {
+      return objectValue.get(path);
+    } else {
+      hardAssert(proto != null && converter != null, "Expected proto and converter to be non-null");
+
+      if (fieldValueCache == null) {
+        // TODO(b/136090445): Remove the cache when `getField` is no longer called during Query
+        // ordering.
+        fieldValueCache = new ConcurrentHashMap<>();
+      }
+
+      FieldValue fieldValue = fieldValueCache.get(path);
+      if (fieldValue == null) {
+        // Instead of deserializing the full Document proto, we only deserialize the value at
+        // the requested field path. This speeds up Query execution as query filters can discard
+        // documents based on a single field.
+        Value protoValue = proto.getFieldsMap().get(path.getFirstSegment());
+        for (int i = 1; protoValue != null && i < path.length(); ++i) {
+          if (protoValue.getValueTypeCase() != Value.ValueTypeCase.MAP_VALUE) {
+            return null;
+          }
+          protoValue = protoValue.getMapValue().getFieldsMap().get(path.getSegment(i));
+        }
+
+        if (protoValue != null) {
+          fieldValue = converter.apply(protoValue);
+          fieldValueCache.put(path, fieldValue);
+        }
+      }
+
+      return fieldValue;
+    }
   }
 
   public @Nullable Object getFieldValue(FieldPath path) {
@@ -113,7 +169,7 @@ public boolean equals(Object o) {
     if (this == o) {
       return true;
     }
-    if (o == null || getClass() != o.getClass()) {
+    if (!(o instanceof Document)) {
       return false;
     }
 
@@ -122,13 +178,13 @@ public boolean equals(Object o) {
     return getVersion().equals(document.getVersion())
         && getKey().equals(document.getKey())
         && documentState.equals(document.documentState)
-        && data.equals(document.data);
+        && getData().equals(document.getData());
   }
 
   @Override
   public int hashCode() {
+    // Note: We deliberately decided to omit `getData()` since its computation is expensive.
     int result = getKey().hashCode();
-    result = 31 * result + data.hashCode();
     result = 31 * result + getVersion().hashCode();
     result = 31 * result + documentState.hashCode();
     return result;
@@ -140,7 +196,7 @@ public String toString() {
         + "key="
         + getKey()
         + ", data="
-        + data
+        + getData()
         + ", version="
         + getVersion()
         + ", documentState="
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/DocumentKey.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/DocumentKey.java
index 8edd053f7..7667801be 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/DocumentKey.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/DocumentKey.java
@@ -16,7 +16,7 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.google.firebase.database.collection.ImmutableSortedSet;
 import java.util.Collections;
 import java.util.Comparator;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/DocumentSet.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/DocumentSet.java
index 47a10987b..1fb2f7ee4 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/DocumentSet.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/DocumentSet.java
@@ -16,7 +16,8 @@
 
 import static com.google.firebase.firestore.model.DocumentCollections.emptyDocumentMap;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.database.collection.ImmutableSortedSet;
 import java.util.ArrayList;
@@ -24,7 +25,6 @@
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
-import javax.annotation.Nullable;
 
 /**
  * An immutable set of documents (unique by key) ordered by the given comparator or ordered by key
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/ArrayTransformOperation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/ArrayTransformOperation.java
index c781129e9..8f03c940c 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/ArrayTransformOperation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/ArrayTransformOperation.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.firestore.model.mutation;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.model.value.ArrayValue;
 import com.google.firebase.firestore.model.value.FieldValue;
@@ -39,17 +39,24 @@
   }
 
   @Override
-  public FieldValue applyToLocalView(FieldValue previousValue, Timestamp localWriteTime) {
+  public FieldValue applyToLocalView(@Nullable FieldValue previousValue, Timestamp localWriteTime) {
     return apply(previousValue);
   }
 
   @Override
-  public FieldValue applyToRemoteDocument(FieldValue previousValue, FieldValue transformResult) {
+  public FieldValue applyToRemoteDocument(
+      @Nullable FieldValue previousValue, FieldValue transformResult) {
     // The server just sends null as the transform result for array operations, so we have to
     // calculate a result the same as we do for local applications.
     return apply(previousValue);
   }
 
+  @Override
+  @Nullable
+  public FieldValue computeBaseValue(@Nullable FieldValue currentValue) {
+    return null; // Array transforms are idempotent and don't require a base value.
+  }
+
   @Override
   @SuppressWarnings("EqualsGetClass") // subtype-sensitive equality is intended.
   public boolean equals(Object o) {
@@ -73,7 +80,7 @@ public int hashCode() {
   }
 
   /** Applies this ArrayTransformOperation against the specified previousValue. */
-  protected abstract ArrayValue apply(FieldValue previousValue);
+  protected abstract ArrayValue apply(@Nullable FieldValue previousValue);
 
   /**
    * Inspects the provided value, returning an ArrayList copy of the internal array if it's an
@@ -88,11 +95,6 @@ public int hashCode() {
     }
   }
 
-  @Override
-  public boolean isIdempotent() {
-    return true;
-  }
-
   /** An array union transform operation. */
   public static class Union extends ArrayTransformOperation {
     public Union(List<FieldValue> elements) {
@@ -100,7 +102,7 @@ public Union(List<FieldValue> elements) {
     }
 
     @Override
-    protected ArrayValue apply(FieldValue previousValue) {
+    protected ArrayValue apply(@Nullable FieldValue previousValue) {
       ArrayList<FieldValue> result = coercedFieldValuesArray(previousValue);
       for (FieldValue element : getElements()) {
         if (!result.contains(element)) {
@@ -118,7 +120,7 @@ public Remove(List<FieldValue> elements) {
     }
 
     @Override
-    protected ArrayValue apply(FieldValue previousValue) {
+    protected ArrayValue apply(@Nullable FieldValue previousValue) {
       ArrayList<FieldValue> result = coercedFieldValuesArray(previousValue);
       for (FieldValue element : getElements()) {
         result.removeAll(Collections.singleton(element));
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/DeleteMutation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/DeleteMutation.java
index b7a00c257..9ca3060ef 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/DeleteMutation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/DeleteMutation.java
@@ -16,12 +16,13 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.MaybeDocument;
 import com.google.firebase.firestore.model.NoDocument;
 import com.google.firebase.firestore.model.SnapshotVersion;
-import javax.annotation.Nullable;
+import com.google.firebase.firestore.model.value.ObjectValue;
 
 /** Represents a Delete operation */
 public final class DeleteMutation extends Mutation {
@@ -85,12 +86,7 @@ public MaybeDocument applyToLocalView(
 
   @Nullable
   @Override
-  public FieldMask getFieldMask() {
+  public ObjectValue extractBaseValue(@Nullable MaybeDocument maybeDoc) {
     return null;
   }
-
-  @Override
-  public boolean isIdempotent() {
-    return true;
-  }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/FieldMask.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/FieldMask.java
index 16573090f..7b0f8ee9f 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/FieldMask.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/FieldMask.java
@@ -15,8 +15,6 @@
 package com.google.firebase.firestore.model.mutation;
 
 import com.google.firebase.firestore.model.FieldPath;
-import com.google.firebase.firestore.model.value.FieldValue;
-import com.google.firebase.firestore.model.value.ObjectValue;
 import java.util.Set;
 
 /**
@@ -71,25 +69,6 @@ public boolean covers(FieldPath fieldPath) {
     return false;
   }
 
-  /**
-   * Applies this field mask to the provided object value and returns an object that only contains
-   * fields that are specified in both the input object and this field mask.
-   */
-  public ObjectValue applyTo(ObjectValue data) {
-    ObjectValue filteredObject = ObjectValue.emptyObject();
-    for (FieldPath path : mask) {
-      if (path.isEmpty()) {
-        return data;
-      } else {
-        FieldValue newValue = data.get(path);
-        if (newValue != null) {
-          filteredObject = filteredObject.set(path, newValue);
-        }
-      }
-    }
-    return filteredObject;
-  }
-
   @Override
   public int hashCode() {
     return mask.hashCode();
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/FieldTransform.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/FieldTransform.java
index 831f79e07..d6739a9f8 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/FieldTransform.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/FieldTransform.java
@@ -58,8 +58,4 @@ public int hashCode() {
     result = 31 * result + operation.hashCode();
     return result;
   }
-
-  public boolean isIdempotent() {
-    return operation.isIdempotent();
-  }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/Mutation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/Mutation.java
index fb56493a8..22cb481ff 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/Mutation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/Mutation.java
@@ -16,12 +16,13 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.MaybeDocument;
 import com.google.firebase.firestore.model.SnapshotVersion;
-import javax.annotation.Nullable;
+import com.google.firebase.firestore.model.value.ObjectValue;
 
 /**
  * Represents a Mutation of a document. Different subclasses of Mutation will perform different
@@ -113,6 +114,23 @@ public abstract MaybeDocument applyToRemoteDocument(
   public abstract MaybeDocument applyToLocalView(
       @Nullable MaybeDocument maybeDoc, @Nullable MaybeDocument baseDoc, Timestamp localWriteTime);
 
+  /**
+   * If applicable, returns the base value to persist with this mutation. If a base value is
+   * provided, the mutation is always applied to this base value, even if document has already been
+   * updated.
+   *
+   * <p>The base value is a sparse object that consists of only the document fields for which this
+   * mutation contains a non-idempotent transformation (e.g. a numeric increment). The provided
+   * value guarantees consistent behavior for non-idempotent transforms and allow us to return the
+   * same latency-compensated value even if the backend has already applied the mutation. The base
+   * value is null for idempotent mutations, as they can be re-played even if the backend has
+   * already applied them.
+   *
+   * @return a base value to store along with the mutation, or null for idempotent mutations.
+   */
+  @Nullable
+  public abstract ObjectValue extractBaseValue(@Nullable MaybeDocument maybeDoc);
+
   /** Helper for derived classes to implement .equals(). */
   boolean hasSameKeyAndPrecondition(Mutation other) {
     return key.equals(other.key) && precondition.equals(other.precondition);
@@ -148,15 +166,4 @@ static SnapshotVersion getPostMutationVersion(@Nullable MaybeDocument maybeDoc)
       return SnapshotVersion.NONE;
     }
   }
-
-  /**
-   * If applicable, returns the field mask for this mutation. Fields that are not included in this
-   * field mask are not modified when this mutation is applied. Mutations that replace all document
-   * values return 'null'.
-   */
-  @Nullable
-  public abstract FieldMask getFieldMask();
-
-  /** Returns whether all operations in the mutation are idempotent. */
-  public abstract boolean isIdempotent();
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/MutationBatch.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/MutationBatch.java
index 0c68de215..4941d1608 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/MutationBatch.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/MutationBatch.java
@@ -16,6 +16,7 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.Timestamp;
 import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.firestore.model.DocumentKey;
@@ -23,7 +24,6 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-import javax.annotation.Nullable;
 
 /**
  * A batch of mutations that will be sent as one unit to the backend. Batches can be marked as a
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/MutationResult.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/MutationResult.java
index 231239fcc..0293dee05 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/MutationResult.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/MutationResult.java
@@ -16,7 +16,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.firebase.firestore.model.SnapshotVersion;
 import com.google.firebase.firestore.model.value.FieldValue;
 import java.util.List;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/NumericIncrementTransformOperation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/NumericIncrementTransformOperation.java
index baf922945..a95e2562d 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/NumericIncrementTransformOperation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/NumericIncrementTransformOperation.java
@@ -15,7 +15,9 @@
 package com.google.firebase.firestore.model.mutation;
 
 import static com.google.firebase.firestore.util.Assert.fail;
+import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.model.value.DoubleValue;
 import com.google.firebase.firestore.model.value.FieldValue;
@@ -35,23 +37,47 @@ public NumericIncrementTransformOperation(NumberValue operand) {
   }
 
   @Override
-  public FieldValue applyToLocalView(FieldValue previousValue, Timestamp localWriteTime) {
+  public FieldValue applyToLocalView(@Nullable FieldValue previousValue, Timestamp localWriteTime) {
+    NumberValue baseValue = computeBaseValue(previousValue);
+
     // Return an integer value only if the previous value and the operand is an integer.
-    if (previousValue instanceof IntegerValue && operand instanceof IntegerValue) {
-      long sum = safeIncrement(((IntegerValue) previousValue).getInternalValue(), operandAsLong());
+    if (baseValue instanceof IntegerValue && operand instanceof IntegerValue) {
+      long sum = safeIncrement(((IntegerValue) baseValue).getInternalValue(), operandAsLong());
       return IntegerValue.valueOf(sum);
-    } else if (previousValue instanceof IntegerValue) {
-      double sum = ((IntegerValue) previousValue).getInternalValue() + operandAsDouble();
+    } else if (baseValue instanceof IntegerValue) {
+      double sum = ((IntegerValue) baseValue).getInternalValue() + operandAsDouble();
       return DoubleValue.valueOf(sum);
-    } else if (previousValue instanceof DoubleValue) {
-      double sum = ((DoubleValue) previousValue).getInternalValue() + operandAsDouble();
+    } else {
+      hardAssert(
+          baseValue instanceof DoubleValue,
+          "Expected NumberValue to be of type DoubleValue, but was ",
+          previousValue.getClass().getCanonicalName());
+      double sum = ((DoubleValue) baseValue).getInternalValue() + operandAsDouble();
       return DoubleValue.valueOf(sum);
     }
+  }
+
+  @Override
+  public FieldValue applyToRemoteDocument(
+      @Nullable FieldValue previousValue, FieldValue transformResult) {
+    return transformResult;
+  }
 
-    // If the existing value is not a number, use the value of the transform as the new base value.
+  public FieldValue getOperand() {
     return operand;
   }
 
+  /**
+   * Inspects the provided value, returning the provided value if it is already a NumberValue,
+   * otherwise returning a coerced IntegerValue of 0.
+   */
+  @Override
+  public NumberValue computeBaseValue(@Nullable FieldValue previousValue) {
+    return previousValue instanceof NumberValue
+        ? (NumberValue) previousValue
+        : IntegerValue.valueOf(0L);
+  }
+
   /**
    * Implementation of Java 8's `addExact()` that resolves positive and negative numeric overflows
    * to Long.MAX_VALUE or Long.MIN_VALUE respectively (instead of throwing an ArithmeticException).
@@ -94,18 +120,4 @@ private long operandAsLong() {
               + operand.getClass().getCanonicalName());
     }
   }
-
-  @Override
-  public FieldValue applyToRemoteDocument(FieldValue previousValue, FieldValue transformResult) {
-    return transformResult;
-  }
-
-  public FieldValue getOperand() {
-    return operand;
-  }
-
-  @Override
-  public boolean isIdempotent() {
-    return false;
-  }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/PatchMutation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/PatchMutation.java
index ade731ba1..1db36f787 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/PatchMutation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/PatchMutation.java
@@ -16,6 +16,7 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentKey;
@@ -25,7 +26,6 @@
 import com.google.firebase.firestore.model.UnknownDocument;
 import com.google.firebase.firestore.model.value.FieldValue;
 import com.google.firebase.firestore.model.value.ObjectValue;
-import javax.annotation.Nullable;
 
 /**
  * A mutation that modifies fields of the document at the given key with the given values. The
@@ -112,7 +112,7 @@ public MaybeDocument applyToRemoteDocument(
 
     SnapshotVersion version = mutationResult.getVersion();
     ObjectValue newData = patchDocument(maybeDoc);
-    return new Document(getKey(), version, newData, Document.DocumentState.COMMITTED_MUTATIONS);
+    return new Document(getKey(), version, Document.DocumentState.COMMITTED_MUTATIONS, newData);
   }
 
   @Nullable
@@ -127,13 +127,13 @@ public MaybeDocument applyToLocalView(
 
     SnapshotVersion version = getPostMutationVersion(maybeDoc);
     ObjectValue newData = patchDocument(maybeDoc);
-    return new Document(getKey(), version, newData, Document.DocumentState.LOCAL_MUTATIONS);
+    return new Document(getKey(), version, Document.DocumentState.LOCAL_MUTATIONS, newData);
   }
 
   @Nullable
   @Override
-  public FieldMask getFieldMask() {
-    return mask;
+  public ObjectValue extractBaseValue(@Nullable MaybeDocument maybeDoc) {
+    return null;
   }
 
   /**
@@ -163,9 +163,4 @@ private ObjectValue patchObject(ObjectValue obj) {
     }
     return obj;
   }
-
-  @Override
-  public boolean isIdempotent() {
-    return true;
-  }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/Precondition.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/Precondition.java
index 8e988bf5e..49904ea6a 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/Precondition.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/Precondition.java
@@ -17,10 +17,10 @@
 import static com.google.firebase.firestore.util.Assert.fail;
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.MaybeDocument;
 import com.google.firebase.firestore.model.SnapshotVersion;
-import javax.annotation.Nullable;
 
 /**
  * Encodes a precondition for a mutation. This follows the model that the backend accepts with the
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/ServerTimestampOperation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/ServerTimestampOperation.java
index 0f75a9430..27dafd156 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/ServerTimestampOperation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/ServerTimestampOperation.java
@@ -14,6 +14,7 @@
 
 package com.google.firebase.firestore.model.mutation;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.model.value.FieldValue;
 import com.google.firebase.firestore.model.value.ServerTimestampValue;
@@ -29,18 +30,20 @@ public static ServerTimestampOperation getInstance() {
   }
 
   @Override
-  public FieldValue applyToLocalView(FieldValue previousValue, Timestamp localWriteTime) {
+  public FieldValue applyToLocalView(@Nullable FieldValue previousValue, Timestamp localWriteTime) {
     return new ServerTimestampValue(localWriteTime, previousValue);
   }
 
   @Override
-  public FieldValue applyToRemoteDocument(FieldValue previousValue, FieldValue transformResult) {
+  public FieldValue applyToRemoteDocument(
+      @Nullable FieldValue previousValue, FieldValue transformResult) {
     return transformResult;
   }
 
+  @Nullable
   @Override
-  public boolean isIdempotent() {
-    return true;
+  public FieldValue computeBaseValue(@Nullable FieldValue currentValue) {
+    return null; // Server timestamps are idempotent and don't require a base value.
   }
 
   // NOTE: Since we've guaranteed a singleton instance, we can rely on Object's default
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/SetMutation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/SetMutation.java
index f4fd44fe1..d148c9816 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/SetMutation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/SetMutation.java
@@ -16,13 +16,13 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.MaybeDocument;
 import com.google.firebase.firestore.model.SnapshotVersion;
 import com.google.firebase.firestore.model.value.ObjectValue;
-import javax.annotation.Nullable;
 
 /**
  * A mutation that creates or replaces the document at the given key with the object value contents.
@@ -72,7 +72,7 @@ public MaybeDocument applyToRemoteDocument(
     // accepted the mutation so the precondition must have held.
 
     SnapshotVersion version = mutationResult.getVersion();
-    return new Document(getKey(), version, value, Document.DocumentState.COMMITTED_MUTATIONS);
+    return new Document(getKey(), version, Document.DocumentState.COMMITTED_MUTATIONS, value);
   }
 
   @Nullable
@@ -86,13 +86,7 @@ public MaybeDocument applyToLocalView(
     }
 
     SnapshotVersion version = getPostMutationVersion(maybeDoc);
-    return new Document(getKey(), version, value, Document.DocumentState.LOCAL_MUTATIONS);
-  }
-
-  @Nullable
-  @Override
-  public FieldMask getFieldMask() {
-    return null;
+    return new Document(getKey(), version, Document.DocumentState.LOCAL_MUTATIONS, value);
   }
 
   /** Returns the object value to use when setting the document. */
@@ -100,8 +94,9 @@ public ObjectValue getValue() {
     return value;
   }
 
+  @Nullable
   @Override
-  public boolean isIdempotent() {
-    return true;
+  public ObjectValue extractBaseValue(@Nullable MaybeDocument maybeDoc) {
+    return null;
   }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/TransformMutation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/TransformMutation.java
index abe82a999..89434670e 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/TransformMutation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/TransformMutation.java
@@ -16,6 +16,7 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentKey;
@@ -25,10 +26,7 @@
 import com.google.firebase.firestore.model.value.FieldValue;
 import com.google.firebase.firestore.model.value.ObjectValue;
 import java.util.ArrayList;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Set;
-import javax.annotation.Nullable;
 
 /**
  * A mutation that modifies specific fields of the document with transform operations. Currently the
@@ -103,7 +101,7 @@ public MaybeDocument applyToRemoteDocument(
         serverTransformResults(doc, mutationResult.getTransformResults());
     ObjectValue newData = transformObject(doc.getData(), transformResults);
     return new Document(
-        getKey(), mutationResult.getVersion(), newData, Document.DocumentState.COMMITTED_MUTATIONS);
+        getKey(), mutationResult.getVersion(), Document.DocumentState.COMMITTED_MUTATIONS, newData);
   }
 
   @Nullable
@@ -117,29 +115,34 @@ public MaybeDocument applyToLocalView(
     }
 
     Document doc = requireDocument(maybeDoc);
-    List<FieldValue> transformResults = localTransformResults(localWriteTime, baseDoc);
+    List<FieldValue> transformResults = localTransformResults(localWriteTime, maybeDoc, baseDoc);
     ObjectValue newData = transformObject(doc.getData(), transformResults);
     return new Document(
-        getKey(), doc.getVersion(), newData, Document.DocumentState.LOCAL_MUTATIONS);
+        getKey(), doc.getVersion(), Document.DocumentState.LOCAL_MUTATIONS, newData);
   }
 
+  @Nullable
   @Override
-  public FieldMask getFieldMask() {
-    Set<FieldPath> fieldMask = new HashSet<>();
-    for (FieldTransform transform : fieldTransforms) {
-      fieldMask.add(transform.getFieldPath());
-    }
-    return FieldMask.fromSet(fieldMask);
-  }
+  public ObjectValue extractBaseValue(@Nullable MaybeDocument maybeDoc) {
+    ObjectValue baseObject = null;
 
-  @Override
-  public boolean isIdempotent() {
     for (FieldTransform transform : fieldTransforms) {
-      if (!transform.isIdempotent()) {
-        return false;
+      FieldValue existingValue = null;
+      if (maybeDoc instanceof Document) {
+        existingValue = ((Document) maybeDoc).getField(transform.getFieldPath());
+      }
+
+      FieldValue coercedValue = transform.getOperation().computeBaseValue(existingValue);
+      if (coercedValue != null) {
+        if (baseObject == null) {
+          baseObject = ObjectValue.emptyObject().set(transform.getFieldPath(), coercedValue);
+        } else {
+          baseObject = baseObject.set(transform.getFieldPath(), coercedValue);
+        }
       }
     }
-    return true;
+
+    return baseObject;
   }
 
   /**
@@ -193,17 +196,25 @@ private Document requireDocument(@Nullable MaybeDocument maybeDoc) {
    *
    * @param localWriteTime The local time of the transform mutation (used to generate
    *     ServerTimestampValues).
+   * @param maybeDoc The current state of the document after applying all previous mutations.
    * @param baseDoc The document prior to applying this mutation batch.
    * @return The transform results list.
    */
   private List<FieldValue> localTransformResults(
-      Timestamp localWriteTime, @Nullable MaybeDocument baseDoc) {
+      Timestamp localWriteTime, @Nullable MaybeDocument maybeDoc, @Nullable MaybeDocument baseDoc) {
     ArrayList<FieldValue> transformResults = new ArrayList<>(fieldTransforms.size());
     for (FieldTransform fieldTransform : fieldTransforms) {
       TransformOperation transform = fieldTransform.getOperation();
 
       FieldValue previousValue = null;
-      if (baseDoc instanceof Document) {
+      if (maybeDoc instanceof Document) {
+        previousValue = ((Document) maybeDoc).getField(fieldTransform.getFieldPath());
+      }
+
+      if (previousValue == null && baseDoc instanceof Document) {
+        // If the current document does not contain a value for the mutated field, use the value
+        // that existed before applying this mutation batch. This solves an edge case where a
+        // PatchMutation clears the values in a nested map before the TransformMutation is applied.
         previousValue = ((Document) baseDoc).getField(fieldTransform.getFieldPath());
       }
 
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/TransformOperation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/TransformOperation.java
index 22bda140c..e4be1caf3 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/TransformOperation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/TransformOperation.java
@@ -14,6 +14,7 @@
 
 package com.google.firebase.firestore.model.mutation;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.model.value.FieldValue;
 
@@ -23,14 +24,26 @@
    * Computes the local transform result against the provided previousValue, optionally using the
    * provided localWriteTime.
    */
-  FieldValue applyToLocalView(FieldValue previousValue, Timestamp localWriteTime);
+  FieldValue applyToLocalView(@Nullable FieldValue previousValue, Timestamp localWriteTime);
 
   /**
    * Computes a final transform result after the transform has been acknowledged by the server,
    * potentially using the server-provided transformResult.
    */
-  FieldValue applyToRemoteDocument(FieldValue previousValue, FieldValue transformResult);
+  FieldValue applyToRemoteDocument(@Nullable FieldValue previousValue, FieldValue transformResult);
 
-  /** Returns whether this field transform is idempotent. */
-  boolean isIdempotent();
+  /**
+   * If applicable, returns the base value to persist for this transform. If a base value is
+   * provided, the transform operation is always applied to this base value, even if document has
+   * already been updated.
+   *
+   * <p>Base values provide consistent behavior for non-idempotent transforms and allow us to return
+   * the same latency-compensated value even if the backend has already applied the transform
+   * operation. The base value is null for idempotent transforms, as they can be re-played even if
+   * the backend has already applied them.
+   *
+   * @return a base value to store along with the mutation, or null for idempotent transforms.
+   */
+  @Nullable
+  FieldValue computeBaseValue(@Nullable FieldValue previousValue);
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/package-info.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/package-info.java
index a736e4521..70f95e9b5 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/package-info.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.firestore.model.mutation;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/package-info.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/package-info.java
index 5a9166dd5..3b3ee461b 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/package-info.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.firestore.model;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ArrayValue.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ArrayValue.java
index 733546ac1..56123535f 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ArrayValue.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ArrayValue.java
@@ -70,16 +70,6 @@ public int typeOrder() {
     return res;
   }
 
-  @Override
-  public List<Object> value(FieldValueOptions options) {
-    // Recursively convert the array into the value that users will see in document snapshots.
-    List<Object> res = new ArrayList<>(internalValue.size());
-    for (FieldValue v : internalValue) {
-      res.add(v.value(options));
-    }
-    return res;
-  }
-
   public List<FieldValue> getInternalValue() {
     return internalValue;
   }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/FieldValue.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/FieldValue.java
index 61292d31d..ae5485995 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/FieldValue.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/FieldValue.java
@@ -16,9 +16,9 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.firestore.util.Util;
-import javax.annotation.Nullable;
 
 /**
  * A field value represents a data type as stored by Firestore.
@@ -63,15 +63,6 @@
   @Nullable
   public abstract Object value();
 
-  /**
-   * Converts a FieldValue into the value that users will see in document snapshots using the
-   * provided deserialization options.
-   */
-  @Nullable
-  public Object value(FieldValueOptions options) {
-    return value();
-  }
-
   @Override
   public abstract boolean equals(Object o);
 
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/FieldValueOptions.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/FieldValueOptions.java
deleted file mode 100644
index 47df719f2..000000000
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/FieldValueOptions.java
+++ /dev/null
@@ -1,66 +0,0 @@
-// Copyright 2018 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.google.firebase.firestore.model.value;
-
-import com.google.firebase.firestore.DocumentSnapshot;
-import com.google.firebase.firestore.util.Assert;
-
-/** Holds settings that define field value deserialization options. */
-public class FieldValueOptions {
-  enum ServerTimestampBehavior {
-    NONE,
-    PREVIOUS,
-    ESTIMATE
-  }
-
-  private final ServerTimestampBehavior serverTimestampBehavior;
-  private final boolean timestampsInSnapshotsEnabled;
-
-  private FieldValueOptions(
-      ServerTimestampBehavior serverTimestampBehavior, boolean timestampsInSnapshotsEnabled) {
-    this.serverTimestampBehavior = serverTimestampBehavior;
-    this.timestampsInSnapshotsEnabled = timestampsInSnapshotsEnabled;
-  }
-
-  ServerTimestampBehavior getServerTimestampBehavior() {
-    return serverTimestampBehavior;
-  }
-
-  boolean areTimestampsInSnapshotsEnabled() {
-    return timestampsInSnapshotsEnabled;
-  }
-
-  public static FieldValueOptions create(
-      DocumentSnapshot.ServerTimestampBehavior serverTimestampBehavior,
-      boolean timestampsInSnapshotsEnabled) {
-    ServerTimestampBehavior internalServerTimestampBehavior;
-    switch (serverTimestampBehavior) {
-      case ESTIMATE:
-        internalServerTimestampBehavior = ServerTimestampBehavior.ESTIMATE;
-        break;
-      case PREVIOUS:
-        internalServerTimestampBehavior = ServerTimestampBehavior.PREVIOUS;
-        break;
-      case NONE:
-        internalServerTimestampBehavior = ServerTimestampBehavior.NONE;
-        break;
-      default:
-        throw Assert.fail(
-            "Unexpected case for ServerTimestampBehavior: %s", serverTimestampBehavior.name());
-    }
-
-    return new FieldValueOptions(internalServerTimestampBehavior, timestampsInSnapshotsEnabled);
-  }
-}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/NullValue.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/NullValue.java
index 902ec5f42..e771e1d6b 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/NullValue.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/NullValue.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.firestore.model.value;
 
-import javax.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 /** A wrapper for null values in Firestore. */
 public class NullValue extends FieldValue {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ObjectValue.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ObjectValue.java
index 00bf3e2f4..d4a0ef7c8 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ObjectValue.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ObjectValue.java
@@ -16,14 +16,17 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.firestore.model.FieldPath;
+import com.google.firebase.firestore.model.mutation.FieldMask;
 import com.google.firebase.firestore.util.Util;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
-import javax.annotation.Nullable;
+import java.util.Set;
 
 /** A structured object value stored in Firestore. */
 public class ObjectValue extends FieldValue {
@@ -57,21 +60,37 @@ public int typeOrder() {
     return TYPE_ORDER_OBJECT;
   }
 
-  /** Recursively converts the Map into the value that users will see in document snapshots. */
-  @Override
-  public Map<String, Object> value() {
-    Map<String, Object> res = new HashMap<>();
+  /** Recursively extracts the FieldPaths that are set in this ObjectValue. */
+  public FieldMask getFieldMask() {
+    Set<FieldPath> fields = new HashSet<>();
     for (Map.Entry<String, FieldValue> entry : internalValue) {
-      res.put(entry.getKey(), entry.getValue().value());
+      FieldPath currentPath = FieldPath.fromSingleSegment(entry.getKey());
+      FieldValue value = entry.getValue();
+      if (value instanceof ObjectValue) {
+        FieldMask nestedMask = ((ObjectValue) value).getFieldMask();
+        Set<FieldPath> nestedFields = nestedMask.getMask();
+        if (nestedFields.isEmpty()) {
+          // Preserve the empty map by adding it to the FieldMask.
+          fields.add(currentPath);
+        } else {
+          // For nested and non-empty ObjectValues, add the FieldPath of the leaf nodes.
+          for (FieldPath nestedPath : nestedFields) {
+            fields.add(currentPath.append(nestedPath));
+          }
+        }
+      } else {
+        fields.add(currentPath);
+      }
     }
-    return res;
+    return FieldMask.fromSet(fields);
   }
 
+  /** Recursively converts the Map into the value that users will see in document snapshots. */
   @Override
-  public Map<String, Object> value(FieldValueOptions options) {
+  public Map<String, Object> value() {
     Map<String, Object> res = new HashMap<>();
     for (Map.Entry<String, FieldValue> entry : internalValue) {
-      res.put(entry.getKey(), entry.getValue().value(options));
+      res.put(entry.getKey(), entry.getValue().value());
     }
     return res;
   }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ServerTimestampValue.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ServerTimestampValue.java
index e7e9cd3d7..81e68040d 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ServerTimestampValue.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ServerTimestampValue.java
@@ -14,9 +14,9 @@
 
 package com.google.firebase.firestore.model.value;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.Timestamp;
-import com.google.firebase.firestore.util.Assert;
-import javax.annotation.Nullable;
+import com.google.firebase.firestore.DocumentSnapshot;
 
 /**
  * Represents a locally-applied Server Timestamp.
@@ -47,21 +47,23 @@ public Object value() {
     return null;
   }
 
-  @Override
+  /**
+   * Returns the value of the field before this ServerTimestamp was set.
+   *
+   * <p>Preserving the previous values allows the user to display the last resoled value until the
+   * backend responds with the timestamp {@link DocumentSnapshot.ServerTimestampBehavior}.
+   */
   @Nullable
-  public Object value(FieldValueOptions options) {
-    switch (options.getServerTimestampBehavior()) {
-      case PREVIOUS:
-        return previousValue != null ? previousValue.value(options) : null;
-      case ESTIMATE:
-        return new TimestampValue(localWriteTime).value(options);
-      case NONE:
-        return null;
-      default:
-        throw Assert.fail(
-            "Unexpected case for ServerTimestampBehavior: %s",
-            options.getServerTimestampBehavior().name());
+  public Object getPreviousValue() {
+    if (previousValue instanceof ServerTimestampValue) {
+      return ((ServerTimestampValue) previousValue).getPreviousValue();
     }
+
+    return previousValue != null ? previousValue.value() : null;
+  }
+
+  public Timestamp getLocalWriteTime() {
+    return localWriteTime;
   }
 
   @Override
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/TimestampValue.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/TimestampValue.java
index 953a0d83a..5b9e50728 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/TimestampValue.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/TimestampValue.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.firestore.model.value;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.google.firebase.Timestamp;
 
 /** A wrapper for Date values in Timestamp. */
@@ -32,19 +32,10 @@ public int typeOrder() {
 
   @Override
   @NonNull
-  public Object value() {
+  public Timestamp value() {
     return internalValue;
   }
 
-  @Override
-  public Object value(FieldValueOptions options) {
-    if (options.areTimestampsInSnapshotsEnabled()) {
-      return internalValue;
-    } else {
-      return internalValue.toDate();
-    }
-  }
-
   public Timestamp getInternalValue() {
     return internalValue;
   }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/package-info.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/package-info.java
index d4a89aad3..fecb6d7d2 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/package-info.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.firestore.model.value;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/AbstractStream.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/AbstractStream.java
index 83e4495ae..edd84343c 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/AbstractStream.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/AbstractStream.java
@@ -14,16 +14,18 @@
 
 package com.google.firebase.firestore.remote;
 
+import static com.google.firebase.firestore.remote.Datastore.SSL_DEPENDENCY_ERROR_MESSAGE;
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.google.firebase.firestore.remote.Stream.StreamCallback;
 import com.google.firebase.firestore.util.AsyncQueue;
 import com.google.firebase.firestore.util.AsyncQueue.DelayedTask;
 import com.google.firebase.firestore.util.AsyncQueue.TimerId;
 import com.google.firebase.firestore.util.ExponentialBackoff;
 import com.google.firebase.firestore.util.Logger;
+import com.google.firebase.firestore.util.Util;
 import io.grpc.ClientCall;
 import io.grpc.Metadata;
 import io.grpc.MethodDescriptor;
@@ -269,6 +271,13 @@ private void close(State finalState, Status status) {
         "Can't provide an error when not in an error state.");
     workerQueue.verifyIsCurrentThread();
 
+    if (Datastore.isSslHandshakeError(status)) {
+      // The Android device is missing required SSL Ciphers. This error is non-recoverable and must
+      // be addressed by the app developer (see https://bit.ly/2XFpdma).
+      Util.crashMainThread(
+          new IllegalStateException(SSL_DEPENDENCY_ERROR_MESSAGE, status.getCause()));
+    }
+
     // Cancel any outstanding timers (they're guaranteed not to execute).
     cancelIdleCheck();
     this.backoff.cancel();
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/AndroidConnectivityMonitor.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/AndroidConnectivityMonitor.java
index d53e6d0c1..228aabbd3 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/AndroidConnectivityMonitor.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/AndroidConnectivityMonitor.java
@@ -25,10 +25,10 @@
 import android.net.Network;
 import android.net.NetworkInfo;
 import android.os.Build;
+import androidx.annotation.Nullable;
 import com.google.firebase.firestore.util.Consumer;
 import java.util.ArrayList;
 import java.util.List;
-import javax.annotation.Nullable;
 
 /**
  * Android implementation of ConnectivityMonitor. Parallel implementations exist for N+ and pre-N.
@@ -84,6 +84,7 @@ public void run() {
           };
     } else {
       NetworkReceiver networkReceiver = new NetworkReceiver();
+      @SuppressWarnings("deprecation")
       IntentFilter networkIntentFilter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);
       context.registerReceiver(networkReceiver, networkIntentFilter);
       unregisterRunnable =
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/Datastore.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/Datastore.java
index 682c9142f..c2ebf2eab 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/Datastore.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/Datastore.java
@@ -15,6 +15,7 @@
 package com.google.firebase.firestore.remote;
 
 import android.content.Context;
+import android.os.Build;
 import com.google.android.gms.tasks.Task;
 import com.google.firebase.firestore.FirebaseFirestoreException;
 import com.google.firebase.firestore.auth.CredentialsProvider;
@@ -31,6 +32,7 @@
 import com.google.firestore.v1.CommitResponse;
 import com.google.firestore.v1.FirestoreGrpc;
 import io.grpc.Status;
+import java.net.ConnectException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
@@ -38,6 +40,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import javax.net.ssl.SSLHandshakeException;
 
 /**
  * Datastore represents a proxy for the remote server, hiding details of the RPC layer. It:
@@ -54,6 +57,16 @@
  */
 public class Datastore {
 
+  /**
+   * Error message to surface when Firestore fails to establish an SSL connection. A failed SSL
+   * connection likely indicates that the developer needs to provide an updated OpenSSL stack as
+   * part of their app's dependencies.
+   */
+  static final String SSL_DEPENDENCY_ERROR_MESSAGE =
+      "The Cloud Firestore client failed to establish a secure connection. This is likely a "
+          + "problem with your app, rather than with Cloud Firestore itself. See "
+          + "https://bit.ly/2XFpdma for instructions on how to enable TLS on Android 4.x devices.";
+
   /** Set of lowercase, white-listed headers for logging purposes. */
   static final Set<String> WHITE_LISTED_HEADERS =
       new HashSet<>(
@@ -176,8 +189,18 @@ WriteStream createWriteStream(WriteStream.Callback listener) {
    * @see #isPermanentWriteError for classifying write errors.
    */
   public static boolean isPermanentError(Status status) {
+    return isPermanentError(FirebaseFirestoreException.Code.fromValue(status.getCode().value()));
+  }
+
+  /**
+   * Determines whether the given error code represents a permanent error when received in response
+   * to a non-write operation.
+   *
+   * @see #isPermanentWriteError for classifying write errors.
+   */
+  public static boolean isPermanentError(FirebaseFirestoreException.Code code) {
     // See go/firestore-client-errors
-    switch (status.getCode()) {
+    switch (code) {
       case OK:
         throw new IllegalArgumentException("Treated status OK as error");
       case CANCELLED:
@@ -204,10 +227,26 @@ public static boolean isPermanentError(Status status) {
       case DATA_LOSS:
         return true;
       default:
-        throw new IllegalArgumentException("Unknown gRPC status code: " + status.getCode());
+        throw new IllegalArgumentException("Unknown gRPC status code: " + code);
     }
   }
 
+  /**
+   * Determine whether the given status maps to the error that GRPC-Java throws when an Android
+   * device is missing required SSL Ciphers.
+   *
+   * <p>This error is non-recoverable and must be addressed by the app developer.
+   */
+  public static boolean isSslHandshakeError(Status status) {
+    Status.Code code = status.getCode();
+    Throwable t = status.getCause();
+
+    return Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP
+        && code.equals(Status.Code.UNAVAILABLE)
+        && (t instanceof SSLHandshakeException
+            || (t instanceof ConnectException && t.getMessage().contains("EHOSTUNREACH")));
+  }
+
   /**
    * Determines whether the given status has an error code that represents a permanent error when
    * received in response to a write operation.
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/FirestoreCallCredentials.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/FirestoreCallCredentials.java
index 289bb98e4..7bc646966 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/FirestoreCallCredentials.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/FirestoreCallCredentials.java
@@ -18,13 +18,13 @@
 import com.google.firebase.firestore.auth.CredentialsProvider;
 import com.google.firebase.firestore.util.Logger;
 import com.google.firebase.internal.api.FirebaseNoSignedInUserException;
-import io.grpc.CallCredentials2;
+import io.grpc.CallCredentials;
 import io.grpc.Metadata;
 import io.grpc.Status;
 import java.util.concurrent.Executor;
 
 /** CallCredentials that applies any authorization headers. */
-final class FirestoreCallCredentials extends CallCredentials2 {
+final class FirestoreCallCredentials extends CallCredentials {
 
   private static final String LOG_TAG = "FirestoreCallCredentials";
 
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/FirestoreChannel.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/FirestoreChannel.java
index fe4de8bfe..e11c2dc14 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/FirestoreChannel.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/FirestoreChannel.java
@@ -199,7 +199,7 @@ public void onClose(Status status, Metadata trailers) {
                       if (status.isOk()) {
                         tcs.setResult(results);
                       } else {
-                        tcs.setException(Util.exceptionFromStatus(status));
+                        tcs.setException(exceptionFromStatus(status));
                       }
                     }
                   },
@@ -244,7 +244,7 @@ public void onClose(Status status, Metadata trailers) {
                                   Code.INTERNAL));
                         }
                       } else {
-                        tcs.setException(Util.exceptionFromStatus(status));
+                        tcs.setException(exceptionFromStatus(status));
                       }
                     }
                   },
@@ -262,6 +262,17 @@ public void onClose(Status status, Metadata trailers) {
     return tcs.getTask();
   }
 
+  private FirebaseFirestoreException exceptionFromStatus(Status status) {
+    if (Datastore.isSslHandshakeError(status)) {
+      return new FirebaseFirestoreException(
+          Datastore.SSL_DEPENDENCY_ERROR_MESSAGE,
+          Code.fromValue(status.getCode().value()),
+          status.getCause());
+    }
+
+    return Util.exceptionFromStatus(status);
+  }
+
   public void invalidateToken() {
     credentialsProvider.invalidateToken();
   }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/GrpcCallProvider.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/GrpcCallProvider.java
index 6b25b504d..b0a297e8d 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/GrpcCallProvider.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/GrpcCallProvider.java
@@ -15,8 +15,7 @@
 package com.google.firebase.firestore.remote;
 
 import android.content.Context;
-import android.os.AsyncTask;
-import android.support.annotation.VisibleForTesting;
+import androidx.annotation.VisibleForTesting;
 import com.google.android.gms.common.GooglePlayServicesNotAvailableException;
 import com.google.android.gms.common.GooglePlayServicesRepairableException;
 import com.google.android.gms.security.ProviderInstaller;
@@ -24,6 +23,7 @@
 import com.google.android.gms.tasks.Tasks;
 import com.google.firebase.firestore.core.DatabaseInfo;
 import com.google.firebase.firestore.util.AsyncQueue;
+import com.google.firebase.firestore.util.Executors;
 import com.google.firebase.firestore.util.Logger;
 import com.google.firebase.firestore.util.Supplier;
 import com.google.firestore.v1.FirestoreGrpc;
@@ -34,6 +34,7 @@
 import io.grpc.ManagedChannelBuilder;
 import io.grpc.MethodDescriptor;
 import io.grpc.android.AndroidChannelBuilder;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 
 /** Manages the gRPC channel and encapsulates all SSL and gRPC initialization. */
@@ -69,15 +70,20 @@ public static void overrideChannelBuilder(
       CallCredentials firestoreHeaders) {
     this.asyncQueue = asyncQueue;
 
-    // We execute network initialization on a separate thred to not block operations that depend on
+    // We execute network initialization on a separate thread to not block operations that depend on
     // the AsyncQueue.
     this.channelTask =
         Tasks.call(
-            AsyncTask.THREAD_POOL_EXECUTOR,
+            Executors.BACKGROUND_EXECUTOR,
             () -> {
               ManagedChannel channel = initChannel(context, databaseInfo);
               FirestoreGrpc.FirestoreStub firestoreStub =
-                  FirestoreGrpc.newStub(channel).withCallCredentials(firestoreHeaders);
+                  FirestoreGrpc.newStub(channel)
+                      .withCallCredentials(firestoreHeaders)
+                      // Ensure all callbacks are issued on the worker queue. If this call is
+                      // removed, all calls need to be audited to make sure they are executed on the
+                      // right thread.
+                      .withExecutor(asyncQueue.getExecutor());
               callOptions = firestoreStub.getCallOptions();
               return channel;
             });
@@ -115,10 +121,6 @@ private ManagedChannel initChannel(Context context, DatabaseInfo databaseInfo) {
     // usually notify gRPC when a connection dies. But not always. This acts as a failsafe.)
     channelBuilder.keepAliveTime(30, TimeUnit.SECONDS);
 
-    // This ensures all callbacks are issued on the worker queue. If this call is removed,
-    // all calls need to be audited to make sure they are executed on the right thread.
-    channelBuilder.executor(asyncQueue.getExecutor());
-
     // Wrap the ManagedChannelBuilder in an AndroidChannelBuilder. This allows the channel to
     // respond more gracefully to network change events (such as switching from cell to wifi).
     AndroidChannelBuilder androidChannelBuilder =
@@ -137,48 +139,63 @@ private ManagedChannel initChannel(Context context, DatabaseInfo databaseInfo) {
 
   /** Shuts down the gRPC channel and the internal worker queue. */
   void shutdown() {
-    channelTask.addOnCompleteListener(
-        asyncQueue.getExecutor(),
-        task -> {
-          ManagedChannel channel = task.getResult();
-          channel.shutdown();
-          try {
-            // TODO(rsgowman): Investigate occasional hangs in channel.shutdown().
-            //
-            // While running the integration tests, channel.shutdown() will occasionally timeout.
-            // (Typically on ~4-5 different tests, differing from one run to the next.) We should
-            // figure this out. But in the meantime, just use an exceptionally short timeout here
-            // and skip straight to shutdownNow() which works every time. (We don't support shutting
-            // down Firestore, so this should only be triggered from the test suite.)
-            if (!channel.awaitTermination(1, TimeUnit.SECONDS)) {
-              Logger.debug(
-                  FirestoreChannel.class.getSimpleName(),
-                  "Unable to gracefully shutdown the gRPC ManagedChannel. Will attempt an immediate shutdown.");
-              channel.shutdownNow();
-
-              // gRPC docs claim "Although forceful, the shutdown process is still not
-              // instantaneous; isTerminated() will likely return false immediately after this
-              // method returns." Therefore, we still need to awaitTermination() again.
-              if (!channel.awaitTermination(60, TimeUnit.SECONDS)) {
-                // Something bad has happened. We could assert, but this is just resource cleanup
-                // for a resource that is likely only released at the end of the execution. So
-                // instead, we'll just log the error.
-                Logger.warn(
-                    FirestoreChannel.class.getSimpleName(),
-                    "Unable to forcefully shutdown the gRPC ManagedChannel.");
-              }
-            }
-          } catch (InterruptedException e) {
-            // (Re-)Cancel if current thread also interrupted
-            channel.shutdownNow();
-
-            // Similar to above, something bad happened, but it's not worth asserting. Just log it.
-            Logger.warn(
-                FirestoreChannel.class.getSimpleName(),
-                "Interrupted while shutting down the gRPC Managed Channel");
-            // Preserve interrupt status
-            Thread.currentThread().interrupt();
-          }
-        });
+    // Handling shutdown synchronously to avoid re-enqueuing on the AsyncQueue after shutdown has
+    // started.
+    ManagedChannel channel = null;
+    try {
+      channel = Tasks.await(channelTask);
+    } catch (ExecutionException e) {
+      Logger.warn(
+          FirestoreChannel.class.getSimpleName(),
+          "Channel is not initialized, shutdown will just do nothing. Channel initializing run into exception: %s",
+          e);
+      return;
+    } catch (InterruptedException e) {
+      Logger.warn(
+          FirestoreChannel.class.getSimpleName(),
+          "Interrupted while retrieving the gRPC Managed Channel");
+      // Preserve interrupt status
+      Thread.currentThread().interrupt();
+      return;
+    }
+
+    channel.shutdown();
+    try {
+      // TODO(rsgowman): Investigate occasional hangs in channel.shutdown().
+      //
+      // While running the integration tests, channel.shutdown() will occasionally timeout.
+      // (Typically on ~4-5 different tests, differing from one run to the next.) We should
+      // figure this out. But in the meantime, just use an exceptionally short timeout here
+      // and skip straight to shutdownNow() which works every time. (We don't support shutting
+      // down Firestore, so this should only be triggered from the test suite.)
+      if (!channel.awaitTermination(1, TimeUnit.SECONDS)) {
+        Logger.debug(
+            FirestoreChannel.class.getSimpleName(),
+            "Unable to gracefully shutdown the gRPC ManagedChannel. Will attempt an immediate shutdown.");
+        channel.shutdownNow();
+
+        // gRPC docs claim "Although forceful, the shutdown process is still not
+        // instantaneous; isTerminated() will likely return false immediately after this
+        // method returns." Therefore, we still need to awaitTermination() again.
+        if (!channel.awaitTermination(60, TimeUnit.SECONDS)) {
+          // Something bad has happened. We could assert, but this is just resource cleanup
+          // for a resource that is likely only released at the end of the execution. So
+          // instead, we'll just log the error.
+          Logger.warn(
+              FirestoreChannel.class.getSimpleName(),
+              "Unable to forcefully shutdown the gRPC ManagedChannel.");
+        }
+      }
+    } catch (InterruptedException e) {
+      // (Re-)Cancel if current thread also interrupted
+      channel.shutdownNow();
+
+      // Similar to above, something bad happened, but it's not worth asserting. Just log it.
+      Logger.warn(
+          FirestoreChannel.class.getSimpleName(),
+          "Interrupted while shutting down the gRPC Managed Channel");
+      // Preserve interrupt status
+      Thread.currentThread().interrupt();
+    }
   }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/RemoteSerializer.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/RemoteSerializer.java
index 9c72064eb..d3dd52d37 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/RemoteSerializer.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/RemoteSerializer.java
@@ -17,18 +17,17 @@
 import static com.google.firebase.firestore.util.Assert.fail;
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.Blob;
 import com.google.firebase.firestore.GeoPoint;
 import com.google.firebase.firestore.core.Bound;
+import com.google.firebase.firestore.core.FieldFilter;
 import com.google.firebase.firestore.core.Filter;
-import com.google.firebase.firestore.core.NaNFilter;
-import com.google.firebase.firestore.core.NullFilter;
 import com.google.firebase.firestore.core.OrderBy;
 import com.google.firebase.firestore.core.OrderBy.Direction;
 import com.google.firebase.firestore.core.Query;
-import com.google.firebase.firestore.core.RelationFilter;
 import com.google.firebase.firestore.local.QueryData;
 import com.google.firebase.firestore.local.QueryPurpose;
 import com.google.firebase.firestore.model.DatabaseId;
@@ -83,7 +82,6 @@
 import com.google.firestore.v1.StructuredQuery;
 import com.google.firestore.v1.StructuredQuery.CollectionSelector;
 import com.google.firestore.v1.StructuredQuery.CompositeFilter;
-import com.google.firestore.v1.StructuredQuery.FieldFilter;
 import com.google.firestore.v1.StructuredQuery.FieldReference;
 import com.google.firestore.v1.StructuredQuery.Filter.FilterTypeCase;
 import com.google.firestore.v1.StructuredQuery.Order;
@@ -406,11 +404,11 @@ private Document decodeFoundDocument(BatchGetDocumentsResponse response) {
         response.getResultCase().equals(ResultCase.FOUND),
         "Tried to deserialize a found document from a missing document.");
     DocumentKey key = decodeKey(response.getFound().getName());
-    ObjectValue value = decodeFields(response.getFound().getFieldsMap());
     SnapshotVersion version = decodeVersion(response.getFound().getUpdateTime());
     hardAssert(
         !version.equals(SnapshotVersion.NONE), "Got a document response with no snapshot version");
-    return new Document(key, version, value, Document.DocumentState.SYNCED, response.getFound());
+    return new Document(
+        key, version, Document.DocumentState.SYNCED, response.getFound(), this::decodeValue);
   }
 
   private NoDocument decodeMissingDocument(BatchGetDocumentsResponse response) {
@@ -817,10 +815,8 @@ public Query decodeQueryTarget(QueryTarget target) {
   private StructuredQuery.Filter encodeFilters(List<Filter> filters) {
     List<StructuredQuery.Filter> protos = new ArrayList<>(filters.size());
     for (Filter filter : filters) {
-      if (filter instanceof RelationFilter) {
-        protos.add(encodeRelationFilter((RelationFilter) filter));
-      } else {
-        protos.add(encodeUnaryFilter(filter));
+      if (filter instanceof FieldFilter) {
+        protos.add(encodeUnaryOrFieldFilter((FieldFilter) filter));
       }
     }
     if (filters.size() == 1) {
@@ -852,7 +848,7 @@ public Query decodeQueryTarget(QueryTarget target) {
           throw fail("Nested composite filters are not supported.");
 
         case FIELD_FILTER:
-          result.add(decodeRelationFilter(filter.getFieldFilter()));
+          result.add(decodeFieldFilter(filter.getFieldFilter()));
           break;
 
         case UNARY_FILTER:
@@ -867,42 +863,42 @@ public Query decodeQueryTarget(QueryTarget target) {
     return result;
   }
 
-  private StructuredQuery.Filter encodeRelationFilter(RelationFilter filter) {
-    FieldFilter.Builder proto = FieldFilter.newBuilder();
+  @VisibleForTesting
+  StructuredQuery.Filter encodeUnaryOrFieldFilter(FieldFilter filter) {
+    if (filter.getOperator() == Filter.Operator.EQUAL) {
+      UnaryFilter.Builder unaryProto = UnaryFilter.newBuilder();
+      unaryProto.setField(encodeFieldPath(filter.getField()));
+      if (filter.getValue().equals(DoubleValue.NaN)) {
+        unaryProto.setOp(UnaryFilter.Operator.IS_NAN);
+        return StructuredQuery.Filter.newBuilder().setUnaryFilter(unaryProto).build();
+      } else if (filter.getValue().equals(NullValue.nullValue())) {
+        unaryProto.setOp(UnaryFilter.Operator.IS_NULL);
+        return StructuredQuery.Filter.newBuilder().setUnaryFilter(unaryProto).build();
+      }
+    }
+    StructuredQuery.FieldFilter.Builder proto = StructuredQuery.FieldFilter.newBuilder();
     proto.setField(encodeFieldPath(filter.getField()));
-    proto.setOp(encodeRelationFilterOperator(filter.getOperator()));
+    proto.setOp(encodeFieldFilterOperator(filter.getOperator()));
     proto.setValue(encodeValue(filter.getValue()));
     return StructuredQuery.Filter.newBuilder().setFieldFilter(proto).build();
   }
 
-  private Filter decodeRelationFilter(StructuredQuery.FieldFilter proto) {
+  @VisibleForTesting
+  FieldFilter decodeFieldFilter(StructuredQuery.FieldFilter proto) {
     FieldPath fieldPath = FieldPath.fromServerFormat(proto.getField().getFieldPath());
-    RelationFilter.Operator filterOperator = decodeRelationFilterOperator(proto.getOp());
+    FieldFilter.Operator filterOperator = decodeFieldFilterOperator(proto.getOp());
     FieldValue value = decodeValue(proto.getValue());
-    return Filter.create(fieldPath, filterOperator, value);
-  }
-
-  private StructuredQuery.Filter encodeUnaryFilter(Filter filter) {
-    UnaryFilter.Builder proto = UnaryFilter.newBuilder();
-    proto.setField(encodeFieldPath(filter.getField()));
-    if (filter instanceof NaNFilter) {
-      proto.setOp(UnaryFilter.Operator.IS_NAN);
-    } else if (filter instanceof NullFilter) {
-      proto.setOp(UnaryFilter.Operator.IS_NULL);
-    } else {
-      throw fail("Unrecognized filter: %s", filter.getCanonicalId());
-    }
-    return StructuredQuery.Filter.newBuilder().setUnaryFilter(proto).build();
+    return FieldFilter.create(fieldPath, filterOperator, value);
   }
 
   private Filter decodeUnaryFilter(StructuredQuery.UnaryFilter proto) {
     FieldPath fieldPath = FieldPath.fromServerFormat(proto.getField().getFieldPath());
     switch (proto.getOp()) {
       case IS_NAN:
-        return new NaNFilter(fieldPath);
+        return FieldFilter.create(fieldPath, Filter.Operator.EQUAL, DoubleValue.NaN);
 
       case IS_NULL:
-        return new NullFilter(fieldPath);
+        return FieldFilter.create(fieldPath, Filter.Operator.EQUAL, NullValue.nullValue());
 
       default:
         throw fail("Unrecognized UnaryFilter.operator %d", proto.getOp());
@@ -913,39 +909,49 @@ private FieldReference encodeFieldPath(FieldPath field) {
     return FieldReference.newBuilder().setFieldPath(field.canonicalString()).build();
   }
 
-  private FieldFilter.Operator encodeRelationFilterOperator(RelationFilter.Operator operator) {
+  private StructuredQuery.FieldFilter.Operator encodeFieldFilterOperator(
+      FieldFilter.Operator operator) {
     switch (operator) {
       case LESS_THAN:
-        return FieldFilter.Operator.LESS_THAN;
+        return StructuredQuery.FieldFilter.Operator.LESS_THAN;
       case LESS_THAN_OR_EQUAL:
-        return FieldFilter.Operator.LESS_THAN_OR_EQUAL;
+        return StructuredQuery.FieldFilter.Operator.LESS_THAN_OR_EQUAL;
       case EQUAL:
-        return FieldFilter.Operator.EQUAL;
+        return StructuredQuery.FieldFilter.Operator.EQUAL;
       case GREATER_THAN:
-        return FieldFilter.Operator.GREATER_THAN;
+        return StructuredQuery.FieldFilter.Operator.GREATER_THAN;
       case GREATER_THAN_OR_EQUAL:
-        return FieldFilter.Operator.GREATER_THAN_OR_EQUAL;
+        return StructuredQuery.FieldFilter.Operator.GREATER_THAN_OR_EQUAL;
       case ARRAY_CONTAINS:
-        return FieldFilter.Operator.ARRAY_CONTAINS;
+        return StructuredQuery.FieldFilter.Operator.ARRAY_CONTAINS;
+      case IN:
+        return StructuredQuery.FieldFilter.Operator.IN;
+      case ARRAY_CONTAINS_ANY:
+        return StructuredQuery.FieldFilter.Operator.ARRAY_CONTAINS_ANY;
       default:
         throw fail("Unknown operator %d", operator);
     }
   }
 
-  private RelationFilter.Operator decodeRelationFilterOperator(FieldFilter.Operator operator) {
+  private FieldFilter.Operator decodeFieldFilterOperator(
+      StructuredQuery.FieldFilter.Operator operator) {
     switch (operator) {
       case LESS_THAN:
-        return RelationFilter.Operator.LESS_THAN;
+        return FieldFilter.Operator.LESS_THAN;
       case LESS_THAN_OR_EQUAL:
-        return RelationFilter.Operator.LESS_THAN_OR_EQUAL;
+        return FieldFilter.Operator.LESS_THAN_OR_EQUAL;
       case EQUAL:
-        return RelationFilter.Operator.EQUAL;
+        return FieldFilter.Operator.EQUAL;
       case GREATER_THAN_OR_EQUAL:
-        return RelationFilter.Operator.GREATER_THAN_OR_EQUAL;
+        return FieldFilter.Operator.GREATER_THAN_OR_EQUAL;
       case GREATER_THAN:
-        return RelationFilter.Operator.GREATER_THAN;
+        return FieldFilter.Operator.GREATER_THAN;
       case ARRAY_CONTAINS:
-        return RelationFilter.Operator.ARRAY_CONTAINS;
+        return FieldFilter.Operator.ARRAY_CONTAINS;
+      case IN:
+        return FieldFilter.Operator.IN;
+      case ARRAY_CONTAINS_ANY:
+        return FieldFilter.Operator.ARRAY_CONTAINS_ANY;
       default:
         throw fail("Unhandled FieldFilter.operator %d", operator);
     }
@@ -1045,12 +1051,13 @@ public WatchChange decodeWatchChange(ListenResponse protoChange) {
         SnapshotVersion version = decodeVersion(docChange.getDocument().getUpdateTime());
         hardAssert(
             !version.equals(SnapshotVersion.NONE), "Got a document change without an update time");
-        ObjectValue data = decodeFields(docChange.getDocument().getFieldsMap());
-        // The document may soon be re-serialized back to protos in order to store it in local
-        // persistence. Memoize the encoded form to avoid encoding it again.
         Document document =
             new Document(
-                key, version, data, Document.DocumentState.SYNCED, docChange.getDocument());
+                key,
+                version,
+                Document.DocumentState.SYNCED,
+                docChange.getDocument(),
+                this::decodeValue);
         watchChange = new WatchChange.DocumentChange(added, removed, document.getKey(), document);
         break;
       case DOCUMENT_DELETE:
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/RemoteStore.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/RemoteStore.java
index 050901ace..dc51e7308 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/RemoteStore.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/RemoteStore.java
@@ -16,8 +16,8 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.google.firebase.database.collection.ImmutableSortedSet;
 import com.google.firebase.firestore.core.OnlineState;
 import com.google.firebase.firestore.core.Transaction;
@@ -478,7 +478,7 @@ private void handleWatchStreamClose(Status status) {
     }
   }
 
-  private boolean canUseNetwork() {
+  public boolean canUseNetwork() {
     // PORTING NOTE: This method exists mostly because web also has to take into account primary
     // vs. secondary state.
     return networkEnabled;
@@ -504,9 +504,7 @@ private void raiseWatchSnapshot(SnapshotVersion snapshotVersion) {
         // A watched target might have been removed already.
         if (queryData != null) {
           this.listenTargets.put(
-              targetId,
-              queryData.copy(
-                  snapshotVersion, targetChange.getResumeToken(), queryData.getSequenceNumber()));
+              targetId, queryData.withResumeToken(targetChange.getResumeToken(), snapshotVersion));
         }
       }
     }
@@ -519,9 +517,7 @@ private void raiseWatchSnapshot(SnapshotVersion snapshotVersion) {
       if (queryData != null) {
         // Clear the resume token for the query, since we're in a known mismatch state.
         this.listenTargets.put(
-            targetId,
-            queryData.copy(
-                queryData.getSnapshotVersion(), ByteString.EMPTY, queryData.getSequenceNumber()));
+            targetId, queryData.withResumeToken(ByteString.EMPTY, queryData.getSnapshotVersion()));
 
         // Cause a hard reset by unwatching and rewatching immediately, but deliberately don't send
         // a resume token so that we get a full update.
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/WatchChange.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/WatchChange.java
index 565c85afa..89debc9d2 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/WatchChange.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/WatchChange.java
@@ -16,12 +16,12 @@
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.MaybeDocument;
 import com.google.protobuf.ByteString;
 import io.grpc.Status;
 import java.util.List;
-import javax.annotation.Nullable;
 
 /**
  * A Watch Change is the internal representation of the watcher API protocol buffers. This is an
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/WatchChangeAggregator.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/WatchChangeAggregator.java
index 10018cc82..38f5d778b 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/WatchChangeAggregator.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/WatchChangeAggregator.java
@@ -17,7 +17,7 @@
 import static com.google.firebase.firestore.util.Assert.fail;
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.firebase.database.collection.ImmutableSortedSet;
 import com.google.firebase.firestore.core.DocumentViewChange;
 import com.google.firebase.firestore.core.Query;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/package-info.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/package-info.java
index 35a4ae14d..893bae523 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/package-info.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.firestore.remote;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/AsyncQueue.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/AsyncQueue.java
index 3ab4c5be9..9802eb53e 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/AsyncQueue.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/AsyncQueue.java
@@ -19,8 +19,8 @@
 
 import android.os.Handler;
 import android.os.Looper;
-import android.support.annotation.NonNull;
-import android.support.annotation.VisibleForTesting;
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
 import com.google.android.gms.tasks.Continuation;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
@@ -69,7 +69,12 @@
      */
     ONLINE_STATE_TIMEOUT,
     /** A timer used to periodically attempt LRU Garbage collection */
-    GARBAGE_COLLECTION
+    GARBAGE_COLLECTION,
+    /**
+     * A timer used to retry transactions. Since there can be multiple concurrent transactions,
+     * multiple of these may be in the queue at a given time.
+     */
+    RETRY_TRANSACTION
   }
 
   /**
@@ -176,83 +181,214 @@ private void markDone() {
   }
 
   /**
-   * The single thread that will be used by the executor. This is created early and managed directly
-   * so that it's possible later to make assertions about executing on the correct thread.
+   * A wrapper around a {@link ScheduledThreadPoolExecutor} class that provides:
+   *
+   * <ol>
+   *   <li>Synchronized task scheduling. This is different from function 3, which is about task
+   *       execution in a single thread.
+   *   <li>Ability to do soft-shutdown: only critical tasks related to shutting Firestore SDK down
+   *       can be executed once the shutdown process initiated.
+   *   <li>Single threaded execution service, no concurrent execution among the `Runnable`s
+   *       scheduled in this Executor.
+   * </ol>
    */
-  private final Thread thread;
+  private class SynchronizedShutdownAwareExecutor implements Executor {
+    /**
+     * The single threaded executor that is backing this Executor. This is also the executor used
+     * when some tasks explicitly request to run after shutdown has been initiated.
+     */
+    private final ScheduledThreadPoolExecutor internalExecutor;
 
-  /** The single threaded executor that is backing this AsyncQueue */
-  private final ScheduledThreadPoolExecutor executor;
+    /** Whether the shutdown process has initiated, once it is started, it is not revertable. */
+    private boolean isShuttingDown;
 
-  // Tasks scheduled to be queued in the future. Tasks are automatically removed after they are run
-  // or canceled.
-  // NOTE: We disallow duplicates currently, so this could be a Set<> which might have better
-  // theoretical removal speed, except this list will always be small so ArrayList is fine.
-  private final ArrayList<DelayedTask> delayedTasks;
+    /**
+     * The single thread that will be used by the executor. This is created early and managed
+     * directly so that it's possible later to make assertions about executing on the correct
+     * thread.
+     */
+    private final Thread thread;
+
+    /** A ThreadFactory for a single, pre-created thread. */
+    private class DelayedStartFactory implements Runnable, ThreadFactory {
+      private final CountDownLatch latch = new CountDownLatch(1);
+      private Runnable delegate;
+
+      @Override
+      public void run() {
+        try {
+          latch.await();
+        } catch (InterruptedException e) {
+          Thread.currentThread().interrupt();
+        }
+        delegate.run();
+      }
+
+      @Override
+      public Thread newThread(@NonNull Runnable runnable) {
+        hardAssert(delegate == null, "Only one thread may be created in an AsyncQueue.");
+        delegate = runnable;
+        latch.countDown();
+        return thread;
+      }
+    }
 
-  /** A ThreadFactory for a single, pre-created thread. */
-  private class DelayedStartFactory implements Runnable, ThreadFactory {
-    private final CountDownLatch latch = new CountDownLatch(1);
-    private Runnable delegate;
+    SynchronizedShutdownAwareExecutor() {
+      DelayedStartFactory threadFactory = new DelayedStartFactory();
+
+      thread = Executors.defaultThreadFactory().newThread(threadFactory);
+      thread.setName("FirestoreWorker");
+      thread.setDaemon(true);
+      thread.setUncaughtExceptionHandler((crashingThread, throwable) -> panic(throwable));
+
+      internalExecutor =
+          new ScheduledThreadPoolExecutor(1, threadFactory) {
+            @Override
+            protected void afterExecute(Runnable r, Throwable t) {
+              super.afterExecute(r, t);
+              if (t == null && r instanceof Future<?>) {
+                Future<?> future = (Future<?>) r;
+                try {
+                  // Not all Futures will be done, e.g. when used with scheduledAtFixedRate
+                  if (future.isDone()) {
+                    future.get();
+                  }
+                } catch (CancellationException ce) {
+                  // Cancellation exceptions are okay, we expect them to happen sometimes
+                } catch (ExecutionException ee) {
+                  t = ee.getCause();
+                } catch (InterruptedException e) {
+                  Thread.currentThread().interrupt();
+                }
+              }
+              if (t != null) {
+                panic(t);
+              }
+            }
+          };
+
+      // Core threads don't time out, this only takes effect when we drop the number of required
+      // core threads
+      internalExecutor.setKeepAliveTime(3, TimeUnit.SECONDS);
+
+      isShuttingDown = false;
+    }
 
+    /** Synchronized access to isShuttingDown */
+    private synchronized boolean isShuttingDown() {
+      return isShuttingDown;
+    }
+
+    /**
+     * Check if shutdown is initiated before scheduling. If it is initiated, the command will not be
+     * executed.
+     */
     @Override
-    public void run() {
+    public synchronized void execute(Runnable command) {
+      if (!isShuttingDown) {
+        internalExecutor.execute(command);
+      }
+    }
+
+    /** Execute the command, regardless if shutdown has been initiated. */
+    public void executeEvenAfterShutdown(Runnable command) {
       try {
-        latch.await();
-      } catch (InterruptedException e) {
-        Thread.currentThread().interrupt();
+        internalExecutor.execute(command);
+      } catch (RejectedExecutionException e) {
+        // The only way we can get here is if the AsyncQueue has panicked and we're now racing with
+        // the post to the main looper that will crash the app.
+        Logger.warn(AsyncQueue.class.getSimpleName(), "Refused to enqueue task after panic");
       }
-      delegate.run();
     }
 
-    @Override
-    public Thread newThread(@NonNull Runnable runnable) {
-      hardAssert(delegate == null, "Only one thread may be created in an AsyncQueue.");
-      delegate = runnable;
-      latch.countDown();
-      return thread;
+    /**
+     * Run a given `Callable` on this executor, and report the result of the `Callable` in a {@link
+     * Task}. The `Callable` will not be run if the executor started shutting down already.
+     *
+     * @return A {@link Task} resolves when the requested `Callable` completes, or reports error
+     *     when the `Callable` runs into exceptions.
+     */
+    private <T> Task<T> executeAndReportResult(Callable<T> task) {
+      final TaskCompletionSource<T> completionSource = new TaskCompletionSource<>();
+      try {
+        this.execute(
+            () -> {
+              try {
+                completionSource.setResult(task.call());
+              } catch (Exception e) {
+                completionSource.setException(e);
+                throw new RuntimeException(e);
+              }
+            });
+      } catch (RejectedExecutionException e) {
+        // The only way we can get here is if the AsyncQueue has panicked and we're now racing with
+        // the post to the main looper that will crash the app.
+        Logger.warn(AsyncQueue.class.getSimpleName(), "Refused to enqueue task after panic");
+      }
+      return completionSource.getTask();
     }
-  }
 
-  public AsyncQueue() {
-    delayedTasks = new ArrayList<>();
+    /**
+     * Initiate the shutdown process. Once called, the only possible way to run `Runnable`s are by
+     * holding the `internalExecutor` reference.
+     */
+    private synchronized Task<Void> executeAndInitiateShutdown(Runnable task) {
+      if (isShuttingDown()) {
+        TaskCompletionSource<Void> source = new TaskCompletionSource<>();
+        source.setResult(null);
+        return source.getTask();
+      }
 
-    DelayedStartFactory threadFactory = new DelayedStartFactory();
+      // Not shutting down yet, execute and return a Task.
+      Task<Void> t =
+          executeAndReportResult(
+              () -> {
+                task.run();
+                return null;
+              });
 
-    thread = Executors.defaultThreadFactory().newThread(threadFactory);
-    thread.setName("FirestoreWorker");
-    thread.setDaemon(true);
-    thread.setUncaughtExceptionHandler((crashingThread, throwable) -> panic(throwable));
+      // Mark the initiation of shut down.
+      isShuttingDown = true;
 
-    executor =
-        new ScheduledThreadPoolExecutor(1, threadFactory) {
-          @Override
-          protected void afterExecute(Runnable r, Throwable t) {
-            super.afterExecute(r, t);
-            if (t == null && r instanceof Future<?>) {
-              Future<?> future = (Future<?>) r;
-              try {
-                // Not all Futures will be done, e.g. when used with scheduledAtFixedRate
-                if (future.isDone()) {
-                  future.get();
-                }
-              } catch (CancellationException ce) {
-                // Cancellation exceptions are okay, we expect them to happen sometimes
-              } catch (ExecutionException ee) {
-                t = ee.getCause();
-              } catch (InterruptedException e) {
-                Thread.currentThread().interrupt();
-              }
-            }
-            if (t != null) {
-              panic(t);
-            }
-          }
-        };
+      return t;
+    }
+
+    /**
+     * Wraps {@link ScheduledThreadPoolExecutor#schedule(Runnable, long, TimeUnit)} and provides
+     * shutdown state check: the command will not be scheduled if the shutdown has been initiated.
+     */
+    private synchronized ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
+      if (!isShuttingDown) {
+        return internalExecutor.schedule(command, delay, unit);
+      }
+      return null;
+    }
+
+    /** Wraps around {@link ScheduledThreadPoolExecutor#shutdownNow()}. */
+    private void shutdownNow() {
+      internalExecutor.shutdownNow();
+    }
+
+    /** Wraps around {@link ScheduledThreadPoolExecutor#setCorePoolSize(int)}. */
+    private void setCorePoolSize(int size) {
+      internalExecutor.setCorePoolSize(size);
+    }
+  }
+
+  /** The executor backing this AsyncQueue. */
+  private final SynchronizedShutdownAwareExecutor executor;
+  // Tasks scheduled to be queued in the future. Tasks are automatically removed after they are run
+  // or canceled.
+  // NOTE: We disallow duplicates currently, so this could be a Set<> which might have better
+  // theoretical removal speed, except this list will always be small so ArrayList is fine.
+  private final ArrayList<DelayedTask> delayedTasks;
 
-    // Core threads don't time out, this only takes effect when we drop the number of required
-    // core threads
-    executor.setKeepAliveTime(3, TimeUnit.SECONDS);
+  // List of TimerIds to fast-forward delays for.
+  private final ArrayList<TimerId> timerIdsToSkip = new ArrayList<>();
+
+  public AsyncQueue() {
+    delayedTasks = new ArrayList<>();
+    executor = new SynchronizedShutdownAwareExecutor();
   }
 
   public Executor getExecutor() {
@@ -262,11 +398,11 @@ public Executor getExecutor() {
   /** Verifies that the current thread is the managed AsyncQueue thread. */
   public void verifyIsCurrentThread() {
     Thread current = Thread.currentThread();
-    if (thread != current) {
+    if (executor.thread != current) {
       throw fail(
           "We are running on the wrong thread. Expected to be on the AsyncQueue "
               + "thread %s/%d but was %s/%d",
-          thread.getName(), thread.getId(), current.getName(), current.getId());
+          executor.thread.getName(), executor.thread.getId(), current.getName(), current.getId());
     }
   }
 
@@ -279,23 +415,7 @@ public void verifyIsCurrentThread() {
    */
   @CheckReturnValue
   public <T> Task<T> enqueue(Callable<T> task) {
-    final TaskCompletionSource<T> completionSource = new TaskCompletionSource<>();
-    try {
-      executor.execute(
-          () -> {
-            try {
-              completionSource.setResult(task.call());
-            } catch (Exception e) {
-              completionSource.setException(e);
-              throw new RuntimeException(e);
-            }
-          });
-    } catch (RejectedExecutionException e) {
-      // The only way we can get here is if the AsyncQueue has panicked and we're now racing with
-      // the post to the main looper that will crash the app.
-      Logger.warn(AsyncQueue.class.getSimpleName(), "Refused to enqueue task after panic");
-    }
-    return completionSource.getTask();
+    return executor.executeAndReportResult(task);
   }
 
   /**
@@ -313,6 +433,28 @@ public void verifyIsCurrentThread() {
         });
   }
 
+  /**
+   * Queue a Runnable and immediately mark the initiation of shutdown process. Tasks queued after
+   * this method is called are not run unless they explicitly are requested via {@link
+   * AsyncQueue#enqueueAndForgetEvenAfterShutdown(Runnable)}.
+   */
+  public Task<Void> enqueueAndInitiateShutdown(Runnable task) {
+    return executor.executeAndInitiateShutdown(task);
+  }
+
+  /**
+   * Queue and run this Runnable task immediately after every other already queued task, regardless
+   * if shutdown has been initiated.
+   */
+  public void enqueueAndForgetEvenAfterShutdown(Runnable task) {
+    executor.executeEvenAfterShutdown(task);
+  }
+
+  /** Has the shutdown process been initiated. */
+  public boolean isShuttingDown() {
+    return executor.isShuttingDown();
+  }
+
   /**
    * Queue and run this Runnable task immediately after every other already queued task. Unlike
    * enqueue(), returns void instead of a Task Object for use when we have no need to "wait" on the
@@ -337,12 +479,10 @@ public void enqueueAndForget(Runnable task) {
    * @return A DelayedTask instance that can be used for cancellation.
    */
   public DelayedTask enqueueAfterDelay(TimerId timerId, long delayMs, Runnable task) {
-    // While not necessarily harmful, we currently don't expect to have multiple tasks with the same
-    // timer id in the queue, so defensively reject them.
-    hardAssert(
-        !containsDelayedTask(timerId),
-        "Attempted to schedule multiple operations with timer id %s.",
-        timerId);
+    // Fast-forward delays for timerIds that have been overridden.
+    if (timerIdsToSkip.contains(timerId)) {
+      delayMs = 0;
+    }
 
     DelayedTask delayedTask = createAndScheduleDelayedTask(timerId, delayMs, task);
     delayedTasks.add(delayedTask);
@@ -350,6 +490,16 @@ public DelayedTask enqueueAfterDelay(TimerId timerId, long delayMs, Runnable tas
     return delayedTask;
   }
 
+  /**
+   * For Tests: Skip all subsequent delays for a timer id.
+   *
+   * @param timerId The timerId to skip delays for.
+   */
+  @VisibleForTesting
+  public void skipDelaysForTimerId(TimerId timerId) {
+    timerIdsToSkip.add(timerId);
+  }
+
   /**
    * Immediately stops running any scheduled tasks and causes a "panic" (through crashing the app).
    *
@@ -377,7 +527,7 @@ public void panic(Throwable t) {
             throw error;
           } else {
             throw new RuntimeException(
-                "Internal error in Firestore (" + BuildConfig.VERSION_NAME + ").", t);
+                "Internal error in Cloud Firestore (" + BuildConfig.VERSION_NAME + ").", t);
           }
         });
   }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/BackgroundQueue.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/BackgroundQueue.java
new file mode 100644
index 000000000..e6df7cb96
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/BackgroundQueue.java
@@ -0,0 +1,47 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.util;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.Semaphore;
+
+/**
+ * A simple queue that executes tasks in parallel on the Android's AsyncTask.THREAD_POOL_EXECUTOR
+ * and supports blocking on their completion.
+ *
+ * <p>This class is not thread-safe. In particular, `execute()` and `drain()` should not be called
+ * from parallel threads.
+ */
+public class BackgroundQueue implements Executor {
+  private Semaphore completedTasks = new Semaphore(0);
+  private int pendingTaskCount = 0;
+
+  /** Enqueue a task on Android's THREAD_POOL_EXECUTOR. */
+  @Override
+  public void execute(Runnable task) {
+    ++pendingTaskCount;
+    Executors.BACKGROUND_EXECUTOR.execute(
+        () -> {
+          task.run();
+          completedTasks.release();
+        });
+  }
+
+  /** Wait for all currently scheduled tasks to complete. */
+  public void drain() throws InterruptedException {
+    completedTasks.acquire(pendingTaskCount);
+    pendingTaskCount = 0;
+  }
+}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/CustomClassMapper.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/CustomClassMapper.java
index f3230a6b1..6c4388419 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/CustomClassMapper.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/CustomClassMapper.java
@@ -19,6 +19,7 @@
 
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.Blob;
+import com.google.firebase.firestore.DocumentId;
 import com.google.firebase.firestore.DocumentReference;
 import com.google.firebase.firestore.Exclude;
 import com.google.firebase.firestore.FieldValue;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/DocumentId.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/DocumentId.java
deleted file mode 100644
index 7eab66748..000000000
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/DocumentId.java
+++ /dev/null
@@ -1,47 +0,0 @@
-// Copyright 2019 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.google.firebase.firestore.util;
-
-import com.google.firebase.annotations.PublicApi;
-import com.google.firebase.firestore.DocumentReference;
-import com.google.firebase.firestore.DocumentSnapshot;
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * Annotation used to mark a POJO property to be automatically populated with the document's ID when
- * the POJO is created from a Firestore document (e.g. via {@link DocumentSnapshot#toObject}).
- *
- * <p>This annotation can only be applied to properties of String or {@link DocumentReference},
- * otherwise a runtime exception will be thrown.
- *
- * <p>A run time exception will be thrown if this annotation is applied to a property that is not
- * writeable (eg, a Java Bean getter without a backing field.).
- *
- * <p>If there are conflicts between this annotation and property name matches, a runtime exception
- * will be thrown. For example: If a POJO has a field `firstName` annotated by @DocumentId, and
- * there is a property from the document named `firstName` as well, an exception will be thrown when
- * you try to read document into the POJO via {@link DocumentSnapshot#toObject} or {@link
- * DocumentReference#get}.
- *
- * <p>When writing a POJO to Firestore, the @DocumentId-annotated property will be ignored, to allow
- * writing to any documents that are not the origin of the POJO.
- */
-@PublicApi
-@Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.FIELD, ElementType.METHOD})
-@interface DocumentId {}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/Executors.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/Executors.java
index 0ff4aaa87..13a16951f 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/Executors.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/Executors.java
@@ -14,11 +14,20 @@
 
 package com.google.firebase.firestore.util;
 
+import android.os.AsyncTask;
 import com.google.android.gms.tasks.TaskExecutors;
 import java.util.concurrent.Executor;
 
 /** Helper class for executors. */
 public final class Executors {
+  /**
+   * The maximum number of tasks we submit to AsyncTask.THREAD_POOL_EXECUTOR.
+   *
+   * <p>The limit is based on the number of core threads spun by THREAD_POOL_EXECUTOR and is well
+   * below the queue size limit of 120 pending tasks. Limiting our usage of the THREAD_POOL_EXECUTOR
+   * allows other users to schedule their own operations on the shared THREAD_POOL_EXECUTOR.
+   */
+  private static final int ASYNC_THREAD_POOL_MAXIMUM_CONCURRENCY = 4;
 
   /**
    * The default executor for user visible callbacks. It is an executor scheduling callbacks on
@@ -29,6 +38,11 @@
   /** An executor that executes the provided runnable immediately on the current thread. */
   public static final Executor DIRECT_EXECUTOR = Runnable::run;
 
+  /** An executor that runs tasks in parallel on Android's AsyncTask.THREAD_POOL_EXECUTOR. */
+  public static final Executor BACKGROUND_EXECUTOR =
+      new ThrottledForwardingExecutor(
+          ASYNC_THREAD_POOL_MAXIMUM_CONCURRENCY, AsyncTask.THREAD_POOL_EXECUTOR);
+
   private Executors() {
     // Private constructor to prevent initialization
   }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/ExponentialBackoff.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/ExponentialBackoff.java
index 89f4a32c7..b67c73393 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/ExponentialBackoff.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/ExponentialBackoff.java
@@ -20,6 +20,18 @@
 
 /** Helper to implement exponential backoff. */
 public class ExponentialBackoff {
+
+  /**
+   * Initial backoff time in milliseconds after an error. Set to 1s according to
+   * https://cloud.google.com/apis/design/errors.
+   */
+  public static final long DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;
+
+  public static final double DEFAULT_BACKOFF_FACTOR = 1.5;
+
+  /** Maximum backoff time in milliseconds */
+  public static final long DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;
+
   private final AsyncQueue queue;
   private final TimerId timerId;
   private final long initialDelayMs;
@@ -64,6 +76,15 @@ public ExponentialBackoff(
     reset();
   }
 
+  public ExponentialBackoff(AsyncQueue queue, AsyncQueue.TimerId timerId) {
+    this(
+        queue,
+        timerId,
+        DEFAULT_BACKOFF_INITIAL_DELAY_MS,
+        DEFAULT_BACKOFF_FACTOR,
+        DEFAULT_BACKOFF_MAX_DELAY_MS);
+  }
+
   /**
    * Resets the backoff delay.
    *
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/ThrottledForwardingExecutor.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/ThrottledForwardingExecutor.java
new file mode 100644
index 000000000..8d6997fb6
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/ThrottledForwardingExecutor.java
@@ -0,0 +1,64 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.util;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.Semaphore;
+
+/**
+ * An executor that forwards executions to another executor, but caps the number of pending
+ * operations. Tasks scheduled past the specified limit are directly invoked on the calling thread,
+ * reducing the total memory consumed by pending tasks.
+ */
+class ThrottledForwardingExecutor implements Executor {
+  private final Executor executor;
+  private final Semaphore availableSlots;
+
+  /**
+   * Instantiates a new ThrottledForwardingExecutor.
+   *
+   * @param maximumConcurrency The maximum number of pending tasks to schedule on the provided
+   *     executor.
+   * @param executor The executor to forward tasks to.
+   */
+  ThrottledForwardingExecutor(int maximumConcurrency, Executor executor) {
+    this.availableSlots = new Semaphore(maximumConcurrency);
+    this.executor = executor;
+  }
+
+  /**
+   * Forwards a task to the provided executor if the current number of pending tasks is less than
+   * the configured limit. Otherwise, executes the task directly.
+   *
+   * @param command The task to run.
+   */
+  @Override
+  public void execute(Runnable command) {
+    if (availableSlots.tryAcquire()) {
+      try {
+        executor.execute(
+            () -> {
+              command.run();
+              availableSlots.release();
+            });
+      } catch (RejectedExecutionException e) {
+        command.run();
+      }
+    } else {
+      command.run();
+    }
+  }
+}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/Util.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/Util.java
index 2739bf1b7..17fcdbb86 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/Util.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/Util.java
@@ -14,7 +14,9 @@
 
 package com.google.firebase.firestore.util;
 
-import android.support.annotation.Nullable;
+import android.os.Handler;
+import android.os.Looper;
+import androidx.annotation.Nullable;
 import com.google.android.gms.tasks.Continuation;
 import com.google.cloud.datastore.core.number.NumberComparisonHelper;
 import com.google.firebase.firestore.FieldPath;
@@ -211,4 +213,13 @@ public static String toDebugString(ByteString bytes) {
   public static String typeName(@Nullable Object obj) {
     return obj == null ? "null" : obj.getClass().getName();
   }
+
+  /** Raises an exception on Android's UI Thread and crashes the end user's app. */
+  public static void crashMainThread(RuntimeException exception) {
+    new Handler(Looper.getMainLooper())
+        .post(
+            () -> {
+              throw exception;
+            });
+  }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/package-info.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/package-info.java
index 108a6ae51..471fde20c 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/package-info.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.firestore.util;
 
-import android.support.annotation.RestrictTo;
+import androidx.annotation.RestrictTo;
diff --git a/firebase-firestore/src/proto/google/firebase/firestore/proto/target.proto b/firebase-firestore/src/proto/google/firebase/firestore/proto/target.proto
index eb8453f46..8bca7e4ad 100644
--- a/firebase-firestore/src/proto/google/firebase/firestore/proto/target.proto
+++ b/firebase-firestore/src/proto/google/firebase/firestore/proto/target.proto
@@ -78,6 +78,10 @@ message Target {
     // A target specified by a set of document names.
     google.firestore.v1.Target.DocumentsTarget documents = 6;
   }
+
+  // Denotes the maximum snapshot version at which the associated query view
+  // contained no limbo documents.
+  google.protobuf.Timestamp last_limbo_free_snapshot_version = 7;
 }
 
 // Global state tracked across all Targets, tracked separately to avoid the
diff --git a/firebase-firestore/src/proto/google/firestore/v1/query.proto b/firebase-firestore/src/proto/google/firestore/v1/query.proto
index dd89ef513..de695e628 100644
--- a/firebase-firestore/src/proto/google/firestore/v1/query.proto
+++ b/firebase-firestore/src/proto/google/firestore/v1/query.proto
@@ -1,4 +1,4 @@
-// Copyright 2018 Google LLC.
+// Copyright 2019 Google LLC.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -103,6 +103,14 @@ message StructuredQuery {
 
       // Contains. Requires that the field is an array.
       ARRAY_CONTAINS = 7;
+
+      // In. Requires that `value` is a non-empty ArrayValue with at most 10
+      // values.
+      IN = 8;
+
+      // Contains any. Requires that the field is an array and
+      // `value` is a non-empty ArrayValue with at most 10 values.
+      ARRAY_CONTAINS_ANY = 9;
     }
 
     // The field to filter by.
diff --git a/firebase-firestore/src/roboUtil/java/com/google/firebase/firestore/TestUtil.java b/firebase-firestore/src/roboUtil/java/com/google/firebase/firestore/TestUtil.java
index 58d78838e..0f6f5190b 100644
--- a/firebase-firestore/src/roboUtil/java/com/google/firebase/firestore/TestUtil.java
+++ b/firebase-firestore/src/roboUtil/java/com/google/firebase/firestore/TestUtil.java
@@ -19,21 +19,17 @@
 import static com.google.firebase.firestore.testutil.TestUtil.key;
 import static org.mockito.Mockito.mock;
 
-import android.support.annotation.Nullable;
 import com.google.android.gms.tasks.Task;
 import com.google.firebase.database.collection.ImmutableSortedSet;
 import com.google.firebase.firestore.core.DocumentViewChange;
 import com.google.firebase.firestore.core.DocumentViewChange.Type;
 import com.google.firebase.firestore.core.ViewSnapshot;
-import com.google.firebase.firestore.local.QueryData;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.DocumentSet;
 import com.google.firebase.firestore.model.ResourcePath;
 import com.google.firebase.firestore.model.value.ObjectValue;
-import com.google.firebase.firestore.remote.WatchChangeAggregator;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import org.junit.Assert;
@@ -133,41 +129,11 @@ public static QuerySnapshot querySnapshot(
             documentChanges,
             isFromCache,
             mutatedKeys,
-            true,
+            /* didSyncStateChange= */ true,
             /* excludesMetadataChanges= */ false);
     return new QuerySnapshot(query(path), viewSnapshot, FIRESTORE);
   }
 
-  /**
-   * An implementation of TargetMetadataProvider that provides controlled access to the
-   * `TargetMetadataProvider` callbacks. Any target accessed via these callbacks must be registered
-   * beforehand via `setSyncedKeys()`.
-   */
-  public static class TestTargetMetadataProvider
-      implements WatchChangeAggregator.TargetMetadataProvider {
-    final Map<Integer, ImmutableSortedSet<DocumentKey>> syncedKeys = new HashMap<>();
-    final Map<Integer, QueryData> queryData = new HashMap<>();
-
-    @Override
-    public ImmutableSortedSet<DocumentKey> getRemoteKeysForTarget(int targetId) {
-      return syncedKeys.get(targetId) != null
-          ? syncedKeys.get(targetId)
-          : DocumentKey.emptyKeySet();
-    }
-
-    @Nullable
-    @Override
-    public QueryData getQueryDataForTarget(int targetId) {
-      return queryData.get(targetId);
-    }
-
-    /** Sets or replaces the local state for the provided query data. */
-    public void setSyncedKeys(QueryData queryData, ImmutableSortedSet<DocumentKey> keys) {
-      this.queryData.put(queryData.getTargetId(), queryData);
-      this.syncedKeys.put(queryData.getTargetId(), keys);
-    }
-  }
-
   public static <T> T waitFor(Task<T> task) {
     if (!task.isComplete()) {
       Robolectric.flushBackgroundThreadScheduler();
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/DocumentSnapshotTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/DocumentSnapshotTest.java
index 5143b4d9f..65d260dd1 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/DocumentSnapshotTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/DocumentSnapshotTest.java
@@ -45,12 +45,14 @@ public void testEquals() {
     assertNotEquals(base, differentData);
     assertNotEquals(base, fromCache);
 
+    // The assertions below that hash codes of different values are not equal is not something that
+    // we guarantee. In particular `base` and `differentData` have a hash collision because we
+    // don't use data in the hashCode.
     assertEquals(base.hashCode(), baseDup.hashCode());
     assertEquals(noData.hashCode(), noDataDup.hashCode());
     assertNotEquals(base.hashCode(), noData.hashCode());
     assertNotEquals(noData.hashCode(), base.hashCode());
     assertNotEquals(base.hashCode(), differentPath.hashCode());
-    assertNotEquals(base.hashCode(), differentData.hashCode());
     assertNotEquals(base.hashCode(), fromCache.hashCode());
   }
 }
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/FirestoreRegistrarTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/FirestoreRegistrarTest.java
index 5e6764ac0..aa06a2fce 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/FirestoreRegistrarTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/FirestoreRegistrarTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.test.core.app.ApplicationProvider;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.FirebaseOptions;
 import com.google.firebase.platforminfo.UserAgentPublisher;
@@ -25,7 +26,6 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 
 @RunWith(RobolectricTestRunner.class)
 public class FirestoreRegistrarTest {
@@ -35,7 +35,7 @@
   public void storageRegistrar_getComponents_publishesLibVersionComponent() {
     FirebaseApp app =
         FirebaseApp.initializeApp(
-            RuntimeEnvironment.application.getApplicationContext(),
+            ApplicationProvider.getApplicationContext(),
             new FirebaseOptions.Builder()
                 .setProjectId("projectId")
                 .setApplicationId("1:196403931065:android:60949756fbe381ea")
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/QuerySnapshotTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/QuerySnapshotTest.java
index 688956608..d11013b34 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/QuerySnapshotTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/QuerySnapshotTest.java
@@ -71,9 +71,10 @@ public void testEquals() {
     assertNotEquals(foo, noPendingWrites);
     assertNotEquals(foo, fromCache);
 
+    // Note: `foo` and `differentDoc` have the same hash code since we no longer take document
+    // contents into account.
     assertEquals(foo.hashCode(), fooDup.hashCode());
     assertNotEquals(foo.hashCode(), differentPath.hashCode());
-    assertNotEquals(foo.hashCode(), differentDoc.hashCode());
     assertNotEquals(foo.hashCode(), noPendingWrites.hashCode());
     assertNotEquals(foo.hashCode(), fromCache.hashCode());
   }
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/core/EventManagerTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/core/EventManagerTest.java
index 02644d365..3d8c28b80 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/core/EventManagerTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/core/EventManagerTest.java
@@ -118,7 +118,11 @@ public void testWillForwardOnOnlineStateChangedCalls() {
 
     QueryListener spy = mock(QueryListener.class);
     when(spy.getQuery()).thenReturn(query1);
-    doAnswer(invocation -> events.add(invocation.getArguments()[0]))
+    doAnswer(
+            invocation -> {
+              events.add(invocation.getArguments()[0]);
+              return false;
+            })
         .when(spy)
         .onOnlineStateChanged(any());
 
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/core/QueryTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/core/QueryTest.java
index acc22a484..1665bf72c 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/core/QueryTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/core/QueryTest.java
@@ -31,6 +31,7 @@
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.ResourcePath;
 import com.google.firebase.firestore.testutil.ComparatorTester;
+import java.util.Collections;
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -159,6 +160,80 @@ public void testArrayContainsFiltersWithObjectValues() {
     assertTrue(query.matches(document));
   }
 
+  @Test
+  public void testInFilters() {
+    Query query =
+        Query.atPath(ResourcePath.fromString("collection"))
+            .filter(filter("zip", "in", asList(12345)));
+
+    Document document = doc("collection/1", 0, map("zip", 12345));
+    assertTrue(query.matches(document));
+
+    // Value matches in array.
+    document = doc("collection/1", 0, map("zip", asList(12345)));
+    assertFalse(query.matches(document));
+
+    // Non-type match.
+    document = doc("collection/1", 0, map("zip", "12345"));
+    assertFalse(query.matches(document));
+
+    // Nested match.
+    document = doc("collection/1", 0, map("zip", asList("12345", map("zip", 12345))));
+    assertFalse(query.matches(document));
+  }
+
+  @Test
+  public void testInFiltersWithObjectValues() {
+    Query query =
+        Query.atPath(ResourcePath.fromString("collection"))
+            .filter(filter("zip", "in", asList(map("a", asList(42)))));
+
+    // Containing object in array.
+    Document document = doc("collection/1", 0, map("zip", asList(map("a", asList(42)))));
+    assertFalse(query.matches(document));
+
+    // Containing object.
+    document = doc("collection/1", 0, map("zip", map("a", asList(42))));
+    assertTrue(query.matches(document));
+  }
+
+  @Test
+  public void testArrayContainsAnyFilters() {
+    Query query =
+        Query.atPath(ResourcePath.fromString("collection"))
+            .filter(filter("zip", "array-contains-any", asList(12345)));
+
+    Document document = doc("collection/1", 0, map("zip", asList(12345)));
+    assertTrue(query.matches(document));
+
+    // Value matches in non-array.
+    document = doc("collection/1", 0, map("zip", 12345));
+    assertFalse(query.matches(document));
+
+    // Non-type match.
+    document = doc("collection/1", 0, map("zip", asList("12345")));
+    assertFalse(query.matches(document));
+
+    // Nested match.
+    document = doc("collection/1", 0, map("zip", asList("12345", map("zip", asList(12345)))));
+    assertFalse(query.matches(document));
+  }
+
+  @Test
+  public void testArrayContainsAnyFiltersWithObjectValues() {
+    Query query =
+        Query.atPath(ResourcePath.fromString("collection"))
+            .filter(filter("zip", "array-contains-any", asList(map("a", asList(42)))));
+
+    // Containing object in array.
+    Document document = doc("collection/1", 0, map("zip", asList(map("a", asList(42)))));
+    assertTrue(query.matches(document));
+
+    // Containing object.
+    document = doc("collection/1", 0, map("zip", map("a", asList(42))));
+    assertFalse(query.matches(document));
+  }
+
   @Test
   public void testNaNFilter() {
     Query query =
@@ -454,4 +529,28 @@ public void testImplicitOrderBy() {
         asList(orderBy("foo", "desc"), orderBy("bar", "asc"), orderBy(KEY_FIELD_NAME, "asc")),
         baseQuery.orderBy(orderBy("foo", "desc")).orderBy(orderBy("bar", "asc")).getOrderBy());
   }
+
+  @Test
+  public void testMatchesAllDocuments() {
+    Query baseQuery = Query.atPath(ResourcePath.fromString("collection"));
+    assertTrue(baseQuery.matchesAllDocuments());
+
+    Query query = baseQuery.orderBy(orderBy("__name__"));
+    assertTrue(query.matchesAllDocuments());
+
+    query = baseQuery.orderBy(orderBy("foo"));
+    assertFalse(query.matchesAllDocuments());
+
+    query = baseQuery.filter(filter("foo", "==", "bar"));
+    assertFalse(query.matchesAllDocuments());
+
+    query = baseQuery.limit(1);
+    assertFalse(query.matchesAllDocuments());
+
+    query = baseQuery.startAt(new Bound(Collections.emptyList(), true));
+    assertFalse(query.matchesAllDocuments());
+
+    query = baseQuery.endAt(new Bound(Collections.emptyList(), true));
+    assertFalse(query.matchesAllDocuments());
+  }
 }
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/core/ViewTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/core/ViewTest.java
index efac909cf..04d9ebef2 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/core/ViewTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/core/ViewTest.java
@@ -301,6 +301,32 @@ public void testKeepsTrackOfLimboDocuments() {
         change.getLimboChanges());
   }
 
+  @Test
+  public void testViewsWithLimboDocumentsAreMarkedFromCache() {
+    Query query = messageQuery();
+    View view = new View(query, DocumentKey.emptyKeySet());
+    Document doc1 = doc("rooms/eros/messages/0", 0, map());
+    Document doc2 = doc("rooms/eros/messages/1", 0, map());
+
+    // Doc1 is contained in the local view, but we are not yet CURRENT so it is expected that the
+    // backend hasn't told us about all documents yet.
+    ViewChange change = applyChanges(view, doc1);
+    assertTrue(change.getSnapshot().isFromCache());
+
+    // Add doc2 to generate a snapshot. Doc1 is still missing.
+    View.DocumentChanges viewDocChanges = view.computeDocChanges(docUpdates(doc2));
+    change =
+        view.applyChanges(
+            viewDocChanges, targetChange(ByteString.EMPTY, true, asList(doc2), null, null));
+    assertTrue(change.getSnapshot().isFromCache()); // We are CURRENT but doc1 is in limbo.
+
+    // Add doc1 to the backend's result set.
+    change =
+        view.applyChanges(
+            viewDocChanges, targetChange(ByteString.EMPTY, true, asList(doc1), null, null));
+    assertFalse(change.getSnapshot().isFromCache());
+  }
+
   @Test
   public void testResumingQueryCreatesNoLimbos() {
     Query query = messageQuery();
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/AccumulatingStatsCollector.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/AccumulatingStatsCollector.java
new file mode 100644
index 000000000..08e56126f
--- /dev/null
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/AccumulatingStatsCollector.java
@@ -0,0 +1,66 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.local;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/* A test-only collector of operation counts from the persistence layer. */
+class AccumulatingStatsCollector extends StatsCollector {
+
+  private final Map<String, Integer> rowsRead = new HashMap<>();
+  private final Map<String, Integer> rowsDeleted = new HashMap<>();
+  private final Map<String, Integer> rowsWritten = new HashMap<>();
+
+  @Override
+  void recordRowsRead(String tag, int count) {
+    Integer currentValue = rowsRead.get(tag);
+    rowsRead.put(tag, currentValue != null ? currentValue + count : count);
+  }
+
+  @Override
+  void recordRowsDeleted(String tag, int count) {
+    Integer currentValue = rowsDeleted.get(tag);
+    rowsDeleted.put(tag, currentValue != null ? currentValue + count : count);
+  }
+
+  @Override
+  void recordRowsWritten(String tag, int count) {
+    Integer currentValue = rowsWritten.get(tag);
+    rowsWritten.put(tag, currentValue != null ? currentValue + count : count);
+  }
+
+  /** Reset all operation counts */
+  void reset() {
+    rowsRead.clear();
+    rowsDeleted.clear();
+    rowsWritten.clear();
+  }
+
+  /** Returns the number of rows read for the given tag since the last call to `reset()`. */
+  int getRowsRead(String tag) {
+    return rowsRead.containsKey(tag) ? rowsRead.get(tag) : 0;
+  }
+
+  /** Returns the number of rows written for the given tag since the last call to `reset()`. */
+  int getRowsWritten(String tag) {
+    return rowsWritten.containsKey(tag) ? rowsWritten.get(tag) : 0;
+  }
+
+  /** Returns the number of rows deleted for the given tag since the last call to `reset()`. */
+  int getRowsDeleted(String tag) {
+    return rowsDeleted.containsKey(tag) ? rowsDeleted.get(tag) : 0;
+  }
+}
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/EncodedPathTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/EncodedPathTest.java
index 9a8dc3cce..1a57b8cae 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/EncodedPathTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/EncodedPathTest.java
@@ -25,6 +25,7 @@
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
+import androidx.test.core.app.ApplicationProvider;
 import com.google.firebase.firestore.model.ResourcePath;
 import java.util.ArrayList;
 import java.util.List;
@@ -33,7 +34,6 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
@@ -42,7 +42,7 @@
 
   static class OpenHelper extends SQLiteOpenHelper {
     OpenHelper() {
-      super(RuntimeEnvironment.application, "test", null, 1);
+      super(ApplicationProvider.getApplicationContext(), "test", null, 1);
     }
 
     @Override
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/IndexFreeQueryEngineTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/IndexFreeQueryEngineTest.java
new file mode 100644
index 000000000..f21c3a6e8
--- /dev/null
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/IndexFreeQueryEngineTest.java
@@ -0,0 +1,314 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.local;
+
+import static com.google.firebase.firestore.testutil.TestUtil.doc;
+import static com.google.firebase.firestore.testutil.TestUtil.docSet;
+import static com.google.firebase.firestore.testutil.TestUtil.filter;
+import static com.google.firebase.firestore.testutil.TestUtil.key;
+import static com.google.firebase.firestore.testutil.TestUtil.map;
+import static com.google.firebase.firestore.testutil.TestUtil.orderBy;
+import static com.google.firebase.firestore.testutil.TestUtil.query;
+import static com.google.firebase.firestore.testutil.TestUtil.version;
+import static org.junit.Assert.assertEquals;
+
+import com.google.android.gms.common.internal.Preconditions;
+import com.google.firebase.database.collection.ImmutableSortedMap;
+import com.google.firebase.database.collection.ImmutableSortedSet;
+import com.google.firebase.firestore.auth.User;
+import com.google.firebase.firestore.core.Query;
+import com.google.firebase.firestore.core.View;
+import com.google.firebase.firestore.model.Document;
+import com.google.firebase.firestore.model.DocumentKey;
+import com.google.firebase.firestore.model.DocumentSet;
+import com.google.firebase.firestore.model.SnapshotVersion;
+import com.google.protobuf.ByteString;
+import java.util.Collections;
+import java.util.concurrent.Callable;
+import javax.annotation.Nullable;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class IndexFreeQueryEngineTest {
+
+  private static final int TEST_TARGET_ID = 1;
+
+  private static final Document MATCHING_DOC_A =
+      doc("coll/a", 1, map("matches", true, "order", 1), Document.DocumentState.SYNCED);
+  private static final Document NON_MATCHING_DOC_A =
+      doc("coll/a", 1, map("matches", false, "order", 1), Document.DocumentState.SYNCED);
+  private static final Document PENDING_MATCHING_DOC_A =
+      doc("coll/a", 1, map("matches", true, "order", 1), Document.DocumentState.LOCAL_MUTATIONS);
+  private static final Document PENDING_NON_MATCHING_DOC_A =
+      doc("coll/a", 1, map("matches", false, "order", 1), Document.DocumentState.LOCAL_MUTATIONS);
+  private static final Document UDPATED_DOC_A =
+      doc("coll/a", 11, map("matches", true, "order", 1), Document.DocumentState.SYNCED);
+  private static final Document MATCHING_DOC_B =
+      doc("coll/b", 1, map("matches", true, "order", 2), Document.DocumentState.SYNCED);
+  private static final Document UPDATED_MATCHING_DOC_B =
+      doc("coll/b", 11, map("matches", true, "order", 2), Document.DocumentState.SYNCED);
+
+  private MemoryPersistence persistence;
+  private MemoryRemoteDocumentCache remoteDocumentCache;
+  private QueryCache queryCache;
+  private QueryEngine queryEngine;
+
+  private @Nullable Boolean expectIndexFreeExecution;
+
+  @Before
+  public void setUp() {
+    expectIndexFreeExecution = null;
+
+    persistence = MemoryPersistence.createEagerGcMemoryPersistence();
+    queryCache = new MemoryQueryCache(persistence);
+    queryEngine = new IndexFreeQueryEngine();
+
+    remoteDocumentCache = persistence.getRemoteDocumentCache();
+
+    LocalDocumentsView localDocuments =
+        new LocalDocumentsView(
+            remoteDocumentCache,
+            persistence.getMutationQueue(User.UNAUTHENTICATED),
+            new MemoryIndexManager()) {
+          @Override
+          public ImmutableSortedMap<DocumentKey, Document> getDocumentsMatchingQuery(
+              Query query, SnapshotVersion sinceReadTime) {
+            assertEquals(
+                "Observed query execution mode did not match expectation",
+                expectIndexFreeExecution,
+                !SnapshotVersion.NONE.equals(sinceReadTime));
+            return super.getDocumentsMatchingQuery(query, sinceReadTime);
+          }
+        };
+    queryEngine.setLocalDocumentsView(localDocuments);
+  }
+
+  /** Adds the provided documents to the query target mapping. */
+  private void persistQueryMapping(DocumentKey... documentKeys) {
+    persistence.runTransaction(
+        "persistQueryMapping",
+        () -> {
+          ImmutableSortedSet<DocumentKey> remoteKeys = DocumentKey.emptyKeySet();
+          for (DocumentKey documentKey : documentKeys) {
+            remoteKeys = remoteKeys.insert(documentKey);
+          }
+          queryCache.addMatchingKeys(remoteKeys, TEST_TARGET_ID);
+        });
+  }
+
+  /** Adds the provided documents to the remote document cache. */
+  private void addDocument(Document... docs) {
+    persistence.runTransaction(
+        "addDocument",
+        () -> {
+          for (Document doc : docs) {
+            remoteDocumentCache.add(doc, doc.getVersion());
+          }
+        });
+  }
+
+  private <T> T expectIndexFreeQuery(Callable<T> c) throws Exception {
+    try {
+      expectIndexFreeExecution = true;
+      return c.call();
+    } finally {
+      expectIndexFreeExecution = null;
+    }
+  }
+
+  private <T> T expectFullCollectionQuery(Callable<T> c) throws Exception {
+    try {
+      expectIndexFreeExecution = false;
+      return c.call();
+    } finally {
+      expectIndexFreeExecution = null;
+    }
+  }
+
+  private DocumentSet runQuery(Query query, QueryData queryData) {
+    Preconditions.checkNotNull(
+        expectIndexFreeExecution,
+        "Encountered runQuery() call not wrapped in expectIndexFreeQuery()/expectFullCollectionQuery()");
+    ImmutableSortedMap<DocumentKey, Document> docs =
+        queryEngine.getDocumentsMatchingQuery(
+            query, queryData, queryCache.getMatchingKeysForTargetId(TEST_TARGET_ID));
+    View view =
+        new View(query, new ImmutableSortedSet<>(Collections.emptyList(), DocumentKey::compareTo));
+    View.DocumentChanges viewDocChanges = view.computeDocChanges(docs);
+    return view.applyChanges(viewDocChanges).getSnapshot().getDocuments();
+  }
+
+  @Test
+  public void usesTargetMappingForInitialView() throws Exception {
+    Query query = query("coll").filter(filter("matches", "==", true));
+    QueryData queryData = queryData(query, /* hasLimboFreeSnapshot= */ true);
+
+    addDocument(MATCHING_DOC_A, MATCHING_DOC_B);
+    persistQueryMapping(MATCHING_DOC_A.getKey(), MATCHING_DOC_B.getKey());
+
+    DocumentSet docs = expectIndexFreeQuery(() -> runQuery(query, queryData));
+    assertEquals(docSet(query.comparator(), MATCHING_DOC_A, MATCHING_DOC_B), docs);
+  }
+
+  @Test
+  public void filtersNonMatchingInitialResults() throws Exception {
+    Query query = query("coll").filter(filter("matches", "==", true));
+    QueryData queryData = queryData(query, /* hasLimboFreeSnapshot= */ true);
+
+    addDocument(MATCHING_DOC_A, MATCHING_DOC_B);
+    persistQueryMapping(MATCHING_DOC_A.getKey(), MATCHING_DOC_B.getKey());
+
+    // Add a mutated document that is not yet part of query's set of remote keys.
+    addDocument(PENDING_NON_MATCHING_DOC_A);
+
+    DocumentSet docs = expectIndexFreeQuery(() -> runQuery(query, queryData));
+    assertEquals(docSet(query.comparator(), MATCHING_DOC_B), docs);
+  }
+
+  @Test
+  public void includesChangesSinceInitialResults() throws Exception {
+    Query query = query("coll").filter(filter("matches", "==", true));
+    QueryData originalQueryData = queryData(query, /* hasLimboFreeSnapshot= */ true);
+
+    addDocument(MATCHING_DOC_A, MATCHING_DOC_B);
+    persistQueryMapping(MATCHING_DOC_A.getKey(), MATCHING_DOC_B.getKey());
+
+    DocumentSet docs = expectIndexFreeQuery(() -> runQuery(query, originalQueryData));
+    assertEquals(docSet(query.comparator(), MATCHING_DOC_A, MATCHING_DOC_B), docs);
+
+    addDocument(UPDATED_MATCHING_DOC_B);
+
+    docs = expectIndexFreeQuery(() -> runQuery(query, originalQueryData));
+    assertEquals(docSet(query.comparator(), MATCHING_DOC_A, UPDATED_MATCHING_DOC_B), docs);
+  }
+
+  @Test
+  public void doesNotUseInitialResultsWithoutLimboFreeSnapshotVersion() throws Exception {
+    Query query = query("coll").filter(filter("matches", "==", true));
+    QueryData queryData = queryData(query, /* hasLimboFreeSnapshot= */ false);
+
+    DocumentSet docs = expectFullCollectionQuery(() -> runQuery(query, queryData));
+    assertEquals(docSet(query.comparator()), docs);
+  }
+
+  @Test
+  public void doesNotUseInitialResultsForUnfilteredCollectionQuery() throws Exception {
+    Query query = query("coll");
+    QueryData queryData = queryData(query, /* hasLimboFreeSnapshot= */ true);
+
+    DocumentSet docs = expectFullCollectionQuery(() -> runQuery(query, queryData));
+    assertEquals(docSet(query.comparator()), docs);
+  }
+
+  @Test
+  public void doesNotUseInitialResultsForLimitQueryWithDocumentRemoval() throws Exception {
+    Query query = query("coll").filter(filter("matches", "==", true)).limit(1);
+
+    // While the backend would never add DocA to the set of remote keys, this allows us to easily
+    // simulate what would happen when a document no longer matches due to an out-of-band update.
+    addDocument(NON_MATCHING_DOC_A);
+    persistQueryMapping(NON_MATCHING_DOC_A.getKey());
+
+    addDocument(MATCHING_DOC_B);
+
+    QueryData queryData = queryData(query, /* hasLimboFreeSnapshot= */ true);
+    DocumentSet docs = expectFullCollectionQuery(() -> runQuery(query, queryData));
+    assertEquals(docSet(query.comparator(), MATCHING_DOC_B), docs);
+  }
+
+  @Test
+  public void doesNotUseInitialResultsForLimitQueryWhenLastDocumentHasPendingWrite()
+      throws Exception {
+    Query query =
+        query("coll")
+            .filter(filter("matches", "==", true))
+            .orderBy(orderBy("order", "desc"))
+            .limit(1);
+
+    // Add a query mapping for a document that matches, but that sorts below another document due to
+    // a pending write.
+    addDocument(PENDING_MATCHING_DOC_A);
+    persistQueryMapping(PENDING_MATCHING_DOC_A.getKey());
+
+    QueryData queryData = queryData(query, /* hasLimboFreeSnapshot= */ true);
+
+    addDocument(MATCHING_DOC_B);
+
+    DocumentSet docs = expectFullCollectionQuery(() -> runQuery(query, queryData));
+    assertEquals(docSet(query.comparator(), MATCHING_DOC_B), docs);
+  }
+
+  @Test
+  public void doesNotUseInitialResultsForLimitQueryWhenLastDocumentHasBeenUpdatedOutOfBand()
+      throws Exception {
+    Query query =
+        query("coll")
+            .filter(filter("matches", "==", true))
+            .orderBy(orderBy("order", "desc"))
+            .limit(1);
+
+    // Add a query mapping for a document that matches, but that sorts below another document based
+    // due to an update that the SDK received after the query's snapshot was persisted.
+    addDocument(UDPATED_DOC_A);
+    persistQueryMapping(UDPATED_DOC_A.getKey());
+
+    QueryData queryData = queryData(query, /* hasLimboFreeSnapshot= */ true);
+
+    addDocument(MATCHING_DOC_B);
+
+    DocumentSet docs = expectFullCollectionQuery(() -> runQuery(query, queryData));
+    assertEquals(docSet(query.comparator(), MATCHING_DOC_B), docs);
+  }
+
+  @Test
+  public void limitQueriesUseInitialResultsIfLastDocumentInLimitIsUnchanged() throws Exception {
+    Query query = query("coll").orderBy(orderBy("order")).limit(2);
+
+    addDocument(doc("coll/a", 1, map("order", 1)));
+    addDocument(doc("coll/b", 1, map("order", 3)));
+    persistQueryMapping(key("coll/a"), key("coll/b"));
+    QueryData queryData = queryData(query, /* hasLimboFreeSnapshot= */ true);
+
+    // Update "coll/a" but make sure it still sorts before "coll/b"
+    addDocument(doc("coll/a", 1, map("order", 2), Document.DocumentState.LOCAL_MUTATIONS));
+
+    // Since the last document in the limit didn't change (and hence we know that all documents
+    // written prior to query execution still sort after "coll/b"), we should use an Index-Free
+    // query.
+    DocumentSet docs = expectIndexFreeQuery(() -> runQuery(query, queryData));
+    assertEquals(
+        docSet(
+            query.comparator(),
+            doc("coll/a", 1, map("order", 2), Document.DocumentState.LOCAL_MUTATIONS),
+            doc("coll/b", 1, map("order", 3))),
+        docs);
+  }
+
+  private QueryData queryData(Query query, boolean hasLimboFreeSnapshot) {
+    return new QueryData(
+        query,
+        TEST_TARGET_ID,
+        1,
+        QueryPurpose.LISTEN,
+        version(10),
+        hasLimboFreeSnapshot ? version(10) : SnapshotVersion.NONE,
+        ByteString.EMPTY);
+  }
+}
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/IndexedQueryEngineTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/IndexedQueryEngineTest.java
index 8cf85f301..b18efe0d9 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/IndexedQueryEngineTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/IndexedQueryEngineTest.java
@@ -69,11 +69,12 @@ public void setUp() {
     remoteDocuments = persistence.getRemoteDocumentCache();
     LocalDocumentsView localDocuments =
         new LocalDocumentsView(remoteDocuments, mutationQueue, persistence.getIndexManager());
-    queryEngine = new IndexedQueryEngine(localDocuments, index);
+    queryEngine = new IndexedQueryEngine(index);
   }
 
   private void addDocument(Document newDoc) {
-    remoteDocuments.add(newDoc);
+    // Use document version as read time as the IndexedQueryEngine does not rely on read time.
+    remoteDocuments.add(newDoc, newDoc.getVersion());
     queryEngine.handleDocumentChange(
         deletedDoc(newDoc.getKey().toString(), ORIGINAL_VERSION), newDoc);
   }
@@ -85,7 +86,7 @@ private void removeDocument(Document oldDoc) {
   }
 
   private void updateDocument(Document oldDoc, Document newDoc) {
-    remoteDocuments.add(newDoc);
+    remoteDocuments.add(newDoc, newDoc.getVersion());
     queryEngine.handleDocumentChange(oldDoc, newDoc);
   }
 
@@ -213,7 +214,8 @@ public void addDocumentQuery() {
     Query query = query("coll").filter(filter("a", "==", "a"));
 
     ImmutableSortedMap<DocumentKey, Document> results =
-        queryEngine.getDocumentsMatchingQuery(query);
+        queryEngine.getDocumentsMatchingQuery(
+            query, /* queryData= */ null, DocumentKey.emptyKeySet());
 
     assertThat(results).doesNotContain(IGNORED_DOC.getKey());
     assertThat(results).contains(MATCHING_DOC.getKey());
@@ -228,7 +230,8 @@ public void updateDocumentQuery() {
     Query query = query("coll").filter(filter("a", "==", "a"));
 
     ImmutableSortedMap<DocumentKey, Document> results =
-        queryEngine.getDocumentsMatchingQuery(query);
+        queryEngine.getDocumentsMatchingQuery(
+            query, /* queryData= */ null, DocumentKey.emptyKeySet());
 
     assertThat(results).doesNotContain(IGNORED_DOC.getKey());
     assertThat(results).contains(MATCHING_DOC.getKey());
@@ -243,7 +246,8 @@ public void removeDocumentQuery() {
     Query query = query("coll").filter(filter("a", "==", "a"));
 
     ImmutableSortedMap<DocumentKey, Document> results =
-        queryEngine.getDocumentsMatchingQuery(query);
+        queryEngine.getDocumentsMatchingQuery(
+            query, /* queryData= */ null, DocumentKey.emptyKeySet());
 
     assertThat(results).doesNotContain(IGNORED_DOC.getKey());
     assertThat(results).doesNotContain(MATCHING_DOC.getKey());
@@ -261,7 +265,8 @@ public void nestedQuery() {
     Query query = query("coll").filter(filter("a.a", "==", "a"));
 
     ImmutableSortedMap<DocumentKey, Document> results =
-        queryEngine.getDocumentsMatchingQuery(query);
+        queryEngine.getDocumentsMatchingQuery(
+            query, /* queryData= */ null, DocumentKey.emptyKeySet());
 
     assertThat(results).doesNotContain(ignoredDoc.getKey());
     assertThat(results).contains(matchingDoc.getKey());
@@ -275,7 +280,8 @@ public void orderByQuery() {
     Query query = query("coll").orderBy(TestUtil.orderBy("a"));
 
     ImmutableSortedMap<DocumentKey, Document> results =
-        queryEngine.getDocumentsMatchingQuery(query);
+        queryEngine.getDocumentsMatchingQuery(
+            query, /* queryData= */ null, DocumentKey.emptyKeySet());
 
     assertThat(results).doesNotContain(IGNORED_DOC.getKey());
     assertThat(results).contains(MATCHING_DOC.getKey());
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LocalSerializerTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LocalSerializerTest.java
index c97f3637f..b671db654 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LocalSerializerTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LocalSerializerTest.java
@@ -203,11 +203,19 @@ public void testEncodesQueryData() {
     Query query = TestUtil.query("room");
     int targetId = 42;
     long sequenceNumber = 10;
-    SnapshotVersion version = TestUtil.version(1039);
+    SnapshotVersion snapshotVersion = TestUtil.version(1039);
+    SnapshotVersion limboFreeVersion = TestUtil.version(1000);
     ByteString resumeToken = TestUtil.resumeToken(1039);
 
     QueryData queryData =
-        new QueryData(query, targetId, sequenceNumber, QueryPurpose.LISTEN, version, resumeToken);
+        new QueryData(
+            query,
+            targetId,
+            sequenceNumber,
+            QueryPurpose.LISTEN,
+            snapshotVersion,
+            limboFreeVersion,
+            resumeToken);
 
     // Let the RPC serializer test various permutations of query serialization.
     com.google.firestore.v1.Target.QueryTarget queryTarget =
@@ -223,6 +231,8 @@ public void testEncodesQueryData() {
                 com.google.firestore.v1.Target.QueryTarget.newBuilder()
                     .setParent(queryTarget.getParent())
                     .setStructuredQuery(queryTarget.getStructuredQuery()))
+            .setLastLimboFreeSnapshotVersion(
+                com.google.protobuf.Timestamp.newBuilder().setNanos(1000000))
             .build();
 
     assertEquals(expected, serializer.encodeQueryData(queryData));
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LocalStoreTestCase.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LocalStoreTestCase.java
index 0d7617c17..72e83e440 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LocalStoreTestCase.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LocalStoreTestCase.java
@@ -19,8 +19,10 @@
 import static com.google.firebase.firestore.testutil.TestUtil.deleteMutation;
 import static com.google.firebase.firestore.testutil.TestUtil.deletedDoc;
 import static com.google.firebase.firestore.testutil.TestUtil.doc;
+import static com.google.firebase.firestore.testutil.TestUtil.filter;
 import static com.google.firebase.firestore.testutil.TestUtil.key;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
+import static com.google.firebase.firestore.testutil.TestUtil.noChangeEvent;
 import static com.google.firebase.firestore.testutil.TestUtil.patchMutation;
 import static com.google.firebase.firestore.testutil.TestUtil.query;
 import static com.google.firebase.firestore.testutil.TestUtil.resumeToken;
@@ -39,6 +41,8 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeFalse;
+import static org.junit.Assume.assumeTrue;
 
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
@@ -46,7 +50,6 @@
 import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.database.collection.ImmutableSortedSet;
 import com.google.firebase.firestore.FieldValue;
-import com.google.firebase.firestore.TestUtil.TestTargetMetadataProvider;
 import com.google.firebase.firestore.auth.User;
 import com.google.firebase.firestore.core.Query;
 import com.google.firebase.firestore.model.Document;
@@ -61,13 +64,9 @@
 import com.google.firebase.firestore.model.mutation.MutationResult;
 import com.google.firebase.firestore.model.mutation.SetMutation;
 import com.google.firebase.firestore.remote.RemoteEvent;
-import com.google.firebase.firestore.remote.WatchChange.WatchTargetChange;
-import com.google.firebase.firestore.remote.WatchChange.WatchTargetChangeType;
-import com.google.firebase.firestore.remote.WatchChangeAggregator;
 import com.google.firebase.firestore.remote.WatchStream;
 import com.google.firebase.firestore.remote.WriteStream;
 import com.google.firebase.firestore.testutil.TestUtil;
-import com.google.protobuf.ByteString;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -76,6 +75,7 @@
 import java.util.Set;
 import javax.annotation.Nullable;
 import org.junit.After;
+import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -90,26 +90,35 @@
  * </ol>
  */
 public abstract class LocalStoreTestCase {
+  private QueryEngine queryEngine;
   private Persistence localStorePersistence;
   private LocalStore localStore;
 
   private List<MutationBatch> batches;
   private @Nullable ImmutableSortedMap<DocumentKey, MaybeDocument> lastChanges;
+  private ImmutableSortedMap<DocumentKey, Document> lastQueryResult;
   private int lastTargetId;
 
+  AccumulatingStatsCollector statsCollector;
+
+  abstract QueryEngine getQueryEngine();
+
   abstract Persistence getPersistence();
 
   abstract boolean garbageCollectorIsEager();
 
   @Before
   public void setUp() {
-    localStorePersistence = getPersistence();
-    localStore = new LocalStore(localStorePersistence, User.UNAUTHENTICATED);
-    localStore.start();
-
+    statsCollector = new AccumulatingStatsCollector();
     batches = new ArrayList<>();
     lastChanges = null;
+    lastQueryResult = null;
     lastTargetId = 0;
+
+    localStorePersistence = getPersistence();
+    queryEngine = getQueryEngine();
+    localStore = new LocalStore(localStorePersistence, queryEngine, User.UNAUTHENTICATED);
+    localStore.start();
   }
 
   @After
@@ -137,6 +146,10 @@ private void notifyLocalViewChanges(LocalViewChanges changes) {
     localStore.notifyLocalViewChanges(asList(changes));
   }
 
+  private void udpateViews(int targetId, boolean fromCache) {
+    notifyLocalViewChanges(viewChanges(targetId, fromCache, asList(), asList()));
+  }
+
   private void acknowledgeMutation(long documentVersion, @Nullable Object transformResult) {
     MutationBatch batch = batches.remove(0);
     SnapshotVersion version = version(documentVersion);
@@ -166,6 +179,11 @@ private int allocateQuery(Query query) {
     return queryData.getTargetId();
   }
 
+  private void executeQuery(Query query) {
+    resetPersistenceStats();
+    lastQueryResult = localStore.executeQuery(query);
+  }
+
   private void releaseQuery(Query query) {
     localStore.releaseQuery(query);
   }
@@ -213,6 +231,35 @@ private void assertNotContains(String keyPathString) {
     assertNull(actual);
   }
 
+  private void assertQueryReturned(String... keys) {
+    assertNotNull(lastQueryResult);
+    for (String key : keys) {
+      assertTrue("Expected query to return: " + key, lastQueryResult.containsKey(key(key)));
+    }
+    assertEquals(lastQueryResult.size(), keys.length);
+  }
+
+  /**
+   * Asserts the expected numbers of mutation rows read by the MutationQueue since the last call to
+   * `resetPersistenceStats()`.
+   */
+  private void assertMutationsRead(int expected) {
+    assertEquals(expected, statsCollector.getRowsRead(MutationQueue.STATS_TAG));
+  }
+
+  /**
+   * Asserts the expected numbers of document rows read by the RemoteDocumentCache since the last
+   * call to `resetPersistenceStats()`.
+   */
+  private void assertRemoteDocumentsRead(int expected) {
+    assertEquals(expected, statsCollector.getRowsRead(RemoteDocumentCache.STATS_TAG));
+  }
+
+  /** Resets the count of rows read by MutationQueue and the RemoteDocumentCache. */
+  private void resetPersistenceStats() {
+    statsCollector.reset();
+  }
+
   @Test
   public void testMutationBatchKeys() {
     SetMutation set1 = setMutation("foo/bar", map("foo", "bar"));
@@ -229,15 +276,15 @@ public void testHandlesSetMutation() {
     assertChanged(doc("foo/bar", 0, map("foo", "bar"), Document.DocumentState.LOCAL_MUTATIONS));
     assertContains(doc("foo/bar", 0, map("foo", "bar"), Document.DocumentState.LOCAL_MUTATIONS));
 
-    acknowledgeMutation(0);
-    assertChanged(doc("foo/bar", 0, map("foo", "bar"), Document.DocumentState.COMMITTED_MUTATIONS));
+    acknowledgeMutation(1);
+    assertChanged(doc("foo/bar", 1, map("foo", "bar"), Document.DocumentState.COMMITTED_MUTATIONS));
     if (garbageCollectorIsEager()) {
       // Nothing is pinning this anymore, as it has been acknowledged and there are no targets
       // active.
       assertNotContains("foo/bar");
     } else {
       assertContains(
-          doc("foo/bar", 0, map("foo", "bar"), Document.DocumentState.COMMITTED_MUTATIONS));
+          doc("foo/bar", 1, map("foo", "bar"), Document.DocumentState.COMMITTED_MUTATIONS));
     }
   }
 
@@ -264,7 +311,7 @@ public void testHandlesSetMutationThenAckThenRelease() {
     allocateQuery(query);
 
     writeMutation(setMutation("foo/bar", map("foo", "bar")));
-    notifyLocalViewChanges(viewChanges(2, asList("foo/bar"), emptyList()));
+    notifyLocalViewChanges(viewChanges(2, /* fromCache= */ false, asList("foo/bar"), emptyList()));
 
     assertChanged(doc("foo/bar", 0, map("foo", "bar"), Document.DocumentState.LOCAL_MUTATIONS));
     assertContains(doc("foo/bar", 0, map("foo", "bar"), Document.DocumentState.LOCAL_MUTATIONS));
@@ -707,12 +754,12 @@ public void testCollectsGarbageAfterAcknowledgedMutation() {
     Query query = Query.atPath(ResourcePath.fromString("foo"));
     int targetId = allocateQuery(query);
     applyRemoteEvent(
-        updateRemoteEvent(doc("foo/bar", 0, map("foo", "old")), asList(targetId), emptyList()));
+        updateRemoteEvent(doc("foo/bar", 1, map("foo", "old")), asList(targetId), emptyList()));
     writeMutation(patchMutation("foo/bar", map("foo", "bar")));
     releaseQuery(query);
     writeMutation(setMutation("foo/bah", map("foo", "bah")));
     writeMutation(deleteMutation("foo/baz"));
-    assertContains(doc("foo/bar", 0, map("foo", "bar"), Document.DocumentState.LOCAL_MUTATIONS));
+    assertContains(doc("foo/bar", 1, map("foo", "bar"), Document.DocumentState.LOCAL_MUTATIONS));
     assertContains(doc("foo/bah", 0, map("foo", "bah"), Document.DocumentState.LOCAL_MUTATIONS));
     assertContains(deletedDoc("foo/baz", 0));
 
@@ -741,13 +788,13 @@ public void testCollectsGarbageAfterRejectedMutation() {
     Query query = Query.atPath(ResourcePath.fromString("foo"));
     int targetId = allocateQuery(query);
     applyRemoteEvent(
-        updateRemoteEvent(doc("foo/bar", 0, map("foo", "old")), asList(targetId), emptyList()));
+        updateRemoteEvent(doc("foo/bar", 1, map("foo", "old")), asList(targetId), emptyList()));
     writeMutation(patchMutation("foo/bar", map("foo", "bar")));
     // Release the query so that our target count goes back to 0 and we are considered up-to-date.
     releaseQuery(query);
     writeMutation(setMutation("foo/bah", map("foo", "bah")));
     writeMutation(deleteMutation("foo/baz"));
-    assertContains(doc("foo/bar", 0, map("foo", "bar"), Document.DocumentState.LOCAL_MUTATIONS));
+    assertContains(doc("foo/bar", 1, map("foo", "bar"), Document.DocumentState.LOCAL_MUTATIONS));
     assertContains(doc("foo/bah", 0, map("foo", "bah"), Document.DocumentState.LOCAL_MUTATIONS));
     assertContains(deletedDoc("foo/baz", 0));
 
@@ -784,14 +831,16 @@ public void testPinsDocumentsInTheLocalView() {
     assertContains(doc("foo/bar", 1, map("foo", "bar")));
     assertContains(doc("foo/baz", 0, map("foo", "baz"), Document.DocumentState.LOCAL_MUTATIONS));
 
-    notifyLocalViewChanges(viewChanges(2, asList("foo/bar", "foo/baz"), emptyList()));
+    notifyLocalViewChanges(
+        viewChanges(2, /* fromCache= */ false, asList("foo/bar", "foo/baz"), emptyList()));
     applyRemoteEvent(updateRemoteEvent(doc("foo/bar", 1, map("foo", "bar")), none, two));
     applyRemoteEvent(updateRemoteEvent(doc("foo/baz", 2, map("foo", "baz")), two, none));
     acknowledgeMutation(2);
     assertContains(doc("foo/bar", 1, map("foo", "bar")));
     assertContains(doc("foo/baz", 2, map("foo", "baz")));
 
-    notifyLocalViewChanges(viewChanges(2, emptyList(), asList("foo/bar", "foo/baz")));
+    notifyLocalViewChanges(
+        viewChanges(2, /* fromCache= */ false, emptyList(), asList("foo/bar", "foo/baz")));
     releaseQuery(query);
 
     assertNotContains("foo/bar");
@@ -804,10 +853,13 @@ public void testThrowsAwayDocumentsWithUnknownTargetIDsImmediately() {
       return;
     }
 
-    int targetID = 321;
+    int unknownTargetID = 321;
     applyRemoteEvent(
-        updateRemoteEvent(doc("foo/bar", 1, map()), emptyList(), emptyList(), asList(targetID)));
-
+        updateRemoteEvent(
+            doc("foo/bar", 1, map()),
+            /* updatedInTargets= */ asList(unknownTargetID),
+            /* removedFromTargets= */ emptyList(),
+            /* activeTargets= */ emptyList()));
     assertNotContains("foo/bar");
   }
 
@@ -862,75 +914,58 @@ public void testCanExecuteMixedCollectionQueries() {
         values(docs));
   }
 
+  @Test
+  public void testReadsAllDocumentsForCollectionQueries() {
+    Query query = Query.atPath(ResourcePath.fromString("foo"));
+    allocateQuery(query);
+
+    applyRemoteEvent(updateRemoteEvent(doc("foo/baz", 10, map()), asList(2), emptyList()));
+    applyRemoteEvent(updateRemoteEvent(doc("foo/bar", 20, map()), asList(2), emptyList()));
+    writeMutation(setMutation("foo/bonk", map()));
+
+    resetPersistenceStats();
+
+    localStore.executeQuery(query);
+
+    assertRemoteDocumentsRead(2);
+    assertMutationsRead(1);
+  }
+
   @Test
   public void testPersistsResumeTokens() {
-    // This test only works in the absence of the EagerGarbageCollector.
-    if (garbageCollectorIsEager()) {
-      return;
-    }
+    assumeFalse(garbageCollectorIsEager());
 
     Query query = query("foo/bar");
     int targetId = allocateQuery(query);
-    ByteString resumeToken = resumeToken(1000);
-
-    QueryData queryData = TestUtil.queryData(targetId, QueryPurpose.LISTEN, "foo/bar");
-    TestTargetMetadataProvider testTargetMetadataProvider = new TestTargetMetadataProvider();
-    testTargetMetadataProvider.setSyncedKeys(queryData, DocumentKey.emptyKeySet());
 
-    WatchChangeAggregator aggregator = new WatchChangeAggregator(testTargetMetadataProvider);
-
-    WatchTargetChange watchChange =
-        new WatchTargetChange(WatchTargetChangeType.Current, asList(targetId), resumeToken);
-    aggregator.handleTargetChange(watchChange);
-    RemoteEvent remoteEvent = aggregator.createRemoteEvent(version(1000));
-    applyRemoteEvent(remoteEvent);
+    applyRemoteEvent(noChangeEvent(targetId, 1000));
 
     // Stop listening so that the query should become inactive (but persistent)
     localStore.releaseQuery(query);
 
     // Should come back with the same resume token
     QueryData queryData2 = localStore.allocateQuery(query);
-    assertEquals(resumeToken, queryData2.getResumeToken());
+    assertEquals(resumeToken(1000), queryData2.getResumeToken());
   }
 
   @Test
   public void testDoesNotReplaceResumeTokenWithEmptyByteString() {
-    // This test only works in the absence of the EagerGarbageCollector.
-    if (garbageCollectorIsEager()) {
-      return;
-    }
+    assumeFalse(garbageCollectorIsEager());
 
     Query query = query("foo/bar");
     int targetId = allocateQuery(query);
-    ByteString resumeToken = resumeToken(1000);
-
-    QueryData queryData = TestUtil.queryData(targetId, QueryPurpose.LISTEN, "foo/bar");
-    TestTargetMetadataProvider testTargetMetadataProvider = new TestTargetMetadataProvider();
-    testTargetMetadataProvider.setSyncedKeys(queryData, DocumentKey.emptyKeySet());
 
-    WatchChangeAggregator aggregator1 = new WatchChangeAggregator(testTargetMetadataProvider);
-
-    WatchTargetChange watchChange1 =
-        new WatchTargetChange(WatchTargetChangeType.Current, asList(targetId), resumeToken);
-    aggregator1.handleTargetChange(watchChange1);
-    RemoteEvent remoteEvent1 = aggregator1.createRemoteEvent(version(1000));
-    applyRemoteEvent(remoteEvent1);
+    applyRemoteEvent(noChangeEvent(targetId, 1000));
 
     // New message with empty resume token should not replace the old resume token
-    WatchChangeAggregator aggregator2 = new WatchChangeAggregator(testTargetMetadataProvider);
-    WatchTargetChange watchChange2 =
-        new WatchTargetChange(
-            WatchTargetChangeType.Current, asList(targetId), WatchStream.EMPTY_RESUME_TOKEN);
-    aggregator2.handleTargetChange(watchChange2);
-    RemoteEvent remoteEvent2 = aggregator2.createRemoteEvent(version(2000));
-    applyRemoteEvent(remoteEvent2);
+    applyRemoteEvent(TestUtil.noChangeEvent(targetId, 2000, WatchStream.EMPTY_RESUME_TOKEN));
 
     // Stop listening so that the query should become inactive (but persistent)
     localStore.releaseQuery(query);
 
     // Should come back with the same resume token
     QueryData queryData2 = localStore.allocateQuery(query);
-    assertEquals(resumeToken, queryData2.getResumeToken());
+    assertEquals(resumeToken(1000), queryData2.getResumeToken());
   }
 
   @Test
@@ -970,12 +1005,10 @@ public void testHandlesSetMutationThenTransformMutationThenTransformMutation() {
 
   @Test
   public void testHandlesSetMutationThenAckThenTransformMutationThenAckThenTransformMutation() {
-    if (garbageCollectorIsEager()) {
-      // Since this test doesn't start a listen, Eager GC removes the documents from the cache as
-      // soon as the mutation is applied. This creates a lot of special casing in this unit test but
-      // does not expand its test coverage.
-      return;
-    }
+    // Since this test doesn't start a listen, Eager GC removes the documents from the cache as
+    // soon as the mutation is applied. This creates a lot of special casing in this unit test but
+    // does not expand its test coverage.
+    assumeFalse(garbageCollectorIsEager());
 
     writeMutation(setMutation("foo/bar", map("sum", 0)));
     assertContains(doc("foo/bar", 0, map("sum", 0), Document.DocumentState.LOCAL_MUTATIONS));
@@ -998,6 +1031,181 @@ public void testHandlesSetMutationThenAckThenTransformMutationThenAckThenTransfo
     assertChanged(doc("foo/bar", 2, map("sum", 3), Document.DocumentState.LOCAL_MUTATIONS));
   }
 
+  @Test
+  public void testUsesTargetMappingToExecuteQueries() {
+    assumeFalse(garbageCollectorIsEager());
+    assumeTrue(queryEngine instanceof IndexFreeQueryEngine);
+
+    // This test verifies that once a target mapping has been written, only documents that match
+    // the query are read from the RemoteDocumentCache.
+
+    Query query =
+        Query.atPath(ResourcePath.fromString("foo")).filter(filter("matches", "==", true));
+    int targetId = allocateQuery(query);
+
+    writeMutation(setMutation("foo/a", map("matches", true)));
+    writeMutation(setMutation("foo/b", map("matches", true)));
+    writeMutation(setMutation("foo/ignored", map("matches", false)));
+    acknowledgeMutation(10);
+    acknowledgeMutation(10);
+    acknowledgeMutation(10);
+
+    // Execute the query, but note that we read all existing documents from the RemoteDocumentCache
+    // since we do not yet have target mapping.
+    executeQuery(query);
+    assertRemoteDocumentsRead(3);
+
+    // Issue a RemoteEvent to persist the target mapping.
+    applyRemoteEvent(
+        addedRemoteEvent(
+            asList(doc("foo/a", 10, map("matches", true)), doc("foo/b", 10, map("matches", true))),
+            asList(targetId),
+            emptyList()));
+    applyRemoteEvent(noChangeEvent(targetId, 10));
+    udpateViews(targetId, /* fromCache= */ false);
+
+    // Execute the query again, this time verifying that we only read the two documents that match
+    // the query.
+    executeQuery(query);
+    assertRemoteDocumentsRead(2);
+    assertQueryReturned("foo/a", "foo/b");
+  }
+
+  @Test
+  public void testLastLimboFreeSnapshotIsAdvancedDuringViewProcessing() {
+    // This test verifies that the `lastLimboFreeSnapshot` version for QueryData is advanced when
+    // we compute a limbo-free free view and that the mapping is persisted when we release a query.
+
+    Query query = Query.atPath(ResourcePath.fromString("foo"));
+    int targetId = allocateQuery(query);
+
+    // Advance the query snapshot.
+    applyRemoteEvent(noChangeEvent(targetId, 10));
+
+    // At this point, we have not yet confirmed that the query is limbo free.
+    QueryData cachedQueryData = localStore.getQueryData(query);
+    Assert.assertEquals(SnapshotVersion.NONE, cachedQueryData.getLastLimboFreeSnapshotVersion());
+
+    // Mark the view synced, which updates the last limbo free snapshot version.
+    udpateViews(targetId, /* fromCache=*/ false);
+    cachedQueryData = localStore.getQueryData(query);
+    Assert.assertEquals(version(10), cachedQueryData.getLastLimboFreeSnapshotVersion());
+
+    // The last limbo free snapshot version is persisted even if we release the query.
+    releaseQuery(query);
+
+    if (!garbageCollectorIsEager()) {
+      cachedQueryData = localStore.getQueryData(query);
+      Assert.assertEquals(version(10), cachedQueryData.getLastLimboFreeSnapshotVersion());
+    }
+  }
+
+  @Test
+  public void testQueriesIncludeLocallyModifiedDocuments() {
+    assumeFalse(garbageCollectorIsEager());
+
+    // This test verifies that queries that have a persisted TargetMapping include documents that
+    // were modified by local edits after the target mapping was written.
+    Query query =
+        Query.atPath(ResourcePath.fromString("foo")).filter(filter("matches", "==", true));
+    int targetId = allocateQuery(query);
+
+    applyRemoteEvent(
+        addedRemoteEvent(
+            asList(doc("foo/a", 10, map("matches", true))), asList(targetId), emptyList()));
+    applyRemoteEvent(noChangeEvent(targetId, 10));
+    udpateViews(targetId, /* fromCache= */ false);
+
+    // Execute the query based on the RemoteEvent.
+    executeQuery(query);
+    assertQueryReturned("foo/a");
+
+    // Write a document.
+    writeMutation(setMutation("foo/b", map("matches", true)));
+
+    // Execute the query and make sure that the pending mutation is included in the result.
+    executeQuery(query);
+    assertQueryReturned("foo/a", "foo/b");
+
+    acknowledgeMutation(11);
+
+    // Execute the query and make sure that the acknowledged mutation is included in the result.
+    executeQuery(query);
+    assertQueryReturned("foo/a", "foo/b");
+  }
+
+  @Test
+  public void testQueriesIncludeDocumentsFromOtherQueries() {
+    assumeFalse(garbageCollectorIsEager());
+
+    // This test verifies that queries that have a persisted TargetMapping include documents that
+    // were modified by other queries after the target mapping was written.
+
+    Query filteredQuery =
+        Query.atPath(ResourcePath.fromString("foo")).filter(filter("matches", "==", true));
+    int targetId = allocateQuery(filteredQuery);
+
+    applyRemoteEvent(
+        addedRemoteEvent(
+            asList(doc("foo/a", 10, map("matches", true))), asList(targetId), emptyList()));
+    applyRemoteEvent(noChangeEvent(targetId, 10));
+    udpateViews(targetId, /* fromCache=*/ false);
+    releaseQuery(filteredQuery);
+
+    // Start another query and add more matching documents to the collection.
+    Query fullQuery = Query.atPath(ResourcePath.fromString("foo"));
+    targetId = allocateQuery(fullQuery);
+    applyRemoteEvent(
+        addedRemoteEvent(
+            asList(doc("foo/a", 10, map("matches", true)), doc("foo/b", 20, map("matches", true))),
+            asList(targetId),
+            emptyList()));
+    releaseQuery(fullQuery);
+
+    // Run the original query again and ensure that both the original matches as well as all new
+    // matches are included in the result set.
+    allocateQuery(filteredQuery);
+    executeQuery(filteredQuery);
+    assertQueryReturned("foo/a", "foo/b");
+  }
+
+  @Test
+  public void testQueriesFilterDocumentsThatNoLongerMatch() {
+    assumeFalse(garbageCollectorIsEager());
+
+    // This test verifies that documents that once matched a query are post-filtered if they no
+    // longer match the query filter.
+
+    // Add two document results for a simple filter query
+    Query filteredQuery =
+        Query.atPath(ResourcePath.fromString("foo")).filter(filter("matches", "==", true));
+    int targetId = allocateQuery(filteredQuery);
+
+    applyRemoteEvent(
+        addedRemoteEvent(
+            asList(doc("foo/a", 10, map("matches", true)), doc("foo/b", 10, map("matches", true))),
+            asList(targetId),
+            emptyList()));
+    applyRemoteEvent(noChangeEvent(targetId, 10));
+    udpateViews(targetId, /* fromCache=*/ false);
+    releaseQuery(filteredQuery);
+
+    // Modify one of the documents to no longer match while the filtered query is inactive.
+    Query fullQuery = Query.atPath(ResourcePath.fromString("foo"));
+    targetId = allocateQuery(fullQuery);
+    applyRemoteEvent(
+        addedRemoteEvent(
+            asList(doc("foo/a", 10, map("matches", true)), doc("foo/b", 20, map("matches", false))),
+            asList(targetId),
+            emptyList()));
+    releaseQuery(fullQuery);
+
+    // Re-run the filtered query and verify that the modified document is no longer returned.
+    allocateQuery(filteredQuery);
+    executeQuery(filteredQuery);
+    assertQueryReturned("foo/a");
+  }
+
   @Test
   public void testHandlesSetMutationThenTransformMutationThenRemoteEventThenTransformMutation() {
     Query query = Query.atPath(ResourcePath.fromString("foo"));
@@ -1134,4 +1342,44 @@ public void testHandlesPatchMutationWithTransformThenRemoteEvent() {
     assertChanged(doc("foo/bar", 1, map("sum", 1), Document.DocumentState.LOCAL_MUTATIONS));
     assertContains(doc("foo/bar", 1, map("sum", 1), Document.DocumentState.LOCAL_MUTATIONS));
   }
+
+  @Test
+  public void testGetHighestUnacknowledgedBatchId() {
+    assertEquals(MutationBatch.UNKNOWN, localStore.getHighestUnacknowledgedBatchId());
+
+    writeMutation(setMutation("foo/bar", map("abc", 123)));
+    assertEquals(1, localStore.getHighestUnacknowledgedBatchId());
+
+    writeMutation(patchMutation("foo/bar", map("abc", 321)));
+    assertEquals(2, localStore.getHighestUnacknowledgedBatchId());
+
+    acknowledgeMutation(1);
+    assertEquals(2, localStore.getHighestUnacknowledgedBatchId());
+
+    rejectMutation();
+    assertEquals(MutationBatch.UNKNOWN, localStore.getHighestUnacknowledgedBatchId());
+  }
+
+  @Test
+  public void testOnlyPersistsUpdatesForDocumentsWhenVersionChanges() {
+    Query query = Query.atPath(ResourcePath.fromString("foo"));
+    allocateQuery(query);
+    assertTargetId(2);
+
+    applyRemoteEvent(
+        addedRemoteEvent(doc("foo/bar", 1, map("val", "old")), asList(2), emptyList()));
+    assertChanged(doc("foo/bar", 1, map("val", "old"), Document.DocumentState.SYNCED));
+    assertContains(doc("foo/bar", 1, map("val", "old"), Document.DocumentState.SYNCED));
+
+    applyRemoteEvent(
+        addedRemoteEvent(
+            asList(doc("foo/bar", 1, map("val", "new")), doc("foo/baz", 2, map("val", "new"))),
+            asList(2),
+            emptyList()));
+
+    assertChanged(doc("foo/baz", 2, map("val", "new"), Document.DocumentState.SYNCED));
+    // The update for foo/bar is ignored.
+    assertContains(doc("foo/bar", 1, map("val", "old"), Document.DocumentState.SYNCED));
+    assertContains(doc("foo/baz", 2, map("val", "new"), Document.DocumentState.SYNCED));
+  }
 }
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LruGarbageCollectorTestCase.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LruGarbageCollectorTestCase.java
index 63889dfb6..50522e31e 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LruGarbageCollectorTestCase.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LruGarbageCollectorTestCase.java
@@ -109,8 +109,9 @@ private void updateTargetInTransaction(QueryData queryData) {
     SnapshotVersion version = version(2);
     ByteString resumeToken = resumeToken(2);
     QueryData updated =
-        queryData.copy(
-            version, resumeToken, persistence.getReferenceDelegate().getCurrentSequenceNumber());
+        queryData
+            .withResumeToken(resumeToken, version)
+            .withSequenceNumber(persistence.getReferenceDelegate().getCurrentSequenceNumber());
     queryCache.updateQueryData(updated);
   }
 
@@ -139,7 +140,7 @@ private Document nextTestDocument() {
 
   private Document cacheADocumentInTransaction() {
     Document doc = nextTestDocument();
-    documentCache.add(doc);
+    documentCache.add(doc, doc.getVersion());
     return doc;
   }
 
@@ -553,8 +554,8 @@ public void testRemoveTargetsThenGC() {
         () -> {
           SnapshotVersion newVersion = version(3);
           Document doc =
-              new Document(middleDocToUpdate, newVersion, testValue, Document.DocumentState.SYNCED);
-          documentCache.add(doc);
+              new Document(middleDocToUpdate, newVersion, Document.DocumentState.SYNCED, testValue);
+          documentCache.add(doc, newVersion);
           updateTargetInTransaction(middleTarget);
         });
 
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/MemoryLocalStoreTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/MemoryLocalStoreTest.java
index 9d18d4480..4b9b05664 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/MemoryLocalStoreTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/MemoryLocalStoreTest.java
@@ -14,17 +14,36 @@
 
 package com.google.firebase.firestore.local;
 
+import java.util.Arrays;
+import java.util.Collection;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
+import org.robolectric.ParameterizedRobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(ParameterizedRobolectricTestRunner.class)
 @Config(manifest = Config.NONE)
 public class MemoryLocalStoreTest extends LocalStoreTestCase {
 
+  private QueryEngine queryEngine;
+
+  @ParameterizedRobolectricTestRunner.Parameters(name = "QueryEngine = {0}")
+  public static Collection<Object[]> data() {
+    return Arrays.asList(
+        new Object[] {new SimpleQueryEngine()}, new Object[] {new IndexFreeQueryEngine()});
+  }
+
+  public MemoryLocalStoreTest(QueryEngine queryEngine) {
+    this.queryEngine = queryEngine;
+  }
+
   @Override
   Persistence getPersistence() {
-    return PersistenceTestHelpers.createEagerGCMemoryPersistence();
+    return PersistenceTestHelpers.createEagerGCMemoryPersistence(statsCollector);
+  }
+
+  @Override
+  QueryEngine getQueryEngine() {
+    return this.queryEngine;
   }
 
   @Override
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/PersistenceTestHelpers.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/PersistenceTestHelpers.java
index f81693766..058dc25ee 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/PersistenceTestHelpers.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/PersistenceTestHelpers.java
@@ -15,34 +15,23 @@
 package com.google.firebase.firestore.local;
 
 import android.content.Context;
+import androidx.test.core.app.ApplicationProvider;
 import com.google.firebase.firestore.model.DatabaseId;
 import com.google.firebase.firestore.remote.RemoteSerializer;
-import org.robolectric.RuntimeEnvironment;
 
 public final class PersistenceTestHelpers {
 
   /** A counter for generating unique database names. */
   private static int databaseNameCounter = 0;
 
-  public static SQLitePersistence openSQLitePersistence(String name) {
-    return openSQLitePersistence(name, LruGarbageCollector.Params.Default());
-  }
-
-  public static SQLitePersistence openSQLitePersistence(
-      String name, LruGarbageCollector.Params params) {
-    DatabaseId databaseId = DatabaseId.forProject("projectId");
-    LocalSerializer serializer = new LocalSerializer(new RemoteSerializer(databaseId));
-    Context context = RuntimeEnvironment.application;
-    SQLitePersistence persistence =
-        new SQLitePersistence(context, name, databaseId, serializer, params);
-    persistence.start();
-    return persistence;
-  }
-
   public static String nextSQLiteDatabaseName() {
     return "test-" + databaseNameCounter++;
   }
 
+  public static SQLitePersistence createSQLitePersistence(String name) {
+    return openSQLitePersistence(
+        name, StatsCollector.NO_OP_STATS_COLLECTOR, LruGarbageCollector.Params.Default());
+  }
   /**
    * Creates and starts a new SQLitePersistence instance for testing.
    *
@@ -52,16 +41,30 @@ public static SQLitePersistence createSQLitePersistence() {
     return createSQLitePersistence(LruGarbageCollector.Params.Default());
   }
 
+  public static SQLitePersistence createSQLitePersistence(StatsCollector statsCollector) {
+    return openSQLitePersistence(
+        nextSQLiteDatabaseName(), statsCollector, LruGarbageCollector.Params.Default());
+  }
+
   public static SQLitePersistence createSQLitePersistence(LruGarbageCollector.Params params) {
     // Robolectric's test runner will clear out the application database directory in between test
     // cases, but sometimes (particularly the spec tests) we create multiple databases per test
     // case and each should be fresh. A unique name is sufficient to keep these separate.
-    return openSQLitePersistence(nextSQLiteDatabaseName(), params);
+    return openSQLitePersistence(
+        nextSQLiteDatabaseName(), StatsCollector.NO_OP_STATS_COLLECTOR, params);
   }
 
   /** Creates and starts a new MemoryPersistence instance for testing. */
   public static MemoryPersistence createEagerGCMemoryPersistence() {
-    MemoryPersistence persistence = MemoryPersistence.createEagerGcMemoryPersistence();
+    MemoryPersistence persistence =
+        MemoryPersistence.createEagerGcMemoryPersistence(StatsCollector.NO_OP_STATS_COLLECTOR);
+    persistence.start();
+    return persistence;
+  }
+
+  public static MemoryPersistence createEagerGCMemoryPersistence(StatsCollector statsCollector) {
+    MemoryPersistence persistence =
+        MemoryPersistence.createEagerGcMemoryPersistence(statsCollector);
     persistence.start();
     return persistence;
   }
@@ -74,7 +77,19 @@ public static MemoryPersistence createLRUMemoryPersistence(LruGarbageCollector.P
     DatabaseId databaseId = DatabaseId.forProject("projectId");
     LocalSerializer serializer = new LocalSerializer(new RemoteSerializer(databaseId));
     MemoryPersistence persistence =
-        MemoryPersistence.createLruGcMemoryPersistence(params, serializer);
+        MemoryPersistence.createLruGcMemoryPersistence(
+            params, StatsCollector.NO_OP_STATS_COLLECTOR, serializer);
+    persistence.start();
+    return persistence;
+  }
+
+  private static SQLitePersistence openSQLitePersistence(
+      String name, StatsCollector statsCollector, LruGarbageCollector.Params params) {
+    DatabaseId databaseId = DatabaseId.forProject("projectId");
+    LocalSerializer serializer = new LocalSerializer(new RemoteSerializer(databaseId));
+    Context context = ApplicationProvider.getApplicationContext();
+    SQLitePersistence persistence =
+        new SQLitePersistence(context, name, databaseId, serializer, statsCollector, params);
     persistence.start();
     return persistence;
   }
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/QueryCacheTestCase.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/QueryCacheTestCase.java
index f5d95486a..ba7cd12f9 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/QueryCacheTestCase.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/QueryCacheTestCase.java
@@ -329,6 +329,7 @@ private QueryData newQueryData(Query query, int targetId, long version) {
         sequenceNumber,
         QueryPurpose.LISTEN,
         version(version),
+        version(version),
         resumeToken(version));
   }
 
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/RemoteDocumentCacheTestCase.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/RemoteDocumentCacheTestCase.java
index 5b575dfaa..91e8407a8 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/RemoteDocumentCacheTestCase.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/RemoteDocumentCacheTestCase.java
@@ -21,6 +21,7 @@
 import static com.google.firebase.firestore.testutil.TestUtil.map;
 import static com.google.firebase.firestore.testutil.TestUtil.path;
 import static com.google.firebase.firestore.testutil.TestUtil.values;
+import static com.google.firebase.firestore.testutil.TestUtil.version;
 import static java.util.Arrays.asList;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
@@ -32,6 +33,7 @@
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.MaybeDocument;
 import com.google.firebase.firestore.model.NoDocument;
+import com.google.firebase.firestore.model.SnapshotVersion;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
@@ -134,7 +136,7 @@ public void testSetAndReadLotsOfDocuments() {
   public void testSetAndReadDeletedDocument() {
     String path = "a/b";
     NoDocument deletedDoc = deletedDoc(path, 42);
-    add(deletedDoc);
+    add(deletedDoc, version(42));
     assertEquals(deletedDoc, get(path));
   }
 
@@ -144,7 +146,7 @@ public void testSetDocumentToNewValue() {
     Document written = addTestDocumentAtPath(path);
 
     Document newDoc = doc(path, 57, map("data", 5));
-    add(newDoc);
+    add(newDoc, version(57));
 
     assertNotEquals(written, newDoc);
     assertEquals(newDoc, get(path));
@@ -175,19 +177,50 @@ public void testDocumentsMatchingQuery() {
 
     Query query = Query.atPath(path("b"));
     ImmutableSortedMap<DocumentKey, Document> results =
-        remoteDocumentCache.getAllDocumentsMatchingQuery(query);
+        remoteDocumentCache.getAllDocumentsMatchingQuery(query, SnapshotVersion.NONE);
     List<Document> expected = asList(doc("b/1", 42, docData), doc("b/2", 42, docData));
     assertEquals(expected, values(results));
   }
 
+  @Test
+  public void testDocumentsMatchingQuerySinceReadTime() {
+    Map<String, Object> docData = map("data", 2);
+    addTestDocumentAtPath("b/old", /* updateTime= */ 1, /* readTime= */ 11);
+    addTestDocumentAtPath("b/current", /* updateTime= */ 2, /*  readTime= = */ 12);
+    addTestDocumentAtPath("b/new", /* updateTime= */ 3, /*  readTime= = */ 13);
+
+    Query query = Query.atPath(path("b"));
+    ImmutableSortedMap<DocumentKey, Document> results =
+        remoteDocumentCache.getAllDocumentsMatchingQuery(query, version(12));
+    List<Document> expected = asList(doc("b/new", 3, docData));
+    assertEquals(expected, values(results));
+  }
+
+  @Test
+  public void testDocumentsMatchingUsesReadTimeNotUpdateTime() {
+    Map<String, Object> docData = map("data", 2);
+    addTestDocumentAtPath("b/old", /* updateTime= */ 1, /* readTime= */ 2);
+    addTestDocumentAtPath("b/new", /* updateTime= */ 2, /* readTime= */ 1);
+
+    Query query = Query.atPath(path("b"));
+    ImmutableSortedMap<DocumentKey, Document> results =
+        remoteDocumentCache.getAllDocumentsMatchingQuery(query, version(1));
+    List<Document> expected = asList(doc("b/old", 1, docData));
+    assertEquals(expected, values(results));
+  }
+
   private Document addTestDocumentAtPath(String path) {
-    Document doc = doc(path, 42, map("data", 2));
-    add(doc);
+    return addTestDocumentAtPath(path, 42, 42);
+  }
+
+  private Document addTestDocumentAtPath(String path, int updateTime, int readTime) {
+    Document doc = doc(path, updateTime, map("data", 2));
+    add(doc, version(readTime));
     return doc;
   }
 
-  private void add(MaybeDocument doc) {
-    persistence.runTransaction("add entry", () -> remoteDocumentCache.add(doc));
+  private void add(MaybeDocument doc, SnapshotVersion readTime) {
+    persistence.runTransaction("add entry", () -> remoteDocumentCache.add(doc, readTime));
   }
 
   @Nullable
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteLocalStoreTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteLocalStoreTest.java
index fe528cbfc..9f66aa726 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteLocalStoreTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteLocalStoreTest.java
@@ -14,17 +14,36 @@
 
 package com.google.firebase.firestore.local;
 
+import java.util.Arrays;
+import java.util.Collection;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
+import org.robolectric.ParameterizedRobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(ParameterizedRobolectricTestRunner.class)
 @Config(manifest = Config.NONE)
 public class SQLiteLocalStoreTest extends LocalStoreTestCase {
 
+  private QueryEngine queryEngine;
+
+  @ParameterizedRobolectricTestRunner.Parameters(name = "QueryEngine = {0}")
+  public static Collection<Object[]> data() {
+    return Arrays.asList(
+        new Object[] {new SimpleQueryEngine()}, new Object[] {new IndexFreeQueryEngine()});
+  }
+
+  public SQLiteLocalStoreTest(QueryEngine queryEngine) {
+    this.queryEngine = queryEngine;
+  }
+
+  @Override
+  QueryEngine getQueryEngine() {
+    return this.queryEngine;
+  }
+
   @Override
   Persistence getPersistence() {
-    return PersistenceTestHelpers.createSQLitePersistence();
+    return PersistenceTestHelpers.createSQLitePersistence(statsCollector);
   }
 
   @Override
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteQueryCacheTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteQueryCacheTest.java
index c7b77a42e..5d41a71fc 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteQueryCacheTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteQueryCacheTest.java
@@ -39,7 +39,7 @@ Persistence getPersistence() {
   public void testMetadataPersistedAcrossRestarts() {
     String name = "test-queryCache-restarts";
 
-    SQLitePersistence db1 = PersistenceTestHelpers.openSQLitePersistence(name);
+    SQLitePersistence db1 = PersistenceTestHelpers.createSQLitePersistence(name);
     QueryCache queryCache1 = db1.getQueryCache();
     assertEquals(0, queryCache1.getHighestListenSequenceNumber());
 
@@ -59,7 +59,7 @@ public void testMetadataPersistedAcrossRestarts() {
 
     db1.shutdown();
 
-    SQLitePersistence db2 = PersistenceTestHelpers.openSQLitePersistence(name);
+    SQLitePersistence db2 = PersistenceTestHelpers.createSQLitePersistence(name);
     db2.runTransaction(
         "verify sequence number",
         () -> {
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteSchemaTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteSchemaTest.java
index 440b83e8f..495bb6f71 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteSchemaTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteSchemaTest.java
@@ -16,8 +16,12 @@
 
 import static com.google.firebase.firestore.local.EncodedPath.decodeResourcePath;
 import static com.google.firebase.firestore.local.EncodedPath.encode;
+import static com.google.firebase.firestore.testutil.TestUtil.key;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
 import static com.google.firebase.firestore.testutil.TestUtil.path;
+import static com.google.firebase.firestore.testutil.TestUtil.query;
+import static com.google.firebase.firestore.testutil.TestUtil.version;
+import static com.google.firebase.firestore.util.Assert.fail;
 import static java.util.Arrays.asList;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -27,11 +31,19 @@
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
+import androidx.test.core.app.ApplicationProvider;
+import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.firestore.model.DatabaseId;
+import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.ResourcePath;
+import com.google.firebase.firestore.proto.MaybeDocument;
+import com.google.firebase.firestore.proto.Target;
 import com.google.firebase.firestore.proto.WriteBatch;
+import com.google.firebase.firestore.remote.RemoteSerializer;
 import com.google.firestore.v1.Document;
 import com.google.firestore.v1.Write;
+import com.google.protobuf.InvalidProtocolBufferException;
+import com.google.protobuf.Timestamp;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -43,7 +55,6 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 /** Tests migrations in SQLiteSchema. */
@@ -55,11 +66,12 @@
 
   private SQLiteDatabase db;
   private SQLiteSchema schema;
+  private SQLiteOpenHelper opener;
 
   @Before
   public void setUp() {
-    SQLiteOpenHelper opener =
-        new SQLiteOpenHelper(RuntimeEnvironment.application, "foo", null, 1) {
+    opener =
+        new SQLiteOpenHelper(ApplicationProvider.getApplicationContext(), "foo", null, 1) {
           @Override
           public void onCreate(SQLiteDatabase db) {}
 
@@ -394,6 +406,142 @@ public void canCreateCollectionParentsIndex() {
     assertEquals(expectedParents, actualParents);
   }
 
+  @Test
+  public void existingDocumentsRemainReadableAfterIndexFreeMigration() {
+    // Initialize the schema to the state prior to the index-free migration.
+    schema.runMigrations(0, 8);
+    db.execSQL(
+        "INSERT INTO remote_documents (path, contents) VALUES (?, ?)",
+        new Object[] {encode(path("coll/existing")), createDummyDocument("coll/existing")});
+
+    // Run the index-free migration.
+    schema.runMigrations(8, 9);
+    db.execSQL(
+        "INSERT INTO remote_documents (path, read_time_seconds, read_time_nanos, contents) VALUES (?, ?, ?, ?)",
+        new Object[] {encode(path("coll/old")), 0, 1000, createDummyDocument("coll/old")});
+    db.execSQL(
+        "INSERT INTO remote_documents (path, read_time_seconds, read_time_nanos, contents) VALUES (?, ?, ?, ?)",
+        new Object[] {encode(path("coll/current")), 0, 2000, createDummyDocument("coll/current")});
+    db.execSQL(
+        "INSERT INTO remote_documents (path, read_time_seconds, read_time_nanos, contents) VALUES (?, ?, ?, ?)",
+        new Object[] {encode(path("coll/new")), 0, 3000, createDummyDocument("coll/new")});
+
+    SQLiteRemoteDocumentCache remoteDocumentCache = createRemoteDocumentCache();
+
+    // Verify that queries with SnapshotVersion.NONE return all results, regardless of whether the
+    // read time has been set.
+    ImmutableSortedMap<DocumentKey, com.google.firebase.firestore.model.Document> results =
+        remoteDocumentCache.getAllDocumentsMatchingQuery(query("coll"), version(0));
+    assertResultsContain(results, "coll/existing", "coll/old", "coll/current", "coll/new");
+
+    // Queries that filter by read time only return documents that were written after the index-free
+    // migration.
+    results = remoteDocumentCache.getAllDocumentsMatchingQuery(query("coll"), version(2));
+    assertResultsContain(results, "coll/new");
+  }
+
+  @Test
+  public void dropsLastLimboFreeSnapshotIfPreviouslyDowngraded() {
+    schema.runMigrations(0, 9);
+
+    db.execSQL(
+        "INSERT INTO targets (target_id, canonical_id, target_proto) VALUES (?,?, ?)",
+        new Object[] {1, "foo", createDummyQueryTargetWithLimboFreeVersion(1).toByteArray()});
+    db.execSQL(
+        "INSERT INTO targets (target_id, canonical_id, target_proto) VALUES (?, ?, ?)",
+        new Object[] {2, "bar", createDummyQueryTargetWithLimboFreeVersion(2).toByteArray()});
+    db.execSQL(
+        "INSERT INTO targets (target_id, canonical_id, target_proto) VALUES (?,?, ?)",
+        new Object[] {3, "baz", createDummyQueryTargetWithLimboFreeVersion(3).toByteArray()});
+
+    schema.runMigrations(0, 8);
+    schema.runMigrations(8, 9);
+
+    int rowCount =
+        new SQLitePersistence.Query(db, "SELECT target_id, target_proto FROM targets")
+            .forEach(
+                cursor -> {
+                  int targetId = cursor.getInt(0);
+                  byte[] targetProtoBytes = cursor.getBlob(1);
+
+                  try {
+                    Target targetProto = Target.parseFrom(targetProtoBytes);
+                    assertEquals(targetId, targetProto.getTargetId());
+                    assertFalse(targetProto.hasLastLimboFreeSnapshotVersion());
+                  } catch (InvalidProtocolBufferException e) {
+                    fail("Failed to decode Query data");
+                  }
+                });
+
+    assertEquals(3, rowCount);
+  }
+
+  @Test
+  public void keepsLastLimboFreeSnapshotIfNotDowngraded() {
+    schema.runMigrations(0, 9);
+
+    db.execSQL(
+        "INSERT INTO targets (target_id, canonical_id, target_proto) VALUES (?,?, ?)",
+        new Object[] {1, "foo", createDummyQueryTargetWithLimboFreeVersion(1).toByteArray()});
+
+    // Make sure that we don't drop the lastLimboFreeSnapshotVersion if we are already on schema
+    // version 9.
+    schema.runMigrations(9, 9);
+
+    new SQLitePersistence.Query(db, "SELECT target_proto FROM targets")
+        .forEach(
+            cursor -> {
+              byte[] targetProtoBytes = cursor.getBlob(0);
+
+              try {
+                Target targetProto = Target.parseFrom(targetProtoBytes);
+                assertTrue(targetProto.hasLastLimboFreeSnapshotVersion());
+              } catch (InvalidProtocolBufferException e) {
+                fail("Failed to decode Query data");
+              }
+            });
+  }
+
+  private SQLiteRemoteDocumentCache createRemoteDocumentCache() {
+    DatabaseId databaseId = DatabaseId.forProject("foo");
+    LocalSerializer serializer = new LocalSerializer(new RemoteSerializer(databaseId));
+    SQLitePersistence persistence =
+        new SQLitePersistence(
+            serializer,
+            StatsCollector.NO_OP_STATS_COLLECTOR,
+            LruGarbageCollector.Params.Default(),
+            opener);
+    persistence.start();
+    return new SQLiteRemoteDocumentCache(
+        persistence, serializer, StatsCollector.NO_OP_STATS_COLLECTOR);
+  }
+
+  private byte[] createDummyDocument(String name) {
+    return MaybeDocument.newBuilder()
+        .setDocument(
+            Document.newBuilder()
+                .setName("projects/foo/databases/(default)/documents/" + name)
+                .build())
+        .build()
+        .toByteArray();
+  }
+
+  private Target createDummyQueryTargetWithLimboFreeVersion(int targetId) {
+    return Target.newBuilder()
+        .setTargetId(targetId)
+        .setLastLimboFreeSnapshotVersion(Timestamp.newBuilder().setSeconds(42))
+        .build();
+  }
+
+  private void assertResultsContain(
+      ImmutableSortedMap<DocumentKey, com.google.firebase.firestore.model.Document> actualResults,
+      String... docs) {
+    for (String doc : docs) {
+      assertTrue("Expected result for " + doc, actualResults.containsKey(key(doc)));
+    }
+    assertEquals("Results contain unexpected entries", docs.length, actualResults.size());
+  }
+
   private void assertNoResultsForQuery(String query, String[] args) {
     Cursor cursor = null;
     try {
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/model/DocumentTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/model/DocumentTest.java
index fbfbb9b3c..f0bdb4891 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/model/DocumentTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/model/DocumentTest.java
@@ -36,10 +36,10 @@
 public class DocumentTest {
 
   @Test
-  public void testConstructor() {
+  public void testInstantiation() {
     Document document =
         new Document(
-            key("messages/first"), version(1), wrapObject("a", 1), Document.DocumentState.SYNCED);
+            key("messages/first"), version(1), Document.DocumentState.SYNCED, wrapObject("a", 1));
 
     assertEquals(key("messages/first"), document.getKey());
     assertEquals(version(1), document.getVersion());
@@ -56,7 +56,7 @@ public void testExtractFields() {
             "owner",
             map("name", "Jonny", "title", "scallywag"));
     Document document =
-        new Document(key("rooms/eros"), version(1), data, Document.DocumentState.SYNCED);
+        new Document(key("rooms/eros"), version(1), Document.DocumentState.SYNCED, data);
 
     assertEquals("Discuss all the project related stuff", document.getFieldValue(field("desc")));
     assertEquals("scallywag", document.getFieldValue(field("owner.title")));
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/model/FieldValueTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/model/FieldValueTest.java
index a251c78ee..d87b27044 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/model/FieldValueTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/model/FieldValueTest.java
@@ -17,6 +17,7 @@
 import static com.google.firebase.firestore.testutil.TestUtil.blob;
 import static com.google.firebase.firestore.testutil.TestUtil.dbId;
 import static com.google.firebase.firestore.testutil.TestUtil.field;
+import static com.google.firebase.firestore.testutil.TestUtil.fieldMask;
 import static com.google.firebase.firestore.testutil.TestUtil.key;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
 import static com.google.firebase.firestore.testutil.TestUtil.ref;
@@ -30,6 +31,7 @@
 import com.google.common.testing.EqualsTester;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.GeoPoint;
+import com.google.firebase.firestore.model.mutation.FieldMask;
 import com.google.firebase.firestore.model.value.BlobValue;
 import com.google.firebase.firestore.model.value.BooleanValue;
 import com.google.firebase.firestore.model.value.DoubleValue;
@@ -85,6 +87,21 @@ public void testExtractsFields() {
     assertNull(obj.get(field("bar.a")));
   }
 
+  @Test
+  public void testExtractsFieldMask() {
+    FieldValue val =
+        wrapObject(
+            "a",
+            "b",
+            "map",
+            map("a", 1, "b", true, "c", "string", "nested", map("d", "e")),
+            "emptymap",
+            map());
+    assertTrue(val instanceof ObjectValue);
+    FieldMask mask = ((ObjectValue) val).getFieldMask();
+    assertEquals(fieldMask("a", "map.a", "map.b", "map.c", "map.nested.d", "emptymap"), mask);
+  }
+
   @Test
   public void testOverwritesExistingFields() {
     ObjectValue old = wrapObject("a", "old");
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/model/MutationTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/model/MutationTest.java
index 03733eed4..3e4ea899d 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/model/MutationTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/model/MutationTest.java
@@ -30,6 +30,7 @@
 import static com.google.firebase.firestore.testutil.TestUtil.wrap;
 import static com.google.firebase.firestore.testutil.TestUtil.wrapObject;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.FieldValue;
@@ -48,6 +49,7 @@
 import com.google.firebase.firestore.model.value.TimestampValue;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import org.junit.Test;
@@ -164,8 +166,8 @@ public void testAppliesLocalServerTimestampTransformsToDocuments() {
         new Document(
             key("collection/key"),
             version(0),
-            expectedData,
-            Document.DocumentState.LOCAL_MUTATIONS);
+            Document.DocumentState.LOCAL_MUTATIONS,
+            expectedData);
     assertEquals(expectedDoc, transformedDoc);
   }
 
@@ -621,4 +623,89 @@ public void testTransitions() {
     assertVersionTransitions(delete, deletedV3, mutationResult, docV7Deleted);
     assertVersionTransitions(delete, null, mutationResult, docV7Deleted);
   }
+
+  @Test
+  public void testNonTransformMutationBaseValue() {
+    Map<String, Object> data = map("foo", "foo");
+    Document baseDoc = doc("collection/key", 0, data);
+
+    Mutation set = setMutation("collection/key", map("foo", "bar"));
+    assertNull(set.extractBaseValue(baseDoc));
+
+    Mutation patch = patchMutation("collection/key", map("foo", "bar"));
+    assertNull(patch.extractBaseValue(baseDoc));
+
+    Mutation delete = deleteMutation("collection/key");
+    assertNull(delete.extractBaseValue(baseDoc));
+  }
+
+  @Test
+  public void testServerTimestampBaseValue() {
+    Map<String, Object> allValues = map("time", "foo");
+    allValues.put("nested", new HashMap<>(allValues));
+    Document baseDoc = doc("collection/key", 0, allValues);
+
+    Map<String, Object> allTransforms = map("time", FieldValue.serverTimestamp());
+    allTransforms.put("nested", new HashMap<>(allTransforms));
+
+    // Server timestamps are idempotent and don't have base values.
+    Mutation transformMutation = transformMutation("collection/key", allTransforms);
+    assertNull(transformMutation.extractBaseValue(baseDoc));
+  }
+
+  @Test
+  public void testNumericIncrementBaseValue() {
+    Map<String, Object> allValues =
+        map("ignore", "foo", "double", 42.0, "long", 42, "string", "foo", "map", map());
+    allValues.put("nested", new HashMap<>(allValues));
+    Document baseDoc = doc("collection/key", 0, allValues);
+
+    Map<String, Object> allTransforms =
+        map(
+            "double",
+            FieldValue.increment(1),
+            "long",
+            FieldValue.increment(1),
+            "string",
+            FieldValue.increment(1),
+            "map",
+            FieldValue.increment(1),
+            "missing",
+            FieldValue.increment(1));
+    allTransforms.put("nested", new HashMap<>(allTransforms));
+
+    Mutation transformMutation = transformMutation("collection/key", allTransforms);
+    ObjectValue baseValue = transformMutation.extractBaseValue(baseDoc);
+
+    com.google.firebase.firestore.model.value.FieldValue expected =
+        wrap(
+            map(
+                "double",
+                42.0,
+                "long",
+                42,
+                "string",
+                0,
+                "map",
+                0,
+                "missing",
+                0,
+                "nested",
+                map("double", 42.0, "long", 42, "string", 0, "map", 0, "missing", 0)));
+    assertEquals(expected, baseValue);
+  }
+
+  @Test
+  public void testIncrementTwice() {
+    Document baseDoc = doc("collection/key", 0, map("sum", "0"));
+
+    Map<String, Object> increment = map("sum", FieldValue.increment(1));
+    Mutation transformMutation = transformMutation("collection/key", increment);
+
+    MaybeDocument mutatedDoc =
+        transformMutation.applyToLocalView(baseDoc, baseDoc, Timestamp.now());
+    mutatedDoc = transformMutation.applyToLocalView(mutatedDoc, baseDoc, Timestamp.now());
+
+    assertEquals(wrap(2L), ((Document) mutatedDoc).getField(field("sum")));
+  }
 }
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/remote/MockDatastore.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/remote/MockDatastore.java
index 84911d286..b13b8b89d 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/remote/MockDatastore.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/remote/MockDatastore.java
@@ -90,8 +90,7 @@ public void watchQuery(QueryData queryData) {
               + ")");
       // Snapshot version is ignored on the wire
       QueryData sentQueryData =
-          queryData.copy(
-              SnapshotVersion.NONE, queryData.getResumeToken(), queryData.getSequenceNumber());
+          queryData.withResumeToken(queryData.getResumeToken(), SnapshotVersion.NONE);
       watchStreamRequestCount += 1;
       this.activeTargets.put(queryData.getTargetId(), sentQueryData);
     }
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/remote/RemoteEventTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/remote/RemoteEventTest.java
index 7611a252b..8a41d83b9 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/remote/RemoteEventTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/remote/RemoteEventTest.java
@@ -32,7 +32,6 @@
 import static org.junit.Assert.fail;
 
 import com.google.firebase.database.collection.ImmutableSortedSet;
-import com.google.firebase.firestore.TestUtil.TestTargetMetadataProvider;
 import com.google.firebase.firestore.local.QueryData;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentKey;
@@ -40,6 +39,7 @@
 import com.google.firebase.firestore.remote.WatchChange.DocumentChange;
 import com.google.firebase.firestore.remote.WatchChange.WatchTargetChange;
 import com.google.firebase.firestore.remote.WatchChange.WatchTargetChangeType;
+import com.google.firebase.firestore.testutil.TestTargetMetadataProvider;
 import com.google.protobuf.ByteString;
 import java.util.ArrayList;
 import java.util.Collections;
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/remote/RemoteSerializerTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/remote/RemoteSerializerTest.java
index e2c1b1b7d..dbb6b5437 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/remote/RemoteSerializerTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/remote/RemoteSerializerTest.java
@@ -31,10 +31,15 @@
 import static java.util.Arrays.asList;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 
 import com.google.firebase.firestore.DocumentReference;
 import com.google.firebase.firestore.GeoPoint;
+import com.google.firebase.firestore.core.ArrayContainsAnyFilter;
 import com.google.firebase.firestore.core.Bound;
+import com.google.firebase.firestore.core.FieldFilter;
+import com.google.firebase.firestore.core.InFilter;
+import com.google.firebase.firestore.core.KeyFieldFilter;
 import com.google.firebase.firestore.core.Query;
 import com.google.firebase.firestore.local.QueryData;
 import com.google.firebase.firestore.local.QueryPurpose;
@@ -64,7 +69,6 @@
 import com.google.firestore.v1.StructuredQuery.CollectionSelector;
 import com.google.firestore.v1.StructuredQuery.CompositeFilter;
 import com.google.firestore.v1.StructuredQuery.Direction;
-import com.google.firestore.v1.StructuredQuery.FieldFilter;
 import com.google.firestore.v1.StructuredQuery.FieldFilter.Operator;
 import com.google.firestore.v1.StructuredQuery.FieldReference;
 import com.google.firestore.v1.StructuredQuery.Filter;
@@ -464,15 +468,7 @@ public void testEncodesListenRequestLabels() {
   @Test
   public void testEncodesFirstLevelKeyQueries() {
     Query q = Query.atPath(ResourcePath.fromString("docs/1"));
-    Target actual =
-        serializer.encodeTarget(
-            new QueryData(
-                q,
-                1,
-                2,
-                QueryPurpose.LISTEN,
-                SnapshotVersion.NONE,
-                WatchStream.EMPTY_RESUME_TOKEN));
+    Target actual = serializer.encodeTarget(new QueryData(q, 1, 2, QueryPurpose.LISTEN));
 
     DocumentsTarget.Builder docs =
         DocumentsTarget.newBuilder().addDocuments("projects/p/databases/d/documents/docs/1");
@@ -547,7 +543,7 @@ public void testEncodesSingleFilterAtFirstLevelCollections() {
             .setWhere(
                 Filter.newBuilder()
                     .setFieldFilter(
-                        FieldFilter.newBuilder()
+                        StructuredQuery.FieldFilter.newBuilder()
                             .setField(FieldReference.newBuilder().setFieldPath("prop"))
                             .setOp(Operator.LESS_THAN)
                             .setValue(valueBuilder().setIntegerValue(42))))
@@ -591,7 +587,7 @@ public void testEncodesMultipleFiltersOnDeeperCollections() {
                             .addFilters(
                                 Filter.newBuilder()
                                     .setFieldFilter(
-                                        FieldFilter.newBuilder()
+                                        StructuredQuery.FieldFilter.newBuilder()
                                             .setField(
                                                 FieldReference.newBuilder().setFieldPath("prop"))
                                             .setOp(Operator.LESS_THAN)
@@ -599,7 +595,7 @@ public void testEncodesMultipleFiltersOnDeeperCollections() {
                             .addFilters(
                                 Filter.newBuilder()
                                     .setFieldFilter(
-                                        FieldFilter.newBuilder()
+                                        StructuredQuery.FieldFilter.newBuilder()
                                             .setField(
                                                 FieldReference.newBuilder().setFieldPath("author"))
                                             .setOp(Operator.EQUAL)
@@ -607,7 +603,7 @@ public void testEncodesMultipleFiltersOnDeeperCollections() {
                             .addFilters(
                                 Filter.newBuilder()
                                     .setFieldFilter(
-                                        FieldFilter.newBuilder()
+                                        StructuredQuery.FieldFilter.newBuilder()
                                             .setField(
                                                 FieldReference.newBuilder().setFieldPath("tags"))
                                             .setOp(Operator.ARRAY_CONTAINS)
@@ -632,10 +628,79 @@ public void testEncodesMultipleFiltersOnDeeperCollections() {
     assertEquals(serializer.decodeQueryTarget(serializer.encodeQueryTarget(q)), q);
   }
 
-  // PORTING NOTE: Isolated array-contains filter test omitted since we seem to have omitted
-  // isolated filter tests on Android (and the encodeRelationFilter() / decodeRelationFilter()
-  // serializer methods are private) in favor of relying on the larger tests. array-contains
-  // encoding / decoding is covered by testEncodesMultipleFiltersOnDeeperCollections().
+  @Test
+  public void testInSerialization() {
+    FieldFilter inputFilter = filter("field", "in", asList(42));
+    StructuredQuery.Filter apiFilter = serializer.encodeUnaryOrFieldFilter(inputFilter);
+
+    ArrayValue.Builder inFilterValue =
+        ArrayValue.newBuilder().addValues(valueBuilder().setIntegerValue(42));
+    StructuredQuery.Filter expectedFilter =
+        Filter.newBuilder()
+            .setFieldFilter(
+                StructuredQuery.FieldFilter.newBuilder()
+                    .setField(FieldReference.newBuilder().setFieldPath("field"))
+                    .setOp(Operator.IN)
+                    .setValue(valueBuilder().setArrayValue(inFilterValue))
+                    .build())
+            .build();
+
+    assertEquals(apiFilter, expectedFilter);
+    FieldFilter roundTripped = serializer.decodeFieldFilter(apiFilter.getFieldFilter());
+    assertEquals(roundTripped, inputFilter);
+    assertTrue(roundTripped instanceof InFilter);
+  }
+
+  @Test
+  public void testArrayContainsAnySerialization() {
+    FieldFilter inputFilter = filter("field", "array-contains-any", asList(42));
+    StructuredQuery.Filter apiFilter = serializer.encodeUnaryOrFieldFilter(inputFilter);
+
+    ArrayValue.Builder arrayContainsAnyFilterValue =
+        ArrayValue.newBuilder().addValues(valueBuilder().setIntegerValue(42));
+    StructuredQuery.Filter expectedFilter =
+        Filter.newBuilder()
+            .setFieldFilter(
+                StructuredQuery.FieldFilter.newBuilder()
+                    .setField(FieldReference.newBuilder().setFieldPath("field"))
+                    .setOp(Operator.ARRAY_CONTAINS_ANY)
+                    .setValue(valueBuilder().setArrayValue(arrayContainsAnyFilterValue))
+                    .build())
+            .build();
+
+    assertEquals(apiFilter, expectedFilter);
+    FieldFilter roundTripped = serializer.decodeFieldFilter(apiFilter.getFieldFilter());
+    assertEquals(roundTripped, inputFilter);
+    assertTrue(roundTripped instanceof ArrayContainsAnyFilter);
+  }
+
+  @Test
+  public void testKeyFieldSerializationEncoding() {
+    FieldFilter inputFilter = filter("__name__", "==", ref("project/database"));
+    StructuredQuery.Filter apiFilter = serializer.encodeUnaryOrFieldFilter(inputFilter);
+
+    StructuredQuery.Filter expectedFilter =
+        Filter.newBuilder()
+            .setFieldFilter(
+                StructuredQuery.FieldFilter.newBuilder()
+                    .setField(FieldReference.newBuilder().setFieldPath("__name__"))
+                    .setOp(Operator.EQUAL)
+                    .setValue(
+                        valueBuilder()
+                            .setReferenceValue(
+                                "projects/project/databases/(default)/documents/project/database"))
+                    .build())
+            .build();
+
+    assertEquals(apiFilter, expectedFilter);
+    FieldFilter roundTripped = serializer.decodeFieldFilter(apiFilter.getFieldFilter());
+    assertEquals(roundTripped, inputFilter);
+    assertTrue(roundTripped instanceof KeyFieldFilter);
+  }
+
+  // TODO(PORTING NOTE): Android currently tests most filter serialization (for equals, greater
+  // than, array-contains, etc.) only in testEncodesMultipleFiltersOnDeeperCollections and lacks
+  // isolated filter tests like the other platforms have. We should fix this.
 
   @Test
   public void testEncodesNullFilter() {
@@ -807,10 +872,10 @@ public void testEncodesBounds() {
   @Test
   public void testEncodesResumeTokens() {
     Query q = Query.atPath(ResourcePath.fromString("docs"));
-    Target actual =
-        serializer.encodeTarget(
-            new QueryData(
-                q, 1, 2, QueryPurpose.LISTEN, SnapshotVersion.NONE, TestUtil.resumeToken(1000)));
+    QueryData queryData =
+        new QueryData(q, 1, 2, QueryPurpose.LISTEN)
+            .withResumeToken(TestUtil.resumeToken(1000), SnapshotVersion.NONE);
+    Target actual = serializer.encodeTarget(queryData);
 
     StructuredQuery.Builder structuredQueryBuilder =
         StructuredQuery.newBuilder()
@@ -837,8 +902,7 @@ public void testEncodesResumeTokens() {
    * QueryData, but for the most part we're just testing variations on Query.
    */
   private QueryData wrapQueryData(Query query) {
-    return new QueryData(
-        query, 1, 2, QueryPurpose.LISTEN, SnapshotVersion.NONE, WatchStream.EMPTY_RESUME_TOKEN);
+    return new QueryData(query, 1, 2, QueryPurpose.LISTEN);
   }
 
   @Test
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/spec/QueryEvent.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/spec/QueryEvent.java
index 4f528afe7..ddb63712e 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/spec/QueryEvent.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/spec/QueryEvent.java
@@ -14,10 +14,10 @@
 
 package com.google.firebase.firestore.spec;
 
+import androidx.annotation.Nullable;
 import com.google.firebase.firestore.FirebaseFirestoreException;
 import com.google.firebase.firestore.core.Query;
 import com.google.firebase.firestore.core.ViewSnapshot;
-import javax.annotation.Nullable;
 
 /** Object that contains exactly one of either a view snapshot or an error for the given query. */
 public class QueryEvent {
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/spec/SQLiteSpecTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/spec/SQLiteSpecTest.java
index c8940dbc1..96ae43bcb 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/spec/SQLiteSpecTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/spec/SQLiteSpecTest.java
@@ -14,7 +14,6 @@
 
 package com.google.firebase.firestore.spec;
 
-import com.google.firebase.firestore.local.LruGarbageCollector;
 import com.google.firebase.firestore.local.Persistence;
 import com.google.firebase.firestore.local.PersistenceTestHelpers;
 import java.util.Set;
@@ -44,8 +43,7 @@ protected void specTearDown() throws Exception {
 
   @Override
   Persistence getPersistence(boolean garbageCollectionEnabled) {
-    return PersistenceTestHelpers.openSQLitePersistence(
-        databaseName, LruGarbageCollector.Params.Default());
+    return PersistenceTestHelpers.createSQLitePersistence(databaseName);
   }
 
   @Override
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/spec/SpecTestCase.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/spec/SpecTestCase.java
index 2ac8754f2..beaab7ae4 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/spec/SpecTestCase.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/spec/SpecTestCase.java
@@ -31,10 +31,13 @@
 import static org.junit.Assert.fail;
 
 import android.util.Pair;
+import androidx.test.core.app.ApplicationProvider;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.common.collect.Sets;
 import com.google.firebase.database.collection.ImmutableSortedSet;
+import com.google.firebase.firestore.EventListener;
+import com.google.firebase.firestore.FirebaseFirestoreException;
 import com.google.firebase.firestore.auth.User;
 import com.google.firebase.firestore.core.DocumentViewChange;
 import com.google.firebase.firestore.core.DocumentViewChange.Type;
@@ -47,7 +50,9 @@
 import com.google.firebase.firestore.local.LocalStore;
 import com.google.firebase.firestore.local.Persistence;
 import com.google.firebase.firestore.local.QueryData;
+import com.google.firebase.firestore.local.QueryEngine;
 import com.google.firebase.firestore.local.QueryPurpose;
+import com.google.firebase.firestore.local.SimpleQueryEngine;
 import com.google.firebase.firestore.model.Document;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.MaybeDocument;
@@ -94,7 +99,6 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.junit.Test;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.android.util.concurrent.RoboExecutorService;
 
 /**
@@ -185,6 +189,8 @@
   private final List<DocumentKey> acknowledgedDocs =
       Collections.synchronizedList(new ArrayList<>());
   private final List<DocumentKey> rejectedDocs = Collections.synchronizedList(new ArrayList<>());
+  private List<EventListener<Void>> snapshotsInSyncListeners;
+  private int snapshotsInSyncEvents = 0;
 
   /** An executor to use for test callbacks. */
   private final RoboExecutorService backgroundExecutor = new RoboExecutorService();
@@ -247,6 +253,8 @@ protected void specSetUp(JSONObject config) {
 
     expectedLimboDocs = new HashSet<>();
     expectedActiveTargets = new HashMap<>();
+
+    snapshotsInSyncListeners = Collections.synchronizedList(new ArrayList<>());
   }
 
   protected void specTearDown() throws Exception {
@@ -262,15 +270,17 @@ protected void specTearDown() throws Exception {
    */
   private void initClient() {
     localPersistence = getPersistence(garbageCollectionEnabled);
-    LocalStore localStore = new LocalStore(localPersistence, currentUser);
+    // TODO(index-free): Update to index-free query engine when it becomes default.
+    QueryEngine queryEngine = new SimpleQueryEngine();
+    LocalStore localStore = new LocalStore(localPersistence, queryEngine, currentUser);
 
     queue = new AsyncQueue();
 
     // Set up the sync engine and various stores.
-    datastore = new MockDatastore(queue, RuntimeEnvironment.application);
+    datastore = new MockDatastore(queue, ApplicationProvider.getApplicationContext());
 
     ConnectivityMonitor connectivityMonitor =
-        new AndroidConnectivityMonitor(RuntimeEnvironment.application);
+        new AndroidConnectivityMonitor(ApplicationProvider.getApplicationContext());
     remoteStore = new RemoteStore(this, localStore, datastore, queue, connectivityMonitor);
     syncEngine = new SyncEngine(localStore, remoteStore, currentUser);
     eventManager = new EventManager(syncEngine);
@@ -486,6 +496,22 @@ private void doDelete(String key) throws Exception {
     doMutation(deleteMutation(key));
   }
 
+  private void doAddSnapshotsInSyncListener() {
+    EventListener<Void> eventListener =
+        (Void v, FirebaseFirestoreException error) -> snapshotsInSyncEvents += 1;
+    snapshotsInSyncListeners.add(eventListener);
+    eventManager.addSnapshotsInSyncListener(eventListener);
+  }
+
+  private void doRemoveSnapshotsInSyncListener() throws Exception {
+    if (snapshotsInSyncListeners.size() == 0) {
+      throw Assert.fail("There must be a listener to unlisten to");
+    } else {
+      EventListener<Void> listenerToRemove = snapshotsInSyncListeners.remove(0);
+      eventManager.removeSnapshotsInSyncListener(listenerToRemove);
+    }
+  }
+
   // Helper for calling datastore.writeWatchChange() on the AsyncQueue.
   private void writeWatchChange(WatchChange change, SnapshotVersion version) throws Exception {
     queue.runSync(() -> datastore.writeWatchChange(change, version));
@@ -720,6 +746,10 @@ private void doStep(JSONObject step) throws Exception {
       doPatch(step.getJSONArray("userPatch"));
     } else if (step.has("userDelete")) {
       doDelete(step.getString("userDelete"));
+    } else if (step.has("addSnapshotsInSyncListener")) {
+      doAddSnapshotsInSyncListener();
+    } else if (step.has("removeSnapshotsInSyncListener")) {
+      doRemoveSnapshotsInSyncListener();
     } else if (step.has("drainQueue")) {
       doDrainQueue();
     } else if (step.has("watchAck")) {
@@ -879,15 +909,10 @@ private void validateStateExpectations(@Nullable JSONObject expected) throws JSO
           // TODO: populate the purpose of the target once it's possible to encode that in the
           // spec tests. For now, hard-code that it's a listen despite the fact that it's not always
           // the right value.
-          expectedActiveTargets.put(
-              targetId,
-              new QueryData(
-                  query,
-                  targetId,
-                  ARBITRARY_SEQUENCE_NUMBER,
-                  QueryPurpose.LISTEN,
-                  SnapshotVersion.NONE,
-                  ByteString.copyFromUtf8(resumeToken)));
+          QueryData queryData =
+              new QueryData(query, targetId, ARBITRARY_SEQUENCE_NUMBER, QueryPurpose.LISTEN)
+                  .withResumeToken(ByteString.copyFromUtf8(resumeToken), SnapshotVersion.NONE);
+          expectedActiveTargets.put(targetId, queryData);
         }
       }
     }
@@ -900,6 +925,11 @@ private void validateStateExpectations(@Nullable JSONObject expected) throws JSO
     validateActiveTargets();
   }
 
+  private void validateSnapshotsInSyncEvents(int expectedCount) {
+    assertEquals(expectedCount, snapshotsInSyncEvents);
+    snapshotsInSyncEvents = 0;
+  }
+
   private void validateUserCallbacks(@Nullable JSONObject expected) throws JSONException {
     if (expected != null && expected.has("userCallbacks")) {
       JSONObject userCallbacks = expected.getJSONObject("userCallbacks");
@@ -987,6 +1017,8 @@ private void runSteps(JSONArray steps, JSONObject config) throws Exception {
         step.remove("expect");
         @Nullable JSONObject stateExpect = step.optJSONObject("stateExpect");
         step.remove("stateExpect");
+        int expectedSnapshotsInSyncEvents = step.optInt("expectedSnapshotsInSyncEvents");
+        step.remove("expectedSnapshotsInSyncEvents");
 
         log("    Doing step " + step);
         doStep(step);
@@ -1003,6 +1035,7 @@ private void runSteps(JSONArray steps, JSONObject config) throws Exception {
           log("      Validating state expectations " + stateExpect);
         }
         validateStateExpectations(stateExpect);
+        validateSnapshotsInSyncEvents(expectedSnapshotsInSyncEvents);
         events.clear();
         acknowledgedDocs.clear();
         rejectedDocs.clear();
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/util/AsyncQueueTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/util/AsyncQueueTest.java
index ae14bfc15..b6f817ef4 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/util/AsyncQueueTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/util/AsyncQueueTest.java
@@ -123,4 +123,20 @@ public void canManuallyDrainSpecificDelayedTasksForTesting() throws Exception {
     queue.runDelayedTasksUntil(TIMER_ID_3);
     assertEquals(Arrays.asList(1, 2, 3, 4), completedSteps);
   }
+
+  @Test
+  public void tasksAreScheduledWithRespectToShutdown() {
+    expectedSteps = Arrays.asList(1, 2, 4);
+    queue.enqueueAndForget(runnableForStep(1));
+
+    // From this point on, `normal` tasks are not scheduled. Only those who explicitly request to
+    // run after shutdown initiated will run.
+    queue.enqueueAndInitiateShutdown(runnableForStep(2));
+
+    queue.enqueueAndForget(runnableForStep(3));
+    queue.enqueueAndForgetEvenAfterShutdown(runnableForStep(4));
+
+    queue.getExecutor().execute(runnableForStep(5));
+    waitForExpectedSteps();
+  }
 }
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/util/MapperTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/util/MapperTest.java
index 3cd91f346..a11754563 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/util/MapperTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/util/MapperTest.java
@@ -21,6 +21,7 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
+import com.google.firebase.firestore.DocumentId;
 import com.google.firebase.firestore.DocumentReference;
 import com.google.firebase.firestore.Exclude;
 import com.google.firebase.firestore.PropertyName;
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/util/ThrottledForwardingExecutorTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/util/ThrottledForwardingExecutorTest.java
new file mode 100644
index 000000000..30eac6817
--- /dev/null
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/util/ThrottledForwardingExecutorTest.java
@@ -0,0 +1,102 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.util;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.junit.Test;
+import org.robolectric.annotation.Config;
+
+@org.junit.runner.RunWith(org.robolectric.RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ThrottledForwardingExecutorTest {
+  @Test
+  public void limitsNumberOfForwardedTasks() throws InterruptedException {
+    Semaphore completedTasks = new Semaphore(0);
+    int maximumConcurrency = 10;
+
+    CountingExecutor countingExecutor = new CountingExecutor();
+    ThrottledForwardingExecutor throttledExecutor =
+        new ThrottledForwardingExecutor(maximumConcurrency, countingExecutor);
+
+    // Schedule more than `maximumConcurrency` parallel tasks and wait until all scheduling has
+    // finished.
+    int numTasks = maximumConcurrency + 1;
+    CountDownLatch schedulingLatch = new CountDownLatch(1);
+    for (int i = 0; i < numTasks; ++i) {
+      int currentTask = i;
+      throttledExecutor.execute(
+          () -> {
+            try {
+              if (currentTask < maximumConcurrency) {
+                // Block if we are running on the forwarded executor. We can't block the thread that
+                // is running this test.
+                schedulingLatch.await();
+              }
+              completedTasks.release();
+            } catch (InterruptedException e) {
+              fail("Unexpected InterruptedException: " + e);
+            }
+          });
+    }
+    schedulingLatch.countDown();
+
+    // Verify that only `maximumConcurrency` tasks were forwarded to the executor.
+    completedTasks.acquire(numTasks);
+    assertEquals(maximumConcurrency, countingExecutor.getNumTasks());
+  }
+
+  @Test
+  public void handlesRejectedExecutionException() {
+    AtomicInteger result = new AtomicInteger(0);
+
+    ThrottledForwardingExecutor executor =
+        new ThrottledForwardingExecutor(
+            10,
+            command -> {
+              throw new RejectedExecutionException();
+            });
+
+    executor.execute(result::incrementAndGet);
+
+    assertEquals(1, result.get());
+  }
+
+  /** An executor that counts the number of tasks submitted. */
+  private static class CountingExecutor implements Executor {
+    int numTasks = 0;
+
+    @Override
+    public void execute(Runnable command) {
+      ++numTasks;
+      new Thread() {
+        @Override
+        public void run() {
+          command.run();
+        }
+      }.start();
+    }
+
+    int getNumTasks() {
+      return numTasks;
+    }
+  }
+}
diff --git a/firebase-firestore/src/test/resources/json/limbo_spec_test.json b/firebase-firestore/src/test/resources/json/limbo_spec_test.json
index 88ed8dcad..0b662d500 100644
--- a/firebase-firestore/src/test/resources/json/limbo_spec_test.json
+++ b/firebase-firestore/src/test/resources/json/limbo_spec_test.json
@@ -611,7 +611,7 @@
           "docs": [
             {
               "key": "collection/a",
-              "version": 1000,
+              "version": 1002,
               "value": {
                 "key": "b"
               },
@@ -948,7 +948,7 @@
           "docs": [
             {
               "key": "collection/a",
-              "version": 1000,
+              "version": 1002,
               "value": {
                 "key": "b"
               },
@@ -1055,7 +1055,7 @@
             "added": [
               {
                 "key": "collection/a",
-                "version": 1000,
+                "version": 1002,
                 "value": {
                   "key": "b"
                 },
@@ -3431,5 +3431,371 @@
         "clientIndex": 0
       }
     ]
+  },
+  "Limbo documents stay consistent between views": {
+    "describeName": "Limbo Documents:",
+    "itName": "Limbo documents stay consistent between views",
+    "tags": [],
+    "config": {
+      "useGarbageCollection": false,
+      "numClients": 1
+    },
+    "steps": [
+      {
+        "userSet": [
+          "collection/a",
+          {
+            "matches": true
+          }
+        ]
+      },
+      {
+        "userSet": [
+          "collection/b",
+          {
+            "matches": true
+          }
+        ]
+      },
+      {
+        "writeAck": {
+          "version": 1000
+        },
+        "stateExpect": {
+          "userCallbacks": {
+            "acknowledgedDocs": [
+              "collection/a"
+            ],
+            "rejectedDocs": []
+          }
+        }
+      },
+      {
+        "writeAck": {
+          "version": 1001
+        },
+        "stateExpect": {
+          "userCallbacks": {
+            "acknowledgedDocs": [
+              "collection/b"
+            ],
+            "rejectedDocs": []
+          }
+        }
+      },
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": true
+                }
+              },
+              {
+                "key": "collection/b",
+                "version": 1001,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": true
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "watchAck": [
+          2
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1000,
+              "value": {
+                "matches": true
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-2000"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 2000,
+          "targetIds": []
+        },
+        "stateExpect": {
+          "limboDocs": [
+            "collection/b"
+          ],
+          "activeTargets": {
+            "1": {
+              "query": {
+                "path": "collection/b",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "userListen": [
+          4,
+          {
+            "path": "collection",
+            "filters": [
+              [
+                "matches",
+                "==",
+                true
+              ]
+            ],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "1": {
+              "query": {
+                "path": "collection/b",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "4": {
+              "query": {
+                "path": "collection",
+                "filters": [
+                  [
+                    "matches",
+                    "==",
+                    true
+                  ]
+                ],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [
+                [
+                  "matches",
+                  "==",
+                  true
+                ]
+              ],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/b",
+                "version": 1001,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": true
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userUnlisten": [
+          2,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "4": {
+              "query": {
+                "path": "collection",
+                "filters": [
+                  [
+                    "matches",
+                    "==",
+                    true
+                  ]
+                ],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          },
+          "limboDocs": []
+        }
+      },
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": "resume-token-2000"
+            },
+            "4": {
+              "query": {
+                "path": "collection",
+                "filters": [
+                  [
+                    "matches",
+                    "==",
+                    true
+                  ]
+                ],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/b",
+                "version": 1001,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": true
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      }
+    ]
   }
 }
diff --git a/firebase-firestore/src/test/resources/json/limit_spec_test.json b/firebase-firestore/src/test/resources/json/limit_spec_test.json
index e387bf071..79e7c1d3f 100644
--- a/firebase-firestore/src/test/resources/json/limit_spec_test.json
+++ b/firebase-firestore/src/test/resources/json/limit_spec_test.json
@@ -1256,6 +1256,2761 @@
       }
     ]
   },
+  "Limits are re-filled from cache": {
+    "describeName": "Limits:",
+    "itName": "Limits are re-filled from cache",
+    "tags": [],
+    "config": {
+      "useGarbageCollection": false,
+      "numClients": 1
+    },
+    "steps": [
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "filters": [
+              [
+                "matches",
+                "==",
+                true
+              ]
+            ],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [
+                  [
+                    "matches",
+                    "==",
+                    true
+                  ]
+                ],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          2
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1001,
+              "value": {
+                "matches": true
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            },
+            {
+              "key": "collection/b",
+              "version": 1002,
+              "value": {
+                "matches": true
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            },
+            {
+              "key": "collection/c",
+              "version": 1000,
+              "value": {
+                "matches": true
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-1002"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1002,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [
+                [
+                  "matches",
+                  "==",
+                  true
+                ]
+              ],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1001,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/b",
+                "version": 1002,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/c",
+                "version": 1000,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userUnlisten": [
+          2,
+          {
+            "path": "collection",
+            "filters": [
+              [
+                "matches",
+                "==",
+                true
+              ]
+            ],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {}
+        }
+      },
+      {
+        "userListen": [
+          4,
+          {
+            "path": "collection",
+            "limit": 2,
+            "filters": [
+              [
+                "matches",
+                "==",
+                true
+              ]
+            ],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "4": {
+              "query": {
+                "path": "collection",
+                "limit": 2,
+                "filters": [
+                  [
+                    "matches",
+                    "==",
+                    true
+                  ]
+                ],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "limit": 2,
+              "filters": [
+                [
+                  "matches",
+                  "==",
+                  true
+                ]
+              ],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1001,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/b",
+                "version": 1002,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userSet": [
+          "collection/a",
+          {
+            "matches": false
+          }
+        ],
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "limit": 2,
+              "filters": [
+                [
+                  "matches",
+                  "==",
+                  true
+                ]
+              ],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/c",
+                "version": 1000,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "removed": [
+              {
+                "key": "collection/a",
+                "version": 1001,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      }
+    ]
+  },
+  "Initial snapshots for limit queries are re-filled from cache (with removal)": {
+    "describeName": "Limits:",
+    "itName": "Initial snapshots for limit queries are re-filled from cache (with removal)",
+    "tags": [],
+    "config": {
+      "useGarbageCollection": false,
+      "numClients": 1
+    },
+    "steps": [
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "filters": [
+              [
+                "matches",
+                "==",
+                true
+              ]
+            ],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [
+                  [
+                    "matches",
+                    "==",
+                    true
+                  ]
+                ],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          2
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1001,
+              "value": {
+                "matches": true
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            },
+            {
+              "key": "collection/b",
+              "version": 1002,
+              "value": {
+                "matches": true
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            },
+            {
+              "key": "collection/c",
+              "version": 1003,
+              "value": {
+                "matches": true
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-1003"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1003,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [
+                [
+                  "matches",
+                  "==",
+                  true
+                ]
+              ],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1001,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/b",
+                "version": 1002,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/c",
+                "version": 1003,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userUnlisten": [
+          2,
+          {
+            "path": "collection",
+            "filters": [
+              [
+                "matches",
+                "==",
+                true
+              ]
+            ],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {}
+        }
+      },
+      {
+        "userListen": [
+          4,
+          {
+            "path": "collection",
+            "limit": 2,
+            "filters": [
+              [
+                "matches",
+                "==",
+                true
+              ]
+            ],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "4": {
+              "query": {
+                "path": "collection",
+                "limit": 2,
+                "filters": [
+                  [
+                    "matches",
+                    "==",
+                    true
+                  ]
+                ],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "limit": 2,
+              "filters": [
+                [
+                  "matches",
+                  "==",
+                  true
+                ]
+              ],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1001,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/b",
+                "version": 1002,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "watchAck": [
+          4
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1001,
+              "value": {
+                "matches": true
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            },
+            {
+              "key": "collection/b",
+              "version": 1002,
+              "value": {
+                "matches": true
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            4
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            4
+          ],
+          "resume-token-1004"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1004,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "limit": 2,
+              "filters": [
+                [
+                  "matches",
+                  "==",
+                  true
+                ]
+              ],
+              "orderBys": []
+            },
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userUnlisten": [
+          4,
+          {
+            "path": "collection",
+            "limit": 2,
+            "filters": [
+              [
+                "matches",
+                "==",
+                true
+              ]
+            ],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {}
+        }
+      },
+      {
+        "watchRemove": {
+          "targetIds": [
+            4
+          ]
+        }
+      },
+      {
+        "userSet": [
+          "collection/a",
+          {
+            "matches": false
+          }
+        ]
+      },
+      {
+        "userListen": [
+          4,
+          {
+            "path": "collection",
+            "limit": 2,
+            "filters": [
+              [
+                "matches",
+                "==",
+                true
+              ]
+            ],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "4": {
+              "query": {
+                "path": "collection",
+                "limit": 2,
+                "filters": [
+                  [
+                    "matches",
+                    "==",
+                    true
+                  ]
+                ],
+                "orderBys": []
+              },
+              "resumeToken": "resume-token-1004"
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "limit": 2,
+              "filters": [
+                [
+                  "matches",
+                  "==",
+                  true
+                ]
+              ],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/b",
+                "version": 1002,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/c",
+                "version": 1003,
+                "value": {
+                  "matches": true
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      }
+    ]
+  },
+  "Initial snapshots for limit queries are re-filled from cache (with latency-compensated edit)": {
+    "describeName": "Limits:",
+    "itName": "Initial snapshots for limit queries are re-filled from cache (with latency-compensated edit)",
+    "tags": [],
+    "config": {
+      "useGarbageCollection": false,
+      "numClients": 1
+    },
+    "steps": [
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          2
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1001,
+              "value": {
+                "pos": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            },
+            {
+              "key": "collection/b",
+              "version": 1002,
+              "value": {
+                "pos": 2
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            },
+            {
+              "key": "collection/c",
+              "version": 1003,
+              "value": {
+                "pos": 3
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-1003"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1003,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1001,
+                "value": {
+                  "pos": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/b",
+                "version": 1002,
+                "value": {
+                  "pos": 2
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/c",
+                "version": 1003,
+                "value": {
+                  "pos": 3
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userUnlisten": [
+          2,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {}
+        }
+      },
+      {
+        "watchRemove": {
+          "targetIds": [
+            2
+          ]
+        }
+      },
+      {
+        "userListen": [
+          4,
+          {
+            "path": "collection",
+            "limit": 2,
+            "filters": [],
+            "orderBys": [
+              [
+                "pos",
+                "asc"
+              ]
+            ]
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "4": {
+              "query": {
+                "path": "collection",
+                "limit": 2,
+                "filters": [],
+                "orderBys": [
+                  [
+                    "pos",
+                    "asc"
+                  ]
+                ]
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "limit": 2,
+              "filters": [],
+              "orderBys": [
+                [
+                  "pos",
+                  "asc"
+                ]
+              ]
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1001,
+                "value": {
+                  "pos": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/b",
+                "version": 1002,
+                "value": {
+                  "pos": 2
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "watchAck": [
+          4
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1001,
+              "value": {
+                "pos": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            },
+            {
+              "key": "collection/b",
+              "version": 1002,
+              "value": {
+                "pos": 2
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            4
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            4
+          ],
+          "resume-token-1004"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1004,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "limit": 2,
+              "filters": [],
+              "orderBys": [
+                [
+                  "pos",
+                  "asc"
+                ]
+              ]
+            },
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userUnlisten": [
+          4,
+          {
+            "path": "collection",
+            "limit": 2,
+            "filters": [],
+            "orderBys": [
+              [
+                "pos",
+                "asc"
+              ]
+            ]
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {}
+        }
+      },
+      {
+        "watchRemove": {
+          "targetIds": [
+            4
+          ]
+        }
+      },
+      {
+        "userSet": [
+          "collection/a",
+          {
+            "pos": 4
+          }
+        ]
+      },
+      {
+        "userListen": [
+          4,
+          {
+            "path": "collection",
+            "limit": 2,
+            "filters": [],
+            "orderBys": [
+              [
+                "pos",
+                "asc"
+              ]
+            ]
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "4": {
+              "query": {
+                "path": "collection",
+                "limit": 2,
+                "filters": [],
+                "orderBys": [
+                  [
+                    "pos",
+                    "asc"
+                  ]
+                ]
+              },
+              "resumeToken": "resume-token-1004"
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "limit": 2,
+              "filters": [],
+              "orderBys": [
+                [
+                  "pos",
+                  "asc"
+                ]
+              ]
+            },
+            "added": [
+              {
+                "key": "collection/b",
+                "version": 1002,
+                "value": {
+                  "pos": 2
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/c",
+                "version": 1003,
+                "value": {
+                  "pos": 3
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      }
+    ]
+  },
+  "Initial snapshots for limit queries are re-filled from cache (with update from backend)": {
+    "describeName": "Limits:",
+    "itName": "Initial snapshots for limit queries are re-filled from cache (with update from backend)",
+    "tags": [],
+    "config": {
+      "useGarbageCollection": false,
+      "numClients": 1
+    },
+    "steps": [
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          2
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1001,
+              "value": {
+                "pos": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            },
+            {
+              "key": "collection/b",
+              "version": 1002,
+              "value": {
+                "pos": 2
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            },
+            {
+              "key": "collection/c",
+              "version": 1003,
+              "value": {
+                "pos": 3
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-1003"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1003,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1001,
+                "value": {
+                  "pos": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/b",
+                "version": 1002,
+                "value": {
+                  "pos": 2
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/c",
+                "version": 1003,
+                "value": {
+                  "pos": 3
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userUnlisten": [
+          2,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {}
+        }
+      },
+      {
+        "watchRemove": {
+          "targetIds": [
+            2
+          ]
+        }
+      },
+      {
+        "userListen": [
+          4,
+          {
+            "path": "collection",
+            "limit": 2,
+            "filters": [],
+            "orderBys": [
+              [
+                "pos",
+                "asc"
+              ]
+            ]
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "4": {
+              "query": {
+                "path": "collection",
+                "limit": 2,
+                "filters": [],
+                "orderBys": [
+                  [
+                    "pos",
+                    "asc"
+                  ]
+                ]
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "limit": 2,
+              "filters": [],
+              "orderBys": [
+                [
+                  "pos",
+                  "asc"
+                ]
+              ]
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1001,
+                "value": {
+                  "pos": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/b",
+                "version": 1002,
+                "value": {
+                  "pos": 2
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "watchAck": [
+          4
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1001,
+              "value": {
+                "pos": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            },
+            {
+              "key": "collection/b",
+              "version": 1002,
+              "value": {
+                "pos": 2
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            4
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            4
+          ],
+          "resume-token-1004"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1004,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "limit": 2,
+              "filters": [],
+              "orderBys": [
+                [
+                  "pos",
+                  "asc"
+                ]
+              ]
+            },
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userUnlisten": [
+          4,
+          {
+            "path": "collection",
+            "limit": 2,
+            "filters": [],
+            "orderBys": [
+              [
+                "pos",
+                "asc"
+              ]
+            ]
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {}
+        }
+      },
+      {
+        "watchRemove": {
+          "targetIds": [
+            4
+          ]
+        }
+      },
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": "resume-token-1003"
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1001,
+                "value": {
+                  "pos": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/b",
+                "version": 1002,
+                "value": {
+                  "pos": 2
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/c",
+                "version": 1003,
+                "value": {
+                  "pos": 3
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "watchAck": [
+          2
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1005,
+              "value": {
+                "pos": 4
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-1005"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1005,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "modified": [
+              {
+                "key": "collection/a",
+                "version": 1005,
+                "value": {
+                  "pos": 4
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userListen": [
+          4,
+          {
+            "path": "collection",
+            "limit": 2,
+            "filters": [],
+            "orderBys": [
+              [
+                "pos",
+                "asc"
+              ]
+            ]
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": "resume-token-1003"
+            },
+            "4": {
+              "query": {
+                "path": "collection",
+                "limit": 2,
+                "filters": [],
+                "orderBys": [
+                  [
+                    "pos",
+                    "asc"
+                  ]
+                ]
+              },
+              "resumeToken": "resume-token-1004"
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "limit": 2,
+              "filters": [],
+              "orderBys": [
+                [
+                  "pos",
+                  "asc"
+                ]
+              ]
+            },
+            "added": [
+              {
+                "key": "collection/b",
+                "version": 1002,
+                "value": {
+                  "pos": 2
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "collection/c",
+                "version": 1003,
+                "value": {
+                  "pos": 3
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      }
+    ]
+  },
+  "Resumed limit queries exclude deleted documents ": {
+    "describeName": "Limits:",
+    "itName": "Resumed limit queries exclude deleted documents ",
+    "tags": [
+      "durable-persistence"
+    ],
+    "config": {
+      "useGarbageCollection": false,
+      "numClients": 1
+    },
+    "steps": [
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "limit": 1,
+            "filters": [],
+            "orderBys": [
+              [
+                "a",
+                "asc"
+              ]
+            ]
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "limit": 1,
+                "filters": [],
+                "orderBys": [
+                  [
+                    "a",
+                    "asc"
+                  ]
+                ]
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          2
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1001,
+              "value": {
+                "a": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-1001"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1001,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "limit": 1,
+              "filters": [],
+              "orderBys": [
+                [
+                  "a",
+                  "asc"
+                ]
+              ]
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1001,
+                "value": {
+                  "a": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userUnlisten": [
+          2,
+          {
+            "path": "collection",
+            "limit": 1,
+            "filters": [],
+            "orderBys": [
+              [
+                "a",
+                "asc"
+              ]
+            ]
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {}
+        }
+      },
+      {
+        "watchRemove": {
+          "targetIds": [
+            2
+          ]
+        }
+      },
+      {
+        "userListen": [
+          4,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": [
+              [
+                "a",
+                "asc"
+              ]
+            ]
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "4": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": [
+                  [
+                    "a",
+                    "asc"
+                  ]
+                ]
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": [
+                [
+                  "a",
+                  "asc"
+                ]
+              ]
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1001,
+                "value": {
+                  "a": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "watchAck": [
+          4
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1001,
+              "value": {
+                "a": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            },
+            {
+              "key": "collection/b",
+              "version": 1000,
+              "value": {
+                "a": 2
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            4
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            4
+          ],
+          "resume-token-1002"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1002,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": [
+                [
+                  "a",
+                  "asc"
+                ]
+              ]
+            },
+            "added": [
+              {
+                "key": "collection/b",
+                "version": 1000,
+                "value": {
+                  "a": 2
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "watchEntity": {
+          "key": "collection/a",
+          "removedTargets": [
+            4
+          ]
+        }
+      },
+      {
+        "watchSnapshot": {
+          "version": 1003,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": [
+                [
+                  "a",
+                  "asc"
+                ]
+              ]
+            },
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ],
+        "stateExpect": {
+          "limboDocs": [
+            "collection/a"
+          ],
+          "activeTargets": {
+            "1": {
+              "query": {
+                "path": "collection/a",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "4": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": [
+                  [
+                    "a",
+                    "asc"
+                  ]
+                ]
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "userUnlisten": [
+          4,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": [
+              [
+                "a",
+                "asc"
+              ]
+            ]
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {},
+          "limboDocs": []
+        }
+      },
+      {
+        "watchRemove": {
+          "targetIds": [
+            4
+          ]
+        }
+      },
+      {
+        "restart": true,
+        "stateExpect": {
+          "activeTargets": {},
+          "limboDocs": []
+        }
+      },
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "limit": 1,
+            "filters": [],
+            "orderBys": [
+              [
+                "a",
+                "asc"
+              ]
+            ]
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "limit": 1,
+                "filters": [],
+                "orderBys": [
+                  [
+                    "a",
+                    "asc"
+                  ]
+                ]
+              },
+              "resumeToken": "resume-token-1001"
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "limit": 1,
+              "filters": [],
+              "orderBys": [
+                [
+                  "a",
+                  "asc"
+                ]
+              ]
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1001,
+                "value": {
+                  "a": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "watchAck": [
+          2
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/b",
+              "version": 1000,
+              "value": {
+                "a": 2
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchFilter": [
+          [
+            2
+          ],
+          "collection/b"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1004,
+          "targetIds": []
+        },
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "limit": 1,
+                "filters": [],
+                "orderBys": [
+                  [
+                    "a",
+                    "asc"
+                  ]
+                ]
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchRemove": {
+          "targetIds": [
+            2
+          ]
+        }
+      },
+      {
+        "watchAck": [
+          2
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/b",
+              "version": 1000,
+              "value": {
+                "a": 2
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-1005"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1005,
+          "targetIds": []
+        },
+        "stateExpect": {
+          "limboDocs": [
+            "collection/a"
+          ],
+          "activeTargets": {
+            "1": {
+              "query": {
+                "path": "collection/a",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "2": {
+              "query": {
+                "path": "collection",
+                "limit": 1,
+                "filters": [],
+                "orderBys": [
+                  [
+                    "a",
+                    "asc"
+                  ]
+                ]
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          1
+        ]
+      },
+      {
+        "watchCurrent": [
+          [
+            1
+          ],
+          "resume-token-1006"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1006,
+          "targetIds": []
+        },
+        "stateExpect": {
+          "limboDocs": [],
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "limit": 1,
+                "filters": [],
+                "orderBys": [
+                  [
+                    "a",
+                    "asc"
+                  ]
+                ]
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "limit": 1,
+              "filters": [],
+              "orderBys": [
+                [
+                  "a",
+                  "asc"
+                ]
+              ]
+            },
+            "added": [
+              {
+                "key": "collection/b",
+                "version": 1000,
+                "value": {
+                  "a": 2
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "removed": [
+              {
+                "key": "collection/a",
+                "version": 1001,
+                "value": {
+                  "a": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      }
+    ]
+  },
+  "Resumed limit queries use updated documents ": {
+    "describeName": "Limits:",
+    "itName": "Resumed limit queries use updated documents ",
+    "tags": [],
+    "config": {
+      "useGarbageCollection": false,
+      "numClients": 1
+    },
+    "steps": [
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "limit": 1,
+            "filters": [],
+            "orderBys": [
+              [
+                "a",
+                "asc"
+              ]
+            ]
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "limit": 1,
+                "filters": [],
+                "orderBys": [
+                  [
+                    "a",
+                    "asc"
+                  ]
+                ]
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          2
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 2001,
+              "value": {
+                "a": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-2001"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 2001,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "limit": 1,
+              "filters": [],
+              "orderBys": [
+                [
+                  "a",
+                  "asc"
+                ]
+              ]
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 2001,
+                "value": {
+                  "a": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userUnlisten": [
+          2,
+          {
+            "path": "collection",
+            "limit": 1,
+            "filters": [],
+            "orderBys": [
+              [
+                "a",
+                "asc"
+              ]
+            ]
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {}
+        }
+      },
+      {
+        "watchRemove": {
+          "targetIds": [
+            2
+          ]
+        }
+      },
+      {
+        "userListen": [
+          4,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": [
+              [
+                "a",
+                "asc"
+              ]
+            ]
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "4": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": [
+                  [
+                    "a",
+                    "asc"
+                  ]
+                ]
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": [
+                [
+                  "a",
+                  "asc"
+                ]
+              ]
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 2001,
+                "value": {
+                  "a": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "watchAck": [
+          4
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 2003,
+              "value": {
+                "a": 3
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            },
+            {
+              "key": "collection/c",
+              "version": 1000,
+              "value": {
+                "a": 2
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            4
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            4
+          ],
+          "resume-token-2003"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 2003,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": [
+                [
+                  "a",
+                  "asc"
+                ]
+              ]
+            },
+            "added": [
+              {
+                "key": "collection/c",
+                "version": 1000,
+                "value": {
+                  "a": 2
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "modified": [
+              {
+                "key": "collection/a",
+                "version": 2003,
+                "value": {
+                  "a": 3
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userUnlisten": [
+          4,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": [
+              [
+                "a",
+                "asc"
+              ]
+            ]
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {}
+        }
+      },
+      {
+        "watchRemove": {
+          "targetIds": [
+            4
+          ]
+        }
+      },
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "limit": 1,
+            "filters": [],
+            "orderBys": [
+              [
+                "a",
+                "asc"
+              ]
+            ]
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "limit": 1,
+                "filters": [],
+                "orderBys": [
+                  [
+                    "a",
+                    "asc"
+                  ]
+                ]
+              },
+              "resumeToken": "resume-token-2001"
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "limit": 1,
+              "filters": [],
+              "orderBys": [
+                [
+                  "a",
+                  "asc"
+                ]
+              ]
+            },
+            "added": [
+              {
+                "key": "collection/c",
+                "version": 1000,
+                "value": {
+                  "a": 2
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      }
+    ]
+  },
   "Multiple docs in limbo in full limit query": {
     "describeName": "Limits:",
     "itName": "Multiple docs in limbo in full limit query",
diff --git a/firebase-firestore/src/test/resources/json/listen_spec_test.json b/firebase-firestore/src/test/resources/json/listen_spec_test.json
index ff17545ce..00df58771 100644
--- a/firebase-firestore/src/test/resources/json/listen_spec_test.json
+++ b/firebase-firestore/src/test/resources/json/listen_spec_test.json
@@ -582,7 +582,7 @@
           "docs": [
             {
               "key": "collection/a",
-              "version": 0,
+              "version": 1000,
               "value": {
                 "key": "a"
               },
@@ -620,7 +620,7 @@
             "added": [
               {
                 "key": "collection/a",
-                "version": 0,
+                "version": 1000,
                 "value": {
                   "key": "a"
                 },
@@ -648,7 +648,7 @@
             "removed": [
               {
                 "key": "collection/a",
-                "version": 0,
+                "version": 1000,
                 "value": {
                   "key": "a"
                 },
@@ -3070,12 +3070,12 @@
       }
     ]
   },
-  "Deleted documents in cache are fixed": {
+  "Listens are reestablished after network disconnect": {
     "describeName": "Listens:",
-    "itName": "Deleted documents in cache are fixed",
+    "itName": "Listens are reestablished after network disconnect",
     "tags": [],
     "config": {
-      "useGarbageCollection": false,
+      "useGarbageCollection": true,
       "numClients": 1
     },
     "steps": [
@@ -3084,13 +3084,7 @@
           2,
           {
             "path": "collection",
-            "filters": [
-              [
-                "key",
-                "==",
-                "a"
-              ]
-            ],
+            "filters": [],
             "orderBys": []
           }
         ],
@@ -3099,18 +3093,13 @@
             "2": {
               "query": {
                 "path": "collection",
-                "filters": [
-                  [
-                    "key",
-                    "==",
-                    "a"
-                  ]
-                ],
+                "filters": [],
                 "orderBys": []
               },
               "resumeToken": ""
             }
-          }
+          },
+          "watchStreamRequestCount": 1
         }
       },
       {
@@ -3155,13 +3144,7 @@
           {
             "query": {
               "path": "collection",
-              "filters": [
-                [
-                  "key",
-                  "==",
-                  "a"
-                ]
-              ],
+              "filters": [],
               "orderBys": []
             },
             "added": [
@@ -3184,126 +3167,53 @@
         ]
       },
       {
-        "watchEntity": {
-          "docs": [
-            {
-              "key": "collection/a",
-              "version": 2000,
-              "value": null
-            }
-          ],
-          "removedTargets": [
-            2
-          ]
-        }
-      },
-      {
-        "watchSnapshot": {
-          "version": 2000,
-          "targetIds": [
-            2
-          ],
-          "resumeToken": "resume-token-2000"
-        }
-      },
-      {
-        "watchSnapshot": {
-          "version": 2000,
-          "targetIds": []
+        "enableNetwork": false,
+        "stateExpect": {
+          "activeTargets": {},
+          "limboDocs": []
         },
         "expect": [
           {
             "query": {
               "path": "collection",
-              "filters": [
-                [
-                  "key",
-                  "==",
-                  "a"
-                ]
-              ],
+              "filters": [],
               "orderBys": []
             },
-            "removed": [
-              {
-                "key": "collection/a",
-                "version": 1000,
-                "value": {
-                  "key": "a"
-                },
-                "options": {
-                  "hasLocalMutations": false,
-                  "hasCommittedMutations": false
-                }
-              }
-            ],
             "errorCode": 0,
-            "fromCache": false,
+            "fromCache": true,
             "hasPendingWrites": false
           }
         ]
       },
       {
-        "userUnlisten": [
-          2,
-          {
-            "path": "collection",
-            "filters": [
-              [
-                "key",
-                "==",
-                "a"
-              ]
-            ],
-            "orderBys": []
-          }
-        ],
-        "stateExpect": {
-          "activeTargets": {}
-        }
-      },
-      {
-        "watchRemove": {
-          "targetIds": [
-            2
-          ]
-        }
-      },
-      {
-        "userListen": [
-          4,
-          {
-            "path": "collection",
-            "filters": [],
-            "orderBys": []
-          }
-        ],
+        "enableNetwork": true,
         "stateExpect": {
           "activeTargets": {
-            "4": {
+            "2": {
               "query": {
                 "path": "collection",
                 "filters": [],
                 "orderBys": []
               },
-              "resumeToken": ""
+              "resumeToken": "resume-token-1000"
             }
-          }
+          },
+          "watchStreamRequestCount": 2
         }
       },
       {
         "watchAck": [
-          4
+          2
         ]
       },
       {
         "watchEntity": {
           "docs": [
             {
-              "key": "collection/a",
-              "version": 1000,
+              "key": "collection/b",
+              "version": 2000,
               "value": {
-                "key": "a"
+                "key": "b"
               },
               "options": {
                 "hasLocalMutations": false,
@@ -3312,21 +3222,21 @@
             }
           ],
           "targets": [
-            4
+            2
           ]
         }
       },
       {
         "watchCurrent": [
           [
-            4
+            2
           ],
-          "resume-token-3000"
+          "resume-token-2000"
         ]
       },
       {
         "watchSnapshot": {
-          "version": 3000,
+          "version": 2000,
           "targetIds": []
         },
         "expect": [
@@ -3338,10 +3248,10 @@
             },
             "added": [
               {
-                "key": "collection/a",
-                "version": 1000,
+                "key": "collection/b",
+                "version": 2000,
                 "value": {
-                  "key": "a"
+                  "key": "b"
                 },
                 "options": {
                   "hasLocalMutations": false,
@@ -3357,12 +3267,12 @@
       }
     ]
   },
-  "Listens are reestablished after network disconnect": {
+  "Synthesizes deletes for missing document": {
     "describeName": "Listens:",
-    "itName": "Listens are reestablished after network disconnect",
+    "itName": "Synthesizes deletes for missing document",
     "tags": [],
     "config": {
-      "useGarbageCollection": true,
+      "useGarbageCollection": false,
       "numClients": 1
     },
     "steps": [
@@ -3385,8 +3295,7 @@
               },
               "resumeToken": ""
             }
-          },
-          "watchStreamRequestCount": 1
+          }
         }
       },
       {
@@ -3407,6 +3316,17 @@
                 "hasLocalMutations": false,
                 "hasCommittedMutations": false
               }
+            },
+            {
+              "key": "collection/b",
+              "version": 1000,
+              "value": {
+                "key": "a"
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
             }
           ],
           "targets": [
@@ -3445,6 +3365,17 @@
                   "hasLocalMutations": false,
                   "hasCommittedMutations": false
                 }
+              },
+              {
+                "key": "collection/b",
+                "version": 1000,
+                "value": {
+                  "key": "a"
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
               }
             ],
             "errorCode": 0,
@@ -3454,26 +3385,34 @@
         ]
       },
       {
-        "enableNetwork": false,
-        "stateExpect": {
-          "activeTargets": {},
-          "limboDocs": []
-        },
-        "expect": [
+        "userUnlisten": [
+          2,
           {
-            "query": {
-              "path": "collection",
-              "filters": [],
-              "orderBys": []
-            },
-            "errorCode": 0,
-            "fromCache": true,
-            "hasPendingWrites": false
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
           }
-        ]
+        ],
+        "stateExpect": {
+          "activeTargets": {}
+        }
       },
       {
-        "enableNetwork": true,
+        "watchRemove": {
+          "targetIds": [
+            2
+          ]
+        }
+      },
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
         "stateExpect": {
           "activeTargets": {
             "2": {
@@ -3484,233 +3423,7 @@
               },
               "resumeToken": "resume-token-1000"
             }
-          },
-          "watchStreamRequestCount": 2
-        }
-      },
-      {
-        "watchAck": [
-          2
-        ]
-      },
-      {
-        "watchEntity": {
-          "docs": [
-            {
-              "key": "collection/b",
-              "version": 2000,
-              "value": {
-                "key": "b"
-              },
-              "options": {
-                "hasLocalMutations": false,
-                "hasCommittedMutations": false
-              }
-            }
-          ],
-          "targets": [
-            2
-          ]
-        }
-      },
-      {
-        "watchCurrent": [
-          [
-            2
-          ],
-          "resume-token-2000"
-        ]
-      },
-      {
-        "watchSnapshot": {
-          "version": 2000,
-          "targetIds": []
-        },
-        "expect": [
-          {
-            "query": {
-              "path": "collection",
-              "filters": [],
-              "orderBys": []
-            },
-            "added": [
-              {
-                "key": "collection/b",
-                "version": 2000,
-                "value": {
-                  "key": "b"
-                },
-                "options": {
-                  "hasLocalMutations": false,
-                  "hasCommittedMutations": false
-                }
-              }
-            ],
-            "errorCode": 0,
-            "fromCache": false,
-            "hasPendingWrites": false
-          }
-        ]
-      }
-    ]
-  },
-  "Synthesizes deletes for missing document": {
-    "describeName": "Listens:",
-    "itName": "Synthesizes deletes for missing document",
-    "tags": [],
-    "config": {
-      "useGarbageCollection": false,
-      "numClients": 1
-    },
-    "steps": [
-      {
-        "userListen": [
-          2,
-          {
-            "path": "collection",
-            "filters": [],
-            "orderBys": []
-          }
-        ],
-        "stateExpect": {
-          "activeTargets": {
-            "2": {
-              "query": {
-                "path": "collection",
-                "filters": [],
-                "orderBys": []
-              },
-              "resumeToken": ""
-            }
-          }
-        }
-      },
-      {
-        "watchAck": [
-          2
-        ]
-      },
-      {
-        "watchEntity": {
-          "docs": [
-            {
-              "key": "collection/a",
-              "version": 1000,
-              "value": {
-                "key": "a"
-              },
-              "options": {
-                "hasLocalMutations": false,
-                "hasCommittedMutations": false
-              }
-            },
-            {
-              "key": "collection/b",
-              "version": 1000,
-              "value": {
-                "key": "a"
-              },
-              "options": {
-                "hasLocalMutations": false,
-                "hasCommittedMutations": false
-              }
-            }
-          ],
-          "targets": [
-            2
-          ]
-        }
-      },
-      {
-        "watchCurrent": [
-          [
-            2
-          ],
-          "resume-token-1000"
-        ]
-      },
-      {
-        "watchSnapshot": {
-          "version": 1000,
-          "targetIds": []
-        },
-        "expect": [
-          {
-            "query": {
-              "path": "collection",
-              "filters": [],
-              "orderBys": []
-            },
-            "added": [
-              {
-                "key": "collection/a",
-                "version": 1000,
-                "value": {
-                  "key": "a"
-                },
-                "options": {
-                  "hasLocalMutations": false,
-                  "hasCommittedMutations": false
-                }
-              },
-              {
-                "key": "collection/b",
-                "version": 1000,
-                "value": {
-                  "key": "a"
-                },
-                "options": {
-                  "hasLocalMutations": false,
-                  "hasCommittedMutations": false
-                }
-              }
-            ],
-            "errorCode": 0,
-            "fromCache": false,
-            "hasPendingWrites": false
-          }
-        ]
-      },
-      {
-        "userUnlisten": [
-          2,
-          {
-            "path": "collection",
-            "filters": [],
-            "orderBys": []
-          }
-        ],
-        "stateExpect": {
-          "activeTargets": {}
-        }
-      },
-      {
-        "watchRemove": {
-          "targetIds": [
-            2
-          ]
-        }
-      },
-      {
-        "userListen": [
-          2,
-          {
-            "path": "collection",
-            "filters": [],
-            "orderBys": []
-          }
-        ],
-        "stateExpect": {
-          "activeTargets": {
-            "2": {
-              "query": {
-                "path": "collection",
-                "filters": [],
-                "orderBys": []
-              },
-              "resumeToken": "resume-token-1000"
-            }
-          }
+          }
         },
         "expect": [
           {
@@ -4866,9 +4579,9 @@
       }
     ]
   },
-  "Persists global resume tokens on unlisten": {
+  "Array-contains queries support resuming": {
     "describeName": "Listens:",
-    "itName": "Persists global resume tokens on unlisten",
+    "itName": "Array-contains queries support resuming",
     "tags": [],
     "config": {
       "useGarbageCollection": false,
@@ -4880,7 +4593,13 @@
           2,
           {
             "path": "collection",
-            "filters": [],
+            "filters": [
+              [
+                "array",
+                "array-contains",
+                42
+              ]
+            ],
             "orderBys": []
           }
         ],
@@ -4889,7 +4608,13 @@
             "2": {
               "query": {
                 "path": "collection",
-                "filters": [],
+                "filters": [
+                  [
+                    "array",
+                    "array-contains",
+                    42
+                  ]
+                ],
                 "orderBys": []
               },
               "resumeToken": ""
@@ -4904,19 +4629,7 @@
       },
       {
         "watchEntity": {
-          "docs": [
-            {
-              "key": "collection/a",
-              "version": 1000,
-              "value": {
-                "key": "a"
-              },
-              "options": {
-                "hasLocalMutations": false,
-                "hasCommittedMutations": false
-              }
-            }
-          ],
+          "docs": [],
           "targets": [
             2
           ]
@@ -4939,41 +4652,109 @@
           {
             "query": {
               "path": "collection",
-              "filters": [],
+              "filters": [
+                [
+                  "array",
+                  "array-contains",
+                  42
+                ]
+              ],
               "orderBys": []
             },
-            "added": [
-              {
-                "key": "collection/a",
-                "version": 1000,
-                "value": {
-                  "key": "a"
-                },
-                "options": {
-                  "hasLocalMutations": false,
-                  "hasCommittedMutations": false
-                }
-              }
-            ],
             "errorCode": 0,
             "fromCache": false,
             "hasPendingWrites": false
           }
         ]
       },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 2000,
+              "value": {
+                "array": [
+                  1,
+                  42,
+                  3
+                ],
+                "foo": "bar"
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
       {
         "watchSnapshot": {
           "version": 2000,
-          "targetIds": [],
+          "targetIds": [
+            2
+          ],
           "resumeToken": "resume-token-2000"
         }
       },
       {
-        "userUnlisten": [
-          2,
+        "watchSnapshot": {
+          "version": 2000,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [
+                [
+                  "array",
+                  "array-contains",
+                  42
+                ]
+              ],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 2000,
+                "value": {
+                  "array": [
+                    1,
+                    42,
+                    3
+                  ],
+                  "foo": "bar"
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userUnlisten": [
+          2,
           {
             "path": "collection",
-            "filters": [],
+            "filters": [
+              [
+                "array",
+                "array-contains",
+                42
+              ]
+            ],
             "orderBys": []
           }
         ],
@@ -4993,7 +4774,13 @@
           2,
           {
             "path": "collection",
-            "filters": [],
+            "filters": [
+              [
+                "array",
+                "array-contains",
+                42
+              ]
+            ],
             "orderBys": []
           }
         ],
@@ -5002,7 +4789,13 @@
             "2": {
               "query": {
                 "path": "collection",
-                "filters": [],
+                "filters": [
+                  [
+                    "array",
+                    "array-contains",
+                    42
+                  ]
+                ],
                 "orderBys": []
               },
               "resumeToken": "resume-token-2000"
@@ -5013,15 +4806,26 @@
           {
             "query": {
               "path": "collection",
-              "filters": [],
+              "filters": [
+                [
+                  "array",
+                  "array-contains",
+                  42
+                ]
+              ],
               "orderBys": []
             },
             "added": [
               {
                 "key": "collection/a",
-                "version": 1000,
+                "version": 2000,
                 "value": {
-                  "key": "a"
+                  "array": [
+                    1,
+                    42,
+                    3
+                  ],
+                  "foo": "bar"
                 },
                 "options": {
                   "hasLocalMutations": false,
@@ -5040,6 +4844,14 @@
           2
         ]
       },
+      {
+        "watchEntity": {
+          "docs": [],
+          "targets": [
+            2
+          ]
+        }
+      },
       {
         "watchCurrent": [
           [
@@ -5057,7 +4869,13 @@
           {
             "query": {
               "path": "collection",
-              "filters": [],
+              "filters": [
+                [
+                  "array",
+                  "array-contains",
+                  42
+                ]
+              ],
               "orderBys": []
             },
             "errorCode": 0,
@@ -5068,12 +4886,10 @@
       }
     ]
   },
-  "Omits global resume tokens for a short while": {
+  "Persists global resume tokens on unlisten": {
     "describeName": "Listens:",
-    "itName": "Omits global resume tokens for a short while",
-    "tags": [
-      "durable-persistence"
-    ],
+    "itName": "Persists global resume tokens on unlisten",
+    "tags": [],
     "config": {
       "useGarbageCollection": false,
       "numClients": 1
@@ -5173,10 +4989,23 @@
         }
       },
       {
-        "restart": true,
+        "userUnlisten": [
+          2,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
         "stateExpect": {
-          "activeTargets": {},
-          "limboDocs": []
+          "activeTargets": {}
+        }
+      },
+      {
+        "watchRemove": {
+          "targetIds": [
+            2
+          ]
         }
       },
       {
@@ -5196,7 +5025,7 @@
                 "filters": [],
                 "orderBys": []
               },
-              "resumeToken": "resume-token-1000"
+              "resumeToken": "resume-token-2000"
             }
           }
         },
@@ -5259,9 +5088,9 @@
       }
     ]
   },
-  "Persists global resume tokens if the snapshot is old enough": {
+  "Omits global resume tokens for a short while": {
     "describeName": "Listens:",
-    "itName": "Persists global resume tokens if the snapshot is old enough",
+    "itName": "Omits global resume tokens for a short while",
     "tags": [
       "durable-persistence"
     ],
@@ -5358,9 +5187,9 @@
       },
       {
         "watchSnapshot": {
-          "version": 300001000,
+          "version": 2000,
           "targetIds": [],
-          "resumeToken": "resume-token-minutes-later"
+          "resumeToken": "resume-token-2000"
         }
       },
       {
@@ -5387,7 +5216,7 @@
                 "filters": [],
                 "orderBys": []
               },
-              "resumeToken": "resume-token-minutes-later"
+              "resumeToken": "resume-token-1000"
             }
           }
         },
@@ -5427,12 +5256,12 @@
           [
             2
           ],
-          "resume-token-even-later"
+          "resume-token-3000"
         ]
       },
       {
         "watchSnapshot": {
-          "version": 300002000,
+          "version": 3000,
           "targetIds": []
         },
         "expect": [
@@ -5450,31 +5279,17 @@
       }
     ]
   },
-  "Query is executed by primary client": {
+  "Persists global resume tokens if the snapshot is old enough": {
     "describeName": "Listens:",
-    "itName": "Query is executed by primary client",
+    "itName": "Persists global resume tokens if the snapshot is old enough",
     "tags": [
-      "multi-client"
+      "durable-persistence"
     ],
     "config": {
       "useGarbageCollection": false,
-      "numClients": 2
+      "numClients": 1
     },
     "steps": [
-      {
-        "drainQueue": true,
-        "clientIndex": 0
-      },
-      {
-        "applyClientState": {
-          "visibility": "visible"
-        },
-        "clientIndex": 0
-      },
-      {
-        "drainQueue": true,
-        "clientIndex": 1
-      },
       {
         "userListen": [
           2,
@@ -5495,30 +5310,12 @@
               "resumeToken": ""
             }
           }
-        },
-        "clientIndex": 1
-      },
-      {
-        "drainQueue": true,
-        "stateExpect": {
-          "activeTargets": {
-            "2": {
-              "query": {
-                "path": "collection",
-                "filters": [],
-                "orderBys": []
-              },
-              "resumeToken": ""
-            }
-          }
-        },
-        "clientIndex": 0
+        }
       },
       {
         "watchAck": [
           2
-        ],
-        "clientIndex": 0
+        ]
       },
       {
         "watchEntity": {
@@ -5538,18 +5335,82 @@
           "targets": [
             2
           ]
-        },
-        "clientIndex": 0
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-1000"
+        ]
       },
       {
         "watchSnapshot": {
           "version": 1000,
           "targetIds": []
         },
-        "clientIndex": 0
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "key": "a"
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
       },
       {
-        "drainQueue": true,
+        "watchSnapshot": {
+          "version": 300001000,
+          "targetIds": [],
+          "resumeToken": "resume-token-minutes-later"
+        }
+      },
+      {
+        "restart": true,
+        "stateExpect": {
+          "activeTargets": {},
+          "limboDocs": []
+        }
+      },
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": "resume-token-minutes-later"
+            }
+          }
+        },
         "expect": [
           {
             "query": {
@@ -5574,31 +5435,26 @@
             "fromCache": true,
             "hasPendingWrites": false
           }
-        ],
-        "clientIndex": 1
+        ]
       },
       {
-        "drainQueue": true,
-        "clientIndex": 0
+        "watchAck": [
+          2
+        ]
       },
       {
         "watchCurrent": [
           [
             2
           ],
-          "resume-token-2000"
-        ],
-        "clientIndex": 0
+          "resume-token-even-later"
+        ]
       },
       {
         "watchSnapshot": {
-          "version": 2000,
+          "version": 300002000,
           "targetIds": []
         },
-        "clientIndex": 0
-      },
-      {
-        "drainQueue": true,
         "expect": [
           {
             "query": {
@@ -5610,14 +5466,178 @@
             "fromCache": false,
             "hasPendingWrites": false
           }
-        ],
-        "clientIndex": 1
+        ]
       }
     ]
   },
-  "Query is shared between primary and secondary client": {
+  "Query is executed by primary client": {
     "describeName": "Listens:",
-    "itName": "Query is shared between primary and secondary client",
+    "itName": "Query is executed by primary client",
+    "tags": [
+      "multi-client"
+    ],
+    "config": {
+      "useGarbageCollection": false,
+      "numClients": 2
+    },
+    "steps": [
+      {
+        "drainQueue": true,
+        "clientIndex": 0
+      },
+      {
+        "applyClientState": {
+          "visibility": "visible"
+        },
+        "clientIndex": 0
+      },
+      {
+        "drainQueue": true,
+        "clientIndex": 1
+      },
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "clientIndex": 1
+      },
+      {
+        "drainQueue": true,
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "clientIndex": 0
+      },
+      {
+        "watchAck": [
+          2
+        ],
+        "clientIndex": 0
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1000,
+              "value": {
+                "key": "a"
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        },
+        "clientIndex": 0
+      },
+      {
+        "watchSnapshot": {
+          "version": 1000,
+          "targetIds": []
+        },
+        "clientIndex": 0
+      },
+      {
+        "drainQueue": true,
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "key": "a"
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ],
+        "clientIndex": 1
+      },
+      {
+        "drainQueue": true,
+        "clientIndex": 0
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-2000"
+        ],
+        "clientIndex": 0
+      },
+      {
+        "watchSnapshot": {
+          "version": 2000,
+          "targetIds": []
+        },
+        "clientIndex": 0
+      },
+      {
+        "drainQueue": true,
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ],
+        "clientIndex": 1
+      }
+    ]
+  },
+  "Query is shared between primary and secondary client": {
+    "describeName": "Listens:",
+    "itName": "Query is shared between primary and secondary client",
     "tags": [
       "multi-client"
     ],
@@ -10259,5 +10279,814 @@
         "clientIndex": 0
       }
     ]
+  },
+  "onSnapshotsInSync should not fire for doc changes if there are no listeners": {
+    "describeName": "Listens:",
+    "itName": "onSnapshotsInSync should not fire for doc changes if there are no listeners",
+    "tags": [],
+    "config": {
+      "useGarbageCollection": true,
+      "numClients": 1
+    },
+    "steps": [
+      {
+        "addSnapshotsInSyncListener": true,
+        "expectedSnapshotsInSyncEvents": 1
+      },
+      {
+        "userSet": [
+          "collection/a",
+          {
+            "v": 2
+          }
+        ]
+      }
+    ]
+  },
+  "onSnapshotsInSync fires when called even if there are no local listeners": {
+    "describeName": "Listens:",
+    "itName": "onSnapshotsInSync fires when called even if there are no local listeners",
+    "tags": [],
+    "config": {
+      "useGarbageCollection": true,
+      "numClients": 1
+    },
+    "steps": [
+      {
+        "addSnapshotsInSyncListener": true,
+        "expectedSnapshotsInSyncEvents": 1
+      },
+      {
+        "addSnapshotsInSyncListener": true,
+        "expectedSnapshotsInSyncEvents": 1
+      }
+    ]
+  },
+  "onSnapshotsInSync fires for metadata changes": {
+    "describeName": "Listens:",
+    "itName": "onSnapshotsInSync fires for metadata changes",
+    "tags": [],
+    "config": {
+      "useGarbageCollection": true,
+      "numClients": 1
+    },
+    "steps": [
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          2
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1000,
+              "value": {
+                "v": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-1000"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1000,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "v": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "addSnapshotsInSyncListener": true,
+        "expectedSnapshotsInSyncEvents": 1
+      },
+      {
+        "userSet": [
+          "collection/a",
+          {
+            "v": 2
+          }
+        ],
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "modified": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "v": 2
+                },
+                "options": {
+                  "hasLocalMutations": true,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": true
+          }
+        ],
+        "expectedSnapshotsInSyncEvents": 1
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 2000,
+              "value": {
+                "v": 2
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchSnapshot": {
+          "version": 2000,
+          "targetIds": []
+        }
+      },
+      {
+        "writeAck": {
+          "version": 2000
+        },
+        "stateExpect": {
+          "userCallbacks": {
+            "acknowledgedDocs": [
+              "collection/a"
+            ],
+            "rejectedDocs": []
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "metadata": [
+              {
+                "key": "collection/a",
+                "version": 2000,
+                "value": {
+                  "v": 2
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ],
+        "expectedSnapshotsInSyncEvents": 1
+      }
+    ]
+  },
+  "onSnapshotsInSync fires once for multiple event snapshots": {
+    "describeName": "Listens:",
+    "itName": "onSnapshotsInSync fires once for multiple event snapshots",
+    "tags": [],
+    "config": {
+      "useGarbageCollection": true,
+      "numClients": 1
+    },
+    "steps": [
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          2
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1000,
+              "value": {
+                "v": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-1000"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1000,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "v": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userListen": [
+          4,
+          {
+            "path": "collection/a",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "4": {
+              "query": {
+                "path": "collection/a",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection/a",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "v": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "watchAck": [
+          4
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1000,
+              "value": {
+                "v": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            4
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            4
+          ],
+          "resume-token-1000"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1000,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection/a",
+              "filters": [],
+              "orderBys": []
+            },
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "addSnapshotsInSyncListener": true,
+        "expectedSnapshotsInSyncEvents": 1
+      },
+      {
+        "userSet": [
+          "collection/a",
+          {
+            "v": 2
+          }
+        ],
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "modified": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "v": 2
+                },
+                "options": {
+                  "hasLocalMutations": true,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": true
+          },
+          {
+            "query": {
+              "path": "collection/a",
+              "filters": [],
+              "orderBys": []
+            },
+            "modified": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "v": 2
+                },
+                "options": {
+                  "hasLocalMutations": true,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": true
+          }
+        ],
+        "expectedSnapshotsInSyncEvents": 1
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 2000,
+              "value": {
+                "v": 2
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2,
+            4
+          ]
+        }
+      },
+      {
+        "watchSnapshot": {
+          "version": 2000,
+          "targetIds": []
+        }
+      },
+      {
+        "writeAck": {
+          "version": 2000
+        },
+        "stateExpect": {
+          "userCallbacks": {
+            "acknowledgedDocs": [
+              "collection/a"
+            ],
+            "rejectedDocs": []
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "metadata": [
+              {
+                "key": "collection/a",
+                "version": 2000,
+                "value": {
+                  "v": 2
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          },
+          {
+            "query": {
+              "path": "collection/a",
+              "filters": [],
+              "orderBys": []
+            },
+            "metadata": [
+              {
+                "key": "collection/a",
+                "version": 2000,
+                "value": {
+                  "v": 2
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ],
+        "expectedSnapshotsInSyncEvents": 1
+      }
+    ]
+  },
+  "onSnapshotsInSync fires for multiple listeners": {
+    "describeName": "Listens:",
+    "itName": "onSnapshotsInSync fires for multiple listeners",
+    "tags": [],
+    "config": {
+      "useGarbageCollection": true,
+      "numClients": 1
+    },
+    "steps": [
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          2
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1000,
+              "value": {
+                "v": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-1000"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1000,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "v": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "addSnapshotsInSyncListener": true,
+        "expectedSnapshotsInSyncEvents": 1
+      },
+      {
+        "userSet": [
+          "collection/a",
+          {
+            "v": 2
+          }
+        ],
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "modified": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "v": 2
+                },
+                "options": {
+                  "hasLocalMutations": true,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": true
+          }
+        ],
+        "expectedSnapshotsInSyncEvents": 1
+      },
+      {
+        "addSnapshotsInSyncListener": true,
+        "expectedSnapshotsInSyncEvents": 1
+      },
+      {
+        "addSnapshotsInSyncListener": true,
+        "expectedSnapshotsInSyncEvents": 1
+      },
+      {
+        "userSet": [
+          "collection/a",
+          {
+            "v": 3
+          }
+        ],
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "modified": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "v": 3
+                },
+                "options": {
+                  "hasLocalMutations": true,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": true
+          }
+        ],
+        "expectedSnapshotsInSyncEvents": 3
+      },
+      {
+        "removeSnapshotsInSyncListener": true
+      },
+      {
+        "userSet": [
+          "collection/a",
+          {
+            "v": 4
+          }
+        ],
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "modified": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "v": 4
+                },
+                "options": {
+                  "hasLocalMutations": true,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": true
+          }
+        ],
+        "expectedSnapshotsInSyncEvents": 2
+      }
+    ]
   }
 }
diff --git a/firebase-firestore/src/test/resources/json/orderby_spec_test.json b/firebase-firestore/src/test/resources/json/orderby_spec_test.json
index 5bb59c4ee..90246bb6b 100644
--- a/firebase-firestore/src/test/resources/json/orderby_spec_test.json
+++ b/firebase-firestore/src/test/resources/json/orderby_spec_test.json
@@ -219,7 +219,7 @@
           "docs": [
             {
               "key": "collection/a",
-              "version": 0,
+              "version": 1000,
               "value": {
                 "key": "a",
                 "sort": 2
@@ -252,12 +252,12 @@
           [
             2
           ],
-          "resume-token-1000"
+          "resume-token-1002"
         ]
       },
       {
         "watchSnapshot": {
-          "version": 1000,
+          "version": 1002,
           "targetIds": []
         },
         "expect": [
@@ -287,7 +287,7 @@
               },
               {
                 "key": "collection/a",
-                "version": 0,
+                "version": 1000,
                 "value": {
                   "key": "a",
                   "sort": 2
@@ -356,7 +356,7 @@
                   ]
                 ]
               },
-              "resumeToken": "resume-token-1000"
+              "resumeToken": "resume-token-1002"
             }
           }
         },
@@ -387,7 +387,7 @@
               },
               {
                 "key": "collection/a",
-                "version": 0,
+                "version": 1000,
                 "value": {
                   "key": "a",
                   "sort": 2
@@ -422,12 +422,12 @@
           [
             2
           ],
-          "resume-token-1000"
+          "resume-token-1002"
         ]
       },
       {
         "watchSnapshot": {
-          "version": 1000,
+          "version": 1002,
           "targetIds": []
         },
         "expect": [
diff --git a/firebase-firestore/src/test/resources/json/persistence_spec_test.json b/firebase-firestore/src/test/resources/json/persistence_spec_test.json
index 9d2289eba..2da72f8e3 100644
--- a/firebase-firestore/src/test/resources/json/persistence_spec_test.json
+++ b/firebase-firestore/src/test/resources/json/persistence_spec_test.json
@@ -1284,18 +1284,16 @@
       },
       {
         "drainQueue": true,
-        "clientIndex": 1
-      },
-      {
-        "expectIsShutdown": true,
+        "stateExpect": {
+          "isShutdown": true
+        },
         "clientIndex": 1
       },
       {
         "drainQueue": true,
-        "clientIndex": 2
-      },
-      {
-        "expectIsShutdown": true,
+        "stateExpect": {
+          "isShutdown": true
+        },
         "clientIndex": 2
       }
     ]
diff --git a/firebase-firestore/src/test/resources/json/query_spec_test.json b/firebase-firestore/src/test/resources/json/query_spec_test.json
index 4ca89f24c..2501ede33 100644
--- a/firebase-firestore/src/test/resources/json/query_spec_test.json
+++ b/firebase-firestore/src/test/resources/json/query_spec_test.json
@@ -1166,5 +1166,208 @@
         ]
       }
     ]
+  },
+  "Latency-compensated updates are included in query results": {
+    "describeName": "Queries:",
+    "itName": "Latency-compensated updates are included in query results",
+    "tags": [],
+    "config": {
+      "useGarbageCollection": true,
+      "numClients": 1
+    },
+    "steps": [
+      {
+        "userListen": [
+          2,
+          {
+            "path": "collection",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          2
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "collection/a",
+              "version": 1000,
+              "value": {
+                "match": false
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-1000"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1000,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "match": false
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userPatch": [
+          "collection/a",
+          {
+            "match": true
+          }
+        ],
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [],
+              "orderBys": []
+            },
+            "modified": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "match": true
+                },
+                "options": {
+                  "hasLocalMutations": true,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": true
+          }
+        ]
+      },
+      {
+        "userListen": [
+          4,
+          {
+            "path": "collection",
+            "filters": [
+              [
+                "match",
+                "==",
+                true
+              ]
+            ],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "collection",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "4": {
+              "query": {
+                "path": "collection",
+                "filters": [
+                  [
+                    "match",
+                    "==",
+                    true
+                  ]
+                ],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "collection",
+              "filters": [
+                [
+                  "match",
+                  "==",
+                  true
+                ]
+              ],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "collection/a",
+                "version": 1000,
+                "value": {
+                  "match": true
+                },
+                "options": {
+                  "hasLocalMutations": true,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": true
+          }
+        ]
+      }
+    ]
   }
 }
diff --git a/firebase-firestore/src/testUtil/java/com/google/firebase/firestore/testutil/TestTargetMetadataProvider.java b/firebase-firestore/src/testUtil/java/com/google/firebase/firestore/testutil/TestTargetMetadataProvider.java
new file mode 100644
index 000000000..fa198ce60
--- /dev/null
+++ b/firebase-firestore/src/testUtil/java/com/google/firebase/firestore/testutil/TestTargetMetadataProvider.java
@@ -0,0 +1,49 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.testutil;
+
+import com.google.firebase.database.collection.ImmutableSortedSet;
+import com.google.firebase.firestore.local.QueryData;
+import com.google.firebase.firestore.model.DocumentKey;
+import com.google.firebase.firestore.remote.WatchChangeAggregator;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * An implementation of TargetMetadataProvider that provides controlled access to the
+ * `TargetMetadataProvider` callbacks. Any target accessed via these callbacks must be registered
+ * beforehand via `setSyncedKeys()`.
+ */
+public class TestTargetMetadataProvider implements WatchChangeAggregator.TargetMetadataProvider {
+  final Map<Integer, ImmutableSortedSet<DocumentKey>> syncedKeys = new HashMap<>();
+  final Map<Integer, QueryData> queryData = new HashMap<>();
+
+  @Override
+  public ImmutableSortedSet<DocumentKey> getRemoteKeysForTarget(int targetId) {
+    return syncedKeys.get(targetId) != null ? syncedKeys.get(targetId) : DocumentKey.emptyKeySet();
+  }
+
+  @androidx.annotation.Nullable
+  @Override
+  public QueryData getQueryDataForTarget(int targetId) {
+    return queryData.get(targetId);
+  }
+
+  /** Sets or replaces the local state for the provided query data. */
+  public void setSyncedKeys(QueryData queryData, ImmutableSortedSet<DocumentKey> keys) {
+    this.queryData.put(queryData.getTargetId(), queryData);
+    this.syncedKeys.put(queryData.getTargetId(), keys);
+  }
+}
diff --git a/firebase-firestore/src/testUtil/java/com/google/firebase/firestore/testutil/TestUtil.java b/firebase-firestore/src/testUtil/java/com/google/firebase/firestore/testutil/TestUtil.java
index 27caae9bb..596dc49a9 100644
--- a/firebase-firestore/src/testUtil/java/com/google/firebase/firestore/testutil/TestUtil.java
+++ b/firebase-firestore/src/testUtil/java/com/google/firebase/firestore/testutil/TestUtil.java
@@ -20,9 +20,10 @@
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.fail;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.android.gms.common.internal.Preconditions;
 import com.google.common.base.Charsets;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
@@ -33,6 +34,7 @@
 import com.google.firebase.firestore.DocumentReference;
 import com.google.firebase.firestore.TestAccessHelper;
 import com.google.firebase.firestore.UserDataConverter;
+import com.google.firebase.firestore.core.FieldFilter;
 import com.google.firebase.firestore.core.Filter;
 import com.google.firebase.firestore.core.Filter.Operator;
 import com.google.firebase.firestore.core.OrderBy;
@@ -64,6 +66,7 @@
 import com.google.firebase.firestore.model.value.ObjectValue;
 import com.google.firebase.firestore.remote.RemoteEvent;
 import com.google.firebase.firestore.remote.TargetChange;
+import com.google.firebase.firestore.remote.WatchChange;
 import com.google.firebase.firestore.remote.WatchChange.DocumentChange;
 import com.google.firebase.firestore.remote.WatchChangeAggregator;
 import com.google.protobuf.ByteString;
@@ -175,21 +178,21 @@ public static SnapshotVersion version(long versionMicros) {
 
   public static Document doc(String key, long version, Map<String, Object> data) {
     return new Document(
-        key(key), version(version), wrapObject(data), Document.DocumentState.SYNCED);
+        key(key), version(version), Document.DocumentState.SYNCED, wrapObject(data));
   }
 
   public static Document doc(DocumentKey key, long version, Map<String, Object> data) {
-    return new Document(key, version(version), wrapObject(data), Document.DocumentState.SYNCED);
+    return new Document(key, version(version), Document.DocumentState.SYNCED, wrapObject(data));
   }
 
   public static Document doc(
       String key, long version, ObjectValue data, Document.DocumentState documentState) {
-    return new Document(key(key), version(version), data, documentState);
+    return new Document(key(key), version(version), documentState, data);
   }
 
   public static Document doc(
       String key, long version, Map<String, Object> data, Document.DocumentState documentState) {
-    return new Document(key(key), version(version), wrapObject(data), documentState);
+    return new Document(key(key), version(version), documentState, wrapObject(data));
   }
 
   public static NoDocument deletedDoc(String key, long version) {
@@ -220,8 +223,13 @@ public static DocumentSet docSet(Comparator<Document> comparator, Document... do
     return keySet;
   }
 
-  public static Filter filter(String key, String operator, Object value) {
-    return Filter.create(field(key), operatorFromString(operator), wrap(value));
+  public static FieldFilter filter(String key, String operator, Object value) {
+    Filter filter = FieldFilter.create(field(key), operatorFromString(operator), wrap(value));
+    if (filter instanceof FieldFilter) {
+      return (FieldFilter) filter;
+    } else {
+      throw new IllegalArgumentException("Unrecognized filter: " + filter.toString());
+    }
   }
 
   public static Operator operatorFromString(String s) {
@@ -237,6 +245,10 @@ public static Operator operatorFromString(String s) {
       return Operator.GREATER_THAN_OR_EQUAL;
     } else if (s.equals("array-contains")) {
       return Operator.ARRAY_CONTAINS;
+    } else if (s.equals("in")) {
+      return Operator.IN;
+    } else if (s.equals("array-contains-any")) {
+      return Operator.ARRAY_CONTAINS_ANY;
     } else {
       throw new IllegalStateException("Unknown operator: " + s);
     }
@@ -364,10 +376,33 @@ public static TargetChange ackTarget(Document... docs) {
     return activeLimboQueries(docKey, asList(targets));
   }
 
+  public static RemoteEvent noChangeEvent(int targetId, int version) {
+    return noChangeEvent(targetId, version, resumeToken(version));
+  }
+
+  public static RemoteEvent noChangeEvent(int targetId, int version, ByteString resumeToken) {
+    QueryData queryData = TestUtil.queryData(targetId, QueryPurpose.LISTEN, "foo/bar");
+    TestTargetMetadataProvider testTargetMetadataProvider = new TestTargetMetadataProvider();
+    testTargetMetadataProvider.setSyncedKeys(queryData, DocumentKey.emptyKeySet());
+
+    WatchChangeAggregator aggregator = new WatchChangeAggregator(testTargetMetadataProvider);
+
+    WatchChange.WatchTargetChange watchChange =
+        new WatchChange.WatchTargetChange(
+            WatchChange.WatchTargetChangeType.NoChange, asList(targetId), resumeToken);
+    aggregator.handleTargetChange(watchChange);
+    return aggregator.createRemoteEvent(version(version));
+  }
+
   public static RemoteEvent addedRemoteEvent(
       MaybeDocument doc, List<Integer> updatedInTargets, List<Integer> removedFromTargets) {
-    DocumentChange change =
-        new DocumentChange(updatedInTargets, removedFromTargets, doc.getKey(), doc);
+    return addedRemoteEvent(Collections.singletonList(doc), updatedInTargets, removedFromTargets);
+  }
+
+  public static RemoteEvent addedRemoteEvent(
+      List<MaybeDocument> docs, List<Integer> updatedInTargets, List<Integer> removedFromTargets) {
+    Preconditions.checkArgument(!docs.isEmpty(), "Cannot pass empty docs array");
+
     WatchChangeAggregator aggregator =
         new WatchChangeAggregator(
             new WatchChangeAggregator.TargetMetadataProvider() {
@@ -378,23 +413,36 @@ public static RemoteEvent addedRemoteEvent(
 
               @Override
               public QueryData getQueryDataForTarget(int targetId) {
-                return queryData(targetId, QueryPurpose.LISTEN, doc.getKey().toString());
+                ResourcePath collectionPath = docs.get(0).getKey().getPath().popLast();
+                return queryData(targetId, QueryPurpose.LISTEN, collectionPath.toString());
               }
             });
-    aggregator.handleDocumentChange(change);
-    return aggregator.createRemoteEvent(doc.getVersion());
+
+    SnapshotVersion version = SnapshotVersion.NONE;
+
+    for (MaybeDocument doc : docs) {
+      DocumentChange change =
+          new DocumentChange(updatedInTargets, removedFromTargets, doc.getKey(), doc);
+      aggregator.handleDocumentChange(change);
+      version = doc.getVersion().compareTo(version) > 0 ? doc.getVersion() : version;
+    }
+
+    return aggregator.createRemoteEvent(version);
   }
 
   public static RemoteEvent updateRemoteEvent(
       MaybeDocument doc, List<Integer> updatedInTargets, List<Integer> removedFromTargets) {
-    return updateRemoteEvent(doc, updatedInTargets, removedFromTargets, Collections.emptyList());
+    List<Integer> activeTargets = new ArrayList<>();
+    activeTargets.addAll(updatedInTargets);
+    activeTargets.addAll(removedFromTargets);
+    return updateRemoteEvent(doc, updatedInTargets, removedFromTargets, activeTargets);
   }
 
   public static RemoteEvent updateRemoteEvent(
       MaybeDocument doc,
       List<Integer> updatedInTargets,
       List<Integer> removedFromTargets,
-      List<Integer> limboTargets) {
+      List<Integer> activeTargets) {
     DocumentChange change =
         new DocumentChange(updatedInTargets, removedFromTargets, doc.getKey(), doc);
     WatchChangeAggregator aggregator =
@@ -407,11 +455,9 @@ public static RemoteEvent updateRemoteEvent(
 
               @Override
               public QueryData getQueryDataForTarget(int targetId) {
-                boolean isLimbo =
-                    !(updatedInTargets.contains(targetId) || removedFromTargets.contains(targetId));
-                QueryPurpose purpose =
-                    isLimbo ? QueryPurpose.LIMBO_RESOLUTION : QueryPurpose.LISTEN;
-                return queryData(targetId, purpose, doc.getKey().toString());
+                return activeTargets.contains(targetId)
+                    ? queryData(targetId, QueryPurpose.LISTEN, doc.getKey().toString())
+                    : null;
               }
             });
     aggregator.handleDocumentChange(change);
@@ -480,7 +526,7 @@ public static MutationResult mutationResult(long version) {
   }
 
   public static LocalViewChanges viewChanges(
-      int targetId, List<String> addedKeys, List<String> removedKeys) {
+      int targetId, boolean fromCache, List<String> addedKeys, List<String> removedKeys) {
     ImmutableSortedSet<DocumentKey> added = DocumentKey.emptyKeySet();
     for (String keyPath : addedKeys) {
       added = added.insert(key(keyPath));
@@ -489,7 +535,7 @@ public static LocalViewChanges viewChanges(
     for (String keyPath : removedKeys) {
       removed = removed.insert(key(keyPath));
     }
-    return new LocalViewChanges(targetId, added, removed);
+    return new LocalViewChanges(targetId, fromCache, added, removed);
   }
 
   /** Creates a resume token to match the given snapshot version. */
diff --git a/firebase-functions/api.txt b/firebase-functions/api.txt
new file mode 100644
index 000000000..042d8c05b
--- /dev/null
+++ b/firebase-functions/api.txt
@@ -0,0 +1,51 @@
+// Signature format: 2.0
+package com.google.firebase.functions {
+
+  public class FirebaseFunctions {
+    method @NonNull public com.google.firebase.functions.HttpsCallableReference getHttpsCallable(@NonNull String);
+    method @NonNull public static com.google.firebase.functions.FirebaseFunctions getInstance(@NonNull FirebaseApp, @NonNull String);
+    method @NonNull public static com.google.firebase.functions.FirebaseFunctions getInstance(@NonNull FirebaseApp);
+    method @NonNull public static com.google.firebase.functions.FirebaseFunctions getInstance(@NonNull String);
+    method @NonNull public static com.google.firebase.functions.FirebaseFunctions getInstance();
+    method public void useFunctionsEmulator(@NonNull String);
+  }
+
+  public class FirebaseFunctionsException {
+    method @NonNull public com.google.firebase.functions.FirebaseFunctionsException.Code getCode();
+    method @Nullable public Object getDetails();
+  }
+
+  public enum FirebaseFunctionsException.Code {
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code ABORTED;
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code ALREADY_EXISTS;
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code CANCELLED;
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code DATA_LOSS;
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code DEADLINE_EXCEEDED;
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code FAILED_PRECONDITION;
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code INTERNAL;
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code INVALID_ARGUMENT;
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code NOT_FOUND;
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code OK;
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code OUT_OF_RANGE;
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code PERMISSION_DENIED;
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code RESOURCE_EXHAUSTED;
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code UNAUTHENTICATED;
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code UNAVAILABLE;
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code UNIMPLEMENTED;
+    enum_constant public static final com.google.firebase.functions.FirebaseFunctionsException.Code UNKNOWN;
+  }
+
+  public class HttpsCallableReference {
+    method @NonNull public Task<HttpsCallableResult> call(@Nullable Object);
+    method @NonNull public Task<HttpsCallableResult> call();
+    method public long getTimeout();
+    method public void setTimeout(long, @NonNull TimeUnit);
+    method @NonNull public com.google.firebase.functions.HttpsCallableReference withTimeout(long, @NonNull TimeUnit);
+  }
+
+  public class HttpsCallableResult {
+    method @Nullable public Object getData();
+  }
+
+}
+
diff --git a/firebase-functions/firebase-functions.gradle b/firebase-functions/firebase-functions.gradle
index 690a4bf51..5123122de 100644
--- a/firebase-functions/firebase-functions.gradle
+++ b/firebase-functions/firebase-functions.gradle
@@ -29,10 +29,10 @@ android {
     compileSdkVersion project.targetSdkVersion
     defaultConfig {
         targetSdkVersion project.targetSdkVersion
-        minSdkVersion project.minSdkVersion
+        minSdkVersion 16
         versionName version
         multiDexEnabled true
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
     }
     sourceSets {
         androidTest {
@@ -50,33 +50,33 @@ android {
 
 dependencies {
     implementation project(':firebase-common')
-    implementation "com.google.android.gms:play-services-basement:$playServicesVersion"
-    implementation "com.google.android.gms:play-services-base:$playServicesVersion"
-    implementation "com.google.android.gms:play-services-tasks:$playServicesVersion"
-    implementation ('com.google.firebase:firebase-iid:17.0.3') {
+    implementation 'com.google.android.gms:play-services-basement:17.0.0'
+    implementation 'com.google.android.gms:play-services-base:17.0.0'
+    implementation 'com.google.android.gms:play-services-tasks:17.0.0'
+    implementation ('com.google.firebase:firebase-iid:19.0.0') {
         exclude group: 'com.google.firebase', module: 'firebase-common'
     }
-    implementation ('com.google.firebase:firebase-auth-interop:17.0.0') {
+    implementation ('com.google.firebase:firebase-auth-interop:18.0.0') {
         exclude group: 'com.google.firebase', module: 'firebase-common'
     }
-    implementation 'com.google.firebase:firebase-iid-interop:16.0.1'
+    implementation 'com.google.firebase:firebase-iid-interop:17.0.0'
 
     implementation 'com.squareup.okhttp3:okhttp:3.12.1'
 
-    annotationProcessor 'com.google.auto.value:auto-value:1.6'
+    annotationProcessor 'com.google.auto.value:auto-value:1.6.2'
 
     androidTestImplementation 'junit:junit:4.12'
     androidTestImplementation "com.google.truth:truth:$googleTruthVersion"
-    androidTestImplementation 'com.android.support.test:runner:1.0.2'
-    androidTestImplementation 'org.mockito:mockito-core:2.21.0'
-    androidTestImplementation 'com.linkedin.dexmaker:dexmaker:2.16.0'
-    androidTestImplementation 'com.linkedin.dexmaker:dexmaker-mockito:2.16.0'
+    androidTestImplementation 'androidx.test:runner:1.2.0'
+    androidTestImplementation 'org.mockito:mockito-core:2.25.0'
+    androidTestImplementation 'com.linkedin.dexmaker:dexmaker:2.25.0'
+    androidTestImplementation 'com.linkedin.dexmaker:dexmaker-mockito:2.25.0'
 
     testImplementation 'junit:junit:4.12'
-    testImplementation 'org.mockito:mockito-core:2.21.0'
+    testImplementation 'org.mockito:mockito-core:2.25.0'
     testImplementation "org.robolectric:robolectric:$robolectricVersion"
     testImplementation "com.google.truth:truth:$googleTruthVersion"
-    testImplementation 'com.android.support.test:rules:1.0.2'
+    testImplementation 'androidx.test:rules:1.2.0'
 }
 
 // ==========================================================================
diff --git a/firebase-functions/gradle.properties b/firebase-functions/gradle.properties
index 4c7da9c12..52a034746 100644
--- a/firebase-functions/gradle.properties
+++ b/firebase-functions/gradle.properties
@@ -1,3 +1,3 @@
-version=16.3.1
-latestReleasedVersion=16.3.0
+version=19.0.2
+latestReleasedVersion=19.0.1
 android.enableUnitTestBinaryResources=true
diff --git a/firebase-functions/ktx/ktx.gradle b/firebase-functions/ktx/ktx.gradle
index a60e95a62..f2ce73b26 100644
--- a/firebase-functions/ktx/ktx.gradle
+++ b/firebase-functions/ktx/ktx.gradle
@@ -27,11 +27,11 @@ firebaseLibrary {
 android {
     compileSdkVersion project.targetSdkVersion
     defaultConfig {
-        minSdkVersion project.minSdkVersion
+        minSdkVersion 16
         multiDexEnabled true
         targetSdkVersion project.targetSdkVersion
         versionName version
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
     }
     sourceSets {
         main.java.srcDirs += 'src/main/kotlin'
@@ -49,12 +49,12 @@ dependencies {
     implementation project(':firebase-common')
     implementation project(':firebase-common:ktx')
     implementation project(':firebase-functions')
-    implementation 'com.android.support:support-annotations:28.0.0'
-    implementation 'com.google.android.gms:play-services-tasks:16.0.1'
+    implementation 'androidx.annotation:annotation:1.1.0'
+    implementation 'com.google.android.gms:play-services-tasks:17.0.0'
 
     androidTestImplementation 'junit:junit:4.12'
     androidTestImplementation "com.google.truth:truth:$googleTruthVersion"
-    androidTestImplementation 'com.android.support.test:runner:1.0.2'
+    androidTestImplementation 'androidx.test:runner:1.2.0'
 
     testImplementation "org.robolectric:robolectric:$robolectricVersion"
     testImplementation 'junit:junit:4.12'
diff --git a/firebase-functions/ktx/src/androidTest/AndroidManifest.xml b/firebase-functions/ktx/src/androidTest/AndroidManifest.xml
index 53cd9caa0..e00dc0c7e 100644
--- a/firebase-functions/ktx/src/androidTest/AndroidManifest.xml
+++ b/firebase-functions/ktx/src/androidTest/AndroidManifest.xml
@@ -1,7 +1,7 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
   package="com.google.firebase.functions.ktx">
   <!--Although the *SdkVersion is captured in gradle build files, this is required for non gradle builds-->
-  <!--<uses-sdk android:minSdkVersion="15" android:targetSdkVersion="23" />-->
+  <!--<uses-sdk android:minSdkVersion="16" android:targetSdkVersion="23" />-->
   <uses-permission android:name="android.permission.INTERNET"/>
   <application
       android:usesCleartextTraffic="true">
diff --git a/firebase-functions/ktx/src/androidTest/kotlin/com/google/firebase/functions/ktx/CallTests.kt b/firebase-functions/ktx/src/androidTest/kotlin/com/google/firebase/functions/ktx/CallTests.kt
index 13dbd94b8..fac9c468e 100644
--- a/firebase-functions/ktx/src/androidTest/kotlin/com/google/firebase/functions/ktx/CallTests.kt
+++ b/firebase-functions/ktx/src/androidTest/kotlin/com/google/firebase/functions/ktx/CallTests.kt
@@ -24,8 +24,8 @@ import org.junit.AfterClass
 import org.junit.BeforeClass
 import org.junit.Test
 import org.junit.runner.RunWith
-import android.support.test.InstrumentationRegistry
-import android.support.test.runner.AndroidJUnit4
+import androidx.test.InstrumentationRegistry
+import androidx.test.runner.AndroidJUnit4
 
 const val APP_ID = "APP_ID"
 const val API_KEY = "API_KEY"
diff --git a/firebase-functions/ktx/src/main/AndroidManifest.xml b/firebase-functions/ktx/src/main/AndroidManifest.xml
index 8eda8b99b..bcdb80660 100644
--- a/firebase-functions/ktx/src/main/AndroidManifest.xml
+++ b/firebase-functions/ktx/src/main/AndroidManifest.xml
@@ -2,7 +2,7 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.google.firebase.functions.ktx">
     <!--Although the *SdkVersion is captured in gradle build files, this is required for non gradle builds-->
-    <!--<uses-sdk android:minSdkVersion="14"/>-->
+    <!--<uses-sdk android:minSdkVersion="16"/>-->
     <application>
         <service android:name="com.google.firebase.components.ComponentDiscoveryService" android:exported="false">
             <meta-data android:name="com.google.firebase.components:com.google.firebase.functions.ktx.FirebaseFunctionsKtxRegistrar"
diff --git a/firebase-functions/ktx/src/main/kotlin/com/google/firebase/functions/ktx/Functions.kt b/firebase-functions/ktx/src/main/kotlin/com/google/firebase/functions/ktx/Functions.kt
index e98fc8098..9e87b219c 100644
--- a/firebase-functions/ktx/src/main/kotlin/com/google/firebase/functions/ktx/Functions.kt
+++ b/firebase-functions/ktx/src/main/kotlin/com/google/firebase/functions/ktx/Functions.kt
@@ -14,7 +14,7 @@
 
 package com.google.firebase.functions.ktx
 
-import android.support.annotation.Keep
+import androidx.annotation.Keep
 import com.google.firebase.FirebaseApp
 import com.google.firebase.functions.FirebaseFunctions
 import com.google.firebase.components.Component
diff --git a/firebase-functions/ktx/src/test/kotlin/com/google/firebase/functions/ktx/FunctionsTests.kt b/firebase-functions/ktx/src/test/kotlin/com/google/firebase/functions/ktx/FunctionsTests.kt
index 57c603276..4370b6de8 100644
--- a/firebase-functions/ktx/src/test/kotlin/com/google/firebase/functions/ktx/FunctionsTests.kt
+++ b/firebase-functions/ktx/src/test/kotlin/com/google/firebase/functions/ktx/FunctionsTests.kt
@@ -68,26 +68,26 @@ class FunctionsTests : BaseTestCase() {
 
     @Test
     fun `functions should delegate to FirebaseFunctions#getInstance()`() {
-        assertThat(Firebase.functions).isSameAs(FirebaseFunctions.getInstance())
+        assertThat(Firebase.functions).isSameInstanceAs(FirebaseFunctions.getInstance())
     }
 
     @Test
     fun `FirebaseApp#functions should delegate to FirebaseFunctions#getInstance(FirebaseApp)`() {
         val app = Firebase.app(EXISTING_APP)
-        assertThat(Firebase.functions(app)).isSameAs(FirebaseFunctions.getInstance(app))
+        assertThat(Firebase.functions(app)).isSameInstanceAs(FirebaseFunctions.getInstance(app))
     }
 
     @Test
     fun `Firebase#functions should delegate to FirebaseFunctions#getInstance(region)`() {
         val region = "valid_region"
-        assertThat(Firebase.functions(region)).isSameAs(FirebaseFunctions.getInstance(region))
+        assertThat(Firebase.functions(region)).isSameInstanceAs(FirebaseFunctions.getInstance(region))
     }
 
     @Test
     fun `Firebase#functions should delegate to FirebaseFunctions#getInstance(FirebaseApp, region)`() {
         val app = Firebase.app(EXISTING_APP)
         val region = "valid_region"
-        assertThat(Firebase.functions(app, region)).isSameAs(FirebaseFunctions.getInstance(app, region))
+        assertThat(Firebase.functions(app, region)).isSameInstanceAs(FirebaseFunctions.getInstance(app, region))
     }
 }
 
diff --git a/firebase-functions/src/androidTest/java/com/google/firebase/functions/CallTest.java b/firebase-functions/src/androidTest/java/com/google/firebase/functions/CallTest.java
index ae1095cc5..a6f38d568 100644
--- a/firebase-functions/src/androidTest/java/com/google/firebase/functions/CallTest.java
+++ b/firebase-functions/src/androidTest/java/com/google/firebase/functions/CallTest.java
@@ -20,8 +20,8 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.Tasks;
 import com.google.firebase.FirebaseApp;
@@ -220,6 +220,7 @@ public void testTimeout() {
 
     HttpsCallableReference function =
         functions.getHttpsCallable("timeoutTest").withTimeout(10, TimeUnit.MILLISECONDS);
+    assertEquals(10, function.getTimeout());
     Task<HttpsCallableResult> result = function.call();
     ExecutionException exe = assertThrows(ExecutionException.class, () -> Tasks.await(result));
     Throwable cause = exe.getCause();
diff --git a/firebase-functions/src/androidTest/java/com/google/firebase/functions/FirebaseFunctionsTest.java b/firebase-functions/src/androidTest/java/com/google/firebase/functions/FirebaseFunctionsTest.java
index ced0a3c3d..41873cdc0 100644
--- a/firebase-functions/src/androidTest/java/com/google/firebase/functions/FirebaseFunctionsTest.java
+++ b/firebase-functions/src/androidTest/java/com/google/firebase/functions/FirebaseFunctionsTest.java
@@ -18,8 +18,8 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.FirebaseApp;
 import java.net.URL;
 import org.junit.Before;
diff --git a/firebase-functions/src/androidTest/java/com/google/firebase/functions/SerializerTest.java b/firebase-functions/src/androidTest/java/com/google/firebase/functions/SerializerTest.java
index f0ad44967..fa016d241 100644
--- a/firebase-functions/src/androidTest/java/com/google/firebase/functions/SerializerTest.java
+++ b/firebase-functions/src/androidTest/java/com/google/firebase/functions/SerializerTest.java
@@ -17,7 +17,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.runner.AndroidJUnit4;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
diff --git a/firebase-functions/src/main/AndroidManifest.xml b/firebase-functions/src/main/AndroidManifest.xml
index 5839314f9..0fd428d93 100644
--- a/firebase-functions/src/main/AndroidManifest.xml
+++ b/firebase-functions/src/main/AndroidManifest.xml
@@ -3,7 +3,7 @@
         xmlns:tools="http://schemas.android.com/tools"
         package="com.google.firebase.functions">
     <!--Although the *SdkVersion is captured in gradle build files, this is required for non gradle builds-->
-    <!--<uses-sdk android:minSdkVersion="14" />-->
+    <!--<uses-sdk android:minSdkVersion="16" />-->
     <uses-permission android:name="android.permission.INTERNET" />
     <application>
         <service android:name="com.google.firebase.components.ComponentDiscoveryService" android:exported="false">
diff --git a/firebase-functions/src/main/java/com/google/firebase/functions/FirebaseContextProvider.java b/firebase-functions/src/main/java/com/google/firebase/functions/FirebaseContextProvider.java
index 8a7d87e62..b4e1cecd6 100644
--- a/firebase-functions/src/main/java/com/google/firebase/functions/FirebaseContextProvider.java
+++ b/firebase-functions/src/main/java/com/google/firebase/functions/FirebaseContextProvider.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.functions;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.firebase.auth.internal.InternalAuthProvider;
diff --git a/firebase-functions/src/main/java/com/google/firebase/functions/FirebaseFunctions.java b/firebase-functions/src/main/java/com/google/firebase/functions/FirebaseFunctions.java
index 136c04b3a..ae9137fa0 100644
--- a/firebase-functions/src/main/java/com/google/firebase/functions/FirebaseFunctions.java
+++ b/firebase-functions/src/main/java/com/google/firebase/functions/FirebaseFunctions.java
@@ -16,10 +16,10 @@
 
 import android.content.Context;
 import android.os.Handler;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.security.ProviderInstaller;
 import com.google.android.gms.security.ProviderInstaller.ProviderInstallListener;
@@ -122,13 +122,13 @@ public void onProviderInstallFailed(int i, android.content.Intent intent) {
     handler.post(runnable);
   }
 
-  @NonNull
   /**
    * Creates a Cloud Functions client with the given app and region.
    *
    * @param app The app for the Firebase project.
    * @param region The region for the HTTPS trigger, such as "us-central1".
    */
+  @NonNull
   public static FirebaseFunctions getInstance(@NonNull FirebaseApp app, @NonNull String region) {
     Preconditions.checkNotNull(app, "You must call FirebaseApp.initializeApp first.");
     Preconditions.checkNotNull(region);
@@ -139,34 +139,34 @@ public static FirebaseFunctions getInstance(@NonNull FirebaseApp app, @NonNull S
     return component.get(region);
   }
 
-  @NonNull
   /**
    * Creates a Cloud Functions client with the given app.
    *
    * @param app The app for the Firebase project.
    */
+  @NonNull
   public static FirebaseFunctions getInstance(@NonNull FirebaseApp app) {
     return getInstance(app, "us-central1");
   }
 
-  @NonNull
   /**
    * Creates a Cloud Functions client with the default app and given region.
    *
    * @param region The region for the HTTPS trigger, such as "us-central1".
    */
+  @NonNull
   public static FirebaseFunctions getInstance(@NonNull String region) {
     return getInstance(FirebaseApp.getInstance(), region);
   }
 
-  @NonNull
   /** Creates a Cloud Functions client with the default app. */
+  @NonNull
   public static FirebaseFunctions getInstance() {
     return getInstance(FirebaseApp.getInstance(), "us-central1");
   }
 
-  @NonNull
   /** Returns a reference to the Callable HTTPS trigger with the given name. */
+  @NonNull
   public HttpsCallableReference getHttpsCallable(@NonNull String name) {
     return new HttpsCallableReference(this, name);
   }
diff --git a/firebase-functions/src/main/java/com/google/firebase/functions/FirebaseFunctionsException.java b/firebase-functions/src/main/java/com/google/firebase/functions/FirebaseFunctionsException.java
index 96d33b6d8..6ea90bda9 100644
--- a/firebase-functions/src/main/java/com/google/firebase/functions/FirebaseFunctionsException.java
+++ b/firebase-functions/src/main/java/com/google/firebase/functions/FirebaseFunctionsException.java
@@ -14,9 +14,9 @@
 
 package com.google.firebase.functions;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.util.SparseArray;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.FirebaseException;
 import org.json.JSONException;
 import org.json.JSONObject;
diff --git a/firebase-functions/src/main/java/com/google/firebase/functions/FunctionsMultiResourceComponent.java b/firebase-functions/src/main/java/com/google/firebase/functions/FunctionsMultiResourceComponent.java
index f9e616345..7f609dd60 100644
--- a/firebase-functions/src/main/java/com/google/firebase/functions/FunctionsMultiResourceComponent.java
+++ b/firebase-functions/src/main/java/com/google/firebase/functions/FunctionsMultiResourceComponent.java
@@ -15,7 +15,7 @@
 package com.google.firebase.functions;
 
 import android.content.Context;
-import android.support.annotation.GuardedBy;
+import androidx.annotation.GuardedBy;
 import java.util.HashMap;
 import java.util.Map;
 
diff --git a/firebase-functions/src/main/java/com/google/firebase/functions/FunctionsRegistrar.java b/firebase-functions/src/main/java/com/google/firebase/functions/FunctionsRegistrar.java
index d1ba251be..95b620cfe 100644
--- a/firebase-functions/src/main/java/com/google/firebase/functions/FunctionsRegistrar.java
+++ b/firebase-functions/src/main/java/com/google/firebase/functions/FunctionsRegistrar.java
@@ -15,7 +15,7 @@
 package com.google.firebase.functions;
 
 import android.content.Context;
-import android.support.annotation.Keep;
+import androidx.annotation.Keep;
 import com.google.firebase.FirebaseOptions;
 import com.google.firebase.auth.internal.InternalAuthProvider;
 import com.google.firebase.components.Component;
diff --git a/firebase-functions/src/main/java/com/google/firebase/functions/HttpsCallOptions.java b/firebase-functions/src/main/java/com/google/firebase/functions/HttpsCallOptions.java
index 7f3dabecf..b046aeaa3 100644
--- a/firebase-functions/src/main/java/com/google/firebase/functions/HttpsCallOptions.java
+++ b/firebase-functions/src/main/java/com/google/firebase/functions/HttpsCallOptions.java
@@ -39,8 +39,21 @@ void setTimeout(long timeout, TimeUnit units) {
     this.timeoutUnits = units;
   }
 
+  /**
+   * Returns the timeout for calls from this instance of Functions.
+   *
+   * @return The timeout, in milliseconds.
+   */
+  public long getTimeout() {
+    return timeoutUnits.toMillis(timeout);
+  }
+
   /** Creates a new OkHttpClient with these options applied to it. */
   OkHttpClient apply(OkHttpClient client) {
-    return client.newBuilder().callTimeout(timeout, timeoutUnits).build();
+    return client
+        .newBuilder()
+        .callTimeout(timeout, timeoutUnits)
+        .readTimeout(timeout, timeoutUnits)
+        .build();
   }
 }
diff --git a/firebase-functions/src/main/java/com/google/firebase/functions/HttpsCallableContext.java b/firebase-functions/src/main/java/com/google/firebase/functions/HttpsCallableContext.java
index 7a8548516..4eec8465e 100644
--- a/firebase-functions/src/main/java/com/google/firebase/functions/HttpsCallableContext.java
+++ b/firebase-functions/src/main/java/com/google/firebase/functions/HttpsCallableContext.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.functions;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 /** The metadata about the client that should automatically be included in function calls. */
 class HttpsCallableContext {
diff --git a/firebase-functions/src/main/java/com/google/firebase/functions/HttpsCallableReference.java b/firebase-functions/src/main/java/com/google/firebase/functions/HttpsCallableReference.java
index 1fd497dbe..667a9b862 100644
--- a/firebase-functions/src/main/java/com/google/firebase/functions/HttpsCallableReference.java
+++ b/firebase-functions/src/main/java/com/google/firebase/functions/HttpsCallableReference.java
@@ -14,8 +14,8 @@
 
 package com.google.firebase.functions;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.tasks.Task;
 import java.util.concurrent.TimeUnit;
 
@@ -37,7 +37,6 @@
     this.name = name;
   }
 
-  @NonNull
   /**
    * Executes this Callable HTTPS trigger asynchronously.
    *
@@ -77,11 +76,11 @@
    * @see java.io.IOException
    * @see FirebaseFunctionsException
    */
+  @NonNull
   public Task<HttpsCallableResult> call(@Nullable Object data) {
     return functionsClient.call(name, data, options);
   }
 
-  @NonNull
   /**
    * Executes this HTTPS endpoint asynchronously without arguments.
    *
@@ -96,6 +95,7 @@
    *
    * @return A Task that will be completed when the HTTPS request has completed.
    */
+  @NonNull
   public Task<HttpsCallableResult> call() {
     return functionsClient.call(name, null, options);
   }
@@ -110,13 +110,22 @@ public void setTimeout(long timeout, @NonNull TimeUnit units) {
     options.setTimeout(timeout, units);
   }
 
-  @NonNull
+  /**
+   * Returns the timeout for calls from this instance of Functions.
+   *
+   * @return The timeout, in milliseconds.
+   */
+  public long getTimeout() {
+    return options.getTimeout();
+  }
+
   /**
    * Creates a new reference with the given timeout for calls. The default is 60 seconds.
    *
    * @param timeout The length of the timeout, in the given units.
    * @param units The units for the specified timeout.
    */
+  @NonNull
   public HttpsCallableReference withTimeout(long timeout, @NonNull TimeUnit units) {
     HttpsCallableReference other = new HttpsCallableReference(functionsClient, name);
     other.setTimeout(timeout, units);
diff --git a/firebase-functions/src/main/java/com/google/firebase/functions/HttpsCallableResult.java b/firebase-functions/src/main/java/com/google/firebase/functions/HttpsCallableResult.java
index b5e180bbb..51f37839d 100644
--- a/firebase-functions/src/main/java/com/google/firebase/functions/HttpsCallableResult.java
+++ b/firebase-functions/src/main/java/com/google/firebase/functions/HttpsCallableResult.java
@@ -14,18 +14,17 @@
 
 package com.google.firebase.functions;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 /** The result of calling a HttpsCallableReference function. */
 public class HttpsCallableResult {
   // The actual result data, as generic types decoded from JSON.
   private final Object data;
 
-  HttpsCallableResult(@Nullable Object data) {
+  HttpsCallableResult(Object data) {
     this.data = data;
   }
 
-  @Nullable
   /**
    * Returns the data that was returned from the Callable HTTPS trigger.
    *
@@ -33,6 +32,7 @@
    * array, this object would be a List<Object>. If your trigger returned a JavaScript object with
    * keys and values, this object would be a Map<String, Object>.
    */
+  @Nullable
   public Object getData() {
     return data;
   }
diff --git a/firebase-functions/src/main/java/com/google/firebase/functions/Serializer.java b/firebase-functions/src/main/java/com/google/firebase/functions/Serializer.java
index e0da06750..b12c62019 100644
--- a/firebase-functions/src/main/java/com/google/firebase/functions/Serializer.java
+++ b/firebase-functions/src/main/java/com/google/firebase/functions/Serializer.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.functions;
 
-import android.support.annotation.VisibleForTesting;
+import androidx.annotation.VisibleForTesting;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
diff --git a/firebase-inappmessaging-display/api.txt b/firebase-inappmessaging-display/api.txt
new file mode 100644
index 000000000..7dcf23618
--- /dev/null
+++ b/firebase-inappmessaging-display/api.txt
@@ -0,0 +1,9 @@
+// Signature format: 2.0
+package com.google.firebase.inappmessaging.display {
+
+  public class FirebaseInAppMessagingDisplay {
+    method public void displayMessage(InAppMessage, FirebaseInAppMessagingDisplayCallbacks);
+    method public static com.google.firebase.inappmessaging.display.FirebaseInAppMessagingDisplay getInstance();
+  }
+
+}
diff --git a/firebase-inappmessaging-display/firebase-inappmessaging-display.gradle b/firebase-inappmessaging-display/firebase-inappmessaging-display.gradle
index 37b35246a..2e488d8ff 100644
--- a/firebase-inappmessaging-display/firebase-inappmessaging-display.gradle
+++ b/firebase-inappmessaging-display/firebase-inappmessaging-display.gradle
@@ -18,7 +18,6 @@ plugins {
 
 firebaseLibrary {
     testLab.enabled = true
-    publishSources = true
 }
 
 android {
@@ -27,15 +26,10 @@ android {
         minSdkVersion 16
         targetSdkVersion project.targetSdkVersion
         versionCode 1
-        versionName "1.0"
+        versionName version
         multiDexEnabled true
 
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
-    }
-
-    // TODO: b/111563140
-    lintOptions {
-        abortOnError false
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
     }
 
     compileOptions {
@@ -45,6 +39,19 @@ android {
         incremental = false
     }
 
+    sourceSets {
+        androidTest {
+            java {
+                srcDir '../firebase-inappmessaging/src/testData'
+            }
+        }
+        test {
+            java {
+                srcDir '../firebase-inappmessaging/src/testData'
+            }
+        }
+    }
+
     testOptions {
         unitTests {
             includeAndroidResources true
@@ -54,39 +61,45 @@ android {
 
 dependencies {
     implementation project(':firebase-common')
-    implementation ("com.google.firebase:firebase-inappmessaging:17.0.3") {
+    implementation project(':firebase-inappmessaging')
+
+    implementation ('com.google.firebase:firebase-iid:19.0.0') {
         exclude group: "com.google.firebase", module: "firebase-common"
     }
+    implementation('com.google.firebase:firebase-measurement-connector:18.0.0') {
+        exclude group: 'com.google.firebase', module: 'firebase-common'
+    }
 
+    implementation 'androidx.appcompat:appcompat:1.0.2'
+    implementation 'androidx.cardview:cardview:1.0.0'
+    implementation 'androidx.legacy:legacy-support-v4:1.0.0'
+    implementation 'androidx.browser:browser:1.0.0'
+    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
+    implementation 'com.google.auto.value:auto-value-annotations:1.6.5'
 
-    implementation "com.android.support:appcompat-v7:27.1.1"
-    implementation "com.android.support:customtabs:27.1.1"
-    implementation 'com.android.support.constraint:constraint-layout:1.1.2'
-    implementation 'com.google.auto.value:auto-value-annotations:1.6'
-
-    implementation "com.squareup.picasso:picasso:2.5.2"
+    implementation "com.squareup.picasso:picasso:2.71828"
     implementation "com.squareup.okhttp:okhttp:2.7.5"
 
-    implementation "com.google.dagger:dagger:2.13"
-    implementation "com.google.dagger:dagger-android-support:2.13"
-    implementation ("com.google.firebase:firebase-core:16.0.4") {
-        exclude group: "com.google.firebase", module: "firebase-common"
-    }
-
+    implementation "com.google.dagger:dagger:2.22"
+    implementation "com.google.dagger:dagger-android-support:2.22"
 
-    annotationProcessor "com.google.dagger:dagger-compiler:2.13"
-    annotationProcessor 'com.google.auto.value:auto-value:1.6'
+    annotationProcessor "com.google.dagger:dagger-compiler:2.22"
+    annotationProcessor 'com.google.auto.value:auto-value:1.6.2'
     annotationProcessor 'com.ryanharter.auto.value:auto-value-parcel:0.2.6'
 
-    testImplementation "org.robolectric:robolectric:$robolectricVersion"
+    testImplementation "org.robolectric:robolectric:4.2"
     testImplementation "junit:junit:4.12"
-    testImplementation "org.mockito:mockito-core:2.18.3"
-    testImplementation "com.google.truth:truth:$googleTruthVersion"
+    testImplementation "org.mockito:mockito-core:2.25.0"
+    testImplementation "com.google.truth:truth:0.44"
 
-    androidTestImplementation "org.mockito:mockito-core:2.18.3"
+    androidTestImplementation "org.mockito:mockito-core:2.25.0"
     androidTestImplementation "com.google.dexmaker:dexmaker:1.2"
-    androidTestImplementation "com.linkedin.dexmaker:dexmaker-mockito:2.16.0"
-    androidTestImplementation "com.android.support:support-annotations:27.1.1"
-    androidTestImplementation "com.android.support.test:runner:1.0.2"
-    androidTestImplementation "com.android.support.test:rules:1.0.2"
+    androidTestImplementation "com.linkedin.dexmaker:dexmaker-mockito:2.25.0"
+    androidTestImplementation 'androidx.annotation:annotation:1.1.0'
+    androidTestImplementation 'androidx.test:runner:1.2.0'
+    androidTestImplementation 'androidx.test:rules:1.2.0'
+    androidTestImplementation ("com.google.firebase:firebase-analytics:17.0.0") {
+        exclude group: "com.google.firebase", module: "firebase-common"
+    }
+
 }
diff --git a/firebase-inappmessaging-display/gradle.properties b/firebase-inappmessaging-display/gradle.properties
index 90ec8c308..737638ce4 100644
--- a/firebase-inappmessaging-display/gradle.properties
+++ b/firebase-inappmessaging-display/gradle.properties
@@ -1 +1,2 @@
-version=17.0.5
+version=18.0.2
+latestReleasedVersion=18.0.1
diff --git a/firebase-inappmessaging-display/src/androidTest/AndroidManifest.xml b/firebase-inappmessaging-display/src/androidTest/AndroidManifest.xml
index 0474d730b..8fc42cf9d 100644
--- a/firebase-inappmessaging-display/src/androidTest/AndroidManifest.xml
+++ b/firebase-inappmessaging-display/src/androidTest/AndroidManifest.xml
@@ -13,7 +13,7 @@
   </application>
 
   <instrumentation
-      android:name="android.support.test.runner.AndroidJUnitRunner"
+      android:name="androidx.test.runner.AndroidJUnitRunner"
       android:targetPackage="com.google.firebase.inappmessaging.display.internal.bindingwrappers">
   </instrumentation>
 </manifest>
\ No newline at end of file
diff --git a/firebase-inappmessaging-display/src/androidTest/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/BannerBindingWrapperTest.java b/firebase-inappmessaging-display/src/androidTest/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/BannerBindingWrapperTest.java
index a1836b6f9..817c272d2 100644
--- a/firebase-inappmessaging-display/src/androidTest/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/BannerBindingWrapperTest.java
+++ b/firebase-inappmessaging-display/src/androidTest/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/BannerBindingWrapperTest.java
@@ -14,20 +14,22 @@
 
 package com.google.firebase.inappmessaging.display.internal.bindingwrappers;
 
+import static com.google.firebase.inappmessaging.testutil.TestData.BANNER_MESSAGE_MODEL;
 import static junit.framework.Assert.assertTrue;
 import static org.junit.Assert.assertEquals;
 
 import android.content.Context;
-import android.support.test.filters.MediumTest;
-import android.support.test.rule.ActivityTestRule;
-import android.support.test.runner.AndroidJUnit4;
-import android.view.Gravity;
+import android.util.DisplayMetrics;
 import android.view.LayoutInflater;
 import android.view.View;
-import android.view.ViewGroup;
+import androidx.test.filters.MediumTest;
+import androidx.test.rule.ActivityTestRule;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.inappmessaging.display.internal.InAppMessageLayoutConfig;
-import com.google.firebase.inappmessaging.model.InAppMessage;
-import com.google.firebase.inappmessaging.model.MessageType;
+import com.google.firebase.inappmessaging.display.internal.injection.modules.InflaterConfigModule;
+import com.google.firebase.inappmessaging.model.Action;
+import java.util.HashMap;
+import java.util.Map;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -38,71 +40,54 @@
 @MediumTest
 @RunWith(AndroidJUnit4.class)
 public class BannerBindingWrapperTest {
-  private static final String IMAGE_URL = "https://www.imgur.com";
-  private static final String CAMPAIGN_ID = "campaign_id";
-  private static final String ACTION_URL = "https://www.google.com";
-  private static final String CAMPAIGN_NAME = "campaign_name";
-  private static final InAppMessage.Action ACTION =
-      InAppMessage.Action.builder().setActionUrl(ACTION_URL).build();
-  private static final InAppMessageLayoutConfig inappMessageLayoutConfig =
-      InAppMessageLayoutConfig.builder()
-          .setMaxDialogHeightPx((int) (0.8 * 1000))
-          .setMaxDialogWidthPx((int) (0.7f * 1000))
-          .setMaxImageHeightWeight(0.6f)
-          .setMaxBodyHeightWeight(0.1f)
-          .setMaxImageWidthWeight(0.9f) // entire dialog width
-          .setMaxBodyWidthWeight(0.9f) // entire dialog width
-          .setViewWindowGravity(Gravity.CENTER)
-          .setWindowFlag(0)
-          .setWindowWidth(ViewGroup.LayoutParams.WRAP_CONTENT)
-          .setWindowHeight(ViewGroup.LayoutParams.WRAP_CONTENT)
-          .setBackgroundEnabled(false)
-          .setAnimate(false)
-          .setAutoDismiss(false)
-          .build();
-  private static final InAppMessage BANNER_MESSAGE =
-      InAppMessage.builder()
-          .setCampaignId(CAMPAIGN_ID)
-          .setIsTestMessage(false)
-          .setCampaignName(CAMPAIGN_NAME)
-          .setAction(ACTION)
-          .setMessageType(MessageType.BANNER)
-          .setImageUrl(IMAGE_URL)
-          .build();
+
+  private DisplayMetrics testDisplayMetrics = new DisplayMetrics();
+  private InflaterConfigModule inflaterConfigModule = new InflaterConfigModule();
+  private InAppMessageLayoutConfig bannerPortraitLayoutConfig;
+
   @Rule public ActivityTestRule<TestActivity> rule = new ActivityTestRule<>(TestActivity.class);
   @Mock private View.OnClickListener onDismissListener;
   @Mock private View.OnClickListener actionListener;
 
+  private Map<Action, View.OnClickListener> actionListeners;
   private BannerBindingWrapper bannerBindingWrapper;
 
   @Before
   public void setup() {
+
+    testDisplayMetrics.widthPixels = 1000;
+    testDisplayMetrics.widthPixels = 2000;
+    bannerPortraitLayoutConfig =
+        inflaterConfigModule.providesBannerPortraitLayoutConfig(testDisplayMetrics);
+
     MockitoAnnotations.initMocks(this);
     TestActivity testActivity = rule.getActivity();
     LayoutInflater layoutInflater =
         (LayoutInflater) testActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
 
     bannerBindingWrapper =
-        new BannerBindingWrapper(BANNER_MESSAGE, layoutInflater, inappMessageLayoutConfig);
+        new BannerBindingWrapper(bannerPortraitLayoutConfig, layoutInflater, BANNER_MESSAGE_MODEL);
+    this.actionListeners = new HashMap<>();
+    actionListeners.put(BANNER_MESSAGE_MODEL.getAction(), actionListener);
   }
 
   @Test
   public void inflate_setsMessage() throws Exception {
-    bannerBindingWrapper.inflate(actionListener, onDismissListener);
+    bannerBindingWrapper.inflate(actionListeners, onDismissListener);
 
-    assertEquals(bannerBindingWrapper.message, BANNER_MESSAGE);
+    assertEquals(bannerBindingWrapper.message, BANNER_MESSAGE_MODEL);
   }
 
   @Test
   public void inflate_setsLayoutConfig() throws Exception {
-    bannerBindingWrapper.inflate(actionListener, onDismissListener);
+    bannerBindingWrapper.inflate(actionListeners, onDismissListener);
 
-    assertEquals(bannerBindingWrapper.config, inappMessageLayoutConfig);
+    assertEquals(bannerBindingWrapper.config, bannerPortraitLayoutConfig);
   }
 
   @Test
   public void inflate_setsActionListener() throws Exception {
-    bannerBindingWrapper.inflate(actionListener, onDismissListener);
+    bannerBindingWrapper.inflate(actionListeners, onDismissListener);
 
     assertTrue(bannerBindingWrapper.getDialogView().hasOnClickListeners());
   }
diff --git a/firebase-inappmessaging-display/src/androidTest/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/CardBindingWrapperTest.java b/firebase-inappmessaging-display/src/androidTest/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/CardBindingWrapperTest.java
new file mode 100644
index 000000000..41c53ab00
--- /dev/null
+++ b/firebase-inappmessaging-display/src/androidTest/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/CardBindingWrapperTest.java
@@ -0,0 +1,233 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.display.internal.bindingwrappers;
+
+import static com.google.firebase.inappmessaging.testutil.TestData.ACTION_MODEL_WITHOUT_URL;
+import static com.google.firebase.inappmessaging.testutil.TestData.ACTION_MODEL_WITH_BUTTON;
+import static com.google.firebase.inappmessaging.testutil.TestData.CAMPAIGN_METADATA_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.CARD_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.IMAGE_DATA;
+import static com.google.firebase.inappmessaging.testutil.TestData.MESSAGE_BACKGROUND_HEX_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.TITLE_MODEL;
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertTrue;
+
+import android.content.Context;
+import android.graphics.Color;
+import android.util.DisplayMetrics;
+import android.view.LayoutInflater;
+import android.view.View;
+import androidx.test.filters.MediumTest;
+import androidx.test.rule.ActivityTestRule;
+import androidx.test.runner.AndroidJUnit4;
+import com.google.firebase.inappmessaging.display.internal.InAppMessageLayoutConfig;
+import com.google.firebase.inappmessaging.display.internal.injection.modules.InflaterConfigModule;
+import com.google.firebase.inappmessaging.model.Action;
+import com.google.firebase.inappmessaging.model.CardMessage;
+import java.util.HashMap;
+import java.util.Map;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@MediumTest
+@RunWith(AndroidJUnit4.class)
+public class CardBindingWrapperTest {
+
+  private DisplayMetrics testDisplayMetrics = new DisplayMetrics();
+  private InflaterConfigModule inflaterConfigModule = new InflaterConfigModule();
+  private InAppMessageLayoutConfig cardPortraitLayoutConfig;
+
+  @Rule public ActivityTestRule<TestActivity> rule = new ActivityTestRule<>(TestActivity.class);
+  @Mock private View.OnClickListener onDismissListener;
+  @Mock private View.OnClickListener primaryActionListener;
+  @Mock private View.OnClickListener secondaryActionListener;
+
+  private Map<Action, View.OnClickListener> actionListeners;
+  private CardBindingWrapper cardBindingWrapper;
+
+  @Before
+  public void setup() {
+    testDisplayMetrics.widthPixels = 1000;
+    testDisplayMetrics.widthPixels = 2000;
+    cardPortraitLayoutConfig = inflaterConfigModule.providesCardPortraitConfig(testDisplayMetrics);
+
+    MockitoAnnotations.initMocks(this);
+    TestActivity testActivity = rule.getActivity();
+    LayoutInflater layoutInflater =
+        (LayoutInflater) testActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+
+    cardBindingWrapper =
+        new CardBindingWrapper(cardPortraitLayoutConfig, layoutInflater, CARD_MESSAGE_MODEL);
+    this.actionListeners = new HashMap<>();
+    actionListeners.put(CARD_MESSAGE_MODEL.getPrimaryAction(), primaryActionListener);
+    actionListeners.put(CARD_MESSAGE_MODEL.getSecondaryAction(), secondaryActionListener);
+  }
+
+  @Test
+  public void inflate_setsMessage() throws Exception {
+    cardBindingWrapper.inflate(actionListeners, onDismissListener);
+
+    assertEquals(cardBindingWrapper.message, CARD_MESSAGE_MODEL);
+  }
+
+  @Test
+  public void inflate_setsLayoutConfig() throws Exception {
+    cardBindingWrapper.inflate(actionListeners, onDismissListener);
+
+    assertEquals(cardBindingWrapper.config, cardPortraitLayoutConfig);
+  }
+
+  @Test
+  public void inflate_setsDismissListener() throws Exception {
+    cardBindingWrapper.inflate(actionListeners, onDismissListener);
+
+    assertEquals(cardBindingWrapper.getDismissListener(), onDismissListener);
+  }
+
+  @Test
+  public void inflate_setsPrimaryActionListener() throws Exception {
+    cardBindingWrapper.inflate(actionListeners, onDismissListener);
+
+    assertTrue(cardBindingWrapper.getPrimaryButton().hasOnClickListeners());
+  }
+
+  @Test
+  public void inflate_setsSecondaryActionListener() throws Exception {
+    cardBindingWrapper.inflate(actionListeners, onDismissListener);
+
+    assertTrue(cardBindingWrapper.getSecondaryButton().hasOnClickListeners());
+  }
+
+  @Test
+  public void inflate_setsPrimaryButtonTextColor() throws Exception {
+    cardBindingWrapper.inflate(actionListeners, onDismissListener);
+
+    int textColor = cardBindingWrapper.getPrimaryButton().getTextColors().getDefaultColor();
+    int expectedTextColor =
+        Color.parseColor(CARD_MESSAGE_MODEL.getPrimaryAction().getButton().getText().getHexColor());
+
+    assertEquals(textColor, expectedTextColor);
+    assertEquals(cardBindingWrapper.getPrimaryButton().getVisibility(), View.VISIBLE);
+  }
+
+  @Test
+  public void inflate_setsSecondaryButtonTextColor() throws Exception {
+    cardBindingWrapper.inflate(actionListeners, onDismissListener);
+
+    int textColor = cardBindingWrapper.getSecondaryButton().getTextColors().getDefaultColor();
+    int expectedTextColor =
+        Color.parseColor(
+            CARD_MESSAGE_MODEL.getSecondaryAction().getButton().getText().getHexColor());
+
+    assertEquals(textColor, expectedTextColor);
+    assertEquals(cardBindingWrapper.getSecondaryButton().getVisibility(), View.VISIBLE);
+  }
+
+  @Test
+  public void inflate_setsAllViewsVisibleWithCompleteMessage() throws Exception {
+    TestActivity testActivity = rule.getActivity();
+    LayoutInflater layoutInflater =
+        (LayoutInflater) testActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+
+    cardBindingWrapper =
+        new CardBindingWrapper(cardPortraitLayoutConfig, layoutInflater, CARD_MESSAGE_MODEL);
+
+    this.actionListeners = new HashMap<>();
+    cardBindingWrapper.inflate(actionListeners, onDismissListener);
+
+    assertEquals(cardBindingWrapper.getTitleView().getVisibility(), View.VISIBLE);
+    assertEquals(cardBindingWrapper.getScrollView().getVisibility(), View.VISIBLE);
+    assertEquals(cardBindingWrapper.getImageView().getVisibility(), View.VISIBLE);
+    assertEquals(cardBindingWrapper.getPrimaryButton().getVisibility(), View.VISIBLE);
+    assertEquals(cardBindingWrapper.getSecondaryButton().getVisibility(), View.VISIBLE);
+  }
+
+  @Test
+  public void inflate_setsSecondaryButtonInvisibleWithNoButton() throws Exception {
+    TestActivity testActivity = rule.getActivity();
+    LayoutInflater layoutInflater =
+        (LayoutInflater) testActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+
+    // This message has no secondary button, so it should be gone in the layout
+    CardMessage message =
+        CardMessage.builder()
+            .setPrimaryAction(ACTION_MODEL_WITH_BUTTON)
+            .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+            .setTitle(TITLE_MODEL)
+            .setPortraitImageData(IMAGE_DATA)
+            .build(CAMPAIGN_METADATA_MODEL);
+
+    cardBindingWrapper = new CardBindingWrapper(cardPortraitLayoutConfig, layoutInflater, message);
+
+    this.actionListeners = new HashMap<>();
+    actionListeners.put(message.getPrimaryAction(), primaryActionListener);
+    cardBindingWrapper.inflate(actionListeners, onDismissListener);
+
+    assertEquals(cardBindingWrapper.getSecondaryButton().getVisibility(), View.GONE);
+  }
+
+  @Test
+  public void inflate_setsPrimaryButtonVisibleWithoutUrl() throws Exception {
+    TestActivity testActivity = rule.getActivity();
+    LayoutInflater layoutInflater =
+        (LayoutInflater) testActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+
+    // This message has no secondary button, so it should be gone in the layout
+    CardMessage message =
+        CardMessage.builder()
+            .setPrimaryAction(ACTION_MODEL_WITHOUT_URL)
+            .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+            .setTitle(TITLE_MODEL)
+            .setPortraitImageData(IMAGE_DATA)
+            .build(CAMPAIGN_METADATA_MODEL);
+
+    cardBindingWrapper = new CardBindingWrapper(cardPortraitLayoutConfig, layoutInflater, message);
+
+    this.actionListeners = new HashMap<>();
+    actionListeners.put(message.getPrimaryAction(), onDismissListener);
+    cardBindingWrapper.inflate(actionListeners, onDismissListener);
+
+    assertEquals(cardBindingWrapper.getPrimaryButton().getVisibility(), View.VISIBLE);
+    assertEquals(cardBindingWrapper.getSecondaryButton().getVisibility(), View.GONE);
+  }
+
+  @Test
+  public void inflate_setsBodyInvisibleWithNoBody() throws Exception {
+    TestActivity testActivity = rule.getActivity();
+    LayoutInflater layoutInflater =
+        (LayoutInflater) testActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+
+    // This message has body scroll, so it should be gone in the layout
+    CardMessage message =
+        CardMessage.builder()
+            .setPrimaryAction(ACTION_MODEL_WITHOUT_URL)
+            .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+            .setTitle(TITLE_MODEL)
+            .setPortraitImageData(IMAGE_DATA)
+            .build(CAMPAIGN_METADATA_MODEL);
+
+    cardBindingWrapper = new CardBindingWrapper(cardPortraitLayoutConfig, layoutInflater, message);
+
+    this.actionListeners = new HashMap<>();
+    actionListeners.put(message.getPrimaryAction(), onDismissListener);
+    cardBindingWrapper.inflate(actionListeners, onDismissListener);
+
+    assertEquals(cardBindingWrapper.getScrollView().getVisibility(), View.GONE);
+  }
+}
diff --git a/firebase-inappmessaging-display/src/androidTest/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/ImageBindingWrapperTest.java b/firebase-inappmessaging-display/src/androidTest/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/ImageBindingWrapperTest.java
index eab5b9ab9..0c9b5da65 100644
--- a/firebase-inappmessaging-display/src/androidTest/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/ImageBindingWrapperTest.java
+++ b/firebase-inappmessaging-display/src/androidTest/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/ImageBindingWrapperTest.java
@@ -14,20 +14,22 @@
 
 package com.google.firebase.inappmessaging.display.internal.bindingwrappers;
 
+import static com.google.firebase.inappmessaging.testutil.TestData.IMAGE_MESSAGE_MODEL;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 import android.content.Context;
-import android.support.test.filters.MediumTest;
-import android.support.test.rule.ActivityTestRule;
-import android.support.test.runner.AndroidJUnit4;
-import android.view.Gravity;
+import android.util.DisplayMetrics;
 import android.view.LayoutInflater;
 import android.view.View;
-import android.view.ViewGroup;
+import androidx.test.filters.MediumTest;
+import androidx.test.rule.ActivityTestRule;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.inappmessaging.display.internal.InAppMessageLayoutConfig;
-import com.google.firebase.inappmessaging.model.InAppMessage;
-import com.google.firebase.inappmessaging.model.MessageType;
+import com.google.firebase.inappmessaging.display.internal.injection.modules.InflaterConfigModule;
+import com.google.firebase.inappmessaging.model.Action;
+import java.util.HashMap;
+import java.util.Map;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -38,78 +40,61 @@
 @MediumTest
 @RunWith(AndroidJUnit4.class)
 public class ImageBindingWrapperTest {
-  private static final String IMAGE_URL = "https://www.imgur.com";
-  private static final String CAMPAIGN_ID = "campaign_id";
-  private static final String ACTION_URL = "https://www.google.com";
-  private static final String CAMPAIGN_NAME = "campaign_name";
-  private static final InAppMessage.Action ACTION =
-      InAppMessage.Action.builder().setActionUrl(ACTION_URL).build();
-  private static final InAppMessageLayoutConfig inappMessageLayoutConfig =
-      InAppMessageLayoutConfig.builder()
-          .setMaxDialogHeightPx((int) (0.8 * 1000))
-          .setMaxDialogWidthPx((int) (0.7f * 1000))
-          .setMaxImageHeightWeight(0.6f)
-          .setMaxBodyHeightWeight(0.1f)
-          .setMaxImageWidthWeight(0.9f) // entire dialog width
-          .setMaxBodyWidthWeight(0.9f) // entire dialog width
-          .setViewWindowGravity(Gravity.CENTER)
-          .setWindowFlag(0)
-          .setWindowWidth(ViewGroup.LayoutParams.WRAP_CONTENT)
-          .setWindowHeight(ViewGroup.LayoutParams.WRAP_CONTENT)
-          .setBackgroundEnabled(false)
-          .setAnimate(false)
-          .setAutoDismiss(false)
-          .build();
-  private static final InAppMessage IMAGE_ONLY_MESSAGE =
-      InAppMessage.builder()
-          .setCampaignId(CAMPAIGN_ID)
-          .setIsTestMessage(false)
-          .setCampaignName(CAMPAIGN_NAME)
-          .setAction(ACTION)
-          .setMessageType(MessageType.IMAGE_ONLY)
-          .setImageUrl(IMAGE_URL)
-          .build();
+
+  private DisplayMetrics testDisplayMetrics = new DisplayMetrics();
+  private InflaterConfigModule inflaterConfigModule = new InflaterConfigModule();
+  private InAppMessageLayoutConfig imagePortraitLayoutConfig;
+
   @Rule public ActivityTestRule<TestActivity> rule = new ActivityTestRule<>(TestActivity.class);
   @Mock private View.OnClickListener onDismissListener;
   @Mock private View.OnClickListener actionListener;
+  private Map<Action, View.OnClickListener> actionListeners;
 
   private ImageBindingWrapper imageBindingWrapper;
 
   @Before
   public void setup() {
+
+    testDisplayMetrics.widthPixels = 1000;
+    testDisplayMetrics.widthPixels = 2000;
+    imagePortraitLayoutConfig =
+        inflaterConfigModule.providesBannerPortraitLayoutConfig(testDisplayMetrics);
+
     MockitoAnnotations.initMocks(this);
     TestActivity testActivity = rule.getActivity();
     LayoutInflater layoutInflater =
         (LayoutInflater) testActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
 
     imageBindingWrapper =
-        new ImageBindingWrapper(inappMessageLayoutConfig, layoutInflater, IMAGE_ONLY_MESSAGE);
+        new ImageBindingWrapper(imagePortraitLayoutConfig, layoutInflater, IMAGE_MESSAGE_MODEL);
+    this.actionListeners = new HashMap<>();
+    actionListeners.put(IMAGE_MESSAGE_MODEL.getAction(), actionListener);
   }
 
   @Test
   public void inflate_setsMessage() throws Exception {
-    imageBindingWrapper.inflate(actionListener, onDismissListener);
+    imageBindingWrapper.inflate(actionListeners, onDismissListener);
 
-    assertEquals(imageBindingWrapper.message, IMAGE_ONLY_MESSAGE);
+    assertEquals(imageBindingWrapper.message, IMAGE_MESSAGE_MODEL);
   }
 
   @Test
   public void inflate_setsLayoutConfig() throws Exception {
-    imageBindingWrapper.inflate(actionListener, onDismissListener);
+    imageBindingWrapper.inflate(actionListeners, onDismissListener);
 
-    assertEquals(imageBindingWrapper.config, inappMessageLayoutConfig);
+    assertEquals(imageBindingWrapper.config, imagePortraitLayoutConfig);
   }
 
   @Test
   public void inflate_setsDismissListener() throws Exception {
-    imageBindingWrapper.inflate(actionListener, onDismissListener);
+    imageBindingWrapper.inflate(actionListeners, onDismissListener);
 
     assertTrue(imageBindingWrapper.getCollapseButton().hasOnClickListeners());
   }
 
   @Test
   public void inflate_setsActionListener() throws Exception {
-    imageBindingWrapper.inflate(actionListener, onDismissListener);
+    imageBindingWrapper.inflate(actionListeners, onDismissListener);
 
     assertTrue(imageBindingWrapper.getImageView().hasOnClickListeners());
   }
diff --git a/firebase-inappmessaging-display/src/androidTest/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/ModalBindingWrapperTest.java b/firebase-inappmessaging-display/src/androidTest/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/ModalBindingWrapperTest.java
index 6e9c1fb42..ed7bd1d27 100644
--- a/firebase-inappmessaging-display/src/androidTest/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/ModalBindingWrapperTest.java
+++ b/firebase-inappmessaging-display/src/androidTest/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/ModalBindingWrapperTest.java
@@ -14,21 +14,29 @@
 
 package com.google.firebase.inappmessaging.display.internal.bindingwrappers;
 
+import static com.google.firebase.inappmessaging.testutil.TestData.ACTION_MODEL_WITH_BUTTON;
+import static com.google.firebase.inappmessaging.testutil.TestData.CAMPAIGN_METADATA_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.IMAGE_DATA;
+import static com.google.firebase.inappmessaging.testutil.TestData.MESSAGE_BACKGROUND_HEX_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.MODAL_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.TITLE_MODEL;
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertTrue;
 
 import android.content.Context;
 import android.graphics.Color;
-import android.support.test.filters.MediumTest;
-import android.support.test.rule.ActivityTestRule;
-import android.support.test.runner.AndroidJUnit4;
-import android.view.Gravity;
+import android.util.DisplayMetrics;
 import android.view.LayoutInflater;
 import android.view.View;
-import android.view.ViewGroup;
+import androidx.test.filters.MediumTest;
+import androidx.test.rule.ActivityTestRule;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.firebase.inappmessaging.display.internal.InAppMessageLayoutConfig;
-import com.google.firebase.inappmessaging.model.InAppMessage;
-import com.google.firebase.inappmessaging.model.MessageType;
+import com.google.firebase.inappmessaging.display.internal.injection.modules.InflaterConfigModule;
+import com.google.firebase.inappmessaging.model.Action;
+import com.google.firebase.inappmessaging.model.ModalMessage;
+import java.util.HashMap;
+import java.util.Map;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -39,105 +47,92 @@
 @MediumTest
 @RunWith(AndroidJUnit4.class)
 public class ModalBindingWrapperTest {
-  private static final String IMAGE_URL = "https://www.imgur.com";
-  private static final String CAMPAIGN_ID = "campaign_id";
-  private static final String ACTION_URL = "https://www.google.com";
-  private static final String CAMPAIGN_NAME = "campaign_name";
-  private static final InAppMessage.Action ACTION =
-      InAppMessage.Action.builder().setActionUrl(ACTION_URL).build();
-  private static final InAppMessageLayoutConfig inappMessageLayoutConfig =
-      InAppMessageLayoutConfig.builder()
-          .setMaxDialogHeightPx((int) (0.8 * 1000))
-          .setMaxDialogWidthPx((int) (0.7f * 1000))
-          .setMaxImageHeightWeight(0.6f)
-          .setMaxBodyHeightWeight(0.1f)
-          .setMaxImageWidthWeight(0.9f) // entire dialog width
-          .setMaxBodyWidthWeight(0.9f) // entire dialog width
-          .setViewWindowGravity(Gravity.CENTER)
-          .setWindowFlag(0)
-          .setWindowWidth(ViewGroup.LayoutParams.WRAP_CONTENT)
-          .setWindowHeight(ViewGroup.LayoutParams.WRAP_CONTENT)
-          .setBackgroundEnabled(false)
-          .setAnimate(false)
-          .setAutoDismiss(false)
-          .build();
-  private static final String NON_STANDARD_TEXT_HEX = "#FFB7F4";
-  private static final String NON_STANDARD_BACKGROUND_HEX = "#37FF3C";
-  private static final InAppMessage MODAL_MESSAGE =
-      InAppMessage.builder()
-          .setCampaignId(CAMPAIGN_ID)
-          .setIsTestMessage(false)
-          .setCampaignName(CAMPAIGN_NAME)
-          .setActionButton(
-              InAppMessage.Button.builder()
-                  .setText(
-                      InAppMessage.Text.builder()
-                          .setText("button")
-                          .setHexColor(NON_STANDARD_TEXT_HEX)
-                          .build())
-                  .setButtonHexColor(NON_STANDARD_BACKGROUND_HEX)
-                  .build())
-          .setAction(ACTION)
-          .setMessageType(MessageType.MODAL)
-          .setImageUrl(IMAGE_URL)
-          .build();
+
+  private DisplayMetrics testDisplayMetrics = new DisplayMetrics();
+  private InflaterConfigModule inflaterConfigModule = new InflaterConfigModule();
+  private InAppMessageLayoutConfig modalPortraitLayoutConfig;
+
   @Rule public ActivityTestRule<TestActivity> rule = new ActivityTestRule<>(TestActivity.class);
   @Mock private View.OnClickListener onDismissListener;
   @Mock private View.OnClickListener actionListener;
 
+  private Map<Action, View.OnClickListener> actionListeners;
   private ModalBindingWrapper modalBindingWrapper;
 
   @Before
   public void setup() {
+    testDisplayMetrics.widthPixels = 1000;
+    testDisplayMetrics.widthPixels = 2000;
+    modalPortraitLayoutConfig =
+        inflaterConfigModule.providesModalPortraitConfig(testDisplayMetrics);
+
     MockitoAnnotations.initMocks(this);
     TestActivity testActivity = rule.getActivity();
     LayoutInflater layoutInflater =
         (LayoutInflater) testActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
 
     modalBindingWrapper =
-        new ModalBindingWrapper(inappMessageLayoutConfig, layoutInflater, MODAL_MESSAGE);
+        new ModalBindingWrapper(modalPortraitLayoutConfig, layoutInflater, MODAL_MESSAGE_MODEL);
+    this.actionListeners = new HashMap<>();
+    actionListeners.put(ACTION_MODEL_WITH_BUTTON, actionListener);
   }
 
   @Test
   public void inflate_setsMessage() throws Exception {
-    modalBindingWrapper.inflate(actionListener, onDismissListener);
+    modalBindingWrapper.inflate(actionListeners, onDismissListener);
 
-    assertEquals(modalBindingWrapper.message, MODAL_MESSAGE);
+    assertEquals(modalBindingWrapper.message, MODAL_MESSAGE_MODEL);
   }
 
   @Test
   public void inflate_setsLayoutConfig() throws Exception {
-    modalBindingWrapper.inflate(actionListener, onDismissListener);
+    modalBindingWrapper.inflate(actionListeners, onDismissListener);
 
-    assertEquals(modalBindingWrapper.config, inappMessageLayoutConfig);
+    assertEquals(modalBindingWrapper.config, modalPortraitLayoutConfig);
   }
 
   @Test
   public void inflate_setsDismissListener() throws Exception {
-    modalBindingWrapper.inflate(actionListener, onDismissListener);
+    modalBindingWrapper.inflate(actionListeners, onDismissListener);
 
     assertTrue(modalBindingWrapper.getCollapseButton().hasOnClickListeners());
   }
 
   @Test
   public void inflate_setsActionListener() throws Exception {
-    modalBindingWrapper.inflate(actionListener, onDismissListener);
+    modalBindingWrapper.inflate(actionListeners, onDismissListener);
 
     assertTrue(modalBindingWrapper.getActionButton().hasOnClickListeners());
   }
 
   @Test
   public void inflate_setsButtonTextColor() throws Exception {
-    modalBindingWrapper.inflate(actionListener, onDismissListener);
+    modalBindingWrapper.inflate(actionListeners, onDismissListener);
 
     int textColor = modalBindingWrapper.getActionButton().getTextColors().getDefaultColor();
     int expectedTextColor =
-        Color.parseColor(MODAL_MESSAGE.getActionButton().getText().getHexColor());
+        Color.parseColor(MODAL_MESSAGE_MODEL.getAction().getButton().getText().getHexColor());
 
     assertEquals(textColor, expectedTextColor);
     assertEquals(modalBindingWrapper.getActionButton().getVisibility(), View.VISIBLE);
   }
 
+  @Test
+  public void inflate_setsAllViewsVisibleWithCompleteMessage() throws Exception {
+    TestActivity testActivity = rule.getActivity();
+    LayoutInflater layoutInflater =
+        (LayoutInflater) testActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+
+    modalBindingWrapper =
+        new ModalBindingWrapper(modalPortraitLayoutConfig, layoutInflater, MODAL_MESSAGE_MODEL);
+    modalBindingWrapper.inflate(actionListeners, onDismissListener);
+
+    assertEquals(modalBindingWrapper.getImageView().getVisibility(), View.VISIBLE);
+    assertEquals(modalBindingWrapper.getActionButton().getVisibility(), View.VISIBLE);
+    assertEquals(modalBindingWrapper.getScrollView().getVisibility(), View.VISIBLE);
+    assertEquals(modalBindingWrapper.getTitleView().getVisibility(), View.VISIBLE);
+  }
+
   @Test
   public void inflate_setsButtonInvisibleWithNoButton() throws Exception {
     TestActivity testActivity = rule.getActivity();
@@ -145,20 +140,62 @@ public void inflate_setsButtonInvisibleWithNoButton() throws Exception {
         (LayoutInflater) testActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
 
     // This message has no button, so it should be gone in the layout
-    InAppMessage message =
-        InAppMessage.builder()
-            .setCampaignId(CAMPAIGN_ID)
-            .setIsTestMessage(false)
-            .setCampaignName(CAMPAIGN_NAME)
-            .setAction(ACTION)
-            .setMessageType(MessageType.MODAL)
-            .setImageUrl(IMAGE_URL)
-            .build();
+    ModalMessage message =
+        ModalMessage.builder()
+            .setImageData(IMAGE_DATA)
+            .setTitle(TITLE_MODEL)
+            .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+            .build(CAMPAIGN_METADATA_MODEL);
 
     modalBindingWrapper =
-        new ModalBindingWrapper(inappMessageLayoutConfig, layoutInflater, message);
-    modalBindingWrapper.inflate(actionListener, onDismissListener);
+        new ModalBindingWrapper(modalPortraitLayoutConfig, layoutInflater, message);
+
+    this.actionListeners = new HashMap<>();
+    modalBindingWrapper.inflate(actionListeners, onDismissListener);
 
     assertEquals(modalBindingWrapper.getActionButton().getVisibility(), View.GONE);
   }
+
+  @Test
+  public void inflate_setsImageInvisibleWithNoImage() throws Exception {
+    TestActivity testActivity = rule.getActivity();
+    LayoutInflater layoutInflater =
+        (LayoutInflater) testActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+
+    // This message has no image, so it should be gone in the layout
+    ModalMessage message =
+        ModalMessage.builder()
+            .setAction(ACTION_MODEL_WITH_BUTTON)
+            .setTitle(TITLE_MODEL)
+            .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+            .build(CAMPAIGN_METADATA_MODEL);
+
+    modalBindingWrapper =
+        new ModalBindingWrapper(modalPortraitLayoutConfig, layoutInflater, message);
+
+    modalBindingWrapper.inflate(actionListeners, onDismissListener);
+    assertEquals(modalBindingWrapper.getImageView().getVisibility(), View.GONE);
+  }
+
+  @Test
+  public void inflate_setsBodyInvisibleWithNoBody() throws Exception {
+    TestActivity testActivity = rule.getActivity();
+    LayoutInflater layoutInflater =
+        (LayoutInflater) testActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+
+    // This message has no image, so it should be gone in the layout
+    ModalMessage message =
+        ModalMessage.builder()
+            .setAction(ACTION_MODEL_WITH_BUTTON)
+            .setImageData(IMAGE_DATA)
+            .setTitle(TITLE_MODEL)
+            .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+            .build(CAMPAIGN_METADATA_MODEL);
+
+    modalBindingWrapper =
+        new ModalBindingWrapper(modalPortraitLayoutConfig, layoutInflater, message);
+
+    modalBindingWrapper.inflate(actionListeners, onDismissListener);
+    assertEquals(modalBindingWrapper.getScrollView().getVisibility(), View.GONE);
+  }
 }
diff --git a/firebase-inappmessaging-display/src/main/AndroidManifest.xml b/firebase-inappmessaging-display/src/main/AndroidManifest.xml
index 5a96198a8..adfc64a39 100644
--- a/firebase-inappmessaging-display/src/main/AndroidManifest.xml
+++ b/firebase-inappmessaging-display/src/main/AndroidManifest.xml
@@ -1,12 +1,11 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.firebase.inappmessaging.display">
 
-  <!--Although the *SdkVersion is captured in gradle build files, this is required for non gradle builds-->
-  <!--<uses-sdk android:minSdkVersion="16" />-->
   <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
   <uses-permission android:name="android.permission.INTERNET" />
   <application>
-    <service android:name="com.google.firebase.components.ComponentDiscoveryService" android:exported="false">
+    <service android:name="com.google.firebase.components.ComponentDiscoveryService"
+        android:exported="false">
       <meta-data android:name="com.google.firebase.components:com.google.firebase.inappmessaging.display.FirebaseInAppMessagingDisplayRegistrar"
           android:value="com.google.firebase.components.ComponentRegistrar" />
     </service>
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/FiamListener.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/FiamListener.java
index b5ede688c..671bc6fc5 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/FiamListener.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/FiamListener.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.inappmessaging.display;
 
-import android.support.annotation.Keep;
+import androidx.annotation.Keep;
 
 /**
  * Listener interface to be notified of in app messaging events. Use to register your listener.
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/FirebaseInAppMessagingDisplay.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/FirebaseInAppMessagingDisplay.java
index 51111d296..68081273d 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/FirebaseInAppMessagingDisplay.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/FirebaseInAppMessagingDisplay.java
@@ -19,16 +19,17 @@
 import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.app.Application;
+import android.content.res.Configuration;
 import android.net.Uri;
-import android.support.annotation.Keep;
-import android.support.annotation.NonNull;
-import android.support.annotation.VisibleForTesting;
-import android.support.customtabs.CustomTabsIntent;
 import android.text.TextUtils;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewTreeObserver.OnGlobalLayoutListener;
-import com.google.android.gms.common.annotation.KeepForSdk;
+import androidx.annotation.Keep;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import androidx.browser.customtabs.CustomTabsIntent;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.inappmessaging.FirebaseInAppMessaging;
 import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks;
@@ -44,9 +45,18 @@
 import com.google.firebase.inappmessaging.display.internal.bindingwrappers.BindingWrapper;
 import com.google.firebase.inappmessaging.display.internal.injection.modules.InflaterConfigModule;
 import com.google.firebase.inappmessaging.display.internal.injection.scopes.FirebaseAppScope;
+import com.google.firebase.inappmessaging.model.Action;
+import com.google.firebase.inappmessaging.model.BannerMessage;
+import com.google.firebase.inappmessaging.model.CardMessage;
+import com.google.firebase.inappmessaging.model.ImageData;
+import com.google.firebase.inappmessaging.model.ImageOnlyMessage;
 import com.google.firebase.inappmessaging.model.InAppMessage;
 import com.google.firebase.inappmessaging.model.MessageType;
+import com.google.firebase.inappmessaging.model.ModalMessage;
 import com.squareup.picasso.Callback;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -65,7 +75,7 @@
  *   <li>send usage metrics to the Firebase backend.
  * </ul>
  *
- * To delete the Instance ID and the data associated with it, see {@link
+ * <p>To delete the Instance ID and the data associated with it, see {@link
  * com.google.firebase.iid.FirebaseInstanceId#deleteInstanceId}.
  */
 @Keep
@@ -120,6 +130,7 @@
    * Get FirebaseInAppMessagingDisplay instance using the default firebase app, returned by {@link
    * FirebaseApp#getInstance()}
    */
+  @NonNull
   @Keep
   public static FirebaseInAppMessagingDisplay getInstance() {
     return FirebaseApp.getInstance().get(FirebaseInAppMessagingDisplay.class);
@@ -135,7 +146,6 @@ private static int getScreenOrientation(Application app) {
    * @hide
    */
   @Keep
-  @KeepForSdk
   public void testMessage(
       Activity activity,
       InAppMessage inAppMessage,
@@ -151,7 +161,6 @@ public void testMessage(
    * @hide
    */
   @Keep
-  @KeepForSdk
   public void setFiamListener(FiamListener listener) {
     this.fiamListener = listener;
   }
@@ -162,7 +171,6 @@ public void setFiamListener(FiamListener listener) {
    * @hide
    */
   @Keep
-  @KeepForSdk
   public void clearFiamListener() {
     this.fiamListener = null;
   }
@@ -173,9 +181,9 @@ public void clearFiamListener() {
    * @hide
    */
   @Keep
-  @KeepForSdk
   @Override
   public void onActivityStarted(final Activity activity) {
+    super.onActivityStarted(activity);
     // Register FIAM listener with the headless sdk.
     firebaseInAppMessagingDisplay =
         new com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplay() {
@@ -192,7 +200,6 @@ public void displayMessage(InAppMessage iam, FirebaseInAppMessagingDisplayCallba
             showActiveFiam(activity);
           }
         };
-
     headlessInAppMessaging.setMessageDisplayComponent(firebaseInAppMessagingDisplay);
   }
 
@@ -202,22 +209,36 @@ public void displayMessage(InAppMessage iam, FirebaseInAppMessagingDisplayCallba
    * @hide
    */
   @Keep
-  @KeepForSdk
   @Override
   public void onActivityPaused(Activity activity) {
+    // clear all state scoped to activity and dismiss fiam
+    headlessInAppMessaging.clearDisplayListener();
+    imageLoader.cancelTag(activity.getClass());
+    removeDisplayedFiam(activity);
     super.onActivityPaused(activity);
+  }
+
+  /**
+   * Clear fiam listener on activity destroyed
+   *
+   * @hide
+   */
+  @Keep
+  @Override
+  public void onActivityDestroyed(Activity activity) {
     // clear all state scoped to activity and dismiss fiam
     headlessInAppMessaging.clearDisplayListener();
     imageLoader.cancelTag(activity.getClass());
     removeDisplayedFiam(activity);
+    super.onActivityDestroyed(activity);
   }
+
   /**
    * Clear fiam listener on activity resumed
    *
    * @hide
    */
   @Keep
-  @KeepForSdk
   @Override
   public void onActivityResumed(Activity activity) {
     super.onActivityResumed(activity);
@@ -237,6 +258,11 @@ private void showActiveFiam(@NonNull final Activity activity) {
       Logging.loge("No active message found to render");
       return;
     }
+
+    if (inAppMessage.getMessageType().equals(MessageType.UNSUPPORTED)) {
+      Logging.loge("The message being triggered is not supported by this version of the sdk.");
+      return;
+    }
     notifyFiamTrigger();
 
     InAppMessageLayoutConfig config =
@@ -248,12 +274,23 @@ private void showActiveFiam(@NonNull final Activity activity) {
 
     final BindingWrapper bindingWrapper;
 
-    if (inAppMessage.getMessageType() == MessageType.MODAL) {
-      bindingWrapper = bindingWrapperFactory.createModalBindingWrapper(config, inAppMessage);
-    } else if (inAppMessage.getMessageType() == MessageType.BANNER) {
-      bindingWrapper = bindingWrapperFactory.createBannerBindingWrapper(config, inAppMessage);
-    } else {
-      bindingWrapper = bindingWrapperFactory.createImageBindingWrapper(config, inAppMessage);
+    switch (inAppMessage.getMessageType()) {
+      case BANNER:
+        bindingWrapper = bindingWrapperFactory.createBannerBindingWrapper(config, inAppMessage);
+        break;
+      case MODAL:
+        bindingWrapper = bindingWrapperFactory.createModalBindingWrapper(config, inAppMessage);
+        break;
+      case IMAGE_ONLY:
+        bindingWrapper = bindingWrapperFactory.createImageBindingWrapper(config, inAppMessage);
+        break;
+      case CARD:
+        bindingWrapper = bindingWrapperFactory.createCardBindingWrapper(config, inAppMessage);
+        break;
+      default:
+        Logging.loge("No bindings found for this message type");
+        // so we should break out completely and not attempt to show anything
+        return;
     }
 
     // The WindowManager LayoutParams.TYPE_APPLICATION_PANEL requires tokens from the activity
@@ -285,37 +322,44 @@ public void onClick(View v) {
           }
         };
 
+    Map<Action, View.OnClickListener> actionListeners = new HashMap<>();
     // If the message has an action, but not an action url, we dismiss when the action
     // button is
     // clicked;
-    final View.OnClickListener actionListener;
-    if (inAppMessage.getAction() != null
-        && !TextUtils.isEmpty(inAppMessage.getAction().getActionUrl())) {
-      actionListener =
-          new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-              if (callbacks != null) {
-                callbacks.messageClicked();
+    for (Action action : extractActions(inAppMessage)) {
+
+      final View.OnClickListener actionListener;
+
+      // TODO: need an onclick listener per action
+      if (action != null && !TextUtils.isEmpty(action.getActionUrl())) {
+        actionListener =
+            new View.OnClickListener() {
+              @Override
+              public void onClick(View v) {
+                if (callbacks != null) {
+                  callbacks.messageClicked(action);
+                }
+                final CustomTabsIntent i =
+                    new CustomTabsIntent.Builder().setShowTitle(true).build();
+
+                i.launchUrl(activity, Uri.parse(action.getActionUrl()));
+                notifyFiamClick();
+                // Ensure that we remove the displayed FIAM, and ensure that on re-load, the message
+                // isn't re-displayed
+                removeDisplayedFiam(activity);
+                inAppMessage = null;
+                callbacks = null;
               }
-              final CustomTabsIntent i = new CustomTabsIntent.Builder().setShowTitle(true).build();
-
-              i.launchUrl(activity, Uri.parse(inAppMessage.getAction().getActionUrl()));
-              notifyFiamClick();
-              // Ensure that we remove the displayed FIAM, and ensure that on re-load, the message
-              // isn't re-displayed
-              removeDisplayedFiam(activity);
-              inAppMessage = null;
-              callbacks = null;
-            }
-          };
-    } else {
-      Logging.loge("No action url found for action.");
-      actionListener = dismissListener;
+            };
+      } else {
+        Logging.loge("No action url found for action.");
+        actionListener = dismissListener;
+      }
+      actionListeners.put(action, actionListener);
     }
 
     final OnGlobalLayoutListener layoutListener =
-        bindingWrapper.inflate(actionListener, dismissListener);
+        bindingWrapper.inflate(actionListeners, dismissListener);
     if (layoutListener != null) {
       bindingWrapper.getImageView().getViewTreeObserver().addOnGlobalLayoutListener(layoutListener);
     }
@@ -324,7 +368,7 @@ public void onClick(View v) {
     loadNullableImage(
         activity,
         bindingWrapper,
-        inAppMessage.getImageUrl(),
+        extractImageData(inAppMessage),
         new Callback() {
           @Override
           public void onSuccess() {
@@ -356,7 +400,8 @@ public boolean onTouch(View v, MotionEvent event) {
                   public void onFinish() {
                     if (inAppMessage != null && callbacks != null) {
                       Logging.logi(
-                          "Impression timer onFinish for: " + inAppMessage.getCampaignId());
+                          "Impression timer onFinish for: "
+                              + inAppMessage.getCampaignMetadata().getCampaignId());
 
                       callbacks.impressionDetected();
                     }
@@ -382,16 +427,21 @@ public void onFinish() {
                   INTERVAL_MILLIS);
             }
 
-            windowManager.show(bindingWrapper, activity);
-
-            if (bindingWrapper.getConfig().animate()) {
-              // Animate entry
-              animator.slideIntoView(application, bindingWrapper.getRootView(), TOP);
-            }
+            activity.runOnUiThread(
+                new Runnable() {
+                  @Override
+                  public void run() {
+                    windowManager.show(bindingWrapper, activity);
+                    if (bindingWrapper.getConfig().animate()) {
+                      // Animate entry
+                      animator.slideIntoView(application, bindingWrapper.getRootView(), TOP);
+                    }
+                  }
+                });
           }
 
           @Override
-          public void onError() {
+          public void onError(Exception e) {
             Logging.loge("Image download failure ");
             if (layoutListener != null) {
               bindingWrapper
@@ -406,11 +456,57 @@ public void onError() {
         });
   }
 
+  private List<Action> extractActions(InAppMessage message) {
+    List<Action> actions = new ArrayList<>();
+    switch (message.getMessageType()) {
+      case BANNER:
+        actions.add(((BannerMessage) message).getAction());
+        break;
+      case CARD:
+        actions.add(((CardMessage) message).getPrimaryAction());
+        actions.add(((CardMessage) message).getSecondaryAction());
+        break;
+      case IMAGE_ONLY:
+        actions.add(((ImageOnlyMessage) message).getAction());
+        break;
+      case MODAL:
+        actions.add(((ModalMessage) message).getAction());
+        break;
+      default:
+        // An empty action is treated like a dismiss
+        actions.add(Action.builder().build());
+    }
+    return actions;
+  }
+
+  // TODO: Factor this into the InAppMessage API.
+  private ImageData extractImageData(InAppMessage message) {
+    // Handle getting image data for card type
+    if (message.getMessageType() == MessageType.CARD) {
+      ImageData portraitImageData = ((CardMessage) message).getPortraitImageData();
+      ImageData landscapeImageData = ((CardMessage) message).getLandscapeImageData();
+
+      // If we're in portrait try to use portrait image data, fallback to landscape
+      if (getScreenOrientation(application) == Configuration.ORIENTATION_PORTRAIT) {
+        return isValidImageData(portraitImageData) ? portraitImageData : landscapeImageData;
+      }
+      // If we're in landscape try to use landscape image data, fallback to portrait
+      return isValidImageData(landscapeImageData) ? landscapeImageData : portraitImageData;
+    }
+    // For now this is how we get all other fiam types image data.
+    return message.getImageData();
+  }
+
+  // TODO: Factor this into the InAppMessage API
+  private boolean isValidImageData(@Nullable ImageData imageData) {
+    return imageData != null && !TextUtils.isEmpty(imageData.getImageUrl());
+  }
+
   private void loadNullableImage(
-      Activity activity, BindingWrapper fiam, String imageUrl, Callback callback) {
-    if (!TextUtils.isEmpty(imageUrl)) {
+      Activity activity, BindingWrapper fiam, ImageData imageData, Callback callback) {
+    if (isValidImageData(imageData)) {
       imageLoader
-          .load(imageUrl)
+          .load(imageData.getImageUrl())
           .tag(activity.getClass())
           .placeholder(R.drawable.image_placeholder)
           .into(fiam.getImageView(), callback);
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/FirebaseInAppMessagingDisplayRegistrar.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/FirebaseInAppMessagingDisplayRegistrar.java
index b11e5fc74..abf2f2d60 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/FirebaseInAppMessagingDisplayRegistrar.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/FirebaseInAppMessagingDisplayRegistrar.java
@@ -15,7 +15,7 @@
 package com.google.firebase.inappmessaging.display;
 
 import android.app.Application;
-import android.support.annotation.Keep;
+import androidx.annotation.Keep;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.analytics.connector.AnalyticsConnector;
 import com.google.firebase.components.Component;
@@ -29,7 +29,8 @@
 import com.google.firebase.inappmessaging.display.internal.injection.components.UniversalComponent;
 import com.google.firebase.inappmessaging.display.internal.injection.modules.ApplicationModule;
 import com.google.firebase.inappmessaging.display.internal.injection.modules.HeadlessInAppMessagingModule;
-import java.util.Collections;
+import com.google.firebase.platforminfo.LibraryVersionComponent;
+import java.util.Arrays;
 import java.util.List;
 
 /**
@@ -42,14 +43,15 @@
   @Override
   @Keep
   public List<Component<?>> getComponents() {
-    return Collections.singletonList(
+    return Arrays.asList(
         Component.builder(FirebaseInAppMessagingDisplay.class)
             .add(Dependency.required(FirebaseApp.class))
             .add(Dependency.required(AnalyticsConnector.class))
             .add(Dependency.required(FirebaseInAppMessaging.class))
-            .factory(c -> buildFirebaseInAppMessagingUI(c))
+            .factory(this::buildFirebaseInAppMessagingUI)
             .eagerInDefaultApp()
-            .build());
+            .build(),
+        LibraryVersionComponent.create("fire-fiamd", BuildConfig.VERSION_NAME));
   }
 
   private FirebaseInAppMessagingDisplay buildFirebaseInAppMessagingUI(
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/BindingWrapperFactory.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/BindingWrapperFactory.java
index 1bb9af6a4..edcc25055 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/BindingWrapperFactory.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/BindingWrapperFactory.java
@@ -60,4 +60,13 @@ public BindingWrapper createBannerBindingWrapper(
             .build();
     return inAppMessageComponent.bannerBindingWrapper();
   }
+
+  public BindingWrapper createCardBindingWrapper(
+      InAppMessageLayoutConfig config, InAppMessage inAppMessage) {
+    InAppMessageComponent inAppMessageComponent =
+        DaggerInAppMessageComponent.builder()
+            .inflaterModule(new InflaterModule(inAppMessage, config, application))
+            .build();
+    return inAppMessageComponent.cardBindingWrapper();
+  }
 }
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/FiamImageLoader.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/FiamImageLoader.java
index 70fe795b2..7951ef8de 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/FiamImageLoader.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/FiamImageLoader.java
@@ -14,8 +14,8 @@
 
 package com.google.firebase.inappmessaging.display.internal;
 
-import android.support.annotation.Nullable;
 import android.widget.ImageView;
+import androidx.annotation.Nullable;
 import com.google.firebase.inappmessaging.display.internal.injection.scopes.FirebaseAppScope;
 import com.squareup.picasso.Callback;
 import com.squareup.picasso.Picasso;
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/FiamWindowManager.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/FiamWindowManager.java
index 96362266f..b3676cb53 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/FiamWindowManager.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/FiamWindowManager.java
@@ -20,13 +20,13 @@
 import android.graphics.Point;
 import android.graphics.Rect;
 import android.os.Build;
-import android.support.annotation.NonNull;
 import android.view.Display;
 import android.view.Gravity;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.Window;
 import android.view.WindowManager;
+import androidx.annotation.NonNull;
 import com.google.firebase.inappmessaging.display.internal.bindingwrappers.BindingWrapper;
 import javax.inject.Inject;
 import javax.inject.Singleton;
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/InAppMessageLayoutConfig.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/InAppMessageLayoutConfig.java
index d10dd4439..2c18c4ccc 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/InAppMessageLayoutConfig.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/InAppMessageLayoutConfig.java
@@ -14,8 +14,8 @@
 
 package com.google.firebase.inappmessaging.display.internal;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 
 /**
  * Configurations for in app message layouts
@@ -36,7 +36,7 @@
   private Integer windowHeight;
   private Boolean backgroundEnabled;
   private Boolean animate;
-  private Boolean autoDismiss;;
+  private Boolean autoDismiss;
 
   @NonNull
   public static Builder builder() {
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/PicassoErrorListener.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/PicassoErrorListener.java
index da70e6cdf..cbb78e880 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/PicassoErrorListener.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/PicassoErrorListener.java
@@ -25,7 +25,6 @@
 import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks.InAppMessagingErrorReason;
 import com.google.firebase.inappmessaging.display.internal.injection.scopes.FirebaseAppScope;
 import com.google.firebase.inappmessaging.model.InAppMessage;
-import com.squareup.picasso.Downloader;
 import com.squareup.picasso.Picasso;
 import java.io.IOException;
 import javax.inject.Inject;
@@ -48,9 +47,7 @@ public void setInAppMessage(
   @Override
   public void onImageLoadFailed(Picasso picasso, Uri uri, Exception exception) {
     if (inAppMessage != null && displayCallbacks != null) {
-      if (exception instanceof Downloader.ResponseException) {
-        displayCallbacks.displayErrorEncountered(InAppMessagingErrorReason.IMAGE_FETCH_ERROR);
-      } else if (exception instanceof IOException
+      if (exception instanceof IOException
           && exception.getLocalizedMessage().contains("Failed to decode")) {
         displayCallbacks.displayErrorEncountered(
             InAppMessagingErrorReason.IMAGE_UNSUPPORTED_FORMAT);
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/ResizableImageView.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/ResizableImageView.java
index 185f0a1ad..2ba1a54bb 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/ResizableImageView.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/ResizableImageView.java
@@ -17,9 +17,10 @@
 import android.content.Context;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
-import android.support.annotation.NonNull;
 import android.util.AttributeSet;
 import android.util.DisplayMetrics;
+import androidx.annotation.NonNull;
+import androidx.appcompat.widget.AppCompatImageView;
 
 /**
  * The purpose of this Image view is best explained in the SO post:
@@ -33,7 +34,7 @@
  * @hide
  */
 // TODO (ashwinraghav) tests pending
-public class ResizableImageView extends android.support.v7.widget.AppCompatImageView {
+public class ResizableImageView extends AppCompatImageView {
   private int mDensityDpi;
 
   public ResizableImageView(Context context) {
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/SwipeDismissTouchListener.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/SwipeDismissTouchListener.java
index 81fd02fa0..337d48832 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/SwipeDismissTouchListener.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/SwipeDismissTouchListener.java
@@ -34,12 +34,12 @@
 import android.animation.AnimatorListenerAdapter;
 import android.animation.ValueAnimator;
 import android.annotation.SuppressLint;
-import android.support.annotation.Nullable;
 import android.view.MotionEvent;
 import android.view.VelocityTracker;
 import android.view.View;
 import android.view.ViewConfiguration;
 import android.view.ViewGroup;
+import androidx.annotation.Nullable;
 
 /**
  * A {@link View.OnTouchListener} that makes any {@link View} dismissable when the user swipes
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/BannerBindingWrapper.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/BannerBindingWrapper.java
index 64544a59a..16a687552 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/BannerBindingWrapper.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/BannerBindingWrapper.java
@@ -15,9 +15,6 @@
 package com.google.firebase.inappmessaging.display.internal.bindingwrappers;
 
 import android.graphics.Color;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.RestrictTo;
 import android.text.TextUtils;
 import android.view.LayoutInflater;
 import android.view.View;
@@ -25,12 +22,19 @@
 import android.view.ViewTreeObserver;
 import android.widget.ImageView;
 import android.widget.TextView;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RestrictTo;
 import com.google.firebase.inappmessaging.display.R;
 import com.google.firebase.inappmessaging.display.internal.InAppMessageLayoutConfig;
 import com.google.firebase.inappmessaging.display.internal.ResizableImageView;
 import com.google.firebase.inappmessaging.display.internal.injection.scopes.InAppMessageScope;
 import com.google.firebase.inappmessaging.display.internal.layout.FiamFrameLayout;
+import com.google.firebase.inappmessaging.model.Action;
+import com.google.firebase.inappmessaging.model.BannerMessage;
 import com.google.firebase.inappmessaging.model.InAppMessage;
+import com.google.firebase.inappmessaging.model.MessageType;
+import java.util.Map;
 import javax.inject.Inject;
 
 /** @hide */
@@ -49,16 +53,16 @@
 
   @Inject
   @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
-  // TODO: Re-order this constructor
   public BannerBindingWrapper(
-      InAppMessage message, LayoutInflater inflater, InAppMessageLayoutConfig config) {
+      InAppMessageLayoutConfig config, LayoutInflater inflater, InAppMessage message) {
     super(config, inflater, message);
   }
 
   @Nullable
   @Override
   public ViewTreeObserver.OnGlobalLayoutListener inflate(
-      View.OnClickListener actionListener, View.OnClickListener dismissOnClickListener) {
+      Map<Action, View.OnClickListener> actionListeners,
+      View.OnClickListener dismissOnClickListener) {
 
     View root = inflater.inflate(R.layout.banner, null);
     bannerRoot = root.findViewById(R.id.banner_root);
@@ -67,20 +71,25 @@ public BannerBindingWrapper(
     bannerImage = root.findViewById(R.id.banner_image);
     bannerTitle = root.findViewById(R.id.banner_title);
 
-    setMessage(message);
-    setLayoutConfig(config);
-    setSwipeDismissListener(dismissOnClickListener);
-    setActionListener(actionListener);
-
+    if (message.getMessageType().equals(MessageType.BANNER)) {
+      BannerMessage bannerMessage = (BannerMessage) message;
+      setMessage(bannerMessage);
+      setLayoutConfig(config);
+      setSwipeDismissListener(dismissOnClickListener);
+      setActionListener(actionListeners.get(bannerMessage.getAction()));
+    }
     return null;
   }
 
-  private void setMessage(@NonNull InAppMessage message) {
+  private void setMessage(@NonNull BannerMessage message) {
     if (!TextUtils.isEmpty(message.getBackgroundHexColor())) {
-      setGradientDrawableBgColor(bannerContentRoot, message.getBackgroundHexColor());
+      setViewBgColorFromHex(bannerContentRoot, message.getBackgroundHexColor());
     }
 
-    bannerImage.setVisibility(TextUtils.isEmpty(message.getImageUrl()) ? View.GONE : View.VISIBLE);
+    bannerImage.setVisibility(
+        (message.getImageData() == null || TextUtils.isEmpty(message.getImageData().getImageUrl()))
+            ? View.GONE
+            : View.VISIBLE);
 
     if (message.getTitle() != null) {
       if (!TextUtils.isEmpty(message.getTitle().getText())) {
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/BindingWrapper.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/BindingWrapper.java
index 1c09fc426..c78e96ba3 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/BindingWrapper.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/BindingWrapper.java
@@ -15,18 +15,23 @@
 package com.google.firebase.inappmessaging.display.internal.bindingwrappers;
 
 import android.graphics.Color;
-import android.graphics.drawable.GradientDrawable;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import android.graphics.drawable.Drawable;
+import android.text.TextUtils;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.View.OnClickListener;
 import android.view.ViewGroup;
 import android.view.ViewTreeObserver.OnGlobalLayoutListener;
+import android.widget.Button;
 import android.widget.ImageView;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.core.graphics.drawable.DrawableCompat;
 import com.google.firebase.inappmessaging.display.internal.InAppMessageLayoutConfig;
 import com.google.firebase.inappmessaging.display.internal.Logging;
+import com.google.firebase.inappmessaging.model.Action;
 import com.google.firebase.inappmessaging.model.InAppMessage;
+import java.util.Map;
 
 /**
  * View container for all in app message layouts This container serves as an abstraction around
@@ -57,7 +62,7 @@ protected BindingWrapper(
 
   @Nullable
   public abstract OnGlobalLayoutListener inflate(
-      OnClickListener actionListener, OnClickListener dismissOnClickListener);
+      Map<Action, OnClickListener> actionListeners, OnClickListener dismissOnClickListener);
 
   public boolean canSwipeToDismiss() {
     return false;
@@ -66,22 +71,48 @@ public boolean canSwipeToDismiss() {
   @Nullable
   public OnClickListener getDismissListener() {
     return null;
-  };
+  }
 
   @NonNull
   public InAppMessageLayoutConfig getConfig() {
     return config;
   }
 
-  protected void setGradientDrawableBgColor(View view, String hexColor) {
-    if (view != null && hexColor != null) {
-      GradientDrawable layoutBg = (GradientDrawable) view.getBackground();
-      try {
-        layoutBg.setColor(Color.parseColor(hexColor));
-      } catch (IllegalArgumentException e) {
-        // If the color didnt parse correctly, fail 'open', with default background color
-        Logging.loge("Error parsing background color: " + e.toString());
-      }
+  protected void setViewBgColorFromHex(@Nullable View view, @Nullable String hexColor) {
+    if (view == null || TextUtils.isEmpty(hexColor)) return;
+    try {
+      view.setBackgroundColor(Color.parseColor(hexColor));
+    } catch (IllegalArgumentException e) {
+      // If the color didnt parse correctly, fail 'open', with default background color
+      Logging.loge("Error parsing background color: " + e.toString() + " color: " + hexColor);
+    }
+  }
+
+  public static void setButtonBgColorFromHex(Button button, String hexColor) {
+    try {
+      Drawable drawable = button.getBackground();
+      Drawable compatDrawable = DrawableCompat.wrap(drawable);
+      DrawableCompat.setTint(compatDrawable, Color.parseColor(hexColor));
+      button.setBackground(compatDrawable);
+    } catch (IllegalArgumentException e) {
+      // If the color didnt parse correctly, fail 'open', with default background color
+      Logging.loge("Error parsing background color: " + e.toString());
+    }
+  }
+
+  // Worth changing the API allow for building a UI model from a data model. Future change.
+  public static void setupViewButtonFromModel(
+      Button viewButton, com.google.firebase.inappmessaging.model.Button modelButton) {
+    String buttonTextHexColor = modelButton.getText().getHexColor();
+    setButtonBgColorFromHex(viewButton, modelButton.getButtonHexColor());
+    viewButton.setText(modelButton.getText().getText());
+    viewButton.setTextColor(Color.parseColor(buttonTextHexColor));
+  }
+
+  protected void setButtonActionListener(
+      @Nullable Button button, View.OnClickListener actionListener) {
+    if (button != null) {
+      button.setOnClickListener(actionListener);
     }
   }
 }
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/CardBindingWrapper.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/CardBindingWrapper.java
new file mode 100644
index 000000000..17808074c
--- /dev/null
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/CardBindingWrapper.java
@@ -0,0 +1,214 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.display.internal.bindingwrappers;
+
+import android.graphics.Color;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver;
+import android.widget.Button;
+import android.widget.ImageView;
+import android.widget.ScrollView;
+import android.widget.TextView;
+import androidx.annotation.NonNull;
+import androidx.annotation.RestrictTo;
+import androidx.annotation.VisibleForTesting;
+import com.google.firebase.inappmessaging.display.R;
+import com.google.firebase.inappmessaging.display.internal.InAppMessageLayoutConfig;
+import com.google.firebase.inappmessaging.display.internal.injection.scopes.InAppMessageScope;
+import com.google.firebase.inappmessaging.display.internal.layout.BaseModalLayout;
+import com.google.firebase.inappmessaging.display.internal.layout.FiamCardView;
+import com.google.firebase.inappmessaging.model.Action;
+import com.google.firebase.inappmessaging.model.CardMessage;
+import com.google.firebase.inappmessaging.model.InAppMessage;
+import com.google.firebase.inappmessaging.model.MessageType;
+import java.util.Map;
+import javax.inject.Inject;
+
+/** @hide */
+@InAppMessageScope
+public class CardBindingWrapper extends BindingWrapper {
+
+  private FiamCardView cardRoot;
+  private BaseModalLayout cardContentRoot;
+  private ScrollView bodyScroll;
+  private Button primaryButton;
+  private Button secondaryButton;
+  private ImageView imageView;
+  private TextView messageBody;
+  private TextView messageTitle;
+  private CardMessage cardMessage;
+  private View.OnClickListener dismissListener;
+
+  private ViewTreeObserver.OnGlobalLayoutListener layoutListener =
+      new ScrollViewAdjustableListener();
+
+  @Inject
+  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+  public CardBindingWrapper(
+      InAppMessageLayoutConfig config, LayoutInflater inflater, InAppMessage message) {
+    super(config, inflater, message);
+  }
+
+  @NonNull
+  @Override
+  public ViewTreeObserver.OnGlobalLayoutListener inflate(
+      Map<Action, View.OnClickListener> actionListeners,
+      View.OnClickListener dismissOnClickListener) {
+
+    View root = inflater.inflate(R.layout.card, null);
+    bodyScroll = root.findViewById(R.id.body_scroll);
+    primaryButton = root.findViewById(R.id.primary_button);
+    secondaryButton = root.findViewById(R.id.secondary_button);
+    imageView = root.findViewById(R.id.image_view);
+    messageBody = root.findViewById(R.id.message_body);
+    messageTitle = root.findViewById(R.id.message_title);
+    cardRoot = root.findViewById(R.id.card_root);
+    cardContentRoot = root.findViewById(R.id.card_content_root);
+
+    if (message.getMessageType().equals(MessageType.CARD)) {
+      cardMessage = (CardMessage) message;
+      setMessage(cardMessage);
+      setImage(cardMessage);
+      setButtons(actionListeners);
+      setLayoutConfig(config);
+      setDismissListener(dismissOnClickListener);
+      setViewBgColorFromHex(cardContentRoot, cardMessage.getBackgroundHexColor());
+    }
+    return layoutListener;
+  }
+
+  @NonNull
+  @Override
+  public ImageView getImageView() {
+    return imageView;
+  }
+
+  @NonNull
+  public View getScrollView() {
+    return bodyScroll;
+  }
+
+  @NonNull
+  public View getTitleView() {
+    return messageTitle;
+  }
+
+  @NonNull
+  @Override
+  public ViewGroup getRootView() {
+    return cardRoot;
+  }
+
+  @NonNull
+  @Override
+  public View getDialogView() {
+    return cardContentRoot;
+  }
+
+  @NonNull
+  @Override
+  public InAppMessageLayoutConfig getConfig() {
+    return config;
+  }
+
+  @NonNull
+  @Override
+  public View.OnClickListener getDismissListener() {
+    return dismissListener;
+  }
+
+  @NonNull
+  public Button getPrimaryButton() {
+    return primaryButton;
+  }
+
+  @NonNull
+  public Button getSecondaryButton() {
+    return secondaryButton;
+  }
+
+  private void setMessage(CardMessage message) {
+    // We can assume we have a title because the CardMessage model enforces it.
+    messageTitle.setText(message.getTitle().getText());
+    messageTitle.setTextColor(Color.parseColor(message.getTitle().getHexColor()));
+
+    // Right now we need to check for null, eventually we will make an API change to have hasBody()
+    // Additionally right now we have to check for getText. this will be fixed soon.
+    if (message.getBody() != null && message.getBody().getText() != null) {
+      bodyScroll.setVisibility(View.VISIBLE);
+      messageBody.setVisibility(View.VISIBLE);
+      messageBody.setText(message.getBody().getText());
+      messageBody.setTextColor(Color.parseColor(message.getBody().getHexColor()));
+    } else {
+      bodyScroll.setVisibility(View.GONE);
+      messageBody.setVisibility(View.GONE);
+    }
+  }
+
+  private void setButtons(Map<Action, View.OnClickListener> actionListeners) {
+    Action primaryAction = cardMessage.getPrimaryAction();
+    Action secondaryAction = cardMessage.getSecondaryAction();
+
+    // Primary button will always exist.
+    setupViewButtonFromModel(primaryButton, primaryAction.getButton());
+    // The main display code will override the action listener with a dismiss listener in the case
+    // of a missing action url.
+    setButtonActionListener(primaryButton, actionListeners.get(primaryAction));
+    primaryButton.setVisibility(View.VISIBLE);
+
+    // Secondary button is optional, eventually this null check will be at the model level.
+    if (secondaryAction != null && secondaryAction.getButton() != null) {
+      setupViewButtonFromModel(secondaryButton, secondaryAction.getButton());
+      setButtonActionListener(secondaryButton, actionListeners.get(secondaryAction));
+      secondaryButton.setVisibility(View.VISIBLE);
+    } else {
+      secondaryButton.setVisibility(View.GONE);
+    }
+  }
+
+  private void setImage(CardMessage message) {
+    // Right now we need to check for null, eventually we will make an API change hasImageData()
+    if (message.getPortraitImageData() != null || message.getLandscapeImageData() != null) {
+      imageView.setVisibility(View.VISIBLE);
+    } else {
+      imageView.setVisibility(View.GONE);
+    }
+  }
+
+  private void setLayoutConfig(InAppMessageLayoutConfig config) {
+    imageView.setMaxHeight(config.getMaxImageHeight());
+    imageView.setMaxWidth(config.getMaxImageWidth());
+  }
+
+  private void setDismissListener(View.OnClickListener dismissListener) {
+    this.dismissListener = dismissListener;
+    cardRoot.setDismissListener(dismissListener);
+  }
+
+  @VisibleForTesting
+  public void setLayoutListener(ViewTreeObserver.OnGlobalLayoutListener listener) {
+    layoutListener = listener;
+  }
+
+  // TODO: Kill this.
+  public class ScrollViewAdjustableListener implements ViewTreeObserver.OnGlobalLayoutListener {
+    @Override
+    public void onGlobalLayout() {
+      imageView.getViewTreeObserver().removeGlobalOnLayoutListener(this);
+    }
+  }
+}
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/ImageBindingWrapper.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/ImageBindingWrapper.java
index 19bc4d8dd..28960d9f0 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/ImageBindingWrapper.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/ImageBindingWrapper.java
@@ -14,9 +14,6 @@
 
 package com.google.firebase.inappmessaging.display.internal.bindingwrappers;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.RestrictTo;
 import android.text.TextUtils;
 import android.view.LayoutInflater;
 import android.view.View;
@@ -24,11 +21,18 @@
 import android.view.ViewTreeObserver;
 import android.widget.Button;
 import android.widget.ImageView;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RestrictTo;
 import com.google.firebase.inappmessaging.display.R;
 import com.google.firebase.inappmessaging.display.internal.InAppMessageLayoutConfig;
 import com.google.firebase.inappmessaging.display.internal.injection.scopes.InAppMessageScope;
 import com.google.firebase.inappmessaging.display.internal.layout.FiamFrameLayout;
+import com.google.firebase.inappmessaging.model.Action;
+import com.google.firebase.inappmessaging.model.ImageOnlyMessage;
 import com.google.firebase.inappmessaging.model.InAppMessage;
+import com.google.firebase.inappmessaging.model.MessageType;
+import java.util.Map;
 import javax.inject.Inject;
 
 /**
@@ -56,7 +60,8 @@ public ImageBindingWrapper(
   @Nullable
   @Override
   public ViewTreeObserver.OnGlobalLayoutListener inflate(
-      View.OnClickListener actionListener, View.OnClickListener dismissOnClickListener) {
+      Map<Action, View.OnClickListener> actionListeners,
+      View.OnClickListener dismissOnClickListener) {
     View v = inflater.inflate(R.layout.image, null);
     imageRoot = v.findViewById(R.id.image_root);
     imageContentRoot = v.findViewById(R.id.image_content_root);
@@ -66,8 +71,14 @@ public ImageBindingWrapper(
     // Setup ImageView.
     imageView.setMaxHeight(config.getMaxImageHeight());
     imageView.setMaxWidth(config.getMaxImageWidth());
-    imageView.setVisibility(TextUtils.isEmpty(message.getImageUrl()) ? View.GONE : View.VISIBLE);
-    imageView.setOnClickListener(actionListener);
+    if (message.getMessageType().equals(MessageType.IMAGE_ONLY)) {
+      ImageOnlyMessage msg = (ImageOnlyMessage) message;
+      imageView.setVisibility(
+          (msg.getImageData() == null || TextUtils.isEmpty(msg.getImageData().getImageUrl()))
+              ? View.GONE
+              : View.VISIBLE);
+      imageView.setOnClickListener(actionListeners.get(msg.getAction()));
+    }
 
     // Setup dismiss button.
     imageRoot.setDismissListener(dismissOnClickListener);
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/ModalBindingWrapper.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/ModalBindingWrapper.java
index fd98d83f4..388186292 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/ModalBindingWrapper.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/bindingwrappers/ModalBindingWrapper.java
@@ -15,11 +15,6 @@
 package com.google.firebase.inappmessaging.display.internal.bindingwrappers;
 
 import android.graphics.Color;
-import android.graphics.drawable.Drawable;
-import android.support.annotation.NonNull;
-import android.support.annotation.RestrictTo;
-import android.support.annotation.VisibleForTesting;
-import android.support.v4.graphics.drawable.DrawableCompat;
 import android.text.TextUtils;
 import android.view.LayoutInflater;
 import android.view.View;
@@ -29,11 +24,18 @@
 import android.widget.ImageView;
 import android.widget.ScrollView;
 import android.widget.TextView;
+import androidx.annotation.NonNull;
+import androidx.annotation.RestrictTo;
+import androidx.annotation.VisibleForTesting;
 import com.google.firebase.inappmessaging.display.R;
 import com.google.firebase.inappmessaging.display.internal.InAppMessageLayoutConfig;
 import com.google.firebase.inappmessaging.display.internal.injection.scopes.InAppMessageScope;
 import com.google.firebase.inappmessaging.display.internal.layout.FiamRelativeLayout;
+import com.google.firebase.inappmessaging.model.Action;
 import com.google.firebase.inappmessaging.model.InAppMessage;
+import com.google.firebase.inappmessaging.model.MessageType;
+import com.google.firebase.inappmessaging.model.ModalMessage;
+import java.util.Map;
 import javax.inject.Inject;
 
 /** @hide */
@@ -49,6 +51,7 @@
   private ImageView imageView;
   private TextView messageBody;
   private TextView messageTitle;
+  private ModalMessage modalMessage;
 
   private ViewTreeObserver.OnGlobalLayoutListener layoutListener =
       new ScrollViewAdjustableListener();
@@ -63,7 +66,8 @@ public ModalBindingWrapper(
   @NonNull
   @Override
   public ViewTreeObserver.OnGlobalLayoutListener inflate(
-      View.OnClickListener actionListener, View.OnClickListener dismissOnClickListener) {
+      Map<Action, View.OnClickListener> actionListeners,
+      View.OnClickListener dismissOnClickListener) {
 
     View root = inflater.inflate(R.layout.modal, null);
     bodyScroll = root.findViewById(R.id.body_scroll);
@@ -76,14 +80,14 @@ public ModalBindingWrapper(
 
     modalContentRoot = root.findViewById(R.id.modal_content_root);
 
-    setMessage(message);
-    setLayoutConfig(config);
-    setDismissListener(dismissOnClickListener);
-    setActionListener(actionListener);
-
-    setModalColorOverrides();
-    setButtonColorOverrides();
-
+    if (message.getMessageType().equals(MessageType.MODAL)) {
+      modalMessage = (ModalMessage) message;
+      setMessage(modalMessage);
+      setButton(actionListeners);
+      setLayoutConfig(config);
+      setDismissListener(dismissOnClickListener);
+      setViewBgColorFromHex(modalContentRoot, modalMessage.getBackgroundHexColor());
+    }
     return layoutListener;
   }
 
@@ -105,6 +109,16 @@ public View getDialogView() {
     return modalContentRoot;
   }
 
+  @NonNull
+  public View getScrollView() {
+    return bodyScroll;
+  }
+
+  @NonNull
+  public View getTitleView() {
+    return messageTitle;
+  }
+
   @NonNull
   @Override
   public InAppMessageLayoutConfig getConfig() {
@@ -121,8 +135,8 @@ public View getCollapseButton() {
     return collapseImage;
   }
 
-  private void setMessage(InAppMessage message) {
-    if (TextUtils.isEmpty(message.getImageUrl())) {
+  private void setMessage(ModalMessage message) {
+    if (message.getImageData() == null || TextUtils.isEmpty(message.getImageData().getImageUrl())) {
       imageView.setVisibility(View.GONE);
     } else {
       imageView.setVisibility(View.VISIBLE);
@@ -141,23 +155,29 @@ private void setMessage(InAppMessage message) {
       }
     }
 
+    // eventually we should no longer need to check for the text of the body
     if (message.getBody() != null && !TextUtils.isEmpty(message.getBody().getText())) {
       bodyScroll.setVisibility(View.VISIBLE);
+      messageBody.setVisibility(View.VISIBLE);
+      messageBody.setTextColor(Color.parseColor(message.getBody().getHexColor()));
+      messageBody.setText(message.getBody().getText());
     } else {
       bodyScroll.setVisibility(View.GONE);
+      messageBody.setVisibility(View.GONE);
     }
+  }
 
-    if (message.getBody() != null) {
-      if (!TextUtils.isEmpty(message.getBody().getText())) {
-        messageBody.setVisibility(View.VISIBLE);
-        messageBody.setText(message.getBody().getText());
-      } else {
-        messageBody.setVisibility(View.GONE);
-      }
-
-      if (!TextUtils.isEmpty(message.getBody().getHexColor())) {
-        messageBody.setTextColor(Color.parseColor(message.getBody().getHexColor()));
-      }
+  private void setButton(Map<Action, View.OnClickListener> actionListeners) {
+    Action modalAction = modalMessage.getAction();
+    // Right now we have to check for text not being empty but this should be fixed in the future
+    if (modalAction != null
+        && modalAction.getButton() != null
+        && !TextUtils.isEmpty(modalAction.getButton().getText().getText())) {
+      setupViewButtonFromModel(button, modalAction.getButton());
+      setButtonActionListener(button, actionListeners.get(modalMessage.getAction()));
+      button.setVisibility(View.VISIBLE);
+    } else {
+      button.setVisibility(View.GONE);
     }
   }
 
@@ -171,53 +191,6 @@ private void setDismissListener(View.OnClickListener dismissListener) {
     modalRoot.setDismissListener(dismissListener);
   }
 
-  private void setActionListener(View.OnClickListener actionListener) {
-    button.setOnClickListener(actionListener);
-  }
-
-  private void setButtonColorOverrides() {
-    // Set the background color of the getAction button to be the FIAM color. We do this explicitly
-    // to
-    // allow for a rounded modal (b/c overloaded background for shape and color)
-
-    if (button != null
-        && message.getActionButton() != null
-        && message.getActionButton().getButtonHexColor() != null) {
-      int buttonColor = Color.parseColor(message.getActionButton().getButtonHexColor());
-
-      // Tint the button based on the background color
-      Drawable drawable = button.getBackground();
-      Drawable compatDrawable = DrawableCompat.wrap(drawable);
-      DrawableCompat.setTint(compatDrawable, buttonColor);
-      button.setBackground(compatDrawable);
-
-      if (message.getActionButton() != null && message.getActionButton().getText() != null) {
-        if (!TextUtils.isEmpty(message.getActionButton().getText().getText())) {
-          button.setVisibility(View.VISIBLE);
-          button.setText(message.getActionButton().getText().getText());
-        } else {
-          button.setVisibility(View.GONE);
-        }
-        String buttonTextColorStr = message.getActionButton().getText().getHexColor();
-
-        if (!TextUtils.isEmpty(buttonTextColorStr)) {
-          button.setTextColor(Color.parseColor(buttonTextColorStr));
-        }
-      }
-    } else {
-      button.setVisibility(View.GONE);
-    }
-  }
-
-  private void setModalColorOverrides() {
-    // Set the background color of the Modal to be the FIAM color. We do this explicitly to
-    // allow for a rounded modal (b/c overloaded background for shape and color)
-
-    if (modalContentRoot != null) {
-      setGradientDrawableBgColor(modalContentRoot, message.getBackgroundHexColor());
-    }
-  }
-
   @VisibleForTesting
   public void setLayoutListener(ViewTreeObserver.OnGlobalLayoutListener listener) {
     layoutListener = listener;
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/injection/components/InAppMessageComponent.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/injection/components/InAppMessageComponent.java
index 18a570065..b81c0d783 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/injection/components/InAppMessageComponent.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/injection/components/InAppMessageComponent.java
@@ -15,6 +15,7 @@
 package com.google.firebase.inappmessaging.display.internal.injection.components;
 
 import com.google.firebase.inappmessaging.display.internal.bindingwrappers.BannerBindingWrapper;
+import com.google.firebase.inappmessaging.display.internal.bindingwrappers.CardBindingWrapper;
 import com.google.firebase.inappmessaging.display.internal.bindingwrappers.ImageBindingWrapper;
 import com.google.firebase.inappmessaging.display.internal.bindingwrappers.ModalBindingWrapper;
 import com.google.firebase.inappmessaging.display.internal.injection.modules.InflaterModule;
@@ -33,4 +34,7 @@
 
   @InAppMessageScope
   BannerBindingWrapper bannerBindingWrapper();
+
+  @InAppMessageScope
+  CardBindingWrapper cardBindingWrapper();
 }
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/injection/keys/LayoutConfigKey.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/injection/keys/LayoutConfigKey.java
index c91fc2184..cc653e26f 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/injection/keys/LayoutConfigKey.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/injection/keys/LayoutConfigKey.java
@@ -23,6 +23,8 @@
 
   public static final String MODAL_PORTRAIT = "MODAL_PORTRAIT";
   public static final String MODAL_LANDSCAPE = "MODAL_LANDSCAPE";
+  public static final String CARD_PORTRAIT = "CARD_PORTRAIT";
+  public static final String CARD_LANDSCAPE = "CARD_LANDSCAPE";
   public static final String IMAGE_ONLY_PORTRAIT = "IMAGE_ONLY_PORTRAIT";
   public static final String IMAGE_ONLY_LANDSCAPE = "IMAGE_ONLY_LANDSCAPE";
   public static final String BANNER_PORTRAIT = "BANNER_PORTRAIT";
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/injection/modules/InflaterConfigModule.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/injection/modules/InflaterConfigModule.java
index 3b928a221..33d21ee04 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/injection/modules/InflaterConfigModule.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/injection/modules/InflaterConfigModule.java
@@ -33,12 +33,20 @@
 @Module
 public class InflaterConfigModule {
 
-  private int DISABLED_BG_FLAG =
+  // visible for testing
+  public static int DISABLED_BG_FLAG =
       WindowManager.LayoutParams.FLAG_DIM_BEHIND
           | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH
           | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN
           | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR;
 
+  public static int DISMISSIBLE_DIALOG_FLAG =
+      WindowManager.LayoutParams.FLAG_DIM_BEHIND
+          | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH
+          | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
+          | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN
+          | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR;
+
   private int ENABLED_BG_FLAG =
       WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN
           | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR
@@ -49,6 +57,8 @@ public static String configFor(MessageType type, int orientation) {
       switch (type) {
         case MODAL:
           return LayoutConfigKey.MODAL_PORTRAIT;
+        case CARD:
+          return LayoutConfigKey.CARD_PORTRAIT;
         case IMAGE_ONLY:
           return LayoutConfigKey.IMAGE_ONLY_PORTRAIT;
         case BANNER:
@@ -60,6 +70,8 @@ public static String configFor(MessageType type, int orientation) {
       switch (type) {
         case MODAL:
           return LayoutConfigKey.MODAL_LANDSCAPE;
+        case CARD:
+          return LayoutConfigKey.CARD_LANDSCAPE;
         case IMAGE_ONLY:
           return LayoutConfigKey.IMAGE_ONLY_LANDSCAPE;
         case BANNER:
@@ -80,10 +92,11 @@ DisplayMetrics providesDisplayMetrics(Application application) {
     return displayMetrics;
   }
 
+  // visible for testing
   @Provides
   @IntoMap
   @StringKey(LayoutConfigKey.IMAGE_ONLY_PORTRAIT)
-  InAppMessageLayoutConfig providesPortraitImageLayoutConfig(DisplayMetrics displayMetrics) {
+  public InAppMessageLayoutConfig providesPortraitImageLayoutConfig(DisplayMetrics displayMetrics) {
     return InAppMessageLayoutConfig.builder()
         .setMaxDialogHeightPx((int) (0.9f * displayMetrics.heightPixels))
         .setMaxDialogWidthPx((int) (0.9f * displayMetrics.widthPixels))
@@ -99,10 +112,12 @@ InAppMessageLayoutConfig providesPortraitImageLayoutConfig(DisplayMetrics displa
         .build();
   }
 
+  // visible for testing
   @Provides
   @IntoMap
   @StringKey(LayoutConfigKey.IMAGE_ONLY_LANDSCAPE)
-  InAppMessageLayoutConfig providesLandscapeImageLayoutConfig(DisplayMetrics displayMetrics) {
+  public InAppMessageLayoutConfig providesLandscapeImageLayoutConfig(
+      DisplayMetrics displayMetrics) {
     return InAppMessageLayoutConfig.builder()
         .setMaxDialogHeightPx((int) (0.9f * displayMetrics.heightPixels))
         .setMaxDialogWidthPx((int) (0.9f * displayMetrics.widthPixels))
@@ -118,10 +133,11 @@ InAppMessageLayoutConfig providesLandscapeImageLayoutConfig(DisplayMetrics displ
         .build();
   }
 
+  // visible for testing
   @Provides
   @IntoMap
   @StringKey(LayoutConfigKey.MODAL_LANDSCAPE)
-  InAppMessageLayoutConfig providesModalLandscapeConfig(DisplayMetrics displayMetrics) {
+  public InAppMessageLayoutConfig providesModalLandscapeConfig(DisplayMetrics displayMetrics) {
     return InAppMessageLayoutConfig.builder()
         .setMaxDialogHeightPx((int) (0.8 * displayMetrics.heightPixels))
         .setMaxDialogWidthPx(displayMetrics.widthPixels)
@@ -139,10 +155,11 @@ InAppMessageLayoutConfig providesModalLandscapeConfig(DisplayMetrics displayMetr
         .build();
   }
 
+  // visible for testing
   @Provides
   @IntoMap
   @StringKey(LayoutConfigKey.MODAL_PORTRAIT)
-  InAppMessageLayoutConfig providesModalPortraitConfig(DisplayMetrics displayMetrics) {
+  public InAppMessageLayoutConfig providesModalPortraitConfig(DisplayMetrics displayMetrics) {
     return InAppMessageLayoutConfig.builder()
         .setMaxDialogHeightPx((int) (0.8 * displayMetrics.heightPixels))
         .setMaxDialogWidthPx((int) (0.7f * displayMetrics.widthPixels))
@@ -160,10 +177,54 @@ InAppMessageLayoutConfig providesModalPortraitConfig(DisplayMetrics displayMetri
         .build();
   }
 
+  // visible for testing
+  @Provides
+  @IntoMap
+  @StringKey(LayoutConfigKey.CARD_LANDSCAPE)
+  public InAppMessageLayoutConfig providesCardLandscapeConfig(DisplayMetrics displayMetrics) {
+    return InAppMessageLayoutConfig.builder()
+        .setMaxDialogHeightPx((int) (0.8 * displayMetrics.heightPixels))
+        .setMaxDialogWidthPx(displayMetrics.widthPixels)
+        .setMaxImageHeightWeight(1f) // entire dialog height
+        .setMaxImageWidthWeight(0.5f)
+        .setViewWindowGravity(Gravity.CENTER)
+        .setWindowFlag(DISMISSIBLE_DIALOG_FLAG)
+        .setWindowWidth(ViewGroup.LayoutParams.WRAP_CONTENT)
+        .setWindowHeight(ViewGroup.LayoutParams.WRAP_CONTENT)
+        .setBackgroundEnabled(false)
+        .setAnimate(false)
+        .setAutoDismiss(false)
+        .build();
+  }
+
+  // visible for testing
+  @Provides
+  @IntoMap
+  @StringKey(LayoutConfigKey.CARD_PORTRAIT)
+  public InAppMessageLayoutConfig providesCardPortraitConfig(DisplayMetrics displayMetrics) {
+    return InAppMessageLayoutConfig.builder()
+        .setMaxDialogHeightPx((int) (0.8 * displayMetrics.heightPixels))
+        .setMaxDialogWidthPx((int) (0.7f * displayMetrics.widthPixels))
+        .setMaxImageHeightWeight(0.6f)
+        .setMaxImageWidthWeight(1f) // entire dialog width
+        .setMaxBodyHeightWeight(0.1f)
+        .setMaxBodyWidthWeight(0.9f) // entire dialog width
+        .setViewWindowGravity(Gravity.CENTER)
+        .setWindowFlag(DISMISSIBLE_DIALOG_FLAG)
+        .setWindowWidth(ViewGroup.LayoutParams.WRAP_CONTENT)
+        .setWindowHeight(ViewGroup.LayoutParams.WRAP_CONTENT)
+        .setBackgroundEnabled(false)
+        .setAnimate(false)
+        .setAutoDismiss(false)
+        .build();
+  }
+
+  // visible for testing
   @Provides
   @IntoMap
   @StringKey(LayoutConfigKey.BANNER_PORTRAIT)
-  InAppMessageLayoutConfig providesBannerPortraitLayoutConfig(DisplayMetrics displayMetrics) {
+  public InAppMessageLayoutConfig providesBannerPortraitLayoutConfig(
+      DisplayMetrics displayMetrics) {
     return InAppMessageLayoutConfig.builder()
         .setMaxImageHeightWeight(0.3f)
         .setMaxImageWidthWeight(0.3f)
@@ -179,10 +240,12 @@ InAppMessageLayoutConfig providesBannerPortraitLayoutConfig(DisplayMetrics displ
         .build();
   }
 
+  // visible for testing
   @Provides
   @IntoMap
   @StringKey(LayoutConfigKey.BANNER_LANDSCAPE)
-  InAppMessageLayoutConfig providesBannerLandscapeLayoutConfig(DisplayMetrics displayMetrics) {
+  public InAppMessageLayoutConfig providesBannerLandscapeLayoutConfig(
+      DisplayMetrics displayMetrics) {
     return InAppMessageLayoutConfig.builder()
         .setMaxImageHeightWeight(0.3f)
         .setMaxImageWidthWeight(0.3f)
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/injection/modules/PicassoModule.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/injection/modules/PicassoModule.java
index 20a0182ef..5e521a414 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/injection/modules/PicassoModule.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/injection/modules/PicassoModule.java
@@ -17,14 +17,14 @@
 import android.app.Application;
 import com.google.firebase.inappmessaging.display.internal.PicassoErrorListener;
 import com.google.firebase.inappmessaging.display.internal.injection.scopes.FirebaseAppScope;
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Response;
-import com.squareup.picasso.OkHttpDownloader;
+import com.squareup.picasso.OkHttp3Downloader;
 import com.squareup.picasso.Picasso;
 import dagger.Module;
 import dagger.Provides;
 import java.io.IOException;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Response;
 
 /** @hide */
 @Module
@@ -33,23 +33,20 @@
   @FirebaseAppScope
   Picasso providesFiamController(
       Application application, PicassoErrorListener picassoErrorListener) {
-    OkHttpClient client = new OkHttpClient();
-    // This seems necessary for some websites to treat this as an Android client
-    // Example: https://pics.clipartpng.com
-    // In the long term decide whether we are going to honor such edge cases
-    client
-        .interceptors()
-        .add(
-            new Interceptor() {
-              @Override
-              public Response intercept(Chain chain) throws IOException {
-                return chain.proceed(
-                    chain.request().newBuilder().addHeader("Accept", "image/*").build());
-              }
-            });
+    okhttp3.OkHttpClient client =
+        new OkHttpClient.Builder()
+            .addInterceptor(
+                new Interceptor() {
+                  @Override
+                  public Response intercept(Chain chain) throws IOException {
+                    return chain.proceed(
+                        chain.request().newBuilder().addHeader("Accept", "image/*").build());
+                  }
+                })
+            .build();
 
     Picasso.Builder builder = new Picasso.Builder(application);
-    builder.listener(picassoErrorListener).downloader(new OkHttpDownloader(client));
+    builder.listener(picassoErrorListener).downloader(new OkHttp3Downloader(client));
     return builder.build();
   }
 }
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/BaseModalLayout.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/BaseModalLayout.java
index 83daa9bff..8434e6f7f 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/BaseModalLayout.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/BaseModalLayout.java
@@ -16,14 +16,14 @@
 
 import android.content.Context;
 import android.content.res.TypedArray;
-import android.support.annotation.IdRes;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.util.AttributeSet;
 import android.util.DisplayMetrics;
 import android.util.TypedValue;
 import android.view.View;
 import android.widget.FrameLayout;
+import androidx.annotation.IdRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.inappmessaging.display.R;
 import com.google.firebase.inappmessaging.display.internal.Logging;
 import java.util.ArrayList;
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/CardLayoutLandscape.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/CardLayoutLandscape.java
new file mode 100644
index 000000000..6eef1d322
--- /dev/null
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/CardLayoutLandscape.java
@@ -0,0 +1,149 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.display.internal.layout;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.google.firebase.inappmessaging.display.R;
+import com.google.firebase.inappmessaging.display.internal.Logging;
+import com.google.firebase.inappmessaging.display.internal.layout.util.MeasureUtils;
+import java.util.Arrays;
+import java.util.List;
+
+/** @hide */
+public class CardLayoutLandscape extends BaseModalLayout {
+
+  private View imageChild;
+  private View titleChild;
+  private View scrollChild;
+  private View actionBarChild;
+  private static double IMAGE_MAX_WIDTH_PCT = 0.60;
+
+  public CardLayoutLandscape(Context context, @Nullable AttributeSet attrs) {
+    super(context, attrs);
+  }
+
+  @Override
+  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+    imageChild = findChildById(R.id.image_view);
+    titleChild = findChildById(R.id.message_title);
+    scrollChild = findChildById(R.id.body_scroll);
+    actionBarChild = findChildById(R.id.action_bar);
+
+    List<View> rightCol = Arrays.asList(titleChild, scrollChild, actionBarChild);
+
+    int baseLayoutWidth = calculateBaseWidth(widthMeasureSpec);
+    int baseLayoutHeight = calculateBaseHeight(heightMeasureSpec);
+    int maxImageWidth = roundToNearest((int) (IMAGE_MAX_WIDTH_PCT * baseLayoutWidth), 4);
+
+    // Measure the image to determine how much space it wants to take up.
+    Logging.logd("Measuring image");
+    MeasureUtils.measureFullHeight(imageChild, baseLayoutWidth, baseLayoutHeight);
+
+    // If the image takes up more than the max width percentage then resize it.
+    if (getDesiredWidth(imageChild) > maxImageWidth) {
+      Logging.logd("Image exceeded maximum width, remeasuring image");
+      MeasureUtils.measureFullWidth(imageChild, maxImageWidth, baseLayoutHeight);
+    }
+
+    // From now on the image height defines the height of the whole dialog
+    int imageHeight = getDesiredHeight(imageChild);
+
+    // The maximum right column width is the base dialog width minus the size of the image.
+    int leftColumnWidth = getDesiredWidth(imageChild);
+    int rightColumnMaxWidth = baseLayoutWidth - leftColumnWidth;
+    Logging.logdPair("Max col widths (l, r)", leftColumnWidth, rightColumnMaxWidth);
+
+    // The title and the button should be given as much vertical space as they need to draw. The
+    // scroll view is given any remaining content space.
+    Logging.logd("Measuring title");
+    MeasureUtils.measureAtMost(titleChild, rightColumnMaxWidth, imageHeight);
+
+    Logging.logd("Measuring action bar");
+    MeasureUtils.measureAtMost(actionBarChild, rightColumnMaxWidth, imageHeight);
+
+    // measure the scroll view using exactly with maximum height it can take up
+    Logging.logd("Measuring scroll view");
+    int scrollHeight =
+        imageHeight - getDesiredHeight(titleChild) - getDesiredHeight(actionBarChild);
+    MeasureUtils.measureFullHeight(scrollChild, rightColumnMaxWidth, scrollHeight);
+
+    // The right column shrinks horizontally based on the size of the widest member.
+    int rightColumnWidth = 0;
+    for (View view : rightCol) {
+      rightColumnWidth = Math.max(getDesiredWidth(view), rightColumnWidth);
+    }
+
+    Logging.logdPair("Measured columns (l, r)", leftColumnWidth, rightColumnWidth);
+    int totalWidth = leftColumnWidth + rightColumnWidth;
+
+    // Measure this view
+    Logging.logdPair("Measured dims", totalWidth, imageHeight);
+    setMeasuredDimension(totalWidth, imageHeight);
+  }
+
+  @Override
+  protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+    super.onLayout(changed, left, top, right, bottom);
+
+    int CONTAINER_LEFT = 0;
+    int CONTAINER_TOP = 0;
+    int CONTAINER_RIGHT = getMeasuredWidth();
+    int CONTAINER_BOTTOM = getMeasuredHeight();
+
+    Logging.logd("Layout image");
+    // Image is set at the top right and takes up as much height and width as it desires.
+    int imageLeft = CONTAINER_LEFT;
+    int imageTop = CONTAINER_TOP;
+    int imageRight = getDesiredWidth(imageChild);
+    int imageBottom = getDesiredHeight(imageChild);
+    layoutChild(imageChild, imageLeft, imageTop, imageRight, imageBottom);
+
+    // The left side of the right column starts at the right of the image.
+    int rightColLeft = imageRight;
+
+    Logging.logd("Layout title");
+    // Title starts to the right of the image and the top of the container.
+    // It spans the width of the container.
+    int titleLeft = rightColLeft;
+    int titleTop = CONTAINER_TOP;
+    int titleRight = CONTAINER_RIGHT;
+    int titleBottom = getDesiredHeight(titleChild);
+    layoutChild(titleChild, titleLeft, titleTop, titleRight, titleBottom);
+
+    Logging.logd("Layout scroll");
+    // The scroll view starts to the right of the image and the bottom of the title.
+    // It spans the width of the container.
+    int scrollLeft = rightColLeft;
+    int scrollTop = titleBottom;
+    int scrollBottom = scrollTop + getDesiredHeight(scrollChild);
+    int scrollRight = CONTAINER_RIGHT;
+    layoutChild(scrollChild, scrollLeft, scrollTop, scrollRight, scrollBottom);
+
+    Logging.logd("Layout action bar");
+    // Layout the action bar from the bottom. This is kinda a hack to get around a potentially
+    // totally missing scroll view but we know this will not have issues because we've
+    // already measured at this point.
+    int actionBarLeft = rightColLeft;
+    int actionBarTop = CONTAINER_BOTTOM - getDesiredHeight(actionBarChild);
+    int actionBarRight = CONTAINER_RIGHT;
+    int actionBarBottom = CONTAINER_BOTTOM;
+    layoutChild(actionBarChild, actionBarLeft, actionBarTop, actionBarRight, actionBarBottom);
+  }
+}
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/CardLayoutPortrait.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/CardLayoutPortrait.java
new file mode 100644
index 000000000..2094b7318
--- /dev/null
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/CardLayoutPortrait.java
@@ -0,0 +1,124 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.display.internal.layout;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.google.firebase.inappmessaging.display.R;
+import com.google.firebase.inappmessaging.display.internal.Logging;
+import com.google.firebase.inappmessaging.display.internal.layout.util.MeasureUtils;
+
+/**
+ * Layout used for portrait modal view.
+ *
+ * @hide
+ */
+public class CardLayoutPortrait extends BaseModalLayout {
+
+  private View imageChild;
+  private View titleChild;
+  private View scrollChild;
+  private View actionBarChild;
+  private static double IMAGE_MAX_HEIGHT_PCT = 0.80;
+
+  public CardLayoutPortrait(Context context, @Nullable AttributeSet attrs) {
+    super(context, attrs);
+  }
+
+  @Override
+  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+    imageChild = findChildById(R.id.image_view);
+    titleChild = findChildById(R.id.message_title);
+    scrollChild = findChildById(R.id.body_scroll);
+    actionBarChild = findChildById(R.id.action_bar);
+
+    int baseLayoutWidth = calculateBaseWidth(widthMeasureSpec);
+    int baseLayoutHeight = calculateBaseHeight(heightMeasureSpec);
+    int maxImageHeight = roundToNearest((int) (IMAGE_MAX_HEIGHT_PCT * baseLayoutHeight), 4);
+
+    // Measure the image to determine how much space it wants to take up.
+    Logging.logd("Measuring image");
+    MeasureUtils.measureFullWidth(imageChild, baseLayoutWidth, baseLayoutHeight);
+
+    // If the image takes up more than the max height percentage then resize it.
+    if (getDesiredHeight(imageChild) > maxImageHeight) {
+      Logging.logd("Image exceeded maximum height, remeasuring image");
+      MeasureUtils.measureFullHeight(imageChild, baseLayoutWidth, maxImageHeight);
+    }
+
+    // From now on the image width defines the width of the whole dialog
+    int imageWidth = getDesiredWidth(imageChild);
+
+    // The title and the button should be given as much vertical space as they need to draw. The
+    // scroll view is given any remaining content space.
+    Logging.logd("Measuring title");
+    MeasureUtils.measureFullWidth(titleChild, imageWidth, baseLayoutHeight);
+
+    Logging.logd("Measuring action bar");
+    MeasureUtils.measureFullWidth(actionBarChild, imageWidth, baseLayoutHeight);
+
+    Logging.logd("Measuring scroll view");
+    int maximumScrollHeight =
+        baseLayoutHeight
+            - getDesiredHeight(imageChild)
+            - getDesiredHeight(titleChild)
+            - getDesiredHeight(actionBarChild);
+    MeasureUtils.measureFullWidth(scrollChild, imageWidth, maximumScrollHeight);
+
+    int totalHeight = 0;
+    int numVisible = getVisibleChildren().size();
+    for (int i = 0; i < numVisible; i++) {
+      View child = getVisibleChildren().get(i);
+      totalHeight += getDesiredHeight(child);
+    }
+    setMeasuredDimension(imageWidth, totalHeight);
+  }
+
+  @Override
+  protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+    super.onLayout(changed, left, top, right, bottom);
+
+    int x = 0;
+    int y = 0;
+
+    int numVisible = getVisibleChildren().size();
+    for (int i = 0; i < numVisible; i++) {
+      View child = getVisibleChildren().get(i);
+
+      int childHeight = child.getMeasuredHeight();
+      int childWidth = child.getMeasuredWidth();
+
+      int childTop = y;
+      int childBottom = y + childHeight;
+
+      int childLeft = x;
+      int childRight = x + childWidth;
+
+      Logging.logd("Layout child " + i);
+      Logging.logdPair("\t(top, bottom)", childTop, childBottom);
+      Logging.logdPair("\t(left, right)", childLeft, childRight);
+      child.layout(childLeft, childTop, childRight, childBottom);
+
+      // Move down by the height the child used
+      Logging.logdPair(
+          "Child " + i + " wants to be ", child.getMeasuredWidth(), child.getMeasuredHeight());
+      y += child.getMeasuredHeight();
+    }
+  }
+}
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/FiamCardView.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/FiamCardView.java
new file mode 100644
index 000000000..ce46bb7f5
--- /dev/null
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/FiamCardView.java
@@ -0,0 +1,55 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.display.internal.layout;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.KeyEvent;
+import android.view.View;
+import androidx.cardview.widget.CardView;
+import com.google.firebase.inappmessaging.display.internal.layout.util.BackButtonHandler;
+
+/** @hide */
+public class FiamCardView extends CardView implements BackButtonLayout {
+
+  private BackButtonHandler mBackHandler;
+
+  public FiamCardView(Context context) {
+    super(context);
+  }
+
+  public FiamCardView(Context context, AttributeSet attrs) {
+    super(context, attrs);
+  }
+
+  public FiamCardView(Context context, AttributeSet attrs, int defStyleAttr) {
+    super(context, attrs, defStyleAttr);
+  }
+
+  @Override
+  public void setDismissListener(View.OnClickListener listener) {
+    mBackHandler = new BackButtonHandler(this, listener);
+  }
+
+  @Override
+  public boolean dispatchKeyEvent(KeyEvent event) {
+    Boolean handled = mBackHandler.dispatchKeyEvent(event);
+    if (handled != null) {
+      return handled;
+    } else {
+      return super.dispatchKeyEvent(event);
+    }
+  }
+}
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/FiamFrameLayout.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/FiamFrameLayout.java
index 7509e2201..73c7371c8 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/FiamFrameLayout.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/FiamFrameLayout.java
@@ -15,11 +15,11 @@
 package com.google.firebase.inappmessaging.display.internal.layout;
 
 import android.content.Context;
-import android.support.annotation.RequiresApi;
 import android.util.AttributeSet;
 import android.view.KeyEvent;
 import android.view.View;
 import android.widget.FrameLayout;
+import androidx.annotation.RequiresApi;
 import com.google.firebase.inappmessaging.display.internal.layout.util.BackButtonHandler;
 
 /** @hide */
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/FiamRelativeLayout.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/FiamRelativeLayout.java
index 3a5200f35..ee4a9613d 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/FiamRelativeLayout.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/FiamRelativeLayout.java
@@ -15,11 +15,11 @@
 package com.google.firebase.inappmessaging.display.internal.layout;
 
 import android.content.Context;
-import android.support.annotation.RequiresApi;
 import android.util.AttributeSet;
 import android.view.KeyEvent;
 import android.view.View;
 import android.widget.RelativeLayout;
+import androidx.annotation.RequiresApi;
 import com.google.firebase.inappmessaging.display.internal.layout.util.BackButtonHandler;
 
 /** @hide */
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/ModalLayoutLandscape.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/ModalLayoutLandscape.java
index 030846729..819a7a3f2 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/ModalLayoutLandscape.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/ModalLayoutLandscape.java
@@ -15,9 +15,9 @@
 package com.google.firebase.inappmessaging.display.internal.layout;
 
 import android.content.Context;
-import android.support.annotation.Nullable;
 import android.util.AttributeSet;
 import android.view.View;
+import androidx.annotation.Nullable;
 import com.google.firebase.inappmessaging.display.R;
 import com.google.firebase.inappmessaging.display.internal.Logging;
 import com.google.firebase.inappmessaging.display.internal.layout.util.MeasureUtils;
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/ModalLayoutPortrait.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/ModalLayoutPortrait.java
index 030357e72..30cc7f5d1 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/ModalLayoutPortrait.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/ModalLayoutPortrait.java
@@ -15,11 +15,11 @@
 package com.google.firebase.inappmessaging.display.internal.layout;
 
 import android.content.Context;
-import android.support.annotation.Nullable;
 import android.util.AttributeSet;
 import android.view.Gravity;
 import android.view.View;
 import android.widget.FrameLayout;
+import androidx.annotation.Nullable;
 import com.google.firebase.inappmessaging.display.R;
 import com.google.firebase.inappmessaging.display.internal.Logging;
 import com.google.firebase.inappmessaging.display.internal.layout.util.MeasureUtils;
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/package-info.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/package-info.java
new file mode 100644
index 000000000..854c4d4c9
--- /dev/null
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.firebase.inappmessaging.display.internal.layout;
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/util/BackButtonHandler.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/util/BackButtonHandler.java
index 0e090b110..686d76134 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/util/BackButtonHandler.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/util/BackButtonHandler.java
@@ -14,10 +14,10 @@
 
 package com.google.firebase.inappmessaging.display.internal.layout.util;
 
-import android.support.annotation.Nullable;
 import android.view.KeyEvent;
 import android.view.View;
 import android.view.ViewGroup;
+import androidx.annotation.Nullable;
 
 /** @hide */
 public class BackButtonHandler {
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/util/MeasureUtils.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/util/MeasureUtils.java
index d73918450..0329104aa 100644
--- a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/util/MeasureUtils.java
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/layout/util/MeasureUtils.java
@@ -22,6 +22,30 @@
 
   /** Call "measure" on a view with the AT_MOST measurespec for the given height/width. */
   public static void measureAtMost(View child, int width, int height) {
+    measure(child, width, height, View.MeasureSpec.AT_MOST, View.MeasureSpec.AT_MOST);
+  }
+
+  /** Call "measure" on a view with the EXACTLY measurespec for the given height and width. */
+  public static void measureExactly(View child, int width, int height) {
+    measure(child, width, height, View.MeasureSpec.EXACTLY, View.MeasureSpec.EXACTLY);
+  }
+
+  /** Call "measure" on a view with the EXACTLY measurespec for the given width. */
+  public static void measureFullWidth(View child, int width, int height) {
+    measure(child, width, height, View.MeasureSpec.EXACTLY, View.MeasureSpec.AT_MOST);
+  }
+
+  /** Call "measure" on a view with the EXACTLY measurespec for the given height. */
+  public static void measureFullHeight(View child, int width, int height) {
+    measure(child, width, height, View.MeasureSpec.AT_MOST, View.MeasureSpec.EXACTLY);
+  }
+
+  /**
+   * Call "measure" on a view the provided measure specifications. The "Exactly" measure spec will
+   * force a view to be exactly the specified size in the specified dimension while the "At most"
+   * spec will tell the view how large it can be at most in the given dimension.
+   */
+  private static void measure(View child, int width, int height, int widthSpec, int heightSpec) {
     Logging.logdPair("\tdesired (w,h)", child.getMeasuredWidth(), child.getMeasuredHeight());
     if (child.getVisibility() == View.GONE) {
       width = 0;
@@ -29,8 +53,8 @@ public static void measureAtMost(View child, int width, int height) {
     }
 
     child.measure(
-        View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.AT_MOST),
-        View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.AT_MOST));
+        View.MeasureSpec.makeMeasureSpec(width, widthSpec),
+        View.MeasureSpec.makeMeasureSpec(height, heightSpec));
     Logging.logdPair("\tactual (w,h)", child.getMeasuredWidth(), child.getMeasuredHeight());
   }
 }
diff --git a/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/package-info.java b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/package-info.java
new file mode 100644
index 000000000..8be9ae325
--- /dev/null
+++ b/firebase-inappmessaging-display/src/main/java/com/google/firebase/inappmessaging/display/internal/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.firebase.inappmessaging.display.internal;
diff --git a/firebase-inappmessaging-display/src/main/res/drawable-hdpi-v4/btn_clear.png b/firebase-inappmessaging-display/src/main/res/drawable-hdpi-v4/btn_clear.png
deleted file mode 100644
index 5814904b7..000000000
Binary files a/firebase-inappmessaging-display/src/main/res/drawable-hdpi-v4/btn_clear.png and /dev/null differ
diff --git a/firebase-inappmessaging-display/src/main/res/drawable-hdpi-v4/image_placeholder.png b/firebase-inappmessaging-display/src/main/res/drawable-hdpi-v4/image_placeholder.png
deleted file mode 100644
index abb744ac9..000000000
Binary files a/firebase-inappmessaging-display/src/main/res/drawable-hdpi-v4/image_placeholder.png and /dev/null differ
diff --git a/firebase-inappmessaging-display/src/main/res/drawable-ldpi-v4/btn_clear.png b/firebase-inappmessaging-display/src/main/res/drawable-ldpi-v4/btn_clear.png
deleted file mode 100644
index 50b63ebc2..000000000
Binary files a/firebase-inappmessaging-display/src/main/res/drawable-ldpi-v4/btn_clear.png and /dev/null differ
diff --git a/firebase-inappmessaging-display/src/main/res/drawable-ldpi-v4/image_placeholder.png b/firebase-inappmessaging-display/src/main/res/drawable-ldpi-v4/image_placeholder.png
deleted file mode 100644
index 8aee34fc4..000000000
Binary files a/firebase-inappmessaging-display/src/main/res/drawable-ldpi-v4/image_placeholder.png and /dev/null differ
diff --git a/firebase-inappmessaging-display/src/main/res/drawable-mdpi-v4/btn_clear.png b/firebase-inappmessaging-display/src/main/res/drawable-mdpi-v4/btn_clear.png
deleted file mode 100644
index 7c37d7286..000000000
Binary files a/firebase-inappmessaging-display/src/main/res/drawable-mdpi-v4/btn_clear.png and /dev/null differ
diff --git a/firebase-inappmessaging-display/src/main/res/drawable-mdpi-v4/image_placeholder.png b/firebase-inappmessaging-display/src/main/res/drawable-mdpi-v4/image_placeholder.png
deleted file mode 100644
index 6a65be3b4..000000000
Binary files a/firebase-inappmessaging-display/src/main/res/drawable-mdpi-v4/image_placeholder.png and /dev/null differ
diff --git a/firebase-inappmessaging-display/src/main/res/drawable-xhdpi-v4/btn_clear.png b/firebase-inappmessaging-display/src/main/res/drawable-xhdpi-v4/btn_clear.png
deleted file mode 100644
index 153ac011f..000000000
Binary files a/firebase-inappmessaging-display/src/main/res/drawable-xhdpi-v4/btn_clear.png and /dev/null differ
diff --git a/firebase-inappmessaging-display/src/main/res/drawable-xhdpi-v4/image_placeholder.png b/firebase-inappmessaging-display/src/main/res/drawable-xhdpi-v4/image_placeholder.png
deleted file mode 100644
index c6e0e68e4..000000000
Binary files a/firebase-inappmessaging-display/src/main/res/drawable-xhdpi-v4/image_placeholder.png and /dev/null differ
diff --git a/firebase-inappmessaging-display/src/main/res/drawable-xxhdpi-v4/btn_clear.png b/firebase-inappmessaging-display/src/main/res/drawable-xxhdpi-v4/btn_clear.png
deleted file mode 100644
index 2071c0b8a..000000000
Binary files a/firebase-inappmessaging-display/src/main/res/drawable-xxhdpi-v4/btn_clear.png and /dev/null differ
diff --git a/firebase-inappmessaging-display/src/main/res/drawable-xxhdpi-v4/image_placeholder.png b/firebase-inappmessaging-display/src/main/res/drawable-xxhdpi-v4/image_placeholder.png
deleted file mode 100644
index 83d13b33d..000000000
Binary files a/firebase-inappmessaging-display/src/main/res/drawable-xxhdpi-v4/image_placeholder.png and /dev/null differ
diff --git a/firebase-inappmessaging-display/src/main/res/drawable-xxxhdpi-v4/btn_clear.png b/firebase-inappmessaging-display/src/main/res/drawable-xxxhdpi-v4/btn_clear.png
deleted file mode 100644
index 9b0b5a282..000000000
Binary files a/firebase-inappmessaging-display/src/main/res/drawable-xxxhdpi-v4/btn_clear.png and /dev/null differ
diff --git a/firebase-inappmessaging-display/src/main/res/drawable-xxxhdpi-v4/image_placeholder.png b/firebase-inappmessaging-display/src/main/res/drawable-xxxhdpi-v4/image_placeholder.png
deleted file mode 100644
index a045db6b3..000000000
Binary files a/firebase-inappmessaging-display/src/main/res/drawable-xxxhdpi-v4/image_placeholder.png and /dev/null differ
diff --git a/firebase-inappmessaging-display/src/main/res/layout-land/card.xml b/firebase-inappmessaging-display/src/main/res/layout-land/card.xml
new file mode 100644
index 000000000..2e0d379e3
--- /dev/null
+++ b/firebase-inappmessaging-display/src/main/res/layout-land/card.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<com.google.firebase.inappmessaging.display.internal.layout.FiamCardView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:id="@+id/card_root"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:clipToPadding="false"
+    app:cardCornerRadius="6dp"
+    app:contentPadding="0dp">
+
+    <include layout="@layout/card_landscape_inner" />
+</com.google.firebase.inappmessaging.display.internal.layout.FiamCardView>
diff --git a/firebase-inappmessaging-display/src/main/res/layout-land/card_landscape_inner.xml b/firebase-inappmessaging-display/src/main/res/layout-land/card_landscape_inner.xml
new file mode 100644
index 000000000..c7b3698f6
--- /dev/null
+++ b/firebase-inappmessaging-display/src/main/res/layout-land/card_landscape_inner.xml
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="utf-8"?>
+<com.google.firebase.inappmessaging.display.internal.layout.CardLayoutLandscape
+    tools:ignore="MissingDefaultResource"
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:fiam="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/card_content_root"
+    style="@style/FiamUI.Card"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:layout_gravity="center"
+    android:theme="@style/FiamUI"
+    fiam:maxHeightPct="@dimen/dialogHeightPct"
+    fiam:maxWidthPct="@dimen/dialogWidthPct">
+
+    <ImageView
+        android:id="@+id/image_view"
+        style="@style/FiamUI.Card.ImageView"
+        tools:src="@drawable/placeholder_850_850" />
+
+    <TextView
+        android:id="@+id/message_title"
+        style="@style/FiamUI.Text.Title"
+        android:paddingLeft="@dimen/paddingSmall"
+        android:paddingTop="@dimen/paddingSmall"
+        android:paddingRight="@dimen/paddingSmall"
+        tools:text="Your wishlist items are on sale!!" />
+
+
+    <ScrollView
+        android:id="@+id/body_scroll"
+        style="@style/FiamUI.Card.Scroll">
+
+        <TextView
+            android:id="@+id/message_body"
+            style="@style/FiamUI.ModalBody"
+            tools:text="@string/placeholder_very_short" />
+
+    </ScrollView>
+
+    <LinearLayout
+        android:id="@+id/action_bar"
+        style="@style/FiamUI.Card.ActionBar">
+
+        <Button
+            android:id="@+id/secondary_button"
+            style="@style/FiamUI.Card.ActionBar.Button"
+            tools:text="Secondary"
+            tools:textColor="#000000" />
+
+        <Button
+            android:id="@+id/primary_button"
+            style="@style/FiamUI.Card.ActionBar.Button"
+            tools:text="Primary"
+            tools:textColor="#000000" />
+    </LinearLayout>
+</com.google.firebase.inappmessaging.display.internal.layout.CardLayoutLandscape>
diff --git a/firebase-inappmessaging-display/src/main/res/layout/banner.xml b/firebase-inappmessaging-display/src/main/res/layout/banner.xml
index 706f51b76..92aed19bf 100644
--- a/firebase-inappmessaging-display/src/main/res/layout/banner.xml
+++ b/firebase-inappmessaging-display/src/main/res/layout/banner.xml
@@ -16,7 +16,7 @@
         android:gravity="center_horizontal"
         android:weightSum="@dimen/bannerWeightSum">
 
-        <android.support.constraint.ConstraintLayout
+        <androidx.constraintlayout.widget.ConstraintLayout
             android:id="@+id/banner_content_root"
             style="@style/FiamUI.Banner"
             android:layout_width="0dp"
@@ -74,7 +74,7 @@
                 app:layout_constraintVertical_bias="0.0"
                 tools:text="@string/placeholder_lorem_ipsum_short" />
 
-        </android.support.constraint.ConstraintLayout>
+        </androidx.constraintlayout.widget.ConstraintLayout>
 
     </LinearLayout>
 
diff --git a/firebase-inappmessaging-display/src/main/res/layout/card.xml b/firebase-inappmessaging-display/src/main/res/layout/card.xml
new file mode 100644
index 000000000..8d8fd454f
--- /dev/null
+++ b/firebase-inappmessaging-display/src/main/res/layout/card.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?><!-- This file should be text identical to layout-sw600dp/card.xml.
+     See comment there for reasoning. -->
+<com.google.firebase.inappmessaging.display.internal.layout.FiamCardView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:id="@+id/card_root"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:clipToPadding="false"
+    app:cardCornerRadius="6dp"
+    app:contentPadding="0dp">
+
+    <include layout="@layout/card_portrait_inner" />
+
+</com.google.firebase.inappmessaging.display.internal.layout.FiamCardView>
diff --git a/firebase-inappmessaging-display/src/main/res/layout/card_portrait_inner.xml b/firebase-inappmessaging-display/src/main/res/layout/card_portrait_inner.xml
new file mode 100644
index 000000000..2cc589ed9
--- /dev/null
+++ b/firebase-inappmessaging-display/src/main/res/layout/card_portrait_inner.xml
@@ -0,0 +1,54 @@
+<?xml version="1.0" encoding="utf-8"?>
+<com.google.firebase.inappmessaging.display.internal.layout.CardLayoutPortrait xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:fiam="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/card_content_root"
+    style="@style/FiamUI.Card"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:layout_gravity="center"
+    android:theme="@style/FiamUI"
+    fiam:maxHeightPct="@dimen/dialogHeightPct"
+    fiam:maxWidthPct="@dimen/dialogWidthPct">
+
+    <ImageView
+        android:id="@+id/image_view"
+        style="@style/FiamUI.Card.ImageView"
+        tools:src="@drawable/placeholder_850_850" />
+
+    <TextView
+        android:id="@+id/message_title"
+        style="@style/FiamUI.Text.Title"
+        android:paddingLeft="@dimen/paddingSmall"
+        android:paddingTop="@dimen/paddingSmall"
+        android:paddingRight="@dimen/paddingSmall"
+        tools:text="Your wishlist items are on sale!!" />
+
+    <ScrollView
+        android:id="@+id/body_scroll"
+        style="@style/FiamUI.Card.Scroll">
+
+        <TextView
+            android:id="@+id/message_body"
+            style="@style/FiamUI.ModalBody"
+            tools:text="@string/placeholder_very_short" />
+    </ScrollView>
+
+    <LinearLayout
+        android:id="@+id/action_bar"
+        style="@style/FiamUI.Card.ActionBar">
+
+        <Button
+            android:id="@+id/secondary_button"
+            style="@style/FiamUI.Card.ActionBar.Button"
+            tools:text="Secondary"
+            tools:textColor="#000000" />
+
+        <Button
+            android:id="@+id/primary_button"
+            style="@style/FiamUI.Card.ActionBar.Button"
+            tools:text="Primary"
+            tools:textColor="#000000" />
+    </LinearLayout>
+
+</com.google.firebase.inappmessaging.display.internal.layout.CardLayoutPortrait>
diff --git a/firebase-inappmessaging-display/src/main/res/layout/modal_portrait_inner.xml b/firebase-inappmessaging-display/src/main/res/layout/modal_portrait_inner.xml
index 2e692e6cb..9152436ea 100644
--- a/firebase-inappmessaging-display/src/main/res/layout/modal_portrait_inner.xml
+++ b/firebase-inappmessaging-display/src/main/res/layout/modal_portrait_inner.xml
@@ -1,5 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
-<com.google.firebase.inappmessaging.display.internal.layout.ModalLayoutPortrait
+<com.google.firebase.inappmessaging.display.internal.layout.ModalLayoutPortrait xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:fiam="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
     android:id="@+id/modal_content_root"
     style="@style/FiamUI.Modal"
     android:layout_width="match_parent"
@@ -8,11 +10,8 @@
     android:background="@drawable/rounded_layout"
     android:padding="24dp"
     android:theme="@style/FiamUI"
-    fiam:maxHeightPct="@dimen/modalPortraitHeightPct"
-    fiam:maxWidthPct="@dimen/modalPortraitWidthPct"
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:fiam="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools">
+    fiam:maxHeightPct="@dimen/dialogHeightPct"
+    fiam:maxWidthPct="@dimen/dialogWidthPct">
 
     <TextView
         android:id="@+id/message_title"
@@ -24,10 +23,10 @@
         tools:text="Your wishlist items are on sale!!" />
 
     <ImageView
-        android:contentDescription="@string/modal_inner_content_descriptor"
         android:id="@+id/image_view"
         style="@style/FiamUI.ModalImageView"
         android:layout_gravity="center_horizontal"
+        android:contentDescription="@string/modal_inner_content_descriptor"
         android:scaleType="centerInside"
         tools:src="@drawable/placeholder_550_350" />
 
diff --git a/firebase-inappmessaging-display/src/main/res/values-land/dimen.xml b/firebase-inappmessaging-display/src/main/res/values-land/dimen.xml
index 0679262ad..3ffeee615 100644
--- a/firebase-inappmessaging-display/src/main/res/values-land/dimen.xml
+++ b/firebase-inappmessaging-display/src/main/res/values-land/dimen.xml
@@ -3,4 +3,8 @@
     <!-- In landscape, banner only fills a fraction (bannerContentWeight/bannerWeightSum) -->
     <item name="bannerWeightSum" format="integer" type="dimen">5</item>
     <item name="bannerContentWeight" format="integer" type="dimen">3</item>
+
+    <item name="dialogHeightPct" format="float" type="dimen">0.80</item>
+    <item name="dialogWidthPct" format="float" type="dimen">0.85</item>
+
 </resources>
\ No newline at end of file
diff --git a/firebase-inappmessaging-display/src/main/res/values-sw600dp/dimen.xml b/firebase-inappmessaging-display/src/main/res/values-sw600dp/dimen.xml
index 6ab975174..dff360cad 100644
--- a/firebase-inappmessaging-display/src/main/res/values-sw600dp/dimen.xml
+++ b/firebase-inappmessaging-display/src/main/res/values-sw600dp/dimen.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
-    <item name="modalPortraitHeightPct" format="float" type="dimen">0.60</item>
-    <item name="modalPortraitWidthPct" format="float" type="dimen">0.50</item>
+    <item name="dialogHeightPct" format="float" type="dimen">0.80</item>
+    <item name="dialogWidthPct" format="float" type="dimen">0.75</item>
 </resources>
diff --git a/firebase-inappmessaging-display/src/main/res/values-v21/styles.xml b/firebase-inappmessaging-display/src/main/res/values-v21/styles.xml
index c679d2c9a..43b20456f 100644
--- a/firebase-inappmessaging-display/src/main/res/values-v21/styles.xml
+++ b/firebase-inappmessaging-display/src/main/res/values-v21/styles.xml
@@ -19,4 +19,8 @@
         <item name="android:elevation">4dp</item>
     </style>
 
+    <style name="FiamUI.Card" parent="@style/FiamUI">
+        <item name="android:elevation">4dp</item>
+    </style>
+
 </resources>
\ No newline at end of file
diff --git a/firebase-inappmessaging-display/src/main/res/values/dimen.xml b/firebase-inappmessaging-display/src/main/res/values/dimen.xml
index 04706d081..f363eacd5 100644
--- a/firebase-inappmessaging-display/src/main/res/values/dimen.xml
+++ b/firebase-inappmessaging-display/src/main/res/values/dimen.xml
@@ -5,8 +5,8 @@
 
   <dimen name="paddingSmall">16dp</dimen>
 
-  <item name="modalPortraitHeightPct" format="float" type="dimen">0.80</item>
-  <item name="modalPortraitWidthPct" format="float" type="dimen">0.85</item>
+  <item name="dialogHeightPct" format="float" type="dimen">0.80</item>
+  <item name="dialogWidthPct" format="float" type="dimen">0.85</item>
 
   <!-- In portrait, banner fills available. -->
   <item name="bannerWeightSum" format="float" type="dimen">1.0</item>
diff --git a/firebase-inappmessaging-display/src/main/res/values/strings.xml b/firebase-inappmessaging-display/src/main/res/values/strings.xml
index e8f4f1da5..236ac33e8 100644
--- a/firebase-inappmessaging-display/src/main/res/values/strings.xml
+++ b/firebase-inappmessaging-display/src/main/res/values/strings.xml
@@ -1,5 +1,6 @@
 <resources>
   <!-- String resources go here -->
+  <string name="card_content_descriptor">card</string>
   <string name="modal_content_descriptor">modal</string>
   <string name="modal_inner_content_descriptor">modal inner</string>
 </resources>
diff --git a/firebase-inappmessaging-display/src/main/res/values/styles.xml b/firebase-inappmessaging-display/src/main/res/values/styles.xml
index e2288b698..7e8e7e904 100644
--- a/firebase-inappmessaging-display/src/main/res/values/styles.xml
+++ b/firebase-inappmessaging-display/src/main/res/values/styles.xml
@@ -2,10 +2,8 @@
 
     <style name="FiamUI" parent="Theme.AppCompat.Light"></style>
 
-    <style name="FiamUI.ModalBody" parent="@style/Base.TextAppearance.AppCompat.Body1">
-        <item name="android:layout_width">wrap_content</item>
-        <item name="android:layout_height">wrap_content</item>
-        <item name="android:textSize">20sp</item>
+    <style name="FiamUI.CollapseButton" parent="FiamUI.CollapseButtonBase">
+        <!-- nothing here, see values-v21 -->
     </style>
 
     <style name="FiamUI.CollapseButtonBase" parent="@style/Base.Widget.AppCompat.Button">
@@ -18,13 +16,19 @@
         <item name="android:layout_marginTop">-12dp</item>
     </style>
 
-    <style name="FiamUI.CollapseButton" parent="FiamUI.CollapseButtonBase">
+    <style name="FiamUI.Modal" parent="@style/FiamUI">
         <!-- nothing here, see values-v21 -->
     </style>
 
-    <style name="FiamUI.ResizableImageView">
+    <style name="FiamUI.ModalBody" parent="@style/Base.TextAppearance.AppCompat.Body1">
         <item name="android:layout_width">wrap_content</item>
         <item name="android:layout_height">wrap_content</item>
+        <item name="android:textSize">20sp</item>
+    </style>
+
+    <style name="FiamUI.ModalImageView">
+        <item name="android:layout_width">match_parent</item>
+        <item name="android:layout_height">wrap_content</item>
         <item name="android:layout_gravity">center</item>
         <item name="android:gravity">center</item>
         <item name="android:adjustViewBounds">true</item>
@@ -33,9 +37,45 @@
         <item name="android:src">@drawable/image_placeholder</item>
     </style>
 
-    <style name="FiamUI.ModalImageView">
+    <style name="FiamUI.Card" parent="@style/FiamUI">
+        <!-- nothing here, see values-v21 -->
+    </style>
+
+    <style name="FiamUI.Card.ImageView">
+        <item name="android:layout_width">wrap_content</item>
+        <item name="android:layout_height">wrap_content</item>
+        <item name="android:scaleType">centerCrop</item>
+        <item name="android:adjustViewBounds">true</item>
+        <item name="android:minHeight">@dimen/minImageHeight</item>
+        <item name="android:minWidth">@dimen/minImageWidth</item>
+        <item name="android:src">@drawable/image_placeholder</item>
+    </style>
+
+    <style name="FiamUI.Card.Scroll">
+        <item name="android:layout_width">match_parent</item>
+        <item name="android:layout_height">wrap_content</item>
+        <item name="android:paddingTop">@dimen/paddingSmall</item>
+        <item name="android:paddingLeft">@dimen/paddingSmall</item>
+        <item name="android:paddingRight">@dimen/paddingSmall</item>
+    </style>
+
+    <style name="FiamUI.Card.ActionBar">
         <item name="android:layout_width">match_parent</item>
         <item name="android:layout_height">wrap_content</item>
+        <item name="android:gravity">right</item>
+        <item name="android:padding">@dimen/paddingSmall</item>
+    </style>
+
+    <style name="FiamUI.Card.ActionBar.Button" parent="@style/Base.Widget.AppCompat.Button.Borderless">
+        <item name="android:layout_width">wrap_content</item>
+        <item name="android:layout_height">wrap_content</item>
+        <item name="android:textSize">16sp</item>
+        <item name="android:layout_gravity">center_horizontal</item>
+    </style>
+
+    <style name="FiamUI.ResizableImageView">
+        <item name="android:layout_width">wrap_content</item>
+        <item name="android:layout_height">wrap_content</item>
         <item name="android:layout_gravity">center</item>
         <item name="android:gravity">center</item>
         <item name="android:adjustViewBounds">true</item>
@@ -48,10 +88,6 @@
         <!-- nothing here, see values-v21 -->
     </style>
 
-    <style name="FiamUI.Modal" parent="@style/FiamUI">
-        <!-- nothing here, see values-v21 -->
-    </style>
-
     <style name="FiamUI.Text.BannerTitle" parent="@style/Base.TextAppearance.AppCompat.Body1">
         <item name="android:textSize">16sp</item>
         <item name="android:textStyle">bold</item>
diff --git a/firebase-inappmessaging-display/src/test/java/com/google/firebase/inappmessaging/display/FirebaseInAppMessagingDisplayTest.java b/firebase-inappmessaging-display/src/test/java/com/google/firebase/inappmessaging/display/FirebaseInAppMessagingDisplayTest.java
index d68bbb8e9..ddd0ad42b 100644
--- a/firebase-inappmessaging-display/src/test/java/com/google/firebase/inappmessaging/display/FirebaseInAppMessagingDisplayTest.java
+++ b/firebase-inappmessaging-display/src/test/java/com/google/firebase/inappmessaging/display/FirebaseInAppMessagingDisplayTest.java
@@ -16,6 +16,13 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.firebase.inappmessaging.display.internal.FiamImageLoader.FiamImageRequestCreator;
+import static com.google.firebase.inappmessaging.testutil.TestData.ACTION_URL_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.BANNER_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.CARD_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.IMAGE_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.IMAGE_MESSAGE_MODEL_WITHOUT_ACTION;
+import static com.google.firebase.inappmessaging.testutil.TestData.IMAGE_URL_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.MODAL_MESSAGE_MODEL;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.ArgumentMatchers.eq;
@@ -31,12 +38,11 @@
 import android.app.Activity;
 import android.content.res.Configuration;
 import android.net.Uri;
-import android.view.Gravity;
+import android.util.DisplayMetrics;
 import android.view.LayoutInflater;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.View.OnClickListener;
-import android.view.ViewGroup;
 import android.view.ViewTreeObserver;
 import android.widget.Button;
 import android.widget.ImageView;
@@ -50,17 +56,21 @@
 import com.google.firebase.inappmessaging.display.internal.InAppMessageLayoutConfig;
 import com.google.firebase.inappmessaging.display.internal.RenewableTimer;
 import com.google.firebase.inappmessaging.display.internal.bindingwrappers.BannerBindingWrapper;
+import com.google.firebase.inappmessaging.display.internal.bindingwrappers.CardBindingWrapper;
 import com.google.firebase.inappmessaging.display.internal.bindingwrappers.ImageBindingWrapper;
 import com.google.firebase.inappmessaging.display.internal.bindingwrappers.ModalBindingWrapper;
 import com.google.firebase.inappmessaging.display.internal.injection.modules.InflaterConfigModule;
+import com.google.firebase.inappmessaging.model.Action;
 import com.google.firebase.inappmessaging.model.InAppMessage;
 import com.google.firebase.inappmessaging.model.MessageType;
 import com.squareup.picasso.Callback;
 import com.squareup.picasso.RequestCreator;
+import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
 import javax.inject.Provider;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
@@ -79,6 +89,8 @@
 
   private com.google.firebase.inappmessaging.display.FirebaseInAppMessagingDisplay fiamUI;
   private Map<String, Provider<InAppMessageLayoutConfig>> layoutConfigs;
+  private DisplayMetrics testDisplayMetrics = new DisplayMetrics();
+  private InflaterConfigModule inflaterConfigModule = new InflaterConfigModule();
 
   @Mock private FirebaseInAppMessaging headless;
   @Mock private FiamImageLoader imageLoader;
@@ -86,8 +98,8 @@
   @Mock private RenewableTimer autoDismissTimer;
   @Mock private FiamWindowManager windowManager;
   @Captor private ArgumentCaptor<FirebaseInAppMessagingDisplay> inAppMessageTriggerListenerCaptor;
-  @Captor private ArgumentCaptor<OnClickListener> onClickListenerArgCaptor;
-  @Captor private ArgumentCaptor<View.OnTouchListener> onTouchListenerArgumentCaptor;
+  @Captor private ArgumentCaptor<Map<Action, OnClickListener>> onClickListenerArgCaptor;
+  @Captor private ArgumentCaptor<OnClickListener> onDismissListenerArgCaptor;
   @Captor private ArgumentCaptor<Callback> callbackArgCaptor;
   @Captor private ArgumentCaptor<RenewableTimer.Callback> timerArgCaptor;
 
@@ -95,68 +107,6 @@
   private ArgumentCaptor<FiamAnimator.AnimationCompleteListener>
       animationCompleteListenerArgumentCaptor;
 
-  private static final String IMAGE_URL = "https://www.imgur.com";
-  private static final String CAMPAIGN_ID = "campaign_id";
-  private static final String CAMPAIGN_NAME = "campaign_name";
-  private static final String ACTION_URL = "https://www.google.com";
-  private static final InAppMessage.Action ACTION =
-      InAppMessage.Action.builder().setActionUrl(ACTION_URL).build();
-  private static final InAppMessage IMAGE_ONLY_MESSAGE =
-      InAppMessage.builder()
-          .setCampaignId(CAMPAIGN_ID)
-          .setIsTestMessage(false)
-          .setCampaignName(CAMPAIGN_NAME)
-          .setAction(ACTION)
-          .setMessageType(MessageType.IMAGE_ONLY)
-          .setImageUrl(IMAGE_URL)
-          .build();
-  private static final InAppMessage MODAL_MESSAGE =
-      InAppMessage.builder()
-          .setCampaignId(CAMPAIGN_ID)
-          .setIsTestMessage(false)
-          .setCampaignName(CAMPAIGN_NAME)
-          .setAction(ACTION)
-          .setMessageType(MessageType.MODAL)
-          .setImageUrl(IMAGE_URL)
-          .build();
-  private static final InAppMessage BANNER_MESSAGE =
-      InAppMessage.builder()
-          .setCampaignId(CAMPAIGN_ID)
-          .setIsTestMessage(false)
-          .setCampaignName(CAMPAIGN_NAME)
-          .setAction(ACTION)
-          .setMessageType(MessageType.BANNER)
-          .setImageUrl(IMAGE_URL)
-          .build();
-  private static final InAppMessageLayoutConfig inappMessageLayoutConfig =
-      InAppMessageLayoutConfig.builder()
-          .setMaxDialogHeightPx((int) (0.9f * 1000))
-          .setMaxDialogWidthPx((int) (0.9f * 1000))
-          .setMaxImageWidthWeight(0.8f)
-          .setMaxImageHeightWeight(0.8f)
-          .setViewWindowGravity(Gravity.CENTER)
-          .setWindowFlag(1)
-          .setWindowWidth(ViewGroup.LayoutParams.WRAP_CONTENT)
-          .setWindowHeight(ViewGroup.LayoutParams.WRAP_CONTENT)
-          .setBackgroundEnabled(false)
-          .setAnimate(false)
-          .setAutoDismiss(false)
-          .build();
-  private static final InAppMessageLayoutConfig bannerConfig =
-      InAppMessageLayoutConfig.builder()
-          .setMaxDialogHeightPx((int) (0.9f * 1000))
-          .setMaxDialogWidthPx((int) (0.9f * 1000))
-          .setMaxImageWidthWeight(0.8f)
-          .setMaxImageHeightWeight(0.8f)
-          .setViewWindowGravity(Gravity.CENTER)
-          .setWindowFlag(1)
-          .setWindowWidth(ViewGroup.LayoutParams.WRAP_CONTENT)
-          .setWindowHeight(ViewGroup.LayoutParams.WRAP_CONTENT)
-          .setBackgroundEnabled(true)
-          .setAnimate(true)
-          .setAutoDismiss(true)
-          .build();
-
   @Mock private BindingWrapperFactory bindingClient;
   @Mock private FiamListener fiamUIListener;
   @Mock private ViewTreeObserver.OnGlobalLayoutListener globalLayoutListener;
@@ -164,8 +114,13 @@
   @Mock private FirebaseInAppMessagingDisplayCallbacks callbacks;
 
   private ImageBindingWrapper imageBindingWrapper;
+  private InAppMessageLayoutConfig imageLayoutConfig;
   private ModalBindingWrapper modalBindingWrapper;
+  private InAppMessageLayoutConfig modalLayoutConfig;
   private BannerBindingWrapper bannerBindingWrapper;
+  private InAppMessageLayoutConfig bannerLayoutConfig;
+  private CardBindingWrapper cardBindingWrapper;
+  private InAppMessageLayoutConfig cardLayoutConfig;
 
   private TestActivity activity;
   private ShadowActivity shadowActivity;
@@ -174,33 +129,46 @@
 
   @Before
   public void setup() {
+    testDisplayMetrics.widthPixels = 1000;
+    testDisplayMetrics.widthPixels = 2000;
+    modalLayoutConfig = inflaterConfigModule.providesModalPortraitConfig(testDisplayMetrics);
+    imageLayoutConfig = inflaterConfigModule.providesPortraitImageLayoutConfig(testDisplayMetrics);
+    bannerLayoutConfig =
+        inflaterConfigModule.providesBannerPortraitLayoutConfig(testDisplayMetrics);
+    cardLayoutConfig = inflaterConfigModule.providesCardPortraitConfig(testDisplayMetrics);
+
     MockitoAnnotations.initMocks(this);
     layoutConfigs = new HashMap<>();
     layoutConfigs.put(
-        InflaterConfigModule.configFor(
-            IMAGE_ONLY_MESSAGE.getMessageType(), Configuration.ORIENTATION_PORTRAIT),
+        InflaterConfigModule.configFor(MessageType.MODAL, Configuration.ORIENTATION_PORTRAIT),
         new Provider<InAppMessageLayoutConfig>() {
           @Override
           public InAppMessageLayoutConfig get() {
-            return inappMessageLayoutConfig;
+            return modalLayoutConfig;
           }
         });
     layoutConfigs.put(
-        InflaterConfigModule.configFor(
-            MODAL_MESSAGE.getMessageType(), Configuration.ORIENTATION_PORTRAIT),
+        InflaterConfigModule.configFor(MessageType.IMAGE_ONLY, Configuration.ORIENTATION_PORTRAIT),
         new Provider<InAppMessageLayoutConfig>() {
           @Override
           public InAppMessageLayoutConfig get() {
-            return inappMessageLayoutConfig;
+            return imageLayoutConfig;
           }
         });
     layoutConfigs.put(
-        InflaterConfigModule.configFor(
-            BANNER_MESSAGE.getMessageType(), Configuration.ORIENTATION_PORTRAIT),
+        InflaterConfigModule.configFor(MessageType.BANNER, Configuration.ORIENTATION_PORTRAIT),
         new Provider<InAppMessageLayoutConfig>() {
           @Override
           public InAppMessageLayoutConfig get() {
-            return bannerConfig;
+            return bannerLayoutConfig;
+          }
+        });
+    layoutConfigs.put(
+        InflaterConfigModule.configFor(MessageType.CARD, Configuration.ORIENTATION_PORTRAIT),
+        new Provider<InAppMessageLayoutConfig>() {
+          @Override
+          public InAppMessageLayoutConfig get() {
+            return cardLayoutConfig;
           }
         });
 
@@ -209,21 +177,22 @@ public InAppMessageLayoutConfig get() {
 
     LayoutInflater inflater = LayoutInflater.from(application);
     imageBindingWrapper =
-        spy(new ImageBindingWrapper(inappMessageLayoutConfig, inflater, IMAGE_ONLY_MESSAGE));
+        spy(new ImageBindingWrapper(imageLayoutConfig, inflater, IMAGE_MESSAGE_MODEL));
     modalBindingWrapper =
-        spy(new ModalBindingWrapper(inappMessageLayoutConfig, inflater, MODAL_MESSAGE));
-    bannerBindingWrapper = spy(new BannerBindingWrapper(BANNER_MESSAGE, inflater, bannerConfig));
+        spy(new ModalBindingWrapper(modalLayoutConfig, inflater, MODAL_MESSAGE_MODEL));
+    bannerBindingWrapper =
+        spy(new BannerBindingWrapper(bannerLayoutConfig, inflater, BANNER_MESSAGE_MODEL));
+    cardBindingWrapper =
+        spy(new CardBindingWrapper(cardLayoutConfig, inflater, CARD_MESSAGE_MODEL));
 
-    when(bindingClient.createImageBindingWrapper(
-            eq(inappMessageLayoutConfig), any(InAppMessage.class)))
+    when(bindingClient.createImageBindingWrapper(eq(imageLayoutConfig), any(InAppMessage.class)))
         .thenReturn(imageBindingWrapper);
-    when(bindingClient.createModalBindingWrapper(
-            eq(inappMessageLayoutConfig), any(InAppMessage.class)))
+    when(bindingClient.createModalBindingWrapper(eq(modalLayoutConfig), any(InAppMessage.class)))
         .thenReturn(modalBindingWrapper);
-    when(bindingClient.createBannerBindingWrapper(eq(bannerConfig), any(InAppMessage.class)))
+    when(bindingClient.createBannerBindingWrapper(eq(bannerLayoutConfig), any(InAppMessage.class)))
         .thenReturn(bannerBindingWrapper);
 
-    when(imageLoader.load(IMAGE_URL)).thenReturn(fakeRequestCreator);
+    when(imageLoader.load(IMAGE_URL_STRING)).thenReturn(fakeRequestCreator);
     fiamUI =
         new com.google.firebase.inappmessaging.display.FirebaseInAppMessagingDisplay(
             headless,
@@ -286,7 +255,7 @@ public void onActivityPaused_cancelsAutoDismissTImer() {
   public void onActivityResumed_whenFiamActive_showsFiam() {
     when(windowManager.isFiamDisplayed()).thenReturn(true);
     startActivity();
-    listener.displayMessage(IMAGE_ONLY_MESSAGE, callbacks);
+    listener.displayMessage(IMAGE_MESSAGE_MODEL, callbacks);
     verify(fakeRequestCreator).into(any(ImageView.class), callbackArgCaptor.capture());
     callbackArgCaptor.getValue().onSuccess();
 
@@ -302,7 +271,7 @@ public void onActivityResumed_whenFiamActive_showsFiam() {
   public void streamListener_onNotifiedImage_showsImageMessage() {
     when(windowManager.isFiamDisplayed()).thenReturn(true);
     startActivity();
-    listener.displayMessage(IMAGE_ONLY_MESSAGE, callbacks);
+    listener.displayMessage(IMAGE_MESSAGE_MODEL, callbacks);
     verify(fakeRequestCreator).into(any(ImageView.class), callbackArgCaptor.capture());
     callbackArgCaptor.getValue().onSuccess();
 
@@ -313,19 +282,31 @@ public void streamListener_onNotifiedImage_showsImageMessage() {
   public void streamListener_onNotifiedModal_showsModalMessage() {
     when(windowManager.isFiamDisplayed()).thenReturn(true);
     startActivity();
-    listener.displayMessage(MODAL_MESSAGE, callbacks);
+    listener.displayMessage(MODAL_MESSAGE_MODEL, callbacks);
     verify(fakeRequestCreator).into(any(ImageView.class), callbackArgCaptor.capture());
     callbackArgCaptor.getValue().onSuccess();
 
     verify(windowManager).show(modalBindingWrapper, activity);
   }
 
+  @Test
+  @Ignore
+  public void streamListener_onNotifiedCard_showsCardMessage() {
+    when(windowManager.isFiamDisplayed()).thenReturn(true);
+    startActivity();
+    listener.displayMessage(CARD_MESSAGE_MODEL, callbacks);
+    verify(fakeRequestCreator).into(any(ImageView.class), callbackArgCaptor.capture());
+    callbackArgCaptor.getValue().onSuccess();
+
+    verify(windowManager).show(cardBindingWrapper, activity);
+  }
+
   @Test
   public void streamListener_onNotified_InflatesBinding() {
     startActivity();
-    listener.displayMessage(IMAGE_ONLY_MESSAGE, callbacks);
+    listener.displayMessage(IMAGE_MESSAGE_MODEL, callbacks);
 
-    verify(imageBindingWrapper).inflate(any(OnClickListener.class), any(OnClickListener.class));
+    verify(imageBindingWrapper).inflate(any(Map.class), any(OnClickListener.class));
   }
 
   @Test
@@ -336,7 +317,7 @@ public void streamListener_onNotifiedModalMessage_setsLayoutListener() {
         mock(ViewTreeObserver.OnGlobalLayoutListener.class);
     modalBindingWrapper.setLayoutListener(mockListener);
 
-    listener.displayMessage(MODAL_MESSAGE, callbacks);
+    listener.displayMessage(MODAL_MESSAGE_MODEL, callbacks);
 
     modalBindingWrapper.getImageView().getViewTreeObserver().dispatchOnGlobalLayout();
     verify(mockListener).onGlobalLayout();
@@ -344,21 +325,15 @@ public void streamListener_onNotifiedModalMessage_setsLayoutListener() {
 
   @Test
   public void streamListener_whenNoActionUrlIsSet_dismissesFiam() {
-    InAppMessage inAppMessage =
-        InAppMessage.builder()
-            .setCampaignId(CAMPAIGN_ID)
-            .setIsTestMessage(false)
-            .setCampaignName(CAMPAIGN_NAME)
-            .setAction(InAppMessage.Action.builder().setActionUrl("").build())
-            .setMessageType(MessageType.IMAGE_ONLY)
-            .setImageUrl(IMAGE_URL)
-            .build();
     when(windowManager.isFiamDisplayed()).thenReturn(true);
     startActivity();
-    listener.displayMessage(inAppMessage, callbacks);
+    listener.displayMessage(IMAGE_MESSAGE_MODEL_WITHOUT_ACTION, callbacks);
     verify(imageBindingWrapper)
         .inflate(onClickListenerArgCaptor.capture(), any(OnClickListener.class));
-    onClickListenerArgCaptor.getValue().onClick(null);
+    onClickListenerArgCaptor
+        .getValue()
+        .get(IMAGE_MESSAGE_MODEL_WITHOUT_ACTION.getAction())
+        .onClick(null);
 
     verify(windowManager).destroy(activity);
   }
@@ -367,7 +342,7 @@ public void streamListener_whenNoActionUrlIsSet_dismissesFiam() {
   public void streamListener_whenImageUrlExists_loadsImage() {
     when(windowManager.isFiamDisplayed()).thenReturn(true);
     startActivity();
-    listener.displayMessage(IMAGE_ONLY_MESSAGE, callbacks);
+    listener.displayMessage(IMAGE_MESSAGE_MODEL, callbacks);
 
     verify(fakeRequestCreator).tag(TestActivity.class);
     verify(fakeRequestCreator).placeholder(R.drawable.image_placeholder);
@@ -376,17 +351,8 @@ public void streamListener_whenImageUrlExists_loadsImage() {
 
   @Test
   public void streamListener_whenNoImageUrlExists_doesNotLoadImage() {
-    InAppMessage inAppMessage =
-        InAppMessage.builder()
-            .setCampaignId(CAMPAIGN_ID)
-            .setIsTestMessage(false)
-            .setCampaignName(CAMPAIGN_NAME)
-            .setAction(InAppMessage.Action.builder().setActionUrl("").build())
-            .setMessageType(MessageType.IMAGE_ONLY)
-            .build();
     startActivity();
-    listener.displayMessage(inAppMessage, callbacks);
-
+    listener.displayMessage(null, callbacks);
     verify(fakeRequestCreator, times(0)).tag(TestActivity.class);
     verify(fakeRequestCreator, times(0)).placeholder(R.drawable.image_placeholder);
     verify(fakeRequestCreator, times(0)).into(any(ImageView.class), any(Callback.class));
@@ -396,23 +362,21 @@ public void streamListener_whenNoImageUrlExists_doesNotLoadImage() {
   public void streamListener_whenImageLoadSucceeds_showsWindow() {
     when(windowManager.isFiamDisplayed()).thenReturn(true);
     startActivity();
-    listener.displayMessage(IMAGE_ONLY_MESSAGE, callbacks);
+    listener.displayMessage(IMAGE_MESSAGE_MODEL, callbacks);
     verify(fakeRequestCreator)
         .into(eq(imageBindingWrapper.getImageView()), callbackArgCaptor.capture());
 
     callbackArgCaptor.getValue().onSuccess();
-
     verify(windowManager).show(imageBindingWrapper, activity);
   }
 
   @Test
   public void streamListener_whenImageLoadSucceeds_startsImpressionTimer() {
     startActivity();
-    listener.displayMessage(IMAGE_ONLY_MESSAGE, callbacks);
+    listener.displayMessage(IMAGE_MESSAGE_MODEL, callbacks);
     verify(fakeRequestCreator).into(any(ImageView.class), callbackArgCaptor.capture());
 
     callbackArgCaptor.getValue().onSuccess();
-
     verify(impressionTimer)
         .start(
             any(RenewableTimer.Callback.class),
@@ -427,11 +391,10 @@ public void streamListener_whenImageLoadSucceeds_startsImpressionTimer() {
   @Test
   public void streamListener_whenImageLoadSucceedsForAutoDismissFiam_startsDismissTimer() {
     startActivity();
-    listener.displayMessage(BANNER_MESSAGE, callbacks);
+    listener.displayMessage(BANNER_MESSAGE_MODEL, callbacks);
     verify(fakeRequestCreator).into(any(ImageView.class), callbackArgCaptor.capture());
 
     callbackArgCaptor.getValue().onSuccess();
-
     verify(autoDismissTimer)
         .start(
             any(RenewableTimer.Callback.class),
@@ -447,11 +410,11 @@ public void streamListener_whenImageLoadSucceedsForAutoDismissFiam_startsDismiss
   @Test
   public void streamListener_whenImageLoadFails_stopsImpressionTimer() {
     startActivity();
-    listener.displayMessage(IMAGE_ONLY_MESSAGE, callbacks);
+    listener.displayMessage(IMAGE_MESSAGE_MODEL, callbacks);
     verify(fakeRequestCreator).into(any(ImageView.class), callbackArgCaptor.capture());
 
-    callbackArgCaptor.getValue().onError();
-
+    Exception e = new IOException();
+    callbackArgCaptor.getValue().onError(e);
     verify(impressionTimer).cancel();
   }
 
@@ -459,18 +422,17 @@ public void streamListener_whenImageLoadFails_stopsImpressionTimer() {
   @Test
   public void streamListener_whenImageLoadFails_stopsDismissTimer() {
     startActivity();
-    listener.displayMessage(BANNER_MESSAGE, callbacks);
+    listener.displayMessage(BANNER_MESSAGE_MODEL, callbacks);
     verify(fakeRequestCreator).into(any(ImageView.class), callbackArgCaptor.capture());
-
-    callbackArgCaptor.getValue().onError();
-
+    Exception e = new IOException();
+    callbackArgCaptor.getValue().onError(e);
     verify(autoDismissTimer).cancel();
   }
 
   @Test
   public void streamListener_whenImageLoadFailsForModal_removesLayoutListener() {
     startActivity();
-    listener.displayMessage(MODAL_MESSAGE, callbacks);
+    listener.displayMessage(MODAL_MESSAGE_MODEL, callbacks);
     verify(fakeRequestCreator)
         .into(eq(modalBindingWrapper.getImageView()), callbackArgCaptor.capture());
 
@@ -478,7 +440,8 @@ public void streamListener_whenImageLoadFailsForModal_removesLayoutListener() {
         mock(ViewTreeObserver.OnGlobalLayoutListener.class);
 
     modalBindingWrapper.setLayoutListener(mockListener);
-    callbackArgCaptor.getValue().onError();
+    Exception e = new IOException();
+    callbackArgCaptor.getValue().onError(e);
 
     // Verify that the listener is no longer called
     modalBindingWrapper.getImageView().getViewTreeObserver().dispatchOnGlobalLayout();
@@ -489,21 +452,20 @@ public void streamListener_whenImageLoadFailsForModal_removesLayoutListener() {
   public void streamListener_forBackgroundDisabledFiams_dismissesFiamOnClickOutside() {
     when(windowManager.isFiamDisplayed()).thenReturn(true);
     startActivity();
-    listener.displayMessage(IMAGE_ONLY_MESSAGE, callbacks);
+    listener.displayMessage(IMAGE_MESSAGE_MODEL, callbacks);
     verify(fakeRequestCreator).into(any(ImageView.class), callbackArgCaptor.capture());
     callbackArgCaptor.getValue().onSuccess();
 
     imageBindingWrapper
         .getRootView()
         .dispatchTouchEvent(MotionEvent.obtain(1, 2, MotionEvent.ACTION_OUTSIDE, 1, 2, 1));
-
     verify(windowManager).destroy(activity);
   }
 
   @Test
   public void streamListener_forBackgroundDisabledFiams_returnsTrueOnTouchEvents() {
     startActivity();
-    listener.displayMessage(IMAGE_ONLY_MESSAGE, callbacks);
+    listener.displayMessage(IMAGE_MESSAGE_MODEL, callbacks);
     verify(fakeRequestCreator).into(any(ImageView.class), callbackArgCaptor.capture());
     callbackArgCaptor.getValue().onSuccess();
 
@@ -511,7 +473,6 @@ public void streamListener_forBackgroundDisabledFiams_returnsTrueOnTouchEvents()
         imageBindingWrapper
             .getRootView()
             .dispatchTouchEvent(MotionEvent.obtain(1, 2, MotionEvent.ACTION_OUTSIDE, 1, 2, 1));
-
     assertThat(ret).isTrue();
   }
 
@@ -519,7 +480,7 @@ public void streamListener_forBackgroundDisabledFiams_returnsTrueOnTouchEvents()
   public void streamListener_onNotifiedAnimatableMessage_animatesEntry() {
     when(windowManager.isFiamDisplayed()).thenReturn(true);
     startActivity();
-    listener.displayMessage(BANNER_MESSAGE, callbacks);
+    listener.displayMessage(BANNER_MESSAGE_MODEL, callbacks);
     verify(fakeRequestCreator).into(any(ImageView.class), callbackArgCaptor.capture());
     callbackArgCaptor.getValue().onSuccess();
 
@@ -529,7 +490,7 @@ public void streamListener_onNotifiedAnimatableMessage_animatesEntry() {
   @Test
   public void impressionTimer_onComplete_firesImpressionLogAction() {
     startActivity();
-    listener.displayMessage(IMAGE_ONLY_MESSAGE, callbacks);
+    listener.displayMessage(IMAGE_MESSAGE_MODEL, callbacks);
     when(windowManager.isFiamDisplayed()).thenReturn(true);
     verify(fakeRequestCreator).into(any(ImageView.class), callbackArgCaptor.capture());
     callbackArgCaptor.getValue().onSuccess();
@@ -543,7 +504,7 @@ public void impressionTimer_onComplete_firesImpressionLogAction() {
   @Test
   public void dismissTimer_onComplete_dismissesFiam() {
     startActivity();
-    listener.displayMessage(BANNER_MESSAGE, callbacks);
+    listener.displayMessage(BANNER_MESSAGE_MODEL, callbacks);
     when(windowManager.isFiamDisplayed()).thenReturn(true);
     verify(fakeRequestCreator).into(any(ImageView.class), callbackArgCaptor.capture());
     callbackArgCaptor.getValue().onSuccess();
@@ -557,31 +518,22 @@ public void dismissTimer_onComplete_dismissesFiam() {
   @Test
   public void fiamClickListener_whenActionUrlProvided_opensCustomTab() {
     startActivity();
-    listener.displayMessage(IMAGE_ONLY_MESSAGE, callbacks);
+    listener.displayMessage(IMAGE_MESSAGE_MODEL, callbacks);
     verify(imageBindingWrapper)
         .inflate(onClickListenerArgCaptor.capture(), any(OnClickListener.class));
-    onClickListenerArgCaptor.getValue().onClick(null);
+    onClickListenerArgCaptor.getValue().get(IMAGE_MESSAGE_MODEL.getAction()).onClick(null);
 
-    assertThat(shadowActivity.getNextStartedActivity().getData()).isEqualTo(Uri.parse(ACTION_URL));
+    assertThat(shadowActivity.getNextStartedActivity().getData())
+        .isEqualTo(Uri.parse(ACTION_URL_STRING));
   }
 
   @Test
   public void dismissClickListener_dismissesFiam() {
-    InAppMessage inAppMessage =
-        InAppMessage.builder()
-            .setCampaignId(CAMPAIGN_ID)
-            .setIsTestMessage(false)
-            .setCampaignName(CAMPAIGN_NAME)
-            .setAction(InAppMessage.Action.builder().setActionUrl("").build())
-            .setMessageType(MessageType.IMAGE_ONLY)
-            .setImageUrl(IMAGE_URL)
-            .build();
     when(windowManager.isFiamDisplayed()).thenReturn(true);
     startActivity();
-    listener.displayMessage(inAppMessage, callbacks);
-    verify(imageBindingWrapper)
-        .inflate(any(OnClickListener.class), onClickListenerArgCaptor.capture());
-    onClickListenerArgCaptor.getValue().onClick(null);
+    listener.displayMessage(IMAGE_MESSAGE_MODEL_WITHOUT_ACTION, callbacks);
+    verify(imageBindingWrapper).inflate(any(Map.class), onDismissListenerArgCaptor.capture());
+    onDismissListenerArgCaptor.getValue().onClick(null);
 
     verify(windowManager).destroy(activity);
   }
@@ -590,7 +542,7 @@ public void dismissClickListener_dismissesFiam() {
   public void firebaseInAppMessagingUIListener_whenFiamRendered_receivesOnFiamTrigger() {
     startActivity();
     fiamUI.setFiamListener(fiamUIListener);
-    listener.displayMessage(IMAGE_ONLY_MESSAGE, callbacks);
+    listener.displayMessage(IMAGE_MESSAGE_MODEL, callbacks);
 
     verify(fiamUIListener).onFiamTrigger();
   }
@@ -599,10 +551,10 @@ public void firebaseInAppMessagingUIListener_whenFiamRendered_receivesOnFiamTrig
   public void fiamUIListener_whenFiamClicked_receivesOnFiamClick() {
     startActivity();
     fiamUI.setFiamListener(fiamUIListener);
-    listener.displayMessage(IMAGE_ONLY_MESSAGE, callbacks);
+    listener.displayMessage(IMAGE_MESSAGE_MODEL, callbacks);
     verify(imageBindingWrapper)
         .inflate(onClickListenerArgCaptor.capture(), any(OnClickListener.class));
-    onClickListenerArgCaptor.getValue().onClick(null);
+    onClickListenerArgCaptor.getValue().get(IMAGE_MESSAGE_MODEL.getAction()).onClick(null);
 
     verify(fiamUIListener).onFiamTrigger();
   }
@@ -611,13 +563,13 @@ public void fiamUIListener_whenFiamClicked_receivesOnFiamClick() {
   public void inflate_setsActionListenerToDismissFiamOnClick() throws Exception {
     startActivity();
     fiamUI.setFiamListener(fiamUIListener);
-    listener.displayMessage(MODAL_MESSAGE, callbacks);
+    listener.displayMessage(MODAL_MESSAGE_MODEL, callbacks);
     verify(modalBindingWrapper)
         .inflate(onClickListenerArgCaptor.capture(), any(OnClickListener.class));
     Button button = modalBindingWrapper.getActionButton();
 
     assertThat(fiamUI.getCurrentInAppMessage()).isNotNull();
-    assertThat(fiamUI.getCurrentInAppMessage()).isEqualTo(MODAL_MESSAGE);
+    assertThat(fiamUI.getCurrentInAppMessage()).isEqualTo(MODAL_MESSAGE_MODEL);
     when(windowManager.isFiamDisplayed()).thenReturn(true);
     button.performClick();
     // Assert that after the messageClick, we now have a null FIAM
diff --git a/firebase-inappmessaging-display/src/test/java/com/google/firebase/inappmessaging/display/internal/FiamWindowManagerTest.java b/firebase-inappmessaging-display/src/test/java/com/google/firebase/inappmessaging/display/internal/FiamWindowManagerTest.java
index 71521489d..1a29837bd 100644
--- a/firebase-inappmessaging-display/src/test/java/com/google/firebase/inappmessaging/display/internal/FiamWindowManagerTest.java
+++ b/firebase-inappmessaging-display/src/test/java/com/google/firebase/inappmessaging/display/internal/FiamWindowManagerTest.java
@@ -15,6 +15,7 @@
 package com.google.firebase.inappmessaging.display.internal;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.firebase.inappmessaging.testutil.TestData.IMAGE_MESSAGE_MODEL;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.times;
@@ -28,8 +29,7 @@
 import android.view.WindowManager;
 import com.google.firebase.inappmessaging.display.internal.bindingwrappers.BindingWrapper;
 import com.google.firebase.inappmessaging.display.internal.bindingwrappers.ImageBindingWrapper;
-import com.google.firebase.inappmessaging.model.InAppMessage;
-import com.google.firebase.inappmessaging.model.MessageType;
+import java.util.HashMap;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -44,12 +44,6 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(sdk = 21, qualifiers = "port")
 public class FiamWindowManagerTest {
-  private static final String IMAGE_URL = "https://www.imgur.com";
-  private static final String CAMPAIGN_ID = "campaign_id";
-  private static final String CAMPAIGN_NAME = "campaign_name";
-  private static final String ACTION_URL = "https://www.google.com";
-  private static final InAppMessage.Action ACTION =
-      InAppMessage.Action.builder().setActionUrl(ACTION_URL).build();
   private static final Context appContext = RuntimeEnvironment.application.getApplicationContext();
   private static final int WINDOW_GRAVITY = Gravity.CENTER;
   private static final InAppMessageLayoutConfig inappMessageLayoutConfig =
@@ -67,16 +61,6 @@
           .setAutoDismiss(false)
           .build();
 
-  private static final InAppMessage IN_APP_MESSAGE =
-      InAppMessage.builder()
-          .setCampaignId(CAMPAIGN_ID)
-          .setIsTestMessage(false)
-          .setCampaignName(CAMPAIGN_NAME)
-          .setAction(ACTION)
-          .setMessageType(MessageType.IMAGE_ONLY)
-          .setImageUrl(IMAGE_URL)
-          .build();
-
   private FiamWindowManager fiamWindowManager;
   private TestActivity activity;
   private BindingWrapper bindingWrapper;
@@ -92,8 +76,8 @@ public void setup() {
 
     LayoutInflater inflater = LayoutInflater.from(appContext);
     bindingWrapper =
-        spy(new ImageBindingWrapper(inappMessageLayoutConfig, inflater, IN_APP_MESSAGE));
-    bindingWrapper.inflate(null, null);
+        spy(new ImageBindingWrapper(inappMessageLayoutConfig, inflater, IMAGE_MESSAGE_MODEL));
+    bindingWrapper.inflate(new HashMap<>(), null);
 
     windowManager = spy((WindowManager) activity.getSystemService(Context.WINDOW_SERVICE));
     activity.setWindowManager(windowManager);
diff --git a/firebase-inappmessaging-display/src/test/java/com/google/firebase/inappmessaging/display/internal/TestActivity.java b/firebase-inappmessaging-display/src/test/java/com/google/firebase/inappmessaging/display/internal/TestActivity.java
index b58bd54ab..1e4ab7567 100644
--- a/firebase-inappmessaging-display/src/test/java/com/google/firebase/inappmessaging/display/internal/TestActivity.java
+++ b/firebase-inappmessaging-display/src/test/java/com/google/firebase/inappmessaging/display/internal/TestActivity.java
@@ -16,8 +16,8 @@
 
 import android.app.Activity;
 import android.content.Context;
-import android.support.annotation.NonNull;
 import android.view.WindowManager;
+import androidx.annotation.NonNull;
 import java.util.Objects;
 
 class TestActivity extends Activity {
diff --git a/firebase-inappmessaging/README.md b/firebase-inappmessaging/README.md
new file mode 100644
index 000000000..490454eb9
--- /dev/null
+++ b/firebase-inappmessaging/README.md
@@ -0,0 +1,17 @@
+# Firebase In-App Messaging SDK
+[Firebase In-App Messaging](https://firebase.google.com/docs/in-app-messaging/) helps you engage
+users who are actively using your app by sending them targeted and contextual messages that nudge
+them to complete key in-app actions - like beating a game level, buying an item, or subscribing to
+content.
+
+The FIAM SDK manages the non-ui logic for FIAM - including fetching new eligible messages from the server, and triggering FIAM messages.
+
+## Running Tests
+Unit tests:
+`../gradlew :firebase-inappmessaging:test`
+
+Integration tests, requiring a running and connected device (emulator or real):
+`../gradlew :firebase-inappmessaging:connectedAndroidTest`
+
+The best way to the FIAM sdks is via the fiamui-app in this repo - you can run the test, or use
+Firebase Test Lab to run a series of UI tests. See fiamui-app/scripts for more details
\ No newline at end of file
diff --git a/firebase-inappmessaging/api.txt b/firebase-inappmessaging/api.txt
new file mode 100644
index 000000000..b7e2988ae
--- /dev/null
+++ b/firebase-inappmessaging/api.txt
@@ -0,0 +1,24 @@
+// Signature format: 2.0
+package com.google.firebase.inappmessaging {
+
+  public class FirebaseInAppMessaging {
+    method public void addClickListener(FirebaseInAppMessagingClickListener);
+    method public void addClickListener(FirebaseInAppMessagingClickListener, Executor);
+    method public void addDisplayErrorListener(FirebaseInAppMessagingDisplayErrorListener);
+    method public void addDisplayErrorListener(FirebaseInAppMessagingDisplayErrorListener, Executor);
+    method public void addImpressionListener(FirebaseInAppMessagingImpressionListener);
+    method public void addImpressionListener(FirebaseInAppMessagingImpressionListener, Executor);
+    method public boolean areMessagesSuppressed();
+    method public void displayMessage(InAppMessage, FirebaseInAppMessagingDisplayCallbacks);
+    method public boolean isAutomaticDataCollectionEnabled();
+    method public static com.google.firebase.inappmessaging.FirebaseInAppMessaging getInstance();
+    method public void removeClickListener(FirebaseInAppMessagingClickListener);
+    method public void removeDisplayErrorListener(FirebaseInAppMessagingDisplayErrorListener);
+    method public void removeImpressionListener(FirebaseInAppMessagingImpressionListener);
+    method public void setAutomaticDataCollectionEnabled(boolean);
+    method public void setMessageDisplayComponent(com.google.firebase.inappmessaging.display.FirebaseInAppMessagingDisplay) 
+    method public void setMessagesSuppressed(Boolean);
+    method public void triggerEvent(String);
+  }
+
+}
\ No newline at end of file
diff --git a/firebase-inappmessaging/firebase-inappmessaging.gradle b/firebase-inappmessaging/firebase-inappmessaging.gradle
new file mode 100644
index 000000000..093be7c73
--- /dev/null
+++ b/firebase-inappmessaging/firebase-inappmessaging.gradle
@@ -0,0 +1,157 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+plugins {
+    id 'firebase-library'
+    id 'com.google.protobuf'
+}
+
+firebaseLibrary {
+    testLab.enabled = true
+}
+
+protobuf {
+    // Configure the protoc executable
+    protoc {
+        // Download from repositories
+        artifact = 'com.google.protobuf:protoc:3.4.0'
+    }
+    plugins {
+        grpc {
+            artifact = 'io.grpc:protoc-gen-grpc-java:1.21.0'
+        }
+        javalite {
+            // The codegen for lite comes as a separate artifact
+            artifact = 'com.google.protobuf:protoc-gen-javalite:3.0.0'
+        }
+    }
+    generateProtoTasks {
+        all().each { task ->
+            task.builtins {
+                // In most cases you don't need the full Java output
+                // if you use the lite output.
+                remove java
+            }
+            task.plugins {
+                grpc {
+                    option 'lite'
+                }
+                javalite {}
+            }
+        }
+    }
+}
+
+android {
+    adbOptions {
+        timeOutInMs 60 * 1000
+    }
+
+    compileSdkVersion project.targetSdkVersion
+    defaultConfig {
+      minSdkVersion 16
+      targetSdkVersion project.targetSdkVersion
+      multiDexEnabled true
+      versionName version
+      testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+    }
+    sourceSets {
+        main {
+            java {
+            }
+            proto {
+                srcDir 'src/proto'
+            }
+        }
+        androidTest {
+            java {
+                srcDir 'src/testUtil'
+                srcDir 'src/testData'
+            }
+        }
+        test {
+            java {
+                srcDir 'src/testUtil'
+                srcDir 'src/testData'
+            }
+        }
+    }
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+        // Neccesary for Dagger
+        incremental = false
+    }
+    testOptions {
+        unitTests {
+            includeAndroidResources = true
+        }
+    }
+}
+
+configurations.all {
+    if(it.name.contains('AndroidTestRuntimeClasspath')) {
+        it.resolutionStrategy {
+            force 'org.checkerframework:checker-compat-qual:2.5.5'
+            force 'com.google.guava:guava:27.0.1-android'
+        }
+    }
+}
+
+dependencies {
+    implementation project(':firebase-abt')
+    implementation project(':firebase-common')
+    implementation project(':protolite-well-known-types')
+    implementation project(':transport:transport-api')
+    implementation project(':firebase-datatransport')
+
+    implementation 'io.grpc:grpc-stub:1.21.0'
+    implementation 'io.grpc:grpc-protobuf-lite:1.21.0'
+    implementation 'io.grpc:grpc-okhttp:1.21.0'
+    implementation 'com.google.dagger:dagger:2.22'
+    implementation 'io.reactivex.rxjava2:rxjava:2.1.14'
+    implementation 'io.reactivex.rxjava2:rxandroid:2.0.2'
+    implementation 'com.google.auto.value:auto-value-annotations:1.6.5'
+    implementation ('com.google.firebase:firebase-iid:19.0.0') {
+        exclude group: "com.google.firebase", module: "firebase-common"
+    }
+
+    implementation('com.google.firebase:firebase-measurement-connector:18.0.0') {
+        exclude group: 'com.google.firebase', module: 'firebase-common'
+    }
+
+    annotationProcessor 'com.google.dagger:dagger-compiler:2.22'
+    annotationProcessor 'com.google.auto.value:auto-value:1.6.2'
+    annotationProcessor 'com.ryanharter.auto.value:auto-value-parcel:0.2.6'
+
+    testImplementation 'org.mockito:mockito-core:1.10.19'
+    testImplementation "com.google.truth:truth:$googleTruthVersion"
+    testImplementation 'junit:junit:4.12'
+    testImplementation 'androidx.test:runner:1.2.0'
+    testImplementation 'org.robolectric:robolectric:4.2'
+    testImplementation 'io.grpc:grpc-testing:1.21.0'
+    testImplementation 'joda-time:joda-time:2.9.2'
+
+    androidTestImplementation 'junit:junit:4.12'
+    androidTestImplementation 'androidx.test:runner:1.2.0'
+    androidTestImplementation "com.google.truth:truth:$googleTruthVersion"
+    androidTestImplementation 'org.mockito:mockito-core:2.25.0'
+    androidTestImplementation 'org.awaitility:awaitility:3.1.0'
+    androidTestImplementation 'io.grpc:grpc-testing:1.21.0'
+    androidTestImplementation 'com.linkedin.dexmaker:dexmaker:2.25.0'
+    androidTestImplementation 'com.linkedin.dexmaker:dexmaker-mockito:2.25.0'
+    androidTestImplementation 'joda-time:joda-time:2.9.2'
+
+    androidTestAnnotationProcessor 'com.google.dagger:dagger-compiler:2.22'
+}
diff --git a/firebase-inappmessaging/gradle.properties b/firebase-inappmessaging/gradle.properties
new file mode 100644
index 000000000..737638ce4
--- /dev/null
+++ b/firebase-inappmessaging/gradle.properties
@@ -0,0 +1,2 @@
+version=18.0.2
+latestReleasedVersion=18.0.1
diff --git a/test-apps/firestore-test-app/lint.xml b/firebase-inappmessaging/lint.xml
similarity index 54%
rename from test-apps/firestore-test-app/lint.xml
rename to firebase-inappmessaging/lint.xml
index 5aaf54d15..8c2383315 100644
--- a/test-apps/firestore-test-app/lint.xml
+++ b/firebase-inappmessaging/lint.xml
@@ -5,4 +5,12 @@
     <issue id="InvalidPackage">
         <ignore path="*/io.grpc/grpc-core/*"/>
     </issue>
+
+    <!--Safe to ignore since we trigger the getToken only to eagerly fetch the token and reduce practial latency -->
+    <issue id="MissingFirebaseInstanceTokenRefresh">
+        <ignore path="src/main/java/com/google/firebase/inappmessaging/internal/DataCollectionHelper.java"/>
+    </issue>
+
+    <!-- Disable the given check in this project -->
+    <issue id="GradleCompatible" severity="ignore" />
 </lint>
diff --git a/firebase-inappmessaging/mapping.txt b/firebase-inappmessaging/mapping.txt
new file mode 100644
index 000000000..e69de29bb
diff --git a/firebase-inappmessaging/preguard.txt b/firebase-inappmessaging/preguard.txt
new file mode 100644
index 000000000..f21284272
--- /dev/null
+++ b/firebase-inappmessaging/preguard.txt
@@ -0,0 +1,20 @@
+-repackageclasses 'com.google.firebase.inappmessaging.obfuscated'
+-dontwarn okio.**
+-dontwarn com.google.j2objc.annotations.**
+-dontwarn java.lang.invoke.LambdaMetafactory
+-keepparameternames
+-renamesourcefileattribute SourceFile
+-keepattributes Exceptions,InnerClasses,Signature,Deprecated,
+                SourceFile,LineNumberTable,*Annotation*,EnclosingMethod
+
+# Auto generated classes cannot be annotated and need to be explicitly kept
+-keep public class com.google.firebase.inappmessaging.model.InAppMessage** {
+	public protected *; 
+}
+
+# Keep rules do not seem to work with enums. Hence the explicit rule
+-keep public enum com.google.firebase.inappmessaging.** {*;}
+
+# Using names starting with "zz"
+-classobfuscationdictionary ../obfuscate_dict.txt
+-obfuscationdictionary ../obfuscate_dict.txt
diff --git a/firebase-inappmessaging/proguard.txt b/firebase-inappmessaging/proguard.txt
new file mode 100644
index 000000000..2abe7791d
--- /dev/null
+++ b/firebase-inappmessaging/proguard.txt
@@ -0,0 +1,20 @@
+# Needed for DNS resolution.  Present in OpenJDK, but not Android
+-dontwarn javax.naming.**
+-dontwarn com.squareup.okhttp.**
+
+# Don't warn about checkerframework
+#
+# Guava uses the checkerframework and the annotations
+# can safely be ignored at runtime.
+-dontwarn org.checkerframework.**
+
+# Guava warnings:
+-dontwarn java.lang.ClassValue
+-dontwarn com.google.j2objc.annotations.Weak
+-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
+-dontwarn javax.lang.model.element.Modifier
+
+# Okhttp warnings.
+-dontwarn okio.**
+-dontwarn com.google.j2objc.annotations.**
+-dontwarn afu.org.checkerframework.**
diff --git a/firebase-inappmessaging/src/androidTest/AndroidManifest.xml b/firebase-inappmessaging/src/androidTest/AndroidManifest.xml
new file mode 100644
index 000000000..b823c9c57
--- /dev/null
+++ b/firebase-inappmessaging/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.google.firebase.inappmessaging">
+
+  <uses-sdk
+      android:minSdkVersion="16"
+      android:targetSdkVersion="23"/>
+  <uses-permission android:name="android.permission.INTERNET"/>
+  <application>
+    <uses-library android:name="android.test.runner"/>
+    <service tools:node="replace" android:name="com.google.firebase.components.ComponentDiscoveryService">
+         <meta-data
+              android:name="com.google.firebase.components:com.google.firebase.iid.Registrar"
+              android:value="com.google.firebase.components.ComponentRegistrar" />
+    </service>
+  </application>
+
+  <instrumentation
+      android:name="androidx.test.runner.AndroidJUnitRunner"
+      android:targetPackage="com.google.firebase.inappmessaging"/>
+</manifest>
diff --git a/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingFlowableTest.java b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingFlowableTest.java
new file mode 100644
index 000000000..f9acaadcb
--- /dev/null
+++ b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingFlowableTest.java
@@ -0,0 +1,1360 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.firebase.inappmessaging.CommonTypesProto.Trigger.ON_FOREGROUND;
+import static com.google.firebase.inappmessaging.internal.injection.modules.ProtoStorageClientModule.CAMPAIGN_CACHE_FILE;
+import static com.google.firebase.inappmessaging.internal.injection.modules.ProtoStorageClientModule.IMPRESSIONS_STORE_FILE;
+import static com.google.firebase.inappmessaging.internal.injection.modules.ProtoStorageClientModule.RATE_LIMIT_STORE_FILE;
+import static com.google.firebase.inappmessaging.testutil.TestData.ANALYTICS_EVENT_NAME;
+import static com.google.firebase.inappmessaging.testutil.TestData.BANNER_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.CAMPAIGN_ID_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.CAMPAIGN_NAME_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.IS_NOT_TEST_MESSAGE;
+import static com.google.firebase.inappmessaging.testutil.TestData.MODAL_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.createBannerMessageCustomMetadata;
+import static com.google.firebase.inappmessaging.testutil.TestProtos.BANNER_MESSAGE_PROTO;
+import static com.google.firebase.inappmessaging.testutil.TestProtos.MODAL_MESSAGE_PROTO;
+import static io.reactivex.BackpressureStrategy.BUFFER;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.awaitility.Awaitility.await;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.app.Application;
+import android.content.Context;
+import android.os.Bundle;
+import android.os.Looper;
+import android.util.Log;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.google.android.gms.tasks.Task;
+import com.google.android.gms.tasks.Tasks;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.FirebaseOptions;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.events.Subscriber;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.inappmessaging.CommonTypesProto.ContextualTrigger;
+import com.google.firebase.inappmessaging.CommonTypesProto.Priority;
+import com.google.firebase.inappmessaging.CommonTypesProto.TriggeringCondition;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks.InAppMessagingDismissType;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks.InAppMessagingErrorReason;
+import com.google.firebase.inappmessaging.internal.DisplayCallbacksFactory;
+import com.google.firebase.inappmessaging.internal.MetricsLoggerClient;
+import com.google.firebase.inappmessaging.internal.ProgramaticContextualTriggers;
+import com.google.firebase.inappmessaging.internal.TestDeviceHelper;
+import com.google.firebase.inappmessaging.internal.injection.modules.AppMeasurementModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.ApplicationModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.GrpcClientModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.ProgrammaticContextualTriggerFlowableModule;
+import com.google.firebase.inappmessaging.model.BannerMessage;
+import com.google.firebase.inappmessaging.model.CampaignMetadata;
+import com.google.firebase.inappmessaging.model.InAppMessage;
+import com.google.internal.firebase.inappmessaging.v1.CampaignProto.ThickContent;
+import com.google.internal.firebase.inappmessaging.v1.CampaignProto.VanillaCampaignPayload;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.CampaignImpression;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsRequest;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsResponse;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.InAppMessagingSdkServingGrpc.InAppMessagingSdkServingImplBase;
+import com.google.protobuf.InvalidProtocolBufferException;
+import io.grpc.stub.StreamObserver;
+import io.grpc.testing.GrpcServerRule;
+import io.reactivex.Flowable;
+import io.reactivex.FlowableEmitter;
+import io.reactivex.FlowableOnSubscribe;
+import io.reactivex.subscribers.TestSubscriber;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+
+// NOTE: Classes cannot have the same name as those in the
+// integration-tests directory since this is an unconventional package structure.
+@RunWith(AndroidJUnit4.class)
+public class FirebaseInAppMessagingFlowableTest {
+
+  public static final String PROJECT_NUMBER = "gcm-sender-id";
+  public static final String APP_ID = "app-id";
+  private static final long PAST = 1000000;
+  private static final long NOW = PAST + 100000;
+  private static final long FUTURE = NOW + 1000000;
+  private static final FirebaseApp app;
+  private static final FirebaseOptions options =
+      new FirebaseOptions.Builder()
+          .setGcmSenderId(PROJECT_NUMBER)
+          .setApplicationId(APP_ID)
+          .setApiKey("apiKey")
+          .setProjectId("fiam-integration-test")
+          .build();
+  private static final String ANALYTICS_EVENT = "event1";
+  private static final TriggeringCondition.Builder ON_FOREGROUND_TRIGGER =
+      TriggeringCondition.newBuilder().setFiamTrigger(ON_FOREGROUND);
+  private static final TriggeringCondition.Builder ON_ANALYTICS_EVENT =
+      TriggeringCondition.newBuilder()
+          .setContextualTrigger(ContextualTrigger.newBuilder().setName(ANALYTICS_EVENT));
+  private static final Priority priorityTwo = Priority.newBuilder().setValue(2).build();
+  private static final VanillaCampaignPayload.Builder vanillaCampaign =
+      VanillaCampaignPayload.newBuilder()
+          .setCampaignId(CAMPAIGN_ID_STRING)
+          .setCampaignName(CAMPAIGN_NAME_STRING)
+          .setCampaignStartTimeMillis(PAST)
+          .setCampaignEndTimeMillis(FUTURE);
+  private static final ThickContent thickContent =
+      ThickContent.newBuilder()
+          .setContent(MODAL_MESSAGE_PROTO)
+          .setIsTestCampaign(IS_NOT_TEST_MESSAGE)
+          .setPriority(priorityTwo)
+          .addTriggeringConditions(ON_FOREGROUND_TRIGGER)
+          .addTriggeringConditions(ON_ANALYTICS_EVENT)
+          .setVanillaPayload(vanillaCampaign)
+          .build();
+  private static final FetchEligibleCampaignsResponse.Builder eligibleCampaignsBuilder =
+      FetchEligibleCampaignsResponse.newBuilder()
+          .setExpirationEpochTimestampMillis(FUTURE)
+          .addMessages(thickContent);
+  private static final FetchEligibleCampaignsResponse eligibleCampaigns =
+      eligibleCampaignsBuilder.build();
+  private static final RuntimeException t = new RuntimeException("boom!");
+  private static final TestAnalyticsConnector analyticsConnector = new TestAnalyticsConnector();
+
+  static {
+    FirebaseApp.initializeApp(InstrumentationRegistry.getContext(), options);
+    app = FirebaseApp.getInstance();
+  }
+
+  @Rule public final GrpcServerRule grpcServerRule = new GrpcServerRule();
+  @Captor ArgumentCaptor<byte[]> byteArrayCaptor;
+
+  @Mock
+  private MetricsLoggerClient.EngagementMetricsLoggerInterface engagementMetricsLoggerInterface;
+
+  @Mock private FirebaseInstanceId instanceId;
+  @Mock private TestDeviceHelper testDeviceHelper;
+  @Mock private Subscriber firebaseEventSubscriber;
+  private TestSubscriber<InAppMessage> subscriber;
+  private FirebaseInAppMessaging instance;
+  private TestForegroundNotifier foregroundNotifier;
+  private Application application;
+  private DisplayCallbacksFactory displayCallbacksFactory;
+  private ProgramaticContextualTriggers programaticContextualTriggers;
+  // CampaignId to display callbacks
+  private static HashMap<String, FirebaseInAppMessagingDisplayCallbacks> callbacksHashMap;
+  private static DaggerTestUniversalComponent.Builder universalComponentBuilder;
+  private static DaggerTestAppComponent.Builder appComponentBuilder;
+
+  private static void clearProtoDiskCache(Context context) {
+    context.deleteFile(CAMPAIGN_CACHE_FILE);
+    context.deleteFile(IMPRESSIONS_STORE_FILE);
+    context.deleteFile(RATE_LIMIT_STORE_FILE);
+  }
+
+  private static List<Object> getPlainValues(TestSubscriber<InAppMessage> subscriber) {
+    return subscriber.getEvents().get(0);
+  }
+
+  private static TestSubscriber<InAppMessage> listenerToFlowable(FirebaseInAppMessaging instance) {
+    Flowable<InAppMessage> listenerFlowable =
+        Flowable.create(
+            new FlowableOnSubscribe<InAppMessage>() {
+              @Override
+              public void subscribe(FlowableEmitter<InAppMessage> emitter) throws Exception {
+                instance.setMessageDisplayComponent(
+                    new FirebaseInAppMessagingDisplay() {
+                      @Override
+                      public void displayMessage(
+                          InAppMessage inAppMessage,
+                          FirebaseInAppMessagingDisplayCallbacks callbacks) {
+                        emitter.onNext(inAppMessage);
+                        Log.i("FIAM", "Putting callback for IAM " + inAppMessage.getCampaignName());
+                        callbacksHashMap.put(inAppMessage.getCampaignId(), callbacks);
+                      }
+                    });
+              }
+            },
+            BUFFER);
+    return listenerFlowable.test();
+  }
+
+  @Before
+  public void setUp() {
+    initMocks(this);
+    callbacksHashMap = new HashMap<>();
+    clearProtoDiskCache(InstrumentationRegistry.getTargetContext());
+    application =
+        spy((Application) InstrumentationRegistry.getTargetContext().getApplicationContext());
+    String id = FirebaseInstanceId.getInstance().getId();
+    when(instanceId.getId()).thenReturn(id);
+    when(instanceId.getToken()).thenReturn("token"); // getToken() waits on a response from IID.
+    when(testDeviceHelper.isAppInstallFresh()).thenReturn(false);
+    when(testDeviceHelper.isDeviceInTestMode()).thenReturn(false);
+
+    if (Looper.myLooper() == null) {
+      Looper.prepare();
+    }
+    foregroundNotifier = new TestForegroundNotifier();
+
+    universalComponentBuilder =
+        DaggerTestUniversalComponent.builder()
+            .testGrpcModule(new TestGrpcModule(grpcServerRule.getChannel()))
+            .testForegroundNotifierModule(new TestForegroundNotifierModule(foregroundNotifier))
+            .applicationModule(new ApplicationModule(application))
+            .appMeasurementModule(
+                new AppMeasurementModule(analyticsConnector, firebaseEventSubscriber))
+            .testSystemClockModule(new TestSystemClockModule(NOW))
+            .programmaticContextualTriggerFlowableModule(
+                new ProgrammaticContextualTriggerFlowableModule(
+                    new ProgramaticContextualTriggers()));
+
+    TestUniversalComponent universalComponent = universalComponentBuilder.build();
+
+    appComponentBuilder =
+        DaggerTestAppComponent.builder()
+            .universalComponent(universalComponent)
+            .testEngagementMetricsLoggerClientModule(
+                new TestEngagementMetricsLoggerClientModule(app, engagementMetricsLoggerInterface))
+            .grpcClientModule(new GrpcClientModule(app))
+            .testApiClientModule(
+                new TestApiClientModule(
+                    app, instanceId, testDeviceHelper, universalComponent.clock()));
+    TestAppComponent appComponent = appComponentBuilder.build();
+
+    instance = appComponent.providesFirebaseInAppMessaging();
+    displayCallbacksFactory = appComponent.displayCallbacksFactory();
+    programaticContextualTriggers = universalComponent.programmaticContextualTriggers();
+    grpcServerRule.getServiceRegistry().addService(new GoodFiamService(eligibleCampaigns));
+
+    subscriber = listenerToFlowable(instance);
+  }
+
+  @Test
+  public void onAppOpen_notifiesSubscriber() {
+    simulateAppResume();
+    waitUntilNotified(subscriber);
+
+    assertSingleSuccessNotification(subscriber);
+  }
+
+  @Test
+  public void onAnalyticsNotification_notifiesSubscriber() {
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    waitUntilNotified(subscriber);
+
+    assertSingleSuccessNotification(subscriber);
+  }
+
+  @Test
+  public void onAppOpen_whenAnalyticsAbsent_notifiesSubscriber() {
+    TestUniversalComponent analyticsLessUniversalComponent =
+        universalComponentBuilder
+            .appMeasurementModule(new AppMeasurementModule(null, firebaseEventSubscriber))
+            .build();
+    TestAppComponent appComponent =
+        appComponentBuilder.universalComponent(analyticsLessUniversalComponent).build();
+    FirebaseInAppMessaging instance = appComponent.providesFirebaseInAppMessaging();
+    TestSubscriber<InAppMessage> subscriber = listenerToFlowable(instance);
+
+    simulateAppResume();
+    waitUntilNotified(subscriber);
+
+    assertSingleSuccessNotification(subscriber);
+  }
+
+  @Test
+  public void onProgrammaticTrigger_notifiesSubscriber() {
+    programaticContextualTriggers.triggerEvent(ANALYTICS_EVENT_NAME);
+    waitUntilNotified(subscriber);
+    assertSingleSuccessNotification(subscriber);
+  }
+
+  @Test
+  public void cachesResponseOnDisk() {
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    waitUntilNotified(subscriber);
+
+    assertThat(fileExists(CAMPAIGN_CACHE_FILE)).isTrue();
+  }
+
+  @Test
+  public void onCacheHit_notifiesCachedValue() {
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    waitUntilNotified(subscriber); // this value will be cached
+    grpcServerRule.getServiceRegistry().addService(new FaultyService());
+
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    await().timeout(2, SECONDS).until(() -> subscriber.valueCount() > 1);
+
+    List<InAppMessage> expected = new ArrayList<>();
+    expected.add(MODAL_MESSAGE_MODEL);
+    expected.add(MODAL_MESSAGE_MODEL);
+    assertSubscriberListIs(expected, subscriber);
+  }
+
+  @Test
+  public void onCorruptProtoCache_fetchesCampaignsFromService() throws IOException {
+    changeFileContents(CAMPAIGN_CACHE_FILE);
+
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    await().timeout(2, SECONDS).until(() -> subscriber.valueCount() > 0);
+
+    assertSingleSuccessNotification(subscriber);
+  }
+
+  @Test
+  public void afterCacheLoad_returnsValueFromMemory() throws IOException {
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    waitUntilNotified(subscriber); // this value will be cached
+    clearProtoDiskCache(InstrumentationRegistry.getContext());
+
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    await().timeout(2, SECONDS).until(() -> subscriber.valueCount() > 1);
+
+    List<Object> triggeredMessages = getPlainValues(subscriber);
+    assertThat(triggeredMessages.size()).isEqualTo(2);
+    for (Object o : triggeredMessages) {
+      assertThat(o).isEqualTo(MODAL_MESSAGE_MODEL);
+    }
+  }
+
+  @Test
+  public void whenTTLNotSet_honorsFileLastUpdated() throws IOException {
+    FetchEligibleCampaignsResponse noExpiry =
+        FetchEligibleCampaignsResponse.newBuilder(eligibleCampaigns)
+            .clearExpirationEpochTimestampMillis()
+            .build();
+    grpcServerRule.getServiceRegistry().addService(new GoodFiamService(noExpiry));
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    waitUntilNotified(subscriber); // this value will be cached
+    grpcServerRule.getServiceRegistry().addService(new FaultyService());
+
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    await().timeout(2, SECONDS).until(() -> subscriber.valueCount() > 1);
+
+    List<Object> triggeredMessages = getPlainValues(subscriber);
+    assertThat(triggeredMessages.size()).isEqualTo(2);
+    for (Object o : triggeredMessages) {
+      assertThat(o).isEqualTo(MODAL_MESSAGE_MODEL);
+    }
+  }
+
+  @Test
+  public void onCacheDiskReadFailure_notifiesValueFromService()
+      throws InterruptedException, FileNotFoundException {
+    CountDownLatch readExceptionLatch = new CountDownLatch(1);
+    doAnswer(
+            i -> {
+              readExceptionLatch.countDown();
+              throw new NullPointerException();
+            })
+        .when(application)
+        .openFileInput(CAMPAIGN_CACHE_FILE);
+    subscriber = listenerToFlowable(instance);
+
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    readExceptionLatch.await();
+    waitUntilNotified(subscriber); // this value will be cached
+
+    assertSingleSuccessNotification(subscriber);
+  }
+
+  @Test
+  public void onCacheAndApiFailure_absorbsErrors()
+      throws InterruptedException, FileNotFoundException {
+    FaultyService faultyService = new FaultyService();
+    grpcServerRule.getServiceRegistry().addService(faultyService);
+    CountDownLatch readExceptionLatch = new CountDownLatch(1);
+    doAnswer(
+            i -> {
+              readExceptionLatch.countDown();
+              throw new NullPointerException();
+            })
+        .when(application)
+        .openFileInput(CAMPAIGN_CACHE_FILE);
+    subscriber = listenerToFlowable(instance);
+
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    readExceptionLatch.await();
+    faultyService.waitUntilFailureExercised();
+
+    assertNoNotification(subscriber);
+  }
+
+  @Test
+  public void onCacheWriteFailure_notifiesValueFetchedFromService()
+      throws FileNotFoundException, InterruptedException {
+    CountDownLatch writeExceptionLatch = new CountDownLatch(1);
+    doAnswer(
+            i -> {
+              writeExceptionLatch.countDown();
+              throw new NullPointerException();
+            })
+        .when(application)
+        .openFileInput(CAMPAIGN_CACHE_FILE);
+    subscriber = listenerToFlowable(instance);
+
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    writeExceptionLatch.await();
+    waitUntilNotified(subscriber);
+
+    assertSingleSuccessNotification(subscriber);
+  }
+
+  @Test
+  public void onTransientServiceFailure_continuesNotifying() throws InterruptedException {
+    FaultyService faultyService = new FaultyService();
+    grpcServerRule.getServiceRegistry().addService(faultyService);
+
+    // Since the analytics events are received on its own thread (managed by it), and the request is
+    // dispatched on io threads (managed by us), we need to ensure that the faulty service is
+    // exercised by our client before "fixing" it. Without the latch, the service might be fixed
+    // even before the first request is fired to it
+    TestSubscriber<InAppMessage> subscriber = listenerToFlowable(instance);
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    faultyService.waitUntilFailureExercised();
+    grpcServerRule
+        .getServiceRegistry()
+        .addService(new GoodFiamService(eligibleCampaigns)); // service recovers
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    waitUntilNotified(subscriber);
+
+    assertSingleSuccessNotification(subscriber);
+  }
+
+  @Test
+  public void onUnrelatedEvents_doesNotNotify() {
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    analyticsConnector.invokeListenerOnEvent("some_other_event");
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    await().timeout(2, SECONDS).until(() -> subscriber.valueCount() > 0);
+
+    List<Object> triggeredMessages = getPlainValues(subscriber);
+    assertThat(triggeredMessages.size()).isEqualTo(2);
+    for (Object o : triggeredMessages) {
+      assertThat(o).isEqualTo(MODAL_MESSAGE_MODEL);
+    }
+  }
+
+  @Test
+  public void onExpiredCampaign_doesNotNotify() {
+    VanillaCampaignPayload.Builder expiredCampaign =
+        VanillaCampaignPayload.newBuilder()
+            .setCampaignName(CAMPAIGN_NAME_STRING)
+            .setCampaignStartTimeMillis(PAST)
+            .setCampaignEndTimeMillis(PAST);
+    TriggeringCondition.Builder analyticsEvent =
+        TriggeringCondition.newBuilder()
+            .setContextualTrigger(ContextualTrigger.newBuilder().setName("ignored"));
+    ThickContent t =
+        ThickContent.newBuilder(thickContent)
+            .clearContent()
+            .clearTriggeringConditions()
+            .addTriggeringConditions(analyticsEvent)
+            .setVanillaPayload(expiredCampaign)
+            .build();
+    FetchEligibleCampaignsResponse r =
+        FetchEligibleCampaignsResponse.newBuilder(eligibleCampaigns).addMessages(t).build();
+    GoodFiamService impl = new GoodFiamService(r);
+    grpcServerRule.getServiceRegistry().addService(impl);
+
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    analyticsConnector.invokeListenerOnEvent("ignored");
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    await().timeout(2, SECONDS).until(() -> subscriber.valueCount() == 2);
+
+    List<InAppMessage> expected = new ArrayList<>();
+    expected.add(MODAL_MESSAGE_MODEL);
+    expected.add(MODAL_MESSAGE_MODEL);
+    assertSubscriberListIs(expected, subscriber);
+  }
+
+  @Test
+  public void onMultipleMatchingCampaigns_notifiesHighestPriorityCampaign() {
+    ThickContent highPriorityContent =
+        ThickContent.newBuilder(thickContent)
+            .setIsTestCampaign(IS_NOT_TEST_MESSAGE)
+            .setContent(BANNER_MESSAGE_PROTO)
+            .setPriority(Priority.newBuilder().setValue(1))
+            .build();
+    FetchEligibleCampaignsResponse response =
+        FetchEligibleCampaignsResponse.newBuilder(eligibleCampaigns)
+            .addMessages(highPriorityContent)
+            .build();
+    GoodFiamService impl = new GoodFiamService(response);
+    grpcServerRule.getServiceRegistry().addService(impl);
+
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    await().timeout(2, SECONDS).until(() -> subscriber.valueCount() == 1);
+    assertSubsriberExactly(BANNER_MESSAGE_MODEL, subscriber);
+  }
+
+  @Test
+  public void onEarlyUnSubscribe_absorbsError() throws InterruptedException {
+    // We assert that unsubscribing early does not result in UndeliveredException
+    FaultyService slowFaultyService = new SlowFaultyService();
+    grpcServerRule.getServiceRegistry().addService(slowFaultyService);
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    slowFaultyService.waitUntilFailureExercised();
+
+    instance.clearDisplayListener();
+    grpcServerRule
+        .getServiceRegistry()
+        .addService(new GoodFiamService(eligibleCampaigns)); // service recovers
+    subscriber = listenerToFlowable(instance);
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    waitUntilNotified(subscriber);
+
+    assertSingleSuccessNotification(subscriber);
+  }
+
+  @Test
+  public void onUnsupportedCampaign_doesNotNotify() {
+    VanillaCampaignPayload.Builder campaign =
+        VanillaCampaignPayload.newBuilder()
+            .setCampaignName(CAMPAIGN_NAME_STRING)
+            .setCampaignStartTimeMillis(NOW)
+            .setCampaignEndTimeMillis(FUTURE);
+    MessagesProto.Content unsupportedContent =
+        MessagesProto.Content.newBuilder().clearMessageDetails().build();
+    String eventName = "unsupported_campaign_event";
+    TriggeringCondition.Builder analyticsEvent =
+        TriggeringCondition.newBuilder()
+            .setContextualTrigger(ContextualTrigger.newBuilder().setName(eventName));
+    ThickContent t =
+        ThickContent.newBuilder(thickContent)
+            .clearContent()
+            .clearTriggeringConditions()
+            .addTriggeringConditions(analyticsEvent)
+            .setVanillaPayload(campaign)
+            .setContent(unsupportedContent)
+            .build();
+    FetchEligibleCampaignsResponse r =
+        FetchEligibleCampaignsResponse.newBuilder(eligibleCampaigns).addMessages(t).build();
+    GoodFiamService impl = new GoodFiamService(r);
+    grpcServerRule.getServiceRegistry().addService(impl);
+
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    analyticsConnector.invokeListenerOnEvent(eventName);
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    await().timeout(2, SECONDS).until(() -> subscriber.valueCount() == 2);
+
+    // assert that the unsupported campaign is not in the list, but we get 2x MODAL
+
+  }
+
+  @Test
+  public void whenImpressed_filtersCampaign()
+      throws ExecutionException, InterruptedException, TimeoutException {
+    CampaignMetadata otherMetadata =
+        new CampaignMetadata("otherCampaignId", "otherName", IS_NOT_TEST_MESSAGE);
+    BannerMessage otherMessage = createBannerMessageCustomMetadata(otherMetadata);
+    VanillaCampaignPayload otherCampaign =
+        VanillaCampaignPayload.newBuilder(vanillaCampaign.build())
+            .setCampaignId(otherMetadata.getCampaignId())
+            .setCampaignName(otherMetadata.getCampaignName())
+            .build();
+    ThickContent otherContent =
+        ThickContent.newBuilder(thickContent)
+            .setContent(BANNER_MESSAGE_PROTO)
+            .setIsTestCampaign(IS_NOT_TEST_MESSAGE)
+            .clearVanillaPayload()
+            .clearTriggeringConditions()
+            .addTriggeringConditions(
+                TriggeringCondition.newBuilder()
+                    .setContextualTrigger(ContextualTrigger.newBuilder().setName("event2")))
+            .setVanillaPayload(otherCampaign)
+            .build();
+    FetchEligibleCampaignsResponse response =
+        FetchEligibleCampaignsResponse.newBuilder(eligibleCampaigns)
+            .addMessages(otherContent)
+            .build();
+    GoodFiamService impl = new GoodFiamService(response);
+    grpcServerRule.getServiceRegistry().addService(impl);
+
+    Task<Void> logImpressionTask =
+        displayCallbacksFactory
+            .generateDisplayCallback(MODAL_MESSAGE_MODEL, ANALYTICS_EVENT_NAME)
+            .impressionDetected();
+    Tasks.await(logImpressionTask, 1000, TimeUnit.MILLISECONDS);
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    analyticsConnector.invokeListenerOnEvent("event2");
+    waitUntilNotified(subscriber);
+
+    assertSubsriberExactly(otherMessage, subscriber);
+  }
+
+  // There is not a purely functional way to determine if our clients inject the impressed
+  // campaigns upstream since we filter impressions from the response on the client as well.
+  // We work around this by failing hard on the fake service if we do not find impressions
+  @Test
+  public void whenImpressed_filtersCampaignToRequestUpstream()
+      throws ExecutionException, InterruptedException, TimeoutException {
+    VanillaCampaignPayload otherCampaign =
+        VanillaCampaignPayload.newBuilder(vanillaCampaign.build())
+            .setCampaignId("otherCampaignId")
+            .setCampaignName(CAMPAIGN_NAME_STRING)
+            .build();
+    ThickContent otherContent =
+        ThickContent.newBuilder(thickContent)
+            .setContent(BANNER_MESSAGE_PROTO)
+            .clearVanillaPayload()
+            .setIsTestCampaign(IS_NOT_TEST_MESSAGE)
+            .clearTriggeringConditions()
+            .addTriggeringConditions(
+                TriggeringCondition.newBuilder()
+                    .setContextualTrigger(ContextualTrigger.newBuilder().setName("event2")))
+            .setVanillaPayload(otherCampaign)
+            .build();
+    FetchEligibleCampaignsResponse response =
+        FetchEligibleCampaignsResponse.newBuilder(eligibleCampaigns)
+            .addMessages(otherContent)
+            .build();
+
+    InAppMessagingSdkServingImplBase impl =
+        new InAppMessagingSdkServingImplBase() {
+          @Override
+          public void fetchEligibleCampaigns(
+              FetchEligibleCampaignsRequest request,
+              StreamObserver<FetchEligibleCampaignsResponse> responseObserver) {
+            // Fail hard if impression not present
+            CampaignImpression firstImpression = request.getAlreadySeenCampaignsList().get(0);
+            assertThat(firstImpression).isNotNull();
+            assertThat(firstImpression.getCampaignId())
+                .isEqualTo(MODAL_MESSAGE_MODEL.getCampaignMetadata().getCampaignId());
+
+            responseObserver.onNext(response);
+            responseObserver.onCompleted();
+          }
+        };
+    grpcServerRule.getServiceRegistry().addService(impl);
+
+    Task<Void> logImpressionTask =
+        displayCallbacksFactory
+            .generateDisplayCallback(MODAL_MESSAGE_MODEL, ANALYTICS_EVENT_NAME)
+            .impressionDetected();
+    Tasks.await(logImpressionTask, 1000, TimeUnit.MILLISECONDS);
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    analyticsConnector.invokeListenerOnEvent("event2");
+
+    waitUntilNotified(subscriber);
+  }
+
+  @Test
+  public void whenImpressed_writesLimitsToDisk() {
+    Task<Void> logImpressionTask =
+        displayCallbacksFactory
+            .generateDisplayCallback(MODAL_MESSAGE_MODEL, ANALYTICS_EVENT_NAME)
+            .impressionDetected();
+    await().timeout(2, SECONDS).until(logImpressionTask::isComplete);
+
+    assertThat(fileExists(IMPRESSIONS_STORE_FILE)).isTrue();
+  }
+
+  @Test
+  public void logImpression_writesExpectedLogToEngagementMetrics()
+      throws InvalidProtocolBufferException {
+    CampaignAnalytics expectedCampaignAnalytics =
+        CampaignAnalytics.newBuilder()
+            .setCampaignId(CAMPAIGN_ID_STRING)
+            .setFiamSdkVersion(BuildConfig.VERSION_NAME)
+            .setProjectNumber(PROJECT_NUMBER)
+            .setClientTimestampMillis(NOW)
+            .setClientApp(
+                ClientAppInfo.newBuilder()
+                    .setFirebaseInstanceId(FirebaseInstanceId.getInstance().getId())
+                    .setGoogleAppId(APP_ID))
+            .setEventType(EventType.IMPRESSION_EVENT_TYPE)
+            .build();
+    simulateAppResume();
+    waitUntilNotified(subscriber);
+    assertSingleSuccessNotification(subscriber);
+
+    Task<Void> logAction =
+        callbacksHashMap
+            .get(MODAL_MESSAGE_MODEL.getCampaignMetadata().getCampaignId())
+            .impressionDetected();
+    await().timeout(2, SECONDS).until(logAction::isComplete);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+    CampaignAnalytics campaignAnalytics = CampaignAnalytics.parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics).isEqualTo(expectedCampaignAnalytics);
+  }
+
+  @Test
+  public void logAction_writesExpectedLogToEngagementMetrics()
+      throws InvalidProtocolBufferException {
+    CampaignAnalytics expectedCampaignAnalytics =
+        CampaignAnalytics.newBuilder()
+            .setCampaignId(CAMPAIGN_ID_STRING)
+            .setFiamSdkVersion(BuildConfig.VERSION_NAME)
+            .setProjectNumber(PROJECT_NUMBER)
+            .setClientTimestampMillis(NOW)
+            .setClientApp(
+                ClientAppInfo.newBuilder()
+                    .setFirebaseInstanceId(FirebaseInstanceId.getInstance().getId())
+                    .setGoogleAppId(APP_ID))
+            .setEventType(EventType.IMPRESSION_EVENT_TYPE)
+            .build();
+    simulateAppResume();
+    waitUntilNotified(subscriber);
+    assertSingleSuccessNotification(subscriber);
+
+    Task<Void> logAction =
+        callbacksHashMap
+            .get(MODAL_MESSAGE_MODEL.getCampaignMetadata().getCampaignId())
+            .impressionDetected();
+    await().timeout(2, SECONDS).until(logAction::isComplete);
+
+    // log impression will log 1 event
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+    CampaignAnalytics campaignAnalytics = CampaignAnalytics.parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics).isEqualTo(expectedCampaignAnalytics);
+  }
+
+  @Test
+  public void logRenderError_writesExpectedLogToEngagementMetrics()
+      throws InvalidProtocolBufferException {
+    CampaignAnalytics expectedCampaignAnalytics =
+        CampaignAnalytics.newBuilder()
+            .setCampaignId(CAMPAIGN_ID_STRING)
+            .setFiamSdkVersion(BuildConfig.VERSION_NAME)
+            .setProjectNumber(PROJECT_NUMBER)
+            .setClientTimestampMillis(NOW)
+            .setClientApp(
+                ClientAppInfo.newBuilder()
+                    .setFirebaseInstanceId(FirebaseInstanceId.getInstance().getId())
+                    .setGoogleAppId(APP_ID))
+            .setRenderErrorReason(RenderErrorReason.IMAGE_DISPLAY_ERROR)
+            .build();
+    simulateAppResume();
+    waitUntilNotified(subscriber);
+    assertSingleSuccessNotification(subscriber);
+
+    Task<Void> logAction =
+        callbacksHashMap
+            .get(MODAL_MESSAGE_MODEL.getCampaignMetadata().getCampaignId())
+            .displayErrorEncountered(InAppMessagingErrorReason.IMAGE_DISPLAY_ERROR);
+    await().timeout(2, SECONDS).until(logAction::isComplete);
+
+    // this should only log the render error - not an impression
+    verify(engagementMetricsLoggerInterface, times(1)).logEvent(byteArrayCaptor.capture());
+    CampaignAnalytics campaignAnalytics = CampaignAnalytics.parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics).isEqualTo(expectedCampaignAnalytics);
+  }
+
+  @Test
+  public void logDismiss_writesExpectedLogToEngagementMetrics()
+      throws InvalidProtocolBufferException {
+    CampaignAnalytics expectedCampaignAnalytics =
+        CampaignAnalytics.newBuilder()
+            .setCampaignId(CAMPAIGN_ID_STRING)
+            .setFiamSdkVersion(BuildConfig.VERSION_NAME)
+            .setProjectNumber(PROJECT_NUMBER)
+            .setClientTimestampMillis(NOW)
+            .setClientApp(
+                ClientAppInfo.newBuilder()
+                    .setFirebaseInstanceId(FirebaseInstanceId.getInstance().getId())
+                    .setGoogleAppId(APP_ID))
+            .setDismissType(DismissType.AUTO)
+            .build();
+    simulateAppResume();
+    waitUntilNotified(subscriber);
+    assertSingleSuccessNotification(subscriber);
+
+    Task<Void> logImpression =
+        callbacksHashMap
+            .get(MODAL_MESSAGE_MODEL.getCampaignMetadata().getCampaignId())
+            .impressionDetected();
+    await().timeout(2, SECONDS).until(logImpression::isComplete);
+
+    Task<Void> logAction =
+        callbacksHashMap
+            .get(MODAL_MESSAGE_MODEL.getCampaignMetadata().getCampaignId())
+            .messageDismissed(InAppMessagingDismissType.AUTO);
+    await().timeout(2, SECONDS).until(logAction::isComplete);
+
+    // We verify this was called
+    verify(engagementMetricsLoggerInterface, times(2)).logEvent(byteArrayCaptor.capture());
+    CampaignAnalytics campaignAnalytics = CampaignAnalytics.parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics).isEqualTo(expectedCampaignAnalytics);
+  }
+
+  @Test
+  public void logImpression_logsToEngagementMetrics() {
+    Task<Void> logImpressionTask =
+        displayCallbacksFactory
+            .generateDisplayCallback(MODAL_MESSAGE_MODEL, ANALYTICS_EVENT_NAME)
+            .impressionDetected();
+    await().timeout(2, SECONDS).until(logImpressionTask::isComplete);
+
+    assertThat(fileExists(IMPRESSIONS_STORE_FILE)).isTrue();
+  }
+
+  @Test
+  public void whenlogImpressionFails_doesNotFilterCampaign()
+      throws ExecutionException, InterruptedException, TimeoutException, FileNotFoundException {
+    doThrow(new NullPointerException("e1")).when(application).openFileInput(IMPRESSIONS_STORE_FILE);
+
+    Task<Void> logImpressionTask =
+        displayCallbacksFactory
+            .generateDisplayCallback(MODAL_MESSAGE_MODEL, ANALYTICS_EVENT_NAME)
+            .impressionDetected();
+    await().timeout(2, SECONDS).until(logImpressionTask::isComplete);
+    assertThat(logImpressionTask.getException()).hasMessageThat().contains("e1");
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    waitUntilNotified(subscriber);
+
+    assertSingleSuccessNotification(subscriber);
+  }
+
+  @Test
+  public void logImpression_whenlogEventLimitIncrementFails_doesNotRateLimit()
+      throws ExecutionException, InterruptedException, TimeoutException, FileNotFoundException {
+    CampaignMetadata otherMetadata =
+        new CampaignMetadata("otherCampaignId", "otherCampaignName", IS_NOT_TEST_MESSAGE);
+    VanillaCampaignPayload.Builder campaign =
+        VanillaCampaignPayload.newBuilder()
+            .setCampaignId(otherMetadata.getCampaignId())
+            .setCampaignName(otherMetadata.getCampaignName())
+            .setCampaignStartTimeMillis(PAST)
+            .setCampaignEndTimeMillis(FUTURE);
+    BannerMessage message = createBannerMessageCustomMetadata(otherMetadata);
+    ThickContent highPriorityAppOpenEvent =
+        ThickContent.newBuilder()
+            .setContent(BANNER_MESSAGE_PROTO)
+            .setIsTestCampaign(IS_NOT_TEST_MESSAGE)
+            .addTriggeringConditions(ON_FOREGROUND_TRIGGER)
+            .setPriority(Priority.newBuilder().setValue(1))
+            .setVanillaPayload(campaign)
+            .build();
+    FetchEligibleCampaignsResponse response =
+        FetchEligibleCampaignsResponse.newBuilder(eligibleCampaigns)
+            .addMessages(highPriorityAppOpenEvent)
+            .build();
+    GoodFiamService impl = new GoodFiamService(response);
+    grpcServerRule.getServiceRegistry().addService(impl);
+    doThrow(new NullPointerException("e1")).when(application).openFileInput(RATE_LIMIT_STORE_FILE);
+
+    // We have 2 campaigns configured for app foreground.
+    // We log impression for one of them during which limiter fails
+    // We simulate foreground to determine that the other gets impressed.
+    simulateAppResume();
+    await().timeout(2, SECONDS).until(() -> subscriber.valueCount() > 0);
+    assertSubsriberExactly(message, subscriber);
+
+    Task<Void> logImpressionTask =
+        callbacksHashMap
+            .get(message.getCampaignMetadata().getCampaignId())
+            .impressionDetected(); // limiter fails
+    await().timeout(2, SECONDS).until(logImpressionTask::isComplete);
+    simulateAppResume();
+    await().timeout(2, SECONDS).until(() -> subscriber.valueCount() > 1);
+
+    // App open events are ignored and analytics events are honored
+    List<InAppMessage> expected = new ArrayList<>();
+    expected.add(message);
+    expected.add(MODAL_MESSAGE_MODEL);
+    assertSubscriberListIs(expected, subscriber);
+  }
+
+  @Test
+  public void logImpression_whenlogEventLimitIncrementSuccess_cachesLimitsInMemory()
+      throws ExecutionException, InterruptedException, TimeoutException, FileNotFoundException {
+    CampaignMetadata otherMetadata =
+        new CampaignMetadata("otherCampaignId", "otherCampaignName", IS_NOT_TEST_MESSAGE);
+    VanillaCampaignPayload.Builder campaign =
+        VanillaCampaignPayload.newBuilder()
+            .setCampaignId(otherMetadata.getCampaignId())
+            .setCampaignName(otherMetadata.getCampaignName())
+            .setCampaignStartTimeMillis(PAST)
+            .setCampaignEndTimeMillis(FUTURE);
+    BannerMessage message = createBannerMessageCustomMetadata(otherMetadata);
+    ThickContent highPriorityAppOpenEvent =
+        ThickContent.newBuilder()
+            .setContent(BANNER_MESSAGE_PROTO)
+            .setIsTestCampaign(IS_NOT_TEST_MESSAGE)
+            .addTriggeringConditions(ON_FOREGROUND_TRIGGER)
+            .setPriority(Priority.newBuilder().setValue(1))
+            .setVanillaPayload(campaign)
+            .build();
+    FetchEligibleCampaignsResponse response =
+        FetchEligibleCampaignsResponse.newBuilder(eligibleCampaigns)
+            .addMessages(highPriorityAppOpenEvent)
+            .build();
+    GoodFiamService impl = new GoodFiamService(response);
+    grpcServerRule.getServiceRegistry().addService(impl);
+
+    simulateAppResume();
+    await().timeout(2, SECONDS).until(() -> subscriber.valueCount() > 0);
+    assertSubsriberExactly(message, subscriber);
+    Task<Void> logImpressionTask =
+        callbacksHashMap.get(message.getCampaignMetadata().getCampaignId()).impressionDetected();
+    await().timeout(2, SECONDS).until(logImpressionTask::isComplete);
+    doThrow(new NullPointerException("e1")).when(application).openFileInput(RATE_LIMIT_STORE_FILE);
+    simulateAppResume();
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    await().timeout(2, SECONDS).until(() -> subscriber.valueCount() > 0);
+
+    // App open events are ignored and analytics events are honored
+    List<InAppMessage> expected = new ArrayList<>();
+    expected.add(message);
+    expected.add(MODAL_MESSAGE_MODEL);
+    assertSubscriberListIs(expected, subscriber);
+  }
+
+  @Test
+  public void whenlogEventLimitIncrementSuccess_writesLimitsToDisk() {
+    simulateAppResume();
+    await().timeout(2, SECONDS).until(() -> subscriber.valueCount() > 0);
+
+    Task<Void> logImpressionTask =
+        callbacksHashMap
+            .get(MODAL_MESSAGE_MODEL.getCampaignMetadata().getCampaignId())
+            .impressionDetected();
+    await().timeout(2, SECONDS).until(logImpressionTask::isComplete);
+
+    assertThat(fileExists(RATE_LIMIT_STORE_FILE)).isTrue();
+  }
+
+  @Test
+  public void onImpressionLog_cachesImpressionsInMemory()
+      throws ExecutionException, InterruptedException, TimeoutException, FileNotFoundException {
+    CampaignMetadata otherMetadata =
+        new CampaignMetadata("otherCampaignId", "other_name", IS_NOT_TEST_MESSAGE);
+    BannerMessage otherMessage = createBannerMessageCustomMetadata(otherMetadata);
+    VanillaCampaignPayload otherCampaign =
+        VanillaCampaignPayload.newBuilder(vanillaCampaign.build())
+            .setCampaignId(otherMetadata.getCampaignId())
+            .setCampaignName(otherMetadata.getCampaignName())
+            .build();
+    ThickContent otherThickContent =
+        ThickContent.newBuilder(thickContent)
+            .setIsTestCampaign(IS_NOT_TEST_MESSAGE)
+            .clearTriggeringConditions()
+            .addTriggeringConditions(
+                TriggeringCondition.newBuilder()
+                    .setContextualTrigger(ContextualTrigger.newBuilder().setName("event2")))
+            .clearVanillaPayload()
+            .setVanillaPayload(otherCampaign)
+            .setContent(BANNER_MESSAGE_PROTO)
+            .build();
+    FetchEligibleCampaignsResponse response =
+        FetchEligibleCampaignsResponse.newBuilder(eligibleCampaigns)
+            .addMessages(otherThickContent)
+            .build();
+    GoodFiamService impl = new GoodFiamService(response);
+    grpcServerRule.getServiceRegistry().addService(impl);
+
+    Task<Void> logImpressionTask =
+        displayCallbacksFactory
+            .generateDisplayCallback(MODAL_MESSAGE_MODEL, ANALYTICS_EVENT_NAME)
+            .impressionDetected();
+    Tasks.await(logImpressionTask, 1000, TimeUnit.MILLISECONDS);
+    doThrow(new NullPointerException("e1")).when(application).openFileInput(IMPRESSIONS_STORE_FILE);
+
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    analyticsConnector.invokeListenerOnEvent("event2");
+    waitUntilNotified(subscriber);
+
+    List<Object> triggeredMessages = getPlainValues(subscriber);
+    assertThat(triggeredMessages.size()).isEqualTo(1);
+    assertThat(triggeredMessages.get(0)).isEqualTo(otherMessage);
+  }
+
+  @Test
+  public void onCorruptImpressionStore_doesNotFilter()
+      throws ExecutionException, InterruptedException, TimeoutException, IOException {
+    changeFileContents(IMPRESSIONS_STORE_FILE);
+
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    waitUntilNotified(subscriber);
+
+    assertSingleSuccessNotification(subscriber);
+  }
+
+  @Test
+  public void onImpressionStoreReadFailure_doesNotFilter()
+      throws ExecutionException, InterruptedException, TimeoutException, IOException {
+    doThrow(new NullPointerException("e1")).when(application).openFileInput(IMPRESSIONS_STORE_FILE);
+
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    waitUntilNotified(subscriber);
+
+    assertSingleSuccessNotification(subscriber);
+  }
+
+  // There is not a purely functional way to determine if our clients inject the impressed
+  // campaigns upstream since we filter impressions from the response on the client as well.
+  // We work around this by failing hard on the fake service if we do not find an empty impression
+  // list
+  @Test
+  public void whenImpressionStorageClientFails_injectsEmptyImpressionListUpstream()
+      throws ExecutionException, InterruptedException, TimeoutException, FileNotFoundException {
+    VanillaCampaignPayload otherCampaign =
+        VanillaCampaignPayload.newBuilder(vanillaCampaign.build())
+            .setCampaignId("otherCampaignId")
+            .setCampaignName("other_name")
+            .build();
+    ThickContent otherContent =
+        ThickContent.newBuilder(thickContent)
+            .setContent(BANNER_MESSAGE_PROTO)
+            .clearVanillaPayload()
+            .clearTriggeringConditions()
+            .addTriggeringConditions(
+                TriggeringCondition.newBuilder()
+                    .setContextualTrigger(ContextualTrigger.newBuilder().setName("event2")))
+            .setVanillaPayload(otherCampaign)
+            .build();
+    FetchEligibleCampaignsResponse response =
+        FetchEligibleCampaignsResponse.newBuilder(eligibleCampaigns)
+            .addMessages(otherContent)
+            .build();
+
+    InAppMessagingSdkServingImplBase fakeFilteringService =
+        new InAppMessagingSdkServingImplBase() {
+          @Override
+          public void fetchEligibleCampaigns(
+              FetchEligibleCampaignsRequest request,
+              StreamObserver<FetchEligibleCampaignsResponse> responseObserver) {
+
+            // Fail if impressions list is not empty
+            assertThat(request.getAlreadySeenCampaignsList()).isEmpty();
+
+            responseObserver.onNext(response);
+            responseObserver.onCompleted();
+          }
+        };
+    grpcServerRule.getServiceRegistry().addService(fakeFilteringService);
+    doThrow(new NullPointerException("e1")).when(application).openFileInput(IMPRESSIONS_STORE_FILE);
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    analyticsConnector.invokeListenerOnEvent("event2");
+
+    waitUntilNotified(subscriber);
+  }
+
+  @Test
+  public void whenAppForegroundIsRateLimited_doesNotNotify() {
+    CampaignMetadata analyticsCampaignMetadata =
+        new CampaignMetadata("analytics", "analyticsName", IS_NOT_TEST_MESSAGE);
+    VanillaCampaignPayload.Builder analyticsCampaign =
+        VanillaCampaignPayload.newBuilder()
+            .setCampaignId(analyticsCampaignMetadata.getCampaignId())
+            .setCampaignName(analyticsCampaignMetadata.getCampaignName())
+            .setCampaignStartTimeMillis(PAST)
+            .setCampaignEndTimeMillis(FUTURE);
+    BannerMessage analyticsMessage = createBannerMessageCustomMetadata(analyticsCampaignMetadata);
+    ThickContent analyticsThickContent =
+        ThickContent.newBuilder()
+            .setContent(BANNER_MESSAGE_PROTO)
+            .setIsTestCampaign(IS_NOT_TEST_MESSAGE)
+            .addTriggeringConditions(ON_ANALYTICS_EVENT)
+            .setVanillaPayload(analyticsCampaign)
+            .build();
+
+    CampaignMetadata foregroundCampaignMetadata =
+        new CampaignMetadata("foreground", "foregroundName", IS_NOT_TEST_MESSAGE);
+    VanillaCampaignPayload.Builder otherForegroundCampaign =
+        VanillaCampaignPayload.newBuilder()
+            .setCampaignId(foregroundCampaignMetadata.getCampaignId())
+            .setCampaignName(foregroundCampaignMetadata.getCampaignName())
+            .setCampaignStartTimeMillis(PAST)
+            .setCampaignEndTimeMillis(FUTURE);
+    ThickContent lowPriorityForegroundEvent =
+        ThickContent.newBuilder()
+            .setIsTestCampaign(IS_NOT_TEST_MESSAGE)
+            .setPriority(Priority.newBuilder().setValue(4))
+            .setContent(BANNER_MESSAGE_PROTO)
+            .addTriggeringConditions(ON_ANALYTICS_EVENT)
+            .addTriggeringConditions(ON_FOREGROUND_TRIGGER)
+            .setVanillaPayload(otherForegroundCampaign)
+            .build();
+
+    FetchEligibleCampaignsResponse response =
+        FetchEligibleCampaignsResponse.newBuilder(eligibleCampaigns)
+            .addMessages(analyticsThickContent)
+            .addMessages(lowPriorityForegroundEvent)
+            .build();
+    GoodFiamService impl = new GoodFiamService(response);
+    grpcServerRule.getServiceRegistry().addService(impl);
+
+    // Log impressions for an app open campaign
+    // Trigger app open events (other app foreground campaign still eligible)
+    // Trigger analytics events
+    // Assert that only analytics event triggers were activated
+    simulateAppResume();
+    await().timeout(2, SECONDS).until(() -> subscriber.valueCount() > 0);
+    assertSubsriberExactly(MODAL_MESSAGE_MODEL, subscriber);
+    Task<Void> logImpressionTask =
+        callbacksHashMap
+            .get(MODAL_MESSAGE_MODEL.getCampaignMetadata().getCampaignId())
+            .impressionDetected();
+    await().timeout(2, SECONDS).until(logImpressionTask::isComplete);
+    simulateAppResume();
+    analyticsConnector.invokeListenerOnEvent(ANALYTICS_EVENT_NAME);
+    await().timeout(2, SECONDS).until(() -> subscriber.valueCount() > 1);
+
+    List<InAppMessage> expected = new ArrayList<>();
+    expected.add(MODAL_MESSAGE_MODEL);
+    expected.add(analyticsMessage);
+    assertSubscriberListIs(expected, subscriber);
+  }
+
+  @Test
+  public void onCorruptLimitStore_doesNotRateLimit()
+      throws ExecutionException, InterruptedException, TimeoutException, IOException {
+    changeFileContents(RATE_LIMIT_STORE_FILE);
+    simulateAppResume();
+    waitUntilNotified(subscriber);
+    assertSubsriberExactly(MODAL_MESSAGE_MODEL, subscriber);
+  }
+
+  /* It is currently non trivial to write a non-flaky *integration* test to determine if
+   * _nothing_ happens when the network fails since the expected outcome is that clients remain
+   * unaffacted
+   */
+  @Test
+  @Ignore("not ready yet")
+  public void testNetworkFailure() {}
+
+  @Test
+  public void onCancellation_dropsNotification() {
+    simulateAppResume();
+    subscriber.dispose();
+    await().timeout(2, SECONDS).until(() -> subscriber.isCancelled());
+
+    assertNoNotification(subscriber);
+  }
+
+  private void assertSingleSuccessNotification(TestSubscriber<InAppMessage> subscriber) {
+    subscriber.assertNotComplete();
+    subscriber.assertNoErrors();
+    assertThat(getPlainValues(subscriber).get(0)).isEqualTo(MODAL_MESSAGE_MODEL);
+    assertThat(subscriber.lastThread().getName()).isEqualTo("main");
+  }
+
+  private void assertNoNotification(TestSubscriber<InAppMessage> subscriber) {
+    subscriber.assertNotComplete();
+    subscriber.assertNoErrors();
+    subscriber.assertNoValues();
+  }
+
+  private void simulateAppResume() {
+    foregroundNotifier.notifyForeground();
+  }
+
+  private void waitUntilNotified(TestSubscriber<InAppMessage> subscriber) {
+    await().timeout(2, SECONDS).until(() -> subscriber.valueCount() > 0);
+  }
+
+  private void changeFileContents(String fileName) throws IOException {
+    File file = new File(InstrumentationRegistry.getContext().getFilesDir(), fileName);
+    FileOutputStream stream = new FileOutputStream(file);
+    try {
+      stream.write("corrupt-non-proto-contents".getBytes());
+    } finally {
+      stream.close();
+    }
+  }
+
+  private boolean fileExists(String fileName) {
+    File file = new File(application.getApplicationContext().getFilesDir(), fileName);
+    return file.exists();
+  }
+
+  public static class GoodFiamService extends InAppMessagingSdkServingImplBase {
+
+    private final FetchEligibleCampaignsResponse response;
+
+    GoodFiamService(FetchEligibleCampaignsResponse response) {
+      this.response = response;
+    }
+
+    @Override
+    public void fetchEligibleCampaigns(
+        FetchEligibleCampaignsRequest request,
+        StreamObserver<FetchEligibleCampaignsResponse> responseObserver) {
+      responseObserver.onNext(response);
+      responseObserver.onCompleted();
+    }
+  }
+
+  public static class FilteringFiamService extends InAppMessagingSdkServingImplBase {
+    private final ThickContent t1;
+    private final ThickContent t2;
+
+    FilteringFiamService(ThickContent t1, ThickContent t2) {
+      this.t1 = t1;
+      this.t2 = t2;
+    }
+
+    @Override
+    public void fetchEligibleCampaigns(
+        FetchEligibleCampaignsRequest request,
+        StreamObserver<FetchEligibleCampaignsResponse> responseObserver) {
+
+      FetchEligibleCampaignsResponse.Builder eligibleCampaignsBuilder =
+          FetchEligibleCampaignsResponse.newBuilder().setExpirationEpochTimestampMillis(FUTURE);
+      HashSet<String> alreadySeen = new HashSet<>();
+      for (CampaignImpression c : request.getAlreadySeenCampaignsList()) {
+        alreadySeen.add(c.getCampaignId());
+      }
+
+      if (!alreadySeen.contains(t1.getVanillaPayload().getCampaignId())) {
+        eligibleCampaignsBuilder.addMessages(t1);
+      }
+
+      if (!alreadySeen.contains(t2.getVanillaPayload().getCampaignId())) {
+        eligibleCampaignsBuilder.addMessages(t2);
+      }
+
+      responseObserver.onNext(eligibleCampaignsBuilder.build());
+      responseObserver.onCompleted();
+    }
+  }
+
+  static class TestAnalyticsConnector implements AnalyticsConnector {
+
+    private AnalyticsConnectorListener listener;
+
+    TestAnalyticsConnector() {}
+
+    @Override
+    public AnalyticsConnectorHandle registerAnalyticsConnectorListener(
+        String origin, AnalyticsConnectorListener listener) {
+      if (origin.equals("fiam")) {
+        this.listener = listener;
+      }
+
+      return new AnalyticsConnectorHandle() {
+        @Override
+        public void unregister() {}
+
+        @Override
+        public void unregisterEventNames() {}
+
+        @Override
+        public void registerEventNames(Set<String> eventNames) {}
+      };
+    }
+
+    void invokeListenerOnEvent(String name) {
+      Bundle b = new Bundle();
+      b.putString("events", name);
+      listener.onMessageTriggered(2, b);
+    }
+
+    @Override
+    public void logEvent(String origin, String name, Bundle params) {}
+
+    @Override
+    public void setUserProperty(String origin, String name, Object value) {}
+
+    @Override
+    public Map<String, Object> getUserProperties(boolean includeInternal) {
+      return new HashMap<>();
+    }
+
+    @Override
+    public void setConditionalUserProperty(ConditionalUserProperty conditionalUserProperty) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void clearConditionalUserProperty(
+        String userPropertyName, String clearEventName, Bundle clearEventParams) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public List<ConditionalUserProperty> getConditionalUserProperties(
+        String origin, String propertyNamePrefix) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int getMaxUserProperties(String origin) {
+      return 0;
+    }
+  }
+
+  private static class FaultyService extends InAppMessagingSdkServingImplBase {
+
+    final CountDownLatch countDownLatch = new CountDownLatch(1);
+
+    @Override
+    public void fetchEligibleCampaigns(
+        FetchEligibleCampaignsRequest request,
+        StreamObserver<FetchEligibleCampaignsResponse> responseObserver) {
+      countDownLatch.countDown();
+      throw t;
+    }
+
+    void waitUntilFailureExercised() throws InterruptedException {
+      countDownLatch.await();
+    }
+  }
+
+  private static class SlowFaultyService extends FaultyService {
+
+    @Override
+    public void fetchEligibleCampaigns(
+        FetchEligibleCampaignsRequest request,
+        StreamObserver<FetchEligibleCampaignsResponse> responseObserver) {
+      try {
+        countDownLatch.countDown();
+        Thread.sleep(1000);
+        throw t;
+      } catch (InterruptedException e) {
+      }
+    }
+  }
+
+  void assertSubsriberExactly(InAppMessage inAppMessage, TestSubscriber<InAppMessage> subsciber) {
+    List<Object> triggeredMessages = getPlainValues(subsciber);
+    assertThat(triggeredMessages.size()).isEqualTo(1);
+    assertThat(triggeredMessages.get(0)).isEqualTo(inAppMessage);
+  }
+
+  void assertSubscriberListIs(List<InAppMessage> messages, TestSubscriber<InAppMessage> subsciber) {
+    List<Object> triggeredMessages = getPlainValues(subsciber);
+    assertThat(triggeredMessages.size()).isEqualTo(messages.size());
+    for (int i = 0; i < messages.size(); i++) {
+      assertThat(triggeredMessages.get(i)).isEqualTo(messages.get(i));
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestApiClientModule.java b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestApiClientModule.java
new file mode 100644
index 000000000..fa663906c
--- /dev/null
+++ b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestApiClientModule.java
@@ -0,0 +1,94 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import android.app.Application;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.events.Subscriber;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.inappmessaging.internal.ApiClient;
+import com.google.firebase.inappmessaging.internal.DataCollectionHelper;
+import com.google.firebase.inappmessaging.internal.GrpcClient;
+import com.google.firebase.inappmessaging.internal.ProviderInstaller;
+import com.google.firebase.inappmessaging.internal.SharedPreferencesUtils;
+import com.google.firebase.inappmessaging.internal.TestDeviceHelper;
+import com.google.firebase.inappmessaging.internal.injection.scopes.FirebaseAppScope;
+import com.google.firebase.inappmessaging.internal.time.Clock;
+import dagger.Lazy;
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Singleton;
+
+/** Test bindings for API client */
+@Module
+public class TestApiClientModule {
+
+  private final FirebaseApp firebaseApp;
+  private final FirebaseInstanceId firebaseInstanceId;
+  private SharedPreferencesUtils sharedPreferencesUtils;
+  private TestDeviceHelper testDeviceHelper;
+  private Clock clock;
+
+  public TestApiClientModule(
+      FirebaseApp firebaseApp,
+      FirebaseInstanceId instanceId,
+      TestDeviceHelper testDeviceHelper,
+      Clock clock) {
+    this.firebaseApp = firebaseApp;
+    this.firebaseInstanceId = instanceId;
+    this.testDeviceHelper = testDeviceHelper;
+    this.sharedPreferencesUtils = new SharedPreferencesUtils(firebaseApp);
+    this.clock = clock;
+  }
+
+  @Provides
+  FirebaseInstanceId providesFirebaseInstanceId() {
+    return firebaseInstanceId;
+  }
+
+  @Provides
+  @Singleton
+  public FirebaseApp providesfirebaseApp() {
+    return firebaseApp;
+  }
+
+  @Provides
+  DataCollectionHelper providesDataCollectionHelper(Subscriber firebaseEventSubscriber) {
+    return new DataCollectionHelper(
+        firebaseApp, sharedPreferencesUtils, firebaseInstanceId, firebaseEventSubscriber);
+  }
+
+  @Provides
+  TestDeviceHelper providesTestDeviceHelper() {
+    return this.testDeviceHelper;
+  }
+
+  @Provides
+  @FirebaseAppScope
+  ApiClient providesApiClient(
+      Lazy<GrpcClient> grpcClient,
+      Application application,
+      DataCollectionHelper dataCollectionHelper,
+      ProviderInstaller providerInstaller) {
+    return new ApiClient(
+        grpcClient,
+        firebaseApp,
+        application,
+        firebaseInstanceId,
+        dataCollectionHelper,
+        clock,
+        providerInstaller);
+  }
+}
diff --git a/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestAppComponent.java b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestAppComponent.java
new file mode 100644
index 000000000..0763fa856
--- /dev/null
+++ b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestAppComponent.java
@@ -0,0 +1,34 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import com.google.firebase.inappmessaging.internal.injection.components.AppComponent;
+import com.google.firebase.inappmessaging.internal.injection.components.UniversalComponent;
+import com.google.firebase.inappmessaging.internal.injection.modules.GrpcClientModule;
+import com.google.firebase.inappmessaging.internal.injection.scopes.FirebaseAppScope;
+import dagger.Component;
+
+@FirebaseAppScope
+@Component(
+    dependencies = {UniversalComponent.class},
+    modules = {
+      // Test modules
+      TestApiClientModule.class,
+      TestEngagementMetricsLoggerClientModule.class,
+
+      // Real modules
+      GrpcClientModule.class
+    })
+public interface TestAppComponent extends AppComponent {}
diff --git a/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestAppMeasurementModule.java b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestAppMeasurementModule.java
new file mode 100644
index 000000000..58dea2715
--- /dev/null
+++ b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestAppMeasurementModule.java
@@ -0,0 +1,44 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.events.Subscriber;
+import dagger.Module;
+import dagger.Provides;
+
+/** Test bindings for API client */
+@Module
+public class TestAppMeasurementModule {
+
+  private AnalyticsConnector analyticsConnector;
+  private Subscriber firebaseEventSubscriber;
+
+  public TestAppMeasurementModule(
+      AnalyticsConnector analyticsConnector, Subscriber firebaseEventSubscriber) {
+    this.analyticsConnector = analyticsConnector;
+    this.firebaseEventSubscriber = firebaseEventSubscriber;
+  }
+
+  @Provides
+  AnalyticsConnector providesAnalyticsConnector() {
+    return analyticsConnector;
+  }
+
+  @Provides
+  Subscriber providesSubscriber() {
+    return firebaseEventSubscriber;
+  }
+}
diff --git a/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestEngagementMetricsLoggerClientModule.java b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestEngagementMetricsLoggerClientModule.java
new file mode 100644
index 000000000..9983c810a
--- /dev/null
+++ b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestEngagementMetricsLoggerClientModule.java
@@ -0,0 +1,54 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.inappmessaging.internal.DeveloperListenerManager;
+import com.google.firebase.inappmessaging.internal.MetricsLoggerClient;
+import com.google.firebase.inappmessaging.internal.MetricsLoggerClient.EngagementMetricsLoggerInterface;
+import com.google.firebase.inappmessaging.internal.injection.scopes.FirebaseAppScope;
+import com.google.firebase.inappmessaging.internal.time.Clock;
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+public class TestEngagementMetricsLoggerClientModule {
+  private final FirebaseApp firebaseApp;
+  private final EngagementMetricsLoggerInterface engagementMetricsLoggerInterface;
+
+  public TestEngagementMetricsLoggerClientModule(
+      FirebaseApp firebaseApp, EngagementMetricsLoggerInterface engagementMetricsLoggerInterface) {
+    this.firebaseApp = firebaseApp;
+    this.engagementMetricsLoggerInterface = engagementMetricsLoggerInterface;
+  }
+
+  @Provides
+  @FirebaseAppScope
+  public MetricsLoggerClient providesApiClient(
+      FirebaseInstanceId firebaseInstanceId,
+      AnalyticsConnector analyticsConnector,
+      Clock clock,
+      DeveloperListenerManager developerListenerManager) {
+    return new MetricsLoggerClient(
+        engagementMetricsLoggerInterface,
+        analyticsConnector,
+        firebaseApp,
+        firebaseInstanceId,
+        clock,
+        developerListenerManager);
+  }
+}
diff --git a/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestForegroundNotifier.java b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestForegroundNotifier.java
new file mode 100644
index 000000000..a328c9794
--- /dev/null
+++ b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestForegroundNotifier.java
@@ -0,0 +1,57 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import android.app.Activity;
+import android.os.Bundle;
+import com.google.firebase.inappmessaging.internal.ForegroundNotifier;
+
+public class TestForegroundNotifier extends ForegroundNotifier {
+
+  private Listener listener;
+
+  public void notifyForeground() {
+    listener.onForeground();
+  }
+
+  @Override
+  public void setListener(Listener listener) {
+    this.listener = listener;
+  }
+
+  @Override
+  public void removeListener(Listener listener) {}
+
+  @Override
+  public void onActivityResumed(Activity activity) {}
+
+  @Override
+  public void onActivityPaused(Activity activity) {}
+
+  @Override
+  public void onActivityCreated(Activity activity, Bundle savedInstanceState) {}
+
+  @Override
+  public void onActivityStarted(Activity activity) {}
+
+  @Override
+  public void onActivityStopped(Activity activity) {}
+
+  @Override
+  public void onActivitySaveInstanceState(Activity activity, Bundle outState) {}
+
+  @Override
+  public void onActivityDestroyed(Activity activity) {}
+}
diff --git a/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestForegroundNotifierModule.java b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestForegroundNotifierModule.java
new file mode 100644
index 000000000..6a3a5c7bb
--- /dev/null
+++ b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestForegroundNotifierModule.java
@@ -0,0 +1,35 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import com.google.firebase.inappmessaging.internal.ForegroundNotifier;
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Singleton;
+
+@Module
+public class TestForegroundNotifierModule {
+  private final ForegroundNotifier foregroundNotifier;
+
+  public TestForegroundNotifierModule(ForegroundNotifier foregroundNotifier) {
+    this.foregroundNotifier = foregroundNotifier;
+  }
+
+  @Provides
+  @Singleton
+  public ForegroundNotifier providesForeroundListener() {
+    return foregroundNotifier;
+  }
+}
diff --git a/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestGrpcModule.java b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestGrpcModule.java
new file mode 100644
index 000000000..730d3ec98
--- /dev/null
+++ b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestGrpcModule.java
@@ -0,0 +1,35 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import dagger.Module;
+import dagger.Provides;
+import io.grpc.Channel;
+import javax.inject.Singleton;
+
+@Module
+public class TestGrpcModule {
+  private final Channel channel;
+
+  public TestGrpcModule(Channel channel) {
+    this.channel = channel;
+  }
+
+  @Provides
+  @Singleton
+  public Channel providesGrpcChannel() {
+    return channel;
+  }
+}
diff --git a/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestSystemClockModule.java b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestSystemClockModule.java
new file mode 100644
index 000000000..d2c3b26f1
--- /dev/null
+++ b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestSystemClockModule.java
@@ -0,0 +1,36 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import com.google.firebase.inappmessaging.internal.time.Clock;
+import com.google.firebase.inappmessaging.internal.time.FakeClock;
+import dagger.Module;
+import dagger.Provides;
+
+/** Bindings for system clock */
+@Module
+public class TestSystemClockModule {
+
+  private final long now;
+
+  public TestSystemClockModule(long now) {
+    this.now = now;
+  }
+
+  @Provides
+  public Clock providesSystemClockModule() {
+    return new FakeClock(now);
+  }
+}
diff --git a/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestUniversalComponent.java b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestUniversalComponent.java
new file mode 100644
index 000000000..5d434febc
--- /dev/null
+++ b/firebase-inappmessaging/src/androidTest/java/com/google/firebase/inappmessaging/TestUniversalComponent.java
@@ -0,0 +1,47 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import com.google.firebase.inappmessaging.internal.injection.components.UniversalComponent;
+import com.google.firebase.inappmessaging.internal.injection.modules.AnalyticsEventsModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.AppMeasurementModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.ApplicationModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.ForegroundFlowableModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.ProgrammaticContextualTriggerFlowableModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.ProtoStorageClientModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.RateLimitModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.SchedulerModule;
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Singleton
+@Component(
+    modules = {
+      // Test modules
+      TestGrpcModule.class,
+      TestForegroundNotifierModule.class,
+      TestSystemClockModule.class,
+
+      // Real modules
+      AnalyticsEventsModule.class,
+      SchedulerModule.class,
+      ApplicationModule.class,
+      ForegroundFlowableModule.class,
+      ProgrammaticContextualTriggerFlowableModule.class,
+      ProtoStorageClientModule.class,
+      RateLimitModule.class,
+      AppMeasurementModule.class,
+    })
+public interface TestUniversalComponent extends UniversalComponent {}
diff --git a/firebase-inappmessaging/src/main/AndroidManifest.xml b/firebase-inappmessaging/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..0becf12ec
--- /dev/null
+++ b/firebase-inappmessaging/src/main/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.firebase.inappmessaging">
+
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+    <uses-permission android:name="android.permission.INTERNET" />
+
+    <application>
+        <service
+            android:name="com.google.firebase.components.ComponentDiscoveryService"
+            android:exported="false">
+            <meta-data
+                android:name="com.google.firebase.components:com.google.firebase.inappmessaging.FirebaseInAppMessagingRegistrar"
+                android:value="com.google.firebase.components.ComponentRegistrar" />
+        </service>
+    </application>
+</manifest>
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessaging.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessaging.java
new file mode 100644
index 000000000..b2469bb09
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessaging.java
@@ -0,0 +1,320 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import androidx.annotation.Keep;
+import androidx.annotation.NonNull;
+import com.google.android.gms.common.annotation.KeepForSdk;
+import com.google.android.gms.common.util.VisibleForTesting;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.inappmessaging.internal.DataCollectionHelper;
+import com.google.firebase.inappmessaging.internal.DeveloperListenerManager;
+import com.google.firebase.inappmessaging.internal.DisplayCallbacksFactory;
+import com.google.firebase.inappmessaging.internal.InAppMessageStreamManager;
+import com.google.firebase.inappmessaging.internal.Logging;
+import com.google.firebase.inappmessaging.internal.ProgramaticContextualTriggers;
+import com.google.firebase.inappmessaging.internal.injection.qualifiers.ProgrammaticTrigger;
+import com.google.firebase.inappmessaging.internal.injection.scopes.FirebaseAppScope;
+import io.reactivex.Maybe;
+import io.reactivex.disposables.Disposable;
+import java.util.concurrent.Executor;
+import javax.inject.Inject;
+
+/**
+ * The entry point of the Firebase In App Messaging headless SDK.
+ *
+ * <p>Firebase In-App Messaging will automatically initialize, and start listening for events.
+ *
+ * <p>This feature uses a Firebase Instance ID token to:
+ *
+ * <ul>
+ *   <li>identify the app instance
+ *   <li>fetch messages from the Firebase backend
+ *   <li>send usage metrics to the Firebase backend.
+ * </ul>
+ *
+ * To delete the Instance ID and the data associated with it, see {@link
+ * com.google.firebase.iid.FirebaseInstanceId#deleteInstanceId}.
+ */
+@FirebaseAppScope
+public class FirebaseInAppMessaging {
+
+  private final InAppMessageStreamManager inAppMessageStreamManager;
+  private final DataCollectionHelper dataCollectionHelper;
+  private final DisplayCallbacksFactory displayCallbacksFactory;
+  private final DeveloperListenerManager developerListenerManager;
+  private final ProgramaticContextualTriggers programaticContextualTriggers;
+
+  private boolean areMessagesSuppressed;
+
+  private Maybe<FirebaseInAppMessagingDisplay> listener = Maybe.empty();
+
+  @VisibleForTesting
+  @Inject
+  FirebaseInAppMessaging(
+      InAppMessageStreamManager inAppMessageStreamManager,
+      @ProgrammaticTrigger ProgramaticContextualTriggers programaticContextualTriggers,
+      DataCollectionHelper dataCollectionHelper,
+      DisplayCallbacksFactory displayCallbacksFactory,
+      DeveloperListenerManager developerListenerManager) {
+
+    this.inAppMessageStreamManager = inAppMessageStreamManager;
+    this.programaticContextualTriggers = programaticContextualTriggers;
+
+    this.dataCollectionHelper = dataCollectionHelper;
+    this.areMessagesSuppressed = false;
+    this.displayCallbacksFactory = displayCallbacksFactory;
+    Logging.logi(
+        "Starting InAppMessaging runtime with Instance ID "
+            + FirebaseInstanceId.getInstance().getId());
+    this.developerListenerManager = developerListenerManager;
+    initializeFiam();
+  }
+
+  /**
+   * Get FirebaseInAppMessaging instance using the firebase app returned by {@link
+   * FirebaseApp#getInstance()}
+   *
+   * @param
+   * @return
+   */
+  @NonNull
+  @Keep
+  public static FirebaseInAppMessaging getInstance() {
+    return FirebaseApp.getInstance().get(FirebaseInAppMessaging.class);
+  }
+
+  /**
+   * Determine whether automatic data collection is enabled or not
+   *
+   * @return true if auto initialization is required
+   */
+  @Keep
+  public boolean isAutomaticDataCollectionEnabled() {
+    return dataCollectionHelper.isAutomaticDataCollectionEnabled();
+  }
+
+  /**
+   * Enable or disable automatic data collection for Firebase In-App Messaging.
+   *
+   * <p>When enabled, generates a registration token on app startup if there is no valid one and
+   * generates a new token when it is deleted (which prevents {@link
+   * com.google.firebase.iid.FirebaseInstanceId#deleteInstanceId} from stopping the periodic sending
+   * of data). This setting is persisted across app restarts and overrides the setting specified in
+   * your manifest.
+   *
+   * <p>By default, auto-initialization is enabled. If you need to change the default, (for example,
+   * because you want to prompt the user before generates/refreshes a registration token on app
+   * startup), add to your applications manifest:
+   *
+   * <pre>{@code
+   * <meta-data android:name="firebase_inapp_messaging_auto_init_enabled" android:value="false" />
+   * }</pre>
+   *
+   * Note, this will require you to manually initialize Firebase In-App Messaging, via:
+   *
+   * <pre>{@code FirebaseInAppMessaging.getInstance().setAutomaticDataCollectionEnabled(true)}</pre>
+   *
+   * @param isAutomaticCollectionEnabled Whether isEnabled
+   */
+  @Keep
+  public void setAutomaticDataCollectionEnabled(boolean isAutomaticCollectionEnabled) {
+    dataCollectionHelper.setAutomaticDataCollectionEnabled(isAutomaticCollectionEnabled);
+  }
+
+  /**
+   * Enable or disable suppression of Firebase In App Messaging messages
+   *
+   * <p>When enabled, no in app messages will be rendered until either you either disable
+   * suppression, or the app restarts, as this state is not preserved over app restarts.
+   *
+   * <p>By default, messages are not suppressed.
+   *
+   * @param areMessagesSuppressed Whether messages should be suppressed
+   */
+  @Keep
+  public void setMessagesSuppressed(@NonNull Boolean areMessagesSuppressed) {
+    this.areMessagesSuppressed = areMessagesSuppressed;
+  }
+
+  /**
+   * Determine whether messages are suppressed or not. This is honored by the UI sdk, which handles
+   * rendering the in app message.
+   *
+   * @return true if messages should be suppressed
+   */
+  @Keep
+  public boolean areMessagesSuppressed() {
+    return areMessagesSuppressed;
+  }
+
+  private void initializeFiam() {
+    Disposable unusedSubscription =
+        inAppMessageStreamManager
+            .createFirebaseInAppMessageStream()
+            .subscribe(
+                triggeredInAppMessage ->
+                    listener
+                        .doOnSuccess(
+                            listener -> {
+                              listener.displayMessage(
+                                  triggeredInAppMessage.getInAppMessage(),
+                                  displayCallbacksFactory.generateDisplayCallback(
+                                      triggeredInAppMessage.getInAppMessage(),
+                                      triggeredInAppMessage.getTriggeringEvent()));
+                            })
+                        .subscribe());
+  }
+
+  /*
+   * Called to set a new message display component for FIAM SDK. This is the method used
+   * by both the default FIAM display SDK or any app wanting to customize the message
+   * display.
+   */
+  @Keep
+  public void setMessageDisplayComponent(@NonNull FirebaseInAppMessagingDisplay messageDisplay) {
+    Logging.logi("Setting display event listener");
+    this.listener = Maybe.just(messageDisplay);
+  }
+
+  /**
+   * Unregisters a listener to in app message display events.
+   *
+   * @hide
+   */
+  @Keep
+  @KeepForSdk
+  public void clearDisplayListener() {
+    Logging.logi("Removing display event listener");
+    this.listener = Maybe.empty();
+  }
+
+  /*
+   * Adds/Removes the event listeners. These listeners are triggered after FIAM's internal metrics reporting, but regardless of success/failure of the FIAM-internal callbacks.
+   */
+
+  // executed on worker thread
+
+  /**
+   * Registers an impression listener with FIAM, which will be notified on every FIAM impression
+   *
+   * @param impressionListener
+   */
+  public void addImpressionListener(
+      @NonNull FirebaseInAppMessagingImpressionListener impressionListener) {
+    developerListenerManager.addImpressionListener(impressionListener);
+  }
+
+  /**
+   * Registers a click listener with FIAM, which will be notified on every FIAM click
+   *
+   * @param clickListener
+   */
+  public void addClickListener(@NonNull FirebaseInAppMessagingClickListener clickListener) {
+    developerListenerManager.addClickListener(clickListener);
+  }
+
+  /**
+   * Registers a display error listener with FIAM, which will be notified on every FIAM display
+   * error
+   *
+   * @param displayErrorListener
+   */
+  public void addDisplayErrorListener(
+      @NonNull FirebaseInAppMessagingDisplayErrorListener displayErrorListener) {
+    developerListenerManager.addDisplayErrorListener(displayErrorListener);
+  }
+
+  // Executed with provided executor
+  /**
+   * Registers an impression listener with FIAM, which will be notified on every FIAM impression,
+   * and triggered on the provided executor
+   *
+   * @param impressionListener
+   * @param executor
+   */
+  public void addImpressionListener(
+      @NonNull FirebaseInAppMessagingImpressionListener impressionListener,
+      @NonNull Executor executor) {
+    developerListenerManager.addImpressionListener(impressionListener, executor);
+  }
+
+  /**
+   * Registers a click listener with FIAM, which will be notified on every FIAM click, and triggered
+   * on the provided executor
+   *
+   * @param clickListener
+   * @param executor
+   */
+  public void addClickListener(
+      @NonNull FirebaseInAppMessagingClickListener clickListener, @NonNull Executor executor) {
+    developerListenerManager.addClickListener(clickListener, executor);
+  }
+
+  /**
+   * Registers a display error listener with FIAM, which will be notified on every FIAM display
+   * error, and triggered on the provided executor
+   *
+   * @param displayErrorListener
+   * @param executor
+   */
+  public void addDisplayErrorListener(
+      @NonNull FirebaseInAppMessagingDisplayErrorListener displayErrorListener,
+      @NonNull Executor executor) {
+    developerListenerManager.addDisplayErrorListener(displayErrorListener, executor);
+  }
+
+  // Removing individual listeners:
+  /**
+   * Unregisters an impression listener
+   *
+   * @param impressionListener
+   */
+  public void removeImpressionListener(
+      @NonNull FirebaseInAppMessagingImpressionListener impressionListener) {
+    developerListenerManager.removeImpressionListener(impressionListener);
+  }
+
+  /**
+   * Unregisters a click listener
+   *
+   * @param clickListener
+   */
+  public void removeClickListener(@NonNull FirebaseInAppMessagingClickListener clickListener) {
+    developerListenerManager.removeClickListener(clickListener);
+  }
+
+  /**
+   * Unregisters a display error listener
+   *
+   * @param displayErrorListener
+   */
+  public void removeDisplayErrorListener(
+      @NonNull FirebaseInAppMessagingDisplayErrorListener displayErrorListener) {
+    developerListenerManager.removeDisplayErrorListener(displayErrorListener);
+  }
+
+  /**
+   * Programmatically trigger a contextual trigger. This will display any eligible in-app messages
+   * that are triggered by this event
+   *
+   * @param eventName
+   * @hide // hiding until api is finalized
+   */
+  public void triggerEvent(String eventName) {
+    programaticContextualTriggers.triggerEvent(eventName);
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingClickListener.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingClickListener.java
new file mode 100644
index 000000000..ad38c7aae
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingClickListener.java
@@ -0,0 +1,26 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import androidx.annotation.NonNull;
+import com.google.firebase.inappmessaging.model.Action;
+import com.google.firebase.inappmessaging.model.InAppMessage;
+
+public interface FirebaseInAppMessagingClickListener {
+
+  // Triggered when a message is tapped (ie: button, in the modal view) and which action was
+  // triggered (which provides support for the multi-button templates)
+  void messageClicked(@NonNull InAppMessage inAppMessage, @NonNull Action action);
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingContextualTrigger.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingContextualTrigger.java
new file mode 100644
index 000000000..f609c916a
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingContextualTrigger.java
@@ -0,0 +1,30 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import androidx.annotation.NonNull;
+
+public class FirebaseInAppMessagingContextualTrigger {
+  private final String triggerName;
+
+  public FirebaseInAppMessagingContextualTrigger(@NonNull String triggerName) {
+    this.triggerName = triggerName;
+  }
+
+  @NonNull
+  public String getTriggerName() {
+    return triggerName;
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingDisplay.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingDisplay.java
new file mode 100644
index 000000000..f71deebe7
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingDisplay.java
@@ -0,0 +1,31 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import androidx.annotation.Keep;
+import androidx.annotation.NonNull;
+import com.google.firebase.inappmessaging.model.InAppMessage;
+
+/**
+ * The interface that a FIAM display class must implement. Note that the developer is responsible
+ * for calling the logging-related methods on FirebaseInAppMessaging to track user-related metrics.
+ */
+@Keep
+public interface FirebaseInAppMessagingDisplay {
+  @Keep
+  void displayMessage(
+      @NonNull InAppMessage inAppMessage,
+      @NonNull FirebaseInAppMessagingDisplayCallbacks callbacks);
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingDisplayCallbacks.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingDisplayCallbacks.java
new file mode 100644
index 000000000..4074d115a
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingDisplayCallbacks.java
@@ -0,0 +1,72 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import androidx.annotation.NonNull;
+import com.google.android.gms.tasks.Task;
+import com.google.firebase.inappmessaging.model.Action;
+
+public interface FirebaseInAppMessagingDisplayCallbacks {
+
+  // log the campaign impression:
+  @NonNull
+  Task<Void> impressionDetected();
+
+  // log when a message is dismissed, and specify dismiss type
+  @NonNull
+  Task<Void> messageDismissed(@NonNull InAppMessagingDismissType dismissType);
+
+  // log when a message is tap (ie: button, in the modal view) and the action_url is followed
+  // With CardMessage, defaults to 'primary Action'
+  @Deprecated
+  // Task<Void> messageClicked();
+
+  // log when a message is tap (ie: button, in the modal view)  with the Action followed
+  @NonNull
+  Task<Void> messageClicked(@NonNull Action action);
+
+  // log when there is an issue rendering the content (ie, image_url is invalid
+  // or file_type is unsupported
+  @NonNull
+  Task<Void> displayErrorEncountered(@NonNull InAppMessagingErrorReason inAppMessagingErrorReason);
+
+  enum InAppMessagingDismissType {
+    // Unspecified dismiss type
+    UNKNOWN_DISMISS_TYPE,
+
+    // Message was dismissed automatically after a timeout
+    AUTO,
+
+    // Message was dismissed by clicking on cancel button or outside the message
+    CLICK,
+
+    // Message was swiped
+    SWIPE
+  }
+
+  enum InAppMessagingErrorReason {
+    // Generic error
+    UNSPECIFIED_RENDER_ERROR,
+
+    // Failure to fetch the image
+    IMAGE_FETCH_ERROR,
+
+    // Failure to display the image
+    IMAGE_DISPLAY_ERROR,
+
+    // Image has an unsupported format
+    IMAGE_UNSUPPORTED_FORMAT
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingDisplayErrorListener.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingDisplayErrorListener.java
new file mode 100644
index 000000000..b957d7ff3
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingDisplayErrorListener.java
@@ -0,0 +1,27 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import androidx.annotation.NonNull;
+import com.google.firebase.inappmessaging.model.InAppMessage;
+
+public interface FirebaseInAppMessagingDisplayErrorListener {
+
+  // Triggered when there is an issue rendering the content (ie, image_url is invalid
+  // or file_type is unsupported
+  void displayErrorEncountered(
+      @NonNull InAppMessage inAppMessage,
+      @NonNull FirebaseInAppMessagingDisplayCallbacks.InAppMessagingErrorReason errorReason);
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingImpressionListener.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingImpressionListener.java
new file mode 100644
index 000000000..d9e2331b8
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingImpressionListener.java
@@ -0,0 +1,24 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import androidx.annotation.NonNull;
+import com.google.firebase.inappmessaging.model.InAppMessage;
+
+public interface FirebaseInAppMessagingImpressionListener {
+
+  // impression detected
+  void impressionDetected(@NonNull InAppMessage inAppMessage);
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingRegistrar.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingRegistrar.java
new file mode 100644
index 000000000..33f40be88
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingRegistrar.java
@@ -0,0 +1,97 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import android.app.Application;
+import androidx.annotation.Keep;
+import com.google.android.datatransport.TransportFactory;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.components.Component;
+import com.google.firebase.components.ComponentContainer;
+import com.google.firebase.components.ComponentRegistrar;
+import com.google.firebase.components.Dependency;
+import com.google.firebase.events.Subscriber;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.inappmessaging.internal.ProgramaticContextualTriggers;
+import com.google.firebase.inappmessaging.internal.injection.components.AppComponent;
+import com.google.firebase.inappmessaging.internal.injection.components.DaggerAppComponent;
+import com.google.firebase.inappmessaging.internal.injection.components.DaggerUniversalComponent;
+import com.google.firebase.inappmessaging.internal.injection.components.UniversalComponent;
+import com.google.firebase.inappmessaging.internal.injection.modules.AnalyticsEventsModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.ApiClientModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.AppMeasurementModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.ApplicationModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.GrpcClientModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.ProgrammaticContextualTriggerFlowableModule;
+import com.google.firebase.platforminfo.LibraryVersionComponent;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Registers {@link FirebaseInAppMessaging}.
+ *
+ * @hide
+ */
+@Keep
+public class FirebaseInAppMessagingRegistrar implements ComponentRegistrar {
+  @Override
+  @Keep
+  public List<Component<?>> getComponents() {
+    return Arrays.asList(
+        Component.builder(FirebaseInAppMessaging.class)
+            .add(Dependency.required(FirebaseInstanceId.class))
+            .add(Dependency.required(FirebaseApp.class))
+            .add(Dependency.optional(AnalyticsConnector.class))
+            .add(Dependency.required(TransportFactory.class))
+            .add(Dependency.required(Subscriber.class))
+            .factory(this::providesFirebaseInAppMessaging)
+            .eagerInDefaultApp()
+            .build(),
+        LibraryVersionComponent.create("fire-fiam", BuildConfig.VERSION_NAME));
+  }
+
+  private FirebaseInAppMessaging providesFirebaseInAppMessaging(ComponentContainer container) {
+    FirebaseApp firebaseApp = container.get(FirebaseApp.class);
+    FirebaseInstanceId firebaseInstanceId = container.get(FirebaseInstanceId.class);
+    AnalyticsConnector analyticsConnector = container.get(AnalyticsConnector.class);
+
+    Subscriber firebaseEventsSubscriber = container.get(Subscriber.class);
+
+    Application application = (Application) firebaseApp.getApplicationContext();
+
+    UniversalComponent universalComponent =
+        DaggerUniversalComponent.builder()
+            .applicationModule(new ApplicationModule(application))
+            .appMeasurementModule(
+                new AppMeasurementModule(analyticsConnector, firebaseEventsSubscriber))
+            .analyticsEventsModule(new AnalyticsEventsModule())
+            .programmaticContextualTriggerFlowableModule(
+                new ProgrammaticContextualTriggerFlowableModule(
+                    new ProgramaticContextualTriggers()))
+            .build();
+
+    AppComponent instance =
+        DaggerAppComponent.builder()
+            .apiClientModule(
+                new ApiClientModule(firebaseApp, firebaseInstanceId, universalComponent.clock()))
+            .grpcClientModule(new GrpcClientModule(firebaseApp))
+            .universalComponent(universalComponent)
+            .transportFactory(container.get(TransportFactory.class))
+            .build();
+
+    return instance.providesFirebaseInAppMessaging();
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/AnalyticsConstants.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/AnalyticsConstants.java
new file mode 100644
index 000000000..da3af94e3
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/AnalyticsConstants.java
@@ -0,0 +1,44 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import com.google.common.annotations.VisibleForTesting;
+
+/**
+ * Constants used for measurement/analytics integration
+ *
+ * @hide
+ */
+final class AnalyticsConstants {
+  // FIAM event names.
+  @VisibleForTesting static final String ANALYTICS_IMPRESSION_EVENT = "fiam_impression";
+
+  @VisibleForTesting static final String ANALYTICS_ACTION_EVENT = "fiam_action";
+
+  @VisibleForTesting static final String ANALYTICS_DISMISS_EVENT = "fiam_dismiss";
+
+  static final String ORIGIN_FIAM = "fiam";
+
+  static final String PARAM_LABEL = "label";
+  static final String PARAM_CAMPAIGN = "campaign";
+  static final String PARAM_MESSAGE_ID = "_nmid";
+  static final String PARAM_MESSAGE_NAME = "_nmn";
+  static final String PARAM_MESSAGE_DEVICE_TIME = "_ndt";
+  static final String USER_PROPERTY_FIREBASE_LAST_NOTIFICATION = "_ln";
+
+  static final int MAX_REGISTERED_EVENTS = 50;
+  static final String BUNDLE_EVENT_NAME_KEY = "events";
+  static final int FIAM_ANALYTICS_CONNECTOR_LISTENER_EVENT_ID = 2;
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/AnalyticsEventsManager.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/AnalyticsEventsManager.java
new file mode 100644
index 000000000..ab8311737
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/AnalyticsEventsManager.java
@@ -0,0 +1,108 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import android.text.TextUtils;
+import com.google.common.annotations.VisibleForTesting;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.analytics.connector.AnalyticsConnector.AnalyticsConnectorHandle;
+import com.google.firebase.inappmessaging.CommonTypesProto;
+import com.google.internal.firebase.inappmessaging.v1.CampaignProto;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsResponse;
+import io.reactivex.BackpressureStrategy;
+import io.reactivex.Flowable;
+import io.reactivex.FlowableEmitter;
+import io.reactivex.FlowableOnSubscribe;
+import io.reactivex.flowables.ConnectableFlowable;
+import java.util.HashSet;
+import java.util.Set;
+import javax.annotation.Nullable;
+
+/**
+ * Container for the analytics handler as well as the flowable used to act on emitted events
+ *
+ * @hide
+ */
+public class AnalyticsEventsManager {
+  private final AnalyticsConnector analyticsConnector;
+  private final ConnectableFlowable<String> flowable;
+  private AnalyticsConnectorHandle handle;
+
+  public AnalyticsEventsManager(AnalyticsConnector analyticsConnector) {
+    this.analyticsConnector = analyticsConnector;
+    AnalyticsFlowableSubscriber subscriber = new AnalyticsFlowableSubscriber();
+    flowable = Flowable.<String>create(subscriber, BackpressureStrategy.BUFFER).publish();
+
+    // We ignore the subscription since this connected flowable is expected to last the lifetime of
+    // the app, but this calls the 'subscribe' method of the subscriber, which registers the handle
+    flowable.connect();
+  }
+
+  @Nullable
+  public AnalyticsConnectorHandle getHandle() {
+    return handle;
+  }
+
+  public ConnectableFlowable<String> getAnalyticsEventsFlowable() {
+    return flowable;
+  }
+
+  @VisibleForTesting
+  static final String TOO_MANY_CONTEXTUAL_TRIGGERS_ERROR =
+      "Too many contextual triggers defined - limiting to "
+          + AnalyticsConstants.MAX_REGISTERED_EVENTS;
+
+  @VisibleForTesting
+  static Set<String> extractAnalyticsEventNames(FetchEligibleCampaignsResponse response) {
+    Set<String> analyticsEvents = new HashSet<>();
+    for (CampaignProto.ThickContent content : response.getMessagesList()) {
+      for (CommonTypesProto.TriggeringCondition condition : content.getTriggeringConditionsList()) {
+        if (condition.getContextualTrigger() != null
+            && !TextUtils.isEmpty(condition.getContextualTrigger().getName())) {
+          analyticsEvents.add(condition.getContextualTrigger().getName());
+        }
+      }
+    }
+    // The analytics connector will automatically filter down to the maximum number of allowable
+    // events,
+    // and track sdks 'abusing' that limit, but we want to note this for the developers as well
+    // Additionally, analytics also filters out 'ineligible' event names - which might result in
+    // fewer than 50 eligible ones to register as contextual triggers.
+    if (analyticsEvents.size() > AnalyticsConstants.MAX_REGISTERED_EVENTS) {
+      Logging.logi(TOO_MANY_CONTEXTUAL_TRIGGERS_ERROR);
+    }
+    return analyticsEvents;
+  }
+
+  public void updateContextualTriggers(FetchEligibleCampaignsResponse serviceResponse) {
+    Set<String> analyticsEventNames = extractAnalyticsEventNames(serviceResponse);
+    Logging.logd(
+        "Updating contextual triggers for the following analytics events: " + analyticsEventNames);
+    handle.registerEventNames(analyticsEventNames);
+  }
+
+  private class AnalyticsFlowableSubscriber implements FlowableOnSubscribe<String> {
+
+    AnalyticsFlowableSubscriber() {}
+
+    @Override
+    public void subscribe(FlowableEmitter<String> emitter) {
+      Logging.logd("Subscribing to analytics events.");
+      handle =
+          analyticsConnector.registerAnalyticsConnectorListener(
+              AnalyticsConstants.ORIGIN_FIAM, new FiamAnalyticsConnectorListener(emitter));
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ApiClient.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ApiClient.java
new file mode 100644
index 000000000..04be3a52c
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ApiClient.java
@@ -0,0 +1,174 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import android.app.Application;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.os.Build.VERSION;
+import android.text.TextUtils;
+import com.google.common.annotations.VisibleForTesting;
+import com.google.developers.mobile.targeting.proto.ClientSignalsProto.ClientSignals;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.inappmessaging.internal.injection.scopes.FirebaseAppScope;
+import com.google.firebase.inappmessaging.internal.time.Clock;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.CampaignImpressionList;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.ClientAppInfo;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsRequest;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsResponse;
+import dagger.Lazy;
+import java.util.Locale;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+
+/**
+ * Interface to speak to the fiam backend
+ *
+ * @hide
+ */
+@FirebaseAppScope
+public class ApiClient {
+
+  private static final String DATA_COLLECTION_DISABLED_ERROR =
+      "Automatic data collection is disabled, not attempting campaign fetch from service.";
+  private static final String IID_NOT_INITIALIZED_ERROR =
+      "FirebaseInstanceId not yet initialized, not attempting campaign fetch from service.";
+  private static final String FETCHING_CAMPAIGN_MESSAGE = "Fetching campaigns from service.";
+
+  private final Lazy<GrpcClient> grpcClient;
+  private final FirebaseApp firebaseApp;
+  private final Application application;
+  private final FirebaseInstanceId firebaseInstanceId;
+  private final DataCollectionHelper dataCollectionHelper;
+  private final Clock clock;
+  private final ProviderInstaller providerInstaller;
+
+  public ApiClient(
+      Lazy<GrpcClient> grpcClient,
+      FirebaseApp firebaseApp,
+      Application application,
+      FirebaseInstanceId firebaseInstanceId,
+      DataCollectionHelper dataCollectionHelper,
+      Clock clock,
+      ProviderInstaller providerInstaller) {
+    this.grpcClient = grpcClient;
+    this.firebaseApp = firebaseApp;
+    this.application = application;
+    this.firebaseInstanceId = firebaseInstanceId;
+    this.dataCollectionHelper = dataCollectionHelper;
+    this.clock = clock;
+    this.providerInstaller = providerInstaller;
+  }
+
+  @VisibleForTesting
+  static FetchEligibleCampaignsResponse createCacheExpiringResponse() {
+    // Within the cache, we use '0' as a special case to 'never' expire. '1' is used when we want to
+    // retry the getFiams call on subsequent event triggers, and force the cache to always expire
+    return FetchEligibleCampaignsResponse.newBuilder().setExpirationEpochTimestampMillis(1).build();
+  }
+
+  FetchEligibleCampaignsResponse getFiams(CampaignImpressionList impressionList) {
+    if (!dataCollectionHelper.isAutomaticDataCollectionEnabled()) {
+      Logging.logi(DATA_COLLECTION_DISABLED_ERROR);
+      return createCacheExpiringResponse();
+    }
+
+    if (!isFirebaseTokenInitialized()) {
+      Logging.logi(IID_NOT_INITIALIZED_ERROR);
+      return createCacheExpiringResponse();
+    }
+
+    Logging.logi(FETCHING_CAMPAIGN_MESSAGE);
+
+    providerInstaller.install();
+
+    return withCacheExpirationSafeguards(
+        grpcClient
+            .get()
+            .fetchEligibleCampaigns(
+                FetchEligibleCampaignsRequest.newBuilder()
+                    // The project Id we expect is the gcm sender id
+                    .setProjectNumber(firebaseApp.getOptions().getGcmSenderId())
+                    .addAllAlreadySeenCampaigns(impressionList.getAlreadySeenCampaignsList())
+                    .setClientSignals(getClientSignals())
+                    .setRequestingClientApp(getClientAppInfo())
+                    .build()));
+  }
+
+  private FetchEligibleCampaignsResponse withCacheExpirationSafeguards(
+      FetchEligibleCampaignsResponse resp) {
+    if (resp.getExpirationEpochTimestampMillis() < clock.now() + TimeUnit.MINUTES.toMillis(1)
+        || resp.getExpirationEpochTimestampMillis() > clock.now() + TimeUnit.DAYS.toMillis(3)) {
+      // we default to minimum 1 day if the expiration passed from the service is less than 1 minute
+      return resp.toBuilder()
+          .setExpirationEpochTimestampMillis(clock.now() + TimeUnit.DAYS.toMillis(1))
+          .build();
+    }
+
+    return resp;
+  }
+
+  private ClientSignals getClientSignals() {
+    ClientSignals.Builder clientSignals =
+        ClientSignals.newBuilder()
+            .setPlatformVersion(String.valueOf(VERSION.SDK_INT))
+            // toString is needed here to support API versions lower than 21.
+            .setLanguageCode(Locale.getDefault().toString())
+            .setTimeZone(TimeZone.getDefault().getID());
+
+    String versionName = getVersionName();
+    if (!TextUtils.isEmpty(versionName)) {
+      clientSignals.setAppVersion(versionName);
+    }
+
+    return clientSignals.build();
+  }
+
+  private boolean isFirebaseTokenInitialized() {
+    return !TextUtils.isEmpty(firebaseInstanceId.getToken())
+        && !TextUtils.isEmpty(firebaseInstanceId.getId());
+  }
+
+  private ClientAppInfo getClientAppInfo() {
+    ClientAppInfo.Builder builder =
+        ClientAppInfo.newBuilder().setGmpAppId(firebaseApp.getOptions().getApplicationId());
+
+    String instanceId = firebaseInstanceId.getId();
+    if (!TextUtils.isEmpty(instanceId)) {
+      builder.setAppInstanceId(instanceId);
+    }
+
+    String instanceToken = firebaseInstanceId.getToken();
+    if (!TextUtils.isEmpty(instanceToken)) {
+      builder.setAppInstanceIdToken(instanceToken);
+    }
+
+    return builder.build();
+  }
+
+  @Nullable
+  private String getVersionName() {
+    try {
+      PackageInfo pInfo =
+          application.getPackageManager().getPackageInfo(application.getPackageName(), 0);
+      return pInfo.versionName;
+    } catch (NameNotFoundException e) {
+      Logging.loge("Error finding versionName : " + e.getMessage());
+    }
+    return null;
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/CampaignCacheClient.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/CampaignCacheClient.java
new file mode 100644
index 000000000..434a65d0e
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/CampaignCacheClient.java
@@ -0,0 +1,112 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import android.app.Application;
+import com.google.firebase.inappmessaging.internal.injection.modules.ProtoStorageClientModule;
+import com.google.firebase.inappmessaging.internal.injection.qualifiers.CampaignCache;
+import com.google.firebase.inappmessaging.internal.time.Clock;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsResponse;
+import io.reactivex.Completable;
+import io.reactivex.Maybe;
+import java.io.File;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import javax.annotation.concurrent.ThreadSafe;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+/**
+ * Client to store and retrieve the latest version of eligible campaigns fetched from the fiam
+ * service
+ *
+ * <p>Operations performed on the cache are thread safe but non atomic.
+ *
+ * @hide
+ */
+@ThreadSafe
+@Singleton
+public class CampaignCacheClient {
+  private final ProtoStorageClient storageClient;
+  private final Application application;
+  private final Clock clock;
+  @Nullable private FetchEligibleCampaignsResponse cachedResponse;
+
+  @Inject
+  CampaignCacheClient(
+      @CampaignCache ProtoStorageClient storageClient, Application application, Clock clock) {
+    this.storageClient = storageClient;
+    this.application = application;
+    this.clock = clock;
+  }
+
+  /**
+   * Writes the provided {@link FetchEligibleCampaignsResponse} to file storage and caches it in
+   * memory.
+   *
+   * @param fetchEligibleCampaignsResponse
+   * @return
+   */
+  public Completable put(FetchEligibleCampaignsResponse fetchEligibleCampaignsResponse) {
+    return storageClient
+        .write(fetchEligibleCampaignsResponse)
+        .doOnComplete(() -> cachedResponse = fetchEligibleCampaignsResponse);
+  }
+
+  /**
+   * Gets the last cached campaign response
+   *
+   * <p>Returns {@link Maybe#empty()} if any of the following are true
+   *
+   * <ul>
+   *   <li>If the storage client returns {@link Maybe#empty()}.
+   *   <li>If the ttl on the cached proto is set and has expired.
+   *   <li>If the ttl on the cached proto is not set and the proto file is older than 1 {@link
+   *       TimeUnit#DAYS}.
+   * </ul>
+   *
+   * @return
+   */
+  public Maybe<FetchEligibleCampaignsResponse> get() {
+    Maybe<FetchEligibleCampaignsResponse> readFromCache = Maybe.fromCallable(() -> cachedResponse);
+    Maybe<FetchEligibleCampaignsResponse> readFromStorage =
+        storageClient
+            .read(FetchEligibleCampaignsResponse.parser())
+            .doOnSuccess(response -> cachedResponse = response);
+    return readFromCache
+        .switchIfEmpty(readFromStorage)
+        .filter(this::isResponseValid)
+        .doOnError(s -> cachedResponse = null);
+  }
+
+  private boolean isResponseValid(FetchEligibleCampaignsResponse response) {
+    long expirationTimestamp = response.getExpirationEpochTimestampMillis();
+    long currentTime = clock.now();
+
+    File file =
+        new File(
+            application.getApplicationContext().getFilesDir(),
+            ProtoStorageClientModule.CAMPAIGN_CACHE_FILE);
+
+    if (expirationTimestamp != 0) {
+      return currentTime < expirationTimestamp;
+    }
+
+    if (file.exists()) {
+      return currentTime < (file.lastModified() + TimeUnit.DAYS.toMillis(1));
+    }
+    return true;
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/DataCollectionHelper.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/DataCollectionHelper.java
new file mode 100644
index 000000000..4aef42f30
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/DataCollectionHelper.java
@@ -0,0 +1,135 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.firebase.DataCollectionDefaultChange;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.events.Subscriber;
+import com.google.firebase.iid.FirebaseInstanceId;
+import java.util.concurrent.atomic.AtomicBoolean;
+import javax.inject.Inject;
+
+/**
+ * Determines whether auto-initialization of app instance ids and data collection are enabled.
+ * Exposes methods to enable/disable the data collection, and stores this across app restarts
+ *
+ * @hide
+ */
+public class DataCollectionHelper {
+
+  @VisibleForTesting
+  static final String MANIFEST_METADATA_AUTO_INIT_ENABLED =
+      "firebase_inapp_messaging_auto_data_collection_enabled";
+
+  @VisibleForTesting static final String AUTO_INIT_PREFERENCES = "auto_init";
+
+  private SharedPreferencesUtils sharedPreferencesUtils;
+  private AtomicBoolean isGlobalAutomaticDataCollectionEnabled;
+
+  @Inject
+  public DataCollectionHelper(
+      FirebaseApp firebaseApp,
+      SharedPreferencesUtils sharedPreferencesUtils,
+      FirebaseInstanceId firebaseInstanceId,
+      Subscriber firebaseEventsSubscriber) {
+    this.sharedPreferencesUtils = sharedPreferencesUtils;
+    isGlobalAutomaticDataCollectionEnabled =
+        new AtomicBoolean(firebaseApp.isDataCollectionDefaultEnabled());
+    if (isAutomaticDataCollectionEnabled()) {
+      // Trigger this as early as possible, to minimize any latencies on returning the token
+      firebaseInstanceId.getToken();
+    }
+
+    firebaseEventsSubscriber.subscribe(
+        DataCollectionDefaultChange.class,
+        event -> {
+          // We don't need to store this value - on re-initialization, we always get the 'current'
+          // state
+          // off the firebaseApp
+          DataCollectionDefaultChange change = event.getPayload();
+          isGlobalAutomaticDataCollectionEnabled.set(change.enabled);
+        });
+  }
+
+  /**
+   * Determine whether automatic data collection is enabled or not
+   *
+   * @return true if auto initialization is required
+   */
+  public boolean isAutomaticDataCollectionEnabled() {
+
+    // We follow this order of precedence:
+    // P0 - the manual override in shared prefs
+    // P1 - the product-level manifest override
+    // P2 - the global-level value
+
+    if (isProductManuallySet()) {
+      return sharedPreferencesUtils.getBooleanPreference(AUTO_INIT_PREFERENCES, true);
+    }
+    if (isProductManifestSet()) {
+      return sharedPreferencesUtils.getBooleanManifestValue(
+          MANIFEST_METADATA_AUTO_INIT_ENABLED, true);
+    }
+    return isGlobalAutomaticDataCollectionEnabled.get();
+  }
+
+  /**
+   * Enable or disable automatic data collection for Firebase In App Messaging.
+   *
+   * <p>
+   *
+   * <p>When enabled, generates a registration token on app startup if there is no valid one and
+   * generates a new token when it is deleted (which prevents {@link
+   * com.google.firebase.iid.FirebaseInstanceId#deleteInstanceId} from stopping the periodic sending
+   * of data). This setting is persisted across app restarts and overrides the setting specified in
+   * your manifest.
+   *
+   * <p>
+   *
+   * <p>By default, auto-initialization is enabled. If you need to change the default, (for example,
+   * because you want to prompt the user before generates/refreshes a registration token on app
+   * startup), add to your applications manifest:
+   *
+   * <p>
+   *
+   * <pre>{@code
+   * <meta-data
+   * android:name="firebase_inapp_messaging_auto_data_collection_enabled" android:value="false"
+   * />
+   * }</pre>
+   *
+   * <p>Note, this will require you to manually initialize Firebase In App Messaging, via:
+   * {@code}FirebaseInAppMessaging.getInstance().setEnabled(true){/code}
+   *
+   * @param isEnabled Whether isEnabled
+   */
+  public void setAutomaticDataCollectionEnabled(boolean isEnabled) {
+    // Update SharedPreferences, so that we preserve state across app restarts
+    sharedPreferencesUtils.setBooleanPreference(AUTO_INIT_PREFERENCES, isEnabled);
+  }
+
+  private boolean readAutomaticDataCollectionEnabledFromPreferences() {
+    return sharedPreferencesUtils.getBooleanPreference(AUTO_INIT_PREFERENCES, true);
+  }
+
+  private boolean isProductManuallySet() {
+    return sharedPreferencesUtils.isPreferenceSet(AUTO_INIT_PREFERENCES);
+  }
+
+  private boolean isProductManifestSet() {
+    return sharedPreferencesUtils.isManifestSet(MANIFEST_METADATA_AUTO_INIT_ENABLED);
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/DeveloperListenerManager.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/DeveloperListenerManager.java
new file mode 100644
index 000000000..2530c3180
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/DeveloperListenerManager.java
@@ -0,0 +1,246 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import androidx.annotation.NonNull;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingClickListener;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayErrorListener;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingImpressionListener;
+import com.google.firebase.inappmessaging.model.Action;
+import com.google.firebase.inappmessaging.model.InAppMessage;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Executor;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * A class used to manage and schedule events to registered (ie: developer-defined) or expensive
+ * listeners
+ *
+ * @hide
+ */
+@SuppressWarnings("JavaDoc")
+public class DeveloperListenerManager {
+
+  // We limit to 1 so there is minimial impact to device performance
+  private static final int POOL_SIZE = 1;
+  // Keep alive to minimize chance of having to restart a thread to handle both impression and click
+  private static final int KEEP_ALIVE_TIME_SECONDS = 15;
+  public static DeveloperListenerManager instance = new DeveloperListenerManager();
+  private Map<FirebaseInAppMessagingClickListener, ClicksExecutorAndListener>
+      registeredClickListeners = new HashMap<>();
+  private Map<FirebaseInAppMessagingDisplayErrorListener, ErrorsExecutorAndListener>
+      registeredErrorListeners = new HashMap<>();;
+  private Map<FirebaseInAppMessagingImpressionListener, ImpressionExecutorAndListener>
+      registeredImpressionListeners = new HashMap<>();;
+
+  private static BlockingQueue<Runnable> mCallbackQueue = new LinkedBlockingQueue<>();
+  private static final ThreadPoolExecutor CALLBACK_QUEUE_EXECUTOR =
+      new ThreadPoolExecutor(
+          POOL_SIZE,
+          POOL_SIZE,
+          KEEP_ALIVE_TIME_SECONDS,
+          TimeUnit.SECONDS,
+          mCallbackQueue,
+          new FIAMThreadFactory("EventListeners-"));
+
+  static {
+    CALLBACK_QUEUE_EXECUTOR.allowCoreThreadTimeOut(true);
+  }
+
+  // Used internally by MetricsLoggerClient
+  public void impressionDetected(InAppMessage inAppMessage) {
+    for (ImpressionExecutorAndListener listener : registeredImpressionListeners.values()) {
+      listener
+          .withExecutor(CALLBACK_QUEUE_EXECUTOR)
+          .execute(() -> listener.getListener().impressionDetected(inAppMessage));
+    }
+  }
+
+  public void displayErrorEncountered(
+      InAppMessage inAppMessage,
+      FirebaseInAppMessagingDisplayCallbacks.InAppMessagingErrorReason errorReason) {
+    for (ErrorsExecutorAndListener listener : registeredErrorListeners.values()) {
+      listener
+          .withExecutor(CALLBACK_QUEUE_EXECUTOR)
+          .execute(() -> listener.getListener().displayErrorEncountered(inAppMessage, errorReason));
+    }
+  }
+
+  public void messageClicked(InAppMessage inAppMessage, Action action) {
+    for (ClicksExecutorAndListener listener : registeredClickListeners.values()) {
+      listener
+          .withExecutor(CALLBACK_QUEUE_EXECUTOR)
+          .execute(() -> listener.getListener().messageClicked(inAppMessage, action));
+    }
+  }
+
+  // pass through from FirebaseInAppMessaging public api
+  public void addImpressionListener(FirebaseInAppMessagingImpressionListener impressionListener) {
+    registeredImpressionListeners.put(
+        impressionListener, new ImpressionExecutorAndListener(impressionListener));
+  }
+
+  public void addClickListener(FirebaseInAppMessagingClickListener clickListener) {
+    registeredClickListeners.put(clickListener, new ClicksExecutorAndListener(clickListener));
+  }
+
+  public void addDisplayErrorListener(
+      FirebaseInAppMessagingDisplayErrorListener displayErrorListener) {
+    registeredErrorListeners.put(
+        displayErrorListener, new ErrorsExecutorAndListener(displayErrorListener));
+  }
+
+  // Executed with provided executor
+  public void addImpressionListener(
+      FirebaseInAppMessagingImpressionListener impressionListener, Executor executor) {
+    registeredImpressionListeners.put(
+        impressionListener, new ImpressionExecutorAndListener(impressionListener, executor));
+  }
+
+  public void addClickListener(
+      FirebaseInAppMessagingClickListener clickListener, Executor executor) {
+    registeredClickListeners.put(
+        clickListener, new ClicksExecutorAndListener(clickListener, executor));
+  }
+
+  public void addDisplayErrorListener(
+      FirebaseInAppMessagingDisplayErrorListener displayErrorListener, Executor executor) {
+    registeredErrorListeners.put(
+        displayErrorListener, new ErrorsExecutorAndListener(displayErrorListener, executor));
+  }
+
+  // Removing individual listeners:
+  public void removeImpressionListener(
+      FirebaseInAppMessagingImpressionListener impressionListener) {
+    registeredImpressionListeners.remove(impressionListener);
+  }
+
+  public void removeClickListener(FirebaseInAppMessagingClickListener clickListener) {
+    registeredClickListeners.remove(clickListener);
+  }
+
+  public void removeDisplayErrorListener(
+      FirebaseInAppMessagingDisplayErrorListener displayErrorListener) {
+    registeredErrorListeners.remove(displayErrorListener);
+  }
+
+  /** The thread factory for Storage threads. */
+  static class FIAMThreadFactory implements ThreadFactory {
+    private final AtomicInteger threadNumber = new AtomicInteger(1);
+    private final String mNameSuffix;
+
+    FIAMThreadFactory(@NonNull String suffix) {
+      mNameSuffix = suffix;
+    }
+
+    @SuppressWarnings("ThreadPriorityCheck")
+    @Override
+    public Thread newThread(@NonNull Runnable r) {
+      Thread t = new Thread(r, "FIAM-" + mNameSuffix + threadNumber.getAndIncrement());
+      t.setDaemon(false);
+      t.setPriority(
+          android.os.Process.THREAD_PRIORITY_BACKGROUND
+              + android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE);
+      return t;
+    }
+  }
+
+  private abstract static class ExecutorAndListener<T> {
+
+    private final Executor executor;
+
+    public abstract T getListener();
+
+    public Executor withExecutor(Executor defaultExecutor) {
+      if (executor == null) {
+        return defaultExecutor;
+      }
+      return executor;
+    }
+
+    public ExecutorAndListener(Executor e) {
+      this.executor = e;
+    }
+  }
+
+  private class ImpressionExecutorAndListener
+      extends ExecutorAndListener<FirebaseInAppMessagingImpressionListener> {
+    FirebaseInAppMessagingImpressionListener listener;
+
+    public ImpressionExecutorAndListener(
+        FirebaseInAppMessagingImpressionListener listener, Executor e) {
+      super(e);
+      this.listener = listener;
+    }
+
+    public ImpressionExecutorAndListener(FirebaseInAppMessagingImpressionListener listener) {
+      super(null);
+      this.listener = listener;
+    }
+
+    @Override
+    public FirebaseInAppMessagingImpressionListener getListener() {
+      return listener;
+    }
+  }
+
+  private class ClicksExecutorAndListener
+      extends ExecutorAndListener<FirebaseInAppMessagingClickListener> {
+    FirebaseInAppMessagingClickListener listener;
+
+    public ClicksExecutorAndListener(FirebaseInAppMessagingClickListener listener, Executor e) {
+      super(e);
+      this.listener = listener;
+    }
+
+    public ClicksExecutorAndListener(FirebaseInAppMessagingClickListener listener) {
+      super(null);
+      this.listener = listener;
+    }
+
+    @Override
+    public FirebaseInAppMessagingClickListener getListener() {
+      return listener;
+    }
+  }
+
+  private class ErrorsExecutorAndListener
+      extends ExecutorAndListener<FirebaseInAppMessagingDisplayErrorListener> {
+    FirebaseInAppMessagingDisplayErrorListener listener;
+
+    public ErrorsExecutorAndListener(
+        FirebaseInAppMessagingDisplayErrorListener listener, Executor e) {
+      super(e);
+      this.listener = listener;
+    }
+
+    public ErrorsExecutorAndListener(FirebaseInAppMessagingDisplayErrorListener listener) {
+      super(null);
+      this.listener = listener;
+    }
+
+    @Override
+    public FirebaseInAppMessagingDisplayErrorListener getListener() {
+      return listener;
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/DisplayCallbacksFactory.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/DisplayCallbacksFactory.java
new file mode 100644
index 000000000..911c4b67d
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/DisplayCallbacksFactory.java
@@ -0,0 +1,70 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks;
+import com.google.firebase.inappmessaging.internal.injection.qualifiers.AppForeground;
+import com.google.firebase.inappmessaging.internal.time.Clock;
+import com.google.firebase.inappmessaging.model.InAppMessage;
+import com.google.firebase.inappmessaging.model.RateLimit;
+import javax.inject.Inject;
+
+public class DisplayCallbacksFactory {
+
+  private final ImpressionStorageClient impressionStorageClient;
+  private final Clock clock;
+  private final Schedulers schedulers;
+  private final RateLimiterClient rateLimiterClient;
+  private final CampaignCacheClient campaignCacheClient;
+  private final RateLimit appForegroundRateLimit;
+  private final MetricsLoggerClient metricsLoggerClient;
+  private final DataCollectionHelper dataCollectionHelper;
+
+  @Inject
+  public DisplayCallbacksFactory(
+      ImpressionStorageClient impressionStorageClient,
+      Clock clock,
+      Schedulers schedulers,
+      RateLimiterClient rateLimiterClient,
+      CampaignCacheClient campaignCacheClient,
+      @AppForeground RateLimit appForegroundRateLimit,
+      MetricsLoggerClient metricsLoggerClient,
+      DataCollectionHelper dataCollectionHelper) {
+    this.impressionStorageClient = impressionStorageClient;
+    this.clock = clock;
+    this.schedulers = schedulers;
+    this.rateLimiterClient = rateLimiterClient;
+    this.campaignCacheClient = campaignCacheClient;
+    this.appForegroundRateLimit = appForegroundRateLimit;
+    this.metricsLoggerClient = metricsLoggerClient;
+    this.dataCollectionHelper = dataCollectionHelper;
+  }
+
+  public FirebaseInAppMessagingDisplayCallbacks generateDisplayCallback(
+      InAppMessage inAppMessage, String triggeringEvent) {
+
+    return new DisplayCallbacksImpl(
+        impressionStorageClient,
+        clock,
+        schedulers,
+        rateLimiterClient,
+        campaignCacheClient,
+        appForegroundRateLimit,
+        metricsLoggerClient,
+        dataCollectionHelper,
+        inAppMessage,
+        triggeringEvent);
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/DisplayCallbacksImpl.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/DisplayCallbacksImpl.java
new file mode 100644
index 000000000..90e0153a8
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/DisplayCallbacksImpl.java
@@ -0,0 +1,290 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import android.text.TextUtils;
+import com.google.android.gms.common.util.VisibleForTesting;
+import com.google.android.gms.tasks.Task;
+import com.google.android.gms.tasks.TaskCompletionSource;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks;
+import com.google.firebase.inappmessaging.internal.time.Clock;
+import com.google.firebase.inappmessaging.model.Action;
+import com.google.firebase.inappmessaging.model.InAppMessage;
+import com.google.firebase.inappmessaging.model.RateLimit;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.CampaignImpression;
+import io.reactivex.Completable;
+import io.reactivex.Maybe;
+import io.reactivex.Scheduler;
+import io.reactivex.disposables.Disposable;
+
+public class DisplayCallbacksImpl implements FirebaseInAppMessagingDisplayCallbacks {
+
+  private final ImpressionStorageClient impressionStorageClient;
+  private final Clock clock;
+  private final Schedulers schedulers;
+  private final RateLimiterClient rateLimiterClient;
+  private final CampaignCacheClient campaignCacheClient;
+  private final RateLimit appForegroundRateLimit;
+  private final MetricsLoggerClient metricsLoggerClient;
+  private final DataCollectionHelper dataCollectionHelper;
+  private final InAppMessage inAppMessage;
+  private final String triggeringEvent;
+
+  private static boolean wasImpressed;
+  private static final String MESSAGE_CLICK = "message click to metrics logger";
+
+  @VisibleForTesting
+  DisplayCallbacksImpl(
+      ImpressionStorageClient impressionStorageClient,
+      Clock clock,
+      Schedulers schedulers,
+      RateLimiterClient rateLimiterClient,
+      CampaignCacheClient campaignCacheClient,
+      RateLimit appForegroundRateLimit,
+      MetricsLoggerClient metricsLoggerClient,
+      DataCollectionHelper dataCollectionHelper,
+      InAppMessage inAppMessage,
+      String triggeringEvent) {
+    this.impressionStorageClient = impressionStorageClient;
+    this.clock = clock;
+    this.schedulers = schedulers;
+    this.rateLimiterClient = rateLimiterClient;
+    this.campaignCacheClient = campaignCacheClient;
+    this.appForegroundRateLimit = appForegroundRateLimit;
+    this.metricsLoggerClient = metricsLoggerClient;
+    this.dataCollectionHelper = dataCollectionHelper;
+    this.inAppMessage = inAppMessage;
+    this.triggeringEvent = triggeringEvent;
+
+    // just to be explicit
+    wasImpressed = false;
+  }
+
+  @Override
+  public Task<Void> impressionDetected() {
+
+    // In the future, when more logAction events are supported, it might be worth
+    // extracting this logic into a manager similar to InAppMessageStreamManager
+    String MESSAGE_IMPRESSION = "message impression to metrics logger";
+
+    if (shouldLog() && !wasImpressed) {
+      Logging.logd("Attempting to record: " + MESSAGE_IMPRESSION);
+
+      Completable logImpressionToMetricsLogger =
+          Completable.fromAction(() -> metricsLoggerClient.logImpression(inAppMessage));
+
+      Completable logImpressionCompletable =
+          logToImpressionStore()
+              .andThen(logImpressionToMetricsLogger)
+              .andThen(updateWasImpressed());
+
+      return maybeToTask(logImpressionCompletable.toMaybe(), schedulers.io());
+    }
+    logActionNotTaken(MESSAGE_IMPRESSION);
+    return new TaskCompletionSource<Void>().getTask();
+  }
+
+  private Completable updateWasImpressed() {
+    return Completable.fromAction(() -> wasImpressed = true);
+  }
+
+  @Override
+  public Task<Void> messageDismissed(InAppMessagingDismissType dismissType) {
+
+    /**
+     * NOTE: While the api is passing us the campaign id via the FIAM, we pull the campaignId from
+     * the cache to ensure that we're only logging events for campaigns that we've fetched - to
+     * avoid implicitly trusting an id that is provided through the app
+     */
+    String MESSAGE_DISMISSAL = "message dismissal to metrics logger";
+    if (shouldLog()) {
+      Logging.logd("Attempting to record: " + MESSAGE_DISMISSAL);
+      Completable completable =
+          Completable.fromAction(() -> metricsLoggerClient.logDismiss(inAppMessage, dismissType));
+
+      return logImpressionIfNeeded(completable);
+    }
+    logActionNotTaken(MESSAGE_DISMISSAL);
+    return new TaskCompletionSource<Void>().getTask();
+  }
+
+  @Deprecated
+  public Task<Void> messageClicked() {
+    return messageClicked(inAppMessage.getAction());
+  }
+
+  @Override
+  public Task<Void> messageClicked(Action action) {
+
+    /**
+     * NOTE: While the api is passing us the campaign id via the FIAM, we pul the campaignId from
+     * the cache to ensure that we're only logging events for campaigns that we've fetched - to
+     * avoid implicitly trusting an id that is provided through the app
+     */
+    if (shouldLog()) {
+      if (action.getActionUrl() == null) {
+        return messageDismissed(InAppMessagingDismissType.CLICK);
+      }
+      return logMessageClick(action);
+    }
+    logActionNotTaken(MESSAGE_CLICK);
+    return new TaskCompletionSource<Void>().getTask();
+  }
+
+  private Task<Void> logMessageClick(Action action) {
+
+    Logging.logd("Attempting to record: " + MESSAGE_CLICK);
+    Completable completable =
+        Completable.fromAction(() -> metricsLoggerClient.logMessageClick(inAppMessage, action));
+
+    return logImpressionIfNeeded(completable);
+  }
+
+  private boolean actionMatches(Action messageAction, Action actionTaken) {
+    if (messageAction == null) {
+      return actionTaken == null || TextUtils.isEmpty(actionTaken.getActionUrl());
+    } else {
+      return messageAction.getActionUrl().equals(actionTaken.getActionUrl());
+    }
+  }
+
+  @Override
+  public Task<Void> displayErrorEncountered(InAppMessagingErrorReason errorReason) {
+    /**
+     * NOTE: While the api is passing us the campaign id via the FIAM, we pull the campaignId from
+     * the cache to ensure that we're only logging events for campaigns that we've fetched - to
+     * avoid implicitly trusting an id that is provided through the app
+     */
+    String RENDER_ERROR = "render error to metrics logger";
+    if (shouldLog()) {
+      Logging.logd("Attempting to record: " + RENDER_ERROR);
+
+      Completable completable =
+          Completable.fromAction(
+              () -> metricsLoggerClient.logRenderError(inAppMessage, errorReason));
+
+      return maybeToTask(
+          logToImpressionStore().andThen(completable).andThen(updateWasImpressed()).toMaybe(),
+          schedulers.io());
+    }
+    logActionNotTaken(RENDER_ERROR);
+    return new TaskCompletionSource<Void>().getTask();
+  }
+
+  /** We should log if data collection is enabled and the message is not a test message. */
+  private boolean shouldLog() {
+    return dataCollectionHelper.isAutomaticDataCollectionEnabled();
+  }
+
+  private Task<Void> logImpressionIfNeeded(Completable actionToTake) {
+    if (!wasImpressed) {
+      impressionDetected();
+    }
+
+    return maybeToTask(actionToTake.toMaybe(), schedulers.io());
+  }
+
+  /**
+   * Logging to clarify why an action was not taken. For example why an impression was not logged.
+   * TODO: Refactor this to be a function wrapper.
+   *
+   * @hide
+   */
+  private void logActionNotTaken(String action, Maybe<String> reason) {
+    // If provided a reason then use that.
+    if (reason != null) {
+      Logging.logd(String.format("Not recording: %s. Reason: %s", action, reason));
+    }
+    // If a reason is not provided then check for a test message.
+    else if (inAppMessage.getIsTestMessage()) {
+      Logging.logd(String.format("Not recording: %s. Reason: Message is test message", action));
+    }
+    // If no reason and not a test message check for data collection being disabled.
+    else if (!dataCollectionHelper.isAutomaticDataCollectionEnabled()) {
+      Logging.logd(String.format("Not recording: %s. Reason: Data collection is disabled", action));
+    }
+    // This should never happen.
+    else Logging.logd(String.format("Not recording: %s", action));
+  }
+
+  private void logActionNotTaken(String action) {
+    logActionNotTaken(action, null);
+  }
+
+  private Completable logToImpressionStore() {
+    Logging.logd("Attempting to record: message impression in impression store");
+    String campaignId = inAppMessage.getCampaignId();
+
+    Completable storeCampaignImpression =
+        impressionStorageClient
+            .storeImpression(
+                CampaignImpression.newBuilder()
+                    .setImpressionTimestampMillis(clock.now())
+                    .setCampaignId(campaignId)
+                    .build())
+            .doOnError(e -> Logging.loge("Impression store write failure"))
+            .doOnComplete(() -> Logging.logd("Impression store write success"));
+
+    if (InAppMessageStreamManager.isAppForegroundEvent(triggeringEvent)) {
+      Completable incrementAppForegroundRateLimit =
+          rateLimiterClient
+              .increment(appForegroundRateLimit)
+              .doOnError(e -> Logging.loge("Rate limiter client write failure"))
+              .doOnComplete(() -> Logging.logd("Rate limiter client write success"))
+              .onErrorComplete(); // Absorb rate limiter write errors
+      return incrementAppForegroundRateLimit.andThen(storeCampaignImpression);
+    }
+
+    return storeCampaignImpression;
+  }
+
+  /**
+   * Converts an rx maybe to task.
+   *
+   * <p>Since the semantics of maybe are different from task, we adopt the following rules.
+   *
+   * <ul>
+   *   <li>Maybe that resolves to a value is resolved to a succeeding task
+   *   <li>Maybe that resolves to an exception is resolved to a failed task
+   *   <li>Maybe that resolves to an error is resolved to a failed task with a wrapped exception
+   *   <li>Maybe that resolves to empty is resolved to succeeding Void Task
+   * </ul>
+   */
+  private static <T> Task<T> maybeToTask(Maybe<T> maybe, Scheduler scheduler) {
+    TaskCompletionSource<T> tcs = new TaskCompletionSource<>();
+    Disposable ignoredDisposable =
+        maybe
+            .doOnSuccess(tcs::setResult)
+            .switchIfEmpty(
+                Maybe.fromCallable(
+                    () -> {
+                      tcs.setResult(null);
+                      return null;
+                    }))
+            .onErrorResumeNext(
+                throwable -> {
+                  if (throwable instanceof Exception) {
+                    tcs.setException((Exception) throwable);
+                  } else {
+                    tcs.setException(new RuntimeException(throwable));
+                  }
+                  return Maybe.empty();
+                })
+            .subscribeOn(scheduler)
+            .subscribe();
+
+    return tcs.getTask();
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/FiamAnalyticsConnectorListener.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/FiamAnalyticsConnectorListener.java
new file mode 100644
index 000000000..736c9e7c3
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/FiamAnalyticsConnectorListener.java
@@ -0,0 +1,39 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import android.os.Bundle;
+import com.google.firebase.analytics.connector.AnalyticsConnector.AnalyticsConnectorListener;
+import io.reactivex.FlowableEmitter;
+
+/**
+ * Fiam specific implementation of the AnalyticsConnectorListener.
+ *
+ * @hide
+ */
+final class FiamAnalyticsConnectorListener implements AnalyticsConnectorListener {
+  private FlowableEmitter<String> emitter;
+
+  FiamAnalyticsConnectorListener(FlowableEmitter<String> emitter) {
+    this.emitter = emitter;
+  }
+
+  @Override
+  public void onMessageTriggered(int id, Bundle extras) {
+    if (id == AnalyticsConstants.FIAM_ANALYTICS_CONNECTOR_LISTENER_EVENT_ID) {
+      emitter.onNext(extras.getString("events"));
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ForegroundNotifier.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ForegroundNotifier.java
new file mode 100644
index 000000000..f7ba75e51
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ForegroundNotifier.java
@@ -0,0 +1,119 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import android.app.Activity;
+import android.app.Application;
+import android.os.Bundle;
+import android.os.Handler;
+
+/**
+ * The {@link ForegroundNotifier} notifies listeners set via {@link #setListener(Listener)} when an
+ * application comes to the foreground.
+ *
+ * <p>This class is necessary because we are unable to use Android architecture components. See
+ * discussion in cl/172370669
+ *
+ * <p>Supported foreground scenarios
+ *
+ * <ul>
+ *   <li>App resumed phone screen is unlocked
+ *   <li>App starts when app icon is clicked
+ *   <li>App resumes aftercompletion of phone call
+ *   <li>App is chosen from recent apps menu
+ * </ul>
+ *
+ * <p>This works as follows
+ *
+ * <ul>
+ *   <li>When an app is foregrounded for the first time after app icon is clicked, it is moved to
+ *       the foreground state and listener is notified
+ *   <li>When any activity in the app is paused and {@link #onActivityPaused(Activity)} callback is
+ *       received, the app is considered to be paused until the next activity starts and the {@link
+ *       #onActivityResumed(Activity)} callback is received. A runnable is simultaneously scheduled
+ *       to be run after a {@link #DELAY_MILLIS} which will put the app into background state.
+ *   <li>If some other activity subsequently starts and beats execution of the runnable by invoking
+ *       the {@link #onActivityResumed(Activity)}, the app never went out of view for the user and
+ *       is considered to have never gone to the background. The runnable is removed and the app
+ *       remains in the foreground.
+ *   <li>Similar to the first step, listener is notified in the {@link #onActivityResumed(Activity)}
+ *       callback if the app was deemed to be in the background</>
+ * </ul>
+ *
+ * @hide
+ */
+public class ForegroundNotifier implements Application.ActivityLifecycleCallbacks {
+  public static final long DELAY_MILLIS = 1000;
+  private final Handler handler = new Handler();
+  private boolean foreground = false, paused = true;
+  private Listener listener;
+  private Runnable check;
+
+  public void setListener(Listener listener) {
+    this.listener = listener;
+  }
+
+  public void removeListener(Listener listener) {
+    this.listener = null;
+  }
+
+  @Override
+  public void onActivityResumed(Activity activity) {
+    paused = false;
+    boolean wasBackground = !foreground;
+    foreground = true;
+
+    if (check != null) {
+      handler.removeCallbacks(check);
+    }
+
+    if (wasBackground) {
+      Logging.logi("went foreground");
+      listener.onForeground();
+    }
+  }
+
+  @Override
+  public void onActivityPaused(Activity activity) {
+    paused = true;
+
+    if (check != null) {
+      handler.removeCallbacks(check);
+    }
+
+    handler.postDelayed(
+        check = () -> foreground = (foreground && paused) ? false : foreground, DELAY_MILLIS);
+  }
+
+  @Override
+  public void onActivityCreated(Activity activity, Bundle savedInstanceState) {}
+
+  @Override
+  public void onActivityStarted(Activity activity) {}
+
+  @Override
+  public void onActivityStopped(Activity activity) {}
+
+  @Override
+  public void onActivitySaveInstanceState(Activity activity, Bundle outState) {}
+
+  @Override
+  public void onActivityDestroyed(Activity activity) {}
+
+  /** Listener to receive callbacks when app comes to the foreground */
+  public interface Listener {
+    void onForeground();
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/GrpcClient.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/GrpcClient.java
new file mode 100644
index 000000000..93d1cc986
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/GrpcClient.java
@@ -0,0 +1,40 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import com.google.firebase.inappmessaging.internal.injection.scopes.FirebaseAppScope;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsRequest;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsResponse;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.InAppMessagingSdkServingGrpc.InAppMessagingSdkServingBlockingStub;
+import javax.inject.Inject;
+
+/**
+ * Wrapper for rpc calls to the fiam backend
+ *
+ * @hide
+ */
+@FirebaseAppScope
+public class GrpcClient {
+  private final InAppMessagingSdkServingBlockingStub stub;
+
+  @Inject
+  GrpcClient(InAppMessagingSdkServingBlockingStub stub) {
+    this.stub = stub;
+  }
+
+  public FetchEligibleCampaignsResponse fetchEligibleCampaigns(FetchEligibleCampaignsRequest req) {
+    return stub.fetchEligibleCampaigns(req);
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ImpressionStorageClient.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ImpressionStorageClient.java
new file mode 100644
index 000000000..c5f94689c
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ImpressionStorageClient.java
@@ -0,0 +1,94 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import com.google.firebase.inappmessaging.internal.injection.qualifiers.ImpressionStore;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.CampaignImpression;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.CampaignImpressionList;
+import io.reactivex.Completable;
+import io.reactivex.Maybe;
+import io.reactivex.Observable;
+import io.reactivex.Single;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+/**
+ * Class to store and retrieve in app message impressions
+ *
+ * @hide
+ */
+@Singleton
+public class ImpressionStorageClient {
+  private static final CampaignImpressionList EMPTY_IMPRESSIONS =
+      CampaignImpressionList.getDefaultInstance();
+  private final ProtoStorageClient storageClient;
+  private Maybe<CampaignImpressionList> cachedImpressionsMaybe = Maybe.empty();
+
+  @Inject
+  ImpressionStorageClient(@ImpressionStore ProtoStorageClient storageClient) {
+    this.storageClient = storageClient;
+  }
+
+  private static CampaignImpressionList appendImpression(
+      CampaignImpressionList campaignImpressions, CampaignImpression impression) {
+    return CampaignImpressionList.newBuilder(campaignImpressions)
+        .addAlreadySeenCampaigns(impression)
+        .build();
+  }
+
+  /** Stores the provided {@link CampaignImpression} to file storage */
+  public Completable storeImpression(CampaignImpression impression) {
+    return getAllImpressions()
+        .defaultIfEmpty(EMPTY_IMPRESSIONS)
+        .flatMapCompletable(
+            storedImpressions -> {
+              CampaignImpressionList appendedImpressions =
+                  appendImpression(storedImpressions, impression);
+              return storageClient
+                  .write(appendedImpressions)
+                  .doOnComplete(() -> initInMemCache(appendedImpressions));
+            });
+  }
+
+  /**
+   * Returns the list of impressed campaigns
+   *
+   * <p>Returns {@link Maybe#empty()} if no campaigns have ever been impressed or if the storage was
+   * corrupt.
+   */
+  public Maybe<CampaignImpressionList> getAllImpressions() {
+    return cachedImpressionsMaybe
+        .switchIfEmpty(
+            storageClient.read(CampaignImpressionList.parser()).doOnSuccess(this::initInMemCache))
+        .doOnError(ignored -> clearInMemCache());
+  }
+
+  private void initInMemCache(CampaignImpressionList campaignImpressions) {
+    cachedImpressionsMaybe = Maybe.just(campaignImpressions);
+  }
+
+  private void clearInMemCache() {
+    cachedImpressionsMaybe = Maybe.empty();
+  }
+
+  /** Returns {@code Single.just(true)} if the campaign has been impressed */
+  public Single<Boolean> isImpressed(String campaignId) {
+    return getAllImpressions()
+        .map(CampaignImpressionList::getAlreadySeenCampaignsList)
+        .flatMapObservable(Observable::fromIterable)
+        .map(CampaignImpression::getCampaignId)
+        .contains(campaignId);
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/InAppMessageStreamManager.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/InAppMessageStreamManager.java
new file mode 100644
index 000000000..67d99f039
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/InAppMessageStreamManager.java
@@ -0,0 +1,317 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import com.google.firebase.inappmessaging.CommonTypesProto.TriggeringCondition;
+import com.google.firebase.inappmessaging.internal.injection.qualifiers.AppForeground;
+import com.google.firebase.inappmessaging.internal.injection.qualifiers.ProgrammaticTrigger;
+import com.google.firebase.inappmessaging.internal.injection.scopes.FirebaseAppScope;
+import com.google.firebase.inappmessaging.internal.time.Clock;
+import com.google.firebase.inappmessaging.model.InAppMessage;
+import com.google.firebase.inappmessaging.model.MessageType;
+import com.google.firebase.inappmessaging.model.ProtoMarshallerClient;
+import com.google.firebase.inappmessaging.model.RateLimit;
+import com.google.firebase.inappmessaging.model.TriggeredInAppMessage;
+import com.google.internal.firebase.inappmessaging.v1.CampaignProto.ThickContent;
+import com.google.internal.firebase.inappmessaging.v1.CampaignProto.VanillaCampaignPayload;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.CampaignImpressionList;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsResponse;
+import io.reactivex.Completable;
+import io.reactivex.Flowable;
+import io.reactivex.Maybe;
+import io.reactivex.Single;
+import io.reactivex.flowables.ConnectableFlowable;
+import io.reactivex.functions.Consumer;
+import io.reactivex.functions.Function;
+import java.util.Locale;
+import javax.inject.Inject;
+
+/**
+ * Class to federate multiple clients and encapsulate the high level behavior of the fiam headless
+ * sdk
+ *
+ * @hide
+ */
+@FirebaseAppScope
+public class InAppMessageStreamManager {
+  public static final String ON_FOREGROUND = "ON_FOREGROUND";
+  private final ConnectableFlowable<String> appForegroundEventFlowable;
+  private final ConnectableFlowable<String> programmaticTriggerEventFlowable;
+  private final CampaignCacheClient campaignCacheClient;
+  private final Clock clock;
+  private final ApiClient apiClient;
+  private final Schedulers schedulers;
+  private final ImpressionStorageClient impressionStorageClient;
+  private final RateLimiterClient rateLimiterClient;
+  private final RateLimit appForegroundRateLimit;
+  private final AnalyticsEventsManager analyticsEventsManager;
+  private final TestDeviceHelper testDeviceHelper;
+
+  @Inject
+  public InAppMessageStreamManager(
+      @AppForeground ConnectableFlowable<String> appForegroundEventFlowable,
+      @ProgrammaticTrigger ConnectableFlowable<String> programmaticTriggerEventFlowable,
+      CampaignCacheClient campaignCacheClient,
+      Clock clock,
+      ApiClient apiClient,
+      AnalyticsEventsManager analyticsEventsManager,
+      Schedulers schedulers,
+      ImpressionStorageClient impressionStorageClient,
+      RateLimiterClient rateLimiterClient,
+      @AppForeground RateLimit appForegroundRateLimit,
+      TestDeviceHelper testDeviceHelper) {
+    this.appForegroundEventFlowable = appForegroundEventFlowable;
+    this.programmaticTriggerEventFlowable = programmaticTriggerEventFlowable;
+    this.campaignCacheClient = campaignCacheClient;
+    this.clock = clock;
+    this.apiClient = apiClient;
+    this.analyticsEventsManager = analyticsEventsManager;
+    this.schedulers = schedulers;
+    this.impressionStorageClient = impressionStorageClient;
+    this.rateLimiterClient = rateLimiterClient;
+    this.appForegroundRateLimit = appForegroundRateLimit;
+    this.testDeviceHelper = testDeviceHelper;
+  }
+
+  private static boolean containsTriggeringCondition(String event, ThickContent content) {
+    if (isAppForegroundEvent(event) && content.getIsTestCampaign()) {
+      return true; // the triggering condition for test campaigns is always 'app foreground'
+    }
+    for (TriggeringCondition condition : content.getTriggeringConditionsList()) {
+      if (hasFiamTrigger(condition, event) || hasAnalyticsTrigger(condition, event)) {
+        Logging.logd(String.format("The event %s is contained in the list of triggers", event));
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private static boolean hasFiamTrigger(TriggeringCondition tc, String event) {
+    return tc.getFiamTrigger() != null && tc.getFiamTrigger().toString().equals(event);
+  }
+
+  private static boolean hasAnalyticsTrigger(TriggeringCondition tc, String event) {
+    return tc.getContextualTrigger() != null
+        && tc.getContextualTrigger().getName().toString().equals(event);
+  }
+
+  private static boolean isActive(Clock clock, VanillaCampaignPayload vanillaPayload) {
+    long campaignStartTime = vanillaPayload.getCampaignStartTimeMillis();
+    long campaignEndTime = vanillaPayload.getCampaignEndTimeMillis();
+    long currentTime = clock.now();
+
+    return currentTime > campaignStartTime && currentTime < campaignEndTime;
+  }
+
+  // Comparisons treat the numeric values of priorities like they were ranks i.e lower is better.
+  // If one campaign is a test campaign it is of higher priority.
+  // Example: P1 > P2. P2(test) > P1. P1(test) > P2(test)
+  private static int compareByPriority(ThickContent content1, ThickContent content2) {
+    if (content1.getIsTestCampaign() && !content2.getIsTestCampaign()) {
+      return -1;
+    }
+    if (content2.getIsTestCampaign() && !content1.getIsTestCampaign()) {
+      return 1;
+    }
+    return Integer.compare(content1.getPriority().getValue(), content2.getPriority().getValue());
+  }
+
+  public static boolean isAppForegroundEvent(TriggeringCondition event) {
+    return event.getFiamTrigger() != null
+        && event.getFiamTrigger().toString().equals(ON_FOREGROUND);
+  }
+
+  public static boolean isAppForegroundEvent(String event) {
+    return event.equals(ON_FOREGROUND);
+  }
+
+  private boolean shouldIgnoreCache(String event) {
+    if (testDeviceHelper.isAppInstallFresh()) {
+      return isAppForegroundEvent(event);
+    }
+    return testDeviceHelper.isDeviceInTestMode();
+  }
+
+  public Flowable<TriggeredInAppMessage> createFirebaseInAppMessageStream() {
+    return Flowable.merge(
+            appForegroundEventFlowable,
+            analyticsEventsManager.getAnalyticsEventsFlowable(),
+            programmaticTriggerEventFlowable)
+        .doOnNext(e -> Logging.logd("Event Triggered: " + e.toString()))
+        .observeOn(schedulers.io())
+        .concatMap(
+            event -> {
+              Maybe<FetchEligibleCampaignsResponse> cacheRead =
+                  campaignCacheClient
+                      .get()
+                      .doOnSuccess(r -> Logging.logd("Fetched from cache"))
+                      .doOnError(e -> Logging.logw("Cache read error: " + e.getMessage()))
+                      .onErrorResumeNext(Maybe.empty()); // Absorb cache read failures
+
+              Consumer<FetchEligibleCampaignsResponse> cacheWrite =
+                  response ->
+                      campaignCacheClient
+                          .put(response)
+                          .doOnComplete(() -> Logging.logd("Wrote to cache"))
+                          .doOnError(e -> Logging.logw("Cache write error: " + e.getMessage()))
+                          .onErrorResumeNext(
+                              ignored -> Completable.complete()) // Absorb cache write fails
+                          .subscribe();
+
+              Function<ThickContent, Maybe<ThickContent>> filterAlreadyImpressed =
+                  content ->
+                      content.getIsTestCampaign()
+                          ? Maybe.just(content)
+                          : impressionStorageClient
+                              .isImpressed(content.getVanillaPayload().getCampaignId())
+                              .doOnError(
+                                  e ->
+                                      Logging.logw("Impression store read fail: " + e.getMessage()))
+                              .onErrorResumeNext(
+                                  Single.just(false)) // Absorb impression read errors
+                              .doOnSuccess(
+                                  isImpressed ->
+                                      Logging.logi(
+                                          String.format(
+                                              "Already impressed %s ? : %s",
+                                              content.getVanillaPayload().getCampaignName(),
+                                              isImpressed)))
+                              .filter(isImpressed -> !isImpressed)
+                              .map(isImpressed -> content);
+
+              Function<ThickContent, Maybe<ThickContent>> appForegroundRateLimitFilter =
+                  content -> getContentIfNotRateLimited(event, content);
+
+              Function<ThickContent, Maybe<ThickContent>> filterDisplayable =
+                  thickContent -> {
+                    switch (thickContent.getContent().getMessageDetailsCase()) {
+                      case BANNER:
+                        return Maybe.just(thickContent);
+                      case IMAGE_ONLY:
+                        return Maybe.just(thickContent);
+                      case MODAL:
+                        return Maybe.just(thickContent);
+                      case CARD:
+                        return Maybe.just(thickContent);
+                      default:
+                        return Maybe.empty();
+                    }
+                  };
+
+              Function<FetchEligibleCampaignsResponse, Maybe<TriggeredInAppMessage>>
+                  selectThickContent =
+                      response ->
+                          getTriggeredInAppMessageMaybe(
+                              event,
+                              filterAlreadyImpressed,
+                              appForegroundRateLimitFilter,
+                              filterDisplayable,
+                              response);
+
+              Maybe<CampaignImpressionList> alreadySeenCampaigns =
+                  impressionStorageClient
+                      .getAllImpressions()
+                      .doOnError(
+                          e -> Logging.logw("Impressions store read fail: " + e.getMessage()))
+                      .defaultIfEmpty(CampaignImpressionList.getDefaultInstance())
+                      .onErrorResumeNext(Maybe.just(CampaignImpressionList.getDefaultInstance()));
+
+              Function<CampaignImpressionList, Maybe<FetchEligibleCampaignsResponse>> serviceFetch =
+                  impressions ->
+                      Maybe.fromCallable(() -> apiClient.getFiams(impressions))
+                          .doOnSuccess(
+                              resp ->
+                                  Logging.logi(
+                                      String.format(
+                                          Locale.US,
+                                          "Successfully fetched %d messages from backend",
+                                          resp.getMessagesList().size())))
+                          .doOnSuccess(analyticsEventsManager::updateContextualTriggers)
+                          .doOnSuccess(testDeviceHelper::processCampaignFetch)
+                          .doOnError(e -> Logging.logw("Service fetch error: " + e.getMessage()))
+                          .onErrorResumeNext(Maybe.empty()); // Absorb service failures
+
+              if (shouldIgnoreCache(event)) {
+                Logging.logi(
+                    String.format(
+                        "Forcing fetch from service rather than cache. "
+                            + "Test Device: %s | App Fresh Install: %s",
+                        testDeviceHelper.isDeviceInTestMode(),
+                        testDeviceHelper.isAppInstallFresh()));
+                return alreadySeenCampaigns
+                    .flatMap(serviceFetch)
+                    .flatMap(selectThickContent)
+                    .toFlowable();
+              }
+
+              Logging.logd("Attempting to fetch campaigns using cache");
+              return cacheRead
+                  .switchIfEmpty(alreadySeenCampaigns.flatMap(serviceFetch).doOnSuccess(cacheWrite))
+                  .flatMap(selectThickContent)
+                  .toFlowable();
+            })
+        .observeOn(schedulers.mainThread()); // Updates are delivered on the main thread
+  }
+
+  private Maybe<ThickContent> getContentIfNotRateLimited(String event, ThickContent content) {
+    if (!content.getIsTestCampaign() && isAppForegroundEvent(event)) {
+      return rateLimiterClient
+          .isRateLimited(appForegroundRateLimit)
+          .doOnSuccess(
+              isRateLimited -> Logging.logi("App foreground rate limited ? : " + isRateLimited))
+          .onErrorResumeNext(Single.just(false)) // Absorb rate limit errors
+          .filter(isRateLimited -> !isRateLimited)
+          .map(isRateLimited -> content);
+    }
+    return Maybe.just(content);
+  }
+
+  private Maybe<TriggeredInAppMessage> getTriggeredInAppMessageMaybe(
+      String event,
+      Function<ThickContent, Maybe<ThickContent>> filterAlreadyImpressed,
+      Function<ThickContent, Maybe<ThickContent>> appForegroundRateLimitFilter,
+      Function<ThickContent, Maybe<ThickContent>> filterDisplayable,
+      FetchEligibleCampaignsResponse response) {
+    return Flowable.fromIterable(response.getMessagesList())
+        .filter(
+            content -> content.getPayloadCase().equals(ThickContent.PayloadCase.VANILLA_PAYLOAD))
+        .filter(
+            content ->
+                testDeviceHelper.isDeviceInTestMode()
+                    || isActive(clock, content.getVanillaPayload()))
+        .filter(content -> containsTriggeringCondition(event, content))
+        .flatMapMaybe(filterAlreadyImpressed)
+        .flatMapMaybe(appForegroundRateLimitFilter)
+        .flatMapMaybe(filterDisplayable)
+        .sorted(InAppMessageStreamManager::compareByPriority)
+        .firstElement()
+        .flatMap(content -> triggeredInAppMessage(content, event));
+  }
+
+  private Maybe<TriggeredInAppMessage> triggeredInAppMessage(
+      ThickContent thickContent, String event) {
+    InAppMessage inAppMessage =
+        ProtoMarshallerClient.decode(
+            thickContent.getContent(),
+            thickContent.getVanillaPayload().getCampaignId(),
+            thickContent.getVanillaPayload().getCampaignName(),
+            thickContent.getIsTestCampaign());
+    if (inAppMessage.getMessageType().equals(MessageType.UNSUPPORTED)) {
+      return Maybe.empty();
+    }
+
+    return Maybe.just(new TriggeredInAppMessage(inAppMessage, event));
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/Logging.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/Logging.java
new file mode 100644
index 000000000..cfea48f69
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/Logging.java
@@ -0,0 +1,54 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import android.util.Log;
+import com.google.common.annotations.VisibleForTesting;
+import com.google.firebase.inappmessaging.BuildConfig;
+
+/**
+ * Helper class to facilitate logging. To enable debug logging in production run `adb shell setprop
+ * log.tag.FIAM.Headless DEBUG`
+ *
+ * @hide
+ */
+public class Logging {
+
+  @VisibleForTesting public static final String TAG = "FIAM.Headless";
+
+  /** Log a message if in debug mode or debug is loggable. */
+  public static void logd(String message) {
+    if (BuildConfig.DEBUG || Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(TAG, message);
+    }
+  }
+
+  /** Log info messages if they are loggable. */
+  public static void logi(String message) {
+    if (Log.isLoggable(TAG, Log.INFO)) {
+      Log.i(TAG, message);
+    }
+  }
+
+  /** Log error messages normally but add a consistent TAG */
+  public static void loge(String message) {
+    Log.e(TAG, message);
+  }
+
+  /** Log warning messages normally but add a consistent TAG */
+  public static void logw(String message) {
+    Log.w(TAG, message);
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/MetricsLoggerClient.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/MetricsLoggerClient.java
new file mode 100644
index 000000000..6bea95b58
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/MetricsLoggerClient.java
@@ -0,0 +1,255 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static com.google.firebase.inappmessaging.EventType.CLICK_EVENT_TYPE;
+import static com.google.firebase.inappmessaging.EventType.IMPRESSION_EVENT_TYPE;
+
+import android.os.Bundle;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.inappmessaging.BuildConfig;
+import com.google.firebase.inappmessaging.CampaignAnalytics;
+import com.google.firebase.inappmessaging.ClientAppInfo;
+import com.google.firebase.inappmessaging.DismissType;
+import com.google.firebase.inappmessaging.EventType;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks.InAppMessagingDismissType;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks.InAppMessagingErrorReason;
+import com.google.firebase.inappmessaging.RenderErrorReason;
+import com.google.firebase.inappmessaging.internal.time.Clock;
+import com.google.firebase.inappmessaging.model.Action;
+import com.google.firebase.inappmessaging.model.BannerMessage;
+import com.google.firebase.inappmessaging.model.CardMessage;
+import com.google.firebase.inappmessaging.model.ImageOnlyMessage;
+import com.google.firebase.inappmessaging.model.InAppMessage;
+import com.google.firebase.inappmessaging.model.ModalMessage;
+import java.util.HashMap;
+import java.util.Map;
+import javax.annotation.Nullable;
+
+/**
+ * Class to log actions to engagementMetrics
+ *
+ * @hide
+ */
+public class MetricsLoggerClient {
+  private static final Map<InAppMessagingErrorReason, RenderErrorReason> errorTransform =
+      new HashMap<>();
+  private static final Map<InAppMessagingDismissType, DismissType> dismissTransform =
+      new HashMap<>();
+
+  static {
+    errorTransform.put(
+        InAppMessagingErrorReason.UNSPECIFIED_RENDER_ERROR,
+        RenderErrorReason.UNSPECIFIED_RENDER_ERROR);
+    errorTransform.put(
+        InAppMessagingErrorReason.IMAGE_FETCH_ERROR, RenderErrorReason.IMAGE_FETCH_ERROR);
+    errorTransform.put(
+        InAppMessagingErrorReason.IMAGE_DISPLAY_ERROR, RenderErrorReason.IMAGE_DISPLAY_ERROR);
+    errorTransform.put(
+        InAppMessagingErrorReason.IMAGE_UNSUPPORTED_FORMAT,
+        RenderErrorReason.IMAGE_UNSUPPORTED_FORMAT);
+  }
+
+  static {
+    dismissTransform.put(InAppMessagingDismissType.AUTO, DismissType.AUTO);
+    dismissTransform.put(InAppMessagingDismissType.CLICK, DismissType.CLICK);
+    dismissTransform.put(InAppMessagingDismissType.SWIPE, DismissType.SWIPE);
+    dismissTransform.put(
+        InAppMessagingDismissType.UNKNOWN_DISMISS_TYPE, DismissType.UNKNOWN_DISMISS_TYPE);
+  }
+
+  private final EngagementMetricsLoggerInterface engagementMetricsLogger;
+  private final FirebaseApp firebaseApp;
+  private final FirebaseInstanceId firebaseInstanceId;
+  private final Clock clock;
+  private final AnalyticsConnector analyticsConnector;
+  private final DeveloperListenerManager developerListenerManager;
+
+  public MetricsLoggerClient(
+      EngagementMetricsLoggerInterface engagementMetricsLogger,
+      AnalyticsConnector analyticsConnector,
+      FirebaseApp firebaseApp,
+      FirebaseInstanceId firebaseInstanceId,
+      Clock clock,
+      DeveloperListenerManager developerListenerManager) {
+    this.engagementMetricsLogger = engagementMetricsLogger;
+    this.analyticsConnector = analyticsConnector;
+    this.firebaseApp = firebaseApp;
+    this.firebaseInstanceId = firebaseInstanceId;
+    this.clock = clock;
+    this.developerListenerManager = developerListenerManager;
+  }
+
+  /** Log impression */
+  public void logImpression(InAppMessage message) {
+    if (!isTestCampaign(message)) {
+      // If message is not a test message then log analytics
+      engagementMetricsLogger.logEvent(
+          createEventEntry(message, IMPRESSION_EVENT_TYPE).toByteArray());
+      logEventAsync(
+          message,
+          AnalyticsConstants.ANALYTICS_IMPRESSION_EVENT,
+          impressionCountsAsConversion(message));
+    }
+    // No matter what, always trigger developer callbacks
+    developerListenerManager.impressionDetected(message);
+  }
+
+  /** Log click */
+  public void logMessageClick(InAppMessage message, Action action) {
+    if (!isTestCampaign(message)) {
+      // If message is not a test message then log analytics
+      engagementMetricsLogger.logEvent(createEventEntry(message, CLICK_EVENT_TYPE).toByteArray());
+      logEventAsync(message, AnalyticsConstants.ANALYTICS_ACTION_EVENT, true);
+    }
+    // No matter what, always trigger developer callbacks
+    developerListenerManager.messageClicked(message, action);
+  }
+
+  /** Log Rendering error */
+  public void logRenderError(InAppMessage message, InAppMessagingErrorReason errorReason) {
+    if (!isTestCampaign(message)) {
+      // If message is not a test message then log analytics
+      engagementMetricsLogger.logEvent(
+          createRenderErrorEntry(message, errorTransform.get(errorReason)).toByteArray());
+    }
+    // No matter what, always trigger developer callbacks
+    developerListenerManager.displayErrorEncountered(message, errorReason);
+  }
+
+  /** Log dismiss */
+  public void logDismiss(InAppMessage message, InAppMessagingDismissType dismissType) {
+    if (!isTestCampaign(message)) {
+      // If message is not a test message then log analytics
+      engagementMetricsLogger.logEvent(
+          createDismissEntry(message, dismissTransform.get(dismissType)).toByteArray());
+      logEventAsync(message, AnalyticsConstants.ANALYTICS_DISMISS_EVENT, false);
+    }
+  }
+
+  private CampaignAnalytics createEventEntry(InAppMessage message, EventType eventType) {
+    return createCampaignAnalyticsBuilder(message).setEventType(eventType).build();
+  }
+
+  private CampaignAnalytics createDismissEntry(InAppMessage message, DismissType dismissType) {
+    return createCampaignAnalyticsBuilder(message).setDismissType(dismissType).build();
+  }
+
+  private CampaignAnalytics createRenderErrorEntry(InAppMessage message, RenderErrorReason reason) {
+    return createCampaignAnalyticsBuilder(message).setRenderErrorReason(reason).build();
+  }
+
+  private CampaignAnalytics.Builder createCampaignAnalyticsBuilder(InAppMessage message) {
+    ClientAppInfo clientAppInfo = createClientAppInfo();
+    return CampaignAnalytics.newBuilder()
+        .setFiamSdkVersion(BuildConfig.VERSION_NAME)
+        .setProjectNumber(firebaseApp.getOptions().getGcmSenderId())
+        .setCampaignId(message.getCampaignMetadata().getCampaignId())
+        .setClientApp(clientAppInfo)
+        .setClientTimestampMillis(clock.now());
+  }
+
+  private ClientAppInfo createClientAppInfo() {
+    return ClientAppInfo.newBuilder()
+        .setGoogleAppId(firebaseApp.getOptions().getApplicationId())
+        .setFirebaseInstanceId(firebaseInstanceId.getId())
+        .build();
+  }
+
+  /**
+   * Asynchronously logs an event to analytics, If a conversion event should be tracked, we
+   * additionally update the userProperty
+   *
+   * <p>Scion schedules a task to run on a worker thread within the client app to send the event.
+   */
+  private void logEventAsync(InAppMessage message, String event, boolean updateConversionTracking) {
+    String campaignId = message.getCampaignMetadata().getCampaignId();
+    String campaignName = message.getCampaignMetadata().getCampaignName();
+    Bundle params = collectAnalyticsParams(campaignName, campaignId);
+
+    Logging.logd("Sending event=" + event + " params=" + params);
+
+    if (analyticsConnector != null) {
+      analyticsConnector.logEvent(AnalyticsConstants.ORIGIN_FIAM, event, params);
+      if (updateConversionTracking) {
+        // Use USER_PROPERTY_FIREBASE_LAST_NOTIFICATION for conversion tracking, prefix the
+        // campaignId with
+        // "fiam:"
+
+        analyticsConnector.setUserProperty(
+            AnalyticsConstants.ORIGIN_FIAM,
+            AnalyticsConstants.USER_PROPERTY_FIREBASE_LAST_NOTIFICATION,
+            "fiam:" + campaignId);
+      }
+    } else {
+      Logging.logw("Unable to log event: analytics library is missing");
+    }
+  }
+
+  Bundle collectAnalyticsParams(String campaignName, String campaignId) {
+    Bundle params = new Bundle();
+
+    params.putString(AnalyticsConstants.PARAM_MESSAGE_ID, campaignId);
+    params.putString(AnalyticsConstants.PARAM_MESSAGE_NAME, campaignName);
+
+    try {
+      // set message time to epoch seconds
+      int epochSeconds = (int) (clock.now() / 1000);
+      params.putInt(AnalyticsConstants.PARAM_MESSAGE_DEVICE_TIME, epochSeconds);
+    } catch (NumberFormatException e) {
+      Logging.logw("Error while parsing use_device_time in FIAM event: " + e.getMessage());
+    }
+
+    return params;
+  }
+
+  private boolean impressionCountsAsConversion(InAppMessage message) {
+    switch (message.getMessageType()) {
+      case CARD:
+        {
+          CardMessage m = (CardMessage) message;
+          boolean hasNoPrimaryAction = !isValidAction(m.getPrimaryAction());
+          boolean hasNoSecondaryAction = !isValidAction(m.getSecondaryAction());
+          return hasNoPrimaryAction && hasNoSecondaryAction;
+        }
+      case MODAL:
+        return !isValidAction(((ModalMessage) message).getAction());
+      case BANNER:
+        return !isValidAction(((BannerMessage) message).getAction());
+      case IMAGE_ONLY:
+        return !isValidAction(((ImageOnlyMessage) message).getAction());
+      default:
+        {
+          Logging.loge("Unable to determine if impression should be counted as conversion.");
+          return false;
+        }
+    }
+  }
+
+  private boolean isTestCampaign(InAppMessage message) {
+    return message.getCampaignMetadata().getIsTestMessage();
+  }
+
+  private boolean isValidAction(@Nullable Action action) {
+    return action != null && action.getActionUrl() != null && !action.getActionUrl().isEmpty();
+  }
+
+  /** Wrapper to assist unit testing usage */
+  public interface EngagementMetricsLoggerInterface {
+    void logEvent(byte[] bytes);
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ProgramaticContextualTriggers.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ProgramaticContextualTriggers.java
new file mode 100644
index 000000000..2915ce53c
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ProgramaticContextualTriggers.java
@@ -0,0 +1,44 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+/**
+ * The {@link ProgramaticContextualTriggers} notifies listeners set via {@link
+ * #setListener(Listener)} when an contextual trigger has been programatically triggered via the
+ * FirebaseInAppMessaging.triggerEvent() flw.
+ *
+ * @hide
+ */
+public class ProgramaticContextualTriggers {
+  private Listener listener;
+
+  public void setListener(Listener listener) {
+    this.listener = listener;
+  }
+
+  public void removeListener(Listener listener) {
+    this.listener = null;
+  }
+
+  public void triggerEvent(String eventName) {
+    Logging.logd("Programmatically trigger: " + eventName);
+    listener.onEventTrigger(eventName);
+  }
+
+  /** Listener to receive callbacks when the trigger is emitted */
+  public interface Listener {
+    void onEventTrigger(String trigger);
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ProtoStorageClient.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ProtoStorageClient.java
new file mode 100644
index 000000000..229217ba0
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ProtoStorageClient.java
@@ -0,0 +1,106 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static android.content.Context.MODE_PRIVATE;
+
+import android.app.Application;
+import com.google.protobuf.AbstractMessageLite;
+import com.google.protobuf.InvalidProtocolBufferException;
+import com.google.protobuf.Parser;
+import io.reactivex.Completable;
+import io.reactivex.Maybe;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import javax.annotation.concurrent.ThreadSafe;
+
+/**
+ * File backed storage client for protos. Reads and writes are non atomic, but thread safe.
+ *
+ * <p>The client confers locking semantics per client read/written.
+ *
+ * <p>Creating multiple clients that read/write to the same file will violate the principles of this
+ * thread safety
+ *
+ * <p>In the future we can consider using Android/Support's AtomicFile to provide atomic reads and
+ * writes
+ *
+ * @hide
+ */
+@ThreadSafe
+public class ProtoStorageClient {
+  private final Application application;
+  private final String fileName;
+
+  public ProtoStorageClient(Application application, String fileName) {
+    this.application = application;
+    this.fileName = fileName;
+  }
+
+  /**
+   * Write the proto to a file in the app' s file directory.
+   *
+   * <p>Writes are non atomic.
+   *
+   * <p>Readers are expected to deal with corrupt data resulting from faulty writes
+   *
+   * @param messageLite
+   * @throws IOException
+   */
+  public Completable write(AbstractMessageLite messageLite) {
+    return Completable.fromCallable(
+        () -> {
+          // reads / writes are synchronized per client instance
+          synchronized (this) {
+            try (FileOutputStream output = application.openFileOutput(fileName, MODE_PRIVATE)) {
+              output.write(messageLite.toByteArray());
+              return messageLite;
+            }
+          }
+        });
+  }
+
+  /**
+   * Read the contents of the file into a proto object using the parser. Since writes are not
+   * atomic, the caller will receive {@link Maybe#empty()} when data is corrupt.
+   *
+   * <p>Some valid scenarios that can lead to corrupt data :
+   *
+   * <ul>
+   *   <li>Out of disk space while writing
+   *   <li>Power outage while writing
+   *   <li>Process killed while writing
+   * </ul>
+   *
+   * @param parser
+   * @param <T>
+   */
+  public <T extends AbstractMessageLite> Maybe<T> read(Parser<T> parser) {
+    return Maybe.fromCallable(
+        () -> {
+          // reads / writes are synchronized per client instance
+          synchronized (this) {
+            try (FileInputStream inputStream = application.openFileInput(fileName)) {
+              return parser.parseFrom(inputStream);
+            } catch (InvalidProtocolBufferException | FileNotFoundException e) {
+              Logging.logw("Recoverable exception while reading cache: " + e.getMessage());
+              return null;
+            }
+          }
+        });
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ProviderInstaller.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ProviderInstaller.java
new file mode 100644
index 000000000..0bbb87339
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/ProviderInstaller.java
@@ -0,0 +1,39 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import android.app.Application;
+import com.google.android.gms.common.GooglePlayServicesNotAvailableException;
+import com.google.android.gms.common.GooglePlayServicesRepairableException;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+@Singleton
+public class ProviderInstaller {
+  private final Application application;
+
+  @Inject
+  ProviderInstaller(Application application) {
+    this.application = application;
+  }
+
+  public void install() {
+    try {
+      com.google.android.gms.security.ProviderInstaller.installIfNeeded(application);
+    } catch (GooglePlayServicesNotAvailableException | GooglePlayServicesRepairableException e) {
+      e.printStackTrace();
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/RateLimiterClient.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/RateLimiterClient.java
new file mode 100644
index 000000000..326fb8c57
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/RateLimiterClient.java
@@ -0,0 +1,118 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import com.google.firebase.inappmessaging.internal.RateLimitProto.Counter;
+import com.google.firebase.inappmessaging.internal.time.Clock;
+import com.google.firebase.inappmessaging.model.RateLimit;
+import io.reactivex.Completable;
+import io.reactivex.Maybe;
+import io.reactivex.Observable;
+import io.reactivex.Single;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+/**
+ * Client to store rate limits. This works as follows:
+ *
+ * <ul>
+ *   <li>Limits are represented by value objects of type {@link RateLimit}.
+ *   <li>Limits can be incremented using {@link #increment(RateLimit)} and checked using the {@link
+ *       #isRateLimited(RateLimit)} methods.
+ * </ul>
+ *
+ * @hide
+ */
+@Singleton
+public class RateLimiterClient {
+  private static final RateLimitProto.RateLimit EMPTY_RATE_LIMITS =
+      RateLimitProto.RateLimit.getDefaultInstance();
+  private final ProtoStorageClient storageClient;
+  private final Clock clock;
+  private Maybe<RateLimitProto.RateLimit> cachedRateLimts = Maybe.empty();
+
+  @Inject
+  RateLimiterClient(
+      @com.google.firebase.inappmessaging.internal.injection.qualifiers.RateLimit
+          ProtoStorageClient storageClient,
+      Clock clock) {
+    this.storageClient = storageClient;
+    this.clock = clock;
+  }
+
+  private static Counter increment(Counter current) {
+    return Counter.newBuilder(current).clearValue().setValue(current.getValue() + 1).build();
+  }
+
+  /**
+   * Increment the value associated to the key by 1, initializing if necessary.
+   *
+   * <p>If the limit has expired, it is reinitialized.
+   *
+   * <p>Callers are thus expected to check if a limit is reached using {@link
+   * #isRateLimited(RateLimit)} before incrementing.
+   */
+  public Completable increment(RateLimit limit) {
+    return getRateLimits()
+        .defaultIfEmpty(EMPTY_RATE_LIMITS)
+        .flatMapCompletable(
+            storedLimits ->
+                Observable.just(storedLimits.getLimitsOrDefault(limit.limiterKey(), newCounter()))
+                    .filter(counter -> !isLimitExpired(counter, limit))
+                    .switchIfEmpty(Observable.just(newCounter()))
+                    .map(
+                        current -> {
+                          Counter incremented = increment(current);
+                          return RateLimitProto.RateLimit.newBuilder(storedLimits)
+                              .putLimits(limit.limiterKey(), incremented)
+                              .build();
+                        })
+                    .flatMapCompletable(
+                        a -> storageClient.write(a).doOnComplete(() -> initInMemCache(a))));
+  }
+
+  /** True if the limit has been reached and has not expired. */
+  public Single<Boolean> isRateLimited(RateLimit limit) {
+    return getRateLimits()
+        .switchIfEmpty(Maybe.just(RateLimitProto.RateLimit.getDefaultInstance()))
+        .map(storedLimits -> storedLimits.getLimitsOrDefault(limit.limiterKey(), newCounter()))
+        .filter(counter -> isLimitExpired(counter, limit) || counter.getValue() < limit.limit())
+        .isEmpty();
+  }
+
+  private boolean isLimitExpired(Counter counter, RateLimit limit) {
+    long currentTime = clock.now();
+    return (currentTime - counter.getStartTimeEpoch()) > limit.timeToLiveMillis();
+  }
+
+  private Maybe<RateLimitProto.RateLimit> getRateLimits() {
+    return cachedRateLimts
+        .switchIfEmpty(
+            storageClient.read(RateLimitProto.RateLimit.parser()).doOnSuccess(this::initInMemCache))
+        .doOnError(ignored -> clearInMemCache());
+  }
+
+  private void initInMemCache(RateLimitProto.RateLimit rateLimits) {
+    cachedRateLimts = Maybe.just(rateLimits);
+  }
+
+  private void clearInMemCache() {
+    cachedRateLimts = Maybe.empty();
+  }
+
+  private Counter newCounter() {
+    return Counter.newBuilder().setValue(0).setStartTimeEpoch(clock.now()).build();
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/Schedulers.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/Schedulers.java
new file mode 100644
index 000000000..33824a3b6
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/Schedulers.java
@@ -0,0 +1,54 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import io.reactivex.Scheduler;
+import javax.inject.Inject;
+import javax.inject.Named;
+import javax.inject.Singleton;
+
+/**
+ * Schedulers container for rx actions
+ *
+ * @hide
+ */
+@Singleton
+public class Schedulers {
+  private final Scheduler ioScheduler;
+  private final Scheduler computeScheduler;
+  private final Scheduler mainThreadScheduler;
+
+  @Inject
+  Schedulers(
+      @Named("io") Scheduler ioScheduler,
+      @Named("compute") Scheduler computeScheduler,
+      @Named("main") Scheduler mainThreadScheduler) {
+    this.ioScheduler = ioScheduler;
+    this.computeScheduler = computeScheduler;
+    this.mainThreadScheduler = mainThreadScheduler;
+  }
+
+  public Scheduler io() {
+    return ioScheduler;
+  }
+
+  public Scheduler mainThread() {
+    return mainThreadScheduler;
+  }
+
+  public Scheduler computation() {
+    return computeScheduler;
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/SharedPreferencesUtils.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/SharedPreferencesUtils.java
new file mode 100644
index 000000000..4cf6d1730
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/SharedPreferencesUtils.java
@@ -0,0 +1,168 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import android.app.Application;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import com.google.common.annotations.VisibleForTesting;
+import com.google.firebase.FirebaseApp;
+import javax.inject.Inject;
+
+/** @hide */
+public class SharedPreferencesUtils {
+
+  @VisibleForTesting
+  static final String PREFERENCES_PACKAGE_NAME = "com.google.firebase.inappmessaging";
+
+  private final FirebaseApp firebaseApp;
+
+  @Inject
+  public SharedPreferencesUtils(FirebaseApp firebaseApp) {
+    this.firebaseApp = firebaseApp;
+  }
+
+  /**
+   * Helper method for setting a boolean value in the apps stored preferences.
+   *
+   * @param preference the preference key.
+   * @param value the value to store.
+   */
+  public void setBooleanPreference(String preference, boolean value) {
+    Application application = (Application) firebaseApp.getApplicationContext();
+    SharedPreferences.Editor preferencesEditor =
+        application.getSharedPreferences(PREFERENCES_PACKAGE_NAME, Context.MODE_PRIVATE).edit();
+    preferencesEditor.putBoolean(preference, value);
+    preferencesEditor.apply();
+  }
+
+  /**
+   * Helper method for getting a boolean value from the apps stored preferences.
+   *
+   * @param preference the preference key.
+   * @param defaultValue the default value to return if the key is not found.
+   * @return the value stored or the default if the stored value is not found.
+   */
+  public boolean getAndSetBooleanPreference(String preference, boolean defaultValue) {
+    Application application = (Application) firebaseApp.getApplicationContext();
+    SharedPreferences preferences =
+        application.getSharedPreferences(PREFERENCES_PACKAGE_NAME, Context.MODE_PRIVATE);
+
+    // Value set at runtime overrides anything else, but default to defaultValue.
+    if (preferences.contains(preference)) {
+      boolean result = preferences.getBoolean(preference, defaultValue);
+      return result;
+    }
+    // No preferences set yet - use and set defaultValue.
+    setBooleanPreference(preference, defaultValue);
+    return defaultValue;
+  }
+
+  /**
+   * Helper method for getting a boolean value from the apps stored preferences.
+   *
+   * @param preference the preference key.
+   * @param defaultValue the default value to return if the key is not found.
+   * @return the value stored or the default if the stored value is not found.
+   */
+  public boolean getBooleanPreference(String preference, boolean defaultValue) {
+    Application application = (Application) firebaseApp.getApplicationContext();
+    SharedPreferences preferences =
+        application.getSharedPreferences(PREFERENCES_PACKAGE_NAME, Context.MODE_PRIVATE);
+
+    // Value set at runtime overrides anything else, but default to defaultValue.
+    if (preferences.contains(preference)) {
+      boolean result = preferences.getBoolean(preference, defaultValue);
+      return result;
+    }
+    // No preferences set yet - use  defaultValue.
+    return defaultValue;
+  }
+
+  /**
+   * Helper method for getting a boolean value from the apps stored preferences.
+   *
+   * @param preference the preference key.
+   * @return whether the preference has been set or not
+   */
+  public boolean isPreferenceSet(String preference) {
+    Application application = (Application) firebaseApp.getApplicationContext();
+    SharedPreferences preferences =
+        application.getSharedPreferences(PREFERENCES_PACKAGE_NAME, Context.MODE_PRIVATE);
+
+    return preferences.contains(preference);
+  }
+
+  /**
+   * Helper method for getting a boolean value from the apps manifest
+   *
+   * @param preference the preference key.
+   * @return whether the preference has been set or not
+   */
+  public boolean isManifestSet(String preference) {
+    Application application = (Application) firebaseApp.getApplicationContext();
+    // Check if there's metadata in the manifest setting the auto-init state.
+    try {
+      PackageManager packageManager = application.getPackageManager();
+      if (packageManager != null) {
+        ApplicationInfo applicationInfo =
+            packageManager.getApplicationInfo(
+                application.getPackageName(), PackageManager.GET_META_DATA);
+        return applicationInfo != null
+            && applicationInfo.metaData != null
+            && applicationInfo.metaData.containsKey(preference);
+      }
+    } catch (PackageManager.NameNotFoundException e) {
+      // This shouldn't happen since it's this app's package. However, if it does, we want to fall
+      // through to the default, and avoid throwing an exception
+
+    }
+    return false;
+  }
+
+  /**
+   * Helper method for getting a boolean value from the apps stored preferences. Falls back to
+   * checking for a manifest preference before returning the default value.
+   *
+   * @param preference the manifest preference key.
+   * @param defaultValue the default value to return if the key is not found.
+   * @return the value stored or the default if the stored value is not found.
+   */
+  public boolean getBooleanManifestValue(String preference, boolean defaultValue) {
+    Application application = (Application) firebaseApp.getApplicationContext();
+    // Check if there's metadata in the manifest setting the auto-init state.
+    try {
+      PackageManager packageManager = application.getPackageManager();
+      if (packageManager != null) {
+        ApplicationInfo applicationInfo =
+            packageManager.getApplicationInfo(
+                application.getPackageName(), PackageManager.GET_META_DATA);
+        if (applicationInfo != null
+            && applicationInfo.metaData != null
+            && applicationInfo.metaData.containsKey(preference)) {
+          return applicationInfo.metaData.getBoolean(preference);
+        }
+      }
+    } catch (PackageManager.NameNotFoundException e) {
+      // This shouldn't happen since it's this app's package. However, if it does, we want to fall
+      // through to the default, and avoid throwing an exception
+    }
+
+    // Return the default
+    return defaultValue;
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/StubAnalyticsConnector.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/StubAnalyticsConnector.java
new file mode 100644
index 000000000..1fb967a3b
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/StubAnalyticsConnector.java
@@ -0,0 +1,88 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import android.os.Bundle;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Stub connector that may be used in the absence of an analytics connector. This allows us to take
+ * an optional dependency on analytics connector, and use the stub as the replacement in its
+ * absence.
+ */
+public class StubAnalyticsConnector implements AnalyticsConnector {
+
+  public static final StubAnalyticsConnector instance = new StubAnalyticsConnector();
+
+  private StubAnalyticsConnector() {}
+
+  @Override
+  public void logEvent(@NonNull String s, @NonNull String s1, Bundle bundle) {}
+
+  @Override
+  public void setUserProperty(@NonNull String s, @NonNull String s1, Object o) {}
+
+  @Override
+  public Map<String, Object> getUserProperties(boolean b) {
+    return null;
+  }
+
+  @Override
+  public AnalyticsConnectorHandle registerAnalyticsConnectorListener(
+      String s, AnalyticsConnectorListener analyticsConnectorListener) {
+    return AnalyticsConnectorHandle.instance;
+  }
+
+  @Override
+  public void setConditionalUserProperty(
+      @NonNull ConditionalUserProperty conditionalUserProperty) {}
+
+  @Override
+  public void clearConditionalUserProperty(
+      @NonNull String s, @Nullable String s1, @Nullable Bundle bundle) {}
+
+  @Override
+  public List<ConditionalUserProperty> getConditionalUserProperties(
+      @NonNull String s, @Nullable String s1) {
+    return null;
+  }
+
+  @Override
+  public int getMaxUserProperties(@NonNull String s) {
+    return 0;
+  }
+
+  private static class AnalyticsConnectorHandle
+      implements AnalyticsConnector.AnalyticsConnectorHandle {
+
+    static final AnalyticsConnectorHandle instance = new AnalyticsConnectorHandle();
+
+    private AnalyticsConnectorHandle() {}
+
+    @Override
+    public void unregister() {}
+
+    @Override
+    public void registerEventNames(Set<String> set) {}
+
+    @Override
+    public void unregisterEventNames() {}
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/TestDeviceHelper.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/TestDeviceHelper.java
new file mode 100644
index 000000000..ff45e485d
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/TestDeviceHelper.java
@@ -0,0 +1,138 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.internal.firebase.inappmessaging.v1.CampaignProto;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsResponse;
+import java.util.List;
+import javax.inject.Inject;
+
+/**
+ * Determines whether the app is a fresh install or the device is in test mode. Exposes methods to
+ * check for install freshness and test device status as well as a method to update these fields by
+ * processing a campaign fetch response.
+ *
+ * @hide
+ */
+public class TestDeviceHelper {
+
+  @VisibleForTesting static final String TEST_DEVICE_PREFERENCES = "test_device";
+  @VisibleForTesting static final String FRESH_INSTALL_PREFERENCES = "fresh_install";
+  @VisibleForTesting static final int MAX_FETCH_COUNT = 5;
+
+  private final SharedPreferencesUtils sharedPreferencesUtils;
+  private boolean isTestDevice;
+  private boolean isFreshInstall;
+  private int fetchCount = 0;
+
+  @Inject
+  public TestDeviceHelper(SharedPreferencesUtils sharedPreferencesUtils) {
+    this.sharedPreferencesUtils = sharedPreferencesUtils;
+    this.isFreshInstall = readFreshInstallStatusFromPreferences();
+    this.isTestDevice = readTestDeviceStatusFromPreferences();
+  }
+
+  /**
+   * Determine whether device is set as a test device.
+   *
+   * @return true if device is in test mode
+   */
+  public boolean isDeviceInTestMode() {
+    return isTestDevice;
+  }
+
+  /**
+   * Determine whether app was just installed.
+   *
+   * @return true if this is a fresh install
+   */
+  public boolean isAppInstallFresh() {
+    return isFreshInstall;
+  }
+
+  /**
+   * Updates test device status based on a response from the FIAM server.
+   *
+   * @param response campaign fetch response from the FIAM server.
+   */
+  public void processCampaignFetch(FetchEligibleCampaignsResponse response) {
+    // We only care about this logic if we are not already a test device.
+    if (!isTestDevice) {
+      updateFreshInstallStatus();
+      List<CampaignProto.ThickContent> messages = response.getMessagesList();
+      for (CampaignProto.ThickContent message : messages) {
+        if (message.getIsTestCampaign()) {
+          setTestDeviceStatus(true);
+          Logging.logi("Setting this device as a test device");
+          return;
+        }
+      }
+    }
+  }
+
+  /** Increments the fetch count which is used to determine if an app install is fresh. */
+  private void updateFreshInstallStatus() {
+    // We only care about this logic if we are a fresh install.
+    if (isFreshInstall) {
+      fetchCount += 1;
+      if (fetchCount >= MAX_FETCH_COUNT) {
+        setFreshInstallStatus(false);
+      }
+    }
+  }
+
+  /**
+   * Sets the test device status and saves it into the app stored preferences.
+   *
+   * @param isEnabled whether or not the device should be a test device
+   */
+  private void setTestDeviceStatus(boolean isEnabled) {
+    isTestDevice = isEnabled;
+    // Update SharedPreferences, so that we preserve state across app restarts
+    sharedPreferencesUtils.setBooleanPreference(TEST_DEVICE_PREFERENCES, isEnabled);
+  }
+
+  /**
+   * Sets the app fresh install state and saves it into the app stored preferences
+   *
+   * @param isEnabled whether or not the app is a fresh install.
+   */
+  private void setFreshInstallStatus(boolean isEnabled) {
+    isFreshInstall = isEnabled;
+    // Update SharedPreferences, so that we preserve state across app restarts
+    sharedPreferencesUtils.setBooleanPreference(FRESH_INSTALL_PREFERENCES, isEnabled);
+  }
+
+  /**
+   * Reads the test device status from the apps stored preferences. Defaults to false because apps
+   * do not start in test mode.
+   *
+   * @return true if device is in test mode.
+   */
+  private boolean readTestDeviceStatusFromPreferences() {
+    return sharedPreferencesUtils.getAndSetBooleanPreference(TEST_DEVICE_PREFERENCES, false);
+  }
+
+  /**
+   * Reads the fresh install status from the apps stored preferences. Defaults to true because apps
+   * start out as fresh installs.
+   *
+   * @return true if the app is a fresh install.
+   */
+  private boolean readFreshInstallStatusFromPreferences() {
+    return sharedPreferencesUtils.getAndSetBooleanPreference(FRESH_INSTALL_PREFERENCES, true);
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/components/AppComponent.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/components/AppComponent.java
new file mode 100644
index 000000000..6f4a5d647
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/components/AppComponent.java
@@ -0,0 +1,55 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.components;
+
+import com.google.android.datatransport.TransportFactory;
+import com.google.firebase.inappmessaging.FirebaseInAppMessaging;
+import com.google.firebase.inappmessaging.internal.DisplayCallbacksFactory;
+import com.google.firebase.inappmessaging.internal.injection.modules.ApiClientModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.GrpcClientModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.TransportClientModule;
+import com.google.firebase.inappmessaging.internal.injection.scopes.FirebaseAppScope;
+import dagger.BindsInstance;
+import dagger.Component;
+
+/**
+ * Dagger component to create FirebaseInAppMessaging Objects. One component is created per firebase
+ * app found on the client.
+ *
+ * @hide
+ */
+@FirebaseAppScope
+@Component(
+    dependencies = {UniversalComponent.class},
+    modules = {ApiClientModule.class, GrpcClientModule.class, TransportClientModule.class})
+public interface AppComponent {
+  FirebaseInAppMessaging providesFirebaseInAppMessaging();
+
+  DisplayCallbacksFactory displayCallbacksFactory();
+
+  @Component.Builder
+  interface Builder {
+    Builder apiClientModule(ApiClientModule module);
+
+    Builder grpcClientModule(GrpcClientModule module);
+
+    Builder universalComponent(UniversalComponent component);
+
+    @BindsInstance
+    Builder transportFactory(TransportFactory transportFactory);
+
+    AppComponent build();
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/components/UniversalComponent.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/components/UniversalComponent.java
new file mode 100644
index 000000000..5b0d36dfa
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/components/UniversalComponent.java
@@ -0,0 +1,112 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.components;
+
+import android.app.Application;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.events.Subscriber;
+import com.google.firebase.inappmessaging.internal.AnalyticsEventsManager;
+import com.google.firebase.inappmessaging.internal.CampaignCacheClient;
+import com.google.firebase.inappmessaging.internal.DeveloperListenerManager;
+import com.google.firebase.inappmessaging.internal.ImpressionStorageClient;
+import com.google.firebase.inappmessaging.internal.ProgramaticContextualTriggers;
+import com.google.firebase.inappmessaging.internal.ProviderInstaller;
+import com.google.firebase.inappmessaging.internal.RateLimiterClient;
+import com.google.firebase.inappmessaging.internal.Schedulers;
+import com.google.firebase.inappmessaging.internal.injection.modules.AnalyticsEventsModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.AppMeasurementModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.ApplicationModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.ForegroundFlowableModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.ForegroundNotifierModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.GrpcChannelModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.ProgrammaticContextualTriggerFlowableModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.ProtoStorageClientModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.RateLimitModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.SchedulerModule;
+import com.google.firebase.inappmessaging.internal.injection.modules.SystemClockModule;
+import com.google.firebase.inappmessaging.internal.injection.qualifiers.AnalyticsListener;
+import com.google.firebase.inappmessaging.internal.injection.qualifiers.AppForeground;
+import com.google.firebase.inappmessaging.internal.injection.qualifiers.ProgrammaticTrigger;
+import com.google.firebase.inappmessaging.internal.time.Clock;
+import com.google.firebase.inappmessaging.model.ProtoMarshallerClient;
+import com.google.firebase.inappmessaging.model.RateLimit;
+import dagger.Component;
+import io.grpc.Channel;
+import io.reactivex.flowables.ConnectableFlowable;
+import javax.inject.Singleton;
+
+/**
+ * A single Network component is shared by all components in the {@link
+ * com.google.firebase.inappmessaging.internal.injection.scopes.FirebaseAppScope}
+ *
+ * @hide
+ */
+@Singleton
+@Component(
+    modules = {
+      GrpcChannelModule.class,
+      SchedulerModule.class,
+      ApplicationModule.class,
+      ForegroundNotifierModule.class,
+      ForegroundFlowableModule.class,
+      ProgrammaticContextualTriggerFlowableModule.class,
+      AnalyticsEventsModule.class,
+      ProtoStorageClientModule.class,
+      SystemClockModule.class,
+      RateLimitModule.class,
+      AppMeasurementModule.class
+    })
+public interface UniversalComponent {
+  ProviderInstaller probiderInstaller();
+
+  Channel gRPCChannel();
+
+  Schedulers schedulers();
+
+  @AppForeground
+  ConnectableFlowable<String> appForegroundEventFlowable();
+
+  @ProgrammaticTrigger
+  ConnectableFlowable<String> programmaticContextualTriggerFlowable();
+
+  @ProgrammaticTrigger
+  ProgramaticContextualTriggers programmaticContextualTriggers();
+
+  @AnalyticsListener
+  ConnectableFlowable<String> analyticsEventsFlowable();
+
+  AnalyticsEventsManager analyticsEventsManager();
+
+  AnalyticsConnector analyticsConnector();
+
+  Subscriber firebaseEventsSubscriber();
+
+  CampaignCacheClient campaignCacheClient();
+
+  ImpressionStorageClient impressionStorageClient();
+
+  Clock clock();
+
+  ProtoMarshallerClient protoMarshallerClient();
+
+  RateLimiterClient rateLimiterClient();
+
+  Application application();
+
+  @AppForeground
+  RateLimit appForegroundRateLimit();
+
+  DeveloperListenerManager developerListenerManager();
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/AnalyticsEventsModule.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/AnalyticsEventsModule.java
new file mode 100644
index 000000000..a16b177ee
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/AnalyticsEventsModule.java
@@ -0,0 +1,47 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.modules;
+
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.inappmessaging.internal.AnalyticsEventsManager;
+import com.google.firebase.inappmessaging.internal.injection.qualifiers.AnalyticsListener;
+import dagger.Module;
+import dagger.Provides;
+import io.reactivex.flowables.ConnectableFlowable;
+import javax.inject.Singleton;
+
+/**
+ * Bindings for firebase analytics events generated by listeners registered with scion using {@link
+ * com.google.firebase.analytics.connector.AnalyticsConnector}.
+ *
+ * @hide
+ */
+@Module
+public class AnalyticsEventsModule {
+
+  @Provides
+  @AnalyticsListener
+  @Singleton
+  ConnectableFlowable<String> providesAnalyticsConnectorEvents(
+      AnalyticsEventsManager analyticsEventsManager) {
+    return analyticsEventsManager.getAnalyticsEventsFlowable();
+  }
+
+  @Provides
+  @Singleton
+  AnalyticsEventsManager providesAnalyticsEventsManager(AnalyticsConnector analyticsConnector) {
+    return new AnalyticsEventsManager(analyticsConnector);
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ApiClientModule.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ApiClientModule.java
new file mode 100644
index 000000000..62d57aa24
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ApiClientModule.java
@@ -0,0 +1,93 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.modules;
+
+import android.app.Application;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.events.Subscriber;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.inappmessaging.internal.ApiClient;
+import com.google.firebase.inappmessaging.internal.DataCollectionHelper;
+import com.google.firebase.inappmessaging.internal.GrpcClient;
+import com.google.firebase.inappmessaging.internal.ProviderInstaller;
+import com.google.firebase.inappmessaging.internal.SharedPreferencesUtils;
+import com.google.firebase.inappmessaging.internal.TestDeviceHelper;
+import com.google.firebase.inappmessaging.internal.injection.scopes.FirebaseAppScope;
+import com.google.firebase.inappmessaging.internal.time.Clock;
+import dagger.Lazy;
+import dagger.Module;
+import dagger.Provides;
+
+/**
+ * Provider for ApiClient
+ *
+ * @hide
+ */
+@Module
+public class ApiClientModule {
+  private final FirebaseApp firebaseApp;
+  private final FirebaseInstanceId firebaseInstanceId;
+  private final Clock clock;
+
+  public ApiClientModule(FirebaseApp firebaseApp, FirebaseInstanceId instanceId, Clock clock) {
+    this.firebaseApp = firebaseApp;
+    this.firebaseInstanceId = instanceId;
+    this.clock = clock;
+  }
+
+  @Provides
+  FirebaseInstanceId providesFirebaseInstanceId() {
+    return firebaseInstanceId;
+  }
+
+  @Provides
+  FirebaseApp providesFirebaseApp() {
+    return firebaseApp;
+  }
+
+  @Provides
+  SharedPreferencesUtils providesSharedPreferencesUtils() {
+    return new SharedPreferencesUtils(firebaseApp);
+  }
+
+  @Provides
+  DataCollectionHelper providesDataCollectionHelper(
+      SharedPreferencesUtils sharedPreferencesUtils, Subscriber firebaseEventSubscriber) {
+    return new DataCollectionHelper(
+        firebaseApp, sharedPreferencesUtils, firebaseInstanceId, firebaseEventSubscriber);
+  }
+
+  @Provides
+  TestDeviceHelper providesTestDeviceHelper(SharedPreferencesUtils sharedPreferencesUtils) {
+    return new TestDeviceHelper(sharedPreferencesUtils);
+  }
+
+  @Provides
+  @FirebaseAppScope
+  ApiClient providesApiClient(
+      Lazy<GrpcClient> grpcClient,
+      Application application,
+      DataCollectionHelper dataCollectionHelper,
+      ProviderInstaller providerInstaller) {
+    return new ApiClient(
+        grpcClient,
+        firebaseApp,
+        application,
+        firebaseInstanceId,
+        dataCollectionHelper,
+        clock,
+        providerInstaller);
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/AppMeasurementModule.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/AppMeasurementModule.java
new file mode 100644
index 000000000..a3b45be66
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/AppMeasurementModule.java
@@ -0,0 +1,53 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.modules;
+
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.events.Subscriber;
+import com.google.firebase.inappmessaging.internal.StubAnalyticsConnector;
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Singleton;
+
+/**
+ * Bindings for app measurement
+ *
+ * @hide
+ */
+@Module
+public class AppMeasurementModule {
+
+  private AnalyticsConnector analyticsConnector;
+  private Subscriber firebaseEventsSubscriber;
+
+  public AppMeasurementModule(
+      AnalyticsConnector analyticsConnector, Subscriber firebaseEventsSubscriber) {
+    this.analyticsConnector =
+        analyticsConnector != null ? analyticsConnector : StubAnalyticsConnector.instance;
+    this.firebaseEventsSubscriber = firebaseEventsSubscriber;
+  }
+
+  @Provides
+  @Singleton
+  AnalyticsConnector providesAnalyticsConnector() {
+    return analyticsConnector;
+  }
+
+  @Provides
+  @Singleton
+  Subscriber providesSubsriber() {
+    return firebaseEventsSubscriber;
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ApplicationModule.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ApplicationModule.java
new file mode 100644
index 000000000..96d8b63e1
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ApplicationModule.java
@@ -0,0 +1,47 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.modules;
+
+import android.app.Application;
+import com.google.firebase.inappmessaging.internal.DeveloperListenerManager;
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Singleton;
+
+/**
+ * Bindings for {@link Application}
+ *
+ * @hide
+ */
+@Module
+public class ApplicationModule {
+  private final Application application;
+
+  public ApplicationModule(Application application) {
+    this.application = application;
+  }
+
+  @Provides
+  @Singleton
+  public Application providesApplication() {
+    return application;
+  }
+
+  @Provides
+  @Singleton
+  public DeveloperListenerManager developerListenerManager() {
+    return new DeveloperListenerManager();
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ForegroundFlowableModule.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ForegroundFlowableModule.java
new file mode 100644
index 000000000..dff946f33
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ForegroundFlowableModule.java
@@ -0,0 +1,57 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.modules;
+
+import static io.reactivex.BackpressureStrategy.BUFFER;
+
+import android.app.Application;
+import com.google.firebase.inappmessaging.internal.ForegroundNotifier;
+import com.google.firebase.inappmessaging.internal.InAppMessageStreamManager;
+import com.google.firebase.inappmessaging.internal.injection.qualifiers.AppForeground;
+import dagger.Module;
+import dagger.Provides;
+import io.reactivex.Flowable;
+import io.reactivex.flowables.ConnectableFlowable;
+import javax.inject.Singleton;
+
+/**
+ * Bindings for app foreground event generated by {@link
+ * com.google.firebase.inappmessaging.internal.ForegroundNotifier}
+ *
+ * @hide
+ */
+@Module
+public class ForegroundFlowableModule {
+
+  @Provides
+  @Singleton
+  @AppForeground
+  public ConnectableFlowable<String> providesAppForegroundEventStream(
+      Application application, ForegroundNotifier foreground) {
+    application.registerActivityLifecycleCallbacks(foreground);
+
+    ConnectableFlowable<String> flowable =
+        Flowable.<String>create(
+                e ->
+                    foreground.setListener(() -> e.onNext(InAppMessageStreamManager.ON_FOREGROUND)),
+                BUFFER)
+            .publish();
+
+    flowable.connect();
+    // We ignore the subscription since this connected flowable is expected to last the lifetime of
+    // the app.
+    return flowable;
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ForegroundNotifierModule.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ForegroundNotifierModule.java
new file mode 100644
index 000000000..94e26de51
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ForegroundNotifierModule.java
@@ -0,0 +1,34 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.modules;
+
+import com.google.firebase.inappmessaging.internal.ForegroundNotifier;
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Singleton;
+
+/**
+ * Bindings for app foreground listener
+ *
+ * @hide
+ */
+@Module
+public class ForegroundNotifierModule {
+  @Provides
+  @Singleton
+  public ForegroundNotifier providesForeground() {
+    return new ForegroundNotifier();
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/GrpcChannelModule.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/GrpcChannelModule.java
new file mode 100644
index 000000000..6f194a89a
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/GrpcChannelModule.java
@@ -0,0 +1,43 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.modules;
+
+import dagger.Module;
+import dagger.Provides;
+import io.grpc.Channel;
+import io.grpc.ManagedChannelBuilder;
+import javax.inject.Named;
+import javax.inject.Singleton;
+
+/**
+ * Bindings for grpc channel
+ *
+ * @hide
+ */
+@Module
+public class GrpcChannelModule {
+  @Provides
+  @Named("host")
+  @Singleton
+  public String providesServiceHost() {
+    return "firebaseinappmessaging.googleapis.com";
+  }
+
+  @Provides
+  @Singleton
+  public Channel providesGrpcChannel(@Named("host") String host) {
+    return ManagedChannelBuilder.forTarget(host).build();
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/GrpcClientModule.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/GrpcClientModule.java
new file mode 100644
index 000000000..43466bcf1
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/GrpcClientModule.java
@@ -0,0 +1,104 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.modules;
+
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.Signature;
+import androidx.annotation.NonNull;
+import com.google.common.io.BaseEncoding;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.inappmessaging.internal.injection.scopes.FirebaseAppScope;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.InAppMessagingSdkServingGrpc;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.InAppMessagingSdkServingGrpc.InAppMessagingSdkServingBlockingStub;
+import dagger.Module;
+import dagger.Provides;
+import io.grpc.Channel;
+import io.grpc.ClientInterceptors;
+import io.grpc.Metadata;
+import io.grpc.stub.MetadataUtils;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+/**
+ * Bindings for grpc client
+ *
+ * @hide
+ */
+@Module
+public class GrpcClientModule {
+  private final FirebaseApp firebaseApp;
+
+  public GrpcClientModule(FirebaseApp firebaseApp) {
+    this.firebaseApp = firebaseApp;
+  }
+
+  @Provides
+  public Metadata providesApiKeyHeaders() {
+    final Metadata.Key<String> apiClientKeyHeader =
+        Metadata.Key.of("X-Goog-Api-Key", Metadata.ASCII_STRING_MARSHALLER);
+    final Metadata.Key<String> androidPackageHeader =
+        Metadata.Key.of("X-Android-Package", Metadata.ASCII_STRING_MARSHALLER);
+    final Metadata.Key<String> androidCertHashHeader =
+        Metadata.Key.of("X-Android-Cert", Metadata.ASCII_STRING_MARSHALLER);
+
+    Metadata metadata = new Metadata();
+    String packageName = firebaseApp.getApplicationContext().getPackageName();
+    metadata.put(apiClientKeyHeader, firebaseApp.getOptions().getApiKey());
+    metadata.put(androidPackageHeader, packageName);
+
+    String signature =
+        getSignature(firebaseApp.getApplicationContext().getPackageManager(), packageName);
+
+    if (signature != null) {
+      metadata.put(androidCertHashHeader, signature);
+    }
+    return metadata;
+  }
+
+  public static String getSignature(@NonNull PackageManager pm, @NonNull String packageName) {
+    try {
+      PackageInfo packageInfo = pm.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
+      if (packageInfo == null
+          || packageInfo.signatures == null
+          || packageInfo.signatures.length == 0
+          || packageInfo.signatures[0] == null) {
+        return null;
+      }
+      return signatureDigest(packageInfo.signatures[0]);
+    } catch (PackageManager.NameNotFoundException e) {
+      return null;
+    }
+  }
+
+  private static String signatureDigest(Signature sig) {
+    byte[] signature = sig.toByteArray();
+    try {
+      MessageDigest md = MessageDigest.getInstance("SHA1");
+      byte[] digest = md.digest(signature);
+      return BaseEncoding.base16().upperCase().encode(digest);
+    } catch (NoSuchAlgorithmException e) {
+      return null;
+    }
+  }
+
+  @Provides
+  @FirebaseAppScope
+  public InAppMessagingSdkServingBlockingStub providesInAppMessagingSdkServingStub(
+      Channel channel, Metadata metadata) {
+    return InAppMessagingSdkServingGrpc.newBlockingStub(
+        ClientInterceptors.intercept(channel, MetadataUtils.newAttachHeadersInterceptor(metadata)));
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ProgrammaticContextualTriggerFlowableModule.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ProgrammaticContextualTriggerFlowableModule.java
new file mode 100644
index 000000000..a1962ee86
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ProgrammaticContextualTriggerFlowableModule.java
@@ -0,0 +1,62 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.modules;
+
+import static io.reactivex.BackpressureStrategy.BUFFER;
+
+import com.google.firebase.inappmessaging.internal.ForegroundNotifier;
+import com.google.firebase.inappmessaging.internal.ProgramaticContextualTriggers;
+import com.google.firebase.inappmessaging.internal.injection.qualifiers.ProgrammaticTrigger;
+import dagger.Module;
+import dagger.Provides;
+import io.reactivex.Flowable;
+import io.reactivex.flowables.ConnectableFlowable;
+import javax.inject.Singleton;
+
+/**
+ * Bindings for programatic contextual triggers created by {@link ForegroundNotifier}
+ *
+ * @hide
+ */
+@Module
+public class ProgrammaticContextualTriggerFlowableModule {
+  private ProgramaticContextualTriggers triggers;
+
+  public ProgrammaticContextualTriggerFlowableModule(ProgramaticContextualTriggers triggers) {
+    this.triggers = triggers;
+  }
+
+  @Provides
+  @Singleton
+  @ProgrammaticTrigger
+  public ProgramaticContextualTriggers providesProgramaticContextualTriggers() {
+    return triggers;
+  }
+
+  @Provides
+  @Singleton
+  @ProgrammaticTrigger
+  public ConnectableFlowable<String> providesProgramaticContextualTriggerStream() {
+
+    ConnectableFlowable<String> flowable =
+        Flowable.<String>create(e -> triggers.setListener((trigger) -> e.onNext(trigger)), BUFFER)
+            .publish();
+
+    flowable.connect();
+    // We ignore the subscription since this connected flowable is expected to last the lifetime of
+    // the app.
+    return flowable;
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ProtoStorageClientModule.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ProtoStorageClientModule.java
new file mode 100644
index 000000000..a1d29a1b8
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/ProtoStorageClientModule.java
@@ -0,0 +1,57 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.modules;
+
+import android.app.Application;
+import com.google.firebase.inappmessaging.internal.ProtoStorageClient;
+import com.google.firebase.inappmessaging.internal.injection.qualifiers.CampaignCache;
+import com.google.firebase.inappmessaging.internal.injection.qualifiers.ImpressionStore;
+import com.google.firebase.inappmessaging.internal.injection.qualifiers.RateLimit;
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Singleton;
+
+/**
+ * Bindings for proto storage client
+ *
+ * @hide
+ */
+@Module
+public class ProtoStorageClientModule {
+  public static final String CAMPAIGN_CACHE_FILE = "fiam_eligible_campaigns_cache_file";
+  public static final String IMPRESSIONS_STORE_FILE = "fiam_impressions_store_file";
+  public static final String RATE_LIMIT_STORE_FILE = "rate_limit_store_file";
+
+  @Provides
+  @Singleton
+  @CampaignCache
+  public ProtoStorageClient providesProtoStorageClientForCampaign(Application application) {
+    return new ProtoStorageClient(application, CAMPAIGN_CACHE_FILE);
+  }
+
+  @Provides
+  @Singleton
+  @ImpressionStore
+  public ProtoStorageClient providesProtoStorageClientForImpressionStore(Application application) {
+    return new ProtoStorageClient(application, IMPRESSIONS_STORE_FILE);
+  }
+
+  @Provides
+  @Singleton
+  @RateLimit
+  public ProtoStorageClient providesProtoStorageClientForLimiterStore(Application application) {
+    return new ProtoStorageClient(application, RATE_LIMIT_STORE_FILE);
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/RateLimitModule.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/RateLimitModule.java
new file mode 100644
index 000000000..0edb8c6bd
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/RateLimitModule.java
@@ -0,0 +1,42 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.modules;
+
+import com.google.firebase.inappmessaging.internal.injection.qualifiers.AppForeground;
+import com.google.firebase.inappmessaging.model.RateLimit;
+import dagger.Module;
+import dagger.Provides;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Bindings for rate limits
+ *
+ * @hide
+ */
+@Module
+public class RateLimitModule {
+  private static final String APP_FOREGROUND_ONE_PER_DAY_LIMITER_KEY =
+      "APP_FOREGROUND_ONE_PER_DAY_LIMITER_KEY";
+
+  @Provides
+  @AppForeground
+  public RateLimit providesAppForegroundRateLimit() {
+    return RateLimit.builder()
+        .setLimit(1)
+        .setLimiterKey(APP_FOREGROUND_ONE_PER_DAY_LIMITER_KEY)
+        .setTimeToLiveMillis(TimeUnit.DAYS.toMillis(1))
+        .build();
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/SchedulerModule.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/SchedulerModule.java
new file mode 100644
index 000000000..073c8a31f
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/SchedulerModule.java
@@ -0,0 +1,52 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.modules;
+
+import dagger.Module;
+import dagger.Provides;
+import io.reactivex.Scheduler;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.schedulers.Schedulers;
+import javax.inject.Named;
+import javax.inject.Singleton;
+
+/**
+ * Bindings for rx schedulers
+ *
+ * @hide
+ */
+@Module
+public class SchedulerModule {
+  @Provides
+  @Singleton
+  @Named("io")
+  public Scheduler providesIOScheduler() {
+    return Schedulers.io();
+  }
+
+  @Provides
+  @Singleton
+  @Named("compute")
+  public Scheduler providesComputeScheduler() {
+    return Schedulers.computation();
+  }
+
+  @Provides
+  @Singleton
+  @Named("main")
+  public Scheduler providesMainThreadScheduler() {
+    return AndroidSchedulers.mainThread();
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/SystemClockModule.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/SystemClockModule.java
new file mode 100644
index 000000000..d0ad947fd
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/SystemClockModule.java
@@ -0,0 +1,34 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.modules;
+
+import com.google.firebase.inappmessaging.internal.time.Clock;
+import com.google.firebase.inappmessaging.internal.time.SystemClock;
+import dagger.Module;
+import dagger.Provides;
+
+/**
+ * Bindings for system clock
+ *
+ * @hide
+ */
+@Module
+public class SystemClockModule {
+
+  @Provides
+  public Clock providesSystemClockModule() {
+    return new SystemClock();
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/TransportClientModule.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/TransportClientModule.java
new file mode 100644
index 000000000..03bbe7874
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/modules/TransportClientModule.java
@@ -0,0 +1,58 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.modules;
+
+import com.google.android.datatransport.Event;
+import com.google.android.datatransport.Transport;
+import com.google.android.datatransport.TransportFactory;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.inappmessaging.internal.DeveloperListenerManager;
+import com.google.firebase.inappmessaging.internal.MetricsLoggerClient;
+import com.google.firebase.inappmessaging.internal.injection.scopes.FirebaseAppScope;
+import com.google.firebase.inappmessaging.internal.time.Clock;
+import dagger.Module;
+import dagger.Provides;
+
+/**
+ * Bindings for engagementMetrics
+ *
+ * @hide
+ */
+@Module
+public class TransportClientModule {
+  private static final String TRANSPORT_NAME = "731";
+
+  @Provides
+  @FirebaseAppScope
+  static MetricsLoggerClient providesApiClient(
+      FirebaseApp app,
+      TransportFactory transportFactory,
+      AnalyticsConnector analyticsConnector,
+      FirebaseInstanceId firebaseInstanceId,
+      Clock clock,
+      DeveloperListenerManager developerListenerManager) {
+    Transport<byte[]> transport =
+        transportFactory.getTransport(TRANSPORT_NAME, byte[].class, b -> b);
+    return new MetricsLoggerClient(
+        bytes -> transport.send(Event.ofData(bytes)),
+        analyticsConnector,
+        app,
+        firebaseInstanceId,
+        clock,
+        developerListenerManager);
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/Analytics.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/Analytics.java
new file mode 100644
index 000000000..9768d4686
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/Analytics.java
@@ -0,0 +1,31 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.qualifiers;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+/**
+ * Dagger binding qualifier for analytics events.
+ *
+ * @hide
+ */
+@Qualifier
+@Documented
+@Retention(RUNTIME)
+public @interface Analytics {}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/AnalyticsListener.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/AnalyticsListener.java
new file mode 100644
index 000000000..f00e57c02
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/AnalyticsListener.java
@@ -0,0 +1,31 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.qualifiers;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+/**
+ * Dagger binding qualifier for analytics events.
+ *
+ * @hide
+ */
+@Qualifier
+@Documented
+@Retention(RUNTIME)
+public @interface AnalyticsListener {}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/AppForeground.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/AppForeground.java
new file mode 100644
index 000000000..145811fc1
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/AppForeground.java
@@ -0,0 +1,31 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.qualifiers;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+/**
+ * Dagger binding qualifier for app foreground events.
+ *
+ * @hide
+ */
+@Qualifier
+@Documented
+@Retention(RUNTIME)
+public @interface AppForeground {}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/CampaignCache.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/CampaignCache.java
new file mode 100644
index 000000000..729f3fbdd
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/CampaignCache.java
@@ -0,0 +1,31 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.qualifiers;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+/**
+ * Bindings for campaign cache
+ *
+ * @hide
+ */
+@Qualifier
+@Documented
+@Retention(RUNTIME)
+public @interface CampaignCache {}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/ImpressionStore.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/ImpressionStore.java
new file mode 100644
index 000000000..cb123fded
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/ImpressionStore.java
@@ -0,0 +1,31 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.qualifiers;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+/**
+ * Bindings for impression store
+ *
+ * @hide
+ */
+@Qualifier
+@Documented
+@Retention(RUNTIME)
+public @interface ImpressionStore {}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/ProgrammaticTrigger.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/ProgrammaticTrigger.java
new file mode 100644
index 000000000..43cc05ee9
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/ProgrammaticTrigger.java
@@ -0,0 +1,31 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.qualifiers;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+/**
+ * Dagger binding qualifier for app foreground events.
+ *
+ * @hide
+ */
+@Qualifier
+@Documented
+@Retention(RUNTIME)
+public @interface ProgrammaticTrigger {}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/RateLimit.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/RateLimit.java
new file mode 100644
index 000000000..64479f5f1
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/qualifiers/RateLimit.java
@@ -0,0 +1,31 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.qualifiers;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+/**
+ * Bindings for campaign cache
+ *
+ * @hide
+ */
+@Qualifier
+@Documented
+@Retention(RUNTIME)
+public @interface RateLimit {}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/scopes/FirebaseAppScope.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/scopes/FirebaseAppScope.java
new file mode 100644
index 000000000..86e2d2ac1
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/injection/scopes/FirebaseAppScope.java
@@ -0,0 +1,25 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.injection.scopes;
+
+import javax.inject.Scope;
+
+/**
+ * Dagger scope for per-app state
+ *
+ * @hide
+ */
+@Scope
+public @interface FirebaseAppScope {}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/package-info.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/package-info.java
new file mode 100644
index 000000000..18173dbff
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.firebase.inappmessaging.internal;
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/time/Clock.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/time/Clock.java
new file mode 100644
index 000000000..255f360d3
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/time/Clock.java
@@ -0,0 +1,28 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal.time;
+
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+
+/**
+ * Provides the current value of "now" to allow injecting time as a dependency for testing.
+ *
+ * @hide
+ */
+public interface Clock {
+  /** Returns the current, absolute time according to this clock. */
+  @CanIgnoreReturnValue
+  long now();
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/time/SystemClock.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/time/SystemClock.java
new file mode 100644
index 000000000..3db140ba3
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/internal/time/SystemClock.java
@@ -0,0 +1,34 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Copyright 2007 Google Inc.  All Rights Reserved.
+
+package com.google.firebase.inappmessaging.internal.time;
+
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import javax.inject.Inject;
+
+/** @hide */
+public class SystemClock implements Clock {
+
+  /** Creates a new instance. All {@code SystemClock} instances function identically. */
+  @Inject
+  public SystemClock() {}
+
+  @Override
+  @CanIgnoreReturnValue
+  public long now() {
+    return System.currentTimeMillis();
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/Action.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/Action.java
new file mode 100644
index 000000000..cde51c98f
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/Action.java
@@ -0,0 +1,125 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.model;
+
+import android.text.TextUtils;
+import androidx.annotation.Nullable;
+import com.google.firebase.inappmessaging.MessagesProto;
+
+/** Encapsulates an Action for a Firebase In App Message. */
+public class Action {
+  /**
+   * !!!!!WARNING!!!!! We are overriding equality in this class. Please add equality checks for all
+   * new private class members.
+   */
+  @Nullable private final String actionUrl;
+
+  @Nullable private final Button button;
+
+  /** @hide */
+  @Override
+  public int hashCode() {
+    int urlHash = actionUrl != null ? actionUrl.hashCode() : 0;
+    int buttonHash = button != null ? button.hashCode() : 0;
+    return urlHash + buttonHash;
+  }
+
+  /** @hide */
+  @Override
+  public boolean equals(Object o) {
+    if (o == this) {
+      return true; // same instance
+    }
+    if (!(o instanceof Action)) {
+      return false; // not the correct instance type
+    }
+    Action a = (Action) o;
+    if (hashCode() != a.hashCode()) {
+      return false; // the hashcodes don't match
+    }
+    if ((actionUrl == null && a.actionUrl != null)
+        || (actionUrl != null && !actionUrl.equals(a.actionUrl))) {
+      return false; // the actionUrls don't match
+    }
+    if ((button == null && a.button == null) || (button != null && button.equals(a.button))) {
+      return true; // either both buttons are null, or the two are equal
+    }
+    return false;
+  }
+  /**
+   * !!!!!WARNING!!!!! We are overriding equality in this class. Please add equality checks for all
+   * new private class members.
+   */
+  private Action(@Nullable String actionUrl, @Nullable Button button) {
+    this.actionUrl = actionUrl;
+    this.button = button;
+  }
+
+  /** Gets URL for action */
+  @Nullable
+  public String getActionUrl() {
+    return actionUrl;
+  }
+
+  /** Gets the {@link Button} associated with this action */
+  @Nullable
+  public Button getButton() {
+    return button;
+  }
+
+  /**
+   * only used by headless sdk and tests
+   *
+   * @hide
+   */
+  public static Builder builder() {
+    return new Builder();
+  }
+
+  /**
+   * Builder for {@link Action}
+   *
+   * @hide
+   */
+  public static class Builder {
+    @Nullable private String actionUrl;
+    @Nullable private Button button;
+
+    public Builder setActionUrl(@Nullable String actionUrl) {
+      if (!TextUtils.isEmpty(actionUrl)) {
+        this.actionUrl = actionUrl;
+      }
+      return this;
+    }
+
+    public Builder setButton(@Nullable Button button) {
+      this.button = button;
+      return this;
+    }
+
+    public Builder setButton(MessagesProto.Button button) {
+      Button.Builder buttonBuilder = new Button.Builder();
+      buttonBuilder.setButtonHexColor(button.getButtonHexColor());
+      buttonBuilder.setText(button.getText());
+      return this;
+    }
+
+    // Technically an action can be completely null although in practice only one field at a time
+    // is ever null. Unfortunately there is no better way to model this.
+    public Action build() {
+      return new Action(actionUrl, button);
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/BannerMessage.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/BannerMessage.java
new file mode 100644
index 000000000..a1499bbcb
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/BannerMessage.java
@@ -0,0 +1,186 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.model;
+
+import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import javax.annotation.Nullable;
+
+/** Encapsulates a Firebase In App Banner Message. */
+public class BannerMessage extends InAppMessage {
+  /**
+   * !!!!!WARNING!!!!! We are overriding equality in this class. Please add equality checks for all
+   * new private class members.
+   */
+  @NonNull private final Text title;
+
+  @Nullable private final Text body;
+  @Nullable private final ImageData imageData;
+  @Nullable private final Action action;
+  @NonNull private final String backgroundHexColor;
+
+  /** @hide */
+  @Override
+  public int hashCode() {
+    int bodyHash = body != null ? body.hashCode() : 0;
+    int imageHash = imageData != null ? imageData.hashCode() : 0;
+    int actionHash = action != null ? action.hashCode() : 0;
+    return title.hashCode() + bodyHash + imageHash + actionHash + backgroundHexColor.hashCode();
+  }
+
+  /** @hide */
+  @Override
+  public boolean equals(Object o) {
+    if (o == this) {
+      return true; // same instance
+    }
+    if (!(o instanceof BannerMessage)) {
+      return false; // not the correct instance type
+    }
+    BannerMessage b = (BannerMessage) o;
+    if (hashCode() != b.hashCode()) {
+      return false; // the hashcodes don't match
+    }
+    if ((body == null && b.body != null) || (body != null && !body.equals(b.body))) {
+      return false; // the bodies don't match
+    }
+    if ((imageData == null && b.imageData != null)
+        || (imageData != null && !imageData.equals(b.imageData))) {
+      return false; // the images don't match
+    }
+    if ((action == null && b.action != null) || (action != null && !action.equals(b.action))) {
+      return false; // the actions don't match
+    }
+    if (!title.equals(b.title)) {
+      return false; // the tiles don't match
+    }
+    if (backgroundHexColor.equals(b.backgroundHexColor)) {
+      return true; // everything matches
+    }
+    return false;
+  }
+  /**
+   * !!!!!WARNING!!!!! We are overriding equality in this class. Please add equality checks for all
+   * new private class members.
+   */
+  private BannerMessage(
+      @NonNull CampaignMetadata campaignMetadata,
+      @NonNull Text title,
+      @Nullable Text body,
+      @Nullable ImageData imageData,
+      @Nullable Action action,
+      @NonNull String backgroundHexColor) {
+    super(campaignMetadata, MessageType.BANNER);
+    this.title = title;
+    this.body = body;
+    this.imageData = imageData;
+    this.action = action;
+    this.backgroundHexColor = backgroundHexColor;
+  }
+
+  /** Gets the title {@link Text} associated with this message */
+  @Override
+  @NonNull
+  public Text getTitle() {
+    return title;
+  }
+
+  /** Gets the body {@link Text} associated with this message */
+  @Override
+  @Nullable
+  public Text getBody() {
+    return body;
+  }
+
+  /** Gets the {@link ImageData} associated with this message */
+  @Override
+  @Nullable
+  public ImageData getImageData() {
+    return imageData;
+  }
+
+  /** Gets the {@link Action} associated with this message */
+  @Override
+  @Nullable
+  public Action getAction() {
+    return action;
+  }
+
+  /** Gets the background hex color associated with this message */
+  @Override
+  @NonNull
+  public String getBackgroundHexColor() {
+    return backgroundHexColor;
+  }
+
+  /**
+   * only used by headless sdk and tests
+   *
+   * @hide
+   */
+  public static Builder builder() {
+    return new BannerMessage.Builder();
+  }
+
+  /**
+   * Builder for {@link BannerMessage}
+   *
+   * @hide
+   */
+  public static class Builder {
+    @Nullable Text title;
+    @Nullable Text body;
+    @Nullable ImageData imageData;
+    @Nullable Action action;
+    @Nullable String backgroundHexColor;
+
+    public Builder setTitle(@Nullable Text title) {
+      this.title = title;
+      return this;
+    }
+
+    public Builder setBody(@Nullable Text body) {
+      this.body = body;
+      return this;
+    }
+
+    public Builder setImageData(@Nullable ImageData imageData) {
+      this.imageData = imageData;
+      return this;
+    }
+
+    public Builder setAction(@Nullable Action action) {
+      this.action = action;
+      return this;
+    }
+
+    public Builder setBackgroundHexColor(@Nullable String backgroundHexColor) {
+      this.backgroundHexColor = backgroundHexColor;
+      return this;
+    }
+
+    public BannerMessage build(CampaignMetadata campaignMetadata) {
+      if (title == null) {
+        throw new IllegalArgumentException("Banner model must have a title");
+      }
+      if (TextUtils.isEmpty(backgroundHexColor)) {
+        throw new IllegalArgumentException("Banner model must have a background color");
+      }
+      // We know backgroundColor is not null here because isEmpty checks for null.
+      return new BannerMessage(
+          campaignMetadata, title, body, imageData, action, backgroundHexColor);
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/Button.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/Button.java
new file mode 100644
index 000000000..ec689ddc1
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/Button.java
@@ -0,0 +1,126 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.model;
+
+import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.google.firebase.inappmessaging.MessagesProto;
+
+/** Encapsulates any button used in a Firebase In App Message. */
+public class Button {
+  /**
+   * !!!!!WARNING!!!!! We are overriding equality in this class. Please add equality checks for all
+   * new private class members.
+   */
+  @NonNull private final Text text;
+
+  @NonNull private final String buttonHexColor;
+
+  /** @hide */
+  @Override
+  public int hashCode() {
+    return text.hashCode() + buttonHexColor.hashCode();
+  }
+
+  /** @hide */
+  @Override
+  public boolean equals(Object o) {
+    if (o == this) {
+      return true; // same instance
+    }
+    if (!(o instanceof Button)) {
+      return false; // not the correct instance type
+    }
+    Button b = (Button) o;
+    if (hashCode() != b.hashCode()) {
+      return false; // the hashcodes don't match
+    }
+    if (!text.equals(b.text)) {
+      return false; // the texts don't match
+    }
+    if (buttonHexColor.equals(b.buttonHexColor)) {
+      return true; // everything matches
+    }
+    return false;
+  }
+  /**
+   * !!!!!WARNING!!!!! We are overriding equality in this class. Please add equality checks for all
+   * new private class members.
+   */
+  private Button(@NonNull Text text, @NonNull String buttonHexColor) {
+    this.text = text;
+    this.buttonHexColor = buttonHexColor;
+  }
+
+  /** Gets the {@link Text} associated with this button */
+  @NonNull
+  public Text getText() {
+    return text;
+  }
+
+  /** Gets the background hex color associated with this button */
+  @NonNull
+  public String getButtonHexColor() {
+    return buttonHexColor;
+  }
+
+  /**
+   * only used by headless sdk and tests
+   *
+   * @hide
+   */
+  public static Builder builder() {
+    return new Builder();
+  }
+
+  /**
+   * Builder for {@link Button}
+   *
+   * @hide
+   */
+  public static class Builder {
+    @Nullable private Text text;
+    @Nullable private String buttonHexColor;
+
+    public Builder setText(@Nullable Text text) {
+      this.text = text;
+      return this;
+    }
+
+    public Builder setText(MessagesProto.Text text) {
+      Text.Builder textBuilder = new Text.Builder();
+      textBuilder.setText(text);
+      this.text = textBuilder.build();
+      return this;
+    }
+
+    public Builder setButtonHexColor(@Nullable String buttonHexColor) {
+      this.buttonHexColor = buttonHexColor;
+      return this;
+    }
+
+    public Button build() {
+      if (TextUtils.isEmpty(buttonHexColor)) {
+        throw new IllegalArgumentException("Button model must have a color");
+      }
+      if (text == null) {
+        throw new IllegalArgumentException("Button model must have text");
+      }
+      // We know buttonColor is not null here because isEmpty checks for null.
+      return new Button(text, buttonHexColor);
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/CampaignMetadata.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/CampaignMetadata.java
new file mode 100644
index 000000000..9c184cc49
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/CampaignMetadata.java
@@ -0,0 +1,49 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.model;
+
+import androidx.annotation.NonNull;
+
+/** Provides the following about any message, */
+public class CampaignMetadata {
+  private final String campaignId;
+  private final String campaignName;
+  private final boolean isTestMessage;
+
+  /**
+   * This is only used by the FIAM internal SDK
+   *
+   * @hide
+   */
+  public CampaignMetadata(String campaignId, String campaignName, boolean isTestMessage) {
+    this.campaignId = campaignId;
+    this.campaignName = campaignName;
+    this.isTestMessage = isTestMessage;
+  }
+
+  @NonNull
+  public String getCampaignId() {
+    return campaignId;
+  }
+
+  @NonNull
+  public String getCampaignName() {
+    return campaignName;
+  }
+
+  public boolean getIsTestMessage() {
+    return isTestMessage;
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/CardMessage.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/CardMessage.java
new file mode 100644
index 000000000..fc404f030
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/CardMessage.java
@@ -0,0 +1,275 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.model;
+
+import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+/** Encapsulates a Firebase In App Card Message. */
+public class CardMessage extends InAppMessage {
+  /**
+   * !!!!!WARNING!!!!! We are overriding equality in this class. Please add equality checks for all
+   * new private class members.
+   */
+  @NonNull private final Text title;
+
+  @Nullable private final Text body;
+  @NonNull private final String backgroundHexColor;
+  @NonNull private final Action primaryAction;
+  @Nullable private final Action secondaryAction;
+  @Nullable private final ImageData portraitImageData;
+  @Nullable private final ImageData landscapeImageData;
+
+  /** @hide */
+  @Override
+  public int hashCode() {
+    int bodyHash = body != null ? body.hashCode() : 0;
+    int secondaryActionHash = secondaryAction != null ? secondaryAction.hashCode() : 0;
+    int portraitImageHash = portraitImageData != null ? portraitImageData.hashCode() : 0;
+    int landscapeImageHash = landscapeImageData != null ? landscapeImageData.hashCode() : 0;
+    return title.hashCode()
+        + bodyHash
+        + backgroundHexColor.hashCode()
+        + primaryAction.hashCode()
+        + secondaryActionHash
+        + portraitImageHash
+        + landscapeImageHash;
+  }
+
+  /** @hide */
+  @Override
+  public boolean equals(Object o) {
+    if (o == this) {
+      return true; // same instance
+    }
+    if (!(o instanceof CardMessage)) {
+      return false; // not the correct instance type
+    }
+    CardMessage c = (CardMessage) o;
+    if (hashCode() != c.hashCode()) {
+      return false; // the hashcodes don't match
+    }
+    if ((body == null && c.body != null) || (body != null && !body.equals(c.body))) {
+      return false; // the bodies don't match
+    }
+    if ((secondaryAction == null && c.secondaryAction != null)
+        || (secondaryAction != null && !secondaryAction.equals(c.secondaryAction))) {
+      return false; // the secondary actions don't match
+    }
+    if ((portraitImageData == null && c.portraitImageData != null)
+        || (portraitImageData != null && !portraitImageData.equals(c.portraitImageData))) {
+      return false; // the portrait image data don't match
+    }
+    if ((landscapeImageData == null && c.landscapeImageData != null)
+        || (landscapeImageData != null && !landscapeImageData.equals(c.landscapeImageData))) {
+      return false; // the landscape image data don't match
+    }
+    if (!title.equals(c.title)) {
+      return false; // the titles don't match
+    }
+    if (!primaryAction.equals(c.primaryAction)) {
+      return false; // the primary actions don't match
+    }
+    if (backgroundHexColor.equals(c.backgroundHexColor)) {
+      return true; // everything matches
+    }
+    return false;
+  }
+  /**
+   * !!!!!WARNING!!!!! We are overriding equality in this class. Please add equality checks for all
+   * new private class members.
+   */
+  private CardMessage(
+      @NonNull CampaignMetadata campaignMetadata,
+      @NonNull Text title,
+      @Nullable Text body,
+      @Nullable ImageData portraitImageData,
+      @Nullable ImageData landscapeImageData,
+      @NonNull String backgroundHexColor,
+      @NonNull Action primaryAction,
+      @Nullable Action secondaryAction) {
+    super(campaignMetadata, MessageType.CARD);
+    this.title = title;
+    this.body = body;
+    this.portraitImageData = portraitImageData;
+    this.landscapeImageData = landscapeImageData;
+    this.backgroundHexColor = backgroundHexColor;
+    this.primaryAction = primaryAction;
+    this.secondaryAction = secondaryAction;
+  }
+
+  /** Gets the {@link ImageData} displayed when the phone is in a portrait orientation */
+  @Nullable
+  public ImageData getPortraitImageData() {
+    return portraitImageData;
+  }
+
+  /** Gets the {@link ImageData} displayed when the phone is in a landcscape orientation */
+  @Nullable
+  public ImageData getLandscapeImageData() {
+    return landscapeImageData;
+  }
+
+  /** Gets the background hex color associated with this message */
+  @Override
+  @NonNull
+  public String getBackgroundHexColor() {
+    return backgroundHexColor;
+  }
+
+  /**
+   * Gets the primary {@link Action} associated with this message. If none is defined, the primary
+   * action is 'dismiss'
+   */
+  @NonNull
+  public Action getPrimaryAction() {
+    return primaryAction;
+  }
+
+  /** Gets the secondary {@link Action} associated with this message */
+  @Nullable
+  public Action getSecondaryAction() {
+    return secondaryAction;
+  }
+
+  /**
+   * Deprecated - Use getPrimaryAction() instead. Gets the primary {@link Action} associated with
+   * this message
+   */
+  @Nullable
+  @Deprecated
+  @Override
+  public Action getAction() {
+    return primaryAction;
+  }
+
+  /** Gets the title {@link Text} associated with this message */
+  @Override
+  @NonNull
+  public Text getTitle() {
+    return title;
+  }
+
+  /** Gets the body {@link Text} associated with this message */
+  @Override
+  @Nullable
+  public Text getBody() {
+    return body;
+  }
+
+  /**
+   * Deprecated - Use getPortraitImageData() instead. Gets the {@link ImageData} associated with
+   * this message
+   */
+  @Nullable
+  @Deprecated
+  @Override
+  public ImageData getImageData() {
+    return portraitImageData;
+  }
+
+  /**
+   * only used by headless sdk and tests
+   *
+   * @hide
+   */
+  public static Builder builder() {
+    return new CardMessage.Builder();
+  }
+
+  /**
+   * Builder for {@link CardMessage}
+   *
+   * @hide
+   */
+  public static class Builder {
+    @Nullable ImageData portraitImageData;
+    @Nullable ImageData landscapeImageData;
+    @Nullable String backgroundHexColor;
+    @Nullable Action primaryAction;
+    @Nullable Text title;
+    @Nullable Text body;
+    @Nullable Action secondaryAction;
+
+    public Builder setPortraitImageData(@Nullable ImageData portraitImageData) {
+      this.portraitImageData = portraitImageData;
+      return this;
+    }
+
+    public Builder setLandscapeImageData(@Nullable ImageData landscapeImageData) {
+      this.landscapeImageData = landscapeImageData;
+      return this;
+    }
+
+    public Builder setBackgroundHexColor(@Nullable String backgroundHexColor) {
+      this.backgroundHexColor = backgroundHexColor;
+      return this;
+    }
+
+    public Builder setPrimaryAction(@Nullable Action primaryAction) {
+      this.primaryAction = primaryAction;
+      return this;
+    }
+
+    public Builder setSecondaryAction(@Nullable Action secondaryAction) {
+      this.secondaryAction = secondaryAction;
+      return this;
+    }
+
+    public Builder setTitle(@Nullable Text title) {
+      this.title = title;
+      return this;
+    }
+
+    public Builder setBody(@Nullable Text body) {
+      this.body = body;
+      return this;
+    }
+
+    public CardMessage build(CampaignMetadata campaignMetadata) {
+      if (primaryAction == null) {
+        throw new IllegalArgumentException("Card model must have a primary action");
+      }
+      if (primaryAction.getButton() == null) {
+        throw new IllegalArgumentException("Card model must have a primary action button");
+      }
+      if (secondaryAction != null && secondaryAction.getButton() == null) {
+        throw new IllegalArgumentException(
+            "Card model secondary action must be null or have a button");
+      }
+      if (title == null) {
+        throw new IllegalArgumentException("Card model must have a title");
+      }
+      if (portraitImageData == null && landscapeImageData == null) {
+        throw new IllegalArgumentException("Card model must have at least one image");
+      }
+      if (TextUtils.isEmpty(backgroundHexColor)) {
+        throw new IllegalArgumentException("Card model must have a background color");
+      }
+
+      // We know backgroundColor is not null here because isEmpty checks for null.
+      return new CardMessage(
+          campaignMetadata,
+          title,
+          body,
+          portraitImageData,
+          landscapeImageData,
+          backgroundHexColor,
+          primaryAction,
+          secondaryAction);
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/ImageData.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/ImageData.java
new file mode 100644
index 000000000..92b89f683
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/ImageData.java
@@ -0,0 +1,117 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.model;
+
+import android.graphics.Bitmap;
+import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+/** Encapsulates an image to be displayed within a Firebase In App Message. */
+public class ImageData {
+  /**
+   * !!!!!WARNING!!!!! We are overriding equality in this class. Please add equality checks for all
+   * new private class members.
+   */
+  @NonNull private final String imageUrl;
+
+  @Nullable private final Bitmap bitmapData;
+
+  /** @hide */
+  @Override
+  public int hashCode() {
+    int bitmapHash = bitmapData != null ? bitmapData.hashCode() : 0;
+    return imageUrl.hashCode() + bitmapHash;
+  }
+
+  /** @hide */
+  @Override
+  public boolean equals(Object o) {
+    if (o == this) {
+      return true; // same instance
+    }
+    if (!(o instanceof ImageData)) {
+      return false; // not the correct instance type
+    }
+    ImageData i = (ImageData) o;
+    if (hashCode() != i.hashCode()) {
+      return false; // the hashcodes don't match
+    }
+    if (imageUrl.equals(i.imageUrl)) {
+      return true; // everything matches
+    }
+    return false;
+  }
+  /**
+   * !!!!!WARNING!!!!! We are overriding equality in this class. Please add equality checks for all
+   * new private class members.
+   */
+
+  /** @hide */
+  public ImageData(@NonNull String imageUrl, @Nullable Bitmap bitmapData) {
+    this.imageUrl = imageUrl;
+    this.bitmapData = bitmapData;
+  }
+
+  @NonNull
+  public String getImageUrl() {
+    return imageUrl;
+  }
+
+  @Nullable
+  public Bitmap getBitmapData() {
+    return bitmapData;
+  }
+
+  /**
+   * only used by headless sdk and tests
+   *
+   * @hide
+   */
+  public static Builder builder() {
+    return new Builder();
+  }
+
+  /**
+   * Builder for {@link ImageData}
+   *
+   * @hide
+   */
+  public static class Builder {
+    @Nullable private String imageUrl;
+    @Nullable private Bitmap bitmapData;
+
+    public Builder setImageUrl(@Nullable String imageUrl) {
+      if (!TextUtils.isEmpty(imageUrl)) {
+        this.imageUrl = imageUrl;
+      }
+      return this;
+    }
+
+    public Builder setBitmapData(@Nullable Bitmap bitmapData) {
+      this.bitmapData = bitmapData;
+      return this;
+    }
+
+    public ImageData build() {
+      if (TextUtils.isEmpty(imageUrl)) {
+        throw new IllegalArgumentException("ImageData model must have an imageUrl");
+      }
+
+      // We know imageUrl is not null here because isEmpty checks for null.
+      return new ImageData(imageUrl, bitmapData);
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/ImageOnlyMessage.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/ImageOnlyMessage.java
new file mode 100644
index 000000000..33e13f25c
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/ImageOnlyMessage.java
@@ -0,0 +1,120 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.model;
+
+import androidx.annotation.NonNull;
+import javax.annotation.Nullable;
+
+/** Encapsulates a Firebase In App ImageOnly Message. */
+public class ImageOnlyMessage extends InAppMessage {
+  /**
+   * !!!!!WARNING!!!!! We are overriding equality in this class. Please add equality checks for all
+   * new private class members.
+   */
+  @NonNull private ImageData imageData;
+
+  @Nullable private Action action;
+
+  /** @hide */
+  @Override
+  public int hashCode() {
+    int actionHash = action != null ? action.hashCode() : 0;
+    return imageData.hashCode() + actionHash;
+  }
+
+  /** @hide */
+  @Override
+  public boolean equals(Object o) {
+    if (o == this) {
+      return true; // same instance
+    }
+    if (!(o instanceof ImageOnlyMessage)) {
+      return false; // not the correct instance type
+    }
+    ImageOnlyMessage i = (ImageOnlyMessage) o;
+    if (hashCode() != i.hashCode()) {
+      return false; // the hashcodes don't match
+    }
+    if ((action == null && i.action != null) || (action != null && !action.equals(i.action))) {
+      return false; // the actions don't match
+    }
+    if (imageData.equals(i.imageData)) {
+      return true; // everything matches
+    }
+    return false;
+  }
+  /**
+   * !!!!!WARNING!!!!! We are overriding equality in this class. Please add equality checks for all
+   * new private class members.
+   */
+  private ImageOnlyMessage(
+      @NonNull CampaignMetadata campaignMetadata,
+      @NonNull ImageData imageData,
+      @Nullable Action action) {
+    super(campaignMetadata, MessageType.IMAGE_ONLY);
+    this.imageData = imageData;
+    this.action = action;
+  }
+
+  /** Gets the {@link ImageData} associated with this message */
+  @Override
+  @NonNull
+  public ImageData getImageData() {
+    return imageData;
+  }
+
+  /** Gets the {@link Action} associated with this message */
+  @Override
+  @Nullable
+  public Action getAction() {
+    return action;
+  }
+
+  /**
+   * only used by headless sdk and tests
+   *
+   * @hide
+   */
+  public static Builder builder() {
+    return new Builder();
+  }
+
+  /**
+   * Builder for {@link ImageOnlyMessage}
+   *
+   * @hide
+   */
+  public static class Builder {
+    @Nullable ImageData imageData;
+    @Nullable Action action;
+
+    public Builder setImageData(@Nullable ImageData imageData) {
+      this.imageData = imageData;
+      return this;
+    }
+
+    public Builder setAction(@Nullable Action action) {
+      this.action = action;
+      return this;
+    }
+
+    public ImageOnlyMessage build(CampaignMetadata campaignMetadata) {
+      if (imageData == null) {
+        throw new IllegalArgumentException("ImageOnly model must have image data");
+      }
+      return new ImageOnlyMessage(campaignMetadata, imageData, action);
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/InAppMessage.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/InAppMessage.java
new file mode 100644
index 000000000..c92878ced
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/InAppMessage.java
@@ -0,0 +1,148 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.model;
+
+import androidx.annotation.Nullable;
+
+/** Encapsulates a Firebase In App Message. */
+public abstract class InAppMessage {
+
+  @Deprecated Text title;
+  @Deprecated Text body;
+  @Deprecated String imageUrl;
+  @Deprecated ImageData imageData;
+  @Deprecated Button actionButton;
+  @Deprecated String backgroundHexColor;
+  @Deprecated String campaignId;
+  @Deprecated String campaignName;
+  @Deprecated Boolean isTestMessage;
+  MessageType messageType;
+  CampaignMetadata campaignMetadata;
+
+  /** @hide */
+  @Deprecated
+  public InAppMessage(
+      Text title,
+      Text body,
+      String imageUrl,
+      ImageData imageData,
+      Button actionButton,
+      Action action,
+      String backgroundHexColor,
+      String campaignId,
+      String campaignName,
+      Boolean isTestMessage,
+      MessageType messageType) {
+    this.title = title;
+    this.body = body;
+    this.imageUrl = imageUrl;
+    this.imageData = imageData;
+    this.actionButton = actionButton;
+    this.backgroundHexColor = backgroundHexColor;
+    this.campaignId = campaignId;
+    this.campaignName = campaignName;
+    this.isTestMessage = isTestMessage;
+    this.messageType = messageType;
+    this.campaignMetadata = new CampaignMetadata(campaignId, campaignName, isTestMessage);
+  }
+
+  /** @hide */
+  public InAppMessage(CampaignMetadata campaignMetadata, MessageType messageType) {
+    this.campaignMetadata = campaignMetadata;
+    this.messageType = messageType;
+  }
+
+  /** Deprecated - Use the message specific methods instead. */
+  @Nullable
+  @Deprecated
+  public Text getTitle() {
+    return title;
+  }
+
+  /** Deprecated - Use the message specific methods (see {@link CardMessage}) instead. */
+  @Nullable
+  @Deprecated
+  public Text getBody() {
+    return body;
+  }
+
+  /** Deprecated - Use the message specific methods (see {@link CardMessage}) instead. */
+  @Nullable
+  @Deprecated
+  public String getImageUrl() {
+    return imageUrl;
+  }
+
+  /** Deprecated - Use the message specific methods (see {@link CardMessage}) instead. */
+  @Nullable
+  @Deprecated
+  public ImageData getImageData() {
+    return imageData;
+  }
+
+  /** Deprecated - Use the message specific methods (see {@link CardMessage}) */
+  @Nullable
+  @Deprecated
+  public Button getActionButton() {
+    if (getAction() != null) {
+      return getAction().getButton();
+    }
+    return actionButton;
+  }
+
+  /** Deprecated - Use the message specific methods (see {@link CardMessage}) instead. */
+  @Deprecated
+  @Nullable
+  public abstract Action getAction();
+
+  /** Deprecated - Use the message specific methods (see {@link CardMessage}) instead. */
+  @Nullable
+  @Deprecated
+  public String getBackgroundHexColor() {
+    return backgroundHexColor;
+  }
+
+  /** Deprecated - Use getCampaignMetadata().getCampaignId() instead. */
+  @Nullable
+  @Deprecated
+  public String getCampaignId() {
+    return campaignMetadata.getCampaignId();
+  }
+
+  /** Deprecated - Use getCampaignMetadata().getCampaignName() instead. */
+  @Nullable
+  @Deprecated
+  public String getCampaignName() {
+    return campaignMetadata.getCampaignName();
+  }
+
+  /** Deprecated - Use getCampaignMetadata().getIsTestMessage() instead. */
+  @Nullable
+  @Deprecated
+  public Boolean getIsTestMessage() {
+    return campaignMetadata.getIsTestMessage();
+  }
+
+  /** Gets the {@link MessageType} of the message */
+  @Nullable
+  public MessageType getMessageType() {
+    return messageType;
+  }
+  /** Gets the {@link CampaignMetadata} of the message */
+  @Nullable
+  public CampaignMetadata getCampaignMetadata() {
+    return campaignMetadata;
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/MessageType.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/MessageType.java
new file mode 100644
index 000000000..0f21e9ddf
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/MessageType.java
@@ -0,0 +1,32 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.model;
+
+import androidx.annotation.Keep;
+
+/** Template type of an in-app message */
+@Keep
+public enum MessageType {
+  @Keep
+  UNSUPPORTED,
+  @Keep
+  MODAL,
+  @Keep
+  IMAGE_ONLY,
+  @Keep
+  BANNER,
+  @Keep
+  CARD
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/ModalMessage.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/ModalMessage.java
new file mode 100644
index 000000000..23f365546
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/ModalMessage.java
@@ -0,0 +1,189 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.model;
+
+import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import javax.annotation.Nullable;
+
+/** Encapsulates a Firebase In App Modal Message. */
+public class ModalMessage extends InAppMessage {
+  /**
+   * !!!!!WARNING!!!!! We are overriding equality in this class. Please add equality checks for all
+   * new private class members.
+   */
+  @NonNull private final Text title;
+
+  @Nullable private final Text body;
+  @Nullable private final ImageData imageData;
+  @Nullable private final Action action;
+  @NonNull private final String backgroundHexColor;
+
+  /** @hide */
+  @Override
+  public int hashCode() {
+    int bodyHash = body != null ? body.hashCode() : 0;
+    int actionHash = action != null ? action.hashCode() : 0;
+    int imageHash = imageData != null ? imageData.hashCode() : 0;
+    return title.hashCode() + bodyHash + backgroundHexColor.hashCode() + actionHash + imageHash;
+  }
+
+  /** @hide */
+  @Override
+  public boolean equals(Object o) {
+    if (o == this) {
+      return true; // same instance
+    }
+    if (!(o instanceof ModalMessage)) {
+      return false; // not the correct instance type
+    }
+    ModalMessage m = (ModalMessage) o;
+    if (hashCode() != m.hashCode()) {
+      return false; // the hashcodes don't match
+    }
+    if ((body == null && m.body != null) || (body != null && !body.equals(m.body))) {
+      return false; // the bodies don't match
+    }
+    if ((action == null && m.action != null) || (action != null && !action.equals(m.action))) {
+      return false; // the actions don't match
+    }
+    if ((imageData == null && m.imageData != null)
+        || (imageData != null && !imageData.equals(m.imageData))) {
+      return false; // the image data don't match
+    }
+    if (!title.equals(m.title)) {
+      return false; // the titles don't match
+    }
+    if (backgroundHexColor.equals(m.backgroundHexColor)) {
+      return true; // everything matches
+    }
+    return false;
+  }
+  /**
+   * !!!!!WARNING!!!!! We are overriding equality in this class. Please add equality checks for all
+   * new private class members.
+   */
+  private ModalMessage(
+      @NonNull CampaignMetadata campaignMetadata,
+      @NonNull Text title,
+      @Nullable Text body,
+      @Nullable ImageData imageData,
+      @Nullable Action action,
+      @NonNull String backgroundHexColor) {
+    super(campaignMetadata, MessageType.MODAL);
+    this.title = title;
+    this.body = body;
+    this.imageData = imageData;
+    this.action = action;
+    this.backgroundHexColor = backgroundHexColor;
+  }
+
+  /** Gets the title {@link Text} associated with this message */
+  @Override
+  @NonNull
+  public Text getTitle() {
+    return title;
+  }
+
+  /** Gets the body {@link Text} associated with this message */
+  @Override
+  @Nullable
+  public Text getBody() {
+    return body;
+  }
+
+  /** Gets the {@link ImageData} associated with this message */
+  @Override
+  @Nullable
+  public ImageData getImageData() {
+    return imageData;
+  }
+
+  /** Gets the background hex color associated with this message */
+  @Override
+  @NonNull
+  public String getBackgroundHexColor() {
+    return backgroundHexColor;
+  }
+
+  /** Gets the {@link Action} associated with this message */
+  @Override
+  @Nullable
+  public Action getAction() {
+    return action;
+  }
+
+  /**
+   * only used by headless sdk and tests
+   *
+   * @hide
+   */
+  public static Builder builder() {
+    return new ModalMessage.Builder();
+  }
+
+  /**
+   * Builder for {@link ModalMessage}
+   *
+   * @hide
+   */
+  public static class Builder {
+    @Nullable Text title;
+    @Nullable Text body;
+    @Nullable ImageData imageData;
+    @Nullable Action action;
+    @Nullable String backgroundHexColor;
+
+    public Builder setTitle(@Nullable Text title) {
+      this.title = title;
+      return this;
+    }
+
+    public Builder setBody(@Nullable Text body) {
+      this.body = body;
+      return this;
+    }
+
+    public Builder setImageData(@Nullable ImageData imageData) {
+      this.imageData = imageData;
+      return this;
+    }
+
+    public Builder setAction(@Nullable Action action) {
+      this.action = action;
+      return this;
+    }
+
+    public Builder setBackgroundHexColor(@Nullable String backgroundHexColor) {
+      this.backgroundHexColor = backgroundHexColor;
+      return this;
+    }
+
+    public ModalMessage build(CampaignMetadata campaignMetadata) {
+      if (title == null) {
+        throw new IllegalArgumentException("Modal model must have a title");
+      }
+      if (action != null && action.getButton() == null) {
+        throw new IllegalArgumentException("Modal model action must be null or have a button");
+      }
+      if (TextUtils.isEmpty(backgroundHexColor)) {
+        throw new IllegalArgumentException("Modal model must have a background color");
+      }
+
+      // We know backgroundColor is not null here because isEmpty checks for null.
+      return new ModalMessage(campaignMetadata, title, body, imageData, action, backgroundHexColor);
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/ProtoMarshallerClient.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/ProtoMarshallerClient.java
new file mode 100644
index 000000000..6939a26d7
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/ProtoMarshallerClient.java
@@ -0,0 +1,238 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.model;
+
+import android.text.TextUtils;
+import com.google.common.base.Preconditions;
+import com.google.firebase.inappmessaging.MessagesProto;
+import com.google.firebase.inappmessaging.internal.Logging;
+import javax.annotation.Nonnull;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+/**
+ * Class to transform internal proto representation to externalized parcelable objects. See {@link
+ * InAppMessage}.
+ *
+ * <p>Note that an object is inflated only if it is defined in the proto and is null otherwise.
+ *
+ * @hide
+ */
+@Singleton
+public class ProtoMarshallerClient {
+  @Inject
+  ProtoMarshallerClient() {}
+
+  @Nonnull
+  private static ModalMessage.Builder from(MessagesProto.ModalMessage in) {
+    ModalMessage.Builder builder = ModalMessage.builder();
+
+    if (!TextUtils.isEmpty(in.getBackgroundHexColor())) {
+      builder.setBackgroundHexColor(in.getBackgroundHexColor());
+    }
+
+    if (!TextUtils.isEmpty(in.getImageUrl())) {
+      builder.setImageData(ImageData.builder().setImageUrl(in.getImageUrl()).build());
+    }
+
+    if (in.hasAction()) {
+      builder.setAction(decode(in.getAction(), in.getActionButton()));
+    }
+
+    if (in.hasBody()) {
+      builder.setBody(decode(in.getBody()));
+    }
+
+    if (in.hasTitle()) {
+      builder.setTitle(decode(in.getTitle()));
+    }
+
+    return builder;
+  }
+
+  @Nonnull
+  private static ImageOnlyMessage.Builder from(MessagesProto.ImageOnlyMessage in) {
+    ImageOnlyMessage.Builder builder = ImageOnlyMessage.builder();
+
+    if (!TextUtils.isEmpty(in.getImageUrl())) {
+      builder.setImageData(ImageData.builder().setImageUrl(in.getImageUrl()).build());
+    }
+
+    if (in.hasAction()) {
+      builder.setAction(decode(in.getAction()).build());
+    }
+
+    return builder;
+  }
+
+  @Nonnull
+  private static BannerMessage.Builder from(MessagesProto.BannerMessage in) {
+    BannerMessage.Builder builder = BannerMessage.builder();
+
+    if (!TextUtils.isEmpty(in.getBackgroundHexColor())) {
+      builder.setBackgroundHexColor(in.getBackgroundHexColor());
+    }
+
+    if (!TextUtils.isEmpty(in.getImageUrl())) {
+      builder.setImageData(ImageData.builder().setImageUrl(in.getImageUrl()).build());
+    }
+
+    if (in.hasAction()) {
+      builder.setAction(decode(in.getAction()).build());
+    }
+
+    if (in.hasBody()) {
+      builder.setBody(decode(in.getBody()));
+    }
+
+    if (in.hasTitle()) {
+      builder.setTitle(decode(in.getTitle()));
+    }
+
+    return builder;
+  }
+
+  @Nonnull
+  private static CardMessage.Builder from(MessagesProto.CardMessage in) {
+    CardMessage.Builder builder = CardMessage.builder();
+
+    if (in.hasTitle()) {
+      builder.setTitle(decode(in.getTitle()));
+    }
+
+    if (in.hasBody()) {
+      builder.setBody(decode(in.getBody()));
+    }
+
+    if (!TextUtils.isEmpty(in.getBackgroundHexColor())) {
+      builder.setBackgroundHexColor(in.getBackgroundHexColor());
+    }
+
+    if (in.hasPrimaryAction() || in.hasPrimaryActionButton()) {
+      builder.setPrimaryAction(decode(in.getPrimaryAction(), in.getPrimaryActionButton()));
+    }
+
+    if (in.hasSecondaryAction() || in.hasSecondaryActionButton()) {
+      builder.setSecondaryAction(decode(in.getSecondaryAction(), in.getSecondaryActionButton()));
+    }
+
+    if (!TextUtils.isEmpty(in.getPortraitImageUrl())) {
+      builder.setPortraitImageData(
+          ImageData.builder().setImageUrl(in.getPortraitImageUrl()).build());
+    }
+
+    if (!TextUtils.isEmpty(in.getLandscapeImageUrl())) {
+      builder.setLandscapeImageData(
+          ImageData.builder().setImageUrl(in.getLandscapeImageUrl()).build());
+    }
+
+    return builder;
+  }
+
+  private static Button decode(MessagesProto.Button in) {
+    Button.Builder builder = Button.builder();
+
+    if (!TextUtils.isEmpty(in.getButtonHexColor())) {
+      builder.setButtonHexColor(in.getButtonHexColor());
+    }
+
+    if (in.hasText()) {
+      builder.setText(decode(in.getText()));
+    }
+    return builder.build();
+  }
+
+  private static Action decode(MessagesProto.Action protoAction, MessagesProto.Button protoButton) {
+
+    Action.Builder builder = decode(protoAction);
+    if (protoButton != MessagesProto.Button.getDefaultInstance()) {
+      Button.Builder buttonBuilder = Button.builder();
+      if (!TextUtils.isEmpty(protoButton.getButtonHexColor())) {
+        buttonBuilder.setButtonHexColor(protoButton.getButtonHexColor());
+      }
+      if (protoButton.hasText()) {
+        Text.Builder buttonText = Text.builder();
+        MessagesProto.Text text = protoButton.getText();
+        if (!TextUtils.isEmpty(text.getText())) {
+          buttonText.setText(text.getText());
+        }
+        if (!TextUtils.isEmpty(text.getHexColor())) {
+          buttonText.setHexColor(text.getHexColor());
+        }
+        buttonBuilder.setText(buttonText.build());
+      }
+      builder.setButton(buttonBuilder.build());
+    }
+    return builder.build();
+  }
+
+  private static Action.Builder decode(MessagesProto.Action protoAction) {
+
+    Action.Builder builder = Action.builder();
+    if (!TextUtils.isEmpty(protoAction.getActionUrl())) {
+      builder.setActionUrl(protoAction.getActionUrl());
+    }
+
+    return builder;
+  }
+
+  private static Text decode(MessagesProto.Text in) {
+    Text.Builder builder = Text.builder();
+
+    if (!TextUtils.isEmpty(in.getHexColor())) {
+      builder.setHexColor(in.getHexColor());
+    }
+
+    if (!TextUtils.isEmpty(in.getText())) {
+      builder.setText(in.getText());
+    }
+
+    return builder.build();
+  }
+
+  /** Tranform {@link MessagesProto.Content} proto to an {@link InAppMessage} value object */
+  public static InAppMessage decode(
+      @Nonnull MessagesProto.Content in,
+      String campaignId,
+      String campaignName,
+      boolean isTestMessage) {
+    Preconditions.checkNotNull(in, "FirebaseInAppMessaging content cannot be null.");
+    Logging.logd("Decoding message: " + in.toString());
+    CampaignMetadata campaignMetadata =
+        new CampaignMetadata(campaignId, campaignName, isTestMessage);
+
+    switch (in.getMessageDetailsCase()) {
+      case BANNER:
+        return from(in.getBanner()).build(campaignMetadata);
+      case IMAGE_ONLY:
+        return from(in.getImageOnly()).build(campaignMetadata);
+      case MODAL:
+        return from(in.getModal()).build(campaignMetadata);
+      case CARD:
+        return from(in.getCard()).build(campaignMetadata);
+
+      default:
+        // If the template is unsupported, then we return an unsupported message
+        return new InAppMessage(
+            new CampaignMetadata(campaignId, campaignName, isTestMessage),
+            MessageType.UNSUPPORTED) {
+          @Override
+          public Action getAction() {
+            return null;
+          }
+        };
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/RateLimit.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/RateLimit.java
new file mode 100644
index 000000000..422c58729
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/RateLimit.java
@@ -0,0 +1,47 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.model;
+
+import com.google.auto.value.AutoValue;
+
+/**
+ * Value object class representing rate limits.
+ *
+ * @hide
+ */
+@AutoValue
+public abstract class RateLimit {
+  public static Builder builder() {
+    return new AutoValue_RateLimit.Builder();
+  }
+
+  public abstract String limiterKey();
+
+  public abstract long limit();
+
+  public abstract long timeToLiveMillis();
+
+  /** Builder for {@link RateLimit}. */
+  @AutoValue.Builder
+  public abstract static class Builder {
+    public abstract Builder setLimiterKey(String limiterKey);
+
+    public abstract Builder setLimit(long limit);
+
+    public abstract Builder setTimeToLiveMillis(long timeToLiveMillis);
+
+    public abstract RateLimit build();
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/Text.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/Text.java
new file mode 100644
index 000000000..c06c27764
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/Text.java
@@ -0,0 +1,122 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.model;
+
+import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.google.firebase.inappmessaging.MessagesProto;
+
+/** Encapsulates any text used in a Firebase In App Message. */
+public class Text {
+  /**
+   * !!!!!WARNING!!!!! We are overriding equality in this class. Please add equality checks for all
+   * new private class members.
+   */
+  @Nullable private final String text;
+
+  @NonNull private final String hexColor;
+
+  /** @hide */
+  @Override
+  public int hashCode() {
+    return text != null ? text.hashCode() + hexColor.hashCode() : hexColor.hashCode();
+  }
+
+  /** @hide */
+  @Override
+  public boolean equals(Object o) {
+    if (o == this) {
+      return true; // same instance
+    }
+    if (!(o instanceof Text)) {
+      return false; // not the correct instance type
+    }
+    Text t = (Text) o;
+    if (hashCode() != t.hashCode()) {
+      return false; // the hashcodes don't match=
+    }
+    if ((text == null && t.text != null) || (text != null && !text.equals(t.text))) {
+      return false; // the texts don't match
+    }
+    if (hexColor.equals(t.hexColor)) {
+      return true; // everything matches
+    }
+    return false;
+  }
+  /**
+   * !!!!!WARNING!!!!! We are overriding equality in this class. Please add equality checks for all
+   * new private class members.
+   */
+  private Text(@Nullable String text, @NonNull String hexColor) {
+    this.text = text;
+    this.hexColor = hexColor;
+  }
+
+  /** Gets the text */
+  @Nullable
+  public String getText() {
+    return text;
+  }
+
+  /** Gets the hex color of this text */
+  @NonNull
+  public String getHexColor() {
+    return hexColor;
+  }
+
+  /**
+   * only used by headless sdk and tests
+   *
+   * @hide
+   */
+  public static Builder builder() {
+    return new Builder();
+  }
+
+  /**
+   * Builder for {@link Text}
+   *
+   * @hide
+   */
+  public static class Builder {
+    @Nullable private String text;
+    @Nullable private String hexColor;
+
+    public Builder setText(@Nullable String text) {
+      this.text = text;
+      return this;
+    }
+
+    public Builder setText(MessagesProto.Text text) {
+      setText(text.getText());
+      setHexColor(text.getHexColor());
+      return this;
+    }
+
+    public Builder setHexColor(@Nullable String hexColor) {
+      this.hexColor = hexColor;
+      return this;
+    }
+
+    public Text build() {
+      if (TextUtils.isEmpty(hexColor)) {
+        throw new IllegalArgumentException("Text model must have a color");
+      }
+      // We know hexColor is not null here because isEmpty checks for null.
+      return new Text(text, hexColor);
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/TriggeredInAppMessage.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/TriggeredInAppMessage.java
new file mode 100644
index 000000000..13907bb13
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/TriggeredInAppMessage.java
@@ -0,0 +1,35 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.model;
+
+/** @hide */
+public class TriggeredInAppMessage {
+  private InAppMessage inAppMessage;
+  private String triggeringEvent;
+
+  public TriggeredInAppMessage(InAppMessage inAppMessage, String triggeringEvent) {
+    this.inAppMessage = inAppMessage;
+    this.triggeringEvent = triggeringEvent;
+  }
+
+  public InAppMessage getInAppMessage() {
+
+    return inAppMessage;
+  }
+
+  public String getTriggeringEvent() {
+    return triggeringEvent;
+  }
+}
diff --git a/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/package-info.java b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/package-info.java
new file mode 100644
index 000000000..0f5cb54c3
--- /dev/null
+++ b/firebase-inappmessaging/src/main/java/com/google/firebase/inappmessaging/model/package-info.java
@@ -0,0 +1,15 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.model;
diff --git a/firebase-inappmessaging/src/proto/developers/mobile/targeting/proto/client_signals.proto b/firebase-inappmessaging/src/proto/developers/mobile/targeting/proto/client_signals.proto
new file mode 100644
index 000000000..e62e7b004
--- /dev/null
+++ b/firebase-inappmessaging/src/proto/developers/mobile/targeting/proto/client_signals.proto
@@ -0,0 +1,69 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+package developers.mobile.targeting.proto;
+
+option java_package = "com.google.developers.mobile.targeting.proto";
+option java_outer_classname = "ClientSignalsProto";
+
+
+// A set of signals which are collected on the client and are included in
+// requests
+//
+// NOTE: These will eventually not be needed in the request when we have an App
+// Checkin service which will upload these signals periodically.
+message ClientSignals {
+
+  // Optional.
+  // The App version.
+  // Android - versionName
+  // iOS - CFBundleVersion
+  string app_version = 1;
+
+  // Optional.
+  // The Platform Version of the device.
+  // Android - The API level.
+  // iOS - A version of the format "X.Y.Z".
+  string platform_version = 2;
+
+  // Optional.
+  // Device language in the BCP47 format.
+  // For example "en-US". This is case-insensitive.
+  // Android - Locale.getDefault()
+  // iOS -
+  string language_code = 3;
+
+  // Optional.
+  // Time zone in Olson ID format (eg: "America/Los_Angeles").  Case-sensitive.
+  // Android - TimeZone.getDefault().getID()
+  // iOS - NSTimeZone.name
+  string time_zone = 4;
+}
+
+// The claim of the App Instance performing the fetch.
+message AppInstanceClaim {
+  // Optional (but highly recommended).
+  string app_instance_id = 1;
+
+  // Required.
+  // The Instance Id Token of the App Instance.
+  // This is created for the scope "*".
+  string app_instance_token = 2;
+
+  // Required.
+  // The firebase app id
+  string gmp_app_id = 3;
+}
diff --git a/firebase-inappmessaging/src/proto/firebase/inappmessaging/proto/common_types.proto b/firebase-inappmessaging/src/proto/firebase/inappmessaging/proto/common_types.proto
new file mode 100644
index 000000000..242f93b1a
--- /dev/null
+++ b/firebase-inappmessaging/src/proto/firebase/inappmessaging/proto/common_types.proto
@@ -0,0 +1,192 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+package firebase.inappmessaging;
+
+option java_package = "com.google.firebase.inappmessaging";
+option java_outer_classname = "CommonTypesProto";
+
+import "firebase/inappmessaging/proto/messages.proto";
+import "google/type/timeofday.proto";
+import "google/type/date.proto";
+
+// this file defines a number of proto types that are shared between external
+// (api) and internal (server side) inapp messaging data models. They are used
+// to build the both the API and internal Campaign proto type
+
+// Timezone-supported time - used for the start/end times of campaigns.
+message CampaignTime {
+  // The date.
+  google.type.Date date = 1;
+
+  // The time of day.
+  google.type.TimeOfDay time = 2;
+
+  // [optional] The time zone.
+  // Time zone in Olson ID format, e.g., "America/Los_Angeles", or, if the
+  // timezone is unspecified, we use the recipient device's timezone.
+  string time_zone = 3;
+}
+
+// Triggering condition for determing when the campaign will be shown to
+// targeted users. Can be either a FiamTrigger, or a Scion Event
+message TriggeringCondition {
+  oneof condition {
+    Trigger fiam_trigger = 1;
+    ContextualTrigger contextual_trigger = 2;
+  }
+}
+
+message ContextualTrigger {
+  // Triggers that represent the context for the in app message
+  repeated TriggerParam trigger_params = 1;
+
+  // The event name. Event name length will be limited to something short like
+  // 24 or 32 chars. The exact max length limit is TBD.
+  string name = 2;
+
+  // UTC client time when the transaction happened in millis.
+  int64 timestamp_millis = 3;
+
+  // UTC client time when the transaction happened in millis.
+  int64 previous_timestamp_millis = 4;
+
+  // Events without timestamps will be grouped together by set of params and
+  // will be reported with occurrence count. This is lossless client side
+  // aggregation to pack the data in more compact form. Events with different
+  // set of params will be logged with different EventParam message.
+  int32 count = 5;
+}
+
+message TriggerParam {
+  // The name of the trigger param. The max size of the event name is TBD but it
+  // will be constrained to 24 or 32 chars.
+  string name = 1 ;
+
+  string string_value = 2 ;
+
+  int64 int_value = 3 ;
+
+  float float_value = 4;
+
+  double double_value = 5;
+}
+
+// User-specified events that can activate a campaign for an app instance.
+// Note, this just controls eligibility. Client-side evaluation of rate limits
+// will determine whether or not the message is actually displayed in the app.
+// If the app is already in the foreground when a campaign is started, the
+// in-app message will not be displayed until the app is re-opened.
+enum Trigger {
+  UNKNOWN_TRIGGER = 0;
+  // App is launched.
+  APP_LAUNCH = 1;
+  // App has already launched and is brought into the foreground.
+  ON_FOREGROUND = 2;
+}
+
+// Priority of the campaign.
+// Used to select the most important messages amongst a set of eligible ones.
+message Priority {
+  // Priority value can range from 1-10, with 1 being the highest priority.
+  int32 value = 1;
+}
+
+// Minimal identifying information on a conversion event for an app.
+message ScionConversionEvent {
+  // Name of the event, e.g. "in_app_purchase".
+  string name = 1;
+}
+
+// A variant of an experimental campaign.
+// Contains information about the variant as well as the variant's message.
+message ExperimentVariant {
+  // [required] Variant's index in the ExperimentDefinition.variants list.
+  int32 index = 1;
+
+  // [required] Content associated with the variant.
+  Content content = 2;
+}
+
+// Possible states of a campaign.
+// Campaign can either be created as 'DRAFT' or directly created as 'PUBLISHED'.
+// Valid state transitions:
+//   DRAFT -> PUBLISHED
+//   PUBLISHED -> STOPPED
+//   {DRAFT, PUBLISHED, STOPPED} -> DELETED
+enum CampaignState {
+  UNKNOWN_CAMPAIGN_STATE = 0;
+  // Created but not eligible to be served to users.
+  // All fields are mutable.
+  DRAFT = 1;
+  // Eligible to be served to users. Campaign is active if published and the
+  // current time is between the start and end times.
+  // Only `state` field is mutable.
+  PUBLISHED = 2;
+  // Manually stopped by the user.
+  // No fields are mutable.
+  STOPPED = 3;
+  // Soft delete state for the campaign. These campaigns will not be served to
+  // clients
+  DELETED = 4;
+}
+
+// Possible states of an experimental campaign.
+// Valid state transitions:
+//   RUNNING -> STOPPED
+//   RUNNING -> ROLLED_OUT (no stop needed)
+//   STOPPED -> ROLLED_OUT
+// An experiment may be considered complete in either the stopped or rolled out
+// states.
+enum ExperimentalCampaignState {
+  UNKNOWN_EXPERIMENTAL_CAMPAIGN_STATE = 0;
+  // Experiments with testing devices that have not been started.
+  EXPERIMENT_DRAFT = 1;
+  // Eligible to be served to users. Campaign is active if running and the
+  // current time is between the start and end times.
+  EXPERIMENT_RUNNING = 2;
+  // Experiment manually stopped by the user.
+  EXPERIMENT_STOPPED = 3;
+  // Rolled out, i.e., promoted to a 'vanilla' campaign. An experimental
+  // campaign can only be rolled out once.
+  EXPERIMENT_ROLLED_OUT = 4;
+}
+
+// Analytics summary of a campaign for a single day
+message DailyAnalyticsSummary {
+  // Epoch timestamp of the day for which this summary is calculated. Based on
+  // Google timezone.
+  int64 start_of_day_millis = 1;
+
+  // [optional] Aggregated impressions of the campaign
+  int32 impressions = 2;
+
+  // [optional] Aggregated clicks on the campaign
+  int32 clicks = 3;
+
+  // [optional] Aggregated errors seen while displaying the campaign
+  int32 errors = 4;
+}
+
+// Conversions summary of a campaign for a single day
+message DailyConversionSummary {
+  // Epoch timestamp of the day for which this summary is calculated. Based on
+  // Google timezone.
+  int64 start_of_day_millis = 1;
+
+  // [optional] Aggregated conversions of the campaign
+  int32 conversions = 2;
+}
\ No newline at end of file
diff --git a/firebase-inappmessaging/src/proto/firebase/inappmessaging/proto/messages.proto b/firebase-inappmessaging/src/proto/firebase/inappmessaging/proto/messages.proto
new file mode 100644
index 000000000..ec7fa1928
--- /dev/null
+++ b/firebase-inappmessaging/src/proto/firebase/inappmessaging/proto/messages.proto
@@ -0,0 +1,150 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+package firebase.inappmessaging;
+
+option java_package = "com.google.firebase.inappmessaging";
+option java_outer_classname = "MessagesProto";
+
+// Content of a Firebase in-app message.
+message Content {
+  oneof message_details {
+    // Banner mode
+    BannerMessage banner = 1;
+    // Modal mode
+    ModalMessage modal = 2;
+    // Entire message is provided by the developer as an image
+    ImageOnlyMessage image_only = 3;
+    // Card mode
+    CardMessage card = 4;
+  }
+}
+
+message CardMessage {
+  // [required] Message title.
+  Text title = 1;
+
+  // [optional] Message body.
+  Text body = 2;
+
+  // [required] HTTPS url of the image to display in portrait orientation of
+  // the device.
+  string portrait_image_url = 3;
+
+  // [optional] HTTPS url of the image to display in landscape orientation
+  // of the device. If missing, the client will default to using the
+  // portrait image url.
+  string landscape_image_url = 4;
+
+  // [required] Message background color.
+  string background_hex_color = 5;
+
+  // [required] Message button.
+  // Clicking this button will trigger the modal's primary action
+  Button primary_action_button = 6;
+
+  // [required] The action to take when clicking on the primary button.
+  // This is required if primary action button is set
+  Action primary_action = 7;
+
+  // [optional] Message button.
+  // Clicking this button will trigger the modal's secondary action
+  // If the secondary action is not provided, the button simply dismisses the
+  // message.
+  Button secondary_action_button = 8;
+
+  // [optional] The action to take when the secondary action button is clicked.
+  Action secondary_action = 9;
+}
+
+message ImageOnlyMessage {
+  // The url of the image to be sent as the message.
+  string image_url = 1;
+
+  // [optional] The Action to take when clicking anywhere on the image.
+  Action action = 2;
+}
+
+message BannerMessage {
+  // [required] Message title.
+  Text title = 1;
+
+  // [optional] Message body.
+  Text body = 2;
+
+  // [optional] Image to display (https url - it will be downloaded onto the
+  // device) No prefix required.
+  string image_url = 3;
+
+  // [optional] Action to take when banner is clicked
+  Action action = 4;
+
+  // [optional]  Message background color.
+  string background_hex_color = 5;
+}
+
+message ModalMessage {
+  // [required] Message title.
+  Text title = 1;
+
+  // [optional] Message body.
+  Text body = 2;
+
+  // [optional] Image to display (https url - it will be downloaded onto the device)
+  // No prefix required.
+  string image_url = 3;
+
+  // [optional] Message button.
+  // Clicking this button will trigger the modal's action
+  // Currently, the two must be set together:
+  // action.isSet() iff actionButton.isSet()
+  Button action_button = 4;
+
+  // [optional] The Action to take when clicking on the button.
+  // Currently, the two must be set together:
+  // action.isSet() iff actionButton.isSet()
+  Action action = 5;
+
+  // [optional]  Message background color.
+  string background_hex_color = 6;
+}
+
+message Text {
+  // Message text.
+  string text = 1;
+
+  // Message font color.
+  string hex_color = 2;
+
+  // old field message font is deprecated
+  // string font_code = 3;
+  reserved 3;
+}
+
+message Button {
+  // Button text.
+  Text text = 1;
+
+  // Button background color.
+  string button_hex_color = 2;
+}
+
+// This defines the action to be taken on click:
+// For now, only the url to navigate to.
+message Action {
+  // Action url
+  string action_url = 1;
+}
\ No newline at end of file
diff --git a/firebase-inappmessaging/src/proto/google/internal/firebase/inappmessaging/internal/rate_limit.proto b/firebase-inappmessaging/src/proto/google/internal/firebase/inappmessaging/internal/rate_limit.proto
new file mode 100644
index 000000000..b6d602b60
--- /dev/null
+++ b/firebase-inappmessaging/src/proto/google/internal/firebase/inappmessaging/internal/rate_limit.proto
@@ -0,0 +1,34 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+package com.google.firebase.inappmessaging.internal;
+
+option java_package = "com.google.firebase.inappmessaging.internal";
+option java_outer_classname = "RateLimitProto";
+
+// Actions performed on the in app message
+message RateLimit {
+  // map from limiter key to counter
+  map<string, Counter> limits = 1;
+}
+
+message Counter {
+  // value of the counter
+  int64 value = 1;
+
+  // time at which the counter was initiated
+  int64 start_time_epoch = 2;
+}
diff --git a/firebase-inappmessaging/src/proto/google/internal/firebase/inappmessaging/v1/campaign.proto b/firebase-inappmessaging/src/proto/google/internal/firebase/inappmessaging/v1/campaign.proto
new file mode 100644
index 000000000..70aae4fd2
--- /dev/null
+++ b/firebase-inappmessaging/src/proto/google/internal/firebase/inappmessaging/v1/campaign.proto
@@ -0,0 +1,95 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+package google.internal.firebase.inappmessaging.v1;
+
+option java_package = "com.google.internal.firebase.inappmessaging.v1";
+option java_outer_classname = "CampaignProto";
+
+import "firebase/inappmessaging/proto/messages.proto";
+import "firebase/inappmessaging/proto/common_types.proto";
+import "developers/mobile/abt/proto/experiment_payload.proto";
+
+// User-specified properties for rolling out an experimental campaign into a new
+// standard campaign.
+message ExperimentalCampaignRollout {
+  // Id of the experiment to roll out.
+  string experiment_id = 1;
+
+  // Index of the variant to roll out.
+  int32 selected_variant_index = 2;
+
+  // Priority of the new campaign.
+  .firebase.inappmessaging.Priority priority = 3;
+
+  // Start time of the new campaign.
+  .firebase.inappmessaging.CampaignTime start_time = 4;
+
+  // [optional] End time of the new campaign.
+  .firebase.inappmessaging.CampaignTime end_time = 5;
+}
+
+// The 'thick' message that gets sent to clients
+message ThickContent {
+  // Campaign payload - used for impression tracking on the client
+  oneof payload {
+    VanillaCampaignPayload vanilla_payload = 1;
+    ExperimentalCampaignPayload experimental_payload = 2;
+  }
+
+  // Content
+  .firebase.inappmessaging.Content content = 3;
+  // Priority of the campaign/message
+  // If two messages have the same priority, the one from the
+  // most-recently-started campaign will 'win'
+  .firebase.inappmessaging.Priority priority = 4;
+
+  // condition to trigger the FIAM
+  repeated .firebase.inappmessaging.TriggeringCondition triggering_conditions =
+      5;
+
+  // old conversion_event = 6 field is deprecated.
+  reserved 6;
+
+  // if true, it's a campaign that's to be tested on client side. otherwise, it
+  // it's a regular message to be rendered.
+  bool is_test_campaign = 7;
+}
+
+message VanillaCampaignPayload {
+  // Campaign id
+  string campaign_id = 1;
+  // [optional] if the campaign is the result of a rolled out campaign,
+  // the old experimental campaign id here is used for impression tracking on
+  // the client
+  string experimental_campaign_id = 2;
+  // Start time of the campaign - we use long vs Timestamp here to
+  // minimize the size of the bundles sent back to the sdk clients
+  int64 campaign_start_time_millis = 3;
+  // [optional]  end time of the campaign - we use long vs Timestamp here to
+  // minimize the size of the bundles sent back to the sdk clients
+  int64 campaign_end_time_millis = 4;
+  // [optional] the display name for the campaign given by the campaign creator.
+  // we need it for generating fiam campaign analytic events on client SDK side
+  string campaign_name = 5;
+}
+
+message ExperimentalCampaignPayload {
+  // Campaign id
+  string campaign_id = 1;
+  // payload is sent for scion tracking of the experiment
+  developers.mobile.abt.ExperimentPayload experiment_payload = 2;
+}
diff --git a/firebase-inappmessaging/src/proto/google/internal/firebase/inappmessaging/v1/sdkserving/fiam_fetch_service.proto b/firebase-inappmessaging/src/proto/google/internal/firebase/inappmessaging/v1/sdkserving/fiam_fetch_service.proto
new file mode 100644
index 000000000..6cf17c3f8
--- /dev/null
+++ b/firebase-inappmessaging/src/proto/google/internal/firebase/inappmessaging/v1/sdkserving/fiam_fetch_service.proto
@@ -0,0 +1,101 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+package google.internal.firebase.inappmessaging.v1.sdkserving;
+
+option java_package = "com.google.internal.firebase.inappmessaging.v1.sdkserving";
+option java_multiple_files = true;
+
+import "google/api/annotations.proto";
+import "developers/mobile/targeting/proto/client_signals.proto";
+import "google/internal/firebase/inappmessaging/v1/campaign.proto";
+
+// In App Messaging SDK serving
+service InAppMessagingSdkServing {
+  // Retrieve fiam messages that are suitable for the current client app
+  // instance. A suitable campaign message needs to satisfy 3 conditions
+  // 1 Active campaign
+  // 2 The requesting client app instance meets the targeting requirement
+  //   for the campaign
+  // 3 The message is still yet to be rendered by the requesting client app
+  //   instance based on the display policy for the campaign. Parameter
+  //   already_seen_campaign in the request object is used to help serve
+  //   this purpose.
+  //
+  // Due to potential risk of a long list of already_seen_campaigns causing
+  // the url to reach the length limit, it's modeled as a POST request (so we
+  // can use body to carry the request data) with custom method even though
+  // it's essentially a read operation.
+  //
+  // The returned list of campaign messages are sorted from high priority to
+  // low priority so that the client can display them in the order as seen
+  // in the response.
+  rpc FetchEligibleCampaigns(FetchEligibleCampaignsRequest)
+      returns (FetchEligibleCampaignsResponse) {
+    option (google.api.http) = {
+      post: "/v1/sdkServing/projects/{project_number}/eligibleCampaigns:fetch"
+      body: "*"
+    };
+  }
+}
+
+message FetchEligibleCampaignsRequest {
+  // [required] the unique numeric string identifying the firebase project that
+  // the client app belongs
+  string project_number = 1;
+
+  ClientAppInfo requesting_client_app = 2;
+
+  // a list of campaigns that have already been rendered by the client so that
+  // service can filter them out while doing search of applicable messages
+  repeated CampaignImpression already_seen_campaigns = 3;
+
+  // [required] A common set of targeting signals - ex: user properties, lang
+  developers.mobile.targeting.proto.ClientSignals client_signals = 4;
+}
+
+// it has the info in identifying the clietn app making the request
+message ClientAppInfo {
+  // [required] the unique app id for the client app
+  string gmp_app_id = 1;
+  // [required] app instance id
+  string app_instance_id = 2;
+  // [required] app instance id token
+  string app_instance_id_token = 3;
+}
+
+// A campaign id and timestamp noting when the device displayed this campaign
+message CampaignImpression {
+  // [required] campaign_id
+  string campaign_id = 1;
+  // [required] when instance last displayed the content for this campaign
+  int64 impression_timestamp_millis = 2;
+}
+
+message FetchEligibleCampaignsResponse {
+  // list of eligible messages sorted in high-to-low priority order
+  repeated ThickContent messages = 1;
+
+  // epoch time at which time clients must invalidates their cache
+  int64 expiration_epoch_timestamp_millis = 2;
+}
+
+// Proto definition to facilitate storing impressions on the client
+message CampaignImpressionList {
+  // a list of campaigns that have already been rendered by the client so that
+  // service can filter them out while doing search of applicable messages
+  repeated CampaignImpression already_seen_campaigns = 1;
+}
diff --git a/firebase-inappmessaging/src/proto/logs/proto/firebase/inappmessaging/campaign_analytics.proto b/firebase-inappmessaging/src/proto/logs/proto/firebase/inappmessaging/campaign_analytics.proto
new file mode 100644
index 000000000..f7fa4615c
--- /dev/null
+++ b/firebase-inappmessaging/src/proto/logs/proto/firebase/inappmessaging/campaign_analytics.proto
@@ -0,0 +1,138 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Protos for firebase inappmessaging campaign analytics
+
+syntax = "proto2";
+
+package logs.proto.firebase.inappmessaging;
+
+option java_package = "com.google.firebase.inappmessaging";
+option java_multiple_files = true;
+option java_outer_classname = "FirebaseInAppMessagingCampaignAnalyticsProto";
+
+// Single unit of analytics data collected from firebase integrated 3P apps
+// using the inappmessaging SDK.
+// Every campaign analytics event that is logged will correspond to this object.
+message CampaignAnalytics {
+  // [required] the firebase project to which the client app belongs
+  optional string project_number = 1;
+  // [required] the campaign id of the campaign for which the analytics data
+  // is being recorded. Note: campaigns are project scoped.
+  optional string campaign_id = 2;
+
+  // [required] Additional metadata about the an application especially within
+  // the context of firebase project
+  optional ClientAppInfo client_app = 3;
+
+  // [required] The timestamp in milliseconds since epoch when the click was
+  // recorded. This time is recorded using the device clock.
+  optional int64 client_timestamp_millis = 4;
+
+  oneof event {
+    // The event type that's being recorded
+    EventType event_type = 5;
+
+    // Information about how the message was dismissed
+    DismissType dismiss_type = 6;
+
+    // Error encountered while rendering messages if any
+    RenderErrorReason render_error_reason = 7;
+
+    // Error encountered while fetching messages from FIAM backend if any
+    FetchErrorReason fetch_error_reason = 8;
+  }
+
+  // [required] The version of the FIAM SDK that's being used
+  optional string fiam_sdk_version = 9;
+
+  // ios only - number of times uploads for this log were retried.
+  // By default, this should be zero indicating that the log uploaded in first
+  // attempt. Every subsequent attempt should increment the previous
+  // attempt's count.
+  optional int32 engagementMetrics_delivery_retry_count = 10;
+}
+
+// Enum representing the kind of event that's being recorded
+enum EventType {
+  // Unspecified event type
+  UNKNOWN_EVENT_TYPE = 0;
+
+  // Event representing an impression of a message
+  IMPRESSION_EVENT_TYPE = 1;
+
+  // Event representing an action click on a message
+  CLICK_EVENT_TYPE = 2;
+}
+
+// A list of possible actions that can result in dismissal of a message.
+enum DismissType {
+  // Unspecified dismiss type
+  UNKNOWN_DISMISS_TYPE = 0;
+
+  // Message was dismissed automatically as done by the SDK after a timeout
+  AUTO = 1;
+
+  // Message was dismissed by clicking on cancel button or outside the message
+  CLICK = 2;
+
+  // Message was swiped
+  SWIPE = 3;
+}
+
+// A list of possible reasons that could lead to the SDK not showing the message
+// in the application.
+enum RenderErrorReason {
+  // Generic error
+  UNSPECIFIED_RENDER_ERROR = 0;
+
+  // Failure to fetch the image in the message
+  IMAGE_FETCH_ERROR = 1;
+
+  // Failure to display the message
+  IMAGE_DISPLAY_ERROR = 2;
+
+  // Image has an unsupported format
+  IMAGE_UNSUPPORTED_FORMAT = 3;
+}
+
+
+// A list of possible errors encountered while fetching messages from the FIAM
+// backend by the SDK
+enum FetchErrorReason {
+  // Generic error
+  UNSPECIFIED_FETCH_ERROR = 0;
+
+  // Errors related to any server-side errors (5xx).
+  SERVER_ERROR = 1;
+
+  // Errors related to any client-side errors (4xx).
+  CLIENT_ERROR = 2;
+
+  // Errors related to the network on the client
+  NETWORK_ERROR = 3;
+}
+
+// Additional metadata about an app that is not provided by default
+message ClientAppInfo {
+  // Identifier for the application that has been registered with firebase.
+  // Contains pantheon project number, platform and the hash of the (package
+  // name or bundle id) fields in hex.
+  // [Version]:[Project Number]:[Platform]:[Hash(package_name/bundle_id)]
+  optional string google_app_id = 1;  // required.
+
+  // The Firebase Instance Id which is used to compute
+  // the distinct devices for which the metrics are recorded.
+  optional string firebase_instance_id = 2;
+}
diff --git a/firebase-inappmessaging/src/test/AndroidManifest.xml b/firebase-inappmessaging/src/test/AndroidManifest.xml
new file mode 100644
index 000000000..1372f98f8
--- /dev/null
+++ b/firebase-inappmessaging/src/test/AndroidManifest.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.firebase.inappmessaging">
+    <uses-sdk android:minSdkVersion="16"/>
+    <application
+        android:label="FirebaseCommonTests" >
+        <uses-library android:name="android.test.runner" />
+    </application>
+    <instrumentation
+        android:name="androidx.test.runner.AndroidJUnitRunner"
+        android:targetPackage="com.google.firebase.inappmessaging" />
+</manifest>
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingTest.java
new file mode 100644
index 000000000..c4230ff41
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/FirebaseInAppMessagingTest.java
@@ -0,0 +1,318 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.firebase.inappmessaging.CommonTypesProto.Trigger.ON_FOREGROUND;
+import static com.google.firebase.inappmessaging.testutil.TestData.BANNER_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.CAMPAIGN_ID_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.CAMPAIGN_NAME_STRING;
+import static io.reactivex.BackpressureStrategy.BUFFER;
+import static io.reactivex.schedulers.Schedulers.trampoline;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.Application;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.FirebaseOptions;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.inappmessaging.CommonTypesProto.ContextualTrigger;
+import com.google.firebase.inappmessaging.CommonTypesProto.Priority;
+import com.google.firebase.inappmessaging.CommonTypesProto.TriggeringCondition;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingTest.ShadowFirebaseInstanceId;
+import com.google.firebase.inappmessaging.MessagesProto.Content;
+import com.google.firebase.inappmessaging.internal.CampaignCacheClient;
+import com.google.firebase.inappmessaging.internal.DataCollectionHelper;
+import com.google.firebase.inappmessaging.internal.DeveloperListenerManager;
+import com.google.firebase.inappmessaging.internal.DisplayCallbacksFactory;
+import com.google.firebase.inappmessaging.internal.InAppMessageStreamManager;
+import com.google.firebase.inappmessaging.internal.ProgramaticContextualTriggers;
+import com.google.firebase.inappmessaging.internal.RateLimiterClient;
+import com.google.firebase.inappmessaging.internal.Schedulers;
+import com.google.firebase.inappmessaging.model.Action;
+import com.google.firebase.inappmessaging.model.InAppMessage;
+import com.google.firebase.inappmessaging.model.TriggeredInAppMessage;
+import com.google.internal.firebase.inappmessaging.v1.CampaignProto.ThickContent;
+import com.google.internal.firebase.inappmessaging.v1.CampaignProto.VanillaCampaignPayload;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsResponse;
+import io.reactivex.Flowable;
+import io.reactivex.FlowableEmitter;
+import io.reactivex.Maybe;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(
+    manifest = Config.NONE,
+    shadows = {ShadowFirebaseInstanceId.class})
+public class FirebaseInAppMessagingTest {
+  private static final long PAST = 1000000;
+  private static final long NOW = PAST + 100000;
+  private static final long FUTURE = NOW + 1000000;
+  private static final String INSTANCE_ID = "instance_id";
+  private static final String INSTANCE_TOKEN = "instance_token";
+  private static final String CAMPAIGN_ID2 = "campaign_id2";
+  private static final String CAMPAIGN_NAME2 = "campaign_name2";
+  private static final String ANALYTICS_EVENT_NAME = "event1";
+
+  private static final TriggeringCondition.Builder onAnalyticsEvent =
+      TriggeringCondition.newBuilder()
+          .setContextualTrigger(ContextualTrigger.newBuilder().setName(ANALYTICS_EVENT_NAME));
+  private static final TriggeringCondition onForeground =
+      TriggeringCondition.newBuilder().setFiamTrigger(ON_FOREGROUND).build();
+
+  private static final Priority PRIORITY_TWO = Priority.newBuilder().setValue(2).build();
+  private static final VanillaCampaignPayload.Builder vanillaCampaign1 =
+      VanillaCampaignPayload.newBuilder()
+          .setCampaignId(CAMPAIGN_ID_STRING)
+          .setCampaignName(CAMPAIGN_NAME_STRING)
+          .setCampaignStartTimeMillis(PAST)
+          .setCampaignEndTimeMillis(FUTURE);
+  private static final VanillaCampaignPayload.Builder vanillaCampaign2 =
+      VanillaCampaignPayload.newBuilder()
+          .setCampaignId(CAMPAIGN_ID2)
+          .setCampaignName(CAMPAIGN_NAME2)
+          .setCampaignStartTimeMillis(PAST)
+          .setCampaignEndTimeMillis(FUTURE);
+  private static final ThickContent.Builder FOREGROUND_THICK_CONTENT_BUILDER =
+      ThickContent.newBuilder()
+          .setPriority(PRIORITY_TWO)
+          .addTriggeringConditions(onForeground)
+          .setVanillaPayload(vanillaCampaign1)
+          .setContent(
+              Content.newBuilder().setBanner(MessagesProto.BannerMessage.getDefaultInstance()));
+  private static final ThickContent.Builder ANALYTICS_EVENT_THICK_CONTENT_BUILDER =
+      ThickContent.newBuilder()
+          .setPriority(PRIORITY_TWO)
+          .addTriggeringConditions(onAnalyticsEvent)
+          .setVanillaPayload(vanillaCampaign2)
+          .setContent(Content.getDefaultInstance());
+
+  private static final FetchEligibleCampaignsResponse.Builder campaignsResponseBuilder =
+      FetchEligibleCampaignsResponse.newBuilder()
+          .setExpirationEpochTimestampMillis(FUTURE)
+          .addMessages(FOREGROUND_THICK_CONTENT_BUILDER)
+          .addMessages(ANALYTICS_EVENT_THICK_CONTENT_BUILDER);
+  private static final FetchEligibleCampaignsResponse campaignsResponse =
+      campaignsResponseBuilder.build();
+
+  @Mock private static FirebaseInstanceId firebaseInstanceId;
+  @Mock private Schedulers schedulers;
+  @Mock private InAppMessageStreamManager inAppMessageStreamManager;
+  @Mock private FirebaseInAppMessagingDisplay firebaseInAppMessagingDisplay;
+  @Mock private DataCollectionHelper dataCollectionHelper;
+  @Mock private DisplayCallbacksFactory displayCallbacksFactory;
+  @Mock private FirebaseInAppMessagingDisplayCallbacks displayCallbacks;
+  @Mock private ProgramaticContextualTriggers programaticContextualTriggers;
+  @Mock DeveloperListenerManager listenerScheduler = new DeveloperListenerManager();
+  FirebaseApp firebaseApp1;
+  FirebaseOptions options;
+
+  private Application application;
+
+  @Mock private RateLimiterClient rateLimiterClient;
+  @Mock private CampaignCacheClient campaignCacheClient;
+  private FirebaseInAppMessaging firebaseInAppMessaging;
+  private FlowableEmitter<TriggeredInAppMessage> emitter;
+  private final Flowable<TriggeredInAppMessage> fiamStream =
+      Flowable.create(e -> emitter = e, BUFFER);
+
+  @Before
+  public void setup() {
+    MockitoAnnotations.initMocks(this);
+
+    application = RuntimeEnvironment.application;
+
+    options =
+        new FirebaseOptions.Builder()
+            .setGcmSenderId("project_number")
+            .setApplicationId("app-id")
+            .setApiKey("apiKey")
+            .setProjectId("fiam-integration-test")
+            .build();
+
+    firebaseApp1 = mock(FirebaseApp.class);
+
+    when(firebaseApp1.getName()).thenReturn("app1");
+    when(firebaseApp1.getOptions()).thenReturn(options);
+    when(firebaseApp1.getApplicationContext()).thenReturn(application);
+
+    when(schedulers.mainThread()).thenReturn(trampoline());
+    when(schedulers.io()).thenReturn(trampoline());
+    when(schedulers.computation()).thenReturn(trampoline());
+
+    when(inAppMessageStreamManager.createFirebaseInAppMessageStream()).thenReturn(fiamStream);
+
+    when(campaignCacheClient.get()).thenReturn(Maybe.just(campaignsResponse));
+
+    when(firebaseInstanceId.getId()).thenReturn(INSTANCE_ID);
+    when(firebaseInstanceId.getToken()).thenReturn(INSTANCE_TOKEN);
+
+    when(firebaseInstanceId.getId()).thenReturn(INSTANCE_ID);
+    when(firebaseInstanceId.getToken()).thenReturn(INSTANCE_TOKEN);
+    when(dataCollectionHelper.isAutomaticDataCollectionEnabled()).thenReturn(true);
+
+    when(displayCallbacksFactory.generateDisplayCallback(
+            BANNER_MESSAGE_MODEL, ANALYTICS_EVENT_NAME))
+        .thenReturn(displayCallbacks);
+
+    firebaseInAppMessaging =
+        new FirebaseInAppMessaging(
+            inAppMessageStreamManager,
+            programaticContextualTriggers,
+            dataCollectionHelper,
+            displayCallbacksFactory,
+            listenerScheduler);
+  }
+
+  @Test
+  public void addListener_addsListener() {
+    when(dataCollectionHelper.isAutomaticDataCollectionEnabled()).thenReturn(true);
+    firebaseInAppMessaging =
+        new FirebaseInAppMessaging(
+            inAppMessageStreamManager,
+            programaticContextualTriggers,
+            dataCollectionHelper,
+            displayCallbacksFactory,
+            listenerScheduler);
+    when(displayCallbacksFactory.generateDisplayCallback(
+            BANNER_MESSAGE_MODEL, ON_FOREGROUND.name()))
+        .thenReturn(displayCallbacks);
+
+    firebaseInAppMessaging.setMessageDisplayComponent(firebaseInAppMessagingDisplay);
+    emitter.onNext(new TriggeredInAppMessage(BANNER_MESSAGE_MODEL, ON_FOREGROUND.name()));
+
+    verify(firebaseInAppMessagingDisplay).displayMessage(BANNER_MESSAGE_MODEL, displayCallbacks);
+  }
+
+  @Test
+  public void removeListener_removesListener() {
+    when(dataCollectionHelper.isAutomaticDataCollectionEnabled()).thenReturn(true);
+    firebaseInAppMessaging =
+        new FirebaseInAppMessaging(
+            inAppMessageStreamManager,
+            programaticContextualTriggers,
+            dataCollectionHelper,
+            displayCallbacksFactory,
+            listenerScheduler);
+
+    firebaseInAppMessaging.setMessageDisplayComponent(firebaseInAppMessagingDisplay);
+    firebaseInAppMessaging.clearDisplayListener();
+    emitter.onNext(new TriggeredInAppMessage(BANNER_MESSAGE_MODEL, ON_FOREGROUND.name()));
+
+    verify(firebaseInAppMessagingDisplay, times(0))
+        .displayMessage(
+            BANNER_MESSAGE_MODEL,
+            displayCallbacksFactory.generateDisplayCallback(
+                BANNER_MESSAGE_MODEL, ON_FOREGROUND.name()));
+  }
+
+  @Test
+  public void automaticDataCollectionEnabling_enablesInDataCollectionHelper() {
+    firebaseInAppMessaging =
+        new FirebaseInAppMessaging(
+            inAppMessageStreamManager,
+            programaticContextualTriggers,
+            dataCollectionHelper,
+            displayCallbacksFactory,
+            listenerScheduler);
+
+    firebaseInAppMessaging.setAutomaticDataCollectionEnabled(true);
+    verify(dataCollectionHelper).setAutomaticDataCollectionEnabled(true);
+    assertThat(firebaseInAppMessaging.isAutomaticDataCollectionEnabled()).isTrue();
+  }
+
+  @Test
+  public void automaticDataCollectionDisabling_disablesInDataCollectionHelper() {
+    firebaseInAppMessaging =
+        new FirebaseInAppMessaging(
+            inAppMessageStreamManager,
+            programaticContextualTriggers,
+            dataCollectionHelper,
+            displayCallbacksFactory,
+            listenerScheduler);
+
+    firebaseInAppMessaging.setAutomaticDataCollectionEnabled(false);
+    verify(dataCollectionHelper).setAutomaticDataCollectionEnabled(false);
+  }
+
+  @Test
+  public void messagesSuppressed_isFalseOnInitialization() {
+    firebaseInAppMessaging =
+        new FirebaseInAppMessaging(
+            inAppMessageStreamManager,
+            programaticContextualTriggers,
+            dataCollectionHelper,
+            displayCallbacksFactory,
+            listenerScheduler);
+
+    assertThat(firebaseInAppMessaging.areMessagesSuppressed()).isFalse();
+  }
+
+  @Test
+  public void messagesSuppressed_isTrueWhenUpdated() {
+    firebaseInAppMessaging =
+        new FirebaseInAppMessaging(
+            inAppMessageStreamManager,
+            programaticContextualTriggers,
+            dataCollectionHelper,
+            displayCallbacksFactory,
+            listenerScheduler);
+
+    firebaseInAppMessaging.setMessagesSuppressed(true);
+    assertThat(firebaseInAppMessaging.areMessagesSuppressed()).isTrue();
+    firebaseInAppMessaging.setMessagesSuppressed(false);
+    assertThat(firebaseInAppMessaging.areMessagesSuppressed()).isFalse();
+  }
+
+  @Test
+  public void forwardsEventListenerRequestsToListenerScheduler() {
+    firebaseInAppMessaging =
+        new FirebaseInAppMessaging(
+            inAppMessageStreamManager,
+            programaticContextualTriggers,
+            dataCollectionHelper,
+            displayCallbacksFactory,
+            listenerScheduler);
+
+    firebaseInAppMessaging.addClickListener(
+        new FirebaseInAppMessagingClickListener() {
+          @Override
+          public void messageClicked(InAppMessage inAppMessage, Action action) {
+            // Nothing
+          }
+        });
+    verify(listenerScheduler, times(1)).addClickListener(any());
+  }
+
+  @Implements(FirebaseInstanceId.class)
+  public static class ShadowFirebaseInstanceId {
+    @Implementation
+    public static FirebaseInstanceId getInstance() {
+      return firebaseInstanceId;
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/AnalyticsEventsManagerTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/AnalyticsEventsManagerTest.java
new file mode 100644
index 000000000..d9db296e9
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/AnalyticsEventsManagerTest.java
@@ -0,0 +1,227 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.firebase.inappmessaging.CommonTypesProto.Trigger.ON_FOREGROUND;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.when;
+
+import android.util.Log;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.inappmessaging.CommonTypesProto.ContextualTrigger;
+import com.google.firebase.inappmessaging.CommonTypesProto.Priority;
+import com.google.firebase.inappmessaging.CommonTypesProto.TriggeringCondition;
+import com.google.firebase.inappmessaging.MessagesProto.BannerMessage;
+import com.google.firebase.inappmessaging.MessagesProto.Content;
+import com.google.internal.firebase.inappmessaging.v1.CampaignProto.ThickContent;
+import com.google.internal.firebase.inappmessaging.v1.CampaignProto.VanillaCampaignPayload;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsResponse;
+import java.util.HashSet;
+import java.util.Set;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.junit.rules.ExpectedLogMessagesRule;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 22, qualifiers = "es")
+public class AnalyticsEventsManagerTest {
+
+  @Rule public final ExpectedLogMessagesRule logged = new ExpectedLogMessagesRule();
+
+  private static final long PAST = 1000000;
+  private static final long NOW = PAST + 100000;
+  private static final long FUTURE = NOW + 1000000;
+  private static final String CAMPAIGN_ID1 = "campaign_id1";
+  private static final String CAMPAIGN_NAME1 = "campaign_name1";
+  private static final String CAMPAIGN_ID2 = "campaign_id2";
+  private static final String CAMPAIGN_NAME2 = "campaign_name2";
+  private static final String ANALYTICS_EVENT_1 = "event1";
+
+  private static final TriggeringCondition.Builder onAnalyticsEvent =
+      TriggeringCondition.newBuilder()
+          .setContextualTrigger(ContextualTrigger.newBuilder().setName(ANALYTICS_EVENT_1));
+  private static final TriggeringCondition onForeground =
+      TriggeringCondition.newBuilder().setFiamTrigger(ON_FOREGROUND).build();
+
+  private static final Priority PRIORITY_TWO = Priority.newBuilder().setValue(2).build();
+  private static final VanillaCampaignPayload.Builder vanillaCampaign1 =
+      VanillaCampaignPayload.newBuilder()
+          .setCampaignId(CAMPAIGN_ID1)
+          .setCampaignName(CAMPAIGN_NAME1)
+          .setCampaignStartTimeMillis(PAST)
+          .setCampaignEndTimeMillis(FUTURE);
+  private static final VanillaCampaignPayload.Builder vanillaCampaign2 =
+      VanillaCampaignPayload.newBuilder()
+          .setCampaignId(CAMPAIGN_ID2)
+          .setCampaignName(CAMPAIGN_NAME2)
+          .setCampaignStartTimeMillis(PAST)
+          .setCampaignEndTimeMillis(FUTURE);
+  private static final ThickContent.Builder FOREGROUND_THICK_CONTENT_BUILDER =
+      ThickContent.newBuilder()
+          .setPriority(PRIORITY_TWO)
+          .addTriggeringConditions(onForeground)
+          .setVanillaPayload(vanillaCampaign1)
+          .setContent(Content.newBuilder().setBanner(BannerMessage.getDefaultInstance()));
+  private static final ThickContent.Builder ANALYTICS_EVENT_THICK_CONTENT_BUILDER =
+      ThickContent.newBuilder()
+          .setPriority(PRIORITY_TWO)
+          .addTriggeringConditions(onAnalyticsEvent)
+          .setVanillaPayload(vanillaCampaign2)
+          .setContent(Content.getDefaultInstance());
+
+  @Mock private AnalyticsConnector analyticsConnector;
+  @Mock private AnalyticsConnector.AnalyticsConnectorHandle handle;
+  private AnalyticsEventsManager eventsManager;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    when(analyticsConnector.registerAnalyticsConnectorListener(
+            eq(AnalyticsConstants.ORIGIN_FIAM), any(FiamAnalyticsConnectorListener.class)))
+        .thenReturn(handle);
+    eventsManager = new AnalyticsEventsManager(analyticsConnector);
+  }
+
+  @Test
+  public void constuctor_ok() throws Exception {
+    // Verifies that the 'subscribe' method is called via the flowable.connect().
+    // Otherwise handle == null
+    assertThat(eventsManager.getHandle()).isEqualTo(handle);
+    assertThat(eventsManager.getAnalyticsEventsFlowable() != null).isTrue();
+  }
+
+  @Test
+  public void extractAnalyticsEventNames_filtersOutFiamEvents() {
+    FetchEligibleCampaignsResponse campaignsResponse =
+        FetchEligibleCampaignsResponse.newBuilder()
+            .setExpirationEpochTimestampMillis(FUTURE)
+            .addMessages(ANALYTICS_EVENT_THICK_CONTENT_BUILDER)
+            .addMessages(FOREGROUND_THICK_CONTENT_BUILDER)
+            .build();
+
+    Set<String> eventNames = AnalyticsEventsManager.extractAnalyticsEventNames(campaignsResponse);
+    assertThat(eventNames).containsExactly(ANALYTICS_EVENT_1);
+  }
+
+  @Test
+  public void extractAnalyticsEventNames_addsEventsWhenResponseHasMultipleTriggers() {
+    String event2 = "event2";
+
+    TriggeringCondition.Builder onAnalyticsEvent2 =
+        TriggeringCondition.newBuilder()
+            .setContextualTrigger(ContextualTrigger.newBuilder().setName(event2));
+
+    ThickContent.Builder event2ContentBuilder =
+        ThickContent.newBuilder()
+            .setPriority(PRIORITY_TWO)
+            .addTriggeringConditions(onAnalyticsEvent2)
+            .setVanillaPayload(vanillaCampaign2)
+            .setContent(Content.getDefaultInstance());
+
+    FetchEligibleCampaignsResponse campaignsResponse =
+        FetchEligibleCampaignsResponse.newBuilder()
+            .setExpirationEpochTimestampMillis(FUTURE)
+            .addMessages(ANALYTICS_EVENT_THICK_CONTENT_BUILDER)
+            .addMessages(event2ContentBuilder)
+            .build();
+
+    Set<String> expectedNames = new HashSet<>();
+    expectedNames.add(ANALYTICS_EVENT_1);
+    expectedNames.add(event2);
+
+    Set<String> eventNames = AnalyticsEventsManager.extractAnalyticsEventNames(campaignsResponse);
+    assertThat(eventNames).containsExactlyElementsIn(expectedNames);
+  }
+
+  @Test
+  public void extractAnalyticsEventNames_addsEventsWhenMultipleCampaignsHasMultipleTriggers() {
+    String event2 = "event2";
+    String event3 = "event3";
+    String event4 = "event4";
+
+    TriggeringCondition.Builder onAnalyticsEvent2 =
+        TriggeringCondition.newBuilder()
+            .setContextualTrigger(ContextualTrigger.newBuilder().setName(event2));
+    TriggeringCondition.Builder onAnalyticsEvent3 =
+        TriggeringCondition.newBuilder()
+            .setContextualTrigger(ContextualTrigger.newBuilder().setName(event3));
+    TriggeringCondition.Builder onAnalyticsEvent4 =
+        TriggeringCondition.newBuilder()
+            .setContextualTrigger(ContextualTrigger.newBuilder().setName(event4));
+
+    ThickContent.Builder event1ContentBuilder =
+        ThickContent.newBuilder()
+            .setPriority(PRIORITY_TWO)
+            .addTriggeringConditions(onAnalyticsEvent)
+            .addTriggeringConditions(onAnalyticsEvent2)
+            .addTriggeringConditions(onAnalyticsEvent3)
+            .setVanillaPayload(vanillaCampaign1)
+            .setContent(Content.getDefaultInstance());
+
+    ThickContent.Builder event2ContentBuilder =
+        ThickContent.newBuilder()
+            .setPriority(PRIORITY_TWO)
+            .addTriggeringConditions(onAnalyticsEvent3)
+            .addTriggeringConditions(onAnalyticsEvent4)
+            .setVanillaPayload(vanillaCampaign2)
+            .setContent(Content.getDefaultInstance());
+
+    FetchEligibleCampaignsResponse campaignsResponse =
+        FetchEligibleCampaignsResponse.newBuilder()
+            .setExpirationEpochTimestampMillis(FUTURE)
+            .addMessages(event1ContentBuilder)
+            .addMessages(event2ContentBuilder)
+            .build();
+    Set<String> eventNames = AnalyticsEventsManager.extractAnalyticsEventNames(campaignsResponse);
+    assertThat(eventNames).containsExactly(ANALYTICS_EVENT_1, event2, event3, event4);
+  }
+
+  @Test
+  public void updateContextualTriggers_logsWhenMoreThan50Events() {
+
+    ThickContent.Builder contentBuilder =
+        ThickContent.newBuilder()
+            .setPriority(PRIORITY_TWO)
+            .setVanillaPayload(vanillaCampaign1)
+            .setContent(Content.getDefaultInstance());
+    Set<String> expectedNames = new HashSet<>(51);
+    for (int i = 0; i < 51; i++) {
+
+      TriggeringCondition.Builder onAnalyticsEvent =
+          TriggeringCondition.newBuilder()
+              .setContextualTrigger(ContextualTrigger.newBuilder().setName(String.valueOf(i)));
+      contentBuilder.addTriggeringConditions(onAnalyticsEvent);
+      expectedNames.add(String.valueOf(i));
+    }
+
+    FetchEligibleCampaignsResponse campaignsResponse =
+        FetchEligibleCampaignsResponse.newBuilder()
+            .setExpirationEpochTimestampMillis(FUTURE)
+            .addMessages(contentBuilder)
+            .build();
+    Set<String> eventNames = AnalyticsEventsManager.extractAnalyticsEventNames(campaignsResponse);
+    assertThat(eventNames).containsExactlyElementsIn(expectedNames);
+    logged.expectLogMessage(
+        Log.INFO, Logging.TAG, AnalyticsEventsManager.TOO_MANY_CONTEXTUAL_TRIGGERS_ERROR);
+  }
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/ApiClientTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/ApiClientTest.java
new file mode 100644
index 000000000..c403e02b9
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/ApiClientTest.java
@@ -0,0 +1,356 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.Application;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import com.google.developers.mobile.targeting.proto.ClientSignalsProto.ClientSignals;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.FirebaseOptions;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.inappmessaging.internal.time.FakeClock;
+import com.google.firebase.inappmessaging.internal.time.SystemClock;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.CampaignImpression;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.CampaignImpressionList;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.ClientAppInfo;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsRequest;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsResponse;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 22, qualifiers = "es")
+public class ApiClientTest {
+
+  public static final String TIME_ZONE = "Europe/London";
+  private static final String TEST_PROJECT_NUMBER = "123";
+  private static final String CAMPAIGN_ID = "campaign_id";
+  private static final CampaignImpressionList campaignImpressionList =
+      CampaignImpressionList.newBuilder()
+          .addAlreadySeenCampaigns(
+              CampaignImpression.newBuilder().setCampaignId(CAMPAIGN_ID).build())
+          .build();
+  private FetchEligibleCampaignsResponse testFetchEligibleCampaignsResponse =
+      FetchEligibleCampaignsResponse.getDefaultInstance();
+  private static final String PACKAGE_NAME = "package_name";
+  private static final String VERSION_NAME = "version_name";
+  private static final String INSTANCE_ID = "instance_id";
+  private static final String INSTANCE_TOKEN = "instance_token";
+  private static final String APPLICATION_ID = "application_id";
+  // This can never be static because of the some validations in firebase options
+  private final FirebaseOptions firebaseOptions =
+      new FirebaseOptions.Builder()
+          .setGcmSenderId(TEST_PROJECT_NUMBER)
+          .setApiKey("api_key")
+          .setApplicationId(APPLICATION_ID)
+          .build();
+  private final PackageInfo packageInfo = new PackageInfo();
+  private final FetchEligibleCampaignsResponse cacheExpiringResponse =
+      ApiClient.createCacheExpiringResponse();
+  private ApiClient apiClient;
+
+  @Captor
+  private ArgumentCaptor<FetchEligibleCampaignsRequest> fetchEligibleCampaignsRequestArgcaptor;
+
+  @Mock private GrpcClient mockGrpcClient;
+  @Mock private FirebaseApp firebaseApp;
+  @Mock private Application application;
+  @Mock private PackageManager packageManager;
+  @Mock private FirebaseInstanceId firebaseInstanceId;
+  @Mock private DataCollectionHelper dataCollectionHelper;
+  private ProviderInstaller providerInstaller;
+  private FakeClock clock;
+  private final long NOW = new SystemClock().now();
+
+  @Before
+  public void setup() throws NameNotFoundException {
+    MockitoAnnotations.initMocks(this);
+
+    providerInstaller = spy(new ProviderInstaller(application));
+    packageInfo.versionName = VERSION_NAME;
+    when(firebaseApp.getOptions()).thenReturn(firebaseOptions);
+    when(application.getPackageManager()).thenReturn(packageManager);
+    when(dataCollectionHelper.isAutomaticDataCollectionEnabled()).thenReturn(true);
+    doNothing().when(providerInstaller).install();
+    clock = new FakeClock(new SystemClock().now());
+    testFetchEligibleCampaignsResponse =
+        testFetchEligibleCampaignsResponse
+            .toBuilder()
+            .setExpirationEpochTimestampMillis(clock.now() + TimeUnit.MINUTES.toMillis(5))
+            .build();
+
+    apiClient =
+        new ApiClient(
+            () -> mockGrpcClient,
+            firebaseApp,
+            application,
+            firebaseInstanceId,
+            dataCollectionHelper,
+            clock,
+            providerInstaller);
+    when(application.getPackageName()).thenReturn(PACKAGE_NAME);
+    when(packageManager.getPackageInfo(PACKAGE_NAME, 0)).thenReturn(packageInfo);
+
+    when(firebaseInstanceId.getId()).thenReturn(INSTANCE_ID);
+    when(firebaseInstanceId.getToken()).thenReturn(INSTANCE_TOKEN);
+
+    TimeZone.setDefault(TimeZone.getTimeZone(TIME_ZONE));
+  }
+
+  @Test
+  public void getFiams_proxiesRequestToGrpcClient() {
+    when(mockGrpcClient.fetchEligibleCampaigns(any(FetchEligibleCampaignsRequest.class)))
+        .thenReturn(testFetchEligibleCampaignsResponse);
+
+    assertThat(apiClient.getFiams(campaignImpressionList))
+        .isEqualTo(testFetchEligibleCampaignsResponse);
+  }
+
+  @Test
+  public void getFiams_doesntFetchIfDataCollectionisNotEnabled() {
+    when(dataCollectionHelper.isAutomaticDataCollectionEnabled()).thenReturn(false);
+
+    FetchEligibleCampaignsResponse response = apiClient.getFiams(campaignImpressionList);
+    assertThat(response).isEqualTo(cacheExpiringResponse);
+    verify(mockGrpcClient, times(0))
+        .fetchEligibleCampaigns(fetchEligibleCampaignsRequestArgcaptor.capture());
+  }
+
+  @Test
+  public void getFiams_doesNotCallGrpcClientWithEmptyIIDToken() {
+    when(mockGrpcClient.fetchEligibleCampaigns(any(FetchEligibleCampaignsRequest.class)))
+        .thenReturn(testFetchEligibleCampaignsResponse);
+    when(firebaseInstanceId.getToken()).thenReturn("");
+
+    FetchEligibleCampaignsResponse response = apiClient.getFiams(campaignImpressionList);
+    assertThat(response).isEqualTo(cacheExpiringResponse);
+    verify(mockGrpcClient, times(0))
+        .fetchEligibleCampaigns(fetchEligibleCampaignsRequestArgcaptor.capture());
+  }
+
+  @Test
+  public void getFiams_doesNotCallGrpcClientWithNullIIDToken() {
+    when(mockGrpcClient.fetchEligibleCampaigns(any(FetchEligibleCampaignsRequest.class)))
+        .thenReturn(testFetchEligibleCampaignsResponse);
+    when(firebaseInstanceId.getToken()).thenReturn(null);
+
+    FetchEligibleCampaignsResponse response = apiClient.getFiams(campaignImpressionList);
+    assertThat(response).isEqualTo(cacheExpiringResponse);
+    verify(mockGrpcClient, times(0))
+        .fetchEligibleCampaigns(fetchEligibleCampaignsRequestArgcaptor.capture());
+  }
+
+  @Test
+  public void getFiams_constructsCampaignsRequestWithProjectNumberFromGcmSenderId() {
+    when(mockGrpcClient.fetchEligibleCampaigns(fetchEligibleCampaignsRequestArgcaptor.capture()))
+        .thenReturn(testFetchEligibleCampaignsResponse);
+
+    apiClient.getFiams(campaignImpressionList);
+
+    assertThat(fetchEligibleCampaignsRequestArgcaptor.getValue().getProjectNumber())
+        .isEqualTo(TEST_PROJECT_NUMBER);
+  }
+
+  @Test
+  public void getFiams_constructsCampaignsRequestWithImpressedCampaigns() {
+    when(mockGrpcClient.fetchEligibleCampaigns(fetchEligibleCampaignsRequestArgcaptor.capture()))
+        .thenReturn(testFetchEligibleCampaignsResponse);
+
+    apiClient.getFiams(campaignImpressionList);
+
+    assertThat(fetchEligibleCampaignsRequestArgcaptor.getValue().getAlreadySeenCampaignsList())
+        .containsExactlyElementsIn(campaignImpressionList.getAlreadySeenCampaignsList());
+  }
+
+  @Test
+  public void getFiams_signalsContainsAppVersion() {
+    when(mockGrpcClient.fetchEligibleCampaigns(fetchEligibleCampaignsRequestArgcaptor.capture()))
+        .thenReturn(testFetchEligibleCampaignsResponse);
+
+    apiClient.getFiams(campaignImpressionList);
+
+    ClientSignals clientSignals =
+        fetchEligibleCampaignsRequestArgcaptor.getValue().getClientSignals();
+
+    assertThat(clientSignals.getAppVersion()).isEqualTo(VERSION_NAME);
+  }
+
+  @Test
+  public void getFiams_whenPackageNotFound_setsSignalsAppVersionToNull()
+      throws NameNotFoundException {
+    when(mockGrpcClient.fetchEligibleCampaigns(fetchEligibleCampaignsRequestArgcaptor.capture()))
+        .thenReturn(testFetchEligibleCampaignsResponse);
+    when(packageManager.getPackageInfo(PACKAGE_NAME, 0)).thenThrow(new NameNotFoundException());
+
+    apiClient.getFiams(campaignImpressionList);
+
+    ClientSignals clientSignals =
+        fetchEligibleCampaignsRequestArgcaptor.getValue().getClientSignals();
+
+    assertThat(clientSignals.getAppVersion()).isEmpty();
+  }
+
+  @Test
+  public void getFiams_signalsContainsPlatformVersion() {
+    when(mockGrpcClient.fetchEligibleCampaigns(fetchEligibleCampaignsRequestArgcaptor.capture()))
+        .thenReturn(testFetchEligibleCampaignsResponse);
+
+    apiClient.getFiams(campaignImpressionList);
+
+    ClientSignals clientSignals =
+        fetchEligibleCampaignsRequestArgcaptor.getValue().getClientSignals();
+
+    // sdk version set in roboelectric annotation above
+    assertThat(clientSignals.getPlatformVersion()).isEqualTo("22");
+  }
+
+  @Test
+  public void getFiams_signalsContainsLanguageCode() {
+    when(mockGrpcClient.fetchEligibleCampaigns(fetchEligibleCampaignsRequestArgcaptor.capture()))
+        .thenReturn(testFetchEligibleCampaignsResponse);
+
+    apiClient.getFiams(campaignImpressionList);
+
+    ClientSignals clientSignals =
+        fetchEligibleCampaignsRequestArgcaptor.getValue().getClientSignals();
+
+    // set via roboelectric annotation anove
+    assertThat(clientSignals.getLanguageCode()).isEqualTo("es");
+  }
+
+  @Test
+  public void getFiams_signalsContainsTimeZone() {
+    when(mockGrpcClient.fetchEligibleCampaigns(fetchEligibleCampaignsRequestArgcaptor.capture()))
+        .thenReturn(testFetchEligibleCampaignsResponse);
+
+    apiClient.getFiams(campaignImpressionList);
+
+    ClientSignals clientSignals =
+        fetchEligibleCampaignsRequestArgcaptor.getValue().getClientSignals();
+
+    assertThat(clientSignals.getTimeZone()).isEqualTo(TIME_ZONE);
+  }
+
+  @Test
+  public void getFiams_installsProvider() {
+    when(mockGrpcClient.fetchEligibleCampaigns(fetchEligibleCampaignsRequestArgcaptor.capture()))
+        .thenReturn(testFetchEligibleCampaignsResponse);
+
+    verify(providerInstaller, times(0)).install();
+
+    apiClient.getFiams(campaignImpressionList);
+
+    verify(providerInstaller, times(1)).install();
+  }
+
+  @Test
+  public void getFiams_clientAppInfoContainsInstanceId() {
+    when(mockGrpcClient.fetchEligibleCampaigns(fetchEligibleCampaignsRequestArgcaptor.capture()))
+        .thenReturn(testFetchEligibleCampaignsResponse);
+
+    apiClient.getFiams(campaignImpressionList);
+
+    ClientAppInfo clientAppInfo =
+        fetchEligibleCampaignsRequestArgcaptor.getValue().getRequestingClientApp();
+
+    assertThat(clientAppInfo.getAppInstanceId()).isEqualTo(INSTANCE_ID);
+  }
+
+  @Test
+  public void getFiams_clientAppInfoContainsInstanceIdToken() {
+    when(mockGrpcClient.fetchEligibleCampaigns(fetchEligibleCampaignsRequestArgcaptor.capture()))
+        .thenReturn(testFetchEligibleCampaignsResponse);
+
+    apiClient.getFiams(campaignImpressionList);
+
+    ClientAppInfo clientAppInfo =
+        fetchEligibleCampaignsRequestArgcaptor.getValue().getRequestingClientApp();
+
+    assertThat(clientAppInfo.getAppInstanceIdToken()).isEqualTo(INSTANCE_TOKEN);
+  }
+
+  @Test
+  public void getFiams_clientAppInfoContainsGmpAppId() {
+    when(mockGrpcClient.fetchEligibleCampaigns(fetchEligibleCampaignsRequestArgcaptor.capture()))
+        .thenReturn(testFetchEligibleCampaignsResponse);
+
+    apiClient.getFiams(campaignImpressionList);
+
+    ClientAppInfo clientAppInfo =
+        fetchEligibleCampaignsRequestArgcaptor.getValue().getRequestingClientApp();
+
+    assertThat(clientAppInfo.getGmpAppId()).isEqualTo(APPLICATION_ID);
+  }
+
+  @Test
+  public void getFiams_protectsFromBadPastCacheTimestamp() {
+    // The expiration timestamp is set to duration of 1 day NOT the timestamp of now+1day
+    FetchEligibleCampaignsResponse badCacheTimestamp =
+        testFetchEligibleCampaignsResponse
+            .toBuilder()
+            .setExpirationEpochTimestampMillis(TimeUnit.DAYS.toMillis(1))
+            .build();
+
+    when(mockGrpcClient.fetchEligibleCampaigns(fetchEligibleCampaignsRequestArgcaptor.capture()))
+        .thenReturn(badCacheTimestamp);
+
+    FetchEligibleCampaignsResponse fetchFiamsSafe = apiClient.getFiams(campaignImpressionList);
+
+    // Now should be:
+    assertThat(fetchFiamsSafe.getExpirationEpochTimestampMillis()).isGreaterThan(clock.now());
+    assertThat(fetchFiamsSafe.getExpirationEpochTimestampMillis())
+        .isEqualTo(clock.now() + TimeUnit.DAYS.toMillis(1));
+  }
+
+  @Test
+  public void getFiams_protectsFromFutureBadCacheTimestamp() {
+    // The expiration timestamp is set to duration of 1 day NOT the timestamp of now+1day
+    FetchEligibleCampaignsResponse badCacheTimestamp =
+        testFetchEligibleCampaignsResponse
+            .toBuilder()
+            .setExpirationEpochTimestampMillis(
+                clock.now() + TimeUnit.DAYS.toMillis(3) + TimeUnit.SECONDS.toMillis(1))
+            .build();
+
+    when(mockGrpcClient.fetchEligibleCampaigns(fetchEligibleCampaignsRequestArgcaptor.capture()))
+        .thenReturn(badCacheTimestamp);
+
+    FetchEligibleCampaignsResponse fetchFiamsSafe = apiClient.getFiams(campaignImpressionList);
+
+    // Now should be:
+    assertThat(fetchFiamsSafe.getExpirationEpochTimestampMillis()).isGreaterThan(clock.now());
+    assertThat(fetchFiamsSafe.getExpirationEpochTimestampMillis())
+        .isEqualTo(clock.now() + TimeUnit.DAYS.toMillis(1));
+  }
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/CampaignCacheClientTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/CampaignCacheClientTest.java
new file mode 100644
index 000000000..9089a2ae5
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/CampaignCacheClientTest.java
@@ -0,0 +1,189 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.when;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.app.Application;
+import com.google.firebase.inappmessaging.internal.time.FakeClock;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsResponse;
+import com.google.protobuf.Parser;
+import io.reactivex.Completable;
+import io.reactivex.Maybe;
+import io.reactivex.observers.TestObserver;
+import io.reactivex.subscribers.TestSubscriber;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class CampaignCacheClientTest {
+  private static final long PAST = 10;
+  private static final long NOW = 100;
+  private static final long FUTURE = 1000;
+
+  private final FetchEligibleCampaignsResponse fetchEligibleCampaignsResponse2 =
+      FetchEligibleCampaignsResponse.newBuilder().setExpirationEpochTimestampMillis(FUTURE).build();
+
+  private final FetchEligibleCampaignsResponse fetchEligibleCampaignsResponse1 =
+      FetchEligibleCampaignsResponse.newBuilder().setExpirationEpochTimestampMillis(FUTURE).build();
+
+  private final FetchEligibleCampaignsResponse expiredCampaignResponse =
+      FetchEligibleCampaignsResponse.newBuilder().setExpirationEpochTimestampMillis(PAST).build();
+
+  CampaignCacheClient campaignCacheClient;
+  TestObserver<FetchEligibleCampaignsResponse> storageWriteObserver;
+  Maybe<FetchEligibleCampaignsResponse> fakeRead;
+  Completable fakeWrite;
+  Boolean wasWritten;
+  @Mock private ProtoStorageClient storageClient;
+
+  private static List<Object> getPlainValues(
+      TestSubscriber<FetchEligibleCampaignsResponse> subscriber) {
+    return subscriber.getEvents().get(0);
+  }
+
+  @Before
+  public void setup() throws IOException {
+    initMocks(this);
+    wasWritten = false;
+
+    campaignCacheClient =
+        new CampaignCacheClient(
+            storageClient,
+            (Application) RuntimeEnvironment.application.getApplicationContext(),
+            new FakeClock(NOW));
+
+    storageWriteObserver = TestObserver.create();
+    fakeRead = Maybe.fromCallable(() -> fetchEligibleCampaignsResponse1);
+    fakeWrite = Completable.fromCallable(() -> wasWritten = true);
+  }
+
+  @Test
+  public void put_noErrors_writesToStorage() {
+    when(storageClient.write(fetchEligibleCampaignsResponse2)).thenReturn(fakeWrite);
+
+    campaignCacheClient.put(fetchEligibleCampaignsResponse2).subscribe();
+
+    assertThat(wasWritten).isTrue();
+  }
+
+  @Test
+  public void put_noErrors_cachesInMemory() {
+    when(storageClient.write(fetchEligibleCampaignsResponse2)).thenReturn(fakeWrite);
+    when(storageClient.read(any(CampaignResponseParser.class)))
+        .thenReturn(Maybe.just(fetchEligibleCampaignsResponse1));
+
+    campaignCacheClient.put(fetchEligibleCampaignsResponse2).subscribe();
+    TestSubscriber<FetchEligibleCampaignsResponse> subscriber =
+        campaignCacheClient.get().toFlowable().test();
+
+    assertThat(getPlainValues(subscriber)).containsExactly(fetchEligibleCampaignsResponse2);
+  }
+
+  @Test
+  public void put_writeErrors_notifiesError() {
+    when(storageClient.write(fetchEligibleCampaignsResponse2))
+        .thenReturn(Completable.error(new IOException()));
+
+    TestSubscriber<Object> subscriber =
+        campaignCacheClient.put(fetchEligibleCampaignsResponse2).toFlowable().test();
+
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test
+  public void put_writeErrors_doesNotSetInMemoryCache() {
+    when(storageClient.write(fetchEligibleCampaignsResponse1))
+        .thenReturn(Completable.error(new IOException()));
+    when(storageClient.read(FetchEligibleCampaignsResponse.parser())).thenReturn(fakeRead);
+
+    campaignCacheClient.put(fetchEligibleCampaignsResponse1).subscribe();
+    TestSubscriber<FetchEligibleCampaignsResponse> subscriber =
+        campaignCacheClient.get().toFlowable().test();
+
+    assertThat(getPlainValues(subscriber)).containsExactly(fetchEligibleCampaignsResponse1);
+  }
+
+  @Test
+  public void get_noInMemoryCache_fetchesFromStorage() {
+    when(storageClient.read(FetchEligibleCampaignsResponse.parser()))
+        .thenReturn(Maybe.just((fetchEligibleCampaignsResponse2)));
+
+    TestSubscriber<FetchEligibleCampaignsResponse> subscriber =
+        campaignCacheClient.get().toFlowable().test();
+
+    assertThat(getPlainValues(subscriber)).containsExactly(fetchEligibleCampaignsResponse2);
+  }
+
+  @Test
+  public void get_withInMemoryCache_returnInMemValue() {
+    when(storageClient.write(fetchEligibleCampaignsResponse2)).thenReturn(fakeWrite);
+    when(storageClient.read(FetchEligibleCampaignsResponse.parser())).thenReturn(fakeRead);
+
+    campaignCacheClient.put(fetchEligibleCampaignsResponse2).subscribe();
+    TestSubscriber<FetchEligibleCampaignsResponse> subscriber =
+        campaignCacheClient.get().toFlowable().test();
+
+    assertThat(getPlainValues(subscriber)).containsExactly(fetchEligibleCampaignsResponse2);
+  }
+
+  @Test
+  public void get_whenInMemCacheExpired_isEmpty() {
+    when(storageClient.write(expiredCampaignResponse)).thenReturn(fakeWrite);
+    when(storageClient.read(FetchEligibleCampaignsResponse.parser())).thenReturn(fakeRead);
+
+    campaignCacheClient.put(expiredCampaignResponse).subscribe();
+    TestSubscriber<FetchEligibleCampaignsResponse> subscriber =
+        campaignCacheClient.get().toFlowable().test();
+
+    subscriber.assertNoValues();
+  }
+
+  @Test
+  public void get_whenStorageCacheExpired_isEmpty() {
+    when(storageClient.read(FetchEligibleCampaignsResponse.parser()))
+        .thenReturn(Maybe.just((expiredCampaignResponse)));
+
+    TestSubscriber<FetchEligibleCampaignsResponse> subscriber =
+        campaignCacheClient.get().toFlowable().test();
+
+    subscriber.assertNoValues();
+  }
+
+  @Test
+  public void get_whenBothCachesAreEmpty_isEmpty() {
+    when(storageClient.read(FetchEligibleCampaignsResponse.parser()))
+        .thenReturn(Maybe.error(new FileNotFoundException()));
+
+    TestSubscriber<FetchEligibleCampaignsResponse> subscriber =
+        campaignCacheClient.get().toFlowable().test();
+
+    subscriber.assertNoValues();
+  }
+
+  interface CampaignResponseParser extends Parser<FetchEligibleCampaignsResponse> {}
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/DataCollectionHelperTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/DataCollectionHelperTest.java
new file mode 100644
index 000000000..549c79588
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/DataCollectionHelperTest.java
@@ -0,0 +1,264 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.Application;
+import android.os.Bundle;
+import com.google.firebase.DataCollectionDefaultChange;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.events.Event;
+import com.google.firebase.events.EventHandler;
+import com.google.firebase.events.Subscriber;
+import com.google.firebase.iid.FirebaseInstanceId;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.Executor;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public final class DataCollectionHelperTest {
+
+  @Mock private Application application;
+  @Mock private FirebaseApp firebaseApp;
+  @Mock private FirebaseInstanceId firebaseInstanceId;
+  @Mock private SharedPreferencesUtils sharedPreferencesUtils;
+
+  @Mock private Subscriber subscriber;
+
+  private DataCollectionHelper dataCollectionHelper;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    when(firebaseInstanceId.getToken()).thenReturn("token");
+    when(firebaseInstanceId.getId()).thenReturn("id");
+  }
+
+  @Test
+  public void isAutomaticDataCollectionEnabled_defaultsToTrue() {
+    when(sharedPreferencesUtils.isPreferenceSet(DataCollectionHelper.AUTO_INIT_PREFERENCES))
+        .thenReturn(false);
+    when(sharedPreferencesUtils.isManifestSet(
+            DataCollectionHelper.MANIFEST_METADATA_AUTO_INIT_ENABLED))
+        .thenReturn(false);
+    when(firebaseApp.isDataCollectionDefaultEnabled()).thenReturn(true);
+    dataCollectionHelper =
+        new DataCollectionHelper(
+            firebaseApp, sharedPreferencesUtils, firebaseInstanceId, subscriber);
+
+    assertThat(dataCollectionHelper.isAutomaticDataCollectionEnabled()).isTrue();
+    verify(firebaseInstanceId, atLeastOnce()).getToken();
+  }
+
+  @Test
+  public void setAutomaticDataCollectionEnabled_updatesSharedPreferences() {
+    when(sharedPreferencesUtils.isPreferenceSet(DataCollectionHelper.AUTO_INIT_PREFERENCES))
+        .thenReturn(false);
+    when(sharedPreferencesUtils.isManifestSet(
+            DataCollectionHelper.MANIFEST_METADATA_AUTO_INIT_ENABLED))
+        .thenReturn(false);
+    when(firebaseApp.isDataCollectionDefaultEnabled()).thenReturn(true);
+
+    dataCollectionHelper =
+        new DataCollectionHelper(
+            firebaseApp, sharedPreferencesUtils, firebaseInstanceId, subscriber);
+    dataCollectionHelper.setAutomaticDataCollectionEnabled(false);
+    verify(sharedPreferencesUtils, times(1))
+        .setBooleanPreference(DataCollectionHelper.AUTO_INIT_PREFERENCES, false);
+  }
+
+  @Test
+  public void isAutomaticDataCollectionEnabled_honorsManifestFlag() {
+    when(sharedPreferencesUtils.isPreferenceSet(DataCollectionHelper.AUTO_INIT_PREFERENCES))
+        .thenReturn(false);
+    when(sharedPreferencesUtils.isManifestSet(
+            DataCollectionHelper.MANIFEST_METADATA_AUTO_INIT_ENABLED))
+        .thenReturn(true);
+    when(sharedPreferencesUtils.getBooleanManifestValue(
+            DataCollectionHelper.MANIFEST_METADATA_AUTO_INIT_ENABLED, true))
+        .thenReturn(false);
+    when(firebaseApp.isDataCollectionDefaultEnabled()).thenReturn(true);
+
+    dataCollectionHelper =
+        new DataCollectionHelper(
+            firebaseApp, sharedPreferencesUtils, firebaseInstanceId, subscriber);
+    assertThat(dataCollectionHelper.isAutomaticDataCollectionEnabled()).isFalse();
+    verify(firebaseInstanceId, times(0)).getToken();
+  }
+
+  @Test
+  public void isAutomaticDataCollectionEnabled_prefOverridesManifest() {
+    when(sharedPreferencesUtils.isPreferenceSet(DataCollectionHelper.AUTO_INIT_PREFERENCES))
+        .thenReturn(true);
+    when(firebaseApp.isDataCollectionDefaultEnabled()).thenReturn(true);
+
+    // Manifest is false, preferences is true
+    when(sharedPreferencesUtils.getBooleanPreference(
+            DataCollectionHelper.AUTO_INIT_PREFERENCES, true))
+        .thenReturn(true);
+
+    dataCollectionHelper =
+        new DataCollectionHelper(
+            firebaseApp, sharedPreferencesUtils, firebaseInstanceId, subscriber);
+
+    assertThat(dataCollectionHelper.isAutomaticDataCollectionEnabled()).isTrue();
+    verify(firebaseInstanceId, times(1)).getToken();
+    verify(sharedPreferencesUtils, never())
+        .isManifestSet(DataCollectionHelper.MANIFEST_METADATA_AUTO_INIT_ENABLED);
+    verify(sharedPreferencesUtils, never())
+        .getBooleanManifestValue(DataCollectionHelper.MANIFEST_METADATA_AUTO_INIT_ENABLED, true);
+  }
+
+  @Test
+  public void isAutomaticDataCollectionEnabled_honorsGlobalFlag_productEnablePriority() {
+    when(sharedPreferencesUtils.isPreferenceSet(DataCollectionHelper.AUTO_INIT_PREFERENCES))
+        .thenReturn(true);
+    when(sharedPreferencesUtils.isManifestSet(
+            DataCollectionHelper.MANIFEST_METADATA_AUTO_INIT_ENABLED))
+        .thenReturn(true);
+    when(sharedPreferencesUtils.getBooleanPreference(
+            DataCollectionHelper.AUTO_INIT_PREFERENCES, true))
+        .thenReturn(false);
+    when(firebaseApp.isDataCollectionDefaultEnabled()).thenReturn(true);
+
+    // These cases follow the order of precedence:
+    // product flag > product manifest > global
+
+    // Case 1:
+    dataCollectionHelper =
+        new DataCollectionHelper(
+            firebaseApp, sharedPreferencesUtils, firebaseInstanceId, subscriber);
+    assertThat(dataCollectionHelper.isAutomaticDataCollectionEnabled()).isFalse();
+
+    verify(sharedPreferencesUtils, never())
+        .getBooleanManifestValue(DataCollectionHelper.MANIFEST_METADATA_AUTO_INIT_ENABLED, true);
+  }
+
+  @Test
+  public void isAutomaticDataCollectionEnabled_honorsGlobalFlag_productManifestPriority() {
+    when(sharedPreferencesUtils.isPreferenceSet(DataCollectionHelper.AUTO_INIT_PREFERENCES))
+        .thenReturn(false);
+    when(sharedPreferencesUtils.isManifestSet(
+            DataCollectionHelper.MANIFEST_METADATA_AUTO_INIT_ENABLED))
+        .thenReturn(true);
+    when(sharedPreferencesUtils.getBooleanManifestValue(
+            DataCollectionHelper.MANIFEST_METADATA_AUTO_INIT_ENABLED, true))
+        .thenReturn(false);
+    when(firebaseApp.isDataCollectionDefaultEnabled()).thenReturn(true);
+    dataCollectionHelper =
+        new DataCollectionHelper(
+            firebaseApp, sharedPreferencesUtils, firebaseInstanceId, subscriber);
+
+    assertThat(dataCollectionHelper.isAutomaticDataCollectionEnabled()).isFalse();
+    verify(sharedPreferencesUtils, never())
+        .getBooleanPreference(DataCollectionHelper.AUTO_INIT_PREFERENCES, true);
+  }
+
+  @Test
+  public void isAutomaticDataCollectionEnabled_honorsGlobalFlag_defaultsToGlobal()
+      throws Exception {
+
+    when(sharedPreferencesUtils.isPreferenceSet(DataCollectionHelper.AUTO_INIT_PREFERENCES))
+        .thenReturn(false);
+    when(sharedPreferencesUtils.isManifestSet(
+            DataCollectionHelper.MANIFEST_METADATA_AUTO_INIT_ENABLED))
+        .thenReturn(false);
+    when(firebaseApp.isDataCollectionDefaultEnabled()).thenReturn(false);
+
+    dataCollectionHelper =
+        new DataCollectionHelper(
+            firebaseApp, sharedPreferencesUtils, firebaseInstanceId, subscriber);
+
+    assertThat(dataCollectionHelper.isAutomaticDataCollectionEnabled()).isFalse();
+    verify(sharedPreferencesUtils, never())
+        .getBooleanPreference(DataCollectionHelper.AUTO_INIT_PREFERENCES, true);
+    verify(sharedPreferencesUtils, never())
+        .getBooleanManifestValue(DataCollectionHelper.MANIFEST_METADATA_AUTO_INIT_ENABLED, true);
+  }
+
+  @Test
+  public void isAutomaticDataCollectionEnabled_updatesOnDataCollectionDefaultChanges()
+      throws Exception {
+    // There are no overrides set by us - the only one we're 'honoring' is the dataCollectionDefault
+    // from the global flag
+
+    when(sharedPreferencesUtils.isPreferenceSet(DataCollectionHelper.AUTO_INIT_PREFERENCES))
+        .thenReturn(false);
+    when(sharedPreferencesUtils.isManifestSet(
+            DataCollectionHelper.MANIFEST_METADATA_AUTO_INIT_ENABLED))
+        .thenReturn(false);
+    when(firebaseApp.isDataCollectionDefaultEnabled()).thenReturn(false);
+
+    TestFirebaseEventSubscriber testFirebaseEventSubscriber = new TestFirebaseEventSubscriber();
+
+    dataCollectionHelper =
+        new DataCollectionHelper(
+            firebaseApp, sharedPreferencesUtils, firebaseInstanceId, testFirebaseEventSubscriber);
+    verify(firebaseInstanceId, times(0)).getToken();
+
+    // Now let's turn on the global flag:
+
+    assertThat(testFirebaseEventSubscriber.dataCollectionHandlers.size()).isEqualTo(1);
+    testFirebaseEventSubscriber.notifySubscribers(new DataCollectionDefaultChange(true));
+
+    assertThat(dataCollectionHelper.isAutomaticDataCollectionEnabled()).isTrue();
+  }
+
+  private static Bundle createNewBundle() {
+    return new Bundle();
+  }
+
+  private class TestFirebaseEventSubscriber implements Subscriber {
+    private List<EventHandler<DataCollectionDefaultChange>> dataCollectionHandlers;
+
+    TestFirebaseEventSubscriber() {
+      dataCollectionHandlers = new ArrayList<>();
+    }
+
+    @Override
+    public <T> void subscribe(Class<T> type, Executor executor, EventHandler<? super T> handler) {
+      // Not implemented/needed
+    }
+
+    @Override
+    public <T> void subscribe(Class<T> type, EventHandler<? super T> handler) {
+      dataCollectionHandlers.add((EventHandler<DataCollectionDefaultChange>) handler);
+    }
+
+    @Override
+    public <T> void unsubscribe(Class<T> type, EventHandler<? super T> handler) {
+      dataCollectionHandlers.remove(handler);
+    }
+
+    public void notifySubscribers(DataCollectionDefaultChange change) {
+      dataCollectionHandlers.forEach(
+          subscriber -> subscriber.handle(new Event(DataCollectionDefaultChange.class, change)));
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/DeveloperListenerManagerTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/DeveloperListenerManagerTest.java
new file mode 100644
index 000000000..b8bc921c8
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/DeveloperListenerManagerTest.java
@@ -0,0 +1,118 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static com.google.firebase.inappmessaging.testutil.TestData.BANNER_MESSAGE_MODEL;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.timeout;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingClickListener;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayErrorListener;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingImpressionListener;
+import java.util.concurrent.Executor;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class DeveloperListenerManagerTest {
+  @Mock FirebaseInAppMessagingClickListener clickListener;
+  @Mock FirebaseInAppMessagingImpressionListener inAppMessagingImpressionListener;
+  @Mock FirebaseInAppMessagingDisplayErrorListener errorListener;
+  @Mock Executor devExecutor;
+  DeveloperListenerManager developerListenerManager;
+
+  @Before
+  public void setup() {
+    MockitoAnnotations.initMocks(this);
+    developerListenerManager = new DeveloperListenerManager();
+  }
+
+  @Test
+  public void notifies_ImpressionListenersOnImpression() {
+    developerListenerManager.addImpressionListener(inAppMessagingImpressionListener);
+    developerListenerManager.impressionDetected(BANNER_MESSAGE_MODEL);
+
+    verify(inAppMessagingImpressionListener, timeout(1000).times(1))
+        .impressionDetected(BANNER_MESSAGE_MODEL);
+  }
+
+  @Test
+  public void notifies_ClickListenersOnClick() {
+    developerListenerManager.addClickListener(clickListener);
+    developerListenerManager.messageClicked(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+
+    verify(clickListener, timeout(1000).times(1))
+        .messageClicked(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+  }
+
+  @Test
+  public void notifies_ErrorListenerOnError() {
+    developerListenerManager.addDisplayErrorListener(errorListener);
+    developerListenerManager.displayErrorEncountered(
+        BANNER_MESSAGE_MODEL,
+        FirebaseInAppMessagingDisplayCallbacks.InAppMessagingErrorReason.UNSPECIFIED_RENDER_ERROR);
+
+    verify(errorListener, timeout(1000).times(1))
+        .displayErrorEncountered(
+            BANNER_MESSAGE_MODEL,
+            FirebaseInAppMessagingDisplayCallbacks.InAppMessagingErrorReason
+                .UNSPECIFIED_RENDER_ERROR);
+  }
+
+  @Test
+  public void notifies_ImpressionListenersOnImpression_onOwnExecutor() {
+
+    developerListenerManager.addImpressionListener(inAppMessagingImpressionListener, devExecutor);
+    developerListenerManager.impressionDetected(BANNER_MESSAGE_MODEL);
+
+    verify(devExecutor, times(1)).execute(any());
+  }
+
+  @Test
+  public void notifies_ClickListenersOnClick_onOwnExecutor() {
+    developerListenerManager.addClickListener(clickListener, devExecutor);
+    developerListenerManager.messageClicked(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+
+    verify(devExecutor, times(1)).execute(any());
+  }
+
+  @Test
+  public void notifies_ErrorListenerOnError_onOwnExecutor() {
+    developerListenerManager.addDisplayErrorListener(errorListener, devExecutor);
+    developerListenerManager.displayErrorEncountered(
+        BANNER_MESSAGE_MODEL,
+        FirebaseInAppMessagingDisplayCallbacks.InAppMessagingErrorReason.UNSPECIFIED_RENDER_ERROR);
+
+    verify(devExecutor, times(1)).execute(any());
+  }
+
+  @Test
+  public void notifies_multipleImpressionListenersOnImpression() {
+    developerListenerManager.addImpressionListener(inAppMessagingImpressionListener);
+    developerListenerManager.impressionDetected(BANNER_MESSAGE_MODEL);
+
+    verify(inAppMessagingImpressionListener, timeout(1000).times(1))
+        .impressionDetected(BANNER_MESSAGE_MODEL);
+  }
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/DisplayCallbacksImplTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/DisplayCallbacksImplTest.java
new file mode 100644
index 000000000..7f4aea457
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/DisplayCallbacksImplTest.java
@@ -0,0 +1,519 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.firebase.inappmessaging.CommonTypesProto.Trigger.ON_FOREGROUND;
+import static com.google.firebase.inappmessaging.testutil.TestData.ACTION_MODEL_WITHOUT_URL;
+import static com.google.firebase.inappmessaging.testutil.TestData.ACTION_MODEL_WITH_BUTTON;
+import static com.google.firebase.inappmessaging.testutil.TestData.ANALYTICS_EVENT_NAME;
+import static com.google.firebase.inappmessaging.testutil.TestData.BANNER_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.BANNER_TEST_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.CAMPAIGN_ID_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.CAMPAIGN_NAME_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.IMAGE_DATA;
+import static com.google.firebase.inappmessaging.testutil.TestData.INSTANCE_ID;
+import static com.google.firebase.inappmessaging.testutil.TestData.INSTANCE_TOKEN;
+import static com.google.firebase.inappmessaging.testutil.TestData.IS_NOT_TEST_MESSAGE;
+import static com.google.firebase.inappmessaging.testutil.TestData.MESSAGE_BACKGROUND_HEX_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.TITLE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.createBannerMessageCustomMetadata;
+import static io.reactivex.BackpressureStrategy.BUFFER;
+import static io.reactivex.schedulers.Schedulers.trampoline;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.Application;
+import com.google.android.gms.tasks.Task;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.FirebaseOptions;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.inappmessaging.CommonTypesProto.ContextualTrigger;
+import com.google.firebase.inappmessaging.CommonTypesProto.Priority;
+import com.google.firebase.inappmessaging.CommonTypesProto.TriggeringCondition;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks.InAppMessagingDismissType;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks.InAppMessagingErrorReason;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingTest.ShadowFirebaseInstanceId;
+import com.google.firebase.inappmessaging.MessagesProto;
+import com.google.firebase.inappmessaging.MessagesProto.Content;
+import com.google.firebase.inappmessaging.internal.time.FakeClock;
+import com.google.firebase.inappmessaging.model.BannerMessage;
+import com.google.firebase.inappmessaging.model.CampaignMetadata;
+import com.google.firebase.inappmessaging.model.CardMessage;
+import com.google.firebase.inappmessaging.model.InAppMessage;
+import com.google.firebase.inappmessaging.model.RateLimit;
+import com.google.firebase.inappmessaging.model.TriggeredInAppMessage;
+import com.google.internal.firebase.inappmessaging.v1.CampaignProto.ThickContent;
+import com.google.internal.firebase.inappmessaging.v1.CampaignProto.VanillaCampaignPayload;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.CampaignImpression;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsResponse;
+import io.reactivex.Completable;
+import io.reactivex.Flowable;
+import io.reactivex.FlowableEmitter;
+import io.reactivex.Maybe;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(
+    manifest = Config.NONE,
+    shadows = {ShadowFirebaseInstanceId.class})
+public class DisplayCallbacksImplTest {
+  private static final long PAST = 1000000;
+  private static final long NOW = PAST + 100000;
+  private static final long FUTURE = NOW + 1000000;
+
+  private static final String CAMPAIGN_ID2 = "campaign_id2";
+  private static final String CAMPAIGN_NAME2 = "campaign_name2";
+  private static final String LIMITER_KEY = "LIMITER_KEY";
+
+  private static final TriggeringCondition.Builder onAnalyticsEvent =
+      TriggeringCondition.newBuilder()
+          .setContextualTrigger(ContextualTrigger.newBuilder().setName(ANALYTICS_EVENT_NAME));
+  private static final TriggeringCondition onForeground =
+      TriggeringCondition.newBuilder().setFiamTrigger(ON_FOREGROUND).build();
+
+  private static final Priority PRIORITY_TWO = Priority.newBuilder().setValue(2).build();
+  private static final VanillaCampaignPayload.Builder vanillaCampaign1 =
+      VanillaCampaignPayload.newBuilder()
+          .setCampaignId(CAMPAIGN_ID_STRING)
+          .setCampaignName(CAMPAIGN_NAME_STRING)
+          .setCampaignStartTimeMillis(PAST)
+          .setCampaignEndTimeMillis(FUTURE);
+  private static final VanillaCampaignPayload.Builder vanillaCampaign2 =
+      VanillaCampaignPayload.newBuilder()
+          .setCampaignId(CAMPAIGN_ID2)
+          .setCampaignName(CAMPAIGN_NAME2)
+          .setCampaignStartTimeMillis(PAST)
+          .setCampaignEndTimeMillis(FUTURE);
+  private static final ThickContent.Builder FOREGROUND_THICK_CONTENT_BUILDER =
+      ThickContent.newBuilder()
+          .setPriority(PRIORITY_TWO)
+          .addTriggeringConditions(onForeground)
+          .setVanillaPayload(vanillaCampaign1)
+          .setContent(
+              Content.newBuilder().setBanner(MessagesProto.BannerMessage.getDefaultInstance()));
+  private static final ThickContent.Builder ANALYTICS_EVENT_THICK_CONTENT_BUILDER =
+      ThickContent.newBuilder()
+          .setPriority(PRIORITY_TWO)
+          .addTriggeringConditions(onAnalyticsEvent)
+          .setVanillaPayload(vanillaCampaign2)
+          .setContent(Content.getDefaultInstance());
+
+  private static final FetchEligibleCampaignsResponse.Builder campaignsResponseBuilder =
+      FetchEligibleCampaignsResponse.newBuilder()
+          .setExpirationEpochTimestampMillis(FUTURE)
+          .addMessages(FOREGROUND_THICK_CONTENT_BUILDER)
+          .addMessages(ANALYTICS_EVENT_THICK_CONTENT_BUILDER);
+  private static final FetchEligibleCampaignsResponse campaignsResponse =
+      campaignsResponseBuilder.build();
+
+  private static final RateLimit appForegroundRateLimit =
+      RateLimit.builder()
+          .setLimit(1)
+          .setLimiterKey(LIMITER_KEY)
+          .setTimeToLiveMillis(TimeUnit.DAYS.toMillis(1))
+          .build();
+
+  @Mock private static FirebaseInstanceId firebaseInstanceId;
+  @Mock private static MetricsLoggerClient metricsLoggerClient;
+  @Mock private Schedulers schedulers;
+  @Mock private ImpressionStorageClient impressionStorageClient;
+  @Mock private InAppMessageStreamManager inAppMessageStreamManager;
+  @Mock private DataCollectionHelper dataCollectionHelper;
+  FirebaseApp firebaseApp1;
+  FirebaseOptions options;
+
+  private Application application;
+
+  @Mock private RateLimiterClient rateLimiterClient;
+  @Mock private CampaignCacheClient campaignCacheClient;
+  private DisplayCallbacksFactory displayCallbacksFactory;
+  private FlowableEmitter<TriggeredInAppMessage> emitter;
+  private final Flowable<TriggeredInAppMessage> fiamStream =
+      Flowable.create(e -> emitter = e, BUFFER);
+
+  private Completable fakeImpressionCompletable;
+  private Completable fakeRateLimitCompletable;
+
+  private boolean wasRecorded;
+  private boolean wasIncremented;
+
+  private FirebaseInAppMessagingDisplayCallbacks displayCallbacksImpl;
+
+  @Before
+  public void setup() {
+    MockitoAnnotations.initMocks(this);
+    wasRecorded = false;
+    wasIncremented = false;
+    fakeImpressionCompletable = Completable.fromCallable(() -> wasRecorded = true);
+    fakeRateLimitCompletable = Completable.fromCallable(() -> wasIncremented = true);
+
+    application = RuntimeEnvironment.application;
+
+    options =
+        new FirebaseOptions.Builder()
+            .setGcmSenderId("project_number")
+            .setApplicationId("app-id")
+            .setApiKey("apiKey")
+            .setProjectId("fiam-integration-test")
+            .build();
+
+    firebaseApp1 = mock(FirebaseApp.class);
+
+    when(firebaseApp1.getName()).thenReturn("app1");
+    when(firebaseApp1.getOptions()).thenReturn(options);
+    when(firebaseApp1.getApplicationContext()).thenReturn(application);
+
+    when(schedulers.mainThread()).thenReturn(trampoline());
+    when(schedulers.io()).thenReturn(trampoline());
+    when(schedulers.computation()).thenReturn(trampoline());
+
+    when(inAppMessageStreamManager.createFirebaseInAppMessageStream()).thenReturn(fiamStream);
+    when(impressionStorageClient.storeImpression(any(CampaignImpression.class)))
+        .thenReturn(fakeImpressionCompletable);
+    when(campaignCacheClient.get()).thenReturn(Maybe.just(campaignsResponse));
+    when(rateLimiterClient.increment(appForegroundRateLimit)).thenReturn(fakeRateLimitCompletable);
+
+    when(firebaseInstanceId.getId()).thenReturn(INSTANCE_ID);
+    when(firebaseInstanceId.getToken()).thenReturn(INSTANCE_TOKEN);
+
+    when(firebaseInstanceId.getId()).thenReturn(INSTANCE_ID);
+    when(firebaseInstanceId.getToken()).thenReturn(INSTANCE_TOKEN);
+    when(dataCollectionHelper.isAutomaticDataCollectionEnabled()).thenReturn(true);
+    FakeClock clock = new FakeClock(NOW);
+
+    displayCallbacksFactory =
+        new DisplayCallbacksFactory(
+            impressionStorageClient,
+            clock,
+            schedulers,
+            rateLimiterClient,
+            campaignCacheClient,
+            appForegroundRateLimit,
+            metricsLoggerClient,
+            dataCollectionHelper);
+    displayCallbacksImpl =
+        displayCallbacksFactory.generateDisplayCallback(BANNER_MESSAGE_MODEL, ANALYTICS_EVENT_NAME);
+  }
+
+  @Test
+  public void logImpression_forVanillaCampaign_completesTask() {
+    Task<Void> logActionTask = displayCallbacksImpl.impressionDetected();
+
+    assertThat(logActionTask.isComplete()).isTrue();
+  }
+
+  @Test
+  public void logImpression_forVanillaCampaign_recordsImpression() {
+    displayCallbacksImpl.impressionDetected();
+
+    assertThat(wasRecorded).isTrue();
+  }
+
+  @Test
+  public void logImpression_forTestCampaign_doesRecordImpression() {
+    displayCallbacksImpl =
+        displayCallbacksFactory.generateDisplayCallback(
+            BANNER_TEST_MESSAGE_MODEL, ANALYTICS_EVENT_NAME);
+    displayCallbacksImpl.impressionDetected();
+
+    assertThat(wasRecorded).isTrue();
+  }
+
+  @Test
+  public void logImpression_forAppOpenCampaign_incrementsLimiter() {
+    displayCallbacksImpl =
+        displayCallbacksFactory.generateDisplayCallback(BANNER_MESSAGE_MODEL, ON_FOREGROUND.name());
+    displayCallbacksImpl.impressionDetected();
+
+    assertThat(ON_FOREGROUND.name()).isEqualTo(InAppMessageStreamManager.ON_FOREGROUND);
+    assertThat(wasIncremented).isTrue();
+  }
+
+  @Test
+  public void logImpression_forUnknownCampaign_doesNotIncrementsLimiter() {
+    BannerMessage inAppMessage =
+        createBannerMessageCustomMetadata(
+            new CampaignMetadata("SOME_OTHER_CAMPAIGN", "other_name", IS_NOT_TEST_MESSAGE));
+    displayCallbacksImpl =
+        displayCallbacksFactory.generateDisplayCallback(inAppMessage, ANALYTICS_EVENT_NAME);
+    displayCallbacksImpl.impressionDetected();
+
+    assertThat(wasIncremented).isFalse();
+  }
+
+  @Test
+  public void logImpression_forTestCampaign_doesNotIncrementsLimiter() {
+    displayCallbacksImpl =
+        displayCallbacksFactory.generateDisplayCallback(
+            BANNER_TEST_MESSAGE_MODEL, ANALYTICS_EVENT_NAME);
+    displayCallbacksImpl.impressionDetected();
+
+    assertThat(wasIncremented).isFalse();
+  }
+
+  @Test
+  public void logImpression_forAnalyticsEventBasedCampaign_doesNotIncrementsLimiter() {
+    InAppMessage inAppMessage =
+        createBannerMessageCustomMetadata(
+            new CampaignMetadata(CAMPAIGN_ID2, CAMPAIGN_NAME2, IS_NOT_TEST_MESSAGE));
+    displayCallbacksImpl =
+        displayCallbacksFactory.generateDisplayCallback(inAppMessage, ANALYTICS_EVENT_NAME);
+    displayCallbacksImpl.impressionDetected();
+
+    assertThat(wasIncremented).isFalse();
+  }
+
+  @Test
+  public void logImpression_onImpressionError_notifiesError() {
+    NullPointerException npe = new NullPointerException("e1");
+    when(impressionStorageClient.storeImpression(any(CampaignImpression.class)))
+        .thenReturn(Completable.error(npe));
+    Task<Void> logActionTask = displayCallbacksImpl.impressionDetected();
+
+    assertThat(logActionTask.getException()).isEqualTo(npe);
+  }
+
+  @Test
+  public void logImpression_onLimiterError_absorbsError() {
+    NullPointerException npe = new NullPointerException("e1");
+    when(rateLimiterClient.increment(appForegroundRateLimit)).thenReturn(Completable.error(npe));
+    Task<Void> logActionTask = displayCallbacksImpl.impressionDetected();
+
+    assertThat(logActionTask.isComplete()).isTrue();
+    assertThat(logActionTask.getException()).isNull();
+    assertThat(wasRecorded).isTrue();
+  }
+
+  @Test
+  public void logImpression_pipesImpressionToEngagementMetrics() {
+    displayCallbacksImpl.impressionDetected();
+    verify(metricsLoggerClient).logImpression(BANNER_MESSAGE_MODEL);
+  }
+
+  @Test
+  public void logImpression_doesNothingIfDataCollectionIsDisabled() {
+    when(dataCollectionHelper.isAutomaticDataCollectionEnabled()).thenReturn(false);
+    displayCallbacksImpl.impressionDetected();
+
+    verify(metricsLoggerClient, times(0)).logImpression(BANNER_MESSAGE_MODEL);
+  }
+
+  @Test
+  public void logImpression_logsCorrectlyForTestMessage() {
+    displayCallbacksImpl =
+        displayCallbacksFactory.generateDisplayCallback(
+            BANNER_TEST_MESSAGE_MODEL, ANALYTICS_EVENT_NAME);
+
+    displayCallbacksImpl.impressionDetected();
+
+    verify(metricsLoggerClient, times(1)).logImpression(BANNER_TEST_MESSAGE_MODEL);
+  }
+
+  @Test
+  public void logMessageClick_pipesActionToEngagementMetrics() {
+    displayCallbacksImpl.messageClicked(BANNER_MESSAGE_MODEL.getAction());
+    verify(metricsLoggerClient)
+        .logMessageClick(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+    assertThat(wasRecorded).isTrue(); // loggedImpression with impression store
+  }
+
+  @Test
+  public void logMessageClick_logsImpressionIfNotAlreadyLogged() {
+    displayCallbacksImpl.messageClicked(BANNER_MESSAGE_MODEL.getAction());
+    verify(metricsLoggerClient)
+        .logMessageClick(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+    verify(metricsLoggerClient, times(1)).logImpression(BANNER_MESSAGE_MODEL);
+    assertThat(wasRecorded).isTrue(); // loggedImpression with impression store
+  }
+
+  @Test
+  public void logMessageClick_doesNotLogImpressionIfAlreadyLogged() {
+    displayCallbacksImpl.impressionDetected();
+    displayCallbacksImpl.messageClicked(BANNER_MESSAGE_MODEL.getAction());
+    verify(metricsLoggerClient)
+        .logMessageClick(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+    verify(metricsLoggerClient, times(1)).logImpression(BANNER_MESSAGE_MODEL);
+    assertThat(wasRecorded).isTrue(); // loggedImpression with impression store
+  }
+
+  @Test
+  public void logImpression_willSendToLoggerOneTimeImpressionIsLoggedPerMessage() {
+    displayCallbacksImpl.impressionDetected();
+    displayCallbacksImpl.impressionDetected();
+    verify(metricsLoggerClient, times(1)).logImpression(BANNER_MESSAGE_MODEL);
+    assertThat(wasRecorded).isTrue(); // loggedImpression with impression store
+  }
+
+  @Test
+  public void logMessageClick_doesNothingIfDataCollectionIsDisabled() {
+    when(dataCollectionHelper.isAutomaticDataCollectionEnabled()).thenReturn(false);
+    displayCallbacksImpl.messageClicked(BANNER_MESSAGE_MODEL.getAction());
+    verify(metricsLoggerClient, times(0))
+        .logMessageClick(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+    ;
+  }
+
+  @Test
+  public void logMessageClick_logsAsDismissIfActionWithoutUrlTriggered() {
+    CardMessage cardMessage =
+        CardMessage.builder()
+            .setTitle(TITLE_MODEL)
+            .setPortraitImageData(IMAGE_DATA)
+            .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+            .setPrimaryAction(ACTION_MODEL_WITH_BUTTON)
+            .setSecondaryAction(ACTION_MODEL_WITHOUT_URL)
+            .build(
+                new CampaignMetadata(
+                    CAMPAIGN_ID_STRING, CAMPAIGN_NAME_STRING, IS_NOT_TEST_MESSAGE));
+
+    displayCallbacksImpl =
+        displayCallbacksFactory.generateDisplayCallback(cardMessage, ANALYTICS_EVENT_NAME);
+
+    displayCallbacksImpl.messageClicked(cardMessage.getSecondaryAction());
+    verify(metricsLoggerClient, times(0))
+        .logMessageClick(cardMessage, cardMessage.getSecondaryAction());
+    verify(metricsLoggerClient, times(1)).logDismiss(cardMessage, InAppMessagingDismissType.CLICK);
+  }
+
+  @Test
+  public void logMessageClick_logsAsClickIfActionWithUrlTriggered() {
+    CardMessage cardMessage =
+        CardMessage.builder()
+            .setTitle(TITLE_MODEL)
+            .setPortraitImageData(IMAGE_DATA)
+            .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+            .setPrimaryAction(ACTION_MODEL_WITH_BUTTON)
+            .setSecondaryAction(ACTION_MODEL_WITH_BUTTON)
+            .build(
+                new CampaignMetadata(
+                    CAMPAIGN_ID_STRING, CAMPAIGN_NAME_STRING, IS_NOT_TEST_MESSAGE));
+
+    displayCallbacksImpl =
+        displayCallbacksFactory.generateDisplayCallback(cardMessage, ANALYTICS_EVENT_NAME);
+
+    displayCallbacksImpl.messageClicked(cardMessage.getSecondaryAction());
+    verify(metricsLoggerClient, times(1))
+        .logMessageClick(cardMessage, cardMessage.getSecondaryAction());
+    verify(metricsLoggerClient, times(0)).logDismiss(cardMessage, InAppMessagingDismissType.CLICK);
+  }
+
+  @Test
+  public void logMessageClick_logsCorrectlyForTestMessage() {
+    displayCallbacksImpl =
+        displayCallbacksFactory.generateDisplayCallback(
+            BANNER_TEST_MESSAGE_MODEL, ANALYTICS_EVENT_NAME);
+    displayCallbacksImpl.messageClicked(BANNER_TEST_MESSAGE_MODEL.getAction());
+
+    verify(metricsLoggerClient, times(1))
+        .logMessageClick(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+    ;
+  }
+
+  @Test
+  public void logRenderError_pipesErrorToEngagementMetrics() {
+    displayCallbacksImpl.displayErrorEncountered(InAppMessagingErrorReason.IMAGE_DISPLAY_ERROR);
+    verify(metricsLoggerClient)
+        .logRenderError(BANNER_MESSAGE_MODEL, InAppMessagingErrorReason.IMAGE_DISPLAY_ERROR);
+    assertThat(wasRecorded).isTrue(); // loggedImpression with impression store
+  }
+
+  @Test
+  public void logRenderError_addsImpressionToStoreButDoesntLogToEngagementMetrics() {
+    displayCallbacksImpl.displayErrorEncountered(InAppMessagingErrorReason.IMAGE_DISPLAY_ERROR);
+    verify(metricsLoggerClient)
+        .logRenderError(BANNER_MESSAGE_MODEL, InAppMessagingErrorReason.IMAGE_DISPLAY_ERROR);
+    verify(metricsLoggerClient, never()).logImpression(BANNER_MESSAGE_MODEL);
+    assertThat(wasRecorded).isTrue(); // loggedImpression with impression store
+  }
+
+  @Test
+  public void logRenderError_doesNothingIfDataCollectionIsDisabled() {
+    when(dataCollectionHelper.isAutomaticDataCollectionEnabled()).thenReturn(false);
+    displayCallbacksImpl.displayErrorEncountered(InAppMessagingErrorReason.IMAGE_DISPLAY_ERROR);
+
+    verify(metricsLoggerClient, times(0))
+        .logRenderError(BANNER_MESSAGE_MODEL, InAppMessagingErrorReason.IMAGE_DISPLAY_ERROR);
+  }
+
+  @Test
+  public void logRenderError_logsCorrectlyForTestMessage() {
+    displayCallbacksImpl =
+        displayCallbacksFactory.generateDisplayCallback(
+            BANNER_TEST_MESSAGE_MODEL, ANALYTICS_EVENT_NAME);
+    displayCallbacksImpl.displayErrorEncountered(InAppMessagingErrorReason.IMAGE_DISPLAY_ERROR);
+
+    verify(metricsLoggerClient, times(1))
+        .logRenderError(BANNER_MESSAGE_MODEL, InAppMessagingErrorReason.IMAGE_DISPLAY_ERROR);
+  }
+
+  @Test
+  public void logDismiss_pipesDismissToEngagementMetrics() {
+    displayCallbacksImpl.messageDismissed(InAppMessagingDismissType.SWIPE);
+    verify(metricsLoggerClient).logDismiss(BANNER_MESSAGE_MODEL, InAppMessagingDismissType.SWIPE);
+    assertThat(wasRecorded).isTrue(); // loggedImpression with impression store
+  }
+
+  @Test
+  public void logDismiss_logsImpressionIfNotAlreadyImpressed() {
+    displayCallbacksImpl.messageDismissed(InAppMessagingDismissType.SWIPE);
+    verify(metricsLoggerClient).logDismiss(BANNER_MESSAGE_MODEL, InAppMessagingDismissType.SWIPE);
+    verify(metricsLoggerClient, times(1)).logImpression(BANNER_MESSAGE_MODEL);
+    assertThat(wasRecorded).isTrue(); // loggedImpression with impression store
+  }
+
+  @Test
+  public void logDismiss_doesNothingIfDataCollectionIsDisabled() {
+    when(dataCollectionHelper.isAutomaticDataCollectionEnabled()).thenReturn(false);
+    displayCallbacksImpl.messageDismissed(InAppMessagingDismissType.SWIPE);
+
+    verify(metricsLoggerClient, times(0))
+        .logDismiss(BANNER_MESSAGE_MODEL, InAppMessagingDismissType.SWIPE);
+  }
+
+  @Test
+  public void logDismiss_logsCorrectlyForTestMessage() {
+    displayCallbacksImpl =
+        displayCallbacksFactory.generateDisplayCallback(
+            BANNER_TEST_MESSAGE_MODEL, ANALYTICS_EVENT_NAME);
+    displayCallbacksImpl.messageDismissed(InAppMessagingDismissType.SWIPE);
+
+    verify(metricsLoggerClient, times(1))
+        .logDismiss(BANNER_MESSAGE_MODEL, InAppMessagingDismissType.SWIPE);
+  }
+
+  @Implements(FirebaseInstanceId.class)
+  public static class ShadowFirebaseInstanceId {
+    @Implementation
+    public static FirebaseInstanceId getInstance() {
+      return firebaseInstanceId;
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/FakeAnalyticsConnector.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/FakeAnalyticsConnector.java
new file mode 100644
index 000000000..ce6f1b223
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/FakeAnalyticsConnector.java
@@ -0,0 +1,160 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static junit.framework.Assert.assertEquals;
+
+import android.os.Bundle;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.analytics.connector.AnalyticsConnector.AnalyticsConnectorHandle;
+import com.google.firebase.analytics.connector.AnalyticsConnector.AnalyticsConnectorListener;
+import com.google.firebase.analytics.connector.AnalyticsConnector.ConditionalUserProperty;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/** Test implementation of AnalyticsConnector (TBReplaced by their test impl) */
+public class FakeAnalyticsConnector implements AnalyticsConnector {
+
+  FakeAnalyticsConnector() {}
+
+  private static final List<LoggedEvent> logEventInternalCalls = new ArrayList<>();
+  private static final List<LoggedUserProperty> setUserPropertyInternalCalls = new ArrayList<>();
+
+  @Override
+  public void logEvent(String origin, String name, Bundle params) {
+    if (origin.equals("fiam")) {
+      logEventInternalCalls.add(new LoggedEvent(origin, name, params));
+    }
+  }
+
+  @Override
+  public void setUserProperty(String origin, String name, Object value) {
+    if (origin.equals("fiam")) {
+      setUserPropertyInternalCalls.add(new LoggedUserProperty(origin, name, value));
+    }
+  }
+
+  public static void resetState() {
+    logEventInternalCalls.clear();
+    setUserPropertyInternalCalls.clear();
+  }
+
+  public List<LoggedEvent> getLoggedEvent() {
+    return logEventInternalCalls;
+  }
+
+  public List<LoggedUserProperty> getSetUserProperty() {
+    return setUserPropertyInternalCalls;
+  }
+
+  public static void verifySetUserProperty(LoggedUserProperty... expectedUserProperties) {
+    assertEquals(
+        "Incorrect # of user-properties",
+        expectedUserProperties.length,
+        setUserPropertyInternalCalls.size());
+
+    for (int i = 0; i < expectedUserProperties.length; i++) {
+      LoggedUserProperty expected = expectedUserProperties[i];
+      LoggedUserProperty actual = setUserPropertyInternalCalls.get(i);
+      assertEquals("Incorrect user-property origin", expected.origin, actual.origin);
+      assertEquals("Incorrect user-property name", expected.name, actual.name);
+      assertEquals("Incorrect user-property value", expected.value, actual.value);
+    }
+  }
+
+  public static class LoggedUserProperty {
+    String origin;
+    String name;
+    Object value;
+
+    public LoggedUserProperty(String origin, String name, Object value) {
+      this.origin = origin;
+      this.name = name;
+      this.value = value;
+    }
+  }
+
+  public static class LoggedEvent {
+    String origin;
+    String name;
+    Bundle params;
+
+    public LoggedEvent() {
+      this("", "", new Bundle());
+    }
+
+    public LoggedEvent(String origin, String name, Bundle params) {
+      this.origin = origin;
+      this.name = name;
+      this.params = params;
+    }
+
+    public LoggedEvent setOrigin(String origin) {
+      this.origin = origin;
+      return this;
+    }
+
+    public LoggedEvent setName(String name) {
+      this.name = name;
+      return this;
+    }
+
+    public LoggedEvent setParam(String key, String value) {
+      params.putString(key, value);
+      return this;
+    }
+
+    public LoggedEvent setParam(String key, int value) {
+      params.putInt(key, value);
+      return this;
+    }
+  }
+
+  // Unused portion of the AnalyticsConnector interface:
+
+  @Override
+  public Map<String, Object> getUserProperties(boolean includeInternal) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public AnalyticsConnectorHandle registerAnalyticsConnectorListener(
+      String origin, AnalyticsConnectorListener listener) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void setConditionalUserProperty(ConditionalUserProperty conditionalUserProperty) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void clearConditionalUserProperty(
+      String userPropertyName, String clearEventName, Bundle clearEventParams) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public List<ConditionalUserProperty> getConditionalUserProperties(
+      String origin, String propertyNamePrefix) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int getMaxUserProperties(String origin) {
+    throw new UnsupportedOperationException();
+  }
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/FiamAnalyticsConnectorListenerTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/FiamAnalyticsConnectorListenerTest.java
new file mode 100644
index 000000000..8c6c8a49c
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/FiamAnalyticsConnectorListenerTest.java
@@ -0,0 +1,60 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import android.os.Bundle;
+import io.reactivex.FlowableEmitter;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+
+@RunWith(RobolectricTestRunner.class)
+public final class FiamAnalyticsConnectorListenerTest {
+
+  @Mock private FlowableEmitter<String> emitter;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void fiamAnalyticsConnectorListener_ok() throws Exception {
+    FiamAnalyticsConnectorListener listener = new FiamAnalyticsConnectorListener(emitter);
+    Bundle bundle = new Bundle();
+    String eventName = "event1";
+    bundle.putString("events", eventName);
+    listener.onMessageTriggered(
+        AnalyticsConstants.FIAM_ANALYTICS_CONNECTOR_LISTENER_EVENT_ID, bundle);
+    verify(emitter, times(1)).onNext(eventName);
+  }
+
+  @Test
+  public void fiamAnalyticsConnectorListener_doesntTriggerOnOtherIds() throws Exception {
+    FiamAnalyticsConnectorListener listener = new FiamAnalyticsConnectorListener(emitter);
+    Bundle bundle = new Bundle();
+    String eventName = "event1";
+    bundle.putString(AnalyticsConstants.BUNDLE_EVENT_NAME_KEY, eventName);
+    listener.onMessageTriggered(1, bundle);
+    verify(emitter, never()).onNext(eventName);
+  }
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/ForegroundNotifierTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/ForegroundNotifierTest.java
new file mode 100644
index 000000000..1588774df
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/ForegroundNotifierTest.java
@@ -0,0 +1,76 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import com.google.firebase.inappmessaging.internal.ForegroundNotifier.Listener;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ForegroundNotifierTest {
+  @Mock Listener listener;
+  private ForegroundNotifier foregroundNotifier;
+
+  @Before
+  public void setup() {
+    initMocks(this);
+    foregroundNotifier = new ForegroundNotifier();
+  }
+
+  @Test
+  public void notifier_onActivityResumedForFirstTime_notifiesListener() {
+    ForegroundNotifier foregroundNotifier = new ForegroundNotifier();
+    foregroundNotifier.setListener(listener);
+
+    foregroundNotifier.onActivityResumed(null);
+
+    verify(listener).onForeground();
+  }
+
+  @Test
+  public void notifier_onActivityResumedBeforeRunnable_doesNotNotifyListener() {
+    foregroundNotifier.setListener(listener);
+
+    foregroundNotifier.onActivityResumed(null); // called once
+    verify(listener, times(1)).onForeground();
+    foregroundNotifier.onActivityPaused(null);
+    foregroundNotifier.onActivityResumed(null); // should not be called
+
+    verify(listener, times(1)).onForeground();
+  }
+
+  @Test
+  public void notifier_onActivityResumedAfterRunnableExecution_notifiesListener() {
+    foregroundNotifier.setListener(listener);
+
+    foregroundNotifier.onActivityResumed(null); // 1
+    verify(listener, times(1)).onForeground();
+    foregroundNotifier.onActivityPaused(null);
+    Robolectric.flushForegroundThreadScheduler();
+    foregroundNotifier.onActivityResumed(null); // 2
+
+    verify(listener, times(2)).onForeground();
+  }
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/GrpcClientTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/GrpcClientTest.java
new file mode 100644
index 000000000..546ed6e1e
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/GrpcClientTest.java
@@ -0,0 +1,111 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static com.google.firebase.inappmessaging.testutil.Assert.assertThrows;
+import static junit.framework.Assert.assertEquals;
+
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsRequest;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsResponse;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.InAppMessagingSdkServingGrpc;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.InAppMessagingSdkServingGrpc.InAppMessagingSdkServingBlockingStub;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.InAppMessagingSdkServingGrpc.InAppMessagingSdkServingImplBase;
+import io.grpc.ClientInterceptors;
+import io.grpc.Metadata;
+import io.grpc.StatusRuntimeException;
+import io.grpc.stub.MetadataUtils;
+import io.grpc.stub.StreamObserver;
+import io.grpc.testing.GrpcServerRule;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class GrpcClientTest {
+  private static final String TEST_PROJECT_NUMBER = "123";
+  private final Metadata testMetadata = new Metadata();
+  private final FetchEligibleCampaignsResponse testFetchEligibleCampaignsResponse =
+      FetchEligibleCampaignsResponse.getDefaultInstance();
+  private final FetchEligibleCampaignsRequest fetchEligibleCampaignsRequest =
+      FetchEligibleCampaignsRequest.newBuilder().setProjectNumber(TEST_PROJECT_NUMBER).build();
+  @Rule public GrpcServerRule grpcServerRule = new GrpcServerRule().directExecutor();
+  private GrpcClient grpcClient;
+  private InAppMessagingSdkServingBlockingStub inAppMessagingSdkServingBlockingStub;
+
+  @Before
+  public void setup() {
+    MockitoAnnotations.initMocks(this);
+    inAppMessagingSdkServingBlockingStub =
+        InAppMessagingSdkServingGrpc.newBlockingStub(
+            ClientInterceptors.intercept(
+                grpcServerRule.getChannel(),
+                MetadataUtils.newAttachHeadersInterceptor(testMetadata)));
+    grpcClient = new GrpcClient(inAppMessagingSdkServingBlockingStub);
+  }
+
+  @Test
+  public void testFetchEligibleCampaignsSuccess() {
+    grpcServerRule
+        .getServiceRegistry()
+        .addService(new FakeFetchService(r -> assertEquals(fetchEligibleCampaignsRequest, r)));
+
+    assertEquals(
+        testFetchEligibleCampaignsResponse,
+        grpcClient.fetchEligibleCampaigns(fetchEligibleCampaignsRequest));
+  }
+
+  @Test
+  public void testFetchEligibleCampaignsFailure() {
+    grpcServerRule
+        .getServiceRegistry()
+        .addService(
+            new FakeFetchService(
+                r -> {
+                  throw new RuntimeException("any exception");
+                }));
+
+    assertThrows(
+        StatusRuntimeException.class,
+        () -> grpcClient.fetchEligibleCampaigns(fetchEligibleCampaignsRequest));
+  }
+
+  interface Callback {
+    void exec(FetchEligibleCampaignsRequest r);
+  }
+
+  class FakeFetchService extends InAppMessagingSdkServingImplBase {
+    private final Callback mCallback;
+
+    protected FakeFetchService(Callback mCallback) {
+      this.mCallback = mCallback;
+    }
+
+    @Override
+    public void fetchEligibleCampaigns(
+        FetchEligibleCampaignsRequest request,
+        StreamObserver<FetchEligibleCampaignsResponse> responseObserver) {
+      if (mCallback != null) {
+        mCallback.exec(request);
+      }
+      responseObserver.onNext(testFetchEligibleCampaignsResponse);
+      responseObserver.onCompleted();
+    }
+  }
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/ImpressionStorageClientTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/ImpressionStorageClientTest.java
new file mode 100644
index 000000000..56ca454d0
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/ImpressionStorageClientTest.java
@@ -0,0 +1,233 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.CampaignImpression;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.CampaignImpressionList;
+import com.google.protobuf.Parser;
+import io.reactivex.Completable;
+import io.reactivex.Maybe;
+import io.reactivex.subscribers.TestSubscriber;
+import java.io.IOException;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ImpressionStorageClientTest {
+  private static final String CAMPAIGN_ID = "campaign_id";
+  private static final CampaignImpression campaignImpression =
+      CampaignImpression.newBuilder().setCampaignId(CAMPAIGN_ID).build();
+  private static final CampaignImpressionList campaignImpressionList =
+      CampaignImpressionList.newBuilder().addAlreadySeenCampaigns(campaignImpression).build();
+  @Mock private ProtoStorageClient storageClient;
+  private ImpressionStorageClient impressionStorageClient;
+  private Completable fakeWrite;
+  private boolean wasWritten;
+  private Maybe<CampaignImpressionList> fakeRead;
+
+  private static List<Object> getPlainValues(TestSubscriber<CampaignImpressionList> subscriber) {
+    return subscriber.getEvents().get(0);
+  }
+
+  @Before
+  public void setup() throws IOException {
+    initMocks(this);
+    impressionStorageClient = new ImpressionStorageClient(storageClient);
+
+    fakeRead = Maybe.fromCallable(() -> campaignImpressionList);
+    fakeWrite =
+        Completable.fromCallable(
+            () -> {
+              wasWritten = true;
+              return null;
+            });
+
+    when(storageClient.read(any(CampaignImpressionsParser.class))).thenReturn(fakeRead);
+    when(storageClient.write(any(CampaignImpressionList.class))).thenReturn(fakeWrite);
+  }
+
+  @Test
+  public void storeImpression_noErrors_writesToStorage() {
+    impressionStorageClient.storeImpression(campaignImpression).subscribe();
+
+    assertThat(wasWritten).isTrue();
+  }
+
+  @Test
+  public void storeImpression_noExistingImpressions_writesToStorage() {
+    when(storageClient.read(any(CampaignImpressionsParser.class))).thenReturn(Maybe.empty());
+
+    impressionStorageClient.storeImpression(campaignImpression).subscribe();
+
+    assertThat(wasWritten).isTrue();
+  }
+
+  @Test
+  public void storeImpression_noErrors_storesAppendedCampaigns() {
+    when(storageClient.read(any(CampaignImpressionsParser.class)))
+        .thenReturn(
+            Maybe.just(
+                CampaignImpressionList.newBuilder()
+                    .addAlreadySeenCampaigns(campaignImpression)
+                    .build()));
+    ArgumentCaptor<CampaignImpressionList> campaignImpressionListArgumentCaptor =
+        ArgumentCaptor.forClass(CampaignImpressionList.class);
+    impressionStorageClient.storeImpression(campaignImpression).subscribe();
+    verify(storageClient).write(campaignImpressionListArgumentCaptor.capture());
+
+    assertThat(campaignImpressionListArgumentCaptor.getValue().getAlreadySeenCampaignsList())
+        .containsExactly(campaignImpression, campaignImpression);
+  }
+
+  @Test
+  public void storeImpression_noExistingCampaigns_storesAppendedCampaigns() {
+    when(storageClient.read(any(CampaignImpressionsParser.class))).thenReturn(Maybe.empty());
+    ArgumentCaptor<CampaignImpressionList> campaignImpressionListArgumentCaptor =
+        ArgumentCaptor.forClass(CampaignImpressionList.class);
+    impressionStorageClient.storeImpression(campaignImpression).subscribe();
+    verify(storageClient).write(campaignImpressionListArgumentCaptor.capture());
+
+    assertThat(campaignImpressionListArgumentCaptor.getValue().getAlreadySeenCampaignsList())
+        .containsExactly(campaignImpression);
+  }
+
+  @Test
+  public void storeImpression_noErrors_cachesInMemory() {
+    CampaignImpressionList otherCampaignImpressionList =
+        CampaignImpressionList.getDefaultInstance();
+    when(storageClient.read(any(CampaignImpressionsParser.class))).thenReturn(Maybe.empty());
+    impressionStorageClient.storeImpression(campaignImpression).subscribe();
+    when(storageClient.read(any(CampaignImpressionsParser.class)))
+        .thenReturn(Maybe.just(otherCampaignImpressionList));
+
+    TestSubscriber<CampaignImpressionList> subscriber =
+        impressionStorageClient.getAllImpressions().toFlowable().test();
+
+    assertThat(
+            ((CampaignImpressionList) (getPlainValues(subscriber).get(0)))
+                .getAlreadySeenCampaignsList())
+        .containsExactly(campaignImpression);
+  }
+
+  @Test
+  public void storeImpression_writeErrors_doesNotSetInMemoryCache() {
+    CampaignImpressionList otherCampaignImpressionList =
+        CampaignImpressionList.getDefaultInstance();
+    when(storageClient.write(any(CampaignImpressionList.class)))
+        .thenReturn(Completable.error(new IOException()));
+    when(storageClient.read(any(CampaignImpressionsParser.class))).thenReturn(Maybe.empty());
+    impressionStorageClient.storeImpression(campaignImpression).subscribe();
+    when(storageClient.read(any(CampaignImpressionsParser.class)))
+        .thenReturn(Maybe.just(otherCampaignImpressionList));
+
+    TestSubscriber<CampaignImpressionList> subscriber =
+        impressionStorageClient.getAllImpressions().toFlowable().test();
+
+    assertThat(getPlainValues(subscriber)).containsExactly(otherCampaignImpressionList);
+  }
+
+  @Test
+  public void storeImpression_writeErrors_notifiesError() {
+    when(storageClient.write(any(CampaignImpressionList.class)))
+        .thenReturn(Completable.error(new IOException()));
+
+    TestSubscriber<Object> subscriber =
+        impressionStorageClient.storeImpression(campaignImpression).toFlowable().test();
+
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test
+  public void storeImpression_readErrors_notifiesError() {
+    when(storageClient.read(any(CampaignImpressionsParser.class)))
+        .thenReturn(Maybe.error(new IOException()));
+
+    TestSubscriber<Object> subscriber =
+        impressionStorageClient.storeImpression(campaignImpression).toFlowable().test();
+
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test
+  public void getAllImpressions_noErrors_returnsCampaignsList() {
+    TestSubscriber<CampaignImpressionList> subscriber =
+        impressionStorageClient.getAllImpressions().toFlowable().test();
+
+    assertThat(getPlainValues(subscriber)).containsExactly(campaignImpressionList);
+  }
+
+  @Test
+  public void getAllImpressions_readError_notifiesError() {
+    when(storageClient.read(any(CampaignImpressionsParser.class)))
+        .thenReturn(Maybe.error(new IOException()));
+
+    TestSubscriber<CampaignImpressionList> subscriber =
+        impressionStorageClient.getAllImpressions().toFlowable().test();
+
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test
+  public void isImpressed_ifCampaignImpressed_isTrue() {
+    TestSubscriber<Boolean> subscriber =
+        impressionStorageClient.isImpressed(CAMPAIGN_ID).toFlowable().test();
+
+    assertThat(subscriber.getEvents().get(0)).containsExactly(true);
+  }
+
+  @Test
+  public void isImpressed_ifCampaignNotImpressed_isFalse() {
+    TestSubscriber<Boolean> subscriber =
+        impressionStorageClient.isImpressed("some_other_campaign_id").toFlowable().test();
+
+    assertThat(subscriber.getEvents().get(0)).containsExactly(false);
+  }
+
+  @Test
+  public void isImpressed_ifNoCampaigns_isFalse() {
+    when(storageClient.read(any(CampaignImpressionsParser.class))).thenReturn(Maybe.empty());
+
+    TestSubscriber<Boolean> subscriber =
+        impressionStorageClient.isImpressed(CAMPAIGN_ID).toFlowable().test();
+
+    assertThat(subscriber.getEvents().get(0)).containsExactly(false);
+  }
+
+  @Test
+  public void isImpressed_onError_notifiesError() {
+    when(storageClient.read(any(CampaignImpressionsParser.class)))
+        .thenReturn(Maybe.error(new IOException()));
+
+    TestSubscriber<Boolean> subscriber =
+        impressionStorageClient.isImpressed(CAMPAIGN_ID).toFlowable().test();
+
+    subscriber.assertError(IOException.class);
+  }
+
+  interface CampaignImpressionsParser extends Parser<CampaignImpressionList> {}
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/InAppMessageStreamManagerTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/InAppMessageStreamManagerTest.java
new file mode 100644
index 000000000..bd47390ec
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/InAppMessageStreamManagerTest.java
@@ -0,0 +1,536 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.firebase.inappmessaging.CommonTypesProto.Trigger.ON_FOREGROUND;
+import static com.google.firebase.inappmessaging.testutil.TestData.ANALYTICS_EVENT_NAME;
+import static com.google.firebase.inappmessaging.testutil.TestData.BANNER_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.BANNER_TEST_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.CAMPAIGN_ID_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.CAMPAIGN_NAME_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.ON_FOREGROUND_EVENT_NAME;
+import static com.google.firebase.inappmessaging.testutil.TestProtos.BANNER_MESSAGE_PROTO;
+import static io.reactivex.BackpressureStrategy.BUFFER;
+import static io.reactivex.schedulers.Schedulers.trampoline;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.Application;
+import com.google.firebase.inappmessaging.CommonTypesProto.ContextualTrigger;
+import com.google.firebase.inappmessaging.CommonTypesProto.Priority;
+import com.google.firebase.inappmessaging.CommonTypesProto.TriggeringCondition;
+import com.google.firebase.inappmessaging.internal.time.FakeClock;
+import com.google.firebase.inappmessaging.model.RateLimit;
+import com.google.firebase.inappmessaging.model.TriggeredInAppMessage;
+import com.google.internal.firebase.inappmessaging.v1.CampaignProto.ThickContent;
+import com.google.internal.firebase.inappmessaging.v1.CampaignProto.VanillaCampaignPayload;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.CampaignImpression;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.CampaignImpressionList;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsResponse;
+import io.grpc.Status;
+import io.grpc.StatusRuntimeException;
+import io.reactivex.Completable;
+import io.reactivex.Flowable;
+import io.reactivex.FlowableEmitter;
+import io.reactivex.Maybe;
+import io.reactivex.Single;
+import io.reactivex.flowables.ConnectableFlowable;
+import io.reactivex.subscribers.TestSubscriber;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+// TODO: Refactor and clean this logic
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class InAppMessageStreamManagerTest {
+  private static final long PAST = 1000000;
+  private static final long NOW = PAST + 100000;
+  private static final long FUTURE = NOW + 1000000;
+
+  private static final TriggeringCondition.Builder ON_ANALYTICS_TRIGGER =
+      TriggeringCondition.newBuilder()
+          .setContextualTrigger(ContextualTrigger.newBuilder().setName(ANALYTICS_EVENT_NAME));
+  private static final TriggeringCondition ON_FOREGROUND_TRIGGER =
+      TriggeringCondition.newBuilder().setFiamTrigger(ON_FOREGROUND).build();
+  private static final Priority priorityTwo = Priority.newBuilder().setValue(2).build();
+  private static final VanillaCampaignPayload.Builder vanillaCampaign =
+      VanillaCampaignPayload.newBuilder()
+          .setCampaignId(CAMPAIGN_ID_STRING)
+          .setCampaignName(CAMPAIGN_NAME_STRING)
+          .setCampaignStartTimeMillis(PAST)
+          .setCampaignEndTimeMillis(FUTURE);
+  private static final ThickContent.Builder thickContentBuilder =
+      ThickContent.newBuilder()
+          .setPriority(priorityTwo)
+          .addTriggeringConditions(ON_FOREGROUND_TRIGGER)
+          .addTriggeringConditions(ON_ANALYTICS_TRIGGER)
+          .setVanillaPayload(vanillaCampaign)
+          .setContent(BANNER_MESSAGE_PROTO);
+  private static final ThickContent thickContent = thickContentBuilder.build();
+
+  private static final TriggeredInAppMessage onForegroundTriggered =
+      new TriggeredInAppMessage(BANNER_MESSAGE_MODEL, ON_FOREGROUND_EVENT_NAME);
+  private static final TriggeredInAppMessage onAnalyticsTriggered =
+      new TriggeredInAppMessage(BANNER_MESSAGE_MODEL, ANALYTICS_EVENT_NAME);
+  private static final FetchEligibleCampaignsResponse.Builder campaignsResponseBuilder =
+      FetchEligibleCampaignsResponse.newBuilder()
+          .setExpirationEpochTimestampMillis(FUTURE)
+          .addMessages(thickContent);
+  private static final FetchEligibleCampaignsResponse campaignsResponse =
+      campaignsResponseBuilder.build();
+  private static final Schedulers schedulers =
+      new Schedulers(trampoline(), trampoline(), trampoline());
+
+  private static final CampaignImpressionList CAMPAIGN_IMPRESSIONS =
+      CampaignImpressionList.newBuilder()
+          .addAlreadySeenCampaigns(
+              CampaignImpression.newBuilder().setCampaignId(CAMPAIGN_ID_STRING).build())
+          .build();
+  private static final String LIMITER_KEY = "LIMITER_KEY";
+  private static final RateLimit appForegroundRateLimit =
+      RateLimit.builder()
+          .setLimit(1)
+          .setLimiterKey(LIMITER_KEY)
+          .setTimeToLiveMillis(TimeUnit.DAYS.toMillis(1))
+          .build();
+  @Mock private ApiClient mockApiClient;
+  @Mock private Application application;
+  @Mock private CampaignCacheClient campaignCacheClient;
+  @Mock private ImpressionStorageClient impressionStorageClient;
+  @Mock private TestDeviceHelper testDeviceHelper;
+  @Mock private RateLimiterClient rateLimiterClient;
+  @Mock private AnalyticsEventsManager analyticsEventsManager;
+  @Captor private ArgumentCaptor<CampaignImpressionList> campaignImpressionListArgumentCaptor;
+
+  private InAppMessageStreamManager streamManager;
+  private FlowableEmitter<String> appForegroundEmitter;
+  private TestSubscriber<TriggeredInAppMessage> subscriber;
+  private FlowableEmitter<String> analyticsEmitter;
+  private FlowableEmitter<String> programmaticTriggerEmitter;
+
+  private static List<TriggeredInAppMessage> getPlainValues(
+      TestSubscriber<TriggeredInAppMessage> subscriber) {
+    return subscriber.getEvents().get(0).stream()
+        .map(obj -> (TriggeredInAppMessage) obj)
+        .collect(Collectors.toList());
+  }
+
+  private static void assertExpectedMessageTriggered(
+      TestSubscriber<TriggeredInAppMessage> subscriber, TriggeredInAppMessage message) {
+    List<TriggeredInAppMessage> values = getPlainValues(subscriber);
+    assertThat(values.size()).isEqualTo(1);
+    TriggeredInAppMessage actual = values.get(0);
+    assertThat(actual.getInAppMessage()).isEqualTo(message.getInAppMessage());
+    assertThat(actual.getTriggeringEvent()).isEqualTo(message.getTriggeringEvent());
+  }
+
+  @Before
+  public void setup() {
+    MockitoAnnotations.initMocks(this);
+    ConnectableFlowable<String> appForegroundEventFlowable =
+        Flowable.<String>create(e -> appForegroundEmitter = e, BUFFER).publish();
+    appForegroundEventFlowable.connect();
+
+    ConnectableFlowable<String> analyticsEventsFlowable =
+        Flowable.<String>create(e -> analyticsEmitter = e, BUFFER).publish();
+    analyticsEventsFlowable.connect();
+    when(analyticsEventsManager.getAnalyticsEventsFlowable()).thenReturn(analyticsEventsFlowable);
+
+    ConnectableFlowable<String> programmaticTriggerFlowable =
+        Flowable.<String>create(e -> programmaticTriggerEmitter = e, BUFFER).publish();
+    programmaticTriggerFlowable.connect();
+
+    streamManager =
+        new InAppMessageStreamManager(
+            appForegroundEventFlowable,
+            programmaticTriggerFlowable,
+            campaignCacheClient,
+            new FakeClock(NOW),
+            mockApiClient,
+            analyticsEventsManager,
+            schedulers,
+            impressionStorageClient,
+            rateLimiterClient,
+            appForegroundRateLimit,
+            testDeviceHelper);
+    subscriber = streamManager.createFirebaseInAppMessageStream().test();
+    when(application.getApplicationContext()).thenReturn(application);
+    when(rateLimiterClient.isRateLimited(appForegroundRateLimit)).thenReturn(Single.just(false));
+    when(campaignCacheClient.get()).thenReturn(Maybe.empty());
+    when(campaignCacheClient.put(any(FetchEligibleCampaignsResponse.class)))
+        .thenReturn(Completable.complete());
+    when(impressionStorageClient.isImpressed(anyString())).thenReturn(Single.just(false));
+    when(impressionStorageClient.getAllImpressions()).thenReturn(Maybe.just(CAMPAIGN_IMPRESSIONS));
+  }
+
+  @Test
+  public void stream_onAppOpen_notifiesSubscriber() {
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    assertExpectedMessageTriggered(subscriber, onForegroundTriggered);
+  }
+
+  @Test
+  public void stream_onAnalyticsEvent_notifiesSubscriber() {
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+
+    analyticsEmitter.onNext(ANALYTICS_EVENT_NAME);
+
+    assertExpectedMessageTriggered(subscriber, onAnalyticsTriggered);
+  }
+
+  @Test
+  public void stream_onProgrammaticTrigger_notifiesSubscriber() {
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+
+    programmaticTriggerEmitter.onNext(ANALYTICS_EVENT_NAME);
+
+    assertExpectedMessageTriggered(subscriber, onAnalyticsTriggered);
+  }
+
+  @Test
+  public void stream_onAppOpen_remainsOpen() {
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    subscriber.assertNotComplete();
+  }
+
+  @Test
+  public void stream_onUnrelatedAnalyticsEvent_doesNotTrigger() {
+    String unrelatedAnalyticsEvent = "some_other_event";
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+
+    appForegroundEmitter.onNext(unrelatedAnalyticsEvent);
+
+    subscriber.assertNoValues();
+  }
+
+  @Test
+  public void stream_onExpiredCampaign_doesNotTrigger() {
+    VanillaCampaignPayload.Builder expiredCampaign =
+        VanillaCampaignPayload.newBuilder()
+            .setCampaignStartTimeMillis(PAST)
+            .setCampaignEndTimeMillis(PAST);
+    ThickContent t =
+        ThickContent.newBuilder(thickContent)
+            .clearContent()
+            .setVanillaPayload(expiredCampaign)
+            .build();
+    FetchEligibleCampaignsResponse r =
+        FetchEligibleCampaignsResponse.newBuilder(campaignsResponse)
+            .clearMessages()
+            .addMessages(t)
+            .build();
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(r);
+
+    analyticsEmitter.onNext(ANALYTICS_EVENT_NAME);
+
+    subscriber.assertNoValues();
+  }
+
+  @Test
+  public void stream_onNonVanillaCampaigns_doesNotTrigger() {
+    String unrelatedAnalyticsEvent = "some_other_event";
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+
+    analyticsEmitter.onNext(unrelatedAnalyticsEvent);
+
+    subscriber.assertNoValues();
+  }
+
+  @Test
+  public void stream_onMultipleCampaigns_triggersTestMessage() {
+    ThickContent highPriorityContent =
+        ThickContent.newBuilder(thickContent)
+            .setPriority(Priority.newBuilder().setValue(1))
+            .build();
+    ThickContent testContent =
+        ThickContent.newBuilder(thickContent)
+            .setPriority(Priority.newBuilder().setValue(2))
+            .setIsTestCampaign(true)
+            .build();
+    FetchEligibleCampaignsResponse response =
+        FetchEligibleCampaignsResponse.newBuilder(campaignsResponse)
+            .addMessages(highPriorityContent)
+            .addMessages(testContent)
+            .build();
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(response);
+
+    analyticsEmitter.onNext(ANALYTICS_EVENT_NAME);
+
+    assertExpectedMessageTriggered(
+        subscriber, new TriggeredInAppMessage(BANNER_TEST_MESSAGE_MODEL, ANALYTICS_EVENT_NAME));
+  }
+
+  @Test
+  public void stream_onApiClientFailure_absorbsErrors() {
+    Throwable t = new StatusRuntimeException(Status.DATA_LOSS);
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenThrow(t);
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    subscriber.assertNotComplete();
+    subscriber.assertNoErrors();
+    subscriber.assertNoValues();
+  }
+
+  @Test
+  public void stream_onCacheHit_notifiesCachedValue() {
+    when(campaignCacheClient.get()).thenReturn(Maybe.just(campaignsResponse));
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    assertExpectedMessageTriggered(subscriber, onForegroundTriggered);
+  }
+
+  @Test
+  public void stream_onServiceFetchSuccess_cachesValue() {
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    verify(campaignCacheClient).put(campaignsResponse);
+  }
+
+  @Test
+  public void stream_onServiceFetchSuccess_updatesContextualTriggers() {
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+    verify(analyticsEventsManager).updateContextualTriggers(campaignsResponse);
+  }
+
+  @Test
+  public void stream_onServiceFetchFailure_doesNotCacheValue() {
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenThrow(new RuntimeException("e"));
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    verify(campaignCacheClient, times(0)).put(campaignsResponse);
+  }
+
+  @Test
+  public void stream_whenAppInstallIsFresh_doesNotCacheValue() {
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+    when(testDeviceHelper.isAppInstallFresh()).thenReturn(true);
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    verify(campaignCacheClient, times(0)).put(any());
+  }
+
+  @Test
+  public void stream_whenDeviceIsInTestMode_doesNotCacheValue() {
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+    when(testDeviceHelper.isDeviceInTestMode()).thenReturn(true);
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    verify(campaignCacheClient, times(0)).put(any());
+  }
+
+  @Test
+  public void stream_onCacheReadFailure_notifiesValueFetchedFromService() {
+    when(campaignCacheClient.get()).thenReturn(Maybe.error(new NullPointerException()));
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    assertExpectedMessageTriggered(subscriber, onForegroundTriggered);
+  }
+
+  @Test
+  public void stream_onCacheAndApiFail_absorbsFailure() {
+    when(campaignCacheClient.get()).thenReturn(Maybe.error(new NullPointerException()));
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenThrow(new NullPointerException());
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    subscriber.assertNotComplete();
+    subscriber.assertNoErrors();
+    subscriber.assertNoValues();
+  }
+
+  @Test
+  public void stream_onCacheWriteFailure_AbsorbsError() {
+    when(campaignCacheClient.put(any(FetchEligibleCampaignsResponse.class)))
+        .thenReturn(Completable.error(new NullPointerException()));
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    assertExpectedMessageTriggered(subscriber, onForegroundTriggered);
+  }
+
+  @Test
+  public void stream_whenCampaignImpressed_filtersCampaign() {
+    when(impressionStorageClient.isImpressed(anyString())).thenReturn(Single.just(true));
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    subscriber.assertNoValues();
+  }
+
+  @Test
+  public void stream_whenCampaignImpressionStoreFails_doesNotFilterCampaign() {
+    when(impressionStorageClient.isImpressed(anyString()))
+        .thenReturn(Single.error(new Exception("e1")));
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    assertExpectedMessageTriggered(subscriber, onForegroundTriggered);
+  }
+
+  @Test
+  public void stream_whenCampaignImpressionStoreFail_doesNotFilterCampaign() {
+    when(impressionStorageClient.isImpressed(anyString()))
+        .thenReturn(Single.error(new Exception("e1")));
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    assertExpectedMessageTriggered(subscriber, onForegroundTriggered);
+  }
+
+  @Test
+  public void stream_whenCampaignImpressionStoreFails_absorbsError() {
+    when(impressionStorageClient.getAllImpressions())
+        .thenReturn(Maybe.error(new NullPointerException()));
+    when(mockApiClient.getFiams(any(CampaignImpressionList.class))).thenReturn(campaignsResponse);
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    assertExpectedMessageTriggered(subscriber, onForegroundTriggered);
+  }
+
+  @Test
+  public void stream_whenCampaignImpressionStoreFails_wiresEmptyImpressionList() {
+    when(impressionStorageClient.getAllImpressions())
+        .thenReturn(Maybe.error(new NullPointerException()));
+    when(mockApiClient.getFiams(campaignImpressionListArgumentCaptor.capture()))
+        .thenReturn(campaignsResponse);
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    assertThat(campaignImpressionListArgumentCaptor.getValue())
+        .isEqualTo(CampaignImpressionList.getDefaultInstance());
+  }
+
+  @Test
+  public void stream_whenAppOpenRateLimited_doesNotTrigger() {
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+    when(rateLimiterClient.isRateLimited(appForegroundRateLimit)).thenReturn(Single.just(true));
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    subscriber.assertNoValues();
+  }
+
+  @Test
+  public void stream_whenAppOpenRateLimited_stillTriggersTestMessage() {
+    when(rateLimiterClient.isRateLimited(appForegroundRateLimit)).thenReturn(Single.just(true));
+    when(testDeviceHelper.isDeviceInTestMode()).thenReturn(true);
+    ThickContent testMessageContent =
+        ThickContent.newBuilder()
+            .setPriority(priorityTwo)
+            .addTriggeringConditions(ON_FOREGROUND_TRIGGER)
+            .addTriggeringConditions(ON_ANALYTICS_TRIGGER)
+            .setIsTestCampaign(true)
+            .setVanillaPayload(vanillaCampaign)
+            .setContent(BANNER_MESSAGE_PROTO)
+            .build();
+
+    TriggeredInAppMessage testTriggered =
+        new TriggeredInAppMessage(BANNER_TEST_MESSAGE_MODEL, ON_FOREGROUND_EVENT_NAME);
+    FetchEligibleCampaignsResponse response =
+        FetchEligibleCampaignsResponse.newBuilder()
+            .setExpirationEpochTimestampMillis(FUTURE)
+            .addMessages(testMessageContent)
+            .build();
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(response);
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    assertExpectedMessageTriggered(subscriber, testTriggered);
+  }
+
+  @Test
+  public void stream_alwaysTriggersTestMessagesOnAppForground() {
+    when(rateLimiterClient.isRateLimited(appForegroundRateLimit)).thenReturn(Single.just(false));
+    when(testDeviceHelper.isDeviceInTestMode()).thenReturn(true);
+    ThickContent testMessageContent =
+        ThickContent.newBuilder()
+            .setPriority(priorityTwo)
+            .addTriggeringConditions(ON_ANALYTICS_TRIGGER)
+            .setIsTestCampaign(true)
+            .setVanillaPayload(vanillaCampaign)
+            .setContent(BANNER_MESSAGE_PROTO)
+            .build();
+
+    TriggeredInAppMessage testTriggered =
+        new TriggeredInAppMessage(BANNER_TEST_MESSAGE_MODEL, ON_FOREGROUND_EVENT_NAME);
+    FetchEligibleCampaignsResponse response =
+        FetchEligibleCampaignsResponse.newBuilder()
+            .setExpirationEpochTimestampMillis(FUTURE)
+            .addMessages(testMessageContent)
+            .build();
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(response);
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    assertExpectedMessageTriggered(subscriber, testTriggered);
+  }
+
+  @Test
+  public void stream_whenRateLimitingClientFails_triggers() {
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+    when(rateLimiterClient.isRateLimited(appForegroundRateLimit))
+        .thenReturn(Single.error(new NullPointerException("e1")));
+
+    appForegroundEmitter.onNext(ON_FOREGROUND_EVENT_NAME);
+
+    assertExpectedMessageTriggered(subscriber, onForegroundTriggered);
+  }
+
+  @Test
+  public void stream_whenAppOpenRateLimited_notifiesAnalyticsSubscriber() {
+    when(mockApiClient.getFiams(CAMPAIGN_IMPRESSIONS)).thenReturn(campaignsResponse);
+    when(rateLimiterClient.isRateLimited(appForegroundRateLimit)).thenReturn(Single.just(true));
+
+    analyticsEmitter.onNext(ANALYTICS_EVENT_NAME);
+
+    assertExpectedMessageTriggered(subscriber, onAnalyticsTriggered);
+  }
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/MetricsLoggerClientTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/MetricsLoggerClientTest.java
new file mode 100644
index 000000000..e62bdac93
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/MetricsLoggerClientTest.java
@@ -0,0 +1,680 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.firebase.inappmessaging.EventType.CLICK_EVENT_TYPE;
+import static com.google.firebase.inappmessaging.EventType.IMPRESSION_EVENT_TYPE;
+import static com.google.firebase.inappmessaging.testutil.TestData.BANNER_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.BANNER_MESSAGE_NO_ACTION_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.BANNER_TEST_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.CAMPAIGN_ID_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.CAMPAIGN_NAME_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.CARD_MESSAGE_WITHOUT_ACTIONS;
+import static org.mockito.Matchers.anyObject;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.os.Bundle;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.FirebaseOptions;
+import com.google.firebase.analytics.connector.AnalyticsConnector;
+import com.google.firebase.iid.FirebaseInstanceId;
+import com.google.firebase.inappmessaging.CampaignAnalytics;
+import com.google.firebase.inappmessaging.DismissType;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks.InAppMessagingDismissType;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks.InAppMessagingErrorReason;
+import com.google.firebase.inappmessaging.RenderErrorReason;
+import com.google.firebase.inappmessaging.internal.FakeAnalyticsConnector.LoggedEvent;
+import com.google.firebase.inappmessaging.internal.FakeAnalyticsConnector.LoggedUserProperty;
+import com.google.firebase.inappmessaging.internal.MetricsLoggerClient.EngagementMetricsLoggerInterface;
+import com.google.firebase.inappmessaging.internal.time.FakeClock;
+import com.google.protobuf.InvalidProtocolBufferException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class MetricsLoggerClientTest {
+  private static final long PAST = 1000000;
+  private static final long NOW = PAST + 100000;
+
+  private static final String APPLICATION_ID = "APPLICATION_ID";
+  private static final String INSTANCE_ID = "instance_id";
+  private static final String PROJECT_NUMBER = "project_number";
+
+  private final FirebaseOptions firebaseOptions =
+      new FirebaseOptions.Builder()
+          .setApplicationId(APPLICATION_ID)
+          .setGcmSenderId(PROJECT_NUMBER)
+          .setApiKey("apiKey")
+          .setProjectId("fiam-integration-test")
+          .build();
+
+  @Mock FirebaseApp firebaseApp;
+  @Captor ArgumentCaptor<byte[]> byteArrayCaptor;
+  @Mock private FirebaseInstanceId firebaseInstanceId;
+  @Mock private MetricsLoggerClient metricsLoggerClient;
+  @Mock private EngagementMetricsLoggerInterface engagementMetricsLoggerInterface;
+  @Mock private AnalyticsConnector analyticsConnector;
+  @Mock private DeveloperListenerManager developerListenerManager;
+  private FakeClock clock;
+  private FakeAnalyticsConnector analytics;
+
+  @Before
+  public void setup() throws NameNotFoundException {
+    MockitoAnnotations.initMocks(this);
+    when(firebaseApp.getName()).thenReturn("app1");
+    when(firebaseApp.getOptions()).thenReturn(firebaseOptions);
+    when(firebaseInstanceId.getId()).thenReturn(INSTANCE_ID);
+    clock = new FakeClock(NOW);
+    analytics = new FakeAnalyticsConnector();
+    FakeAnalyticsConnector.resetState();
+    metricsLoggerClient =
+        new MetricsLoggerClient(
+            engagementMetricsLoggerInterface,
+            analyticsConnector,
+            firebaseApp,
+            firebaseInstanceId,
+            clock,
+            developerListenerManager);
+  }
+
+  @Test
+  public void logImpression_proxiesRequestToEngagementMetricsClient() {
+    metricsLoggerClient =
+        new MetricsLoggerClient(
+            engagementMetricsLoggerInterface,
+            null,
+            firebaseApp,
+            firebaseInstanceId,
+            clock,
+            developerListenerManager);
+
+    metricsLoggerClient.logImpression(BANNER_MESSAGE_MODEL);
+
+    verify(engagementMetricsLoggerInterface).logEvent(anyObject());
+  }
+
+  @Test
+  public void logImpression_alertsImpressionListeners() {
+    metricsLoggerClient =
+        new MetricsLoggerClient(
+            engagementMetricsLoggerInterface,
+            null,
+            firebaseApp,
+            firebaseInstanceId,
+            clock,
+            developerListenerManager);
+
+    metricsLoggerClient.logImpression(BANNER_MESSAGE_MODEL);
+    verify(developerListenerManager, times(1)).impressionDetected(BANNER_MESSAGE_MODEL);
+  }
+
+  @Test
+  public void logImpression_alertsImpressionListenerAndSetsConversionPropWithoutActions() {
+    metricsLoggerClient =
+        new MetricsLoggerClient(
+            engagementMetricsLoggerInterface,
+            analyticsConnector,
+            firebaseApp,
+            firebaseInstanceId,
+            clock,
+            developerListenerManager);
+
+    metricsLoggerClient.logImpression(CARD_MESSAGE_WITHOUT_ACTIONS);
+    verify(developerListenerManager, times(1)).impressionDetected(CARD_MESSAGE_WITHOUT_ACTIONS);
+    // sets conversion user prop
+    verify(analyticsConnector, times(1))
+        .setUserProperty(
+            AnalyticsConstants.ORIGIN_FIAM,
+            AnalyticsConstants.USER_PROPERTY_FIREBASE_LAST_NOTIFICATION,
+            "fiam:" + CAMPAIGN_ID_STRING);
+  }
+
+  @Test
+  public void logImpression_failsGracefullyWithNoAnalytics() {
+    metricsLoggerClient.logImpression(BANNER_MESSAGE_MODEL);
+
+    verify(engagementMetricsLoggerInterface).logEvent(anyObject());
+  }
+
+  @Test
+  public void logImpression_setsCampaignId() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logImpression(BANNER_MESSAGE_MODEL);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getCampaignId()).isEqualTo(CAMPAIGN_ID_STRING);
+  }
+
+  @Test
+  public void logImpression_setsApplicationId() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logImpression(BANNER_MESSAGE_MODEL);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getClientApp().getGoogleAppId()).isEqualTo(APPLICATION_ID);
+  }
+
+  @Test
+  public void logImpression_setsInstanceId() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logImpression(BANNER_MESSAGE_MODEL);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getClientApp().getFirebaseInstanceId()).isEqualTo(INSTANCE_ID);
+  }
+
+  @Test
+  public void logImpression_setsImpressionEventType() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logImpression(BANNER_MESSAGE_MODEL);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getEventType()).isEqualTo(IMPRESSION_EVENT_TYPE);
+  }
+
+  @Test
+  public void logImpression_setsClientTimestamp() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logImpression(BANNER_MESSAGE_MODEL);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getClientTimestampMillis()).isEqualTo(NOW);
+  }
+
+  @Test
+  public void logMessageClick_proxiesRequestToEngagementMetricsClient() {
+    metricsLoggerClient.logMessageClick(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+
+    verify(engagementMetricsLoggerInterface).logEvent(anyObject());
+  }
+
+  @Test
+  public void logMessageClick_notifiesListeners() {
+    metricsLoggerClient.logMessageClick(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+
+    verify(developerListenerManager, times(1))
+        .messageClicked(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+  }
+
+  @Test
+  public void logMessageClick_setsCampaignId() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logMessageClick(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getCampaignId()).isEqualTo(CAMPAIGN_ID_STRING);
+  }
+
+  @Test
+  public void logMessageClick_setsApplicationId() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logMessageClick(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getClientApp().getGoogleAppId()).isEqualTo(APPLICATION_ID);
+  }
+
+  @Test
+  public void logMessageClick_setsInstanceId() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logMessageClick(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getClientApp().getFirebaseInstanceId()).isEqualTo(INSTANCE_ID);
+  }
+
+  @Test
+  public void logMessageClick_setsClickEventType() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logMessageClick(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getEventType()).isEqualTo(CLICK_EVENT_TYPE);
+  }
+
+  @Test
+  public void logMessageClick_setsClientTimestamp() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logMessageClick(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getClientTimestampMillis()).isEqualTo(NOW);
+  }
+
+  @Test
+  public void logRenderError_proxiesRequestToEngagementMetricsClient() {
+    metricsLoggerClient.logRenderError(
+        BANNER_MESSAGE_MODEL, InAppMessagingErrorReason.UNSPECIFIED_RENDER_ERROR);
+
+    verify(engagementMetricsLoggerInterface).logEvent(anyObject());
+  }
+
+  @Test
+  public void logRenderError_notifiesListeners() {
+    metricsLoggerClient.logRenderError(
+        BANNER_MESSAGE_MODEL, InAppMessagingErrorReason.UNSPECIFIED_RENDER_ERROR);
+
+    verify(developerListenerManager, times(1))
+        .displayErrorEncountered(
+            BANNER_MESSAGE_MODEL, InAppMessagingErrorReason.UNSPECIFIED_RENDER_ERROR);
+  }
+
+  @Test
+  public void logRenderError_setsCampaignId() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logRenderError(
+        BANNER_MESSAGE_MODEL, InAppMessagingErrorReason.UNSPECIFIED_RENDER_ERROR);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getCampaignId()).isEqualTo(CAMPAIGN_ID_STRING);
+  }
+
+  @Test
+  public void logRenderError_setsApplicationId() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logRenderError(
+        BANNER_MESSAGE_MODEL, InAppMessagingErrorReason.UNSPECIFIED_RENDER_ERROR);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getClientApp().getGoogleAppId()).isEqualTo(APPLICATION_ID);
+  }
+
+  @Test
+  public void logRenderError_setsInstanceId() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logRenderError(
+        BANNER_MESSAGE_MODEL, InAppMessagingErrorReason.UNSPECIFIED_RENDER_ERROR);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getClientApp().getFirebaseInstanceId()).isEqualTo(INSTANCE_ID);
+  }
+
+  @Test
+  public void logRenderError_withGenericRenderErrorReason_setsEquivalentErrorReason()
+      throws InvalidProtocolBufferException {
+    metricsLoggerClient.logRenderError(
+        BANNER_MESSAGE_MODEL, InAppMessagingErrorReason.UNSPECIFIED_RENDER_ERROR);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getRenderErrorReason())
+        .isEqualTo(RenderErrorReason.UNSPECIFIED_RENDER_ERROR);
+  }
+
+  @Test
+  public void logRenderError_withImageFetchRenderError_setsEquivalentErrorReason()
+      throws InvalidProtocolBufferException {
+    metricsLoggerClient.logRenderError(
+        BANNER_MESSAGE_MODEL, InAppMessagingErrorReason.IMAGE_FETCH_ERROR);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getRenderErrorReason())
+        .isEqualTo(RenderErrorReason.IMAGE_FETCH_ERROR);
+  }
+
+  @Test
+  public void logRenderError_withImageDisplayError_setsEquivalentErrorReason()
+      throws InvalidProtocolBufferException {
+    metricsLoggerClient.logRenderError(
+        BANNER_MESSAGE_MODEL, InAppMessagingErrorReason.IMAGE_DISPLAY_ERROR);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getRenderErrorReason())
+        .isEqualTo(RenderErrorReason.IMAGE_DISPLAY_ERROR);
+  }
+
+  @Test
+  public void logRenderError_withUnsupportedFiam_setsEquivalentErrorReason()
+      throws InvalidProtocolBufferException {
+    metricsLoggerClient.logRenderError(
+        BANNER_MESSAGE_MODEL, InAppMessagingErrorReason.IMAGE_UNSUPPORTED_FORMAT);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getRenderErrorReason())
+        .isEqualTo(RenderErrorReason.IMAGE_UNSUPPORTED_FORMAT);
+  }
+
+  @Test
+  public void logRenderError_setsClientTimestamp() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logRenderError(
+        BANNER_MESSAGE_MODEL, InAppMessagingErrorReason.UNSPECIFIED_RENDER_ERROR);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getClientTimestampMillis()).isEqualTo(NOW);
+  }
+
+  @Test
+  public void logDismiss_proxiesRequestToEngagementMetricsClient() {
+    metricsLoggerClient.logDismiss(
+        BANNER_MESSAGE_MODEL, InAppMessagingDismissType.UNKNOWN_DISMISS_TYPE);
+
+    verify(engagementMetricsLoggerInterface).logEvent(anyObject());
+  }
+
+  @Test
+  public void logDismiss_setsCampaignId() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logDismiss(
+        BANNER_MESSAGE_MODEL, InAppMessagingDismissType.UNKNOWN_DISMISS_TYPE);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getCampaignId()).isEqualTo(CAMPAIGN_ID_STRING);
+  }
+
+  @Test
+  public void logDismiss_setsApplicationId() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logDismiss(
+        BANNER_MESSAGE_MODEL, InAppMessagingDismissType.UNKNOWN_DISMISS_TYPE);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getClientApp().getGoogleAppId()).isEqualTo(APPLICATION_ID);
+  }
+
+  @Test
+  public void logDismiss_setsInstanceId() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logDismiss(
+        BANNER_MESSAGE_MODEL, InAppMessagingDismissType.UNKNOWN_DISMISS_TYPE);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getClientApp().getFirebaseInstanceId()).isEqualTo(INSTANCE_ID);
+  }
+
+  @Test
+  public void logDismiss_withUnknownDismissType_setsEquivalentDismissType()
+      throws InvalidProtocolBufferException {
+    metricsLoggerClient.logDismiss(
+        BANNER_MESSAGE_MODEL, InAppMessagingDismissType.UNKNOWN_DISMISS_TYPE);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getDismissType()).isEqualTo(DismissType.UNKNOWN_DISMISS_TYPE);
+  }
+
+  @Test
+  public void logDismiss_withAutoDismissType_setsEquivalentDismissType()
+      throws InvalidProtocolBufferException {
+    metricsLoggerClient.logDismiss(BANNER_MESSAGE_MODEL, InAppMessagingDismissType.AUTO);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getDismissType()).isEqualTo(DismissType.AUTO);
+  }
+
+  @Test
+  public void logDismiss_withClickDismissType_setsEquivalentDismissType()
+      throws InvalidProtocolBufferException {
+    metricsLoggerClient.logDismiss(BANNER_MESSAGE_MODEL, InAppMessagingDismissType.CLICK);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getDismissType()).isEqualTo(DismissType.CLICK);
+  }
+
+  @Test
+  public void logDismiss_withSwipeDismissType_setsEquivalentDismissType()
+      throws InvalidProtocolBufferException {
+    metricsLoggerClient.logDismiss(BANNER_MESSAGE_MODEL, InAppMessagingDismissType.SWIPE);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getDismissType()).isEqualTo(DismissType.SWIPE);
+  }
+
+  @Test
+  public void logDismiss_setsClientTimestamp() throws InvalidProtocolBufferException {
+    metricsLoggerClient.logDismiss(
+        BANNER_MESSAGE_MODEL, InAppMessagingDismissType.UNKNOWN_DISMISS_TYPE);
+
+    verify(engagementMetricsLoggerInterface).logEvent(byteArrayCaptor.capture());
+
+    CampaignAnalytics campaignAnalytics =
+        CampaignAnalytics.parser().parseFrom(byteArrayCaptor.getValue());
+    assertThat(campaignAnalytics.getClientTimestampMillis()).isEqualTo(NOW);
+  }
+
+  @Test
+  public void logImpression_sendsCorrectScionEventWithParams()
+      throws InvalidProtocolBufferException {
+    FakeAnalyticsConnector analytics = new FakeAnalyticsConnector();
+    metricsLoggerClient =
+        new MetricsLoggerClient(
+            engagementMetricsLoggerInterface,
+            analytics,
+            firebaseApp,
+            firebaseInstanceId,
+            clock,
+            developerListenerManager);
+
+    metricsLoggerClient.logImpression(BANNER_MESSAGE_MODEL);
+    LoggedEvent actual = analytics.getLoggedEvent().get(0);
+
+    assertThat(actual.origin).isEqualTo(AnalyticsConstants.ORIGIN_FIAM);
+    assertThat(actual.name).isEqualTo(AnalyticsConstants.ANALYTICS_IMPRESSION_EVENT);
+    Bundle actualParams = actual.params;
+    assertThat(actualParams.getString(AnalyticsConstants.PARAM_MESSAGE_ID))
+        .isEqualTo(CAMPAIGN_ID_STRING);
+    assertThat(actualParams.getString(AnalyticsConstants.PARAM_MESSAGE_NAME))
+        .isEqualTo(CAMPAIGN_NAME_STRING);
+
+    int epochSeconds = (int) (NOW / 1000);
+    assertThat(actualParams.getInt(AnalyticsConstants.PARAM_MESSAGE_DEVICE_TIME))
+        .isEqualTo(epochSeconds);
+  }
+
+  @Test
+  public void logClick_sendsCorrectScionEventName() throws InvalidProtocolBufferException {
+    metricsLoggerClient =
+        new MetricsLoggerClient(
+            engagementMetricsLoggerInterface,
+            analytics,
+            firebaseApp,
+            firebaseInstanceId,
+            clock,
+            developerListenerManager);
+
+    metricsLoggerClient.logMessageClick(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+
+    assertThat(analytics.getLoggedEvent().size()).isEqualTo(1);
+    LoggedEvent actual = analytics.getLoggedEvent().get(0);
+
+    assertThat(actual.origin).isEqualTo(AnalyticsConstants.ORIGIN_FIAM);
+    assertThat(actual.name).isEqualTo(AnalyticsConstants.ANALYTICS_ACTION_EVENT);
+  }
+
+  @Test
+  public void logDismisssendsCorrectScionEventName() throws InvalidProtocolBufferException {
+    metricsLoggerClient =
+        new MetricsLoggerClient(
+            engagementMetricsLoggerInterface,
+            analytics,
+            firebaseApp,
+            firebaseInstanceId,
+            clock,
+            developerListenerManager);
+
+    metricsLoggerClient.logMessageClick(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+
+    assertThat(analytics.getLoggedEvent().size()).isEqualTo(1);
+    LoggedEvent actual = analytics.getLoggedEvent().get(0);
+
+    assertThat(actual.origin).isEqualTo(AnalyticsConstants.ORIGIN_FIAM);
+    assertThat(actual.name).isEqualTo(AnalyticsConstants.ANALYTICS_ACTION_EVENT);
+  }
+
+  @Test
+  public void logEvent_sendsEventParams() throws InvalidProtocolBufferException {
+    metricsLoggerClient =
+        new MetricsLoggerClient(
+            engagementMetricsLoggerInterface,
+            analytics,
+            firebaseApp,
+            firebaseInstanceId,
+            clock,
+            developerListenerManager);
+
+    metricsLoggerClient.logImpression(BANNER_MESSAGE_MODEL);
+
+    assertThat(analytics.getLoggedEvent().size()).isEqualTo(1);
+    LoggedEvent actual = analytics.getLoggedEvent().get(0);
+
+    assertThat(actual.origin).isEqualTo(AnalyticsConstants.ORIGIN_FIAM);
+    assertThat(actual.name).isEqualTo(AnalyticsConstants.ANALYTICS_IMPRESSION_EVENT);
+    Bundle actualParams = actual.params;
+    assertThat(actualParams.getString(AnalyticsConstants.PARAM_MESSAGE_ID))
+        .isEqualTo(CAMPAIGN_ID_STRING);
+    assertThat(actualParams.getString(AnalyticsConstants.PARAM_MESSAGE_NAME))
+        .isEqualTo(CAMPAIGN_NAME_STRING);
+
+    int epochSeconds = (int) (NOW / 1000);
+    assertThat(actualParams.getInt(AnalyticsConstants.PARAM_MESSAGE_DEVICE_TIME))
+        .isEqualTo(epochSeconds);
+  }
+
+  @Test
+  public void logEvent_addsConversionTrackingOnAction() throws InvalidProtocolBufferException {
+    metricsLoggerClient =
+        new MetricsLoggerClient(
+            engagementMetricsLoggerInterface,
+            analytics,
+            firebaseApp,
+            firebaseInstanceId,
+            clock,
+            developerListenerManager);
+
+    metricsLoggerClient.logImpression(BANNER_MESSAGE_MODEL);
+    metricsLoggerClient.logDismiss(
+        BANNER_MESSAGE_MODEL, InAppMessagingDismissType.UNKNOWN_DISMISS_TYPE);
+
+    assertThat(analytics.getSetUserProperty().size()).isEqualTo(0);
+
+    metricsLoggerClient.logMessageClick(BANNER_MESSAGE_MODEL, BANNER_MESSAGE_MODEL.getAction());
+
+    assertThat(analytics.getSetUserProperty().size()).isEqualTo(1);
+    LoggedUserProperty actual = analytics.getSetUserProperty().get(0);
+
+    assertThat(actual.origin).isEqualTo(AnalyticsConstants.ORIGIN_FIAM);
+    assertThat(actual.name).isEqualTo(AnalyticsConstants.USER_PROPERTY_FIREBASE_LAST_NOTIFICATION);
+    assertThat(actual.value).isEqualTo("fiam:" + CAMPAIGN_ID_STRING);
+  }
+
+  @Test
+  public void logEvent_addsConversionTrackingOnClickWhenNoAction()
+      throws InvalidProtocolBufferException {
+    metricsLoggerClient =
+        new MetricsLoggerClient(
+            engagementMetricsLoggerInterface,
+            analytics,
+            firebaseApp,
+            firebaseInstanceId,
+            clock,
+            developerListenerManager);
+
+    metricsLoggerClient.logDismiss(
+        BANNER_MESSAGE_NO_ACTION_MODEL, InAppMessagingDismissType.UNKNOWN_DISMISS_TYPE);
+
+    assertThat(analytics.getSetUserProperty().size()).isEqualTo(0);
+
+    metricsLoggerClient.logImpression(BANNER_MESSAGE_NO_ACTION_MODEL);
+
+    assertThat(analytics.getSetUserProperty().size()).isEqualTo(1);
+    LoggedUserProperty actual = analytics.getSetUserProperty().get(0);
+
+    assertThat(actual.origin).isEqualTo(AnalyticsConstants.ORIGIN_FIAM);
+    assertThat(actual.name).isEqualTo(AnalyticsConstants.USER_PROPERTY_FIREBASE_LAST_NOTIFICATION);
+    assertThat(actual.value).isEqualTo("fiam:" + CAMPAIGN_ID_STRING);
+  }
+
+  @Test
+  public void metricsLoggerClient_doesNotLogTestCampaigns() {
+    metricsLoggerClient.logImpression(BANNER_TEST_MESSAGE_MODEL);
+    metricsLoggerClient.logMessageClick(
+        BANNER_TEST_MESSAGE_MODEL, BANNER_TEST_MESSAGE_MODEL.getAction());
+    metricsLoggerClient.logDismiss(
+        BANNER_TEST_MESSAGE_MODEL, InAppMessagingDismissType.UNKNOWN_DISMISS_TYPE);
+    metricsLoggerClient.logRenderError(
+        BANNER_TEST_MESSAGE_MODEL, InAppMessagingErrorReason.UNSPECIFIED_RENDER_ERROR);
+
+    verify(engagementMetricsLoggerInterface, never()).logEvent(anyObject());
+  }
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/ProtoStorageClientTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/ProtoStorageClientTest.java
new file mode 100644
index 000000000..3b459a7c3
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/ProtoStorageClientTest.java
@@ -0,0 +1,176 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.app.Application;
+import android.content.Context;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsResponse;
+import com.google.protobuf.InvalidProtocolBufferException;
+import com.google.protobuf.Parser;
+import io.reactivex.observers.TestObserver;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ProtoStorageClientTest {
+  private static final String FILE_NAME = "file";
+  private final FetchEligibleCampaignsResponse response =
+      FetchEligibleCampaignsResponse.getDefaultInstance();
+  private ProtoStorageClient protoStorageClient;
+  @Mock private Application application;
+  @Mock private FileOutputStream fileOutputStream;
+  @Mock private FileInputStream fileInputStream;
+  @Mock private Parser<FetchEligibleCampaignsResponse> parser;
+
+  @Before
+  public void setup() throws IOException {
+    initMocks(this);
+    protoStorageClient = new ProtoStorageClient(application, FILE_NAME);
+    when(application.openFileOutput(FILE_NAME, Context.MODE_PRIVATE)).thenReturn(fileOutputStream);
+    when(application.openFileInput(FILE_NAME)).thenReturn(fileInputStream);
+    when(parser.parseFrom(fileInputStream)).thenReturn(response);
+  }
+
+  @Test
+  public void write_noFailure_writesBytes() throws IOException {
+    protoStorageClient.write(response).subscribe();
+
+    verify(fileOutputStream).write(response.toByteArray());
+  }
+
+  @Test
+  public void write_noFailure_completes() {
+    TestObserver<Void> subscriber = protoStorageClient.write(response).test();
+
+    subscriber.assertComplete();
+  }
+
+  @Test
+  public void write_onFailure_notfiedError() throws IOException {
+    when(application.openFileOutput(FILE_NAME, Context.MODE_PRIVATE))
+        .thenThrow(new FileNotFoundException());
+
+    TestObserver<Void> subscriber = protoStorageClient.write(response).test();
+
+    subscriber.assertError(FileNotFoundException.class);
+  }
+
+  @Test
+  public void write_noFailure_closesStream() throws IOException {
+    protoStorageClient.write(response).subscribe();
+
+    verify(fileOutputStream).close();
+  }
+
+  @Test
+  public void write_withFailureOpeningFile_doesNotCloseStream() throws IOException {
+    when(application.openFileOutput(FILE_NAME, Context.MODE_PRIVATE))
+        .thenThrow(new FileNotFoundException());
+
+    protoStorageClient.write(response).subscribe();
+
+    verify(fileOutputStream, times(0)).close();
+  }
+
+  @Test
+  public void write_withFailureWriting_closesStream() throws IOException {
+    doThrow(new IOException()).when(fileOutputStream).write(response.toByteArray());
+
+    protoStorageClient.write(response).subscribe();
+
+    verify(fileOutputStream).close();
+  }
+
+  @Test
+  public void read_noFailure_readsBytes() {
+    TestObserver<FetchEligibleCampaignsResponse> subscriber =
+        protoStorageClient.read(parser).test();
+
+    assertThat(subscriber.getEvents().get(0)).containsExactly(response);
+  }
+
+  @Test
+  public void read_onFailure_propagatesException() throws IOException {
+    when(application.openFileInput(FILE_NAME)).thenThrow(new NullPointerException());
+
+    TestObserver<FetchEligibleCampaignsResponse> subscriber =
+        protoStorageClient.read(parser).test();
+
+    subscriber.assertError(NullPointerException.class);
+  }
+
+  @Test
+  public void read_onFileNotFound_absorbsError() throws IOException {
+    when(application.openFileInput(FILE_NAME)).thenThrow(new FileNotFoundException());
+
+    TestObserver<FetchEligibleCampaignsResponse> subscriber =
+        protoStorageClient.read(parser).test();
+
+    subscriber.assertNoErrors();
+    subscriber.assertNoValues();
+  }
+
+  @Test
+  public void read_onParsingException_absorbsError() throws IOException {
+    when(parser.parseFrom(fileInputStream)).thenThrow(new InvalidProtocolBufferException(""));
+
+    TestObserver<FetchEligibleCampaignsResponse> subscriber =
+        protoStorageClient.read(parser).test();
+
+    subscriber.assertNoErrors();
+    subscriber.assertNoValues();
+  }
+
+  @Test
+  public void read_noFailure_closesStream() throws IOException {
+    protoStorageClient.read(parser).subscribe();
+
+    verify(fileInputStream).close();
+  }
+
+  @Test
+  public void read_withFailureOpeningFile_doesNotCloseStream() throws IOException {
+    when(application.openFileInput(FILE_NAME)).thenThrow(new FileNotFoundException());
+
+    protoStorageClient.read(parser).subscribe();
+
+    verify(fileInputStream, times(0)).close();
+  }
+
+  @Test
+  public void read_withFailureReading_closesStream() throws IOException {
+    doThrow(new InvalidProtocolBufferException("")).when(parser).parseFrom(fileInputStream);
+
+    protoStorageClient.read(parser).subscribe();
+
+    verify(fileInputStream).close();
+  }
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/RateLimiterClientTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/RateLimiterClientTest.java
new file mode 100644
index 000000000..454dd0c84
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/RateLimiterClientTest.java
@@ -0,0 +1,267 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import com.google.firebase.inappmessaging.internal.RateLimitProto.Counter;
+import com.google.firebase.inappmessaging.internal.time.FakeClock;
+import com.google.firebase.inappmessaging.model.RateLimit;
+import com.google.protobuf.Parser;
+import io.reactivex.Completable;
+import io.reactivex.Maybe;
+import io.reactivex.observers.TestObserver;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class RateLimiterClientTest {
+  private static final long PAST = 10;
+  private static final long NOW = 100;
+  private static final long LIMIT_TWO = 2L;
+  private static final String LIMITER_KEY = "LIMITER_KEY";
+  private static final long TTL = 100000;
+  private static final Counter counter =
+      Counter.newBuilder().setValue(1).setStartTimeEpoch(PAST).build();
+
+  private static final RateLimit rateLimit =
+      RateLimit.builder()
+          .setLimit(LIMIT_TWO)
+          .setLimiterKey(LIMITER_KEY)
+          .setTimeToLiveMillis(TTL)
+          .build();
+
+  private static Map<String, Counter> limitsMap;
+  private static RateLimitProto.RateLimit storedRateLimit;
+
+  private RateLimiterClient rateLimiterClient;
+  private Completable fakeWrite;
+  private boolean wasWritten;
+  private Maybe<RateLimitProto.RateLimit> fakeRead;
+
+  @Mock private ProtoStorageClient storageClient;
+
+  @Before
+  public void setup() throws IOException {
+    initMocks(this);
+
+    limitsMap = new HashMap<>();
+    limitsMap.put(LIMITER_KEY, counter);
+    storedRateLimit = RateLimitProto.RateLimit.newBuilder().putAllLimits(limitsMap).build();
+
+    fakeRead = Maybe.fromCallable(() -> storedRateLimit);
+    fakeWrite =
+        Completable.fromCallable(
+            () -> {
+              wasWritten = true;
+              return null;
+            });
+
+    rateLimiterClient = new RateLimiterClient(storageClient, new FakeClock(NOW));
+
+    when(storageClient.read(any(RateLimitParser.class))).thenReturn(fakeRead);
+    when(storageClient.write(any(RateLimitProto.RateLimit.class))).thenReturn(fakeWrite);
+  }
+
+  @Test
+  public void increment_noErrors_writesToStorage() {
+    rateLimiterClient.increment(rateLimit).subscribe();
+
+    assertThat(wasWritten).isTrue();
+  }
+
+  @Test
+  public void increment_noExistingCounter_writesToStorage() {
+    when(storageClient.read(any(RateLimitParser.class))).thenReturn(Maybe.empty());
+
+    rateLimiterClient.increment(rateLimit).subscribe();
+
+    assertThat(wasWritten).isTrue();
+  }
+
+  @Test
+  public void increment_noErrors_incrementsCounter() {
+    ArgumentCaptor<RateLimitProto.RateLimit> rateLimitCaptor =
+        ArgumentCaptor.forClass(RateLimitProto.RateLimit.class);
+
+    rateLimiterClient.increment(rateLimit).subscribe();
+    verify(storageClient).write(rateLimitCaptor.capture());
+
+    assertThat(rateLimitCaptor.getValue().getLimitsOrThrow(LIMITER_KEY).getValue()).isEqualTo(2);
+  }
+
+  @Test
+  public void increment_noExistingLimits_initializesLimits() {
+    when(storageClient.read(any(RateLimitParser.class))).thenReturn(Maybe.empty());
+    ArgumentCaptor<RateLimitProto.RateLimit> rateLimitCaptor =
+        ArgumentCaptor.forClass(RateLimitProto.RateLimit.class);
+
+    rateLimiterClient.increment(rateLimit).subscribe();
+    verify(storageClient).write(rateLimitCaptor.capture());
+
+    assertThat(rateLimitCaptor.getValue().getLimitsOrThrow(LIMITER_KEY).getValue()).isEqualTo(1);
+  }
+
+  @Test
+  public void increment_expiredLimit_resetsLimit() {
+    RateLimit noTTLLimit =
+        RateLimit.builder()
+            .setLimit(LIMIT_TWO)
+            .setLimiterKey(LIMITER_KEY)
+            .setTimeToLiveMillis(1000L)
+            .build();
+    ArgumentCaptor<RateLimitProto.RateLimit> rateLimitCaptor =
+        ArgumentCaptor.forClass(RateLimitProto.RateLimit.class);
+    rateLimiterClient = new RateLimiterClient(storageClient, new FakeClock(NOW + 1001));
+
+    rateLimiterClient.increment(noTTLLimit).subscribe();
+    verify(storageClient).write(rateLimitCaptor.capture());
+
+    assertThat(rateLimitCaptor.getValue().getLimitsOrThrow(LIMITER_KEY).getValue()).isEqualTo(1);
+    assertThat(rateLimitCaptor.getValue().getLimitsOrThrow(LIMITER_KEY).getStartTimeEpoch())
+        .isEqualTo(NOW + 1001);
+  }
+
+  @Test
+  public void increment_noCounterForLimit_initializesCounter() {
+    RateLimit otherLimit =
+        RateLimit.builder()
+            .setLimit(LIMIT_TWO)
+            .setLimiterKey("OTHER_KEY")
+            .setTimeToLiveMillis(TTL)
+            .build();
+    ArgumentCaptor<RateLimitProto.RateLimit> rateLimitCaptor =
+        ArgumentCaptor.forClass(RateLimitProto.RateLimit.class);
+
+    rateLimiterClient.increment(otherLimit).subscribe();
+    verify(storageClient).write(rateLimitCaptor.capture());
+
+    assertThat(rateLimitCaptor.getValue().getLimitsOrThrow(LIMITER_KEY).getValue()).isEqualTo(1);
+    assertThat(rateLimitCaptor.getValue().getLimitsOrThrow("OTHER_KEY").getValue()).isEqualTo(1);
+  }
+
+  @Test
+  public void increment_noErrors_cachesInMemory() {
+    rateLimiterClient.increment(rateLimit).subscribe();
+    when(storageClient.read(any(RateLimitParser.class))).thenReturn(Maybe.empty());
+
+    TestObserver<Boolean> testObserver = rateLimiterClient.isRateLimited(rateLimit).test();
+
+    assertThat(testObserver.getEvents().get(0)).containsExactly(true);
+  }
+
+  @Test
+  public void increment_writeErrors_doesNotSetInMemoryCache() {
+    RateLimit otherLimit =
+        RateLimit.builder().setLimit(2).setLimiterKey("OTHER_KEY").setTimeToLiveMillis(TTL).build();
+    when(storageClient.write(any(RateLimitProto.RateLimit.class)))
+        .thenReturn(Completable.error(new IOException()));
+    when(storageClient.read(any(RateLimitParser.class))).thenReturn(Maybe.empty());
+    rateLimiterClient.increment(otherLimit).subscribe();
+    rateLimiterClient.increment(otherLimit).subscribe();
+    rateLimiterClient.increment(otherLimit).subscribe();
+
+    TestObserver<Boolean> testObserver = rateLimiterClient.isRateLimited(otherLimit).test();
+
+    assertThat(testObserver.getEvents().get(0)).containsExactly(false);
+  }
+
+  @Test
+  public void increment_writeErrors_notifiesError() {
+    when(storageClient.write(any(RateLimitProto.RateLimit.class)))
+        .thenReturn(Completable.error(new IOException()));
+
+    TestObserver<Void> testObserver = rateLimiterClient.increment(rateLimit).test();
+
+    testObserver.assertError(IOException.class);
+  }
+
+  @Test
+  public void increment_readErrors_notifiesError() {
+    when(storageClient.read(any(RateLimitParser.class))).thenReturn(Maybe.error(new IOException()));
+
+    TestObserver<Boolean> testObserver = rateLimiterClient.isRateLimited(rateLimit).test();
+
+    testObserver.assertError(IOException.class);
+  }
+
+  @Test
+  public void isRateLimited_ifRateLimited_isTrue() {
+    rateLimiterClient.increment(rateLimit).subscribe();
+
+    TestObserver<Boolean> testObserver = rateLimiterClient.isRateLimited(rateLimit).test();
+
+    assertThat(testObserver.getEvents().get(0)).containsExactly(true);
+  }
+
+  @Test
+  public void isRateLimited_ifNotRateLimited_isFalse() {
+    rateLimiterClient.increment(rateLimit).subscribe();
+
+    TestObserver<Boolean> testObserver = rateLimiterClient.isRateLimited(rateLimit).test();
+
+    assertThat(testObserver.getEvents().get(0)).containsExactly(true);
+  }
+
+  @Test
+  public void isRateLimited_ifExpired_isFalse() {
+    RateLimit noTTLLimit =
+        RateLimit.builder()
+            .setLimit(LIMIT_TWO)
+            .setLimiterKey(LIMITER_KEY)
+            .setTimeToLiveMillis(0L)
+            .build();
+
+    // check with no ttl limit
+    TestObserver<Boolean> testObserver = rateLimiterClient.isRateLimited(noTTLLimit).test();
+
+    assertThat(testObserver.getEvents().get(0)).containsExactly(false);
+  }
+
+  @Test
+  public void isRateLimited_ifNoLimits_isFalse() {
+    when(storageClient.read(any(RateLimitParser.class))).thenReturn(Maybe.empty());
+    RateLimit oneLimit =
+        RateLimit.builder().setLimit(1).setLimiterKey(LIMITER_KEY).setTimeToLiveMillis(TTL).build();
+
+    TestObserver<Boolean> testObserver = rateLimiterClient.isRateLimited(oneLimit).test();
+
+    assertThat(testObserver.getEvents().get(0)).containsExactly(false);
+  }
+
+  @Test
+  public void isRateLimited_readError_notifiesError() {
+    when(storageClient.read(any(RateLimitParser.class))).thenReturn(Maybe.error(new IOException()));
+
+    TestObserver<Boolean> testObserver = rateLimiterClient.isRateLimited(rateLimit).test();
+
+    testObserver.assertError(IOException.class);
+  }
+
+  interface RateLimitParser extends Parser<RateLimitProto.RateLimit> {}
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/SharedPreferencesUtilsTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/SharedPreferencesUtilsTest.java
new file mode 100644
index 000000000..73d8ee6cf
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/SharedPreferencesUtilsTest.java
@@ -0,0 +1,165 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.Application;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import com.google.firebase.FirebaseApp;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class SharedPreferencesUtilsTest {
+
+  private final String packageName = "package.name";
+  private final String TEST_PREFERENCE = "TEST_PREF";
+  private final String TEST_MANIFEST_PREFERENCE = "TEST_MANIFEST_PREF";
+
+  @Mock private SharedPreferences sharedPreferences;
+  @Mock private Application application;
+  @Mock private FirebaseApp firebaseApp;
+  @Mock private PackageManager packageManager;
+  @Mock private SharedPreferences.Editor editor;
+
+  private SharedPreferencesUtils sharedPreferencesUtils;
+
+  // This is needed to avoid the 'Stub!' runtime exception that happens when you try to instantiate
+  // a new Bundle, because roboelectric tests run with mocks
+  private static Bundle createNewBundle() {
+    return new Bundle();
+  }
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    when(firebaseApp.getApplicationContext()).thenReturn(application);
+    when(application.getPackageName()).thenReturn(packageName);
+    when(application.getSharedPreferences(
+            SharedPreferencesUtils.PREFERENCES_PACKAGE_NAME, Context.MODE_PRIVATE))
+        .thenReturn(sharedPreferences);
+    when(application.getPackageManager()).thenReturn(packageManager);
+    when(sharedPreferences.edit()).thenReturn(editor);
+
+    sharedPreferencesUtils = new SharedPreferencesUtils(firebaseApp);
+  }
+
+  @Test
+  public void getAndSetBooleanPreference_correctlySetsPreference() throws Exception {
+    sharedPreferencesUtils.getAndSetBooleanPreference(TEST_PREFERENCE, false);
+    verify(editor).putBoolean(TEST_PREFERENCE, false);
+    verify(editor).apply();
+  }
+
+  @Test
+  public void setBooleanPreference_correctlySetsPreference() throws Exception {
+    sharedPreferencesUtils.setBooleanPreference(TEST_PREFERENCE, false);
+    verify(editor).putBoolean(TEST_PREFERENCE, false);
+    verify(editor).apply();
+  }
+
+  @Test
+  public void getAndSetBooleanPreference_correctlyGetsPreference() throws Exception {
+    when(sharedPreferences.contains(TEST_PREFERENCE)).thenReturn(true);
+    when(sharedPreferences.getBoolean(TEST_PREFERENCE, true)).thenReturn(false);
+
+    // Here we default to true but we know that the mock will return false.
+    assertThat(sharedPreferencesUtils.getAndSetBooleanPreference(TEST_PREFERENCE, true)).isFalse();
+
+    verify(sharedPreferences).contains(TEST_PREFERENCE);
+    verify(sharedPreferences).getBoolean(TEST_PREFERENCE, true);
+  }
+
+  @Test
+  public void getAndSetBooleanPreference_correctlyGetsPreferenceFromDefault() throws Exception {
+    when(sharedPreferences.contains(TEST_PREFERENCE)).thenReturn(false);
+
+    // Here we expect the default to be returned.
+    assertThat(sharedPreferencesUtils.getAndSetBooleanPreference(TEST_PREFERENCE, true)).isTrue();
+
+    verify(sharedPreferences).contains(TEST_PREFERENCE);
+    verify(editor).putBoolean(TEST_PREFERENCE, true);
+    verify(editor).apply();
+  }
+
+  @Test
+  public void getAndSetBooleanPreference_correctlyUsesDefaultWhenAllElseFails() throws Exception {
+    Bundle metaData = createNewBundle();
+    ApplicationInfo appInfo = new ApplicationInfo();
+    appInfo.metaData = metaData;
+
+    when(packageManager.getApplicationInfo(packageName, PackageManager.GET_META_DATA))
+        .thenReturn(appInfo);
+    when(sharedPreferences.contains(any())).thenReturn(false);
+
+    assertThat(sharedPreferencesUtils.getAndSetBooleanPreference(TEST_PREFERENCE, false)).isFalse();
+
+    verify(editor).putBoolean(TEST_PREFERENCE, false);
+    verify(editor).apply();
+  }
+
+  @Test
+  public void getBooleanPreference_correctlyGetsPreference() throws Exception {
+    when(sharedPreferences.contains(TEST_PREFERENCE)).thenReturn(true);
+    when(sharedPreferences.getBoolean(TEST_PREFERENCE, true)).thenReturn(false);
+
+    // Here we default to true but we know that the mock will return false.
+    assertThat(sharedPreferencesUtils.getAndSetBooleanPreference(TEST_PREFERENCE, true)).isFalse();
+
+    verify(sharedPreferences).contains(TEST_PREFERENCE);
+    verify(sharedPreferences).getBoolean(TEST_PREFERENCE, true);
+  }
+
+  @Test
+  public void getBooleanPreference_correctlyGetsPreferenceFromDefault() throws Exception {
+    when(sharedPreferences.contains(TEST_PREFERENCE)).thenReturn(false);
+
+    // Here we expect the default to be returned.
+    assertThat(sharedPreferencesUtils.getAndSetBooleanPreference(TEST_PREFERENCE, true)).isTrue();
+    // Shouldnt have motif
+
+    verify(sharedPreferences).contains(TEST_PREFERENCE);
+  }
+
+  @Test
+  public void getBooleanPreference_correctlyUsesDefaultWhenAllElseFails() throws Exception {
+    Bundle metaData = createNewBundle();
+    ApplicationInfo appInfo = new ApplicationInfo();
+    appInfo.metaData = metaData;
+
+    when(packageManager.getApplicationInfo(packageName, PackageManager.GET_META_DATA))
+        .thenReturn(appInfo);
+    when(sharedPreferences.contains(any())).thenReturn(false);
+
+    assertThat(sharedPreferencesUtils.getAndSetBooleanPreference(TEST_PREFERENCE, false)).isFalse();
+
+    verify(editor).putBoolean(TEST_PREFERENCE, false);
+    verify(editor).apply();
+  }
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/TestDeviceHelperTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/TestDeviceHelperTest.java
new file mode 100644
index 000000000..f1c3311e6
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/internal/TestDeviceHelperTest.java
@@ -0,0 +1,107 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.google.firebase.inappmessaging.MessagesProto;
+import com.google.internal.firebase.inappmessaging.v1.CampaignProto;
+import com.google.internal.firebase.inappmessaging.v1.sdkserving.FetchEligibleCampaignsResponse;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class TestDeviceHelperTest {
+
+  private static final CampaignProto.ThickContent.Builder thickContentBuilder =
+      CampaignProto.ThickContent.newBuilder()
+          .setContent(MessagesProto.Content.getDefaultInstance());
+  private static final CampaignProto.ThickContent thickContent = thickContentBuilder.build();
+  private static final FetchEligibleCampaignsResponse.Builder campaignsResponseBuilder =
+      FetchEligibleCampaignsResponse.newBuilder();
+  private static final FetchEligibleCampaignsResponse campaignsResponse =
+      campaignsResponseBuilder.build();
+
+  @Mock private SharedPreferencesUtils sharedPreferencesUtils;
+  private TestDeviceHelper testDeviceHelper;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    testDeviceHelper = new TestDeviceHelper(sharedPreferencesUtils);
+  }
+
+  @Test
+  public void instantiation_attemptsToGetCorrectPreferencesWithDefaults() throws Exception {
+    verify(sharedPreferencesUtils)
+        .getAndSetBooleanPreference(TestDeviceHelper.TEST_DEVICE_PREFERENCES, false);
+    verify(sharedPreferencesUtils)
+        .getAndSetBooleanPreference(TestDeviceHelper.FRESH_INSTALL_PREFERENCES, true);
+  }
+
+  @Test
+  public void processCampaignFetch_properlyHandlesFreshnessState() throws Exception {
+    when(sharedPreferencesUtils.getAndSetBooleanPreference(
+            TestDeviceHelper.FRESH_INSTALL_PREFERENCES, true))
+        .thenReturn(true);
+    testDeviceHelper = new TestDeviceHelper(sharedPreferencesUtils);
+
+    CampaignProto.ThickContent randomContent =
+        CampaignProto.ThickContent.newBuilder(thickContent).build();
+    FetchEligibleCampaignsResponse response =
+        FetchEligibleCampaignsResponse.newBuilder(campaignsResponse)
+            .addMessages(randomContent)
+            .build();
+
+    assertThat(testDeviceHelper.isAppInstallFresh()).isTrue();
+    for (int i = 0; i < TestDeviceHelper.MAX_FETCH_COUNT - 1; i++) {
+      testDeviceHelper.processCampaignFetch(response);
+    }
+    assertThat(testDeviceHelper.isAppInstallFresh()).isTrue();
+    testDeviceHelper.processCampaignFetch(response);
+    assertThat(testDeviceHelper.isAppInstallFresh()).isFalse();
+    verify(sharedPreferencesUtils)
+        .setBooleanPreference(TestDeviceHelper.FRESH_INSTALL_PREFERENCES, false);
+  }
+
+  @Test
+  public void processCampaignFetch_properlyHandlesTestDeviceState() throws Exception {
+    when(sharedPreferencesUtils.getAndSetBooleanPreference(
+            TestDeviceHelper.TEST_DEVICE_PREFERENCES, false))
+        .thenReturn(false);
+    testDeviceHelper = new TestDeviceHelper(sharedPreferencesUtils);
+
+    CampaignProto.ThickContent testContent =
+        CampaignProto.ThickContent.newBuilder(thickContent).setIsTestCampaign(true).build();
+    FetchEligibleCampaignsResponse response =
+        FetchEligibleCampaignsResponse.newBuilder(campaignsResponse)
+            .addMessages(testContent)
+            .build();
+
+    assertThat(testDeviceHelper.isDeviceInTestMode()).isFalse();
+    testDeviceHelper.processCampaignFetch(response);
+    assertThat(testDeviceHelper.isDeviceInTestMode()).isTrue();
+    verify(sharedPreferencesUtils)
+        .setBooleanPreference(TestDeviceHelper.TEST_DEVICE_PREFERENCES, true);
+  }
+}
diff --git a/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/model/ProtoMarshallerClientTest.java b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/model/ProtoMarshallerClientTest.java
new file mode 100644
index 000000000..31451d6fc
--- /dev/null
+++ b/firebase-inappmessaging/src/test/java/com/google/firebase/inappmessaging/model/ProtoMarshallerClientTest.java
@@ -0,0 +1,391 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.model;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.firebase.inappmessaging.testutil.Assert.expectThrows;
+import static com.google.firebase.inappmessaging.testutil.TestData.ACTION_MODEL_WITHOUT_URL;
+import static com.google.firebase.inappmessaging.testutil.TestData.BANNER_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.CAMPAIGN_ID_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.CAMPAIGN_METADATA_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.CAMPAIGN_NAME_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.CARD_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.IMAGE_DATA;
+import static com.google.firebase.inappmessaging.testutil.TestData.IMAGE_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.IMAGE_URL_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.IS_NOT_TEST_MESSAGE;
+import static com.google.firebase.inappmessaging.testutil.TestData.MESSAGE_BACKGROUND_HEX_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.MODAL_MESSAGE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestData.TITLE_MODEL;
+import static com.google.firebase.inappmessaging.testutil.TestProtos.ACTION_PROTO;
+import static com.google.firebase.inappmessaging.testutil.TestProtos.BANNER_MESSAGE_PROTO;
+import static com.google.firebase.inappmessaging.testutil.TestProtos.BODY_PROTO;
+import static com.google.firebase.inappmessaging.testutil.TestProtos.BUTTON_PROTO;
+import static com.google.firebase.inappmessaging.testutil.TestProtos.CARD_MESSAGE_PROTO;
+import static com.google.firebase.inappmessaging.testutil.TestProtos.IMAGE_MESSAGE_PROTO;
+import static com.google.firebase.inappmessaging.testutil.TestProtos.MODAL_MESSAGE_PROTO;
+import static com.google.firebase.inappmessaging.testutil.TestProtos.SECONDARY_ACTION_PROTO;
+import static com.google.firebase.inappmessaging.testutil.TestProtos.TITLE_PROTO;
+
+import com.google.firebase.inappmessaging.MessagesProto;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ProtoMarshallerClientTest {
+
+  @Before
+  public void setup() {}
+
+  // ************************* BANNER *************************
+  @Test
+  public void banner_completeMessage_createsInAppMessage() {
+    InAppMessage decodedModel = decode(BANNER_MESSAGE_PROTO);
+    assertThat(decodedModel).isEqualTo(BANNER_MESSAGE_MODEL);
+  }
+
+  @Test
+  public void banner_emptyeMessage_throwsException() {
+    MessagesProto.Content incompleteBannerProto =
+        MessagesProto.Content.newBuilder()
+            .setBanner(MessagesProto.BannerMessage.getDefaultInstance())
+            .build();
+
+    IllegalArgumentException e =
+        expectThrows(IllegalArgumentException.class, () -> decode(incompleteBannerProto));
+    assertThat(e).hasMessageThat().contains("Banner model must have a title");
+  }
+
+  @Test
+  public void banner_missingTitle_throwsException() {
+    MessagesProto.Content incompleteBannerProto =
+        MessagesProto.Content.newBuilder()
+            .setBanner(
+                MessagesProto.BannerMessage.newBuilder()
+                    .setAction(ACTION_PROTO)
+                    .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+                    .setBody(BODY_PROTO)
+                    .setImageUrl(IMAGE_URL_STRING))
+            .build();
+
+    IllegalArgumentException e =
+        expectThrows(IllegalArgumentException.class, () -> decode(incompleteBannerProto));
+    assertThat(e).hasMessageThat().contains("Banner model must have a title");
+  }
+
+  @Test
+  public void banner_withMinimumAttributes_createsInAppMessage() {
+    MessagesProto.Content minimumBanner =
+        MessagesProto.Content.newBuilder()
+            .setBanner(
+                MessagesProto.BannerMessage.newBuilder()
+                    .setTitle(TITLE_PROTO)
+                    .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING))
+            .build();
+
+    BannerMessage expected =
+        BannerMessage.builder()
+            .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+            .setTitle(TITLE_MODEL)
+            .build(CAMPAIGN_METADATA_MODEL);
+    InAppMessage actual = decode(minimumBanner);
+    assertThat(actual).isEqualTo(expected);
+  }
+
+  // ************************* MODAL *************************
+  @Test
+  public void modal_completeMessage_createsInAppMessage() {
+    InAppMessage decodedModel = decode(MODAL_MESSAGE_PROTO);
+    assertThat(decodedModel).isEqualTo(MODAL_MESSAGE_MODEL);
+  }
+
+  @Test
+  public void modal_emptyMessage_throwsException() {
+    MessagesProto.Content incompleteModalProto =
+        MessagesProto.Content.newBuilder()
+            .setModal(MessagesProto.ModalMessage.getDefaultInstance())
+            .build();
+
+    IllegalArgumentException e =
+        expectThrows(IllegalArgumentException.class, () -> decode(incompleteModalProto));
+    assertThat(e).hasMessageThat().contains("Modal model must have a title");
+  }
+
+  @Test
+  public void modal_missingTitle_throwsException() {
+    MessagesProto.Content incompleteModalProto =
+        MessagesProto.Content.newBuilder()
+            .setModal(
+                MessagesProto.ModalMessage.newBuilder()
+                    .setAction(ACTION_PROTO)
+                    .setActionButton(BUTTON_PROTO)
+                    .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+                    .setBody(BODY_PROTO)
+                    .setImageUrl(IMAGE_URL_STRING))
+            .build();
+
+    IllegalArgumentException e =
+        expectThrows(IllegalArgumentException.class, () -> decode(incompleteModalProto));
+    assertThat(e).hasMessageThat().contains("Modal model must have a title");
+  }
+
+  @Test
+  public void modal_withActionWithoutButton_throwsException() {
+    MessagesProto.Content incompleteModalProto =
+        MessagesProto.Content.newBuilder()
+            .setModal(
+                MessagesProto.ModalMessage.newBuilder()
+                    .setAction(ACTION_PROTO)
+                    .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+                    .setBody(BODY_PROTO)
+                    .setTitle(TITLE_PROTO)
+                    .setImageUrl(IMAGE_URL_STRING))
+            .build();
+
+    IllegalArgumentException e =
+        expectThrows(IllegalArgumentException.class, () -> decode(incompleteModalProto));
+    assertThat(e).hasMessageThat().contains("Modal model action must be null or have a button");
+  }
+
+  @Test
+  public void modal_withMinimumAttributes_createsInAppMessage() {
+    MessagesProto.Content minimumModal =
+        MessagesProto.Content.newBuilder()
+            .setModal(
+                MessagesProto.ModalMessage.newBuilder()
+                    .setTitle(TITLE_PROTO)
+                    .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING))
+            .build();
+
+    ModalMessage expected =
+        ModalMessage.builder()
+            .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+            .setTitle(TITLE_MODEL)
+            .build(CAMPAIGN_METADATA_MODEL);
+    InAppMessage actual = decode(minimumModal);
+    assertThat(actual).isEqualTo(expected);
+  }
+
+  // ************************* IMAGE *************************
+  @Test
+  public void imageOnly_completeMessage_createsInAppMessage() {
+    InAppMessage decodedModel = decode(IMAGE_MESSAGE_PROTO);
+    assertThat(decodedModel).isEqualTo(IMAGE_MESSAGE_MODEL);
+  }
+
+  @Test
+  public void imageOnly_emptyMessage_throwsException() {
+    MessagesProto.Content incompleteImageProto =
+        MessagesProto.Content.newBuilder()
+            .setImageOnly(MessagesProto.ImageOnlyMessage.getDefaultInstance())
+            .build();
+
+    IllegalArgumentException e =
+        expectThrows(IllegalArgumentException.class, () -> decode(incompleteImageProto));
+    assertThat(e).hasMessageThat().contains("ImageOnly model must have image data");
+  }
+
+  @Test
+  public void imageOnly_missingUrl_throwsException() {
+    MessagesProto.Content incompleteImageProto =
+        MessagesProto.Content.newBuilder()
+            .setImageOnly(
+                MessagesProto.ImageOnlyMessage.newBuilder().setAction(ACTION_PROTO).setImageUrl(""))
+            .build();
+
+    IllegalArgumentException e =
+        expectThrows(IllegalArgumentException.class, () -> decode(incompleteImageProto));
+    assertThat(e).hasMessageThat().contains("ImageOnly model must have image data");
+  }
+
+  @Test
+  public void imageOnly_withMinimumAttributes_createsInAppMessage() {
+    MessagesProto.Content minimumImageOnly =
+        MessagesProto.Content.newBuilder()
+            .setImageOnly(MessagesProto.ImageOnlyMessage.newBuilder().setImageUrl(IMAGE_URL_STRING))
+            .build();
+
+    ImageOnlyMessage expected =
+        ImageOnlyMessage.builder().setImageData(IMAGE_DATA).build(CAMPAIGN_METADATA_MODEL);
+    InAppMessage actual = decode(minimumImageOnly);
+    assertThat(actual).isEqualTo(expected);
+  }
+
+  // ************************* CARD *************************
+  @Test
+  public void card_completeMessage_createsInAppMessage() {
+    InAppMessage decodedModel = decode(CARD_MESSAGE_PROTO);
+    assertThat(decodedModel).isEqualTo(CARD_MESSAGE_MODEL);
+  }
+
+  @Test
+  public void card_emptyMessage_throwsException() {
+    MessagesProto.Content incompleteCardProto =
+        MessagesProto.Content.newBuilder()
+            .setCard(MessagesProto.CardMessage.getDefaultInstance())
+            .build();
+
+    IllegalArgumentException e =
+        expectThrows(IllegalArgumentException.class, () -> decode(incompleteCardProto));
+    assertThat(e).hasMessageThat().contains("Card model must have a primary action");
+  }
+
+  @Test
+  public void card_missingPrimaryActionButton_throwsException() {
+    MessagesProto.Content incompleteCardProto =
+        MessagesProto.Content.newBuilder()
+            .setCard(
+                MessagesProto.CardMessage.newBuilder()
+                    .setPrimaryAction(ACTION_PROTO)
+                    .setSecondaryAction(SECONDARY_ACTION_PROTO)
+                    .setSecondaryActionButton(BUTTON_PROTO)
+                    .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+                    .setBody(BODY_PROTO)
+                    .setTitle(TITLE_PROTO)
+                    .setPortraitImageUrl(IMAGE_URL_STRING))
+            .build();
+
+    IllegalArgumentException e =
+        expectThrows(IllegalArgumentException.class, () -> decode(incompleteCardProto));
+    assertThat(e).hasMessageThat().contains("Card model must have a primary action button");
+  }
+
+  @Test
+  public void card_missingSecondaryActionButton_throwsException() {
+    MessagesProto.Content incompleteCardProto =
+        MessagesProto.Content.newBuilder()
+            .setCard(
+                MessagesProto.CardMessage.newBuilder()
+                    .setPrimaryAction(ACTION_PROTO)
+                    .setPrimaryActionButton(BUTTON_PROTO)
+                    .setSecondaryAction(SECONDARY_ACTION_PROTO)
+                    .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+                    .setBody(BODY_PROTO)
+                    .setTitle(TITLE_PROTO)
+                    .setPortraitImageUrl(IMAGE_URL_STRING))
+            .build();
+
+    IllegalArgumentException e =
+        expectThrows(IllegalArgumentException.class, () -> decode(incompleteCardProto));
+    assertThat(e)
+        .hasMessageThat()
+        .contains("Card model secondary action must be null or have a button");
+  }
+
+  @Test
+  public void card_missingTitle_throwsException() {
+    MessagesProto.Content incompleteCardProto =
+        MessagesProto.Content.newBuilder()
+            .setCard(
+                MessagesProto.CardMessage.newBuilder()
+                    .setPrimaryAction(ACTION_PROTO)
+                    .setPrimaryActionButton(BUTTON_PROTO)
+                    .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+                    .setBody(BODY_PROTO)
+                    .setPortraitImageUrl(IMAGE_URL_STRING))
+            .build();
+
+    IllegalArgumentException e =
+        expectThrows(IllegalArgumentException.class, () -> decode(incompleteCardProto));
+    assertThat(e).hasMessageThat().contains("Card model must have a title");
+  }
+
+  @Test
+  public void card_missingImageData_throwsException() {
+    MessagesProto.Content incompleteCardProto =
+        MessagesProto.Content.newBuilder()
+            .setCard(
+                MessagesProto.CardMessage.newBuilder()
+                    .setPrimaryAction(ACTION_PROTO)
+                    .setPrimaryActionButton(BUTTON_PROTO)
+                    .setTitle(TITLE_PROTO)
+                    .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+                    .setBody(BODY_PROTO))
+            .build();
+
+    IllegalArgumentException e =
+        expectThrows(IllegalArgumentException.class, () -> decode(incompleteCardProto));
+    assertThat(e).hasMessageThat().contains("Card model must have at least one image");
+  }
+
+  @Test
+  public void card_missingBackgroundColor_throwsException() {
+    MessagesProto.Content incompleteCardProto =
+        MessagesProto.Content.newBuilder()
+            .setCard(
+                MessagesProto.CardMessage.newBuilder()
+                    .setPrimaryAction(ACTION_PROTO)
+                    .setPrimaryActionButton(BUTTON_PROTO)
+                    .setTitle(TITLE_PROTO)
+                    .setBody(BODY_PROTO)
+                    .setPortraitImageUrl(IMAGE_URL_STRING))
+            .build();
+
+    IllegalArgumentException e =
+        expectThrows(IllegalArgumentException.class, () -> decode(incompleteCardProto));
+    assertThat(e).hasMessageThat().contains("Card model must have a background color");
+  }
+
+  @Test
+  public void card_withMinimumAttributes_createsInAppMessage() {
+    MessagesProto.Content minimumCard =
+        MessagesProto.Content.newBuilder()
+            .setCard(
+                MessagesProto.CardMessage.newBuilder()
+                    .setPrimaryActionButton(BUTTON_PROTO)
+                    .setTitle(TITLE_PROTO)
+                    .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+                    .setPortraitImageUrl(IMAGE_URL_STRING))
+            .build();
+
+    CardMessage expected =
+        CardMessage.builder()
+            .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+            .setPrimaryAction(ACTION_MODEL_WITHOUT_URL)
+            .setPortraitImageData(IMAGE_DATA)
+            .setTitle(TITLE_MODEL)
+            .build(CAMPAIGN_METADATA_MODEL);
+    InAppMessage actual = decode(minimumCard);
+    assertThat(actual).isEqualTo(expected);
+  }
+
+  // ************************* DECODING *************************
+  @Test
+  public void decode_nullContent_failsPreconditionCheck() {
+    NullPointerException e = expectThrows(NullPointerException.class, () -> decode(null));
+    assertThat(e).hasMessageThat().contains("FirebaseInAppMessaging content cannot be null.");
+  }
+
+  @Test
+  public void decode_withNoMessageDetails_createsInAppMessageWithUnsupportedType() {
+    MessagesProto.Content unsupportedProto =
+        MessagesProto.Content.newBuilder()
+            .setModal(MessagesProto.ModalMessage.getDefaultInstance())
+            .clearMessageDetails()
+            .build();
+
+    InAppMessage actual = decode(unsupportedProto);
+    assertThat(actual.messageType).isEqualTo(MessageType.UNSUPPORTED);
+  }
+
+  private static InAppMessage decode(MessagesProto.Content message) {
+    return ProtoMarshallerClient.decode(
+        message, CAMPAIGN_ID_STRING, CAMPAIGN_NAME_STRING, IS_NOT_TEST_MESSAGE);
+  }
+}
diff --git a/firebase-inappmessaging/src/testData/inappmessaging/testutil/TestData.java b/firebase-inappmessaging/src/testData/inappmessaging/testutil/TestData.java
new file mode 100644
index 000000000..cbe8e1efc
--- /dev/null
+++ b/firebase-inappmessaging/src/testData/inappmessaging/testutil/TestData.java
@@ -0,0 +1,165 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.testutil;
+
+import com.google.firebase.inappmessaging.model.Action;
+import com.google.firebase.inappmessaging.model.BannerMessage;
+import com.google.firebase.inappmessaging.model.Button;
+import com.google.firebase.inappmessaging.model.CampaignMetadata;
+import com.google.firebase.inappmessaging.model.CardMessage;
+import com.google.firebase.inappmessaging.model.ImageData;
+import com.google.firebase.inappmessaging.model.ImageOnlyMessage;
+import com.google.firebase.inappmessaging.model.ModalMessage;
+import com.google.firebase.inappmessaging.model.Text;
+
+public class TestData {
+  // ************************* METADATA *************************
+  public static final String ANALYTICS_EVENT_NAME = "event1";
+  public static final String ON_FOREGROUND_EVENT_NAME = "ON_FOREGROUND";
+  public static final String INSTANCE_ID = "instance_id";
+  public static final String INSTANCE_TOKEN = "instance_token";
+  public static final boolean IS_NOT_TEST_MESSAGE = false;
+  public static final boolean IS_TEST_MESSAGE = true;
+  public static final String MESSAGE_BACKGROUND_HEX_STRING = "#FFFFFF";
+  public static final String CAMPAIGN_ID_STRING = "campaign_id";
+  public static final String CAMPAIGN_NAME_STRING = "campaign_name";
+  public static final CampaignMetadata CAMPAIGN_METADATA_MODEL =
+      new CampaignMetadata(CAMPAIGN_ID_STRING, CAMPAIGN_NAME_STRING, IS_NOT_TEST_MESSAGE);
+  public static final CampaignMetadata TEST_CAMPAIGN_METADATA_MODEL =
+      new CampaignMetadata(CAMPAIGN_ID_STRING, CAMPAIGN_NAME_STRING, IS_TEST_MESSAGE);
+
+  // ************************* TITLE *************************
+  public static final String TITLE_TEXT_STRING = "title";
+  public static final String TITLE_HEX_STRING = "#CCCCCC";
+  public static final Text TITLE_MODEL =
+      Text.builder().setText(TITLE_TEXT_STRING).setHexColor(TITLE_HEX_STRING).build();
+
+  // ************************* BODY *************************
+  public static final String BODY_TEXT_STRING = "body";
+  public static final String BODY_HEX_STRING = "#000000";
+  public static final Text BODY_MODEL =
+      Text.builder().setText(BODY_TEXT_STRING).setHexColor(BODY_HEX_STRING).build();
+
+  // ************************* IMAGE *************************
+  public static final String IMAGE_URL_STRING = "image_url";
+  public static final String LANDSCAPE_IMAGE_URL_STRING = "landscape_image";
+  public static final ImageData IMAGE_DATA =
+      ImageData.builder().setImageUrl(IMAGE_URL_STRING).build();
+  public static final ImageData LANDSCAPE_IMAGE_DATA =
+      ImageData.builder().setImageUrl(LANDSCAPE_IMAGE_URL_STRING).build();
+
+  // ************************* BUTTON *************************
+  public static final String BUTTON_TEXT_STRING = "button";
+  public static final String BUTTON_HEX_STRING = "#FFFCCC";
+  public static final String BUTTON_BG_STRING = "button_bg";
+  public static final Text BUTTON_TEXT_MODEL =
+      Text.builder().setText(BUTTON_TEXT_STRING).setHexColor(BUTTON_HEX_STRING).build();
+  public static final Button BUTTON_MODEL =
+      Button.builder().setText(BUTTON_TEXT_MODEL).setButtonHexColor(BUTTON_BG_STRING).build();
+
+  // ************************* ACTION *************************
+  public static final String ACTION_URL_STRING = "action_url";
+  public static final String SECONDARY_ACTION_URL_STRING = "secondary_action";
+  public static final Action ACTION_MODEL_WITHOUT_BUTTON =
+      Action.builder().setActionUrl(ACTION_URL_STRING).build();
+  public static final Action ACTION_MODEL_WITHOUT_URL =
+      Action.builder().setButton(BUTTON_MODEL).build();
+  public static final Action SECONDARY_ACTION_MODEL_WITHOUT_BUTTON =
+      Action.builder().setActionUrl(SECONDARY_ACTION_URL_STRING).build();
+  public static final Action ACTION_MODEL_WITH_BUTTON =
+      Action.builder().setActionUrl(ACTION_URL_STRING).setButton(BUTTON_MODEL).build();
+  public static final Action SECONDARY_ACTION_MODEL_WITH_BUTTON =
+      Action.builder().setActionUrl(SECONDARY_ACTION_URL_STRING).setButton(BUTTON_MODEL).build();
+
+  // ************************* BANNER *************************
+  public static final BannerMessage BANNER_MESSAGE_MODEL =
+      BannerMessage.builder()
+          .setAction(ACTION_MODEL_WITHOUT_BUTTON)
+          .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+          .setBody(BODY_MODEL)
+          .setTitle(TITLE_MODEL)
+          .setImageData(IMAGE_DATA)
+          .build(CAMPAIGN_METADATA_MODEL);
+
+  public static final BannerMessage BANNER_MESSAGE_NO_ACTION_MODEL =
+      BannerMessage.builder()
+          .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+          .setBody(BODY_MODEL)
+          .setTitle(TITLE_MODEL)
+          .setImageData(IMAGE_DATA)
+          .build(CAMPAIGN_METADATA_MODEL);
+
+  public static final BannerMessage BANNER_TEST_MESSAGE_MODEL =
+      BannerMessage.builder()
+          .setAction(ACTION_MODEL_WITHOUT_BUTTON)
+          .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+          .setBody(BODY_MODEL)
+          .setTitle(TITLE_MODEL)
+          .setImageData(IMAGE_DATA)
+          .build(TEST_CAMPAIGN_METADATA_MODEL);
+
+  // ************************* MODAL *************************
+  public static final ModalMessage MODAL_MESSAGE_MODEL =
+      ModalMessage.builder()
+          .setAction(ACTION_MODEL_WITH_BUTTON)
+          .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+          .setBody(BODY_MODEL)
+          .setTitle(TITLE_MODEL)
+          .setImageData(IMAGE_DATA)
+          .build(CAMPAIGN_METADATA_MODEL);
+
+  // ************************* CARD *************************
+  public static final CardMessage CARD_MESSAGE_MODEL =
+      CardMessage.builder()
+          .setTitle(TITLE_MODEL)
+          .setBody(BODY_MODEL)
+          .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+          .setPrimaryAction(ACTION_MODEL_WITH_BUTTON)
+          .setSecondaryAction(ACTION_MODEL_WITHOUT_URL)
+          .setPortraitImageData(IMAGE_DATA)
+          .setLandscapeImageData(LANDSCAPE_IMAGE_DATA)
+          .build(CAMPAIGN_METADATA_MODEL);
+
+  public static final CardMessage CARD_MESSAGE_WITHOUT_ACTIONS =
+      CardMessage.builder()
+          .setTitle(TITLE_MODEL)
+          .setBody(BODY_MODEL)
+          .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+          .setPrimaryAction(ACTION_MODEL_WITHOUT_URL)
+          .setPortraitImageData(IMAGE_DATA)
+          .setLandscapeImageData(LANDSCAPE_IMAGE_DATA)
+          .build(CAMPAIGN_METADATA_MODEL);
+
+  // ************************* IMAGE *************************
+  public static final ImageOnlyMessage IMAGE_MESSAGE_MODEL =
+      ImageOnlyMessage.builder()
+          .setAction(ACTION_MODEL_WITHOUT_BUTTON)
+          .setImageData(IMAGE_DATA)
+          .build(CAMPAIGN_METADATA_MODEL);
+
+  public static final ImageOnlyMessage IMAGE_MESSAGE_MODEL_WITHOUT_ACTION =
+      ImageOnlyMessage.builder().setImageData(IMAGE_DATA).build(CAMPAIGN_METADATA_MODEL);
+
+  // ************************* HELPERS *************************
+  public static BannerMessage createBannerMessageCustomMetadata(CampaignMetadata metadata) {
+    return BannerMessage.builder()
+        .setAction(ACTION_MODEL_WITHOUT_BUTTON)
+        .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+        .setBody(BODY_MODEL)
+        .setTitle(TITLE_MODEL)
+        .setImageData(IMAGE_DATA)
+        .build(metadata);
+  }
+}
diff --git a/firebase-inappmessaging/src/testUtil/java/com/google/firebase/inappmessaging/internal/time/FakeClock.java b/firebase-inappmessaging/src/testUtil/java/com/google/firebase/inappmessaging/internal/time/FakeClock.java
new file mode 100644
index 000000000..ce6fc74a1
--- /dev/null
+++ b/firebase-inappmessaging/src/testUtil/java/com/google/firebase/inappmessaging/internal/time/FakeClock.java
@@ -0,0 +1,31 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Copyright 2007 Google Inc.  All Rights Reserved.
+
+package com.google.firebase.inappmessaging.internal.time;
+
+public class FakeClock implements Clock {
+  private final long currentTimeMillis;
+
+  /** Creates a FakeClock instance initialized to the given time. */
+  public FakeClock(long currentTimeMillis) {
+    this.currentTimeMillis = currentTimeMillis;
+  }
+
+  @Override
+  public long now() {
+    return currentTimeMillis;
+  }
+}
diff --git a/firebase-inappmessaging/src/testUtil/java/com/google/firebase/inappmessaging/testutil/Assert.java b/firebase-inappmessaging/src/testUtil/java/com/google/firebase/inappmessaging/testutil/Assert.java
new file mode 100644
index 000000000..aaa677d4e
--- /dev/null
+++ b/firebase-inappmessaging/src/testUtil/java/com/google/firebase/inappmessaging/testutil/Assert.java
@@ -0,0 +1,211 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.testutil;
+
+import org.hamcrest.Matcher;
+import org.hamcrest.MatcherAssert;
+
+// JUnit 4.13 class lifted from https://github.com/junit-team/junit4 with thanks.
+
+/**
+ * A set of assertion methods useful for writing tests. Only failed assertions are recorded. These
+ * methods can be used directly: <code>Assert.assertEquals(...)</code>, however, they read better if
+ * they are referenced through static import:
+ *
+ * <pre>
+ * import static org.junit.Assert.*;
+ *    ...
+ *    assertEquals(...);
+ * </pre>
+ */
+public class Assert {
+  /** Protect constructor since it is a static only class */
+  protected Assert() {}
+
+  private static boolean equalsRegardingNull(Object expected, Object actual) {
+    if (expected == null) {
+      return actual == null;
+    }
+
+    return isEquals(expected, actual);
+  }
+
+  private static boolean isEquals(Object expected, Object actual) {
+    return expected.equals(actual);
+  }
+
+  private static boolean floatIsDifferent(float f1, float f2, float delta) {
+    if (Float.compare(f1, f2) == 0) {
+      return false;
+    }
+    if ((Math.abs(f1 - f2) <= delta)) {
+      return false;
+    }
+
+    return true;
+  }
+
+  static String format(String message, Object expected, Object actual) {
+    String formatted = "";
+    if (message != null && !"".equals(message)) {
+      formatted = message + " ";
+    }
+    String expectedString = String.valueOf(expected);
+    String actualString = String.valueOf(actual);
+    if (equalsRegardingNull(expectedString, actualString)) {
+      return formatted
+          + "expected: "
+          + formatClassAndValue(expected, expectedString)
+          + " but was: "
+          + formatClassAndValue(actual, actualString);
+    } else {
+      return formatted + "expected:<" + expectedString + "> but was:<" + actualString + ">";
+    }
+  }
+
+  private static String formatClass(Class<?> value) {
+    String className = value.getCanonicalName();
+    return className == null ? value.getName() : className;
+  }
+
+  private static String formatClassAndValue(Object value, String valueString) {
+    String className = value == null ? "null" : value.getClass().getName();
+    return className + "<" + valueString + ">";
+  }
+
+  /**
+   * Asserts that <code>actual</code> satisfies the condition specified by <code>matcher</code>. If
+   * not, an {@link AssertionError} is thrown with information about the matcher and failing value.
+   * Example:
+   *
+   * <pre>
+   *   assertThat(0, is(1)); // fails:
+   *     // failure message:
+   *     // expected: is &lt;1&gt;
+   *     // got value: &lt;0&gt;
+   *   assertThat(0, is(not(1))) // passes
+   * </pre>
+   *
+   * <code>org.hamcrest.Matcher</code> does not currently document the meaning of its type parameter
+   * <code>T</code>. This method assumes that a matcher typed as <code>Matcher&lt;T&gt;</code> can
+   * be meaningfully applied only to values that could be assigned to a variable of type <code>T
+   * </code>.
+   *
+   * @param <T> the static type accepted by the matcher (this can flag obvious compile-time problems
+   *     such as {@code assertThat(1, is("a"))}
+   * @param actual the computed value being compared
+   * @param matcher an expression, built of {@link Matcher}s, specifying allowed values
+   * @see org.hamcrest.CoreMatchers
+   * @see org.hamcrest.MatcherAssert
+   * @deprecated use {@code org.hamcrest.junit.MatcherAssert.assertThat()}
+   */
+  @Deprecated
+  public static <T> void assertThat(T actual, Matcher<? super T> matcher) {
+    assertThat("", actual, matcher);
+  }
+
+  /**
+   * Asserts that <code>actual</code> satisfies the condition specified by <code>matcher</code>. If
+   * not, an {@link AssertionError} is thrown with the reason and information about the matcher and
+   * failing value. Example:
+   *
+   * <pre>
+   *   assertThat(&quot;Help! Integers don't work&quot;, 0, is(1)); // fails:
+   *     // failure message:
+   *     // Help! Integers don't work
+   *     // expected: is &lt;1&gt;
+   *     // got value: &lt;0&gt;
+   *   assertThat(&quot;Zero is one&quot;, 0, is(not(1))) // passes
+   * </pre>
+   *
+   * <code>org.hamcrest.Matcher</code> does not currently document the meaning of its type parameter
+   * <code>T</code>. This method assumes that a matcher typed as <code>Matcher&lt;T&gt;</code> can
+   * be meaningfully applied only to values that could be assigned to a variable of type <code>T
+   * </code>.
+   *
+   * @param reason additional information about the error
+   * @param <T> the static type accepted by the matcher (this can flag obvious compile-time problems
+   *     such as {@code assertThat(1, is("a"))}
+   * @param actual the computed value being compared
+   * @param matcher an expression, built of {@link Matcher}s, specifying allowed values
+   * @see org.hamcrest.CoreMatchers
+   * @see org.hamcrest.MatcherAssert
+   * @deprecated use {@code org.hamcrest.junit.MatcherAssert.assertThat()}
+   */
+  @Deprecated
+  public static <T> void assertThat(String reason, T actual, Matcher<? super T> matcher) {
+    MatcherAssert.assertThat(reason, actual, matcher);
+  }
+
+  /**
+   * Asserts that {@code runnable} throws an exception of type {@code expectedThrowable} when
+   * executed. If it does not throw an exception, an {@link AssertionError} is thrown. If it throws
+   * the wrong type of exception, an {@code AssertionError} is thrown describing the mismatch; the
+   * exception that was actually thrown can be obtained by calling {@link AssertionError#getCause}.
+   *
+   * @param expectedThrowable the expected type of the exception
+   * @param runnable a function that is expected to throw an exception when executed
+   * @since 4.13
+   */
+  public static void assertThrows(
+      Class<? extends Throwable> expectedThrowable, ThrowingRunnable runnable) {
+    expectThrows(expectedThrowable, runnable);
+  }
+
+  /**
+   * Asserts that {@code runnable} throws an exception of type {@code expectedThrowable} when
+   * executed. If it does, the exception object is returned. If it does not throw an exception, an
+   * {@link AssertionError} is thrown. If it throws the wrong type of exception, an {@code
+   * AssertionError} is thrown describing the mismatch; the exception that was actually thrown can
+   * be obtained by calling {@link AssertionError#getCause}.
+   *
+   * @param expectedThrowable the expected type of the exception
+   * @param runnable a function that is expected to throw an exception when executed
+   * @return the exception thrown by {@code runnable}
+   * @since 4.13
+   */
+  public static <T extends Throwable> T expectThrows(
+      Class<T> expectedThrowable, ThrowingRunnable runnable) {
+    try {
+      runnable.run();
+    } catch (Throwable actualThrown) {
+      if (expectedThrowable.isInstance(actualThrown)) {
+        @SuppressWarnings("unchecked")
+        T retVal = (T) actualThrown;
+        return retVal;
+      } else {
+        String expected = formatClass(expectedThrowable);
+        Class<? extends Throwable> actualThrowable = actualThrown.getClass();
+        String actual = formatClass(actualThrowable);
+        if (expected.equals(actual)) {
+          // There must be multiple class loaders. Add the identity hash code so the message
+          // doesn't say "expected: java.lang.String<my.package.MyException> ..."
+          expected += "@" + Integer.toHexString(System.identityHashCode(expectedThrowable));
+          actual += "@" + Integer.toHexString(System.identityHashCode(actualThrowable));
+        }
+        String mismatchMessage = format("unexpected exception type thrown;", expected, actual);
+
+        // The AssertionError(String, Throwable) ctor is only available on JDK7.
+        AssertionError assertionError = new AssertionError(mismatchMessage);
+        assertionError.initCause(actualThrown);
+        throw assertionError;
+      }
+    }
+    String message =
+        String.format(
+            "expected %s to be thrown, but nothing was thrown", formatClass(expectedThrowable));
+    throw new AssertionError(message);
+  }
+}
diff --git a/firebase-inappmessaging/src/testUtil/java/com/google/firebase/inappmessaging/testutil/TestProtos.java b/firebase-inappmessaging/src/testUtil/java/com/google/firebase/inappmessaging/testutil/TestProtos.java
new file mode 100644
index 000000000..dab6de4f1
--- /dev/null
+++ b/firebase-inappmessaging/src/testUtil/java/com/google/firebase/inappmessaging/testutil/TestProtos.java
@@ -0,0 +1,106 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.testutil;
+
+import static com.google.firebase.inappmessaging.testutil.TestData.ACTION_URL_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.BODY_HEX_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.BODY_TEXT_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.BUTTON_BG_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.BUTTON_HEX_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.BUTTON_TEXT_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.IMAGE_URL_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.LANDSCAPE_IMAGE_URL_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.MESSAGE_BACKGROUND_HEX_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.SECONDARY_ACTION_URL_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.TITLE_HEX_STRING;
+import static com.google.firebase.inappmessaging.testutil.TestData.TITLE_TEXT_STRING;
+
+import com.google.firebase.inappmessaging.MessagesProto;
+
+public class TestProtos {
+  public static final MessagesProto.Text TITLE_PROTO =
+      MessagesProto.Text.newBuilder()
+          .setText(TITLE_TEXT_STRING)
+          .setHexColor(TITLE_HEX_STRING)
+          .build();
+
+  public static final MessagesProto.Text BODY_PROTO =
+      MessagesProto.Text.newBuilder()
+          .setText(BODY_TEXT_STRING)
+          .setHexColor(BODY_HEX_STRING)
+          .build();
+
+  public static final MessagesProto.Text BUTTON_TEXT_PROTO =
+      MessagesProto.Text.newBuilder()
+          .setText(BUTTON_TEXT_STRING)
+          .setHexColor(BUTTON_HEX_STRING)
+          .build();
+
+  public static final MessagesProto.Button BUTTON_PROTO =
+      MessagesProto.Button.newBuilder()
+          .setText(BUTTON_TEXT_PROTO)
+          .setButtonHexColor(BUTTON_BG_STRING)
+          .build();
+
+  public static final MessagesProto.Action ACTION_PROTO =
+      MessagesProto.Action.newBuilder().setActionUrl(ACTION_URL_STRING).build();
+  public static final MessagesProto.Action SECONDARY_ACTION_PROTO =
+      MessagesProto.Action.newBuilder().setActionUrl(SECONDARY_ACTION_URL_STRING).build();
+
+  public static final MessagesProto.Content BANNER_MESSAGE_PROTO =
+      MessagesProto.Content.newBuilder()
+          .setBanner(
+              MessagesProto.BannerMessage.newBuilder()
+                  .setAction(ACTION_PROTO)
+                  .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+                  .setBody(BODY_PROTO)
+                  .setTitle(TITLE_PROTO)
+                  .setImageUrl(IMAGE_URL_STRING))
+          .build();
+
+  public static final MessagesProto.Content MODAL_MESSAGE_PROTO =
+      MessagesProto.Content.newBuilder()
+          .setModal(
+              MessagesProto.ModalMessage.newBuilder()
+                  .setAction(ACTION_PROTO)
+                  .setActionButton(BUTTON_PROTO)
+                  .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+                  .setBody(BODY_PROTO)
+                  .setTitle(TITLE_PROTO)
+                  .setImageUrl(IMAGE_URL_STRING))
+          .build();
+
+  public static final MessagesProto.Content CARD_MESSAGE_PROTO =
+      MessagesProto.Content.newBuilder()
+          .setCard(
+              MessagesProto.CardMessage.newBuilder()
+                  .setPrimaryActionButton(BUTTON_PROTO)
+                  .setPrimaryAction(ACTION_PROTO)
+                  .setSecondaryActionButton(BUTTON_PROTO)
+                  .setBackgroundHexColor(MESSAGE_BACKGROUND_HEX_STRING)
+                  .setBody(BODY_PROTO)
+                  .setTitle(TITLE_PROTO)
+                  .setPortraitImageUrl(IMAGE_URL_STRING)
+                  .setLandscapeImageUrl(LANDSCAPE_IMAGE_URL_STRING))
+          .build();
+
+  public static final MessagesProto.Content IMAGE_MESSAGE_PROTO =
+      MessagesProto.Content.newBuilder()
+          .setImageOnly(
+              MessagesProto.ImageOnlyMessage.newBuilder()
+                  .setAction(ACTION_PROTO)
+                  .setImageUrl(IMAGE_URL_STRING))
+          .build();
+}
diff --git a/firebase-inappmessaging/src/testUtil/java/com/google/firebase/inappmessaging/testutil/ThrowingRunnable.java b/firebase-inappmessaging/src/testUtil/java/com/google/firebase/inappmessaging/testutil/ThrowingRunnable.java
new file mode 100644
index 000000000..50417f25e
--- /dev/null
+++ b/firebase-inappmessaging/src/testUtil/java/com/google/firebase/inappmessaging/testutil/ThrowingRunnable.java
@@ -0,0 +1,26 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.inappmessaging.testutil;
+
+// JUnit 4.13 class lifted from https://github.com/junit-team/junit4 with thanks.
+
+/**
+ * This interface facilitates the use of expectThrows from Java 8. It allows method references to
+ * void methods (that declare checked exceptions) to be passed directly into expectThrows without
+ * wrapping. It is not meant to be implemented directly.
+ */
+public interface ThrowingRunnable {
+  void run() throws Throwable;
+}
diff --git a/firebase-storage/CHANGELOG.md b/firebase-storage/CHANGELOG.md
index cfa98fb53..0d835e7de 100644
--- a/firebase-storage/CHANGELOG.md
+++ b/firebase-storage/CHANGELOG.md
@@ -1,4 +1,17 @@
-# Unreleased (17.1.0)
+# 19.0.2
+- [fixed] Fixed an encoding issue in `list()/listAll()` that caused us to miss
+  entries for folders that contained special characters.
+
+# 19.0.1
+- [fixed] `listAll()` now propagates the error messages if the List operation
+  was denied by a Security Rule.
+
+# 19.0.0
+- [changed] Added missing nullability annotations for better Kotlin interop.
+- [internal] Removed ``@PublicApi` annotations as they are no longer enforced
+  and have no semantic meaning.
+
+# 18.1.0
 - [feature] Added `StorageReference.list()` and `StorageReference.listAll()`,
   which allows developers to list the files and folders under the given
   StorageReference.
diff --git a/firebase-storage/api.txt b/firebase-storage/api.txt
new file mode 100644
index 000000000..48292e2af
--- /dev/null
+++ b/firebase-storage/api.txt
@@ -0,0 +1,249 @@
+// Signature format: 2.0
+package com.google.firebase.storage {
+
+  public abstract class CancellableTask<StateT> {
+    ctor public CancellableTask();
+    method @NonNull public abstract com.google.firebase.storage.CancellableTask<StateT> addOnProgressListener(@NonNull com.google.firebase.storage.OnProgressListener<? super StateT>);
+    method @NonNull public abstract com.google.firebase.storage.CancellableTask<StateT> addOnProgressListener(@NonNull Executor, @NonNull com.google.firebase.storage.OnProgressListener<? super StateT>);
+    method @NonNull public abstract com.google.firebase.storage.CancellableTask<StateT> addOnProgressListener(@NonNull Activity, @NonNull com.google.firebase.storage.OnProgressListener<? super StateT>);
+    method public abstract boolean cancel();
+    method public abstract boolean isCanceled();
+    method public abstract boolean isInProgress();
+  }
+
+  public abstract class ControllableTask<StateT> extends com.google.firebase.storage.CancellableTask<StateT> {
+    ctor public ControllableTask();
+    method @NonNull public abstract com.google.firebase.storage.ControllableTask<StateT> addOnPausedListener(@NonNull com.google.firebase.storage.OnPausedListener<? super StateT>);
+    method @NonNull public abstract com.google.firebase.storage.ControllableTask<StateT> addOnPausedListener(@NonNull Executor, @NonNull com.google.firebase.storage.OnPausedListener<? super StateT>);
+    method @NonNull public abstract com.google.firebase.storage.ControllableTask<StateT> addOnPausedListener(@NonNull Activity, @NonNull com.google.firebase.storage.OnPausedListener<? super StateT>);
+    method public abstract boolean isPaused();
+    method public abstract boolean pause();
+    method public abstract boolean resume();
+  }
+
+  public class FileDownloadTask extends com.google.firebase.storage.StorageTask<com.google.firebase.storage.FileDownloadTask.TaskSnapshot> {
+  }
+
+  public class FileDownloadTask.TaskSnapshot extends com.google.firebase.storage.StorageTask<com.google.firebase.storage.FileDownloadTask.TaskSnapshot>.SnapshotBase {
+    method public long getBytesTransferred();
+    method public long getTotalByteCount();
+  }
+
+  public class FirebaseStorage {
+    method @NonNull public FirebaseApp getApp();
+    method @NonNull public static com.google.firebase.storage.FirebaseStorage getInstance();
+    method @NonNull public static com.google.firebase.storage.FirebaseStorage getInstance(@NonNull String);
+    method @NonNull public static com.google.firebase.storage.FirebaseStorage getInstance(@NonNull FirebaseApp);
+    method @NonNull public static com.google.firebase.storage.FirebaseStorage getInstance(@NonNull FirebaseApp, @NonNull String);
+    method public long getMaxDownloadRetryTimeMillis();
+    method public long getMaxOperationRetryTimeMillis();
+    method public long getMaxUploadRetryTimeMillis();
+    method @NonNull public com.google.firebase.storage.StorageReference getReference();
+    method @NonNull public com.google.firebase.storage.StorageReference getReference(@NonNull String);
+    method @NonNull public com.google.firebase.storage.StorageReference getReferenceFromUrl(@NonNull String);
+    method public void setMaxDownloadRetryTimeMillis(long);
+    method public void setMaxOperationRetryTimeMillis(long);
+    method public void setMaxUploadRetryTimeMillis(long);
+  }
+
+  public final class ListResult {
+    method @NonNull public List<StorageReference> getItems();
+    method @Nullable public String getPageToken();
+    method @NonNull public List<StorageReference> getPrefixes();
+  }
+
+  public interface OnPausedListener<ProgressT> {
+    method public void onPaused(@NonNull ProgressT);
+  }
+
+  public interface OnProgressListener<ProgressT> {
+    method public void onProgress(@NonNull ProgressT);
+  }
+
+  public class StorageException {
+    method @NonNull public static com.google.firebase.storage.StorageException fromErrorStatus(@NonNull Status);
+    method @NonNull public static com.google.firebase.storage.StorageException fromException(@NonNull Throwable);
+    method @Nullable public static com.google.firebase.storage.StorageException fromExceptionAndHttpCode(@Nullable Throwable, int);
+    method @Nullable public Throwable getCause();
+    method @com.google.firebase.storage.StorageException.ErrorCode public int getErrorCode();
+    method public int getHttpResultCode();
+    method public boolean getIsRecoverableException();
+    field public static final int ERROR_BUCKET_NOT_FOUND = -13011; // 0xffffcd2d
+    field public static final int ERROR_CANCELED = -13040; // 0xffffcd10
+    field public static final int ERROR_INVALID_CHECKSUM = -13031; // 0xffffcd19
+    field public static final int ERROR_NOT_AUTHENTICATED = -13020; // 0xffffcd24
+    field public static final int ERROR_NOT_AUTHORIZED = -13021; // 0xffffcd23
+    field public static final int ERROR_OBJECT_NOT_FOUND = -13010; // 0xffffcd2e
+    field public static final int ERROR_PROJECT_NOT_FOUND = -13012; // 0xffffcd2c
+    field public static final int ERROR_QUOTA_EXCEEDED = -13013; // 0xffffcd2b
+    field public static final int ERROR_RETRY_LIMIT_EXCEEDED = -13030; // 0xffffcd1a
+    field public static final int ERROR_UNKNOWN = -13000; // 0xffffcd38
+  }
+
+  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public static @interface StorageException.ErrorCode {
+  }
+
+  public class StorageMetadata {
+    ctor public StorageMetadata();
+    method @Nullable public String getBucket();
+    method @Nullable public String getCacheControl();
+    method @Nullable public String getContentDisposition();
+    method @Nullable public String getContentEncoding();
+    method @Nullable public String getContentLanguage();
+    method @Nullable public String getContentType();
+    method public long getCreationTimeMillis();
+    method @Nullable public String getCustomMetadata(@NonNull String);
+    method @NonNull public Set<String> getCustomMetadataKeys();
+    method @Nullable public String getGeneration();
+    method @Nullable public String getMd5Hash();
+    method @Nullable public String getMetadataGeneration();
+    method @Nullable public String getName();
+    method @NonNull public String getPath();
+    method @Nullable public com.google.firebase.storage.StorageReference getReference();
+    method public long getSizeBytes();
+    method public long getUpdatedTimeMillis();
+  }
+
+  public static class StorageMetadata.Builder {
+    ctor public StorageMetadata.Builder();
+    ctor public StorageMetadata.Builder(@NonNull com.google.firebase.storage.StorageMetadata);
+    method @NonNull public com.google.firebase.storage.StorageMetadata build();
+    method @Nullable public String getCacheControl();
+    method @Nullable public String getContentDisposition();
+    method @Nullable public String getContentEncoding();
+    method @Nullable public String getContentLanguage();
+    method @Nullable public String getContentType();
+    method @NonNull public com.google.firebase.storage.StorageMetadata.Builder setCacheControl(@Nullable String);
+    method @NonNull public com.google.firebase.storage.StorageMetadata.Builder setContentDisposition(@Nullable String);
+    method @NonNull public com.google.firebase.storage.StorageMetadata.Builder setContentEncoding(@Nullable String);
+    method @NonNull public com.google.firebase.storage.StorageMetadata.Builder setContentLanguage(@Nullable String);
+    method @NonNull public com.google.firebase.storage.StorageMetadata.Builder setContentType(@Nullable String);
+    method @NonNull public com.google.firebase.storage.StorageMetadata.Builder setCustomMetadata(@NonNull String, @Nullable String);
+  }
+
+  public class StorageReference {
+    method @NonNull public com.google.firebase.storage.StorageReference child(@NonNull String);
+    method public int compareTo(@NonNull com.google.firebase.storage.StorageReference);
+    method @NonNull public Task<Void> delete();
+    method public boolean equals(Object);
+    method @NonNull public List<FileDownloadTask> getActiveDownloadTasks();
+    method @NonNull public List<UploadTask> getActiveUploadTasks();
+    method @NonNull public String getBucket();
+    method @NonNull public Task<byte[]> getBytes(long);
+    method @NonNull public Task<Uri> getDownloadUrl();
+    method @NonNull public com.google.firebase.storage.FileDownloadTask getFile(@NonNull Uri);
+    method @NonNull public com.google.firebase.storage.FileDownloadTask getFile(@NonNull File);
+    method @NonNull public Task<StorageMetadata> getMetadata();
+    method @NonNull public String getName();
+    method @Nullable public com.google.firebase.storage.StorageReference getParent();
+    method @NonNull public String getPath();
+    method @NonNull public com.google.firebase.storage.StorageReference getRoot();
+    method @NonNull public com.google.firebase.storage.FirebaseStorage getStorage();
+    method @NonNull public com.google.firebase.storage.StreamDownloadTask getStream();
+    method @NonNull public com.google.firebase.storage.StreamDownloadTask getStream(@NonNull com.google.firebase.storage.StreamDownloadTask.StreamProcessor);
+    method public int hashCode();
+    method @NonNull public Task<ListResult> list(int);
+    method @NonNull public Task<ListResult> list(int, @NonNull String);
+    method @NonNull public Task<ListResult> listAll();
+    method @NonNull public com.google.firebase.storage.UploadTask putBytes(@NonNull byte[]);
+    method @NonNull public com.google.firebase.storage.UploadTask putBytes(@NonNull byte[], @NonNull com.google.firebase.storage.StorageMetadata);
+    method @NonNull public com.google.firebase.storage.UploadTask putFile(@NonNull Uri);
+    method @NonNull public com.google.firebase.storage.UploadTask putFile(@NonNull Uri, @NonNull com.google.firebase.storage.StorageMetadata);
+    method @NonNull public com.google.firebase.storage.UploadTask putFile(@NonNull Uri, @Nullable com.google.firebase.storage.StorageMetadata, @Nullable Uri);
+    method @NonNull public com.google.firebase.storage.UploadTask putStream(@NonNull InputStream);
+    method @NonNull public com.google.firebase.storage.UploadTask putStream(@NonNull InputStream, @NonNull com.google.firebase.storage.StorageMetadata);
+    method public String toString();
+    method @NonNull public Task<StorageMetadata> updateMetadata(@NonNull com.google.firebase.storage.StorageMetadata);
+  }
+
+  public abstract class StorageTask<ResultT extends com.google.firebase.storage.StorageTask.ProvideError> extends com.google.firebase.storage.ControllableTask<ResultT> {
+    ctor protected StorageTask();
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnCanceledListener(@NonNull OnCanceledListener);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnCanceledListener(@NonNull Executor, @NonNull OnCanceledListener);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnCanceledListener(@NonNull Activity, @NonNull OnCanceledListener);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnCompleteListener(@NonNull OnCompleteListener<ResultT>);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnCompleteListener(@NonNull Executor, @NonNull OnCompleteListener<ResultT>);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnCompleteListener(@NonNull Activity, @NonNull OnCompleteListener<ResultT>);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnFailureListener(@NonNull OnFailureListener);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnFailureListener(@NonNull Executor, @NonNull OnFailureListener);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnFailureListener(@NonNull Activity, @NonNull OnFailureListener);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnPausedListener(@NonNull com.google.firebase.storage.OnPausedListener<? super ResultT>);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnPausedListener(@NonNull Executor, @NonNull com.google.firebase.storage.OnPausedListener<? super ResultT>);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnPausedListener(@NonNull Activity, @NonNull com.google.firebase.storage.OnPausedListener<? super ResultT>);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnProgressListener(@NonNull com.google.firebase.storage.OnProgressListener<? super ResultT>);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnProgressListener(@NonNull Executor, @NonNull com.google.firebase.storage.OnProgressListener<? super ResultT>);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnProgressListener(@NonNull Activity, @NonNull com.google.firebase.storage.OnProgressListener<? super ResultT>);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnSuccessListener(@NonNull OnSuccessListener<? super ResultT>);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnSuccessListener(@NonNull Executor, @NonNull OnSuccessListener<? super ResultT>);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> addOnSuccessListener(@NonNull Activity, @NonNull OnSuccessListener<? super ResultT>);
+    method public boolean cancel();
+    method @NonNull public <ContinuationResultT> Task<ContinuationResultT> continueWith(@NonNull Continuation<ResultT,ContinuationResultT>);
+    method @NonNull public <ContinuationResultT> Task<ContinuationResultT> continueWith(@NonNull Executor, @NonNull Continuation<ResultT,ContinuationResultT>);
+    method @NonNull public <ContinuationResultT> Task<ContinuationResultT> continueWithTask(@NonNull Continuation<ResultT,Task<ContinuationResultT>>);
+    method @NonNull public <ContinuationResultT> Task<ContinuationResultT> continueWithTask(@NonNull Executor, @NonNull Continuation<ResultT,Task<ContinuationResultT>>);
+    method @Nullable public Exception getException();
+    method @NonNull public ResultT getResult();
+    method @NonNull public <X extends Throwable> ResultT getResult(@NonNull Class<X>) throws X;
+    method @NonNull public ResultT getSnapshot();
+    method public boolean isCanceled();
+    method public boolean isComplete();
+    method public boolean isInProgress();
+    method public boolean isPaused();
+    method public boolean isSuccessful();
+    method protected void onCanceled();
+    method protected void onFailure();
+    method protected void onPaused();
+    method protected void onProgress();
+    method protected void onQueued();
+    method protected void onSuccess();
+    method @NonNull public <ContinuationResultT> Task<ContinuationResultT> onSuccessTask(@NonNull SuccessContinuation<ResultT,ContinuationResultT>);
+    method @NonNull public <ContinuationResultT> Task<ContinuationResultT> onSuccessTask(@NonNull Executor, @NonNull SuccessContinuation<ResultT,ContinuationResultT>);
+    method public boolean pause();
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> removeOnCanceledListener(@NonNull OnCanceledListener);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> removeOnCompleteListener(@NonNull OnCompleteListener<ResultT>);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> removeOnFailureListener(@NonNull OnFailureListener);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> removeOnPausedListener(@NonNull com.google.firebase.storage.OnPausedListener<? super ResultT>);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> removeOnProgressListener(@NonNull com.google.firebase.storage.OnProgressListener<? super ResultT>);
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> removeOnSuccessListener(@NonNull OnSuccessListener<? super ResultT>);
+    method public boolean resume();
+    field protected final Object syncObject;
+  }
+
+  protected static interface StorageTask.ProvideError {
+    method public Exception getError();
+  }
+
+  public class StorageTask.SnapshotBase implements com.google.firebase.storage.StorageTask.ProvideError {
+    ctor public StorageTask.SnapshotBase(@Nullable Exception);
+    method @Nullable public Exception getError();
+    method @NonNull public com.google.firebase.storage.StorageReference getStorage();
+    method @NonNull public com.google.firebase.storage.StorageTask<ResultT> getTask();
+  }
+
+  public class StreamDownloadTask extends com.google.firebase.storage.StorageTask<com.google.firebase.storage.StreamDownloadTask.TaskSnapshot> {
+  }
+
+  public static interface StreamDownloadTask.StreamProcessor {
+    method public void doInBackground(@NonNull com.google.firebase.storage.StreamDownloadTask.TaskSnapshot, @NonNull InputStream);
+  }
+
+  public class StreamDownloadTask.TaskSnapshot extends com.google.firebase.storage.StorageTask<com.google.firebase.storage.StreamDownloadTask.TaskSnapshot>.SnapshotBase {
+    method public long getBytesTransferred();
+    method @NonNull public InputStream getStream();
+    method public long getTotalByteCount();
+  }
+
+  public class UploadTask extends com.google.firebase.storage.StorageTask<com.google.firebase.storage.UploadTask.TaskSnapshot> {
+    method protected void resetState();
+    method protected void schedule();
+  }
+
+  public class UploadTask.TaskSnapshot extends com.google.firebase.storage.StorageTask<com.google.firebase.storage.UploadTask.TaskSnapshot>.SnapshotBase {
+    method public long getBytesTransferred();
+    method @Nullable public com.google.firebase.storage.StorageMetadata getMetadata();
+    method public long getTotalByteCount();
+    method @Nullable public Uri getUploadSessionUri();
+  }
+
+}
+
diff --git a/firebase-storage/firebase-storage.gradle b/firebase-storage/firebase-storage.gradle
index 3944b2df1..6650891f0 100644
--- a/firebase-storage/firebase-storage.gradle
+++ b/firebase-storage/firebase-storage.gradle
@@ -20,6 +20,7 @@ plugins {
 firebaseLibrary {
     testLab.enabled = true
     publishJavadoc = true
+    publishSources = true
 }
 
 android {
@@ -33,7 +34,7 @@ android {
         minSdkVersion project.minSdkVersion
         multiDexEnabled true
         versionName version
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
     }
 
     buildTypes {
@@ -76,23 +77,24 @@ android {
 dependencies {
     implementation project(':firebase-common')
 
-    implementation "com.google.android.gms:play-services-base:$playServicesVersion"
-    implementation "com.google.android.gms:play-services-tasks:$playServicesVersion"
-    implementation('com.google.firebase:firebase-auth-interop:17.0.0') {
+    implementation 'androidx.annotation:annotation:1.1.0'
+    implementation 'com.google.android.gms:play-services-base:17.0.0'
+    implementation 'com.google.android.gms:play-services-tasks:17.0.0'
+    implementation('com.google.firebase:firebase-auth-interop:18.0.0') {
         exclude group: "com.google.firebase", module: "firebase-common"
     }
 
-    androidTestImplementation "com.android.support:support-annotations:$supportAnnotationsVersion"
-    androidTestImplementation 'com.android.support.test:rules:1.0.2'
-    androidTestImplementation 'com.android.support.test:runner:1.0.2'
+    androidTestImplementation "androidx.annotation:annotation:1.1.0"
+    androidTestImplementation 'androidx.test:rules:1.2.0'
+    androidTestImplementation 'androidx.test:runner:1.2.0'
     androidTestImplementation "com.google.truth:truth:$googleTruthVersion"
     androidTestImplementation 'junit:junit:4.12'
 
     testImplementation 'junit:junit:4.12'
-    testImplementation 'org.mockito:mockito-core:2.21.0'
+    testImplementation 'org.mockito:mockito-core:2.25.0'
     testImplementation "org.robolectric:robolectric:$robolectricVersion"
     testImplementation "com.google.truth:truth:$googleTruthVersion"
-    testImplementation 'com.android.support.test:rules:1.0.2'
+    testImplementation 'androidx.test:rules:1.2.0'
 }
 
 // ==========================================================================
diff --git a/firebase-storage/gradle.properties b/firebase-storage/gradle.properties
index f4ae1a575..18169ffc3 100644
--- a/firebase-storage/gradle.properties
+++ b/firebase-storage/gradle.properties
@@ -12,6 +12,6 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-version=17.0.0
-latestReleasedVersion=16.1.0
+version=19.0.1
+latestReleasedVersion=19.0.0
 android.enableUnitTestBinaryResources=true
diff --git a/firebase-storage/ktx/gradle.properties b/firebase-storage/ktx/gradle.properties
new file mode 100644
index 000000000..016fa887b
--- /dev/null
+++ b/firebase-storage/ktx/gradle.properties
@@ -0,0 +1,2 @@
+android.enableUnitTestBinaryResources=true
+
diff --git a/firebase-storage/ktx/ktx.gradle b/firebase-storage/ktx/ktx.gradle
new file mode 100644
index 000000000..698ac79fa
--- /dev/null
+++ b/firebase-storage/ktx/ktx.gradle
@@ -0,0 +1,61 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+plugins {
+    id 'firebase-library'
+    id 'kotlin-android'
+}
+
+firebaseLibrary {
+    releaseWith project(':firebase-storage')
+    publishJavadoc = false
+    publishSources = true
+}
+
+android {
+    compileSdkVersion project.targetSdkVersion
+    defaultConfig {
+        minSdkVersion 16
+        multiDexEnabled true
+        targetSdkVersion project.targetSdkVersion
+        versionName version
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+    }
+    sourceSets {
+        main.java.srcDirs += 'src/main/kotlin'
+        test.java {
+            srcDir 'src/test/kotlin'
+        }
+        androidTest.java.srcDirs += 'src/androidTest/kotlin'
+    }
+    testOptions.unitTests.includeAndroidResources = true
+}
+
+dependencies {
+    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlinVersion"
+
+    implementation project(':firebase-common')
+    implementation project(':firebase-common:ktx')
+    implementation project(':firebase-storage')
+    implementation 'androidx.annotation:annotation:1.1.0'
+    implementation 'com.google.android.gms:play-services-tasks:17.0.0'
+
+    androidTestImplementation 'junit:junit:4.12'
+    androidTestImplementation "com.google.truth:truth:$googleTruthVersion"
+    androidTestImplementation 'androidx.test:runner:1.2.0'
+
+    testImplementation "org.robolectric:robolectric:$robolectricVersion"
+    testImplementation 'junit:junit:4.12'
+    testImplementation "com.google.truth:truth:$googleTruthVersion"
+}
diff --git a/firebase-storage/ktx/src/main/AndroidManifest.xml b/firebase-storage/ktx/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..a0588e1a8
--- /dev/null
+++ b/firebase-storage/ktx/src/main/AndroidManifest.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.google.firebase.storage.ktx">
+    <!--Although the *SdkVersion is captured in gradle build files, this is required for non gradle builds-->
+    <!--<uses-sdk android:minSdkVersion="16"/>-->
+    <application>
+        <service android:name="com.google.firebase.components.ComponentDiscoveryService" android:exported="false">
+            <meta-data android:name="com.google.firebase.components:com.google.firebase.storage.ktx.FirebaseStorageKtxRegistrar"
+                android:value="com.google.firebase.components.ComponentRegistrar" />
+        </service>
+    </application>
+</manifest>
diff --git a/firebase-storage/ktx/src/main/kotlin/com/google/firebase/storage/ktx/Storage.kt b/firebase-storage/ktx/src/main/kotlin/com/google/firebase/storage/ktx/Storage.kt
new file mode 100644
index 000000000..5fe363558
--- /dev/null
+++ b/firebase-storage/ktx/src/main/kotlin/com/google/firebase/storage/ktx/Storage.kt
@@ -0,0 +1,55 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.storage.ktx
+
+import androidx.annotation.Keep
+import com.google.firebase.FirebaseApp
+import com.google.firebase.storage.FirebaseStorage
+import com.google.firebase.storage.StorageMetadata
+import com.google.firebase.components.Component
+import com.google.firebase.components.ComponentRegistrar
+
+import com.google.firebase.ktx.Firebase
+import com.google.firebase.platforminfo.LibraryVersionComponent
+
+/** Returns the [FirebaseStorage] instance of the default [FirebaseApp]. */
+val Firebase.storage: FirebaseStorage
+    get() = FirebaseStorage.getInstance()
+
+/** Returns the [FirebaseStorage] instance for a custom storage bucket at [url]. */
+fun Firebase.storage(url: String): FirebaseStorage = FirebaseStorage.getInstance(url)
+
+/** Returns the [FirebaseStorage] instance of a given [FirebaseApp]. */
+fun Firebase.storage(app: FirebaseApp): FirebaseStorage = FirebaseStorage.getInstance(app)
+
+/** Returns the [FirebaseStorage] instance of a given [FirebaseApp] and storage bucket [url]. */
+fun Firebase.storage(app: FirebaseApp, url: String): FirebaseStorage =
+        FirebaseStorage.getInstance(app, url)
+
+/** Returns a [StorageMetadata] object initialized using the [init] function. */
+fun storageMetadata(init: StorageMetadata.Builder.() -> Unit): StorageMetadata {
+    val builder = StorageMetadata.Builder()
+    builder.init()
+    return builder.build()
+}
+
+internal const val LIBRARY_NAME: String = "fire-stg-ktx"
+
+/** @suppress */
+@Keep
+class FirebaseStorageKtxRegistrar : ComponentRegistrar {
+    override fun getComponents(): List<Component<*>> =
+            listOf(LibraryVersionComponent.create(LIBRARY_NAME, BuildConfig.VERSION_NAME))
+}
diff --git a/firebase-storage/ktx/src/test/kotlin/com/google/firebase/storage/ktx/StorageTest.kt b/firebase-storage/ktx/src/test/kotlin/com/google/firebase/storage/ktx/StorageTest.kt
new file mode 100644
index 000000000..db4368387
--- /dev/null
+++ b/firebase-storage/ktx/src/test/kotlin/com/google/firebase/storage/ktx/StorageTest.kt
@@ -0,0 +1,117 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.storage.ktx
+
+import com.google.common.truth.Truth.assertThat
+import com.google.firebase.FirebaseApp
+import com.google.firebase.FirebaseOptions
+import com.google.firebase.storage.FirebaseStorage
+import com.google.firebase.storage.StorageMetadata
+import com.google.firebase.ktx.Firebase
+import com.google.firebase.ktx.app
+import com.google.firebase.ktx.initialize
+import com.google.firebase.platforminfo.UserAgentPublisher
+import org.junit.After
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.RobolectricTestRunner
+import org.robolectric.RuntimeEnvironment
+
+const val APP_ID = "APP_ID"
+const val API_KEY = "API_KEY"
+
+const val EXISTING_APP = "existing"
+
+abstract class BaseTestCase {
+    @Before
+    fun setUp() {
+        Firebase.initialize(
+                RuntimeEnvironment.application,
+                FirebaseOptions.Builder()
+                        .setApplicationId(APP_ID)
+                        .setApiKey(API_KEY)
+                        .setProjectId("123")
+                        .build()
+        )
+
+        Firebase.initialize(
+                RuntimeEnvironment.application,
+                FirebaseOptions.Builder()
+                        .setApplicationId(APP_ID)
+                        .setApiKey(API_KEY)
+                        .setProjectId("123")
+                        .build(),
+                EXISTING_APP
+        )
+    }
+
+    @After
+    fun cleanUp() {
+        FirebaseApp.clearInstancesForTest()
+    }
+}
+
+@RunWith(RobolectricTestRunner::class)
+class StorageTests : BaseTestCase() {
+
+    @Test
+    fun `storage should delegate to FirebaseStorage#getInstance()`() {
+        assertThat(Firebase.storage).isSameInstanceAs(FirebaseStorage.getInstance())
+    }
+
+    @Test
+    fun `FirebaseApp#storage should delegate to FirebaseStorage#getInstance(FirebaseApp)`() {
+        val app = Firebase.app(EXISTING_APP)
+        assertThat(Firebase.storage(app)).isSameInstanceAs(FirebaseStorage.getInstance(app))
+    }
+
+    @Test
+    fun `Firebase#storage should delegate to FirebaseStorage#getInstance(url)`() {
+        val url = "gs://valid.url"
+        assertThat(Firebase.storage(url)).isSameInstanceAs(FirebaseStorage.getInstance(url))
+    }
+
+    @Test
+    fun `Firebase#storage should delegate to FirebaseStorage#getInstance(FirebaseApp, url)`() {
+        val app = Firebase.app(EXISTING_APP)
+        val url = "gs://valid.url"
+        assertThat(Firebase.storage(app, url)).isSameInstanceAs(FirebaseStorage.getInstance(app, url))
+    }
+
+    @Test
+    fun `storageMetadata type-safe builder extension works`() {
+        val storage = Firebase.storage
+        val metadata: StorageMetadata = storageMetadata {
+            contentLanguage = "en_us"
+            contentType = "text/html"
+            contentEncoding = "utf-8"
+            cacheControl = "no-cache"
+            contentDisposition = "attachment"
+        }
+
+        assertThat(metadata.getContentType()).isEqualTo("text/html")
+        assertThat(metadata.getCacheControl()).isEqualTo("no-cache")
+    }
+}
+
+@RunWith(RobolectricTestRunner::class)
+class LibraryVersionTest : BaseTestCase() {
+    @Test
+    fun `library version should be registered with runtime`() {
+        val publisher = Firebase.app.get(UserAgentPublisher::class.java)
+        assertThat(publisher.userAgent).contains(LIBRARY_NAME)
+    }
+}
diff --git a/firebase-storage/src/androidTest/java/com/google/firebase/storage/IntegrationTest.java b/firebase-storage/src/androidTest/java/com/google/firebase/storage/IntegrationTest.java
index e4c7df2e3..34e931ed7 100644
--- a/firebase-storage/src/androidTest/java/com/google/firebase/storage/IntegrationTest.java
+++ b/firebase-storage/src/androidTest/java/com/google/firebase/storage/IntegrationTest.java
@@ -19,10 +19,10 @@
 
 import android.net.Uri;
 import android.os.Environment;
-import android.support.annotation.NonNull;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.rule.GrantPermissionRule;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.annotation.NonNull;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.rule.GrantPermissionRule;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.Tasks;
 import com.google.firebase.FirebaseApp;
@@ -51,6 +51,8 @@
 
   private final String randomPrefix = UUID.randomUUID().toString();
 
+  private final String unicodePrefix = "prefix/\\%: ";
+
   @Before
   public void before() throws ExecutionException, InterruptedException {
     if (storageClient == null) {
@@ -60,6 +62,7 @@ public void before() throws ExecutionException, InterruptedException {
       Tasks.await(getReference("metadata.dat").putBytes(new byte[0]));
       Tasks.await(getReference("download.dat").putBytes(new byte[LARGE_FILE_SIZE_BYTES]));
       Tasks.await(getReference("prefix/empty.dat").putBytes(new byte[0]));
+      Tasks.await(getReference(unicodePrefix + "/empty.dat").putBytes(new byte[0]));
     }
   }
 
@@ -75,6 +78,15 @@ public void downloadFile() throws ExecutionException, InterruptedException, IOEx
     assertThat(fileTask.getBytesTransferred()).isEqualTo(LARGE_FILE_SIZE_BYTES);
   }
 
+  @Test
+  public void downloadUnicodeFile() throws ExecutionException, InterruptedException, IOException {
+    File tempFile = new File(Environment.getExternalStorageDirectory(), "empty.dat");
+
+    Tasks.await(getReference(unicodePrefix + "/empty.dat").getFile(tempFile));
+
+    assertThat(tempFile.exists()).isTrue();
+  }
+
   @Test
   public void streamFile() throws ExecutionException, InterruptedException, IOException {
     TaskSnapshot streamTask = Tasks.await(getReference("download.dat").getStream());
@@ -134,7 +146,7 @@ public void updateMetadata() throws ExecutionException, InterruptedException {
 
   @Test
   public void pagedListFiles() throws ExecutionException, InterruptedException {
-    Task<ListResult> listTask = storageClient.getReference(randomPrefix).list(2);
+    Task<ListResult> listTask = getReference().list(2);
     ListResult listResult = Tasks.await(listTask);
 
     assertThat(listResult.getItems())
@@ -142,7 +154,7 @@ public void pagedListFiles() throws ExecutionException, InterruptedException {
     assertThat(listResult.getPrefixes()).isEmpty();
     assertThat(listResult.getPageToken()).isNotEmpty();
 
-    listTask = storageClient.getReference(randomPrefix).list(2, listResult.getPageToken());
+    listTask = getReference().list(2, listResult.getPageToken());
     listResult = Tasks.await(listTask);
 
     assertThat(listResult.getItems()).isEmpty();
@@ -152,7 +164,7 @@ public void pagedListFiles() throws ExecutionException, InterruptedException {
 
   @Test
   public void listAllFiles() throws ExecutionException, InterruptedException {
-    Task<ListResult> listTask = storageClient.getReference(randomPrefix).listAll();
+    Task<ListResult> listTask = getReference().listAll();
     ListResult listResult = Tasks.await(listTask);
 
     assertThat(listResult.getPrefixes()).containsExactly(getReference("prefix"));
@@ -161,6 +173,24 @@ public void listAllFiles() throws ExecutionException, InterruptedException {
     assertThat(listResult.getPageToken()).isNull();
   }
 
+  @Test
+  public void listUnicodeFiles() throws ExecutionException, InterruptedException {
+    Task<ListResult> listTask = getReference("prefix").listAll();
+    ListResult listResult = Tasks.await(listTask);
+
+    assertThat(listResult.getPrefixes()).containsExactly(getReference(unicodePrefix));
+
+    listTask = getReference(unicodePrefix).listAll();
+    listResult = Tasks.await(listTask);
+
+    assertThat(listResult.getItems()).containsExactly(getReference(unicodePrefix + "/empty.dat"));
+  }
+
+  @NonNull
+  private StorageReference getReference() {
+    return storageClient.getReference(randomPrefix);
+  }
+
   @NonNull
   private StorageReference getReference(String filename) {
     return storageClient.getReference(randomPrefix + "/" + filename);
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/CancelException.java b/firebase-storage/src/main/java/com/google/firebase/storage/CancelException.java
index ee783f305..2bcf43ef1 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/CancelException.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/CancelException.java
@@ -14,13 +14,11 @@
 
 package com.google.firebase.storage;
 
-import com.google.firebase.annotations.PublicApi;
 import java.io.IOException;
 
 /** Represents an internal exception that is thrown to cancel a currently running task. */
-@PublicApi
 class CancelException extends IOException {
-  @PublicApi
+
   CancelException() {
     super("The operation was canceled.");
   }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/CancellableTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/CancellableTask.java
index eac9217a8..a4e2ef7ce 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/CancellableTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/CancellableTask.java
@@ -15,10 +15,9 @@
 package com.google.firebase.storage;
 
 import android.app.Activity;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.google.android.gms.tasks.OnFailureListener;
 import com.google.android.gms.tasks.Task;
-import com.google.firebase.annotations.PublicApi;
 import java.util.concurrent.Executor;
 
 /**
@@ -27,7 +26,6 @@
  * @param <StateT> the type of state this operation returns in events.
  */
 @SuppressWarnings("unused")
-@PublicApi
 public abstract class CancellableTask<StateT> extends Task<StateT> {
   /**
    * Attempts to cancel the task. A canceled task cannot be resumed later. A canceled task calls
@@ -37,16 +35,13 @@
    * @return true if this task was successfully canceled or is in the process of being canceled.
    *     Returns false if the task is already completed or in a state that cannot be canceled.
    */
-  @PublicApi
   public abstract boolean cancel();
 
   /** @return true if the task has been canceled. */
-  @PublicApi
   @Override
   public abstract boolean isCanceled();
 
   /** @return true if the task is currently running. */
-  @PublicApi
   public abstract boolean isInProgress();
 
   /**
@@ -54,7 +49,7 @@
    *
    * @return this Task
    */
-  @PublicApi
+  @NonNull
   public abstract CancellableTask<StateT> addOnProgressListener(
       @NonNull OnProgressListener<? super StateT> listener);
 
@@ -64,7 +59,7 @@
    * @param executor the executor to use to call the listener
    * @return this Task
    */
-  @PublicApi
+  @NonNull
   public abstract CancellableTask<StateT> addOnProgressListener(
       @NonNull Executor executor, @NonNull OnProgressListener<? super StateT> listener);
 
@@ -75,7 +70,7 @@
    *     removed.
    * @return this Task
    */
-  @PublicApi
+  @NonNull
   public abstract CancellableTask<StateT> addOnProgressListener(
       @NonNull Activity activity, @NonNull OnProgressListener<? super StateT> listener);
 }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/ControllableTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/ControllableTask.java
index df60e4d73..b0a41f6e4 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/ControllableTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/ControllableTask.java
@@ -15,8 +15,7 @@
 package com.google.firebase.storage;
 
 import android.app.Activity;
-import android.support.annotation.NonNull;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
 import java.util.concurrent.Executor;
 
 /**
@@ -26,7 +25,6 @@
  * @param <StateT> the type of state this operation returns in events.
  */
 @SuppressWarnings("unused")
-@PublicApi
 public abstract class ControllableTask<StateT> extends CancellableTask<StateT> {
 
   /**
@@ -35,7 +33,6 @@
    * @return true if this task was successfully paused or is in the process of being paused. Returns
    *     false if the task is already completed or in a state that cannot be paused.
    */
-  @PublicApi
   public abstract boolean pause();
 
   /**
@@ -44,11 +41,9 @@
    * @return true if the task is successfully resumed or is in the process of being resumed. Returns
    *     false if the task is already completed or in a state that cannot be resumed.
    */
-  @PublicApi
   public abstract boolean resume();
 
   /** @return true if the task has been paused. */
-  @PublicApi
   public abstract boolean isPaused();
 
   /**
@@ -56,7 +51,7 @@
    *
    * @return this Task
    */
-  @PublicApi
+  @NonNull
   public abstract ControllableTask<StateT> addOnPausedListener(
       @NonNull OnPausedListener<? super StateT> listener);
 
@@ -66,7 +61,7 @@
    * @param executor the executor to use to call the listener
    * @return this Task
    */
-  @PublicApi
+  @NonNull
   public abstract ControllableTask<StateT> addOnPausedListener(
       @NonNull Executor executor, @NonNull OnPausedListener<? super StateT> listener);
 
@@ -77,7 +72,7 @@
    *     removed.
    * @return this Task
    */
-  @PublicApi
+  @NonNull
   public abstract ControllableTask<StateT> addOnPausedListener(
       @NonNull Activity activity, @NonNull OnPausedListener<? super StateT> listener);
 }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/DeleteStorageTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/DeleteStorageTask.java
index 5d863cf5f..d0f4b79b2 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/DeleteStorageTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/DeleteStorageTask.java
@@ -14,8 +14,8 @@
 
 package com.google.firebase.storage;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.RestrictTo;
+import androidx.annotation.NonNull;
+import androidx.annotation.RestrictTo;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.firebase.storage.internal.ExponentialBackoffSender;
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/FileDownloadTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/FileDownloadTask.java
index 59d20f403..623059315 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/FileDownloadTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/FileDownloadTask.java
@@ -15,11 +15,10 @@
 package com.google.firebase.storage;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
 import android.text.TextUtils;
 import android.util.Log;
+import androidx.annotation.NonNull;
 import com.google.android.gms.common.api.Status;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.storage.internal.ExponentialBackoffSender;
 import com.google.firebase.storage.network.GetNetworkRequest;
 import com.google.firebase.storage.network.NetworkRequest;
@@ -31,7 +30,6 @@
 
 /** A task that downloads bytes of a GCS blob to a specified File. */
 @SuppressWarnings("unused")
-@PublicApi
 public class FileDownloadTask extends StorageTask<FileDownloadTask.TaskSnapshot> {
   static final int PREFERRED_CHUNK_SIZE = 256 * 1024; // 256KB
   private static final String TAG = "FileDownloadTask";
@@ -262,7 +260,6 @@ private boolean processResponse(final NetworkRequest request) throws IOException
   }
 
   @Override
-  @PublicApi
   protected void onCanceled() {
     mSender.cancel();
     mException = StorageException.fromErrorStatus(Status.RESULT_CANCELED);
@@ -274,7 +271,6 @@ private boolean isValidHttpResponseCode(int code) {
 
   /** Encapsulates state about the running {@link FileDownloadTask} */
   @SuppressWarnings("unused")
-  @PublicApi
   public class TaskSnapshot extends StorageTask<FileDownloadTask.TaskSnapshot>.SnapshotBase {
     private final long mBytesDownloaded;
 
@@ -284,13 +280,11 @@ private boolean isValidHttpResponseCode(int code) {
     }
 
     /** @return the total bytes downloaded so far. */
-    @PublicApi
     public long getBytesTransferred() {
       return mBytesDownloaded;
     }
 
     /** @return the total bytes to upload.. */
-    @PublicApi
     public long getTotalByteCount() {
       return FileDownloadTask.this.getTotalBytes();
     }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/FirebaseStorage.java b/firebase-storage/src/main/java/com/google/firebase/storage/FirebaseStorage.java
index 367b5aaeb..226cf5dca 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/FirebaseStorage.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/FirebaseStorage.java
@@ -15,15 +15,14 @@
 package com.google.firebase.storage;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.text.format.DateUtils;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.FirebaseOptions;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.auth.internal.InternalAuthProvider;
 import com.google.firebase.inject.Provider;
 import com.google.firebase.storage.internal.Util;
@@ -40,7 +39,6 @@
  * {@link FirebaseApp#getInstance()}. The storage location in this case will come the JSON
  * configuration file downloaded from the web.
  */
-@PublicApi
 public class FirebaseStorage {
   private static final String TAG = "FirebaseStorage";
   private static final String STORAGE_URI_PARSE_EXCEPTION = "The storage Uri could not be parsed.";
@@ -81,7 +79,6 @@ private static FirebaseStorage getInstanceImpl(@NonNull FirebaseApp app, @Nullab
    * @return a {@link FirebaseStorage} instance.
    */
   @NonNull
-  @PublicApi
   public static FirebaseStorage getInstance() {
     FirebaseApp app = FirebaseApp.getInstance();
     Preconditions.checkArgument(app != null, "You must call FirebaseApp.initialize() first.");
@@ -97,7 +94,6 @@ public static FirebaseStorage getInstance() {
    * @return a {@link FirebaseStorage} instance.
    */
   @NonNull
-  @PublicApi
   public static FirebaseStorage getInstance(@NonNull String url) {
     FirebaseApp app = FirebaseApp.getInstance();
     Preconditions.checkArgument(app != null, "You must call FirebaseApp.initialize() first.");
@@ -112,7 +108,6 @@ public static FirebaseStorage getInstance(@NonNull String url) {
    * @return a {@link FirebaseStorage} instance.
    */
   @NonNull
-  @PublicApi
   public static FirebaseStorage getInstance(@NonNull FirebaseApp app) {
     // noinspection ConstantConditions
     Preconditions.checkArgument(app != null, "Null is not a valid value for the FirebaseApp.");
@@ -140,7 +135,6 @@ public static FirebaseStorage getInstance(@NonNull FirebaseApp app) {
    * @return a {@link FirebaseStorage} instance.
    */
   @NonNull
-  @PublicApi
   public static FirebaseStorage getInstance(@NonNull FirebaseApp app, @NonNull String url) {
     // noinspection ConstantConditions
     Preconditions.checkArgument(app != null, "Null is not a valid value for the FirebaseApp.");
@@ -165,7 +159,6 @@ public static FirebaseStorage getInstance(@NonNull FirebaseApp app, @NonNull Str
    *
    * @return maximum time in milliseconds. Defaults to 10 minutes (600,000 milliseconds).
    */
-  @PublicApi
   public long getMaxDownloadRetryTimeMillis() {
     return sMaxDownloadRetry;
   }
@@ -176,7 +169,6 @@ public long getMaxDownloadRetryTimeMillis() {
    * @param maxTransferRetryMillis the maximum time in milliseconds. Defaults to 10 minutes (600,000
    *     milliseconds).
    */
-  @PublicApi
   public void setMaxDownloadRetryTimeMillis(long maxTransferRetryMillis) {
     sMaxDownloadRetry = maxTransferRetryMillis;
   }
@@ -186,7 +178,6 @@ public void setMaxDownloadRetryTimeMillis(long maxTransferRetryMillis) {
    *
    * @return the maximum time in milliseconds. Defaults to 10 minutes (600,000 milliseconds).
    */
-  @PublicApi
   public long getMaxUploadRetryTimeMillis() {
     return sMaxUploadRetry;
   }
@@ -197,7 +188,6 @@ public long getMaxUploadRetryTimeMillis() {
    * @param maxTransferRetryMillis the maximum time in milliseconds. Defaults to 10 minutes (600,000
    *     milliseconds).
    */
-  @PublicApi
   public void setMaxUploadRetryTimeMillis(long maxTransferRetryMillis) {
     sMaxUploadRetry = maxTransferRetryMillis;
   }
@@ -208,7 +198,6 @@ public void setMaxUploadRetryTimeMillis(long maxTransferRetryMillis) {
    *
    * @return the maximum time in milliseconds. Defaults to 2 minutes (120,000 milliseconds).
    */
-  @PublicApi
   public long getMaxOperationRetryTimeMillis() {
     return sMaxQueryRetry;
   }
@@ -220,7 +209,6 @@ public long getMaxOperationRetryTimeMillis() {
    *     milliseconds).
    */
   @SuppressWarnings("unused")
-  @PublicApi
   public void setMaxOperationRetryTimeMillis(long maxTransferRetryMillis) {
     sMaxQueryRetry = maxTransferRetryMillis;
   }
@@ -235,7 +223,6 @@ private String getBucketName() {
    *
    * @return An instance of {@link StorageReference}.
    */
-  @PublicApi
   @NonNull
   public StorageReference getReference() {
     String bucketName = getBucketName();
@@ -257,7 +244,6 @@ public StorageReference getReference() {
    *     associated with the {@link FirebaseApp} used to initialize this {@link FirebaseStorage}.
    */
   @NonNull
-  @PublicApi
   public StorageReference getReferenceFromUrl(@NonNull String fullUrl) {
     Preconditions.checkArgument(!TextUtils.isEmpty(fullUrl), "location must not be null or empty");
     String lowerCaseLocation = fullUrl.toLowerCase();
@@ -288,7 +274,6 @@ public StorageReference getReferenceFromUrl(@NonNull String fullUrl) {
    * @return An instance of {@link StorageReference} at the given child path.
    */
   @NonNull
-  @PublicApi
   public StorageReference getReference(@NonNull String location) {
     Preconditions.checkArgument(!TextUtils.isEmpty(location), "location must not be null or empty");
     String lowerCaseLocation = location.toLowerCase();
@@ -314,7 +299,6 @@ private StorageReference getReference(@NonNull Uri uri) {
 
   /** The {@link FirebaseApp} associated with this {@link FirebaseStorage} instance. */
   @NonNull
-  @PublicApi
   public FirebaseApp getApp() {
     return mApp;
   }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/FirebaseStorageComponent.java b/firebase-storage/src/main/java/com/google/firebase/storage/FirebaseStorageComponent.java
index 4f9c47bb8..ed936bf77 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/FirebaseStorageComponent.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/FirebaseStorageComponent.java
@@ -14,9 +14,9 @@
 
 package com.google.firebase.storage;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.auth.internal.InternalAuthProvider;
 import com.google.firebase.inject.Provider;
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/GetDownloadUrlTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/GetDownloadUrlTask.java
index d4daab1cd..9c071d71e 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/GetDownloadUrlTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/GetDownloadUrlTask.java
@@ -15,12 +15,11 @@
 package com.google.firebase.storage;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.tasks.TaskCompletionSource;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.storage.internal.ExponentialBackoffSender;
 import com.google.firebase.storage.network.GetMetadataNetworkRequest;
 import com.google.firebase.storage.network.NetworkRequest;
@@ -60,15 +59,16 @@ private Uri extractDownloadUrl(JSONObject response) {
 
     if (!TextUtils.isEmpty(downloadTokens)) {
       String downloadToken = downloadTokens.split(",", -1)[0];
-      String baseURL = NetworkRequest.getdefaultURL(storageRef.getStorageUri());
-      return Uri.parse(baseURL + "?alt=media&token=" + downloadToken);
+      Uri.Builder uriBuilder = NetworkRequest.getDefaultURL(storageRef.getStorageUri()).buildUpon();
+      uriBuilder.appendQueryParameter("alt", "media");
+      uriBuilder.appendQueryParameter("token", downloadToken);
+      return uriBuilder.build();
     }
 
     return null;
   }
 
   @Override
-  @PublicApi
   public void run() {
     final NetworkRequest request =
         new GetMetadataNetworkRequest(storageRef.getStorageUri(), storageRef.getApp());
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/GetMetadataTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/GetMetadataTask.java
index d9bcd244c..6f8b7082f 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/GetMetadataTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/GetMetadataTask.java
@@ -14,11 +14,10 @@
 
 package com.google.firebase.storage;
 
-import android.support.annotation.NonNull;
 import android.util.Log;
+import androidx.annotation.NonNull;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.tasks.TaskCompletionSource;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.storage.internal.ExponentialBackoffSender;
 import com.google.firebase.storage.network.GetMetadataNetworkRequest;
 import com.google.firebase.storage.network.NetworkRequest;
@@ -55,7 +54,6 @@
   }
 
   @Override
-  @PublicApi
   public void run() {
     final NetworkRequest request =
         new GetMetadataNetworkRequest(mStorageRef.getStorageUri(), mStorageRef.getApp());
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/ListResult.java b/firebase-storage/src/main/java/com/google/firebase/storage/ListResult.java
index 1300135a0..c41963b0d 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/ListResult.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/ListResult.java
@@ -14,9 +14,8 @@
 
 package com.google.firebase.storage;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import java.util.ArrayList;
 import java.util.List;
 import org.json.JSONArray;
@@ -24,7 +23,6 @@
 import org.json.JSONObject;
 
 /** Contains the prefixes and items returned by a {@link StorageReference#list} call. */
-@PublicApi
 public final class ListResult {
   private static final String ITEMS_KEY = "items";
   private static final String NAME_KEY = "name";
@@ -76,7 +74,6 @@ static ListResult fromJSON(FirebaseStorage storage, JSONObject resultBody) throw
    * @return A list of prefixes (folders).
    */
   @NonNull
-  @PublicApi
   public List<StorageReference> getPrefixes() {
     return prefixes;
   }
@@ -87,19 +84,17 @@ static ListResult fromJSON(FirebaseStorage storage, JSONObject resultBody) throw
    * @return A list of items (files).
    */
   @NonNull
-  @PublicApi
   public List<StorageReference> getItems() {
     return items;
   }
 
   /**
-   * Returns a token that can be used to resume a previous {@code list()} operation. `null`
+   * Returns a token that can be used to resume a previous {@code list()} operation. {@code null}
    * indicates that there are no more results.
    *
-   * @return A page token if more results are avaible.
+   * @return A page token if more results are available.
    */
   @Nullable
-  @PublicApi
   public String getPageToken() {
     return pageToken;
   }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/ListTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/ListTask.java
index 3da370e89..3385fa401 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/ListTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/ListTask.java
@@ -14,9 +14,9 @@
 
 package com.google.firebase.storage;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.firebase.storage.internal.ExponentialBackoffSender;
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/OnPausedListener.java b/firebase-storage/src/main/java/com/google/firebase/storage/OnPausedListener.java
index 07bb3ead5..08bfe2171 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/OnPausedListener.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/OnPausedListener.java
@@ -14,11 +14,10 @@
 
 package com.google.firebase.storage;
 
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
 
 /** A listener that is called if the Task is paused via {@link ControllableTask#pause()}. */
-@PublicApi
 public interface OnPausedListener<ProgressT> {
-  @PublicApi
-  void onPaused(ProgressT snapshot);
+
+  void onPaused(@NonNull ProgressT snapshot);
 }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/OnProgressListener.java b/firebase-storage/src/main/java/com/google/firebase/storage/OnProgressListener.java
index 25bfe738f..93458263b 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/OnProgressListener.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/OnProgressListener.java
@@ -14,11 +14,10 @@
 
 package com.google.firebase.storage;
 
-import com.google.firebase.annotations.PublicApi;
+import androidx.annotation.NonNull;
 
 /** A listener that is called periodically during execution of the {@link ControllableTask}. */
-@PublicApi
 public interface OnProgressListener<ProgressT> {
-  @PublicApi
-  void onProgress(ProgressT snapshot);
+
+  void onProgress(@NonNull ProgressT snapshot);
 }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/StorageException.java b/firebase-storage/src/main/java/com/google/firebase/storage/StorageException.java
index a1a1005c1..726459d69 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/StorageException.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/StorageException.java
@@ -14,52 +14,50 @@
 
 package com.google.firebase.storage;
 
-import android.support.annotation.IntDef;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.util.Log;
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.api.Status;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.firebase.FirebaseException;
-import com.google.firebase.annotations.PublicApi;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
 /** Represents an Exception resulting from an operation on a {@link StorageReference}. */
-@PublicApi
 public class StorageException extends FirebaseException {
   private static final String TAG = "StorageException";
 
-  @PublicApi public static final int ERROR_UNKNOWN = -13000;
-  @PublicApi public static final int ERROR_OBJECT_NOT_FOUND = -13010;
-  @PublicApi public static final int ERROR_BUCKET_NOT_FOUND = -13011;
-  @PublicApi public static final int ERROR_PROJECT_NOT_FOUND = -13012;
-  @PublicApi public static final int ERROR_QUOTA_EXCEEDED = -13013;
-  @PublicApi public static final int ERROR_NOT_AUTHENTICATED = -13020;
-  @PublicApi public static final int ERROR_NOT_AUTHORIZED = -13021;
-  @PublicApi public static final int ERROR_RETRY_LIMIT_EXCEEDED = -13030;
-  @PublicApi public static final int ERROR_INVALID_CHECKSUM = -13031;
-  @PublicApi public static final int ERROR_CANCELED = -13040;
+  public static final int ERROR_UNKNOWN = -13000;
+  public static final int ERROR_OBJECT_NOT_FOUND = -13010;
+  public static final int ERROR_BUCKET_NOT_FOUND = -13011;
+  public static final int ERROR_PROJECT_NOT_FOUND = -13012;
+  public static final int ERROR_QUOTA_EXCEEDED = -13013;
+  public static final int ERROR_NOT_AUTHENTICATED = -13020;
+  public static final int ERROR_NOT_AUTHORIZED = -13021;
+  public static final int ERROR_RETRY_LIMIT_EXCEEDED = -13030;
+  public static final int ERROR_INVALID_CHECKSUM = -13031;
+  public static final int ERROR_CANCELED = -13040;
   private static final int NETWORK_UNAVAILABLE = -2;
 
   private final int errorCode;
   private final int httpResultCode;
-  private String detailMessage;
   private Throwable cause;
 
   StorageException(@ErrorCode int errorCode, Throwable inner, int httpResultCode) {
-    this.detailMessage = getErrorMessageForCode(errorCode);
+    super(getErrorMessageForCode(errorCode));
+
     this.cause = inner;
     this.errorCode = errorCode;
     this.httpResultCode = httpResultCode;
     Log.e(
         TAG,
         "StorageException has occurred.\n"
-            + detailMessage
+            + getErrorMessageForCode(errorCode)
             + "\n Code: "
-            + Integer.toString(this.errorCode)
+            + this.errorCode
             + " HttpResult: "
-            + Integer.toString(this.httpResultCode));
+            + this.httpResultCode);
     if (cause != null) {
       Log.e(TAG, cause.getMessage(), cause);
     }
@@ -96,7 +94,6 @@ private static int calculateErrorCode(@Nullable Throwable inner, int httpResultC
   }
 
   @NonNull
-  @PublicApi
   public static StorageException fromErrorStatus(@NonNull Status status) {
     Preconditions.checkNotNull(status);
     Preconditions.checkArgument(!status.isSuccess());
@@ -104,7 +101,6 @@ public static StorageException fromErrorStatus(@NonNull Status status) {
   }
 
   @Nullable
-  @PublicApi
   public static StorageException fromExceptionAndHttpCode(
       @Nullable Throwable exception, int httpResultCode) {
     if (exception instanceof StorageException) {
@@ -118,7 +114,6 @@ public static StorageException fromExceptionAndHttpCode(
   }
 
   @NonNull
-  @PublicApi
   public static StorageException fromException(@NonNull Throwable exception) {
     StorageException se = fromExceptionAndHttpCode(exception, 0);
     assert se != null;
@@ -160,19 +155,9 @@ static String getErrorMessageForCode(int errorCode) {
     }
   }
 
-  /**
-   * Returns the detail message which was provided when this {@code Throwable} was created. Returns
-   * {@code null} if no message was provided at creation time.
-   */
-  @Override
-  @PublicApi
-  public String getMessage() {
-    return detailMessage;
-  }
-
   /** Returns the cause of this {@code Throwable}, or {@code null} if there is no cause. */
+  @Nullable
   @Override
-  @PublicApi
   public synchronized Throwable getCause() {
     if (cause == this) {
       return null;
@@ -181,14 +166,12 @@ public synchronized Throwable getCause() {
   }
 
   @ErrorCode
-  @PublicApi
   public int getErrorCode() {
     return errorCode;
   }
 
   /** @return the Http result code (if one exists) from a network operation. */
   @SuppressWarnings("unused")
-  @PublicApi
   public int getHttpResultCode() {
     return httpResultCode;
   }
@@ -198,7 +181,6 @@ public int getHttpResultCode() {
    *     attempt.
    */
   @SuppressWarnings("unused")
-  @PublicApi
   public boolean getIsRecoverableException() {
     return getErrorCode() == ERROR_RETRY_LIMIT_EXCEEDED;
   }
@@ -217,6 +199,5 @@ public boolean getIsRecoverableException() {
     ERROR_INVALID_CHECKSUM,
     ERROR_CANCELED
   })
-  @PublicApi
   public @interface ErrorCode {}
 }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/StorageMetadata.java b/firebase-storage/src/main/java/com/google/firebase/storage/StorageMetadata.java
index b8cd3b951..e4c30caee 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/StorageMetadata.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/StorageMetadata.java
@@ -15,15 +15,12 @@
 package com.google.firebase.storage;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.text.TextUtils;
-import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.internal.Preconditions;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.storage.internal.Slashes;
 import com.google.firebase.storage.internal.Util;
-import java.io.UnsupportedEncodingException;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -37,7 +34,6 @@
  * content type. You may also store custom metadata key value pairs. Metadata values may be used to
  * authorize operations using declarative validation rules.
  */
-@PublicApi
 public class StorageMetadata {
   private static final String TAG = "StorageMetadata";
 
@@ -112,7 +108,6 @@ T getValue() {
       MetadataValue.withDefaultValue(Collections.emptyMap());
 
   /** Creates a {@link StorageMetadata} object to hold metadata for a {@link StorageReference} */
-  @PublicApi
   public StorageMetadata() {}
 
   private StorageMetadata(@NonNull StorageMetadata original, boolean fullClone) {
@@ -139,7 +134,7 @@ private StorageMetadata(@NonNull StorageMetadata original, boolean fullClone) {
   }
 
   /** @return the content type of the {@link StorageReference}. */
-  @PublicApi
+  @Nullable
   public String getContentType() {
     return mContentType.getValue();
   }
@@ -150,7 +145,7 @@ public String getContentType() {
    * @param key The key for which the metadata should be returned
    * @return the metadata stored in the object the given key.
    */
-  @PublicApi
+  @Nullable
   public String getCustomMetadata(@NonNull String key) {
     if (TextUtils.isEmpty(key)) {
       return null;
@@ -161,7 +156,6 @@ public String getCustomMetadata(@NonNull String key) {
 
   /** @return the keys for custom metadata. */
   @NonNull
-  @PublicApi
   public Set<String> getCustomMetadataKeys() {
     Map<String, String> metadata = mCustomMetadata.getValue();
     return metadata.keySet();
@@ -169,14 +163,12 @@ public String getCustomMetadata(@NonNull String key) {
 
   /** @return the path of the {@link StorageReference} object */
   @NonNull
-  @PublicApi
   public String getPath() {
     return mPath != null ? mPath : "";
   }
 
   /** @return a simple name of the {@link StorageReference} object */
   @Nullable
-  @PublicApi
   public String getName() {
     String path = getPath();
     if (TextUtils.isEmpty(path)) {
@@ -191,81 +183,69 @@ public String getName() {
 
   /** @return the owning Google Cloud Storage bucket for the {@link StorageReference} */
   @Nullable
-  @PublicApi
   public String getBucket() {
     return mBucket;
   }
 
   /** @return a version String indicating what version of the {@link StorageReference} */
   @Nullable
-  @PublicApi
   public String getGeneration() {
     return mGeneration;
   }
 
   /** @return a version String indicating the version of this {@link StorageMetadata} */
   @Nullable
-  @PublicApi
   public String getMetadataGeneration() {
     return mMetadataGeneration;
   }
 
   /** @return the time the {@link StorageReference} was created. */
-  @PublicApi
   public long getCreationTimeMillis() {
     return Util.parseDateTime(mCreationTime);
   }
 
   /** @return the time the {@link StorageReference} was last updated. */
-  @PublicApi
   public long getUpdatedTimeMillis() {
     return Util.parseDateTime(mUpdatedTime);
   }
 
   /** @return the stored Size in bytes of the {@link StorageReference} object */
-  @PublicApi
   public long getSizeBytes() {
     return mSize;
   }
 
   /** @return the MD5Hash of the {@link StorageReference} object */
   @Nullable
-  @PublicApi
   public String getMd5Hash() {
     return mMD5Hash;
   }
 
   /** @return the Cache Control setting of the {@link StorageReference} */
   @Nullable
-  @PublicApi
   public String getCacheControl() {
     return mCacheControl.getValue();
   }
 
   /** @return the content disposition of the {@link StorageReference} */
   @Nullable
-  @PublicApi
   public String getContentDisposition() {
     return mContentDisposition.getValue();
   }
 
   /** @return the content encoding for the {@link StorageReference} */
   @Nullable
-  @PublicApi
   public String getContentEncoding() {
     return mContentEncoding.getValue();
   }
 
   /** @return the content language for the {@link StorageReference} */
   @Nullable
-  @PublicApi
   public String getContentLanguage() {
     return mContentLanguage.getValue();
   }
 
   /** @return the associated {@link StorageReference} for which this metadata belongs to. */
   @Nullable
-  @PublicApi
   public StorageReference getReference() {
     if (mStorageRef == null) {
       if (mStorage != null) {
@@ -274,18 +254,12 @@ public StorageReference getReference() {
         if (TextUtils.isEmpty(bucket) || TextUtils.isEmpty(path)) {
           return null;
         }
-        Uri uri;
-        try {
-          uri =
-              new Uri.Builder()
-                  .scheme("gs")
-                  .authority(bucket)
-                  .encodedPath(Slashes.preserveSlashEncode(path))
-                  .build();
-        } catch (UnsupportedEncodingException e) {
-          Log.e(TAG, "Unable to create a valid default Uri. " + bucket + path, e);
-          throw new IllegalStateException(e);
-        }
+        Uri uri =
+            new Uri.Builder()
+                .scheme("gs")
+                .authority(bucket)
+                .encodedPath(Slashes.preserveSlashEncode(path))
+                .build();
 
         return new StorageReference(uri, mStorage);
       }
@@ -294,7 +268,7 @@ public StorageReference getReference() {
   }
 
   @NonNull
-  JSONObject createJSONObject() throws JSONException {
+  JSONObject createJSONObject() {
     Map<String, Object> jsonData = new HashMap<>();
 
     if (mContentType.isUserProvided()) {
@@ -320,13 +294,11 @@ JSONObject createJSONObject() throws JSONException {
   }
 
   /** Creates a StorageMetadata object. */
-  @PublicApi
   public static class Builder {
     StorageMetadata mMetadata;
     boolean mFromJSON;
 
     /** Creates an empty set of metadata. */
-    @PublicApi
     public Builder() {
       mMetadata = new StorageMetadata();
     }
@@ -336,8 +308,7 @@ public Builder() {
      *
      * @param original The source of the metadata to build from.
      */
-    @PublicApi
-    public Builder(StorageMetadata original) {
+    public Builder(@NonNull StorageMetadata original) {
       mMetadata = new StorageMetadata(original, false);
     }
 
@@ -368,11 +339,11 @@ private void parseJSON(JSONObject jsonObject) throws JSONException {
       mMetadata.mGeneration = jsonObject.optString(GENERATION_KEY);
       mMetadata.mPath = jsonObject.optString(NAME_KEY);
       mMetadata.mBucket = jsonObject.optString(BUCKET_KEY);
-      mMetadata.mMetadataGeneration = (jsonObject.optString(META_GENERATION_KEY));
-      mMetadata.mCreationTime = (jsonObject.optString(TIME_CREATED_KEY));
-      mMetadata.mUpdatedTime = (jsonObject.optString(TIME_UPDATED_KEY));
-      mMetadata.mSize = (jsonObject.optLong(SIZE_KEY));
-      mMetadata.mMD5Hash = (jsonObject.optString(MD5_HASH_KEY));
+      mMetadata.mMetadataGeneration = jsonObject.optString(META_GENERATION_KEY);
+      mMetadata.mCreationTime = jsonObject.optString(TIME_CREATED_KEY);
+      mMetadata.mUpdatedTime = jsonObject.optString(TIME_UPDATED_KEY);
+      mMetadata.mSize = jsonObject.optLong(SIZE_KEY);
+      mMetadata.mMD5Hash = jsonObject.optString(MD5_HASH_KEY);
 
       if (jsonObject.has(CUSTOM_METADATA_KEY) && !jsonObject.isNull(CUSTOM_METADATA_KEY)) {
         JSONObject customMetadata = jsonObject.getJSONObject(CUSTOM_METADATA_KEY);
@@ -400,7 +371,7 @@ private void parseJSON(JSONObject jsonObject) throws JSONException {
       }
     }
 
-    @PublicApi
+    @NonNull
     public StorageMetadata build() {
       return new StorageMetadata(mMetadata, mFromJSON);
     }
@@ -410,51 +381,77 @@ public StorageMetadata build() {
      *
      * @param contentLanguage the new content language.
      */
-    @PublicApi
+    @NonNull
     public Builder setContentLanguage(@Nullable String contentLanguage) {
       mMetadata.mContentLanguage = MetadataValue.withUserValue(contentLanguage);
       return this;
     }
 
+    /** @return the content language for the {@link StorageReference} */
+    @Nullable
+    public String getContentLanguage() {
+      return mMetadata.mContentLanguage.getValue();
+    }
+
     /**
      * Changes the content encoding for the {@link StorageReference}
      *
      * @param contentEncoding the new encoding to use.
      */
-    @PublicApi
+    @NonNull
     public Builder setContentEncoding(@Nullable String contentEncoding) {
       mMetadata.mContentEncoding = MetadataValue.withUserValue(contentEncoding);
       return this;
     }
 
+    /** @return the content encoding for the {@link StorageReference} */
+    @Nullable
+    public String getContentEncoding() {
+      return mMetadata.mContentEncoding.getValue();
+    }
+
     /**
-     * @param contentDisposition changes the content disposition for the {@link StorageReference}
+     * Changes the content disposition for the {@link StorageReference}
+     *
+     * @param contentDisposition the new content disposition to use.
      */
-    @PublicApi
+    @NonNull
     public Builder setContentDisposition(@Nullable String contentDisposition) {
       mMetadata.mContentDisposition = MetadataValue.withUserValue(contentDisposition);
       return this;
     }
 
+    /** @return the content disposition for the {@link StorageReference} */
+    @Nullable
+    public String getContentDisposition() {
+      return mMetadata.mContentDisposition.getValue();
+    }
+
     /**
-     * sets the Cache Control for the {@link StorageReference}
+     * Sets the Cache Control header for the {@link StorageReference}
      *
      * @param cacheControl the new Cache Control setting.
      */
-    @PublicApi
+    @NonNull
     public Builder setCacheControl(@Nullable String cacheControl) {
       mMetadata.mCacheControl = MetadataValue.withUserValue(cacheControl);
       return this;
     }
 
+    /** @return the Cache Control header for the {@link StorageReference} */
+    @Nullable
+    public String getCacheControl() {
+      return mMetadata.mCacheControl.getValue();
+    }
+
     /**
      * Sets custom metadata
      *
      * @param key the key of the new value
      * @param value the value to set.
      */
-    @PublicApi
-    public Builder setCustomMetadata(String key, String value) {
+    @NonNull
+    public Builder setCustomMetadata(@NonNull String key, @Nullable String value) {
       if (!mMetadata.mCustomMetadata.isUserProvided()) {
         mMetadata.mCustomMetadata = MetadataValue.withUserValue(new HashMap<>());
       }
@@ -467,10 +464,16 @@ public Builder setCustomMetadata(String key, String value) {
      *
      * @param contentType the new Content Type.
      */
-    @PublicApi
+    @NonNull
     public Builder setContentType(@Nullable String contentType) {
       mMetadata.mContentType = MetadataValue.withUserValue(contentType);
       return this;
     }
+
+    /** @return the Content Type of this associated {@link StorageReference} */
+    @Nullable
+    public String getContentType() {
+      return mMetadata.mContentType.getValue();
+    }
   }
 }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/StorageReference.java b/firebase-storage/src/main/java/com/google/firebase/storage/StorageReference.java
index 9a7068310..66c538428 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/StorageReference.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/StorageReference.java
@@ -15,10 +15,10 @@
 package com.google.firebase.storage;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.api.Status;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.tasks.Continuation;
@@ -28,13 +28,11 @@
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.android.gms.tasks.Tasks;
 import com.google.firebase.FirebaseApp;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.storage.internal.Slashes;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.List;
@@ -46,7 +44,6 @@
  * href="https://cloud.google.com/storage/">Google Cloud Storage</a>)
  */
 @SuppressWarnings("unused")
-@PublicApi
 public class StorageReference implements Comparable<StorageReference> {
   private static final String TAG = "StorageReference";
 
@@ -82,24 +79,13 @@
    * @return the child {@link StorageReference}.
    */
   @NonNull
-  @PublicApi
   public StorageReference child(@NonNull String pathString) {
     Preconditions.checkArgument(
         !TextUtils.isEmpty(pathString), "childName cannot be null or empty");
 
     pathString = Slashes.normalizeSlashes(pathString);
-    Uri child;
-    try {
-      child =
-          mStorageUri
-              .buildUpon()
-              .appendEncodedPath(Slashes.preserveSlashEncode(pathString))
-              .build();
-    } catch (UnsupportedEncodingException e) {
-      Log.e(TAG, "Unable to create a valid default Uri. " + pathString, e);
-
-      throw new IllegalArgumentException("childName");
-    }
+    Uri child =
+        mStorageUri.buildUpon().appendEncodedPath(Slashes.preserveSlashEncode(pathString)).build();
     return new StorageReference(child, mFirebaseStorage);
   }
 
@@ -116,7 +102,6 @@ public StorageReference child(@NonNull String pathString) {
    * @return the parent {@link StorageReference}.
    */
   @Nullable
-  @PublicApi
   public StorageReference getParent() {
     String path = mStorageUri.getPath();
     if (TextUtils.isEmpty(path) || path.equals("/")) {
@@ -139,7 +124,6 @@ public StorageReference getParent() {
    * @return the root {@link StorageReference}.
    */
   @NonNull
-  @PublicApi
   public StorageReference getRoot() {
     Uri child = mStorageUri.buildUpon().path("").build();
     return new StorageReference(child, mFirebaseStorage);
@@ -151,7 +135,6 @@ public StorageReference getRoot() {
    * @return the name.
    */
   @NonNull
-  @PublicApi
   public String getName() {
     String path = mStorageUri.getPath();
     assert path != null;
@@ -168,7 +151,6 @@ public String getName() {
    * @return the path.
    */
   @NonNull
-  @PublicApi
   public String getPath() {
     String path = mStorageUri.getPath();
     assert path != null;
@@ -181,7 +163,6 @@ public String getPath() {
    * @return the bucket.
    */
   @NonNull
-  @PublicApi
   public String getBucket() {
     return mStorageUri.getAuthority();
   }
@@ -192,7 +173,6 @@ public String getBucket() {
    * @return The {@link FirebaseStorage} service.
    */
   @NonNull
-  @PublicApi
   public FirebaseStorage getStorage() {
     return mFirebaseStorage;
   }
@@ -216,7 +196,6 @@ public FirebaseStorage getStorage() {
    */
   @SuppressWarnings("ConstantConditions")
   @NonNull
-  @PublicApi
   public UploadTask putBytes(@NonNull byte[] bytes) {
     Preconditions.checkArgument(bytes != null, "bytes cannot be null");
 
@@ -237,7 +216,6 @@ public UploadTask putBytes(@NonNull byte[] bytes) {
    */
   @SuppressWarnings("ConstantConditions")
   @NonNull
-  @PublicApi
   public UploadTask putBytes(@NonNull byte[] bytes, @NonNull StorageMetadata metadata) {
     Preconditions.checkArgument(bytes != null, "bytes cannot be null");
     Preconditions.checkArgument(metadata != null, "metadata cannot be null");
@@ -256,7 +234,6 @@ public UploadTask putBytes(@NonNull byte[] bytes, @NonNull StorageMetadata metad
    */
   @SuppressWarnings("ConstantConditions")
   @NonNull
-  @PublicApi
   public UploadTask putFile(@NonNull Uri uri) {
     Preconditions.checkArgument(uri != null, "uri cannot be null");
 
@@ -276,7 +253,6 @@ public UploadTask putFile(@NonNull Uri uri) {
    */
   @SuppressWarnings("ConstantConditions")
   @NonNull
-  @PublicApi
   public UploadTask putFile(@NonNull Uri uri, @NonNull StorageMetadata metadata) {
     Preconditions.checkArgument(uri != null, "uri cannot be null");
     Preconditions.checkArgument(metadata != null, "metadata cannot be null");
@@ -299,7 +275,6 @@ public UploadTask putFile(@NonNull Uri uri, @NonNull StorageMetadata metadata) {
    */
   @SuppressWarnings("ConstantConditions")
   @NonNull
-  @PublicApi
   public UploadTask putFile(
       @NonNull Uri uri, @Nullable StorageMetadata metadata, @Nullable Uri existingUploadUri) {
     Preconditions.checkArgument(uri != null, "uri cannot be null");
@@ -319,7 +294,6 @@ public UploadTask putFile(
    */
   @SuppressWarnings("ConstantConditions")
   @NonNull
-  @PublicApi
   public UploadTask putStream(@NonNull InputStream stream) {
     Preconditions.checkArgument(stream != null, "stream cannot be null");
 
@@ -339,7 +313,6 @@ public UploadTask putStream(@NonNull InputStream stream) {
    */
   @SuppressWarnings("ConstantConditions")
   @NonNull
-  @PublicApi
   public UploadTask putStream(@NonNull InputStream stream, @NonNull StorageMetadata metadata) {
     Preconditions.checkArgument(stream != null, "stream cannot be null");
     Preconditions.checkArgument(metadata != null, "metadata cannot be null");
@@ -355,14 +328,12 @@ public UploadTask putStream(@NonNull InputStream stream, @NonNull StorageMetadat
 
   /** @return the set of active upload tasks currently in progress or recently completed. */
   @NonNull
-  @PublicApi
   public List<UploadTask> getActiveUploadTasks() {
     return StorageTaskManager.getInstance().getUploadTasksUnder(this);
   }
 
   /** @return the set of active download tasks currently in progress or recently completed. */
   @NonNull
-  @PublicApi
   public List<FileDownloadTask> getActiveDownloadTasks() {
     return StorageTaskManager.getInstance().getDownloadTasksUnder(this);
   }
@@ -377,7 +348,6 @@ public UploadTask putStream(@NonNull InputStream stream, @NonNull StorageMetadat
    */
   @SuppressWarnings("deprecation")
   @NonNull
-  @PublicApi
   public Task<StorageMetadata> getMetadata() {
     TaskCompletionSource<StorageMetadata> pendingResult = new TaskCompletionSource<>();
     StorageTaskScheduler.getInstance().scheduleCommand(new GetMetadataTask(this, pendingResult));
@@ -394,7 +364,6 @@ public UploadTask putStream(@NonNull InputStream stream, @NonNull StorageMetadat
    */
   @SuppressWarnings("deprecation,unused")
   @NonNull
-  @PublicApi
   public Task<Uri> getDownloadUrl() {
     TaskCompletionSource<Uri> pendingResult = new TaskCompletionSource<>();
     StorageTaskScheduler.getInstance().scheduleCommand(new GetDownloadUrlTask(this, pendingResult));
@@ -410,7 +379,6 @@ public UploadTask putStream(@NonNull InputStream stream, @NonNull StorageMetadat
    */
   @SuppressWarnings("deprecation")
   @NonNull
-  @PublicApi
   public Task<StorageMetadata> updateMetadata(@NonNull StorageMetadata metadata) {
     Preconditions.checkNotNull(metadata);
 
@@ -436,7 +404,6 @@ public UploadTask putStream(@NonNull InputStream stream, @NonNull StorageMetadat
    */
   @SuppressWarnings("deprecation")
   @NonNull
-  @PublicApi
   public Task<byte[]> getBytes(final long maxDownloadSizeBytes) {
     final TaskCompletionSource<byte[]> pendingResult = new TaskCompletionSource<>();
 
@@ -444,7 +411,6 @@ public UploadTask putStream(@NonNull InputStream stream, @NonNull StorageMetadat
     task.setStreamProcessor(
             new StreamDownloadTask.StreamProcessor() {
               @Override
-              @PublicApi
               public void doInBackground(StreamDownloadTask.TaskSnapshot state, InputStream stream)
                   throws IOException {
                 try {
@@ -472,7 +438,6 @@ public void doInBackground(StreamDownloadTask.TaskSnapshot state, InputStream st
         .addOnSuccessListener(
             new OnSuccessListener<StreamDownloadTask.TaskSnapshot>() {
               @Override
-              @PublicApi
               public void onSuccess(StreamDownloadTask.TaskSnapshot state) {
                 if (!pendingResult.getTask().isComplete()) {
                   // something went wrong and we didn't set results, but we think it worked.
@@ -485,7 +450,6 @@ public void onSuccess(StreamDownloadTask.TaskSnapshot state) {
         .addOnFailureListener(
             new OnFailureListener() {
               @Override
-              @PublicApi
               public void onFailure(@NonNull Exception e) {
                 StorageException se = StorageException.fromExceptionAndHttpCode(e, 0);
                 assert se != null;
@@ -506,7 +470,6 @@ public void onFailure(@NonNull Exception e) {
    * @return A {@link FileDownloadTask} that can be used to monitor or manage the download.
    */
   @NonNull
-  @PublicApi
   public FileDownloadTask getFile(@NonNull Uri destinationUri) {
     FileDownloadTask task = new FileDownloadTask(this, destinationUri);
     task.queue();
@@ -521,7 +484,6 @@ public FileDownloadTask getFile(@NonNull Uri destinationUri) {
    * @return A {@link FileDownloadTask} that can be used to monitor or manage the download.
    */
   @NonNull
-  @PublicApi
   public FileDownloadTask getFile(@NonNull File destinationFile) {
     return getFile(Uri.fromFile(destinationFile));
   }
@@ -535,7 +497,6 @@ public FileDownloadTask getFile(@NonNull File destinationFile) {
    * @return A {@link FileDownloadTask} that can be used to monitor or manage the download.
    */
   @NonNull
-  @PublicApi
   public StreamDownloadTask getStream() {
     StreamDownloadTask task = new StreamDownloadTask(this);
     task.queue();
@@ -552,7 +513,6 @@ public StreamDownloadTask getStream() {
    * @return A {@link FileDownloadTask} that can be used to monitor or manage the download.
    */
   @NonNull
-  @PublicApi
   public StreamDownloadTask getStream(@NonNull StreamDownloadTask.StreamProcessor processor) {
     StreamDownloadTask task = new StreamDownloadTask(this);
     task.setStreamProcessor(processor);
@@ -569,7 +529,6 @@ public StreamDownloadTask getStream(@NonNull StreamDownloadTask.StreamProcessor
    * @return A {@link Task} that indicates whether the operation succeeded or failed.
    */
   @NonNull
-  @PublicApi
   public Task<Void> delete() {
     TaskCompletionSource<Void> pendingResult = new TaskCompletionSource<>();
     StorageTaskScheduler.getInstance().scheduleCommand(new DeleteStorageTask(this, pendingResult));
@@ -579,11 +538,11 @@ public StreamDownloadTask getStream(@NonNull StreamDownloadTask.StreamProcessor
   // region List
 
   /**
-   * List up to `maxResults` items (files) and prefixes (folders) under this StorageReference.
+   * List up to {@code maxResults} items (files) and prefixes (folders) under this StorageReference.
    *
-   * <p>"/" is treated as a path delimiter. Firebase Storage does not support unsupported object
-   * paths that end with "/" or contain two consecutive "/"s. All invalid objects in GCS will be
-   * filtered.
+   * <p>"/" is treated as a path delimiter. Cloud Storage for Firebase does not support object paths
+   * that end with "/" or contain two consecutive "/"s. All invalid objects in Google Cloud Storage
+   * will be filtered.
    *
    * <p>{@code list()} is only available for projects using <a
    * href="https://firebase.google.com/docs/rules/rules-behavior#security_rules_version_2">Firebase
@@ -595,7 +554,6 @@ public StreamDownloadTask getStream(@NonNull StreamDownloadTask.StreamProcessor
    *     StorageReference.
    */
   @NonNull
-  @PublicApi
   public Task<ListResult> list(int maxResults) {
     Preconditions.checkArgument(maxResults > 0, "maxResults must be greater than zero");
     Preconditions.checkArgument(maxResults <= 1000, "maxResults must be at most 1000");
@@ -606,9 +564,9 @@ public StreamDownloadTask getStream(@NonNull StreamDownloadTask.StreamProcessor
    * Resumes a previous call to {@link #list(int)}, starting after a pagination token. Returns the
    * next set of items (files) and prefixes (folders) under this StorageReference.
    *
-   * <p>"/" is treated as a path delimiter. Firebase Storage does not support unsupported object
-   * paths that end with "/" or contain two consecutive "/"s. All invalid objects in GCS will be
-   * filtered.
+   * <p>"/" is treated as a path delimiter. Cloud Storage for Firebase does not support object paths
+   * that end with "/" or contain two consecutive "/"s. All invalid objects in Google Cloud Storage
+   * will be filtered.
    *
    * <p>{@code list()} is only available for projects using <a
    * href="https://firebase.google.com/docs/rules/rules-behavior#security_rules_version_2">Firebase
@@ -621,7 +579,6 @@ public StreamDownloadTask getStream(@NonNull StreamDownloadTask.StreamProcessor
    *     StorageReference.
    */
   @NonNull
-  @PublicApi
   public Task<ListResult> list(int maxResults, @NonNull String pageToken) {
     Preconditions.checkArgument(maxResults > 0, "maxResults must be greater than zero");
     Preconditions.checkArgument(maxResults <= 1000, "maxResults must be at most 1000");
@@ -633,9 +590,9 @@ public StreamDownloadTask getStream(@NonNull StreamDownloadTask.StreamProcessor
   /**
    * List all items (files) and prefixes (folders) under this StorageReference.
    *
-   * <p>This is a helper method for calling list() repeatedly until there are no more results.
-   * Consistency of the result is not guaranteed if objects are inserted or removed while this
-   * operation is executing.
+   * <p>This is a helper method for calling {@code list()} repeatedly until there are no more
+   * results. Consistency of the result is not guaranteed if objects are inserted or removed while
+   * this operation is executing.
    *
    * <p>{@code listAll()} is only available for projects using <a
    * href="https://firebase.google.com/docs/rules/rules-behavior#security_rules_version_2">Firebase
@@ -645,7 +602,6 @@ public StreamDownloadTask getStream(@NonNull StreamDownloadTask.StreamProcessor
    * @return A {@link Task} that returns all items and prefixes under the current StorageReference.
    */
   @NonNull
-  @PublicApi
   public Task<ListResult> listAll() {
     TaskCompletionSource<ListResult> pendingResult = new TaskCompletionSource<>();
 
@@ -659,15 +615,20 @@ public StreamDownloadTask getStream(@NonNull StreamDownloadTask.StreamProcessor
         new Continuation<ListResult, Task<Void>>() {
           @Override
           public Task<Void> then(@NonNull Task<ListResult> currentPage) {
-            ListResult result = currentPage.getResult();
-            prefixes.addAll(result.getPrefixes());
-            items.addAll(result.getItems());
-
-            if (result.getPageToken() != null) {
-              Task<ListResult> nextPage = listHelper(/* maxResults= */ null, result.getPageToken());
-              nextPage.continueWithTask(executor, this);
+            if (currentPage.isSuccessful()) {
+              ListResult result = currentPage.getResult();
+              prefixes.addAll(result.getPrefixes());
+              items.addAll(result.getItems());
+
+              if (result.getPageToken() != null) {
+                Task<ListResult> nextPage =
+                    listHelper(/* maxResults= */ null, result.getPageToken());
+                nextPage.continueWithTask(executor, this);
+              } else {
+                pendingResult.setResult(new ListResult(prefixes, items, /* pageToken= */ null));
+              }
             } else {
-              pendingResult.setResult(new ListResult(prefixes, items, /* pageToken= */ null));
+              pendingResult.setException(currentPage.getException());
             }
 
             return Tasks.forResult(null);
@@ -720,7 +681,7 @@ public int hashCode() {
   }
 
   @Override
-  public int compareTo(StorageReference other) {
+  public int compareTo(@NonNull StorageReference other) {
     // mStorageUri contains a reference to the GCS bucket as well as the fully qualified path
     // of this reference.
     return mStorageUri.compareTo(other.mStorageUri);
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/StorageRegistrar.java b/firebase-storage/src/main/java/com/google/firebase/storage/StorageRegistrar.java
index 09aa27c5e..8bea1d1ee 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/StorageRegistrar.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/StorageRegistrar.java
@@ -14,8 +14,8 @@
 
 package com.google.firebase.storage;
 
-import android.support.annotation.Keep;
-import android.support.annotation.RestrictTo;
+import androidx.annotation.Keep;
+import androidx.annotation.RestrictTo;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.auth.internal.InternalAuthProvider;
 import com.google.firebase.components.Component;
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/StorageTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/StorageTask.java
index 8b08d3e66..c40f1c050 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/StorageTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/StorageTask.java
@@ -15,10 +15,10 @@
 package com.google.firebase.storage;
 
 import android.app.Activity;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.google.android.gms.common.api.Status;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.tasks.CancellationToken;
@@ -32,7 +32,6 @@
 import com.google.android.gms.tasks.SuccessContinuation;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
-import com.google.firebase.annotations.PublicApi;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -40,7 +39,6 @@
 
 /** A controllable Task that has a synchronized state machine. */
 @SuppressWarnings({"unused", "TypeParameterUnusedInFormals"})
-@PublicApi
 public abstract class StorageTask<ResultT extends StorageTask.ProvideError>
     extends ControllableTask<ResultT> {
   private static final String TAG = "StorageTask";
@@ -203,7 +201,6 @@ void resetState() {}
    *     unrecoverable error or has entered another state that precludes resume.
    */
   @Override
-  @PublicApi
   public boolean resume() {
     if (tryChangeState(INTERNAL_STATE_QUEUED, true)) {
       resetState();
@@ -220,7 +217,6 @@ public boolean resume() {
    *     immediately paused if it was executing another action and can still fail or complete.
    */
   @Override
-  @PublicApi
   public boolean pause() {
     return tryChangeState(new int[] {INTERNAL_STATE_PAUSED, INTERNAL_STATE_PAUSING}, true);
   }
@@ -231,42 +227,36 @@ public boolean pause() {
    * @return {@code true} if this task is successfully being canceled.
    */
   @Override
-  @PublicApi
   public boolean cancel() {
     return tryChangeState(new int[] {INTERNAL_STATE_CANCELED, INTERNAL_STATE_CANCELING}, true);
   }
 
   /** Returns {@code true} if the Task is complete; {@code false} otherwise. */
   @Override
-  @PublicApi
   public boolean isComplete() {
     return (getInternalState() & STATES_COMPLETE) != 0;
   }
 
   /** Returns {@code true} if the Task has completed successfully; {@code false} otherwise. */
   @Override
-  @PublicApi
   public boolean isSuccessful() {
     return (getInternalState() & STATES_SUCCESS) != 0;
   }
 
   /** Returns {@code true} if the task has been canceled. */
   @Override
-  @PublicApi
   public boolean isCanceled() {
     return getInternalState() == INTERNAL_STATE_CANCELED;
   }
 
   /** Returns {@code true} if the task is currently running. */
   @Override
-  @PublicApi
   public boolean isInProgress() {
     return (getInternalState() & STATES_INPROGRESS) != 0;
   }
 
   /** Returns {@code true} if the task has been paused. */
   @Override
-  @PublicApi
   public boolean isPaused() {
     return (getInternalState() & STATES_PAUSED) != 0;
   }
@@ -277,8 +267,8 @@ public boolean isPaused() {
    * @throws IllegalStateException if the Task is not yet complete
    * @throws RuntimeExecutionException if the Task failed with an exception
    */
+  @NonNull
   @Override
-  @PublicApi
   public ResultT getResult() {
     if (getFinalResult() == null) {
       throw new IllegalStateException();
@@ -297,8 +287,8 @@ public ResultT getResult() {
    * @throws X if the Task failed with an exception of type X
    * @throws RuntimeExecutionException if the Task failed with an exception that was not of type X
    */
+  @NonNull
   @Override
-  @PublicApi
   public <X extends Throwable> ResultT getResult(@NonNull Class<X> exceptionType) throws X {
     if (getFinalResult() == null) {
       throw new IllegalStateException();
@@ -319,7 +309,6 @@ public ResultT getResult() {
    */
   @Nullable
   @Override
-  @PublicApi
   public Exception getException() {
     if (getFinalResult() == null) {
       return null;
@@ -331,7 +320,7 @@ public Exception getException() {
    * Returns the current state of the task. This method will return state at any point of the tasks
    * execution and may not be the final result..
    */
-  @PublicApi
+  @NonNull
   public ResultT getSnapshot() {
     return snapState();
   }
@@ -438,22 +427,17 @@ boolean tryChangeState(int newState, boolean userInitiated) {
   }
 
   // These callbacks get executed in a synchronized block
-  @PublicApi
+
   protected void onQueued() {}
 
-  @PublicApi
   protected void onProgress() {}
 
-  @PublicApi
   protected void onPaused() {}
 
-  @PublicApi
   protected void onFailure() {}
 
-  @PublicApi
   protected void onSuccess() {}
 
-  @PublicApi
   protected void onCanceled() {}
 
   private ResultT getFinalResult() {
@@ -476,8 +460,8 @@ private ResultT getFinalResult() {
    *
    * @return this Task
    */
+  @NonNull
   @Override
-  @PublicApi
   public StorageTask<ResultT> addOnPausedListener(
       @NonNull OnPausedListener<? super ResultT> listener) {
     Preconditions.checkNotNull(listener);
@@ -491,8 +475,8 @@ private ResultT getFinalResult() {
    * @param executor the executor to use to call the listener
    * @return this Task
    */
+  @NonNull
   @Override
-  @PublicApi
   public StorageTask<ResultT> addOnPausedListener(
       @NonNull Executor executor, @NonNull OnPausedListener<? super ResultT> listener) {
     Preconditions.checkNotNull(listener);
@@ -510,8 +494,8 @@ private ResultT getFinalResult() {
    *     removed.
    * @return this Task
    */
+  @NonNull
   @Override
-  @PublicApi
   public StorageTask<ResultT> addOnPausedListener(
       @NonNull Activity activity, @NonNull OnPausedListener<? super ResultT> listener) {
     Preconditions.checkNotNull(listener);
@@ -521,7 +505,7 @@ private ResultT getFinalResult() {
   }
 
   /** Removes a listener. */
-  @PublicApi
+  @NonNull
   public StorageTask<ResultT> removeOnPausedListener(
       @NonNull OnPausedListener<? super ResultT> listener) {
     Preconditions.checkNotNull(listener);
@@ -534,8 +518,8 @@ private ResultT getFinalResult() {
    *
    * @return this Task
    */
+  @NonNull
   @Override
-  @PublicApi
   public StorageTask<ResultT> addOnProgressListener(
       @NonNull OnProgressListener<? super ResultT> listener) {
     Preconditions.checkNotNull(listener);
@@ -549,8 +533,8 @@ private ResultT getFinalResult() {
    * @param executor the executor to use to call the listener
    * @return this Task
    */
+  @NonNull
   @Override
-  @PublicApi
   public StorageTask<ResultT> addOnProgressListener(
       @NonNull Executor executor, @NonNull OnProgressListener<? super ResultT> listener) {
     Preconditions.checkNotNull(listener);
@@ -566,8 +550,8 @@ private ResultT getFinalResult() {
    *     removed.
    * @return this Task
    */
+  @NonNull
   @Override
-  @PublicApi
   public StorageTask<ResultT> addOnProgressListener(
       @NonNull Activity activity, @NonNull OnProgressListener<? super ResultT> listener) {
     Preconditions.checkNotNull(listener);
@@ -577,7 +561,7 @@ private ResultT getFinalResult() {
   }
 
   /** Removes a listener. */
-  @PublicApi
+  @NonNull
   public StorageTask<ResultT> removeOnProgressListener(
       @NonNull OnProgressListener<? super ResultT> listener) {
     Preconditions.checkNotNull(listener);
@@ -595,7 +579,6 @@ private ResultT getFinalResult() {
    */
   @Override
   @NonNull
-  @PublicApi
   public StorageTask<ResultT> addOnSuccessListener(
       @NonNull OnSuccessListener<? super ResultT> listener) {
     Preconditions.checkNotNull(listener);
@@ -617,7 +600,6 @@ private ResultT getFinalResult() {
    */
   @Override
   @NonNull
-  @PublicApi
   public StorageTask<ResultT> addOnSuccessListener(
       @NonNull Executor executor, @NonNull OnSuccessListener<? super ResultT> listener) {
     Preconditions.checkNotNull(executor);
@@ -641,7 +623,6 @@ private ResultT getFinalResult() {
    */
   @Override
   @NonNull
-  @PublicApi
   public StorageTask<ResultT> addOnSuccessListener(
       @NonNull Activity activity, @NonNull OnSuccessListener<? super ResultT> listener) {
     Preconditions.checkNotNull(activity);
@@ -651,7 +632,7 @@ private ResultT getFinalResult() {
   }
 
   /** Removes a listener. */
-  @PublicApi
+  @NonNull
   public StorageTask<ResultT> removeOnSuccessListener(
       @NonNull OnSuccessListener<? super ResultT> listener) {
     Preconditions.checkNotNull(listener);
@@ -672,7 +653,6 @@ private ResultT getFinalResult() {
    */
   @Override
   @NonNull
-  @PublicApi
   public StorageTask<ResultT> addOnFailureListener(@NonNull OnFailureListener listener) {
     Preconditions.checkNotNull(listener);
     failureManager.addListener(null, null, listener);
@@ -692,7 +672,6 @@ private ResultT getFinalResult() {
    */
   @Override
   @NonNull
-  @PublicApi
   public StorageTask<ResultT> addOnFailureListener(
       @NonNull Executor executor, @NonNull OnFailureListener listener) {
     Preconditions.checkNotNull(listener);
@@ -716,7 +695,6 @@ private ResultT getFinalResult() {
    */
   @Override
   @NonNull
-  @PublicApi
   public StorageTask<ResultT> addOnFailureListener(
       @NonNull Activity activity, @NonNull OnFailureListener listener) {
     Preconditions.checkNotNull(listener);
@@ -727,7 +705,7 @@ private ResultT getFinalResult() {
   }
 
   /** Removes a listener. */
-  @PublicApi
+  @NonNull
   public StorageTask<ResultT> removeOnFailureListener(@NonNull OnFailureListener listener) {
     Preconditions.checkNotNull(listener);
     failureManager.removeListener(listener);
@@ -747,7 +725,6 @@ private ResultT getFinalResult() {
    */
   @Override
   @NonNull
-  @PublicApi
   public StorageTask<ResultT> addOnCompleteListener(@NonNull OnCompleteListener<ResultT> listener) {
     Preconditions.checkNotNull(listener);
     completeListener.addListener(null, null, listener);
@@ -767,7 +744,6 @@ private ResultT getFinalResult() {
    */
   @Override
   @NonNull
-  @PublicApi
   public StorageTask<ResultT> addOnCompleteListener(
       @NonNull Executor executor, @NonNull OnCompleteListener<ResultT> listener) {
     Preconditions.checkNotNull(listener);
@@ -790,7 +766,6 @@ private ResultT getFinalResult() {
    */
   @Override
   @NonNull
-  @PublicApi
   public StorageTask<ResultT> addOnCompleteListener(
       @NonNull Activity activity, @NonNull OnCompleteListener<ResultT> listener) {
     Preconditions.checkNotNull(listener);
@@ -801,7 +776,7 @@ private ResultT getFinalResult() {
   }
 
   /** Removes a listener. */
-  @PublicApi
+  @NonNull
   public StorageTask<ResultT> removeOnCompleteListener(
       @NonNull OnCompleteListener<ResultT> listener) {
     Preconditions.checkNotNull(listener);
@@ -820,7 +795,6 @@ private ResultT getFinalResult() {
    */
   @NonNull
   @Override
-  @PublicApi
   public StorageTask<ResultT> addOnCanceledListener(@NonNull OnCanceledListener listener) {
     Preconditions.checkNotNull(listener);
     cancelManager.addListener(null, null, listener);
@@ -838,7 +812,6 @@ private ResultT getFinalResult() {
    */
   @NonNull
   @Override
-  @PublicApi
   public StorageTask<ResultT> addOnCanceledListener(
       @NonNull Executor executor, @NonNull OnCanceledListener listener) {
     Preconditions.checkNotNull(listener);
@@ -860,7 +833,6 @@ private ResultT getFinalResult() {
    */
   @NonNull
   @Override
-  @PublicApi
   public StorageTask<ResultT> addOnCanceledListener(
       @NonNull Activity activity, @NonNull OnCanceledListener listener) {
     Preconditions.checkNotNull(listener);
@@ -870,7 +842,7 @@ private ResultT getFinalResult() {
   }
 
   /** Removes a listener. */
-  @PublicApi
+  @NonNull
   public StorageTask<ResultT> removeOnCanceledListener(@NonNull OnCanceledListener listener) {
     Preconditions.checkNotNull(listener);
     cancelManager.removeListener(listener);
@@ -887,7 +859,6 @@ private ResultT getFinalResult() {
    */
   @NonNull
   @Override
-  @PublicApi
   public <ContinuationResultT> Task<ContinuationResultT> continueWith(
       @NonNull Continuation<ResultT, ContinuationResultT> continuation) {
     return continueWithImpl(null, continuation);
@@ -902,7 +873,6 @@ private ResultT getFinalResult() {
    */
   @NonNull
   @Override
-  @PublicApi
   public <ContinuationResultT> Task<ContinuationResultT> continueWith(
       @NonNull final Executor executor,
       @NonNull final Continuation<ResultT, ContinuationResultT> continuation) {
@@ -950,7 +920,6 @@ private ResultT getFinalResult() {
    */
   @NonNull
   @Override
-  @PublicApi
   public <ContinuationResultT> Task<ContinuationResultT> continueWithTask(
       @NonNull Continuation<ResultT, Task<ContinuationResultT>> continuation) {
     return continueWithTaskImpl(null, continuation);
@@ -965,7 +934,6 @@ private ResultT getFinalResult() {
    */
   @NonNull
   @Override
-  @PublicApi
   public <ContinuationResultT> Task<ContinuationResultT> continueWithTask(
       @NonNull final Executor executor,
       @NonNull final Continuation<ResultT, Task<ContinuationResultT>> continuation) {
@@ -986,7 +954,6 @@ private ResultT getFinalResult() {
    */
   @NonNull
   @Override
-  @PublicApi
   public <ContinuationResultT> Task<ContinuationResultT> onSuccessTask(
       @NonNull SuccessContinuation<ResultT, ContinuationResultT> continuation) {
     return successTaskImpl(null, continuation);
@@ -1005,7 +972,6 @@ private ResultT getFinalResult() {
    */
   @NonNull
   @Override
-  @PublicApi
   public <ContinuationResultT> Task<ContinuationResultT> onSuccessTask(
       @NonNull Executor executor,
       @NonNull SuccessContinuation<ResultT, ContinuationResultT> continuation) {
@@ -1166,12 +1132,10 @@ private String getStateString(int state) {
   }
 
   /** Base class for state. */
-  @PublicApi
   public class SnapshotBase implements StorageTask.ProvideError {
     private final Exception error;
 
-    @PublicApi
-    public SnapshotBase(Exception error) {
+    public SnapshotBase(@Nullable Exception error) {
       if (error == null) {
         if (isCanceled()) {
           // give the developer a canceled exception.
@@ -1189,14 +1153,12 @@ public SnapshotBase(Exception error) {
 
     /** Returns the {@link StorageTask} for this state. */
     @NonNull
-    @PublicApi
     public StorageTask<ResultT> getTask() {
       return StorageTask.this;
     }
 
     /** Returns the target of the upload. */
     @NonNull
-    @PublicApi
     public StorageReference getStorage() {
       return getTask().getStorage();
     }
@@ -1204,7 +1166,6 @@ public StorageReference getStorage() {
     /** Returns the last error encountered. */
     @Override
     @Nullable
-    @PublicApi
     public Exception getError() {
       return error;
     }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/StorageTaskManager.java b/firebase-storage/src/main/java/com/google/firebase/storage/StorageTaskManager.java
index 55c846288..8a89deb37 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/StorageTaskManager.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/StorageTaskManager.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.storage;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -32,7 +32,7 @@
 /*package*/ class StorageTaskManager {
   private static final StorageTaskManager _instance = new StorageTaskManager();
 
-  private final Map<String, WeakReference<StorageTask>> inProgressTasks = new HashMap<>();
+  private final Map<String, WeakReference<StorageTask<?>>> inProgressTasks = new HashMap<>();
 
   private final Object syncObject = new Object();
 
@@ -44,9 +44,9 @@ static StorageTaskManager getInstance() {
     synchronized (syncObject) {
       ArrayList<UploadTask> inProgressList = new ArrayList<>();
       String parentPath = parent.toString();
-      for (Map.Entry<String, WeakReference<StorageTask>> entry : inProgressTasks.entrySet()) {
+      for (Map.Entry<String, WeakReference<StorageTask<?>>> entry : inProgressTasks.entrySet()) {
         if (entry.getKey().startsWith(parentPath)) {
-          StorageTask task = entry.getValue().get();
+          StorageTask<?> task = entry.getValue().get();
           if (task instanceof UploadTask) {
             inProgressList.add((UploadTask) task);
           }
@@ -60,9 +60,9 @@ static StorageTaskManager getInstance() {
     synchronized (syncObject) {
       ArrayList<FileDownloadTask> inProgressList = new ArrayList<>();
       String parentPath = parent.toString();
-      for (Map.Entry<String, WeakReference<StorageTask>> entry : inProgressTasks.entrySet()) {
+      for (Map.Entry<String, WeakReference<StorageTask<?>>> entry : inProgressTasks.entrySet()) {
         if (entry.getKey().startsWith(parentPath)) {
-          StorageTask task = entry.getValue().get();
+          StorageTask<?> task = entry.getValue().get();
           if (task instanceof FileDownloadTask) {
             inProgressList.add((FileDownloadTask) task);
           }
@@ -72,19 +72,19 @@ static StorageTaskManager getInstance() {
     }
   }
 
-  public void ensureRegistered(StorageTask targetTask) {
+  public void ensureRegistered(StorageTask<?> targetTask) {
     synchronized (syncObject) {
       // ensure *this* is added to the in progress list
       inProgressTasks.put(targetTask.getStorage().toString(), new WeakReference<>(targetTask));
     }
   }
 
-  public void unRegister(StorageTask targetTask) {
+  public void unRegister(StorageTask<?> targetTask) {
     synchronized (syncObject) {
       // ensure *this* is added to the in progress list
       String key = targetTask.getStorage().toString();
-      WeakReference<StorageTask> weakReference = inProgressTasks.get(key);
-      StorageTask task = weakReference != null ? weakReference.get() : null;
+      WeakReference<StorageTask<?>> weakReference = inProgressTasks.get(key);
+      StorageTask<?> task = weakReference != null ? weakReference.get() : null;
       if (task == null || task == targetTask) {
         inProgressTasks.remove(key);
       }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/StorageTaskScheduler.java b/firebase-storage/src/main/java/com/google/firebase/storage/StorageTaskScheduler.java
index b68b2f4ca..27f0da2f6 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/StorageTaskScheduler.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/StorageTaskScheduler.java
@@ -14,8 +14,8 @@
 
 package com.google.firebase.storage;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.RestrictTo;
+import androidx.annotation.NonNull;
+import androidx.annotation.RestrictTo;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Executor;
 import java.util.concurrent.LinkedBlockingQueue;
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/StreamDownloadTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/StreamDownloadTask.java
index 5b11fb988..59abe3d83 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/StreamDownloadTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/StreamDownloadTask.java
@@ -14,15 +14,14 @@
 
 package com.google.firebase.storage;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.api.Status;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.tasks.OnFailureListener;
 import com.google.android.gms.tasks.OnSuccessListener;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.storage.internal.ExponentialBackoffSender;
 import com.google.firebase.storage.network.GetNetworkRequest;
 import com.google.firebase.storage.network.NetworkRequest;
@@ -34,28 +33,27 @@
 
 /** A task that downloads bytes of a GCS blob. */
 @SuppressWarnings("unused")
-@PublicApi
 public class StreamDownloadTask extends StorageTask<StreamDownloadTask.TaskSnapshot> {
   static final long PREFERRED_CHUNK_SIZE = 256 * 1024;
   private static final String TAG = "StreamDownloadTask";
-  private StorageReference mStorageRef;
-  private ExponentialBackoffSender mSender;
-  private volatile Exception mException = null;
-  private volatile int mResultCode = 0;
-  private StreamProcessor mProcessor;
-
-  private long mTotalBytes = -1;
-  private long mBytesDownloaded;
-  private long mBytesDownloadedSnapped;
-  private InputStream mInputStream;
-  private NetworkRequest mRequest;
-  private String mETagVerification;
+  private StorageReference storageRef;
+  private ExponentialBackoffSender sender;
+  private volatile Exception exception = null;
+  private volatile int resultCode = 0;
+  private StreamProcessor processor;
+
+  private long totalBytes = -1;
+  private long bytesDownloaded;
+  private long bytesDownloadedSnapped;
+  private InputStream inputStream;
+  private NetworkRequest request;
+  private String eTagVerification;
 
   /*package*/ StreamDownloadTask(@NonNull StorageReference storageRef) {
-    mStorageRef = storageRef;
+    this.storageRef = storageRef;
 
-    FirebaseStorage storage = mStorageRef.getStorage();
-    mSender =
+    FirebaseStorage storage = this.storageRef.getStorage();
+    sender =
         new ExponentialBackoffSender(
             storage.getApp().getApplicationContext(),
             storage.getAuthProvider(),
@@ -71,8 +69,8 @@
    */
   /*package*/ StreamDownloadTask setStreamProcessor(@NonNull StreamProcessor processor) {
     Preconditions.checkNotNull(processor);
-    Preconditions.checkState(mProcessor == null);
-    this.mProcessor = processor;
+    Preconditions.checkState(this.processor == null);
+    this.processor = processor;
     return this;
   }
 
@@ -80,7 +78,7 @@
   @Override
   @NonNull
   /*package*/ StorageReference getStorage() {
-    return mStorageRef;
+    return storageRef;
   }
 
   /**
@@ -89,16 +87,16 @@
    */
   @SuppressWarnings("unused")
   /*package*/ long getTotalBytes() {
-    return mTotalBytes;
+    return totalBytes;
   }
 
   void recordDownloadedBytes(long bytesDownloaded) {
-    mBytesDownloaded += bytesDownloaded;
-    if (mBytesDownloadedSnapped + PREFERRED_CHUNK_SIZE <= mBytesDownloaded) {
+    this.bytesDownloaded += bytesDownloaded;
+    if (bytesDownloadedSnapped + PREFERRED_CHUNK_SIZE <= this.bytesDownloaded) {
       if (getInternalState() == INTERNAL_STATE_IN_PROGRESS) {
         tryChangeState(INTERNAL_STATE_IN_PROGRESS, false);
       } else {
-        mBytesDownloadedSnapped = mBytesDownloaded;
+        bytesDownloadedSnapped = this.bytesDownloaded;
       }
     }
   }
@@ -112,37 +110,37 @@ protected void schedule() {
 
   @SuppressWarnings({"JavaDoc", "ThrowableResultOfMethodCallIgnored"})
   private InputStream createDownloadStream() throws Exception {
-    mSender.reset();
+    sender.reset();
 
-    if (mRequest != null) {
-      mRequest.performRequestEnd();
+    if (request != null) {
+      request.performRequestEnd();
     }
 
-    mRequest =
-        new GetNetworkRequest(mStorageRef.getStorageUri(), mStorageRef.getApp(), mBytesDownloaded);
+    request =
+        new GetNetworkRequest(storageRef.getStorageUri(), storageRef.getApp(), bytesDownloaded);
 
-    mSender.sendWithExponentialBackoff(mRequest, false);
-    mResultCode = mRequest.getResultCode();
-    mException = mRequest.getException() != null ? mRequest.getException() : mException;
+    sender.sendWithExponentialBackoff(request, false);
+    resultCode = request.getResultCode();
+    exception = request.getException() != null ? request.getException() : exception;
     boolean success =
-        isValidHttpResponseCode(mResultCode)
-            && mException == null
+        isValidHttpResponseCode(resultCode)
+            && exception == null
             && getInternalState() == INTERNAL_STATE_IN_PROGRESS;
 
     if (success) {
-      String newEtag = mRequest.getResultString("ETag");
+      String newEtag = request.getResultString("ETag");
       if (!TextUtils.isEmpty(newEtag)
-          && mETagVerification != null
-          && !mETagVerification.equals(newEtag)) {
-        mResultCode = HttpURLConnection.HTTP_CONFLICT;
+          && eTagVerification != null
+          && !eTagVerification.equals(newEtag)) {
+        resultCode = HttpURLConnection.HTTP_CONFLICT;
         throw new IOException("The ETag on the server changed.");
       }
 
-      mETagVerification = newEtag;
-      if (mTotalBytes == -1) {
-        mTotalBytes = mRequest.getResultingContentLength();
+      eTagVerification = newEtag;
+      if (totalBytes == -1) {
+        totalBytes = request.getResultingContentLength();
       }
-      return mRequest.getStream();
+      return request.getStream();
     } else {
       throw new IOException("Could not open resulting stream.");
     }
@@ -152,7 +150,7 @@ private InputStream createDownloadStream() throws Exception {
   @SuppressWarnings({"JavaDoc", "ThrowableResultOfMethodCallIgnored"})
   @Override
   /*package*/ void run() {
-    if (mException != null) {
+    if (exception != null) {
       tryChangeState(INTERNAL_STATE_FAILURE, false);
       return;
     }
@@ -170,31 +168,31 @@ public InputStream call() throws Exception {
               }
             },
             StreamDownloadTask.this);
-    mInputStream = new BufferedInputStream(streamWrapper);
+    inputStream = new BufferedInputStream(streamWrapper);
 
     try {
       // Open stream to fetch initial state.
       streamWrapper.ensureStream();
 
-      if (mProcessor != null) {
+      if (processor != null) {
         try {
-          mProcessor.doInBackground(snapState(), mInputStream);
+          processor.doInBackground(snapState(), inputStream);
         } catch (Exception e) {
           Log.w(TAG, "Exception occurred calling doInBackground.", e);
-          mException = e;
+          exception = e;
         }
       }
     } catch (IOException e) {
       Log.d(TAG, "Initial opening of Stream failed", e);
-      mException = e;
+      exception = e;
     }
 
-    if (mInputStream == null) {
-      mRequest.performRequestEnd();
-      mRequest = null;
+    if (inputStream == null) {
+      request.performRequestEnd();
+      request = null;
     }
 
-    boolean success = mException == null && getInternalState() == INTERNAL_STATE_IN_PROGRESS;
+    boolean success = exception == null && getInternalState() == INTERNAL_STATE_IN_PROGRESS;
 
     if (success) {
       tryChangeState(INTERNAL_STATE_IN_PROGRESS, false);
@@ -228,19 +226,18 @@ public boolean pause() {
   @Override
   TaskSnapshot snapStateImpl() {
     return new TaskSnapshot(
-        StorageException.fromExceptionAndHttpCode(mException, mResultCode),
-        mBytesDownloadedSnapped);
+        StorageException.fromExceptionAndHttpCode(exception, resultCode), bytesDownloadedSnapped);
   }
 
   @Override
   protected void onCanceled() {
-    mSender.cancel();
-    mException = StorageException.fromErrorStatus(Status.RESULT_CANCELED);
+    sender.cancel();
+    exception = StorageException.fromErrorStatus(Status.RESULT_CANCELED);
   }
 
   @Override
   protected void onProgress() {
-    mBytesDownloadedSnapped = mBytesDownloaded;
+    bytesDownloadedSnapped = bytesDownloaded;
   }
 
   private boolean isValidHttpResponseCode(int code) {
@@ -248,7 +245,6 @@ private boolean isValidHttpResponseCode(int code) {
   }
 
   /** A callback that is used to handle the stream download */
-  @PublicApi
   public interface StreamProcessor {
     /**
      * doInBackground gets called on a background thread and should process the input stream to load
@@ -259,7 +255,8 @@ private boolean isValidHttpResponseCode(int code) {
      * @param stream the {@link InputStream} for the downloaded bytes.
      * @throws IOException may be thrown to cancel the operation.
      */
-    void doInBackground(TaskSnapshot state, InputStream stream) throws IOException;
+    void doInBackground(@NonNull TaskSnapshot state, @NonNull InputStream stream)
+        throws IOException;
   }
 
   static class StreamProgressWrapper extends InputStream {
@@ -339,7 +336,6 @@ private boolean ensureStream() throws IOException {
     }
 
     @Override
-    @PublicApi
     public int read() throws IOException {
       while (ensureStream()) {
         try {
@@ -357,7 +353,6 @@ public int read() throws IOException {
     }
 
     @Override
-    @PublicApi
     public int available() throws IOException {
       while (ensureStream()) {
         try {
@@ -371,32 +366,28 @@ public int available() throws IOException {
     }
 
     @Override
-    @PublicApi
     public void close() throws IOException {
       if (mWrappedStream != null) {
         mWrappedStream.close();
       }
       mStreamClosed = true;
-      if (mParentTask != null && mParentTask.mRequest != null) {
-        mParentTask.mRequest.performRequestEnd();
-        mParentTask.mRequest = null;
+      if (mParentTask != null && mParentTask.request != null) {
+        mParentTask.request.performRequestEnd();
+        mParentTask.request = null;
       }
 
       checkCancel();
     }
 
     @Override
-    @PublicApi
     public void mark(int readlimit) {}
 
     @Override
-    @PublicApi
     public boolean markSupported() {
       return false;
     }
 
     @Override
-    @PublicApi
     public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
       int bytesRead = 0;
       while (ensureStream()) {
@@ -435,7 +426,6 @@ public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IO
     }
 
     @Override
-    @PublicApi
     public long skip(long byteCount) throws IOException {
       long bytesSkipped = 0;
 
@@ -473,7 +463,6 @@ public long skip(long byteCount) throws IOException {
   }
 
   /** Encapsulates state about the running {@link StreamDownloadTask} */
-  @PublicApi
   public class TaskSnapshot extends StorageTask<StreamDownloadTask.TaskSnapshot>.SnapshotBase {
     private final long mBytesDownloaded;
 
@@ -488,13 +477,11 @@ public long skip(long byteCount) throws IOException {
     }
 
     /** @return the total bytes downloaded so far. */
-    @PublicApi
     public long getBytesTransferred() {
       return mBytesDownloaded;
     }
 
     /** @return the total bytes of the download. */
-    @PublicApi
     public long getTotalByteCount() {
       return StreamDownloadTask.this.getTotalBytes();
     }
@@ -504,9 +491,9 @@ public long getTotalByteCount() {
      *     closed either in {@link StreamProcessor#doInBackground(TaskSnapshot, InputStream)} or in
      *     {@link OnSuccessListener}, {@link OnFailureListener}
      */
-    @PublicApi
+    @NonNull
     public InputStream getStream() {
-      return StreamDownloadTask.this.mInputStream;
+      return StreamDownloadTask.this.inputStream;
     }
   }
 }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/TaskListenerImpl.java b/firebase-storage/src/main/java/com/google/firebase/storage/TaskListenerImpl.java
index 15391ce6b..a852320a9 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/TaskListenerImpl.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/TaskListenerImpl.java
@@ -16,10 +16,9 @@
 
 import android.app.Activity;
 import android.os.Build;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.internal.Preconditions;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.storage.internal.ActivityLifecycleListener;
 import com.google.firebase.storage.internal.SmartHandler;
 import java.util.HashMap;
@@ -29,7 +28,7 @@
 
 /** Helper class to manage listener subscriptions on executor/activity. */
 /*package*/
-@PublicApi
+
 class TaskListenerImpl<ListenerTypeT, ResultT extends StorageTask.ProvideError> {
   private final Queue<ListenerTypeT> listenerQueue = new ConcurrentLinkedQueue<>();
   private final HashMap<ListenerTypeT, SmartHandler> handlerMap = new HashMap<>();
@@ -37,7 +36,6 @@
   private int targetStates;
   private OnRaise<ListenerTypeT, ResultT> onRaise;
 
-  @PublicApi
   public TaskListenerImpl(
       @NonNull StorageTask<ResultT> task,
       int targetInternalStates,
@@ -52,7 +50,6 @@ public int getListenerCount() {
     return Math.max(listenerQueue.size(), handlerMap.size());
   }
 
-  @PublicApi
   public void addListener(
       @Nullable Activity activity,
       @Nullable Executor executor,
@@ -83,7 +80,6 @@ public void addListener(
     }
   }
 
-  @PublicApi
   public void onInternalStateChanged() {
     if ((task.getInternalState() & targetStates) != 0) {
       final ResultT snappedState = task.snapState();
@@ -98,7 +94,6 @@ public void onInternalStateChanged() {
   }
 
   /** Removes a listener. */
-  @PublicApi
   public void removeListener(@NonNull ListenerTypeT listener) {
     Preconditions.checkNotNull(listener);
 
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/UpdateMetadataTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/UpdateMetadataTask.java
index 451428f68..f71bdeaf7 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/UpdateMetadataTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/UpdateMetadataTask.java
@@ -14,8 +14,8 @@
 
 package com.google.firebase.storage;
 
-import android.support.annotation.NonNull;
 import android.util.Log;
+import androidx.annotation.NonNull;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.firebase.storage.internal.ExponentialBackoffSender;
 import com.google.firebase.storage.network.NetworkRequest;
@@ -50,17 +50,9 @@ public UpdateMetadataTask(
 
   @Override
   public void run() {
-    final NetworkRequest request;
-    try {
-      request =
-          new UpdateMetadataNetworkRequest(
-              mStorageRef.getStorageUri(), mStorageRef.getApp(), mNewMetadata.createJSONObject());
-    } catch (final JSONException e) {
-      Log.e(TAG, "Unable to create the request from metadata.", e);
-
-      mPendingResult.setException(StorageException.fromException(e));
-      return;
-    }
+    final NetworkRequest request =
+        new UpdateMetadataNetworkRequest(
+            mStorageRef.getStorageUri(), mStorageRef.getApp(), mNewMetadata.createJSONObject());
 
     mSender.sendWithExponentialBackoff(request);
     if (request.isResultSuccess()) {
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/UploadTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/UploadTask.java
index 9a76e0fd3..45eda3c84 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/UploadTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/UploadTask.java
@@ -18,14 +18,13 @@
 import android.content.Context;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
 import android.text.TextUtils;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.google.android.gms.common.api.Status;
 import com.google.android.gms.common.internal.Preconditions;
-import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.auth.internal.InternalAuthProvider;
 import com.google.firebase.storage.internal.AdaptiveStreamBuffer;
 import com.google.firebase.storage.internal.ExponentialBackoffSender;
@@ -48,7 +47,6 @@
  * allows pause and resume to control the upload operation.
  */
 @SuppressWarnings("unused")
-@PublicApi
 public class UploadTask extends StorageTask<UploadTask.TaskSnapshot> {
   @VisibleForTesting static final int PREFERRED_CHUNK_SIZE = 256 * 1024; // 256 KB
   private static final int MAXIMUM_CHUNK_SIZE = 32 * 1024 * 1024; // 32 MB
@@ -260,19 +258,12 @@ private void beginResumableUpload() {
     if (TextUtils.isEmpty(mimeType)) {
       mimeType = APPLICATION_OCTET_STREAM;
     }
-    NetworkRequest startRequest;
-    try {
-      startRequest =
-          new ResumableUploadStartRequest(
-              mStorageRef.getStorageUri(),
-              mStorageRef.getApp(),
-              mMetadata != null ? mMetadata.createJSONObject() : null,
-              mimeType);
-    } catch (JSONException e) {
-      Log.e(TAG, "Unable to create a network request from metadata", e);
-      mException = e;
-      return;
-    }
+    NetworkRequest startRequest =
+        new ResumableUploadStartRequest(
+            mStorageRef.getStorageUri(),
+            mStorageRef.getApp(),
+            mMetadata != null ? mMetadata.createJSONObject() : null,
+            mimeType);
 
     if (!sendWithRetry(startRequest)) {
       return;
@@ -354,7 +345,7 @@ private boolean serverStateValid() {
   private boolean recoverStatus(boolean withRetry) {
     NetworkRequest queryRequest =
         new ResumableUploadQueryRequest(
-            mStorageRef.getStorageUri(), mStorageRef.getApp(), mUploadUri.toString());
+            mStorageRef.getStorageUri(), mStorageRef.getApp(), mUploadUri);
 
     if (RESUMABLE_FINAL_STATUS.equals(mServerStatus)) {
       return false;
@@ -420,7 +411,7 @@ private void uploadChunk() {
           new ResumableUploadByteRequest(
               mStorageRef.getStorageUri(),
               mStorageRef.getApp(),
-              mUploadUri.toString(),
+              mUploadUri,
               mStreamBuffer.get(),
               mBytesUploaded.get(),
               bytesToUpload,
@@ -493,7 +484,7 @@ protected void onCanceled() {
     if (mUploadUri != null) {
       cancelRequest =
           new ResumableUploadCancelRequest(
-              mStorageRef.getStorageUri(), mStorageRef.getApp(), mUploadUri.toString());
+              mStorageRef.getStorageUri(), mStorageRef.getApp(), mUploadUri);
     }
 
     if (cancelRequest != null) {
@@ -526,7 +517,6 @@ public void run() {
   }
 
   /** Encapsulates state about the running {@link UploadTask} */
-  @PublicApi
   public class TaskSnapshot extends StorageTask<UploadTask.TaskSnapshot>.SnapshotBase {
     private final long mBytesUploaded;
     private final Uri mUploadUri;
@@ -546,13 +536,11 @@ public void run() {
     }
 
     /** @return the total bytes uploaded so far. */
-    @PublicApi
     public long getBytesTransferred() {
       return mBytesUploaded;
     }
 
     /** @return The number of bytes to upload. Will return -1 if uploading from a stream. */
-    @PublicApi
     public long getTotalByteCount() {
       return UploadTask.this.getTotalByteCount();
     }
@@ -563,7 +551,6 @@ public long getTotalByteCount() {
      *     StorageMetadata, Uri)}
      */
     @Nullable
-    @PublicApi
     public Uri getUploadSessionUri() {
       return mUploadUri;
     }
@@ -573,7 +560,6 @@ public Uri getUploadSessionUri() {
      *     Metadata which will include the upload URL.
      */
     @Nullable
-    @PublicApi
     public StorageMetadata getMetadata() {
       return mMetadata;
     }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/internal/ActivityLifecycleListener.java b/firebase-storage/src/main/java/com/google/firebase/storage/internal/ActivityLifecycleListener.java
index 277745201..16e217609 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/internal/ActivityLifecycleListener.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/internal/ActivityLifecycleListener.java
@@ -15,9 +15,9 @@
 package com.google.firebase.storage.internal;
 
 import android.app.Activity;
-import android.support.annotation.MainThread;
-import android.support.annotation.NonNull;
 import android.util.Log;
+import androidx.annotation.MainThread;
+import androidx.annotation.NonNull;
 import com.google.android.gms.common.api.internal.LifecycleActivity;
 import com.google.android.gms.common.api.internal.LifecycleCallback;
 import com.google.android.gms.common.api.internal.LifecycleFragment;
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/internal/ExponentialBackoffSender.java b/firebase-storage/src/main/java/com/google/firebase/storage/internal/ExponentialBackoffSender.java
index 820ba5527..4d2ff798c 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/internal/ExponentialBackoffSender.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/internal/ExponentialBackoffSender.java
@@ -15,9 +15,9 @@
 package com.google.firebase.storage.internal;
 
 import android.content.Context;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.common.util.Clock;
 import com.google.android.gms.common.util.DefaultClock;
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/internal/Slashes.java b/firebase-storage/src/main/java/com/google/firebase/storage/internal/Slashes.java
index f2852a48c..b45767ebc 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/internal/Slashes.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/internal/Slashes.java
@@ -15,11 +15,10 @@
 package com.google.firebase.storage.internal;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.internal.Preconditions;
-import java.io.UnsupportedEncodingException;
 
 /**
  * Utility methods for Firebase Storage.
@@ -34,10 +33,9 @@
    *
    * @param s The String to convert
    * @return A partially URL encoded string where slashes are preserved.
-   * @throws UnsupportedEncodingException
    */
   @NonNull
-  public static String preserveSlashEncode(@Nullable String s) throws UnsupportedEncodingException {
+  public static String preserveSlashEncode(@Nullable String s) {
     if (TextUtils.isEmpty(s)) {
       return "";
     }
@@ -56,18 +54,6 @@ public static String slashize(@NonNull String s) {
     return s.replace("%2F", "/");
   }
 
-  /**
-   * URL Encodes slashes (only) within a string.
-   *
-   * @param s The String to change
-   * @return A modified string that replaces slashes with their escape codes.
-   */
-  @NonNull
-  public static String unSlashize(@NonNull String s) {
-    Preconditions.checkNotNull(s);
-    return s.replace("/", "%2F");
-  }
-
   @NonNull
   @SuppressWarnings("StringSplitter")
   public static String normalizeSlashes(@NonNull String uriSegment) {
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/internal/SmartHandler.java b/firebase-storage/src/main/java/com/google/firebase/storage/internal/SmartHandler.java
index fe34b99e3..1b3d4a786 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/internal/SmartHandler.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/internal/SmartHandler.java
@@ -16,8 +16,8 @@
 
 import android.os.Handler;
 import android.os.Looper;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.firebase.storage.StorageTaskScheduler;
 import java.util.concurrent.Executor;
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/internal/Util.java b/firebase-storage/src/main/java/com/google/firebase/storage/internal/Util.java
index d6b42d6bc..45d70c47a 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/internal/Util.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/internal/Util.java
@@ -16,10 +16,10 @@
 
 import android.net.Uri;
 import android.os.RemoteException;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.internal.Objects;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.tasks.Task;
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/internal/package-info.java b/firebase-storage/src/main/java/com/google/firebase/storage/internal/package-info.java
index cd3f36cc0..79d434593 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/internal/package-info.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/internal/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.storage.internal;
 
-import android.support.annotation.RestrictTo;
\ No newline at end of file
+import androidx.annotation.RestrictTo;
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/DeleteNetworkRequest.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/DeleteNetworkRequest.java
index 4c276a7aa..3249f3f85 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/DeleteNetworkRequest.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/DeleteNetworkRequest.java
@@ -15,7 +15,7 @@
 package com.google.firebase.storage.network;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.google.firebase.FirebaseApp;
 
 /** A network request that deletes a gcs object. */
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/GetMetadataNetworkRequest.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/GetMetadataNetworkRequest.java
index bc9af71c7..cd54c2d65 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/GetMetadataNetworkRequest.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/GetMetadataNetworkRequest.java
@@ -15,7 +15,7 @@
 package com.google.firebase.storage.network;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.google.firebase.FirebaseApp;
 
 /** A network request that returns metadata on a gcs object. */
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/GetNetworkRequest.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/GetNetworkRequest.java
index 13292570f..92598de50 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/GetNetworkRequest.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/GetNetworkRequest.java
@@ -15,10 +15,10 @@
 package com.google.firebase.storage.network;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.google.firebase.FirebaseApp;
-import java.io.UnsupportedEncodingException;
 import java.util.Collections;
+import java.util.Map;
 
 /** A network request that returns bytes of a gcs object. */
 public class GetNetworkRequest extends NetworkRequest {
@@ -40,8 +40,7 @@ protected String getAction() {
 
   @Override
   @NonNull
-  protected String getQueryParameters() throws UnsupportedEncodingException {
-    return getPostDataString(
-        Collections.singletonList("alt"), Collections.singletonList("media"), true);
+  protected Map<String, String> getQueryParameters() {
+    return Collections.singletonMap("alt", "media");
   }
 }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/ListNetworkRequest.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/ListNetworkRequest.java
index afbed33af..4a40a0195 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/ListNetworkRequest.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/ListNetworkRequest.java
@@ -15,13 +15,12 @@
 package com.google.firebase.storage.network;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.FirebaseApp;
-import java.io.UnsupportedEncodingException;
-import java.util.ArrayList;
-import java.util.List;
+import java.util.HashMap;
+import java.util.Map;
 
 /** A network request that lists folder contents within gcs. */
 public class ListNetworkRequest extends NetworkRequest {
@@ -46,40 +45,35 @@ protected String getAction() {
 
   @Override
   @NonNull
-  protected String getURL() {
-    return sNetworkRequestUrl + "/b/" + mGsUri.getAuthority() + "/o";
+  protected Uri getURL() {
+    return Uri.parse(sNetworkRequestUrl + "/b/" + mGsUri.getAuthority() + "/o");
   }
 
   @Override
-  @Nullable
-  protected String getQueryParameters() throws UnsupportedEncodingException {
-    List<String> keys = new ArrayList<>();
-    List<String> values = new ArrayList<>();
+  @NonNull
+  protected Map<String, String> getQueryParameters() {
+    Map<String, String> headers = new HashMap<>();
 
     String prefix = getPathWithoutBucket();
-    if (!TextUtils.isEmpty(prefix)) {
-      keys.add("prefix");
-      values.add(prefix + "/");
+    if (!prefix.isEmpty()) {
+      headers.put("prefix", prefix + "/");
     }
 
     // Firebase Storage uses file system semantics and treats slashes as separators. GCS's List API
     // does not prescribe a separator, and hence we need to provide a slash as the delimiter.
-    keys.add("delimiter");
-    values.add("/");
+    headers.put("delimiter", "/");
 
     // We don't set the `maxPageSize` for listAll() as this allows Firebase Storage to return
     // fewer items per page. This removes the need to backfill results if Firebase Storage filters
     // objects that are considered invalid (such as items with two consecutive slashes).
     if (maxPageSize != null) {
-      keys.add("maxResults");
-      values.add(Integer.toString(maxPageSize));
+      headers.put("maxResults", Integer.toString(maxPageSize));
     }
 
     if (!TextUtils.isEmpty(nextPageToken)) {
-      keys.add("pageToken");
-      values.add(nextPageToken);
+      headers.put("pageToken", nextPageToken);
     }
 
-    return getPostDataString(keys, values, true);
+    return headers;
   }
 }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/NetworkRequest.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/NetworkRequest.java
index e51472618..f9d8c4c12 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/NetworkRequest.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/NetworkRequest.java
@@ -20,15 +20,14 @@
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 import android.net.Uri;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.storage.StorageException;
-import com.google.firebase.storage.internal.Slashes;
 import com.google.firebase.storage.network.connection.HttpURLConnectionFactory;
 import com.google.firebase.storage.network.connection.HttpURLConnectionFactoryImpl;
 import java.io.BufferedOutputStream;
@@ -37,11 +36,9 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
 import java.net.HttpURLConnection;
 import java.net.SocketException;
 import java.net.URL;
-import java.net.URLEncoder;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -71,8 +68,8 @@
   private static final String CONTENT_LENGTH = "Content-Length";
   private static final String UTF_8 = "UTF-8";
 
-  @NonNull public static String sNetworkRequestUrl = "https://firebasestorage.googleapis.com/v0";
-  @NonNull public static String sUploadUrl = "https://firebasestorage.googleapis.com/v0/b/";
+  @NonNull static Uri sNetworkRequestUrl = Uri.parse("https://firebasestorage.googleapis.com/v0");
+
   // For test purposes only.
   /*package*/ static HttpURLConnectionFactory connectionFactory =
       new HttpURLConnectionFactoryImpl();
@@ -100,8 +97,7 @@ public NetworkRequest(@NonNull Uri gsUri, @NonNull FirebaseApp app) {
 
   @NonNull
   public static String getAuthority() {
-    Uri uri = Uri.parse(sNetworkRequestUrl);
-    return uri.getAuthority();
+    return sNetworkRequestUrl.getAuthority();
   }
 
   /**
@@ -110,31 +106,38 @@ public static String getAuthority() {
    * @return Url for the target REST call in string form.
    */
   @NonNull
-  public static String getdefaultURL(@NonNull Uri gsUri) {
+  public static Uri getDefaultURL(@NonNull Uri gsUri) {
     Preconditions.checkNotNull(gsUri);
-
     String pathWithoutBucket = getPathWithoutBucket(gsUri);
-    return sNetworkRequestUrl
-        + "/b/"
-        + gsUri.getAuthority()
-        + "/o/"
-        + (pathWithoutBucket != null ? Slashes.unSlashize(pathWithoutBucket) : "");
+    Uri.Builder uriBuilder = sNetworkRequestUrl.buildUpon();
+    uriBuilder.appendPath("b");
+    uriBuilder.appendPath(gsUri.getAuthority());
+    uriBuilder.appendPath("o");
+    uriBuilder.appendPath(pathWithoutBucket);
+    return uriBuilder.build();
   }
 
   /**
-   * Returns the path of the object but excludes the bucket name
+   * Returns the decoded path of the object but excludes the bucket name
    *
    * @param gsUri the "gs://" Uri of the blob.
    * @return the path in string form.
    */
-  @Nullable
-  public static String getPathWithoutBucket(@NonNull Uri gsUri) {
-    String path = gsUri.getEncodedPath();
-    if (path != null && path.startsWith("/")) {
-      // this should always be true.
-      path = path.substring(1);
+  private static String getPathWithoutBucket(@NonNull Uri gsUri) {
+    String path = gsUri.getPath();
+    if (path == null) {
+      return "";
     }
-    return path;
+    return path.startsWith("/") ? path.substring(1) : path;
+  }
+
+  /**
+   * Returns the decoded path of the object but excludes the bucket name
+   *
+   * @return the path in string form.
+   */
+  String getPathWithoutBucket() {
+    return getPathWithoutBucket(mGsUri);
   }
 
   @NonNull
@@ -146,18 +149,8 @@ public static String getPathWithoutBucket(@NonNull Uri gsUri) {
    * @return Url for the target REST call in string form.
    */
   @NonNull
-  protected String getURL() {
-    return getdefaultURL(mGsUri);
-  }
-
-  /**
-   * Returns the path of the object but excludes the bucket name
-   *
-   * @return the path in string form.
-   */
-  @Nullable
-  public String getPathWithoutBucket() {
-    return getPathWithoutBucket(mGsUri);
+  protected Uri getURL() {
+    return getDefaultURL(mGsUri);
   }
 
   /**
@@ -193,10 +186,10 @@ protected int getOutputRawSize() {
   /**
    * If overridden, returns the query parameters to send on the REST request.
    *
-   * @return query parameters in string form.
+   * @return If applicable, query params as a Map.
    */
   @Nullable
-  protected String getQueryParameters() throws UnsupportedEncodingException {
+  protected Map<String, String> getQueryParameters() {
     return null;
   }
 
@@ -309,16 +302,18 @@ private HttpURLConnection createConnection() throws IOException {
     HttpURLConnection conn;
     URL url;
 
-    String urlString;
-    String queryParams = getQueryParameters();
-    if (TextUtils.isEmpty(queryParams)) {
-      urlString = getURL();
-    } else {
-      urlString = getURL() + "?" + queryParams;
+    Uri connectionUri = getURL();
+
+    Map<String, String> queryParams = getQueryParameters();
+    if (queryParams != null) {
+      Uri.Builder uriBuilder = connectionUri.buildUpon();
+      for (Map.Entry<String, String> param : queryParams.entrySet()) {
+        uriBuilder.appendQueryParameter(param.getKey(), param.getValue());
+      }
+      connectionUri = uriBuilder.build();
     }
 
-    url = new URL(urlString);
-    conn = connectionFactory.createInstance(url);
+    conn = connectionFactory.createInstance(new URL(connectionUri.toString()));
     return conn;
   }
 
@@ -418,22 +413,6 @@ private void parseResponse(@NonNull HttpURLConnection conn) throws IOException {
     }
   }
 
-  private void processResponseStream() throws IOException {
-    if (isResultSuccess()) {
-      parseSuccessulResponse(resultInputStream);
-    } else {
-      parseErrorResponse(resultInputStream);
-    }
-  }
-
-  protected void parseSuccessulResponse(@Nullable InputStream resultStream) throws IOException {
-    parseResponse(resultStream);
-  }
-
-  protected void parseErrorResponse(@Nullable InputStream resultStream) throws IOException {
-    parseResponse(resultStream);
-  }
-
   @SuppressWarnings("TryFinallyCanBeTryWithResources")
   private void parseResponse(@Nullable InputStream resultStream) throws IOException {
     StringBuilder sb = new StringBuilder();
@@ -455,6 +434,22 @@ private void parseResponse(@Nullable InputStream resultStream) throws IOExceptio
     }
   }
 
+  private void processResponseStream() throws IOException {
+    if (isResultSuccess()) {
+      parseSuccessulResponse(resultInputStream);
+    } else {
+      parseErrorResponse(resultInputStream);
+    }
+  }
+
+  protected void parseSuccessulResponse(@Nullable InputStream resultStream) throws IOException {
+    parseResponse(resultStream);
+  }
+
+  protected void parseErrorResponse(@Nullable InputStream resultStream) throws IOException {
+    parseResponse(resultStream);
+  }
+
   @Nullable
   public String getRawResult() {
     return rawStringResponse;
@@ -508,29 +503,6 @@ public boolean isResultSuccess() {
     return resultCode >= 200 && resultCode < 300;
   }
 
-  String getPostDataString(@Nullable List<String> keys, List<String> values, boolean encode)
-      throws UnsupportedEncodingException {
-    if (keys == null || keys.size() == 0) {
-      return null;
-    }
-
-    StringBuilder result = new StringBuilder();
-    boolean first = true;
-    for (int i = 0; i < keys.size(); i++) {
-      if (first) {
-        first = false;
-      } else {
-        result.append("&");
-      }
-
-      result.append(encode ? URLEncoder.encode(keys.get(i), "UTF-8") : keys.get(i));
-      result.append("=");
-      result.append(encode ? URLEncoder.encode(values.get(i), "UTF-8") : values.get(i));
-    }
-
-    return result.toString();
-  }
-
   @Nullable
   public String getResultString(String key) {
     Map<String, List<String>> resultHeaders = getResultHeadersImpl();
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableNetworkRequest.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableNetworkRequest.java
index c92bb4c2f..766d39ada 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableNetworkRequest.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableNetworkRequest.java
@@ -15,7 +15,7 @@
 package com.google.firebase.storage.network;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.google.firebase.FirebaseApp;
 
 /** Encapsulates a single resumable network request and response */
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableUploadByteRequest.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableUploadByteRequest.java
index 7fd70358c..b68d64bff 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableUploadByteRequest.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableUploadByteRequest.java
@@ -15,14 +15,13 @@
 package com.google.firebase.storage.network;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.FirebaseApp;
 
 /** A request to upload a single chunk of a large blob. */
 public class ResumableUploadByteRequest extends ResumableNetworkRequest {
-  private final String uploadURL;
+  private final Uri uploadURL;
   private final byte[] chunk;
   private final long offset;
   private final boolean isFinal;
@@ -31,15 +30,12 @@
   public ResumableUploadByteRequest(
       @NonNull Uri gsUri,
       @NonNull FirebaseApp app,
-      @NonNull String uploadURL,
+      @NonNull Uri uploadURL,
       @Nullable byte[] chunk,
       long offset,
       int bytesToWrite,
       boolean isFinal) {
     super(gsUri, app);
-    if (TextUtils.isEmpty(uploadURL)) {
-      super.mException = new IllegalArgumentException("uploadURL is null or empty");
-    }
     if (chunk == null && bytesToWrite != -1) {
       super.mException = new IllegalArgumentException("contentType is null or empty");
     }
@@ -71,7 +67,7 @@ protected String getAction() {
 
   @Override
   @NonNull
-  protected String getURL() {
+  protected Uri getURL() {
     return uploadURL;
   }
 
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableUploadCancelRequest.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableUploadCancelRequest.java
index af0be713a..50156157e 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableUploadCancelRequest.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableUploadCancelRequest.java
@@ -15,24 +15,20 @@
 package com.google.firebase.storage.network;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
-import android.support.annotation.VisibleForTesting;
-import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
 import com.google.firebase.FirebaseApp;
 
 /** Cancels an upload request in progress. */
 public class ResumableUploadCancelRequest extends ResumableNetworkRequest {
   @VisibleForTesting public static boolean cancelCalled = false;
 
-  private final String uploadURL;
+  private final Uri uploadURL;
 
   public ResumableUploadCancelRequest(
-      @NonNull Uri gsUri, @NonNull FirebaseApp app, @NonNull String uploadURL) {
+      @NonNull Uri gsUri, @NonNull FirebaseApp app, @NonNull Uri uploadURL) {
     super(gsUri, app);
     cancelCalled = true;
-    if (TextUtils.isEmpty(uploadURL)) {
-      super.mException = new IllegalArgumentException("uploadURL is null or empty");
-    }
     this.uploadURL = uploadURL;
     super.setCustomHeader(PROTOCOL, "resumable");
     super.setCustomHeader(COMMAND, "cancel");
@@ -46,7 +42,7 @@ protected String getAction() {
 
   @NonNull
   @Override
-  protected String getURL() {
+  protected Uri getURL() {
     return uploadURL;
   }
 }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableUploadQueryRequest.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableUploadQueryRequest.java
index 054337704..f8a7328ee 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableUploadQueryRequest.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableUploadQueryRequest.java
@@ -15,20 +15,16 @@
 package com.google.firebase.storage.network;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
-import android.text.TextUtils;
+import androidx.annotation.NonNull;
 import com.google.firebase.FirebaseApp;
 
 /** Queries the current status of a resumable upload session. */
 public class ResumableUploadQueryRequest extends ResumableNetworkRequest {
-  private final String uploadURL;
+  private final Uri uploadURL;
 
   public ResumableUploadQueryRequest(
-      @NonNull Uri gsUri, @NonNull FirebaseApp app, @NonNull String uploadURL) {
+      @NonNull Uri gsUri, @NonNull FirebaseApp app, @NonNull Uri uploadURL) {
     super(gsUri, app);
-    if (TextUtils.isEmpty(uploadURL)) {
-      super.mException = new IllegalArgumentException("uploadURL is null or empty");
-    }
     this.uploadURL = uploadURL;
 
     super.setCustomHeader(PROTOCOL, "resumable");
@@ -43,7 +39,7 @@ protected String getAction() {
 
   @NonNull
   @Override
-  protected String getURL() {
+  protected Uri getURL() {
     return uploadURL;
   }
 }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableUploadStartRequest.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableUploadStartRequest.java
index 0870dbbb7..492aae358 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableUploadStartRequest.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/ResumableUploadStartRequest.java
@@ -15,14 +15,12 @@
 package com.google.firebase.storage.network;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.FirebaseApp;
-import com.google.firebase.storage.internal.Slashes;
-import java.io.UnsupportedEncodingException;
-import java.util.ArrayList;
-import java.util.List;
+import java.util.HashMap;
+import java.util.Map;
 import org.json.JSONObject;
 
 /** Starts a resumable upload session with GCS. */
@@ -48,8 +46,12 @@ public ResumableUploadStartRequest(
 
   @Override
   @NonNull
-  protected String getURL() {
-    return sUploadUrl + mGsUri.getAuthority() + "/o";
+  protected Uri getURL() {
+    Uri.Builder uriBuilder = sNetworkRequestUrl.buildUpon();
+    uriBuilder.appendPath("b");
+    uriBuilder.appendPath(mGsUri.getAuthority());
+    uriBuilder.appendPath("o");
+    return uriBuilder.build();
   }
 
   @Override
@@ -60,16 +62,11 @@ protected String getAction() {
 
   @Override
   @NonNull
-  protected String getQueryParameters() throws UnsupportedEncodingException {
-    List<String> keys = new ArrayList<>();
-    List<String> values = new ArrayList<>();
-
-    String pathWithoutBucket = getPathWithoutBucket();
-    keys.add("name");
-    values.add(pathWithoutBucket != null ? Slashes.unSlashize(pathWithoutBucket) : "");
-    keys.add("uploadType");
-    values.add("resumable");
-    return getPostDataString(keys, values, false);
+  protected Map<String, String> getQueryParameters() {
+    Map<String, String> headers = new HashMap<>();
+    headers.put("name", getPathWithoutBucket());
+    headers.put("uploadType", "resumable");
+    return headers;
   }
 
   @Override
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/UpdateMetadataNetworkRequest.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/UpdateMetadataNetworkRequest.java
index d1e763d34..271b74028 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/UpdateMetadataNetworkRequest.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/UpdateMetadataNetworkRequest.java
@@ -15,8 +15,8 @@
 package com.google.firebase.storage.network;
 
 import android.net.Uri;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.firebase.FirebaseApp;
 import org.json.JSONObject;
 
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/connection/HttpURLConnectionFactory.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/connection/HttpURLConnectionFactory.java
index 4c7e66c03..a389ecb09 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/connection/HttpURLConnectionFactory.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/connection/HttpURLConnectionFactory.java
@@ -14,8 +14,8 @@
 
 package com.google.firebase.storage.network.connection;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.net.URL;
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/connection/HttpURLConnectionFactoryImpl.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/connection/HttpURLConnectionFactoryImpl.java
index 515206557..b447756e0 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/connection/HttpURLConnectionFactoryImpl.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/connection/HttpURLConnectionFactoryImpl.java
@@ -14,8 +14,8 @@
 
 package com.google.firebase.storage.network.connection;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.net.URL;
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/connection/package-info.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/connection/package-info.java
index 6000a4b34..2640a25a7 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/connection/package-info.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/connection/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.storage.network.connection;
 
-import android.support.annotation.RestrictTo;
\ No newline at end of file
+import androidx.annotation.RestrictTo;
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/package-info.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/package-info.java
index 91379e86f..4a220c04b 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/package-info.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/package-info.java
@@ -16,4 +16,4 @@
 @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.storage.network;
 
-import android.support.annotation.RestrictTo;
\ No newline at end of file
+import androidx.annotation.RestrictTo;
diff --git a/firebase-storage/src/test/java/com/google/firebase/storage/DependencyTest.java b/firebase-storage/src/test/java/com/google/firebase/storage/DependencyTest.java
index 1e4aee002..1c1ef9b56 100644
--- a/firebase-storage/src/test/java/com/google/firebase/storage/DependencyTest.java
+++ b/firebase-storage/src/test/java/com/google/firebase/storage/DependencyTest.java
@@ -73,11 +73,9 @@
    * If this test fails, its because you added a new method/overload to Task and you need to let
    * someone in Firebase Storage know. Otherwise users will see NotImplementedException on these new
    * methods for Storage Tasks. Please contact benwu@ for more info.
-   *
-   * @throws Exception
    */
   @Test
-  public void catchNewTaskMethods() throws Exception {
+  public void catchNewTaskMethods() {
     StringBuilder builder = new StringBuilder();
 
     try {
@@ -96,7 +94,7 @@ public void catchNewTaskMethods() throws Exception {
     }
     String newValue = builder.toString();
     if (!expected.equals(newValue)) {
-      System.err.println("Exepected:\n" + expected + "\nBut got:\n" + newValue);
+      System.err.println("Expected:\n" + expected + "\nBut got:\n" + newValue);
     }
     Assert.assertEquals(expected, newValue);
   }
diff --git a/firebase-storage/src/test/java/com/google/firebase/storage/ListTest.java b/firebase-storage/src/test/java/com/google/firebase/storage/ListTest.java
index 3c4582e43..fda83ae5b 100644
--- a/firebase-storage/src/test/java/com/google/firebase/storage/ListTest.java
+++ b/firebase-storage/src/test/java/com/google/firebase/storage/ListTest.java
@@ -103,6 +103,18 @@ public void listResultsWithMultiplePages() throws InterruptedException {
     TestUtil.verifyTaskStateChanges("listMultiplePages", task.getResult().toString());
   }
 
+  @Test
+  public void listFailure() throws InterruptedException {
+    MockConnectionFactory factory =
+        NetworkLayerMock.ensureNetworkMock("listSinglePageFailed", false);
+    Task<StringBuilder> task = TestCommandHelper.listFiles(/* pageSize= */ 10, /* pageCount= */ 1);
+
+    TestUtil.await(task);
+
+    factory.verifyOldMock();
+    TestUtil.verifyTaskStateChanges("listSinglePageFailed", task.getResult().toString());
+  }
+
   @Test
   public void listAll() throws InterruptedException {
     MockConnectionFactory factory = NetworkLayerMock.ensureNetworkMock("listAll", true);
@@ -113,4 +125,15 @@ public void listAll() throws InterruptedException {
     factory.verifyOldMock();
     TestUtil.verifyTaskStateChanges("listAll", task.getResult().toString());
   }
+
+  @Test
+  public void listAllWithFailure() throws InterruptedException {
+    MockConnectionFactory factory = NetworkLayerMock.ensureNetworkMock("listAllFailed", false);
+    Task<StringBuilder> task = TestCommandHelper.listAllFiles();
+
+    TestUtil.await(task);
+
+    factory.verifyOldMock();
+    TestUtil.verifyTaskStateChanges("listAllFailed", task.getResult().toString());
+  }
 }
diff --git a/firebase-storage/src/test/java/com/google/firebase/storage/RetryRule.java b/firebase-storage/src/test/java/com/google/firebase/storage/RetryRule.java
index a09e4482c..ef57cad7c 100644
--- a/firebase-storage/src/test/java/com/google/firebase/storage/RetryRule.java
+++ b/firebase-storage/src/test/java/com/google/firebase/storage/RetryRule.java
@@ -20,12 +20,13 @@
 
 /** Retries tests that fail due to the test harnesses' unpredictable threading behavior. */
 public class RetryRule implements TestRule {
-  private int retryCount;
+  private final int retryCount;
 
   public RetryRule(int retryCount) {
     this.retryCount = retryCount;
   }
 
+  @Override
   public Statement apply(final Statement base, Description description) {
     return new Statement() {
       @Override
diff --git a/firebase-storage/src/test/java/com/google/firebase/storage/TestUtil.java b/firebase-storage/src/test/java/com/google/firebase/storage/TestUtil.java
index 6b48ec33c..5dae0c40d 100644
--- a/firebase-storage/src/test/java/com/google/firebase/storage/TestUtil.java
+++ b/firebase-storage/src/test/java/com/google/firebase/storage/TestUtil.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.storage;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.gms.tasks.Task;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.FirebaseOptions;
@@ -80,21 +80,19 @@ private static void verifyTaskStateChanges(@Nullable InputStream inputStream, St
     }
 
     StringBuilder baselineContents = new StringBuilder();
-    try {
-      BufferedReader br = new BufferedReader(new InputStreamReader(inputStream, "UTF-8"));
+    try (BufferedReader br = new BufferedReader(new InputStreamReader(inputStream, "UTF-8"))) {
       // skip to first <new>
       String line;
       while ((line = br.readLine()) != null) {
         baselineContents.append(line).append("\n");
       }
-      inputStream.close();
     } catch (IOException e) {
-      e.printStackTrace();
+      throw new RuntimeException(e);
     }
 
-    try {
-      BufferedReader current = new BufferedReader(new StringReader(contents));
-      BufferedReader baseline = new BufferedReader(new StringReader(baselineContents.toString()));
+    try (BufferedReader current = new BufferedReader(new StringReader(contents));
+        BufferedReader baseline =
+            new BufferedReader(new StringReader(baselineContents.toString()))) {
       String originalLine;
       String newLine;
       // skip to first <new>
@@ -113,7 +111,7 @@ private static void verifyTaskStateChanges(@Nullable InputStream inputStream, St
         } else {
           if (!originalLine.equals(newLine)) {
             System.err.println("Original:");
-            System.err.println(baselineContents.toString());
+            System.err.println(baselineContents);
             System.err.println("New:");
             System.err.println(contents);
           }
@@ -121,16 +119,8 @@ private static void verifyTaskStateChanges(@Nullable InputStream inputStream, St
         }
         line++;
       }
-      current.close();
-      baseline.close();
     } catch (IOException e) {
-      e.printStackTrace();
-    }
-
-    try {
-      inputStream.close();
-    } catch (IOException e) {
-      e.printStackTrace();
+      throw new RuntimeException(e);
     }
   }
 
diff --git a/firebase-storage/src/test/java/com/google/firebase/storage/UploadTest.java b/firebase-storage/src/test/java/com/google/firebase/storage/UploadTest.java
index e70896943..bce51fedc 100644
--- a/firebase-storage/src/test/java/com/google/firebase/storage/UploadTest.java
+++ b/firebase-storage/src/test/java/com/google/firebase/storage/UploadTest.java
@@ -274,7 +274,9 @@ public void uploadWithSpace() throws Exception {
     System.out.println("Starting test uploadWithSpace.");
 
     MockConnectionFactory factory = NetworkLayerMock.ensureNetworkMock("uploadWithSpace", true);
-    Task<StringBuilder> task = TestUploadHelper.uploadWithSpace();
+    StorageReference storage =
+        FirebaseStorage.getInstance().getReference().child("hello world.txt");
+    Task<StringBuilder> task = TestUploadHelper.byteUpload(storage);
 
     TestUtil.await(task);
 
@@ -342,6 +344,20 @@ public void emptyUpload() throws Exception {
     TestUtil.verifyTaskStateChanges("emptyUpload", task.getResult().toString());
   }
 
+  @Test
+  public void unicodeUpload() throws Exception {
+    System.out.println("Starting test unicodeUpload.");
+
+    MockConnectionFactory factory = NetworkLayerMock.ensureNetworkMock("uploadWithUnicode", true);
+    StorageReference storage = FirebaseStorage.getInstance().getReference().child("\\%:");
+    Task<StringBuilder> task = TestUploadHelper.byteUpload(storage);
+
+    TestUtil.await(task);
+
+    factory.verifyOldMock();
+    TestUtil.verifyTaskStateChanges("uploadWithUnicode", task.getResult().toString());
+  }
+
   @Test
   public void fileUploadWithPauseCancel() throws Exception {
     System.out.println("Starting test fileUploadWithPauseCancel.");
diff --git a/firebase-storage/src/test/java/com/google/firebase/storage/internal/MockSleeperHelper.java b/firebase-storage/src/test/java/com/google/firebase/storage/internal/MockSleeperHelper.java
index d4dcd14ca..021e442a2 100644
--- a/firebase-storage/src/test/java/com/google/firebase/storage/internal/MockSleeperHelper.java
+++ b/firebase-storage/src/test/java/com/google/firebase/storage/internal/MockSleeperHelper.java
@@ -16,7 +16,7 @@
 
 /** Helper for mocking sleep for exponential backoff. */
 public class MockSleeperHelper implements Sleeper {
-  private MockClockHelper clock;
+  private final MockClockHelper clock;
 
   public MockSleeperHelper(MockClockHelper clock) {
     this.clock = clock;
diff --git a/firebase-storage/src/test/java/com/google/firebase/storage/network/MockConnectionFactory.java b/firebase-storage/src/test/java/com/google/firebase/storage/network/MockConnectionFactory.java
index 9e09054aa..a085936a1 100644
--- a/firebase-storage/src/test/java/com/google/firebase/storage/network/MockConnectionFactory.java
+++ b/firebase-storage/src/test/java/com/google/firebase/storage/network/MockConnectionFactory.java
@@ -18,8 +18,8 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import android.support.annotation.NonNull;
 import android.util.Base64;
+import androidx.annotation.NonNull;
 import com.google.firebase.storage.network.connection.HttpURLConnectionFactory;
 import java.io.BufferedReader;
 import java.io.ByteArrayOutputStream;
@@ -41,20 +41,16 @@
 import org.mockito.ArgumentCaptor;
 import org.mockito.Mockito;
 import org.mockito.exceptions.base.MockitoAssertionError;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
 
 public class MockConnectionFactory implements HttpURLConnectionFactory {
-  private static final String LOG_TAG = MockConnectionFactory.class.getName();
-
   private final boolean binaryBody;
-  HttpURLConnection oldMock;
-  List<String> verifications = new ArrayList<>();
-  int count = 0;
-  private BufferedReader br;
+  private HttpURLConnection oldMock;
+  private List<String> verifications = new ArrayList<>();
+  private final BufferedReader br;
+  private final Semaphore pauseSemaphore = new Semaphore(0);
+  private int lineCount = 0;
   private int pauseRecord = Integer.MAX_VALUE;
-  private int currentRecord = 0;
-  private Semaphore pauseSemaphore = new Semaphore(0);
+  private int currentRecord = 0;;
 
   public MockConnectionFactory(String testName, boolean binaryBody) {
     this.binaryBody = binaryBody;
@@ -69,7 +65,7 @@ public MockConnectionFactory(String testName, boolean binaryBody) {
         }
       }
     } catch (IOException e) {
-      e.printStackTrace();
+      throw new RuntimeException(e);
     }
   }
 
@@ -95,7 +91,7 @@ public synchronized HttpURLConnection createInstance(@NonNull URL url) throws IO
     String line;
     try {
       while ((line = br.readLine()) != null) {
-        count++;
+        lineCount++;
 
         if ("<new>".equalsIgnoreCase(line)) {
           break;
@@ -160,22 +156,19 @@ public synchronized HttpURLConnection createInstance(@NonNull URL url) throws IO
         }
       }
     } catch (ComparisonFailure | IllegalArgumentException e) {
-      System.out.println("**** Error at line:" + count);
+      System.out.println("**** Error at line:" + lineCount);
       throw e;
     }
     currentRecord++;
     if (currentRecord == pauseRecord) {
       Mockito.doAnswer(
-              new Answer<Void>() {
-                @Override
-                public Void answer(InvocationOnMock invocation) {
-                  try {
-                    pauseSemaphore.acquire();
-                  } catch (InterruptedException e) {
-                    e.printStackTrace();
-                  }
-                  return null;
+              invocation -> {
+                try {
+                  pauseSemaphore.acquire();
+                } catch (InterruptedException e) {
+                  Thread.currentThread().interrupt();
                 }
+                return null;
               })
           .when(mock)
           .disconnect();
@@ -186,7 +179,7 @@ public Void answer(InvocationOnMock invocation) {
   }
 
   public synchronized void verifyOldMock() {
-    if (oldMock == null || verifications.size() == 0) {
+    if (oldMock == null || verifications.isEmpty()) {
       return;
     }
     List<String> requestPropertyKeys = new ArrayList<>();
@@ -205,7 +198,7 @@ public synchronized void verifyOldMock() {
           try {
             verify(oldMock).setRequestMethod(value);
           } catch (ProtocolException e) {
-            e.printStackTrace();
+            throw new RuntimeException(e);
           }
         } else if (key.equalsIgnoreCase("setRequestProperty")) {
           int comma = value.indexOf(',');
@@ -240,7 +233,7 @@ public synchronized void verifyOldMock() {
             valueCapture.getAllValues().get(keyIndex));
       }
     } catch (MockitoAssertionError | ComparisonFailure e) {
-      System.out.println("**********Error in network Line: " + count);
+      System.out.println("**********Error in network Line: " + lineCount);
       throw e;
     }
 
diff --git a/firebase-storage/src/test/resources/activitylogs/listAllFailed_network.txt b/firebase-storage/src/test/resources/activitylogs/listAllFailed_network.txt
new file mode 100644
index 000000000..3470353dd
--- /dev/null
+++ b/firebase-storage/src/test/resources/activitylogs/listAllFailed_network.txt
@@ -0,0 +1,29 @@
+
+<new>
+Url:https://firebasestorage.googleapis.com/v0/b/fooey.appspot.com/o?prefix=largeDirectory%2F&delimiter=%2F
+setRequestMethod:GET
+setRequestProperty:X-Firebase-Storage-Version,Android/[No Gmscore]
+setRequestProperty:x-firebase-gmpid,fooey
+setRequestProperty:Content-Length,0
+setUseCaches:false
+setDoInput:true
+getResponseCode:403
+getHeaderFields:
+ null:[HTTP/1.1 403 Forbidden]
+ Access-Control-Allow-Origin:[*]
+ Access-Control-Expose-Headers:[Content-Range, X-Firebase-Storage-XSRF]
+ Alt-Svc:[quic=":443"; ma=2592000; v="46,43,39"]
+ Cache-Control:[private, max-age=0]
+ Content-Length:[106]
+ Content-Type:[application/json; charset=UTF-8]
+ Date:[Fri, 16 Aug 2019 17:51:19 GMT]
+ Expires:[Fri, 16 Aug 2019 17:51:19 GMT]
+ Server:[UploadServer]
+ X-Android-Received-Millis:[1565977885114]
+ X-Android-Response-Source:[NETWORK 403]
+ X-Android-Selected-Protocol:[http/1.1]
+ X-Android-Sent-Millis:[1565977884943]
+ X-Content-Type-Options:[nosniff]
+ X-GUploader-UploadID:[AEnB2Up1Fu4ZwtUsQe7mXrzuQ_S2KZvRwUttfOYcrQsZm4kuJcUJFvMzTRxkmydO8ErBV1bI_Ku_B7xqFBp5r4bt-hEu4a2JBQ]
+getErrorStream:{  "error": {    "code": 403,    "message": "Permission denied. Could not perform this operation"  }}
+disconnect:
diff --git a/firebase-storage/src/test/resources/activitylogs/listAllFailed_task.txt b/firebase-storage/src/test/resources/activitylogs/listAllFailed_task.txt
new file mode 100644
index 000000000..1377b9706
--- /dev/null
+++ b/firebase-storage/src/test/resources/activitylogs/listAllFailed_task.txt
@@ -0,0 +1,4 @@
+
+listAll:
+  onComplete:Success=false
+done.
diff --git a/firebase-storage/src/test/resources/activitylogs/listSinglePageFailed_network.txt b/firebase-storage/src/test/resources/activitylogs/listSinglePageFailed_network.txt
new file mode 100644
index 000000000..589508cf7
--- /dev/null
+++ b/firebase-storage/src/test/resources/activitylogs/listSinglePageFailed_network.txt
@@ -0,0 +1,29 @@
+
+<new>
+Url:https://firebasestorage.googleapis.com/v0/b/fooey.appspot.com/o?prefix=smallDirectory%2F&delimiter=%2F&maxResults=10
+setRequestMethod:GET
+setRequestProperty:X-Firebase-Storage-Version,Android/[No Gmscore]
+setRequestProperty:x-firebase-gmpid,fooey
+setRequestProperty:Content-Length,0
+setUseCaches:false
+setDoInput:true
+getResponseCode:403
+getHeaderFields:
+ null:[HTTP/1.1 403 Forbidden]
+ Access-Control-Allow-Origin:[*]
+ Access-Control-Expose-Headers:[Content-Range, X-Firebase-Storage-XSRF]
+ Alt-Svc:[quic=":443"; ma=2592000; v="46,43,39"]
+ Cache-Control:[private, max-age=0]
+ Content-Length:[106]
+ Content-Type:[application/json; charset=UTF-8]
+ Date:[Fri, 16 Aug 2019 17:51:19 GMT]
+ Expires:[Fri, 16 Aug 2019 17:51:19 GMT]
+ Server:[UploadServer]
+ X-Android-Received-Millis:[1565977885114]
+ X-Android-Response-Source:[NETWORK 403]
+ X-Android-Selected-Protocol:[http/1.1]
+ X-Android-Sent-Millis:[1565977884943]
+ X-Content-Type-Options:[nosniff]
+ X-GUploader-UploadID:[AEnB2Up1Fu4ZwtUsQe7mXrzuQ_S2KZvRwUttfOYcrQsZm4kuJcUJFvMzTRxkmydO8ErBV1bI_Ku_B7xqFBp5r4bt-hEu4a2JBQ]
+getErrorStream:{  "error": {    "code": 403,    "message": "Permission denied. Could not perform this operation"  }}
+disconnect:
diff --git a/firebase-storage/src/test/resources/activitylogs/listSinglePageFailed_task.txt b/firebase-storage/src/test/resources/activitylogs/listSinglePageFailed_task.txt
new file mode 100644
index 000000000..173e33629
--- /dev/null
+++ b/firebase-storage/src/test/resources/activitylogs/listSinglePageFailed_task.txt
@@ -0,0 +1,4 @@
+
+list:
+  onComplete:Success=false
+done.
diff --git a/firebase-storage/src/test/resources/activitylogs/uploadWithUnicode_network.txt b/firebase-storage/src/test/resources/activitylogs/uploadWithUnicode_network.txt
new file mode 100644
index 000000000..aeccf919b
--- /dev/null
+++ b/firebase-storage/src/test/resources/activitylogs/uploadWithUnicode_network.txt
@@ -0,0 +1,130 @@
+
+<new>
+Url:https://firebasestorage.googleapis.com/v0/b/fooey.appspot.com/o?name=%5C%25%3A%F0%9F%98%8A&uploadType=resumable
+setRequestMethod:POST
+setRequestProperty:X-Firebase-Storage-Version,Android/[No Gmscore]
+setRequestProperty:x-firebase-gmpid,fooey
+setRequestProperty:X-Goog-Upload-Protocol,resumable
+setRequestProperty:X-Goog-Upload-Header-Content-Type,text/plain
+setRequestProperty:X-Goog-Upload-Command,start
+setRequestProperty:Content-Type,application/json
+setDoOutput:true
+setRequestProperty:Content-Length,29
+setUseCaches:false
+setDoInput:true
+getOutputStream:
+getResponseCode:200
+getHeaderFields:
+ null:[HTTP/1.1 200 OK]
+ Alt-Svc:[quic=":443"; ma=2592000; v="36,35,34"]
+ Content-Length:[0]
+ Content-Type:[text/html; charset=UTF-8]
+ Date:[Fri, 03 Mar 2017 23:00:11 GMT]
+ Server:[UploadServer]
+ X-Android-Received-Millis:[1488582013323]
+ X-Android-Response-Source:[NETWORK 200]
+ X-Android-Selected-Protocol:[http/1.1]
+ X-Android-Sent-Millis:[1488582012958]
+ X-Goog-Upload-Chunk-Granularity:[262144]
+ X-Goog-Upload-Control-URL:[https://firebasestorage.googleapis.com/v0/b/fooey.appspot.com/o?name=%5C%25%3A%F0%9F%98%8A&uploadType=resumable&upload_id=AEnB2Up6a4kp5P8Xuhz1mofQpbwHFKEuLxt0X_KpCwzCwZ1N_LGtzBFm9vPpqt3eI2BDD2EDffjtzTovN6W-Cf6UHVYg9vrtGpzuU2xIV6aEtHrvBwQj8g8&upload_protocol=resumable]
+ X-Goog-Upload-Status:[active]
+ X-Goog-Upload-URL:[https://firebasestorage.googleapis.com/v0/b/fooey.appspot.com/o?name=%5C%25%3A%F0%9F%98%8A&uploadType=resumable&upload_id=AEnB2Up6a4kp5P8Xuhz1mofQpbwHFKEuLxt0X_KpCwzCwZ1N_LGtzBFm9vPpqt3eI2BDD2EDffjtzTovN6W-Cf6UHVYg9vrtGpzuU2xIV6aEtHrvBwQj8g8&upload_protocol=resumable]
+ X-GUploader-UploadID:[AEnB2Up6a4kp5P8Xuhz1mofQpbwHFKEuLxt0X_KpCwzCwZ1N_LGtzBFm9vPpqt3eI2BDD2EDffjtzTovN6W-Cf6UHVYg9vrtGpzuU2xIV6aEtHrvBwQj8g8]
+getInputStream:
+disconnect:
+<new>
+Url:https://firebasestorage.googleapis.com/v0/b/fooey.appspot.com/o?name=%5C%25%3A%F0%9F%98%8A&uploadType=resumable&upload_id=AEnB2Up6a4kp5P8Xuhz1mofQpbwHFKEuLxt0X_KpCwzCwZ1N_LGtzBFm9vPpqt3eI2BDD2EDffjtzTovN6W-Cf6UHVYg9vrtGpzuU2xIV6aEtHrvBwQj8g8&upload_protocol=resumable
+setRequestMethod:POST
+setRequestProperty:X-Firebase-Storage-Version,Android/[No Gmscore]
+setRequestProperty:x-firebase-gmpid,fooey
+setRequestProperty:X-Goog-Upload-Protocol,resumable
+setRequestProperty:X-Goog-Upload-Offset,0
+setRequestProperty:X-Goog-Upload-Command,upload, finalize
+setDoOutput:true
+setRequestProperty:Content-Length,17
+setUseCaches:false
+setDoInput:true
+getOutputStream:
+getResponseCode:200
+getHeaderFields:
+ null:[HTTP/1.1 200 OK]
+ Access-Control-Allow-Origin:[*]
+ Access-Control-Expose-Headers:[X-Firebase-Storage-XSRF]
+ Alt-Svc:[quic=":443"; ma=2592000; v="36,35,34"]
+ Content-Length:[568]
+ Content-Type:[application/json; charset=UTF-8]
+ Date:[Fri, 03 Mar 2017 23:00:45 GMT]
+ Server:[UploadServer]
+ X-Android-Received-Millis:[1488582047427]
+ X-Android-Response-Source:[NETWORK 200]
+ X-Android-Selected-Protocol:[http/1.1]
+ X-Android-Sent-Millis:[1488582046945]
+ X-Content-Type-Options:[nosniff]
+ X-Goog-Upload-Status:[final]
+ X-GUploader-UploadID:[AEnB2Up6a4kp5P8Xuhz1mofQpbwHFKEuLxt0X_KpCwzCwZ1N_LGtzBFm9vPpqt3eI2BDD2EDffjtzTovN6W-Cf6UHVYg9vrtGpzuU2xIV6aEtHrvBwQj8g8]
+getInputStream:ewogICJuYW1lIjogIlxcJTrwn5iKIiwKICAiYnVja2V0IjogImZvb2V5LmFwcHNwb3QuY29tIiwKICAiZ2VuZXJhdGlvbiI6ICIxNDg4NTgyMDQ1NzAwMDAwIiwKICAibWV0YWdlbmVyYXRpb24iOiAiMSIsCiAgImNvbnRlbnRUeXBlIjogInRleHQvcGxhaW4iLAogICJ0aW1lQ3JlYXRlZCI6ICIyMDE3LTAzLTAzVDIzOjAwOjQ1LjYwNFoiLAogICJ1cGRhdGVkIjogIjIwMTctMDMtMDNUMjM6MDA6NDUuNjA0WiIsCiAgInN0b3JhZ2VDbGFzcyI6ICJTVEFOREFSRCIsCiAgInNpemUiOiAiMTciLAogICJtZDVIYXNoIjogInNDSVA2ajhlcXVOZ1hrZlc0WlRFUXc9PSIsCiAgImNvbnRlbnRFbmNvZGluZyI6ICJpZGVudGl0eSIsCiAgImNvbnRlbnREaXNwb3NpdGlvbiI6ICJpbmxpbmU7IGZpbGVuYW1lKj11dGYtOCcnJTVDJTI1JTNBJUYwJTlGJTk4JThBIiwKICAiY3JjMzJjIjogIkRyOG5FQT09IiwKICAiZXRhZyI6ICJDS0NmdHFDNHU5SUNFQUU9IiwKICAiZG93bmxvYWRUb2tlbnMiOiAiNWFkNDAwZDgtYWJjYS00M2NiLTllOTYtNTBhOGMwYWQ4NTBhIgp9
+disconnect:
+<new>
+Url:https://firebasestorage.googleapis.com/v0/b/fooey.appspot.com/o/%5C%25%3A%F0%9F%98%8A
+setRequestMethod:GET
+setRequestProperty:X-Firebase-Storage-Version,Android/[No Gmscore]
+setRequestProperty:x-firebase-gmpid,fooey
+setRequestProperty:Content-Length,0
+setUseCaches:false
+setDoInput:true
+getResponseCode:200
+getHeaderFields:
+ null:[HTTP/1.1 200 OK]
+ Access-Control-Allow-Origin:[*]
+ Access-Control-Expose-Headers:[X-Firebase-Storage-XSRF]
+ Alt-Svc:[quic=":443"; ma=2592000; v="36,35,34"]
+ Cache-Control:[private, max-age=0]
+ Content-Length:[568]
+ Content-Type:[application/json; charset=UTF-8]
+ Date:[Fri, 03 Mar 2017 23:01:05 GMT]
+ Expires:[Fri, 03 Mar 2017 23:01:05 GMT]
+ Server:[UploadServer]
+ X-Android-Received-Millis:[1488582066821]
+ X-Android-Response-Source:[NETWORK 200]
+ X-Android-Selected-Protocol:[http/1.1]
+ X-Android-Sent-Millis:[1488582066670]
+ X-Content-Type-Options:[nosniff]
+ X-GUploader-UploadID:[AEnB2UoXFQd6vfXyfreuXyAVKSw-dCOcYBtXIAodtgR93SydOKB4WOFOH3If0o7JNTMgcCDt14o8SgdBQw49T9V2WS2IPZ80N5TQDxvSyE_Of-MwL6e-j5c]
+getInputStream:ewogICJuYW1lIjogIlxcJTrwn5iKIiwKICAiYnVja2V0IjogImZvb2V5LmFwcHNwb3QuY29tIiwKICAiZ2VuZXJhdGlvbiI6ICIxNDg4NTgyMDQ1NzAwMDAwIiwKICAibWV0YWdlbmVyYXRpb24iOiAiMSIsCiAgImNvbnRlbnRUeXBlIjogInRleHQvcGxhaW4iLAogICJ0aW1lQ3JlYXRlZCI6ICIyMDE3LTAzLTAzVDIzOjAwOjQ1LjYwNFoiLAogICJ1cGRhdGVkIjogIjIwMTctMDMtMDNUMjM6MDA6NDUuNjA0WiIsCiAgInN0b3JhZ2VDbGFzcyI6ICJTVEFOREFSRCIsCiAgInNpemUiOiAiMTciLAogICJtZDVIYXNoIjogInNDSVA2ajhlcXVOZ1hrZlc0WlRFUXc9PSIsCiAgImNvbnRlbnRFbmNvZGluZyI6ICJpZGVudGl0eSIsCiAgImNvbnRlbnREaXNwb3NpdGlvbiI6ICJpbmxpbmU7IGZpbGVuYW1lKj11dGYtOCcnJTVDJTI1JTNBJUYwJTlGJTk4JThBIiwKICAiY3JjMzJjIjogIkRyOG5FQT09IiwKICAiZXRhZyI6ICJDS0NmdHFDNHU5SUNFQUU9IiwKICAiZG93bmxvYWRUb2tlbnMiOiAiNWFkNDAwZDgtYWJjYS00M2NiLTllOTYtNTBhOGMwYWQ4NTBhIgp9
+disconnect:
+<new>
+Url:https://firebasestorage.googleapis.com/v0/b/fooey.appspot.com/o/%5C%25%3A%F0%9F%98%8A?alt=media
+setRequestMethod:GET
+setRequestProperty:X-Firebase-Storage-Version,Android/[No Gmscore]
+setRequestProperty:x-firebase-gmpid,fooey
+setRequestProperty:Content-Length,0
+setUseCaches:false
+setDoInput:true
+getResponseCode:200
+getHeaderFields:
+ null:[HTTP/1.1 200 OK]
+ Accept-Ranges:[bytes]
+ Alt-Svc:[quic=":443"; ma=2592000; v="36,35,34"]
+ Cache-Control:[private, max-age=0]
+ Content-Disposition:[inline; filename*=utf-8''%5C%25%3A%F0%9F%98%8A]
+ Content-Length:[17]
+ Content-Type:[text/plain]
+ Date:[Fri, 03 Mar 2017 23:01:09 GMT]
+ ETag:["b0220fea3f1eaae3605e47d6e194c443"]
+ Expires:[Fri, 03 Mar 2017 23:01:09 GMT]
+ Last-Modified:[Fri, 03 Mar 2017 23:00:45 GMT]
+ Server:[UploadServer]
+ X-Android-Received-Millis:[1488582071224]
+ X-Android-Response-Source:[NETWORK 200]
+ X-Android-Selected-Protocol:[http/1.1]
+ X-Android-Sent-Millis:[1488582070989]
+ x-goog-generation:[1488582045700000]
+ x-goog-hash:[crc32c=Dr8nEA==][md5=sCIP6j8equNgXkfW4ZTEQw==]
+ x-goog-meta-firebaseStorageDownloadTokens:[5ad400d8-abca-43cb-9e96-50a8c0ad850a]
+ x-goog-metageneration:[1]
+ x-goog-storage-class:[STANDARD]
+ x-goog-stored-content-encoding:[identity]
+ x-goog-stored-content-length:[17]
+ X-GUploader-UploadID:[AEnB2UoCD1g6ZTwfSeJUjf26LsatDn2wD0owCuLzsSnT5Jmc9O58XuZiIb9QTvmKjzTNQ706cNQZSzA03xcTuCOkNzEgoFHuEu4QjYzmps1RaJEi4O3sV-s]
+getInputStream:VGhpcyBpcyBhIHRlc3QhISE=
+disconnect:
diff --git a/firebase-storage/src/test/resources/activitylogs/uploadWithUnicode_task.txt b/firebase-storage/src/test/resources/activitylogs/uploadWithUnicode_task.txt
new file mode 100644
index 000000000..e865953c9
--- /dev/null
+++ b/firebase-storage/src/test/resources/activitylogs/uploadWithUnicode_task.txt
@@ -0,0 +1,56 @@
+
+onProgress:
+  exceptionMessage:<none>
+  targetStorageString:gs://fooey.appspot.com/%5C%25%3A%F0%9F%98%8A
+  bytesUploaded:0
+  currentState:4
+  uploadUri:<none>
+  total bytes:17
+onProgress:
+  exceptionMessage:<none>
+  targetStorageString:gs://fooey.appspot.com/%5C%25%3A%F0%9F%98%8A
+  bytesUploaded:0
+  currentState:4
+  uploadUri:<none>
+  total bytes:17
+onProgress:
+  exceptionMessage:<none>
+  targetStorageString:gs://fooey.appspot.com/%5C%25%3A%F0%9F%98%8A
+  bytesUploaded:17
+  currentState:128
+  uploadUri:https://firebasestorage.googleapis.com/v0/b/fooey.appspot.com/o?name=%5C%25%3A%F0%9F%98%8A&uploadType=resumable&upload_id=AEnB2Up6a4kp5P8Xuhz1mofQpbwHFKEuLxt0X_KpCwzCwZ1N_LGtzBFm9vPpqt3eI2BDD2EDffjtzTovN6W-Cf6UHVYg9vrtGpzuU2xIV6aEtHrvBwQj8g8&upload_protocol=resumable
+  total bytes:17
+onSuccess:
+  exceptionMessage:<none>
+  targetStorageString:gs://fooey.appspot.com/%5C%25%3A%F0%9F%98%8A
+  bytesUploaded:17
+  currentState:128
+  uploadUri:https://firebasestorage.googleapis.com/v0/b/fooey.appspot.com/o?name=%5C%25%3A%F0%9F%98%8A&uploadType=resumable&upload_id=AEnB2Up6a4kp5P8Xuhz1mofQpbwHFKEuLxt0X_KpCwzCwZ1N_LGtzBFm9vPpqt3eI2BDD2EDffjtzTovN6W-Cf6UHVYg9vrtGpzuU2xIV6aEtHrvBwQj8g8&upload_protocol=resumable
+  total bytes:17
+getBucket:fooey.appspot.com
+getCacheControl:
+getContentDisposition:inline; filename*=utf-8''%5C%25%3A%F0%9F%98%8A
+getContentEncoding:identity
+getContentLanguage:
+getContentType:text/plain
+getName:\%:
+getPath:\%:
+getMD5Hash:sCIP6j8equNgXkfW4ZTEQw==
+getGeneration:1488582045700000
+getMetadataGeneration:1
+getSizeBytes:17
+getReference:\%:
+getCreationTimeMillis:03/03/2017
+getUpdatedTimeMillis:03/03/2017
+Type:FILE
+
+onSuccessTask:
+  exceptionMessage:<none>
+  targetStorageString:gs://fooey.appspot.com/%5C%25%3A%F0%9F%98%8A
+  bytesUploaded:17
+  currentState:128
+  uploadUri:https://firebasestorage.googleapis.com/v0/b/fooey.appspot.com/o?name=%5C%25%3A%F0%9F%98%8A&uploadType=resumable&upload_id=AEnB2Up6a4kp5P8Xuhz1mofQpbwHFKEuLxt0X_KpCwzCwZ1N_LGtzBFm9vPpqt3eI2BDD2EDffjtzTovN6W-Cf6UHVYg9vrtGpzuU2xIV6aEtHrvBwQj8g8&upload_protocol=resumable
+  total bytes:17
+onComplete:Success=
+true
+done.
diff --git a/firebase-storage/src/testUtil/java/com/google/firebase/storage/TestCommandHelper.java b/firebase-storage/src/testUtil/java/com/google/firebase/storage/TestCommandHelper.java
index c9b2c2aa2..f2b459044 100644
--- a/firebase-storage/src/testUtil/java/com/google/firebase/storage/TestCommandHelper.java
+++ b/firebase-storage/src/testUtil/java/com/google/firebase/storage/TestCommandHelper.java
@@ -16,8 +16,8 @@
 
 import android.annotation.TargetApi;
 import android.net.Uri;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.tasks.OnCompleteListener;
 import com.google.android.gms.tasks.OnSuccessListener;
@@ -48,7 +48,7 @@
         executor,
         task -> {
           builder.append("Received Download Url.\n");
-          builder.append("getDownloadUrl:").append(task.getResult().toString());
+          builder.append("getDownloadUrl:").append(task.getResult());
           builder.append("\nonComplete:Success=\n").append(task.isSuccessful());
           result.setResult(builder);
         });
@@ -180,7 +180,7 @@ public static void dumpMetadata(final StringBuilder builder, @Nullable StorageMe
     builder.append("getMD5Hash:").append(metadata.getMd5Hash()).append("\n");
     builder.append("getGeneration:").append(metadata.getGeneration()).append("\n");
     builder.append("getMetadataGeneration:").append(metadata.getMetadataGeneration()).append("\n");
-    builder.append("getSizeBytes:").append(Long.toString(metadata.getSizeBytes())).append("\n");
+    builder.append("getSizeBytes:").append(metadata.getSizeBytes()).append("\n");
     builder.append("getReference:").append(metadata.getReference().getName()).append("\n");
     SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault());
     sdf.setTimeZone(TimeZone.getTimeZone("America/Los_Angeles"));
@@ -242,12 +242,12 @@ public static void dumpMetadata(final StringBuilder builder, @Nullable StorageMe
           public void onComplete(@NonNull Task<ListResult> task) {
             ++pagesReceived[0];
 
-            ListResult listResult = task.getResult();
-
             builder.append("\nlist:");
             builder.append("\n  onComplete:Success=").append(task.isSuccessful());
 
             if (task.isSuccessful()) {
+              ListResult listResult = task.getResult();
+
               builder.append("\n  Received Prefixes:");
               for (StorageReference prefix : listResult.getPrefixes()) {
                 builder.append("\n    ").append(prefix.getPath());
@@ -257,12 +257,14 @@ public void onComplete(@NonNull Task<ListResult> task) {
                 builder.append("\n    ").append(item.getPath());
               }
               builder.append("\n  Page Token:").append(listResult.getPageToken());
-            }
 
-            if (pagesReceived[0] == pageCount) {
-              result.setResult(builder);
+              if (pagesReceived[0] == pageCount) {
+                result.setResult(builder);
+              } else {
+                reference.list(pageSize, listResult.getPageToken()).addOnCompleteListener(this);
+              }
             } else {
-              reference.list(pageSize, listResult.getPageToken()).addOnCompleteListener(this);
+              result.setResult(builder);
             }
           }
         });
@@ -280,12 +282,11 @@ public void onComplete(@NonNull Task<ListResult> task) {
     listFiles.addOnCompleteListener(
         executor,
         task -> {
-          ListResult listResult = task.getResult();
-
           builder.append("\nlistAll:");
           builder.append("\n  onComplete:Success=").append(task.isSuccessful());
 
           if (task.isSuccessful()) {
+            ListResult listResult = task.getResult();
             builder.append("\n  Received Prefixes:");
             for (StorageReference prefix : listResult.getPrefixes()) {
               builder.append("\n    ").append(prefix.getPath());
diff --git a/firebase-storage/src/testUtil/java/com/google/firebase/storage/TestDownloadHelper.java b/firebase-storage/src/testUtil/java/com/google/firebase/storage/TestDownloadHelper.java
index 215959e49..a301ccb76 100644
--- a/firebase-storage/src/testUtil/java/com/google/firebase/storage/TestDownloadHelper.java
+++ b/firebase-storage/src/testUtil/java/com/google/firebase/storage/TestDownloadHelper.java
@@ -17,8 +17,8 @@
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.net.Uri;
-import android.support.annotation.Nullable;
 import android.util.Log;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.common.util.IOUtils;
 import com.google.android.gms.tasks.Task;
@@ -30,8 +30,8 @@
 @SuppressWarnings("unused")
 public class TestDownloadHelper {
   private static final String TAG = "TestDownloadHelper";
-  private static Bitmap mIcon;
-  private static byte[] mBytes;
+  private static Bitmap icon;
+  private static byte[] bytes;
 
   public static class StreamDownloadResponse {
     public StringBuilder mainTask = new StringBuilder();
@@ -59,8 +59,8 @@
                 response.backgroundTask.append(statusMessage);
 
                 try {
-                  mBytes = IOUtils.toByteArray(stream);
-                  mIcon = BitmapFactory.decodeByteArray(mBytes, 0, mBytes.length);
+                  bytes = IOUtils.toByteArray(stream);
+                  icon = BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
                 } catch (OutOfMemoryError e) {
                   Log.w(TAG, "Can't persist download due to low memory", e);
                 }
@@ -71,7 +71,7 @@
 
                 if (state.getTotalByteCount() != -1) {
                   Preconditions.checkState(totalByteCountBeginning == state.getTotalByteCount());
-                  Preconditions.checkState(mBytes.length == state.getTotalByteCount());
+                  Preconditions.checkState(bytes.length == state.getTotalByteCount());
                 }
               } finally {
                 // Closing stream
@@ -106,10 +106,10 @@
               Log.i(TAG, statusMessage);
               response.mainTask.append(statusMessage);
               if (imageCallback != null) {
-                imageCallback.run(mIcon);
+                imageCallback.run(icon);
               }
               if (byteCallback != null) {
-                byteCallback.run(mBytes);
+                byteCallback.run(bytes);
               }
             })
         .addOnFailureListener(
@@ -219,7 +219,7 @@ public static Semaphore byteDownload(final StringBuilder builder, final ProcessB
         .addOnFailureListener(
             e -> {
               ControllableSchedulerHelper.getInstance().verifyCallbackThread();
-              String statusMessage = "\nonFailure:\n" + e.toString();
+              String statusMessage = "\nonFailure:\n" + e;
               Log.i(TAG, statusMessage);
               builder.append(statusMessage);
             })
@@ -267,7 +267,8 @@ private static void verifyTaskCount(StorageReference reference, int expectedTask
     Preconditions.checkState(
         globalDownloadTasks.size() == expectedTasks,
         "Expected active download task to contain %s item(s), but contained %s item(s)",
-        globalDownloadTasks.size());
+        globalDownloadTasks.size(),
+        expectedTasks);
     List<FileDownloadTask> downloadTasksAtParent =
         StorageTaskManager.getInstance().getDownloadTasksUnder(reference.getParent());
     Preconditions.checkState(
@@ -275,7 +276,8 @@ private static void verifyTaskCount(StorageReference reference, int expectedTask
         "Expected active download task at location %s to contain %s item(s), "
             + "but contained %s item(s)",
         reference.getParent(),
-        downloadTasksAtParent.size());
+        downloadTasksAtParent.size(),
+        expectedTasks);
   }
 
   private static String fileTaskToString(FileDownloadTask.TaskSnapshot state) {
diff --git a/firebase-storage/src/testUtil/java/com/google/firebase/storage/TestUploadHelper.java b/firebase-storage/src/testUtil/java/com/google/firebase/storage/TestUploadHelper.java
index a86b2d17f..dc01718cc 100644
--- a/firebase-storage/src/testUtil/java/com/google/firebase/storage/TestUploadHelper.java
+++ b/firebase-storage/src/testUtil/java/com/google/firebase/storage/TestUploadHelper.java
@@ -16,8 +16,8 @@
 
 import android.app.Activity;
 import android.net.Uri;
-import android.support.annotation.Nullable;
 import android.util.Log;
+import androidx.annotation.Nullable;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.tasks.OnCanceledListener;
 import com.google.android.gms.tasks.OnCompleteListener;
@@ -134,10 +134,8 @@ public void onSuccess(TaskSnapshot state) {
         });
   }
 
-  public static Task<StringBuilder> uploadWithSpace() {
+  public static Task<StringBuilder> byteUpload(StorageReference storage) {
     final StringBuilder builder = new StringBuilder();
-    StorageReference storage =
-        FirebaseStorage.getInstance().getReference().child("hello world.txt");
     String foo = "This is a test!!!";
     byte[] bytes = foo.getBytes(Charset.forName("UTF-8"));
     StorageMetadata metadata = new StorageMetadata.Builder().setContentType("text/plain").build();
@@ -300,7 +298,7 @@ public void onSuccess(UploadTask.TaskSnapshot state) {
      * indicates end of stream.
      */
     class WonkyStream extends InputStream {
-      private ArrayList<byte[]> streamData = new ArrayList<>();
+      private final ArrayList<byte[]> streamData = new ArrayList<>();
 
       private WonkyStream() {
         streamData.add(new byte[] {0, 1, 2});
@@ -319,17 +317,6 @@ public int read() {
         }
       }
 
-      private void removeData(int removeFirst) {
-        if (streamData.get(0).length == removeFirst) {
-          streamData.remove(0);
-        } else {
-          streamData.set(
-              0,
-              Arrays.copyOfRange(
-                  streamData.get(0), removeFirst, streamData.get(0).length - removeFirst));
-        }
-      }
-
       @Override
       public int read(byte[] b, int off, int len) {
         if (streamData.isEmpty()) {
@@ -342,6 +329,17 @@ public int read(byte[] b, int off, int len) {
         }
       }
 
+      private void removeData(int removeFirst) {
+        if (streamData.get(0).length == removeFirst) {
+          streamData.remove(0);
+        } else {
+          streamData.set(
+              0,
+              Arrays.copyOfRange(
+                  streamData.get(0), removeFirst, streamData.get(0).length - removeFirst));
+        }
+      }
+
       @Override
       public int available() {
         if (streamData.isEmpty()) {
diff --git a/firebase-storage/src/testUtil/java/com/google/firebase/storage/network/MockInputStreamHelper.java b/firebase-storage/src/testUtil/java/com/google/firebase/storage/network/MockInputStreamHelper.java
index af31ca3fc..e03c90575 100644
--- a/firebase-storage/src/testUtil/java/com/google/firebase/storage/network/MockInputStreamHelper.java
+++ b/firebase-storage/src/testUtil/java/com/google/firebase/storage/network/MockInputStreamHelper.java
@@ -71,7 +71,7 @@ public int read(byte[] b, int off, int len) throws IOException {
     }
 
     int bytesRead = inputStream.read(b, off, len);
-    currentOffset += bytesRead > 0 ? bytesRead : 0;
+    currentOffset += Math.max(bytesRead, 0);
     return bytesRead;
   }
 
diff --git a/firebase-storage/test-app/src/main/AndroidManifest.xml b/firebase-storage/test-app/src/main/AndroidManifest.xml
index 6eac4c9bd..388548293 100644
--- a/firebase-storage/test-app/src/main/AndroidManifest.xml
+++ b/firebase-storage/test-app/src/main/AndroidManifest.xml
@@ -24,7 +24,7 @@
     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
 
     <application
-        android:name="android.support.multidex.MultiDexApplication"
+        android:name="androidx.multidex.MultiDexApplication"
         android:allowBackup="true"
         android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
diff --git a/firebase-storage/test-app/src/main/java/com/example/storage/MainActivity.java b/firebase-storage/test-app/src/main/java/com/example/storage/MainActivity.java
index b5fd4695d..4689c4e57 100644
--- a/firebase-storage/test-app/src/main/java/com/example/storage/MainActivity.java
+++ b/firebase-storage/test-app/src/main/java/com/example/storage/MainActivity.java
@@ -25,10 +25,6 @@
 import android.os.CountDownTimer;
 import android.os.Environment;
 import android.os.StrictMode;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.v4.app.ActivityCompat;
-import android.support.v7.app.AppCompatActivity;
 import android.util.Log;
 import android.view.Menu;
 import android.view.MenuItem;
@@ -36,10 +32,15 @@
 import android.widget.EditText;
 import android.widget.ImageView;
 import android.widget.TextView;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.core.app.ActivityCompat;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.tasks.Continuation;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
+import com.google.firebase.FirebaseApp;
 import com.google.firebase.auth.FirebaseAuth;
 import com.google.firebase.storage.FirebaseStorage;
 import com.google.firebase.storage.TestCommandHelper;
@@ -104,7 +105,9 @@ protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.activity_main);
 
+    FirebaseApp.initializeApp(getApplicationContext());
     FirebaseAuth.getInstance().signInAnonymously();
+    FirebaseStorage storage = FirebaseStorage.getInstance();
 
     Button clickButton = findViewById(R.id.streamDownload);
     clickButton.setOnClickListener(
@@ -156,7 +159,7 @@ protected void onCreate(Bundle savedInstanceState) {
                 "uploadWithSpace",
                 () -> {
                   try {
-                    return TestUploadHelper.uploadWithSpace();
+                    return TestUploadHelper.byteUpload(storage.getReference("hello world.txt"));
                   } catch (Exception e) {
                     e.printStackTrace();
                   }
diff --git a/firebase-storage/test-app/src/main/java/com/google/firebase/storage/network/RecordingHttpURLConnection.java b/firebase-storage/test-app/src/main/java/com/google/firebase/storage/network/RecordingHttpURLConnection.java
index 81c3ed570..43db46ef3 100644
--- a/firebase-storage/test-app/src/main/java/com/google/firebase/storage/network/RecordingHttpURLConnection.java
+++ b/firebase-storage/test-app/src/main/java/com/google/firebase/storage/network/RecordingHttpURLConnection.java
@@ -15,8 +15,8 @@
 package com.google.firebase.storage.network;
 
 import android.os.Build;
-import android.support.annotation.Nullable;
 import android.util.Base64;
+import androidx.annotation.Nullable;
 import java.io.BufferedInputStream;
 import java.io.BufferedReader;
 import java.io.ByteArrayInputStream;
diff --git a/firebase-storage/test-app/src/main/res/layout/activity_main.xml b/firebase-storage/test-app/src/main/res/layout/activity_main.xml
index 6dddfa7ce..24546ef22 100644
--- a/firebase-storage/test-app/src/main/res/layout/activity_main.xml
+++ b/firebase-storage/test-app/src/main/res/layout/activity_main.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
-<android.support.design.widget.CoordinatorLayout
+<androidx.coordinatorlayout.widget.CoordinatorLayout
     xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:app="http://schemas.android.com/apk/res-auto"
     xmlns:tools="http://schemas.android.com/tools"
@@ -9,4 +9,4 @@
     tools:context="com.google.firebase.storage.MainActivity">
 
     <include layout="@layout/content_main"/>
-</android.support.design.widget.CoordinatorLayout>
+</androidx.coordinatorlayout.widget.CoordinatorLayout>
diff --git a/firebase-storage/test-app/test-app.gradle b/firebase-storage/test-app/test-app.gradle
index 8a2408b82..0784665ee 100644
--- a/firebase-storage/test-app/test-app.gradle
+++ b/firebase-storage/test-app/test-app.gradle
@@ -24,7 +24,7 @@ android {
     targetSdkVersion project.targetSdkVersion
     versionCode 1
     versionName "1.0"
-    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
     multiDexEnabled true
   }
 
@@ -49,14 +49,16 @@ dependencies {
 
   // We intentionally use an open ended version to pick up any SNAPSHOT
   // versions published to the root project' s build/ directory.
-  implementation 'com.google.firebase:firebase-auth:17+'
-  implementation 'com.google.firebase:firebase-common:17+'
+  implementation 'com.google.firebase:firebase-auth:18+'
+  implementation 'com.google.firebase:firebase-common:18+'
+  implementation 'com.google.android.gms:play-services-basement:17.0.0'
+  implementation 'com.google.android.gms:play-services-base:17.0.0'
 
-  implementation "com.android.support:design:27.1.1"
-  implementation "com.android.support:appcompat-v7:27.1.1"
+  implementation 'com.google.android.material:material:1.0.0'
+  implementation 'androidx.appcompat:appcompat:1.0.2'
 
-  androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
-  androidTestImplementation 'com.android.support.test:rules:1.0.2'
+  androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
+  androidTestImplementation 'androidx.test:rules:1.2.0'
 }
 
 
@@ -65,4 +67,4 @@ dependencies {
 // androidTest integration tests.
 // ==========================================================================
 ext.packageName = "com.example.storage"
-apply from: '../../gradle/googleServices.gradle'
\ No newline at end of file
+apply from: '../../gradle/googleServices.gradle'
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 000000000..eec402919
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,25 @@
+# Copyright 2019 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+org.gradle.jvmargs=-Xmx8g -XX:MaxPermSize=8g
+
+org.gradle.jvmargs=-Xmx8g -XX:MaxPermSize=8g
+
+android.enableJetifier=true
+android.useAndroidX=true
+
+org.gradle.parallel=true
+org.gradle.caching=true
+
+firebase.checks.errorproneProjects=:tools:errorprone
+firebase.checks.lintProjects=:tools:lint
diff --git a/gradle/googleServices.gradle b/gradle/googleServices.gradle
index c2e8e3802..200a3964d 100644
--- a/gradle/googleServices.gradle
+++ b/gradle/googleServices.gradle
@@ -48,7 +48,7 @@ def isTesting = getGradle().getStartParameter().getTaskNames().any({ String task
 
     // this is needed for storage test app to build
     def hasStorageAppAssembleTask = taskName == ":firebase-storage:test-app:assembleRelease"
-    return hasProjectTestTask || hasStorageAppAssembleTask || taskName.contains('connectedCheck') || taskName.contains('deviceCheck')
+    return hasProjectTestTask || hasStorageAppAssembleTask || taskName.contains('connectedCheck') || taskName.contains('deviceCheck') || taskName.contains('AndroidTest')
 })
 
 if (isTesting) {
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 842b452bd..e247862be 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.2-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip
diff --git a/protolite-well-known-types/gradle.properties b/protolite-well-known-types/gradle.properties
index c763f6446..54be3eb47 100644
--- a/protolite-well-known-types/gradle.properties
+++ b/protolite-well-known-types/gradle.properties
@@ -1,2 +1,2 @@
-version=16.0.2
-latestReleasedVersion=16.0.1
+version=17.0.1
+latestReleasedVersion=17.0.0
diff --git a/protolite-well-known-types/protolite-well-known-types.gradle b/protolite-well-known-types/protolite-well-known-types.gradle
index 3de9d754a..a86068e99 100644
--- a/protolite-well-known-types/protolite-well-known-types.gradle
+++ b/protolite-well-known-types/protolite-well-known-types.gradle
@@ -60,6 +60,6 @@ android {
 
 dependencies {
     implementation 'com.google.protobuf:protobuf-lite:3.0.1'
-    protobuf 'com.google.protobuf:protobuf-java:3.5.1'
-    protobuf 'com.google.api.grpc:proto-google-common-protos:1.11.0'
+    protobuf 'com.google.protobuf:protobuf-java:3.6.1'
+    protobuf 'com.google.api.grpc:proto-google-common-protos:1.12.0'
 }
diff --git a/root-project.gradle b/root-project.gradle
index b0d63dcaa..c013e5275 100644
--- a/root-project.gradle
+++ b/root-project.gradle
@@ -15,7 +15,7 @@
 import com.google.firebase.gradle.plugins.license.LicenseResolverPlugin
 
 buildscript {
-    ext.kotlinVersion = '1.3.20'
+    ext.kotlinVersion = '1.3.50'
     repositories {
         google()
         jcenter()
@@ -26,12 +26,12 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.2.1'
-        classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.6'
-        classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.6'
+        classpath 'com.android.tools.build:gradle:3.4.2'
+        classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.8'
+        classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.7.1'
         classpath 'org.jsoup:jsoup:1.11.2'
-        classpath 'gradle.plugin.com.github.sherter.google-java-format:google-java-format-gradle-plugin:0.6'
-        classpath 'com.google.gms:google-services:4.1.0'
+        classpath 'gradle.plugin.com.github.sherter.google-java-format:google-java-format-gradle-plugin:0.8'
+        classpath 'com.google.gms:google-services:4.3.0'
         classpath 'me.tatarka:gradle-retrolambda:3.7.1'
         classpath 'digital.wup:android-maven-publish:3.6.2'
         classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion"
@@ -46,12 +46,13 @@ ext {
     supportAnnotationsVersion = '28.0.0'
     errorproneVersion = '2.3.2'
     errorproneJavacVersion = '9+181-r4173-1'
-    googleTruthVersion = '0.40'
+    googleTruthVersion = '0.45'
     robolectricVersion = '4.1'
 }
 
 apply plugin: com.google.firebase.gradle.plugins.publish.PublishingPlugin
 apply plugin: com.google.firebase.gradle.plugins.ci.ContinuousIntegrationPlugin
+apply plugin: com.google.firebase.gradle.plugins.ci.SmokeTestsPlugin
 apply plugin: com.google.firebase.gradle.plugins.ci.metrics.MetricsPlugin
 
 firebaseContinuousIntegration {
@@ -78,7 +79,7 @@ configure(subprojects) {
     }
     apply plugin: 'com.github.sherter.google-java-format'
     googleJavaFormat {
-        toolVersion = '1.6'
+        toolVersion = '1.7'
     }
     tasks.googleJavaFormat {
         source '.'
@@ -102,10 +103,12 @@ configure(subprojects) {
     }
     task(['type': JacocoReport, 'dependsOn': 'check', 'group': 'Coverage',
           'description': 'Generates JaCoCo unit test coverage reports.'], checkCoverage) {
-        def excludes = ['**/R.class', '**/R$*.class', '**/BuildConfig.*', '**Manifest*.*']
+        def excludes = ['**/R.class', '**/R$*.class', '**/BuildConfig.*', '**/proto/**', '**Manifest*.*']
         classDirectories = files([
-            fileTree(dir: "$buildDir/intermediates/javac", excludes: excludes),
-            fileTree(dir: "$buildDir/tmp/kotlin-classes", excludes: excludes)
+            fileTree(dir: "$buildDir/intermediates/javac/release", excludes: excludes),
+            fileTree(dir: "$buildDir/intermediates/javac/releaseUnitTest", excludes: excludes),
+            fileTree(dir: "$buildDir/tmp/kotlin-classes/release", excludes: excludes),
+            fileTree(dir: "$buildDir/tmp/kotlin-classes/releaseUnitTest", excludes: excludes),
         ])
         sourceDirectories = files(['src/main/java', 'src/main/kotlin'])
         executionData = fileTree(dir: "$buildDir", includes: ['jacoco/*.exec'])
@@ -124,53 +127,8 @@ configure(subprojects) {
     }
 
     apply plugin: "org.jlleitschuh.gradle.ktlint"
-
-    // Adds firebase custom errorprone checks to the annotation processor classpath.
-    configurations.whenObjectAdded {
-        if (it.name == 'annotationProcessor' && project != project(':tools:errorprone')) {
-            dependencies {
-                annotationProcessor project(':tools:errorprone')
-            }
-        } else if (it.name == 'lintChecks' && project != project(':tools:lint')) {
-            dependencies {
-                lintChecks project(':tools:lint')
-            }
-        }
-    }
 }
 
-/**
- * Disable "debug" build type for all subprojects.
- *
- * They are identical to "release" and are not used in either release or smoke tests. Disabling them
- * to reduce the number of tests we run on pre/post-submit.
- */
-configure(subprojects) {
-    afterEvaluate { Project sub ->
-        if (!sub.plugins.hasPlugin('com.android.library') && !sub.plugins.hasPlugin('com.android.application')) {
-            return
-        }
-
-        // skip debug unit tests in CI
-        // TODO(vkryachko): provide ability for teams to control this if needed
-        if (System.getenv().containsKey("FIREBASE_CI")) {
-            sub.tasks.all {Task task ->
-                if (task.name == 'testDebugUnitTest') {
-                    task.enabled = false
-                }
-            }
-        }
-        sub.android {
-            testBuildType "release"
-
-            buildTypes {
-                // In the case of and android library signing config only affects instrumentation test APK.
-                // We need it signed with default debug credentials in order for FTL to accept the APK.
-                release.signingConfig = debug.signingConfig
-            }
-        }
-    }
-}
 
 /**
  * Configure "Preguarding" and Desugaring for the subprojects.
diff --git a/smoke-tests/build.gradle b/smoke-tests/build.gradle
index 087c2b0d0..7a80b78b0 100644
--- a/smoke-tests/build.gradle
+++ b/smoke-tests/build.gradle
@@ -12,6 +12,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+import java.nio.file.Files
+import java.nio.file.Path
+import java.nio.file.Paths
+
 buildscript {
   repositories {
     google()
@@ -19,15 +23,15 @@ buildscript {
   }
 
   dependencies {
-    classpath "com.android.tools.build:gradle:3.3.2"
-    classpath "com.google.gms:google-services:4.0.0"
+    classpath "com.android.tools.build:gradle:3.4.2"
+    classpath "com.google.gms:google-services:4.3.0"
   }
 }
 
 apply plugin: "com.android.application"
 
 android {
-  compileSdkVersion 24
+  compileSdkVersion 28
 
   defaultConfig {
     minSdkVersion 16
@@ -35,83 +39,63 @@ android {
     testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
   }
 
+  buildTypes {
+    release {
+      minifyEnabled true
+      shrinkResources true
+      signingConfig signingConfigs.debug
+      proguardFiles getDefaultProguardFile("proguard-android-optimize.txt"), "smoke-test-rules.pro"
+      testProguardFiles "infrastructure-rules.pro"
+    }
+  }
+
+  if (project.hasProperty("testBuildType")) {
+    testBuildType project.getProperty("testBuildType")
+  }
+
   flavorDimensions "systemUnderTest"
 
+  // TODO(allisonbm92): Switch to the default flavor.
   productFlavors {
     combined {
       dimension "systemUnderTest"
       applicationId "com.google.firebase.testing.combined"
     }
-
-    database {
-      dimension "systemUnderTest"
-      applicationId "com.google.firebase.testing.database"
-    }
-
-    firestore {
-      dimension "systemUnderTest"
-      applicationId "com.google.firebase.testing.firestore"
-    }
-
-    storage {
-      dimension "systemUnderTest"
-      applicationId "com.google.firebase.testing.storage"
-    }
-  }
-
-  sourceSets {
-    combined {
-      java.srcDirs = [
-          "src/combined/java",
-	  "src/database/java",
-	  "src/firestore/java",
-	  "src/functions/java",
-	  "src/storage/java",
-      ]
-    }
   }
-}
-
-repositories {
-  google()
-  jcenter()
 
-  // This is necessary for Bill of Materials injection. This repository is created by running the
-  // `publishAllToBuildDir` task on the main firebase-android-sdk project.
-  maven {
-    url "../build/m2repository/"
-  }
 }
 
 apply from: "configure.gradle"
 
 dependencies {
   // Common
-  api "androidx.test:runner:1.1.0"
-  api "com.google.truth:truth:0.43"
-  api "junit:junit:4.12"
-
-  implementation "androidx.test:rules:1.1.0"
+  implementation "androidx.test:rules:1.2.0"
+  implementation "androidx.test:runner:1.2.0"
   implementation "com.google.firebase:firebase-common"
+  implementation "com.google.truth:truth:0.44"
+  implementation "junit:junit:4.12"
 
   // All
+  combinedImplementation "com.google.firebase:firebase-analytics"
   combinedImplementation "com.google.firebase:firebase-auth"
   combinedImplementation "com.google.firebase:firebase-database"
   combinedImplementation "com.google.firebase:firebase-firestore"
   combinedImplementation "com.google.firebase:firebase-functions"
+  combinedImplementation "com.google.firebase:firebase-inappmessaging"
+  combinedImplementation "com.google.firebase:firebase-config"
   combinedImplementation "com.google.firebase:firebase-storage"
 
-  // Database
-  databaseImplementation "com.google.firebase:firebase-auth"
-  databaseImplementation "com.google.firebase:firebase-database"
+  androidTestImplementation "androidx.test:core:1.2.0"
+  androidTestImplementation "androidx.test:runner:1.2.0"
+  androidTestImplementation "junit:junit:4.12"
+}
 
-  // Firestore
-  firestoreImplementation "com.google.firebase:firebase-auth"
-  firestoreImplementation "com.google.firebase:firebase-firestore"
+clean.doLast {
+  def paths = Files.newDirectoryStream(Paths.get("."), "build-*")
 
-  // Storage
-  storageImplementation "com.google.firebase:firebase-auth"
-  storageImplementation "com.google.firebase:firebase-storage"
+  for (Path path : paths) {
+    project.delete "$path/"
+  }
 }
 
 apply plugin: "com.google.gms.google-services"
diff --git a/smoke-tests/configure.gradle b/smoke-tests/configure.gradle
index 531d2576a..9caa0d0ea 100644
--- a/smoke-tests/configure.gradle
+++ b/smoke-tests/configure.gradle
@@ -14,7 +14,7 @@
 
 
 def configurePlatform() {
-  def bom = "com.google.firebase:firebase-bom:18.1.0"
+  def bom = "com.google.firebase:firebase-bom:20.0.0"
   if (project.hasProperty("firebase-bom")) {
     bom = project.getProperty("firebase-bom")
   }
@@ -30,4 +30,23 @@ def configurePlatform() {
   }
 }
 
+def configureRepositories() {
+  def m2repo = "../build/m2repository/"
+  if (project.hasProperty("m2repo")) {
+    m2repo = project.getProperty("m2repo")
+  }
+
+  project.repositories {
+    // This is necessary for Bill of Materials injection. This repository is created by running the
+    // `assembleAllForSmokeTests` task on the main firebase-android-sdk project.
+    maven {
+      url m2repo
+    }
+
+    google()
+    jcenter()
+  }
+}
+
+configureRepositories()
 configurePlatform()
diff --git a/smoke-tests/gradle.properties b/smoke-tests/gradle.properties
new file mode 100644
index 000000000..1340490eb
--- /dev/null
+++ b/smoke-tests/gradle.properties
@@ -0,0 +1,16 @@
+# Copyright 2019 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+android.enableR8=true
+android.useAndroidX=true
diff --git a/smoke-tests/infrastructure-rules.pro b/smoke-tests/infrastructure-rules.pro
new file mode 100644
index 000000000..9032f3729
--- /dev/null
+++ b/smoke-tests/infrastructure-rules.pro
@@ -0,0 +1,3 @@
+-dontobfuscate
+-dontoptimize
+-dontshrink
diff --git a/smoke-tests/runner.config b/smoke-tests/runner.config
new file mode 100644
index 000000000..c3bdeee34
--- /dev/null
+++ b/smoke-tests/runner.config
@@ -0,0 +1,82 @@
+core {
+  # gcloud
+  ## This option is the path to the Gcloud executable. It may be relative or
+  ## absolute. This is optional, because the default is `/usr/bin/gcloud`.
+
+  # gradle
+  ## This option is the path to the Gradle executable. It may be relative or
+  ## absolute. This is optional, because the default is `gradlew`.
+
+  # loggingDir
+  ## This option is the path to the directory to be used for logging. All logs
+  ## from the test runner and its sub-processes will be placed in this
+  ## directory. It is optional, and is configured by the `ARTIFACTS` environment
+  ## variable by default.
+}
+
+firebase {
+  # buildTask
+  ## This option specifies the Gradle task to execute to build Firebase
+  ## libraries. It is mandatory.
+  buildTask assembleAllForSmokeTests
+
+  # localMavenRepo
+  ## This option specifies the path to a local Maven repository. This repository
+  ## should contain the Firebase artifacts constructed by the build task. It is
+  ## mandatory.
+  localMavenRepo build/m2repository
+
+  # latestBillOfMaterials
+  ## This option specifies the Bill of Materials for the latest release. This is
+  ## given as a Maven id. The tests will use this information to build a test
+  ## matrix. This is mandatory.
+  latestBillOfMaterials com.google.firebase:firebase-bom:22.1.0
+
+  # project
+  ## This option specifies the path to the main Firebase project. This is
+  ## optional and defaults to the current directory.
+}
+
+smokeTest {
+  # flavors
+  ## This option specifies the Android flavors of the test to build for testing.
+  ## It may be omitted if there are no flavors.
+  flavors combined
+
+  # googleServices
+  ## This option is the path to the Google Services file. If provided, the
+  ## runner will make this available to the build. This file must be
+  ## manually placed in the smoke tests' project directory if this option
+  ## is unspecified.
+  googleServices /smoke-tests-google-services/google-services.json
+
+  # project
+  ## This option specifies the path to the smoke tests' project. It may be
+  ## relative or absolute. It is mandatory.
+  project smoke-tests
+
+  # variants
+  ## This option specifies the Android build variants to build for testing. It
+  ## is mandatory, and there must be at least one build variant.
+  variants debug, release
+}
+
+testLab {
+  # artifactsBucket
+  ## This option specifies the target GCS bucket for uploading test lab logs.
+  ## These logs are not written to core.loggingDir. This is optional, and the
+  ## public, test lab bucket will be used if nothing is provided. Note, the
+  ## artifactsDir option must also be specified for this to take effect.
+  artifactsBucket android-ci
+
+  # artifactsDir
+  ## This option specifies the directory to use within the bucket specified by
+  ## the artifactsBucket option. It is constructed by default using environment
+  ## variables.
+
+  # credentials
+  ## This option is the path to a Google credentials file. It is optional. If
+  ## provided, the runner will authenticate to Google Cloud before running any
+  ## tests on Firebase Test Lab. The default configuration is determined by the
+  ## `GOOGLE_APPLICATION_CREDENTIALS` environment variable.
+}
diff --git a/smoke-tests/smoke-test-rules.pro b/smoke-tests/smoke-test-rules.pro
new file mode 100644
index 000000000..dba28d601
--- /dev/null
+++ b/smoke-tests/smoke-test-rules.pro
@@ -0,0 +1,23 @@
+-optimizationpasses 3
+-keepattributes SourceFile, LineNumberTable, *Annotation*
+
+-keep @org.junit.runner.RunWith class *
+-keep class androidx.test.**
+-keep class org.junit.**
+
+-keepclassmembers @org.junit.runner.RunWith class * {
+  public <methods>;
+  public <fields>;
+}
+
+-keepclassmembers class androidx.test.** {
+  public <methods>;
+}
+
+-keepclassmembers class org.junit.** {
+  protected <methods>;
+  public <methods>;
+}
+
+-dontwarn android.**
+-dontwarn okio.**
diff --git a/smoke-tests/src/androidTest/java/com/google/firebase/testing/common/SmokeTestSuite.java b/smoke-tests/src/androidTest/java/com/google/firebase/testing/common/SmokeTestSuite.java
index aa615bf61..43ce6c868 100644
--- a/smoke-tests/src/androidTest/java/com/google/firebase/testing/common/SmokeTestSuite.java
+++ b/smoke-tests/src/androidTest/java/com/google/firebase/testing/common/SmokeTestSuite.java
@@ -17,7 +17,7 @@
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
-import androidx.test.InstrumentationRegistry;
+import androidx.test.core.app.ApplicationProvider;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -69,7 +69,7 @@ protected void runChild(Runner runner, RunNotifier notifier) {
   }
 
   private static List<Class<?>> getTestClasses() throws InitializationError {
-    Context ctx = InstrumentationRegistry.getTargetContext();
+    Context ctx = ApplicationProvider.getApplicationContext();
     return getTestClasses(ctx);
   }
 
diff --git a/smoke-tests/src/combined/java/com/google/firebase/testing/combined/AllTests.java b/smoke-tests/src/combined/java/com/google/firebase/testing/combined/AllTests.java
index 99ced1081..c490e93cf 100644
--- a/smoke-tests/src/combined/java/com/google/firebase/testing/combined/AllTests.java
+++ b/smoke-tests/src/combined/java/com/google/firebase/testing/combined/AllTests.java
@@ -17,6 +17,8 @@
 import com.google.firebase.testing.database.DatabaseTest;
 import com.google.firebase.testing.firestore.FirestoreTest;
 import com.google.firebase.testing.functions.FunctionsTest;
+import com.google.firebase.testing.inappmessaging.InappMessagingTest;
+import com.google.firebase.testing.remoteconfig.RemoteConfigTest;
 import com.google.firebase.testing.storage.StorageTest;
 import org.junit.runner.RunWith;
 import org.junit.runners.Suite;
@@ -25,5 +27,12 @@
  * A test suite combining the individual product flavors.
  */
 @RunWith(Suite.class)
-@Suite.SuiteClasses({DatabaseTest.class, FirestoreTest.class, FunctionsTest.class, StorageTest.class})
+@Suite.SuiteClasses({
+  DatabaseTest.class,
+  FirestoreTest.class,
+  FunctionsTest.class,
+  InappMessagingTest.class,
+  RemoteConfigTest.class,
+  StorageTest.class,
+})
 public final class AllTests {}
diff --git a/smoke-tests/src/database/java/com/google/firebase/testing/database/DatabaseTest.java b/smoke-tests/src/combined/java/com/google/firebase/testing/database/DatabaseTest.java
similarity index 100%
rename from smoke-tests/src/database/java/com/google/firebase/testing/database/DatabaseTest.java
rename to smoke-tests/src/combined/java/com/google/firebase/testing/database/DatabaseTest.java
diff --git a/smoke-tests/src/firestore/java/com/google/firebase/testing/firestore/FirestoreTest.java b/smoke-tests/src/combined/java/com/google/firebase/testing/firestore/FirestoreTest.java
similarity index 100%
rename from smoke-tests/src/firestore/java/com/google/firebase/testing/firestore/FirestoreTest.java
rename to smoke-tests/src/combined/java/com/google/firebase/testing/firestore/FirestoreTest.java
diff --git a/smoke-tests/src/functions/java/com/google/firebase/testing/functions/FunctionsTest.java b/smoke-tests/src/combined/java/com/google/firebase/testing/functions/FunctionsTest.java
similarity index 100%
rename from smoke-tests/src/functions/java/com/google/firebase/testing/functions/FunctionsTest.java
rename to smoke-tests/src/combined/java/com/google/firebase/testing/functions/FunctionsTest.java
diff --git a/smoke-tests/src/combined/java/com/google/firebase/testing/inappmessaging/InappMessagingTest.java b/smoke-tests/src/combined/java/com/google/firebase/testing/inappmessaging/InappMessagingTest.java
new file mode 100644
index 000000000..aa7d32e03
--- /dev/null
+++ b/smoke-tests/src/combined/java/com/google/firebase/testing/inappmessaging/InappMessagingTest.java
@@ -0,0 +1,31 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.testing.inappmessaging;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.firebase.inappmessaging.FirebaseInAppMessaging;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class InappMessagingTest {
+
+  @Test
+  public void getInstanceReturnsNotNull() {
+    assertThat(FirebaseInAppMessaging.getInstance()).isNotNull();
+  }
+}
diff --git a/smoke-tests/src/combined/java/com/google/firebase/testing/remoteconfig/RemoteConfigTest.java b/smoke-tests/src/combined/java/com/google/firebase/testing/remoteconfig/RemoteConfigTest.java
new file mode 100644
index 000000000..adaced919
--- /dev/null
+++ b/smoke-tests/src/combined/java/com/google/firebase/testing/remoteconfig/RemoteConfigTest.java
@@ -0,0 +1,67 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.testing.remoteconfig;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.firebase.testing.common.Tasks2.waitForSuccess;
+
+import android.app.Activity;
+import androidx.test.rule.ActivityTestRule;
+import androidx.test.runner.AndroidJUnit4;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfig;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigValue;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public final class RemoteConfigTest {
+
+  private static final String MODEL_NAME = "Acura/Honda+Mercedes-Benz";
+  private static final boolean COLOR_IS_RED = true;
+
+  @Rule public final ActivityTestRule<Activity> activity = new ActivityTestRule<>(Activity.class);
+
+  @Before
+  public void prepareRemoteConfig() throws Exception {
+    FirebaseRemoteConfig frc = FirebaseRemoteConfig.getInstance();
+
+    waitForSuccess(frc.fetch());
+    waitForSuccess(frc.activate());
+  }
+
+  @Test
+  public void getBooleanConvertsValueSetInConsole() {
+    FirebaseRemoteConfig frc = FirebaseRemoteConfig.getInstance();
+
+    assertThat(frc.getBoolean("COLOR_IS_RED")).isEqualTo(COLOR_IS_RED);
+  }
+
+  @Test
+  public void getStringReturnsValueSetInConsole() {
+    FirebaseRemoteConfig frc = FirebaseRemoteConfig.getInstance();
+
+    assertThat(frc.getString("MODEL_NAME")).isEqualTo(MODEL_NAME);
+  }
+
+  @Test
+  public void getValueNotSetInConsoleYieldsStaticSource() {
+    FirebaseRemoteConfig frc = FirebaseRemoteConfig.getInstance();
+    FirebaseRemoteConfigValue value = frc.getValue("GOOBER_GOOBER");
+
+    assertThat(value.getSource()).isEqualTo(FirebaseRemoteConfig.VALUE_SOURCE_STATIC);
+  }
+}
diff --git a/smoke-tests/src/storage/java/com/google/firebase/testing/storage/StorageTest.java b/smoke-tests/src/combined/java/com/google/firebase/testing/storage/StorageTest.java
similarity index 100%
rename from smoke-tests/src/storage/java/com/google/firebase/testing/storage/StorageTest.java
rename to smoke-tests/src/combined/java/com/google/firebase/testing/storage/StorageTest.java
diff --git a/smoke-tests/src/database/AndroidManifest.xml b/smoke-tests/src/database/AndroidManifest.xml
deleted file mode 100644
index 7424d5dda..000000000
--- a/smoke-tests/src/database/AndroidManifest.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.google.firebase.testing">
-
-  <uses-permission android:name="android.permission.INTERNET" />
-
-  <application>
-    <activity android:name="android.app.Activity">
-      <intent-filter>
-        <action android:name="android.intent.action.MAIN" />
-        <category android:name="android.intent.category.LAUNCHER" />
-      </intent-filter>
-    </activity>
-
-    <meta-data android:name="com.google.firebase.testing.classes"
-      android:value="com.google.firebase.testing.database.DatabaseTest" />
-  </application>
-</manifest>
diff --git a/smoke-tests/src/firestore/AndroidManifest.xml b/smoke-tests/src/firestore/AndroidManifest.xml
deleted file mode 100644
index 910b5b59f..000000000
--- a/smoke-tests/src/firestore/AndroidManifest.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.google.firebase.testing">
-
-  <uses-permission android:name="android.permission.INTERNET" />
-
-  <application>
-    <activity android:name="android.app.Activity">
-      <intent-filter>
-        <action android:name="android.intent.action.MAIN" />
-        <category android:name="android.intent.category.LAUNCHER" />
-      </intent-filter>
-    </activity>
-
-    <meta-data android:name="com.google.firebase.testing.classes"
-      android:value="com.google.firebase.testing.firestore.FirestoreTest" />
-  </application>
-</manifest>
diff --git a/smoke-tests/src/storage/AndroidManifest.xml b/smoke-tests/src/storage/AndroidManifest.xml
deleted file mode 100644
index 073db5223..000000000
--- a/smoke-tests/src/storage/AndroidManifest.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.google.firebase.testing">
-
-  <uses-permission android:name="android.permission.INTERNET" />
-
-  <application>
-    <activity android:name="android.app.Activity">
-      <intent-filter>
-        <action android:name="android.intent.action.MAIN" />
-        <category android:name="android.intent.category.LAUNCHER" />
-      </intent-filter>
-    </activity>
-
-    <meta-data android:name="com.google.firebase.testing.classes"
-      android:value="com.google.firebase.testing.storage.StorageTest" />
-  </application>
-</manifest>
diff --git a/subprojects.cfg b/subprojects.cfg
index 811bd1c0d..4f9d31782 100644
--- a/subprojects.cfg
+++ b/subprojects.cfg
@@ -1,25 +1,32 @@
+fiamui-app
+firebase-abt
 firebase-common
+firebase-common:data-collection-tests
 firebase-common:ktx
+firebase-config
+firebase-config:ktx
+firebase-config:bandwagoner
 firebase-database
 firebase-database-collection
+firebase-datatransport
 firebase-firestore
 firebase-firestore:ktx
 firebase-functions
 firebase-functions:ktx
+firebase-inappmessaging
 firebase-inappmessaging-display
-firebase-datatransport
-fiamui-app
 firebase-storage
+firebase-storage:ktx
 firebase-storage:test-app
-protolite-well-known-types
-
-transport
-transport:transport-api
-transport:transport-runtime
-transport:transport-backend-cct
 
+protolite-well-known-types
 
+tools:errorprone
 tools:lint
 tools:measurement:apksize
 tools:measurement:coverage
-tools:errorprone
+
+transport
+transport:transport-api
+transport:transport-backend-cct
+transport:transport-runtime
diff --git a/test-apps/.gitignore b/test-apps/.gitignore
deleted file mode 100644
index f0c7ca8f6..000000000
--- a/test-apps/.gitignore
+++ /dev/null
@@ -1,9 +0,0 @@
-.gradle
-local.properties
-.idea
-build/
-.DS_Store
-*.iml
-*.apk
-*.aar
-*.zip
diff --git a/test-apps/README.md b/test-apps/README.md
deleted file mode 100644
index abb8a9722..000000000
--- a/test-apps/README.md
+++ /dev/null
@@ -1,33 +0,0 @@
-# Test apps
-
-This experimental directory contains apps that are used to smoke test Firebase Android projects.
-
-## Prerequisites
-
-- npm must be installed
-- [Firebase CLI](https://github.com/firebase/firebase-tools/search?q=storage&unscoped_q=storage) needs to be installed.
-
-## Setup
-- At the root of the firebase android sdk repo, run the following command to publish all repos to the build dir.
-  ```
-  ./gradlew publishAllToBuildDir
-  ```
-  
-- From the [firebase console](https://console.firebae.com) for your project, create four Android apps with the following package names
-
-  ```
-  com.google.firebase.testapps.database
-  com.google.firebase.testapps.storage
-  com.google.firebase.testapps.functions
-  com.google.firebase.testapps.firestore
-  ```
-
-- Download the google-services.json and copy into the /test-apps directory
-
-- Start the android emulator
-
-- From the /test-apps dir, run the tests
-
-  ```
-  ./gradlew connectedCheck -PtestBuildType=<release|debug> -PfirebaseProjectId=<your_project_id> -PfirebaseToken=<your_firebase_token> -Pm2Repository=${PWD}/../build/m2repository/
-  ```
diff --git a/test-apps/build.gradle b/test-apps/build.gradle
deleted file mode 100644
index a1d2a4ece..000000000
--- a/test-apps/build.gradle
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Copyright 2018 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-buildscript {
-    repositories {
-        jcenter()
-        mavenLocal()
-        google()
-    }
-    dependencies {
-        classpath 'com.android.tools.build:gradle:3.2.1'
-        classpath 'com.google.gms:google-services:4.1.0'
-        classpath 'gradle.plugin.com.github.sherter.google-java-format:google-java-format-gradle-plugin:0.7.1'
-    }
-}
-
-plugins {
-    id 'com.github.ben-manes.versions' version '0.20.0'
-}
-
-apply from: '../sdkProperties.gradle'
-
-allprojects {
-    ext.testBuildType = project.getProperties().get("testBuildType", "debug")
-
-    apply plugin: 'com.github.sherter.google-java-format'
-    googleJavaFormat {
-        toolVersion = '1.6'
-    }
-    tasks.googleJavaFormat {
-        source '.'
-        include '**/*.java'
-    }
-
-    repositories {
-        //mavenLocal() can be overridden via GRADLE_OPTS="-Dmaven.repo.local=<path>"
-        mavenLocal()
-        google()
-        jcenter()
-        maven { url 'https://maven.fabric.io/public' }
-    }
-
-    task copyRootGoogleServices(type: Copy) {
-        from(System.env.FIREBASE_GOOGLE_SERVICES_PATH ?: "${rootDir}/google-services.json")
-        into projectDir
-        rename {
-            'google-services.json'
-        }
-    }
-    tasks.whenTaskAdded {
-        if ( it.name == 'processReleaseGoogleServices') {
-            it.dependsOn 'copyRootGoogleServices'
-        }
-        if ( it.name == 'processDebugGoogleServices') {
-            it.dependsOn 'copyRootGoogleServices'
-        }
-    }
-
-    if(file('test_setup.sh').exists()) {
-        task setupSmokeTest {
-            doLast {
-                project.exec {
-                    Map env = [:]
-
-                    if (System.env.PROJECT_ID) {
-                        env.put('PROJECT_ID', System.env.PROJECT_ID)
-                    }
-                    if (project.hasProperty('firebaseProjectId')) {
-                        env.put('PROJECT_ID', project.firebaseProjectId)
-                    }
-                    if (!env.PROJECT_ID) {
-                        throw new GradleException(
-                                'Fireescape project id was not set. Use -PfirebaseProjectId',
-                                new IllegalArgumentException())
-                    }
-
-                    if (System.env.FIREBASE_TOKEN) {
-                        env.put('FIREBASE_TOKEN', System.env.FIREBASE_TOKEN)
-                    }
-                    if (project.hasProperty('firebaseToken')) {
-                        env.put("FIREBASE_TOKEN", project.firebaseToken)
-                    }
-                    if(!env.FIREBASE_TOKEN) {
-                        throw new GradleException('Firebase token was not set. Use -PfirebaseToken',
-                                new IllegalArgumentException())
-                    }
-
-                    env.put('PATH', System.env.PATH)
-
-                    workingDir projectDir.absolutePath
-                    commandLine './test_setup.sh'
-
-                    //Ensure firebase cli does not output project info
-                    standardOutput = new ByteArrayOutputStream()
-
-                    //Ensure firebase cli does not output project info
-                    standardOutput = new ByteArrayOutputStream()
-
-                    environment = env
-                }
-            }
-        }
-        tasks.whenTaskAdded {
-            if ( it.name == 'connectedCheck') {
-                it.dependsOn setupSmokeTest
-                it.dependsOn rootProject.tasks.findByName("dependencyUpdates")
-            }
-        }
-    }
-}
-
-task clean(type: Delete) {
-    delete rootProject.buildDir
-}
diff --git a/test-apps/database-test-app/.gitignore b/test-apps/database-test-app/.gitignore
deleted file mode 100644
index f0c7ca8f6..000000000
--- a/test-apps/database-test-app/.gitignore
+++ /dev/null
@@ -1,9 +0,0 @@
-.gradle
-local.properties
-.idea
-build/
-.DS_Store
-*.iml
-*.apk
-*.aar
-*.zip
diff --git a/test-apps/database-test-app/accounts.json b/test-apps/database-test-app/accounts.json
deleted file mode 100644
index 1cb3bccbf..000000000
--- a/test-apps/database-test-app/accounts.json
+++ /dev/null
@@ -1,7 +0,0 @@
-{
-	"users": [{
-		"localId": "1",
-		"email": "test@mailinator.com",
-		"passwordHash": "XohImNooBHFR0OVvjcYpJ3NgPQ1qq73WKhHvch0VQtg=",
-	}]
-}
diff --git a/test-apps/database-test-app/build.gradle b/test-apps/database-test-app/build.gradle
deleted file mode 100644
index 633ceecd0..000000000
--- a/test-apps/database-test-app/build.gradle
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright 2018 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-apply plugin: 'com.android.application'
-
-android {
-    testBuildType = project.testBuildType
-    compileSdkVersion project.targetSdkVersion
-
-    defaultConfig {
-        applicationId "com.google.firebase.testapps.database"
-        minSdkVersion 16
-        targetSdkVersion project.targetSdkVersion
-        versionCode 1
-        versionName "1.0"
-        multiDexEnabled true
-
-        vectorDrawables.useSupportLibrary true
-
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled true
-            testProguardFiles getDefaultProguardFile('proguard-android.txt'), 'test-proguard-rules.pro'
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-            signingConfig signingConfigs.debug
-        }
-    }
-}
-
-configurations.all {
-    resolutionStrategy.force 'com.android.support:support-annotations:27.1.1'
-}
-
-dependencies {
-    // We intentionally use an open ended version to pick up any SNAPSHOT
-    // versions published to the root project' s build/ directory.
-    implementation 'com.google.firebase:firebase-database:+'
-    implementation 'com.google.firebase:firebase-core:16+'
-    implementation 'com.google.firebase:firebase-auth:16+'
-
-    implementation 'com.android.support.test.espresso:espresso-idling-resource:3.0.2'
-
-    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
-    androidTestImplementation 'com.android.support.test:rules:1.0.2'
-    androidTestImplementation 'com.android.support.test:runner:1.0.2'
-    androidTestImplementation 'com.android.support.test.espresso:espresso-idling-resource:3.0.2'
-}
-
-apply plugin: 'com.google.gms.google-services'
diff --git a/test-apps/database-test-app/proguard-rules.pro b/test-apps/database-test-app/proguard-rules.pro
deleted file mode 100644
index a40b64681..000000000
--- a/test-apps/database-test-app/proguard-rules.pro
+++ /dev/null
@@ -1,4 +0,0 @@
--keepattributes SourceFile,LineNumberTable
-
--keep class android.support.test.espresso.IdlingResource { *; }
--keep class android.support.test.espresso.IdlingRegistry { *; }
\ No newline at end of file
diff --git a/test-apps/database-test-app/src/androidTest/java/com/google/firebase/testapps/database/TestActivityTest.java b/test-apps/database-test-app/src/androidTest/java/com/google/firebase/testapps/database/TestActivityTest.java
deleted file mode 100644
index 1100133ee..000000000
--- a/test-apps/database-test-app/src/androidTest/java/com/google/firebase/testapps/database/TestActivityTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-// Copyright 2018 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.google.firebase.testapps.database;
-
-import android.support.test.espresso.IdlingRegistry;
-import android.support.test.espresso.IdlingResource;
-import android.support.test.filters.LargeTest;
-import android.support.test.rule.ActivityTestRule;
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import static android.support.test.espresso.Espresso.onView;
-import static android.support.test.espresso.assertion.ViewAssertions.matches;
-import static android.support.test.espresso.matcher.ViewMatchers.withId;
-import static android.support.test.espresso.matcher.ViewMatchers.withText;
-
-@LargeTest
-@RunWith(AndroidJUnit4.class)
-public class TestActivityTest {
-
-  @Rule
-  public ActivityTestRule<TestActivity> mActivityTestRule =
-      new ActivityTestRule<>(TestActivity.class);
-
-  private IdlingResource mIdlingResource;
-
-  @Before
-  public void before() {
-    mIdlingResource = mActivityTestRule.getActivity().getIdlingResource();
-    IdlingRegistry.getInstance().register(mIdlingResource);
-  }
-
-  @After
-  public void unregisterIdlingResource() {
-    if (mIdlingResource != null) {
-      IdlingRegistry.getInstance().unregister(mIdlingResource);
-    }
-  }
-
-  @Test
-  public void testActivityTest() throws Exception {
-    onView(withId(R.id.restaurant)).check(matches(withText("{location=Google MTV}")));
-  }
-}
diff --git a/test-apps/database-test-app/src/main/java/com/google/firebase/testapps/database/TestActivity.java b/test-apps/database-test-app/src/main/java/com/google/firebase/testapps/database/TestActivity.java
deleted file mode 100644
index c941e394d..000000000
--- a/test-apps/database-test-app/src/main/java/com/google/firebase/testapps/database/TestActivity.java
+++ /dev/null
@@ -1,103 +0,0 @@
-// Copyright 2018 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.google.firebase.testapps.database;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.support.annotation.Keep;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
-import android.support.test.espresso.IdlingResource;
-import android.support.test.espresso.idling.CountingIdlingResource;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import com.google.android.gms.tasks.OnSuccessListener;
-import com.google.firebase.auth.AuthResult;
-import com.google.firebase.auth.FirebaseAuth;
-import com.google.firebase.database.DataSnapshot;
-import com.google.firebase.database.DatabaseError;
-import com.google.firebase.database.FirebaseDatabase;
-import com.google.firebase.database.ValueEventListener;
-
-import java.util.Map;
-
-public class TestActivity extends Activity {
-  private final CountingIdlingResource idlingResource =
-      new CountingIdlingResource("Firebase database listener");
-  private FirebaseDatabase db;
-  private FirebaseAuth auth;
-  private TextView restaurantTextView;
-
-  @Override
-  protected void onCreate(@Nullable Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-    setContentView(R.layout.test_activity);
-
-    db = FirebaseDatabase.getInstance();
-    auth = FirebaseAuth.getInstance();
-
-    restaurantTextView = this.findViewById(R.id.restaurant);
-    idlingResource.increment();
-
-    //// Since offline persistence is enabled by default, the event listener is invoked even without
-    db.setPersistenceEnabled(false);
-
-    //// Listen for a change to the collection
-    db.getReference("restaurants")
-        .addValueEventListener(
-            new ValueEventListener() {
-              @Override
-              public void onDataChange(DataSnapshot dataSnapshot) {
-                // This method is called once with the initial value and again
-                // whenever data at this location is updated.
-                Map<String, Map<String, String>> value =
-                    (Map<String, Map<String, String>>) dataSnapshot.getValue();
-                if (value != null) {
-                  restaurantTextView.setText(value.get("Baadal").toString());
-                  idlingResource.decrement();
-                }
-              }
-
-              @Override
-              public void onCancelled(DatabaseError error) {
-                // Failed to read value
-                Toast.makeText(TestActivity.this, error.toString(), Toast.LENGTH_LONG).show();
-                idlingResource.decrement();
-              }
-            });
-
-    //// Signout of any existing sessions and sign in with email and password
-    auth.signOut();
-    auth.signInWithEmailAndPassword("test@mailinator.com", "password")
-        .addOnSuccessListener(new OnSuccessListener<AuthResult>() {
-          @Override
-          public void onSuccess(AuthResult authResult) {
-            db.getReference("restaurants")
-                    .child("Baadal")
-                    .child("location")
-                    .setValue("Google MTV");
-          }
-        });
-  }
-
-  @VisibleForTesting
-  @NonNull
-  @Keep
-  public IdlingResource getIdlingResource() {
-    return idlingResource;
-  }
-}
diff --git a/test-apps/database-test-app/test-proguard-rules.pro b/test-apps/database-test-app/test-proguard-rules.pro
deleted file mode 100644
index ee5e74b9f..000000000
--- a/test-apps/database-test-app/test-proguard-rules.pro
+++ /dev/null
@@ -1,4 +0,0 @@
--keepattributes SourceFile,LineNumberTable
-
--dontwarn org.xmlpull.v1.**
--dontnote org.xmlpull.v1.**
\ No newline at end of file
diff --git a/test-apps/database-test-app/test_setup.sh b/test-apps/database-test-app/test_setup.sh
deleted file mode 100755
index 43a5c9f77..000000000
--- a/test-apps/database-test-app/test_setup.sh
+++ /dev/null
@@ -1,25 +0,0 @@
-#Copyright 2018 Google LLC
-#
-#Licensed under the Apache License, Version 2.0 (the "License");
-#you may not use this file except in compliance with the License.
-#You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-#Unless required by applicable law or agreed to in writing, software
-#distributed under the License is distributed on an "AS IS" BASIS,
-#WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#See the License for the specific language governing permissions and
-#limitations under the License.
-
-#!/bin/bash
-set -o nounset
-set -e
-
-#delete the restaurants collection
-echo "Deleting the restaurants collection under project"
-firebase database:remove "/restaurants" -y --project="$PROJECT_ID"
-
-#create a test account test@mailinator.com
-echo "Creating test accounts"
-firebase auth:import accounts.json --hash-algo=SHA256 --rounds=1 --project="$PROJECT_ID"
diff --git a/test-apps/firestore-test-app/.gitignore b/test-apps/firestore-test-app/.gitignore
deleted file mode 100644
index f0c7ca8f6..000000000
--- a/test-apps/firestore-test-app/.gitignore
+++ /dev/null
@@ -1,9 +0,0 @@
-.gradle
-local.properties
-.idea
-build/
-.DS_Store
-*.iml
-*.apk
-*.aar
-*.zip
diff --git a/test-apps/firestore-test-app/accounts.json b/test-apps/firestore-test-app/accounts.json
deleted file mode 100644
index 1cb3bccbf..000000000
--- a/test-apps/firestore-test-app/accounts.json
+++ /dev/null
@@ -1,7 +0,0 @@
-{
-	"users": [{
-		"localId": "1",
-		"email": "test@mailinator.com",
-		"passwordHash": "XohImNooBHFR0OVvjcYpJ3NgPQ1qq73WKhHvch0VQtg=",
-	}]
-}
diff --git a/test-apps/firestore-test-app/build.gradle b/test-apps/firestore-test-app/build.gradle
deleted file mode 100644
index 395d3f6c6..000000000
--- a/test-apps/firestore-test-app/build.gradle
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright 2018 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-apply plugin: 'com.android.application'
-
-android {
-    testBuildType = project.testBuildType
-    compileSdkVersion project.targetSdkVersion
-
-    defaultConfig {
-        applicationId "com.google.firebase.testapps.firestore"
-        minSdkVersion 16
-        targetSdkVersion project.targetSdkVersion
-        versionCode 1
-        versionName "1.0"
-        multiDexEnabled true
-
-        vectorDrawables.useSupportLibrary true
-
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled true
-            testProguardFiles getDefaultProguardFile('proguard-android.txt'), 'test-proguard-rules.pro'
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-            signingConfig signingConfigs.debug
-        }
-    }
-}
-
-configurations.all {
-  resolutionStrategy.force 'com.android.support:support-annotations:27.1.1'
-}
-
-dependencies {
-    // We intentionally use an open ended version to pick up any SNAPSHOT
-    // versions published to the root project' s build/ directory.
-    implementation 'com.google.firebase:firebase-firestore:17+'
-    implementation 'com.google.firebase:firebase-core:16+'
-    implementation 'com.google.firebase:firebase-auth:16+'
-    implementation 'com.android.support.test.espresso:espresso-idling-resource:3.0.2'
-
-    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
-    androidTestImplementation 'com.android.support.test:rules:1.0.2'
-    androidTestImplementation 'com.android.support.test:runner:1.0.2'
-    androidTestImplementation 'com.android.support.test.espresso:espresso-idling-resource:3.0.2'
-}
-
-apply plugin: 'com.google.gms.google-services'
diff --git a/test-apps/firestore-test-app/proguard-rules.pro b/test-apps/firestore-test-app/proguard-rules.pro
deleted file mode 100644
index a40b64681..000000000
--- a/test-apps/firestore-test-app/proguard-rules.pro
+++ /dev/null
@@ -1,4 +0,0 @@
--keepattributes SourceFile,LineNumberTable
-
--keep class android.support.test.espresso.IdlingResource { *; }
--keep class android.support.test.espresso.IdlingRegistry { *; }
\ No newline at end of file
diff --git a/test-apps/firestore-test-app/src/androidTest/java/com/google/firebase/testapps/firestore/TestActivityTest.java b/test-apps/firestore-test-app/src/androidTest/java/com/google/firebase/testapps/firestore/TestActivityTest.java
deleted file mode 100644
index 60590606d..000000000
--- a/test-apps/firestore-test-app/src/androidTest/java/com/google/firebase/testapps/firestore/TestActivityTest.java
+++ /dev/null
@@ -1,60 +0,0 @@
-// Copyright 2018 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.google.firebase.testapps.firestore;
-
-import android.support.test.espresso.IdlingRegistry;
-import android.support.test.espresso.IdlingResource;
-import android.support.test.filters.LargeTest;
-import android.support.test.rule.ActivityTestRule;
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import static android.support.test.espresso.Espresso.onView;
-import static android.support.test.espresso.assertion.ViewAssertions.matches;
-import static android.support.test.espresso.matcher.ViewMatchers.withId;
-import static android.support.test.espresso.matcher.ViewMatchers.withText;
-
-@LargeTest
-@RunWith(AndroidJUnit4.class)
-public class TestActivityTest {
-  @Rule
-  public ActivityTestRule<TestActivity> mActivityTestRule =
-      new ActivityTestRule<>(TestActivity.class);
-
-  private IdlingResource mIdlingResource;
-
-  @Before
-  public void before() {
-    mIdlingResource = mActivityTestRule.getActivity().getIdlingResource();
-    IdlingRegistry.getInstance().register(mIdlingResource);
-  }
-
-  @After
-  public void unregisterIdlingResource() {
-    if (mIdlingResource != null) {
-      IdlingRegistry.getInstance().unregister(mIdlingResource);
-    }
-  }
-
-  @Test
-  public void testActivityTest() throws Exception {
-    onView(withId(R.id.restaurant)).check(matches(withText("{location=Google MTV}")));
-  }
-}
diff --git a/test-apps/firestore-test-app/src/main/java/com/google/firebase/testapps/firestore/TestActivity.java b/test-apps/firestore-test-app/src/main/java/com/google/firebase/testapps/firestore/TestActivity.java
deleted file mode 100644
index b991f0c83..000000000
--- a/test-apps/firestore-test-app/src/main/java/com/google/firebase/testapps/firestore/TestActivity.java
+++ /dev/null
@@ -1,111 +0,0 @@
-// Copyright 2018 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.google.firebase.testapps.firestore;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.support.annotation.Keep;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
-import android.support.test.espresso.IdlingResource;
-import android.support.test.espresso.idling.CountingIdlingResource;
-import android.util.Log;
-import android.widget.TextView;
-import android.widget.Toast;
-import com.google.android.gms.tasks.OnFailureListener;
-import com.google.android.gms.tasks.OnSuccessListener;
-import com.google.firebase.auth.AuthResult;
-import com.google.firebase.auth.FirebaseAuth;
-import com.google.firebase.firestore.DocumentSnapshot;
-import com.google.firebase.firestore.EventListener;
-import com.google.firebase.firestore.FirebaseFirestore;
-import com.google.firebase.firestore.FirebaseFirestoreException;
-import com.google.firebase.firestore.FirebaseFirestoreSettings;
-import java.util.HashMap;
-import java.util.Map;
-
-public class TestActivity extends Activity {
-  private static final Map<String, Object> restaurant = new HashMap<>();
-  private static final String TAG = TestActivity.class.toString();
-
-  static {
-    restaurant.put("location", "Google MTV");
-  }
-
-  private FirebaseFirestore db;
-  private FirebaseAuth auth;
-  private TextView restaurantTextView;
-  private final CountingIdlingResource idlingResource =
-      new CountingIdlingResource("Firebase firestore listener");
-
-  @Override
-  protected void onCreate(@Nullable Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-    setContentView(R.layout.test_activity);
-
-    db = FirebaseFirestore.getInstance();
-    auth = FirebaseAuth.getInstance();
-    restaurantTextView = this.findViewById(R.id.restaurant);
-    idlingResource.increment();
-
-    // Since offline persistence is enabled by default, the event listener is invoked even without
-    db.setFirestoreSettings(
-        new FirebaseFirestoreSettings.Builder().setPersistenceEnabled(false).build());
-
-    // Listen for a change to the collection
-    db.collection("restaurants")
-        .document("Baadal")
-        .addSnapshotListener(
-            new EventListener<DocumentSnapshot>() {
-              @Override
-              public void onEvent(
-                  @javax.annotation.Nullable DocumentSnapshot snapshot,
-                  @javax.annotation.Nullable FirebaseFirestoreException e) {
-                if (snapshot != null && snapshot.exists()) {
-                  restaurantTextView.setText(snapshot.getData().toString());
-                  idlingResource.decrement();
-                }
-              }
-            });
-
-    // Signout of any existing sessions and sign in with email and password
-    auth.signOut();
-    auth.signInWithEmailAndPassword("test@mailinator.com", "password")
-        .addOnSuccessListener(
-            new OnSuccessListener<AuthResult>() {
-              @Override
-              public void onSuccess(AuthResult authResult) {
-                Toast.makeText(TestActivity.this, "Signed in", Toast.LENGTH_LONG).show();
-                db.collection("restaurants").document("Baadal").set(restaurant);
-              }
-            })
-        .addOnFailureListener(
-            new OnFailureListener() {
-              @Override
-              public void onFailure(@NonNull Exception e) {
-                Log.d(TAG, "Failed to sign in");
-                Toast.makeText(TestActivity.this, e.toString(), Toast.LENGTH_LONG).show();
-              }
-            });
-  }
-
-  @VisibleForTesting
-  @NonNull
-  @Keep
-  public IdlingResource getIdlingResource() {
-    return idlingResource;
-  }
-}
diff --git a/test-apps/firestore-test-app/test-proguard-rules.pro b/test-apps/firestore-test-app/test-proguard-rules.pro
deleted file mode 100644
index ee5e74b9f..000000000
--- a/test-apps/firestore-test-app/test-proguard-rules.pro
+++ /dev/null
@@ -1,4 +0,0 @@
--keepattributes SourceFile,LineNumberTable
-
--dontwarn org.xmlpull.v1.**
--dontnote org.xmlpull.v1.**
\ No newline at end of file
diff --git a/test-apps/firestore-test-app/test_setup.sh b/test-apps/firestore-test-app/test_setup.sh
deleted file mode 100755
index 810b3c5df..000000000
--- a/test-apps/firestore-test-app/test_setup.sh
+++ /dev/null
@@ -1,25 +0,0 @@
-#Copyright 2018 Google LLC
-#
-#Licensed under the Apache License, Version 2.0 (the "License");
-#you may not use this file except in compliance with the License.
-#You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-#Unless required by applicable law or agreed to in writing, software
-#distributed under the License is distributed on an "AS IS" BASIS,
-#WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#See the License for the specific language governing permissions and
-#limitations under the License.
-
-#!/bin/bash
-set -o nounset
-set -e
-
-#delete the restaurants collection
-echo "Deleting the restaurants collection under project"
-firebase firestore:delete "restaurants" -r -y --project="$PROJECT_ID"
-
-#create a test account test@mailinator.com
-echo "Creating test accounts"
-firebase auth:import accounts.json --hash-algo=SHA256 --rounds=1 --project="$PROJECT_ID"
diff --git a/test-apps/functions-test-app/.gitignore b/test-apps/functions-test-app/.gitignore
deleted file mode 100644
index f0c7ca8f6..000000000
--- a/test-apps/functions-test-app/.gitignore
+++ /dev/null
@@ -1,9 +0,0 @@
-.gradle
-local.properties
-.idea
-build/
-.DS_Store
-*.iml
-*.apk
-*.aar
-*.zip
diff --git a/test-apps/functions-test-app/build.gradle b/test-apps/functions-test-app/build.gradle
deleted file mode 100644
index d213d280b..000000000
--- a/test-apps/functions-test-app/build.gradle
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright 2018 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-apply plugin: 'com.android.application'
-
-android {
-    testBuildType = project.testBuildType
-    compileSdkVersion project.targetSdkVersion
-
-    defaultConfig {
-        applicationId "com.google.firebase.testapps.functions"
-        minSdkVersion 16
-        targetSdkVersion project.targetSdkVersion
-        versionCode 1
-        versionName "1.0"
-        testInstrumentationRunner 'android.support.test.runner.AndroidJUnitRunner'
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled true
-            testProguardFiles getDefaultProguardFile('proguard-android.txt'), 'test-proguard-rules.pro'
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-            signingConfig signingConfigs.debug
-        }
-    }
-}
-
-configurations.all {
-    resolutionStrategy.force 'com.android.support:support-annotations:27.1.1'
-}
-
-dependencies {
-    // We intentionally use an open ended version to pick up any SNAPSHOT
-    // versions published to the root project' s build/ directory.
-    implementation "com.google.firebase:firebase-functions:16+"
-    implementation 'com.google.firebase:firebase-core:16+'
-    implementation 'com.google.firebase:firebase-auth:16+'
-    implementation 'com.android.support.test.espresso:espresso-idling-resource:3.0.2'
-
-    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
-    androidTestImplementation 'com.android.support.test:rules:1.0.2'
-    androidTestImplementation 'com.android.support.test:runner:1.0.2'
-    androidTestImplementation 'com.android.support.test.espresso:espresso-idling-resource:3.0.2'
-}
-
-apply plugin: 'com.google.gms.google-services'
diff --git a/test-apps/functions-test-app/firebase.json b/test-apps/functions-test-app/firebase.json
deleted file mode 100644
index 0967ef424..000000000
--- a/test-apps/functions-test-app/firebase.json
+++ /dev/null
@@ -1 +0,0 @@
-{}
diff --git a/test-apps/functions-test-app/functions/.gitignore b/test-apps/functions-test-app/functions/.gitignore
deleted file mode 100644
index 3351ce2e9..000000000
--- a/test-apps/functions-test-app/functions/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-*.log
-node_modules
diff --git a/test-apps/functions-test-app/functions/index.js b/test-apps/functions-test-app/functions/index.js
deleted file mode 100644
index 547ee321f..000000000
--- a/test-apps/functions-test-app/functions/index.js
+++ /dev/null
@@ -1,110 +0,0 @@
-/**
- * Copyright 2018 Google Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-'use strict';
-
-const functions = require('firebase-functions');
-const sanitizer = require('./sanitizer');
-const admin = require('firebase-admin');
-admin.initializeApp(functions.config().firebase);
-
-// [START allAdd]
-// [START addFunctionTrigger]
-// Adds two numbers to each other.
-exports.addNumbers = functions.https.onCall((data) => {
-// [END addFunctionTrigger]
-  // [START readAddData]
-  // Numbers passed from the client.
-  const firstNumber = data.firstNumber;
-  const secondNumber = data.secondNumber;
-  // [END readAddData]
-
-  // [START addHttpsError]
-  // Checking that attributes are present and are numbers.
-  if (!Number.isFinite(firstNumber) || !Number.isFinite(secondNumber)) {
-    // Throwing an HttpsError so that the client gets the error details.
-    throw new functions.https.HttpsError('invalid-argument', 'The function must be called with ' +
-        'two arguments "firstNumber" and "secondNumber" which must both be numbers.');
-  }
-  // [END addHttpsError]
-
-  // [START returnAddData]
-  // returning result.
-  return {
-    firstNumber: firstNumber,
-    secondNumber: secondNumber,
-    operator: '+',
-    operationResult: firstNumber + secondNumber,
-  };
-  // [END returnAddData]
-});
-// [END allAdd]
-
-// [START messageFunctionTrigger]
-// Saves a message to the Firebase Realtime Database but sanitizes the text by removing swearwords.
-exports.addMessage = functions.https.onCall((data, context) => {
-  // [START_EXCLUDE]
-  // [START readMessageData]
-  // Message text passed from the client.
-  const text = data.text;
-  // [END readMessageData]
-  // [START messageHttpsErrors]
-  // Checking attribute.
-  if (!(typeof text === 'string') || text.length === 0) {
-    // Throwing an HttpsError so that the client gets the error details.
-    throw new functions.https.HttpsError('invalid-argument', 'The function must be called with ' +
-        'one arguments "text" containing the message text to add.');
-  }
-  // Checking that the user is authenticated.
-  if (!context.auth) {
-    // Throwing an HttpsError so that the client gets the error details.
-    throw new functions.https.HttpsError('failed-precondition', 'The function must be called ' +
-        'while authenticated.');
-  }
-  // [END messageHttpsErrors]
-
-  // [START authIntegration]
-  // Authentication / user information is automatically added to the request.
-  const uid = context.auth.uid;
-  const name = context.auth.token.name || null;
-  const picture = context.auth.token.picture || null;
-  const email = context.auth.token.email || null;
-  // [END authIntegration]
-
-  // [START returnMessageAsync]
-  // Saving the new message to the Realtime Database.
-  const sanitizedMessage = sanitizer.sanitizeText(text); // Sanitize the message.
-  return admin.database().ref('/messages').push({
-    text: sanitizedMessage,
-    author: { uid, name, picture, email },
-  }).then(() => {
-    // Optionally send a push notification with the message.
-    if (data.push && context.instanceIdToken) {
-      return admin.messaging().send({
-        token: context.instanceIdToken,
-        data: { text: sanitizedMessage },
-      });
-    }
-  }).then(() => {
-    console.log('New Message written');
-    return sanitizedMessage;
-  }).catch((error) => {
-    // Re-throwing the error as an HttpsError so that the client gets the error details.
-    throw new functions.https.HttpsError('unknown', error.message, error);
-  });
-  // [END returnMessageAsync]
-  // [END_EXCLUDE]
-});
-// [END messageFunctionTrigger]
diff --git a/test-apps/functions-test-app/functions/package-lock.json b/test-apps/functions-test-app/functions/package-lock.json
deleted file mode 100644
index 6093b8515..000000000
--- a/test-apps/functions-test-app/functions/package-lock.json
+++ /dev/null
@@ -1,3902 +0,0 @@
-{
-  "name": "functions",
-  "requires": true,
-  "lockfileVersion": 1,
-  "dependencies": {
-    "@firebase/app": {
-      "version": "0.1.10",
-      "resolved": "https://registry.npmjs.org/@firebase/app/-/app-0.1.10.tgz",
-      "integrity": "sha512-2GTXt3b2QZXkmx6/5nNJq+pEN/VTjAG55MFJS1WMoLVZkwKuNpWNk65QVyPaoL88x1iHtuLqAMFgJUOnhOg+Pw==",
-      "requires": {
-        "@firebase/app-types": "0.1.2",
-        "@firebase/util": "0.1.10",
-        "tslib": "1.9.3"
-      }
-    },
-    "@firebase/app-types": {
-      "version": "0.1.2",
-      "resolved": "https://registry.npmjs.org/@firebase/app-types/-/app-types-0.1.2.tgz",
-      "integrity": "sha512-bCIZGeMtP0ibrXNNaU214/1tRNw0jHnir/cfiAao1gjUyIS7RzOTQoH+zbwPJNEwUqJ0T3ykw/Tv4/khGqbVBg=="
-    },
-    "@firebase/database": {
-      "version": "0.2.2",
-      "resolved": "https://registry.npmjs.org/@firebase/database/-/database-0.2.2.tgz",
-      "integrity": "sha512-iTNEN33D3V0hAG2hdx+guFBXaN4hcFS2k2EGp/bzNviAG7n2AotMscdbkS6xDS2e3Uk2/D3lfibHQO4zgJ3LIg==",
-      "requires": {
-        "@firebase/database-types": "0.2.1",
-        "@firebase/logger": "0.1.1",
-        "@firebase/util": "0.1.11",
-        "faye-websocket": "0.11.1",
-        "tslib": "1.9.0"
-      },
-      "dependencies": {
-        "@firebase/util": {
-          "version": "0.1.11",
-          "resolved": "https://registry.npmjs.org/@firebase/util/-/util-0.1.11.tgz",
-          "integrity": "sha512-xUMugOJBSKVKOjrKJIVeIr4Z/6iDxSuOlOJRdz0xsOBJ9+lZVxGZs0U4oZmszWhQER1zzR+EQWIYFYePt6/QMQ==",
-          "requires": {
-            "tslib": "1.9.0"
-          }
-        },
-        "faye-websocket": {
-          "version": "0.11.1",
-          "resolved": "https://registry.npmjs.org/faye-websocket/-/faye-websocket-0.11.1.tgz",
-          "integrity": "sha1-8O/hjE9W5PQK/H4Gxxn9XuYYjzg=",
-          "requires": {
-            "websocket-driver": "0.7.0"
-          }
-        },
-        "tslib": {
-          "version": "1.9.0",
-          "resolved": "https://registry.npmjs.org/tslib/-/tslib-1.9.0.tgz",
-          "integrity": "sha512-f/qGG2tUkrISBlQZEjEqoZ3B2+npJjIf04H1wuAv9iA8i04Icp+61KRXxFdha22670NJopsZCIjhC3SnjPRKrQ=="
-        }
-      }
-    },
-    "@firebase/database-types": {
-      "version": "0.2.1",
-      "resolved": "https://registry.npmjs.org/@firebase/database-types/-/database-types-0.2.1.tgz",
-      "integrity": "sha512-LyvTpLImnhSTyHfPGcBxhD0tHw+R7FUb+als23Ad5hPCcGxlRgLhA+ukrhFIGA8Mt8FYHWgFm7TCX4YDRDxK6w=="
-    },
-    "@firebase/logger": {
-      "version": "0.1.1",
-      "resolved": "https://registry.npmjs.org/@firebase/logger/-/logger-0.1.1.tgz",
-      "integrity": "sha512-5jn3HHbEfdOwychyIEIkP1cik+MW/vvoOavTOzwDkH+fv6Bx+HBUOzh09M7sCYzXFtKzjbUax9+g39mJNBLklQ=="
-    },
-    "@firebase/util": {
-      "version": "0.1.10",
-      "resolved": "https://registry.npmjs.org/@firebase/util/-/util-0.1.10.tgz",
-      "integrity": "sha512-XEogRfUQBZ4T37TMq/3ZbuiTdRAKX8hF3TgJglUZNCJf/6QnQ+jlupCuMAXBqCGfw2Mw0m2matoCUBWpsyevOA==",
-      "requires": {
-        "tslib": "1.9.3"
-      }
-    },
-    "@google-cloud/common": {
-      "version": "0.17.0",
-      "resolved": "https://registry.npmjs.org/@google-cloud/common/-/common-0.17.0.tgz",
-      "integrity": "sha512-HRZLSU762E6HaKoGfJGa8W95yRjb9rY7LePhjaHK9ILAnFacMuUGVamDbTHu1csZomm1g3tZTtXfX/aAhtie/Q==",
-      "requires": {
-        "array-uniq": "1.0.3",
-        "arrify": "1.0.1",
-        "concat-stream": "1.6.2",
-        "create-error-class": "3.0.2",
-        "duplexify": "3.7.1",
-        "ent": "2.2.0",
-        "extend": "3.0.2",
-        "google-auto-auth": "0.10.1",
-        "is": "3.3.0",
-        "log-driver": "1.2.7",
-        "methmeth": "1.1.0",
-        "modelo": "4.2.3",
-        "request": "2.88.0",
-        "retry-request": "3.3.2",
-        "split-array-stream": "1.0.3",
-        "stream-events": "1.0.5",
-        "string-format-obj": "1.1.1",
-        "through2": "2.0.5"
-      }
-    },
-    "@google-cloud/common-grpc": {
-      "version": "0.6.1",
-      "resolved": "https://registry.npmjs.org/@google-cloud/common-grpc/-/common-grpc-0.6.1.tgz",
-      "integrity": "sha512-pspOZVfmrCTP0svTNwFE8nYJsQp5rTUaeUpJwpgslDk5tDWFbYT3dZkANbiURcTSq0mo6hZmd+M5rPIzWMVUmA==",
-      "requires": {
-        "@google-cloud/common": "0.17.0",
-        "dot-prop": "4.2.0",
-        "duplexify": "3.7.1",
-        "extend": "3.0.2",
-        "grpc": "1.18.0",
-        "is": "3.3.0",
-        "modelo": "4.2.3",
-        "retry-request": "3.3.2",
-        "through2": "2.0.5"
-      }
-    },
-    "@google-cloud/firestore": {
-      "version": "0.13.1",
-      "resolved": "https://registry.npmjs.org/@google-cloud/firestore/-/firestore-0.13.1.tgz",
-      "integrity": "sha512-70PPCDg++AGx4OGW/FhDoDtIh4Z2WuwPMkHkvFWNvEDGghCxGrYgRvpCsfcZBU0TLYpcbsndrweLp972cwItrQ==",
-      "requires": {
-        "@google-cloud/common": "0.17.0",
-        "@google-cloud/common-grpc": "0.6.1",
-        "bun": "0.0.12",
-        "deep-equal": "1.0.1",
-        "extend": "3.0.2",
-        "functional-red-black-tree": "1.0.1",
-        "google-gax": "0.16.1",
-        "is": "3.3.0",
-        "safe-buffer": "5.1.2",
-        "through2": "2.0.5"
-      }
-    },
-    "@google-cloud/storage": {
-      "version": "1.7.0",
-      "resolved": "https://registry.npmjs.org/@google-cloud/storage/-/storage-1.7.0.tgz",
-      "integrity": "sha512-QaAxzCkbhspwajoaEnT0GcnQcpjPRcBrHYuQsXtD05BtOJgVnHCLXSsfUiRdU0nVpK+Thp7+sTkQ0fvk5PanKg==",
-      "requires": {
-        "@google-cloud/common": "0.17.0",
-        "arrify": "1.0.1",
-        "async": "2.6.2",
-        "compressible": "2.0.15",
-        "concat-stream": "1.6.2",
-        "create-error-class": "3.0.2",
-        "duplexify": "3.7.1",
-        "extend": "3.0.2",
-        "gcs-resumable-upload": "0.10.2",
-        "hash-stream-validation": "0.2.1",
-        "is": "3.3.0",
-        "mime": "2.4.0",
-        "mime-types": "2.1.22",
-        "once": "1.4.0",
-        "pumpify": "1.5.1",
-        "request": "2.88.0",
-        "safe-buffer": "5.1.2",
-        "snakeize": "0.1.0",
-        "stream-events": "1.0.5",
-        "through2": "2.0.5",
-        "xdg-basedir": "3.0.0"
-      }
-    },
-    "@mrmlnc/readdir-enhanced": {
-      "version": "2.2.1",
-      "resolved": "https://registry.npmjs.org/@mrmlnc/readdir-enhanced/-/readdir-enhanced-2.2.1.tgz",
-      "integrity": "sha512-bPHp6Ji8b41szTOcaP63VlnbbO5Ny6dwAATtY6JTjh5N2OLrb5Qk/Th5cRkRQhkWCt+EJsYrNB0MiL+Gpn6e3g==",
-      "requires": {
-        "call-me-maybe": "1.0.1",
-        "glob-to-regexp": "0.3.0"
-      }
-    },
-    "@nodelib/fs.stat": {
-      "version": "1.1.3",
-      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-1.1.3.tgz",
-      "integrity": "sha512-shAmDyaQC4H92APFoIaVDHCx5bStIocgvbwQyxPRrbUY20V1EYTbSDchWbuwlMG3V17cprZhA6+78JfB+3DTPw=="
-    },
-    "@protobufjs/aspromise": {
-      "version": "1.1.2",
-      "resolved": "https://registry.npmjs.org/@protobufjs/aspromise/-/aspromise-1.1.2.tgz",
-      "integrity": "sha1-m4sMxmPWaafY9vXQiToU00jzD78="
-    },
-    "@protobufjs/base64": {
-      "version": "1.1.2",
-      "resolved": "https://registry.npmjs.org/@protobufjs/base64/-/base64-1.1.2.tgz",
-      "integrity": "sha512-AZkcAA5vnN/v4PDqKyMR5lx7hZttPDgClv83E//FMNhR2TMcLUhfRUBHCmSl0oi9zMgDDqRUJkSxO3wm85+XLg=="
-    },
-    "@protobufjs/codegen": {
-      "version": "2.0.4",
-      "resolved": "https://registry.npmjs.org/@protobufjs/codegen/-/codegen-2.0.4.tgz",
-      "integrity": "sha512-YyFaikqM5sH0ziFZCN3xDC7zeGaB/d0IUb9CATugHWbd1FRFwWwt4ld4OYMPWu5a3Xe01mGAULCdqhMlPl29Jg=="
-    },
-    "@protobufjs/eventemitter": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/@protobufjs/eventemitter/-/eventemitter-1.1.0.tgz",
-      "integrity": "sha1-NVy8mLr61ZePntCV85diHx0Ga3A="
-    },
-    "@protobufjs/fetch": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/@protobufjs/fetch/-/fetch-1.1.0.tgz",
-      "integrity": "sha1-upn7WYYUr2VwDBYZ/wbUVLDYTEU=",
-      "requires": {
-        "@protobufjs/aspromise": "1.1.2",
-        "@protobufjs/inquire": "1.1.0"
-      }
-    },
-    "@protobufjs/float": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/@protobufjs/float/-/float-1.0.2.tgz",
-      "integrity": "sha1-Xp4avctz/Ap8uLKR33jIy9l7h9E="
-    },
-    "@protobufjs/inquire": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/@protobufjs/inquire/-/inquire-1.1.0.tgz",
-      "integrity": "sha1-/yAOPnzyQp4tyvwRQIKOjMY48Ik="
-    },
-    "@protobufjs/path": {
-      "version": "1.1.2",
-      "resolved": "https://registry.npmjs.org/@protobufjs/path/-/path-1.1.2.tgz",
-      "integrity": "sha1-bMKyDFya1q0NzP0hynZz2Nf79o0="
-    },
-    "@protobufjs/pool": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/@protobufjs/pool/-/pool-1.1.0.tgz",
-      "integrity": "sha1-Cf0V8tbTq/qbZbw2ZQbWrXhG/1Q="
-    },
-    "@protobufjs/utf8": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/@protobufjs/utf8/-/utf8-1.1.0.tgz",
-      "integrity": "sha1-p3c2C1s5oaLlEG+OhY8v0tBgxXA="
-    },
-    "@types/body-parser": {
-      "version": "1.17.0",
-      "resolved": "https://registry.npmjs.org/@types/body-parser/-/body-parser-1.17.0.tgz",
-      "integrity": "sha512-a2+YeUjPkztKJu5aIF2yArYFQQp8d51wZ7DavSHjFuY1mqVgidGyzEQ41JIVNy82fXj8yPgy2vJmfIywgESW6w==",
-      "requires": {
-        "@types/connect": "3.4.32",
-        "@types/node": "8.10.40"
-      }
-    },
-    "@types/caseless": {
-      "version": "0.12.1",
-      "resolved": "https://registry.npmjs.org/@types/caseless/-/caseless-0.12.1.tgz",
-      "integrity": "sha512-FhlMa34NHp9K5MY1Uz8yb+ZvuX0pnvn3jScRSNAb75KHGB8d3rEU6hqMs3Z2vjuytcMfRg6c5CHMc3wtYyD2/A=="
-    },
-    "@types/connect": {
-      "version": "3.4.32",
-      "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.32.tgz",
-      "integrity": "sha512-4r8qa0quOvh7lGD0pre62CAb1oni1OO6ecJLGCezTmhQ8Fz50Arx9RUszryR8KlgK6avuSXvviL6yWyViQABOg==",
-      "requires": {
-        "@types/node": "8.10.40"
-      }
-    },
-    "@types/cors": {
-      "version": "2.8.4",
-      "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.4.tgz",
-      "integrity": "sha512-ipZjBVsm2tF/n8qFGOuGBkUij9X9ZswVi9G3bx/6dz7POpVa6gVHcj1wsX/LVEn9MMF41fxK/PnZPPoTD1UFPw==",
-      "requires": {
-        "@types/express": "4.16.1"
-      }
-    },
-    "@types/express": {
-      "version": "4.16.1",
-      "resolved": "https://registry.npmjs.org/@types/express/-/express-4.16.1.tgz",
-      "integrity": "sha512-V0clmJow23WeyblmACoxbHBu2JKlE5TiIme6Lem14FnPW9gsttyHtk6wq7njcdIWH1njAaFgR8gW09lgY98gQg==",
-      "requires": {
-        "@types/body-parser": "1.17.0",
-        "@types/express-serve-static-core": "4.16.1",
-        "@types/serve-static": "1.13.2"
-      }
-    },
-    "@types/express-serve-static-core": {
-      "version": "4.16.1",
-      "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-4.16.1.tgz",
-      "integrity": "sha512-QgbIMRU1EVRry5cIu1ORCQP4flSYqLM1lS5LYyGWfKnFT3E58f0gKto7BR13clBFVrVZ0G0rbLZ1hUpSkgQQOA==",
-      "requires": {
-        "@types/node": "8.10.40",
-        "@types/range-parser": "1.2.3"
-      }
-    },
-    "@types/form-data": {
-      "version": "2.2.1",
-      "resolved": "https://registry.npmjs.org/@types/form-data/-/form-data-2.2.1.tgz",
-      "integrity": "sha512-JAMFhOaHIciYVh8fb5/83nmuO/AHwmto+Hq7a9y8FzLDcC1KCU344XDOMEmahnrTFlHjgh4L0WJFczNIX2GxnQ==",
-      "requires": {
-        "@types/node": "8.10.40"
-      }
-    },
-    "@types/google-cloud__storage": {
-      "version": "1.7.2",
-      "resolved": "https://registry.npmjs.org/@types/google-cloud__storage/-/google-cloud__storage-1.7.2.tgz",
-      "integrity": "sha512-RaQJ7+Ht20MRYJu7mgKBpbVNZIPneztKIl/DUKacRC6A8mXRsJfgDdPA7indHmJGIgm+hzUTj44+A3RyuuYZhg==",
-      "requires": {
-        "@types/node": "8.10.40",
-        "@types/request": "2.48.1"
-      }
-    },
-    "@types/jsonwebtoken": {
-      "version": "7.2.8",
-      "resolved": "https://registry.npmjs.org/@types/jsonwebtoken/-/jsonwebtoken-7.2.8.tgz",
-      "integrity": "sha512-XENN3YzEB8D6TiUww0O8SRznzy1v+77lH7UmuN54xq/IHIsyWjWOzZuFFTtoiRuaE782uAoRwBe/wwow+vQXZw==",
-      "requires": {
-        "@types/node": "8.10.40"
-      }
-    },
-    "@types/lodash": {
-      "version": "4.14.121",
-      "resolved": "https://registry.npmjs.org/@types/lodash/-/lodash-4.14.121.tgz",
-      "integrity": "sha512-ORj7IBWj13iYufXt/VXrCNMbUuCTJfhzme5kx9U/UtcIPdJYuvPDUAlHlbNhz/8lKCLy9XGIZnGrqXOtQbPGoQ=="
-    },
-    "@types/long": {
-      "version": "4.0.0",
-      "resolved": "https://registry.npmjs.org/@types/long/-/long-4.0.0.tgz",
-      "integrity": "sha512-1w52Nyx4Gq47uuu0EVcsHBxZFJgurQ+rTKS3qMHxR1GY2T8c2AJYd6vZoZ9q1rupaDjU0yT+Jc2XTyXkjeMA+Q=="
-    },
-    "@types/mime": {
-      "version": "2.0.1",
-      "resolved": "https://registry.npmjs.org/@types/mime/-/mime-2.0.1.tgz",
-      "integrity": "sha512-FwI9gX75FgVBJ7ywgnq/P7tw+/o1GUbtP0KzbtusLigAOgIgNISRK0ZPl4qertvXSIE8YbsVJueQ90cDt9YYyw=="
-    },
-    "@types/node": {
-      "version": "8.10.40",
-      "resolved": "https://registry.npmjs.org/@types/node/-/node-8.10.40.tgz",
-      "integrity": "sha512-RRSjdwz63kS4u7edIwJUn8NqKLLQ6LyqF/X4+4jp38MBT3Vwetewi2N4dgJEshLbDwNgOJXNYoOwzVZUSSLhkQ=="
-    },
-    "@types/range-parser": {
-      "version": "1.2.3",
-      "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.3.tgz",
-      "integrity": "sha512-ewFXqrQHlFsgc09MK5jP5iR7vumV/BYayNC6PgJO2LPe8vrnNFyjQjSppfEngITi0qvfKtzFvgKymGheFM9UOA=="
-    },
-    "@types/request": {
-      "version": "2.48.1",
-      "resolved": "https://registry.npmjs.org/@types/request/-/request-2.48.1.tgz",
-      "integrity": "sha512-ZgEZ1TiD+KGA9LiAAPPJL68Id2UWfeSO62ijSXZjFJArVV+2pKcsVHmrcu+1oiE3q6eDGiFiSolRc4JHoerBBg==",
-      "requires": {
-        "@types/caseless": "0.12.1",
-        "@types/form-data": "2.2.1",
-        "@types/node": "8.10.40",
-        "@types/tough-cookie": "2.3.5"
-      }
-    },
-    "@types/serve-static": {
-      "version": "1.13.2",
-      "resolved": "https://registry.npmjs.org/@types/serve-static/-/serve-static-1.13.2.tgz",
-      "integrity": "sha512-/BZ4QRLpH/bNYgZgwhKEh+5AsboDBcUdlBYgzoLX0fpj3Y2gp6EApyOlM3bK53wQS/OE1SrdSYBAbux2D1528Q==",
-      "requires": {
-        "@types/express-serve-static-core": "4.16.1",
-        "@types/mime": "2.0.1"
-      }
-    },
-    "@types/tough-cookie": {
-      "version": "2.3.5",
-      "resolved": "https://registry.npmjs.org/@types/tough-cookie/-/tough-cookie-2.3.5.tgz",
-      "integrity": "sha512-SCcK7mvGi3+ZNz833RRjFIxrn4gI1PPR3NtuIS+6vMkvmsGjosqTJwRt5bAEFLRz+wtJMWv8+uOnZf2hi2QXTg=="
-    },
-    "abort-controller": {
-      "version": "2.0.2",
-      "resolved": "https://registry.npmjs.org/abort-controller/-/abort-controller-2.0.2.tgz",
-      "integrity": "sha512-JXEYGxxMwiNl9EUdLysK0K0DwB7ENw6KeeaLHgofijTfJYPB/vOer3Mb+IcP913dCfWiQsd05MmVNl0H5PanrQ==",
-      "requires": {
-        "event-target-shim": "5.0.0"
-      }
-    },
-    "accepts": {
-      "version": "1.3.5",
-      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.5.tgz",
-      "integrity": "sha1-63d99gEXI6OxTopywIBcjoZ0a9I=",
-      "requires": {
-        "mime-types": "2.1.22",
-        "negotiator": "0.6.1"
-      }
-    },
-    "acorn": {
-      "version": "5.7.3",
-      "resolved": "https://registry.npmjs.org/acorn/-/acorn-5.7.3.tgz",
-      "integrity": "sha512-T/zvzYRfbVojPWahDsE5evJdHb3oJoQfFbsrKM7w5Zcs++Tr257tia3BmMP8XYVjp1S9RZXQMh7gao96BlqZOw=="
-    },
-    "acorn-es7-plugin": {
-      "version": "1.1.7",
-      "resolved": "https://registry.npmjs.org/acorn-es7-plugin/-/acorn-es7-plugin-1.1.7.tgz",
-      "integrity": "sha1-8u4fMiipDurRJF+asZIusucdM2s="
-    },
-    "agent-base": {
-      "version": "4.2.1",
-      "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-4.2.1.tgz",
-      "integrity": "sha512-JVwXMr9nHYTUXsBFKUqhJwvlcYU/blreOEUkhNR2eXZIvwd+c+o5V4MgDPKWnMS/56awN3TRzIP+KoPn+roQtg==",
-      "requires": {
-        "es6-promisify": "5.0.0"
-      }
-    },
-    "ajv": {
-      "version": "6.9.1",
-      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.9.1.tgz",
-      "integrity": "sha512-XDN92U311aINL77ieWHmqCcNlwjoP5cHXDxIxbf2MaPYuCXOHS7gHH8jktxeK5omgd52XbSTX6a4Piwd1pQmzA==",
-      "requires": {
-        "fast-deep-equal": "2.0.1",
-        "fast-json-stable-stringify": "2.0.0",
-        "json-schema-traverse": "0.4.1",
-        "uri-js": "4.2.2"
-      }
-    },
-    "ansi-regex": {
-      "version": "2.1.1",
-      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-2.1.1.tgz",
-      "integrity": "sha1-w7M6te42DYbg5ijwRorn7yfWVN8="
-    },
-    "arr-diff": {
-      "version": "4.0.0",
-      "resolved": "https://registry.npmjs.org/arr-diff/-/arr-diff-4.0.0.tgz",
-      "integrity": "sha1-1kYQdP6/7HHn4VI1dhoyml3HxSA="
-    },
-    "arr-flatten": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/arr-flatten/-/arr-flatten-1.1.0.tgz",
-      "integrity": "sha512-L3hKV5R/p5o81R7O02IGnwpDmkp6E982XhtbuwSe3O4qOtMMMtodicASA1Cny2U+aCXcNpml+m4dPsvsJ3jatg=="
-    },
-    "arr-union": {
-      "version": "3.1.0",
-      "resolved": "https://registry.npmjs.org/arr-union/-/arr-union-3.1.0.tgz",
-      "integrity": "sha1-45sJrqne+Gao8gbiiK9jkZuuOcQ="
-    },
-    "array-filter": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/array-filter/-/array-filter-1.0.0.tgz",
-      "integrity": "sha1-uveeYubvTCpMC4MSMtr/7CUfnYM="
-    },
-    "array-flatten": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-1.1.1.tgz",
-      "integrity": "sha1-ml9pkFGx5wczKPKgCJaLZOopVdI="
-    },
-    "array-union": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/array-union/-/array-union-1.0.2.tgz",
-      "integrity": "sha1-mjRBDk9OPaI96jdb5b5w8kd47Dk=",
-      "requires": {
-        "array-uniq": "1.0.3"
-      }
-    },
-    "array-uniq": {
-      "version": "1.0.3",
-      "resolved": "https://registry.npmjs.org/array-uniq/-/array-uniq-1.0.3.tgz",
-      "integrity": "sha1-r2rId6Jcx/dOBYiUdThY39sk/bY="
-    },
-    "array-unique": {
-      "version": "0.3.2",
-      "resolved": "https://registry.npmjs.org/array-unique/-/array-unique-0.3.2.tgz",
-      "integrity": "sha1-qJS3XUvE9s1nnvMkSp/Y9Gri1Cg="
-    },
-    "arrify": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/arrify/-/arrify-1.0.1.tgz",
-      "integrity": "sha1-iYUI2iIm84DfkEcoRWhJwVAaSw0="
-    },
-    "ascli": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/ascli/-/ascli-1.0.1.tgz",
-      "integrity": "sha1-vPpZdKYvGOgcq660lzKrSoj5Brw=",
-      "requires": {
-        "colour": "0.7.1",
-        "optjs": "3.2.2"
-      }
-    },
-    "asn1": {
-      "version": "0.2.4",
-      "resolved": "https://registry.npmjs.org/asn1/-/asn1-0.2.4.tgz",
-      "integrity": "sha512-jxwzQpLQjSmWXgwaCZE9Nz+glAG01yF1QnWgbhGwHI5A6FRIEY6IVqtHhIepHqI7/kyEyQEagBC5mBEFlIYvdg==",
-      "requires": {
-        "safer-buffer": "2.1.2"
-      }
-    },
-    "assert-plus": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/assert-plus/-/assert-plus-1.0.0.tgz",
-      "integrity": "sha1-8S4PPF13sLHN2RRpQuTpbB5N1SU="
-    },
-    "assign-symbols": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/assign-symbols/-/assign-symbols-1.0.0.tgz",
-      "integrity": "sha1-WWZ/QfrdTyDMvCu5a41Pf3jsA2c="
-    },
-    "async": {
-      "version": "2.6.2",
-      "resolved": "https://registry.npmjs.org/async/-/async-2.6.2.tgz",
-      "integrity": "sha512-H1qVYh1MYhEEFLsP97cVKqCGo7KfCyTt6uEWqsTBr9SO84oK9Uwbyd/yCW+6rKJLHksBNUVWZDAjfS+Ccx0Bbg==",
-      "requires": {
-        "lodash": "4.17.11"
-      }
-    },
-    "asynckit": {
-      "version": "0.4.0",
-      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
-      "integrity": "sha1-x57Zf380y48robyXkLzDZkdLS3k="
-    },
-    "atob": {
-      "version": "2.1.2",
-      "resolved": "https://registry.npmjs.org/atob/-/atob-2.1.2.tgz",
-      "integrity": "sha512-Wm6ukoaOGJi/73p/cl2GvLjTI5JM1k/O14isD73YML8StrH/7/lRFgmg8nICZgD3bZZvjwCGxtMOD3wWNAu8cg=="
-    },
-    "aws-sign2": {
-      "version": "0.7.0",
-      "resolved": "https://registry.npmjs.org/aws-sign2/-/aws-sign2-0.7.0.tgz",
-      "integrity": "sha1-tG6JCTSpWR8tL2+G1+ap8bP+dqg="
-    },
-    "aws4": {
-      "version": "1.8.0",
-      "resolved": "https://registry.npmjs.org/aws4/-/aws4-1.8.0.tgz",
-      "integrity": "sha512-ReZxvNHIOv88FlT7rxcXIIC0fPt4KZqZbOlivyWtXLt8ESx84zd3kMC6iK5jVeS2qt+g7ftS7ye4fi06X5rtRQ=="
-    },
-    "axios": {
-      "version": "0.18.0",
-      "resolved": "https://registry.npmjs.org/axios/-/axios-0.18.0.tgz",
-      "integrity": "sha1-MtU+SFHv3AoRmTts0AB4nXDAUQI=",
-      "requires": {
-        "follow-redirects": "1.7.0",
-        "is-buffer": "1.1.6"
-      }
-    },
-    "bad-words": {
-      "version": "1.6.5",
-      "resolved": "https://registry.npmjs.org/bad-words/-/bad-words-1.6.5.tgz",
-      "integrity": "sha512-KzDrzFtzS8Z+v4I+KuanePuaj7g6aRms2WYQOt7n+UugfqMPheYS7zcyTypokxMno2Ss6xfo062ya1aVrviB2g==",
-      "requires": {
-        "badwords-list": "1.0.0"
-      }
-    },
-    "badwords-list": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/badwords-list/-/badwords-list-1.0.0.tgz",
-      "integrity": "sha1-XphW2/E0gqKVw7CzBK+51M/FxXk="
-    },
-    "balanced-match": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.0.tgz",
-      "integrity": "sha1-ibTRmasr7kneFk6gK4nORi1xt2c="
-    },
-    "base": {
-      "version": "0.11.2",
-      "resolved": "https://registry.npmjs.org/base/-/base-0.11.2.tgz",
-      "integrity": "sha512-5T6P4xPgpp0YDFvSWwEZ4NoE3aM4QBQXDzmVbraCkFj8zHM+mba8SyqB5DbZWyR7mYHo6Y7BdQo3MoA4m0TeQg==",
-      "requires": {
-        "cache-base": "1.0.1",
-        "class-utils": "0.3.6",
-        "component-emitter": "1.2.1",
-        "define-property": "1.0.0",
-        "isobject": "3.0.1",
-        "mixin-deep": "1.3.1",
-        "pascalcase": "0.1.1"
-      },
-      "dependencies": {
-        "define-property": {
-          "version": "1.0.0",
-          "resolved": "https://registry.npmjs.org/define-property/-/define-property-1.0.0.tgz",
-          "integrity": "sha1-dp66rz9KY6rTr56NMEybvnm/sOY=",
-          "requires": {
-            "is-descriptor": "1.0.2"
-          }
-        },
-        "is-accessor-descriptor": {
-          "version": "1.0.0",
-          "resolved": "https://registry.npmjs.org/is-accessor-descriptor/-/is-accessor-descriptor-1.0.0.tgz",
-          "integrity": "sha512-m5hnHTkcVsPfqx3AKlyttIPb7J+XykHvJP2B9bZDjlhLIoEq4XoK64Vg7boZlVWYK6LUY94dYPEE7Lh0ZkZKcQ==",
-          "requires": {
-            "kind-of": "6.0.2"
-          }
-        },
-        "is-data-descriptor": {
-          "version": "1.0.0",
-          "resolved": "https://registry.npmjs.org/is-data-descriptor/-/is-data-descriptor-1.0.0.tgz",
-          "integrity": "sha512-jbRXy1FmtAoCjQkVmIVYwuuqDFUbaOeDjmed1tOGPrsMhtJA4rD9tkgA0F1qJ3gRFRXcHYVkdeaP50Q5rE/jLQ==",
-          "requires": {
-            "kind-of": "6.0.2"
-          }
-        },
-        "is-descriptor": {
-          "version": "1.0.2",
-          "resolved": "https://registry.npmjs.org/is-descriptor/-/is-descriptor-1.0.2.tgz",
-          "integrity": "sha512-2eis5WqQGV7peooDyLmNEPUrps9+SXX5c9pL3xEB+4e9HnGuDa7mB7kHxHw4CbqS9k1T2hOH3miL8n8WtiYVtg==",
-          "requires": {
-            "is-accessor-descriptor": "1.0.0",
-            "is-data-descriptor": "1.0.0",
-            "kind-of": "6.0.2"
-          }
-        }
-      }
-    },
-    "bcrypt-pbkdf": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/bcrypt-pbkdf/-/bcrypt-pbkdf-1.0.2.tgz",
-      "integrity": "sha1-pDAdOJtqQ/m2f/PKEaP2Y342Dp4=",
-      "requires": {
-        "tweetnacl": "0.14.5"
-      }
-    },
-    "body-parser": {
-      "version": "1.18.3",
-      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.18.3.tgz",
-      "integrity": "sha1-WykhmP/dVTs6DyDe0FkrlWlVyLQ=",
-      "requires": {
-        "bytes": "3.0.0",
-        "content-type": "1.0.4",
-        "debug": "2.6.9",
-        "depd": "1.1.2",
-        "http-errors": "1.6.3",
-        "iconv-lite": "0.4.23",
-        "on-finished": "2.3.0",
-        "qs": "6.5.2",
-        "raw-body": "2.3.3",
-        "type-is": "1.6.16"
-      },
-      "dependencies": {
-        "debug": {
-          "version": "2.6.9",
-          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
-          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
-          "requires": {
-            "ms": "2.0.0"
-          }
-        },
-        "ms": {
-          "version": "2.0.0",
-          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
-          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g="
-        }
-      }
-    },
-    "brace-expansion": {
-      "version": "1.1.11",
-      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
-      "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
-      "requires": {
-        "balanced-match": "1.0.0",
-        "concat-map": "0.0.1"
-      }
-    },
-    "braces": {
-      "version": "2.3.2",
-      "resolved": "https://registry.npmjs.org/braces/-/braces-2.3.2.tgz",
-      "integrity": "sha512-aNdbnj9P8PjdXU4ybaWLK2IF3jc/EoDYbC7AazW6to3TRsfXxscC9UXOB5iDiEQrkyIbWp2SLQda4+QAa7nc3w==",
-      "requires": {
-        "arr-flatten": "1.1.0",
-        "array-unique": "0.3.2",
-        "extend-shallow": "2.0.1",
-        "fill-range": "4.0.0",
-        "isobject": "3.0.1",
-        "repeat-element": "1.1.3",
-        "snapdragon": "0.8.2",
-        "snapdragon-node": "2.1.1",
-        "split-string": "3.1.0",
-        "to-regex": "3.0.2"
-      },
-      "dependencies": {
-        "extend-shallow": {
-          "version": "2.0.1",
-          "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-2.0.1.tgz",
-          "integrity": "sha1-Ua99YUrZqfYQ6huvu5idaxxWiQ8=",
-          "requires": {
-            "is-extendable": "0.1.1"
-          }
-        }
-      }
-    },
-    "buffer-equal-constant-time": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
-      "integrity": "sha1-+OcRMvf/5uAaXJaXpMbz5I1cyBk="
-    },
-    "buffer-from": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.1.tgz",
-      "integrity": "sha512-MQcXEUbCKtEo7bhqEs6560Hyd4XaovZlO/k9V3hjVUF/zwW7KBVdSK4gIt/bzwS9MbR5qob+F5jusZsb0YQK2A=="
-    },
-    "bun": {
-      "version": "0.0.12",
-      "resolved": "https://registry.npmjs.org/bun/-/bun-0.0.12.tgz",
-      "integrity": "sha512-Toms18J9DqnT+IfWkwxVTB2EaBprHvjlMWrTIsfX4xbu3ZBqVBwrERU0em1IgtRe04wT+wJxMlKHZok24hrcSQ==",
-      "requires": {
-        "readable-stream": "1.0.34"
-      },
-      "dependencies": {
-        "isarray": {
-          "version": "0.0.1",
-          "resolved": "https://registry.npmjs.org/isarray/-/isarray-0.0.1.tgz",
-          "integrity": "sha1-ihis/Kmo9Bd+Cav8YDiTmwXR7t8="
-        },
-        "readable-stream": {
-          "version": "1.0.34",
-          "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-1.0.34.tgz",
-          "integrity": "sha1-Elgg40vIQtLyqq+v5MKRbuMsFXw=",
-          "requires": {
-            "core-util-is": "1.0.2",
-            "inherits": "2.0.3",
-            "isarray": "0.0.1",
-            "string_decoder": "0.10.31"
-          }
-        },
-        "string_decoder": {
-          "version": "0.10.31",
-          "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-0.10.31.tgz",
-          "integrity": "sha1-YuIDvEF2bGwoyfyEMB2rHFMQ+pQ="
-        }
-      }
-    },
-    "bytebuffer": {
-      "version": "5.0.1",
-      "resolved": "https://registry.npmjs.org/bytebuffer/-/bytebuffer-5.0.1.tgz",
-      "integrity": "sha1-WC7qSxqHO20CCkjVjfhfC7ps/d0=",
-      "requires": {
-        "long": "3.2.0"
-      }
-    },
-    "bytes": {
-      "version": "3.0.0",
-      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.0.0.tgz",
-      "integrity": "sha1-0ygVQE1olpn4Wk6k+odV3ROpYEg="
-    },
-    "cache-base": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/cache-base/-/cache-base-1.0.1.tgz",
-      "integrity": "sha512-AKcdTnFSWATd5/GCPRxr2ChwIJ85CeyrEyjRHlKxQ56d4XJMGym0uAiKn0xbLOGOl3+yRpOTi484dVCEc5AUzQ==",
-      "requires": {
-        "collection-visit": "1.0.0",
-        "component-emitter": "1.2.1",
-        "get-value": "2.0.6",
-        "has-value": "1.0.0",
-        "isobject": "3.0.1",
-        "set-value": "2.0.0",
-        "to-object-path": "0.3.0",
-        "union-value": "1.0.0",
-        "unset-value": "1.0.0"
-      }
-    },
-    "call-me-maybe": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/call-me-maybe/-/call-me-maybe-1.0.1.tgz",
-      "integrity": "sha1-JtII6onje1y95gJQoV8DHBak1ms="
-    },
-    "call-signature": {
-      "version": "0.0.2",
-      "resolved": "https://registry.npmjs.org/call-signature/-/call-signature-0.0.2.tgz",
-      "integrity": "sha1-qEq8glpV70yysCi9dOIFpluaSZY="
-    },
-    "camelcase": {
-      "version": "2.1.1",
-      "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-2.1.1.tgz",
-      "integrity": "sha1-fB0W1nmhu+WcoCys7PsBHiAfWh8="
-    },
-    "capitalize-sentence": {
-      "version": "0.1.5",
-      "resolved": "https://registry.npmjs.org/capitalize-sentence/-/capitalize-sentence-0.1.5.tgz",
-      "integrity": "sha1-e/LtUdyKoqY8lPgkA55KphS3HeY="
-    },
-    "capture-stack-trace": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/capture-stack-trace/-/capture-stack-trace-1.0.1.tgz",
-      "integrity": "sha512-mYQLZnx5Qt1JgB1WEiMCf2647plpGeQ2NMR/5L0HNZzGQo4fuSPnK+wjfPnKZV0aiJDgzmWqqkV/g7JD+DW0qw=="
-    },
-    "caseless": {
-      "version": "0.12.0",
-      "resolved": "https://registry.npmjs.org/caseless/-/caseless-0.12.0.tgz",
-      "integrity": "sha1-G2gcIf+EAzyCZUMJBolCDRhxUdw="
-    },
-    "class-utils": {
-      "version": "0.3.6",
-      "resolved": "https://registry.npmjs.org/class-utils/-/class-utils-0.3.6.tgz",
-      "integrity": "sha512-qOhPa/Fj7s6TY8H8esGu5QNpMMQxz79h+urzrNYN6mn+9BnxlDGf5QZ+XeCDsxSjPqsSR56XOZOJmpeurnLMeg==",
-      "requires": {
-        "arr-union": "3.1.0",
-        "define-property": "0.2.5",
-        "isobject": "3.0.1",
-        "static-extend": "0.1.2"
-      },
-      "dependencies": {
-        "define-property": {
-          "version": "0.2.5",
-          "resolved": "https://registry.npmjs.org/define-property/-/define-property-0.2.5.tgz",
-          "integrity": "sha1-w1se+RjsPJkPmlvFe+BKrOxcgRY=",
-          "requires": {
-            "is-descriptor": "0.1.6"
-          }
-        }
-      }
-    },
-    "cliui": {
-      "version": "3.2.0",
-      "resolved": "https://registry.npmjs.org/cliui/-/cliui-3.2.0.tgz",
-      "integrity": "sha1-EgYBU3qRbSmUD5NNo7SNWFo5IT0=",
-      "requires": {
-        "string-width": "1.0.2",
-        "strip-ansi": "3.0.1",
-        "wrap-ansi": "2.1.0"
-      }
-    },
-    "code-point-at": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/code-point-at/-/code-point-at-1.1.0.tgz",
-      "integrity": "sha1-DQcLTQQ6W+ozovGkDi7bPZpMz3c="
-    },
-    "collection-visit": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/collection-visit/-/collection-visit-1.0.0.tgz",
-      "integrity": "sha1-S8A3PBZLwykbTTaMgpzxqApZ3KA=",
-      "requires": {
-        "map-visit": "1.0.0",
-        "object-visit": "1.0.1"
-      }
-    },
-    "colour": {
-      "version": "0.7.1",
-      "resolved": "https://registry.npmjs.org/colour/-/colour-0.7.1.tgz",
-      "integrity": "sha1-nLFpkX7F0SwHNtPoaFdG3xyt93g="
-    },
-    "combined-stream": {
-      "version": "1.0.7",
-      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.7.tgz",
-      "integrity": "sha512-brWl9y6vOB1xYPZcpZde3N9zDByXTosAeMDo4p1wzo6UMOX4vumB+TP1RZ76sfE6Md68Q0NJSrE/gbezd4Ul+w==",
-      "requires": {
-        "delayed-stream": "1.0.0"
-      }
-    },
-    "component-emitter": {
-      "version": "1.2.1",
-      "resolved": "https://registry.npmjs.org/component-emitter/-/component-emitter-1.2.1.tgz",
-      "integrity": "sha1-E3kY1teCg/ffemt8WmPhQOaUJeY="
-    },
-    "compressible": {
-      "version": "2.0.15",
-      "resolved": "https://registry.npmjs.org/compressible/-/compressible-2.0.15.tgz",
-      "integrity": "sha512-4aE67DL33dSW9gw4CI2H/yTxqHLNcxp0yS6jB+4h+wr3e43+1z7vm0HU9qXOH8j+qjKuL8+UtkOxYQSMq60Ylw==",
-      "requires": {
-        "mime-db": "1.38.0"
-      }
-    },
-    "concat-map": {
-      "version": "0.0.1",
-      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
-      "integrity": "sha1-2Klr13/Wjfd5OnMDajug1UBdR3s="
-    },
-    "concat-stream": {
-      "version": "1.6.2",
-      "resolved": "https://registry.npmjs.org/concat-stream/-/concat-stream-1.6.2.tgz",
-      "integrity": "sha512-27HBghJxjiZtIk3Ycvn/4kbJk/1uZuJFfuPEns6LaEvpvG1f0hTea8lilrouyo9mVc2GWdcEZ8OLoGmSADlrCw==",
-      "requires": {
-        "buffer-from": "1.1.1",
-        "inherits": "2.0.3",
-        "readable-stream": "2.3.6",
-        "typedarray": "0.0.6"
-      }
-    },
-    "configstore": {
-      "version": "3.1.2",
-      "resolved": "https://registry.npmjs.org/configstore/-/configstore-3.1.2.tgz",
-      "integrity": "sha512-vtv5HtGjcYUgFrXc6Kx747B83MRRVS5R1VTEQoXvuP+kMI+if6uywV0nDGoiydJRy4yk7h9od5Og0kxx4zUXmw==",
-      "requires": {
-        "dot-prop": "4.2.0",
-        "graceful-fs": "4.1.15",
-        "make-dir": "1.3.0",
-        "unique-string": "1.0.0",
-        "write-file-atomic": "2.4.2",
-        "xdg-basedir": "3.0.0"
-      }
-    },
-    "content-disposition": {
-      "version": "0.5.2",
-      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-0.5.2.tgz",
-      "integrity": "sha1-DPaLud318r55YcOoUXjLhdunjLQ="
-    },
-    "content-type": {
-      "version": "1.0.4",
-      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.4.tgz",
-      "integrity": "sha512-hIP3EEPs8tB9AT1L+NUqtwOAps4mk2Zob89MWXMHjHWg9milF/j4osnnQLXBCBFBk/tvIG/tUc9mOUJiPBhPXA=="
-    },
-    "cookie": {
-      "version": "0.3.1",
-      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.3.1.tgz",
-      "integrity": "sha1-5+Ch+e9DtMi6klxcWpboBtFoc7s="
-    },
-    "cookie-signature": {
-      "version": "1.0.6",
-      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.6.tgz",
-      "integrity": "sha1-4wOogrNCzD7oylE6eZmXNNqzriw="
-    },
-    "copy-descriptor": {
-      "version": "0.1.1",
-      "resolved": "https://registry.npmjs.org/copy-descriptor/-/copy-descriptor-0.1.1.tgz",
-      "integrity": "sha1-Z29us8OZl8LuGsOpJP1hJHSPV40="
-    },
-    "core-js": {
-      "version": "2.6.5",
-      "resolved": "https://registry.npmjs.org/core-js/-/core-js-2.6.5.tgz",
-      "integrity": "sha512-klh/kDpwX8hryYL14M9w/xei6vrv6sE8gTHDG7/T/+SEovB/G4ejwcfE/CBzO6Edsu+OETZMZ3wcX/EjUkrl5A=="
-    },
-    "core-util-is": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.2.tgz",
-      "integrity": "sha1-tf1UIgqivFq1eqtxQMlAdUUDwac="
-    },
-    "cors": {
-      "version": "2.8.5",
-      "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
-      "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
-      "requires": {
-        "object-assign": "4.1.1",
-        "vary": "1.1.2"
-      }
-    },
-    "create-error-class": {
-      "version": "3.0.2",
-      "resolved": "https://registry.npmjs.org/create-error-class/-/create-error-class-3.0.2.tgz",
-      "integrity": "sha1-Br56vvlHo/FKMP1hBnHUAbyot7Y=",
-      "requires": {
-        "capture-stack-trace": "1.0.1"
-      }
-    },
-    "crypto-random-string": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/crypto-random-string/-/crypto-random-string-1.0.0.tgz",
-      "integrity": "sha1-ojD2T1aDEOFJgAmUB5DsmVRbyn4="
-    },
-    "dashdash": {
-      "version": "1.14.1",
-      "resolved": "https://registry.npmjs.org/dashdash/-/dashdash-1.14.1.tgz",
-      "integrity": "sha1-hTz6D3y+L+1d4gMmuN1YEDX24vA=",
-      "requires": {
-        "assert-plus": "1.0.0"
-      }
-    },
-    "debug": {
-      "version": "3.2.6",
-      "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.6.tgz",
-      "integrity": "sha512-mel+jf7nrtEl5Pn1Qx46zARXKDpBbvzezse7p7LqINmdoIk8PYP5SySaxEmYv6TZ0JyEKA1hsCId6DIhgITtWQ==",
-      "requires": {
-        "ms": "2.1.1"
-      }
-    },
-    "decamelize": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/decamelize/-/decamelize-1.2.0.tgz",
-      "integrity": "sha1-9lNNFRSCabIDUue+4m9QH5oZEpA="
-    },
-    "decode-uri-component": {
-      "version": "0.2.0",
-      "resolved": "https://registry.npmjs.org/decode-uri-component/-/decode-uri-component-0.2.0.tgz",
-      "integrity": "sha1-6zkTMzRYd1y4TNGh+uBiEGu4dUU="
-    },
-    "deep-equal": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/deep-equal/-/deep-equal-1.0.1.tgz",
-      "integrity": "sha1-9dJgKStmDghO/0zbyfCK0yR0SLU="
-    },
-    "define-properties": {
-      "version": "1.1.3",
-      "resolved": "https://registry.npmjs.org/define-properties/-/define-properties-1.1.3.tgz",
-      "integrity": "sha512-3MqfYKj2lLzdMSf8ZIZE/V+Zuy+BgD6f164e8K2w7dgnpKArBDerGYpM46IYYcjnkdPNMjPk9A6VFB8+3SKlXQ==",
-      "requires": {
-        "object-keys": "1.1.0"
-      }
-    },
-    "define-property": {
-      "version": "2.0.2",
-      "resolved": "https://registry.npmjs.org/define-property/-/define-property-2.0.2.tgz",
-      "integrity": "sha512-jwK2UV4cnPpbcG7+VRARKTZPUWowwXA8bzH5NP6ud0oeAxyYPuGZUAC7hMugpCdz4BeSZl2Dl9k66CHJ/46ZYQ==",
-      "requires": {
-        "is-descriptor": "1.0.2",
-        "isobject": "3.0.1"
-      },
-      "dependencies": {
-        "is-accessor-descriptor": {
-          "version": "1.0.0",
-          "resolved": "https://registry.npmjs.org/is-accessor-descriptor/-/is-accessor-descriptor-1.0.0.tgz",
-          "integrity": "sha512-m5hnHTkcVsPfqx3AKlyttIPb7J+XykHvJP2B9bZDjlhLIoEq4XoK64Vg7boZlVWYK6LUY94dYPEE7Lh0ZkZKcQ==",
-          "requires": {
-            "kind-of": "6.0.2"
-          }
-        },
-        "is-data-descriptor": {
-          "version": "1.0.0",
-          "resolved": "https://registry.npmjs.org/is-data-descriptor/-/is-data-descriptor-1.0.0.tgz",
-          "integrity": "sha512-jbRXy1FmtAoCjQkVmIVYwuuqDFUbaOeDjmed1tOGPrsMhtJA4rD9tkgA0F1qJ3gRFRXcHYVkdeaP50Q5rE/jLQ==",
-          "requires": {
-            "kind-of": "6.0.2"
-          }
-        },
-        "is-descriptor": {
-          "version": "1.0.2",
-          "resolved": "https://registry.npmjs.org/is-descriptor/-/is-descriptor-1.0.2.tgz",
-          "integrity": "sha512-2eis5WqQGV7peooDyLmNEPUrps9+SXX5c9pL3xEB+4e9HnGuDa7mB7kHxHw4CbqS9k1T2hOH3miL8n8WtiYVtg==",
-          "requires": {
-            "is-accessor-descriptor": "1.0.0",
-            "is-data-descriptor": "1.0.0",
-            "kind-of": "6.0.2"
-          }
-        }
-      }
-    },
-    "delayed-stream": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
-      "integrity": "sha1-3zrhmayt+31ECqrgsp4icrJOxhk="
-    },
-    "depd": {
-      "version": "1.1.2",
-      "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
-      "integrity": "sha1-m81S4UwJd2PnSbJ0xDRu0uVgtak="
-    },
-    "destroy": {
-      "version": "1.0.4",
-      "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.0.4.tgz",
-      "integrity": "sha1-l4hXRCxEdJ5CBmE+N5RiBYJqvYA="
-    },
-    "diff-match-patch": {
-      "version": "1.0.4",
-      "resolved": "https://registry.npmjs.org/diff-match-patch/-/diff-match-patch-1.0.4.tgz",
-      "integrity": "sha512-Uv3SW8bmH9nAtHKaKSanOQmj2DnlH65fUpcrMdfdaOxUG02QQ4YGZ8AE7kKOMisF7UqvOlGKVYWRvezdncW9lg=="
-    },
-    "dir-glob": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/dir-glob/-/dir-glob-2.0.0.tgz",
-      "integrity": "sha512-37qirFDz8cA5fimp9feo43fSuRo2gHwaIn6dXL8Ber1dGwUosDrGZeCCXq57WnIqE4aQ+u3eQZzsk1yOzhdwag==",
-      "requires": {
-        "arrify": "1.0.1",
-        "path-type": "3.0.0"
-      }
-    },
-    "dot-prop": {
-      "version": "4.2.0",
-      "resolved": "https://registry.npmjs.org/dot-prop/-/dot-prop-4.2.0.tgz",
-      "integrity": "sha512-tUMXrxlExSW6U2EXiiKGSBVdYgtV8qlHL+C10TsW4PURY/ic+eaysnSkwB4kA/mBlCyy/IKDJ+Lc3wbWeaXtuQ==",
-      "requires": {
-        "is-obj": "1.0.1"
-      }
-    },
-    "duplexify": {
-      "version": "3.7.1",
-      "resolved": "https://registry.npmjs.org/duplexify/-/duplexify-3.7.1.tgz",
-      "integrity": "sha512-07z8uv2wMyS51kKhD1KsdXJg5WQ6t93RneqRxUHnskXVtlYYkLqM0gqStQZ3pj073g687jPCHrqNfCzawLYh5g==",
-      "requires": {
-        "end-of-stream": "1.4.1",
-        "inherits": "2.0.3",
-        "readable-stream": "2.3.6",
-        "stream-shift": "1.0.0"
-      }
-    },
-    "eastasianwidth": {
-      "version": "0.2.0",
-      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
-      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA=="
-    },
-    "ecc-jsbn": {
-      "version": "0.1.2",
-      "resolved": "https://registry.npmjs.org/ecc-jsbn/-/ecc-jsbn-0.1.2.tgz",
-      "integrity": "sha1-OoOpBOVDUyh4dMVkt1SThoSamMk=",
-      "requires": {
-        "jsbn": "0.1.1",
-        "safer-buffer": "2.1.2"
-      }
-    },
-    "ecdsa-sig-formatter": {
-      "version": "1.0.10",
-      "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.10.tgz",
-      "integrity": "sha1-HFlQAPBKiJffuFAAiSoPTDOvhsM=",
-      "requires": {
-        "safe-buffer": "5.1.2"
-      }
-    },
-    "ee-first": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
-      "integrity": "sha1-WQxhFWsK4vTwJVcyoViyZrxWsh0="
-    },
-    "empower": {
-      "version": "1.3.1",
-      "resolved": "https://registry.npmjs.org/empower/-/empower-1.3.1.tgz",
-      "integrity": "sha512-uB6/ViBaawOO/uujFADTK3SqdYlxYNn+N4usK9MRKZ4Hbn/1QSy8k2PezxCA2/+JGbF8vd/eOfghZ90oOSDZCA==",
-      "requires": {
-        "core-js": "2.6.5",
-        "empower-core": "1.2.0"
-      }
-    },
-    "empower-core": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/empower-core/-/empower-core-1.2.0.tgz",
-      "integrity": "sha512-g6+K6Geyc1o6FdXs9HwrXleCFan7d66G5xSCfSF7x1mJDCes6t0om9lFQG3zOrzh3Bkb/45N0cZ5Gqsf7YrzGQ==",
-      "requires": {
-        "call-signature": "0.0.2",
-        "core-js": "2.6.5"
-      }
-    },
-    "encodeurl": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz",
-      "integrity": "sha1-rT/0yG7C0CkyL1oCw6mmBslbP1k="
-    },
-    "end-of-stream": {
-      "version": "1.4.1",
-      "resolved": "https://registry.npmjs.org/end-of-stream/-/end-of-stream-1.4.1.tgz",
-      "integrity": "sha512-1MkrZNvWTKCaigbn+W15elq2BB/L22nqrSY5DKlo3X6+vclJm8Bb5djXJBmEX6fS3+zCh/F4VBK5Z2KxJt4s2Q==",
-      "requires": {
-        "once": "1.4.0"
-      }
-    },
-    "ent": {
-      "version": "2.2.0",
-      "resolved": "https://registry.npmjs.org/ent/-/ent-2.2.0.tgz",
-      "integrity": "sha1-6WQhkyWiHQX0RGai9obtbOX13R0="
-    },
-    "es6-promise": {
-      "version": "4.2.5",
-      "resolved": "https://registry.npmjs.org/es6-promise/-/es6-promise-4.2.5.tgz",
-      "integrity": "sha512-n6wvpdE43VFtJq+lUDYDBFUwV8TZbuGXLV4D6wKafg13ldznKsyEvatubnmUe31zcvelSzOHF+XbaT+Bl9ObDg=="
-    },
-    "es6-promisify": {
-      "version": "5.0.0",
-      "resolved": "https://registry.npmjs.org/es6-promisify/-/es6-promisify-5.0.0.tgz",
-      "integrity": "sha1-UQnWLz5W6pZ8S2NQWu8IKRyKUgM=",
-      "requires": {
-        "es6-promise": "4.2.5"
-      }
-    },
-    "escape-html": {
-      "version": "1.0.3",
-      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
-      "integrity": "sha1-Aljq5NPQwJdN4cFpGI7wBR0dGYg="
-    },
-    "espurify": {
-      "version": "1.8.1",
-      "resolved": "https://registry.npmjs.org/espurify/-/espurify-1.8.1.tgz",
-      "integrity": "sha512-ZDko6eY/o+D/gHCWyHTU85mKDgYcS4FJj7S+YD6WIInm7GQ6AnOjmcL4+buFV/JOztVLELi/7MmuGU5NHta0Mg==",
-      "requires": {
-        "core-js": "2.6.5"
-      }
-    },
-    "estraverse": {
-      "version": "4.2.0",
-      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.2.0.tgz",
-      "integrity": "sha1-De4/7TH81GlhjOc0IJn8GvoL2xM="
-    },
-    "etag": {
-      "version": "1.8.1",
-      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
-      "integrity": "sha1-Qa4u62XvpiJorr/qg6x9eSmbCIc="
-    },
-    "event-target-shim": {
-      "version": "5.0.0",
-      "resolved": "https://registry.npmjs.org/event-target-shim/-/event-target-shim-5.0.0.tgz",
-      "integrity": "sha512-vu4tlY5xqMEGj/rzuDHxfvm9Kk2562O5h58i8xwnkMkv/yqmBqBcDJt/vGBrOBbCKuVc5eV3ghYxAX9YUhyi0w=="
-    },
-    "expand-brackets": {
-      "version": "2.1.4",
-      "resolved": "https://registry.npmjs.org/expand-brackets/-/expand-brackets-2.1.4.tgz",
-      "integrity": "sha1-t3c14xXOMPa27/D4OwQVGiJEliI=",
-      "requires": {
-        "debug": "2.6.9",
-        "define-property": "0.2.5",
-        "extend-shallow": "2.0.1",
-        "posix-character-classes": "0.1.1",
-        "regex-not": "1.0.2",
-        "snapdragon": "0.8.2",
-        "to-regex": "3.0.2"
-      },
-      "dependencies": {
-        "debug": {
-          "version": "2.6.9",
-          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
-          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
-          "requires": {
-            "ms": "2.0.0"
-          }
-        },
-        "define-property": {
-          "version": "0.2.5",
-          "resolved": "https://registry.npmjs.org/define-property/-/define-property-0.2.5.tgz",
-          "integrity": "sha1-w1se+RjsPJkPmlvFe+BKrOxcgRY=",
-          "requires": {
-            "is-descriptor": "0.1.6"
-          }
-        },
-        "extend-shallow": {
-          "version": "2.0.1",
-          "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-2.0.1.tgz",
-          "integrity": "sha1-Ua99YUrZqfYQ6huvu5idaxxWiQ8=",
-          "requires": {
-            "is-extendable": "0.1.1"
-          }
-        },
-        "ms": {
-          "version": "2.0.0",
-          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
-          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g="
-        }
-      }
-    },
-    "express": {
-      "version": "4.16.4",
-      "resolved": "https://registry.npmjs.org/express/-/express-4.16.4.tgz",
-      "integrity": "sha512-j12Uuyb4FMrd/qQAm6uCHAkPtO8FDTRJZBDd5D2KOL2eLaz1yUNdUB/NOIyq0iU4q4cFarsUCrnFDPBcnksuOg==",
-      "requires": {
-        "accepts": "1.3.5",
-        "array-flatten": "1.1.1",
-        "body-parser": "1.18.3",
-        "content-disposition": "0.5.2",
-        "content-type": "1.0.4",
-        "cookie": "0.3.1",
-        "cookie-signature": "1.0.6",
-        "debug": "2.6.9",
-        "depd": "1.1.2",
-        "encodeurl": "1.0.2",
-        "escape-html": "1.0.3",
-        "etag": "1.8.1",
-        "finalhandler": "1.1.1",
-        "fresh": "0.5.2",
-        "merge-descriptors": "1.0.1",
-        "methods": "1.1.2",
-        "on-finished": "2.3.0",
-        "parseurl": "1.3.2",
-        "path-to-regexp": "0.1.7",
-        "proxy-addr": "2.0.4",
-        "qs": "6.5.2",
-        "range-parser": "1.2.0",
-        "safe-buffer": "5.1.2",
-        "send": "0.16.2",
-        "serve-static": "1.13.2",
-        "setprototypeof": "1.1.0",
-        "statuses": "1.4.0",
-        "type-is": "1.6.16",
-        "utils-merge": "1.0.1",
-        "vary": "1.1.2"
-      },
-      "dependencies": {
-        "debug": {
-          "version": "2.6.9",
-          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
-          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
-          "requires": {
-            "ms": "2.0.0"
-          }
-        },
-        "ms": {
-          "version": "2.0.0",
-          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
-          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g="
-        }
-      }
-    },
-    "extend": {
-      "version": "3.0.2",
-      "resolved": "https://registry.npmjs.org/extend/-/extend-3.0.2.tgz",
-      "integrity": "sha512-fjquC59cD7CyW6urNXK0FBufkZcoiGG80wTuPujX590cB5Ttln20E2UB4S/WARVqhXffZl2LNgS+gQdPIIim/g=="
-    },
-    "extend-shallow": {
-      "version": "3.0.2",
-      "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-3.0.2.tgz",
-      "integrity": "sha1-Jqcarwc7OfshJxcnRhMcJwQCjbg=",
-      "requires": {
-        "assign-symbols": "1.0.0",
-        "is-extendable": "1.0.1"
-      },
-      "dependencies": {
-        "is-extendable": {
-          "version": "1.0.1",
-          "resolved": "https://registry.npmjs.org/is-extendable/-/is-extendable-1.0.1.tgz",
-          "integrity": "sha512-arnXMxT1hhoKo9k1LZdmlNyJdDDfy2v0fXjFlmok4+i8ul/6WlbVge9bhM74OpNPQPMGUToDtz+KXa1PneJxOA==",
-          "requires": {
-            "is-plain-object": "2.0.4"
-          }
-        }
-      }
-    },
-    "extglob": {
-      "version": "2.0.4",
-      "resolved": "https://registry.npmjs.org/extglob/-/extglob-2.0.4.tgz",
-      "integrity": "sha512-Nmb6QXkELsuBr24CJSkilo6UHHgbekK5UiZgfE6UHD3Eb27YC6oD+bhcT+tJ6cl8dmsgdQxnWlcry8ksBIBLpw==",
-      "requires": {
-        "array-unique": "0.3.2",
-        "define-property": "1.0.0",
-        "expand-brackets": "2.1.4",
-        "extend-shallow": "2.0.1",
-        "fragment-cache": "0.2.1",
-        "regex-not": "1.0.2",
-        "snapdragon": "0.8.2",
-        "to-regex": "3.0.2"
-      },
-      "dependencies": {
-        "define-property": {
-          "version": "1.0.0",
-          "resolved": "https://registry.npmjs.org/define-property/-/define-property-1.0.0.tgz",
-          "integrity": "sha1-dp66rz9KY6rTr56NMEybvnm/sOY=",
-          "requires": {
-            "is-descriptor": "1.0.2"
-          }
-        },
-        "extend-shallow": {
-          "version": "2.0.1",
-          "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-2.0.1.tgz",
-          "integrity": "sha1-Ua99YUrZqfYQ6huvu5idaxxWiQ8=",
-          "requires": {
-            "is-extendable": "0.1.1"
-          }
-        },
-        "is-accessor-descriptor": {
-          "version": "1.0.0",
-          "resolved": "https://registry.npmjs.org/is-accessor-descriptor/-/is-accessor-descriptor-1.0.0.tgz",
-          "integrity": "sha512-m5hnHTkcVsPfqx3AKlyttIPb7J+XykHvJP2B9bZDjlhLIoEq4XoK64Vg7boZlVWYK6LUY94dYPEE7Lh0ZkZKcQ==",
-          "requires": {
-            "kind-of": "6.0.2"
-          }
-        },
-        "is-data-descriptor": {
-          "version": "1.0.0",
-          "resolved": "https://registry.npmjs.org/is-data-descriptor/-/is-data-descriptor-1.0.0.tgz",
-          "integrity": "sha512-jbRXy1FmtAoCjQkVmIVYwuuqDFUbaOeDjmed1tOGPrsMhtJA4rD9tkgA0F1qJ3gRFRXcHYVkdeaP50Q5rE/jLQ==",
-          "requires": {
-            "kind-of": "6.0.2"
-          }
-        },
-        "is-descriptor": {
-          "version": "1.0.2",
-          "resolved": "https://registry.npmjs.org/is-descriptor/-/is-descriptor-1.0.2.tgz",
-          "integrity": "sha512-2eis5WqQGV7peooDyLmNEPUrps9+SXX5c9pL3xEB+4e9HnGuDa7mB7kHxHw4CbqS9k1T2hOH3miL8n8WtiYVtg==",
-          "requires": {
-            "is-accessor-descriptor": "1.0.0",
-            "is-data-descriptor": "1.0.0",
-            "kind-of": "6.0.2"
-          }
-        }
-      }
-    },
-    "extsprintf": {
-      "version": "1.3.0",
-      "resolved": "https://registry.npmjs.org/extsprintf/-/extsprintf-1.3.0.tgz",
-      "integrity": "sha1-lpGEQOMEGnpBT4xS48V06zw+HgU="
-    },
-    "fast-deep-equal": {
-      "version": "2.0.1",
-      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-2.0.1.tgz",
-      "integrity": "sha1-ewUhjd+WZ79/Nwv3/bLLFf3Qqkk="
-    },
-    "fast-glob": {
-      "version": "2.2.6",
-      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-2.2.6.tgz",
-      "integrity": "sha512-0BvMaZc1k9F+MeWWMe8pL6YltFzZYcJsYU7D4JyDA6PAczaXvxqQQ/z+mDF7/4Mw01DeUc+i3CTKajnkANkV4w==",
-      "requires": {
-        "@mrmlnc/readdir-enhanced": "2.2.1",
-        "@nodelib/fs.stat": "1.1.3",
-        "glob-parent": "3.1.0",
-        "is-glob": "4.0.0",
-        "merge2": "1.2.3",
-        "micromatch": "3.1.10"
-      }
-    },
-    "fast-json-stable-stringify": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.0.0.tgz",
-      "integrity": "sha1-1RQsDK7msRifh9OnYREGT4bIu/I="
-    },
-    "faye-websocket": {
-      "version": "0.9.3",
-      "resolved": "https://registry.npmjs.org/faye-websocket/-/faye-websocket-0.9.3.tgz",
-      "integrity": "sha1-SCpQWw3wrmJrlphm0710DNuWLoM=",
-      "requires": {
-        "websocket-driver": "0.7.0"
-      }
-    },
-    "fill-range": {
-      "version": "4.0.0",
-      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-4.0.0.tgz",
-      "integrity": "sha1-1USBHUKPmOsGpj3EAtJAPDKMOPc=",
-      "requires": {
-        "extend-shallow": "2.0.1",
-        "is-number": "3.0.0",
-        "repeat-string": "1.6.1",
-        "to-regex-range": "2.1.1"
-      },
-      "dependencies": {
-        "extend-shallow": {
-          "version": "2.0.1",
-          "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-2.0.1.tgz",
-          "integrity": "sha1-Ua99YUrZqfYQ6huvu5idaxxWiQ8=",
-          "requires": {
-            "is-extendable": "0.1.1"
-          }
-        }
-      }
-    },
-    "finalhandler": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.1.1.tgz",
-      "integrity": "sha512-Y1GUDo39ez4aHAw7MysnUD5JzYX+WaIj8I57kO3aEPT1fFRL4sr7mjei97FgnwhAyyzRYmQZaTHb2+9uZ1dPtg==",
-      "requires": {
-        "debug": "2.6.9",
-        "encodeurl": "1.0.2",
-        "escape-html": "1.0.3",
-        "on-finished": "2.3.0",
-        "parseurl": "1.3.2",
-        "statuses": "1.4.0",
-        "unpipe": "1.0.0"
-      },
-      "dependencies": {
-        "debug": {
-          "version": "2.6.9",
-          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
-          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
-          "requires": {
-            "ms": "2.0.0"
-          }
-        },
-        "ms": {
-          "version": "2.0.0",
-          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
-          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g="
-        }
-      }
-    },
-    "firebase-admin": {
-      "version": "5.10.0",
-      "resolved": "https://registry.npmjs.org/firebase-admin/-/firebase-admin-5.10.0.tgz",
-      "integrity": "sha1-dtj85rsdvSwF7HbL+1ncGtOXflY=",
-      "requires": {
-        "@firebase/app": "0.1.10",
-        "@firebase/database": "0.2.2",
-        "@google-cloud/firestore": "0.13.1",
-        "@google-cloud/storage": "1.7.0",
-        "@types/google-cloud__storage": "1.7.2",
-        "@types/node": "8.10.40",
-        "faye-websocket": "0.9.3",
-        "jsonwebtoken": "8.1.0",
-        "node-forge": "0.7.1"
-      }
-    },
-    "firebase-functions": {
-      "version": "2.2.0",
-      "resolved": "https://registry.npmjs.org/firebase-functions/-/firebase-functions-2.2.0.tgz",
-      "integrity": "sha512-83rJvXreTH98q1XEEUZ4G9nFZ0sUVaqkxPC+v25L9FuXsWgAFpW7G28K0MJ9DBPNo/RaeNNw0zvZVtDw11CEbQ==",
-      "requires": {
-        "@types/cors": "2.8.4",
-        "@types/express": "4.16.1",
-        "@types/jsonwebtoken": "7.2.8",
-        "@types/lodash": "4.14.121",
-        "cors": "2.8.5",
-        "express": "4.16.4",
-        "jsonwebtoken": "8.4.0",
-        "lodash": "4.17.11"
-      },
-      "dependencies": {
-        "jsonwebtoken": {
-          "version": "8.4.0",
-          "resolved": "https://registry.npmjs.org/jsonwebtoken/-/jsonwebtoken-8.4.0.tgz",
-          "integrity": "sha512-coyXjRTCy0pw5WYBpMvWOMN+Kjaik2MwTUIq9cna/W7NpO9E+iYbumZONAz3hcr+tXFJECoQVrtmIoC3Oz0gvg==",
-          "requires": {
-            "jws": "3.2.1",
-            "lodash.includes": "4.3.0",
-            "lodash.isboolean": "3.0.3",
-            "lodash.isinteger": "4.0.4",
-            "lodash.isnumber": "3.0.3",
-            "lodash.isplainobject": "4.0.6",
-            "lodash.isstring": "4.0.1",
-            "lodash.once": "4.1.1",
-            "ms": "2.1.1"
-          }
-        }
-      }
-    },
-    "follow-redirects": {
-      "version": "1.7.0",
-      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.7.0.tgz",
-      "integrity": "sha512-m/pZQy4Gj287eNy94nivy5wchN3Kp+Q5WgUPNy5lJSZ3sgkVKSYV/ZChMAQVIgx1SqfZ2zBZtPA2YlXIWxxJOQ==",
-      "requires": {
-        "debug": "3.2.6"
-      }
-    },
-    "for-in": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/for-in/-/for-in-1.0.2.tgz",
-      "integrity": "sha1-gQaNKVqBQuwKxybG4iAMMPttXoA="
-    },
-    "forever-agent": {
-      "version": "0.6.1",
-      "resolved": "https://registry.npmjs.org/forever-agent/-/forever-agent-0.6.1.tgz",
-      "integrity": "sha1-+8cfDEGt6zf5bFd60e1C2P2sypE="
-    },
-    "form-data": {
-      "version": "2.3.3",
-      "resolved": "https://registry.npmjs.org/form-data/-/form-data-2.3.3.tgz",
-      "integrity": "sha512-1lLKB2Mu3aGP1Q/2eCOx0fNbRMe7XdwktwOruhfqqd0rIJWwN4Dh+E3hrPSlDCXnSR7UtZ1N38rVXm+6+MEhJQ==",
-      "requires": {
-        "asynckit": "0.4.0",
-        "combined-stream": "1.0.7",
-        "mime-types": "2.1.22"
-      }
-    },
-    "forwarded": {
-      "version": "0.1.2",
-      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.1.2.tgz",
-      "integrity": "sha1-mMI9qxF1ZXuMBXPozszZGw/xjIQ="
-    },
-    "fragment-cache": {
-      "version": "0.2.1",
-      "resolved": "https://registry.npmjs.org/fragment-cache/-/fragment-cache-0.2.1.tgz",
-      "integrity": "sha1-QpD60n8T6Jvn8zeZxrxaCr//DRk=",
-      "requires": {
-        "map-cache": "0.2.2"
-      }
-    },
-    "fresh": {
-      "version": "0.5.2",
-      "resolved": "https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz",
-      "integrity": "sha1-PYyt2Q2XZWn6g1qx+OSyOhBWBac="
-    },
-    "fs.realpath": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
-      "integrity": "sha1-FQStJSMVjKpA20onh8sBQRmU6k8="
-    },
-    "functional-red-black-tree": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/functional-red-black-tree/-/functional-red-black-tree-1.0.1.tgz",
-      "integrity": "sha1-GwqzvVU7Kg1jmdKcDj6gslIHgyc="
-    },
-    "gaxios": {
-      "version": "1.7.0",
-      "resolved": "https://registry.npmjs.org/gaxios/-/gaxios-1.7.0.tgz",
-      "integrity": "sha512-2SaZTtaEgnSMgRrBVnPA5O9Tc8xWfnL48fuxFL7zOHZwnam3HiNOkoosnRgnkNBZoEZrH1Aja3wMCrrDtOEqUw==",
-      "requires": {
-        "abort-controller": "2.0.2",
-        "extend": "3.0.2",
-        "https-proxy-agent": "2.2.1",
-        "node-fetch": "2.3.0"
-      }
-    },
-    "gcp-metadata": {
-      "version": "0.6.3",
-      "resolved": "https://registry.npmjs.org/gcp-metadata/-/gcp-metadata-0.6.3.tgz",
-      "integrity": "sha512-MSmczZctbz91AxCvqp9GHBoZOSbJKAICV7Ow/AIWSJZRrRchUd5NL1b2P4OfP+4m490BEUPhhARfpHdqCxuCvg==",
-      "requires": {
-        "axios": "0.18.0",
-        "extend": "3.0.2",
-        "retry-axios": "0.3.2"
-      }
-    },
-    "gcs-resumable-upload": {
-      "version": "0.10.2",
-      "resolved": "https://registry.npmjs.org/gcs-resumable-upload/-/gcs-resumable-upload-0.10.2.tgz",
-      "integrity": "sha1-fymz7iPc7EFwNnwHEUGCScZgVF8=",
-      "requires": {
-        "configstore": "3.1.2",
-        "google-auto-auth": "0.10.1",
-        "pumpify": "1.5.1",
-        "request": "2.88.0",
-        "stream-events": "1.0.5"
-      }
-    },
-    "get-value": {
-      "version": "2.0.6",
-      "resolved": "https://registry.npmjs.org/get-value/-/get-value-2.0.6.tgz",
-      "integrity": "sha1-3BXKHGcjh8p2vTesCjlbogQqLCg="
-    },
-    "getpass": {
-      "version": "0.1.7",
-      "resolved": "https://registry.npmjs.org/getpass/-/getpass-0.1.7.tgz",
-      "integrity": "sha1-Xv+OPmhNVprkyysSgmBOi6YhSfo=",
-      "requires": {
-        "assert-plus": "1.0.0"
-      }
-    },
-    "glob": {
-      "version": "7.1.3",
-      "resolved": "https://registry.npmjs.org/glob/-/glob-7.1.3.tgz",
-      "integrity": "sha512-vcfuiIxogLV4DlGBHIUOwI0IbrJ8HWPc4MU7HzviGeNho/UJDfi6B5p3sHeWIQ0KGIU0Jpxi5ZHxemQfLkkAwQ==",
-      "requires": {
-        "fs.realpath": "1.0.0",
-        "inflight": "1.0.6",
-        "inherits": "2.0.3",
-        "minimatch": "3.0.4",
-        "once": "1.4.0",
-        "path-is-absolute": "1.0.1"
-      }
-    },
-    "glob-parent": {
-      "version": "3.1.0",
-      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-3.1.0.tgz",
-      "integrity": "sha1-nmr2KZ2NO9K9QEMIMr0RPfkGxa4=",
-      "requires": {
-        "is-glob": "3.1.0",
-        "path-dirname": "1.0.2"
-      },
-      "dependencies": {
-        "is-glob": {
-          "version": "3.1.0",
-          "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-3.1.0.tgz",
-          "integrity": "sha1-e6WuJCF4BKxwcHuWkiVnSGzD6Eo=",
-          "requires": {
-            "is-extglob": "2.1.1"
-          }
-        }
-      }
-    },
-    "glob-to-regexp": {
-      "version": "0.3.0",
-      "resolved": "https://registry.npmjs.org/glob-to-regexp/-/glob-to-regexp-0.3.0.tgz",
-      "integrity": "sha1-jFoUlNIGbFcMw7/kSWF1rMTVAqs="
-    },
-    "globby": {
-      "version": "8.0.2",
-      "resolved": "https://registry.npmjs.org/globby/-/globby-8.0.2.tgz",
-      "integrity": "sha512-yTzMmKygLp8RUpG1Ymu2VXPSJQZjNAZPD4ywgYEaG7e4tBJeUQBO8OpXrf1RCNcEs5alsoJYPAMiIHP0cmeC7w==",
-      "requires": {
-        "array-union": "1.0.2",
-        "dir-glob": "2.0.0",
-        "fast-glob": "2.2.6",
-        "glob": "7.1.3",
-        "ignore": "3.3.10",
-        "pify": "3.0.0",
-        "slash": "1.0.0"
-      },
-      "dependencies": {
-        "pify": {
-          "version": "3.0.0",
-          "resolved": "https://registry.npmjs.org/pify/-/pify-3.0.0.tgz",
-          "integrity": "sha1-5aSs0sEB/fPZpNB/DbxNtJ3SgXY="
-        }
-      }
-    },
-    "google-auth-library": {
-      "version": "1.6.1",
-      "resolved": "https://registry.npmjs.org/google-auth-library/-/google-auth-library-1.6.1.tgz",
-      "integrity": "sha512-jYiWC8NA9n9OtQM7ANn0Tk464do9yhKEtaJ72pKcaBiEwn4LwcGYIYOfwtfsSm3aur/ed3tlSxbmg24IAT6gAg==",
-      "requires": {
-        "axios": "0.18.0",
-        "gcp-metadata": "0.6.3",
-        "gtoken": "2.3.2",
-        "jws": "3.2.1",
-        "lodash.isstring": "4.0.1",
-        "lru-cache": "4.1.5",
-        "retry-axios": "0.3.2"
-      }
-    },
-    "google-auto-auth": {
-      "version": "0.10.1",
-      "resolved": "https://registry.npmjs.org/google-auto-auth/-/google-auto-auth-0.10.1.tgz",
-      "integrity": "sha512-iIqSbY7Ypd32mnHGbYctp80vZzXoDlvI9gEfvtl3kmyy5HzOcrZCIGCBdSlIzRsg7nHpQiHE3Zl6Ycur6TSodQ==",
-      "requires": {
-        "async": "2.6.2",
-        "gcp-metadata": "0.6.3",
-        "google-auth-library": "1.6.1",
-        "request": "2.88.0"
-      }
-    },
-    "google-gax": {
-      "version": "0.16.1",
-      "resolved": "https://registry.npmjs.org/google-gax/-/google-gax-0.16.1.tgz",
-      "integrity": "sha512-eP7UUkKvaHmmvCrr+rxzkIOeEKOnXmoib7/AkENDAuqlC9T2+lWlzwpthDRnitQcV8SblDMzsk73YPMPCDwPyQ==",
-      "requires": {
-        "duplexify": "3.7.1",
-        "extend": "3.0.2",
-        "globby": "8.0.2",
-        "google-auto-auth": "0.10.1",
-        "google-proto-files": "0.15.1",
-        "grpc": "1.18.0",
-        "is-stream-ended": "0.1.4",
-        "lodash": "4.17.11",
-        "protobufjs": "6.8.8",
-        "through2": "2.0.5"
-      },
-      "dependencies": {
-        "@types/node": {
-          "version": "10.12.26",
-          "resolved": "https://registry.npmjs.org/@types/node/-/node-10.12.26.tgz",
-          "integrity": "sha512-nMRqS+mL1TOnIJrL6LKJcNZPB8V3eTfRo9FQA2b5gDvrHurC8XbSA86KNe0dShlEL7ReWJv/OU9NL7Z0dnqWTg=="
-        },
-        "long": {
-          "version": "4.0.0",
-          "resolved": "https://registry.npmjs.org/long/-/long-4.0.0.tgz",
-          "integrity": "sha512-XsP+KhQif4bjX1kbuSiySJFNAehNxgLb6hPRGJ9QsUr8ajHkuXGdrHmFUTUUXhDwVX2R5bY4JNZEwbUiMhV+MA=="
-        },
-        "protobufjs": {
-          "version": "6.8.8",
-          "resolved": "https://registry.npmjs.org/protobufjs/-/protobufjs-6.8.8.tgz",
-          "integrity": "sha512-AAmHtD5pXgZfi7GMpllpO3q1Xw1OYldr+dMUlAnffGTAhqkg72WdmSY71uKBF/JuyiKs8psYbtKrhi0ASCD8qw==",
-          "requires": {
-            "@protobufjs/aspromise": "1.1.2",
-            "@protobufjs/base64": "1.1.2",
-            "@protobufjs/codegen": "2.0.4",
-            "@protobufjs/eventemitter": "1.1.0",
-            "@protobufjs/fetch": "1.1.0",
-            "@protobufjs/float": "1.0.2",
-            "@protobufjs/inquire": "1.1.0",
-            "@protobufjs/path": "1.1.2",
-            "@protobufjs/pool": "1.1.0",
-            "@protobufjs/utf8": "1.1.0",
-            "@types/long": "4.0.0",
-            "@types/node": "10.12.26",
-            "long": "4.0.0"
-          }
-        }
-      }
-    },
-    "google-p12-pem": {
-      "version": "1.0.3",
-      "resolved": "https://registry.npmjs.org/google-p12-pem/-/google-p12-pem-1.0.3.tgz",
-      "integrity": "sha512-KGnAiMMWaJp4j4tYVvAjfP3wCKZRLv9M1Nir2wRRNWUYO7j1aX8O9Qgz+a8/EQ5rAvuo4SIu79n6SIdkNl7Msg==",
-      "requires": {
-        "node-forge": "0.7.6",
-        "pify": "4.0.1"
-      },
-      "dependencies": {
-        "node-forge": {
-          "version": "0.7.6",
-          "resolved": "https://registry.npmjs.org/node-forge/-/node-forge-0.7.6.tgz",
-          "integrity": "sha512-sol30LUpz1jQFBjOKwbjxijiE3b6pjd74YwfD0fJOKPjF+fONKb2Yg8rYgS6+bK6VDl+/wfr4IYpC7jDzLUIfw=="
-        }
-      }
-    },
-    "google-proto-files": {
-      "version": "0.15.1",
-      "resolved": "https://registry.npmjs.org/google-proto-files/-/google-proto-files-0.15.1.tgz",
-      "integrity": "sha512-ebtmWgi/ooR5Nl63qRVZZ6VLM6JOb5zTNxTT/ZAU8yfMOdcauoOZNNMOVg0pCmTjqWXeuuVbgPP0CwO5UHHzBQ==",
-      "requires": {
-        "globby": "7.1.1",
-        "power-assert": "1.6.1",
-        "protobufjs": "6.8.8"
-      },
-      "dependencies": {
-        "@types/node": {
-          "version": "10.12.26",
-          "resolved": "https://registry.npmjs.org/@types/node/-/node-10.12.26.tgz",
-          "integrity": "sha512-nMRqS+mL1TOnIJrL6LKJcNZPB8V3eTfRo9FQA2b5gDvrHurC8XbSA86KNe0dShlEL7ReWJv/OU9NL7Z0dnqWTg=="
-        },
-        "globby": {
-          "version": "7.1.1",
-          "resolved": "https://registry.npmjs.org/globby/-/globby-7.1.1.tgz",
-          "integrity": "sha1-+yzP+UAfhgCUXfral0QMypcrhoA=",
-          "requires": {
-            "array-union": "1.0.2",
-            "dir-glob": "2.0.0",
-            "glob": "7.1.3",
-            "ignore": "3.3.10",
-            "pify": "3.0.0",
-            "slash": "1.0.0"
-          }
-        },
-        "long": {
-          "version": "4.0.0",
-          "resolved": "https://registry.npmjs.org/long/-/long-4.0.0.tgz",
-          "integrity": "sha512-XsP+KhQif4bjX1kbuSiySJFNAehNxgLb6hPRGJ9QsUr8ajHkuXGdrHmFUTUUXhDwVX2R5bY4JNZEwbUiMhV+MA=="
-        },
-        "pify": {
-          "version": "3.0.0",
-          "resolved": "https://registry.npmjs.org/pify/-/pify-3.0.0.tgz",
-          "integrity": "sha1-5aSs0sEB/fPZpNB/DbxNtJ3SgXY="
-        },
-        "protobufjs": {
-          "version": "6.8.8",
-          "resolved": "https://registry.npmjs.org/protobufjs/-/protobufjs-6.8.8.tgz",
-          "integrity": "sha512-AAmHtD5pXgZfi7GMpllpO3q1Xw1OYldr+dMUlAnffGTAhqkg72WdmSY71uKBF/JuyiKs8psYbtKrhi0ASCD8qw==",
-          "requires": {
-            "@protobufjs/aspromise": "1.1.2",
-            "@protobufjs/base64": "1.1.2",
-            "@protobufjs/codegen": "2.0.4",
-            "@protobufjs/eventemitter": "1.1.0",
-            "@protobufjs/fetch": "1.1.0",
-            "@protobufjs/float": "1.0.2",
-            "@protobufjs/inquire": "1.1.0",
-            "@protobufjs/path": "1.1.2",
-            "@protobufjs/pool": "1.1.0",
-            "@protobufjs/utf8": "1.1.0",
-            "@types/long": "4.0.0",
-            "@types/node": "10.12.26",
-            "long": "4.0.0"
-          }
-        }
-      }
-    },
-    "graceful-fs": {
-      "version": "4.1.15",
-      "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.1.15.tgz",
-      "integrity": "sha512-6uHUhOPEBgQ24HM+r6b/QwWfZq+yiFcipKFrOFiBEnWdy5sdzYoi+pJeQaPI5qOLRFqWmAXUPQNsielzdLoecA=="
-    },
-    "grpc": {
-      "version": "1.18.0",
-      "resolved": "https://registry.npmjs.org/grpc/-/grpc-1.18.0.tgz",
-      "integrity": "sha512-M0K67Zhv2ZzCjrTbQvjWgYFPB929L+qAVnbNgXepbfO5kJxUYc30dP8m8vb+o8QdahLHAeYfIqRoIzZRcCB98Q==",
-      "requires": {
-        "lodash.camelcase": "4.3.0",
-        "lodash.clone": "4.5.0",
-        "nan": "2.12.1",
-        "node-pre-gyp": "0.12.0",
-        "protobufjs": "5.0.3"
-      },
-      "dependencies": {
-        "abbrev": {
-          "version": "1.1.1",
-          "bundled": true
-        },
-        "ansi-regex": {
-          "version": "2.1.1",
-          "bundled": true
-        },
-        "aproba": {
-          "version": "1.2.0",
-          "bundled": true
-        },
-        "are-we-there-yet": {
-          "version": "1.1.5",
-          "bundled": true,
-          "requires": {
-            "delegates": "1.0.0",
-            "readable-stream": "2.3.6"
-          }
-        },
-        "balanced-match": {
-          "version": "1.0.0",
-          "bundled": true
-        },
-        "brace-expansion": {
-          "version": "1.1.11",
-          "bundled": true,
-          "requires": {
-            "balanced-match": "1.0.0",
-            "concat-map": "0.0.1"
-          }
-        },
-        "chownr": {
-          "version": "1.1.1",
-          "bundled": true
-        },
-        "code-point-at": {
-          "version": "1.1.0",
-          "bundled": true
-        },
-        "concat-map": {
-          "version": "0.0.1",
-          "bundled": true
-        },
-        "console-control-strings": {
-          "version": "1.1.0",
-          "bundled": true
-        },
-        "core-util-is": {
-          "version": "1.0.2",
-          "bundled": true
-        },
-        "debug": {
-          "version": "2.6.9",
-          "bundled": true,
-          "requires": {
-            "ms": "2.0.0"
-          }
-        },
-        "deep-extend": {
-          "version": "0.6.0",
-          "bundled": true
-        },
-        "delegates": {
-          "version": "1.0.0",
-          "bundled": true
-        },
-        "detect-libc": {
-          "version": "1.0.3",
-          "bundled": true
-        },
-        "fs-minipass": {
-          "version": "1.2.5",
-          "bundled": true,
-          "requires": {
-            "minipass": "2.3.5"
-          }
-        },
-        "fs.realpath": {
-          "version": "1.0.0",
-          "bundled": true
-        },
-        "gauge": {
-          "version": "2.7.4",
-          "bundled": true,
-          "requires": {
-            "aproba": "1.2.0",
-            "console-control-strings": "1.1.0",
-            "has-unicode": "2.0.1",
-            "object-assign": "4.1.1",
-            "signal-exit": "3.0.2",
-            "string-width": "1.0.2",
-            "strip-ansi": "3.0.1",
-            "wide-align": "1.1.3"
-          }
-        },
-        "glob": {
-          "version": "7.1.2",
-          "bundled": true,
-          "requires": {
-            "fs.realpath": "1.0.0",
-            "inflight": "1.0.6",
-            "inherits": "2.0.3",
-            "minimatch": "3.0.4",
-            "once": "1.4.0",
-            "path-is-absolute": "1.0.1"
-          }
-        },
-        "has-unicode": {
-          "version": "2.0.1",
-          "bundled": true
-        },
-        "iconv-lite": {
-          "version": "0.4.23",
-          "bundled": true,
-          "requires": {
-            "safer-buffer": "2.1.2"
-          }
-        },
-        "ignore-walk": {
-          "version": "3.0.1",
-          "bundled": true,
-          "requires": {
-            "minimatch": "3.0.4"
-          }
-        },
-        "inflight": {
-          "version": "1.0.6",
-          "bundled": true,
-          "requires": {
-            "once": "1.4.0",
-            "wrappy": "1.0.2"
-          }
-        },
-        "inherits": {
-          "version": "2.0.3",
-          "bundled": true
-        },
-        "ini": {
-          "version": "1.3.5",
-          "bundled": true
-        },
-        "is-fullwidth-code-point": {
-          "version": "1.0.0",
-          "bundled": true,
-          "requires": {
-            "number-is-nan": "1.0.1"
-          }
-        },
-        "isarray": {
-          "version": "1.0.0",
-          "bundled": true
-        },
-        "minimatch": {
-          "version": "3.0.4",
-          "bundled": true,
-          "requires": {
-            "brace-expansion": "1.1.11"
-          }
-        },
-        "minimist": {
-          "version": "1.2.0",
-          "bundled": true
-        },
-        "minipass": {
-          "version": "2.3.5",
-          "bundled": true,
-          "requires": {
-            "safe-buffer": "5.1.2",
-            "yallist": "3.0.3"
-          }
-        },
-        "minizlib": {
-          "version": "1.1.1",
-          "bundled": true,
-          "requires": {
-            "minipass": "2.3.5"
-          }
-        },
-        "mkdirp": {
-          "version": "0.5.1",
-          "bundled": true,
-          "requires": {
-            "minimist": "0.0.8"
-          },
-          "dependencies": {
-            "minimist": {
-              "version": "0.0.8",
-              "bundled": true
-            }
-          }
-        },
-        "ms": {
-          "version": "2.0.0",
-          "bundled": true
-        },
-        "needle": {
-          "version": "2.2.4",
-          "bundled": true,
-          "requires": {
-            "debug": "2.6.9",
-            "iconv-lite": "0.4.23",
-            "sax": "1.2.4"
-          }
-        },
-        "node-pre-gyp": {
-          "version": "0.12.0",
-          "bundled": true,
-          "requires": {
-            "detect-libc": "1.0.3",
-            "mkdirp": "0.5.1",
-            "needle": "2.2.4",
-            "nopt": "4.0.1",
-            "npm-packlist": "1.1.12",
-            "npmlog": "4.1.2",
-            "rc": "1.2.8",
-            "rimraf": "2.6.2",
-            "semver": "5.6.0",
-            "tar": "4.4.8"
-          }
-        },
-        "nopt": {
-          "version": "4.0.1",
-          "bundled": true,
-          "requires": {
-            "abbrev": "1.1.1",
-            "osenv": "0.1.5"
-          }
-        },
-        "npm-bundled": {
-          "version": "1.0.5",
-          "bundled": true
-        },
-        "npm-packlist": {
-          "version": "1.1.12",
-          "bundled": true,
-          "requires": {
-            "ignore-walk": "3.0.1",
-            "npm-bundled": "1.0.5"
-          }
-        },
-        "npmlog": {
-          "version": "4.1.2",
-          "bundled": true,
-          "requires": {
-            "are-we-there-yet": "1.1.5",
-            "console-control-strings": "1.1.0",
-            "gauge": "2.7.4",
-            "set-blocking": "2.0.0"
-          }
-        },
-        "number-is-nan": {
-          "version": "1.0.1",
-          "bundled": true
-        },
-        "object-assign": {
-          "version": "4.1.1",
-          "bundled": true
-        },
-        "once": {
-          "version": "1.4.0",
-          "bundled": true,
-          "requires": {
-            "wrappy": "1.0.2"
-          }
-        },
-        "os-homedir": {
-          "version": "1.0.2",
-          "bundled": true
-        },
-        "os-tmpdir": {
-          "version": "1.0.2",
-          "bundled": true
-        },
-        "osenv": {
-          "version": "0.1.5",
-          "bundled": true,
-          "requires": {
-            "os-homedir": "1.0.2",
-            "os-tmpdir": "1.0.2"
-          }
-        },
-        "path-is-absolute": {
-          "version": "1.0.1",
-          "bundled": true
-        },
-        "process-nextick-args": {
-          "version": "2.0.0",
-          "bundled": true
-        },
-        "rc": {
-          "version": "1.2.8",
-          "bundled": true,
-          "requires": {
-            "deep-extend": "0.6.0",
-            "ini": "1.3.5",
-            "minimist": "1.2.0",
-            "strip-json-comments": "2.0.1"
-          }
-        },
-        "readable-stream": {
-          "version": "2.3.6",
-          "bundled": true,
-          "requires": {
-            "core-util-is": "1.0.2",
-            "inherits": "2.0.3",
-            "isarray": "1.0.0",
-            "process-nextick-args": "2.0.0",
-            "safe-buffer": "5.1.2",
-            "string_decoder": "1.1.1",
-            "util-deprecate": "1.0.2"
-          }
-        },
-        "rimraf": {
-          "version": "2.6.2",
-          "bundled": true,
-          "requires": {
-            "glob": "7.1.2"
-          }
-        },
-        "safe-buffer": {
-          "version": "5.1.2",
-          "bundled": true
-        },
-        "safer-buffer": {
-          "version": "2.1.2",
-          "bundled": true
-        },
-        "sax": {
-          "version": "1.2.4",
-          "bundled": true
-        },
-        "semver": {
-          "version": "5.6.0",
-          "bundled": true
-        },
-        "set-blocking": {
-          "version": "2.0.0",
-          "bundled": true
-        },
-        "signal-exit": {
-          "version": "3.0.2",
-          "bundled": true
-        },
-        "string_decoder": {
-          "version": "1.1.1",
-          "bundled": true,
-          "requires": {
-            "safe-buffer": "5.1.2"
-          }
-        },
-        "string-width": {
-          "version": "1.0.2",
-          "bundled": true,
-          "requires": {
-            "code-point-at": "1.1.0",
-            "is-fullwidth-code-point": "1.0.0",
-            "strip-ansi": "3.0.1"
-          }
-        },
-        "strip-ansi": {
-          "version": "3.0.1",
-          "bundled": true,
-          "requires": {
-            "ansi-regex": "2.1.1"
-          }
-        },
-        "strip-json-comments": {
-          "version": "2.0.1",
-          "bundled": true
-        },
-        "tar": {
-          "version": "4.4.8",
-          "bundled": true,
-          "requires": {
-            "chownr": "1.1.1",
-            "fs-minipass": "1.2.5",
-            "minipass": "2.3.5",
-            "minizlib": "1.1.1",
-            "mkdirp": "0.5.1",
-            "safe-buffer": "5.1.2",
-            "yallist": "3.0.3"
-          }
-        },
-        "util-deprecate": {
-          "version": "1.0.2",
-          "bundled": true
-        },
-        "wide-align": {
-          "version": "1.1.3",
-          "bundled": true,
-          "requires": {
-            "string-width": "1.0.2"
-          }
-        },
-        "wrappy": {
-          "version": "1.0.2",
-          "bundled": true
-        },
-        "yallist": {
-          "version": "3.0.3",
-          "bundled": true
-        }
-      }
-    },
-    "gtoken": {
-      "version": "2.3.2",
-      "resolved": "https://registry.npmjs.org/gtoken/-/gtoken-2.3.2.tgz",
-      "integrity": "sha512-F8EObUGyC8Qd3WXTloNULZBwfUsOABoHElihB1F6zGhT/cy38iPL09wGLRY712I+hQnOyA+sYlgPFX2cOKz0qg==",
-      "requires": {
-        "gaxios": "1.7.0",
-        "google-p12-pem": "1.0.3",
-        "jws": "3.2.1",
-        "mime": "2.4.0",
-        "pify": "4.0.1"
-      }
-    },
-    "har-schema": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/har-schema/-/har-schema-2.0.0.tgz",
-      "integrity": "sha1-qUwiJOvKwEeCoNkDVSHyRzW37JI="
-    },
-    "har-validator": {
-      "version": "5.1.3",
-      "resolved": "https://registry.npmjs.org/har-validator/-/har-validator-5.1.3.tgz",
-      "integrity": "sha512-sNvOCzEQNr/qrvJgc3UG/kD4QtlHycrzwS+6mfTrrSq97BvaYcPZZI1ZSqGSPR73Cxn4LKTD4PttRwfU7jWq5g==",
-      "requires": {
-        "ajv": "6.9.1",
-        "har-schema": "2.0.0"
-      }
-    },
-    "has-value": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/has-value/-/has-value-1.0.0.tgz",
-      "integrity": "sha1-GLKB2lhbHFxR3vJMkw7SmgvmsXc=",
-      "requires": {
-        "get-value": "2.0.6",
-        "has-values": "1.0.0",
-        "isobject": "3.0.1"
-      }
-    },
-    "has-values": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/has-values/-/has-values-1.0.0.tgz",
-      "integrity": "sha1-lbC2P+whRmGab+V/51Yo1aOe/k8=",
-      "requires": {
-        "is-number": "3.0.0",
-        "kind-of": "4.0.0"
-      },
-      "dependencies": {
-        "kind-of": {
-          "version": "4.0.0",
-          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-4.0.0.tgz",
-          "integrity": "sha1-IIE989cSkosgc3hpGkUGb65y3Vc=",
-          "requires": {
-            "is-buffer": "1.1.6"
-          }
-        }
-      }
-    },
-    "hash-stream-validation": {
-      "version": "0.2.1",
-      "resolved": "https://registry.npmjs.org/hash-stream-validation/-/hash-stream-validation-0.2.1.tgz",
-      "integrity": "sha1-7Mm5l7IYvluzEphii7gHhptz3NE=",
-      "requires": {
-        "through2": "2.0.5"
-      }
-    },
-    "http-errors": {
-      "version": "1.6.3",
-      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.6.3.tgz",
-      "integrity": "sha1-i1VoC7S+KDoLW/TqLjhYC+HZMg0=",
-      "requires": {
-        "depd": "1.1.2",
-        "inherits": "2.0.3",
-        "setprototypeof": "1.1.0",
-        "statuses": "1.4.0"
-      }
-    },
-    "http-parser-js": {
-      "version": "0.5.0",
-      "resolved": "https://registry.npmjs.org/http-parser-js/-/http-parser-js-0.5.0.tgz",
-      "integrity": "sha512-cZdEF7r4gfRIq7ezX9J0T+kQmJNOub71dWbgAXVHDct80TKP4MCETtZQ31xyv38UwgzkWPYF/Xc0ge55dW9Z9w=="
-    },
-    "http-signature": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/http-signature/-/http-signature-1.2.0.tgz",
-      "integrity": "sha1-muzZJRFHcvPZW2WmCruPfBj7rOE=",
-      "requires": {
-        "assert-plus": "1.0.0",
-        "jsprim": "1.4.1",
-        "sshpk": "1.16.1"
-      }
-    },
-    "https-proxy-agent": {
-      "version": "2.2.1",
-      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-2.2.1.tgz",
-      "integrity": "sha512-HPCTS1LW51bcyMYbxUIOO4HEOlQ1/1qRaFWcyxvwaqUS9TY88aoEuHUY33kuAh1YhVVaDQhLZsnPd+XNARWZlQ==",
-      "requires": {
-        "agent-base": "4.2.1",
-        "debug": "3.2.6"
-      }
-    },
-    "iconv-lite": {
-      "version": "0.4.23",
-      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.23.tgz",
-      "integrity": "sha512-neyTUVFtahjf0mB3dZT77u+8O0QB89jFdnBkd5P1JgYPbPaia3gXXOVL2fq8VyU2gMMD7SaN7QukTB/pmXYvDA==",
-      "requires": {
-        "safer-buffer": "2.1.2"
-      }
-    },
-    "ignore": {
-      "version": "3.3.10",
-      "resolved": "https://registry.npmjs.org/ignore/-/ignore-3.3.10.tgz",
-      "integrity": "sha512-Pgs951kaMm5GXP7MOvxERINe3gsaVjUWFm+UZPSq9xYriQAksyhg0csnS0KXSNRD5NmNdapXEpjxG49+AKh/ug=="
-    },
-    "imurmurhash": {
-      "version": "0.1.4",
-      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
-      "integrity": "sha1-khi5srkoojixPcT7a21XbyMUU+o="
-    },
-    "indexof": {
-      "version": "0.0.1",
-      "resolved": "https://registry.npmjs.org/indexof/-/indexof-0.0.1.tgz",
-      "integrity": "sha1-gtwzbSMrkGIXnQWrMpOmYFn9Q10="
-    },
-    "inflight": {
-      "version": "1.0.6",
-      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
-      "integrity": "sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=",
-      "requires": {
-        "once": "1.4.0",
-        "wrappy": "1.0.2"
-      }
-    },
-    "inherits": {
-      "version": "2.0.3",
-      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz",
-      "integrity": "sha1-Yzwsg+PaQqUC9SRmAiSA9CCCYd4="
-    },
-    "invert-kv": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/invert-kv/-/invert-kv-1.0.0.tgz",
-      "integrity": "sha1-EEqOSqym09jNFXqO+L+rLXo//bY="
-    },
-    "ipaddr.js": {
-      "version": "1.8.0",
-      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.8.0.tgz",
-      "integrity": "sha1-6qM9bd16zo9/b+DJygRA5wZzix4="
-    },
-    "is": {
-      "version": "3.3.0",
-      "resolved": "https://registry.npmjs.org/is/-/is-3.3.0.tgz",
-      "integrity": "sha512-nW24QBoPcFGGHJGUwnfpI7Yc5CdqWNdsyHQszVE/z2pKHXzh7FZ5GWhJqSyaQ9wMkQnsTx+kAI8bHlCX4tKdbg=="
-    },
-    "is-accessor-descriptor": {
-      "version": "0.1.6",
-      "resolved": "https://registry.npmjs.org/is-accessor-descriptor/-/is-accessor-descriptor-0.1.6.tgz",
-      "integrity": "sha1-qeEss66Nh2cn7u84Q/igiXtcmNY=",
-      "requires": {
-        "kind-of": "3.2.2"
-      },
-      "dependencies": {
-        "kind-of": {
-          "version": "3.2.2",
-          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz",
-          "integrity": "sha1-MeohpzS6ubuw8yRm2JOupR5KPGQ=",
-          "requires": {
-            "is-buffer": "1.1.6"
-          }
-        }
-      }
-    },
-    "is-buffer": {
-      "version": "1.1.6",
-      "resolved": "https://registry.npmjs.org/is-buffer/-/is-buffer-1.1.6.tgz",
-      "integrity": "sha512-NcdALwpXkTm5Zvvbk7owOUSvVvBKDgKP5/ewfXEznmQFfs4ZRmanOeKBTjRVjka3QFoN6XJ+9F3USqfHqTaU5w=="
-    },
-    "is-data-descriptor": {
-      "version": "0.1.4",
-      "resolved": "https://registry.npmjs.org/is-data-descriptor/-/is-data-descriptor-0.1.4.tgz",
-      "integrity": "sha1-C17mSDiOLIYCgueT8YVv7D8wG1Y=",
-      "requires": {
-        "kind-of": "3.2.2"
-      },
-      "dependencies": {
-        "kind-of": {
-          "version": "3.2.2",
-          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz",
-          "integrity": "sha1-MeohpzS6ubuw8yRm2JOupR5KPGQ=",
-          "requires": {
-            "is-buffer": "1.1.6"
-          }
-        }
-      }
-    },
-    "is-descriptor": {
-      "version": "0.1.6",
-      "resolved": "https://registry.npmjs.org/is-descriptor/-/is-descriptor-0.1.6.tgz",
-      "integrity": "sha512-avDYr0SB3DwO9zsMov0gKCESFYqCnE4hq/4z3TdUlukEy5t9C0YRq7HLrsN52NAcqXKaepeCD0n+B0arnVG3Hg==",
-      "requires": {
-        "is-accessor-descriptor": "0.1.6",
-        "is-data-descriptor": "0.1.4",
-        "kind-of": "5.1.0"
-      },
-      "dependencies": {
-        "kind-of": {
-          "version": "5.1.0",
-          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-5.1.0.tgz",
-          "integrity": "sha512-NGEErnH6F2vUuXDh+OlbcKW7/wOcfdRHaZ7VWtqCztfHri/++YKmP51OdWeGPuqCOba6kk2OTe5d02VmTB80Pw=="
-        }
-      }
-    },
-    "is-extendable": {
-      "version": "0.1.1",
-      "resolved": "https://registry.npmjs.org/is-extendable/-/is-extendable-0.1.1.tgz",
-      "integrity": "sha1-YrEQ4omkcUGOPsNqYX1HLjAd/Ik="
-    },
-    "is-extglob": {
-      "version": "2.1.1",
-      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
-      "integrity": "sha1-qIwCU1eR8C7TfHahueqXc8gz+MI="
-    },
-    "is-fullwidth-code-point": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-1.0.0.tgz",
-      "integrity": "sha1-754xOG8DGn8NZDr4L95QxFfvAMs=",
-      "requires": {
-        "number-is-nan": "1.0.1"
-      }
-    },
-    "is-glob": {
-      "version": "4.0.0",
-      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.0.tgz",
-      "integrity": "sha1-lSHHaEXMJhCoUgPd8ICpWML/q8A=",
-      "requires": {
-        "is-extglob": "2.1.1"
-      }
-    },
-    "is-number": {
-      "version": "3.0.0",
-      "resolved": "https://registry.npmjs.org/is-number/-/is-number-3.0.0.tgz",
-      "integrity": "sha1-JP1iAaR4LPUFYcgQJ2r8fRLXEZU=",
-      "requires": {
-        "kind-of": "3.2.2"
-      },
-      "dependencies": {
-        "kind-of": {
-          "version": "3.2.2",
-          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz",
-          "integrity": "sha1-MeohpzS6ubuw8yRm2JOupR5KPGQ=",
-          "requires": {
-            "is-buffer": "1.1.6"
-          }
-        }
-      }
-    },
-    "is-obj": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/is-obj/-/is-obj-1.0.1.tgz",
-      "integrity": "sha1-PkcprB9f3gJc19g6iW2rn09n2w8="
-    },
-    "is-plain-object": {
-      "version": "2.0.4",
-      "resolved": "https://registry.npmjs.org/is-plain-object/-/is-plain-object-2.0.4.tgz",
-      "integrity": "sha512-h5PpgXkWitc38BBMYawTYMWJHFZJVnBquFE57xFpjB8pJFiF6gZ+bU+WyI/yqXiFR5mdLsgYNaPe8uao6Uv9Og==",
-      "requires": {
-        "isobject": "3.0.1"
-      }
-    },
-    "is-stream-ended": {
-      "version": "0.1.4",
-      "resolved": "https://registry.npmjs.org/is-stream-ended/-/is-stream-ended-0.1.4.tgz",
-      "integrity": "sha512-xj0XPvmr7bQFTvirqnFr50o0hQIh6ZItDqloxt5aJrR4NQsYeSsyFQERYGCAzfindAcnKjINnwEEgLx4IqVzQw=="
-    },
-    "is-typedarray": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/is-typedarray/-/is-typedarray-1.0.0.tgz",
-      "integrity": "sha1-5HnICFjfDBsR3dppQPlgEfzaSpo="
-    },
-    "is-windows": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/is-windows/-/is-windows-1.0.2.tgz",
-      "integrity": "sha512-eXK1UInq2bPmjyX6e3VHIzMLobc4J94i4AWn+Hpq3OU5KkrRC96OAcR3PRJ/pGu6m8TRnBHP9dkXQVsT/COVIA=="
-    },
-    "isarray": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/isarray/-/isarray-1.0.0.tgz",
-      "integrity": "sha1-u5NdSFgsuhaMBoNJV6VKPgcSTxE="
-    },
-    "isobject": {
-      "version": "3.0.1",
-      "resolved": "https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz",
-      "integrity": "sha1-TkMekrEalzFjaqH5yNHMvP2reN8="
-    },
-    "isstream": {
-      "version": "0.1.2",
-      "resolved": "https://registry.npmjs.org/isstream/-/isstream-0.1.2.tgz",
-      "integrity": "sha1-R+Y/evVa+m+S4VAOaQ64uFKcCZo="
-    },
-    "jsbn": {
-      "version": "0.1.1",
-      "resolved": "https://registry.npmjs.org/jsbn/-/jsbn-0.1.1.tgz",
-      "integrity": "sha1-peZUwuWi3rXyAdls77yoDA7y9RM="
-    },
-    "json-schema": {
-      "version": "0.2.3",
-      "resolved": "https://registry.npmjs.org/json-schema/-/json-schema-0.2.3.tgz",
-      "integrity": "sha1-tIDIkuWaLwWVTOcnvT8qTogvnhM="
-    },
-    "json-schema-traverse": {
-      "version": "0.4.1",
-      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
-      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg=="
-    },
-    "json-stringify-safe": {
-      "version": "5.0.1",
-      "resolved": "https://registry.npmjs.org/json-stringify-safe/-/json-stringify-safe-5.0.1.tgz",
-      "integrity": "sha1-Epai1Y/UXxmg9s4B1lcB4sc1tus="
-    },
-    "jsonwebtoken": {
-      "version": "8.1.0",
-      "resolved": "https://registry.npmjs.org/jsonwebtoken/-/jsonwebtoken-8.1.0.tgz",
-      "integrity": "sha1-xjl80uX9WD1lwAeoPce7eOaYK4M=",
-      "requires": {
-        "jws": "3.2.1",
-        "lodash.includes": "4.3.0",
-        "lodash.isboolean": "3.0.3",
-        "lodash.isinteger": "4.0.4",
-        "lodash.isnumber": "3.0.3",
-        "lodash.isplainobject": "4.0.6",
-        "lodash.isstring": "4.0.1",
-        "lodash.once": "4.1.1",
-        "ms": "2.1.1",
-        "xtend": "4.0.1"
-      }
-    },
-    "jsprim": {
-      "version": "1.4.1",
-      "resolved": "https://registry.npmjs.org/jsprim/-/jsprim-1.4.1.tgz",
-      "integrity": "sha1-MT5mvB5cwG5Di8G3SZwuXFastqI=",
-      "requires": {
-        "assert-plus": "1.0.0",
-        "extsprintf": "1.3.0",
-        "json-schema": "0.2.3",
-        "verror": "1.10.0"
-      }
-    },
-    "jwa": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/jwa/-/jwa-1.2.0.tgz",
-      "integrity": "sha512-Grku9ZST5NNQ3hqNUodSkDfEBqAmGA1R8yiyPHOnLzEKI0GaCQC/XhFmsheXYuXzFQJdILbh+lYBiliqG5R/Vg==",
-      "requires": {
-        "buffer-equal-constant-time": "1.0.1",
-        "ecdsa-sig-formatter": "1.0.10",
-        "safe-buffer": "5.1.2"
-      }
-    },
-    "jws": {
-      "version": "3.2.1",
-      "resolved": "https://registry.npmjs.org/jws/-/jws-3.2.1.tgz",
-      "integrity": "sha512-bGA2omSrFUkd72dhh05bIAN832znP4wOU3lfuXtRBuGTbsmNmDXMQg28f0Vsxaxgk4myF5YkKQpz6qeRpMgX9g==",
-      "requires": {
-        "jwa": "1.2.0",
-        "safe-buffer": "5.1.2"
-      }
-    },
-    "kind-of": {
-      "version": "6.0.2",
-      "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-6.0.2.tgz",
-      "integrity": "sha512-s5kLOcnH0XqDO+FvuaLX8DDjZ18CGFk7VygH40QoKPUQhW4e2rvM0rwUq0t8IQDOwYSeLK01U90OjzBTme2QqA=="
-    },
-    "lcid": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/lcid/-/lcid-1.0.0.tgz",
-      "integrity": "sha1-MIrMr6C8SDo4Z7S28rlQYlHRuDU=",
-      "requires": {
-        "invert-kv": "1.0.0"
-      }
-    },
-    "lodash": {
-      "version": "4.17.11",
-      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.11.tgz",
-      "integrity": "sha512-cQKh8igo5QUhZ7lg38DYWAxMvjSAKG0A8wGSVimP07SIUEK2UO+arSRKbRZWtelMtN5V0Hkwh5ryOto/SshYIg=="
-    },
-    "lodash.camelcase": {
-      "version": "4.3.0",
-      "resolved": "https://registry.npmjs.org/lodash.camelcase/-/lodash.camelcase-4.3.0.tgz",
-      "integrity": "sha1-soqmKIorn8ZRA1x3EfZathkDMaY="
-    },
-    "lodash.clone": {
-      "version": "4.5.0",
-      "resolved": "https://registry.npmjs.org/lodash.clone/-/lodash.clone-4.5.0.tgz",
-      "integrity": "sha1-GVhwRQ9aExkkeN9Lw9I9LeoZB7Y="
-    },
-    "lodash.includes": {
-      "version": "4.3.0",
-      "resolved": "https://registry.npmjs.org/lodash.includes/-/lodash.includes-4.3.0.tgz",
-      "integrity": "sha1-YLuYqHy5I8aMoeUTJUgzFISfVT8="
-    },
-    "lodash.isboolean": {
-      "version": "3.0.3",
-      "resolved": "https://registry.npmjs.org/lodash.isboolean/-/lodash.isboolean-3.0.3.tgz",
-      "integrity": "sha1-bC4XHbKiV82WgC/UOwGyDV9YcPY="
-    },
-    "lodash.isinteger": {
-      "version": "4.0.4",
-      "resolved": "https://registry.npmjs.org/lodash.isinteger/-/lodash.isinteger-4.0.4.tgz",
-      "integrity": "sha1-YZwK89A/iwTDH1iChAt3sRzWg0M="
-    },
-    "lodash.isnumber": {
-      "version": "3.0.3",
-      "resolved": "https://registry.npmjs.org/lodash.isnumber/-/lodash.isnumber-3.0.3.tgz",
-      "integrity": "sha1-POdoEMWSjQM1IwGsKHMX8RwLH/w="
-    },
-    "lodash.isplainobject": {
-      "version": "4.0.6",
-      "resolved": "https://registry.npmjs.org/lodash.isplainobject/-/lodash.isplainobject-4.0.6.tgz",
-      "integrity": "sha1-fFJqUtibRcRcxpC4gWO+BJf1UMs="
-    },
-    "lodash.isstring": {
-      "version": "4.0.1",
-      "resolved": "https://registry.npmjs.org/lodash.isstring/-/lodash.isstring-4.0.1.tgz",
-      "integrity": "sha1-1SfftUVuynzJu5XV2ur4i6VKVFE="
-    },
-    "lodash.once": {
-      "version": "4.1.1",
-      "resolved": "https://registry.npmjs.org/lodash.once/-/lodash.once-4.1.1.tgz",
-      "integrity": "sha1-DdOXEhPHxW34gJd9UEyI+0cal6w="
-    },
-    "log-driver": {
-      "version": "1.2.7",
-      "resolved": "https://registry.npmjs.org/log-driver/-/log-driver-1.2.7.tgz",
-      "integrity": "sha512-U7KCmLdqsGHBLeWqYlFA0V0Sl6P08EE1ZrmA9cxjUE0WVqT9qnyVDPz1kzpFEP0jdJuFnasWIfSd7fsaNXkpbg=="
-    },
-    "long": {
-      "version": "3.2.0",
-      "resolved": "https://registry.npmjs.org/long/-/long-3.2.0.tgz",
-      "integrity": "sha1-2CG3E4yhy1gcFymQ7xTbIAtcR0s="
-    },
-    "lru-cache": {
-      "version": "4.1.5",
-      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-4.1.5.tgz",
-      "integrity": "sha512-sWZlbEP2OsHNkXrMl5GYk/jKk70MBng6UU4YI/qGDYbgf6YbP4EvmqISbXCoJiRKs+1bSpFHVgQxvJ17F2li5g==",
-      "requires": {
-        "pseudomap": "1.0.2",
-        "yallist": "2.1.2"
-      }
-    },
-    "make-dir": {
-      "version": "1.3.0",
-      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-1.3.0.tgz",
-      "integrity": "sha512-2w31R7SJtieJJnQtGc7RVL2StM2vGYVfqUOvUDxH6bC6aJTxPxTF0GnIgCyu7tjockiUWAYQRbxa7vKn34s5sQ==",
-      "requires": {
-        "pify": "3.0.0"
-      },
-      "dependencies": {
-        "pify": {
-          "version": "3.0.0",
-          "resolved": "https://registry.npmjs.org/pify/-/pify-3.0.0.tgz",
-          "integrity": "sha1-5aSs0sEB/fPZpNB/DbxNtJ3SgXY="
-        }
-      }
-    },
-    "map-cache": {
-      "version": "0.2.2",
-      "resolved": "https://registry.npmjs.org/map-cache/-/map-cache-0.2.2.tgz",
-      "integrity": "sha1-wyq9C9ZSXZsFFkW7TyasXcmKDb8="
-    },
-    "map-visit": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/map-visit/-/map-visit-1.0.0.tgz",
-      "integrity": "sha1-7Nyo8TFE5mDxtb1B8S80edmN+48=",
-      "requires": {
-        "object-visit": "1.0.1"
-      }
-    },
-    "media-typer": {
-      "version": "0.3.0",
-      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
-      "integrity": "sha1-hxDXrwqmJvj/+hzgAWhUUmMlV0g="
-    },
-    "merge-descriptors": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.1.tgz",
-      "integrity": "sha1-sAqqVW3YtEVoFQ7J0blT8/kMu2E="
-    },
-    "merge2": {
-      "version": "1.2.3",
-      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.2.3.tgz",
-      "integrity": "sha512-gdUU1Fwj5ep4kplwcmftruWofEFt6lfpkkr3h860CXbAB9c3hGb55EOL2ali0Td5oebvW0E1+3Sr+Ur7XfKpRA=="
-    },
-    "methmeth": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/methmeth/-/methmeth-1.1.0.tgz",
-      "integrity": "sha1-6AomYY5S9cQiKGG7dIUQvRDikIk="
-    },
-    "methods": {
-      "version": "1.1.2",
-      "resolved": "https://registry.npmjs.org/methods/-/methods-1.1.2.tgz",
-      "integrity": "sha1-VSmk1nZUE07cxSZmVoNbD4Ua/O4="
-    },
-    "micromatch": {
-      "version": "3.1.10",
-      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-3.1.10.tgz",
-      "integrity": "sha512-MWikgl9n9M3w+bpsY3He8L+w9eF9338xRl8IAO5viDizwSzziFEyUzo2xrrloB64ADbTf8uA8vRqqttDTOmccg==",
-      "requires": {
-        "arr-diff": "4.0.0",
-        "array-unique": "0.3.2",
-        "braces": "2.3.2",
-        "define-property": "2.0.2",
-        "extend-shallow": "3.0.2",
-        "extglob": "2.0.4",
-        "fragment-cache": "0.2.1",
-        "kind-of": "6.0.2",
-        "nanomatch": "1.2.13",
-        "object.pick": "1.3.0",
-        "regex-not": "1.0.2",
-        "snapdragon": "0.8.2",
-        "to-regex": "3.0.2"
-      }
-    },
-    "mime": {
-      "version": "2.4.0",
-      "resolved": "https://registry.npmjs.org/mime/-/mime-2.4.0.tgz",
-      "integrity": "sha512-ikBcWwyqXQSHKtciCcctu9YfPbFYZ4+gbHEmE0Q8jzcTYQg5dHCr3g2wwAZjPoJfQVXZq6KXAjpXOTf5/cjT7w=="
-    },
-    "mime-db": {
-      "version": "1.38.0",
-      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.38.0.tgz",
-      "integrity": "sha512-bqVioMFFzc2awcdJZIzR3HjZFX20QhilVS7hytkKrv7xFAn8bM1gzc/FOX2awLISvWe0PV8ptFKcon+wZ5qYkg=="
-    },
-    "mime-types": {
-      "version": "2.1.22",
-      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.22.tgz",
-      "integrity": "sha512-aGl6TZGnhm/li6F7yx82bJiBZwgiEa4Hf6CNr8YO+r5UHr53tSTYZb102zyU50DOWWKeOv0uQLRL0/9EiKWCog==",
-      "requires": {
-        "mime-db": "1.38.0"
-      }
-    },
-    "minimatch": {
-      "version": "3.0.4",
-      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz",
-      "integrity": "sha512-yJHVQEhyqPLUTgt9B83PXu6W3rx4MvvHvSUvToogpwoGDOUQ+yDrR0HRot+yOCdCO7u4hX3pWft6kWBBcqh0UA==",
-      "requires": {
-        "brace-expansion": "1.1.11"
-      }
-    },
-    "mixin-deep": {
-      "version": "1.3.1",
-      "resolved": "https://registry.npmjs.org/mixin-deep/-/mixin-deep-1.3.1.tgz",
-      "integrity": "sha512-8ZItLHeEgaqEvd5lYBXfm4EZSFCX29Jb9K+lAHhDKzReKBQKj3R+7NOF6tjqYi9t4oI8VUfaWITJQm86wnXGNQ==",
-      "requires": {
-        "for-in": "1.0.2",
-        "is-extendable": "1.0.1"
-      },
-      "dependencies": {
-        "is-extendable": {
-          "version": "1.0.1",
-          "resolved": "https://registry.npmjs.org/is-extendable/-/is-extendable-1.0.1.tgz",
-          "integrity": "sha512-arnXMxT1hhoKo9k1LZdmlNyJdDDfy2v0fXjFlmok4+i8ul/6WlbVge9bhM74OpNPQPMGUToDtz+KXa1PneJxOA==",
-          "requires": {
-            "is-plain-object": "2.0.4"
-          }
-        }
-      }
-    },
-    "modelo": {
-      "version": "4.2.3",
-      "resolved": "https://registry.npmjs.org/modelo/-/modelo-4.2.3.tgz",
-      "integrity": "sha512-9DITV2YEMcw7XojdfvGl3gDD8J9QjZTJ7ZOUuSAkP+F3T6rDbzMJuPktxptsdHYEvZcmXrCD3LMOhdSAEq6zKA=="
-    },
-    "ms": {
-      "version": "2.1.1",
-      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.1.tgz",
-      "integrity": "sha512-tgp+dl5cGk28utYktBsrFqA7HKgrhgPsg6Z/EfhWI4gl1Hwq8B/GmY/0oXZ6nF8hDVesS/FpnYaD/kOWhYQvyg=="
-    },
-    "nan": {
-      "version": "2.12.1",
-      "resolved": "https://registry.npmjs.org/nan/-/nan-2.12.1.tgz",
-      "integrity": "sha512-JY7V6lRkStKcKTvHO5NVSQRv+RV+FIL5pvDoLiAtSL9pKlC5x9PKQcZDsq7m4FO4d57mkhC6Z+QhAh3Jdk5JFw=="
-    },
-    "nanomatch": {
-      "version": "1.2.13",
-      "resolved": "https://registry.npmjs.org/nanomatch/-/nanomatch-1.2.13.tgz",
-      "integrity": "sha512-fpoe2T0RbHwBTBUOftAfBPaDEi06ufaUai0mE6Yn1kacc3SnTErfb/h+X94VXzI64rKFHYImXSvdwGGCmwOqCA==",
-      "requires": {
-        "arr-diff": "4.0.0",
-        "array-unique": "0.3.2",
-        "define-property": "2.0.2",
-        "extend-shallow": "3.0.2",
-        "fragment-cache": "0.2.1",
-        "is-windows": "1.0.2",
-        "kind-of": "6.0.2",
-        "object.pick": "1.3.0",
-        "regex-not": "1.0.2",
-        "snapdragon": "0.8.2",
-        "to-regex": "3.0.2"
-      }
-    },
-    "negotiator": {
-      "version": "0.6.1",
-      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.1.tgz",
-      "integrity": "sha1-KzJxhOiZIQEXeyhWP7XnECrNDKk="
-    },
-    "node-fetch": {
-      "version": "2.3.0",
-      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.3.0.tgz",
-      "integrity": "sha512-MOd8pV3fxENbryESLgVIeaGKrdl+uaYhCSSVkjeOb/31/njTpcis5aWfdqgNlHIrKOLRbMnfPINPOML2CIFeXA=="
-    },
-    "node-forge": {
-      "version": "0.7.1",
-      "resolved": "https://registry.npmjs.org/node-forge/-/node-forge-0.7.1.tgz",
-      "integrity": "sha1-naYR6giYL0uUIGs760zJZl8gwwA="
-    },
-    "number-is-nan": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/number-is-nan/-/number-is-nan-1.0.1.tgz",
-      "integrity": "sha1-CXtgK1NCKlIsGvuHkDGDNpQaAR0="
-    },
-    "oauth-sign": {
-      "version": "0.9.0",
-      "resolved": "https://registry.npmjs.org/oauth-sign/-/oauth-sign-0.9.0.tgz",
-      "integrity": "sha512-fexhUFFPTGV8ybAtSIGbV6gOkSv8UtRbDBnAyLQw4QPKkgNlsH2ByPGtMUqdWkos6YCRmAqViwgZrJc/mRDzZQ=="
-    },
-    "object-assign": {
-      "version": "4.1.1",
-      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
-      "integrity": "sha1-IQmtx5ZYh8/AXLvUQsrIv7s2CGM="
-    },
-    "object-copy": {
-      "version": "0.1.0",
-      "resolved": "https://registry.npmjs.org/object-copy/-/object-copy-0.1.0.tgz",
-      "integrity": "sha1-fn2Fi3gb18mRpBupde04EnVOmYw=",
-      "requires": {
-        "copy-descriptor": "0.1.1",
-        "define-property": "0.2.5",
-        "kind-of": "3.2.2"
-      },
-      "dependencies": {
-        "define-property": {
-          "version": "0.2.5",
-          "resolved": "https://registry.npmjs.org/define-property/-/define-property-0.2.5.tgz",
-          "integrity": "sha1-w1se+RjsPJkPmlvFe+BKrOxcgRY=",
-          "requires": {
-            "is-descriptor": "0.1.6"
-          }
-        },
-        "kind-of": {
-          "version": "3.2.2",
-          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz",
-          "integrity": "sha1-MeohpzS6ubuw8yRm2JOupR5KPGQ=",
-          "requires": {
-            "is-buffer": "1.1.6"
-          }
-        }
-      }
-    },
-    "object-keys": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/object-keys/-/object-keys-1.1.0.tgz",
-      "integrity": "sha512-6OO5X1+2tYkNyNEx6TsCxEqFfRWaqx6EtMiSbGrw8Ob8v9Ne+Hl8rBAgLBZn5wjEz3s/s6U1WXFUFOcxxAwUpg=="
-    },
-    "object-visit": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/object-visit/-/object-visit-1.0.1.tgz",
-      "integrity": "sha1-95xEk68MU3e1n+OdOV5BBC3QRbs=",
-      "requires": {
-        "isobject": "3.0.1"
-      }
-    },
-    "object.pick": {
-      "version": "1.3.0",
-      "resolved": "https://registry.npmjs.org/object.pick/-/object.pick-1.3.0.tgz",
-      "integrity": "sha1-h6EKxMFpS9Lhy/U1kaZhQftd10c=",
-      "requires": {
-        "isobject": "3.0.1"
-      }
-    },
-    "on-finished": {
-      "version": "2.3.0",
-      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.3.0.tgz",
-      "integrity": "sha1-IPEzZIGwg811M3mSoWlxqi2QaUc=",
-      "requires": {
-        "ee-first": "1.1.1"
-      }
-    },
-    "once": {
-      "version": "1.4.0",
-      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
-      "integrity": "sha1-WDsap3WWHUsROsF9nFC6753Xa9E=",
-      "requires": {
-        "wrappy": "1.0.2"
-      }
-    },
-    "optjs": {
-      "version": "3.2.2",
-      "resolved": "https://registry.npmjs.org/optjs/-/optjs-3.2.2.tgz",
-      "integrity": "sha1-aabOicRCpEQDFBrS+bNwvVu29O4="
-    },
-    "os-locale": {
-      "version": "1.4.0",
-      "resolved": "https://registry.npmjs.org/os-locale/-/os-locale-1.4.0.tgz",
-      "integrity": "sha1-IPnxeuKe00XoveWDsT0gCYA8FNk=",
-      "requires": {
-        "lcid": "1.0.0"
-      }
-    },
-    "parseurl": {
-      "version": "1.3.2",
-      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.2.tgz",
-      "integrity": "sha1-/CidTtiZMRlGDBViUyYs3I3mW/M="
-    },
-    "pascalcase": {
-      "version": "0.1.1",
-      "resolved": "https://registry.npmjs.org/pascalcase/-/pascalcase-0.1.1.tgz",
-      "integrity": "sha1-s2PlXoAGym/iF4TS2yK9FdeRfxQ="
-    },
-    "path-dirname": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/path-dirname/-/path-dirname-1.0.2.tgz",
-      "integrity": "sha1-zDPSTVJeCZpTiMAzbG4yuRYGCeA="
-    },
-    "path-is-absolute": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
-      "integrity": "sha1-F0uSaHNVNP+8es5r9TpanhtcX18="
-    },
-    "path-to-regexp": {
-      "version": "0.1.7",
-      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.7.tgz",
-      "integrity": "sha1-32BBeABfUi8V60SQ5yR6G/qmf4w="
-    },
-    "path-type": {
-      "version": "3.0.0",
-      "resolved": "https://registry.npmjs.org/path-type/-/path-type-3.0.0.tgz",
-      "integrity": "sha512-T2ZUsdZFHgA3u4e5PfPbjd7HDDpxPnQb5jN0SrDsjNSuVXHJqtwTnWqG0B1jZrgmJ/7lj1EmVIByWt1gxGkWvg==",
-      "requires": {
-        "pify": "3.0.0"
-      },
-      "dependencies": {
-        "pify": {
-          "version": "3.0.0",
-          "resolved": "https://registry.npmjs.org/pify/-/pify-3.0.0.tgz",
-          "integrity": "sha1-5aSs0sEB/fPZpNB/DbxNtJ3SgXY="
-        }
-      }
-    },
-    "performance-now": {
-      "version": "2.1.0",
-      "resolved": "https://registry.npmjs.org/performance-now/-/performance-now-2.1.0.tgz",
-      "integrity": "sha1-Ywn04OX6kT7BxpMHrjZLSzd8nns="
-    },
-    "pify": {
-      "version": "4.0.1",
-      "resolved": "https://registry.npmjs.org/pify/-/pify-4.0.1.tgz",
-      "integrity": "sha512-uB80kBFb/tfd68bVleG9T5GGsGPjJrLAUpR5PZIrhBnIaRTQRjqdJSsIKkOP6OAIFbj7GOrcudc5pNjZ+geV2g=="
-    },
-    "posix-character-classes": {
-      "version": "0.1.1",
-      "resolved": "https://registry.npmjs.org/posix-character-classes/-/posix-character-classes-0.1.1.tgz",
-      "integrity": "sha1-AerA/jta9xoqbAL+q7jB/vfgDqs="
-    },
-    "power-assert": {
-      "version": "1.6.1",
-      "resolved": "https://registry.npmjs.org/power-assert/-/power-assert-1.6.1.tgz",
-      "integrity": "sha512-VWkkZV6Y+W8qLX/PtJu2Ur2jDPIs0a5vbP0TpKeybNcIXmT4vcKoVkyTp5lnQvTpY/DxacAZ4RZisHRHLJcAZQ==",
-      "requires": {
-        "define-properties": "1.1.3",
-        "empower": "1.3.1",
-        "power-assert-formatter": "1.4.1",
-        "universal-deep-strict-equal": "1.2.2",
-        "xtend": "4.0.1"
-      }
-    },
-    "power-assert-context-formatter": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/power-assert-context-formatter/-/power-assert-context-formatter-1.2.0.tgz",
-      "integrity": "sha512-HLNEW8Bin+BFCpk/zbyKwkEu9W8/zThIStxGo7weYcFkKgMuGCHUJhvJeBGXDZf0Qm2xis4pbnnciGZiX0EpSg==",
-      "requires": {
-        "core-js": "2.6.5",
-        "power-assert-context-traversal": "1.2.0"
-      }
-    },
-    "power-assert-context-reducer-ast": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/power-assert-context-reducer-ast/-/power-assert-context-reducer-ast-1.2.0.tgz",
-      "integrity": "sha512-EgOxmZ/Lb7tw4EwSKX7ZnfC0P/qRZFEG28dx/690qvhmOJ6hgThYFm5TUWANDLK5NiNKlPBi5WekVGd2+5wPrw==",
-      "requires": {
-        "acorn": "5.7.3",
-        "acorn-es7-plugin": "1.1.7",
-        "core-js": "2.6.5",
-        "espurify": "1.8.1",
-        "estraverse": "4.2.0"
-      }
-    },
-    "power-assert-context-traversal": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/power-assert-context-traversal/-/power-assert-context-traversal-1.2.0.tgz",
-      "integrity": "sha512-NFoHU6g2umNajiP2l4qb0BRWD773Aw9uWdWYH9EQsVwIZnog5bd2YYLFCVvaxWpwNzWeEfZIon2xtyc63026pQ==",
-      "requires": {
-        "core-js": "2.6.5",
-        "estraverse": "4.2.0"
-      }
-    },
-    "power-assert-formatter": {
-      "version": "1.4.1",
-      "resolved": "https://registry.npmjs.org/power-assert-formatter/-/power-assert-formatter-1.4.1.tgz",
-      "integrity": "sha1-XcEl7VCj37HdomwZNH879Y7CiEo=",
-      "requires": {
-        "core-js": "2.6.5",
-        "power-assert-context-formatter": "1.2.0",
-        "power-assert-context-reducer-ast": "1.2.0",
-        "power-assert-renderer-assertion": "1.2.0",
-        "power-assert-renderer-comparison": "1.2.0",
-        "power-assert-renderer-diagram": "1.2.0",
-        "power-assert-renderer-file": "1.2.0"
-      }
-    },
-    "power-assert-renderer-assertion": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/power-assert-renderer-assertion/-/power-assert-renderer-assertion-1.2.0.tgz",
-      "integrity": "sha512-3F7Q1ZLmV2ZCQv7aV7NJLNK9G7QsostrhOU7U0RhEQS/0vhEqrRg2jEJl1jtUL4ZyL2dXUlaaqrmPv5r9kRvIg==",
-      "requires": {
-        "power-assert-renderer-base": "1.1.1",
-        "power-assert-util-string-width": "1.2.0"
-      }
-    },
-    "power-assert-renderer-base": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/power-assert-renderer-base/-/power-assert-renderer-base-1.1.1.tgz",
-      "integrity": "sha1-lqZQxv0F7hvB9mtUrWFELIs/Y+s="
-    },
-    "power-assert-renderer-comparison": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/power-assert-renderer-comparison/-/power-assert-renderer-comparison-1.2.0.tgz",
-      "integrity": "sha512-7c3RKPDBKK4E3JqdPtYRE9cM8AyX4LC4yfTvvTYyx8zSqmT5kJnXwzR0yWQLOavACllZfwrAGQzFiXPc5sWa+g==",
-      "requires": {
-        "core-js": "2.6.5",
-        "diff-match-patch": "1.0.4",
-        "power-assert-renderer-base": "1.1.1",
-        "stringifier": "1.4.0",
-        "type-name": "2.0.2"
-      }
-    },
-    "power-assert-renderer-diagram": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/power-assert-renderer-diagram/-/power-assert-renderer-diagram-1.2.0.tgz",
-      "integrity": "sha512-JZ6PC+DJPQqfU6dwSmpcoD7gNnb/5U77bU5KgNwPPa+i1Pxiz6UuDeM3EUBlhZ1HvH9tMjI60anqVyi5l2oNdg==",
-      "requires": {
-        "core-js": "2.6.5",
-        "power-assert-renderer-base": "1.1.1",
-        "power-assert-util-string-width": "1.2.0",
-        "stringifier": "1.4.0"
-      }
-    },
-    "power-assert-renderer-file": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/power-assert-renderer-file/-/power-assert-renderer-file-1.2.0.tgz",
-      "integrity": "sha512-/oaVrRbeOtGoyyd7e4IdLP/jIIUFJdqJtsYzP9/88R39CMnfF/S/rUc8ZQalENfUfQ/wQHu+XZYRMaCEZmEesg==",
-      "requires": {
-        "power-assert-renderer-base": "1.1.1"
-      }
-    },
-    "power-assert-util-string-width": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/power-assert-util-string-width/-/power-assert-util-string-width-1.2.0.tgz",
-      "integrity": "sha512-lX90G0igAW0iyORTILZ/QjZWsa1MZ6VVY3L0K86e2eKun3S4LKPH4xZIl8fdeMYLfOjkaszbNSzf1uugLeAm2A==",
-      "requires": {
-        "eastasianwidth": "0.2.0"
-      }
-    },
-    "process-nextick-args": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/process-nextick-args/-/process-nextick-args-2.0.0.tgz",
-      "integrity": "sha512-MtEC1TqN0EU5nephaJ4rAtThHtC86dNN9qCuEhtshvpVBkAW5ZO7BASN9REnF9eoXGcRub+pFuKEpOHE+HbEMw=="
-    },
-    "protobufjs": {
-      "version": "5.0.3",
-      "resolved": "https://registry.npmjs.org/protobufjs/-/protobufjs-5.0.3.tgz",
-      "integrity": "sha512-55Kcx1MhPZX0zTbVosMQEO5R6/rikNXd9b6RQK4KSPcrSIIwoXTtebIczUrXlwaSrbz4x8XUVThGPob1n8I4QA==",
-      "requires": {
-        "ascli": "1.0.1",
-        "bytebuffer": "5.0.1",
-        "glob": "7.1.3",
-        "yargs": "3.32.0"
-      }
-    },
-    "proxy-addr": {
-      "version": "2.0.4",
-      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.4.tgz",
-      "integrity": "sha512-5erio2h9jp5CHGwcybmxmVqHmnCBZeewlfJ0pex+UW7Qny7OOZXTtH56TGNyBizkgiOwhJtMKrVzDTeKcySZwA==",
-      "requires": {
-        "forwarded": "0.1.2",
-        "ipaddr.js": "1.8.0"
-      }
-    },
-    "pseudomap": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/pseudomap/-/pseudomap-1.0.2.tgz",
-      "integrity": "sha1-8FKijacOYYkX7wqKw0wa5aaChrM="
-    },
-    "psl": {
-      "version": "1.1.31",
-      "resolved": "https://registry.npmjs.org/psl/-/psl-1.1.31.tgz",
-      "integrity": "sha512-/6pt4+C+T+wZUieKR620OpzN/LlnNKuWjy1iFLQ/UG35JqHlR/89MP1d96dUfkf6Dne3TuLQzOYEYshJ+Hx8mw=="
-    },
-    "pump": {
-      "version": "2.0.1",
-      "resolved": "https://registry.npmjs.org/pump/-/pump-2.0.1.tgz",
-      "integrity": "sha512-ruPMNRkN3MHP1cWJc9OWr+T/xDP0jhXYCLfJcBuX54hhfIBnaQmAUMfDcG4DM5UMWByBbJY69QSphm3jtDKIkA==",
-      "requires": {
-        "end-of-stream": "1.4.1",
-        "once": "1.4.0"
-      }
-    },
-    "pumpify": {
-      "version": "1.5.1",
-      "resolved": "https://registry.npmjs.org/pumpify/-/pumpify-1.5.1.tgz",
-      "integrity": "sha512-oClZI37HvuUJJxSKKrC17bZ9Cu0ZYhEAGPsPUy9KlMUmv9dKX2o77RUmq7f3XjIxbwyGwYzbzQ1L2Ks8sIradQ==",
-      "requires": {
-        "duplexify": "3.7.1",
-        "inherits": "2.0.3",
-        "pump": "2.0.1"
-      }
-    },
-    "punycode": {
-      "version": "2.1.1",
-      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.1.1.tgz",
-      "integrity": "sha512-XRsRjdf+j5ml+y/6GKHPZbrF/8p2Yga0JPtdqTIY2Xe5ohJPD9saDJJLPvp9+NSBprVvevdXZybnj2cv8OEd0A=="
-    },
-    "qs": {
-      "version": "6.5.2",
-      "resolved": "https://registry.npmjs.org/qs/-/qs-6.5.2.tgz",
-      "integrity": "sha512-N5ZAX4/LxJmF+7wN74pUD6qAh9/wnvdQcjq9TZjevvXzSUo7bfmw91saqMjzGS2xq91/odN2dW/WOl7qQHNDGA=="
-    },
-    "range-parser": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.0.tgz",
-      "integrity": "sha1-9JvmtIeJTdxA3MlKMi9hEJLgDV4="
-    },
-    "raw-body": {
-      "version": "2.3.3",
-      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.3.3.tgz",
-      "integrity": "sha512-9esiElv1BrZoI3rCDuOuKCBRbuApGGaDPQfjSflGxdy4oyzqghxu6klEkkVIvBje+FF0BX9coEv8KqW6X/7njw==",
-      "requires": {
-        "bytes": "3.0.0",
-        "http-errors": "1.6.3",
-        "iconv-lite": "0.4.23",
-        "unpipe": "1.0.0"
-      }
-    },
-    "readable-stream": {
-      "version": "2.3.6",
-      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-2.3.6.tgz",
-      "integrity": "sha512-tQtKA9WIAhBF3+VLAseyMqZeBjW0AHJoxOtYqSUZNJxauErmLbVm2FW1y+J/YA9dUrAC39ITejlZWhVIwawkKw==",
-      "requires": {
-        "core-util-is": "1.0.2",
-        "inherits": "2.0.3",
-        "isarray": "1.0.0",
-        "process-nextick-args": "2.0.0",
-        "safe-buffer": "5.1.2",
-        "string_decoder": "1.1.1",
-        "util-deprecate": "1.0.2"
-      }
-    },
-    "regex-not": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/regex-not/-/regex-not-1.0.2.tgz",
-      "integrity": "sha512-J6SDjUgDxQj5NusnOtdFxDwN/+HWykR8GELwctJ7mdqhcyy1xEc4SRFHUXvxTp661YaVKAjfRLZ9cCqS6tn32A==",
-      "requires": {
-        "extend-shallow": "3.0.2",
-        "safe-regex": "1.1.0"
-      }
-    },
-    "repeat-element": {
-      "version": "1.1.3",
-      "resolved": "https://registry.npmjs.org/repeat-element/-/repeat-element-1.1.3.tgz",
-      "integrity": "sha512-ahGq0ZnV5m5XtZLMb+vP76kcAM5nkLqk0lpqAuojSKGgQtn4eRi4ZZGm2olo2zKFH+sMsWaqOCW1dqAnOru72g=="
-    },
-    "repeat-string": {
-      "version": "1.6.1",
-      "resolved": "https://registry.npmjs.org/repeat-string/-/repeat-string-1.6.1.tgz",
-      "integrity": "sha1-jcrkcOHIirwtYA//Sndihtp15jc="
-    },
-    "request": {
-      "version": "2.88.0",
-      "resolved": "https://registry.npmjs.org/request/-/request-2.88.0.tgz",
-      "integrity": "sha512-NAqBSrijGLZdM0WZNsInLJpkJokL72XYjUpnB0iwsRgxh7dB6COrHnTBNwN0E+lHDAJzu7kLAkDeY08z2/A0hg==",
-      "requires": {
-        "aws-sign2": "0.7.0",
-        "aws4": "1.8.0",
-        "caseless": "0.12.0",
-        "combined-stream": "1.0.7",
-        "extend": "3.0.2",
-        "forever-agent": "0.6.1",
-        "form-data": "2.3.3",
-        "har-validator": "5.1.3",
-        "http-signature": "1.2.0",
-        "is-typedarray": "1.0.0",
-        "isstream": "0.1.2",
-        "json-stringify-safe": "5.0.1",
-        "mime-types": "2.1.22",
-        "oauth-sign": "0.9.0",
-        "performance-now": "2.1.0",
-        "qs": "6.5.2",
-        "safe-buffer": "5.1.2",
-        "tough-cookie": "2.4.3",
-        "tunnel-agent": "0.6.0",
-        "uuid": "3.3.2"
-      }
-    },
-    "resolve-url": {
-      "version": "0.2.1",
-      "resolved": "https://registry.npmjs.org/resolve-url/-/resolve-url-0.2.1.tgz",
-      "integrity": "sha1-LGN/53yJOv0qZj/iGqkIAGjiBSo="
-    },
-    "ret": {
-      "version": "0.1.15",
-      "resolved": "https://registry.npmjs.org/ret/-/ret-0.1.15.tgz",
-      "integrity": "sha512-TTlYpa+OL+vMMNG24xSlQGEJ3B/RzEfUlLct7b5G/ytav+wPrplCpVMFuwzXbkecJrb6IYo1iFb0S9v37754mg=="
-    },
-    "retry-axios": {
-      "version": "0.3.2",
-      "resolved": "https://registry.npmjs.org/retry-axios/-/retry-axios-0.3.2.tgz",
-      "integrity": "sha512-jp4YlI0qyDFfXiXGhkCOliBN1G7fRH03Nqy8YdShzGqbY5/9S2x/IR6C88ls2DFkbWuL3ASkP7QD3pVrNpPgwQ=="
-    },
-    "retry-request": {
-      "version": "3.3.2",
-      "resolved": "https://registry.npmjs.org/retry-request/-/retry-request-3.3.2.tgz",
-      "integrity": "sha512-WIiGp37XXDC6e7ku3LFoi7LCL/Gs9luGeeqvbPRb+Zl6OQMw4RCRfSaW+aLfE6lhz1R941UavE6Svl3Dm5xGIQ==",
-      "requires": {
-        "request": "2.88.0",
-        "through2": "2.0.5"
-      }
-    },
-    "safe-buffer": {
-      "version": "5.1.2",
-      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
-      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g=="
-    },
-    "safe-regex": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/safe-regex/-/safe-regex-1.1.0.tgz",
-      "integrity": "sha1-QKNmnzsHfR6UPURinhV91IAjvy4=",
-      "requires": {
-        "ret": "0.1.15"
-      }
-    },
-    "safer-buffer": {
-      "version": "2.1.2",
-      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
-      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
-    },
-    "send": {
-      "version": "0.16.2",
-      "resolved": "https://registry.npmjs.org/send/-/send-0.16.2.tgz",
-      "integrity": "sha512-E64YFPUssFHEFBvpbbjr44NCLtI1AohxQ8ZSiJjQLskAdKuriYEP6VyGEsRDH8ScozGpkaX1BGvhanqCwkcEZw==",
-      "requires": {
-        "debug": "2.6.9",
-        "depd": "1.1.2",
-        "destroy": "1.0.4",
-        "encodeurl": "1.0.2",
-        "escape-html": "1.0.3",
-        "etag": "1.8.1",
-        "fresh": "0.5.2",
-        "http-errors": "1.6.3",
-        "mime": "1.4.1",
-        "ms": "2.0.0",
-        "on-finished": "2.3.0",
-        "range-parser": "1.2.0",
-        "statuses": "1.4.0"
-      },
-      "dependencies": {
-        "debug": {
-          "version": "2.6.9",
-          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
-          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
-          "requires": {
-            "ms": "2.0.0"
-          }
-        },
-        "mime": {
-          "version": "1.4.1",
-          "resolved": "https://registry.npmjs.org/mime/-/mime-1.4.1.tgz",
-          "integrity": "sha512-KI1+qOZu5DcW6wayYHSzR/tXKCDC5Om4s1z2QJjDULzLcmf3DvzS7oluY4HCTrc+9FiKmWUgeNLg7W3uIQvxtQ=="
-        },
-        "ms": {
-          "version": "2.0.0",
-          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
-          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g="
-        }
-      }
-    },
-    "serve-static": {
-      "version": "1.13.2",
-      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.13.2.tgz",
-      "integrity": "sha512-p/tdJrO4U387R9oMjb1oj7qSMaMfmOyd4j9hOFoxZe2baQszgHcSWjuya/CiT5kgZZKRudHNOA0pYXOl8rQ5nw==",
-      "requires": {
-        "encodeurl": "1.0.2",
-        "escape-html": "1.0.3",
-        "parseurl": "1.3.2",
-        "send": "0.16.2"
-      }
-    },
-    "set-value": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/set-value/-/set-value-2.0.0.tgz",
-      "integrity": "sha512-hw0yxk9GT/Hr5yJEYnHNKYXkIA8mVJgd9ditYZCe16ZczcaELYYcfvaXesNACk2O8O0nTiPQcQhGUQj8JLzeeg==",
-      "requires": {
-        "extend-shallow": "2.0.1",
-        "is-extendable": "0.1.1",
-        "is-plain-object": "2.0.4",
-        "split-string": "3.1.0"
-      },
-      "dependencies": {
-        "extend-shallow": {
-          "version": "2.0.1",
-          "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-2.0.1.tgz",
-          "integrity": "sha1-Ua99YUrZqfYQ6huvu5idaxxWiQ8=",
-          "requires": {
-            "is-extendable": "0.1.1"
-          }
-        }
-      }
-    },
-    "setprototypeof": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.1.0.tgz",
-      "integrity": "sha512-BvE/TwpZX4FXExxOxZyRGQQv651MSwmWKZGqvmPcRIjDqWub67kTKuIMx43cZZrS/cBBzwBcNDWoFxt2XEFIpQ=="
-    },
-    "signal-exit": {
-      "version": "3.0.2",
-      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.2.tgz",
-      "integrity": "sha1-tf3AjxKH6hF4Yo5BXiUTK3NkbG0="
-    },
-    "slash": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/slash/-/slash-1.0.0.tgz",
-      "integrity": "sha1-xB8vbDn8FtHNF61LXYlhFK5HDVU="
-    },
-    "snakeize": {
-      "version": "0.1.0",
-      "resolved": "https://registry.npmjs.org/snakeize/-/snakeize-0.1.0.tgz",
-      "integrity": "sha1-EMCI2LWOsHazIpu1oE4jLOEmQi0="
-    },
-    "snapdragon": {
-      "version": "0.8.2",
-      "resolved": "https://registry.npmjs.org/snapdragon/-/snapdragon-0.8.2.tgz",
-      "integrity": "sha512-FtyOnWN/wCHTVXOMwvSv26d+ko5vWlIDD6zoUJ7LW8vh+ZBC8QdljveRP+crNrtBwioEUWy/4dMtbBjA4ioNlg==",
-      "requires": {
-        "base": "0.11.2",
-        "debug": "2.6.9",
-        "define-property": "0.2.5",
-        "extend-shallow": "2.0.1",
-        "map-cache": "0.2.2",
-        "source-map": "0.5.7",
-        "source-map-resolve": "0.5.2",
-        "use": "3.1.1"
-      },
-      "dependencies": {
-        "debug": {
-          "version": "2.6.9",
-          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
-          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
-          "requires": {
-            "ms": "2.0.0"
-          }
-        },
-        "define-property": {
-          "version": "0.2.5",
-          "resolved": "https://registry.npmjs.org/define-property/-/define-property-0.2.5.tgz",
-          "integrity": "sha1-w1se+RjsPJkPmlvFe+BKrOxcgRY=",
-          "requires": {
-            "is-descriptor": "0.1.6"
-          }
-        },
-        "extend-shallow": {
-          "version": "2.0.1",
-          "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-2.0.1.tgz",
-          "integrity": "sha1-Ua99YUrZqfYQ6huvu5idaxxWiQ8=",
-          "requires": {
-            "is-extendable": "0.1.1"
-          }
-        },
-        "ms": {
-          "version": "2.0.0",
-          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
-          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g="
-        }
-      }
-    },
-    "snapdragon-node": {
-      "version": "2.1.1",
-      "resolved": "https://registry.npmjs.org/snapdragon-node/-/snapdragon-node-2.1.1.tgz",
-      "integrity": "sha512-O27l4xaMYt/RSQ5TR3vpWCAB5Kb/czIcqUFOM/C4fYcLnbZUc1PkjTAMjof2pBWaSTwOUd6qUHcFGVGj7aIwnw==",
-      "requires": {
-        "define-property": "1.0.0",
-        "isobject": "3.0.1",
-        "snapdragon-util": "3.0.1"
-      },
-      "dependencies": {
-        "define-property": {
-          "version": "1.0.0",
-          "resolved": "https://registry.npmjs.org/define-property/-/define-property-1.0.0.tgz",
-          "integrity": "sha1-dp66rz9KY6rTr56NMEybvnm/sOY=",
-          "requires": {
-            "is-descriptor": "1.0.2"
-          }
-        },
-        "is-accessor-descriptor": {
-          "version": "1.0.0",
-          "resolved": "https://registry.npmjs.org/is-accessor-descriptor/-/is-accessor-descriptor-1.0.0.tgz",
-          "integrity": "sha512-m5hnHTkcVsPfqx3AKlyttIPb7J+XykHvJP2B9bZDjlhLIoEq4XoK64Vg7boZlVWYK6LUY94dYPEE7Lh0ZkZKcQ==",
-          "requires": {
-            "kind-of": "6.0.2"
-          }
-        },
-        "is-data-descriptor": {
-          "version": "1.0.0",
-          "resolved": "https://registry.npmjs.org/is-data-descriptor/-/is-data-descriptor-1.0.0.tgz",
-          "integrity": "sha512-jbRXy1FmtAoCjQkVmIVYwuuqDFUbaOeDjmed1tOGPrsMhtJA4rD9tkgA0F1qJ3gRFRXcHYVkdeaP50Q5rE/jLQ==",
-          "requires": {
-            "kind-of": "6.0.2"
-          }
-        },
-        "is-descriptor": {
-          "version": "1.0.2",
-          "resolved": "https://registry.npmjs.org/is-descriptor/-/is-descriptor-1.0.2.tgz",
-          "integrity": "sha512-2eis5WqQGV7peooDyLmNEPUrps9+SXX5c9pL3xEB+4e9HnGuDa7mB7kHxHw4CbqS9k1T2hOH3miL8n8WtiYVtg==",
-          "requires": {
-            "is-accessor-descriptor": "1.0.0",
-            "is-data-descriptor": "1.0.0",
-            "kind-of": "6.0.2"
-          }
-        }
-      }
-    },
-    "snapdragon-util": {
-      "version": "3.0.1",
-      "resolved": "https://registry.npmjs.org/snapdragon-util/-/snapdragon-util-3.0.1.tgz",
-      "integrity": "sha512-mbKkMdQKsjX4BAL4bRYTj21edOf8cN7XHdYUJEe+Zn99hVEYcMvKPct1IqNe7+AZPirn8BCDOQBHQZknqmKlZQ==",
-      "requires": {
-        "kind-of": "3.2.2"
-      },
-      "dependencies": {
-        "kind-of": {
-          "version": "3.2.2",
-          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz",
-          "integrity": "sha1-MeohpzS6ubuw8yRm2JOupR5KPGQ=",
-          "requires": {
-            "is-buffer": "1.1.6"
-          }
-        }
-      }
-    },
-    "source-map": {
-      "version": "0.5.7",
-      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz",
-      "integrity": "sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w="
-    },
-    "source-map-resolve": {
-      "version": "0.5.2",
-      "resolved": "https://registry.npmjs.org/source-map-resolve/-/source-map-resolve-0.5.2.tgz",
-      "integrity": "sha512-MjqsvNwyz1s0k81Goz/9vRBe9SZdB09Bdw+/zYyO+3CuPk6fouTaxscHkgtE8jKvf01kVfl8riHzERQ/kefaSA==",
-      "requires": {
-        "atob": "2.1.2",
-        "decode-uri-component": "0.2.0",
-        "resolve-url": "0.2.1",
-        "source-map-url": "0.4.0",
-        "urix": "0.1.0"
-      }
-    },
-    "source-map-url": {
-      "version": "0.4.0",
-      "resolved": "https://registry.npmjs.org/source-map-url/-/source-map-url-0.4.0.tgz",
-      "integrity": "sha1-PpNdfd1zYxuXZZlW1VEo6HtQhKM="
-    },
-    "split-array-stream": {
-      "version": "1.0.3",
-      "resolved": "https://registry.npmjs.org/split-array-stream/-/split-array-stream-1.0.3.tgz",
-      "integrity": "sha1-0rdajl4Ngk1S/eyLgiWDncLjXfo=",
-      "requires": {
-        "async": "2.6.2",
-        "is-stream-ended": "0.1.4"
-      }
-    },
-    "split-string": {
-      "version": "3.1.0",
-      "resolved": "https://registry.npmjs.org/split-string/-/split-string-3.1.0.tgz",
-      "integrity": "sha512-NzNVhJDYpwceVVii8/Hu6DKfD2G+NrQHlS/V/qgv763EYudVwEcMQNxd2lh+0VrUByXN/oJkl5grOhYWvQUYiw==",
-      "requires": {
-        "extend-shallow": "3.0.2"
-      }
-    },
-    "sshpk": {
-      "version": "1.16.1",
-      "resolved": "https://registry.npmjs.org/sshpk/-/sshpk-1.16.1.tgz",
-      "integrity": "sha512-HXXqVUq7+pcKeLqqZj6mHFUMvXtOJt1uoUx09pFW6011inTMxqI8BA8PM95myrIyyKwdnzjdFjLiE6KBPVtJIg==",
-      "requires": {
-        "asn1": "0.2.4",
-        "assert-plus": "1.0.0",
-        "bcrypt-pbkdf": "1.0.2",
-        "dashdash": "1.14.1",
-        "ecc-jsbn": "0.1.2",
-        "getpass": "0.1.7",
-        "jsbn": "0.1.1",
-        "safer-buffer": "2.1.2",
-        "tweetnacl": "0.14.5"
-      }
-    },
-    "static-extend": {
-      "version": "0.1.2",
-      "resolved": "https://registry.npmjs.org/static-extend/-/static-extend-0.1.2.tgz",
-      "integrity": "sha1-YICcOcv/VTNyJv1eC1IPNB8ftcY=",
-      "requires": {
-        "define-property": "0.2.5",
-        "object-copy": "0.1.0"
-      },
-      "dependencies": {
-        "define-property": {
-          "version": "0.2.5",
-          "resolved": "https://registry.npmjs.org/define-property/-/define-property-0.2.5.tgz",
-          "integrity": "sha1-w1se+RjsPJkPmlvFe+BKrOxcgRY=",
-          "requires": {
-            "is-descriptor": "0.1.6"
-          }
-        }
-      }
-    },
-    "statuses": {
-      "version": "1.4.0",
-      "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.4.0.tgz",
-      "integrity": "sha512-zhSCtt8v2NDrRlPQpCNtw/heZLtfUDqxBM1udqikb/Hbk52LK4nQSwr10u77iopCW5LsyHpuXS0GnEc48mLeew=="
-    },
-    "stream-events": {
-      "version": "1.0.5",
-      "resolved": "https://registry.npmjs.org/stream-events/-/stream-events-1.0.5.tgz",
-      "integrity": "sha512-E1GUzBSgvct8Jsb3v2X15pjzN1tYebtbLaMg+eBOUOAxgbLoSbT2NS91ckc5lJD1KfLjId+jXJRgo0qnV5Nerg==",
-      "requires": {
-        "stubs": "3.0.0"
-      }
-    },
-    "stream-shift": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/stream-shift/-/stream-shift-1.0.0.tgz",
-      "integrity": "sha1-1cdSgl5TZ+eG944Y5EXqIjoVWVI="
-    },
-    "string_decoder": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.1.1.tgz",
-      "integrity": "sha512-n/ShnvDi6FHbbVfviro+WojiFzv+s8MPMHBczVePfUpDJLwoLT0ht1l4YwBCbi8pJAveEEdnkHyPyTP/mzRfwg==",
-      "requires": {
-        "safe-buffer": "5.1.2"
-      }
-    },
-    "string-format-obj": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/string-format-obj/-/string-format-obj-1.1.1.tgz",
-      "integrity": "sha512-Mm+sROy+pHJmx0P/0Bs1uxIX6UhGJGj6xDGQZ5zh9v/SZRmLGevp+p0VJxV7lirrkAmQ2mvva/gHKpnF/pTb+Q=="
-    },
-    "string-width": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/string-width/-/string-width-1.0.2.tgz",
-      "integrity": "sha1-EYvfW4zcUaKn5w0hHgfisLmxB9M=",
-      "requires": {
-        "code-point-at": "1.1.0",
-        "is-fullwidth-code-point": "1.0.0",
-        "strip-ansi": "3.0.1"
-      }
-    },
-    "stringifier": {
-      "version": "1.4.0",
-      "resolved": "https://registry.npmjs.org/stringifier/-/stringifier-1.4.0.tgz",
-      "integrity": "sha512-cNsMOqqrcbLcHTXEVmkw9y0fwDwkdgtZwlfyolzpQDoAE1xdNGhQhxBUfiDvvZIKl1hnUEgMv66nHwtMz3OjPw==",
-      "requires": {
-        "core-js": "2.6.5",
-        "traverse": "0.6.6",
-        "type-name": "2.0.2"
-      }
-    },
-    "strip-ansi": {
-      "version": "3.0.1",
-      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-3.0.1.tgz",
-      "integrity": "sha1-ajhfuIU9lS1f8F0Oiq+UJ43GPc8=",
-      "requires": {
-        "ansi-regex": "2.1.1"
-      }
-    },
-    "stubs": {
-      "version": "3.0.0",
-      "resolved": "https://registry.npmjs.org/stubs/-/stubs-3.0.0.tgz",
-      "integrity": "sha1-6NK6H6nJBXAwPAMLaQD31fiavls="
-    },
-    "through2": {
-      "version": "2.0.5",
-      "resolved": "https://registry.npmjs.org/through2/-/through2-2.0.5.tgz",
-      "integrity": "sha512-/mrRod8xqpA+IHSLyGCQ2s8SPHiCDEeQJSep1jqLYeEUClOFG2Qsh+4FU6G9VeqpZnGW/Su8LQGc4YKni5rYSQ==",
-      "requires": {
-        "readable-stream": "2.3.6",
-        "xtend": "4.0.1"
-      }
-    },
-    "to-object-path": {
-      "version": "0.3.0",
-      "resolved": "https://registry.npmjs.org/to-object-path/-/to-object-path-0.3.0.tgz",
-      "integrity": "sha1-KXWIt7Dn4KwI4E5nL4XB9JmeF68=",
-      "requires": {
-        "kind-of": "3.2.2"
-      },
-      "dependencies": {
-        "kind-of": {
-          "version": "3.2.2",
-          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz",
-          "integrity": "sha1-MeohpzS6ubuw8yRm2JOupR5KPGQ=",
-          "requires": {
-            "is-buffer": "1.1.6"
-          }
-        }
-      }
-    },
-    "to-regex": {
-      "version": "3.0.2",
-      "resolved": "https://registry.npmjs.org/to-regex/-/to-regex-3.0.2.tgz",
-      "integrity": "sha512-FWtleNAtZ/Ki2qtqej2CXTOayOH9bHDQF+Q48VpWyDXjbYxA4Yz8iDB31zXOBUlOHHKidDbqGVrTUvQMPmBGBw==",
-      "requires": {
-        "define-property": "2.0.2",
-        "extend-shallow": "3.0.2",
-        "regex-not": "1.0.2",
-        "safe-regex": "1.1.0"
-      }
-    },
-    "to-regex-range": {
-      "version": "2.1.1",
-      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-2.1.1.tgz",
-      "integrity": "sha1-fIDBe53+vlmeJzZ+DU3VWQFB2zg=",
-      "requires": {
-        "is-number": "3.0.0",
-        "repeat-string": "1.6.1"
-      }
-    },
-    "tough-cookie": {
-      "version": "2.4.3",
-      "resolved": "https://registry.npmjs.org/tough-cookie/-/tough-cookie-2.4.3.tgz",
-      "integrity": "sha512-Q5srk/4vDM54WJsJio3XNn6K2sCG+CQ8G5Wz6bZhRZoAe/+TxjWB/GlFAnYEbkYVlON9FMk/fE3h2RLpPXo4lQ==",
-      "requires": {
-        "psl": "1.1.31",
-        "punycode": "1.4.1"
-      },
-      "dependencies": {
-        "punycode": {
-          "version": "1.4.1",
-          "resolved": "https://registry.npmjs.org/punycode/-/punycode-1.4.1.tgz",
-          "integrity": "sha1-wNWmOycYgArY4esPpSachN1BhF4="
-        }
-      }
-    },
-    "traverse": {
-      "version": "0.6.6",
-      "resolved": "https://registry.npmjs.org/traverse/-/traverse-0.6.6.tgz",
-      "integrity": "sha1-y99WD9e5r2MlAv7UD5GMFX6pcTc="
-    },
-    "tslib": {
-      "version": "1.9.3",
-      "resolved": "https://registry.npmjs.org/tslib/-/tslib-1.9.3.tgz",
-      "integrity": "sha512-4krF8scpejhaOgqzBEcGM7yDIEfi0/8+8zDRZhNZZ2kjmHJ4hv3zCbQWxoJGz1iw5U0Jl0nma13xzHXcncMavQ=="
-    },
-    "tunnel-agent": {
-      "version": "0.6.0",
-      "resolved": "https://registry.npmjs.org/tunnel-agent/-/tunnel-agent-0.6.0.tgz",
-      "integrity": "sha1-J6XeoGs2sEoKmWZ3SykIaPD8QP0=",
-      "requires": {
-        "safe-buffer": "5.1.2"
-      }
-    },
-    "tweetnacl": {
-      "version": "0.14.5",
-      "resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-0.14.5.tgz",
-      "integrity": "sha1-WuaBd/GS1EViadEIr6k/+HQ/T2Q="
-    },
-    "type-is": {
-      "version": "1.6.16",
-      "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.16.tgz",
-      "integrity": "sha512-HRkVv/5qY2G6I8iab9cI7v1bOIdhm94dVjQCPFElW9W+3GeDOSHmy2EBYe4VTApuzolPcmgFTN3ftVJRKR2J9Q==",
-      "requires": {
-        "media-typer": "0.3.0",
-        "mime-types": "2.1.22"
-      }
-    },
-    "type-name": {
-      "version": "2.0.2",
-      "resolved": "https://registry.npmjs.org/type-name/-/type-name-2.0.2.tgz",
-      "integrity": "sha1-7+fUEj2KxSr/9/QMfk3sUmYAj7Q="
-    },
-    "typedarray": {
-      "version": "0.0.6",
-      "resolved": "https://registry.npmjs.org/typedarray/-/typedarray-0.0.6.tgz",
-      "integrity": "sha1-hnrHTjhkGHsdPUfZlqeOxciDB3c="
-    },
-    "union-value": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/union-value/-/union-value-1.0.0.tgz",
-      "integrity": "sha1-XHHDTLW61dzr4+oM0IIHulqhrqQ=",
-      "requires": {
-        "arr-union": "3.1.0",
-        "get-value": "2.0.6",
-        "is-extendable": "0.1.1",
-        "set-value": "0.4.3"
-      },
-      "dependencies": {
-        "extend-shallow": {
-          "version": "2.0.1",
-          "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-2.0.1.tgz",
-          "integrity": "sha1-Ua99YUrZqfYQ6huvu5idaxxWiQ8=",
-          "requires": {
-            "is-extendable": "0.1.1"
-          }
-        },
-        "set-value": {
-          "version": "0.4.3",
-          "resolved": "https://registry.npmjs.org/set-value/-/set-value-0.4.3.tgz",
-          "integrity": "sha1-fbCPnT0i3H945Trzw79GZuzfzPE=",
-          "requires": {
-            "extend-shallow": "2.0.1",
-            "is-extendable": "0.1.1",
-            "is-plain-object": "2.0.4",
-            "to-object-path": "0.3.0"
-          }
-        }
-      }
-    },
-    "unique-string": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/unique-string/-/unique-string-1.0.0.tgz",
-      "integrity": "sha1-nhBXzKhRq7kzmPizOuGHuZyuwRo=",
-      "requires": {
-        "crypto-random-string": "1.0.0"
-      }
-    },
-    "universal-deep-strict-equal": {
-      "version": "1.2.2",
-      "resolved": "https://registry.npmjs.org/universal-deep-strict-equal/-/universal-deep-strict-equal-1.2.2.tgz",
-      "integrity": "sha1-DaSsL3PP95JMgfpN4BjKViyisKc=",
-      "requires": {
-        "array-filter": "1.0.0",
-        "indexof": "0.0.1",
-        "object-keys": "1.1.0"
-      }
-    },
-    "unpipe": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
-      "integrity": "sha1-sr9O6FFKrmFltIF4KdIbLvSZBOw="
-    },
-    "unset-value": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/unset-value/-/unset-value-1.0.0.tgz",
-      "integrity": "sha1-g3aHP30jNRef+x5vw6jtDfyKtVk=",
-      "requires": {
-        "has-value": "0.3.1",
-        "isobject": "3.0.1"
-      },
-      "dependencies": {
-        "has-value": {
-          "version": "0.3.1",
-          "resolved": "https://registry.npmjs.org/has-value/-/has-value-0.3.1.tgz",
-          "integrity": "sha1-ex9YutpiyoJ+wKIHgCVlSEWZXh8=",
-          "requires": {
-            "get-value": "2.0.6",
-            "has-values": "0.1.4",
-            "isobject": "2.1.0"
-          },
-          "dependencies": {
-            "isobject": {
-              "version": "2.1.0",
-              "resolved": "https://registry.npmjs.org/isobject/-/isobject-2.1.0.tgz",
-              "integrity": "sha1-8GVWEJaj8dou9GJy+BXIQNh+DIk=",
-              "requires": {
-                "isarray": "1.0.0"
-              }
-            }
-          }
-        },
-        "has-values": {
-          "version": "0.1.4",
-          "resolved": "https://registry.npmjs.org/has-values/-/has-values-0.1.4.tgz",
-          "integrity": "sha1-bWHeldkd/Km5oCCJrThL/49it3E="
-        }
-      }
-    },
-    "uri-js": {
-      "version": "4.2.2",
-      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.2.2.tgz",
-      "integrity": "sha512-KY9Frmirql91X2Qgjry0Wd4Y+YTdrdZheS8TFwvkbLWf/G5KNJDCh6pKL5OZctEW4+0Baa5idK2ZQuELRwPznQ==",
-      "requires": {
-        "punycode": "2.1.1"
-      }
-    },
-    "urix": {
-      "version": "0.1.0",
-      "resolved": "https://registry.npmjs.org/urix/-/urix-0.1.0.tgz",
-      "integrity": "sha1-2pN/emLiH+wf0Y1Js1wpNQZ6bHI="
-    },
-    "use": {
-      "version": "3.1.1",
-      "resolved": "https://registry.npmjs.org/use/-/use-3.1.1.tgz",
-      "integrity": "sha512-cwESVXlO3url9YWlFW/TA9cshCEhtu7IKJ/p5soJ/gGpj7vbvFrAY/eIioQ6Dw23KjZhYgiIo8HOs1nQ2vr/oQ=="
-    },
-    "util-deprecate": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
-      "integrity": "sha1-RQ1Nyfpw3nMnYvvS1KKJgUGaDM8="
-    },
-    "utils-merge": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
-      "integrity": "sha1-n5VxD1CiZ5R7LMwSR0HBAoQn5xM="
-    },
-    "uuid": {
-      "version": "3.3.2",
-      "resolved": "https://registry.npmjs.org/uuid/-/uuid-3.3.2.tgz",
-      "integrity": "sha512-yXJmeNaw3DnnKAOKJE51sL/ZaYfWJRl1pK9dr19YFCu0ObS231AB1/LbqTKRAQ5kw8A90rA6fr4riOUpTZvQZA=="
-    },
-    "vary": {
-      "version": "1.1.2",
-      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
-      "integrity": "sha1-IpnwLG3tMNSllhsLn3RSShj2NPw="
-    },
-    "verror": {
-      "version": "1.10.0",
-      "resolved": "https://registry.npmjs.org/verror/-/verror-1.10.0.tgz",
-      "integrity": "sha1-OhBcoXBTr1XW4nDB+CiGguGNpAA=",
-      "requires": {
-        "assert-plus": "1.0.0",
-        "core-util-is": "1.0.2",
-        "extsprintf": "1.3.0"
-      }
-    },
-    "websocket-driver": {
-      "version": "0.7.0",
-      "resolved": "https://registry.npmjs.org/websocket-driver/-/websocket-driver-0.7.0.tgz",
-      "integrity": "sha1-DK+dLXVdk67gSdS90NP+LMoqJOs=",
-      "requires": {
-        "http-parser-js": "0.5.0",
-        "websocket-extensions": "0.1.3"
-      }
-    },
-    "websocket-extensions": {
-      "version": "0.1.3",
-      "resolved": "https://registry.npmjs.org/websocket-extensions/-/websocket-extensions-0.1.3.tgz",
-      "integrity": "sha512-nqHUnMXmBzT0w570r2JpJxfiSD1IzoI+HGVdd3aZ0yNi3ngvQ4jv1dtHt5VGxfI2yj5yqImPhOK4vmIh2xMbGg=="
-    },
-    "window-size": {
-      "version": "0.1.4",
-      "resolved": "https://registry.npmjs.org/window-size/-/window-size-0.1.4.tgz",
-      "integrity": "sha1-+OGqHuWlPsW/FR/6CXQqatdpeHY="
-    },
-    "wrap-ansi": {
-      "version": "2.1.0",
-      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-2.1.0.tgz",
-      "integrity": "sha1-2Pw9KE3QV5T+hJc8rs3Rz4JP3YU=",
-      "requires": {
-        "string-width": "1.0.2",
-        "strip-ansi": "3.0.1"
-      }
-    },
-    "wrappy": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
-      "integrity": "sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8="
-    },
-    "write-file-atomic": {
-      "version": "2.4.2",
-      "resolved": "https://registry.npmjs.org/write-file-atomic/-/write-file-atomic-2.4.2.tgz",
-      "integrity": "sha512-s0b6vB3xIVRLWywa6X9TOMA7k9zio0TMOsl9ZnDkliA/cfJlpHXAscj0gbHVJiTdIuAYpIyqS5GW91fqm6gG5g==",
-      "requires": {
-        "graceful-fs": "4.1.15",
-        "imurmurhash": "0.1.4",
-        "signal-exit": "3.0.2"
-      }
-    },
-    "xdg-basedir": {
-      "version": "3.0.0",
-      "resolved": "https://registry.npmjs.org/xdg-basedir/-/xdg-basedir-3.0.0.tgz",
-      "integrity": "sha1-SWsswQnsqNus/i3HK2A8F8WHCtQ="
-    },
-    "xtend": {
-      "version": "4.0.1",
-      "resolved": "https://registry.npmjs.org/xtend/-/xtend-4.0.1.tgz",
-      "integrity": "sha1-pcbVMr5lbiPbgg77lDofBJmNY68="
-    },
-    "y18n": {
-      "version": "3.2.1",
-      "resolved": "https://registry.npmjs.org/y18n/-/y18n-3.2.1.tgz",
-      "integrity": "sha1-bRX7qITAhnnA136I53WegR4H+kE="
-    },
-    "yallist": {
-      "version": "2.1.2",
-      "resolved": "https://registry.npmjs.org/yallist/-/yallist-2.1.2.tgz",
-      "integrity": "sha1-HBH5IY8HYImkfdUS+TxmmaaoHVI="
-    },
-    "yargs": {
-      "version": "3.32.0",
-      "resolved": "https://registry.npmjs.org/yargs/-/yargs-3.32.0.tgz",
-      "integrity": "sha1-AwiOnr+edWtpdRYR0qXvWRSCyZU=",
-      "requires": {
-        "camelcase": "2.1.1",
-        "cliui": "3.2.0",
-        "decamelize": "1.2.0",
-        "os-locale": "1.4.0",
-        "string-width": "1.0.2",
-        "window-size": "0.1.4",
-        "y18n": "3.2.1"
-      }
-    }
-  }
-}
diff --git a/test-apps/functions-test-app/functions/package.json b/test-apps/functions-test-app/functions/package.json
deleted file mode 100644
index ae7537c8b..000000000
--- a/test-apps/functions-test-app/functions/package.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-  "name": "functions",
-  "description": "Cloud Functions for Android Functions Quickstart",
-  "dependencies": {
-    "bad-words": "^1.3.1",
-    "capitalize-sentence": "^0.1.2",
-    "firebase-admin": "~5.10.0",
-    "firebase-functions": "^2.0.5"
-  },
-  "private": true
-}
diff --git a/test-apps/functions-test-app/functions/sanitizer.js b/test-apps/functions-test-app/functions/sanitizer.js
deleted file mode 100644
index 3b1f5c28f..000000000
--- a/test-apps/functions-test-app/functions/sanitizer.js
+++ /dev/null
@@ -1,59 +0,0 @@
-/**
- * Copyright 2018 Google Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-'use strict';
-
-const capitalizeSentence = require('capitalize-sentence');
-const Filter = require('bad-words');
-const badWordsFilter = new Filter();
-
-// Sanitizes the given text if needed by replacing bad words with '*'.
-exports.sanitizeText = (text) => {
-  // Re-capitalize if the user is Shouting.
-  if (isShouting(text)) {
-    console.log('User is shouting. Fixing sentence case...');
-    text = stopShouting(text);
-  }
-
-  // Moderate if the user uses SwearWords.
-  if (containsSwearwords(text)) {
-    console.log('User is swearing. moderating...');
-    text = replaceSwearwords(text);
-  }
-
-  return text;
-};
-
-// Returns true if the string contains swearwords.
-function containsSwearwords(message) {
-  return message !== badWordsFilter.clean(message);
-}
-
-// Hide all swearwords. e.g: Crap => ****.
-function replaceSwearwords(message) {
-  return badWordsFilter.clean(message);
-}
-
-// Detect if the current message is shouting. i.e. there are too many Uppercase
-// characters or exclamation points.
-function isShouting(message) {
-  return message.replace(/[^A-Z]/g, '').length > message.length / 2 || message.replace(/[^!]/g, '').length >= 3;
-}
-
-// Correctly capitalize the string as a sentence (e.g. uppercase after dots)
-// and remove exclamation points.
-function stopShouting(message) {
-  return capitalizeSentence(message.toLowerCase()).replace(/!+/g, '.');
-}
diff --git a/test-apps/functions-test-app/gradle.properties b/test-apps/functions-test-app/gradle.properties
deleted file mode 100644
index 8781e6875..000000000
--- a/test-apps/functions-test-app/gradle.properties
+++ /dev/null
@@ -1,33 +0,0 @@
-#
-# Copyright 2018 Google LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-# Project-wide Gradle settings.
-
-# IDE (e.g. Android Studio) users:
-# Gradle settings configured through the IDE *will override*
-# any settings specified in this file.
-
-# For more details on how to configure your build environment visit
-# http://www.gradle.org/docs/current/userguide/build_environment.html
-
-# Specifies the JVM arguments used for the daemon process.
-# The setting is particularly useful for tweaking memory settings.
-org.gradle.jvmargs=-Xmx1536m
-
-# When configured, Gradle will run in incubating parallel mode.
-# This option should only be used with decoupled projects. More details, visit
-# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
-# org.gradle.parallel=true
diff --git a/test-apps/functions-test-app/proguard-rules.pro b/test-apps/functions-test-app/proguard-rules.pro
deleted file mode 100644
index 0464076e9..000000000
--- a/test-apps/functions-test-app/proguard-rules.pro
+++ /dev/null
@@ -1,5 +0,0 @@
--keepattributes SourceFile,LineNumberTable
-
--keep class android.support.test.espresso.IdlingResource { *; }
--keep class android.support.test.espresso.IdlingRegistry { *; }
-
diff --git a/test-apps/functions-test-app/src/androidTest/java/com/google/firebase/testapps/functions/TestActivityTest.java b/test-apps/functions-test-app/src/androidTest/java/com/google/firebase/testapps/functions/TestActivityTest.java
deleted file mode 100644
index 4b9684299..000000000
--- a/test-apps/functions-test-app/src/androidTest/java/com/google/firebase/testapps/functions/TestActivityTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-// Copyright 2018 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.google.firebase.testapps.functions;
-
-import android.support.test.espresso.IdlingRegistry;
-import android.support.test.espresso.IdlingResource;
-import android.support.test.filters.LargeTest;
-import android.support.test.rule.ActivityTestRule;
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import static android.support.test.espresso.Espresso.onView;
-import static android.support.test.espresso.assertion.ViewAssertions.matches;
-import static android.support.test.espresso.matcher.ViewMatchers.withId;
-import static android.support.test.espresso.matcher.ViewMatchers.withText;
-
-@LargeTest
-@RunWith(AndroidJUnit4.class)
-public class TestActivityTest {
-
-  @Rule
-  public ActivityTestRule<TestActivity> mActivityTestRule =
-      new ActivityTestRule<>(TestActivity.class);
-
-  private IdlingResource mIdlingResource;
-
-  @Before
-  public void before() {
-    mIdlingResource = mActivityTestRule.getActivity().getIdlingResource();
-    IdlingRegistry.getInstance().register(mIdlingResource);
-  }
-
-  @After
-  public void unregisterIdlingResource() {
-    if (mIdlingResource != null) {
-      IdlingRegistry.getInstance().unregister(mIdlingResource);
-    }
-  }
-
-  @Test
-  public void testActivityTest() throws Exception {
-    onView(withId(R.id.sum)).check(matches(withText("21")));
-  }
-}
diff --git a/test-apps/functions-test-app/src/main/java/com/google/firebase/testapps/functions/TestActivity.java b/test-apps/functions-test-app/src/main/java/com/google/firebase/testapps/functions/TestActivity.java
deleted file mode 100644
index 56af2290c..000000000
--- a/test-apps/functions-test-app/src/main/java/com/google/firebase/testapps/functions/TestActivity.java
+++ /dev/null
@@ -1,91 +0,0 @@
-// Copyright 2018 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.google.firebase.testapps.functions;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.support.annotation.Keep;
-import android.support.annotation.NonNull;
-import android.support.annotation.VisibleForTesting;
-import android.support.test.espresso.IdlingResource;
-import android.support.test.espresso.idling.CountingIdlingResource;
-import android.widget.TextView;
-import com.google.android.gms.tasks.Continuation;
-import com.google.android.gms.tasks.OnCompleteListener;
-import com.google.android.gms.tasks.OnSuccessListener;
-import com.google.android.gms.tasks.Task;
-import com.google.firebase.functions.FirebaseFunctions;
-import com.google.firebase.functions.HttpsCallableResult;
-import java.util.HashMap;
-import java.util.Map;
-
-public class TestActivity extends Activity {
-  // Add message views
-  private TextView sum;
-
-  private FirebaseFunctions mFunctions;
-  private CountingIdlingResource idlingResource =
-      new CountingIdlingResource("Functions invocation");
-
-  @Override
-  protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-    setContentView(R.layout.test_activity);
-
-    idlingResource.increment();
-
-    sum = findViewById(R.id.sum);
-
-    mFunctions = FirebaseFunctions.getInstance();
-
-    Map<String, Object> data = new HashMap<>();
-    data.put("firstNumber", 10);
-    data.put("secondNumber", 11);
-
-    // Call the function and extract the operation from the result
-    mFunctions
-        .getHttpsCallable("addNumbers")
-        .call(data)
-        .continueWith(
-            new Continuation<HttpsCallableResult, Integer>() {
-              @Override
-              public Integer then(@NonNull Task<HttpsCallableResult> task) {
-                Map<String, Object> result = (Map<String, Object>) task.getResult().getData();
-                return (Integer) result.get("operationResult");
-              }
-            })
-        .addOnSuccessListener(
-            new OnSuccessListener<Integer>() {
-              @Override
-              public void onSuccess(Integer integer) {
-                sum.setText(String.valueOf(integer));
-              }
-            })
-        .addOnCompleteListener(
-            new OnCompleteListener<Integer>() {
-              @Override
-              public void onComplete(@NonNull Task<Integer> task) {
-                idlingResource.decrement();
-              }
-            });
-  }
-
-  @VisibleForTesting
-  @NonNull
-  @Keep
-  public IdlingResource getIdlingResource() {
-    return idlingResource;
-  }
-}
diff --git a/test-apps/functions-test-app/test-proguard-rules.pro b/test-apps/functions-test-app/test-proguard-rules.pro
deleted file mode 100644
index 802ad2841..000000000
--- a/test-apps/functions-test-app/test-proguard-rules.pro
+++ /dev/null
@@ -1,4 +0,0 @@
--keepattributes SourceFile,LineNumberTable
-
--dontwarn org.xmlpull.v1.**
--dontnote org.xmlpull.v1.**
diff --git a/test-apps/functions-test-app/test_setup.sh b/test-apps/functions-test-app/test_setup.sh
deleted file mode 100755
index 5fb4e2e04..000000000
--- a/test-apps/functions-test-app/test_setup.sh
+++ /dev/null
@@ -1,25 +0,0 @@
-#Copyright 2018 Google LLC
-#
-#Licensed under the Apache License, Version 2.0 (the "License");
-#you may not use this file except in compliance with the License.
-#You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-#Unless required by applicable law or agreed to in writing, software
-#distributed under the License is distributed on an "AS IS" BASIS,
-#WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#See the License for the specific language governing permissions and
-#limitations under the License.
-
-#!/bin/bash
-set -o nounset
-set -e
-
-# Install all of the dependencies of the cloud functions
-cd functions
-npm install
-cd ..
-
-# Deploy functions to your Firebase project
-firebase --project="$PROJECT_ID" deploy --only functions
diff --git a/test-apps/gradlew b/test-apps/gradlew
deleted file mode 120000
index 502f5a2d3..000000000
--- a/test-apps/gradlew
+++ /dev/null
@@ -1 +0,0 @@
-../gradlew
\ No newline at end of file
diff --git a/test-apps/storage-test-app/.gitignore b/test-apps/storage-test-app/.gitignore
deleted file mode 100644
index f0c7ca8f6..000000000
--- a/test-apps/storage-test-app/.gitignore
+++ /dev/null
@@ -1,9 +0,0 @@
-.gradle
-local.properties
-.idea
-build/
-.DS_Store
-*.iml
-*.apk
-*.aar
-*.zip
diff --git a/test-apps/storage-test-app/build.gradle b/test-apps/storage-test-app/build.gradle
deleted file mode 100644
index 452af173a..000000000
--- a/test-apps/storage-test-app/build.gradle
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright 2018 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-apply plugin: 'com.android.application'
-
-android {
-    testBuildType = project.testBuildType
-    compileSdkVersion project.targetSdkVersion
-
-    defaultConfig {
-        applicationId "com.google.firebase.testapps.storage"
-        minSdkVersion 16
-        targetSdkVersion project.targetSdkVersion
-        versionCode 1
-        versionName "1.0"
-        multiDexEnabled true
-
-        vectorDrawables.useSupportLibrary true
-
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled true
-            testProguardFiles getDefaultProguardFile('proguard-android.txt'), 'test-proguard-rules.pro'
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-            signingConfig signingConfigs.debug
-        }
-    }
-}
-
-configurations.all {
-    resolutionStrategy.force 'com.android.support:support-annotations:27.1.1'
-}
-
-dependencies {
-    // We intentionally use an open ended version to pick up any SNAPSHOT
-    // versions published to the root project' s build/ directory.
-    implementation 'com.google.firebase:firebase-storage:16+'
-    implementation 'com.google.firebase:firebase-core:16+'
-    implementation 'com.google.firebase:firebase-auth:16+'
-    implementation 'com.android.support.test.espresso:espresso-idling-resource:3.0.2'
-
-    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
-    androidTestImplementation 'com.android.support.test:rules:1.0.2'
-    androidTestImplementation 'com.android.support.test:runner:1.0.2'
-    androidTestImplementation 'com.android.support.test.espresso:espresso-idling-resource:3.0.2'
-}
-
-apply plugin: 'com.google.gms.google-services'
diff --git a/test-apps/storage-test-app/proguard-rules.pro b/test-apps/storage-test-app/proguard-rules.pro
deleted file mode 100644
index 24be176fd..000000000
--- a/test-apps/storage-test-app/proguard-rules.pro
+++ /dev/null
@@ -1,5 +0,0 @@
--keepattributes Exceptions,InnerClasses,Signature,Deprecated,
-                SourceFile,LineNumberTable,*Annotation*,EnclosingMethod
-
--keep class android.support.test.espresso.IdlingResource { *; }
--keep class android.support.test.espresso.IdlingRegistry { *; }
diff --git a/test-apps/storage-test-app/src/androidTest/java/com/google/firebase/testapps/storage/TestActivityTest.java b/test-apps/storage-test-app/src/androidTest/java/com/google/firebase/testapps/storage/TestActivityTest.java
deleted file mode 100644
index daa719d3e..000000000
--- a/test-apps/storage-test-app/src/androidTest/java/com/google/firebase/testapps/storage/TestActivityTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-// Copyright 2018 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.google.firebase.testapps.storage;
-
-import static android.support.test.espresso.Espresso.onView;
-import static android.support.test.espresso.action.ViewActions.*;
-import static android.support.test.espresso.assertion.ViewAssertions.*;
-import static android.support.test.espresso.matcher.ViewMatchers.*;
-
-import android.support.test.espresso.Espresso;
-import android.support.test.espresso.IdlingRegistry;
-import android.support.test.espresso.IdlingResource;
-import android.support.test.rule.ActivityTestRule;
-import android.support.test.runner.AndroidJUnit4;
-import android.support.test.filters.LargeTest;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-@LargeTest
-@RunWith(AndroidJUnit4.class)
-public class TestActivityTest {
-  @Rule
-  public ActivityTestRule<TestActivity> mActivityTestRule =
-      new ActivityTestRule<>(TestActivity.class);
-
-  private IdlingResource mIdlingResource;
-
-  @Before
-  public void before() {
-    mIdlingResource = mActivityTestRule.getActivity().getIdlingResource();
-    // To prove that the test fails, omit this call:
-    IdlingRegistry.getInstance().register(mIdlingResource);
-  }
-
-  @After
-  public void unregisterIdlingResource() {
-    if (mIdlingResource != null) {
-      IdlingRegistry.getInstance().unregister(mIdlingResource);
-    }
-  }
-
-  @Test
-  public void testActivityTest() throws Exception {
-    onView(withId(R.id.restaurant)).check(matches(withText("Google MTV")));
-  }
-}
diff --git a/test-apps/storage-test-app/src/main/java/com/google/firebase/testapps/storage/TestActivity.java b/test-apps/storage-test-app/src/main/java/com/google/firebase/testapps/storage/TestActivity.java
deleted file mode 100644
index 2ec58d8bc..000000000
--- a/test-apps/storage-test-app/src/main/java/com/google/firebase/testapps/storage/TestActivity.java
+++ /dev/null
@@ -1,119 +0,0 @@
-// Copyright 2018 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.google.firebase.testapps.storage;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.support.annotation.Keep;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
-import android.support.test.espresso.IdlingResource;
-import android.support.test.espresso.idling.CountingIdlingResource;
-import android.util.Log;
-import android.widget.TextView;
-import com.google.android.gms.tasks.OnCompleteListener;
-import com.google.android.gms.tasks.Task;
-import com.google.firebase.auth.AuthResult;
-import com.google.firebase.auth.FirebaseAuth;
-import com.google.firebase.storage.FirebaseStorage;
-import com.google.firebase.storage.UploadTask;
-import java.nio.charset.Charset;
-
-public class TestActivity extends Activity {
-  private static final String TAG = TestActivity.class.toString();
-
-  private FirebaseStorage storage;
-  private FirebaseAuth auth;
-  private CountingIdlingResource idlingResource = new CountingIdlingResource("Firebase storage download");
-  private TextView stringTextView;
-
-  @Override
-  protected void onCreate(@Nullable Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-
-    setContentView(R.layout.test_activity);
-
-    storage = FirebaseStorage.getInstance();
-    auth = FirebaseAuth.getInstance();
-
-    stringTextView = this.findViewById(R.id.restaurant);
-
-    idlingResource.increment();
-
-    // Signout of any existing sessions and sign in with email and password
-    auth.signOut();
-
-    auth.signInWithEmailAndPassword("test@mailinator.com", "password")
-        .addOnCompleteListener(
-            new OnCompleteListener<AuthResult>() {
-              @Override
-              public void onComplete(@NonNull Task<AuthResult> task) {
-                if (task.isSuccessful()) {
-                  uploadString();
-                } else {
-                  Log.d(TAG, "Unable to sign in");
-                  idlingResource.decrement();
-                }
-              }
-            });
-  }
-
-  private void uploadString() {
-    storage
-        .getReference()
-        .child("restaurants/Baadal")
-        .putBytes("Google MTV".getBytes(Charset.forName("UTF-8")))
-        .addOnCompleteListener(
-            new OnCompleteListener<UploadTask.TaskSnapshot>() {
-              @Override
-              public void onComplete(@NonNull Task<UploadTask.TaskSnapshot> task) {
-                if (task.isSuccessful()) {
-                  readBytes();
-                } else {
-                  Log.d(TAG, "Failed to upload");
-                  idlingResource.decrement();
-                }
-              }
-            });
-  }
-
-  private void readBytes() {
-    storage
-        .getReference()
-        .child("restaurants/Baadal")
-        .getBytes(1024)
-        .addOnCompleteListener(
-            new OnCompleteListener<byte[]>() {
-              @Override
-              public void onComplete(@NonNull Task<byte[]> task) {
-                if (task.isSuccessful()) {
-                  String s = new String(task.getResult(), Charset.forName("UTF-8"));
-                  stringTextView.setText(s);
-                  idlingResource.decrement();
-                } else {
-                  Log.d(TAG, "Failed to download");
-                }
-              }
-            });
-  }
-
-  @VisibleForTesting
-  @Nullable
-  @Keep
-  public IdlingResource getIdlingResource() {
-    return idlingResource;
-  }
-}
diff --git a/test-apps/storage-test-app/test-proguard-rules.pro b/test-apps/storage-test-app/test-proguard-rules.pro
deleted file mode 100644
index ee5e74b9f..000000000
--- a/test-apps/storage-test-app/test-proguard-rules.pro
+++ /dev/null
@@ -1,4 +0,0 @@
--keepattributes SourceFile,LineNumberTable
-
--dontwarn org.xmlpull.v1.**
--dontnote org.xmlpull.v1.**
\ No newline at end of file
diff --git a/tools/lint/lint.gradle b/tools/lint/lint.gradle
index d22667520..5145f894f 100644
--- a/tools/lint/lint.gradle
+++ b/tools/lint/lint.gradle
@@ -16,7 +16,7 @@ plugins {
   id 'org.jetbrains.kotlin.jvm'
 }
 
-def lintVersion = '26.3.2'
+def lintVersion = '26.4.1'
 
 dependencies {
   compileOnly "com.android.tools.lint:lint-api:$lintVersion"
diff --git a/tools/lint/src/main/kotlin/CheckRegistry.kt b/tools/lint/src/main/kotlin/CheckRegistry.kt
new file mode 100644
index 000000000..b8df4c08c
--- /dev/null
+++ b/tools/lint/src/main/kotlin/CheckRegistry.kt
@@ -0,0 +1,36 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.lint.checks
+
+import com.android.tools.lint.client.api.IssueRegistry
+import com.android.tools.lint.detector.api.CURRENT_API
+import com.android.tools.lint.detector.api.Issue
+
+class CheckRegistry : IssueRegistry() {
+    override val issues: List<Issue>
+        get() = listOf(
+                ManifestElementHasNoExportedAttributeDetector.EXPORTED_MISSING_ISSUE,
+                KotlinInteropDetector.KOTLIN_PROPERTY,
+                KotlinInteropDetector.LAMBDA_LAST,
+                KotlinInteropDetector.NO_HARD_KOTLIN_KEYWORDS,
+                KotlinInteropDetector.PLATFORM_NULLNESS,
+                NonAndroidxNullabilityDetector.NON_ANDROIDX_NULLABILITY
+        )
+
+    override val api: Int
+        get() = CURRENT_API
+    override val minApi: Int
+        get() = 2
+}
diff --git a/tools/lint/src/main/kotlin/KotlinInteropDetector.kt b/tools/lint/src/main/kotlin/KotlinInteropDetector.kt
new file mode 100644
index 000000000..1ed75f45c
--- /dev/null
+++ b/tools/lint/src/main/kotlin/KotlinInteropDetector.kt
@@ -0,0 +1,727 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.lint.checks
+
+import com.android.tools.lint.client.api.UElementHandler
+import com.android.tools.lint.detector.api.Category
+import com.android.tools.lint.detector.api.Detector
+import com.android.tools.lint.detector.api.Implementation
+import com.android.tools.lint.detector.api.Issue
+import com.android.tools.lint.detector.api.JavaContext
+import com.android.tools.lint.detector.api.LintFix
+import com.android.tools.lint.detector.api.Location
+import com.android.tools.lint.detector.api.Scope
+import com.android.tools.lint.detector.api.Severity
+import com.android.tools.lint.detector.api.SourceCodeScanner
+import com.android.tools.lint.detector.api.isKotlin
+import com.intellij.psi.PsiClassType
+import com.intellij.psi.PsiCompiledElement
+import com.intellij.psi.PsiDocCommentOwner
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiJavaDocumentedElement
+import com.intellij.psi.PsiKeyword
+import com.intellij.psi.PsiMember
+import com.intellij.psi.PsiMethod
+import com.intellij.psi.PsiModifier
+import com.intellij.psi.PsiPackage
+import com.intellij.psi.PsiPrimitiveType
+import com.intellij.psi.PsiType
+import com.intellij.psi.PsiTypeParameter
+import com.intellij.psi.search.GlobalSearchScope
+import org.jetbrains.uast.UAnonymousClass
+import org.jetbrains.uast.UClass
+import org.jetbrains.uast.UDeclaration
+import org.jetbrains.uast.UElement
+import org.jetbrains.uast.UField
+import org.jetbrains.uast.UMethod
+import org.jetbrains.uast.UParameter
+import org.jetbrains.uast.UVariable
+import org.jetbrains.uast.getContainingUClass
+import org.jetbrains.uast.getContainingUMethod
+import org.jetbrains.uast.getParentOfType
+
+class KotlinInteropDetector : Detector(), SourceCodeScanner {
+    companion object Issues {
+        private val IMPLEMENTATION = Implementation(
+                KotlinInteropDetector::class.java,
+                Scope.JAVA_FILE_SCOPE
+        )
+
+        const val IGNORE_DEPRECATED = false
+
+        @JvmField
+        val NO_HARD_KOTLIN_KEYWORDS = Issue.create(
+                id = "FirebaseNoHardKeywords",
+                briefDescription = "No Hard Kotlin Keywords",
+
+                explanation = """
+            Do not use Kotlins hard keywords as the name of methods or fields.
+            These require the use of backticks to escape when calling from Kotlin.
+            Soft keywords, modifier keywords, and special identifiers are allowed.
+
+            For example, Mockitos `when` function requires backticks when used from Kotlin:
+
+                val callable = Mockito.mock(Callable::class.java)
+                Mockito.\`when\`(callable.call()).thenReturn(/*  */)
+            """,
+                category = Category.INTEROPERABILITY_KOTLIN,
+                priority = 1,
+                severity = Severity.ERROR,
+                implementation = IMPLEMENTATION
+        )
+
+        @JvmField
+        val LAMBDA_LAST = Issue.create(
+                id = "FirebaseLambdaLast",
+                briefDescription = "Lambda Parameters Last",
+
+                explanation = """
+            To improve calling this code from Kotlin,
+            parameter types eligible for SAM conversion should be last.
+            """,
+                category = Category.INTEROPERABILITY_KOTLIN,
+                priority = 1,
+                severity = Severity.ERROR,
+                implementation = IMPLEMENTATION
+        )
+
+        @JvmField
+        val PLATFORM_NULLNESS = Issue.create(
+                id = "FirebaseUnknownNullness",
+                briefDescription = "Unknown nullness",
+
+                explanation = """
+            To improve referencing this code from Kotlin, consider adding
+            explicit nullness information here with either `@NonNull` or `@Nullable`.
+            """,
+                category = Category.INTEROPERABILITY_KOTLIN,
+                priority = 1,
+                severity = Severity.ERROR,
+                implementation = IMPLEMENTATION
+        )
+
+        @JvmField
+        val KOTLIN_PROPERTY = Issue.create(
+                id = "FirebaseKotlinPropertyAccess",
+                briefDescription = "Kotlin Property Access",
+
+                explanation = """
+            For a method to be represented as a property in Kotlin, strict bean-style prefixing must be used.
+
+            Accessor methods require a get prefix or for boolean-returning methods an is prefix can be used.
+            """,
+                category = Category.INTEROPERABILITY_KOTLIN,
+                priority = 1,
+                severity = Severity.ERROR,
+                implementation = IMPLEMENTATION
+        )
+
+        private fun isKotlinHardKeyword(keyword: String): Boolean {
+            // From https://github.com/JetBrains/kotlin/blob/master/core/descriptors/src/org/jetbrains/kotlin/renderer/KeywordStringsGenerated.java
+            when (keyword) {
+                "as",
+                "break",
+                "class",
+                "continue",
+                "do",
+                "else",
+                "false",
+                "for",
+                "fun",
+                "if",
+                "in",
+                "interface",
+                "is",
+                "null",
+                "object",
+                "package",
+                "return",
+                "super",
+                "this",
+                "throw",
+                "true",
+                "try",
+                "typealias",
+                "typeof",
+                "val",
+                "var",
+                "when",
+                "while"
+                -> return true
+            }
+
+            return false
+        }
+    }
+
+    override fun getApplicableUastTypes(): List<Class<out UElement>>? {
+        return listOf(UMethod::class.java, UField::class.java)
+    }
+
+    override fun createUastHandler(context: JavaContext): UElementHandler? {
+        // using deprecated psi field here instead of sourcePsi because the IDE
+        // still uses older version of UAST
+        if (isKotlin(context.uastFile?.sourcePsi)) {
+            // These checks apply only to Java code
+            return null
+        }
+        return JavaVisitor(context)
+    }
+
+    class JavaVisitor(private val context: JavaContext) : UElementHandler() {
+        private val checkForKeywords = true
+        private val checkNullness = true
+        private val checkLambdaLast = true
+        private val checkPropertyAccess = true
+
+        override fun visitMethod(node: UMethod) {
+            if (isPublicApi(node)) {
+                val methodName = node.name
+
+                if (checkForKeywords) {
+                    ensureNonKeyword(methodName, node, "method")
+                }
+
+                if (checkPropertyAccess && isLikelySetter(methodName, node)) {
+                    ensureValidProperty(node, methodName)
+                }
+
+                if (checkLambdaLast) {
+                    ensureLambdaLastParameter(node)
+                }
+
+                if (checkNullness) {
+                    val type = node.returnType
+                    if (type != null) { // not a constructor
+                        ensureNullnessKnown(node, type)
+                    }
+                    for (parameter in node.uastParameters) {
+                        ensureNullnessKnown(parameter, parameter.type)
+                    }
+                }
+            }
+        }
+
+        override fun visitField(node: UField) {
+            if (isPublicApi(node)) {
+                if (checkForKeywords) {
+                    ensureNonKeyword(node.name, node, "field")
+                }
+                if (checkNullness) {
+                    ensureNullnessKnown(node, node.type)
+                }
+            }
+        }
+
+        private fun isLikelySetter(
+            methodName: String,
+            node: UMethod
+        ): Boolean {
+            return methodName.startsWith("set") && methodName.length > 3 &&
+                    Character.isUpperCase(methodName[3]) &&
+                    node.uastParameters.size == 1 &&
+                    context.evaluator.isPublic(node) &&
+                    !context.evaluator.isStatic(node)
+        }
+
+        private fun isPublicApi(node: UDeclaration): Boolean {
+            if (!isJavaPublic(node)) {
+                return false
+            }
+            if (node is PsiJavaDocumentedElement) {
+                node.docComment?.findTagByName("hide")?.let {
+                    return false
+                }
+            }
+
+            if (node is PsiMember) {
+                var curNode = node.containingClass
+                while (curNode != null) {
+                    curNode.docComment?.findTagByName("hide")?.let {
+                        return false
+                    }
+                    curNode = curNode.containingClass
+                }
+            }
+
+            val psiPackage: PsiPackage = context.evaluator.getPackage(node as PsiElement)!!
+            psiPackage.getFiles(GlobalSearchScope.projectScope(psiPackage.project)).find {
+                it.name == "package-info.java"
+            }?.let {
+                if (it.viewProvider.contents.toString().matches(Regex(".*/\\*\\*.*@hide.*\\*/.*\n\\s*package.*", RegexOption.DOT_MATCHES_ALL))) {
+                    return false
+                }
+            }
+
+            return true
+        }
+
+        private fun isJavaPublic(node: UDeclaration): Boolean {
+            val evaluator = context.evaluator
+            if (evaluator.isPublic(node) || evaluator.isProtected(node)) {
+                val cls = node.getParentOfType<UClass>(UClass::class.java) ?: return true
+                return evaluator.isPublic(cls) && cls !is UAnonymousClass
+            }
+
+            return false
+        }
+
+        private fun ensureValidProperty(setter: UMethod, methodName: String) {
+            val cls = setter.getContainingUClass() ?: return
+            val propertySuffix = methodName.substring(3)
+            val propertyName = propertySuffix.decapitalize()
+            val getterName1 = "get$propertySuffix"
+            val getterName2 = "is$propertySuffix"
+            val badGetterName = "has$propertySuffix"
+            var getter: PsiMethod? = null
+            var badGetter: UMethod? = null
+            cls.methods.forEach {
+                if (it.parameters.isEmpty()) {
+                    val name = it.name
+                    if (name == getterName1 || name == getterName2) {
+                        getter = it
+                    } else if ((name == badGetterName || name == propertyName ||
+                                    name.endsWith(propertySuffix)) &&
+                            context.evaluator.isPublic(it) &&
+                            !it.isConstructor &&
+                            it.returnType == setter.uastParameters.firstOrNull()?.type
+                    ) {
+                        badGetter = it
+                    }
+                }
+            }
+
+            if (getter == null) {
+                // Look for inherited methods
+                cls.superClass?.let { superClass ->
+                    for (inherited in superClass.findMethodsByName(getterName1, true)) {
+                        if (inherited.parameterList.parametersCount == 0) {
+                            getter = inherited
+                            break
+                        }
+                    }
+                    if (getter == null) {
+                        for (inherited in superClass.findMethodsByName(getterName2, true)) {
+                            if (inherited.parameterList.parametersCount == 0) {
+                                getter = inherited
+                                break
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (getter != null && getter !is PsiCompiledElement) {
+                @Suppress("NAME_SHADOWING") // compiler gets confused about getter nullness
+                val getter: PsiMethod = getter!!
+
+                // enforce public and not static
+                if (!context.evaluator.isPublic(getter)) {
+                    val message = "This getter should be public such that `$propertyName` can " +
+                            "be accessed as a property from Kotlin; see https://android.github.io/kotlin-guides/interop.html#property-prefixes"
+                    val location = context.getNameLocation(getter)
+                    context.report(KOTLIN_PROPERTY, getter, location, message)
+                    return
+                }
+
+                if (context.evaluator.isStatic(getter)) {
+                    var staticElement: PsiElement? = null
+                    val modifierList = getter.modifierList
+                    // Try to find the static modifier itself
+                    if (modifierList.hasExplicitModifier(PsiModifier.STATIC)) {
+                        var child: PsiElement? = modifierList.firstChild
+                        while (child != null) {
+                            if (child is PsiKeyword && PsiKeyword.STATIC == child.text) {
+                                staticElement = child
+                                break
+                            }
+                            child = child.nextSibling
+                        }
+                    }
+                    val location = if (staticElement != null) {
+                        context.getLocation(staticElement)
+                    } else {
+                        context.getNameLocation(getter)
+                    }
+                    val message =
+                            "This getter should not be static such that `$propertyName` can " +
+                                    "be accessed as a property from Kotlin; see https://android.github.io/kotlin-guides/interop.html#property-prefixes"
+                    context.report(
+                            KOTLIN_PROPERTY,
+                            location.source as? PsiElement ?: setter, location, message
+                    )
+                    return
+                }
+
+                val setterParameterType = setter.uastParameters.first().type
+                if (setterParameterType != getter.returnType &&
+                        !hasSetter(cls, getter.returnType, setter.name) &&
+                        !isTypeVariableReference(setterParameterType)
+                ) {
+                    val message =
+                            "The getter return type (`${getter.returnType?.presentableText}`) and setter parameter type (`${setterParameterType.presentableText}`) getter and setter methods for property `$propertyName` should have exactly the same type to allow " +
+                                    "be accessed as a property from Kotlin; see https://android.github.io/kotlin-guides/interop.html#property-prefixes"
+                    val location = getPropertyLocation(getter, setter)
+                    context.report(
+                            KOTLIN_PROPERTY,
+                            location.source as? PsiElement ?: setter, location, message
+                    )
+                    return
+                }
+
+                // Make sure that if the getter is inherited, it has the same return type
+                for (superMethod in getter.findSuperMethods()) {
+                    if (superMethod.containingClass?.isInterface != true) {
+                        val superReturnType = superMethod.returnType ?: return
+                        val getterType = getter.returnType
+                        if (superReturnType != getterType) {
+                            val message =
+                                    "The getter return type (`${getterType?.presentableText}`)" +
+                                            " is not the same as the setter return type " +
+                                            "(`${superReturnType.presentableText}`); they should have " +
+                                            "exactly the same type to allow " +
+                                            "`${propertySuffix.decapitalize()}` " +
+                                            "be accessed as a property from Kotlin; see " +
+                                            "https://android.github.io/kotlin-guides/interop.html#property-prefixes"
+                            val location = getPropertyLocation(getter, setter)
+                            context.report(
+                                    KOTLIN_PROPERTY,
+                                    location.source as? PsiElement ?: setter, location, message
+                            )
+                            return
+                        }
+                    }
+                }
+            } else if (badGetter != null &&
+                    // Don't complain about overrides; we can't rename those
+                    !badGetter!!.findSuperMethods().any() &&
+                    // Don't complain if the matched bad getter method already has its own
+                    // match
+                    run {
+                        val matchingName =
+                                "set${badGetter!!.name.removePrefix("is").removePrefix("get").removePrefix("has")}"
+
+                        methodName == matchingName || cls.methods.none { it.name == matchingName }
+                    }
+            ) {
+                val name1 = badGetter!!.name
+                if (name1.startsWith("is") && methodName.startsWith("setIs") &&
+                        name1[2].isUpperCase()
+                ) {
+                    val newProperty = name1[2].toLowerCase() + name1.substring(3)
+                    val message =
+                            "This method should be called `set${newProperty.capitalize()}` such " +
+                                    "that (along with the `$name1` getter) Kotlin code can access it " +
+                                    "as a property (`$newProperty`); see " +
+                                    "https://android.github.io/kotlin-guides/interop.html#property-prefixes"
+                    val location = context.getNameLocation(setter)
+                    context.report(KOTLIN_PROPERTY, setter, location, message)
+                    return
+                }
+
+                val location = context.getNameLocation(badGetter!!)
+                val message =
+                        "This method should be called `get$propertySuffix` such that `$propertyName` can " +
+                                "be accessed as a property from Kotlin; see https://android.github.io/kotlin-guides/interop.html#property-prefixes"
+                context.report(KOTLIN_PROPERTY, badGetter, location, message)
+            }
+        }
+
+        private fun isTypeVariableReference(type: PsiType): Boolean {
+            if (type is PsiClassType) {
+                val cls = type.resolve() ?: return false
+                return cls is PsiTypeParameter
+            } else {
+                return false
+            }
+        }
+
+        /** Returns true if the given class has a (possibly inherited) setter of the given type */
+        private fun hasSetter(cls: UClass, type: PsiType?, setterName: String): Boolean {
+            for (method in cls.findMethodsByName(setterName, true)) {
+                val parameterList = method.parameterList
+                val parameters = parameterList.parameters
+                if (parameters.size == 1 && parameters[0].type == type) {
+                    return true
+                }
+            }
+
+            return false
+        }
+
+        private fun getPropertyLocation(
+            location1: PsiMethod,
+            location2: PsiMethod
+        ): Location {
+            val primary: PsiMethod
+            val secondary: PsiMethod
+
+            if (location1 is PsiCompiledElement) {
+                primary = location2
+                secondary = location1
+            } else {
+                primary = location1
+                secondary = location2
+            }
+
+            return context.getNameLocation(primary).withSecondary(
+                    context.getNameLocation(secondary),
+                    "${if (secondary.name.startsWith("set")) "Setter" else "Getter"} here"
+            )
+        }
+
+        private fun ensureNullnessKnown(
+            node: UDeclaration,
+            type: PsiType
+        ) {
+            if (type is PsiPrimitiveType) {
+                return
+            }
+            if (node is UField &&
+                    node.modifierList?.hasModifierProperty(PsiModifier.FINAL) == true) {
+                return
+            }
+            for (annotation in node.annotations) {
+                val name = annotation.qualifiedName ?: continue
+
+                if (isNullableAnnotation(name)) {
+                    if (isToStringMethod(node)) {
+                        val location = context.getLocation(annotation)
+                        val message = "Unexpected `@Nullable`: `toString` should never return null"
+                        context.report(PLATFORM_NULLNESS, node as UElement, location, message)
+                    }
+                    return
+                }
+
+                if (isNonNullAnnotation(name)) {
+                    if (isEqualsParameter(node)) {
+                        val location = context.getLocation(annotation)
+                        val message =
+                                "Unexpected @NonNull: The `equals` contract allows the parameter to be null"
+                        context.report(PLATFORM_NULLNESS, node as UElement, location, message)
+                    }
+                    return
+                }
+            }
+
+            // Known nullability: don't complain
+            if (isEqualsParameter(node) || isToStringMethod(node) || isVarargParameter(node)) {
+                return
+            }
+
+            // Annotation members cannot be null
+            if (node is UMethod) {
+                node.getContainingUClass()?.let {
+                    if (it.isAnnotationType) {
+                        return
+                    }
+                }
+            }
+
+            // Skip deprecated members?
+            if (IGNORE_DEPRECATED) {
+                val deprecatedNode =
+                        if (node is UParameter) {
+                            node.uastParent
+                        } else {
+                            node
+                        }
+                if ((deprecatedNode?.sourcePsi as? PsiDocCommentOwner)?.isDeprecated == true) {
+                    return
+                }
+                var curr = deprecatedNode
+                while (curr != null) {
+                    curr = curr.getContainingUClass() ?: break
+                    if ((curr.sourcePsi as? PsiDocCommentOwner)?.isDeprecated == true) {
+                        return
+                    }
+                }
+            }
+
+            val location: Location =
+                    when (node) {
+                        is UVariable -> // UParameter, UField
+                            context.getLocation(node.typeReference ?: return)
+                        is UMethod -> context.getLocation(node.returnTypeElement ?: return)
+                        else -> return
+                    }
+            val replaceLocation = if (node is UParameter) {
+                location
+            } else if (node is UMethod && node.modifierList != null) {
+                // Place the insertion point at the modifiers such that we don't
+                // insert the annotation for example after the "public" keyword.
+                // We also don't want to place it on the method range itself since
+                // that would place it before the method comments.
+                context.getLocation(node.modifierList)
+            } else if (node is UField && node.modifierList != null) {
+                // Ditto for fields
+                context.getLocation(node.modifierList!!)
+            } else {
+                return
+            }
+            val message = "Unknown nullability; explicitly declare as `@Nullable` or `@NonNull`" +
+                    " to improve Kotlin interoperability; see " +
+                    "https://android.github.io/kotlin-guides/interop.html#nullability-annotations"
+            val fix = LintFix.create().alternatives(
+                    LintFix.create()
+                            .replace()
+                            .name("Annotate @NonNull")
+                            .range(replaceLocation)
+                            .beginning()
+                            .shortenNames()
+                            .reformat(true)
+                            .with("$nonNullAnnotation ")
+                            .build(),
+                    LintFix.create()
+                            .replace()
+                            .name("Annotate @Nullable")
+                            .range(replaceLocation)
+                            .beginning()
+                            .shortenNames()
+                            .reformat(true)
+                            .with("$nullableAnnotation ")
+                            .build()
+            )
+            context.report(PLATFORM_NULLNESS, node as UElement, location, message, fix)
+        }
+
+        private fun isEqualsParameter(node: UDeclaration): Boolean {
+            if (node is UParameter) {
+                val method = node.getContainingUMethod() ?: return false
+                if (method.name == "equals" && method.uastParameters.size == 1) {
+                    return true
+                }
+            }
+
+            return false
+        }
+
+        private fun isVarargParameter(node: UDeclaration): Boolean {
+            return node is UParameter && node.isVarArgs
+        }
+
+        private fun isToStringMethod(node: UDeclaration): Boolean {
+            if (node is UMethod) {
+                val method = node
+                if (method.name == "toString" && method.uastParameters.isEmpty()) {
+                    return true
+                }
+            }
+
+            return false
+        }
+
+        private var nonNullAnnotation: String = "@androidx.annotation.NonNull"
+        private var nullableAnnotation: String? = "@androidx.annotation.Nullable"
+
+        private fun isNullableAnnotation(qualifiedName: String): Boolean {
+            return qualifiedName.endsWith("Nullable")
+        }
+
+        private fun isNonNullAnnotation(qualifiedName: String): Boolean {
+            return qualifiedName.endsWith("NonNull") ||
+                    qualifiedName.endsWith("NotNull") ||
+                    qualifiedName.endsWith("Nonnull")
+        }
+
+        private fun ensureNonKeyword(name: String, node: UDeclaration, typeLabel: String) {
+            if (isKotlinHardKeyword(name)) {
+                // See if this method is overriding some other method; in that case
+                // we don't have a choice here.
+                if (node is UMethod && context.evaluator.isOverride(node)) {
+                    return
+                }
+                val message =
+                        "Avoid $typeLabel names that are Kotlin hard keywords (\"$name\"); see " +
+                                "https://android.github.io/kotlin-guides/interop.html#no-hard-keywords"
+                context.report(
+                        NO_HARD_KOTLIN_KEYWORDS,
+                        node as UElement,
+                        context.getNameLocation(node as UElement),
+                        message
+                )
+            }
+        }
+
+        private fun ensureLambdaLastParameter(method: UMethod) {
+            val parameters = method.uastParameters
+            if (parameters.size > 1) {
+                // Make sure that SAM-compatible parameters are last
+                val lastIndex = parameters.size - 1
+                if (!isFunctionalInterface(parameters[lastIndex].type)) {
+                    for (i in lastIndex - 1 downTo 0) {
+                        val parameter = parameters[i]
+                        if (isFunctionalInterface(parameter.type)) {
+                            val message =
+                                    "Functional interface parameters (such as parameter ${i + 1}, \"${parameter.name}\", in ${
+                                    method.containingClass?.qualifiedName}.${method.name
+                                    }) should be last to improve Kotlin interoperability; see " +
+                                            "https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions"
+                            context.report(
+                                    LAMBDA_LAST,
+                                    method,
+                                    context.getLocation(parameters[lastIndex] as UElement),
+                                    message
+                            )
+                            break
+                        }
+                    }
+                }
+            }
+        }
+
+        private fun isFunctionalInterface(type: PsiType): Boolean {
+            if (type !is PsiClassType) {
+                return false
+            }
+
+            val cls = type.resolve() ?: return false
+            if (!cls.isInterface) {
+                return false
+            }
+
+            var abstractCount = 0
+            for (method in cls.methods) {
+                if (method.modifierList.hasModifierProperty(PsiModifier.ABSTRACT)) {
+                    abstractCount++
+                }
+            }
+
+            if (abstractCount != 1) {
+                // Try a little harder; we don't want to count methods that are overrides
+                if (abstractCount > 1) {
+                    abstractCount = 0
+                    for (method in cls.methods) {
+                        if (method.modifierList.hasModifierProperty(PsiModifier.ABSTRACT) &&
+                                !context.evaluator.isOverride(method, true)
+                        ) {
+                            abstractCount++
+                        }
+                    }
+                }
+
+                if (abstractCount != 1) {
+                    return false
+                }
+            }
+
+            if (cls.superClass?.isInterface == true) {
+                return false
+            }
+
+            return true
+        }
+    }
+}
\ No newline at end of file
diff --git a/tools/lint/src/main/kotlin/LintChecks.kt b/tools/lint/src/main/kotlin/ManifestElementHasNoExportedAttributeDetector.kt
similarity index 64%
rename from tools/lint/src/main/kotlin/LintChecks.kt
rename to tools/lint/src/main/kotlin/ManifestElementHasNoExportedAttributeDetector.kt
index 0d533e9fb..b22bb7cde 100644
--- a/tools/lint/src/main/kotlin/LintChecks.kt
+++ b/tools/lint/src/main/kotlin/ManifestElementHasNoExportedAttributeDetector.kt
@@ -15,8 +15,6 @@
 package com.google.firebase.lint.checks
 
 import com.android.SdkConstants
-import com.android.tools.lint.client.api.IssueRegistry
-import com.android.tools.lint.detector.api.CURRENT_API
 import com.android.tools.lint.detector.api.Category
 import com.android.tools.lint.detector.api.Detector
 import com.android.tools.lint.detector.api.Implementation
@@ -27,35 +25,27 @@ import com.android.tools.lint.detector.api.XmlContext
 import com.android.tools.lint.detector.api.XmlScanner
 import org.w3c.dom.Element
 
-class CheckRegistry : IssueRegistry() {
-    override val issues: List<Issue>
-        get() = listOf(EXPORTED_MISSING_ISSUE)
-
-    override val api: Int
-        get() = CURRENT_API
-    override val minApi: Int
-        get() = 2
-}
-
-internal val EXPORTED_MISSING_ISSUE: Issue = Issue.create(
-        "ManifestElementHasNoExportedAttribute",
-        "`android:exported` attribute missing on element",
-        "Leaving this attribute out may unintentionally lead to an exported component, please " +
-                "specify the value explicitly.",
-        Category.SECURITY,
-        1,
-        Severity.ERROR,
-        Implementation(ManifestElementHasNoExportedAttributeDetector::class.java, Scope.MANIFEST_SCOPE))
+class ManifestElementHasNoExportedAttributeDetector : Detector(), XmlScanner {
 
-enum class Component(val xmlName: String) {
-    ACTIVITY("activity"),
-    ACTIVITY_ALIAS("activity-alias"),
-    PROVIDER("provider"),
-    RECEIVER("receiver"),
-    SERVICE("service"),
-}
+    enum class Component(val xmlName: String) {
+        ACTIVITY("activity"),
+        ACTIVITY_ALIAS("activity-alias"),
+        PROVIDER("provider"),
+        RECEIVER("receiver"),
+        SERVICE("service"),
+    }
 
-class ManifestElementHasNoExportedAttributeDetector : Detector(), XmlScanner {
+    companion object {
+        internal val EXPORTED_MISSING_ISSUE: Issue = Issue.create(
+                "ManifestElementHasNoExportedAttribute",
+                "`android:exported` attribute missing on element",
+                "Leaving this attribute out may unintentionally lead to an exported component, please " +
+                        "specify the value explicitly.",
+                Category.SECURITY,
+                1,
+                Severity.ERROR,
+                Implementation(ManifestElementHasNoExportedAttributeDetector::class.java, Scope.MANIFEST_SCOPE))
+    }
 
     override fun getApplicableElements(): Collection<String>? = Component.values().map { it.xmlName }
 
diff --git a/tools/lint/src/main/kotlin/NonAndroidxNullabilityDetector.kt b/tools/lint/src/main/kotlin/NonAndroidxNullabilityDetector.kt
new file mode 100644
index 000000000..00baa2f6e
--- /dev/null
+++ b/tools/lint/src/main/kotlin/NonAndroidxNullabilityDetector.kt
@@ -0,0 +1,130 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.lint.checks
+
+import com.android.tools.lint.client.api.UElementHandler
+import com.android.tools.lint.detector.api.Category
+import com.android.tools.lint.detector.api.Detector
+import com.android.tools.lint.detector.api.Implementation
+import com.android.tools.lint.detector.api.Issue
+import com.android.tools.lint.detector.api.JavaContext
+import com.android.tools.lint.detector.api.LintFix
+import com.android.tools.lint.detector.api.Scope
+import com.android.tools.lint.detector.api.Severity
+import com.android.tools.lint.detector.api.SourceCodeScanner
+import com.android.tools.lint.detector.api.isKotlin
+import org.jetbrains.uast.UAnnotation
+import org.jetbrains.uast.UClass
+import org.jetbrains.uast.UDeclaration
+import org.jetbrains.uast.UElement
+import org.jetbrains.uast.UField
+import org.jetbrains.uast.UMethod
+
+private val NULLABLE_ANNOTATIONS = listOf("Nullable", "CheckForNull")
+private val NOT_NULL_ANNOTATIONS = listOf("NonNull", "NotNull", "Nonnull")
+
+private val ANDROIDX_ANNOTATIONS = listOf(
+        "androidx.annotation.Nullable",
+        "androidx.annotation.NonNull",
+        "android.support.annotation.Nullable",
+        "android.support.annotation.NonNull")
+
+class NonAndroidxNullabilityDetector : Detector(), SourceCodeScanner {
+    companion object Issues {
+        private val IMPLEMENTATION = Implementation(
+                NonAndroidxNullabilityDetector::class.java,
+                Scope.JAVA_FILE_SCOPE
+        )
+
+        @JvmField
+        val NON_ANDROIDX_NULLABILITY = Issue.create(
+                id = "FirebaseNonAndroidxNullability",
+                briefDescription = "Use androidx nullability annotations.",
+
+                explanation = "Use androidx nullability annotations instead.",
+                category = Category.COMPLIANCE,
+                priority = 1,
+                severity = Severity.ERROR,
+                enabledByDefault = false,
+                implementation = IMPLEMENTATION
+        )
+    }
+
+    override fun getApplicableUastTypes(): List<Class<out UElement>>? {
+        return listOf(UClass::class.java, UMethod::class.java, UField::class.java)
+    }
+
+    override fun createUastHandler(context: JavaContext): UElementHandler? {
+        // using deprecated psi field here instead of sourcePsi because the IDE
+        // still uses older version of UAST
+        if (isKotlin(context.uastFile?.sourcePsi)) {
+            // These checks apply only to Java code
+            return null
+        }
+        return Visitor(context)
+    }
+
+    class Visitor(private val context: JavaContext) : UElementHandler() {
+        override fun visitClass(node: UClass) {
+            doVisit(node)
+        }
+
+        override fun visitMethod(node: UMethod) {
+            doVisit(node)
+            for (parameter in node.uastParameters) {
+                doVisit(parameter)
+            }
+        }
+
+        override fun visitField(node: UField) {
+            doVisit(node)
+        }
+
+        private fun doVisit(node: UDeclaration) {
+            for (annotation in node.annotations) {
+                ensureAndroidNullability(context, annotation)
+            }
+        }
+
+        private fun ensureAndroidNullability(context: JavaContext, annotation: UAnnotation) {
+            val name = annotation.qualifiedName ?: return
+
+            val simpleName = name.split('.').last()
+
+            if (!isNullabilityAnnotation(simpleName) || name in ANDROIDX_ANNOTATIONS) {
+                return
+            }
+
+            val replacement = if (simpleName in NOT_NULL_ANNOTATIONS) "NonNull" else "Nullable"
+            val replacementAnnotation = "@androidx.annotation.$replacement"
+
+            val fix = LintFix.create()
+                    .replace()
+                    .name("Replace with $replacementAnnotation")
+                    .range(context.getLocation(annotation))
+                    .all()
+                    .shortenNames()
+                    .reformat(true)
+                    .with(replacementAnnotation)
+                    .build()
+
+            context.report(NON_ANDROIDX_NULLABILITY, context.getLocation(annotation),
+                    "Use androidx nullability annotations.", fix)
+        }
+
+        private fun isNullabilityAnnotation(name: String): Boolean =
+                name in NULLABLE_ANNOTATIONS || name in NOT_NULL_ANNOTATIONS
+    }
+}
\ No newline at end of file
diff --git a/tools/lint/src/test/kotlin/AndroidxNullabilityTests.kt b/tools/lint/src/test/kotlin/AndroidxNullabilityTests.kt
new file mode 100644
index 000000000..f101e6c68
--- /dev/null
+++ b/tools/lint/src/test/kotlin/AndroidxNullabilityTests.kt
@@ -0,0 +1,130 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.lint.checks
+
+import com.android.tools.lint.checks.infrastructure.LintDetectorTest
+import com.android.tools.lint.detector.api.Detector
+import com.android.tools.lint.detector.api.Issue
+
+private const val EXPECTED_ERROR = "Use androidx nullability annotations"
+private const val NO_WARNINGS = "No warnings."
+
+private fun annotationSource(pkg: String, name: String): String {
+    return """
+        package $pkg;
+
+        public @interface $name {}
+    """.trimIndent()
+}
+
+private fun javaxAnnotation(name: String): String {
+    return annotationSource("javax.annotation", name)
+}
+
+private fun androidxAnnotation(name: String): String {
+    return annotationSource("androidx.annotation", name)
+}
+
+private val JAVAX_NULLABLE_CLASS = """
+    import javax.annotation.Nullable;
+    @Nullable
+    class Foo {}
+""".trimIndent()
+
+private val ANDROIDX_NULLABLE_CLASS = """
+    import androidx.annotation.Nullable;
+    @Nullable
+    class Foo {}
+""".trimIndent()
+
+private val JAVAX_NULLABLE_METHOD = """
+    import javax.annotation.Nullable;
+
+    class Foo {
+      @Nullable String hello() { return null; }
+    }
+""".trimIndent()
+
+private val ANDROIDX_NULLABLE_METHOD = """
+    import androidx.annotation.Nullable;
+
+    class Foo {
+      @Nullable String hello() { return null; }
+    }
+""".trimIndent()
+
+private val JAVAX_NON_NULL_METHOD_PARAMETER = """
+    import javax.annotation.Nonnull;
+
+    class Foo {
+      String hello(@Nonnull String bar) { return null; }
+    }
+""".trimIndent()
+
+private val ANDROIDX_NON_NULL_METHOD_PARAMETER = """
+    import androidx.annotation.NonNull;
+
+    class Foo {
+      String hello(@NonNull String bar) { return null; }
+    }
+""".trimIndent()
+
+class AndroidxNullabilityTests : LintDetectorTest() {
+    override fun getDetector(): Detector = NonAndroidxNullabilityDetector()
+
+    override fun getIssues(): MutableList<Issue> =
+            mutableListOf(NonAndroidxNullabilityDetector.NON_ANDROIDX_NULLABILITY)
+
+    fun testJavaxAnnotatedNullableClass() {
+        lint().files(java(JAVAX_NULLABLE_CLASS), java(javaxAnnotation("Nullable")))
+                .run()
+                .checkContains(EXPECTED_ERROR)
+    }
+
+    fun testAndroidxAnnotatedNullableClass() {
+        lint().files(
+                java(ANDROIDX_NULLABLE_CLASS), java(androidxAnnotation("Nullable")))
+                .run()
+                .checkContains(NO_WARNINGS)
+    }
+
+    fun testJavaxAnnotatedNullableMethod() {
+        lint().files(
+                java(JAVAX_NULLABLE_METHOD), java(javaxAnnotation("Nullable")))
+                .run()
+                .checkContains(EXPECTED_ERROR)
+    }
+
+    fun testAndroidxAnnotatedNullableMethod() {
+        lint().files(
+                java(ANDROIDX_NULLABLE_METHOD), java(androidxAnnotation("Nullable")))
+                .run()
+                .checkContains(NO_WARNINGS)
+    }
+
+    fun testJavaxAnnotatedNonNullMethodParameter() {
+        lint().files(
+                java(JAVAX_NON_NULL_METHOD_PARAMETER), java(javaxAnnotation("Nonnull")))
+                .run()
+                .checkContains(EXPECTED_ERROR)
+    }
+
+    fun testAndroidxAnnotatedNonNullMethodParameter() {
+        lint().files(
+                java(ANDROIDX_NON_NULL_METHOD_PARAMETER), java(androidxAnnotation("NonNull")))
+                .run()
+                .checkContains(NO_WARNINGS)
+    }
+}
diff --git a/tools/lint/src/test/kotlin/LintChecksTest.kt b/tools/lint/src/test/kotlin/ManifestTests.kt
similarity index 94%
rename from tools/lint/src/test/kotlin/LintChecksTest.kt
rename to tools/lint/src/test/kotlin/ManifestTests.kt
index ea47da481..25f3316b1 100644
--- a/tools/lint/src/test/kotlin/LintChecksTest.kt
+++ b/tools/lint/src/test/kotlin/ManifestTests.kt
@@ -19,6 +19,7 @@ import com.android.tools.lint.checks.infrastructure.TestLintResult
 import com.android.tools.lint.checks.infrastructure.TestResultChecker
 import com.android.tools.lint.detector.api.Detector
 import com.android.tools.lint.detector.api.Issue
+import com.google.firebase.lint.checks.ManifestElementHasNoExportedAttributeDetector.Component
 import java.lang.AssertionError
 
 internal fun manifestWith(cmp: Component, exported: Boolean? = null): String {
@@ -76,5 +77,5 @@ class Test : LintDetectorTest() {
 
     override fun getDetector(): Detector = ManifestElementHasNoExportedAttributeDetector()
 
-    override fun getIssues(): MutableList<Issue> = mutableListOf(EXPORTED_MISSING_ISSUE)
+    override fun getIssues(): MutableList<Issue> = mutableListOf(ManifestElementHasNoExportedAttributeDetector.EXPORTED_MISSING_ISSUE)
 }
\ No newline at end of file
diff --git a/tools/measurement/apksize/apksize.gradle b/tools/measurement/apksize/apksize.gradle
index b2a601163..8ae08c8ab 100644
--- a/tools/measurement/apksize/apksize.gradle
+++ b/tools/measurement/apksize/apksize.gradle
@@ -21,10 +21,12 @@ android {
     flavorDimensions "apkSize"
 }
 
+apply from: "src/config/config.gradle"
 apply from: "src/database/database.gradle"
-apply from: "src/storage/storage.gradle"
 apply from: "src/firestore/firestore.gradle"
 apply from: "src/functions/functions.gradle"
+apply from: "src/inappmessagingdisplay/inappmessaging-display.gradle"
+apply from: "src/storage/storage.gradle"
 
 /**
  * This task builds all supported variants (only aggressive as of writing) and writes the
diff --git a/tools/measurement/apksize/sdks.csv b/tools/measurement/apksize/sdks.csv
index c6ea184cf..e9e8c12a0 100644
--- a/tools/measurement/apksize/sdks.csv
+++ b/tools/measurement/apksize/sdks.csv
@@ -6,3 +6,7 @@ functions-aggressive:2
 storage-aggressive:3
 functions-release:6
 storage-release:7
+config-aggressive:9
+config-release:10
+inappmessagingdisplay-aggressive:11
+inappmessagingdisplay-release:12
diff --git a/tools/measurement/apksize/src/config/config.gradle b/tools/measurement/apksize/src/config/config.gradle
new file mode 100644
index 000000000..a7509903c
--- /dev/null
+++ b/tools/measurement/apksize/src/config/config.gradle
@@ -0,0 +1,33 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+
+android {
+    productFlavors {
+        config {
+            dimension "apkSize"
+            applicationId "com.google.apksize.config"
+        }
+    }
+    sourceSets {
+        config {
+            java.srcDirs = [
+                "src/config/java",
+            ]
+        }
+    }
+}
+dependencies {
+    configImplementation project(":firebase-config")
+}
diff --git a/tools/measurement/apksize/src/config/java/com.google.apksize/Config.java b/tools/measurement/apksize/src/config/java/com.google.apksize/Config.java
new file mode 100644
index 000000000..cf2bcc59f
--- /dev/null
+++ b/tools/measurement/apksize/src/config/java/com.google.apksize/Config.java
@@ -0,0 +1,41 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.apksize;
+
+import android.content.Context;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfig;
+import com.google.firebase.remoteconfig.FirebaseRemoteConfigSettings;
+
+public class Config implements SampleCode {
+  private static final String MESSAGE_TAG = "message";
+  private static final String FLAG_TAG = "flag";
+  private static final String NUMBER_TAG = "number";
+
+  @Override
+  public void runSample(Context context) {
+    FirebaseRemoteConfig remoteConfig = FirebaseRemoteConfig.getInstance();
+    FirebaseRemoteConfigSettings settings =
+        new FirebaseRemoteConfigSettings.Builder()
+            .setDeveloperModeEnabled(BuildConfig.DEBUG)
+            .setMinimumFetchIntervalInSeconds(3600)
+            .build();
+    remoteConfig.setConfigSettings(settings);
+    remoteConfig.setDefaults(R.xml.remote_config_defaults);
+
+    remoteConfig.getString(MESSAGE_TAG);
+    remoteConfig.getBoolean(FLAG_TAG);
+    remoteConfig.getDouble(NUMBER_TAG);
+  }
+}
diff --git a/tools/measurement/apksize/src/config/java/com.google.apksize/SampleCodeLoader.java b/tools/measurement/apksize/src/config/java/com.google.apksize/SampleCodeLoader.java
new file mode 100644
index 000000000..db3bc825c
--- /dev/null
+++ b/tools/measurement/apksize/src/config/java/com.google.apksize/SampleCodeLoader.java
@@ -0,0 +1,24 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.apksize;
+
+import android.content.Context;
+
+public class SampleCodeLoader {
+
+  public void runSamples(Context context) {
+    new Config().runSample(context);
+  }
+}
diff --git a/tools/measurement/apksize/src/firestore/firestore.gradle b/tools/measurement/apksize/src/firestore/firestore.gradle
index 16ced1f72..f8640c43e 100644
--- a/tools/measurement/apksize/src/firestore/firestore.gradle
+++ b/tools/measurement/apksize/src/firestore/firestore.gradle
@@ -31,5 +31,6 @@ android {
 dependencies {
     firestoreImplementation project(":firebase-firestore")
     firestoreImplementation "com.google.android.gms:play-services-auth:16.0.1"
-    firestoreImplementation "com.android.support:support-v4:27.1.0"
+    firestoreImplementation "com.google.android.gms:play-services-base:17.0.0"
+    firestoreImplementation 'androidx.legacy:legacy-support-v4:1.0.0'
 }
diff --git a/tools/measurement/apksize/src/firestore/java/com.google.apksize/Firestore.java b/tools/measurement/apksize/src/firestore/java/com.google.apksize/Firestore.java
index 9b90237c1..4b5a2cbf0 100644
--- a/tools/measurement/apksize/src/firestore/java/com.google.apksize/Firestore.java
+++ b/tools/measurement/apksize/src/firestore/java/com.google.apksize/Firestore.java
@@ -15,8 +15,8 @@
 package com.google.apksize;
 
 import android.content.Context;
-import android.support.annotation.NonNull;
 import android.util.Log;
+import androidx.annotation.NonNull;
 import com.google.android.gms.tasks.OnCompleteListener;
 import com.google.android.gms.tasks.OnFailureListener;
 import com.google.android.gms.tasks.OnSuccessListener;
diff --git a/tools/measurement/apksize/src/functions/functions.gradle b/tools/measurement/apksize/src/functions/functions.gradle
index f6ff68942..085df2df3 100644
--- a/tools/measurement/apksize/src/functions/functions.gradle
+++ b/tools/measurement/apksize/src/functions/functions.gradle
@@ -31,5 +31,6 @@ android {
 dependencies {
     functionsImplementation project(":firebase-functions")
     functionsImplementation "com.google.android.gms:play-services-auth:16.0.1"
-    functionsImplementation "com.android.support:support-v4:27.1.0"
+    functionsImplementation "com.google.android.gms:play-services-base:16.1.0"
+    functionsImplementation 'androidx.legacy:legacy-support-v4:1.0.0'
 }
diff --git a/tools/measurement/apksize/src/functions/java/com.google.apksize/Functions.java b/tools/measurement/apksize/src/functions/java/com.google.apksize/Functions.java
index 07c29fa81..84438bdc2 100644
--- a/tools/measurement/apksize/src/functions/java/com.google.apksize/Functions.java
+++ b/tools/measurement/apksize/src/functions/java/com.google.apksize/Functions.java
@@ -15,7 +15,7 @@
 package com.google.apksize;
 
 import android.content.Context;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.google.android.gms.tasks.Continuation;
 import com.google.android.gms.tasks.Task;
 import com.google.firebase.functions.FirebaseFunctions;
diff --git a/tools/measurement/apksize/src/inappmessagingdisplay/inappmessaging-display.gradle b/tools/measurement/apksize/src/inappmessagingdisplay/inappmessaging-display.gradle
new file mode 100644
index 000000000..4ab856cce
--- /dev/null
+++ b/tools/measurement/apksize/src/inappmessagingdisplay/inappmessaging-display.gradle
@@ -0,0 +1,38 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+
+android {
+    productFlavors {
+        inappmessagingdisplay {
+            dimension "apkSize"
+            applicationId "com.google.apksize.inappmessaging_display"
+        }
+    }
+    sourceSets {
+        inappmessagingdisplay {
+            java.srcDirs = [
+                "src/inappmessagingdisplay/java",
+            ]
+        }
+    }
+}
+dependencies {
+    inappmessagingdisplayImplementation ("com.google.firebase:firebase-inappmessaging-display:19.0.0") {
+        exclude group: "com.google.firebase", module: "firebase-common"
+    }
+    inappmessagingdisplayImplementation ("com.google.firebase:firebase-inappmessaging:19.0.0") {
+        exclude group: "com.google.firebase", module: "firebase-common"
+    }
+}
diff --git a/tools/measurement/apksize/src/inappmessagingdisplay/java/com.google.apksize/InAppMessagingDisplay.java b/tools/measurement/apksize/src/inappmessagingdisplay/java/com.google.apksize/InAppMessagingDisplay.java
new file mode 100644
index 000000000..a2710c806
--- /dev/null
+++ b/tools/measurement/apksize/src/inappmessagingdisplay/java/com.google.apksize/InAppMessagingDisplay.java
@@ -0,0 +1,68 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.apksize;
+
+import android.app.Activity;
+import android.content.Context;
+import com.google.android.gms.tasks.Task;
+import com.google.android.gms.tasks.TaskCompletionSource;
+import com.google.firebase.inappmessaging.FirebaseInAppMessagingDisplayCallbacks;
+import com.google.firebase.inappmessaging.display.FirebaseInAppMessagingDisplay;
+import com.google.firebase.inappmessaging.model.InAppMessage;
+
+public class InAppMessagingDisplay implements SampleCode {
+  private static final String SAMPLE_TEXT = "My sample text";
+  private static final String ACTION_URL = "https://www.example.com";
+  private static final String CAMPAIGN_ID = "my_campaign";
+  private static final String TITLE = "Title";
+
+  public static class DisplayCallback implements FirebaseInAppMessagingDisplayCallbacks {
+    @Override
+    public Task<Void> impressionDetected() {
+      return new TaskCompletionSource<Void>().getTask();
+    }
+
+    @Override
+    public Task<Void> messageDismissed(InAppMessagingDismissType dismissType) {
+      return new TaskCompletionSource<Void>().getTask();
+    }
+
+    @Override
+    public Task<Void> messageClicked() {
+      return new TaskCompletionSource<Void>().getTask();
+    }
+
+    @Override
+    public Task<Void> displayErrorEncountered(InAppMessagingErrorReason InAppMessagingErrorReason) {
+      return new TaskCompletionSource<Void>().getTask();
+    }
+  }
+
+  @Override
+  public void runSample(Context context) {
+    InAppMessage message =
+        InAppMessage.builder()
+            .setBody(InAppMessage.Text.builder().setText(SAMPLE_TEXT).build())
+            .setAction(InAppMessage.Action.builder().setActionUrl(ACTION_URL).build())
+            .setCampaignId(CAMPAIGN_ID)
+            .setTitle(InAppMessage.Text.builder().setText(TITLE).build())
+            .build();
+
+    // NOTE: Context is *not guaranteed* to be an Activity. This is **fine** in this case because we
+    // only want to compile the APK to measure it size, and it will not be run.
+    FirebaseInAppMessagingDisplay.getInstance()
+        .testMessage((Activity) context, message, new DisplayCallback());
+  }
+}
diff --git a/tools/measurement/apksize/src/inappmessagingdisplay/java/com.google.apksize/SampleCodeLoader.java b/tools/measurement/apksize/src/inappmessagingdisplay/java/com.google.apksize/SampleCodeLoader.java
new file mode 100644
index 000000000..01d9b28ae
--- /dev/null
+++ b/tools/measurement/apksize/src/inappmessagingdisplay/java/com.google.apksize/SampleCodeLoader.java
@@ -0,0 +1,24 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.apksize;
+
+import android.content.Context;
+
+public class SampleCodeLoader {
+
+  public void runSamples(Context context) {
+    new InAppMessagingDisplay().runSample(context);
+  }
+}
diff --git a/tools/measurement/apksize/src/main/res/xml/remote_config_defaults.xml b/tools/measurement/apksize/src/main/res/xml/remote_config_defaults.xml
new file mode 100644
index 000000000..4e5a5eb3a
--- /dev/null
+++ b/tools/measurement/apksize/src/main/res/xml/remote_config_defaults.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+<defaultsMap>
+    <entry>
+        <key>message</key>
+        <value>My custom message</value>
+    </entry>
+    <entry>
+        <key>flag</key>
+        <value>false</value>
+    </entry>
+    <entry>
+        <key>number</key>
+        <value>3.14159</value>
+    </entry>
+</defaultsMap>
diff --git a/tools/measurement/apksize/src/storage/storage.gradle b/tools/measurement/apksize/src/storage/storage.gradle
index 5d07491c1..c1324d30a 100644
--- a/tools/measurement/apksize/src/storage/storage.gradle
+++ b/tools/measurement/apksize/src/storage/storage.gradle
@@ -32,4 +32,5 @@ android {
 dependencies {
     storageImplementation project(":firebase-storage")
     storageImplementation "com.google.android.gms:play-services-tasks:16.0.1"
+    storageImplementation "com.google.android.gms:play-services-basement:16.2.0"
 }
diff --git a/tools/measurement/coverage/coverage.gradle b/tools/measurement/coverage/coverage.gradle
index 1781f033f..14acf80ca 100644
--- a/tools/measurement/coverage/coverage.gradle
+++ b/tools/measurement/coverage/coverage.gradle
@@ -22,11 +22,6 @@ task generateCoverageMeasurements(type: GenerateMeasurementsTask) {
     description 'Runs checkCoverage task in all projects and calculates coverage percents.'
     group 'Measurements'
 
-    dependsOn rootProject.allprojects.findAll {
-        it.extensions.findByType(FirebaseLibraryExtension) != null
-    }.collect {
-        it.tasks.withType(JacocoReport)
-    }.flatten()
     reportFile = file("$buildDir/coverage-report.json")
 }
 
diff --git a/transport/transport-api/api.txt b/transport/transport-api/api.txt
new file mode 100644
index 000000000..d802177e2
--- /dev/null
+++ b/transport/transport-api/api.txt
@@ -0,0 +1 @@
+// Signature format: 2.0
diff --git a/transport/transport-api/gradle.properties b/transport/transport-api/gradle.properties
index a9aff5b2e..983642acd 100644
--- a/transport/transport-api/gradle.properties
+++ b/transport/transport-api/gradle.properties
@@ -12,5 +12,5 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-version=1.0.1
-latestReleasedVersion=1.0.0
+version=2.0.1
+latestReleasedVersion=2.0.0
diff --git a/transport/transport-api/src/main/java/com/google/android/datatransport/Event.java b/transport/transport-api/src/main/java/com/google/android/datatransport/Event.java
index 735130aba..c7c79d199 100644
--- a/transport/transport-api/src/main/java/com/google/android/datatransport/Event.java
+++ b/transport/transport-api/src/main/java/com/google/android/datatransport/Event.java
@@ -14,7 +14,7 @@
 
 package com.google.android.datatransport;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.auto.value.AutoValue;
 
 @AutoValue
diff --git a/transport/transport-api/src/main/java/com/google/android/datatransport/package-info.java b/transport/transport-api/src/main/java/com/google/android/datatransport/package-info.java
new file mode 100644
index 000000000..b336cac10
--- /dev/null
+++ b/transport/transport-api/src/main/java/com/google/android/datatransport/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.android.datatransport;
\ No newline at end of file
diff --git a/transport/transport-api/transport-api.gradle b/transport/transport-api/transport-api.gradle
index 132e07cf8..d8b327fab 100644
--- a/transport/transport-api/transport-api.gradle
+++ b/transport/transport-api/transport-api.gradle
@@ -16,22 +16,24 @@ plugins {
     id 'firebase-library'
 }
 
-firebaseLibrary.publishJavadoc = false
+firebaseLibrary{
+    publishJavadoc = false
+}
 
 android {
     compileSdkVersion 28
     defaultConfig {
         minSdkVersion 14
         targetSdkVersion 28
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
     }
 }
 
 dependencies {
     compileOnly 'com.google.auto.value:auto-value-annotations:1.6.5'
-    compileOnly 'com.android.support:support-annotations:28.0.0'
+    compileOnly 'androidx.annotation:annotation:1.1.0'
     annotationProcessor "com.google.auto.value:auto-value:1.6.2"
     testImplementation 'junit:junit:4.12'
-    androidTestImplementation 'com.android.support.test:runner:1.0.2'
-    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
+    androidTestImplementation 'androidx.test:runner:1.2.0'
+    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
 }
diff --git a/transport/transport-backend-cct/api.txt b/transport/transport-backend-cct/api.txt
new file mode 100644
index 000000000..d802177e2
--- /dev/null
+++ b/transport/transport-backend-cct/api.txt
@@ -0,0 +1 @@
+// Signature format: 2.0
diff --git a/transport/transport-backend-cct/gradle.properties b/transport/transport-backend-cct/gradle.properties
index 4e6041d68..5c673db9f 100644
--- a/transport/transport-backend-cct/gradle.properties
+++ b/transport/transport-backend-cct/gradle.properties
@@ -12,6 +12,6 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-version=1.0.1
-latestReleasedVersion=1.0.0
+version=2.0.2
+latestReleasedVersion=2.0.1
 firebaseSkipPreguard=false
diff --git a/transport/transport-backend-cct/preguard.txt b/transport/transport-backend-cct/preguard.txt
index 7b60487ec..67d552458 100644
--- a/transport/transport-backend-cct/preguard.txt
+++ b/transport/transport-backend-cct/preguard.txt
@@ -2,3 +2,10 @@
   public *;
 }
 
+-keep class com.google.android.datatransport.cct.CCTDestination {
+  public *;
+}
+
+-keep class com.google.android.datatransport.cct.LegacyFlgDestination {
+  public *;
+}
diff --git a/transport/transport-backend-cct/src/main/AndroidManifest.xml b/transport/transport-backend-cct/src/main/AndroidManifest.xml
index 90b8f0856..e230ff9bf 100644
--- a/transport/transport-backend-cct/src/main/AndroidManifest.xml
+++ b/transport/transport-backend-cct/src/main/AndroidManifest.xml
@@ -26,7 +26,7 @@
             android:exported="false">
             <meta-data
                 android:name="backend:com.google.android.datatransport.cct.CctBackendFactory"
-                android:value="cct" />
+                android:value="cct,lflg" />
         </service>
     </application>
 </manifest>
diff --git a/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/CCTDestination.java b/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/CCTDestination.java
new file mode 100644
index 000000000..fa0f9f89a
--- /dev/null
+++ b/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/CCTDestination.java
@@ -0,0 +1,38 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.cct;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.google.android.datatransport.runtime.Destination;
+
+public final class CCTDestination implements Destination {
+  static final String DESTINATION_NAME = "cct";
+  public static final CCTDestination INSTANCE = new CCTDestination();
+
+  private CCTDestination() {}
+
+  @NonNull
+  @Override
+  public String getName() {
+    return DESTINATION_NAME;
+  }
+
+  @Nullable
+  @Override
+  public byte[] getExtras() {
+    return null;
+  }
+}
diff --git a/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/CctBackendFactory.java b/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/CctBackendFactory.java
index a458d3cc8..bb44cb14d 100644
--- a/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/CctBackendFactory.java
+++ b/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/CctBackendFactory.java
@@ -14,42 +14,34 @@
 
 package com.google.android.datatransport.cct;
 
-import android.support.annotation.Keep;
-import android.support.annotation.VisibleForTesting;
+import androidx.annotation.Keep;
 import com.google.android.datatransport.runtime.backends.BackendFactory;
 import com.google.android.datatransport.runtime.backends.CreationContext;
 import com.google.android.datatransport.runtime.backends.TransportBackend;
 
 @Keep
 public class CctBackendFactory implements BackendFactory {
-  private static final String URL =
-      mergeStrings("hts/frbslgiggolai.o/0clgbth", "tp:/ieaeogn.ogepscmvc/o/ac");
+  static final String CCT_URL =
+      StringMerger.mergeStrings("hts/frbslgiggolai.o/0clgbth", "tp:/ieaeogn.ogepscmvc/o/ac");
+
+  static final String LFLG_URL =
+      StringMerger.mergeStrings(
+          "hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o");
 
   @Override
   public TransportBackend create(CreationContext creationContext) {
+    final String url;
+    // Since legacy flg and clearcut APIs are identical, they share the same backend.
+    if (creationContext.getBackendName().equals(LegacyFlgDestination.DESTINATION_NAME)) {
+      url = LFLG_URL;
+    } else {
+      url = CCT_URL;
+    }
+
     return new CctTransportBackend(
         creationContext.getApplicationContext(),
-        URL,
+        url,
         creationContext.getWallClock(),
         creationContext.getMonotonicClock());
   }
-
-  @VisibleForTesting
-  static String mergeStrings(String part1, String part2) {
-    int sizeDiff = part1.length() - part2.length();
-    if (sizeDiff < 0 || sizeDiff > 1) {
-      throw new IllegalArgumentException("Invalid input received");
-    }
-
-    StringBuilder url = new StringBuilder(part1.length() + part2.length());
-
-    for (int i = 0; i < part1.length(); i++) {
-      url.append(part1.charAt(i));
-      if (part2.length() > i) {
-        url.append(part2.charAt(i));
-      }
-    }
-
-    return url.toString();
-  }
 }
diff --git a/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/CctTransportBackend.java b/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/CctTransportBackend.java
index 7b7e85c03..75442e0f4 100644
--- a/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/CctTransportBackend.java
+++ b/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/CctTransportBackend.java
@@ -14,11 +14,15 @@
 
 package com.google.android.datatransport.cct;
 
+import static com.google.android.datatransport.runtime.retries.Retries.retry;
+
 import android.content.Context;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 import android.os.Build;
-import android.support.annotation.VisibleForTesting;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import com.google.android.datatransport.backend.cct.BuildConfig;
 import com.google.android.datatransport.cct.proto.AndroidClientInfo;
 import com.google.android.datatransport.cct.proto.BatchedLogRequest;
 import com.google.android.datatransport.cct.proto.ClientInfo;
@@ -27,14 +31,15 @@
 import com.google.android.datatransport.cct.proto.LogResponse;
 import com.google.android.datatransport.cct.proto.NetworkConnectionInfo;
 import com.google.android.datatransport.cct.proto.NetworkConnectionInfo.MobileSubtype;
+import com.google.android.datatransport.cct.proto.NetworkConnectionInfo.NetworkType;
 import com.google.android.datatransport.cct.proto.QosTierConfiguration;
 import com.google.android.datatransport.runtime.EventInternal;
 import com.google.android.datatransport.runtime.backends.BackendRequest;
 import com.google.android.datatransport.runtime.backends.BackendResponse;
 import com.google.android.datatransport.runtime.backends.TransportBackend;
+import com.google.android.datatransport.runtime.logging.Logging;
 import com.google.android.datatransport.runtime.time.Clock;
 import com.google.protobuf.ByteString;
-import com.google.protobuf.InvalidProtocolBufferException;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -50,21 +55,23 @@
 import java.util.List;
 import java.util.Map;
 import java.util.TimeZone;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 import java.util.zip.GZIPOutputStream;
 
 final class CctTransportBackend implements TransportBackend {
 
-  private static final Logger LOGGER = Logger.getLogger(CctTransportBackend.class.getName());
+  private static final String LOG_TAG = "CctTransportBackend";
 
   private static final int CONNECTION_TIME_OUT = 30000;
   private static final int READ_TIME_OUT = 40000;
   private static final String CONTENT_ENCODING_HEADER_KEY = "Content-Encoding";
   private static final String GZIP_CONTENT_ENCODING = "gzip";
   private static final String CONTENT_TYPE_HEADER_KEY = "Content-Type";
+  static final String API_KEY_HEADER_KEY = "X-Goog-Api-Key";
   private static final String PROTOBUF_CONTENT_TYPE = "application/x-protobuf";
 
+  @VisibleForTesting static final String KEY_NETWORK_TYPE = "net-type";
+  @VisibleForTesting static final String KEY_MOBILE_SUBTYPE = "mobile-subtype";
+
   private static final String KEY_SDK_VERSION = "sdk-version";
   private static final String KEY_MODEL = "model";
   private static final String KEY_HARDWARE = "hardware";
@@ -73,12 +80,10 @@
   private static final String KEY_OS_BUILD = "os-uild";
   private static final String KEY_MANUFACTURER = "manufacturer";
   private static final String KEY_FINGERPRINT = "fingerprint";
-  private static final String KEY_NETWORK_TYPE = "net-type";
-  private static final String KEY_MOBILE_SUBTYPE = "mobile-subtype";
   private static final String KEY_TIMEZONE_OFFSET = "tz-offset";
 
   private final ConnectivityManager connectivityManager;
-  private final URL endPoint;
+  final URL endPoint;
   private final Clock uptimeClock;
   private final Clock wallTimeClock;
   private final int readTimeout;
@@ -125,12 +130,25 @@ public EventInternal decorate(EventInternal eventInternal) {
         .addMetadata(KEY_MANUFACTURER, Build.MANUFACTURER)
         .addMetadata(KEY_FINGERPRINT, Build.FINGERPRINT)
         .addMetadata(KEY_TIMEZONE_OFFSET, getTzOffset())
-        .addMetadata(KEY_NETWORK_TYPE, networkInfo.getType())
-        .addMetadata(KEY_MOBILE_SUBTYPE, toSubtypeValue(networkInfo.getSubtype()))
+        .addMetadata(KEY_NETWORK_TYPE, getNetTypeValue(networkInfo))
+        .addMetadata(KEY_MOBILE_SUBTYPE, getNetSubtypeValue(networkInfo))
         .build();
   }
 
-  private int toSubtypeValue(int subtype) {
+  private static int getNetTypeValue(NetworkInfo networkInfo) {
+    // when the device is not connected networkInfo returned by ConnectivityManger is null.
+    if (networkInfo == null) {
+      return NetworkType.NONE_VALUE;
+    }
+    return networkInfo.getType();
+  }
+
+  private static int getNetSubtypeValue(NetworkInfo networkInfo) {
+    // when the device is not connected networkInfo returned by ConnectivityManger is null.
+    if (networkInfo == null) {
+      return MobileSubtype.UNKNOWN_MOBILE_SUBTYPE_VALUE;
+    }
+    int subtype = networkInfo.getSubtype();
     if (subtype == -1) {
       return MobileSubtype.COMBINED_VALUE;
     }
@@ -195,48 +213,54 @@ private BatchedLogRequest getRequestBody(BackendRequest backendRequest) {
     return batchedRequestBuilder.build();
   }
 
-  private BackendResponse doSend(BatchedLogRequest requestBody) throws IOException {
-    HttpURLConnection connection = (HttpURLConnection) endPoint.openConnection();
+  private HttpResponse doSend(HttpRequest request) throws IOException {
+
+    Logging.d(LOG_TAG, "Making request to: %s", request.url);
+    HttpURLConnection connection = (HttpURLConnection) request.url.openConnection();
     connection.setConnectTimeout(CONNECTION_TIME_OUT);
     connection.setReadTimeout(readTimeout);
     connection.setDoOutput(true);
     connection.setInstanceFollowRedirects(false);
     connection.setRequestMethod("POST");
+    connection.setRequestProperty(
+        "User-Agent", String.format("datatransport/%s android/", BuildConfig.VERSION_NAME));
     connection.setRequestProperty(CONTENT_ENCODING_HEADER_KEY, GZIP_CONTENT_ENCODING);
     connection.setRequestProperty(CONTENT_TYPE_HEADER_KEY, PROTOBUF_CONTENT_TYPE);
 
+    if (request.apiKey != null) {
+      connection.setRequestProperty(API_KEY_HEADER_KEY, request.apiKey);
+    }
+
     WritableByteChannel channel = Channels.newChannel(connection.getOutputStream());
     try {
       ByteArrayOutputStream output = new ByteArrayOutputStream();
       GZIPOutputStream gzipOutputStream = new GZIPOutputStream(output);
 
       try {
-        requestBody.writeTo(gzipOutputStream);
+        request.requestBody.writeTo(gzipOutputStream);
       } finally {
         gzipOutputStream.close();
       }
       channel.write(ByteBuffer.wrap(output.toByteArray()));
       int responseCode = connection.getResponseCode();
-      LOGGER.info("Status Code: " + responseCode);
+      Logging.i(LOG_TAG, "Status Code: " + responseCode);
+      Logging.i(LOG_TAG, "Content-Type:" + connection.getHeaderField("Content-Type"));
+
+      if (responseCode == 302 || responseCode == 301) {
+        String redirect = connection.getHeaderField("Location");
+        return new HttpResponse(responseCode, new URL(redirect), 0);
+      }
+      if (responseCode != 200) {
+        return new HttpResponse(responseCode, null, 0);
+      }
 
-      long nextRequestMillis;
       InputStream inputStream = connection.getInputStream();
       try {
-        try {
-          nextRequestMillis = LogResponse.parseFrom(inputStream).getNextRequestWaitMillis();
-        } catch (InvalidProtocolBufferException e) {
-          return BackendResponse.fatalError();
-        }
+        long nextRequestMillis = LogResponse.parseFrom(inputStream).getNextRequestWaitMillis();
+        return new HttpResponse(responseCode, null, nextRequestMillis);
       } finally {
         inputStream.close();
       }
-      if (responseCode == 200) {
-        return BackendResponse.ok(nextRequestMillis);
-      } else if (responseCode >= 500 || responseCode == 404) {
-        return BackendResponse.transientError();
-      } else {
-        return BackendResponse.fatalError();
-      }
     } finally {
       channel.close();
     }
@@ -245,10 +269,37 @@ private BackendResponse doSend(BatchedLogRequest requestBody) throws IOException
   @Override
   public BackendResponse send(BackendRequest request) {
     BatchedLogRequest requestBody = getRequestBody(request);
+    // CCT backend supports 2 different endpoints
+    // We route to CCT backend if extras are null and to LegacyFlg otherwise.
+    // This (anti-) pattern should not be required for other backends
+    final String apiKey =
+        request.getExtras() == null ? null : LegacyFlgDestination.decodeExtras(request.getExtras());
+
     try {
-      return doSend(requestBody);
+      HttpResponse response =
+          retry(
+              5,
+              new HttpRequest(endPoint, requestBody, apiKey),
+              this::doSend,
+              (req, resp) -> {
+                if (resp.redirectUrl != null) {
+                  // retry with different url
+                  Logging.d(LOG_TAG, "Following redirect to: %s", resp.redirectUrl);
+                  return req.withUrl(resp.redirectUrl);
+                }
+                // don't retry
+                return null;
+              });
+
+      if (response.code == 200) {
+        return BackendResponse.ok(response.nextRequestMillis);
+      } else if (response.code >= 500 || response.code == 404) {
+        return BackendResponse.transientError();
+      } else {
+        return BackendResponse.fatalError();
+      }
     } catch (IOException e) {
-      LOGGER.log(Level.SEVERE, "Could not make request to the backend", e);
+      Logging.e(LOG_TAG, "Could not make request to the backend", e);
       return BackendResponse.transientError();
     }
   }
@@ -259,4 +310,32 @@ static long getTzOffset() {
     TimeZone tz = TimeZone.getDefault();
     return tz.getOffset(Calendar.getInstance().getTimeInMillis()) / 1000;
   }
+
+  static final class HttpResponse {
+    final int code;
+    @Nullable final URL redirectUrl;
+    final long nextRequestMillis;
+
+    HttpResponse(int code, @Nullable URL redirectUrl, long nextRequestMillis) {
+      this.code = code;
+      this.redirectUrl = redirectUrl;
+      this.nextRequestMillis = nextRequestMillis;
+    }
+  }
+
+  static final class HttpRequest {
+    final URL url;
+    final BatchedLogRequest requestBody;
+    @Nullable final String apiKey;
+
+    HttpRequest(URL url, BatchedLogRequest requestBody, @Nullable String apiKey) {
+      this.url = url;
+      this.requestBody = requestBody;
+      this.apiKey = apiKey;
+    }
+
+    HttpRequest withUrl(URL newUrl) {
+      return new HttpRequest(newUrl, requestBody, apiKey);
+    }
+  }
 }
diff --git a/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/LegacyFlgDestination.java b/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/LegacyFlgDestination.java
new file mode 100644
index 000000000..32f7dfb15
--- /dev/null
+++ b/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/LegacyFlgDestination.java
@@ -0,0 +1,69 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.cct;
+
+import androidx.annotation.NonNull;
+import com.google.android.datatransport.runtime.Destination;
+import java.io.UnsupportedEncodingException;
+
+public class LegacyFlgDestination implements Destination {
+  static final String DESTINATION_NAME = "lflg";
+  private static final String DEFAULT_API_KEY =
+      StringMerger.mergeStrings("AzSCki82AwsLzKd5O8zo", "IayckHiZRO1EFl1aGoK");
+
+  public static final LegacyFlgDestination DEFAULT_INSTANCE =
+      new LegacyFlgDestination(DEFAULT_API_KEY);
+
+  private final String apiKey;
+
+  private LegacyFlgDestination(String apiKey) {
+    this.apiKey = apiKey;
+  }
+
+  @NonNull
+  String getAPIKey() {
+    return apiKey;
+  }
+
+  @NonNull
+  @Override
+  public String getName() {
+    return DESTINATION_NAME;
+  }
+
+  @NonNull
+  @Override
+  public byte[] getExtras() {
+    return encodeString(apiKey);
+  }
+
+  @NonNull
+  static byte[] encodeString(@NonNull String s) {
+    try {
+      return s.getBytes("UTF-8");
+    } catch (UnsupportedEncodingException e) {
+      throw new IllegalStateException("UTF-8 encoding not found.");
+    }
+  }
+
+  @NonNull
+  static String decodeExtras(@NonNull byte[] a) {
+    try {
+      return new String(a, "UTF-8");
+    } catch (UnsupportedEncodingException e) {
+      throw new IllegalStateException("UTF-8 encoding not found.");
+    }
+  }
+}
diff --git a/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/StringMerger.java b/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/StringMerger.java
new file mode 100644
index 000000000..424faca45
--- /dev/null
+++ b/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/StringMerger.java
@@ -0,0 +1,35 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.cct;
+
+public final class StringMerger {
+  static String mergeStrings(String part1, String part2) {
+    int sizeDiff = part1.length() - part2.length();
+    if (sizeDiff < 0 || sizeDiff > 1) {
+      throw new IllegalArgumentException("Invalid input received");
+    }
+
+    StringBuilder url = new StringBuilder(part1.length() + part2.length());
+
+    for (int i = 0; i < part1.length(); i++) {
+      url.append(part1.charAt(i));
+      if (part2.length() > i) {
+        url.append(part2.charAt(i));
+      }
+    }
+
+    return url.toString();
+  }
+}
diff --git a/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/package-info.java b/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/package-info.java
new file mode 100644
index 000000000..17dd99170
--- /dev/null
+++ b/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.android.datatransport.cct;
\ No newline at end of file
diff --git a/transport/transport-backend-cct/src/test/java/com/google/android/datatransport/cct/CctBackendFactoryTest.java b/transport/transport-backend-cct/src/test/java/com/google/android/datatransport/cct/CctBackendFactoryTest.java
index 9bba69781..125e2569c 100644
--- a/transport/transport-backend-cct/src/test/java/com/google/android/datatransport/cct/CctBackendFactoryTest.java
+++ b/transport/transport-backend-cct/src/test/java/com/google/android/datatransport/cct/CctBackendFactoryTest.java
@@ -14,34 +14,61 @@
 
 package com.google.android.datatransport.cct;
 
+import static com.google.android.datatransport.cct.CctBackendFactory.CCT_URL;
+import static com.google.android.datatransport.cct.CctBackendFactory.LFLG_URL;
 import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertThrows;
 
+import com.google.android.datatransport.runtime.backends.CreationContext;
+import com.google.android.datatransport.runtime.time.TestClock;
+import java.net.MalformedURLException;
+import java.net.URL;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 
-@RunWith(JUnit4.class)
+@RunWith(RobolectricTestRunner.class)
 public class CctBackendFactoryTest {
+  private static final long INITIAL_WALL_TIME = 200L;
+  private static final long INITIAL_UPTIME = 10L;
+  private TestClock wallClock = new TestClock(INITIAL_WALL_TIME);
+  private TestClock uptimeClock = new TestClock(INITIAL_UPTIME);
+
   @Test
-  public void mergeStrings_whenPartsAreUnequalLength() {
-    String part1 = "hts/eapecm";
-    String part2 = "tp:/xml.o";
-    assertThat(CctBackendFactory.mergeStrings(part1, part2)).isEqualTo("https://example.com");
+  public void create_returnCCTBackend_WhenBackendNameIsCCT() throws MalformedURLException {
+    CctBackendFactory cctBackendFactory = new CctBackendFactory();
+    CreationContext creationContext =
+        CreationContext.create(
+            RuntimeEnvironment.application,
+            wallClock,
+            uptimeClock,
+            CCTDestination.DESTINATION_NAME);
+
+    CctTransportBackend backend = (CctTransportBackend) cctBackendFactory.create(creationContext);
+    assertThat(backend.endPoint).isEqualTo(new URL(CCT_URL));
   }
 
   @Test
-  public void mergeStrings_whenPartsAreEqualLength() {
-    String part1 = "hts/eape.o";
-    String part2 = "tp:/xmlscm";
-    assertThat(CctBackendFactory.mergeStrings(part1, part2)).isEqualTo("https://examples.com");
+  public void create_returnCCTBackend_WhenNoBackendIsSpecified() throws MalformedURLException {
+    CctBackendFactory cctBackendFactory = new CctBackendFactory();
+    CreationContext creationContext =
+        CreationContext.create(RuntimeEnvironment.application, wallClock, uptimeClock);
+
+    CctTransportBackend backend = (CctTransportBackend) cctBackendFactory.create(creationContext);
+    assertThat(backend.endPoint).isEqualTo(new URL(CCT_URL));
   }
 
   @Test
-  public void mergeStrings_whenPart2IsLongerThanPart1() {
-    String part1 = "135";
-    String part2 = "2467";
-    assertThrows(
-        IllegalArgumentException.class, () -> CctBackendFactory.mergeStrings(part1, part2));
+  public void create_returnCCTBackend_WhenBackendNameIslflg() throws MalformedURLException {
+    CctBackendFactory cctBackendFactory = new CctBackendFactory();
+    CreationContext creationContext =
+        CreationContext.create(
+            RuntimeEnvironment.application,
+            wallClock,
+            uptimeClock,
+            LegacyFlgDestination.DESTINATION_NAME);
+
+    CctTransportBackend backend = (CctTransportBackend) cctBackendFactory.create(creationContext);
+    assertThat(backend.endPoint).isEqualTo(new URL(LFLG_URL));
   }
 }
diff --git a/transport/transport-backend-cct/src/test/java/com/google/android/datatransport/cct/CctTransportBackendTest.java b/transport/transport-backend-cct/src/test/java/com/google/android/datatransport/cct/CctTransportBackendTest.java
index b0d3b5f8d..7abf716d8 100644
--- a/transport/transport-backend-cct/src/test/java/com/google/android/datatransport/cct/CctTransportBackendTest.java
+++ b/transport/transport-backend-cct/src/test/java/com/google/android/datatransport/cct/CctTransportBackendTest.java
@@ -23,6 +23,7 @@
 import static com.github.tomakehurst.wiremock.client.WireMock.verify;
 import static com.google.android.datatransport.cct.CctTransportBackend.getTzOffset;
 import static com.google.android.datatransport.cct.ProtoMatchers.protoMatcher;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 
 import android.content.Context;
@@ -30,6 +31,7 @@
 import android.net.NetworkInfo;
 import com.github.tomakehurst.wiremock.http.Request;
 import com.github.tomakehurst.wiremock.junit.WireMockRule;
+import com.google.android.datatransport.backend.cct.BuildConfig;
 import com.google.android.datatransport.cct.ProtoMatchers.PredicateMatcher;
 import com.google.android.datatransport.cct.proto.BatchedLogRequest;
 import com.google.android.datatransport.cct.proto.LogEvent;
@@ -47,6 +49,9 @@
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
 
 @RunWith(RobolectricTestRunner.class)
 public class CctTransportBackendTest {
@@ -68,6 +73,7 @@
       firstLogRequestMatcher.zoom(b -> b.getLogEvent(1));
 
   private static final String TEST_ENDPOINT = "http://localhost:8999/api";
+  private static final String API_KEY = "api_key";
   private TestClock wallClock = new TestClock(INITIAL_WALL_TIME);
   private TestClock uptimeClock = new TestClock(INITIAL_UPTIME);
   private CctTransportBackend BACKEND =
@@ -76,7 +82,7 @@
 
   @Rule public WireMockRule wireMockRule = new WireMockRule(8999);
 
-  private BackendRequest getBackendRequest() {
+  private BackendRequest getCCTBackendRequest() {
     return BackendRequest.create(
         Arrays.asList(
             BACKEND.decorate(
@@ -96,8 +102,31 @@ private BackendRequest getBackendRequest() {
                     .build())));
   }
 
+  private BackendRequest getLegacyFirelogBackendRequest() {
+    return BackendRequest.builder()
+        .setEvents(
+            Arrays.asList(
+                BACKEND.decorate(
+                    EventInternal.builder()
+                        .setEventMillis(INITIAL_WALL_TIME)
+                        .setUptimeMillis(INITIAL_UPTIME)
+                        .setTransportName("4")
+                        .setPayload(PAYLOAD.toByteArray())
+                        .build()),
+                BACKEND.decorate(
+                    EventInternal.builder()
+                        .setEventMillis(INITIAL_WALL_TIME)
+                        .setUptimeMillis(INITIAL_UPTIME)
+                        .setTransportName("4")
+                        .setPayload(PAYLOAD.toByteArray())
+                        .setCode(CODE)
+                        .build())))
+        .setExtras(LegacyFlgDestination.encodeString(API_KEY))
+        .build();
+  }
+
   @Test
-  public void testSuccessLoggingRequest() {
+  public void testCCTSuccessLoggingRequest() {
     stubFor(
         post(urlEqualTo("/api"))
             .willReturn(
@@ -109,7 +138,7 @@ public void testSuccessLoggingRequest() {
                             .setNextRequestWaitMillis(3)
                             .build()
                             .toByteArray())));
-    BackendRequest backendRequest = getBackendRequest();
+    BackendRequest backendRequest = getCCTBackendRequest();
     wallClock.tick();
     uptimeClock.tick();
 
@@ -122,6 +151,9 @@ public void testSuccessLoggingRequest() {
 
     verify(
         postRequestedFor(urlEqualTo("/api"))
+            .withHeader(
+                "User-Agent",
+                equalTo(String.format("datatransport/%s android/", BuildConfig.VERSION_NAME)))
             .withHeader("Content-Type", equalTo("application/x-protobuf"))
             .andMatching(batchRequestMatcher.test(batch -> batch.getLogRequestCount() == 1))
             .andMatching(
@@ -146,27 +178,50 @@ public void testSuccessLoggingRequest() {
             .andMatching(firstLogEventMatcher.test(e -> e.getEventCode() == 0))
             .andMatching(secondLogEventMatcher.test(e -> e.getEventCode() == 5)));
 
-    assertEquals(response, BackendResponse.ok(3));
+    assertEquals(BackendResponse.ok(3), response);
+  }
+
+  @Test
+  public void testLegacyFlgSuccessLoggingRequest_containsAPIKey() {
+    stubFor(
+        post(urlEqualTo("/api"))
+            .willReturn(
+                aResponse()
+                    .withStatus(200)
+                    .withHeader("Content-Type", "application/x-protobuf;charset=UTF8;hello=world")
+                    .withBody(
+                        LogResponse.newBuilder()
+                            .setNextRequestWaitMillis(3)
+                            .build()
+                            .toByteArray())));
+    wallClock.tick();
+    uptimeClock.tick();
+
+    BACKEND.send(getLegacyFirelogBackendRequest());
+
+    verify(
+        postRequestedFor(urlEqualTo("/api"))
+            .withHeader(CctTransportBackend.API_KEY_HEADER_KEY, equalTo(API_KEY)));
   }
 
   @Test
   public void testUnsuccessfulLoggingRequest() {
     stubFor(post(urlEqualTo("/api")).willReturn(aResponse().withStatus(404)));
-    BackendResponse response = BACKEND.send(getBackendRequest());
+    BackendResponse response = BACKEND.send(getCCTBackendRequest());
     verify(
         postRequestedFor(urlEqualTo("/api"))
             .withHeader("Content-Type", equalTo("application/x-protobuf")));
-    assertEquals(response, BackendResponse.transientError());
+    assertEquals(BackendResponse.transientError(), response);
   }
 
   @Test
   public void testServerErrorLoggingRequest() {
     stubFor(post(urlEqualTo("/api")).willReturn(aResponse().withStatus(500)));
-    BackendResponse response = BACKEND.send(getBackendRequest());
+    BackendResponse response = BACKEND.send(getCCTBackendRequest());
     verify(
         postRequestedFor(urlEqualTo("/api"))
             .withHeader("Content-Type", equalTo("application/x-protobuf")));
-    assertEquals(response, BackendResponse.transientError());
+    assertEquals(BackendResponse.transientError(), response);
   }
 
   @Test
@@ -178,21 +233,21 @@ public void testGarbageFromServer() {
                     .withStatus(200)
                     .withHeader("Content-Type", "application/x-protobuf;charset=UTF8;hello=world")
                     .withBody("{\"status\":\"Error\",\"message\":\"Endpoint not found\"}")));
-    BackendResponse response = BACKEND.send(getBackendRequest());
+    BackendResponse response = BACKEND.send(getCCTBackendRequest());
     verify(
         postRequestedFor(urlEqualTo("/api"))
             .withHeader("Content-Type", equalTo("application/x-protobuf")));
-    assertEquals(response, BackendResponse.fatalError());
+    assertEquals(BackendResponse.transientError(), response);
   }
 
   @Test
   public void testNonHandledResponseCode() {
     stubFor(post(urlEqualTo("/api")).willReturn(aResponse().withStatus(300)));
-    BackendResponse response = BACKEND.send(getBackendRequest());
+    BackendResponse response = BACKEND.send(getCCTBackendRequest());
     verify(
         postRequestedFor(urlEqualTo("/api"))
             .withHeader("Content-Type", equalTo("application/x-protobuf")));
-    assertEquals(response, BackendResponse.fatalError());
+    assertEquals(BackendResponse.fatalError(), response);
   }
 
   @Test
@@ -201,8 +256,126 @@ public void send_whenBackendResponseTimesOut_shouldReturnTransientError() {
         new CctTransportBackend(
             RuntimeEnvironment.application, TEST_ENDPOINT, wallClock, uptimeClock, 300);
     stubFor(post(urlEqualTo("/api")).willReturn(aResponse().withFixedDelay(500)));
-    BackendResponse response = backend.send(getBackendRequest());
+    BackendResponse response = backend.send(getCCTBackendRequest());
+
+    assertEquals(BackendResponse.transientError(), response);
+  }
+
+  @Test
+  public void decorate_whenOnline_shouldProperlyPopulateNetworkInfo() {
+    CctTransportBackend backend =
+        new CctTransportBackend(
+            RuntimeEnvironment.application, TEST_ENDPOINT, wallClock, uptimeClock, 300);
+
+    EventInternal result =
+        backend.decorate(
+            EventInternal.builder()
+                .setEventMillis(INITIAL_WALL_TIME)
+                .setUptimeMillis(INITIAL_UPTIME)
+                .setTransportName("3")
+                .setPayload(PAYLOAD.toByteArray())
+                .build());
+
+    assertThat(result.get(CctTransportBackend.KEY_NETWORK_TYPE))
+        .isEqualTo(String.valueOf(NetworkConnectionInfo.NetworkType.MOBILE_VALUE));
+    assertThat(result.get(CctTransportBackend.KEY_MOBILE_SUBTYPE))
+        .isEqualTo(String.valueOf(NetworkConnectionInfo.MobileSubtype.EDGE_VALUE));
+  }
+
+  @Test
+  @Config(shadows = {OfflineConnectivityManagerShadow.class})
+  public void decorate_whenOffline_shouldProperlyPopulateNetworkInfo() {
+    CctTransportBackend backend =
+        new CctTransportBackend(
+            RuntimeEnvironment.application, TEST_ENDPOINT, wallClock, uptimeClock, 300);
+
+    EventInternal result =
+        backend.decorate(
+            EventInternal.builder()
+                .setEventMillis(INITIAL_WALL_TIME)
+                .setUptimeMillis(INITIAL_UPTIME)
+                .setTransportName("3")
+                .setPayload(PAYLOAD.toByteArray())
+                .build());
+
+    assertThat(result.get(CctTransportBackend.KEY_NETWORK_TYPE))
+        .isEqualTo(String.valueOf(NetworkConnectionInfo.NetworkType.NONE_VALUE));
+    assertThat(result.get(CctTransportBackend.KEY_MOBILE_SUBTYPE))
+        .isEqualTo(
+            String.valueOf(NetworkConnectionInfo.MobileSubtype.UNKNOWN_MOBILE_SUBTYPE_VALUE));
+  }
+
+  @Test
+  public void send_whenBackendRedirects_shouldCorrectlyFollowTheRedirectViaPost() {
+    stubFor(
+        post(urlEqualTo("/api"))
+            .willReturn(
+                aResponse().withStatus(302).withHeader("Location", TEST_ENDPOINT + "/hello")));
+    stubFor(
+        post(urlEqualTo("/api/hello"))
+            .willReturn(
+                aResponse()
+                    .withStatus(200)
+                    .withHeader("Content-Type", "application/x-protobuf;charset=UTF8;hello=world")
+                    .withBody(
+                        LogResponse.newBuilder()
+                            .setNextRequestWaitMillis(3)
+                            .build()
+                            .toByteArray())));
+    BackendRequest backendRequest = getCCTBackendRequest();
+    wallClock.tick();
+    uptimeClock.tick();
+
+    BackendResponse response = BACKEND.send(backendRequest);
+
+    verify(
+        postRequestedFor(urlEqualTo("/api"))
+            .withHeader("Content-Type", equalTo("application/x-protobuf")));
+
+    verify(
+        postRequestedFor(urlEqualTo("/api/hello"))
+            .withHeader("Content-Type", equalTo("application/x-protobuf")));
+
+    assertEquals(BackendResponse.ok(3), response);
+  }
+
+  @Test
+  public void send_whenBackendRedirectsMoreThan5Times_shouldOnlyRedirect4Times() {
+    stubFor(
+        post(urlEqualTo("/api"))
+            .willReturn(
+                aResponse().withStatus(302).withHeader("Location", TEST_ENDPOINT + "/hello")));
+    stubFor(
+        post(urlEqualTo("/api/hello"))
+            .willReturn(
+                aResponse().withStatus(302).withHeader("Location", TEST_ENDPOINT + "/hello")));
+
+    BackendRequest backendRequest = getCCTBackendRequest();
+    wallClock.tick();
+    uptimeClock.tick();
+
+    BackendResponse response = BACKEND.send(backendRequest);
+
+    verify(
+        postRequestedFor(urlEqualTo("/api"))
+            .withHeader("Content-Type", equalTo("application/x-protobuf")));
+
+    verify(
+        4,
+        postRequestedFor(urlEqualTo("/api/hello"))
+            .withHeader("Content-Type", equalTo("application/x-protobuf")));
+
+    assertEquals(BackendResponse.fatalError(), response);
+  }
+
+  // When there is no active network, the ConnectivityManager returns null when
+  // getActiveNetworkInfo() is called.
+  @Implements(ConnectivityManager.class)
+  public static class OfflineConnectivityManagerShadow {
 
-    assertEquals(response, BackendResponse.transientError());
+    @Implementation
+    public NetworkInfo getActiveNetworkInfo() {
+      return null;
+    }
   }
 }
diff --git a/transport/transport-backend-cct/src/test/java/com/google/android/datatransport/cct/StringMergerTest.java b/transport/transport-backend-cct/src/test/java/com/google/android/datatransport/cct/StringMergerTest.java
new file mode 100644
index 000000000..99ced56df
--- /dev/null
+++ b/transport/transport-backend-cct/src/test/java/com/google/android/datatransport/cct/StringMergerTest.java
@@ -0,0 +1,50 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.cct;
+
+import static com.google.android.datatransport.cct.StringMerger.mergeStrings;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class StringMergerTest {
+  private static final long INITIAL_WALL_TIME = 200L;
+  private static final long INITIAL_UPTIME = 10L;
+
+  @Test
+  public void mergeStrings_whenPartsAreUnequalLength() {
+    String part1 = "hts/eapecm";
+    String part2 = "tp:/xml.o";
+    assertThat(mergeStrings(part1, part2)).isEqualTo("https://example.com");
+  }
+
+  @Test
+  public void mergeStrings_whenPartsAreEqualLength() {
+    String part1 = "hts/eape.o";
+    String part2 = "tp:/xmlscm";
+    assertThat(mergeStrings(part1, part2)).isEqualTo("https://examples.com");
+  }
+
+  @Test
+  public void mergeStrings_whenPart2IsLongerThanPart1() {
+    String part1 = "135";
+    String part2 = "2467";
+    assertThrows(IllegalArgumentException.class, () -> mergeStrings(part1, part2));
+  }
+}
diff --git a/transport/transport-backend-cct/transport-backend-cct.gradle b/transport/transport-backend-cct/transport-backend-cct.gradle
index 8ec86d99c..cbd32dc9e 100644
--- a/transport/transport-backend-cct/transport-backend-cct.gradle
+++ b/transport/transport-backend-cct/transport-backend-cct.gradle
@@ -17,7 +17,9 @@ plugins {
     id 'com.google.protobuf'
 }
 
-firebaseLibrary.publishJavadoc = false
+firebaseLibrary{
+    publishJavadoc = false
+}
 
 protobuf {
     // Configure the protoc executable
@@ -50,7 +52,8 @@ android {
     defaultConfig {
         minSdkVersion 14
         targetSdkVersion 28
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+        versionName version
     }
     compileOptions {
         sourceCompatibility = '1.8'
@@ -63,6 +66,10 @@ dependencies {
     implementation project(':transport:transport-runtime')
     implementation 'com.google.protobuf:protobuf-lite:3.0.1'
 
+    compileOnly "com.google.auto.value:auto-value-annotations:1.6.5"
+
+    annotationProcessor "com.google.auto.value:auto-value:1.6.2"
+
     testImplementation 'junit:junit:4.12'
     testImplementation "com.google.truth:truth:$googleTruthVersion"
     testImplementation("com.github.tomakehurst:wiremock-jre8:2.21.0") {
@@ -82,7 +89,7 @@ dependencies {
     testImplementation 'org.robolectric:robolectric:4.2'
     testImplementation 'junit:junit:4.13-beta-2'
 
-    androidTestImplementation 'com.android.support.test:runner:1.0.2'
-    implementation 'com.android.support:support-annotations:28.0.0'
-    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
+    androidTestImplementation 'androidx.test:runner:1.2.0'
+    implementation 'androidx.annotation:annotation:1.1.0'
+    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
 }
diff --git a/transport/transport-runtime/api.txt b/transport/transport-runtime/api.txt
new file mode 100644
index 000000000..d802177e2
--- /dev/null
+++ b/transport/transport-runtime/api.txt
@@ -0,0 +1 @@
+// Signature format: 2.0
diff --git a/transport/transport-runtime/gradle.properties b/transport/transport-runtime/gradle.properties
index 0cbb89724..18a78760e 100644
--- a/transport/transport-runtime/gradle.properties
+++ b/transport/transport-runtime/gradle.properties
@@ -12,6 +12,6 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-version=1.0.1
-latestReleasedVersion=1.0.0
+version=2.0.1
+latestReleasedVersion=2.0.0
 android.enableUnitTestBinaryResources=true
diff --git a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/SchedulerIntegrationTest.java b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/SchedulerIntegrationTest.java
index 3dd00e990..d6115e92e 100644
--- a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/SchedulerIntegrationTest.java
+++ b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/SchedulerIntegrationTest.java
@@ -24,8 +24,8 @@
 import static org.mockito.Mockito.when;
 
 import android.content.Context;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.datatransport.Event;
 import com.google.android.datatransport.Priority;
 import com.google.android.datatransport.Transport;
diff --git a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/TestRuntimeComponent.java b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/TestRuntimeComponent.java
index 79704dc31..141e23fc4 100644
--- a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/TestRuntimeComponent.java
+++ b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/TestRuntimeComponent.java
@@ -20,11 +20,13 @@
 import com.google.android.datatransport.runtime.scheduling.jobscheduling.SchedulerConfig;
 import com.google.android.datatransport.runtime.scheduling.jobscheduling.Uploader;
 import com.google.android.datatransport.runtime.scheduling.persistence.EventStoreModule;
+import com.google.android.datatransport.runtime.scheduling.persistence.SQLiteEventStore;
 import com.google.android.datatransport.runtime.time.Clock;
 import com.google.android.datatransport.runtime.time.Monotonic;
 import com.google.android.datatransport.runtime.time.WallTime;
 import dagger.BindsInstance;
 import dagger.Component;
+import java.io.IOException;
 import javax.inject.Singleton;
 
 @Component(
@@ -38,6 +40,14 @@
 
   abstract TransportRuntime getTransportRuntime();
 
+  abstract SQLiteEventStore getEventStore();
+
+  @Override
+  public void close() throws IOException {
+    getEventStore().clearDb();
+    super.close();
+  }
+
   @Component.Builder
   interface Builder {
     @BindsInstance
diff --git a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/TestSchedulingModule.java b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/TestSchedulingModule.java
index 01ce988be..b8a39f95a 100644
--- a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/TestSchedulingModule.java
+++ b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/TestSchedulingModule.java
@@ -14,14 +14,27 @@
 
 package com.google.android.datatransport.runtime;
 
+import static org.mockito.Mockito.spy;
+
 import com.google.android.datatransport.runtime.scheduling.DefaultScheduler;
 import com.google.android.datatransport.runtime.scheduling.Scheduler;
+import com.google.android.datatransport.runtime.scheduling.jobscheduling.Uploader;
+import com.google.android.datatransport.runtime.scheduling.jobscheduling.WorkScheduler;
 import dagger.Binds;
 import dagger.Module;
+import dagger.Provides;
+import javax.inject.Provider;
+import javax.inject.Singleton;
 
 @Module
 abstract class TestSchedulingModule {
 
   @Binds
   abstract Scheduler scheduler(DefaultScheduler scheduler);
+
+  @Provides
+  @Singleton
+  static WorkScheduler workScheduler(Provider<Uploader> uploader) {
+    return spy(new TestWorkScheduler(uploader));
+  }
 }
diff --git a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/TestWorkScheduler.java b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/TestWorkScheduler.java
index cad794467..633a07eba 100644
--- a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/TestWorkScheduler.java
+++ b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/TestWorkScheduler.java
@@ -14,15 +14,16 @@
 
 package com.google.android.datatransport.runtime;
 
-import android.content.Context;
+import com.google.android.datatransport.runtime.scheduling.jobscheduling.Uploader;
 import com.google.android.datatransport.runtime.scheduling.jobscheduling.WorkScheduler;
+import javax.inject.Provider;
 
 public class TestWorkScheduler implements WorkScheduler {
 
-  private final Context context;
+  private final Provider<Uploader> uploader;
 
-  public TestWorkScheduler(Context applicationContext) {
-    this.context = applicationContext;
+  TestWorkScheduler(Provider<Uploader> uploader) {
+    this.uploader = uploader;
   }
 
   @Override
@@ -30,7 +31,6 @@ public void schedule(TransportContext transportContext, int attemptNumber) {
     if (attemptNumber > 2) {
       return;
     }
-    TransportRuntime.initialize(context);
-    TransportRuntime.getInstance().getUploader().upload(transportContext, attemptNumber, () -> {});
+    uploader.get().upload(transportContext, attemptNumber, () -> {});
   }
 }
diff --git a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/UploaderIntegrationTest.java b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/UploaderIntegrationTest.java
index b191e6703..55369f186 100644
--- a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/UploaderIntegrationTest.java
+++ b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/UploaderIntegrationTest.java
@@ -19,14 +19,13 @@
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.content.Context;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.datatransport.Event;
 import com.google.android.datatransport.Priority;
 import com.google.android.datatransport.Transport;
@@ -53,17 +52,17 @@
   private final TransportBackend mockBackend = mock(TransportBackend.class);
   private final BackendRegistry mockRegistry = mock(BackendRegistry.class);
   private final Context context = InstrumentationRegistry.getInstrumentation().getContext();
-  private final WorkScheduler spyScheduler = spy(new TestWorkScheduler(context));
 
-  private final TransportRuntimeComponent component =
+  private final UploaderTestRuntimeComponent component =
       DaggerUploaderTestRuntimeComponent.builder()
           .setApplicationContext(context)
           .setBackendRegistry(mockRegistry)
-          .setWorkScheduler(spyScheduler)
           .setEventClock(() -> 3)
           .setUptimeClock(() -> 1)
           .build();
 
+  private final WorkScheduler spyScheduler = component.getWorkScheduler();
+
   @Rule public final TransportRuntimeRule runtimeRule = new TransportRuntimeRule(component);
 
   @Before
diff --git a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/UploaderTestRuntimeComponent.java b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/UploaderTestRuntimeComponent.java
index 1234fa807..c73352942 100644
--- a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/UploaderTestRuntimeComponent.java
+++ b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/UploaderTestRuntimeComponent.java
@@ -17,13 +17,14 @@
 import android.content.Context;
 import com.google.android.datatransport.runtime.backends.BackendRegistry;
 import com.google.android.datatransport.runtime.scheduling.jobscheduling.WorkScheduler;
-import com.google.android.datatransport.runtime.scheduling.persistence.EventStore;
+import com.google.android.datatransport.runtime.scheduling.persistence.SQLiteEventStore;
 import com.google.android.datatransport.runtime.scheduling.persistence.SpyEventStoreModule;
 import com.google.android.datatransport.runtime.time.Clock;
 import com.google.android.datatransport.runtime.time.Monotonic;
 import com.google.android.datatransport.runtime.time.WallTime;
 import dagger.BindsInstance;
 import dagger.Component;
+import java.io.IOException;
 import javax.inject.Singleton;
 
 @Component(
@@ -37,16 +38,21 @@
 
   abstract TransportRuntime getTransportRuntime();
 
-  abstract EventStore getEventStore();
+  abstract SQLiteEventStore getEventStore();
+
+  abstract WorkScheduler getWorkScheduler();
+
+  @Override
+  public void close() throws IOException {
+    getEventStore().clearDb();
+    super.close();
+  }
 
   @Component.Builder
   interface Builder {
     @BindsInstance
     Builder setApplicationContext(Context applicationContext);
 
-    @BindsInstance
-    Builder setWorkScheduler(WorkScheduler workScheduler);
-
     @BindsInstance
     Builder setBackendRegistry(BackendRegistry registry);
 
diff --git a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/MultiProcessSynchronizationGuardTest.java b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/MultiProcessSynchronizationGuardTest.java
index 96a2a2a23..f9d597ea5 100644
--- a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/MultiProcessSynchronizationGuardTest.java
+++ b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/MultiProcessSynchronizationGuardTest.java
@@ -20,9 +20,9 @@
 import android.app.Service;
 import android.content.Intent;
 import android.os.RemoteException;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.rule.ServiceTestRule;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.rule.ServiceTestRule;
+import androidx.test.runner.AndroidJUnit4;
 import com.google.android.datatransport.runtime.ITestRemoteLockRpc;
 import java.util.concurrent.TimeoutException;
 import org.junit.After;
diff --git a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/persistence/SpyEventStoreModule.java b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/persistence/SpyEventStoreModule.java
index d6729b5fa..d3d0a6333 100644
--- a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/persistence/SpyEventStoreModule.java
+++ b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/persistence/SpyEventStoreModule.java
@@ -17,9 +17,13 @@
 import static org.mockito.Mockito.spy;
 
 import com.google.android.datatransport.runtime.synchronization.SynchronizationGuard;
+import com.google.android.datatransport.runtime.time.Clock;
+import com.google.android.datatransport.runtime.time.Monotonic;
+import com.google.android.datatransport.runtime.time.WallTime;
 import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
+import javax.inject.Named;
 import javax.inject.Singleton;
 
 @Module
@@ -31,10 +35,23 @@ static EventStoreConfig storeConfig() {
 
   @Provides
   @Singleton
-  static EventStore eventStore(SQLiteEventStore store) {
-    return spy(store);
+  static SQLiteEventStore sqliteEventStore(
+      @WallTime Clock wallClock,
+      @Monotonic Clock clock,
+      EventStoreConfig config,
+      SchemaManager schemaManager) {
+    return spy(new SQLiteEventStore(wallClock, clock, config, schemaManager));
   }
 
+  @Binds
+  abstract EventStore eventStore(SQLiteEventStore store);
+
   @Binds
   abstract SynchronizationGuard synchronizationGuard(SQLiteEventStore store);
+
+  @Provides
+  @Named("SCHEMA_VERSION")
+  static int schemaVersion() {
+    return SchemaManager.SCHEMA_VERSION;
+  }
 }
diff --git a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/persistence/TestEventStoreModule.java b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/persistence/TestEventStoreModule.java
index 07f80479f..758be3234 100644
--- a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/persistence/TestEventStoreModule.java
+++ b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/persistence/TestEventStoreModule.java
@@ -14,10 +14,13 @@
 
 package com.google.android.datatransport.runtime.scheduling.persistence;
 
+import static com.google.android.datatransport.runtime.scheduling.persistence.SchemaManager.SCHEMA_VERSION;
+
 import com.google.android.datatransport.runtime.synchronization.SynchronizationGuard;
 import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
+import javax.inject.Named;
 
 @Module
 public abstract class TestEventStoreModule {
@@ -40,4 +43,10 @@ static EventStoreConfig storeConfig() {
 
   @Binds
   abstract SynchronizationGuard synchronizationGuard(SQLiteEventStore store);
+
+  @Provides
+  @Named("SCHEMA_VERSION")
+  static int schemaVersion() {
+    return SCHEMA_VERSION;
+  }
 }
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/Destination.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/Destination.java
new file mode 100644
index 000000000..c25436048
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/Destination.java
@@ -0,0 +1,35 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+public interface Destination {
+  /** Name that can be used to discover the backend */
+  @NonNull
+  String getName();
+
+  /**
+   * Any extras that must be passed to the backend while uploading. Uploads to the backend are
+   * grouped by (backend_name, priority, extras)
+   *
+   * <p>Note that backends that change the implementations of this method must prepare to
+   * deserialize older implementations as well. For events that have already been written to disk,
+   * extras may be at older versions.
+   */
+  @Nullable
+  byte[] getExtras();
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/EventInternal.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/EventInternal.java
index cc143370e..11f475ead 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/EventInternal.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/EventInternal.java
@@ -14,7 +14,7 @@
 
 package com.google.android.datatransport.runtime;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.auto.value.AutoValue;
 import java.util.Collections;
 import java.util.HashMap;
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportContext.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportContext.java
index 06f88717a..5b6acb2b3 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportContext.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportContext.java
@@ -14,7 +14,9 @@
 
 package com.google.android.datatransport.runtime;
 
-import android.support.annotation.RestrictTo;
+import android.util.Base64;
+import androidx.annotation.Nullable;
+import androidx.annotation.RestrictTo;
 import com.google.android.datatransport.Priority;
 import com.google.auto.value.AutoValue;
 
@@ -26,6 +28,9 @@
   /** Backend events are sent to. */
   public abstract String getBackendName();
 
+  @Nullable
+  public abstract byte[] getExtras();
+
   /**
    * Priority of the event.
    *
@@ -37,6 +42,15 @@
   @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
   public abstract Priority getPriority();
 
+  @Override
+  public String toString() {
+    return String.format(
+        "TransportContext(%s, %s, %s)",
+        getBackendName(),
+        getPriority(),
+        getExtras() == null ? "" : Base64.encodeToString(getExtras(), Base64.NO_WRAP));
+  }
+
   /** Returns a new builder for {@link TransportContext}. */
   public static Builder builder() {
     return new AutoValue_TransportContext.Builder().setPriority(Priority.DEFAULT);
@@ -49,7 +63,11 @@ public static Builder builder() {
    */
   @RestrictTo(RestrictTo.Scope.LIBRARY)
   public TransportContext withPriority(Priority priority) {
-    return builder().setBackendName(getBackendName()).setPriority(priority).build();
+    return builder()
+        .setBackendName(getBackendName())
+        .setPriority(priority)
+        .setExtras(getExtras())
+        .build();
   }
 
   @AutoValue.Builder
@@ -58,6 +76,8 @@ public TransportContext withPriority(Priority priority) {
 
     public abstract Builder setBackendName(String name);
 
+    public abstract Builder setExtras(@Nullable byte[] extras);
+
     /** @hide */
     @RestrictTo(RestrictTo.Scope.LIBRARY)
     public abstract Builder setPriority(Priority priority);
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportRuntime.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportRuntime.java
index 6b35c2798..8946c011b 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportRuntime.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportRuntime.java
@@ -15,11 +15,12 @@
 package com.google.android.datatransport.runtime;
 
 import android.content.Context;
-import android.support.annotation.RestrictTo;
-import android.support.annotation.VisibleForTesting;
+import androidx.annotation.RestrictTo;
+import androidx.annotation.VisibleForTesting;
 import com.google.android.datatransport.TransportFactory;
 import com.google.android.datatransport.runtime.scheduling.Scheduler;
 import com.google.android.datatransport.runtime.scheduling.jobscheduling.Uploader;
+import com.google.android.datatransport.runtime.scheduling.jobscheduling.WorkInitializer;
 import com.google.android.datatransport.runtime.time.Clock;
 import com.google.android.datatransport.runtime.time.Monotonic;
 import com.google.android.datatransport.runtime.time.WallTime;
@@ -36,7 +37,7 @@
 @Singleton
 public class TransportRuntime implements TransportInternal {
 
-  private static volatile TransportRuntimeComponent INSTANCE = null;
+  private static volatile TransportRuntimeComponent instance = null;
 
   private final Clock eventClock;
   private final Clock uptimeClock;
@@ -48,11 +49,14 @@
       @WallTime Clock eventClock,
       @Monotonic Clock uptimeClock,
       Scheduler scheduler,
-      Uploader uploader) {
+      Uploader uploader,
+      WorkInitializer initializer) {
     this.eventClock = eventClock;
     this.uptimeClock = uptimeClock;
     this.scheduler = scheduler;
     this.uploader = uploader;
+
+    initializer.ensureContextsScheduled();
   }
 
   /**
@@ -61,12 +65,14 @@
    * <p>This method must be called before {@link #getInstance()}.
    */
   public static void initialize(Context applicationContext) {
-    if (INSTANCE == null) {
+    if (instance == null) {
       synchronized (TransportRuntime.class) {
-        INSTANCE =
-            DaggerTransportRuntimeComponent.builder()
-                .setApplicationContext(applicationContext)
-                .build();
+        if (instance == null) {
+          instance =
+              DaggerTransportRuntimeComponent.builder()
+                  .setApplicationContext(applicationContext)
+                  .build();
+        }
       }
     }
     // send warning
@@ -78,7 +84,7 @@ public static void initialize(Context applicationContext) {
    * @throws IllegalStateException if {@link #initialize(Context)} is not called before this method.
    */
   public static TransportRuntime getInstance() {
-    TransportRuntimeComponent localRef = INSTANCE;
+    TransportRuntimeComponent localRef = instance;
     if (localRef == null) {
       throw new IllegalStateException("Not initialized!");
     }
@@ -91,24 +97,35 @@ static void withInstance(TransportRuntimeComponent component, Callable<Void> cal
       throws Throwable {
     TransportRuntimeComponent original;
     synchronized (TransportRuntime.class) {
-      original = INSTANCE;
-      INSTANCE = component;
+      original = instance;
+      instance = component;
     }
     try {
       callable.call();
     } finally {
       synchronized (TransportRuntime.class) {
-        INSTANCE = original;
+        instance = original;
       }
     }
   }
 
   /** Returns a {@link TransportFactory} for a given {@code backendName}. */
+  @Deprecated
   public TransportFactory newFactory(String backendName) {
     return new TransportFactoryImpl(
         TransportContext.builder().setBackendName(backendName).build(), this);
   }
 
+  /** Returns a {@link TransportFactory} for a given {@code backendName}. */
+  public TransportFactory newFactory(Destination destination) {
+    return new TransportFactoryImpl(
+        TransportContext.builder()
+            .setBackendName(destination.getName())
+            .setExtras(destination.getExtras())
+            .build(),
+        this);
+  }
+
   @RestrictTo(RestrictTo.Scope.LIBRARY)
   public Uploader getUploader() {
     return uploader;
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/BackendRegistry.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/BackendRegistry.java
index 2f4bd921a..24d60e3bd 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/BackendRegistry.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/BackendRegistry.java
@@ -14,7 +14,7 @@
 
 package com.google.android.datatransport.runtime.backends;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 public interface BackendRegistry {
   @Nullable
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/BackendRegistryModule.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/BackendRegistryModule.java
index 4f9ebc693..4ab33b765 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/BackendRegistryModule.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/BackendRegistryModule.java
@@ -14,24 +14,11 @@
 
 package com.google.android.datatransport.runtime.backends;
 
-import android.content.Context;
-import com.google.android.datatransport.runtime.time.Clock;
-import com.google.android.datatransport.runtime.time.Monotonic;
-import com.google.android.datatransport.runtime.time.WallTime;
 import dagger.Binds;
 import dagger.Module;
-import dagger.Provides;
-import javax.inject.Singleton;
 
 @Module
 public abstract class BackendRegistryModule {
   @Binds
   abstract BackendRegistry backendRegistry(MetadataBackendRegistry registry);
-
-  @Provides
-  @Singleton
-  static CreationContext creationContext(
-      Context applicationContext, @WallTime Clock wallClock, @Monotonic Clock monotonicClock) {
-    return CreationContext.create(applicationContext, wallClock, monotonicClock);
-  }
 }
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/BackendRequest.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/BackendRequest.java
index b51a70d2a..ca5b9953a 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/BackendRequest.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/BackendRequest.java
@@ -14,6 +14,7 @@
 
 package com.google.android.datatransport.runtime.backends;
 
+import androidx.annotation.Nullable;
 import com.google.android.datatransport.runtime.EventInternal;
 import com.google.auto.value.AutoValue;
 
@@ -23,8 +24,24 @@
   /** Events to be sent to the backend. */
   public abstract Iterable<EventInternal> getEvents();
 
+  @Nullable
+  public abstract byte[] getExtras();
+
   /** Creates a new instance of the request. */
   public static BackendRequest create(Iterable<EventInternal> events) {
-    return new AutoValue_BackendRequest(events);
+    return BackendRequest.builder().setEvents(events).build();
+  }
+
+  public static Builder builder() {
+    return new AutoValue_BackendRequest.Builder();
+  }
+
+  @AutoValue.Builder
+  public abstract static class Builder {
+    public abstract Builder setEvents(Iterable<EventInternal> events);
+
+    public abstract Builder setExtras(@Nullable byte[] extras);
+
+    public abstract BackendRequest build();
   }
 }
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/CreationContext.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/CreationContext.java
index 97cbc06ef..72e5d0589 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/CreationContext.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/CreationContext.java
@@ -15,6 +15,7 @@
 package com.google.android.datatransport.runtime.backends;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
 import com.google.android.datatransport.runtime.time.Clock;
 import com.google.auto.value.AutoValue;
 
@@ -25,6 +26,7 @@
  */
 @AutoValue
 public abstract class CreationContext {
+  private static final String DEFAULT_BACKEND_NAME = "cct";
 
   /** Returns the {@link Context application context}. */
   public abstract Context getApplicationContext();
@@ -38,6 +40,17 @@
   /** Creates a new instance of {@link CreationContext}. */
   public static CreationContext create(
       Context applicationContext, Clock wallClock, Clock monotonicClock) {
-    return new AutoValue_CreationContext(applicationContext, wallClock, monotonicClock);
+
+    return new AutoValue_CreationContext(
+        applicationContext, wallClock, monotonicClock, DEFAULT_BACKEND_NAME);
+  }
+
+  public static CreationContext create(
+      Context applicationContext, Clock wallClock, Clock monotonicClock, String backendName) {
+    return new AutoValue_CreationContext(
+        applicationContext, wallClock, monotonicClock, backendName);
   }
+  /** Returns the backend name. */
+  @NonNull
+  public abstract String getBackendName();
 }
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/CreationContextFactory.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/CreationContextFactory.java
new file mode 100644
index 000000000..6e4a79d45
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/CreationContextFactory.java
@@ -0,0 +1,39 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.backends;
+
+import android.content.Context;
+import com.google.android.datatransport.runtime.time.Clock;
+import com.google.android.datatransport.runtime.time.Monotonic;
+import com.google.android.datatransport.runtime.time.WallTime;
+import javax.inject.Inject;
+
+class CreationContextFactory {
+  private final Context applicationContext;
+  private final Clock wallClock;
+  private final Clock monotonicClock;
+
+  @Inject
+  CreationContextFactory(
+      Context applicationContext, @WallTime Clock wallClock, @Monotonic Clock monotonicClock) {
+    this.applicationContext = applicationContext;
+    this.wallClock = wallClock;
+    this.monotonicClock = monotonicClock;
+  }
+
+  CreationContext create(String backendName) {
+    return CreationContext.create(applicationContext, wallClock, monotonicClock, backendName);
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/MetadataBackendRegistry.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/MetadataBackendRegistry.java
index e7a986cd4..ea984d288 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/MetadataBackendRegistry.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/MetadataBackendRegistry.java
@@ -19,8 +19,8 @@
 import android.content.pm.PackageManager;
 import android.content.pm.ServiceInfo;
 import android.os.Bundle;
-import android.support.annotation.Nullable;
 import android.util.Log;
+import androidx.annotation.Nullable;
 import java.lang.reflect.InvocationTargetException;
 import java.util.Collections;
 import java.util.HashMap;
@@ -49,15 +49,21 @@
   private static final String TAG = "BackendRegistry";
   private static final String BACKEND_KEY_PREFIX = "backend:";
 
-  private final Context applicationContext;
-  private final CreationContext creationContext;
+  private final BackendFactoryProvider backendFactoryProvider;
+  private final CreationContextFactory creationContextFactory;
   private final Map<String, TransportBackend> backends = new HashMap<>();
-  private Map<String, String> backendProviders = null;
 
   @Inject
-  MetadataBackendRegistry(Context applicationContext, CreationContext creationContext) {
-    this.applicationContext = applicationContext;
-    this.creationContext = creationContext;
+  MetadataBackendRegistry(
+      Context applicationContext, CreationContextFactory creationContextFactory) {
+    this(new BackendFactoryProvider(applicationContext), creationContextFactory);
+  }
+
+  MetadataBackendRegistry(
+      BackendFactoryProvider backendFactoryProvider,
+      CreationContextFactory creationContextFactory) {
+    this.backendFactoryProvider = backendFactoryProvider;
+    this.creationContextFactory = creationContextFactory;
   }
 
   @Override
@@ -66,85 +72,102 @@ public synchronized TransportBackend get(String name) {
     if (backends.containsKey(name)) {
       return backends.get(name);
     }
-    String backendProviderName = getBackendProviders().get(name);
-    if (backendProviderName == null) {
+
+    BackendFactory factory = backendFactoryProvider.get(name);
+    if (factory == null) {
       return null;
     }
+    TransportBackend backend = factory.create(creationContextFactory.create(name));
+    backends.put(name, backend);
+    return backend;
+  }
+
+  static class BackendFactoryProvider {
+    private final Context applicationContext;
+    private Map<String, String> backendProviders = null;
 
-    try {
-      BackendFactory provider =
-          Class.forName(backendProviderName)
-              .asSubclass(BackendFactory.class)
-              .getDeclaredConstructor()
-              .newInstance();
-      TransportBackend newBackend = provider.create(creationContext);
-      backends.put(name, newBackend);
-      return newBackend;
-    } catch (ClassNotFoundException e) {
-      Log.w(TAG, String.format("Class %s is not found.", backendProviderName), e);
-    } catch (IllegalAccessException e) {
-      Log.w(TAG, String.format("Could not instantiate %s.", backendProviderName), e);
-    } catch (InstantiationException e) {
-      Log.w(TAG, String.format("Could not instantiate %s.", backendProviderName), e);
-    } catch (NoSuchMethodException e) {
-      Log.w(TAG, String.format("Could not instantiate %s", backendProviderName), e);
-    } catch (InvocationTargetException e) {
-      Log.w(TAG, String.format("Could not instantiate %s", backendProviderName), e);
+    BackendFactoryProvider(Context applicationContext) {
+      this.applicationContext = applicationContext;
     }
 
-    return null;
-  }
+    @Nullable
+    BackendFactory get(String name) {
+      String backendProviderName = getBackendProviders().get(name);
+      if (backendProviderName == null) {
+        return null;
+      }
 
-  private Map<String, String> getBackendProviders() {
-    if (backendProviders == null) {
-      backendProviders = discover(applicationContext);
-    }
-    return backendProviders;
-  }
+      try {
+        return Class.forName(backendProviderName)
+            .asSubclass(BackendFactory.class)
+            .getDeclaredConstructor()
+            .newInstance();
+      } catch (ClassNotFoundException e) {
+        Log.w(TAG, String.format("Class %s is not found.", backendProviderName), e);
+      } catch (IllegalAccessException e) {
+        Log.w(TAG, String.format("Could not instantiate %s.", backendProviderName), e);
+      } catch (InstantiationException e) {
+        Log.w(TAG, String.format("Could not instantiate %s.", backendProviderName), e);
+      } catch (NoSuchMethodException e) {
+        Log.w(TAG, String.format("Could not instantiate %s", backendProviderName), e);
+      } catch (InvocationTargetException e) {
+        Log.w(TAG, String.format("Could not instantiate %s", backendProviderName), e);
+      }
 
-  private Map<String, String> discover(Context ctx) {
-    Bundle metadata = getMetadata(ctx);
+      return null;
+    }
 
-    if (metadata == null) {
-      Log.w(TAG, "Could not retrieve metadata, returning empty list of transport backends.");
-      return Collections.emptyMap();
+    private Map<String, String> getBackendProviders() {
+      if (backendProviders == null) {
+        backendProviders = discover(applicationContext);
+      }
+      return backendProviders;
     }
 
-    Map<String, String> backendNames = new HashMap<>();
-    for (String key : metadata.keySet()) {
-      Object rawValue = metadata.get(key);
-      if (rawValue instanceof String && key.startsWith(BACKEND_KEY_PREFIX)) {
-        for (String name : ((String) rawValue).split(",", -1)) {
-          name = name.trim();
-          if (name.isEmpty()) {
-            continue;
+    private Map<String, String> discover(Context ctx) {
+      Bundle metadata = getMetadata(ctx);
+
+      if (metadata == null) {
+        Log.w(TAG, "Could not retrieve metadata, returning empty list of transport backends.");
+        return Collections.emptyMap();
+      }
+
+      Map<String, String> backendNames = new HashMap<>();
+      for (String key : metadata.keySet()) {
+        Object rawValue = metadata.get(key);
+        if (rawValue instanceof String && key.startsWith(BACKEND_KEY_PREFIX)) {
+          for (String name : ((String) rawValue).split(",", -1)) {
+            name = name.trim();
+            if (name.isEmpty()) {
+              continue;
+            }
+            backendNames.put(name, key.substring(BACKEND_KEY_PREFIX.length()));
           }
-          backendNames.put(name, key.substring(BACKEND_KEY_PREFIX.length()));
         }
       }
+      return backendNames;
     }
-    return backendNames;
-  }
 
-  private static Bundle getMetadata(Context context) {
-    try {
-      PackageManager manager = context.getPackageManager();
-      if (manager == null) {
-        Log.w(TAG, "Context has no PackageManager.");
-        return null;
-      }
-      ServiceInfo info =
-          manager.getServiceInfo(
-              new ComponentName(context, TransportBackendDiscovery.class),
-              PackageManager.GET_META_DATA);
-      if (info == null) {
-        Log.w(TAG, "TransportBackendDiscovery has no service info.");
+    private static Bundle getMetadata(Context context) {
+      try {
+        PackageManager manager = context.getPackageManager();
+        if (manager == null) {
+          Log.w(TAG, "Context has no PackageManager.");
+          return null;
+        }
+        ServiceInfo info =
+            manager.getServiceInfo(
+                new ComponentName(context, TransportBackendDiscovery.class),
+                PackageManager.GET_META_DATA);
+        if (info == null) {
+          Log.w(TAG, "TransportBackendDiscovery has no service info.");
+          return null;
+        }
+        return info.metaData;
+      } catch (PackageManager.NameNotFoundException e) {
+        Log.w(TAG, "Application info not found.");
         return null;
       }
-      return info.metaData;
-    } catch (PackageManager.NameNotFoundException e) {
-      Log.w(TAG, "Application info not found.");
-      return null;
     }
   }
 }
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/package-info.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/package-info.java
new file mode 100644
index 000000000..e591571ce
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/backends/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.android.datatransport.runtime.backends;
\ No newline at end of file
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/logging/Logging.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/logging/Logging.java
new file mode 100644
index 000000000..d203c9000
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/logging/Logging.java
@@ -0,0 +1,49 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.logging;
+
+import android.util.Log;
+
+public final class Logging {
+  private Logging() {}
+
+  private static String getTag(String tag) {
+    return "TransportRuntime." + tag;
+  }
+
+  public static void d(String tag, String message) {
+    Log.d(getTag(tag), message);
+  }
+
+  public static void d(String tag, String message, Object arg1) {
+    Log.d(getTag(tag), String.format(message, arg1));
+  }
+
+  public static void d(String tag, String message, Object arg1, Object arg2) {
+    Log.d(getTag(tag), String.format(message, arg1, arg2));
+  }
+
+  public static void d(String tag, String message, Object... args) {
+    Log.d(getTag(tag), String.format(message, args));
+  }
+
+  public static void i(String tag, String message) {
+    Log.i(getTag(tag), message);
+  }
+
+  public static void e(String tag, String message, Throwable e) {
+    Log.e(getTag(tag), message, e);
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/logging/package-info.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/logging/package-info.java
new file mode 100644
index 000000000..4580dbfd0
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/logging/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.android.datatransport.runtime.logging;
\ No newline at end of file
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/package-info.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/package-info.java
new file mode 100644
index 000000000..267e9a20f
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.android.datatransport.runtime;
\ No newline at end of file
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/retries/Function.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/retries/Function.java
new file mode 100644
index 000000000..acf9f2289
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/retries/Function.java
@@ -0,0 +1,20 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.retries;
+
+/** Generic functional interface which supports checked exceptions. */
+public interface Function<TInput, TResult, TException extends Throwable> {
+  TResult apply(TInput input) throws TException;
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/retries/Retries.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/retries/Retries.java
new file mode 100644
index 000000000..283add987
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/retries/Retries.java
@@ -0,0 +1,62 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.retries;
+
+/** Provides utilities to retry function calls. */
+public final class Retries {
+  private Retries() {}
+
+  /**
+   * Retries given {@link Function} upto {@code maxAttempts} times.
+   *
+   * <p>It takes an {@code input} parameter that is passed to the first {@link Function} call. The
+   * rest of the retries are called with the value produced by the {@code retryStrategy}. If the
+   * {@code retryStrategy} returns null, the retries are stopped and the result of the last retry is
+   * returned.
+   *
+   * <p>Example
+   *
+   * <pre>{@code
+   * int initialParameter = 10;
+   *
+   * // finalResult is 12.
+   * int finalResult = retry(5, initialParameter, Integer::valueOf, (input, result) -> {
+   *   if ( result.equals(12)) {
+   *     return null;
+   *   }
+   *   return input + 1;
+   * });
+   * }</pre>
+   */
+  public static <TInput, TResult, TException extends Throwable> TResult retry(
+      int maxAttempts,
+      TInput input,
+      Function<TInput, TResult, TException> function,
+      RetryStrategy<TInput, TResult> retryStrategy)
+      throws TException {
+    if (maxAttempts < 1) {
+      return function.apply(input);
+    }
+
+    while (true) {
+      TResult result = function.apply(input);
+      input = retryStrategy.shouldRetry(input, result);
+
+      if (input == null || --maxAttempts < 1) {
+        return result;
+      }
+    }
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/retries/RetryStrategy.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/retries/RetryStrategy.java
new file mode 100644
index 000000000..b16d44504
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/retries/RetryStrategy.java
@@ -0,0 +1,28 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.retries;
+
+import androidx.annotation.Nullable;
+
+public interface RetryStrategy<TInput, TResult> {
+  /**
+   * Whether a function call should be retried with a new input.
+   *
+   * <p>Given an input and result of a function call, return a new input to cause call to be
+   * retried, returning null will prevent further retries.
+   */
+  @Nullable
+  TInput shouldRetry(TInput input, TResult result);
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/retries/package-info.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/retries/package-info.java
new file mode 100644
index 000000000..63f6d8664
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/retries/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.android.datatransport.runtime.retries;
\ No newline at end of file
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/AlarmManagerScheduler.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/AlarmManagerScheduler.java
index dc1c41761..1706e0975 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/AlarmManagerScheduler.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/AlarmManagerScheduler.java
@@ -19,8 +19,10 @@
 import android.content.Context;
 import android.content.Intent;
 import android.net.Uri;
-import android.support.annotation.VisibleForTesting;
+import android.util.Base64;
+import androidx.annotation.VisibleForTesting;
 import com.google.android.datatransport.runtime.TransportContext;
+import com.google.android.datatransport.runtime.logging.Logging;
 import com.google.android.datatransport.runtime.scheduling.persistence.EventStore;
 
 /**
@@ -28,9 +30,11 @@
  * Used for Apis 20 and below.
  */
 public class AlarmManagerScheduler implements WorkScheduler {
+  private static final String LOG_TAG = "AlarmManagerScheduler";
   static final String ATTEMPT_NUMBER = "attemptNumber";
   static final String BACKEND_NAME = "backendName";
   static final String EVENT_PRIORITY = "priority";
+  static final String EXTRAS = "extras";
 
   private final Context context;
 
@@ -78,18 +82,34 @@ public void schedule(TransportContext transportContext, int attemptNumber) {
     intentDataBuilder.appendQueryParameter(BACKEND_NAME, transportContext.getBackendName());
     intentDataBuilder.appendQueryParameter(
         EVENT_PRIORITY, String.valueOf(transportContext.getPriority().ordinal()));
+    if (transportContext.getExtras() != null) {
+      intentDataBuilder.appendQueryParameter(
+          EXTRAS, Base64.encodeToString(transportContext.getExtras(), Base64.DEFAULT));
+    }
     Intent intent = new Intent(context, AlarmManagerSchedulerBroadcastReceiver.class);
     intent.setData(intentDataBuilder.build());
     intent.putExtra(ATTEMPT_NUMBER, attemptNumber);
 
-    if (isJobServiceOn(intent)) return;
+    if (isJobServiceOn(intent)) {
+      Logging.d(
+          LOG_TAG, "Upload for context %s is already scheduled. Returning...", transportContext);
+      return;
+    }
 
     long backendTime = eventStore.getNextCallTime(transportContext);
 
+    long scheduleDelay =
+        config.getScheduleDelay(transportContext.getPriority(), backendTime, attemptNumber);
+
+    Logging.d(
+        LOG_TAG,
+        "Scheduling upload for context %s in %dms(Backend next call timestamp %d). Attempt %d",
+        transportContext,
+        scheduleDelay,
+        backendTime,
+        attemptNumber);
+
     PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intent, 0);
-    this.alarmManager.set(
-        AlarmManager.ELAPSED_REALTIME,
-        config.getScheduleDelay(transportContext.getPriority(), backendTime, attemptNumber),
-        pendingIntent);
+    this.alarmManager.set(AlarmManager.ELAPSED_REALTIME, scheduleDelay, pendingIntent);
   }
 }
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/AlarmManagerSchedulerBroadcastReceiver.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/AlarmManagerSchedulerBroadcastReceiver.java
index 80844c6a9..98db1058b 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/AlarmManagerSchedulerBroadcastReceiver.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/AlarmManagerSchedulerBroadcastReceiver.java
@@ -14,6 +14,8 @@
 
 package com.google.android.datatransport.runtime.scheduling.jobscheduling;
 
+import static android.util.Base64.*;
+
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
@@ -26,15 +28,21 @@
   @Override
   public void onReceive(Context context, Intent intent) {
     String backendName = intent.getData().getQueryParameter(AlarmManagerScheduler.BACKEND_NAME);
+    String extras = intent.getData().getQueryParameter(AlarmManagerScheduler.EXTRAS);
     int priority =
         Integer.valueOf(intent.getData().getQueryParameter(AlarmManagerScheduler.EVENT_PRIORITY));
     int attemptNumber = intent.getExtras().getInt(AlarmManagerScheduler.ATTEMPT_NUMBER);
     TransportRuntime.initialize(context);
+
+    TransportContext.Builder transportContext =
+        TransportContext.builder().setBackendName(backendName).setPriority(priority);
+
+    if (extras != null) {
+      transportContext.setExtras(decode(extras, DEFAULT));
+    }
+
     TransportRuntime.getInstance()
         .getUploader()
-        .upload(
-            TransportContext.builder().setBackendName(backendName).setPriority(priority).build(),
-            attemptNumber,
-            () -> {});
+        .upload(transportContext.build(), attemptNumber, () -> {});
   }
 }
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoScheduler.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoScheduler.java
index 0c582d46c..b12e1a77e 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoScheduler.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoScheduler.java
@@ -14,15 +14,18 @@
 
 package com.google.android.datatransport.runtime.scheduling.jobscheduling;
 
+import static android.util.Base64.*;
+
 import android.app.job.JobInfo;
 import android.app.job.JobScheduler;
 import android.content.ComponentName;
 import android.content.Context;
 import android.os.Build;
 import android.os.PersistableBundle;
-import android.support.annotation.RequiresApi;
-import android.support.annotation.VisibleForTesting;
+import androidx.annotation.RequiresApi;
+import androidx.annotation.VisibleForTesting;
 import com.google.android.datatransport.runtime.TransportContext;
+import com.google.android.datatransport.runtime.logging.Logging;
 import com.google.android.datatransport.runtime.scheduling.persistence.EventStore;
 import java.nio.ByteBuffer;
 import java.util.zip.Adler32;
@@ -33,9 +36,12 @@
  */
 @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
 public class JobInfoScheduler implements WorkScheduler {
+  private static final String LOG_TAG = "JobInfoScheduler";
+
   static final String ATTEMPT_NUMBER = "attemptNumber";
   static final String BACKEND_NAME = "backendName";
   static final String EVENT_PRIORITY = "priority";
+  static final String EXTRAS = "extras";
 
   private final Context context;
 
@@ -57,6 +63,9 @@ int getJobId(TransportContext transportContext) {
     checksum.update(transportContext.getBackendName().getBytes());
     checksum.update(
         ByteBuffer.allocate(4).putInt(transportContext.getPriority().ordinal()).array());
+    if (transportContext.getExtras() != null) {
+      checksum.update(transportContext.getExtras());
+    }
     return (int) checksum.getValue();
   }
 
@@ -83,22 +92,40 @@ public void schedule(TransportContext transportContext, int attemptNumber) {
         (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
     int jobId = getJobId(transportContext);
     // Check if there exists a job scheduled for this backend name.
-    if (isJobServiceOn(jobScheduler, jobId, attemptNumber)) return;
+    if (isJobServiceOn(jobScheduler, jobId, attemptNumber)) {
+      Logging.d(
+          LOG_TAG, "Upload for context %s is already scheduled. Returning...", transportContext);
+      return;
+    }
+
+    long nextCallTime = eventStore.getNextCallTime(transportContext);
 
     // Schedule the build.
     JobInfo.Builder builder =
         config.configureJob(
             new JobInfo.Builder(jobId, serviceComponent),
             transportContext.getPriority(),
-            eventStore.getNextCallTime(transportContext),
+            nextCallTime,
             attemptNumber);
 
     PersistableBundle bundle = new PersistableBundle();
     bundle.putInt(ATTEMPT_NUMBER, attemptNumber);
     bundle.putString(BACKEND_NAME, transportContext.getBackendName());
     bundle.putInt(EVENT_PRIORITY, transportContext.getPriority().ordinal());
+    if (transportContext.getExtras() != null) {
+      bundle.putString(EXTRAS, encodeToString(transportContext.getExtras(), DEFAULT));
+    }
     builder.setExtras(bundle);
 
+    Logging.d(
+        LOG_TAG,
+        "Scheduling upload for context %s with jobId=%d in %dms(Backend next call timestamp %d). Attempt %d",
+        transportContext,
+        jobId,
+        config.getScheduleDelay(transportContext.getPriority(), nextCallTime, attemptNumber),
+        nextCallTime,
+        attemptNumber);
+
     jobScheduler.schedule(builder.build());
   }
 }
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoSchedulerService.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoSchedulerService.java
index e07eefa9f..c493c95c9 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoSchedulerService.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoSchedulerService.java
@@ -17,7 +17,8 @@
 import android.app.job.JobParameters;
 import android.app.job.JobService;
 import android.os.Build;
-import android.support.annotation.RequiresApi;
+import android.util.Base64;
+import androidx.annotation.RequiresApi;
 import com.google.android.datatransport.runtime.TransportContext;
 import com.google.android.datatransport.runtime.TransportRuntime;
 
@@ -28,15 +29,21 @@
   @Override
   public boolean onStartJob(JobParameters params) {
     String backendName = params.getExtras().getString(JobInfoScheduler.BACKEND_NAME);
+    String extras = params.getExtras().getString(JobInfoScheduler.EXTRAS);
+
     int priority = params.getExtras().getInt(JobInfoScheduler.EVENT_PRIORITY);
     int attemptNumber = params.getExtras().getInt(JobInfoScheduler.ATTEMPT_NUMBER);
     TransportRuntime.initialize(getApplicationContext());
+    TransportContext.Builder transportContext =
+        TransportContext.builder().setBackendName(backendName).setPriority(priority);
+
+    if (extras != null) {
+      transportContext.setExtras(Base64.decode(extras, Base64.DEFAULT));
+    }
+
     TransportRuntime.getInstance()
         .getUploader()
-        .upload(
-            TransportContext.builder().setBackendName(backendName).setPriority(priority).build(),
-            attemptNumber,
-            () -> this.jobFinished(params, false));
+        .upload(transportContext.build(), attemptNumber, () -> this.jobFinished(params, false));
     return true;
   }
 
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/SchedulerConfig.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/SchedulerConfig.java
index cc3d0db4f..3d4e6697e 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/SchedulerConfig.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/SchedulerConfig.java
@@ -16,7 +16,7 @@
 
 import android.app.job.JobInfo;
 import android.os.Build;
-import android.support.annotation.RequiresApi;
+import androidx.annotation.RequiresApi;
 import com.google.android.datatransport.Priority;
 import com.google.android.datatransport.runtime.time.Clock;
 import com.google.auto.value.AutoValue;
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/Uploader.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/Uploader.java
index 00c738270..a88ca2429 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/Uploader.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/Uploader.java
@@ -23,6 +23,7 @@
 import com.google.android.datatransport.runtime.backends.BackendRequest;
 import com.google.android.datatransport.runtime.backends.BackendResponse;
 import com.google.android.datatransport.runtime.backends.TransportBackend;
+import com.google.android.datatransport.runtime.logging.Logging;
 import com.google.android.datatransport.runtime.scheduling.persistence.EventStore;
 import com.google.android.datatransport.runtime.scheduling.persistence.PersistedEvent;
 import com.google.android.datatransport.runtime.synchronization.SynchronizationException;
@@ -37,6 +38,8 @@
 /** Handles upload of all the events corresponding to a backend. */
 public class Uploader {
 
+  private static final String LOG_TAG = "Uploader";
+
   private final Context context;
   private final BackendRegistry backendRegistry;
   private final EventStore eventStore;
@@ -94,19 +97,34 @@ public void upload(TransportContext transportContext, int attemptNumber, Runnabl
 
   void logAndUpdateState(TransportContext transportContext, int attemptNumber) {
     TransportBackend backend = backendRegistry.get(transportContext.getBackendName());
-    List<EventInternal> eventInternals = new ArrayList<>();
+
     Iterable<PersistedEvent> persistedEvents =
         guard.runCriticalSection(() -> eventStore.loadBatch(transportContext));
 
-    // Donot make a call to the backend if the list is empty.
+    // Do not make a call to the backend if the list is empty.
     if (!persistedEvents.iterator().hasNext()) {
       return;
     }
-    // Load all the backends to an iterable of event internals.
-    for (PersistedEvent persistedEvent : persistedEvents) {
-      eventInternals.add(persistedEvent.getEvent());
+
+    BackendResponse response;
+    if (backend == null) {
+      Logging.d(
+          LOG_TAG, "Unknown backend for %s, deleting event batch for it...", transportContext);
+      response = BackendResponse.fatalError();
+    } else {
+      List<EventInternal> eventInternals = new ArrayList<>();
+
+      for (PersistedEvent persistedEvent : persistedEvents) {
+        eventInternals.add(persistedEvent.getEvent());
+      }
+      response =
+          backend.send(
+              BackendRequest.builder()
+                  .setEvents(eventInternals)
+                  .setExtras(transportContext.getExtras())
+                  .build());
     }
-    BackendResponse response = backend.send(BackendRequest.create(eventInternals));
+
     guard.runCriticalSection(
         () -> {
           if (response.getStatus() == BackendResponse.Status.TRANSIENT_ERROR) {
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/WorkInitializer.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/WorkInitializer.java
new file mode 100644
index 000000000..af6870148
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/WorkInitializer.java
@@ -0,0 +1,62 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling.jobscheduling;
+
+import com.google.android.datatransport.runtime.TransportContext;
+import com.google.android.datatransport.runtime.scheduling.persistence.EventStore;
+import com.google.android.datatransport.runtime.synchronization.SynchronizationGuard;
+import java.util.concurrent.Executor;
+import javax.inject.Inject;
+
+/**
+ * Re-schedules any contexts that have pending events and are not currently scheduled.
+ *
+ * <p>The reasons for them not to be scheduled include:
+ *
+ * <ul>
+ *   <li>Host application update to newer version
+ *   <li>Device restart
+ * </ul>
+ *
+ * Note: there is no way for us to know how many attempts had been previously tried, so we
+ * re-schedule from attempt 1.
+ */
+public class WorkInitializer {
+  private final Executor executor;
+  private final EventStore store;
+  private final WorkScheduler scheduler;
+  private final SynchronizationGuard guard;
+
+  @Inject
+  WorkInitializer(
+      Executor executor, EventStore store, WorkScheduler scheduler, SynchronizationGuard guard) {
+    this.executor = executor;
+    this.store = store;
+    this.scheduler = scheduler;
+    this.guard = guard;
+  }
+
+  public void ensureContextsScheduled() {
+    executor.execute(
+        () ->
+            guard.runCriticalSection(
+                () -> {
+                  for (TransportContext context : store.loadActiveContexts()) {
+                    scheduler.schedule(context, 1);
+                  }
+                  return null;
+                }));
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/package-info.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/package-info.java
new file mode 100644
index 000000000..c09d25e8b
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.android.datatransport.runtime.scheduling.jobscheduling;
\ No newline at end of file
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/package-info.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/package-info.java
new file mode 100644
index 000000000..cfe5ad9a5
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.android.datatransport.runtime.scheduling;
\ No newline at end of file
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/EventStore.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/EventStore.java
index ac326acd5..cb6939cd8 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/EventStore.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/EventStore.java
@@ -14,8 +14,8 @@
 
 package com.google.android.datatransport.runtime.scheduling.persistence;
 
-import android.support.annotation.Nullable;
-import android.support.annotation.WorkerThread;
+import androidx.annotation.Nullable;
+import androidx.annotation.WorkerThread;
 import com.google.android.datatransport.runtime.EventInternal;
 import com.google.android.datatransport.runtime.TransportContext;
 import java.io.Closeable;
@@ -50,6 +50,9 @@
   /** Load all pending events for a given backend. */
   Iterable<PersistedEvent> loadBatch(TransportContext transportContext);
 
+  /** Load all {@link TransportContext}s that have pending events. */
+  Iterable<TransportContext> loadActiveContexts();
+
   /** Remove events that have been stored for more than 7 days. */
   int cleanUp();
 }
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/EventStoreModule.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/EventStoreModule.java
index bd88e0702..480247eba 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/EventStoreModule.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/EventStoreModule.java
@@ -14,13 +14,17 @@
 
 package com.google.android.datatransport.runtime.scheduling.persistence;
 
+import static com.google.android.datatransport.runtime.scheduling.persistence.SchemaManager.SCHEMA_VERSION;
+
 import com.google.android.datatransport.runtime.synchronization.SynchronizationGuard;
 import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
+import javax.inject.Named;
 
 @Module
 public abstract class EventStoreModule {
+
   @Provides
   static EventStoreConfig storeConfig() {
     return EventStoreConfig.DEFAULT;
@@ -31,4 +35,10 @@ static EventStoreConfig storeConfig() {
 
   @Binds
   abstract SynchronizationGuard synchronizationGuard(SQLiteEventStore store);
+
+  @Provides
+  @Named("SCHEMA_VERSION")
+  static int schemaVersion() {
+    return SCHEMA_VERSION;
+  }
 }
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStore.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStore.java
index 161bb9635..263b8071e 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStore.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStore.java
@@ -15,24 +15,25 @@
 package com.google.android.datatransport.runtime.scheduling.persistence;
 
 import android.content.ContentValues;
-import android.content.Context;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteDatabaseLockedException;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.os.Build;
 import android.os.SystemClock;
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
-import android.support.annotation.WorkerThread;
+import android.util.Base64;
+import androidx.annotation.Nullable;
+import androidx.annotation.RestrictTo;
+import androidx.annotation.VisibleForTesting;
+import androidx.annotation.WorkerThread;
 import com.google.android.datatransport.runtime.EventInternal;
 import com.google.android.datatransport.runtime.TransportContext;
+import com.google.android.datatransport.runtime.logging.Logging;
 import com.google.android.datatransport.runtime.synchronization.SynchronizationException;
 import com.google.android.datatransport.runtime.synchronization.SynchronizationGuard;
 import com.google.android.datatransport.runtime.time.Clock;
 import com.google.android.datatransport.runtime.time.Monotonic;
 import com.google.android.datatransport.runtime.time.WallTime;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -47,24 +48,25 @@
 @Singleton
 @WorkerThread
 public class SQLiteEventStore implements EventStore, SynchronizationGuard {
+  private static final String LOG_TAG = "SQLiteEventStore";
 
   static final int MAX_RETRIES = 10;
 
   private static final int LOCK_RETRY_BACK_OFF_MILLIS = 50;
 
-  private final OpenHelper openHelper;
+  private final SchemaManager schemaManager;
   private final Clock wallClock;
   private final Clock monotonicClock;
   private final EventStoreConfig config;
 
   @Inject
   SQLiteEventStore(
-      Context applicationContext,
       @WallTime Clock wallClock,
       @Monotonic Clock clock,
-      EventStoreConfig config) {
+      EventStoreConfig config,
+      SchemaManager schemaManager) {
 
-    this.openHelper = new OpenHelper(applicationContext);
+    this.schemaManager = schemaManager;
     this.wallClock = wallClock;
     this.monotonicClock = clock;
     this.config = config;
@@ -72,7 +74,7 @@
 
   private SQLiteDatabase getDb() {
     return retryIfDbLocked(
-        openHelper::getWritableDatabase,
+        schemaManager::getWritableDatabase,
         ex -> {
           throw new SynchronizationException("Timed out while trying to open db.", ex);
         });
@@ -81,7 +83,12 @@ private SQLiteDatabase getDb() {
   @Override
   @Nullable
   public PersistedEvent persist(TransportContext transportContext, EventInternal event) {
-
+    Logging.d(
+        LOG_TAG,
+        "Storing event with priority=%s, name=%s for destination %s",
+        transportContext.getPriority(),
+        event.getTransportName(),
+        transportContext.getBackendName());
     long newRowId =
         inTransaction(
             db -> {
@@ -130,20 +137,33 @@ private long ensureTransportContext(SQLiteDatabase db, TransportContext transpor
     record.put("backend_name", transportContext.getBackendName());
     record.put("priority", transportContext.getPriority().ordinal());
     record.put("next_request_ms", 0);
+    if (transportContext.getExtras() != null) {
+      record.put("extras", Base64.encodeToString(transportContext.getExtras(), Base64.DEFAULT));
+    }
+
     return db.insert("transport_contexts", null, record);
   }
 
   @Nullable
   private Long getTransportContextId(SQLiteDatabase db, TransportContext transportContext) {
+    final StringBuilder selection = new StringBuilder("backend_name = ? and priority = ?");
+    ArrayList<String> selectionArgs =
+        new ArrayList<>(
+            Arrays.asList(
+                transportContext.getBackendName(),
+                String.valueOf(transportContext.getPriority().ordinal())));
+
+    if (transportContext.getExtras() != null) {
+      selection.append(" and extras = ?");
+      selectionArgs.add(Base64.encodeToString(transportContext.getExtras(), Base64.DEFAULT));
+    }
+
     return tryWithCursor(
         db.query(
             "transport_contexts",
             new String[] {"_id"},
-            "backend_name = ? and priority = ?",
-            new String[] {
-              transportContext.getBackendName(),
-              String.valueOf(transportContext.getPriority().ordinal())
-            },
+            selection.toString(),
+            selectionArgs.toArray(new String[0]),
             null,
             null,
             null),
@@ -263,6 +283,28 @@ public void recordNextCallTime(TransportContext transportContext, long timestamp
         });
   }
 
+  @Override
+  public Iterable<TransportContext> loadActiveContexts() {
+    return inTransaction(
+        db ->
+            tryWithCursor(
+                db.rawQuery(
+                    "SELECT t.backend_name, t.priority, t.extras FROM transport_contexts AS t, events AS e WHERE e.context_id = t._id",
+                    new String[] {}),
+                cursor -> {
+                  List<TransportContext> results = new ArrayList<>();
+                  while (cursor.moveToNext()) {
+                    results.add(
+                        TransportContext.builder()
+                            .setBackendName(cursor.getString(0))
+                            .setPriority(cursor.getInt(1))
+                            .setExtras(maybeBase64Decode(cursor.getString(2)))
+                            .build());
+                  }
+                  return results;
+                }));
+  }
+
   @Override
   public int cleanUp() {
     long oneWeekAgo = wallClock.getTime() - config.getEventCleanUpAge();
@@ -272,7 +314,24 @@ public int cleanUp() {
 
   @Override
   public void close() {
-    openHelper.close();
+    schemaManager.close();
+  }
+
+  @RestrictTo(RestrictTo.Scope.TESTS)
+  public void clearDb() {
+    inTransaction(
+        db -> {
+          db.delete("events", null, new String[] {});
+          db.delete("transport_contexts", null, new String[] {});
+          return null;
+        });
+  }
+
+  private static byte[] maybeBase64Decode(@Nullable String value) {
+    if (value == null) {
+      return null;
+    }
+    return Base64.decode(value, Base64.DEFAULT);
   }
 
   /** Loads all events for a backend. */
@@ -468,93 +527,4 @@ private long getPageCount() {
       c.close();
     }
   }
-
-  private static class OpenHelper extends SQLiteOpenHelper {
-    // TODO: when we do schema upgrades in the future we need to make sure both downgrades and
-    // upgrades work as expected, e.g. `up+down+up` is equivalent to `up`.
-    private static int SCHEMA_VERSION = 1;
-    private static String DB_NAME = "com.google.android.datatransport.events";
-    private static String CREATE_EVENTS_SQL =
-        "CREATE TABLE events "
-            + "(_id INTEGER PRIMARY KEY,"
-            + " context_id INTEGER NOT NULL,"
-            + " transport_name TEXT NOT NULL,"
-            + " timestamp_ms INTEGER NOT NULL,"
-            + " uptime_ms INTEGER NOT NULL,"
-            + " payload BLOB NOT NULL,"
-            + " code INTEGER,"
-            + " num_attempts INTEGER NOT NULL,"
-            + "FOREIGN KEY (context_id) REFERENCES transport_contexts(_id) ON DELETE CASCADE)";
-
-    private static String CREATE_EVENT_METADATA_SQL =
-        "CREATE TABLE event_metadata "
-            + "(_id INTEGER PRIMARY KEY,"
-            + " event_id INTEGER NOT NULL,"
-            + " name TEXT NOT NULL,"
-            + " value TEXT NOT NULL,"
-            + "FOREIGN KEY (event_id) REFERENCES events(_id) ON DELETE CASCADE)";
-
-    private static String CREATE_CONTEXTS_SQL =
-        "CREATE TABLE transport_contexts "
-            + "(_id INTEGER PRIMARY KEY,"
-            + " backend_name TEXT NOT NULL,"
-            + " priority INTEGER NOT NULL,"
-            + " next_request_ms INTEGER NOT NULL)";
-
-    private static String CREATE_EVENT_BACKEND_INDEX =
-        "CREATE INDEX events_backend_id on events(context_id)";
-
-    private static String CREATE_CONTEXT_BACKEND_PRIORITY_INDEX =
-        "CREATE UNIQUE INDEX contexts_backend_priority on transport_contexts(backend_name, priority)";
-
-    private boolean configured = false;
-
-    private OpenHelper(Context context) {
-      super(context, DB_NAME, null, SCHEMA_VERSION);
-    }
-
-    @Override
-    public void onConfigure(SQLiteDatabase db) {
-      // Note that this is only called automatically by the SQLiteOpenHelper base class on Jelly
-      // Bean and above.
-      configured = true;
-
-      db.rawQuery("PRAGMA busy_timeout=0;", new String[0]).close();
-
-      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
-        db.setForeignKeyConstraintsEnabled(true);
-      }
-    }
-
-    private void ensureConfigured(SQLiteDatabase db) {
-      if (!configured) {
-        onConfigure(db);
-      }
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase db) {
-      ensureConfigured(db);
-      db.execSQL(CREATE_EVENTS_SQL);
-      db.execSQL(CREATE_EVENT_METADATA_SQL);
-      db.execSQL(CREATE_CONTEXTS_SQL);
-      db.execSQL(CREATE_EVENT_BACKEND_INDEX);
-      db.execSQL(CREATE_CONTEXT_BACKEND_PRIORITY_INDEX);
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-      ensureConfigured(db);
-    }
-
-    @Override
-    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-      ensureConfigured(db);
-    }
-
-    @Override
-    public void onOpen(SQLiteDatabase db) {
-      ensureConfigured(db);
-    }
-  }
 }
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/SchemaManager.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/SchemaManager.java
new file mode 100644
index 000000000..2395b5703
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/SchemaManager.java
@@ -0,0 +1,169 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+package com.google.android.datatransport.runtime.scheduling.persistence;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.os.Build;
+import java.util.Arrays;
+import java.util.List;
+import javax.inject.Inject;
+import javax.inject.Named;
+
+final class SchemaManager extends SQLiteOpenHelper {
+  // TODO: when we do schema upgrades in the future we need to make sure both downgrades and
+  // upgrades work as expected, e.g. `up+down+up` is equivalent to `up`.
+  private static final String DB_NAME = "com.google.android.datatransport.events";
+  private final int schemaVersion;
+  private boolean configured = false;
+
+  // Schema migration guidelines
+  // 1. Model migration at Vn as an operation performed on the database at Vn-1.
+  // 2. Append the migration to the ordered list of Migrations in the static initializer
+  // 3. Write tests that cover the following scenarios migrating to Vn from V0..Vn-1
+  // Note: Migrations handle only upgrades. Downgrades will drop and recreate all tables/indices.
+  private static final String CREATE_EVENTS_SQL_V1 =
+      "CREATE TABLE events "
+          + "(_id INTEGER PRIMARY KEY,"
+          + " context_id INTEGER NOT NULL,"
+          + " transport_name TEXT NOT NULL,"
+          + " timestamp_ms INTEGER NOT NULL,"
+          + " uptime_ms INTEGER NOT NULL,"
+          + " payload BLOB NOT NULL,"
+          + " code INTEGER,"
+          + " num_attempts INTEGER NOT NULL,"
+          + "FOREIGN KEY (context_id) REFERENCES transport_contexts(_id) ON DELETE CASCADE)";
+
+  private static final String CREATE_EVENT_METADATA_SQL_V1 =
+      "CREATE TABLE event_metadata "
+          + "(_id INTEGER PRIMARY KEY,"
+          + " event_id INTEGER NOT NULL,"
+          + " name TEXT NOT NULL,"
+          + " value TEXT NOT NULL,"
+          + "FOREIGN KEY (event_id) REFERENCES events(_id) ON DELETE CASCADE)";
+
+  private static final String CREATE_CONTEXTS_SQL_V1 =
+      "CREATE TABLE transport_contexts "
+          + "(_id INTEGER PRIMARY KEY,"
+          + " backend_name TEXT NOT NULL,"
+          + " priority INTEGER NOT NULL,"
+          + " next_request_ms INTEGER NOT NULL)";
+
+  private static final String CREATE_EVENT_BACKEND_INDEX_V1 =
+      "CREATE INDEX events_backend_id on events(context_id)";
+
+  private static final String CREATE_CONTEXT_BACKEND_PRIORITY_INDEX_V1 =
+      "CREATE UNIQUE INDEX contexts_backend_priority on transport_contexts(backend_name, priority)";
+
+  private static final String DROP_EVENTS_SQL = "DROP TABLE events";
+
+  private static final String DROP_EVENT_METADATA_SQL = "DROP TABLE event_metadata";
+
+  private static final String DROP_CONTEXTS_SQL = "DROP TABLE transport_contexts";
+
+  static int SCHEMA_VERSION = 2;
+
+  private static final SchemaManager.Migration MIGRATE_TO_V1 =
+      (db) -> {
+        db.execSQL(CREATE_EVENTS_SQL_V1);
+        db.execSQL(CREATE_EVENT_METADATA_SQL_V1);
+        db.execSQL(CREATE_CONTEXTS_SQL_V1);
+        db.execSQL(CREATE_EVENT_BACKEND_INDEX_V1);
+        db.execSQL(CREATE_CONTEXT_BACKEND_PRIORITY_INDEX_V1);
+      };
+
+  private static final SchemaManager.Migration MIGRATE_TO_V2 =
+      (db) -> {
+        db.execSQL("ALTER TABLE transport_contexts ADD COLUMN extras BLOB");
+        db.execSQL(
+            "CREATE UNIQUE INDEX contexts_backend_priority_extras on transport_contexts(backend_name, priority, extras)");
+        db.execSQL("DROP INDEX contexts_backend_priority");
+      };
+
+  private static final List<Migration> INCREMENTAL_MIGRATIONS =
+      Arrays.asList(MIGRATE_TO_V1, MIGRATE_TO_V2);
+
+  @Inject
+  SchemaManager(Context context, @Named("SCHEMA_VERSION") int schemaVersion) {
+    super(context, DB_NAME, null, schemaVersion);
+    this.schemaVersion = schemaVersion;
+  }
+
+  @Override
+  public void onConfigure(SQLiteDatabase db) {
+    // Note that this is only called automatically by the SQLiteOpenHelper base class on Jelly
+    // Bean and above.
+    configured = true;
+
+    db.rawQuery("PRAGMA busy_timeout=0;", new String[0]).close();
+
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+      db.setForeignKeyConstraintsEnabled(true);
+    }
+  }
+
+  private void ensureConfigured(SQLiteDatabase db) {
+    if (!configured) {
+      onConfigure(db);
+    }
+  }
+
+  @Override
+  public void onCreate(SQLiteDatabase db) {
+    ensureConfigured(db);
+    upgrade(db, 0, schemaVersion);
+  }
+
+  @Override
+  public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+    ensureConfigured(db);
+    upgrade(db, oldVersion, newVersion);
+  }
+
+  @Override
+  public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+    db.execSQL(DROP_EVENTS_SQL);
+    db.execSQL(DROP_EVENT_METADATA_SQL);
+    db.execSQL(DROP_CONTEXTS_SQL);
+    // Indices are dropped automatically when the tables are dropped
+
+    onCreate(db);
+  }
+
+  @Override
+  public void onOpen(SQLiteDatabase db) {
+    ensureConfigured(db);
+  }
+
+  private void upgrade(SQLiteDatabase db, int fromVersion, int toVersion) {
+    if (toVersion > INCREMENTAL_MIGRATIONS.size()) {
+      throw new IllegalArgumentException(
+          "Migration from "
+              + fromVersion
+              + " to "
+              + toVersion
+              + " was requested, but cannot be performed. Only "
+              + INCREMENTAL_MIGRATIONS.size()
+              + " migrations are provided");
+    }
+    for (int version = fromVersion; version < toVersion; version++) {
+      INCREMENTAL_MIGRATIONS.get(version).upgrade(db);
+    }
+  }
+
+  public interface Migration {
+    void upgrade(SQLiteDatabase db);
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/package-info.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/package-info.java
new file mode 100644
index 000000000..add4e13db
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.android.datatransport.runtime.scheduling.persistence;
\ No newline at end of file
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/synchronization/SynchronizationGuard.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/synchronization/SynchronizationGuard.java
index 2068a2e3c..4a99fa493 100644
--- a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/synchronization/SynchronizationGuard.java
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/synchronization/SynchronizationGuard.java
@@ -14,7 +14,7 @@
 
 package com.google.android.datatransport.runtime.synchronization;
 
-import android.support.annotation.WorkerThread;
+import androidx.annotation.WorkerThread;
 import com.google.android.datatransport.runtime.scheduling.persistence.EventStore;
 
 @WorkerThread
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/synchronization/package-info.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/synchronization/package-info.java
new file mode 100644
index 000000000..6ab0961dc
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/synchronization/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.android.datatransport.runtime.synchronization;
\ No newline at end of file
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/package-info.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/package-info.java
new file mode 100644
index 000000000..83e7fb1f0
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/package-info.java
@@ -0,0 +1,16 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+package com.google.android.datatransport.runtime.time;
\ No newline at end of file
diff --git a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/TransportContextTest.java b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/TransportContextTest.java
new file mode 100644
index 000000000..5bb5ac467
--- /dev/null
+++ b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/TransportContextTest.java
@@ -0,0 +1,57 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.datatransport.Priority;
+import java.nio.charset.Charset;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+@RunWith(RobolectricTestRunner.class)
+public class TransportContextTest {
+  private static final byte[] EXTRAS = "hello".getBytes(Charset.forName("UTF-8"));
+  private static final String BACKEND_NAME = "bknd";
+
+  private static final TransportContext CTX =
+      TransportContext.builder()
+          .setPriority(Priority.DEFAULT)
+          .setExtras(EXTRAS)
+          .setBackendName(BACKEND_NAME)
+          .build();
+
+  @Test
+  public void withPriority_whenPriorityNotChanged_shouldReturnEqualContext() {
+    assertThat(CTX.withPriority(Priority.DEFAULT)).isEqualTo(CTX);
+  }
+
+  @Test
+  public void withPriority_whenPriorityChangedBackToOriginal_shouldReturnEqualContext() {
+    assertThat(CTX.withPriority(Priority.VERY_LOW).withPriority(Priority.DEFAULT)).isEqualTo(CTX);
+  }
+
+  @Test
+  public void withPriority_whenPriorityIsDifferent_shouldReturnContextWithPriorityChanged() {
+    assertThat(CTX.withPriority(Priority.VERY_LOW))
+        .isEqualTo(
+            TransportContext.builder()
+                .setPriority(Priority.VERY_LOW)
+                .setExtras(EXTRAS)
+                .setBackendName(BACKEND_NAME)
+                .build());
+  }
+}
diff --git a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/TransportRuntimeTest.java b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/TransportRuntimeTest.java
index d045dc1a5..23e2a079f 100644
--- a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/TransportRuntimeTest.java
+++ b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/TransportRuntimeTest.java
@@ -30,6 +30,7 @@
 import com.google.android.datatransport.runtime.backends.TransportBackend;
 import com.google.android.datatransport.runtime.scheduling.ImmediateScheduler;
 import com.google.android.datatransport.runtime.scheduling.jobscheduling.Uploader;
+import com.google.android.datatransport.runtime.scheduling.jobscheduling.WorkInitializer;
 import java.util.Collections;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -40,9 +41,11 @@
 public class TransportRuntimeTest {
   private static final String TEST_KEY = "test";
   private static final String TEST_VALUE = "test-value";
-  private TransportInternal transportInternalMock = mock(TransportInternal.class);
-  private TransportBackend mockBackend = mock(TransportBackend.class);
-  private BackendRegistry mockRegistry = mock(BackendRegistry.class);
+
+  private final TransportInternal transportInternalMock = mock(TransportInternal.class);
+  private final TransportBackend mockBackend = mock(TransportBackend.class);
+  private final BackendRegistry mockRegistry = mock(BackendRegistry.class);
+  private final WorkInitializer mockInitializer = mock(WorkInitializer.class);
 
   @Test
   public void testTransportInternalSend() {
@@ -75,7 +78,10 @@ public void testTransportRuntimeBackendDiscovery() {
             () -> eventMillis,
             () -> uptimeMillis,
             new ImmediateScheduler(Runnable::run, mockRegistry),
-            new Uploader(null, null, null, null, null, null, () -> 2));
+            new Uploader(null, null, null, null, null, null, () -> 2),
+            mockInitializer);
+    verify(mockInitializer, times(1)).ensureContextsScheduled();
+
     when(mockRegistry.get(mockBackendName)).thenReturn(mockBackend);
     when(mockBackend.decorate(any()))
         .thenAnswer(
diff --git a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/backends/BackendRegistryTest.java b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/backends/BackendRegistryTest.java
index a82d3a9b8..4ef4e9a71 100644
--- a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/backends/BackendRegistryTest.java
+++ b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/backends/BackendRegistryTest.java
@@ -15,10 +15,12 @@
 package com.google.android.datatransport.runtime.backends;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
 
+import androidx.annotation.Nullable;
 import androidx.test.core.app.ApplicationProvider;
 import com.google.android.datatransport.runtime.time.TestClock;
-import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -26,16 +28,25 @@
 @RunWith(RobolectricTestRunner.class)
 public class BackendRegistryTest {
 
-  private final CreationContext creationContext =
-      CreationContext.create(
+  private final CreationContextFactory creationContextFactory =
+      new CreationContextFactory(
           ApplicationProvider.getApplicationContext(), new TestClock(1), new TestClock(2));
-  private BackendRegistry registry;
+  private final BackendRegistry registry =
+      new MetadataBackendRegistry(
+          ApplicationProvider.getApplicationContext(), creationContextFactory);
 
-  @Before
-  public void setup() {
-    registry =
-        new MetadataBackendRegistry(ApplicationProvider.getApplicationContext(), creationContext);
-  }
+  private final BackendFactory mockBackendFactory = mock(BackendFactory.class);
+  private final BackendRegistry fakeRegistry =
+      new MetadataBackendRegistry(
+          new MetadataBackendRegistry.BackendFactoryProvider(
+              ApplicationProvider.getApplicationContext()) {
+            @Nullable
+            @Override
+            BackendFactory get(String name) {
+              return mockBackendFactory;
+            }
+          },
+          creationContextFactory);
 
   @Test
   public void get_withRegisteredBackendName_shouldReturnCorrectBackend() {
@@ -46,4 +57,14 @@ public void get_withRegisteredBackendName_shouldReturnCorrectBackend() {
   public void get_withUnknownBackend_name_shouldReturnNull() {
     assertThat(registry.get("unknown")).isNull();
   }
+
+  @Test
+  public void get_calls_transportFactory_withCorrectCreationContext() {
+    fakeRegistry.get("testBackend");
+
+    verify(mockBackendFactory).create(creationContextFactory.create("testBackend"));
+
+    fakeRegistry.get("unknown");
+    verify(mockBackendFactory).create(creationContextFactory.create("unknown"));
+  }
 }
diff --git a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/AlarmManagerSchedulerTest.java b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/AlarmManagerSchedulerTest.java
index fce96ca8e..4df9d3127 100644
--- a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/AlarmManagerSchedulerTest.java
+++ b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/AlarmManagerSchedulerTest.java
@@ -28,6 +28,7 @@
 import android.content.Context;
 import android.content.Intent;
 import android.net.Uri;
+import android.util.Base64;
 import com.google.android.datatransport.Priority;
 import com.google.android.datatransport.runtime.TransportContext;
 import com.google.android.datatransport.runtime.scheduling.persistence.EventStore;
@@ -65,6 +66,12 @@ private Intent getIntent(TransportContext transportContext) {
         AlarmManagerScheduler.EVENT_PRIORITY,
         String.valueOf(transportContext.getPriority().ordinal()));
 
+    if (transportContext.getExtras() != null) {
+      intentDataBuilder.appendQueryParameter(
+          AlarmManagerScheduler.EXTRAS,
+          Base64.encodeToString(transportContext.getExtras(), Base64.DEFAULT));
+    }
+
     Intent intent = new Intent(context, AlarmManagerSchedulerBroadcastReceiver.class);
     intent.setData(intentDataBuilder.build());
     return intent;
@@ -124,6 +131,16 @@ public void schedule_twoJobs() {
     verify(alarmManager, times(1)).set(eq(AlarmManager.ELAPSED_REALTIME), gt(1000000L), any());
   }
 
+  @Test
+  public void schedule_whenExtrasEvailable_transmitsExtras() {
+    TransportContext transportContext =
+        TransportContext.builder().setBackendName("backend1").setExtras("e1".getBytes()).build();
+    Intent intent = getIntent(transportContext);
+    assertThat(scheduler.isJobServiceOn(intent)).isFalse();
+    scheduler.schedule(transportContext, 1);
+    assertThat(scheduler.isJobServiceOn(intent)).isTrue();
+  }
+
   @Test
   public void schedule_smallWaitTImeFirstAttempt_multiplePriorities() {
     Intent intent1 = getIntent(TRANSPORT_CONTEXT);
diff --git a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoSchedulerTest.java b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoSchedulerTest.java
index 3d045b2b8..28d34be04 100644
--- a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoSchedulerTest.java
+++ b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoSchedulerTest.java
@@ -21,6 +21,7 @@
 import android.app.job.JobScheduler;
 import android.content.Context;
 import android.os.PersistableBundle;
+import android.util.Base64;
 import com.google.android.datatransport.Priority;
 import com.google.android.datatransport.runtime.TransportContext;
 import com.google.android.datatransport.runtime.scheduling.persistence.EventStore;
@@ -135,6 +136,44 @@ public void schedule_twoJobs() {
         .isEqualTo(TRANSPORT_CONTEXT.getBackendName());
   }
 
+  @Test
+  public void schedule_whenExtrasEvailable_transmitsExtras() {
+    String extras = "e1";
+    TransportContext transportContext =
+        TransportContext.builder().setBackendName("backend1").setExtras(extras.getBytes()).build();
+    store.recordNextCallTime(transportContext, 1000000);
+    scheduler.schedule(transportContext, 1);
+    JobInfo jobInfo = jobScheduler.getAllPendingJobs().get(0);
+    PersistableBundle bundle = jobInfo.getExtras();
+    assertThat(bundle.get(JobInfoScheduler.EXTRAS))
+        .isEqualTo(Base64.encodeToString(extras.getBytes(), Base64.DEFAULT));
+  }
+
+  @Test
+  public void schedule_withMultipleContexts_whenExtrasAvailable_schedulesForBothContexts() {
+    String extras1 = "e1";
+    String extras2 = "e2";
+    TransportContext ctx1 =
+        TransportContext.builder().setBackendName("backend1").setExtras(extras1.getBytes()).build();
+    TransportContext ctx2 =
+        TransportContext.builder().setBackendName("backend1").setExtras(extras2.getBytes()).build();
+
+    store.recordNextCallTime(ctx1, 1000000);
+    store.recordNextCallTime(ctx2, 1000000);
+    scheduler.schedule(ctx1, 1);
+    scheduler.schedule(ctx2, 1);
+    assertThat(jobScheduler.getAllPendingJobs()).hasSize(2);
+    JobInfo jobInfo = jobScheduler.getAllPendingJobs().get(0);
+    PersistableBundle bundle = jobInfo.getExtras();
+    assertThat(bundle.get(JobInfoScheduler.EXTRAS))
+        .isEqualTo(Base64.encodeToString(extras1.getBytes(), Base64.DEFAULT));
+
+    jobInfo = jobScheduler.getAllPendingJobs().get(1);
+    bundle = jobInfo.getExtras();
+    assertThat(bundle.get(JobInfoScheduler.EXTRAS))
+        .isEqualTo(Base64.encodeToString(extras2.getBytes(), Base64.DEFAULT));
+  }
+
   @Test
   public void schedule_smallWaitTImeFirstAttempt_multiplePriorities() {
     store.recordNextCallTime(TRANSPORT_CONTEXT, 5);
diff --git a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/WorkInitializerTest.java b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/WorkInitializerTest.java
new file mode 100644
index 000000000..4517de5c0
--- /dev/null
+++ b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/WorkInitializerTest.java
@@ -0,0 +1,53 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling.jobscheduling;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.google.android.datatransport.runtime.TransportContext;
+import com.google.android.datatransport.runtime.scheduling.persistence.EventStore;
+import com.google.android.datatransport.runtime.synchronization.SynchronizationGuard.CriticalSection;
+import java.util.Arrays;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class WorkInitializerTest {
+
+  private final EventStore mockStore = mock(EventStore.class);
+  private final WorkScheduler mockScheduler = mock(WorkScheduler.class);
+
+  private final WorkInitializer initializer =
+      new WorkInitializer(Runnable::run, mockStore, mockScheduler, CriticalSection::execute);
+
+  @Test
+  public void test() {
+    TransportContext ctx1 =
+        TransportContext.builder().setBackendName("backend1").setExtras(null).build();
+    TransportContext ctx2 =
+        TransportContext.builder().setBackendName("backend1").setExtras("e1".getBytes()).build();
+
+    when(mockStore.loadActiveContexts()).thenReturn(Arrays.asList(ctx1, ctx2));
+
+    initializer.ensureContextsScheduled();
+
+    verify(mockScheduler, times(1)).schedule(ctx1, 1);
+    verify(mockScheduler, times(1)).schedule(ctx2, 1);
+  }
+}
diff --git a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/InMemoryEventStore.java b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/InMemoryEventStore.java
index be3b8c99e..d99c525ad 100644
--- a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/InMemoryEventStore.java
+++ b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/InMemoryEventStore.java
@@ -14,7 +14,7 @@
 
 package com.google.android.datatransport.runtime.scheduling.persistence;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.google.android.datatransport.runtime.EventInternal;
 import com.google.android.datatransport.runtime.TransportContext;
 import java.util.ArrayList;
@@ -102,6 +102,18 @@ public synchronized boolean hasPendingEventsFor(TransportContext transportContex
     return events;
   }
 
+  @Override
+  public synchronized Iterable<TransportContext> loadActiveContexts() {
+    List<TransportContext> results = new ArrayList<>();
+    for (Map.Entry<TransportContext, Map<Long, EventInternal>> entry : store.entrySet()) {
+      if (entry.getValue().isEmpty()) {
+        continue;
+      }
+      results.add(entry.getKey());
+    }
+    return results;
+  }
+
   @Override
   public int cleanUp() {
     return 0;
diff --git a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStoreTest.java b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStoreTest.java
index 9c3993545..124786497 100644
--- a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStoreTest.java
+++ b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStoreTest.java
@@ -14,6 +14,8 @@
 
 package com.google.android.datatransport.runtime.scheduling.persistence;
 
+import static com.google.android.datatransport.runtime.scheduling.persistence.EventStoreModule.*;
+import static com.google.android.datatransport.runtime.scheduling.persistence.SchemaManager.SCHEMA_VERSION;
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.android.datatransport.Priority;
@@ -53,7 +55,11 @@
   private final SQLiteEventStore store = newStoreWithConfig(clock, CONFIG);
 
   private static SQLiteEventStore newStoreWithConfig(Clock clock, EventStoreConfig config) {
-    return new SQLiteEventStore(RuntimeEnvironment.application, clock, new UptimeClock(), config);
+    return new SQLiteEventStore(
+        clock,
+        new UptimeClock(),
+        config,
+        new SchemaManager(RuntimeEnvironment.application, SCHEMA_VERSION));
   }
 
   @Test
@@ -67,8 +73,14 @@ public void persist_correctlyRoundTrips() {
 
   @Test
   public void persist_withEventsOfDifferentPriority_shouldEndBeStoredUnderDifferentContexts() {
-    TransportContext ctx1 = TRANSPORT_CONTEXT;
-    TransportContext ctx2 = TRANSPORT_CONTEXT.withPriority(Priority.VERY_LOW);
+    TransportContext ctx1 =
+        TransportContext.builder().setBackendName("backend1").setExtras("e1".getBytes()).build();
+    TransportContext ctx2 =
+        TransportContext.builder()
+            .setBackendName("backend1")
+            .setExtras("e1".getBytes())
+            .setPriority(Priority.VERY_LOW)
+            .build();
 
     EventInternal event1 = EVENT;
     EventInternal event2 = EVENT.toBuilder().setPayload("World".getBytes()).build();
@@ -80,6 +92,50 @@ public void persist_withEventsOfDifferentPriority_shouldEndBeStoredUnderDifferen
     assertThat(store.loadBatch(ctx2)).containsExactly(newEvent2);
   }
 
+  @Test
+  public void persist_withEventsOfDifferentExtras_shouldEndBeStoredUnderDifferentContexts() {
+    TransportContext ctx1 =
+        TransportContext.builder().setBackendName("backend1").setExtras("e1".getBytes()).build();
+    TransportContext ctx2 =
+        TransportContext.builder().setBackendName("backend1").setExtras("e2".getBytes()).build();
+
+    EventInternal event1 = EVENT;
+    EventInternal event2 = EVENT.toBuilder().setPayload("World".getBytes()).build();
+
+    PersistedEvent newEvent1 = store.persist(ctx1, event1);
+    PersistedEvent newEvent2 = store.persist(ctx2, event2);
+
+    assertThat(store.loadBatch(ctx1)).containsExactly(newEvent1);
+    assertThat(store.loadBatch(ctx2)).containsExactly(newEvent2);
+  }
+
+  @Test
+  public void persist_withEventsOfSameExtras_shouldEndBeStoredUnderSameContexts() {
+    TransportContext ctx1 =
+        TransportContext.builder().setBackendName("backend1").setExtras("e1".getBytes()).build();
+    TransportContext ctx2 =
+        TransportContext.builder().setBackendName("backend1").setExtras("e1".getBytes()).build();
+
+    PersistedEvent newEvent1 = store.persist(ctx1, EVENT);
+    PersistedEvent newEvent2 = store.persist(ctx2, EVENT);
+
+    assertThat(store.loadBatch(ctx2)).containsExactly(newEvent1, newEvent2);
+  }
+
+  @Test
+  public void persist_sameBackendswithDifferentExtras_shouldEndBeStoredUnderDifferentContexts() {
+    TransportContext ctx1 =
+        TransportContext.builder().setBackendName("backend1").setExtras(null).build();
+    TransportContext ctx2 =
+        TransportContext.builder().setBackendName("backend1").setExtras("e1".getBytes()).build();
+
+    PersistedEvent newEvent1 = store.persist(ctx1, EVENT);
+    PersistedEvent newEvent2 = store.persist(ctx2, EVENT);
+
+    assertThat(store.loadBatch(ctx1)).containsExactly(newEvent1);
+    assertThat(store.loadBatch(ctx2)).containsExactly(newEvent2);
+  }
+
   @Test
   public void persist_withEventCode_correctlyRoundTrips() {
     EventInternal eventWithCode = EVENT.toBuilder().setCode(5).build();
@@ -212,4 +268,36 @@ public void cleanUp_whenEventIsOld_shouldDeleteIt() {
     assertThat(store.cleanUp()).isEqualTo(1);
     assertThat(store.loadBatch(TRANSPORT_CONTEXT)).isEmpty();
   }
+
+  @Test
+  public void loadActiveContexts_whenNoContextsAvailable_shouldReturnEmptyList() {
+    assertThat(store.loadActiveContexts()).isEmpty();
+  }
+
+  @Test
+  public void loadActiveContexts_whenTwoContextsAvailable_shouldReturnThem() {
+    TransportContext ctx1 =
+        TransportContext.builder().setBackendName("backend1").setExtras(null).build();
+    TransportContext ctx2 =
+        TransportContext.builder().setBackendName("backend1").setExtras("e1".getBytes()).build();
+
+    store.persist(ctx1, EVENT);
+    store.persist(ctx2, EVENT);
+
+    assertThat(store.loadActiveContexts()).containsExactly(ctx1, ctx2);
+  }
+
+  @Test
+  public void loadActiveContexts_whenTwoContextsWithOneAvailable_shouldReturnIt() {
+    TransportContext ctx1 =
+        TransportContext.builder().setBackendName("backend1").setExtras(null).build();
+    TransportContext ctx2 =
+        TransportContext.builder().setBackendName("backend1").setExtras("e1".getBytes()).build();
+
+    store.persist(ctx1, EVENT);
+    PersistedEvent persistedEvent2 = store.persist(ctx2, EVENT);
+    store.recordSuccess(Collections.singleton(persistedEvent2));
+
+    assertThat(store.loadActiveContexts()).containsExactly(ctx1);
+  }
 }
diff --git a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/SchemaManagerTest.java b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/SchemaManagerTest.java
new file mode 100644
index 000000000..f2a3fa6ff
--- /dev/null
+++ b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/SchemaManagerTest.java
@@ -0,0 +1,178 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+package com.google.android.datatransport.runtime.scheduling.persistence;
+
+import static com.google.android.datatransport.runtime.scheduling.persistence.SchemaManager.SCHEMA_VERSION;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.ContentValues;
+import android.database.sqlite.SQLiteDatabase;
+import com.google.android.datatransport.Priority;
+import com.google.android.datatransport.runtime.EventInternal;
+import com.google.android.datatransport.runtime.TransportContext;
+import com.google.android.datatransport.runtime.time.TestClock;
+import com.google.android.datatransport.runtime.time.UptimeClock;
+import java.util.Map;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+@RunWith(RobolectricTestRunner.class)
+public class SchemaManagerTest {
+  private static final TransportContext CONTEXT1 =
+      TransportContext.builder().setBackendName("b1").build();
+
+  private static final TransportContext CONTEXT2 =
+      TransportContext.builder()
+          .setBackendName("b2")
+          .setExtras("e2".getBytes())
+          .build()
+          .withPriority(Priority.VERY_LOW);
+
+  private static final EventInternal EVENT1 =
+      EventInternal.builder()
+          .setTransportName("42")
+          .setEventMillis(1)
+          .setUptimeMillis(2)
+          .setPayload("Hello".getBytes())
+          .addMetadata("key1", "value1")
+          .addMetadata("key2", "value2")
+          .build();
+
+  private static final EventInternal EVENT2 =
+      EVENT1.toBuilder().setPayload("World".getBytes()).build();
+
+  private static final long HOUR = 60 * 60 * 1000;
+  private static final EventStoreConfig CONFIG =
+      EventStoreConfig.DEFAULT.toBuilder().setLoadBatchSize(5).setEventCleanUpAge(HOUR).build();
+
+  private final TestClock clock = new TestClock(1);
+
+  @Test
+  public void persist_correctlyRoundTrips() {
+    SchemaManager schemaManager = new SchemaManager(RuntimeEnvironment.application, SCHEMA_VERSION);
+    SQLiteEventStore store = new SQLiteEventStore(clock, new UptimeClock(), CONFIG, schemaManager);
+
+    PersistedEvent newEvent = store.persist(CONTEXT1, EVENT1);
+    Iterable<PersistedEvent> events = store.loadBatch(CONTEXT1);
+
+    assertThat(newEvent.getEvent()).isEqualTo(EVENT1);
+    assertThat(events).containsExactly(newEvent);
+  }
+
+  @Test
+  public void upgradingV1ToV2_emptyDatabase_allowsPersistsAfterUpgrade() {
+    int oldVersion = 1;
+    int newVersion = 2;
+    SchemaManager schemaManager = new SchemaManager(RuntimeEnvironment.application, oldVersion);
+
+    SQLiteEventStore store = new SQLiteEventStore(clock, new UptimeClock(), CONFIG, schemaManager);
+
+    schemaManager.onUpgrade(schemaManager.getWritableDatabase(), oldVersion, newVersion);
+    PersistedEvent newEvent1 = store.persist(CONTEXT1, EVENT1);
+
+    assertThat(store.loadBatch(CONTEXT1)).containsExactly(newEvent1);
+  }
+
+  @Test
+  public void upgradingV1ToV2_nonEmptyDB_isLossless() {
+    int oldVersion = 1;
+    int newVersion = 2;
+    SchemaManager schemaManager = new SchemaManager(RuntimeEnvironment.application, oldVersion);
+    SQLiteEventStore store = new SQLiteEventStore(clock, new UptimeClock(), CONFIG, schemaManager);
+    // We simulate operations as done by an older SQLLiteEventStore at V1
+    // We cannot simulate older operations with a newer client
+    PersistedEvent event1 = simulatedPersistOnV1Database(schemaManager, CONTEXT1, EVENT1);
+
+    // Upgrade to V2
+    schemaManager.onUpgrade(schemaManager.getWritableDatabase(), oldVersion, newVersion);
+
+    assertThat(store.loadBatch(CONTEXT1)).containsExactly(event1);
+  }
+
+  @Test
+  public void downgradeV2ToV1_withEmptyDB_allowsPersistanceAfterMigration() {
+    int fromVersion = 2;
+    SchemaManager schemaManager = new SchemaManager(RuntimeEnvironment.application, fromVersion);
+
+    SQLiteEventStore store = new SQLiteEventStore(clock, new UptimeClock(), CONFIG, schemaManager);
+    // We simulate operations as done by an older SQLLiteEventStore at V1
+    // We cannot simulate older operations with a newer client
+    simulatedPersistOnV1Database(schemaManager, CONTEXT1, EVENT1);
+
+    schemaManager.onDowngrade(schemaManager.getWritableDatabase(), fromVersion, -1);
+    PersistedEvent event2 = store.persist(CONTEXT2, EVENT2);
+
+    assertThat(store.loadBatch(CONTEXT2)).containsExactly(event2);
+  }
+
+  @Test
+  public void downgradeV2ToV1_withNonEmptyDB_isLossy() {
+    int fromVersion = 2;
+    int toVersion = fromVersion - 1;
+    SchemaManager schemaManager = new SchemaManager(RuntimeEnvironment.application, fromVersion);
+    SQLiteEventStore store = new SQLiteEventStore(clock, new UptimeClock(), CONFIG, schemaManager);
+    PersistedEvent event1 = store.persist(CONTEXT1, EVENT1);
+
+    schemaManager.onDowngrade(schemaManager.getWritableDatabase(), toVersion, fromVersion);
+
+    assertThat(store.loadBatch(CONTEXT1)).doesNotContain(event1);
+  }
+
+  @Test
+  public void upgrade_toANonExistentVersion_fails() {
+    int oldVersion = 1;
+    int nonExistentVersion = 1000;
+    SchemaManager schemaManager = new SchemaManager(RuntimeEnvironment.application, oldVersion);
+
+    Assert.assertThrows(
+        IllegalArgumentException.class,
+        () ->
+            schemaManager.onUpgrade(
+                schemaManager.getWritableDatabase(), oldVersion, nonExistentVersion));
+  }
+
+  private PersistedEvent simulatedPersistOnV1Database(
+      SchemaManager schemaManager, TransportContext transportContext, EventInternal eventInternal) {
+    SQLiteDatabase db = schemaManager.getWritableDatabase();
+
+    ContentValues record = new ContentValues();
+    record.put("backend_name", transportContext.getBackendName());
+    record.put("priority", transportContext.getPriority().ordinal());
+    record.put("next_request_ms", 0);
+    long contextId = db.insert("transport_contexts", null, record);
+
+    ContentValues values = new ContentValues();
+    values.put("context_id", contextId);
+    values.put("transport_name", eventInternal.getTransportName());
+    values.put("timestamp_ms", eventInternal.getEventMillis());
+    values.put("uptime_ms", eventInternal.getUptimeMillis());
+    values.put("payload", eventInternal.getPayload());
+    values.put("code", eventInternal.getCode());
+    values.put("num_attempts", 0);
+    long newEventId = db.insert("events", null, values);
+
+    for (Map.Entry<String, String> entry : eventInternal.getMetadata().entrySet()) {
+      ContentValues metadata = new ContentValues();
+      metadata.put("event_id", newEventId);
+      metadata.put("name", entry.getKey());
+      metadata.put("value", entry.getValue());
+      db.insert("event_metadata", null, metadata);
+    }
+
+    return PersistedEvent.create(newEventId, transportContext, eventInternal);
+  }
+}
diff --git a/transport/transport-runtime/transport-runtime.gradle b/transport/transport-runtime/transport-runtime.gradle
index 9e19a7358..556a0082b 100644
--- a/transport/transport-runtime/transport-runtime.gradle
+++ b/transport/transport-runtime/transport-runtime.gradle
@@ -39,7 +39,7 @@ android {
     defaultConfig {
         minSdkVersion 14
         targetSdkVersion 28
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
     }
     compileOptions {
         sourceCompatibility = '1.8'
@@ -58,7 +58,7 @@ android {
 dependencies {
     implementation project(':transport:transport-api')
     implementation 'com.google.dagger:dagger:2.22'
-    implementation 'com.android.support:support-annotations:28.0.0'
+    implementation 'androidx.annotation:annotation:1.1.0'
 
     compileOnly "com.google.auto.value:auto-value-annotations:1.6.5"
 
@@ -67,16 +67,16 @@ dependencies {
 
     testImplementation 'junit:junit:4.13-beta-2'
     testImplementation "com.google.truth:truth:$googleTruthVersion"
-    testImplementation 'androidx.test:core:1.1.0'
+    testImplementation 'androidx.test:core:1.2.0'
     testImplementation 'org.robolectric:robolectric:4.2'
-    testImplementation 'org.mockito:mockito-core:2.21.0'
+    testImplementation 'org.mockito:mockito-core:2.25.0'
 
     androidTestImplementation 'junit:junit:4.12'
     androidTestImplementation "com.google.truth:truth:$googleTruthVersion"
-    androidTestImplementation 'com.android.support.test:runner:1.0.2'
-    androidTestImplementation 'com.android.support.test:rules:1.0.2'
-    androidTestImplementation 'org.mockito:mockito-core:2.21.0'
-    androidTestImplementation 'org.mockito:mockito-android:2.21.0'
+    androidTestImplementation 'androidx.test:runner:1.2.0'
+    androidTestImplementation 'androidx.test:rules:1.2.0'
+    androidTestImplementation 'org.mockito:mockito-core:2.25.0'
+    androidTestImplementation 'org.mockito:mockito-android:2.25.0'
 
     androidTestAnnotationProcessor 'com.google.dagger:dagger-compiler:2.22'
 }
