diff --git a/CHANGELOG.md b/CHANGELOG.md
index 7bb4e15db2..908acec1e8 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,4 +1,32 @@
-## 3.6.0 (YYYY-MM-DD)
+## 3.8.0 (YYYY-MM-DD)
+
+### Breaking Changes
+
+### Deprecated
+
+### Enhancements
+
+### Bug Fixes
+
+### Internal
+
+
+## 3.7.0 (2017-09-01)
+
+### Deprecated
+
+* [ObjectServer] `SyncUser.getManagementRealm()`. Use `SyncUser.getPermissionManager()` instead.
+
+### Enhancements
+
+* [ObjectServer] `SyncUser.getPermissionManager` added as a helper API for working with permissions and permission offers.
+
+### Internal
+
+* [ObjectServer] Upgraded OkHttp to 3.7.0.
+
+
+## 3.6.0 (2017-09-01)
 
 ### Breaking Changes
 
@@ -24,25 +52,20 @@ and `SyncUser#retrieveInfoForUserAsync` which returns a `SyncUserInfo` with mode
 
 ### Bug Fixes
 
-### Internal
-
-* [ObjectServer] removed `ObjectServerUser` and its inner classes, in a step to reduce `SyncUser` complexity (#3741).
-* [ObjectServer] changed the `SyncSessionStopPolicy` to `AfterChangesUploaded` to align with other binding and to prevent use cases where the Realm might be deleted before the last changes get synchronized (#5028).
-* Upgraded Realm Sync to 1.10.8
-* Let Object Store handle migration.
-
-## 3.5.1 (YYYY-MM-DD)
-
-### Bug Fixes
-
 * Potential crash after using `Realm.getSchema()` to change the schema of a typed Realm. `Realm.getSchema()` now returns an immutable `RealmSchema` instance.
-* `Realm.copyToRealmOrUpdate()` might cause a `RealmList` field to contain duplicated elements (#4957).
+* `Realm.copyToRealmOrUpdate()` could cause a `RealmList` field to contain duplicated elements (#4957).
 * `RealmSchema.create(String)` and `RealmObjectSchema.setClassName(String)` did not accept class name whose length was 51 to 57.
 * Workaround for an Android JVM crash when using `compactOnLaunch()` (#4964).
 * Class name in exception message from link query is wrong (#5096).
+* The `compactOnLaunch` callback is no longer invoked if the Realm at that path is already open on other threads.
 
 ### Internal
 
+* [ObjectServer] removed `ObjectServerUser` and its inner classes, in a step to reduce `SyncUser` complexity (#3741).
+* [ObjectServer] changed the `SyncSessionStopPolicy` to `AfterChangesUploaded` to align with other binding and to prevent use cases where the Realm might be deleted before the last changes get synchronized (#5028).
+* Upgraded Realm Sync to 1.10.8
+* Let Object Store handle migration.
+
 
 ## 3.5.0 (2017-07-11)
 
@@ -159,6 +182,7 @@ and `SyncUser#retrieveInfoForUserAsync` which returns a `SyncUserInfo` with mode
 ### Enhancements
 
 * [ObjectServer] Added support for `SyncUser.isAdmin()` (#4353).
+* [ObjectServer] New set of Permission API's have been added to `SyncUser` through `SyncUser.getPermissionManager()` (#4296).
 * [ObjectServer] Added support for changing passwords through `SyncUser.changePassword()` (#4423).
 * [ObjectServer] Added support for `SyncConfiguration.Builder.waitForInitialRemoteData()` (#4270).
 * Transient fields are now allowed in model classes, but are implicitly treated as having the `@Ignore` annotation (#4279).
diff --git a/realm/config/findbugs/findbugs-filter.xml b/realm/config/findbugs/findbugs-filter.xml
index c7079866b1..25485943d5 100644
--- a/realm/config/findbugs/findbugs-filter.xml
+++ b/realm/config/findbugs/findbugs-filter.xml
@@ -21,5 +21,8 @@
     <Match>
         <Class name="io.realm.PermissionOfferResponseRealmProxy"/>
     </Match>
+    <Match>
+        <Class name="io.realm.PermissionRealmProxy"/>
+    </Match>
 
 </FindBugsFilter>
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index ff5f58d9cc..0f0d69c280 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -180,7 +180,7 @@ dependencies {
     implementation 'com.getkeepsafe.relinker:relinker:1.2.2'
 
     kaptObjectServer project(':realm-annotations-processor')
-    objectServerImplementation 'com.squareup.okhttp3:okhttp:3.4.1'
+    objectServerImplementation 'com.squareup.okhttp3:okhttp:3.7.0'
 
     kaptAndroidTest project(':realm-annotations-processor')
     androidTestImplementation fileTree(dir: 'testLibs', include: ['*.jar'])
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index ec12cb382b..6485e6ed5c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -64,6 +64,8 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
+import javax.annotation.Nullable;
+
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
@@ -1060,15 +1062,24 @@ public void compactRealm_onExternalStorage() {
         Realm.deleteRealm(config);
     }
 
+    private void populateTestRealmForCompact(Realm realm, int sizeInMB) {
+        byte[] oneMBData = new byte[1024 * 1024];
+        realm.beginTransaction();
+        for (int i = 0; i < sizeInMB; i++) {
+            realm.createObject(AllTypes.class).setColumnBinary(oneMBData);
+        }
+        realm.commitTransaction();
+    }
+
     private Pair<Long, Long> populateTestRealmAndCompactOnLaunch(CompactOnLaunchCallback compactOnLaunch) {
-        return populateTestRealmAndCompactOnLaunch(compactOnLaunch, 100);
+        return populateTestRealmAndCompactOnLaunch(compactOnLaunch, 1);
     }
 
-    private Pair<Long, Long> populateTestRealmAndCompactOnLaunch(CompactOnLaunchCallback compactOnLaunch, int objects) {
+    private Pair<Long, Long> populateTestRealmAndCompactOnLaunch(CompactOnLaunchCallback compactOnLaunch, int sizeInMB) {
         final String REALM_NAME = "test.realm";
         RealmConfiguration realmConfig = configFactory.createConfiguration(REALM_NAME);
         Realm realm = Realm.getInstance(realmConfig);
-        populateTestRealm(realm, objects);
+        populateTestRealmForCompact(realm, sizeInMB);
         realm.beginTransaction();
         realm.deleteAll();
         realm.commitTransaction();
@@ -1131,12 +1142,23 @@ public boolean shouldCompact(long totalBytes, long usedBytes) {
                 })
                 .build();
         Realm realm = Realm.getInstance(realmConfig);
+        realm.close();
+        // WARNING: We need to init the schema first and close the Realm to make sure the relevant logic works in Object
+        // Store. See https://github.com/realm/realm-object-store/blob/master/src/shared_realm.cpp#L58
+        // Called once.
+        assertEquals(1, compactOnLaunchCount.get());
+
+        realm = Realm.getInstance(realmConfig);
+        // Called 2 more times. The PK table migration logic (the old PK bug) needs to open/close the Realm once.
+        assertEquals(3, compactOnLaunchCount.get());
 
         Thread thread = new Thread(new Runnable() {
             @Override
             public void run() {
                 Realm bgRealm = Realm.getInstance(realmConfig);
                 bgRealm.close();
+                // compactOnLaunch should not be called anymore!
+                assertEquals(3, compactOnLaunchCount.get());
             }
         });
         thread.start();
@@ -1149,8 +1171,6 @@ public void run() {
 
         realm.close();
 
-        // FIXME: It should be 1. Current compactOnLaunch is called each time a Realm is opened on a new thread.
-        assertNotEquals(1, compactOnLaunchCount.get());
         assertEquals(3, compactOnLaunchCount.get());
     }
 
@@ -1162,7 +1182,7 @@ public boolean shouldCompact(long totalBytes, long usedBytes) {
                 final long thresholdSize = 50 * 1024 * 1024;
                 return (totalBytes > thresholdSize) && (((double) usedBytes / (double) totalBytes) < 0.5);
             }
-        }, 100);
+        }, 1);
         final long thresholdSize = 50 * 1024 * 1024;
         assertTrue(results.first < thresholdSize);
         assertEquals(results.first, results.second);
@@ -1195,7 +1215,7 @@ public boolean shouldCompact(long totalBytes, long usedBytes) {
 
     @Test
     public void defaultCompactOnLaunch() throws IOException {
-        Pair<Long, Long> results = populateTestRealmAndCompactOnLaunch(null, 30000);
+        Pair<Long, Long> results = populateTestRealmAndCompactOnLaunch(null, 50);
         final long thresholdSize = 50 * 1024 * 1024;
         assertTrue(results.first > thresholdSize);
         assertTrue(results.first > results.second);
@@ -1215,7 +1235,7 @@ public void defaultCompactOnLaunch_onlyCallback() {
 
     @Test
     public void defaultCompactOnLaunch_insufficientAmount() throws IOException {
-        Pair<Long, Long> results = populateTestRealmAndCompactOnLaunch(null, 100);
+        Pair<Long, Long> results = populateTestRealmAndCompactOnLaunch(null, 1);
         final long thresholdSize = 50 * 1024 * 1024;
         assertTrue(results.first < thresholdSize);
         assertEquals(results.first, results.second);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index a0e805da98..43329e65d4 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -39,6 +39,7 @@
 import java.util.Date;
 import java.util.Locale;
 import java.util.Random;
+import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
@@ -319,6 +320,13 @@ public static InputStream stringToStream(String str) {
         return key;
     }
 
+    public static String getRandomEmail() {
+        StringBuilder sb = new StringBuilder(UUID.randomUUID().toString().toLowerCase());
+        sb.append('@');
+        sb.append("androidtest.realm.io");
+        return sb.toString();
+    }
+
     // Returns a random key from the given seed. Used by encrypted Realms.
     public static byte[] getRandomKey(long seed) {
         byte[] key = new byte[64];
@@ -1134,7 +1142,7 @@ public static void waitRealmThreadExecutorFinish() {
             }
             counter--;
         }
-        fail("'BaseRealm.asyncTaskExecutor' is not finished in " + counter/10 + " seconds");
+        fail("'BaseRealm.asyncTaskExecutor' is not finished in " + counter/10.0D + " seconds");
     }
 
     /**
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
index c5325a0d42..8f998e57c7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
@@ -62,6 +62,9 @@
     // Thread safe
     private final CountDownLatch signalTestCompleted = new CountDownLatch(1);
 
+    // Thread safe
+    private boolean ruleBeingUsed = false;
+
     // Access guarded by 'lock'
     private RealmConfiguration realmConfiguration;
 
@@ -298,6 +301,9 @@ public Statement apply(Statement base, Description description) {
         if (annotation == null) {
             return base;
         }
+        synchronized (lock) {
+            ruleBeingUsed = true;
+        }
         return new RunInLooperThreadStatement(annotation, base);
     }
 
@@ -348,6 +354,13 @@ public boolean isTestComplete() {
         }
     }
 
+    /**
+     * Returns true if the current test being run is using this rule.
+     */
+    public boolean isRuleUsed() {
+        return ruleBeingUsed;
+    }
+
     /**
      * If an implementation of this is supplied with the annotation, the {@link RunnableBefore#run(RealmConfiguration)}
      * will be executed before the looper thread starts. It is normally for populating the Realm before the test.
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/PermissionRequestTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/PermissionRequestTests.java
new file mode 100644
index 0000000000..5ecde21eca
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/PermissionRequestTests.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.permissions.AccessLevel;
+import io.realm.permissions.PermissionRequest;
+import io.realm.permissions.UserCondition;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+
+@RunWith(AndroidJUnit4.class)
+public class PermissionRequestTests {
+
+    @Test
+    public void nullArgumentsThrows() {
+        try {
+            new PermissionRequest(null, "*", AccessLevel.ADMIN);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("Non-null 'condition' required."));
+        }
+
+        try {
+            new PermissionRequest(UserCondition.userId("id"), null, AccessLevel.ADMIN);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("Non-empty 'realmUrl' required."));
+        }
+
+        try {
+            new PermissionRequest(UserCondition.userId("id"), "*", null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("Non-null 'accessLevel' required."));
+        }
+    }
+
+    @Test
+    public void url_throwsOnInvalidURIs() {
+        String[] invalidUrls = { "", "\\", "<foo>" };
+        for (String url : invalidUrls) {
+            try {
+                new PermissionRequest(UserCondition.userId("id"), url, AccessLevel.ADMIN);
+                fail(url + " should have thrown");
+            } catch (IllegalArgumentException ignore) {
+            }
+        }
+    }
+
+    @Test
+    public void url_validURIs() {
+        // We support "*" and valid URI's
+        // We don't attempt to do more validation than that and leaves that up to ROS
+        String[] validUrls = {
+                "*",
+                "http://foo/bar/baz",
+                "https://foo/bar/baz",
+                "realm://foo.bar/~/default",
+                "realms://foo.bar/~/default"
+        };
+        for (String url : validUrls) {
+            PermissionRequest request = new PermissionRequest(UserCondition.userId("id"), url, AccessLevel.ADMIN);
+            assertEquals(url, request.getUrl());
+        }
+    }
+
+    @Test
+    public void getters() {
+        UserCondition condition = UserCondition.userId("id");
+        String url = "*";
+        AccessLevel accessLevel = AccessLevel.ADMIN;
+
+        PermissionRequest request = new PermissionRequest(condition, url, accessLevel);
+
+        assertEquals(condition, request.getCondition());
+        assertEquals(url, request.getUrl());
+        assertEquals(accessLevel, request.getAccessLevel());
+    }
+
+    @Test
+    public void equals() {
+        PermissionRequest r1 = new PermissionRequest(UserCondition.userId("id"), "*", AccessLevel.ADMIN);
+        PermissionRequest r2 = new PermissionRequest(UserCondition.userId("id"), "*", AccessLevel.ADMIN);
+
+        assertTrue(r1.equals(r2));
+        assertTrue(r2.equals(r1));
+        assertEquals(r1.hashCode(), r2.hashCode());
+    }
+
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index ee9b216eb3..5dc2af0691 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -21,10 +21,13 @@
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.util.concurrent.atomic.AtomicReference;
+
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestSyncConfigurationFactory;
@@ -188,6 +191,56 @@ public void onError(SyncSession session, ObjectServerError error) {
         SyncManager.simulateClientReset(SyncManager.getSession(config));
     }
 
+    // Check that if we manually trigger a Client Reset, then it should be possible to start
+    // downloading the Realm immediately after.
+    @Test
+    @RunTestInLooperThread
+    @Ignore("https://github.com/realm/realm-java/issues/5143")
+    public void clientReset_manualTriggerAllowSessionToRestart() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/~/myrealm";
+        final AtomicReference<SyncConfiguration> configRef = new AtomicReference<>(null);
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user , url)
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
+
+                        // Execute Client Reset
+                        looperThread.closeTestRealms();
+                        handler.executeClientReset();
+
+                        // Try to re-open Realm and download it again
+                        looperThread.postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                // Validate that files have been moved
+                                assertFalse(handler.getOriginalFile().exists());
+                                assertTrue(handler.getBackupFile().exists());
+
+                                SyncConfiguration config = configRef.get();
+                                Realm instance = Realm.getInstance(config);
+                                looperThread.addTestRealm(instance);
+                                try {
+                                    SyncManager.getSession(config).downloadAllServerChanges();
+                                    looperThread.testComplete();
+                                } catch (InterruptedException e) {
+                                    fail(e.toString());
+                                }
+                            }
+                        });
+                    }
+                })
+                .build();
+        configRef.set(config);
+
+        Realm realm = Realm.getInstance(config);
+        looperThread.addTestRealm(realm);
+
+        // Trigger error
+        SyncManager.simulateClientReset(SyncManager.getSession(config));
+    }
+
     @Test
     @UiThreadTest
     public void uploadAllLocalChanges_throwsOnUiThread() throws InterruptedException {
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
index be713e25b7..2d306e413e 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
@@ -18,6 +18,7 @@
 
 import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -26,7 +27,9 @@
 
 import java.io.IOException;
 import java.util.Collection;
+import java.util.Collections;
 
+import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static io.realm.util.SyncTestUtils.createTestUser;
@@ -66,7 +69,7 @@ public void remove(String identity, String authenticationUrl) {
 
             @Override
             public Collection<SyncUser> allUsers() {
-                return null;
+                return Collections.emptySet();
             }
 
             @Override
@@ -76,6 +79,12 @@ public boolean isActive(String identity, String authenticationUrl) {
         };
     }
 
+    @After
+    public void tearDown() {
+        UserFactory.logoutAllUsers();
+        SyncManager.reset();
+    }
+
     @Test
     public void set_userStore() {
         SyncManager.setUserStore(userStore);
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index 40e8f831f9..1c90667d09 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -20,6 +20,7 @@
 import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Ignore;
@@ -49,11 +50,13 @@
 import io.realm.internal.network.AuthenticationServer;
 import io.realm.internal.objectserver.Token;
 import io.realm.log.RealmLog;
+import io.realm.objectserver.utils.UserFactory;
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.util.SyncTestUtils;
 
+import static io.realm.util.SyncTestUtils.createNamedTestUser;
 import static io.realm.util.SyncTestUtils.createTestAdminUser;
 import static io.realm.util.SyncTestUtils.createTestUser;
 import static junit.framework.Assert.assertEquals;
@@ -104,6 +107,20 @@ public void setUp() {
         SyncManager.reset();
     }
 
+    @After
+    public void after() {
+        if (!looperThread.isRuleUsed() || looperThread.isTestComplete()) {
+            UserFactory.logoutAllUsers();
+        } else {
+            looperThread.runAfterTest(new Runnable() {
+                @Override
+                public void run() {
+                    UserFactory.logoutAllUsers();
+                }
+            });
+        }
+    }
+
     private static SyncUser createFakeUser(String id) {
         final Token token = new Token("token_value", id, "path_value", Long.MAX_VALUE, null);
         try {
@@ -425,6 +442,51 @@ public void changePassword_noneAdminThrows() {
         user.changePassword("user-id", "new-password");
     }
 
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getPermissionManager_isReferenceCounted() {
+        SyncUser user = createTestUser();
+        PermissionManager pm1 = user.getPermissionManager();
+        PermissionManager pm2 = user.getPermissionManager();
+        assertTrue(pm1 == pm2);
+        assertFalse(pm1.isClosed());
+        pm1.close();
+        assertFalse(pm1.isClosed());
+        pm1.close();
+        assertTrue(pm1.isClosed());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getPermissionManger_instanceUniqueToUser() {
+        SyncUser user1 = createNamedTestUser("user1");
+        SyncUser user2 = createNamedTestUser("user2");
+        PermissionManager pm1 = user1.getPermissionManager();
+        PermissionManager pm2 = user2.getPermissionManager();
+
+        try {
+            assertFalse(pm1 == pm2);
+            assertFalse(pm1.equals(pm2));
+            looperThread.testComplete();
+        } finally {
+            pm1.close();
+            pm2.close();
+            user1.logout();
+            user2.logout();
+        }
+    }
+
+    @Test
+    public void getPermissionManager_throwOnNonLooperThread() {
+        SyncUser user = createTestUser();
+        try {
+            user.getPermissionManager();
+            fail();
+        } catch (IllegalStateException e) {
+        }
+    }
+
     @Test
     public void allSessions() {
         String url1 = "realm://objectserver.realm.io/default";
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/UserConditionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/UserConditionTests.java
new file mode 100644
index 0000000000..173e3dccce
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/UserConditionTests.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.permissions.UserCondition;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+
+@RunWith(AndroidJUnit4.class)
+public class UserConditionTests {
+
+    @Test
+    public void username_nullOrEmptyThrows() {
+        String[] illegalValues = { null, ""};
+        for (String value : illegalValues) {
+            try {
+                UserCondition.username(value);
+                fail();
+            } catch (IllegalArgumentException ignore) {
+            }
+        }
+    }
+
+    @Test
+    public void userId_nullOrEmptyThrows() {
+        String[] illegalValues = { null, ""};
+        for (String value : illegalValues) {
+            try {
+                UserCondition.userId(value);
+                fail();
+            } catch (IllegalArgumentException ignore) {
+            }
+        }
+    }
+
+    @Test
+    public void keyValue_nullOrEmptyThrows() {
+        // Keys
+        String[] illegalKeys = { null, ""};
+        for (String key : illegalKeys) {
+            try {
+                UserCondition.keyValue(key, "value");
+                fail();
+            } catch (IllegalArgumentException ignore) {
+            }
+        }
+
+        // Values
+        try {
+            UserCondition.keyValue("key", null);
+            fail();
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    @Test
+    public void username() {
+        UserCondition condition = UserCondition.username("a@b.c");
+        assertEquals("a@b.c", condition.getValue());
+        assertEquals("email", condition.getKey());
+        assertEquals(UserCondition.MatcherType.METADATA, condition.getType());
+    }
+
+    @Test
+    public void userId() {
+        UserCondition condition = UserCondition.userId("foo");
+        assertEquals("foo", condition.getValue());
+        assertEquals("", condition.getKey());
+        assertEquals(UserCondition.MatcherType.USER_ID, condition.getType());
+    }
+
+    @Test
+    public void keyValue() {
+        UserCondition condition = UserCondition.keyValue("key", "value");
+        assertEquals("value", condition.getValue());
+        assertEquals("key", condition.getKey());
+        assertEquals(UserCondition.MatcherType.METADATA, condition.getType());
+    }
+
+    @Test
+    public void nonExistingPermissions() {
+        UserCondition condition = UserCondition.noExistingPermissions();
+        assertEquals("*", condition.getValue());
+        assertEquals("", condition.getKey());
+        assertEquals(UserCondition.MatcherType.USER_ID, condition.getType());
+    }
+
+    @Test
+    public void equals() {
+        UserCondition c1 = UserCondition.username("a@b.c");
+        UserCondition c2 = UserCondition.username("a@b.c");
+
+        assertTrue(c1.equals(c2));
+        assertTrue(c2.equals(c1));
+        assertEquals(c1.hashCode(), c2.hashCode());
+    }
+
+    @Test
+    public void notEquals() {
+        UserCondition c1 = UserCondition.username("a@b.c");
+        UserCondition c2 = UserCondition.username("a@b.d");
+
+        assertFalse(c1.equals(c2));
+        assertFalse(c2.equals(c1));
+        assertNotEquals(c1.hashCode(), c2.hashCode());
+    }
+}
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index 9636fb6a29..97ce1d8b06 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -51,7 +51,7 @@ set(jni_headers_PATH /./${PROJECT_BINARY_DIR}/jni_include)
 if (build_SYNC)
     list(APPEND classes_LIST
         io.realm.ClientResetRequiredError io.realm.RealmFileUserStore
-        io.realm.SyncManager io.realm.SyncSession
+        io.realm.SyncManager io.realm.SyncSession io.realm.SyncUser
     )
 endif()
 create_javah(TARGET jni_headers
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 54a98b2152..d1a101fda6 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 54a98b215284e58b73e0664723fbd852ffb04902
+Subproject commit d1a101fda6999e070c1e73cc5aff002c3de7c129
diff --git a/realm/realm-library/src/main/java/io/realm/DefaultCompactOnLaunchCallback.java b/realm/realm-library/src/main/java/io/realm/DefaultCompactOnLaunchCallback.java
index 9c385effbc..59369a51a6 100644
--- a/realm/realm-library/src/main/java/io/realm/DefaultCompactOnLaunchCallback.java
+++ b/realm/realm-library/src/main/java/io/realm/DefaultCompactOnLaunchCallback.java
@@ -16,8 +16,6 @@
 
 package io.realm;
 
-import io.realm.log.RealmLog;
-
 /**
  * The default implementation for determining if a file should be compacted or not. This implementation will only
  * trigger if the file is above 50 MB and more than 50% can be reclaimed.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java b/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
index 28fceabc74..950b3066d7 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
@@ -17,7 +17,7 @@
 package io.realm;
 
 /**
- * Represents a pending asynchronous Realm transaction.
+ * Represents a pending asynchronous Realm task, like asynchronous transactions.
  * <p>
  * Users are responsible for maintaining a reference to {@code RealmAsyncTask} in order to call {@link #cancel()} in
  * case of a configuration change for example (to avoid memory leak, as the transaction will post the result to the
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 1528639988..1044874e21 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -292,35 +292,40 @@ private static RealmCache getCache(String realmPath, boolean createIfNotExist) {
 
             SharedRealm sharedRealm = null;
             try {
-                sharedRealm = SharedRealm.getInstance(configuration);
-
-                // If waitForInitialRemoteData() was enabled, we need to make sure that all data is downloaded
-                // before proceeding. We need to open the Realm instance first to start any potential underlying
-                // SyncSession so this will work. TODO: This needs to be decoupled.
-                if (!fileExists) {
-                    try {
-                        ObjectServerFacade.getSyncFacadeIfPossible().downloadRemoteChanges(configuration);
-                    } catch (Throwable t) {
-                        // If an error happened while downloading initial data, we need to reset the file so we can
-                        // download it again on the next attempt.
-                        // Realm.deleteRealm() is under the same lock as this method and globalCount is still 0, so
-                        // this should be safe.
-                        sharedRealm.close();
-                        sharedRealm = null;
-                        Realm.deleteRealm(configuration);
-                        throw t;
+                if (configuration.isSyncConfiguration()) {
+                    // If waitForInitialRemoteData() was enabled, we need to make sure that all data is downloaded
+                    // before proceeding. We need to open the Realm instance first to start any potential underlying
+                    // SyncSession so this will work. TODO: This needs to be decoupled.
+                    if (!fileExists) {
+                        sharedRealm = SharedRealm.getInstance(configuration);
+                        try {
+                            ObjectServerFacade.getSyncFacadeIfPossible().downloadRemoteChanges(configuration);
+                        } catch (Throwable t) {
+                            // If an error happened while downloading initial data, we need to reset the file so we can
+                            // download it again on the next attempt.
+                            // Realm.deleteRealm() is under the same lock as this method and globalCount is still 0, so
+                            // this should be safe.
+                            sharedRealm.close();
+                            sharedRealm = null;
+                            Realm.deleteRealm(configuration);
+                            throw t;
+                        }
                     }
-                }
-
-                if (Table.primaryKeyTableNeedsMigration(sharedRealm)) {
-                    sharedRealm.beginTransaction();
-                    if (Table.migratePrimaryKeyTableIfNeeded(sharedRealm)) {
-                        sharedRealm.commitTransaction();
-                    } else {
-                        sharedRealm.cancelTransaction();
+                } else {
+                    if (fileExists) {
+                        // Primary key problem only exists before we release sync.
+                        sharedRealm = SharedRealm.getInstance(configuration);
+
+                        if (Table.primaryKeyTableNeedsMigration(sharedRealm)) {
+                            sharedRealm.beginTransaction();
+                            if (Table.migratePrimaryKeyTableIfNeeded(sharedRealm)) {
+                                sharedRealm.commitTransaction();
+                            } else {
+                                sharedRealm.cancelTransaction();
+                            }
+                        }
                     }
                 }
-
             } finally {
                 if (sharedRealm != null) {
                     sharedRealm.close();
diff --git a/realm/realm-library/src/main/java/io/realm/log/RealmLog.java b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
index df2dd20fda..62a09e760f 100644
--- a/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
+++ b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
@@ -51,6 +51,9 @@ public static void add(RealmLogger logger) {
      * @param level see {@link LogLevel}.
      */
     public static void setLevel(int level) {
+        if (level < LogLevel.ALL || level > LogLevel.OFF) {
+            throw new IllegalArgumentException("Invalid log level: " + level);
+        }
         nativeSetLogLevel(level);
     }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java b/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
new file mode 100644
index 0000000000..170b11db05
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
@@ -0,0 +1,1362 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.Handler;
+
+import java.io.Closeable;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+import io.realm.internal.Util;
+import io.realm.internal.permissions.BasePermissionApi;
+import io.realm.internal.permissions.ManagementModule;
+import io.realm.internal.permissions.PermissionChange;
+import io.realm.internal.permissions.PermissionModule;
+import io.realm.internal.permissions.PermissionOfferResponse;
+import io.realm.log.RealmLog;
+import io.realm.permissions.Permission;
+import io.realm.permissions.PermissionOffer;
+import io.realm.permissions.PermissionRequest;
+
+
+/**
+ * Helper class for interacting with Realm Object Server permissions for a {@link SyncUser}.
+ * <p>
+ * Current functionality supported by this class:
+ * <ul>
+ *     <li>List users existing permissions.</li>
+ *     <li>List default permissions.</li>
+ *     <li>Modify permissions for a Realm.</li>
+ *     <li>Create a permission offer that can be sent to others.</li>
+ *     <li>Accept permission offers sent by other users.</li>
+ * </ul>
+ * <p>
+ * This class depends on underlying Realms, so all data coming from this class is thread-confined and must be
+ * closed after use to avoid leaking resources.
+ *
+ * @see <a href="https://realm.io/docs/java/latest/#access-control">How to work with Access Controls</a>
+ */
+public class PermissionManager implements Closeable {
+
+    // Reference counted cache equivalent to how Realm instances work.
+    private static Map<String, ThreadLocal<Cache>> cache = new HashMap<>();
+
+    private static class Cache {
+        public PermissionManager pm = null;
+        public Integer instanceCounter = Integer.valueOf(0);
+    }
+
+    private static final Object cacheLock = new Object();
+
+    /**
+     * Return a thread confined, reference counted instance of the PermissionManager.
+     *
+     * @param syncUser user to create the PermissionManager for.
+     * @return a thread confined PermissionManager instance for the provided user.
+     */
+    static PermissionManager getInstance(SyncUser syncUser) {
+        synchronized (cacheLock) {
+            String userId = syncUser.getIdentity();
+            ThreadLocal<Cache> threadLocalCache = cache.get(userId);
+            if (threadLocalCache == null) {
+                threadLocalCache = new ThreadLocal<Cache>() {
+                    @Override
+                    protected Cache initialValue() {
+                        return new Cache();
+                    }
+                };
+                cache.put(userId, threadLocalCache);
+            }
+            Cache c = threadLocalCache.get();
+            if (c.instanceCounter == 0) {
+                c.pm = new PermissionManager(syncUser);
+            }
+            c.instanceCounter++;
+            return c.pm;
+        }
+    }
+
+    private enum RealmType {
+        DEFAULT_PERMISSION_REALM("__permission", true),
+        PERMISSION_REALM("__permission", false),
+        MANAGEMENT_REALM("__management", false);
+
+        private final String name;
+        private final boolean globalRealm;
+
+        RealmType(String realmName, boolean globalRealm) {
+            this.name = realmName;
+            this.globalRealm = globalRealm;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public boolean isGlobalRealm() {
+            return globalRealm;
+        }
+    }
+
+    private final SyncUser user;
+
+    // Used to track the lifecycle of the PermissionManager
+    private RealmAsyncTask managementRealmOpenTask;
+    private RealmAsyncTask permissionRealmOpenTask;
+    private RealmAsyncTask defaultPermissionRealmOpenTask;
+    private boolean openInProgress = false;
+    private boolean closed;
+
+    private final long threadId;
+    private Handler handler = new Handler();
+    final SyncConfiguration managementRealmConfig;
+    final SyncConfiguration permissionRealmConfig;
+    final SyncConfiguration defaultPermissionRealmConfig;
+    private Realm permissionRealm;
+    private Realm managementRealm;
+    private Realm defaultPermissionRealm;
+
+    // Task list used to queue tasks until the underlying Realms are done opening (or failed doing so).
+    private Deque<PermissionManagerTask> delayedTasks = new LinkedList<>();
+
+    // List of tasks that are being processed. Used to keep strong references for listeners to work.
+    // The task must remove itself from this list once it either completes
+    // or fails.
+    private List<RealmAsyncTask> activeTasks = new ArrayList<>();
+
+    // Object Server Errors might be reported on another thread than the one running this PermissionManager
+    // In order to prevent race conditions, all blocks of code that read/write these errors should do
+    // so while holding the errorLock
+    private final Object errorLock = new Object();
+    private volatile ObjectServerError permissionRealmError = null;
+    private volatile ObjectServerError managementRealmError = null;
+    private volatile ObjectServerError defaultPermissionRealmError = null;
+
+    // A client reset was encountered in one of the Realms.
+    // This has invalidated the PermissionManager and it must be closed as soon as possible.
+    // This flag purely used to be able to send a proper error message to users.
+    private boolean clientReset = false;
+
+
+    // Cached result of the permission query. This will be filled, once the first PermissionAsyncTask has loaded
+    // the result.
+    private RealmResults<Permission> userPermissions;
+    private RealmResults<Permission> defaultPermissions;
+    private RealmResults<PermissionOffer> offers;
+
+    /**
+     * Creates a PermissionManager for the given user.
+     *
+     * This class is thread confined, so thread safety is not a concern since all internal
+     * communication is routed through the original Handler thread.
+     *
+     * @param user user to create manager for.
+     */
+    private PermissionManager(SyncUser user) {
+        this.user = user;
+        threadId = Thread.currentThread().getId();
+        managementRealmConfig = new SyncConfiguration.Builder(
+                user, getRealmUrl(RealmType.MANAGEMENT_REALM, user.getAuthenticationUrl()))
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        synchronized (errorLock) {
+                            managementRealmError = error;
+                        }
+                    }
+                })
+                .modules(new ManagementModule())
+                .build();
+
+        permissionRealmConfig = new SyncConfiguration.Builder(
+                user, getRealmUrl(RealmType.PERMISSION_REALM, user.getAuthenticationUrl()))
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        synchronized (errorLock) {
+                            permissionRealmError = error;
+                        }
+                    }
+                })
+                .modules(new PermissionModule())
+                .waitForInitialRemoteData()
+                // FIXME: Something is seriously wrong with the Permission Realm. It doesn't seem to
+                // exist on the server. Making it impossible to mark it read only
+                // .readOnly()
+                .build();
+
+        defaultPermissionRealmConfig = new SyncConfiguration.Builder(
+                user, getRealmUrl(RealmType.DEFAULT_PERMISSION_REALM, user.getAuthenticationUrl()))
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        synchronized (errorLock) {
+                            defaultPermissionRealmError = error;
+                        }
+                    }
+                })
+                .modules(new PermissionModule())
+                .waitForInitialRemoteData()
+                .readOnly()
+                .build();
+    }
+
+    /**
+     * Retrieves the list of permissions for all Realms available to this user.
+     *
+     * @param callback callback notified when the permissions are ready. The returned {@link RealmResults} is a fully
+     * live query result, that will be auto-updated like any other {@link RealmResults}.
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     */
+    public RealmAsyncTask getPermissions(PermissionsCallback callback) {
+        checkIfValidThread();
+        checkCallbackNotNull(callback);
+        return addTask(new GetPermissionsAsyncTask(this, callback));
+    }
+
+    /**
+     * TODO: Removed from the public API until we know for 100% that we are going to use this going forward.
+     *
+     * Returns default permissions for all Realms. The default permissions are the ones that will be used if no
+     * user specific permissions is in effect.
+     *
+     * @param callback callback notified when the permissions are ready. The returned {@link RealmResults} is a fully
+     * live query result, that will be auto-updated like any other {@link RealmResults}.
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     */
+    RealmAsyncTask getDefaultPermissions(PermissionsCallback callback) {
+        checkIfValidThread();
+        checkCallbackNotNull(callback);
+        return addTask(new GetDefaultPermissionsAsyncTask(this, callback));
+    }
+
+    /**
+     * Applies a given set of permissions to a Realm.
+     * <p>
+     * A {@link PermissionRequest} object encapsulates a description of which users are granted what
+     * {@link io.realm.permissions.AccessLevel}s for which Realm(s).
+     * <p>
+     * Once the request is successfully handled, a {@link Permission} entry is created in each user's
+     * {@link PermissionManager} and can be found using {@link PermissionManager#getPermissions(PermissionsCallback)}.
+     *
+     * @param request request object describing which permissions to grant and to what Realm(s).
+     * @param callback callback when the request either succeeded or failed.
+     * @return async task representing the request. This can be used to cancel it if needed.
+     */
+    public RealmAsyncTask applyPermissions(PermissionRequest request, ApplyPermissionsCallback callback) {
+        checkIfValidThread();
+        checkCallbackNotNull(callback);
+        return addTask(new ApplyPermissionTask(this, request, callback));
+    }
+
+    /**
+     * Makes a permission offer to users. The offer is represented by an offer token and the permission changes
+     * described in the {@link PermissionOffer} do not take effect until the offer has been accepted by a user
+     * calling {@link #acceptOffer(String, AcceptOfferCallback)}.
+     * <p>
+     * A permission offer can be used as a flexible way of sharing Realms with other users that might not be known at the time
+     * of making the offer as well as enabling sharing across other channels like e-mail. If a specific user should be
+     * granted access, using {@link #applyPermissions(PermissionRequest, ApplyPermissionsCallback)} will be faster and quicker.
+     * <p>
+     * An offer can be accepted by multiple users.
+     *
+     * @param callback callback to be notified with the offer token once it is ready.
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Permissions description</a> for general
+     * documentation.
+     * @see <a href="https://realm.io/docs/java/latest/#modifying-permissions">Modifying permissions</a> for a more
+     * high level description.
+     */
+    public RealmAsyncTask makeOffer(PermissionOffer offer, MakeOfferCallback callback) {
+        checkIfValidThread();
+        checkCallbackNotNull(callback);
+        if (offer.isOfferCreated()) {
+            throw new IllegalStateException("Offer has already been created: " + offer);
+        }
+        return addTask(new MakeOfferAsyncTask(this, offer, callback));
+    }
+
+    /**
+     * Accepts a permission offer sent by another user. Once this offer is accepted successfully, the permissions
+     * described by the token will be granted.
+     *
+     * @param offerToken token representing the permission offer.
+     * @param callback with the permission details that were accepted.
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     */
+    public RealmAsyncTask acceptOffer(String offerToken, AcceptOfferCallback callback) {
+        checkIfValidThread();
+        checkCallbackNotNull(callback);
+        if (Util.isEmptyString(offerToken)) {
+            throw new IllegalArgumentException("Non-empty 'offerToken' required.");
+        }
+        return addTask(new AcceptOfferAsyncTask(this, offerToken, callback));
+    }
+
+    /**
+     * Revokes an existing offer. This will prevent any other users from accepting it. Users that already accepted it,
+     * will not be affected. Revocation cannot happen until the device has talked to the server. The callback will
+     * not be notified until this has happened.
+     *
+     * @param offerToken token that should be revoked.
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     */
+    public RealmAsyncTask revokeOffer(String offerToken, RevokeOfferCallback callback) {
+        checkIfValidThread();
+        checkCallbackNotNull(callback);
+        return addTask(new RevokeOfferAsyncTask(this, offerToken, callback));
+    }
+
+    /**
+     * Returns the list of offers created by this user. These offers can be revoked again by calling
+     * {@link #revokeOffer(String, RevokeOfferCallback)} or sent to other users by sending the
+     * {@link PermissionOffer#getToken()}.
+     *
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     */
+    public RealmAsyncTask getCreatedOffers(OffersCallback callback) {
+        checkIfValidThread();
+        checkCallbackNotNull(callback);
+        return addTask(new GetOffersAsyncTask(this, callback));
+    }
+
+    // Queue the task if the underlying Realms are not ready yet, otherwise
+    // start the task by sending it to this thread handler. This is done
+    // in order to be able to provide the user with a RealmAsyncTask representation
+    // of the work being done.
+    private RealmAsyncTask addTask(PermissionManagerTask task) {
+        if (isReady()) {
+            activateTask(task);
+        } else {
+            delayTask(task);
+            openRealms();
+        }
+
+        return task;
+    }
+
+    // Park the task until all underlying Realms are ready
+    private void delayTask(PermissionManagerTask task) {
+        delayedTasks.add(task);
+    }
+
+    // Run any tasks that were delayed while the underlying Realms were being opened.
+    // PRECONDITION: Underlying Realms are no longer in the process of being opened.
+    private void runDelayedTasks() {
+        for (PermissionManagerTask delayedTask : delayedTasks) {
+            activateTask(delayedTask);
+        }
+        delayedTasks.clear();
+    }
+
+    // Activate a task. All tasks are controlled by the Handler in order to make it asynchronous.
+    // PRECONDITION: Underlying Realms are no longer in the process of being opened.
+    private void activateTask(PermissionManagerTask task) {
+        activeTasks.add(task);
+        handler.post(task);
+    }
+
+    // Open all underlying Realms asynchronously. Once they are all ready, all tasks added in the meantime are
+    // started. Any error will be reported through the `Callback.onError` callback if the Realms failed to open
+    // correctly.
+    private void openRealms() {
+        if (!openInProgress) {
+            openInProgress = true;
+            managementRealmOpenTask = Realm.getInstanceAsync(managementRealmConfig, new Realm.Callback() {
+                @Override
+                public void onSuccess(Realm realm) {
+                    managementRealm = realm;
+                    checkIfRealmsAreOpenedAndRunDelayedTasks();
+                }
+
+                @Override
+                public void onError(Throwable exception) {
+                    synchronized (errorLock) {
+                        managementRealmError = new ObjectServerError(ErrorCode.UNKNOWN, exception);
+                        checkIfRealmsAreOpenedAndRunDelayedTasks();
+                    }
+                }
+            });
+            permissionRealmOpenTask = Realm.getInstanceAsync(permissionRealmConfig, new Realm.Callback() {
+                @Override
+                public void onSuccess(Realm realm) {
+                    permissionRealm = realm;
+                    checkIfRealmsAreOpenedAndRunDelayedTasks();
+                }
+
+                @Override
+                public void onError(Throwable exception) {
+                    synchronized (errorLock) {
+                        permissionRealmError = new ObjectServerError(ErrorCode.UNKNOWN, exception);
+                        checkIfRealmsAreOpenedAndRunDelayedTasks();
+                    }
+                }
+            });
+            defaultPermissionRealmOpenTask = Realm.getInstanceAsync(defaultPermissionRealmConfig, new Realm.Callback() {
+                @Override
+                public void onSuccess(Realm realm) {
+                    defaultPermissionRealm = realm;
+                    checkIfRealmsAreOpenedAndRunDelayedTasks();
+                }
+
+                @Override
+                public void onError(Throwable exception) {
+                    synchronized (errorLock) {
+                        defaultPermissionRealmError = new ObjectServerError(ErrorCode.UNKNOWN, exception);
+                        checkIfRealmsAreOpenedAndRunDelayedTasks();
+                    }
+                }
+            });
+        }
+    }
+
+    private void checkIfRealmsAreOpenedAndRunDelayedTasks() {
+        synchronized (errorLock) {
+            if ((permissionRealm != null || permissionRealmError != null)
+                && (defaultPermissionRealm != null || defaultPermissionRealmError != null)
+                && (managementRealm != null || managementRealmError != null)) {
+                openInProgress = false;
+                runDelayedTasks();
+            }
+        }
+    }
+
+    private void checkCallbackNotNull(PermissionManagerBaseCallback callback) {
+        if (callback == null) {
+            throw new IllegalArgumentException("Non-null 'callback' required.");
+        }
+    }
+
+    private boolean isReady() {
+        return managementRealm != null && permissionRealm != null && defaultPermissionRealm != null;
+    }
+
+    private void checkIfValidThread() {
+        // Checks if we are in thread that created the PermissionManager.
+        if (threadId != Thread.currentThread().getId()) {
+            throw new IllegalStateException("PermissionManager was accessed from the wrong thread. It can only be " +
+                                            "accessed on the thread it was created on.");
+        }
+    }
+
+    /**
+     * Closes the PermissionManager as well as any underlying Realms.
+     * Any active tasks in progress will be canceled.
+     */
+    @Override
+    public void close() {
+        checkIfValidThread();
+
+        // Multiple instances open, just decrement the reference count
+        synchronized (cacheLock) {
+            Cache cache = PermissionManager.cache.get(user.getIdentity()).get();
+            if (cache.instanceCounter > 1) {
+                cache.instanceCounter--;
+                return;
+            }
+
+            // Only one instance open. Do a full close
+            cache.instanceCounter = 0;
+            cache.pm = null;
+        }
+        delayedTasks.clear();
+
+        // If Realms are still being opened, abort that task
+        if (managementRealmOpenTask != null) {
+            managementRealmOpenTask.cancel();
+            managementRealmOpenTask = null;
+        }
+        if (permissionRealmOpenTask != null) {
+            permissionRealmOpenTask.cancel();
+            permissionRealmOpenTask = null;
+        }
+        if (defaultPermissionRealmOpenTask != null) {
+            defaultPermissionRealmOpenTask.cancel();
+            defaultPermissionRealmOpenTask = null;
+        }
+
+        // If Realms are opened. Close them.
+        if (managementRealm != null) {
+            managementRealm.close();
+        }
+        if (permissionRealm != null) {
+            permissionRealm.close();
+        }
+        if (defaultPermissionRealm != null) {
+            defaultPermissionRealm.close();
+        }
+        closed = true;
+    }
+
+    /**
+     * Checks if this PermissionManager is closed or not. If it is closed, all methods will report back an error.
+     *
+     * @return {@code true} if the PermissionManager is closed, {@code false} if it is still open.
+     */
+    public boolean isClosed() {
+        checkIfValidThread();
+        return closed;
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        if (!closed) {
+            RealmLog.warn("PermissionManager was not correctly closed before being finalized.");
+        }
+        super.finalize();
+    }
+
+    // Creates the URL to the permission/management Realm based on the authentication URL.
+    private static String getRealmUrl(RealmType type, URL authUrl) {
+        String scheme = "realm";
+        if (authUrl.getProtocol().equalsIgnoreCase("https")) {
+            scheme = "realms";
+        }
+        try {
+            String path = (type.isGlobalRealm() ? "/" : "/~/") + type.getName();
+            return new URI(scheme, authUrl.getUserInfo(), authUrl.getHost(), authUrl.getPort(), path, null, null).toString();
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException("Could not create URL to the " + type + " Realm", e);
+        }
+    }
+
+    // Task responsible for loading the Permissions result and returning it to the user.
+    // The Permission result is not considered available until the query has completed.
+    private class GetPermissionsAsyncTask extends PermissionManagerTask<RealmResults<Permission>> {
+
+        private final PermissionsCallback callback;
+        // Prevent permissions from being GC'ed until fully loaded.
+        private RealmResults<Permission> loadingPermissions;
+
+        GetPermissionsAsyncTask(PermissionManager permissionManager, PermissionsCallback callback) {
+            super(permissionManager, callback);
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            if (checkAndReportInvalidState()) { return; }
+            if (userPermissions != null) {
+                // Permissions already loaded
+                notifyCallbackWithSuccess(userPermissions);
+            } else {
+                // TODO Right now multiple getPermission() calls will result in multiple
+                // queries being executed. The first one to return will be the one returned
+                // by all callbacks.
+                loadingPermissions = permissionRealm.where(Permission.class).findAllAsync();
+                loadingPermissions.addChangeListener(new RealmChangeListener <RealmResults<Permission>>() {
+                    @Override
+                    public void onChange(RealmResults <Permission> loadedPermissions) {
+                        // FIXME Wait until both the __permission and __management Realm are available
+                        if (loadedPermissions.size() > 0) {
+                            loadingPermissions.removeChangeListener(this);
+                            if (checkAndReportInvalidState()) { return; }
+                            if (userPermissions == null) {
+                                userPermissions = loadedPermissions;
+                            }
+                            notifyCallbackWithSuccess(userPermissions);
+                        }
+                    }
+                });
+            }
+        }
+
+        void notifyCallbackWithSuccess(RealmResults<Permission> permissions) {
+            try {
+                callback.onSuccess(permissions);
+            } finally {
+                activeTasks.remove(this);
+            }
+        }
+    }
+
+    // Task responsible for loading the Default Permissions result and returning it to the user.
+    // The Permission result is not considered available until the query has completed.
+    private class GetDefaultPermissionsAsyncTask extends PermissionManagerTask<RealmResults<Permission>> {
+
+        private final PermissionsCallback callback;
+        // Prevent permissions from being GC'ed until fully loaded.
+        private RealmResults<Permission> loadingPermissions;
+
+        GetDefaultPermissionsAsyncTask(PermissionManager permissionManager, PermissionsCallback callback) {
+            super(permissionManager, callback);
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            if (checkAndReportInvalidState()) { return; }
+            if (defaultPermissions != null) {
+                notifyCallbackWithSuccess(defaultPermissions);
+            } else {
+                // Start loading permissions.
+                // TODO Right now multiple getPermission() calls will result in multiple
+                // queries being executed. The first one to return will be the one returned
+                // by all callbacks.
+                loadingPermissions = permissionRealm.where(Permission.class).findAllAsync();
+                loadingPermissions.addChangeListener(new RealmChangeListener <RealmResults<Permission>>() {
+                    @Override
+                    public void onChange(RealmResults <Permission> loadedPermissions) {
+                        if (loadedPermissions.size() > 0) {
+                            loadingPermissions.removeChangeListener(this);
+                            if (checkAndReportInvalidState()) { return; }
+                            if (defaultPermissions == null) {
+                                defaultPermissions = loadedPermissions;
+                            }
+                            notifyCallbackWithSuccess(defaultPermissions);
+                        }
+                    }
+                });
+            }
+        }
+
+        void notifyCallbackWithSuccess(RealmResults<Permission> permissions) {
+            try {
+               callback.onSuccess(permissions);
+            } finally {
+                activeTasks.remove(this);
+            }
+        }
+    }
+
+    // Class encapsulating setting a Permission by writing a PermissionChange and waiting for it to
+    // be processed.
+    private class ApplyPermissionTask extends PermissionManagerTask<Void> {
+
+        private final PermissionChange unmanagedChangeRequest;
+        private final ApplyPermissionsCallback callback;
+        private final String changeRequestId;
+        private PermissionChange managedChangeRequest;
+        private RealmAsyncTask transactionTask;
+
+        public ApplyPermissionTask(PermissionManager manager, PermissionRequest request, ApplyPermissionsCallback callback) {
+            super(manager, callback);
+            this.unmanagedChangeRequest = PermissionChange.fromRequest(request);
+            this.changeRequestId = unmanagedChangeRequest.getId();
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            if (checkAndReportInvalidState()) {
+                return;
+            }
+
+            // Save PermissionChange object. It will be synchronized to the server where it will be processed.
+            Realm.Transaction transaction = new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    if (checkAndReportInvalidState()) { return; }
+                    realm.insertOrUpdate(unmanagedChangeRequest);
+                }
+            };
+
+            // If the PermissionChange was successfully written to Realm, we need to wait for it to be processed.
+            // Register a ChangeListener on the object and wait for the proper response code, which can then be
+            // converted to a proper response to the user.
+            Realm.Transaction.OnSuccess onSuccess = new Realm.Transaction.OnSuccess() {
+                @Override
+                public void onSuccess() {
+                    if (checkAndReportInvalidState()) { return; }
+
+                    // Find PermissionChange object we just added
+                    managedChangeRequest = managementRealm.where(PermissionChange.class)
+                            .equalTo("id", changeRequestId)
+                            .findFirstAsync();
+
+
+                    // Wait for it to be processed
+                    RealmObject.addChangeListener(managedChangeRequest, new RealmChangeListener<PermissionChange>() {
+                        @Override
+                        public void onChange(PermissionChange permissionChange) {
+                            if (checkAndReportInvalidState()) {
+                                RealmObject.removeChangeListener(managedChangeRequest, this);
+                                return;
+                            }
+                            handleServerStatusChanges(permissionChange, new Runnable() {
+                                @Override
+                                public void run() {
+                                    notifyCallbackWithSuccess();
+                                }
+                            });
+                        }
+                    });
+                }
+            };
+
+            // Critical error: The PermissionChange could not be written to the Realm.
+            // Report it back to the user.
+            Realm.Transaction.OnError onError = new Realm.Transaction.OnError() {
+                @Override
+                public void onError(Throwable error) {
+                    if (checkAndReportInvalidState()) { return; }
+                    notifyCallbackWithError(new ObjectServerError(ErrorCode.UNKNOWN, error));
+                }
+            };
+
+            // Run
+            transactionTask = managementRealm.executeTransactionAsync(transaction, onSuccess, onError);
+        }
+
+        void notifyCallbackWithSuccess() {
+            try {
+                callback.onSuccess();
+            } finally {
+                activeTasks.remove(this);
+            }
+        }
+
+        @Override
+        public void cancel() {
+            super.cancel();
+            if (transactionTask != null) {
+                cancel();
+            }
+        }
+    }
+
+    private class MakeOfferAsyncTask extends PermissionManagerTask<String> {
+
+        private final PermissionOffer unmanagedOffer;
+        private final String offerId;
+        private final MakeOfferCallback callback;
+        private PermissionOffer managedOffer;
+        private RealmAsyncTask transactionTask;
+
+        public MakeOfferAsyncTask(PermissionManager permissionManager, PermissionOffer offer, MakeOfferCallback callback) {
+            super(permissionManager, callback);
+            this.unmanagedOffer = offer;
+            this.offerId = offer.getId();
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            if (checkAndReportInvalidState()) {
+                return;
+            }
+
+            // Save PermissionOffer object. It will be synchronized to the server where it will be processed.
+            Realm.Transaction transaction = new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    if (checkAndReportInvalidState()) { return; }
+                    realm.insertOrUpdate(unmanagedOffer);
+                }
+            };
+
+            // If the PermissionOffer was successfully written to Realm, we need to wait for it to be processed.
+            // Register a ChangeListener on the object and wait for the proper response code, which can then be
+            // converted to a proper response to the user.
+            Realm.Transaction.OnSuccess onSuccess = new Realm.Transaction.OnSuccess() {
+                @Override
+                public void onSuccess() {
+                    if (checkAndReportInvalidState()) { return; }
+
+                    // Find PermissionChange object we just added
+                    // Wait for it to be processed
+                    managedOffer = managementRealm.where(PermissionOffer.class).equalTo("id", offerId).findFirstAsync();
+                    RealmObject.addChangeListener(managedOffer, new RealmChangeListener<PermissionOffer>() {
+                        @Override
+                        public void onChange(final PermissionOffer permissionOffer) {
+                            if (checkAndReportInvalidState()) {
+                                RealmObject.removeChangeListener(managedOffer, this);
+                                return;
+                            }
+                            handleServerStatusChanges(permissionOffer, new Runnable() {
+                                @Override
+                                public void run() {
+                                    notifyCallbackWithSuccess(permissionOffer.getToken());
+                                }
+                            });
+                        }
+                    });
+                }
+            };
+
+            // Critical error: The PermissionChange could not be written to the Realm.
+            // Report it back to the user.
+            Realm.Transaction.OnError onError = new Realm.Transaction.OnError() {
+                @Override
+                public void onError(Throwable error) {
+                    if (checkAndReportInvalidState()) { return; }
+                    notifyCallbackWithError(new ObjectServerError(ErrorCode.UNKNOWN, error));
+                }
+            };
+
+            // Run
+            transactionTask = managementRealm.executeTransactionAsync(transaction, onSuccess, onError);
+        }
+
+        void notifyCallbackWithSuccess(String token) {
+            try {
+                callback.onSuccess(token);
+            } finally {
+                activeTasks.remove(this);
+            }
+        }
+
+        @Override
+        public void cancel() {
+            super.cancel();
+            if (transactionTask != null) {
+                transactionTask.cancel();
+                transactionTask = null;
+            }
+        }
+    }
+
+    private class AcceptOfferAsyncTask extends PermissionManagerTask<Permission> {
+
+        private final PermissionOfferResponse unmanagedResponse;
+        private final String responseId;
+        private final AcceptOfferCallback callback;
+        private PermissionOfferResponse managedResponse;
+        private RealmAsyncTask transactionTask;
+        public RealmResults<Permission> grantedPermissionResults;
+
+        public AcceptOfferAsyncTask(PermissionManager permissionManager, String offerToken, AcceptOfferCallback callback) {
+            super(permissionManager, callback);
+            this.unmanagedResponse = new PermissionOfferResponse(offerToken);
+            this.responseId = unmanagedResponse.getId();
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            if (checkAndReportInvalidState()) {
+                return;
+            }
+
+            // Save response object. It will be synchronized to the server where it will be processed.
+            Realm.Transaction transaction = new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    if (checkAndReportInvalidState()) { return; }
+                    realm.insertOrUpdate(unmanagedResponse);
+                }
+            };
+
+            // If the response was successfully written to Realm, we need to wait for it to be processed.
+            // Register a ChangeListener on the object and wait for the proper response code, which can then be
+            // converted to a proper response to the user.
+            Realm.Transaction.OnSuccess onSuccess = new Realm.Transaction.OnSuccess() {
+                @Override
+                public void onSuccess() {
+                    if (checkAndReportInvalidState()) { return; }
+
+                    // Find PermissionOffer object we just added
+                    // Wait for it to be processed
+                    managedResponse = managementRealm.where(PermissionOfferResponse.class).equalTo("id", responseId).findFirstAsync();
+                    RealmObject.addChangeListener(managedResponse, new RealmChangeListener<PermissionOfferResponse>() {
+                        @Override
+                        public void onChange(final PermissionOfferResponse response) {
+                            if (checkAndReportInvalidState()) {
+                                RealmObject.removeChangeListener(managedResponse, this);
+                                return;
+                            }
+                            handleServerStatusChanges(response, new Runnable() {
+                                @Override
+                                public void run() {
+                                    grantedPermissionResults = permissionRealm.where(Permission.class).equalTo("path", response.getPath()).findAllAsync();
+                                    grantedPermissionResults.addChangeListener(new RealmChangeListener<RealmResults<Permission>>() {
+                                        @Override
+                                        public void onChange(RealmResults<Permission> permissions) {
+                                            if (!permissions.isEmpty()) {
+                                                grantedPermissionResults.removeChangeListener(this);
+                                                notifyCallbackWithSuccess(managedResponse.getRealmUrl(), permissions.first());
+                                            }
+                                        }
+                                    });
+                                }
+                            });
+                        }
+                    });
+                }
+            };
+
+            // Critical error: The PermissionChange could not be written to the Realm.
+            // Report it back to the user.
+            Realm.Transaction.OnError onError = new Realm.Transaction.OnError() {
+                @Override
+                public void onError(Throwable error) {
+                    if (checkAndReportInvalidState()) { return; }
+                    notifyCallbackWithError(new ObjectServerError(ErrorCode.UNKNOWN, error));
+                }
+            };
+
+            // Run
+            transactionTask = managementRealm.executeTransactionAsync(transaction, onSuccess, onError);
+        }
+
+        void notifyCallbackWithSuccess(String url, Permission permission) {
+            try {
+                callback.onSuccess(url, permission);
+            } finally {
+                activeTasks.remove(this);
+            }
+        }
+
+        @Override
+        public void cancel() {
+            super.cancel();
+            if (transactionTask != null) {
+                transactionTask.cancel();
+                transactionTask = null;
+            }
+        }
+    }
+
+    // Class encapsulating all async tasks exposed by the PermissionManager.
+    // Made package protected instead of private to facilitate testing
+    // IMPORTANT:
+    // - All subclasses are responsible for removing themselves from the activeTaskList when done.
+    // - All callbacks should start by checking `if (checkAndReportInvalidState()) { return; }`
+    //   This will abort the task if it was canceled or failed. It will also remove the task from the activeTaskList.
+    abstract static class PermissionManagerTask<T> implements RealmAsyncTask, Runnable {
+
+        private final PermissionManagerBaseCallback callback;
+        private final PermissionManager permissionManager;
+        private volatile boolean canceled = false;
+        private static final String ERROR_MESSAGE_CLIENT_RESET = "The PermissionManager " +
+                "has been invalidated due to a server conflict. No further tasks can be scheduled. " +
+                "The app needs to be restarted to allow the PermissionManager to work again.";
+
+        public PermissionManagerTask(PermissionManager permissionManager, PermissionManagerBaseCallback callback) {
+            this.callback = callback;
+            this.permissionManager = permissionManager;
+        }
+
+        @Override
+        public abstract void run();
+
+        @Override
+        public void cancel() {
+            canceled = true;
+        }
+
+        @Override
+        public boolean isCancelled() {
+            return canceled;
+        }
+
+        /**
+         * Checks if we are in a state where we are not allowed to continue executing.
+         * If an invalid state is encountered, it will be reported to the error callback.
+         *
+         * This method will return {@code true} if an invalid state was encountered, {@code false}
+         * if it looks ok to continue.
+
+         * @return {@code true} if in a invalid state, {@code false} if in a valid one.
+         */
+        protected final boolean checkAndReportInvalidState() {
+            if (isCancelled()) {
+                permissionManager.activeTasks.remove(this);
+                return true;
+            }
+            // Closed check need to work around thread confinement
+            if (permissionManager.closed) {
+                ObjectServerError error = new ObjectServerError(ErrorCode.UNKNOWN,
+                        new IllegalStateException("PermissionManager has been closed"));
+                notifyCallbackWithError(error); // This will remove the task from the task list
+                return true;
+            }
+            if (permissionManager.clientReset) {
+                ObjectServerError error = new ObjectServerError(ErrorCode.CLIENT_RESET, ERROR_MESSAGE_CLIENT_RESET);
+                notifyCallbackWithError(error);
+                return true;
+            }
+
+            // We are juggling two different Realms. If only one fail, expose that error directly.
+            // Otherwise try to sensible join the two error messages before returning it to the user.
+            // TODO: Should we expose the underlying Realm errors directly? What else would make sense?
+            boolean managementErrorHappened;
+            boolean permissionErrorHappened;
+            boolean defaultPermissionErrorHappened;
+            ObjectServerError managementError;
+            ObjectServerError permissionError;
+            ObjectServerError defaultPermissionError;
+            synchronized (permissionManager.errorLock) {
+                // Only hold lock while making a safe copy of current error state
+                managementErrorHappened = (permissionManager.managementRealmError != null);
+                permissionErrorHappened = (permissionManager.permissionRealmError != null);
+                defaultPermissionErrorHappened = (permissionManager.defaultPermissionRealmError != null);
+                managementError = permissionManager.managementRealmError;
+                permissionError = permissionManager.permissionRealmError;
+                defaultPermissionError = permissionManager.defaultPermissionRealmError;
+            }
+
+            // Everything seems valid
+            if (!permissionErrorHappened && !managementErrorHappened && !defaultPermissionErrorHappened) {
+                return false;
+            }
+
+            // Handle Client Reset if it happened in any of the Realms.
+            // A Client Reset is a fatal error for the PermissionManager, so all current and
+            // future tasks will exit as soon as possible after this event happened and report it
+            // through the error callback. Only action a user can take is to close the
+            // PermissionManager and re-open it again. Some data might be lost (like permission
+            // offers not yet processed). This is currently unavoidable.
+            // TODO: Eventually we might be able to recover the permission manager from this event
+            // but it will require some serious task management as we would need to do a full
+            // close, reschedule all tasks, and re-open behind users back. This is out of scope for
+            // now.
+            if (managementErrorHappened && managementError instanceof ClientResetRequiredError) {
+                ClientResetRequiredError cr = (ClientResetRequiredError) managementError;
+                permissionManager.managementRealm.close();
+                cr.executeClientReset();
+                permissionManager.clientReset = true;
+            }
+
+            if (permissionErrorHappened && permissionError instanceof ClientResetRequiredError) {
+                ClientResetRequiredError cr = (ClientResetRequiredError) permissionError;
+                permissionManager.permissionRealm.close();
+                cr.executeClientReset();
+                permissionManager.clientReset = true;
+            }
+
+            if (defaultPermissionErrorHappened && defaultPermissionError instanceof ClientResetRequiredError) {
+                ClientResetRequiredError cr = (ClientResetRequiredError) defaultPermissionError;
+                permissionManager.defaultPermissionRealm.close();
+                cr.executeClientReset();
+                permissionManager.clientReset = true;
+            }
+
+            // Handle errors
+            Map<String, ObjectServerError> errors = new LinkedHashMap<>();
+            if (permissionManager.clientReset) {
+                errors.put("ClientReset", new ObjectServerError(ErrorCode.CLIENT_RESET, ERROR_MESSAGE_CLIENT_RESET));
+            } else {
+                if (managementErrorHappened) { errors.put("Management Realm", managementError); }
+                if (permissionErrorHappened) { errors.put("Permission Realm", permissionError); }
+                if (defaultPermissionErrorHappened) { errors.put("Default Permission Realm", defaultPermissionError); }
+            }
+            notifyCallbackWithError(combineRealmErrors(errors)); // This will remove the task from the task list
+
+            return true;
+        }
+
+        /**
+         * Handle the status change from ROS and either call error or success callbacks.
+         */
+        protected void handleServerStatusChanges(BasePermissionApi obj, Runnable onSuccessDelegate) {
+            Integer statusCode = obj.getStatusCode();
+            if (statusCode != null) {
+                RealmObject.removeAllChangeListeners(obj);
+                if (statusCode > 0) {
+                    ErrorCode errorCode = ErrorCode.fromInt(statusCode);
+                    String errorMsg = obj.getStatusMessage();
+                    ObjectServerError error = new ObjectServerError(errorCode, errorMsg);
+                    notifyCallbackWithError(error);
+                } else if (statusCode == 0) {
+                    onSuccessDelegate.run();
+                } else {
+                    ErrorCode errorCode = ErrorCode.UNKNOWN;
+                    String errorMsg = "Illegal status code: " + statusCode;
+                    ObjectServerError error = new ObjectServerError(errorCode, errorMsg);
+                    notifyCallbackWithError(error);
+                }
+            }
+        }
+
+        protected final void notifyCallbackWithError(ObjectServerError e) {
+            RealmLog.debug("Error happened in PermissionManager for %s: %s",
+                    permissionManager.user.getIdentity(), e.toString());
+            try {
+                callback.onError(e);
+            } finally {
+                permissionManager.activeTasks.remove(this);
+            }
+        }
+
+        // Combine error messages. If they have the same ErrorCode, it will be re-used, otherwise
+        // we are forced to report back UNKNOWN as error code. The real error codes
+        // will be always part of the exception message.
+        private ObjectServerError combineRealmErrors(Map<String, ObjectServerError> errors) {
+
+            String errorMsg = combineErrorMessage(errors);
+            ErrorCode errorCode = combineErrorCodes(errors);
+
+            return new ObjectServerError(errorCode, errorMsg);
+        }
+
+        // Combine the text based error message from two ObjectServerErrrors.
+        private String combineErrorMessage(Map<String, ObjectServerError> errors) {
+            boolean multipleErrors = errors.size() > 1;
+            StringBuilder errorMsg = new StringBuilder(multipleErrors ? "Multiple errors occurred: " : "Error occurred in Realm: ");
+            for (Map.Entry<String, ObjectServerError> entry : errors.entrySet()) {
+                errorMsg.append('\n');
+                errorMsg.append(entry.getKey());
+                errorMsg.append('\n');
+                errorMsg.append(entry.getValue().toString());
+            }
+            return errorMsg.toString();
+        }
+
+        private ErrorCode combineErrorCodes(Map<String, ObjectServerError> errors) {
+            ErrorCode finalErrorCode = null;
+            for (ObjectServerError error : errors.values()) {
+                ErrorCode errorCode = error.getErrorCode();
+                if (finalErrorCode == null) {
+                    finalErrorCode = errorCode;
+                    continue;
+                }
+                if (errorCode == finalErrorCode) {
+                    continue;
+                }
+
+                // Multiple error codes. No good way to report this.
+                // The real error codes will still be in the error text.
+                finalErrorCode = ErrorCode.UNKNOWN;
+                break;
+            }
+            return finalErrorCode;
+        }
+
+    }
+
+    // Task responsible for loading the Permissions result and returning it to the user.
+    // The Permission result is not considered available until the query has completed.
+    private class GetOffersAsyncTask extends PermissionManagerTask<RealmResults<Permission>> {
+
+        private final OffersCallback callback;
+        // Prevent permissions from being GC'ed until fully loaded.
+        private RealmResults<PermissionOffer> loadingOffers;
+
+        GetOffersAsyncTask(PermissionManager permissionManager, OffersCallback callback) {
+            super(permissionManager, callback);
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            if (checkAndReportInvalidState()) { return; }
+            if (offers != null) {
+                notifyCallbackWithSuccess(offers);
+            } else {
+                // We only want offers that have been created.
+                loadingOffers = managementRealm.where(PermissionOffer.class)
+                        .equalTo("statusCode", 0)
+                        .findAllAsync();
+                loadingOffers.addChangeListener(new RealmChangeListener<RealmResults<PermissionOffer>>() {
+                    @Override
+                    public void onChange(RealmResults<PermissionOffer> loadedOffers) {
+                        loadedOffers.removeChangeListener(this);
+                        if (checkAndReportInvalidState()) { return; }
+                        if (offers == null) {
+                            offers = loadedOffers;
+                        }
+                        notifyCallbackWithSuccess(offers);
+                    }
+                });
+            }
+        }
+
+        void notifyCallbackWithSuccess(RealmResults<PermissionOffer> permissions) {
+            try {
+                callback.onSuccess(permissions);
+            } finally {
+                activeTasks.remove(this);
+            }
+        }
+    }
+
+    private class RevokeOfferAsyncTask extends PermissionManagerTask<Permission> {
+
+        private final String offerToken;
+        private final RevokeOfferCallback callback;
+        private RealmResults<PermissionOffer> matchingOffers;
+
+        public RevokeOfferAsyncTask(PermissionManager permissionManager, String offerToken, RevokeOfferCallback callback) {
+            super(permissionManager, callback);
+            this.offerToken = offerToken;
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            if (checkAndReportInvalidState()) {
+                return;
+            }
+            matchingOffers = managementRealm.where(PermissionOffer.class)
+                    .equalTo("token", offerToken)
+                    .findAllAsync();
+            matchingOffers.addChangeListener(new RealmChangeListener<RealmResults<PermissionOffer>>() {
+                @Override
+                public void onChange(final RealmResults<PermissionOffer> offers) {
+                    if (checkAndReportInvalidState()) { return; }
+                    if (!offers.isEmpty()) {
+                        managementRealm.executeTransactionAsync(new Realm.Transaction() {
+                            @Override
+                            public void execute(Realm realm) {
+                                if (checkAndReportInvalidState()) { return; }
+                                // Make 100% sure the offer is still in the Realm.
+                                // It could have been deleted between querying for it and the
+                                // transaction running. We will still call OnSuccess if the
+                                // offer was removed by someone else.
+                                RealmResults<PermissionOffer> offers = realm.where(PermissionOffer.class)
+                                        .equalTo("token", offerToken)
+                                        .findAll();
+                                if (!offers.isEmpty()) {
+                                    offers.deleteAllFromRealm();
+                                }
+                            }
+                        }, new Realm.Transaction.OnSuccess() {
+                            @Override
+                            public void onSuccess() {
+                                // Don't notify user about success before changes have been uploaded to the server.
+                                matchingOffers.removeAllChangeListeners();
+                                if (checkAndReportInvalidState()) { return; }
+                                final SyncSession session = SyncManager.getSession(managementRealmConfig);
+                                session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+                                    @Override
+                                    public void onChange(Progress progress) {
+                                        if (progress.isTransferComplete()) {
+                                            session.removeProgressListener(this);
+                                            handler.post(new Runnable() {
+                                                @Override
+                                                public void run() {
+                                                    if (checkAndReportInvalidState()) { return; }
+                                                    notifyCallbackWithSuccess();
+                                                }
+                                            });
+                                        }
+                                    }
+                                });
+                            }
+                        }, new Realm.Transaction.OnError() {
+                            @Override
+                            public void onError(Throwable error) {
+                                matchingOffers.removeAllChangeListeners();
+                                notifyCallbackWithError(new ObjectServerError(ErrorCode.UNKNOWN, error));
+
+                            }
+                        });
+                    }
+                }
+            });
+        }
+
+        void notifyCallbackWithSuccess() {
+            try {
+                callback.onSuccess();
+            } finally {
+                activeTasks.remove(this);
+            }
+        }
+    }
+
+    private interface PermissionManagerBaseCallback {
+        /**
+         * Called if an error happened while executing the task. The PermissionManager uses different underlying Realms,
+         * and this error will report errors from all of these Realms combining them as best as possible.
+         * <p>
+         * This means that if all Realms fail with the same error code, {@link ObjectServerError#getErrorCode()} will
+         * return that error code. If the underlying Realms fail for different reasons, {@link ErrorCode#UNKNOWN} will
+         * be returned. {@link ObjectServerError#getErrorMessage()} will always contain the full description of errors
+         * including the specific error code for each underlying Realm that failed.
+         *
+         * @param error error object describing what happened.
+         */
+        void onError(ObjectServerError error);
+    }
+
+    /**
+     * Callback used when loading a set of permissions.
+     */
+    public interface PermissionsCallback extends PermissionManagerBaseCallback {
+        /**
+         * Called when all known permissions are successfully loaded.
+         * <p>
+         * These permissions will continue to synchronize with the server in the background. Register a
+         * {@link RealmChangeListener} to be notified about any further changes.
+         *
+         * @param permissions The set of currently known permissions.
+         */
+        void onSuccess(RealmResults<Permission> permissions);
+    }
+
+    /**
+     * Callback used when modifying or creating new permissions.
+     */
+    public interface ApplyPermissionsCallback extends PermissionManagerBaseCallback {
+        /**
+         * Called when the permissions where successfully modified.
+         */
+        void onSuccess();
+    }
+
+    /**
+     * Callback used when making a permission offer for other users.
+     */
+    public interface MakeOfferCallback extends PermissionManagerBaseCallback {
+        /**
+         * Called when the offer was successfully created.
+         *
+         * @param offerToken token representing the offer that can be sent to other users.
+         */
+        void onSuccess(String offerToken);
+    }
+
+    /**
+     * Callback used when accepting a permission offer.
+     */
+    public interface AcceptOfferCallback extends PermissionManagerBaseCallback {
+        /**
+         * Called when the offer was successfully accepted. This means that this user can now access this Realm.
+         *
+         * @param realmUrl The url pointing to the Realm for which the offer was created.
+         * @param permission The permissions granted.
+         */
+        void onSuccess(String realmUrl, Permission permission);
+    }
+
+    /**
+     * Callback used when loading the list of {@link PermissionOffer}'s created by the user.
+     */
+    public interface OffersCallback extends PermissionManagerBaseCallback {
+        /**
+         * Called when all known offers are successfully loaded.
+         * <p>
+         * These offers will continue to synchronize with the server in the background. Register a
+         * {@link RealmChangeListener} to be notified about any further changes.
+         *
+         * @param offers The set of currently known offers.
+         */
+        void onSuccess(RealmResults<PermissionOffer> offers);
+    }
+
+    /**
+     * Callback used when revoking an existing offer.
+     */
+    public interface RevokeOfferCallback extends PermissionManagerBaseCallback {
+        /**
+         * Called when the offer was successfully revoked successfully modified.
+         */
+        void onSuccess();
+    }
+
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index acafd13393..5839f59cfa 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -46,9 +46,9 @@
 import io.realm.internal.network.LogoutResponse;
 import io.realm.internal.network.LookupUserIdResponse;
 import io.realm.internal.objectserver.Token;
+import io.realm.internal.permissions.ManagementModule;
+import io.realm.internal.permissions.PermissionModule;
 import io.realm.log.RealmLog;
-import io.realm.permissions.PermissionModule;
-
 
 /**
  * This class represents a user on the Realm Object Server. The credentials are provided by various 3rd party
@@ -88,7 +88,7 @@ public void onError(SyncSession session, ObjectServerError error) {
                                 }
                             }
                         })
-                        .modules(new PermissionModule())
+                        .modules(new ManagementModule())
                         .build();
             }
 
@@ -129,7 +129,7 @@ public static SyncUser currentUser() {
     public static Map<String, SyncUser> all() {
         UserStore userStore = SyncManager.getUserStore();
         Collection<SyncUser> storedUsers = userStore.allUsers();
-        Map<String, SyncUser> map = new HashMap<String, SyncUser>();
+        Map<String, SyncUser> map = new HashMap<>();
         for (SyncUser user : storedUsers) {
             if (user.isValid()) {
                 map.put(user.getIdentity(), user);
@@ -658,7 +658,9 @@ void setRefreshToken(Token refreshToken) {
      * giving other users access to Realms.
      *
      * @see <a href="https://realm.io/docs/realm-object-server/#permissions">How to control permissions</a>
+     * @deprecated use {@link #getPermissionManager()} instead.
      */
+    @Deprecated
     public Realm getManagementRealm() {
         return Realm.getInstance(managementConfig.initAndGetManagementRealmConfig(this));
     }
@@ -713,6 +715,26 @@ private static String getManagementRealmUrl(URL authUrl) {
         }
     }
 
+    /**
+     * Returns an instance of the {@link PermissionManager} for this user that makes it possible to see, modify and create
+     * permissions related to this users Realms.
+     * <p>
+     * Every instance returned by this method must be closed by calling {@link PermissionManager#close()} when it
+     * no longer is needed.
+     * <p>
+     * The {@link PermissionManager} can only be opened from the main tread, calling this method from any other thread
+     * will throw an {@link IllegalStateException}.
+     *
+     * @throws IllegalStateException if this method is not called from the UI thread.
+     * @return an instance of the PermissionManager.
+     */
+    public PermissionManager getPermissionManager() {
+        if (!new AndroidCapabilities().isMainThread()) {
+            throw new IllegalStateException("The PermissionManager can only be opened from the main thread.");
+        }
+        return PermissionManager.getInstance(this);
+    }
+
     // what defines a user is it's identity(Token) and authURL (as required by the constructor)
     //
     // not the list of Realms it's managing, furthermore, trying to include the `realms` in the `hashCode` will
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/BasePermissionApi.java b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/BasePermissionApi.java
new file mode 100644
index 0000000000..ea7e6fc103
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/BasePermissionApi.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.permissions;
+
+import java.util.Date;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import io.realm.RealmModel;
+
+
+/**
+ * Common methods shared between most Realm model classes used in the Permission Realm API.
+ */
+public interface BasePermissionApi extends RealmModel {
+
+    /**
+     * Returns the unique id for this object.
+     *
+     * @return the unique id for this object.
+     */
+    String getId();
+
+    /**
+     * Returns the timestamp on the Client that created this object.
+     *
+     * @return {@link Date} this object was created. The timestamp will use the device clock it was created on.
+     */
+    @SuppressFBWarnings("EI_EXPOSE_REP")
+    Date getCreatedAt();
+
+    /**
+     * Returns the timestamp this object was last updated. The timstamp can be both a server timestamp and a device
+     * timestamp.
+     *
+     * @return {@link Date} this object was last modified.
+     */
+    @SuppressFBWarnings("EI_EXPOSE_REP")
+    Date getUpdatedAt();
+
+    /**
+     * Returns the status code for this change.
+     *
+     * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened. See {@link #getStatusMessage()}.
+     */
+    Integer getStatusCode();
+
+    /**
+     * Returns the servers status message, if an error occurred. Otherwise it will return {@code null}.
+     *
+     * @return The servers status message in case of an error, {@code null} otherwise.
+     */
+    String getStatusMessage();
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionModule.java b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/ManagementModule.java
similarity index 80%
rename from realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionModule.java
rename to realm/realm-library/src/objectServer/java/io/realm/internal/permissions/ManagementModule.java
index 319cd2a83a..8ba6882d11 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionModule.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/ManagementModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2016 Realm Inc.
+ * Copyright 2017 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,10 +14,15 @@
  * limitations under the License.
  */
 
-package io.realm.permissions;
+package io.realm.internal.permissions;
 
 import io.realm.annotations.RealmModule;
+import io.realm.permissions.PermissionOffer;
 
+
+/**
+ * FIXME Javadoc
+ */
 @RealmModule(library = true, classes = { PermissionChange.class, PermissionOffer.class, PermissionOfferResponse.class })
-public class PermissionModule {
+public class ManagementModule {
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionChange.java b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionChange.java
similarity index 65%
rename from realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionChange.java
rename to realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionChange.java
index 248cc05cf3..df839523d4 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionChange.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionChange.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.realm.permissions;
+package io.realm.internal.permissions;
 
 import java.util.Date;
 import java.util.UUID;
@@ -23,14 +23,20 @@
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import io.realm.RealmObject;
 import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmClass;
 import io.realm.annotations.Required;
+import io.realm.permissions.AccessLevel;
+import io.realm.permissions.UserCondition;
+import io.realm.permissions.PermissionRequest;
+
 
 /**
  * This class is used for requesting changes to a Realm's permissions.
  *
  * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Controlling Permissions</a>
  */
-public class PermissionChange extends RealmObject {
+@RealmClass
+public class PermissionChange implements BasePermissionApi {
 
     // Base fields
     @PrimaryKey
@@ -47,10 +53,42 @@
     private String realmUrl;
     @Required
     private String userId;
+
+    private String metadataKey;
+    private String metadataValue;
+    private String metadataNameSpace;
     private Boolean mayRead = false;
     private Boolean mayWrite = false;
     private Boolean mayManage = false;
 
+    /**
+     * Maps between a PermissionRequest and a PermissionChange object.
+     *
+     * @param request request to map to a PermissionChange.
+     */
+    public static PermissionChange fromRequest(PermissionRequest request) {
+        // PRE-CONDITION: All input are verified to be valid from the perspective of the Client.
+        UserCondition condition = request.getCondition();
+        AccessLevel level = request.getAccessLevel();
+        String realmUrl = request.getUrl();
+
+        String userId = "";
+        String metadataKey = null;
+        String metadataValue = null;
+        switch (condition.getType()) {
+            case USER_ID:
+                userId = condition.getValue();
+                break;
+            case METADATA:
+                metadataKey = condition.getKey();
+                metadataValue = condition.getValue();
+                break;
+        }
+
+        return new PermissionChange(realmUrl, userId, metadataKey, metadataValue, level.mayRead(), level.mayWrite(),
+                level.mayManage());
+    }
+
     public PermissionChange() {
         // Default constructor required by Realm
     }
@@ -78,15 +116,29 @@ public PermissionChange(String realmUrl, String userId,
         this.mayManage = mayManage;
     }
 
+    public PermissionChange(String realmUrl, String userId, String metadataKey, String metadataValue, Boolean mayRead,
+            Boolean mayWrite, Boolean mayManage) {
+        this.realmUrl = realmUrl;
+        this.userId = userId;
+        this.metadataKey = metadataKey;
+        this.metadataValue = metadataValue;
+        this.mayRead = mayRead;
+        this.mayWrite = mayWrite;
+        this.mayManage = mayManage;
+    }
+
+    @Override
     public String getId() {
         return id;
     }
 
+    @Override
     @SuppressFBWarnings("EI_EXPOSE_REP")
     public Date getCreatedAt() {
         return createdAt;
     }
 
+    @Override
     @SuppressFBWarnings("EI_EXPOSE_REP")
     public Date getUpdatedAt() {
         return updatedAt;
@@ -97,11 +149,13 @@ public Date getUpdatedAt() {
      *
      * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened. See {@link #getStatusMessage()}.
      */
+    @Override
     @Nullable
     public Integer getStatusCode() {
         return statusCode;
     }
 
+    @Override
     @Nullable
     public String getStatusMessage() {
         return statusMessage;
@@ -129,4 +183,12 @@ public Boolean mayWrite() {
     public Boolean mayManage() {
         return mayManage;
     }
+
+    public String getMetadataKey() {
+        return metadataKey;
+    }
+
+    public String getMetadataValue() {
+        return metadataValue;
+    }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionModule.java b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionModule.java
new file mode 100644
index 0000000000..9ba21bba00
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionModule.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.permissions;
+
+import io.realm.annotations.RealmModule;
+import io.realm.permissions.Permission;
+
+@RealmModule(library = true, classes = { Permission.class })
+public class PermissionModule {
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOfferResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionOfferResponse.java
similarity index 87%
rename from realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOfferResponse.java
rename to realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionOfferResponse.java
index 8c3704b0de..812c67d7e8 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOfferResponse.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionOfferResponse.java
@@ -13,17 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.realm.permissions;
+package io.realm.internal.permissions;
 
+import java.net.URI;
+import java.net.URISyntaxException;
 import java.util.Date;
 import java.util.UUID;
 
 import javax.annotation.Nullable;
 
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-import io.realm.RealmObject;
 import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmClass;
 import io.realm.annotations.Required;
+import io.realm.permissions.PermissionOffer;
+
 
 /**
  * This model is used to apply permission changes defined in the permission offer
@@ -35,7 +39,8 @@
  * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Permissions description</a> for general
  * documentation.
  */
-public class PermissionOfferResponse extends RealmObject {
+@RealmClass
+public class PermissionOfferResponse implements BasePermissionApi {
 
     // Base fields
     @PrimaryKey
@@ -77,15 +82,18 @@ public void setToken(String token) {
         this.token = token;
     }
 
+    @Override
     public String getId() {
         return id;
     }
 
+    @Override
     @SuppressFBWarnings("EI_EXPOSE_REP")
     public Date getCreatedAt() {
         return createdAt;
     }
 
+    @Override
     @SuppressFBWarnings("EI_EXPOSE_REP")
     public Date getUpdatedAt() {
         return updatedAt;
@@ -96,6 +104,7 @@ public Date getUpdatedAt() {
      *
      * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened. See {@link #getStatusMessage()}.
      */
+    @Override
     @Nullable
     public Integer getStatusCode() {
         return statusCode;
@@ -111,6 +120,7 @@ public boolean isSuccessful() {
         return statusCode != null && statusCode == 0;
     }
 
+    @Override
     @Nullable
     public String getStatusMessage() {
         return statusMessage;
@@ -124,4 +134,12 @@ public String getToken() {
     public String getRealmUrl() {
         return realmUrl;
     }
+
+    public String getPath() {
+        try {
+            return new URI(realmUrl).getPath();
+        } catch (URISyntaxException e) {
+            throw new RuntimeException(e);
+        }
+    }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/AccessLevel.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/AccessLevel.java
new file mode 100644
index 0000000000..79afe55b95
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/AccessLevel.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.permissions;
+
+import io.realm.PermissionManager;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+
+
+/**
+ * Access levels which can be granted to Realm Mobile Platform users for specific synchronized Realms, using a
+ * {@link PermissionRequest}.
+ * <p>
+ * Note that each access level guarantees all allowed actions provided by less permissive access levels.
+ * Specifically, users with write access to a Realm can always read from that Realm, and users with administrative
+ * access can always read or write from the Realm. This means that {@code NONE < READ < WRITE < ADMIN}.
+ *
+ * @see PermissionRequest
+ * @see io.realm.PermissionManager#applyPermissions(PermissionRequest, PermissionManager.ApplyPermissionsCallback)
+ */
+public enum AccessLevel {
+
+    /**
+     * The user does not have access to this Realm.
+     */
+    NONE(false, false, false),
+
+    /**
+     * User can only read the contents of the Realm.
+     * <p>
+     * Users who have read-only access to a Realm should open it using `readOnly()` and
+     * `waitForInitialRemoteData()` on the {@link io.realm.SyncConfiguration}. Attempting to directly open the Realm
+     * is an error; in this case the Realm must manually be deleted using {@link Realm#deleteRealm(RealmConfiguration)}
+     * before being re-opened with the correct configuration.
+     * <p>
+     * <pre>
+     * {@code
+     * SyncConfiguration config = new SyncConfiguration(getUser(), getUrl())
+     *     .readOnly()
+     *     .waitForInitialRemoteData()
+     *     .build();
+     * }
+     * </pre>
+     */
+    READ(true, false, false),
+
+    /**
+     * User can read and write the contents of the Realm.
+     */
+    WRITE(true, true, false),
+
+    /**
+     * User can read, write, and administer the Realm. This includes both granting permissions as well as removing them
+     * again.
+     */
+    ADMIN(true, true, true);
+
+    private final boolean mayRead;
+    private final boolean mayWrite;
+    private final boolean mayManage;
+
+    AccessLevel(boolean mayRead, boolean mayWrite, boolean mayManage) {
+        this.mayRead = mayRead;
+        this.mayWrite = mayWrite;
+        this.mayManage = mayManage;
+    }
+
+    /**
+     * Returns {@code true} if the user is allowed to read a Realm, {@code false} if not.
+     */
+    public boolean mayRead() {
+        return mayRead;
+    }
+
+    /**
+     * Returns {@code true} if the user is allowed to write to the Realm, {@code false} if not.
+     */
+    public boolean mayWrite() {
+        return mayWrite;
+    }
+
+    /**
+     * Returns {@code true} if the user is allowed to manage the Realm, {@code false} if not.
+     * <p>
+     * Having this permission, means the user is able to grant permissions to other users as well as remove them
+     * again.
+     */
+    public boolean mayManage() {
+        return mayManage;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/Permission.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/Permission.java
new file mode 100644
index 0000000000..2e975c7ff5
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/Permission.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.permissions;
+
+import java.util.Date;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import io.realm.PermissionManager;
+import io.realm.RealmObject;
+import io.realm.SyncUser;
+import io.realm.annotations.Required;
+
+
+/**
+ * This class represents a given set of permissions for one user on one Realm.
+ * <p>
+ * Permissions can be changed by users with administrative rights using the {@link PermissionManager}.
+ *
+ * @see SyncUser#getPermissionManager()
+ */
+public class Permission extends RealmObject {
+
+    @Required
+    private String userId;
+    @Required
+    private String path;
+    private boolean mayRead;
+    private boolean mayWrite;
+    private boolean mayManage;
+    @Required
+    private Date updatedAt;
+
+    /**
+     * Required by Realm. Do not use.
+     */
+    public Permission() {
+        // Required by Realm
+    }
+
+    /**
+     * Returns the {@link SyncUser#getIdentity()} of the user effected by this permission.
+     * <p>
+     *
+     * @return the user effected by this permission.
+     */
+    public String getUserId() {
+        return userId;
+    }
+
+    /**
+     * Returns the path to the Realm on the server effected by this permission. This is not the full URL.
+     *
+     * @return the path to the Realm this permission object refers to.
+     */
+    public String getPath() {
+        return path;
+    }
+
+    /**
+     * Checks whether or not the user defined by this permission is allowed to read the Realm defined by
+     * {@link #getPath()}.
+     *
+     * @return {@code true} if this permission grant read permissions to the Realm, {@code false} if not.
+     */
+    public boolean mayRead() {
+        return mayRead;
+    }
+
+    /**
+     * Checks whether or not the user defined by this permission is allowed to write to the Realm defined by
+     * {@link #getPath()}.
+     *
+     * @return {@code true} if this permission grant write permissions to the Realm, {@code false} if not.
+     */
+    public boolean mayWrite() {
+        return mayWrite;
+    }
+
+    /**
+     * Checks whether or not the user defined by this permission is allowed to manage access to the Realm defined
+     * by {@link #getPath()}. Having this permission enable those users to add or remove permissions from
+     * other users, including the one who granted it.
+     *
+     * @return {@code true} if this permission grant administrative rights to the Realm, {@code false} if not.
+     */
+    public boolean mayManage() {
+        return mayManage;
+    }
+
+    /**
+     * Returns the timestamp for when this permission object was last updated.
+     *
+     * @return the timestamp for when this permission was last updated.
+     */
+    @SuppressFBWarnings({"EI_EXPOSE_REP"})
+    public Date getUpdatedAt() {
+        return updatedAt;
+    }
+
+    @Override
+    public String toString() {
+        return "Permission{" +
+                "userId='" + userId + '\'' +
+                ", path='" + path + '\'' +
+                ", mayRead=" + mayRead +
+                ", mayWrite=" + mayWrite +
+                ", mayManage=" + mayManage +
+                ", updatedAt=" + updatedAt +
+                '}';
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOffer.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOffer.java
index 6c726aec0d..a42e5b9e77 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOffer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOffer.java
@@ -15,25 +15,39 @@
  */
 package io.realm.permissions;
 
+import java.net.URI;
+import java.net.URISyntaxException;
 import java.util.Date;
 import java.util.UUID;
 
 import javax.annotation.Nullable;
 
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-import io.realm.RealmObject;
+import io.realm.PermissionManager;
 import io.realm.annotations.Index;
 import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmClass;
 import io.realm.annotations.Required;
+import io.realm.internal.Util;
+import io.realm.internal.permissions.BasePermissionApi;
+
 
 /**
- * This model is used for offering permission changes to other users.
- * It should be used in conjunction with an {@link io.realm.SyncUser}'s management Realm.
+ * This class represents a permission offer for a Realm that can be given to other users.
+ * When an offer is successfully created, it will be represented by an {@code offerToken} that can be sent
+ * to other users. Once they accept this token, the permissions covered by this offer will take effect for that
+ * user.
+ * <p>
+ * Permission offers can only be created by users that can manage the Realm, the offer is about.
  *
+ * @see PermissionManager#makeOffer(PermissionOffer, PermissionManager.MakeOfferCallback)
+ * @see PermissionManager#acceptOffer(String, PermissionManager.AcceptOfferCallback)
  * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Permissions description</a> for general
  * documentation.
  */
-public class PermissionOffer extends RealmObject {
+
+@RealmClass
+public class PermissionOffer implements BasePermissionApi {
 
     // Base fields
     @PrimaryKey
@@ -56,95 +70,206 @@
     private boolean mayManage;
     private Date expiresAt;
 
+    /**
+     * Constructor required by Realm. Should not be used.
+     */
     public PermissionOffer() {
         // No args constructor required by Realm
     }
 
     /**
-     * Construct a permission offer object used to offer permission changes to other users.
+     * Creates a request for an permission offer that last until it is manually revoked.
      *
-     * @param url The URL to the Realm on which to apply these permission changes to, once the offer is accepted.
-     * @param mayRead Grant or revoke read access.
-     * @param mayWrite Grant or revoked read-write access.
-     * @param mayManage Grant or revoke administrative access.
-     * @param expiresAt When this token will expire and become invalid. Pass {@code null} if this offer should not expire.
+     * @param url specific url to Realm effected this offer encompasses all Realms manged by the user making the offer.
+     * @param accessLevel the {@link AccessLevel} granted to the user accepting the offer.
+     *
+     * @see PermissionManager#revokeOffer(String, PermissionManager.RevokeOfferCallback)
      */
     @SuppressFBWarnings("EI_EXPOSE_REP2")
-    public PermissionOffer(String url, boolean mayRead, boolean mayWrite, boolean mayManage, @Nullable Date expiresAt) {
+    public PermissionOffer(String url, AccessLevel accessLevel) {
         //noinspection ConstantConditions
-        if (url == null) {
-            throw new IllegalArgumentException("Non-null 'url' required.");
-        }
+        this(url, accessLevel, null);
+    }
+
+    /**
+     * Creates a request for a permission offer that last until it is manually revoked.
+     *
+     * @param url specific url to Realm effected. The user sending the offer must have manage rights to this Realm.
+     * @param accessLevel the {@link AccessLevel} granted to the user accepting the offer.
+     * @param expiresAt the date and time when this offer expires. If {@code null} is provided the offer never expires.
+     *
+     *
+     * @see PermissionManager#revokeOffer(String, PermissionManager.RevokeOfferCallback)
+     */
+    @SuppressFBWarnings("EI_EXPOSE_REP2")
+    public PermissionOffer(String url, AccessLevel accessLevel, @Nullable Date expiresAt) {
+        validateUrl(url);
+        validateAccessLevel(accessLevel);
+        this.mayRead = accessLevel.mayRead();
+        this.mayWrite = accessLevel.mayWrite();
+        this.mayManage = accessLevel.mayManage();
         this.realmUrl = url;
-        this.mayRead = mayRead;
-        this.mayWrite= mayWrite;
-        this.mayManage = mayManage;
-        this.expiresAt = expiresAt;
+        //noinspection ConstantConditions
+        this.expiresAt = (expiresAt != null) ? (Date) expiresAt.clone() : null;
     }
 
+    private void validateUrl(String url) {
+        if (Util.isEmptyString(url)) {
+            throw new IllegalArgumentException("Non-empty 'realmUrl' required.");
+        }
+
+        try {
+            // Validate basic syntax.
+            new URI(url);
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException("Invalid 'realmUrl'.", e);
+        }
+    }
+
+    private void validateAccessLevel(AccessLevel accessLevel) {
+        if (accessLevel == null) {
+            throw new IllegalArgumentException("Non-null 'accessLevel' required.");
+        }
+    }
+
+    /**
+     * Returns the id uniquely identifying this offer.
+     *
+     * @return the id uniquely identifying this offer.
+     */
+    @Override
     public String getId() {
         return id;
     }
 
+    /**
+     * Returns the timestamp when this offer was created.
+     *
+     * @return the timstamp when this offer was created.
+     */
+    @Override
     @SuppressFBWarnings("EI_EXPOSE_REP")
     public Date getCreatedAt() {
         return createdAt;
     }
 
+    /**
+     * Returns the timestamp this offer was last updated.
+     *
+     * @return the timestamp when this offer was last updated.
+     */
+    @Override
     @SuppressFBWarnings("EI_EXPOSE_REP")
     public Date getUpdatedAt() {
         return updatedAt;
     }
 
+
     /**
-     * Returns the status code for this change.
+     * Returns the server status code for this change.
      *
-     * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened. See {@link #getStatusMessage()}.
+     * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened.
+     * See {@link #getStatusMessage()}.
      */
+    @Override
     @Nullable
     public Integer getStatusCode() {
         return statusCode;
     }
 
     /**
-     * Check if the request was successfully handled by the Realm Object Server.
+     * Returns the servers status message, if an error occurred. Otherwise it will return {@code null}.
      *
-     * @return {@code true} if request was handled successfully. {@code false} if not. See {@link #getStatusMessage()}
-     *         for the full error message.
+     * @return The servers status message in case of an error, {@code null} otherwise.
      */
-    public boolean isSuccessful() {
-        return statusCode != null && statusCode == 0;
-    }
-
+    @Override
     @Nullable
     public String getStatusMessage() {
         return statusMessage;
     }
 
+    /**
+     * Checks if the request was successfully handled by the Realm Object Server.
+     *
+     * @return {@code true} if the request was handled successfully. {@code false} if not. See {@link #getStatusMessage()}
+     *         for the full error message.
+     */
+    public boolean isOfferCreated() {
+        return !Util.isEmptyString(token);
+    }
+
+    /**
+     * Returns the offer token if this offer was successfully created.
+     *
+     * @return the offer token or {@code null} if the offer wasn't created yet.
+     */
     @Nullable
     public String getToken() {
         return token;
     }
 
+    /**
+     * Returns the Realm URL for which the permissions are granted.
+     *
+     * @return the Realm URL for which the permissions should be granted.
+     */
     public String getRealmUrl() {
         return realmUrl;
     }
 
-    public boolean isMayRead() {
+    /**
+     * Returns whether or not the user accepting this offer is granted read permission.
+     *
+     * @return {@code true} if the user accepting this offer is granted read permission, {@code false} if not.
+     */
+    public boolean mayRead() {
         return mayRead;
     }
 
-    public boolean isMayWrite() {
+    /**
+     * Returns whether or not the user accepting this offer is granted write permission.
+     *
+     * @return {@code true} if the user accepting this offer is granted write permission, {@code false} if not.
+     */
+    public boolean mayWrite() {
         return mayWrite;
     }
 
-    public boolean isMayManage() {
+    /**
+     * Returns whether or not the user accepting this offer is granted manage permission. This will allow this user
+     * to also grant or remove permission for other users on this Realm.
+     *
+     * @return {@code true} if the user accepting this offer is granted mange permission, {@code false} if not.
+     */
+    public boolean mayManage() {
         return mayManage;
     }
 
+    /**
+     * Returns when this offer expires. {@code null} is returned if this offer never expires.
+     *
+     * @return the date when this offer expires or {@code null} if it never expires.
+     */
     @SuppressFBWarnings("EI_EXPOSE_REP")
     @Nullable
     public Date getExpiresAt() {
         return expiresAt;
     }
+
+    @Override
+    public String toString() {
+        return "PermissionOffer{" +
+                "id='" + id + '\'' +
+                ", createdAt=" + createdAt +
+                ", updatedAt=" + updatedAt +
+                ", statusCode=" + statusCode +
+                ", statusMessage='" + statusMessage + '\'' +
+                ", token='" + token + '\'' +
+                ", realmUrl='" + realmUrl + '\'' +
+                ", mayRead=" + mayRead +
+                ", mayWrite=" + mayWrite +
+                ", mayManage=" + mayManage +
+                ", expiresAt=" + expiresAt +
+                '}';
+    }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionRequest.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionRequest.java
new file mode 100644
index 0000000000..59dca34d0a
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionRequest.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.permissions;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import io.realm.PermissionManager;
+import io.realm.internal.Util;
+
+
+/**
+ * This class represents the intent of giving a set of permissions to some users for some Realm(s).
+ * <p>
+ * If the request is successful, a {@link Permission} entry will be added to each affected users
+ * {@link PermissionManager}, where it can be fetched using
+ * {@link PermissionManager#getPermissions(PermissionManager.PermissionsCallback)}
+ *
+ * @see PermissionManager#applyPermissions(PermissionRequest, PermissionManager.ApplyPermissionsCallback)
+ * @see PermissionManager#getPermissions(PermissionManager.PermissionsCallback)
+ */
+public final class PermissionRequest {
+
+    private final AccessLevel accessLevel;
+    private final UserCondition condition;
+    private final String url;
+
+    /**
+     * Creates a description of a set of permissions granted to some users for some Realms.
+     *
+     * @param realmUrl the Realm URL whose permissions settings should be changed. Use {@code *} to change the
+     * permissions of all Realms managed by the user sending this request. The user that wants to grant these permissions
+     * must have administrative rights to those Realms.
+     *
+     * @param condition the conditions used to match which users are effected.
+     * @param accessLevel the {@link AccessLevel} to grant matching users. Setting the access level is absolute i.e., it
+     * may revoke permissions for users that previously had a higher access level. To revoke all permissions, use
+     * {@link AccessLevel#NONE}.
+     *
+     */
+    public PermissionRequest(UserCondition condition, String realmUrl, AccessLevel accessLevel) {
+        checkCondition(condition);
+        checkUrl(realmUrl);
+        checkAccessLevel(accessLevel);
+        this.condition = condition;
+        this.accessLevel = accessLevel;
+        this.url = realmUrl;
+    }
+
+    private void checkUrl(String url) {
+        if (Util.isEmptyString(url)) {
+            throw new IllegalArgumentException("Non-empty 'realmUrl' required.");
+        }
+
+        if (url.equals("*")) {
+            return; // Special case for selecting all URL's
+        }
+
+        try {
+            // Validate basic syntax.
+            new URI(url);
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException("Invalid 'realmUrl'.", e);
+        }
+    }
+
+    private void checkCondition(UserCondition condition) {
+        if (condition == null) {
+            throw new IllegalArgumentException("Non-null 'condition' required.");
+        }
+    }
+
+    private void checkAccessLevel(AccessLevel accessLevel) {
+        if (accessLevel == null) {
+            throw new IllegalArgumentException("Non-null 'accessLevel' required.");
+        }
+    }
+
+    /**
+     * Returns the access level that users will be granted if the request is successful.
+     *
+     * @return the {@link AccessLevel} users will have once this request is successfully handled.
+     */
+    public AccessLevel getAccessLevel() {
+        return accessLevel;
+    }
+
+    /**
+     * Returns the {@link UserCondition} used to match users. Those users that match will be granted the the
+     * {@link AccessLevel} defined by {@link #getAccessLevel()}.
+     *
+     * @return the condition used to match users.
+     */
+    public UserCondition getCondition() {
+        return condition;
+    }
+
+    /**
+     * The Realm URL for which the permissions are granted. {@code *} is returned if the request should match
+     * all Realms, for which the user sending the request, has administrative rights.
+     *
+     * @return the Realm URL for which the permissions should be granted.
+     * @see Permission#mayManage()
+     */
+    public String getUrl() {
+        return url;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) { return true; }
+        if (o == null || getClass() != o.getClass()) { return false; }
+
+        PermissionRequest that = (PermissionRequest) o;
+
+        if (accessLevel != that.accessLevel) { return false; }
+        if (!condition.equals(that.condition)) { return false; }
+        return url.equals(that.url);
+
+    }
+
+    @Override
+    public int hashCode() {
+        int result = accessLevel.hashCode();
+        result = 31 * result + condition.hashCode();
+        result = 31 * result + url.hashCode();
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "PermissionRequest{" +
+                "accessLevel=" + accessLevel +
+                ", condition=" + condition +
+                ", url='" + url + '\'' +
+                '}';
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/UserCondition.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/UserCondition.java
new file mode 100644
index 0000000000..57026e7ed4
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/UserCondition.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.permissions;
+
+import io.realm.PermissionManager;
+import io.realm.SyncUser;
+import io.realm.internal.Util;
+
+
+/**
+ * This class represents a condition for matching users on the Realm Object Server.
+ * It is used when a request for changing existing permissions is made.
+ *
+ * @see PermissionRequest
+ * @see io.realm.PermissionManager#applyPermissions(PermissionRequest, PermissionManager.ApplyPermissionsCallback)
+ */
+public final class UserCondition {
+
+    private final String key;
+    private final String value;
+    private final MatcherType type;
+
+    /**
+     * Creates a condition for matching, exactly, a users username. The comparison is case-sensitive and wildcards are
+     * not allowed.
+     *
+     * @param username exact username to match against.
+     */
+    public static UserCondition username(String username) {
+        if (Util.isEmptyString(username)) {
+            throw new IllegalArgumentException("Non-empty 'username' required.");
+        }
+        return new UserCondition(MatcherType.METADATA, "email", username);
+    }
+
+    /**
+     * Creates a condition for matching, exactly, a users id.
+     *
+     * @param userId user id to match against. No wildcards are allowed.
+     * @see SyncUser#getIdentity()
+     */
+    public static UserCondition userId(String userId) {
+        if (Util.isEmptyString(userId)) {
+            throw new IllegalArgumentException("Non-empty 'userId' required.");
+        }
+        return new UserCondition(MatcherType.USER_ID, "", userId);
+    }
+
+    /**
+     * Creates a condition that will match all users with no permissions for the Realm.
+     * <p>
+     * The {@link AccessLevel} defined alongside this condition, will also be used as the default access level
+     * for future new users that might be given access to the Realm.
+     *
+     * @see PermissionManager#makeOffer(PermissionOffer, PermissionManager.MakeOfferCallback)
+     */
+    public static UserCondition noExistingPermissions() {
+        return userId("*");
+    }
+
+    /**
+     * Creates a custom permission condition.
+     * This will apply the permissions based on a key/value combination in the user's metadata.
+     *
+     * @param key key to use.
+     * @param value value for that field to match.
+     */
+    public static UserCondition keyValue(String key, String value) {
+        if (Util.isEmptyString(key)) {
+            throw new IllegalArgumentException("Non-empty 'key' required.");
+        }
+        if (value == null) {
+            throw new IllegalArgumentException("Non-null 'value' required.");
+        }
+        return new UserCondition(MatcherType.METADATA, key, value);
+    }
+
+    private UserCondition(MatcherType type, String key, String value) {
+        this.type = type;
+        this.key = key;
+        this.value = value;
+    }
+
+    /**
+     * Returns the they in the users metadata that is used for evaluating this condition.
+     *
+     * @return the key in the users metadata.
+     */
+    public String getKey() {
+        return key;
+    }
+
+    /**
+     * Returns the value that is used when matching users. The semantics of the value will be different
+     * depending on the type of key used.
+     *
+     * @return the value to searchh for in the users meta data.
+     */
+    public String getValue() {
+        return value;
+    }
+
+    /**
+     * Returns the type of data this condition matches.
+     *
+     * @return the type of data this condition matches.
+     */
+    public MatcherType getType() {
+        return type;
+    }
+
+    /**
+     * Type of matcher this condition represents.
+     */
+    public enum MatcherType {
+        USER_ID,
+        METADATA
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) { return true; }
+        if (o == null || getClass() != o.getClass()) { return false; }
+
+        UserCondition that = (UserCondition) o;
+
+        if (!key.equals(that.key)) { return false; }
+        return value.equals(that.value);
+
+    }
+
+    @Override
+    public int hashCode() {
+        int result = key.hashCode();
+        result = 31 * result + value.hashCode();
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "UserCondition{" +
+                "key='" + key + '\'' +
+                ", value='" + value + '\'' +
+                '}';
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
index 8faa03f76b..b538fc953c 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
@@ -20,10 +20,6 @@
 import android.support.test.rule.UiThreadTestRule;
 import android.util.Log;
 
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
 import org.junit.Rule;
 import org.junit.rules.ExpectedException;
 
@@ -34,11 +30,17 @@
 import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.HttpUtils;
+import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.TestSyncConfigurationFactory;
 
 
-public class BaseIntegrationTest {
+/**
+ * Base class used by Integration Tests.
+ * This class should not be used directly. Instead {@link StandardIntegrationTest} or {@link IsolatedIntegrationTests }
+ * should be used instead.
+ */
+public abstract class BaseIntegrationTest {
 
     private static int originalLogLevel;
 
@@ -54,29 +56,8 @@
     @Rule
     public final ExpectedException thrown = ExpectedException.none();
 
-    @BeforeClass
-    public static void setupTestClass() throws Exception {
-        SyncManager.Debug.skipOnlineChecking = true;
-        try {
-            HttpUtils.startSyncServer();
-        } catch (Exception e) {
-            // Throwing an exception from this method will crash JUnit. Instead just log it.
-            // If this setup method fails, all unit tests in the class extending it will most likely fail as well.
-            Log.e(HttpUtils.TAG, "Could not start Sync Server: " + Util.getStackTrace(e));
-        }
-    }
-
-    @AfterClass
-    public static void tearDownTestClass() throws Exception {
-        try {
-            HttpUtils.stopSyncServer();
-        } catch (Exception e) {
-            Log.e(HttpUtils.TAG, "Failed to stop Sync Server" + Util.getStackTrace(e));
-        }
-    }
-
-    @Before
-    public void setupTest() throws IOException {
+    protected void prepareEnvironmentForTest() throws IOException {
+        // FIXME Trying to reset the device environment is crashing tests somehow
         deleteRosFiles();
         if (BaseRealm.applicationContext != null) {
             // Realm was already initialized. Reset all internal state
@@ -95,26 +76,37 @@ public void setupTest() throws IOException {
         RealmLog.setLevel(LogLevel.DEBUG);
     }
 
-    @After
-    public void teardownTest() {
-        if (looperThread.isTestComplete()) {
-            // Non-looper tests can reset here
-            resetTestEnvironment();
-        } else {
-            // Otherwise we need to wait for the test to complete
-            looperThread.runAfterTest(new Runnable() {
-                @Override
-                public void run() {
-                    resetTestEnvironment();
-                }
-            });
+    /**
+     * Starts a new ROS instance that can be used for testing.
+     */
+    protected static void startSyncServer() {
+        SyncManager.Debug.skipOnlineChecking = true;
+        try {
+            HttpUtils.startSyncServer();
+        } catch (Exception e) {
+            throw new IllegalStateException(e);
         }
     }
 
-    private void resetTestEnvironment() {
-        for (SyncUser syncUser : SyncUser.all().values()) {
-            syncUser.logout();
+    /**
+     * Stops the ROS instance used for the test.
+     */
+    protected static void stopSyncServer() {
+        try {
+            HttpUtils.stopSyncServer();
+        } catch (Exception e) {
+            Log.e(HttpUtils.TAG, "Failed to stop Sync Server" + Util.getStackTrace(e));
         }
+    }
+
+    /**
+     * Tries to restore the environment as best as possible after a test.
+     */
+    protected void restoreEnvironmentAfterTest() {
+        // Block until all users are logged out
+        UserFactory.logoutAllUsers();
+
+        // Reset log level
         RealmLog.setLevel(originalLogLevel);
     }
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java
new file mode 100644
index 0000000000..e25225fbbe
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java
@@ -0,0 +1,42 @@
+package io.realm;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+
+import java.io.IOException;
+
+
+/**
+ * Base class for integration tests where each test is run on a separate ROS instance.
+ * This adds quite a lot of overhead between each test, so only use this base class if absolutely needed.
+ * Otherwise use {@link IsolatedIntegrationTests}.
+ */
+public class IsolatedIntegrationTests extends BaseIntegrationTest {
+
+    @Before
+    public void setupTest() throws IOException {
+        startSyncServer();
+        prepareEnvironmentForTest();
+    }
+
+    @After
+    public void teardownTest() {
+        if (!looperThread.isRuleUsed() || looperThread.isTestComplete()) {
+            // Non-looper tests can reset here
+            restoreEnvironmentAfterTest();
+            stopSyncServer();
+        } else {
+            // Otherwise we need to wait for the test to complete
+            looperThread.runAfterTest(new Runnable() {
+                @Override
+                public void run() {
+                    restoreEnvironmentAfterTest();
+                    stopSyncServer();
+                }
+            });
+        }
+    }
+
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
new file mode 100644
index 0000000000..95c8c4a7c7
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
@@ -0,0 +1,1222 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.SystemClock;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.realm.internal.Util;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.UserFactory;
+import io.realm.permissions.AccessLevel;
+import io.realm.permissions.Permission;
+import io.realm.permissions.PermissionOffer;
+import io.realm.permissions.PermissionRequest;
+import io.realm.permissions.UserCondition;
+import io.realm.rule.RunTestInLooperThread;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@Ignore("Wait for https://github.com/realm/realm-object-server/issues/1671 to be fixed")
+@RunWith(AndroidJUnit4.class)
+public class PermissionManagerTests extends StandardIntegrationTest {
+
+    private SyncUser user;
+
+    @Before
+    public void setUpTest() {
+        user = UserFactory.createUniqueUser();
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getPermissions_returnLoadedResults() {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.getPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                assertTrue(permissions.isLoaded());
+                assertInitialPermissions(permissions);
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getPermissions_noLongerValidWhenPermissionManagerIsClosed() {
+        final PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.getPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                assertTrue(permissions.isValid());
+                pm.close();
+                assertFalse(permissions.isValid());
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getPermissions_updatedWithNewRealms() {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.getPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                assertTrue(permissions.isLoaded());
+                assertInitialPermissions(permissions);
+
+                // Create new Realm, which should create a new Permission entry
+                SyncConfiguration config2 = new SyncConfiguration.Builder(user, Constants.USER_REALM_2)
+                        .errorHandler(new SyncSession.ErrorHandler() {
+                            @Override
+                            public void onError(SyncSession session, ObjectServerError error) {
+                                fail(error.toString());
+                            }
+                        })
+                        .build();
+                final Realm secondRealm = Realm.getInstance(config2);
+                looperThread.closeAfterTest(secondRealm);
+                // Wait for the permission Result to report the new Realms
+                looperThread.keepStrongReference(permissions);
+                permissions.addChangeListener(new RealmChangeListener<RealmResults<Permission>>() {
+                    @Override
+                    public void onChange(RealmResults<Permission> permissions) {
+                        Permission p = permissions.where().endsWith("path", "tests2").findFirst();
+                        if (p != null) {
+                            assertTrue(p.mayRead());
+                            assertTrue(p.mayWrite());
+                            assertTrue(p.mayManage());
+                            looperThread.testComplete();
+                        }
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail("Could not open Realm: " + error.toString());
+            }
+        });
+    }
+
+    @Ignore("Until https://github.com/realm/realm-object-server/issues/1671 has been solved")
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getPermissions_updatedWithNewRealms_stressTest() {
+        final PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.getPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                assertTrue(permissions.isLoaded());
+                assertInitialPermissions(permissions);
+
+                for (int i = 0; i < 10; i++) {
+                    SyncConfiguration configNew = new SyncConfiguration.Builder(user, "realm://127.0.0.1:9080/~/test" + i).build();
+                    Realm newRealm = Realm.getInstance(configNew);
+                    looperThread.closeAfterTest(newRealm);
+                }
+
+                // Wait for the permission Result to report the new Realms
+                looperThread.keepStrongReference(permissions);
+                permissions.addChangeListener(new RealmChangeListener<RealmResults<Permission>>() {
+                    @Override
+                    public void onChange(RealmResults<Permission> permissions) {
+                        Permission p = permissions.where().endsWith("path", "test9").findFirst();
+                        if (p != null) {
+                            assertTrue(p.mayRead());
+                            assertTrue(p.mayWrite());
+                            assertTrue(p.mayManage());
+                            looperThread.testComplete();
+                        }
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getPermissions_closed() throws IOException {
+        PermissionManager pm = user.getPermissionManager();
+        pm.close();
+
+        pm.getPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.UNKNOWN, error.getErrorCode());
+                assertEquals(IllegalStateException.class, error.getException().getClass());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getPermissions_clientReset() {
+        final PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.getPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                // Simulate reset after first request succeeded to make sure that session is
+                // alive.
+                SyncManager.simulateClientReset(SyncManager.getSession(pm.permissionRealmConfig));
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        fail();
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        assertEquals(ErrorCode.CLIENT_RESET, error.getErrorCode());
+                        looperThread.testComplete();
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getPermissions_addTaskAfterClientReset() {
+        final PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.getPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                // Simulate reset after first request succeeded to make sure that session is
+                // alive.
+                SyncManager.simulateClientReset(SyncManager.getSession(pm.permissionRealmConfig));
+
+                // 1. Run task that fail
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        fail();
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        assertEquals(ErrorCode.CLIENT_RESET, error.getErrorCode());
+                        // 2. Then try to add another
+                        pm.getDefaultPermissions(new PermissionManager.PermissionsCallback() {
+                            @Override
+                            public void onSuccess(RealmResults<Permission> permissions) {
+                                fail();
+                            }
+
+                            @Override
+                            public void onError(ObjectServerError error) {
+                                assertEquals(ErrorCode.CLIENT_RESET, error.getErrorCode());
+                                looperThread.testComplete();
+                            }
+                        });
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Ignore("See https://github.com/realm/realm-java/issues/5143")
+    @Test
+    public void clientResetOnMultipleThreads() {
+
+        HandlerThread thread1 = new HandlerThread("handler1");
+        thread1.start();
+        Handler handler1 = new Handler(thread1.getLooper());
+
+        HandlerThread thread2 = new HandlerThread("handler2");
+        thread2.start();
+        Handler handler2 = new Handler(thread1.getLooper());
+
+        final AtomicReference<PermissionManager> pm1 = new AtomicReference<>(null);
+        final AtomicReference<PermissionManager> pm2 = new AtomicReference<>(null);
+
+        final CountDownLatch pmsOpened = new CountDownLatch(1);
+
+        // 1) Thread 1: Open PermissionManager and check permissions
+        handler1.post(new Runnable() {
+            @Override
+            public void run() {
+                PermissionManager pm = user.getPermissionManager();
+                pm1.set(pm);
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        assertInitialPermissions(permissions);
+                        pmsOpened.countDown();
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        fail(error.toString());
+                    }
+                });
+            }
+        });
+
+        // 2) Thread 2: Open PermissionManager and check permissions
+        handler2.post(new Runnable() {
+            @Override
+            public void run() {
+                PermissionManager pm = user.getPermissionManager();
+                pm2.set(pm);
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        assertInitialPermissions(permissions);
+                        pmsOpened.countDown();
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        fail(error.toString());
+                    }
+                });
+            }
+        });
+
+        TestHelper.awaitOrFail(pmsOpened);
+
+        // 3) Trigger Client Reset
+        SyncManager.simulateClientReset(SyncManager.getSession(pm1.get().permissionRealmConfig));
+        SyncManager.simulateClientReset(SyncManager.getSession(pm2.get().permissionRealmConfig));
+
+        // 4) Thread 1: Attempt to get permissions should trigger a Client Reset
+        final CountDownLatch clientResetThread1 = new CountDownLatch(1);
+        final CountDownLatch clientResetThread2 = new CountDownLatch(1);
+        handler1.post(new Runnable() {
+            @Override
+            public void run() {
+                final PermissionManager pm = pm1.get();
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        fail("Client reset should have been triggered");
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        assertEquals(ErrorCode.CLIENT_RESET, error.getErrorCode());
+                        pm.close();
+                        assertFalse(new File(pm.permissionRealmConfig.getPath()).exists());
+                        clientResetThread1.countDown();
+                    }
+                });
+            }
+        });
+
+        // 5) Thread 2: Attempting to get permissions should also trigger a Client Reset even though
+        //    Thread 1 just executed it
+        TestHelper.awaitOrFail(clientResetThread1);
+        handler2.post(new Runnable() {
+            @Override
+            public void run() {
+                final PermissionManager pm = pm2.get();
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        fail("Client reset should have been triggered");
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        assertEquals(ErrorCode.CLIENT_RESET, error.getErrorCode());
+                        pm.close();
+                        clientResetThread2.countDown();
+                    }
+                });
+            }
+        });
+        TestHelper.awaitOrFail(clientResetThread2);
+
+        // 6) After closing the PermissionManager, re-opening it again should work fine
+        final CountDownLatch newPmOpenedAndReady = new CountDownLatch(1);
+        handler1.post(new Runnable() {
+            @Override
+            public void run() {
+                final PermissionManager pm = user.getPermissionManager();
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        assertInitialPermissions(permissions);
+                        pm.close();
+                        newPmOpenedAndReady.countDown();
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        fail(error.toString());
+                    }
+                });
+            }
+        });
+
+        TestHelper.awaitOrFail(newPmOpenedAndReady);
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getDefaultPermissions_returnLoadedResults() {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.getDefaultPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                assertTrue(permissions.isLoaded());
+                assertInitialPermissions(permissions);
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getDefaultPermissions_noLongerValidWhenPermissionManagerIsClosed() {
+        final PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.getDefaultPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                assertTrue(permissions.isValid());
+                pm.close();
+                assertFalse(permissions.isValid());
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @Ignore("FIXME Add once `setPermissions` are implemented")
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getDefaultPermissions_updatedWithNewRealms() {
+
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getDefaultPermissions_closed() throws IOException {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.close();
+
+        pm.getDefaultPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.UNKNOWN, error.getErrorCode());
+                assertEquals(IllegalStateException.class, error.getException().getClass());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void permissionManagerAsyncTask_handlePermissionRealmError() throws NoSuchFieldException, IllegalAccessException {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        // Simulate error in the permission Realm
+        Field permissionConfigField = pm.getClass().getDeclaredField("permissionRealmError");
+        permissionConfigField.setAccessible(true);
+        final ObjectServerError error = new ObjectServerError(ErrorCode.UNKNOWN, "Boom");
+        permissionConfigField.set(pm, error);
+
+        PermissionManager.ApplyPermissionsCallback callback = new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertTrue(error.getErrorMessage().startsWith("Error occurred in Realm"));
+                assertTrue(error.getErrorMessage().contains("Permission Realm"));
+                assertEquals(ErrorCode.UNKNOWN, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        };
+
+        // Create dummy task that can trigger the error reporting
+        runTask(pm, callback);
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void permissionManagerAsyncTask_handleManagementRealmError() throws NoSuchFieldException, IllegalAccessException {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        // Simulate error in the permission Realm
+        final ObjectServerError error = new ObjectServerError(ErrorCode.UNKNOWN, "Boom");
+        setRealmError(pm, "managementRealmError", error);
+
+        PermissionManager.ApplyPermissionsCallback callback = new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertTrue(error.getErrorMessage().startsWith("Error occurred in Realm"));
+                assertTrue(error.getErrorMessage().contains("Management Realm"));
+                assertEquals(ErrorCode.UNKNOWN, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        };
+
+        // Create dummy task that can trigger the error reporting
+        runTask(pm, callback);
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void permissionManagerAsyncTask_handleTwoErrorsSameErrorCode() throws NoSuchFieldException, IllegalAccessException {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        // Simulate error in the permission Realm
+        setRealmError(pm, "managementRealmError", new ObjectServerError(ErrorCode.CONNECTION_CLOSED, "Boom1"));
+
+        // Simulate error in the management Realm
+        setRealmError(pm, "permissionRealmError", new ObjectServerError(ErrorCode.CONNECTION_CLOSED, "Boom2"));
+
+        PermissionManager.ApplyPermissionsCallback callback = new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.CONNECTION_CLOSED, error.getErrorCode());
+                assertTrue(error.toString().contains("Boom1"));
+                assertTrue(error.toString().contains("Boom2"));
+                looperThread.testComplete();
+            }
+        };
+
+        // Create dummy task that can trigger the error reporting
+        runTask(pm, callback);
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void permissionManagerAsyncTask_handleTwoErrorsDifferentErrorCode() throws NoSuchFieldException, IllegalAccessException {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        // Simulate error in the permission Realm
+        setRealmError(pm, "managementRealmError", new ObjectServerError(ErrorCode.CONNECTION_CLOSED, "Boom1"));
+
+        // Simulate error in the management Realm
+        setRealmError(pm, "permissionRealmError", new ObjectServerError(ErrorCode.SESSION_CLOSED, "Boom2"));
+
+        PermissionManager.ApplyPermissionsCallback callback = new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.UNKNOWN, error.getErrorCode());
+                assertTrue(error.toString().contains(ErrorCode.CONNECTION_CLOSED.toString()));
+                assertTrue(error.toString().contains(ErrorCode.SESSION_CLOSED.toString()));
+                looperThread.testComplete();
+            }
+        };
+
+        // Create dummy task that can trigger the error reporting
+        runTask(pm, callback);
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void applyPermissions_nonAdminUserFails() {
+        SyncUser user2 = UserFactory.createUniqueUser();
+        String otherUsersUrl = createRemoteRealm(user2, "test");
+
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        // Create request for setting permissions on another users Realm,
+        // i.e. user making the request do not have manage rights.
+        UserCondition condition = UserCondition.userId(user.getIdentity());
+        AccessLevel accessLevel = AccessLevel.WRITE;
+        PermissionRequest request = new PermissionRequest(condition, otherUsersUrl, accessLevel);
+
+        pm.applyPermissions(request, new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.ACCESS_DENIED, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void applyPermissions_wrongUrlFails() {
+        String wrongUrl = createRemoteRealm(user, "test") + "-notexisting";
+
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        // Create request for setting permissions on another users Realm,
+        // i.e. user making the request do not have manage rights.
+        UserCondition condition = UserCondition.userId(user.getIdentity());
+        AccessLevel accessLevel = AccessLevel.WRITE;
+        PermissionRequest request = new PermissionRequest(condition, wrongUrl, accessLevel);
+
+        pm.applyPermissions(request, new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.ACCESS_DENIED, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void applyPermissions_withUserId() {
+        final SyncUser user2 = UserFactory.createUniqueUser();
+        String url = createRemoteRealm(user2, "test");
+        PermissionManager pm2 = user2.getPermissionManager();
+        looperThread.closeAfterTest(pm2);
+
+        // Create request for giving `user` WRITE permissions to `user2`'s Realm.
+        UserCondition condition = UserCondition.userId(user.getIdentity());
+        AccessLevel accessLevel = AccessLevel.WRITE;
+        PermissionRequest request = new PermissionRequest(condition, url, accessLevel);
+
+        pm2.applyPermissions(request, new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                PermissionManager pm = user.getPermissionManager();
+                looperThread.closeAfterTest(pm);
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        assertPermissionPresent(permissions, user, "/test", AccessLevel.WRITE);
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        fail(error.toString());
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void applyPermissions_withUsername() {
+        String user1Username = TestHelper.getRandomEmail();
+        String user2Username = TestHelper.getRandomEmail();
+        final SyncUser user1 = UserFactory.createUser(user1Username);
+        final SyncUser user2 = UserFactory.createUser(user2Username);
+        PermissionManager pm1 = user1.getPermissionManager();
+        looperThread.closeAfterTest(pm1);
+
+        // Create request for giving `user2` WRITE permissions to `user1`'s Realm.
+        UserCondition condition = UserCondition.username(user2Username);
+        AccessLevel accessLevel = AccessLevel.WRITE;
+        String url = createRemoteRealm(user1, "test");
+        PermissionRequest request = new PermissionRequest(condition, url, accessLevel);
+
+        pm1.applyPermissions(request, new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                PermissionManager pm2 = user2.getPermissionManager();
+                looperThread.closeAfterTest(pm2);
+                pm2.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        assertPermissionPresent(permissions, user2, user1.getIdentity() + "/test", AccessLevel.WRITE);
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        fail(error.toString());
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void applyPermissions_usersWithNoExistingPermissions() {
+        final SyncUser user1 = UserFactory.createUser("user1@realm.io");
+        final SyncUser user2 = UserFactory.createUser("user2@realm.io");
+        PermissionManager pm1 = user1.getPermissionManager();
+        looperThread.closeAfterTest(pm1);
+
+        // Create request for giving all users with no existing permissions WRITE permissions to `user1`'s Realm.
+        UserCondition condition = UserCondition.noExistingPermissions();
+        AccessLevel accessLevel = AccessLevel.WRITE;
+        final String url = createRemoteRealm(user1, "test");
+        PermissionRequest request = new PermissionRequest(condition, url, accessLevel);
+
+        pm1.applyPermissions(request, new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                // Default permissions are not recorded in the __permission Realm for user2
+                // Only way to check is by opening the Realm.
+                SyncConfiguration config = new SyncConfiguration.Builder(user2, url)
+                        .waitForInitialRemoteData()
+                        .errorHandler(new SyncSession.ErrorHandler() {
+                            @Override
+                            public void onError(SyncSession session, ObjectServerError error) {
+                                fail(error.toString());
+                            }
+                        })
+                        .build();
+
+                RealmAsyncTask task = Realm.getInstanceAsync(config, new Realm.Callback() {
+                    @Override
+                    public void onSuccess(Realm realm) {
+                        realm.close();
+                        looperThread.testComplete();
+                    }
+
+                    @Override
+                    public void onError(Throwable exception) {
+                        fail(exception.toString());
+                    }
+                });
+                looperThread.keepStrongReference(task);
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void makeOffer() {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        String url = createRemoteRealm(user, "test");
+
+        PermissionOffer offer = new PermissionOffer(url, AccessLevel.WRITE);
+        pm.makeOffer(offer, new PermissionManager.MakeOfferCallback() {
+            @Override
+            public void onSuccess(String offerToken) {
+                assertNotNull(offerToken);
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void makeOffer_noManageAccessThrows() {
+        // User 2 creates a Realm
+        SyncUser user2 = UserFactory.createUniqueUser();
+        String url = createRemoteRealm(user2, "test");
+
+        // User 1 tries to create an offer for it.
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        PermissionOffer offer = new PermissionOffer(url, AccessLevel.WRITE);
+        pm.makeOffer(offer, new PermissionManager.MakeOfferCallback() {
+            @Override
+            public void onSuccess(String offerToken) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.ACCESS_DENIED, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void acceptOffer() {
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
+
+        final SyncUser user2 = UserFactory.createUniqueUser();
+        final PermissionManager pm = user2.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        pm.acceptOffer(offerToken, new PermissionManager.AcceptOfferCallback() {
+            @Override
+            public void onSuccess(String url, Permission permission) {
+                assertEquals("/" + user.getIdentity() + "/test", permission.getPath());
+                assertTrue(permission.mayRead());
+                assertTrue(permission.mayWrite());
+                assertFalse(permission.mayManage());
+                assertEquals(user2.getIdentity(), permission.getUserId());
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void acceptOffer_invalidToken() {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.acceptOffer("wrong-token", new PermissionManager.AcceptOfferCallback() {
+            @Override
+            public void onSuccess(String url, Permission permission) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.INVALID_PARAMETERS, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    @Ignore("Figure out how the time differs between emulator and server")
+    public void acceptOffer_expiredThrows() {
+        // Trying to guess how long CI is to process this. The offer cannot be created if it
+        // already expired.
+        long delayMillis = TimeUnit.SECONDS.toMillis(10);
+        Date expiresAt = new Date(new Date().getTime() + delayMillis);
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, expiresAt);
+        SystemClock.sleep(delayMillis); // Make sure that the offer expires.
+        final SyncUser user2 = UserFactory.createUniqueUser();
+        final PermissionManager pm = user2.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        pm.acceptOffer(offerToken, new PermissionManager.AcceptOfferCallback() {
+            @Override
+            public void onSuccess(String url, Permission permission) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.EXPIRED_PERMISSION_OFFER, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void acceptOffer_multipleUsers() {
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
+
+        final SyncUser user2 = UserFactory.createUniqueUser();
+        final SyncUser user3 = UserFactory.createUniqueUser();
+        final PermissionManager pm2 = user2.getPermissionManager();
+        final PermissionManager pm3 = user3.getPermissionManager();
+        looperThread.closeAfterTest(pm2);
+        looperThread.closeAfterTest(pm3);
+
+        final AtomicInteger offersAccepted = new AtomicInteger(0);
+        PermissionManager.AcceptOfferCallback callback = new PermissionManager.AcceptOfferCallback() {
+            @Override
+            public void onSuccess(String url, Permission permission) {
+                assertEquals("/" + user.getIdentity() + "/test", permission.getPath());
+                assertTrue(permission.mayRead());
+                assertTrue(permission.mayWrite());
+                assertFalse(permission.mayManage());
+                if (offersAccepted.incrementAndGet() == 2) {
+                    looperThread.testComplete();
+                }
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        };
+
+        pm2.acceptOffer(offerToken, callback);
+        pm3.acceptOffer(offerToken, callback);
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getCreatedOffers() {
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        pm.getCreatedOffers(new PermissionManager.OffersCallback() {
+            @Override
+            public void onSuccess(RealmResults<PermissionOffer> offers) {
+                RealmResults filteredOffers = offers.where()
+                        .equalTo("token", offerToken)
+                        .findAllAsync();
+                looperThread.keepStrongReference(offers);
+                filteredOffers.addChangeListener(new RealmChangeListener<RealmResults>() {
+                    @Override
+                    public void onChange(RealmResults results) {
+                        switch (results.size()) {
+                            case 0: return;
+                            case 1:
+                                looperThread.testComplete();
+                                break;
+                            default:
+                                fail("To many offers: " + Arrays.toString(results.toArray()));
+                        }
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void revokeOffer() {
+        // createOffer validates that the offer is actually in the __management Realm.
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
+        final PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        pm.revokeOffer(offerToken, new PermissionManager.RevokeOfferCallback() {
+            @Override
+            public void onSuccess() {
+                pm.getCreatedOffers(new PermissionManager.OffersCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<PermissionOffer> offers) {
+                        assertEquals(0, offers.size());
+                        looperThread.testComplete();
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        fail(error.toString());
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void revokeOffer_afterOneAcceptEdit() {
+        // createOffer validates that the offer is actually in the __management Realm.
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
+
+        SyncUser user2 = UserFactory.createUniqueUser();
+        SyncUser user3 = UserFactory.createUniqueUser();
+        final PermissionManager pm1 = user.getPermissionManager();
+        PermissionManager pm2 = user2.getPermissionManager();
+        final PermissionManager pm3 = user3.getPermissionManager();
+        looperThread.closeAfterTest(pm1);
+        looperThread.closeAfterTest(pm2);
+        looperThread.closeAfterTest(pm3);
+
+        pm2.acceptOffer(offerToken, new PermissionManager.AcceptOfferCallback() {
+            @Override
+            public void onSuccess(String realmUrl, Permission permission) {
+                pm1.revokeOffer(offerToken, new PermissionManager.RevokeOfferCallback() {
+                    @Override
+                    public void onSuccess() {
+                        pm3.acceptOffer(offerToken, new PermissionManager.AcceptOfferCallback() {
+                            @Override
+                            public void onSuccess(String realmUrl, Permission permission) {
+                                fail("Offer should have been revoked");
+                            }
+
+                            @Override
+                            public void onError(ObjectServerError error) {
+                                assertEquals(ErrorCode.INVALID_PARAMETERS, error.getErrorCode());
+                                looperThread.testComplete();
+                            }
+                        });
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        fail(error.toString());
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    @Ignore("Figure out why clocks on server/emulator on CI seem to differ")
+    public void revokeOffer_alreadyExpired() {
+        fail("Implement this");
+    }
+
+    /**
+     * Creates a offer for a newly created Realm.
+     *
+     * @param user User that should create the offer
+     * @param realmName Realm to create
+     * @param level accessLevel to offer
+     * @param expires when the offer expires
+     */
+    private String createOffer(final SyncUser user, final String realmName, final AccessLevel level, final Date expires) {
+        final CountDownLatch offerReady = new CountDownLatch(1);
+        final AtomicReference<String> offer = new AtomicReference<>(null);
+        final HandlerThread ht = new HandlerThread("OfferThread");
+        ht.start();
+        Handler handler = new Handler(ht.getLooper());
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                String url = createRemoteRealm(user, realmName);
+                final PermissionManager pm = user.getPermissionManager();
+                pm.makeOffer(new PermissionOffer(url, level, expires), new PermissionManager.MakeOfferCallback() {
+                    @Override
+                    public void onSuccess(String offerToken) {
+                        offer.set(offerToken);
+                        pm.close();
+                        offerReady.countDown();
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        pm.close();
+                        fail(error.toString());
+                    }
+                });
+            }
+        });
+        TestHelper.awaitOrFail(offerReady);
+        ht.quit();
+        return offer.get();
+    }
+
+    /**
+     * Wait for a given permission to be present.
+     *
+     * @param permissions permission results.
+     * @param user user that is being granted the permission.
+     * @param urlSuffix the url suffix to listen for.
+     * @param accessLevel the expected access level for 'user'.
+     */
+    private void assertPermissionPresent(RealmResults<Permission> permissions, final SyncUser user, String urlSuffix, final AccessLevel accessLevel) {
+        RealmResults<Permission> filteredPermissions = permissions.where().endsWith("path", urlSuffix).findAllAsync();
+        looperThread.keepStrongReference(permissions);
+        filteredPermissions.addChangeListener(new RealmChangeListener<RealmResults<Permission>>() {
+            @Override
+            public void onChange(RealmResults<Permission> permissions) {
+                switch(permissions.size()) {
+                    case 0: return;
+                    case 1:
+                        Permission p = permissions.first();
+                        assertEquals(accessLevel.mayRead(), p.mayRead());
+                        assertEquals(accessLevel.mayWrite(), p.mayWrite());
+                        assertEquals(accessLevel.mayManage(), p.mayManage());
+                        assertEquals(user.getIdentity(), p.getUserId());
+                        looperThread.testComplete();
+                        break;
+                    default:
+                        fail("To many permissions matched: " + Arrays.toString(permissions.toArray()));
+                }
+            }
+        });
+    }
+
+    private void setRealmError(PermissionManager pm, String fieldName, ObjectServerError error) throws NoSuchFieldException,
+            IllegalAccessException {
+        Field managementRealmErrorField = pm.getClass().getDeclaredField(fieldName);
+        managementRealmErrorField.setAccessible(true);
+        managementRealmErrorField.set(pm, error);
+    }
+
+    private void runTask(final PermissionManager pm, final PermissionManager.ApplyPermissionsCallback callback) {
+        new PermissionManager.PermissionManagerTask<Void>(pm, callback) {
+            @Override
+            public void run() {
+                if (!checkAndReportInvalidState()) {
+                    fail();
+                }
+            }
+        }.run();
+    }
+
+    /**
+     * Creates an empty remote Realm on ROS owned by the provided user
+     */
+    private String createRemoteRealm(SyncUser user, String realmName) {
+        String url = Constants.AUTH_SERVER_URL + "~/" + realmName;
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url).build();
+
+        Realm realm = Realm.getInstance(config);
+        SyncSession session = SyncManager.getSession(config);
+        final CountDownLatch uploadLatch = new CountDownLatch(1);
+        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    uploadLatch.countDown();
+                }
+            }
+        });
+        TestHelper.awaitOrFail(uploadLatch);
+        realm.close();
+        return config.getServerUrl().toString();
+    }
+
+    /**
+     * The initial set of permissions of ROS is timing dependant. This method will identify the possible known starting
+     * states and fail if neither of these can be verified.
+     */
+    private void assertInitialPermissions(RealmResults<Permission> permissions) {
+        // For a new user, the PermissionManager should contain 1 entry for the __permission Realm, but we are
+        // creating the __management Realm at the same time, so this might be here as well.
+        permissions = permissions.sort("path");
+        if (permissions.size() == 1) {
+            // FIXME It is very unpredictable which Permission is returned. This needs to be fixed.
+            Permission permission = permissions.first();
+            assertTrue(permission.getPath().endsWith("__permission") || permission.getPath().endsWith("__management"));
+        } else if (permissions.size() == 2) {
+            assertTrue("Failed: " + permissions.get(0).toString(), permissions.get(0).getPath().endsWith("__management"));
+            assertTrue("Failed: " + permissions.get(1).toString(), permissions.get(1).getPath().endsWith("__permission"));
+        } else {
+            fail("Permission Realm contains unknown permissions: " + Arrays.toString(permissions.toArray()));
+        }
+    }
+
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
index ebe2663b8d..bed08c965f 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
@@ -18,6 +18,7 @@
 
 import android.os.SystemClock;
 import android.support.test.runner.AndroidJUnit4;
+import android.text.style.TabStopSpan;
 
 import org.junit.Rule;
 import org.junit.Test;
@@ -39,7 +40,7 @@
 import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
-public class SSLConfigurationTests extends BaseIntegrationTest {
+public class SSLConfigurationTests extends StandardIntegrationTest {
 
     @Rule
     public Timeout globalTimeout = Timeout.seconds(10);
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java
new file mode 100644
index 0000000000..e2b7bb9513
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+
+import java.io.IOException;
+
+
+/**
+ * The standard base class for integration tests.
+ * This class will keep a ROS instance running for all tests to minimize the overhead between each test.
+ */
+public abstract class StandardIntegrationTest extends BaseIntegrationTest {
+
+    @BeforeClass
+    public static void setupTestClass() throws Exception {
+        startSyncServer();
+    }
+
+    @AfterClass
+    public static void tearDownTestClass() throws Exception {
+        stopSyncServer();
+    }
+
+    @Before
+    public void setupTest() throws IOException {
+        prepareEnvironmentForTest();
+    }
+
+    @After
+    public void teardownTest() {
+        if (!looperThread.isRuleUsed() || looperThread.isTestComplete()) {
+            // Non-looper tests can reset here
+            restoreEnvironmentAfterTest();
+        } else {
+            // Otherwise we need to wait for the test to complete
+            looperThread.runAfterTest(new Runnable() {
+                @Override
+                public void run() {
+                    restoreEnvironmentAfterTest();
+                }
+            });
+        }
+    }
+
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
index fc834ea91c..fddce46123 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
@@ -43,7 +43,7 @@
  * Catch all class for tests that not naturally fit anywhere else.
  */
 @RunWith(AndroidJUnit4.class)
-public class SyncedRealmTests extends BaseIntegrationTest {
+public class SyncedRealmTests extends StandardIntegrationTest {
 
     @Test
     @UiThreadTest
@@ -218,8 +218,7 @@ public void execute(Realm realm) {
         realm.close();
         user.logout();
     }
-
-
+    
     @Test
     public void waitForInitialRemoteData_readOnlyTrue_throwsIfWrongServerSchema() {
         SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index c2c982888e..7c249c1480 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -7,7 +7,6 @@
 
 import org.junit.Assert;
 import org.junit.Ignore;
-import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -22,11 +21,11 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.realm.AuthenticationListener;
-import io.realm.BaseIntegrationTest;
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
+import io.realm.StandardIntegrationTest;
 import io.realm.SyncConfiguration;
 import io.realm.SyncCredentials;
 import io.realm.SyncManager;
@@ -40,7 +39,6 @@
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunTestInLooperThread;
-import io.realm.rule.TestSyncConfigurationFactory;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertNotNull;
@@ -58,9 +56,7 @@
 
 
 @RunWith(AndroidJUnit4.class)
-public class AuthTests extends BaseIntegrationTest {
-    @Rule
-    public TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
+public class AuthTests extends StandardIntegrationTest {
 
     @Test
     public void login_userNotExist() {
@@ -532,7 +528,7 @@ public void preemptiveTokenRefresh() throws NoSuchFieldException, IllegalAccessE
         @SuppressWarnings("unchecked") // using reflection
         Map<SyncConfiguration, Token> accessTokens = (Map<SyncConfiguration, Token>) realmsField.get(user);
 
-        final SyncConfiguration syncConfiguration = configFactory
+        final SyncConfiguration syncConfiguration = configurationFactory
                 .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
                 .modules(new StringOnlyModule())
                 .errorHandler(new SyncSession.ErrorHandler() {
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
index 5d02db4426..50d7ed8b40 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
@@ -1,6 +1,7 @@
 package io.realm.objectserver;
 
 import android.os.SystemClock;
+import android.text.style.TabStopSpan;
 
 import org.junit.Rule;
 import org.junit.Test;
@@ -15,6 +16,7 @@
 import io.realm.ObjectServerError;
 import io.realm.Realm;
 import io.realm.RealmResults;
+import io.realm.StandardIntegrationTest;
 import io.realm.SyncConfiguration;
 import io.realm.SyncCredentials;
 import io.realm.SyncManager;
@@ -32,7 +34,7 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-public class EncryptedSynchronizedRealmTests extends BaseIntegrationTest {
+public class EncryptedSynchronizedRealmTests extends StandardIntegrationTest {
 
     @Rule
     public Timeout globalTimeout = Timeout.seconds(10);
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
index b616151928..135d607826 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
@@ -22,23 +22,23 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import java.util.Date;
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.realm.BaseIntegrationTest;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
 import io.realm.RealmResults;
+import io.realm.StandardIntegrationTest;
 import io.realm.SyncConfiguration;
 import io.realm.SyncSession;
 import io.realm.SyncUser;
 import io.realm.entities.Dog;
+import io.realm.internal.permissions.PermissionOfferResponse;
 import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.UserFactory;
+import io.realm.permissions.AccessLevel;
 import io.realm.permissions.PermissionOffer;
-import io.realm.permissions.PermissionOfferResponse;
 import io.realm.rule.RunTestInLooperThread;
 
 import static org.junit.Assert.assertEquals;
@@ -46,7 +46,7 @@
 import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
-public class ManagementRealmTests extends BaseIntegrationTest {
+public class ManagementRealmTests extends StandardIntegrationTest {
 
     // This is primarily a test making sure that an admin user actually connects correctly to ROS.
     // See https://github.com/realm/realm-java/issues/4750
@@ -65,7 +65,7 @@ public void run() {
         });
         realm.beginTransaction();
         // Invalid Permission offer
-        realm.copyToRealm(new PermissionOffer("*", true, true, false, null));
+        realm.copyToRealm(new PermissionOffer("*", AccessLevel.WRITE, null));
         realm.commitTransaction();
         RealmResults <PermissionOffer> results = realm.where(PermissionOffer.class).findAllAsync();
         looperThread.keepStrongReference(results);
@@ -120,11 +120,7 @@ public void execute(Realm realm) {
         user1ManagementRealm.executeTransactionAsync(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-                boolean readPermission = true;
-                boolean readWritePermission = true;
-                boolean managePermission = false;
-                Date expiresAt = null;
-                PermissionOffer offer = new PermissionOffer(user1RealmUrl, readPermission, readWritePermission, managePermission, expiresAt);
+                PermissionOffer offer = new PermissionOffer(user1RealmUrl, AccessLevel.WRITE, null);
                 offerId.set(offer.getId());
                 realm.copyToRealm(offer);
             }
@@ -141,7 +137,7 @@ public void onSuccess() {
                     @Override
                     public void onChange(RealmResults<PermissionOffer> offers) {
                         final PermissionOffer offer = offers.first(null);
-                        if (offer != null && offer.isSuccessful() && offer.getToken() != null) {
+                        if (offer != null && offer.isOfferCreated() && offer.getToken() != null) {
                             // 5. User2 uses the token to accept the offer
                             final String offerToken = offer.getToken();
                             final AtomicReference<String> offerResponseId = new AtomicReference<String>();
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
index 42bd324388..fe4eebfe8c 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
@@ -31,6 +31,7 @@
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
 import io.realm.RealmResults;
+import io.realm.StandardIntegrationTest;
 import io.realm.SyncConfiguration;
 import io.realm.SyncUser;
 import io.realm.objectserver.model.ProcessInfo;
@@ -47,7 +48,7 @@
 
 
 @RunWith(AndroidJUnit4.class)
-public class ProcessCommitTests extends BaseIntegrationTest {
+public class ProcessCommitTests extends StandardIntegrationTest {
 
     @Rule
     public RunWithRemoteService remoteService = new RunWithRemoteService();
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
index 4917f926cb..a42a274f97 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
@@ -34,6 +34,7 @@
 import io.realm.ProgressListener;
 import io.realm.ProgressMode;
 import io.realm.Realm;
+import io.realm.StandardIntegrationTest;
 import io.realm.SyncConfiguration;
 import io.realm.SyncManager;
 import io.realm.SyncSession;
@@ -50,7 +51,7 @@
 import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
-public class ProgressListenerTests extends BaseIntegrationTest {
+public class ProgressListenerTests extends StandardIntegrationTest {
 
     private static final long TEST_SIZE = 10;
     @Rule
@@ -180,7 +181,7 @@ public void onChange(Progress progress) {
                             break;
                         }
                         default:
-                            fail();
+                            fail("Transfer complete called too many times:" + transferCompleted.get());
                     }
                 }
             }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
index 3d344f46b5..2bebc5a193 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
@@ -17,6 +17,7 @@
 
 import io.realm.BaseIntegrationTest;
 import io.realm.Realm;
+import io.realm.StandardIntegrationTest;
 import io.realm.RealmChangeListener;
 import io.realm.RealmResults;
 import io.realm.SyncConfiguration;
@@ -37,7 +38,7 @@
 import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
-public class SyncSessionTests extends BaseIntegrationTest {
+public class SyncSessionTests extends StandardIntegrationTest {
     @Rule
     public TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
 
@@ -246,6 +247,7 @@ public void onChange(RealmResults<StringOnly> stringOnlies) {
         });
 
         TestHelper.awaitOrFail(testCompleted, 60);
+        realm.close();
     }
 
     // A Realm that was opened before a user logged out should be able to resume uploading if the user logs back in.
@@ -375,6 +377,7 @@ public void run() {
                     e.printStackTrace();
                     fail(e.getMessage());
                 }
+                adminRealm.close();
 
                 backgroundUpload.countDown();
                 handlerThread.quit();
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/suite/IntegrationTestSuite.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/suite/IntegrationTestSuite.java
index 87b8f5cb8b..85c69b9236 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/suite/IntegrationTestSuite.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/suite/IntegrationTestSuite.java
@@ -26,6 +26,8 @@
 import io.realm.objectserver.EncryptedSynchronizedRealmTests;
 import io.realm.objectserver.ManagementRealmTests;
 import io.realm.objectserver.ProcessCommitTests;
+import io.realm.objectserver.ProgressListenerTests;
+import io.realm.objectserver.SyncSessionTests;
 
 // Test suite includes all integration tests. Makes it easy to run all integration tests in the Android Studio.
 @RunWith(Suite.class)
@@ -35,6 +37,8 @@
         AuthTests.class,
         EncryptedSynchronizedRealmTests.class,
         ManagementRealmTests.class,
-        ProcessCommitTests.class})
+        ProcessCommitTests.class,
+        ProgressListenerTests.class,
+        SyncSessionTests.class})
 public class IntegrationTestSuite {
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
index d2be7cbc90..0bf26e0eca 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
@@ -19,6 +19,7 @@
 public class Constants {
 
     public static final String USER_REALM = "realm://127.0.0.1:9080/~/tests";
+    public static final String USER_REALM_2 = "realm://127.0.0.1:9080/~/tests2";
     public static final String USER_REALM_SECURE = "realms://127.0.0.1:9443/~/tests";
     public static final String SYNC_SERVER_URL = "realm://127.0.0.1:9080/~/tests";
     public static final String SYNC_SERVER_URL_2 = "realm://127.0.0.1/~/tests2";
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
index fca7147dc5..1257444155 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
@@ -32,6 +32,8 @@
  * WARNING: This class is called before Realm is initialized, so RealmLog cannot be used.
  */
 public class HttpUtils {
+    // TODO If the timeouts are longer than the test timeout you risk getting
+    // "Realm could not be deleted errors".
     private final static OkHttpClient client = new OkHttpClient.Builder()
             .retryOnConnectionFailure(true)
             .build();
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
index f9851b917d..f4b13ed174 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
@@ -16,14 +16,26 @@
 
 package io.realm.objectserver.utils;
 
+import android.os.Handler;
+import android.os.HandlerThread;
+
+import java.util.Map;
 import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
 
+import io.realm.AuthenticationListener;
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
 import io.realm.SyncCredentials;
+import io.realm.SyncManager;
 import io.realm.SyncUser;
+import io.realm.TestHelper;
 import io.realm.log.RealmLog;
 
+import static org.junit.Assert.fail;
+
+
 // Helper class to retrieve users with same IDs even in multi-processes.
 // Must be in `io.realm.objectserver` to work around package protected methods.
 // This require Realm.init() to be called before using this class.
@@ -46,12 +58,28 @@ public SyncUser loginWithDefaultUser(String authUrl) {
         return SyncUser.login(credentials, authUrl);
     }
 
+    /**
+     * Create a unique user, using the standard authentification URL used by the test server.
+     */
+    public static SyncUser createUniqueUser() {
+        return createUniqueUser(Constants.AUTH_URL);
+    }
+
+    public static SyncUser createUser(String username) {
+        return createUser(username, Constants.AUTH_URL);
+    }
+
     public static SyncUser createUniqueUser(String authUrl) {
         String uniqueName = UUID.randomUUID().toString();
-        SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, PASSWORD, true);
+        return createUser(uniqueName);
+    }
+
+    private static SyncUser createUser(String username, String authUrl) {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, PASSWORD, true);
         return SyncUser.login(credentials, authUrl);
     }
 
+
     public SyncUser createDefaultUser(String authUrl) {
         SyncCredentials credentials = SyncCredentials.usernamePassword(userName, PASSWORD, true);
         return SyncUser.login(credentials, authUrl);
@@ -101,4 +129,55 @@ public static synchronized UserFactory getInstance() {
         RealmLog.debug("UserFactory.getInstance, the default user is " + instance.userName + " .");
         return instance;
     }
+
+    /**
+     * Blocking call that logs out all users
+     */
+    public static void logoutAllUsers() {
+        final CountDownLatch allUsersLoggedOut = new CountDownLatch(1);
+        final HandlerThread ht = new HandlerThread("LoggingOutUsersThread");
+        ht.start();
+        Handler handler = new Handler(ht.getLooper());
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                final AtomicInteger usersLoggedOut = new AtomicInteger(0);
+                final int activeUsers = SyncUser.all().size();
+                final AuthenticationListener listener = new AuthenticationListener() {
+                    @Override
+                    public void loggedIn(SyncUser user) {
+                        SyncManager.removeAuthenticationListener(this);
+                        fail("User logged in while exiting test: " + user);
+                    }
+
+                    @Override
+                    public void loggedOut(SyncUser user) {
+                        if (usersLoggedOut.incrementAndGet() == activeUsers) {
+                            SyncManager.removeAuthenticationListener(this);
+                            allUsersLoggedOut.countDown();
+                        }
+                    }
+                };
+                SyncManager.addAuthenticationListener(listener);
+
+                Map<String, SyncUser> users = SyncUser.all();
+                if (users.isEmpty()) {
+                    SyncManager.removeAuthenticationListener(listener);
+                    allUsersLoggedOut.countDown();
+                } else {
+                    for (SyncUser user : users.values()) {
+                        user.logout();
+                        if (!user.getAuthenticationUrl().toString().contains("127.0.0.1")) {
+                            // For dummy users, calling `logout()` will never result in the
+                            // authentication listener to trigger since the URL doesn't exist.
+                            // For these cases, we manually trigger the listener.
+                            listener.loggedOut(user);
+                        }
+                    }
+                }
+            }
+        });
+        TestHelper.awaitOrFail(allUsersLoggedOut);
+        ht.quit();
+    }
 }
diff --git a/tools/release.sh b/tools/release.sh
index 343c4367cc..73f94f6ee6 100755
--- a/tools/release.sh
+++ b/tools/release.sh
@@ -98,6 +98,7 @@ prepare_branch() {
     # Merge the branch to the releases branch and check the CHANGELOG.md
     if [[ "$BRANCH_TO_RELEASE" != "releases" ]] ; then
         git merge "origin/$BRANCH_TO_RELEASE"
+        git submodule update --init --recursive
 
         while true
         do
@@ -144,7 +145,7 @@ prepare_branch() {
 
     # Update date in change log
     cur_date=$(date "+%F")
-    sed -i .bak "1 s/YYYY-MM-DD/${cur_date}/" CHANGELOG.md
+    sed "1 s/YYYY-MM-DD/${cur_date}/" CHANGELOG.md > CHANGELOG.md.tmp && mv CHANGELOG.md.tmp CHANGELOG.md
     git add CHANGELOG.md
     git commit -m "Update changelog date"
 
diff --git a/tools/sync_test_server/configuration.yml b/tools/sync_test_server/configuration.yml
index a0e17934b2..9b73a0c68c 100644
--- a/tools/sync_test_server/configuration.yml
+++ b/tools/sync_test_server/configuration.yml
@@ -106,7 +106,28 @@ auth:
     ## This enables authentication via a Facebook access token for a specific app.
     ## This provider needs no configuration (uncommenting the next line enables it).
     # facebook: {}
-    debug: {}
+
+    ## This enables authentication via an Azure Active Directory access token for a specific directory.
+    # azuread:
+      ## The Directory Id as retrieved from the Active Directory properties in the Azure portal.
+      # tenant_id: '01234567-89ab-cdef-0123-4567890a'
+
+    ## This would enable a custom authentication provider with the name "custom/twitter".
+    ## The prefix "custom/" is necessary for all authentication providers using a custom
+    ## implementation to ensure forwards-compatiblity and avoid name clashes.
+    # custom/twitter:
+      ## The implementation to be used. This can be either one of the predefined
+      ## implementations under a custom name or a custom implementation found at
+      ## the include_path or if not given at the auth:providers_include_path.
+      # implementation: custom_provider_implementation.js
+
+      ## The include path to use for this providers custom implementation.
+      # include_path: /~/.realm/auth
+
+      ## Beyond that custom implementations can define custom configuration
+      ## options which will be populated to their configuration and merged with
+      ## the default values they can define.
+     debug: {}
 
 ## ----------------------------------------------------------------------------
 
@@ -160,28 +181,28 @@ proxy:
     listen_address: '0.0.0.0'
 
     ## The port that the HTTP proxy module should bind to.
-    # listen_port: 9080
+    listen_port: 9080
 
   https:
     ## Whether or not to enable the HTTPS proxy module. It enables multiplexing requests
     ## by forwarding incoming requests on a single port to all services.
     ## Note that even if it enabled, the HTTPS proxy will only start if supplied
     ## with a valid pair of certificates through certificate_path and private_key_path below.
-    enable: true
+     enable: true
 
     ## The path to the certificate and private keys (in PEM format) that will be used
     ## to set up the HTTPS server accepting connections.
     ## These configuration options are MANDATORY to start the HTTPS proxy module.
-    certificate_path: '/127_0_0_1-chain.crt.pem'
-    private_key_path: '/127_0_0_1-server.key.pem'
+     certificate_path: '/127_0_0_1-chain.crt.pem'
+     private_key_path: '/127_0_0_1-server.key.pem'
 
     ## The address/interface on which the HTTPS proxy module should listen. This defaults
     ## to 127.0.0.1. If you wish to listen on all available interfaces,
     ## uncomment the following line.
-    listen_address: '0.0.0.0'
+     listen_address: '0.0.0.0'
 
     ## The port that the HTTPS proxy module should bind to.
-    listen_port: 9443
+     listen_port: 9443
 
 ## ----------------------------------------------------------------------------
 
@@ -250,7 +271,7 @@ logging:
   ##   error
   ##   fatal
   ##   off: all output suppressed
-  # level: 'info'
+   level: 'detail'
 
   ## The file to which the synchronisation server should log. This should
   ## be a writable path from the perspective of the user under which the
diff --git a/version.txt b/version.txt
index 0fe613c3a5..ca12ba1b1d 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-3.6.0-SNAPSHOT
+3.8.0-SNAPSHOT
\ No newline at end of file
