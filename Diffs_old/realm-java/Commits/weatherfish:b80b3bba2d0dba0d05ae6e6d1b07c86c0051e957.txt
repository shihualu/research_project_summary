diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5d909505eb..966045e390 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,18 +1,34 @@
 ## 3.1.0 (YYYY-MM-DD)
 
+### Breaking Changes
+
+* [ObjectServer] Added `onClientResetRequired(SyncSession, ClientResetHandler)` method to the `ErrorHandler` interface (#4080).
+
 ### Enhancements
 
 * Now `targetSdkVersion` is 25.
+* Now using Gradle 3.4.1
+* The real `RealmMigrationNeededException` is now thrown instead of `IllegalArgumentException` if no migration is provided for a Realm that requires it.
+* Partial implementation of `LinkingObjects`.  There is documentation in `io.realm.annotations.LinkingObjects`.  Internal docs are in `io.realm.processor.Backlink`.
+  * Queries on linking objects do not work.  Queries like `were(...).equalTo("field.linkingObjects.id", 7).findAll()` are not yet supported.
+  * Linking objects are not yet supported on dynamic objects
+  * Migration for linking objects is not yet supported.
+  * Backlink verification is incomplete.  Evil code can cause native crashes.
+* [ObjectServer] In case of a Client Reset, information about the location of the backed up Realm file is now reported through the `ErrorHandler` interface (#4080).
 
 ### Bug Fixes
 
 * `Realm.migrateRealm(RealmConfiguration)` now fails correctly with an `IllegalArgumentException` if a `SyncConfiguration` is provided (#4075).
+* Fixed a potential cause for Realm file corruptions (never reported).
+* Add `@Override` annotation to proxy class accessors and stop using raw type in proxy classes in order to remove warnings from javac (#4329).
 
 ### Deprecated
 
 ### Internal
 
 * Using the Object Store's Session and SyncManager.
+* Upgraded to Realm Sync 1.3.2.
+* Upgraded to Realm Core 2.4.0.
 
 ## 3.0.0 (2017-02-28)
 
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index e25a9af5f1..88db58a2b6 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -31,6 +31,8 @@ Realm welcomes all contributions! The only requirement we have is that, like man
 
 While we havn't described our code style yet, please just follow the existing style you see in the files you change.
 
+For source code written in C++, we format it using `clang-format`. You can use the [plugin](https://plugins.jetbrains.com/plugin/8396-clangformatij): mark the entire file and right-click to execute `clang-format` before committing any changes. Of course, if you don't use Android Studio to edit C++ code, run `clang-format` on the command-line.
+
 ### Unit Tests
 
 All PR's must be accompanied by related unit tests. All bug fixes must have a unit test proving that the bug is fixed.
diff --git a/dependencies.list b/dependencies.list
index 538519aa4d..857165a0d4 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,7 +1,7 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=1.3.0
-REALM_SYNC_SHA256=0572417435b92e3a9f7de5bd71ed00ca5d4ed24813afeffc7e4e7b7510a9f449
+REALM_SYNC_VERSION=1.3.2
+REALM_SYNC_SHA256=be79d334ca8d87785a91fa5d68264bc62de49271936d5c19b6473f34cd47f9f0
 
 # Object Server Release used by Integration tests
 # `realm` is stable releases, `realm-testing` is developer builds.
diff --git a/examples/gradle/wrapper/gradle-wrapper.properties b/examples/gradle/wrapper/gradle-wrapper.properties
index c7fdbdb551..ec898ce9bb 100644
--- a/examples/gradle/wrapper/gradle-wrapper.properties
+++ b/examples/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.4-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.4.1-all.zip
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index 79d9712d8a..a548e407de 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -1,5 +1,5 @@
 buildscript {
-    ext.kotlin_version = '1.1.0'
+    ext.kotlin_version = '1.1.1'
     repositories {
         jcenter()
         mavenCentral()
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
index 1e575420eb..fddc506432 100644
--- a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.4-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.4.1-all.zip
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index e330fabc4f..0c43fa77cc 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.4-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.4.1-all.zip
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.properties b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
index 767373dd38..b4fb3b92dc 100644
--- a/realm-annotations/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.4-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.4.1-all.zip
diff --git a/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java b/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
new file mode 100644
index 0000000000..4c79b44550
--- /dev/null
+++ b/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Annotation for defining a reverse relationship from one class to another. This annotation can
+ * only be added to a field of the type {@code RealmResults}.
+ *<pre>
+ * To expose reverse relationships for use, create a declaration as follows:
+ * {@code
+ *
+ * public class Person extends RealmObject {
+ *   String name;
+ *   Dog dog; // Normal relation
+ * }
+ *
+ * public class Dog extends RealmObject {
+ *   // This holds all Person objects with a relation to this Dog object (= linking objects)
+ *   \@LinkingObjects("dog")
+ *   final RealmResults&gt;Person&lt; owners = null;
+ * }
+ *
+ * // Find all Dogs with at least one owner named John
+ * realm.where(Dog.class).equalTo("owners.name", "John").findAll();
+ * }
+ * </pre>
+ * In the above example `Person` is related to `Dog` through the field `dog`.
+ * This in turn means that an implict reverse relationship exists between the class `Dog`
+ * and the class `Person`. This inverse relationship is made public and queryable by the `RealmResults`
+ * field annotated with `@LinkingObject`. This makes it possible to query properties of the dogs owner
+ * without having to manually maintain a "owner" field in the `Dog` class.
+ * <p>
+ * Linking objects have the following properties:
+ * <ul>
+ *     <li>The link is maintained by Realm and only works for managed objects.</li>
+ *     <li>They can be queried just like normal relation.</li>
+ *     <li>They can be followed just like normal relation.</li>
+ *     <li>They are ignored when doing a `copyToRealm().`</li>
+ *     <li>They are ignored when doing a `copyFromRealm().`</li>
+ *     <li>They are ignored when using the various `createObjectFromJson*` and `createAllFromJson*` methods.</li>
+ * </ul>
+ * <p>
+ * In addition, they have the following restrictions:
+ * <ul>
+ *     <li>{@literal @}Ignore takes precedence.  A {@literal @}LinkingObjects annotation on {@literal @}Ignore field will be ignored.</li>
+ *     <li>The annotated field cannot be {@literal @}Required.</li>
+ *     <li>The annotated field must be `final`.</li>
+ *     <li>The annotation argument (the name of the backlinked field) is required.</li>
+ *     <li>The annotation argument must be a simple field name.  It cannot contain periods ('.').</li>
+ *     <li>The annotated field must be of type `RealmResults&gt;T&lt;` where T is concrete class that extends `RealmModel`.</li>
+ * </ul>
+ *
+ * Note that when the source of the reverse reference (`dog` in the case above) is a `List`, there is a reverse
+ * reference for each forward reference, even if both forward references are to the same object.
+ * If the `Person` class above were defined as:
+ * {@code
+ *
+ * public class DogLover extends RealmObject {
+ *   String name;
+ *   List<Dog> dogs = new ArrayList<Dog>;
+ * }
+ * }
+ * then the following code executes without error
+ * {@code
+ *
+ * Dog fido = new Dog();
+ * DogLover john = new DogLover()
+ * john.dogs.add(fido);
+ * john.dogs.add(fido);
+ * assert john.dogs.size() == 2;
+ * assert fido.owners.size() == 2;
+ * }
+ */
+@Retention(RetentionPolicy.SOURCE)
+@Target(ElementType.FIELD)
+public @interface LinkingObjects {
+    /**
+     * The name of a field that contains a relation to an instance of the
+     * class containing this annotation.  If this argument is not provided
+     * the annotation processor will abort with an {@code IllegalArgumentException}.
+     */
+    String value() default "";
+}
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.properties b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
index e5aee03000..362711c0bf 100644
--- a/realm-transformer/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.4-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.4.1-all.zip
diff --git a/realm/gradle/wrapper/gradle-wrapper.properties b/realm/gradle/wrapper/gradle-wrapper.properties
index 1f2857b24f..31c57c1646 100644
--- a/realm/gradle/wrapper/gradle-wrapper.properties
+++ b/realm/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.4-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.4.1-all.zip
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.java
new file mode 100644
index 0000000000..16c49d43eb
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.java
@@ -0,0 +1,241 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.VariableElement;
+
+import io.realm.annotations.LinkingObjects;
+import io.realm.annotations.Required;
+
+/**
+ * A <b>Backlink</b> is an implicit backwards reference.  If field <code>sourceField</code> in instance <code>I</code>
+ * of type <code>SourceClass</code> holds a reference to instance <code>J</code> of type <code>TargetClass</code>,
+ * then a "backlink" is the automatically created reference from <code>J</code> to <code>I</code>.
+ * Backlinks are automatically created and destroyed when the forward references to which they correspond are
+ * created and destroyed.  This can dramatically reduce the complexity of client code.
+ * <p>
+ * To expose backinks for use, create a declaration as follows:
+ * <code>
+ * class TargetClass {
+ *     // ...
+ *     {@literal @}LinkingObjects("sourceField")
+ *     final RealmResults&lt;SourceClass&gt; targetField = null;
+ * }
+ * </code>.
+ * <p>
+ * The targetField, the field annotated with the {@literal @}LinkingObjects annotation must be final.
+ * Its type must be <code>RealmResults</code> whose generic argument is the <code>SourceClass</code>,
+ * the class with the <code>sourceField</code> that will hold the forward reference to an instance of
+ * <code>TargetClass</code>
+ * <p>
+ * The <code>sourceField</code> must be either of type <code>TargetClass</code>
+ * or <code>RealmList&lt;TargetClass&gt;</code>
+ * <p>
+ * In the code link direction is from the perspective of the link, not the backlink: the source is the
+ * instance to which the backlink points, the target is the instance holding the pointer.
+ * This is consistent with the use of terms in the Realm Core.
+ * <p>
+ * As should be obvious, from the declaration, backlinks are useful only on managed objects.
+ * An unmanaged Model object will have, as the value of its backlink field, the value with which
+ * the field is initialized (typically null).
+ */
+final class Backlink {
+    private final VariableElement backlink;
+
+    /**
+     * The fully-qualified name of the class containing the <code>targetField</code>,
+     * the field annotated with the {@literal @}LinkingObjects annotation.
+     */
+    private final String targetClass;
+
+    /**
+     * The name of the backlink field, in <code>targetClass</code>.
+     * A <code>RealmResults&lt;&gt;</code> field annotated with a {@literal @}LinkingObjects annotation.
+     */
+    private final String targetField;
+
+    /**
+     * The fully-qualified name of the class to which the backlinks, from <code>targetField</code>,
+     * point: The generic argument to the type of the <code>targetField</code>.
+     */
+    private final String sourceClass;
+
+    /**
+     * The name of the field, in <code>SourceClass</code> that creates the backlink.
+     * Making this field, in an instance I of <code>SourceClass</code>,
+     * a reference to an instance J of <code>TargetClass</code>
+     * will cause the <code>targetField</code> of J to contain a backlink to I.
+     */
+    private final String sourceField;
+
+
+    public Backlink(ClassMetaData clazz, VariableElement backlink) {
+        if ((null == clazz) || (null == backlink)) {
+            throw new NullPointerException(String.format("null parameter: %s, %s", clazz, backlink));
+        }
+
+        this.backlink = backlink;
+        this.targetClass = clazz.getFullyQualifiedClassName();
+        this.targetField = backlink.getSimpleName().toString();
+        this.sourceClass = Utils.getRealmResultsType(backlink);
+        this.sourceField = backlink.getAnnotation(LinkingObjects.class).value();
+    }
+
+    public String getTargetClass() {
+        return targetClass;
+    }
+
+    public String getTargetField() {
+        return targetField;
+    }
+
+    public String getSourceClass() {
+        return sourceClass;
+    }
+
+    public String getSourceField() {
+        return sourceField;
+    }
+
+    public String getTargetFieldType() {
+        return backlink.asType().toString();
+    }
+
+    public String getSimpleSourceClass() {
+        return Utils.getFieldTypeSimpleName(Utils.getGenericTypeForContainer(backlink));
+    }
+
+    /**
+     * Validate the source side of the backlink.
+     *
+     * @return true if the backlink source looks good.
+     */
+    public boolean validateSource() {
+        // A @LinkingObjects cannot be @Required
+        if (backlink.getAnnotation(Required.class) != null) {
+            Utils.error(String.format(
+                "The @LinkingObjects field \"%s.%s\" cannot be @Required.",
+                targetClass,
+                targetField));
+            return false;
+        }
+
+        // The annotation must have an argument, identifying the linked field
+        if ((sourceField == null) || sourceField.equals("")) {
+            Utils.error(String.format(
+                "The @LinkingObjects annotation for the field \"%s.%s\" must have a parameter identifying the link target.",
+                targetClass,
+                targetField));
+            return false;
+        }
+
+        // Using link syntax to try to reference a linked field is not possible.
+        if (sourceField.contains(".")) {
+            Utils.error(String.format(
+                "The parameter to the @LinkingObjects annotation for the field \"%s.%s\" contains a '.'.  The use of '.' to specify fields in referenced classes is not supported.",
+                targetClass,
+                targetField));
+            return false;
+        }
+
+        // The annotated element must be a RealmResult
+        if (!Utils.isRealmResults(backlink)) {
+            Utils.error(String.format(
+                "The field \"%s.%s\" is a \"%s\". Fields annotated with @LinkingObjects must be RealmResults.",
+                targetClass,
+                targetField,
+                backlink.asType()));
+            return false;
+        }
+
+        if (sourceClass == null) {
+            Utils.error(String.format(
+                "\"The field \"%s.%s\", annotated with @LinkingObjects, must specify a generic type.",
+                targetClass,
+                targetField));
+            return false;
+        }
+
+        // A @LinkingObjects field must be final
+        if (!backlink.getModifiers().contains(Modifier.FINAL)) {
+            Utils.error(String.format(
+                "A @LinkingObjects field \"%s.%s\" must be final.",
+                targetClass,
+                targetField));
+            return false;
+        }
+
+        return true;
+    }
+
+    public boolean validateTarget(ClassMetaData clazz) {
+        VariableElement field = clazz.getDeclaredField(sourceField);
+
+        if (field == null) {
+            Utils.error(String.format(
+                "Field \"%s\", the target of the @LinkedObjects annotation on field \"%s.%s\", does not exist in class \"%s\".",
+                sourceField,
+                targetClass,
+                targetField,
+                sourceClass));
+            return false;
+        }
+
+        String fieldType = field.asType().toString();
+        if (!(targetClass.equals(fieldType) || targetClass.equals(Utils.getRealmListType(field)))) {
+            Utils.error(String.format(
+                "Field \"%s.%s\", the target of the @LinkedObjects annotation on field \"%s.%s\", has type \"%s\" instead of \"%3$s\".",
+                sourceClass,
+                sourceField,
+                targetClass,
+                targetField,
+                fieldType));
+            return false;
+        }
+
+        return true;
+    }
+
+    @Override
+    public String toString() {
+        return "Backlink{" + sourceClass + "." + sourceField + " ==> " + targetClass + "." + targetField + "}";
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (null == o) { return false; }
+        if (this == o) { return true; }
+
+        if (!(o instanceof Backlink)) { return false; }
+        Backlink backlink = (Backlink) o;
+
+        return targetClass.equals(backlink.targetClass)
+            && targetField.equals(backlink.targetField)
+            && sourceClass.equals(backlink.sourceClass)
+            && sourceField.equals(backlink.sourceField);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = targetClass.hashCode();
+        result = 31 * result + targetField.hashCode();
+        result = 31 * result + sourceClass.hashCode();
+        result = 31 * result + sourceField.hashCode();
+        return result;
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index de43217461..9c187ca09a 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -18,6 +18,7 @@
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -39,6 +40,7 @@
 
 import io.realm.annotations.Ignore;
 import io.realm.annotations.Index;
+import io.realm.annotations.LinkingObjects;
 import io.realm.annotations.PrimaryKey;
 import io.realm.annotations.Required;
 
@@ -54,6 +56,7 @@
     private VariableElement primaryKey; // Reference to field used as primary key, if any.
     private List<VariableElement> fields = new ArrayList<VariableElement>(); // List of all fields in the class except those @Ignored.
     private List<VariableElement> indexedFields = new ArrayList<VariableElement>(); // list of all fields marked @Index.
+    private Set<Backlink> backlinks = new HashSet<Backlink>();
     private Set<VariableElement> nullableFields = new HashSet<VariableElement>(); // Set of fields which can be nullable
     private boolean containsToString;
     private boolean containsEquals;
@@ -70,11 +73,11 @@ public ClassMetaData(ProcessingEnvironment env, TypeElement clazz) {
         elements = env.getElementUtils();
         TypeMirror stringType = env.getElementUtils().getTypeElement("java.lang.String").asType();
         validPrimaryKeyTypes = Arrays.asList(
-                stringType,
-                typeUtils.getPrimitiveType(TypeKind.SHORT),
-                typeUtils.getPrimitiveType(TypeKind.INT),
-                typeUtils.getPrimitiveType(TypeKind.LONG),
-                typeUtils.getPrimitiveType(TypeKind.BYTE)
+            stringType,
+            typeUtils.getPrimitiveType(TypeKind.SHORT),
+            typeUtils.getPrimitiveType(TypeKind.INT),
+            typeUtils.getPrimitiveType(TypeKind.LONG),
+            typeUtils.getPrimitiveType(TypeKind.BYTE)
         );
 
         for (Element element : classType.getEnclosedElements()) {
@@ -91,6 +94,131 @@ public ClassMetaData(ProcessingEnvironment env, TypeElement clazz) {
         }
     }
 
+    @Override
+    public String toString() {
+        return "class " + getFullyQualifiedClassName();
+    }
+
+    public String getSimpleClassName() {
+        return className;
+    }
+
+    public String getPackageName() {
+        return packageName;
+    }
+
+    public String getFullyQualifiedClassName() {
+        return packageName + "." + className;
+    }
+
+    public List<VariableElement> getFields() {
+        return Collections.unmodifiableList(fields);
+    }
+
+    public Set<Backlink> getBacklinkFields() {
+        return backlinks;
+    }
+
+    public String getInternalGetter(String fieldName) {
+        return "realmGet$" + fieldName;
+    }
+
+    public String getInternalSetter(String fieldName) {
+        return "realmSet$" + fieldName;
+    }
+
+    public List<VariableElement> getIndexedFields() {
+        return indexedFields;
+    }
+
+    public boolean hasPrimaryKey() {
+        return primaryKey != null;
+    }
+
+    public VariableElement getPrimaryKey() {
+        return primaryKey;
+    }
+
+    public String getPrimaryKeyGetter() {
+        return getInternalGetter(primaryKey.getSimpleName().toString());
+    }
+
+    public boolean containsToString() {
+        return containsToString;
+    }
+
+    public boolean containsEquals() {
+        return containsEquals;
+    }
+
+    public boolean containsHashCode() {
+        return containsHashCode;
+    }
+
+    /**
+     * Checks if a VariableElement is nullable.
+     *
+     * @return {@code true} if a VariableElement is nullable type, {@code false} otherwise.
+     */
+    public boolean isNullable(VariableElement variableElement) {
+        return nullableFields.contains(variableElement);
+    }
+
+    /**
+     * Checks if a VariableElement is indexed.
+     *
+     * @param variableElement the element/field
+     * @return {@code true} if a VariableElement is indexed, {@code false} otherwise.
+     */
+    public boolean isIndexed(VariableElement variableElement) {
+        return indexedFields.contains(variableElement);
+    }
+
+    /**
+     * Checks if a VariableElement is a primary key.
+     *
+     * @param variableElement the element/field
+     * @return {@code true} if a VariableElement is primary key, {@code false} otherwise.
+     */
+    public boolean isPrimaryKey(VariableElement variableElement) {
+        if (primaryKey == null) {
+            return false;
+        }
+        return primaryKey.equals(variableElement);
+    }
+
+    /**
+     * Returns {@code true} if the class is considered to be a valid RealmObject class.
+     * RealmObject and Proxy classes also have the @RealmClass annotation but are not considered valid
+     * RealmObject classes.
+     */
+    public boolean isModelClass() {
+        String type = classType.toString();
+        if (type.equals("io.realm.DynamicRealmObject")) {
+            return false;
+        }
+        return (!type.endsWith(".RealmObject") && !type.endsWith("RealmProxy"));
+    }
+
+    /**
+     * Find the named field in this classes list of fields.
+     * This method is called only during backlink checking,
+     * so creating a map, even lazily, doesn't seem like a worthwhile optimization.
+     * If it gets used more widely, that decision should be revisited.
+     *
+     * @param fieldName The name of the sought field
+     * @return the named field's VariableElement, or null if not found
+     */
+    public VariableElement getDeclaredField(String fieldName) {
+        if (fieldName == null) { return null; }
+        for (VariableElement field : fields) {
+            if (field.getSimpleName().toString().equals(fieldName)) {
+                return field;
+            }
+        }
+        return null;
+    }
+
     /**
      * Builds the meta data structures for this class. Any errors or messages will be
      * posted on the provided Messager.
@@ -101,66 +229,59 @@ public boolean generate() {
         // Get the package of the class
         Element enclosingElement = classType.getEnclosingElement();
         if (!enclosingElement.getKind().equals(ElementKind.PACKAGE)) {
-            Utils.error("The RealmClass annotation does not support nested classes", classType);
+            Utils.error("The RealmClass annotation does not support nested classes.", classType);
             return false;
         }
 
         TypeElement parentElement = (TypeElement) Utils.getSuperClass(classType);
-        if (!parentElement.toString().equals("java.lang.Object") && !parentElement.toString().equals("io.realm.RealmObject")) {
-                Utils.error("Realm model classes must either extend RealmObject or implement RealmModel to be considered a valid model class", classType);
-                return false;
+        if (!parentElement.toString().equals("java.lang.Object") && !parentElement.toString().equals("io.realm.RealmObject"))
+        {
+            Utils.error("Valid model classes must either extend RealmObject or implement RealmModel.", classType);
+            return false;
         }
 
         PackageElement packageElement = (PackageElement) enclosingElement;
         packageName = packageElement.getQualifiedName().toString();
 
-        if (!categorizeClassElements()) return false;
-        if (!checkListTypes()) return  false;
-        if (!checkReferenceTypes()) return  false;
-        if (!checkDefaultConstructor()) return false;
-        if (!checkForFinalFields()) return false;
-        if (!checkForTransientFields()) return false;
-        if (!checkForVolatileFields()) return false;
+        if (!categorizeClassElements()) { return false; }
+        if (!checkListTypes()) { return false; }
+        if (!checkReferenceTypes()) { return false; }
+        if (!checkDefaultConstructor()) { return false; }
+        if (!checkForFinalFields()) { return false; }
+        if (!checkForTransientFields()) { return false; }
+        if (!checkForVolatileFields()) { return false; }
 
         return true; // Meta data was successfully generated
     }
 
-    private boolean checkForTransientFields() {
-        for (VariableElement field : fields) {
-            if (field.getModifiers().contains(Modifier.TRANSIENT)) {
-                Utils.error("Transient fields are not allowed. Class: " + className + ", Field: " +
-                        field.getSimpleName().toString());
-                return false;
-            }
-        }
-        return true;
-    }
+    // Iterate through all class elements and add them to the appropriate internal data structures.
+    // Returns true if all elements could be categorized and false otherwise.
+    private boolean categorizeClassElements() {
+        for (Element element : classType.getEnclosedElements()) {
+            ElementKind elementKind = element.getKind();
+            switch (elementKind) {
+                case CONSTRUCTOR:
+                    if (Utils.isDefaultConstructor(element)) { hasDefaultConstructor = true; }
+                    break;
 
-    private boolean checkForVolatileFields() {
-        for (VariableElement field : fields) {
-            if (field.getModifiers().contains(Modifier.VOLATILE)) {
-                Utils.error("Volatile fields are not allowed. Class: " + className + ", Field: " +
-                        field.getSimpleName().toString());
-                return false;
+                case FIELD:
+                    if (!categorizeField(element)) { return false; }
+                    break;
+
+                default:
             }
         }
-        return true;
-    }
 
-    private boolean checkForFinalFields() {
-        for (VariableElement field : fields) {
-            if (field.getModifiers().contains(Modifier.FINAL)) {
-                Utils.error("Final fields are not allowed. Class: " + className + ", Field: " +
-                        field.getSimpleName().toString());
-                return false;
-            }
+        if (fields.size() == 0) {
+            Utils.error(String.format("Class \"%s\" must contain at least 1 persistable field.", className));
         }
+
         return true;
     }
 
     private boolean checkListTypes() {
         for (VariableElement field : fields) {
-            if (Utils.isRealmList(field)) {
+            if (Utils.isRealmList(field) || Utils.isRealmResults(field)) {
                 // Check for missing generic (default back to Object)
                 if (Utils.getGenericTypeQualifiedName(field) == null) {
                     Utils.error("No generic type supplied for field", field);
@@ -173,8 +294,10 @@ private boolean checkListTypes() {
                 String genericCanonicalType = typeArguments.get(0).toString();
                 TypeElement typeElement = elements.getTypeElement(genericCanonicalType);
                 if (typeElement.getSuperclass().getKind() == TypeKind.NONE) {
-                    Utils.error("Only concrete Realm classes are allowed in RealmLists. Neither " +
-                            "interfaces nor abstract classes can be used.", field);
+                    Utils.error(
+                        "Only concrete Realm classes are allowed in RealmLists. "
+                            + "Neither interfaces nor abstract classes are allowed.",
+                        field);
                     return false;
                 }
             }
@@ -189,8 +312,10 @@ private boolean checkReferenceTypes() {
                 // Check that the referenced type is a concrete class and not an interface
                 TypeElement typeElement = elements.getTypeElement(field.asType().toString());
                 if (typeElement.getSuperclass().getKind() == TypeKind.NONE) {
-                    Utils.error("Only concrete Realm classes can be referenced in model classes. " +
-                            "Neither interfaces nor abstract classes can be used.", field);
+                    Utils.error(
+                        "Only concrete Realm classes can be referenced from model classes. "
+                            + "Neither interfaces nor abstract classes are allowed.",
+                        field);
                     return false;
                 }
             }
@@ -199,201 +324,170 @@ private boolean checkReferenceTypes() {
         return true;
     }
 
-
-
     // Report if the default constructor is missing
     private boolean checkDefaultConstructor() {
         if (!hasDefaultConstructor) {
-            Utils.error("A default public constructor with no argument must be declared in " + className + " if a custom constructor is declared.");
+            Utils.error(String.format(
+                "Class \"%s\" must declare a public constructor with no arguments if it contains custom constructors.",
+                className));
             return false;
         } else {
             return true;
         }
     }
 
-    // Iterate through all class elements and add them to the appropriate internal data structures.
-    // Returns true if all elements could be false if elements could not be categorized,
-    private boolean categorizeClassElements() {
-        for (Element element : classType.getEnclosedElements()) {
-            ElementKind elementKind = element.getKind();
-
-            if (elementKind.equals(ElementKind.FIELD)) {
-                VariableElement variableElement = (VariableElement) element;
+    private boolean checkForFinalFields() {
+        for (VariableElement field : fields) {
+            if (field.getModifiers().contains(Modifier.FINAL)) {
+                Utils.error(String.format(
+                    "Class \"%s\" contains illegal final field \"%s\".", className, field.getSimpleName().toString()));
+                return false;
+            }
+        }
+        return true;
+    }
 
-                Set<Modifier> modifiers = variableElement.getModifiers();
-                if (modifiers.contains(Modifier.STATIC)) {
-                    continue; // completely ignore any static fields
-                }
+    private boolean checkForTransientFields() {
+        for (VariableElement field : fields) {
+            if (field.getModifiers().contains(Modifier.TRANSIENT)) {
+                Utils.error(String.format(
+                    "Class \"%s\" contains illegal transient field \"%s\".",
+                    className,
+                    field.getSimpleName().toString()));
+                return false;
+            }
+        }
+        return true;
+    }
 
-                if (variableElement.getAnnotation(Ignore.class) != null) {
-                    continue;
-                }
+    private boolean checkForVolatileFields() {
+        for (VariableElement field : fields) {
+            if (field.getModifiers().contains(Modifier.VOLATILE)) {
+                Utils.error(String.format(
+                    "Class \"%s\" contains illegal volatile field \"%s\".",
+                    className,
+                    field.getSimpleName().toString()));
+                return false;
+            }
+        }
+        return true;
+    }
 
-                if (variableElement.getAnnotation(Index.class) != null) {
-                    // The field has the @Index annotation. It's only valid for column types:
-                    // STRING, DATE, INTEGER, BOOLEAN
-                    String elementTypeCanonicalName = variableElement.asType().toString();
-                    String columnType = Constants.JAVA_TO_COLUMN_TYPES.get(elementTypeCanonicalName);
-                    if (columnType != null && (columnType.equals("RealmFieldType.STRING") ||
-                            columnType.equals("RealmFieldType.DATE") ||
-                            columnType.equals("RealmFieldType.INTEGER") ||
-                            columnType.equals("RealmFieldType.BOOLEAN"))) {
-                        indexedFields.add(variableElement);
-                    } else {
-                        Utils.error("@Index is not applicable to this field " + element + ".");
-                        return false;
-                    }
-                }
+    private boolean categorizeField(Element element) {
+        VariableElement variableElement = (VariableElement) element;
 
-                if (variableElement.getAnnotation(Required.class) == null) {
-                    // The field doesn't have the @Required annotation.
-                    // Without @Required annotation, boxed types/RealmObject/Date/String/bytes should be added to
-                    // nullableFields.
-                    // RealmList and Primitive types are NOT nullable always. @Required annotation is not supported.
-                    if (!Utils.isPrimitiveType(variableElement) && !Utils.isRealmList(variableElement)) {
-                        nullableFields.add(variableElement);
-                    }
-                } else {
-                    // The field has the @Required annotation
-                    if (Utils.isPrimitiveType(variableElement)) {
-                        Utils.error("@Required is not needed for field " + element +
-                                " with the type " + element.asType());
-                    } else if (Utils.isRealmList(variableElement)) {
-                        Utils.error("@Required is invalid for field " + element +
-                                " with the type " + element.asType());
-                    } else if (Utils.isRealmModel(variableElement)) {
-                        Utils.error("@Required is invalid for field " + element +
-                                " with the type " + element.asType());
-                    } else {
-                        // Should never get here - user should remove @Required
-                        if (nullableFields.contains(variableElement)) {
-                            Utils.error("Annotated field " + element + " with type " + element.asType() +
-                                    " has been added to the nullableFields before. Consider to remove @Required.");
-                        }
-                    }
-                }
+        // completely ignore any static fields
+        if (variableElement.getModifiers().contains(Modifier.STATIC)) { return true; }
 
-                if (variableElement.getAnnotation(PrimaryKey.class) != null) {
-                    // The field has the @PrimaryKey annotation. It is only valid for
-                    // String, short, int, long and must only be present one time
-                    if (primaryKey != null) {
-                        Utils.error(String.format("@PrimaryKey cannot be defined more than once. It was found here \"%s\" and here \"%s\"",
-                                primaryKey.getSimpleName().toString(),
-                                variableElement.getSimpleName().toString()));
-                        return false;
-                    }
-
-                    TypeMirror fieldType = variableElement.asType();
-                    if (!isValidPrimaryKeyType(fieldType)) {
-                        Utils.error("\"" + variableElement.getSimpleName().toString() + "\" is not allowed as primary key. See @PrimaryKey for allowed types.");
-                        return false;
-                    }
-
-                    primaryKey = variableElement;
-
-                    // Also add as index. All types of primary key can be indexed.
-                    if (!indexedFields.contains(variableElement)) {
-                        indexedFields.add(variableElement);
-                    }
-                }
+        if (variableElement.getAnnotation(Ignore.class) != null) { return true; }
 
-                fields.add(variableElement);
-            } else if (elementKind.equals(ElementKind.CONSTRUCTOR)) {
-                hasDefaultConstructor =  hasDefaultConstructor || Utils.isDefaultConstructor(element);
+        if (variableElement.getAnnotation(Index.class) != null) {
+            if (!categorizeIndexField(element, variableElement)) { return false; }
+        }
 
+        if (variableElement.getAnnotation(Required.class) != null) {
+            categorizeRequiredField(element, variableElement);
+        } else {
+            // The field doesn't have the @Required annotation.
+            // Without @Required annotation, boxed types/RealmObject/Date/String/bytes should be added to
+            // nullableFields.
+            // RealmList and Primitive types are NOT nullable always. @Required annotation is not supported.
+            if (!Utils.isPrimitiveType(variableElement) && !Utils.isRealmList(variableElement)) {
+                nullableFields.add(variableElement);
             }
         }
 
-        if (fields.size() == 0) {
-            Utils.error(className + " must contain at least 1 persistable field");
+        if (variableElement.getAnnotation(PrimaryKey.class) != null) {
+            if (!categorizePrimaryKeyField(variableElement)) { return false; }
         }
 
-        return true;
-    }
+        // Check @LinkingObjects last since it is not allowed to be either @Index, @Required or @PrimaryKey
+        if (variableElement.getAnnotation(LinkingObjects.class) != null) {
+            return categorizeBacklinkField(variableElement);
+        }
 
-    public String getSimpleClassName() {
-        return className;
+        // Standard field that appear valid (more fine grained checks might fail later).
+        fields.add(variableElement);
+
+        return true;
     }
 
-    /**
-     * Returns {@code true} if the class is considered to be a valid RealmObject class.
-     * RealmObject and Proxy classes also have the @RealmClass annotation but are not considered valid
-     * RealmObject classes.
-     */
-    public boolean isModelClass() {
-        String type = classType.toString();
-        if (type.equals("io.realm.DynamicRealmObject")) {
+    private boolean categorizeIndexField(Element element, VariableElement variableElement) {
+        // The field has the @Index annotation. It's only valid for column types:
+        // STRING, DATE, INTEGER, BOOLEAN
+        String elementTypeCanonicalName = variableElement.asType().toString();
+        String columnType = Constants.JAVA_TO_COLUMN_TYPES.get(elementTypeCanonicalName);
+        if (columnType != null &&
+            (columnType.equals("RealmFieldType.STRING") ||
+                columnType.equals("RealmFieldType.DATE") ||
+                columnType.equals("RealmFieldType.INTEGER") ||
+                columnType.equals("RealmFieldType.BOOLEAN")))
+        {
+            indexedFields.add(variableElement);
+        } else {
+            Utils.error(String.format("Field \"%s\" of type \"%s\" cannot be an @Index.", element, element.asType()));
             return false;
         }
-        return (!type.endsWith(".RealmObject") && !type.endsWith("RealmProxy"));
-    }
-
-    public String getPackageName() {
-        return packageName;
-    }
-
-    public String getFullyQualifiedClassName() {
-        return packageName + "." + className;
-    }
 
-    public List<VariableElement> getFields() {
-        return fields;
+        return true;
     }
 
-    public String getGetter(String fieldName) {
-        return "realmGet$" + fieldName;
+    // The field has the @Required annotation
+    private void categorizeRequiredField(Element element, VariableElement variableElement) {
+        if (Utils.isPrimitiveType(variableElement)) {
+            Utils.error(String.format(
+                "@Required annotation is unnecessary for primitive field \"%s\".", element));
+        } else if (Utils.isRealmList(variableElement) || Utils.isRealmModel(variableElement)) {
+            Utils.error(String.format(
+                "Field \"%s\" with type \"%s\" cannot be @Required.", element, element.asType()));
+        } else {
+            // Should never get here - user should remove @Required
+            if (nullableFields.contains(variableElement)) {
+                Utils.error(String.format(
+                    "Field \"%s\" with type \"%s\" appears to be nullable. Consider removing @Required.",
+                    element,
+                    element.asType()));
+            }
+        }
     }
 
-    public String getSetter(String fieldName) {
-        return "realmSet$" + fieldName;
-    }
+    // The field has the @PrimaryKey annotation. It is only valid for
+    // String, short, int, long and must only be present one time
+    private boolean categorizePrimaryKeyField(VariableElement variableElement) {
+        if (primaryKey != null) {
+            Utils.error(String.format(
+                "A class cannot have more than one @PrimaryKey. Both \"%s\" and \"%s\" are annotated as @PrimaryKey.",
+                primaryKey.getSimpleName().toString(),
+                variableElement.getSimpleName().toString()));
+            return false;
+        }
 
-    public List<VariableElement> getIndexedFields() {
-        return indexedFields;
-    }
+        TypeMirror fieldType = variableElement.asType();
+        if (!isValidPrimaryKeyType(fieldType)) {
+            Utils.error(String.format(
+                "Field \"%s\" with type \"%s\" cannot be used as primary key. See @PrimaryKey for legal types.",
+                variableElement.getSimpleName().toString(),
+                fieldType));
+            return false;
+        }
 
-    public boolean hasPrimaryKey() {
-        return primaryKey != null;
-    }
+        primaryKey = variableElement;
 
-    public VariableElement getPrimaryKey() {
-        return primaryKey;
-    }
+        // Also add as index. All types of primary key can be indexed.
+        if (!indexedFields.contains(variableElement)) {
+            indexedFields.add(variableElement);
+        }
 
-    public String getPrimaryKeyGetter() {
-        return getGetter(primaryKey.getSimpleName().toString());
+        return true;
     }
 
-    /**
-     * Checks if a VariableElement is nullable.
-     *
-     * @return {@code true} if a VariableElement is nullable type, {@code false} otherwise.
-     */
-    public boolean isNullable(VariableElement variableElement) {
-        return nullableFields.contains(variableElement);
-    }
+    private boolean categorizeBacklinkField(VariableElement variableElement) {
+        Backlink backlink = new Backlink(this, variableElement);
+        if (!backlink.validateSource()) { return false; }
 
-    /**
-     * Checks if a VariableElement is indexed.
-     *
-     * @param variableElement the element/field
-     * @return {@code true} if a VariableElement is indexed, {@code false} otherwise.
-     */
-    public boolean isIndexed(VariableElement variableElement) {
-        return indexedFields.contains(variableElement);
-    }
+        backlinks.add(backlink);
 
-    /**
-     * Checks if a VariableElement is a primary key.
-     *
-     * @param variableElement the element/field
-     * @return {@code true} if a VariableElement is primary key, {@code false} otherwise.
-     */
-    public boolean isPrimaryKey(VariableElement variableElement) {
-        if (primaryKey == null) {
-            return false;
-        }
-        return primaryKey.equals(variableElement);
+        return true;
     }
 
     private boolean isValidPrimaryKeyType(TypeMirror type) {
@@ -404,17 +498,5 @@ private boolean isValidPrimaryKeyType(TypeMirror type) {
         }
         return false;
     }
-
-    public boolean containsToString() {
-        return containsToString;
-    }
-
-    public boolean containsEquals() {
-        return containsEquals;
-    }
-
-    public boolean containsHashCode() {
-        return containsHashCode;
-    }
 }
 
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
index 791f81df9c..fc6745ed5f 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
@@ -33,6 +33,8 @@
     static final String STATEMENT_EXCEPTION_PRIMARY_KEY_CANNOT_BE_CHANGED =
             "throw new io.realm.exceptions.RealmException(\"Primary key field '%s' cannot be changed after object" +
                     " was created.\")";
+    static final String STATEMENT_EXCEPTION_ILLEGAL_JSON_LOAD =
+        "throw new io.realm.exceptions.RealmException(\"\\\"%s\\\" field \\\"%s\\\" cannot be loaded from json\")";
 
     static final Map<String, String> JAVA_TO_REALM_TYPES;
     static {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
index 1ace559402..f6fda5eb7e 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
@@ -16,12 +16,20 @@
 
 package io.realm.processor;
 
-import io.realm.annotations.RealmModule;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.annotation.processing.RoundEnvironment;
-import javax.lang.model.element.*;
-import java.util.*;
+import io.realm.annotations.RealmModule;
 
 /**
  * Utility class for holding metadata for the Realm modules.
@@ -29,14 +37,12 @@
 public class ModuleMetaData {
 
     private final Set<ClassMetaData> availableClasses;
-    private final RoundEnvironment env;
     private Map<String, Set<ClassMetaData>> modules = new HashMap<String, Set<ClassMetaData>>();
     private Map<String, Set<ClassMetaData>> libraryModules = new HashMap<String, Set<ClassMetaData>>();
     private Map<String, ClassMetaData> classMetaData = new HashMap<String, ClassMetaData>(); // <FullyQualifiedClassName, ClassMetaData>
     private boolean shouldCreateDefaultModule;
 
-    public ModuleMetaData(RoundEnvironment env, Set<ClassMetaData> availableClasses) {
-        this.env = env;
+    public ModuleMetaData(Set<ClassMetaData> availableClasses) {
         this.availableClasses = availableClasses;
         for (ClassMetaData classMetaData : availableClasses) {
             this.classMetaData.put(classMetaData.getFullyQualifiedClassName(), classMetaData);
@@ -48,10 +54,10 @@ public ModuleMetaData(RoundEnvironment env, Set<ClassMetaData> availableClasses)
      *
      * @return True if meta data was correctly created and processing can continue, false otherwise.
      */
-    public boolean generate(ProcessingEnvironment processingEnv) {
+    public boolean generate(Set<? extends Element> clazzes) {
 
         // Check that modules are setup correctly
-        for (Element classElement : env.getElementsAnnotatedWith(RealmModule.class)) {
+        for (Element classElement : clazzes) {
             String classSimpleName = classElement.getSimpleName().toString();
 
             // Check that the annotation is only applied to a class
@@ -115,6 +121,7 @@ public boolean generate(ProcessingEnvironment processingEnv) {
 
     // Detour needed to access the class elements in the array
     // See http://blog.retep.org/2009/02/13/getting-class-values-from-annotations-in-an-annotationprocessor/
+    @SuppressWarnings("unchecked")
     private Set<String> getClassMetaDataFromModule(Element classElement) {
         AnnotationMirror annotationMirror = getAnnotationMirror(classElement);
         AnnotationValue annotationValue = getAnnotationValue(annotationMirror);
@@ -129,6 +136,7 @@ public boolean generate(ProcessingEnvironment processingEnv) {
 
     // Work-around for asking for a Class primitive array which would otherwise throw a TypeMirrorException
     // https://community.oracle.com/thread/1184190
+    @SuppressWarnings("unchecked")
     private boolean hasCustomClassList(Element classElement) {
         AnnotationMirror annotationMirror = getAnnotationMirror(classElement);
         AnnotationValue annotationValue = getAnnotationValue(annotationMirror);
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
index af9402ab21..26906a0e7f 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
@@ -150,6 +150,13 @@ public static void emitFillJavaTypeWithJsonValue(String interfaceName, String se
         }
     }
 
+    public static void emitIllegalJsonValueException(String fieldType, String fieldName, JavaWriter writer)
+        throws IOException {
+        writer.beginControlFlow("if (json.has(\"%s\"))", fieldName);
+        writer.emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_JSON_LOAD, fieldType, fieldName);
+        writer.endControlFlow();
+    }
+
     public static void emitFillRealmObjectWithJsonValue(String interfaceName, String setter, String fieldName, String
             qualifiedFieldType, String proxyClass, JavaWriter writer) throws IOException {
         writer
@@ -185,7 +192,7 @@ public static void emitFillRealmListWithJsonValue(String interfaceName, String g
 
     public static void emitFillJavaTypeFromStream(String interfaceName, ClassMetaData metaData, String fieldName, String
             fieldType, JavaWriter writer) throws IOException {
-        String setter = metaData.getSetter(fieldName);
+        String setter = metaData.getInternalSetter(fieldName);
         boolean isPrimaryKey = false;
         if (metaData.hasPrimaryKey() && metaData.getPrimaryKey().getSimpleName().toString().equals(fieldName)) {
             isPrimaryKey = true;
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index 59f14327d7..fb3562963c 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -17,10 +17,10 @@
 package io.realm.processor;
 
 import java.io.IOException;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
-import java.util.TreeSet;
 
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
@@ -31,6 +31,7 @@
 import javax.lang.model.element.TypeElement;
 
 import io.realm.annotations.RealmClass;
+import io.realm.annotations.RealmModule;
 
 /**
  * The RealmProcessor is responsible for creating the plumbing that connects the RealmObjects to a Realm. The process
@@ -122,12 +123,17 @@
         "io.realm.annotations.Required"
 })
 public class RealmProcessor extends AbstractProcessor {
-
     // Don't consume annotations. This allows 3rd party annotation processors to run.
     private static final boolean CONSUME_ANNOTATIONS = false;
 
-    Set<ClassMetaData> classesToValidate = new HashSet<ClassMetaData>();
+
+    // List of all fields maintained by Realm (RealmResults)
+    private final Set<ClassMetaData> classesToValidate = new HashSet<ClassMetaData>();
+    // List of backlinks
+    private final Set<Backlink> backlinksToValidate = new HashSet<Backlink>();
+
     private boolean hasProcessedModules = false;
+    private int round;
 
     @Override public SourceVersion getSupportedSourceVersion() {
         return SourceVersion.latestSupported();
@@ -135,42 +141,55 @@
 
     @Override
     public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-        // Don't run this processor in subsequent runs. We created everything in the first one.
-        if (hasProcessedModules) {
-            return CONSUME_ANNOTATIONS;
+        round++;
+
+        if (round == 0) {
+            RealmVersionChecker updateChecker = RealmVersionChecker.getInstance(processingEnv);
+            updateChecker.executeRealmVersionUpdate();
+        }
+
+        if (roundEnv.errorRaised()) { return true; }
+
+        if (!hasProcessedModules) {
+            Utils.initialize(processingEnv);
+
+            if (!processAnnotations(roundEnv)) { return true; }
+
+            hasProcessedModules = true;
+            if (!processModules(roundEnv)) { return true; }
         }
-        RealmVersionChecker updateChecker = RealmVersionChecker.getInstance(processingEnv);
-        updateChecker.executeRealmVersionUpdate();
 
-        Utils.initialize(processingEnv);
+        if (roundEnv.processingOver()) {
+            if (!validateBacklinks()) { return true; }
+        }
 
-        Set<String> packages = new TreeSet<String>();
+        return CONSUME_ANNOTATIONS;
+    }
 
-        // Create all proxy classes
+    // Create all proxy classes
+    private boolean processAnnotations(RoundEnvironment roundEnv) {
         for (Element classElement : roundEnv.getElementsAnnotatedWith(RealmClass.class)) {
 
             // The class must either extend RealmObject or implement RealmModel
             if (!Utils.isImplementingMarkerInterface(classElement)) {
-                Utils.error("A RealmClass annotated object must implement RealmModel or derive from RealmObject", classElement);
+                Utils.error("A RealmClass annotated object must implement RealmModel or derive from RealmObject.", classElement);
+                return false;
             }
 
             // Check the annotation was applied to a Class
             if (!classElement.getKind().equals(ElementKind.CLASS)) {
-                Utils.error("The RealmClass annotation can only be applied to classes", classElement);
-                return true; // Abort processing by claiming all annotations
+                Utils.error("The RealmClass annotation can only be applied to classes.", classElement);
+                return false;
             }
 
             ClassMetaData metadata = new ClassMetaData(processingEnv, (TypeElement) classElement);
-            if (!metadata.isModelClass()) {
-                continue;
-            }
+            if (!metadata.isModelClass()) { continue; }
+
             Utils.note("Processing class " + metadata.getSimpleClassName());
-            boolean success = metadata.generate();
-            if (!success) {
-                return true;
-            }
+            if (!metadata.generate()) { return false; }
+
             classesToValidate.add(metadata);
-            packages.add(metadata.getPackageName());
+            backlinksToValidate.addAll(metadata.getBacklinkFields());
 
             RealmProxyInterfaceGenerator interfaceGenerator = new RealmProxyInterfaceGenerator(processingEnv, metadata);
             try {
@@ -189,17 +208,13 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
             }
         }
 
-        hasProcessedModules = true;
-        processModules(roundEnv);
-
-        return CONSUME_ANNOTATIONS;
+        return true;
     }
 
     // Returns true if modules was processed successfully, false otherwise
     private boolean processModules(RoundEnvironment roundEnv) {
-
-        ModuleMetaData moduleMetaData = new ModuleMetaData(roundEnv, classesToValidate);
-        if (!moduleMetaData.generate(processingEnv)) {
+        ModuleMetaData moduleMetaData = new ModuleMetaData(classesToValidate);
+        if (!moduleMetaData.generate(roundEnv.getElementsAnnotatedWith(RealmModule.class))) {
             return false;
         }
 
@@ -245,4 +260,32 @@ private boolean createMediator(String simpleModuleName, Set<ClassMetaData> modul
 
         return true;
     }
+
+    // Because library classes are processed separately, there is no guarantee
+    // that this method can see all of the classes necessary to completely validate
+    // all of the backlinks.  If it can find the fully-qualified class, though,
+    // and prove that the class either does not contain the necessary field, or
+    // that it does contain the field, but the field is of the wrong type, it can
+    // catch the error at compile time.
+    // Give all failure messages before failing
+    private boolean validateBacklinks() {
+        boolean allValid = true;
+
+        Map<String, ClassMetaData> realmClasses = new HashMap<String, ClassMetaData>(classesToValidate.size());
+        for (ClassMetaData classData: classesToValidate) {
+            realmClasses.put(classData.getFullyQualifiedClassName(), classData);
+        }
+
+        for (Backlink backlink: backlinksToValidate) {
+            ClassMetaData clazz = realmClasses.get(backlink.getSourceClass());
+
+            // If the class is not here it might be part of some other compilation unit.
+            if (clazz == null) { continue; }
+
+            // If the class is here, we can validate it.
+            if (!backlink.validateTarget(clazz) && allValid) { allValid = false; }
+        }
+
+        return allValid;
+    }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 6aa0cf7e0e..2a83073af5 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -22,9 +22,10 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.EnumSet;
-import java.util.List;
+import java.util.Set;
 
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Modifier;
@@ -34,8 +35,10 @@
 import javax.tools.JavaFileObject;
 
 public class RealmProxyClassGenerator {
-    private ProcessingEnvironment processingEnvironment;
-    private ClassMetaData metadata;
+    private static final String BACKLINKS_FIELD_EXTENSION = "Backlinks";
+
+    private final ProcessingEnvironment processingEnvironment;
+    private final ClassMetaData metadata;
     private final String simpleClassName;
     private final String qualifiedClassName;
     private final String interfaceName;
@@ -59,7 +62,7 @@ public void generate() throws IOException, UnsupportedOperationException {
         writer.setIndent(Constants.INDENT);
 
         writer.emitPackage(Constants.REALM_PACKAGE_NAME)
-                .emitEmptyLine();
+            .emitEmptyLine();
 
         ArrayList<String> imports = new ArrayList<String>();
         imports.add("android.annotation.TargetApi");
@@ -89,9 +92,8 @@ public void generate() throws IOException, UnsupportedOperationException {
         imports.add("org.json.JSONException");
         imports.add("org.json.JSONArray");
 
-        Collections.sort(imports);
-        writer.emitImports(imports);
-        writer.emitEmptyLine();
+        writer.emitImports(imports)
+            .emitEmptyLine();
 
         // Begin the class definition
         writer.beginType(
@@ -107,8 +109,10 @@ public void generate() throws IOException, UnsupportedOperationException {
 
         emitClassFields(writer);
         emitConstructor(writer);
+
         emitInjectContextMethod(writer);
-        emitAccessors(writer);
+        emitPersistedFieldAccessors(writer);
+        emitBacklinkFieldAccessors(writer);
         emitCreateRealmObjectSchemaMethod(writer);
         emitInitTableMethod(writer);
         emitValidateTableMethod(writer);
@@ -160,17 +164,17 @@ private void emitColumnIndicesClass(JavaWriter writer) throws IOException {
             final String columnName = variableElement.getSimpleName().toString();
             final String columnIndexVarName = columnIndexVarName(variableElement);
             writer.emitStatement("this.%s = getValidColumnIndex(path, table, \"%s\", \"%s\")",
-                    columnIndexVarName, simpleClassName, columnName);
-            writer.emitStatement("indicesMap.put(\"%s\", this.%s)", columnName, columnIndexVarName);
+                    columnIndexVarName, simpleClassName, columnName)
+                .emitStatement("indicesMap.put(\"%s\", this.%s)", columnName, columnIndexVarName);
         }
-        writer.emitEmptyLine();
-        writer.emitStatement("setIndicesMap(indicesMap)");
-        writer.endConstructor();
-        writer.emitEmptyLine();
+        writer.emitEmptyLine()
+            .emitStatement("setIndicesMap(indicesMap)");
+        writer.endConstructor()
+            .emitEmptyLine();
 
         // copyColumnInfoFrom method
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
+        writer.emitAnnotation("Override")
+            .beginMethod(
                 "void",                      // return type
                 "copyColumnInfoFrom",        // method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.FINAL), // modifiers
@@ -182,15 +186,15 @@ private void emitColumnIndicesClass(JavaWriter writer) throws IOException {
             for (VariableElement variableElement : metadata.getFields()) {
                 writer.emitStatement("this.%1$s = otherInfo.%1$s", columnIndexVarName(variableElement));
             }
-            writer.emitEmptyLine();
-            writer.emitStatement("setIndicesMap(otherInfo.getIndicesMap())");
+            writer.emitEmptyLine()
+                .emitStatement("setIndicesMap(otherInfo.getIndicesMap())");
         }
-        writer.endMethod();
-        writer.emitEmptyLine();
+        writer.endMethod()
+            .emitEmptyLine();
 
         // clone method
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
+        writer.emitAnnotation("Override")
+            .beginMethod(
                 columnInfoClassName(),       // return type
                 "clone",                     // method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.FINAL)) // modifiers
@@ -203,8 +207,8 @@ private void emitColumnIndicesClass(JavaWriter writer) throws IOException {
     }
 
     private void emitClassFields(JavaWriter writer) throws IOException {
-        writer.emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE));
-        writer.emitField("ProxyState<" + qualifiedClassName + ">", "proxyState", EnumSet.of(Modifier.PRIVATE));
+        writer.emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE))
+            .emitField("ProxyState<" + qualifiedClassName + ">", "proxyState", EnumSet.of(Modifier.PRIVATE));
 
         for (VariableElement variableElement : metadata.getFields()) {
             if (Utils.isRealmList(variableElement)) {
@@ -213,243 +217,283 @@ private void emitClassFields(JavaWriter writer) throws IOException {
             }
         }
 
-        writer.emitField("List<String>", "FIELD_NAMES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
-        writer.beginInitializer(true);
-        writer.emitStatement("List<String> fieldNames = new ArrayList<String>()");
+        for (Backlink backlink : metadata.getBacklinkFields()) {
+            writer.emitField(
+                backlink.getTargetFieldType(),
+                backlink.getTargetField() + BACKLINKS_FIELD_EXTENSION,
+                EnumSet.of(Modifier.PRIVATE));
+        }
+
+        writer.emitField("List<String>", "FIELD_NAMES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL))
+            .beginInitializer(true)
+            .emitStatement("List<String> fieldNames = new ArrayList<String>()");
         for (VariableElement field : metadata.getFields()) {
             writer.emitStatement("fieldNames.add(\"%s\")", field.getSimpleName().toString());
         }
-        writer.emitStatement("FIELD_NAMES = Collections.unmodifiableList(fieldNames)");
-        writer.endInitializer();
-        writer.emitEmptyLine();
+        writer.emitStatement("FIELD_NAMES = Collections.unmodifiableList(fieldNames)")
+            .endInitializer()
+            .emitEmptyLine();
     }
 
     private void emitConstructor(JavaWriter writer) throws IOException {
         // FooRealmProxy(ColumnInfo)
-        writer.beginConstructor(EnumSet.noneOf(Modifier.class));
-        writer.emitStatement("proxyState.setConstructionFinished()");
-        writer.endConstructor();
-        writer.emitEmptyLine();
+        writer.beginConstructor(EnumSet.noneOf(Modifier.class))
+            .emitStatement("proxyState.setConstructionFinished()")
+            .endConstructor()
+            .emitEmptyLine();
     }
 
-    private void emitAccessors(final JavaWriter writer) throws IOException {
+    private void emitPersistedFieldAccessors(final JavaWriter writer) throws IOException {
         for (final VariableElement field : metadata.getFields()) {
             final String fieldName = field.getSimpleName().toString();
             final String fieldTypeCanonicalName = field.asType().toString();
 
             if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
-                /**
-                 * Primitives and boxed types
-                 */
-                final String realmType = Constants.JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
-
-                // Getter
-                writer.emitAnnotation("SuppressWarnings", "\"cast\"");
-                writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
-                writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
-
-                // For String and bytes[], null value will be returned by JNI code. Try to save one JNI call here.
-                if (metadata.isNullable(field) && !Utils.isString(field) && !Utils.isByteArray(field)) {
-                    writer.beginControlFlow("if (proxyState.getRow$realm().isNull(%s))", fieldIndexVariableReference(field));
-                    writer.emitStatement("return null");
-                    writer.endControlFlow();
-                }
+                emitPrimitiveType(writer, field, fieldName, fieldTypeCanonicalName);
+            } else if (Utils.isRealmModel(field)) {
+                emitRealmModel(writer, field, fieldName, fieldTypeCanonicalName);
+            } else if (Utils.isRealmList(field)) {
+                emitRealmList(writer, field, fieldName, fieldTypeCanonicalName);
+            } else {
+                throw new UnsupportedOperationException(String.format(
+                    "Field \"%s\" of type \"%s\" is not supported.", fieldName, fieldTypeCanonicalName));
+            }
 
-                // For Boxed types, this should be the corresponding primitive types. Others remain the same.
-                String castingBackType;
-                if (Utils.isBoxedType(fieldTypeCanonicalName)) {
-                    Types typeUtils = processingEnvironment.getTypeUtils();
-                    castingBackType = typeUtils.unboxedType(field.asType()).toString();
-                } else {
-                    castingBackType = fieldTypeCanonicalName;
+            writer.emitEmptyLine();
+        }
+    }
+
+    /**
+     * Primitives and boxed types
+     */
+    private void emitPrimitiveType(
+        JavaWriter writer,
+        final VariableElement field,
+        final String fieldName,
+        String fieldTypeCanonicalName) throws IOException
+    {
+        final String realmType = Constants.JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
+
+        // Getter
+        writer.emitAnnotation("Override");
+        writer.emitAnnotation("SuppressWarnings", "\"cast\"")
+            .beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
+            .emitStatement("proxyState.getRealm$realm().checkIfValid()");
+
+        // For String and bytes[], null value will be returned by JNI code. Try to save one JNI call here.
+        if (metadata.isNullable(field) && !Utils.isString(field) && !Utils.isByteArray(field)) {
+            writer.beginControlFlow("if (proxyState.getRow$realm().isNull(%s))", fieldIndexVariableReference(field))
+                .emitStatement("return null")
+                .endControlFlow();
+        }
+
+        // For Boxed types, this should be the corresponding primitive types. Others remain the same.
+        String castingBackType;
+        if (Utils.isBoxedType(fieldTypeCanonicalName)) {
+            Types typeUtils = processingEnvironment.getTypeUtils();
+            castingBackType = typeUtils.unboxedType(field.asType()).toString();
+        } else {
+            castingBackType = fieldTypeCanonicalName;
+        }
+        writer.emitStatement(
+            "return (%s) proxyState.getRow$realm().get%s(%s)",
+            castingBackType, realmType, fieldIndexVariableReference(field));
+        writer.endMethod()
+            .emitEmptyLine();
+
+        // Setter
+        writer.emitAnnotation("Override");
+        writer.beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
+        emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
+            @Override
+            public void emit(JavaWriter writer) throws IOException {
+                // set value as default value
+                writer.emitStatement("final Row row = proxyState.getRow$realm()");
+
+                if (metadata.isNullable(field)) {
+                    writer.beginControlFlow("if (value == null)")
+                        .emitStatement("row.getTable().setNull(%s, row.getIndex(), true)",
+                            fieldIndexVariableReference(field))
+                        .emitStatement("return")
+                        .endControlFlow();
+                } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
+                    writer.beginControlFlow("if (value == null)")
+                        .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
+                        .endControlFlow();
                 }
                 writer.emitStatement(
-                        "return (%s) proxyState.getRow$realm().get%s(%s)",
-                        castingBackType, realmType, fieldIndexVariableReference(field));
-                writer.endMethod();
-                writer.emitEmptyLine();
-
-                // Setter
-                writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-                emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
-                    @Override
-                    public void emit(JavaWriter writer) throws IOException {
-                        // set value as default value
-                        writer.emitStatement("final Row row = proxyState.getRow$realm()");
-
-                        if (metadata.isNullable(field)) {
-                            writer.beginControlFlow("if (value == null)")
-                                    .emitStatement("row.getTable().setNull(%s, row.getIndex(), true)",
-                                            fieldIndexVariableReference(field))
-                                    .emitStatement("return")
-                                .endControlFlow();
-                        } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
-                            writer.beginControlFlow("if (value == null)")
-                                    .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
-                                .endControlFlow();
-                        }
-                        writer.emitStatement(
-                                "row.getTable().set%s(%s, row.getIndex(), value, true)",
-                                realmType, fieldIndexVariableReference(field));
-                        writer.emitStatement("return");
-                    }
-                });
-                writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
-                // Although setting null value for String and bytes[] can be handled by the JNI code, we still generate the same code here.
-                // Compared with getter, null value won't trigger more native calls in setter which is relatively cheaper.
-                if (metadata.isPrimaryKey(field)) {
-                    // Primary key is not allowed to be changed after object created.
-                    writer.emitStatement(Constants.STATEMENT_EXCEPTION_PRIMARY_KEY_CANNOT_BE_CHANGED, fieldName);
-                } else {
-                    if (metadata.isNullable(field)) {
-                        writer.beginControlFlow("if (value == null)")
-                                .emitStatement("proxyState.getRow$realm().setNull(%s)", fieldIndexVariableReference(field))
-                                .emitStatement("return")
-                                .endControlFlow();
-                    } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
-                        // Same reason, throw IAE earlier.
-                        writer
-                                .beginControlFlow("if (value == null)")
-                                .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
-                                .endControlFlow();
-                    }
-                    writer.emitStatement(
-                            "proxyState.getRow$realm().set%s(%s, value)",
-                            realmType, fieldIndexVariableReference(field));
-                }
-                writer.endMethod();
-            } else if (Utils.isRealmModel(field)) {
-                /**
-                 * Links
-                 */
-
-                // Getter
-                writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
-                writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
-                writer.beginControlFlow("if (proxyState.getRow$realm().isNullLink(%s))", fieldIndexVariableReference(field));
-                        writer.emitStatement("return null");
-                        writer.endControlFlow();
-                writer.emitStatement("return proxyState.getRealm$realm().get(%s.class, proxyState.getRow$realm().getLink(%s), false, Collections.<String>emptyList())",
-                        fieldTypeCanonicalName, fieldIndexVariableReference(field));
-                writer.endMethod();
-                writer.emitEmptyLine();
-
-                // Setter
-                writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-                emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
-                    @Override
-                    public void emit(JavaWriter writer) throws IOException {
-                        // check excludeFields
-                        writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
-                                field.getSimpleName().toString())
-                                .emitStatement("return")
-                            .endControlFlow();
-                        writer.beginControlFlow("if (value != null && !RealmObject.isManaged(value))")
-                                .emitStatement("value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value)")
-                            .endControlFlow();
+                    "row.getTable().set%s(%s, row.getIndex(), value, true)",
+                    realmType, fieldIndexVariableReference(field));
+                writer.emitStatement("return");
+            }
+        });
+        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
+        // Although setting null value for String and bytes[] can be handled by the JNI code, we still generate the same code here.
+        // Compared with getter, null value won't trigger more native calls in setter which is relatively cheaper.
+        if (metadata.isPrimaryKey(field)) {
+            // Primary key is not allowed to be changed after object created.
+            writer.emitStatement(Constants.STATEMENT_EXCEPTION_PRIMARY_KEY_CANNOT_BE_CHANGED, fieldName);
+        } else {
+            if (metadata.isNullable(field)) {
+                writer.beginControlFlow("if (value == null)")
+                    .emitStatement("proxyState.getRow$realm().setNull(%s)", fieldIndexVariableReference(field))
+                    .emitStatement("return")
+                    .endControlFlow();
+            } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
+                // Same reason, throw IAE earlier.
+                writer
+                    .beginControlFlow("if (value == null)")
+                    .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
+                    .endControlFlow();
+            }
+            writer.emitStatement(
+                "proxyState.getRow$realm().set%s(%s, value)",
+                realmType, fieldIndexVariableReference(field));
+        }
+        writer.endMethod();
+    }
 
-                        // set value as default value
-                        writer.emitStatement("final Row row = proxyState.getRow$realm()");
-                        writer.beginControlFlow("if (value == null)")
-                                .emitSingleLineComment("Table#nullifyLink() does not support default value. Just using Row.")
-                                .emitStatement("row.nullifyLink(%s)", fieldIndexVariableReference(field))
-                                .emitStatement("return")
-                            .endControlFlow();
-                        writer.beginControlFlow("if (!RealmObject.isValid(value))")
-                                .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
-                            .endControlFlow();
-                        writer.beginControlFlow("if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
-                                .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
-                            .endControlFlow();
-                        writer.emitStatement("row.getTable().setLink(%s, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true)",
-                                fieldIndexVariableReference(field));
-                        writer.emitStatement("return");
-                    }
-                });
-                writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
-                writer.beginControlFlow("if (value == null)");
-                    writer.emitStatement("proxyState.getRow$realm().nullifyLink(%s)", fieldIndexVariableReference(field));
-                    writer.emitStatement("return");
-                writer.endControlFlow();
-                writer.beginControlFlow("if (!(RealmObject.isManaged(value) && RealmObject.isValid(value)))");
-                    writer.emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")");
-                writer.endControlFlow();
-                writer.beginControlFlow("if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())");
-                    writer.emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")");
-                writer.endControlFlow();
-                writer.emitStatement("proxyState.getRow$realm().setLink(%s, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex())", fieldIndexVariableReference(field));
-                writer.endMethod();
-            } else if (Utils.isRealmList(field)) {
-                /**
-                 * LinkLists
-                 */
-                String genericType = Utils.getGenericTypeQualifiedName(field);
-
-                // Getter
-                writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
-                writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
-                writer.emitSingleLineComment("use the cached value if available");
-                writer.beginControlFlow("if (" + fieldName + "RealmList != null)");
-                        writer.emitStatement("return " + fieldName + "RealmList");
-                writer.nextControlFlow("else");
-                    writer.emitStatement("LinkView linkView = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field));
-                    writer.emitStatement(fieldName + "RealmList = new RealmList<%s>(%s.class, linkView, proxyState.getRealm$realm())",
-                        genericType, genericType);
-                    writer.emitStatement("return " + fieldName + "RealmList");
-                writer.endControlFlow();
+    /**
+     * Links
+     */
+    private void emitRealmModel(
+        JavaWriter writer,
+        final VariableElement field,
+        String fieldName,
+        String fieldTypeCanonicalName) throws IOException
+    {
+
+        // Getter
+        writer.emitAnnotation("Override");
+        writer.beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
+            .emitStatement("proxyState.getRealm$realm().checkIfValid()")
+            .beginControlFlow("if (proxyState.getRow$realm().isNullLink(%s))", fieldIndexVariableReference(field))
+                .emitStatement("return null")
+            .endControlFlow()
+            .emitStatement("return proxyState.getRealm$realm().get(%s.class, proxyState.getRow$realm().getLink(%s), false, Collections.<String>emptyList())",
+                fieldTypeCanonicalName, fieldIndexVariableReference(field))
+            .endMethod()
+            .emitEmptyLine();
 
-                writer.endMethod();
-                writer.emitEmptyLine();
-
-                // Setter
-                writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-                emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
-                    @Override
-                    public void emit(JavaWriter writer) throws IOException {
-                        // check excludeFields
-                        writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
-                                field.getSimpleName().toString())
-                                .emitStatement("return")
-                                .endControlFlow();
-                        final String modelFqcn = Utils.getGenericTypeQualifiedName(field);
-                        writer.beginControlFlow("if (value != null && !value.isManaged())")
-                                .emitStatement("final Realm realm = (Realm) proxyState.getRealm$realm()")
-                                .emitStatement("final RealmList<%1$s> original = value", modelFqcn)
-                                .emitStatement("value = new RealmList<%1$s>()", modelFqcn)
-                                .beginControlFlow("for (%1$s item : original)", modelFqcn)
-                                    .beginControlFlow("if (item == null || RealmObject.isManaged(item))")
-                                        .emitStatement("value.add(item)")
-                                    .nextControlFlow("else")
-                                        .emitStatement("value.add(realm.copyToRealm(item))")
-                                    .endControlFlow()
-                                .endControlFlow()
-                            .endControlFlow();
+        // Setter
+        writer.emitAnnotation("Override");
+        writer.beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
+        emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
+            @Override
+            public void emit(JavaWriter writer) throws IOException {
+                // check excludeFields
+                writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
+                    field.getSimpleName().toString())
+                    .emitStatement("return")
+                    .endControlFlow();
+                writer.beginControlFlow("if (value != null && !RealmObject.isManaged(value))")
+                    .emitStatement("value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value)")
+                    .endControlFlow();
 
-                        // LinkView currently does not support default value feature. Just fallback to normal code.
-                    }
-                });
-                writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
-                writer.emitStatement("LinkView links = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field));
-                writer.emitStatement("links.clear()");
-                writer.beginControlFlow("if (value == null)");
-                    writer.emitStatement("return");
-                writer.endControlFlow();
-                writer.beginControlFlow("for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value)");
-                    writer.beginControlFlow("if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject)))");
-                        writer.emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must be a valid managed object.\")");
-                    writer.endControlFlow();
-                    writer.beginControlFlow("if (((RealmObjectProxy)linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())");
-                        writer.emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must belong to the same Realm.\")");
-                    writer.endControlFlow();
-                    writer.emitStatement("links.add(((RealmObjectProxy)linkedObject).realmGet$proxyState().getRow$realm().getIndex())");
-                writer.endControlFlow();
-                writer.endMethod();
-            } else {
-                throw new UnsupportedOperationException(
-                        String.format("Type '%s' of field '%s' is not supported", fieldTypeCanonicalName, fieldName));
+                // set value as default value
+                writer.emitStatement("final Row row = proxyState.getRow$realm()");
+                writer.beginControlFlow("if (value == null)")
+                    .emitSingleLineComment("Table#nullifyLink() does not support default value. Just using Row.")
+                    .emitStatement("row.nullifyLink(%s)", fieldIndexVariableReference(field))
+                    .emitStatement("return")
+                    .endControlFlow();
+                writer.beginControlFlow("if (!RealmObject.isValid(value))")
+                    .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
+                    .endControlFlow();
+                writer.beginControlFlow("if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
+                    .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
+                    .endControlFlow();
+                writer.emitStatement("row.getTable().setLink(%s, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true)",
+                    fieldIndexVariableReference(field));
+                writer.emitStatement("return");
             }
-            writer.emitEmptyLine();
-        }
+        });
+        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()")
+            .beginControlFlow("if (value == null)")
+                .emitStatement("proxyState.getRow$realm().nullifyLink(%s)", fieldIndexVariableReference(field))
+                .emitStatement("return")
+            .endControlFlow()
+            .beginControlFlow("if (!(RealmObject.isManaged(value) && RealmObject.isValid(value)))")
+                .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
+            .endControlFlow()
+            .beginControlFlow("if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
+                .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
+            .endControlFlow()
+            .emitStatement("proxyState.getRow$realm().setLink(%s, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex())", fieldIndexVariableReference(field))
+            .endMethod();
+    }
+
+    /**
+     * LinkLists
+     */
+    private void emitRealmList(
+        JavaWriter writer,
+        final VariableElement field,
+        String fieldName,
+        String fieldTypeCanonicalName) throws IOException
+    {
+        String genericType = Utils.getGenericTypeQualifiedName(field);
+
+        // Getter
+        writer.emitAnnotation("Override");
+        writer.beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
+            .emitStatement("proxyState.getRealm$realm().checkIfValid()")
+            .emitSingleLineComment("use the cached value if available")
+            .beginControlFlow("if (" + fieldName + "RealmList != null)")
+                .emitStatement("return " + fieldName + "RealmList")
+            .nextControlFlow("else")
+                .emitStatement("LinkView linkView = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field))
+                .emitStatement(fieldName + "RealmList = new RealmList<%s>(%s.class, linkView, proxyState.getRealm$realm())",
+                    genericType, genericType)
+                .emitStatement("return " + fieldName + "RealmList")
+            .endControlFlow()
+            .endMethod()
+            .emitEmptyLine();
+
+        // Setter
+        writer.emitAnnotation("Override");
+        writer.beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
+        emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
+            @Override
+            public void emit(JavaWriter writer) throws IOException {
+                // check excludeFields
+                writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
+                        field.getSimpleName().toString())
+                        .emitStatement("return")
+                        .endControlFlow();
+                final String modelFqcn = Utils.getGenericTypeQualifiedName(field);
+                writer.beginControlFlow("if (value != null && !value.isManaged())")
+                        .emitStatement("final Realm realm = (Realm) proxyState.getRealm$realm()")
+                        .emitStatement("final RealmList<%1$s> original = value", modelFqcn)
+                        .emitStatement("value = new RealmList<%1$s>()", modelFqcn)
+                        .beginControlFlow("for (%1$s item : original)", modelFqcn)
+                            .beginControlFlow("if (item == null || RealmObject.isManaged(item))")
+                                .emitStatement("value.add(item)")
+                            .nextControlFlow("else")
+                                .emitStatement("value.add(realm.copyToRealm(item))")
+                            .endControlFlow()
+                        .endControlFlow()
+                    .endControlFlow();
+
+                // LinkView currently does not support default value feature. Just fallback to normal code.
+            }
+        });
+        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()")
+            .emitStatement("LinkView links = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field))
+            .emitStatement("links.clear()")
+            .beginControlFlow("if (value == null)")
+                .emitStatement("return")
+            .endControlFlow()
+            .beginControlFlow("for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value)")
+                .beginControlFlow("if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject)))")
+                    .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must be a valid managed object.\")")
+                .endControlFlow()
+                .beginControlFlow("if (((RealmObjectProxy)linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
+                    .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must belong to the same Realm.\")")
+                .endControlFlow()
+                .emitStatement("links.add(((RealmObjectProxy)linkedObject).realmGet$proxyState().getRow$realm().getIndex())")
+            .endControlFlow()
+            .endMethod();
     }
 
     private interface CodeEmitter {
@@ -460,16 +504,16 @@ private void emitCodeForUnderConstruction(JavaWriter writer, boolean isPrimaryKe
                                               CodeEmitter defaultValueCodeEmitter) throws IOException {
         writer.beginControlFlow("if (proxyState.isUnderConstruction())");
         if (isPrimaryKey) {
-            writer.emitSingleLineComment("default value of the primary key is always ignored.");
-            writer.emitStatement("return");
+            writer.emitSingleLineComment("default value of the primary key is always ignored.")
+                .emitStatement("return");
         } else {
             writer.beginControlFlow("if (!proxyState.getAcceptDefaultValue$realm())")
                     .emitStatement("return")
                     .endControlFlow();
             defaultValueCodeEmitter.emit(writer);
         }
-        writer.endControlFlow();
-        writer.emitEmptyLine();
+        writer.endControlFlow()
+            .emitEmptyLine();
     }
 
     private void emitInjectContextMethod(JavaWriter writer) throws IOException {
@@ -480,27 +524,46 @@ private void emitInjectContextMethod(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.PUBLIC) // Modifiers
                 ); // Argument type & argument name
 
-        writer.beginControlFlow("if (this.proxyState != null)");
-        writer.emitStatement("return");
-        writer.endControlFlow();
-        writer.emitStatement("final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get()");
-        writer.emitStatement("this.columnInfo = (%1$s) context.getColumnInfo()", columnInfoClassName());
-        writer.emitStatement("this.proxyState = new ProxyState<%1$s>(this)", qualifiedClassName);
-        writer.emitStatement("proxyState.setRealm$realm(context.getRealm())");
-        writer.emitStatement("proxyState.setRow$realm(context.getRow())");
-        writer.emitStatement("proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue())");
-        writer.emitStatement("proxyState.setExcludeFields$realm(context.getExcludeFields())");
+        writer.beginControlFlow("if (this.proxyState != null)")
+                .emitStatement("return")
+            .endControlFlow()
+            .emitStatement("final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get()")
+            .emitStatement("this.columnInfo = (%1$s) context.getColumnInfo()", columnInfoClassName())
+            .emitStatement("this.proxyState = new ProxyState<%1$s>(this)", qualifiedClassName)
+            .emitStatement("proxyState.setRealm$realm(context.getRealm())")
+            .emitStatement("proxyState.setRow$realm(context.getRow())")
+            .emitStatement("proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue())")
+            .emitStatement("proxyState.setExcludeFields$realm(context.getExcludeFields())");
+
+        writer.endMethod()
+            .emitEmptyLine();
+    }
 
-        writer.endMethod();
-        writer.emitEmptyLine();
+    private void emitBacklinkFieldAccessors(JavaWriter writer) throws IOException {
+        for (Backlink backlink : metadata.getBacklinkFields()) {
+            String cacheFieldName = backlink.getTargetField() + BACKLINKS_FIELD_EXTENSION;
+            String realmResultsType = "RealmResults<" + backlink.getSourceClass() + ">";
+
+            // Getter, no setter
+            writer.beginMethod(realmResultsType, metadata.getInternalGetter(backlink.getTargetField()), EnumSet.of(Modifier.PUBLIC))
+                .emitStatement("BaseRealm realm = proxyState.getRealm$realm()")
+                .emitStatement("realm.checkIfValid()")
+                .beginControlFlow("if (" + cacheFieldName + " == null)")
+                    .emitStatement(cacheFieldName + " = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), %s.class, \"%s\")",
+                        backlink.getSourceClass(), backlink.getSourceField())
+                .endControlFlow()
+                .emitStatement("return " + cacheFieldName)
+                .endMethod()
+                .emitEmptyLine();
+        }
     }
 
     private void emitRealmObjectProxyImplementation(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod("ProxyState", "realmGet$proxyState", EnumSet.of(Modifier.PUBLIC));
-        writer.emitStatement("return proxyState");
-        writer.endMethod();
-        writer.emitEmptyLine();
+        writer.emitAnnotation("Override")
+            .beginMethod("ProxyState<?>", "realmGet$proxyState", EnumSet.of(Modifier.PUBLIC))
+                .emitStatement("return proxyState")
+            .endMethod()
+            .emitEmptyLine();
     }
 
     private void emitCreateRealmObjectSchemaMethod(JavaWriter writer) throws IOException {
@@ -530,25 +593,25 @@ private void emitCreateRealmObjectSchemaMethod(JavaWriter writer) throws IOExcep
                         indexedFlag,
                         nullableFlag);
             } else if (Utils.isRealmModel(field)) {
-                writer.beginControlFlow("if (!realmSchema.contains(\"" + fieldTypeSimpleName + "\"))");
-                writer.emitStatement("%s%s.createRealmObjectSchema(realmSchema)", fieldTypeSimpleName, Constants.PROXY_SUFFIX);
-                writer.endControlFlow();
-                writer.emitStatement("realmObjectSchema.add(new Property(\"%s\", RealmFieldType.OBJECT, realmSchema.get(\"%s\")))",
+                writer.beginControlFlow("if (!realmSchema.contains(\"" + fieldTypeSimpleName + "\"))")
+                        .emitStatement("%s%s.createRealmObjectSchema(realmSchema)", fieldTypeSimpleName, Constants.PROXY_SUFFIX)
+                    .endControlFlow()
+                    .emitStatement("realmObjectSchema.add(new Property(\"%s\", RealmFieldType.OBJECT, realmSchema.get(\"%s\")))",
                         fieldName, fieldTypeSimpleName);
             } else if (Utils.isRealmList(field)) {
                 String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
-                writer.beginControlFlow("if (!realmSchema.contains(\"" + genericTypeSimpleName +"\"))");
-                writer.emitStatement("%s%s.createRealmObjectSchema(realmSchema)", genericTypeSimpleName, Constants.PROXY_SUFFIX);
-                writer.endControlFlow();
-                writer.emitStatement("realmObjectSchema.add(new Property(\"%s\", RealmFieldType.LIST, realmSchema.get(\"%s\")))",
+                writer.beginControlFlow("if (!realmSchema.contains(\"" + genericTypeSimpleName +"\"))")
+                        .emitStatement("%s%s.createRealmObjectSchema(realmSchema)", genericTypeSimpleName, Constants.PROXY_SUFFIX)
+                    .endControlFlow()
+                    .emitStatement("realmObjectSchema.add(new Property(\"%s\", RealmFieldType.LIST, realmSchema.get(\"%s\")))",
                         fieldName, genericTypeSimpleName);
             }
         }
         writer.emitStatement("return realmObjectSchema");
         writer.endControlFlow();
         writer.emitStatement("return realmSchema.get(\"" + this.simpleClassName + "\")");
-        writer.endMethod();
-        writer.emitEmptyLine();
+        writer.endMethod()
+            .emitEmptyLine();
     }
 
     private void emitInitTableMethod(JavaWriter writer) throws IOException {
@@ -578,17 +641,17 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
                         Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
                         fieldName, nullableFlag);
             } else if (Utils.isRealmModel(field)) {
-                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
-                writer.emitStatement("%s%s.initTable(sharedRealm)", fieldTypeSimpleName, Constants.PROXY_SUFFIX);
-                writer.endControlFlow();
-                writer.emitStatement("table.addColumnLink(RealmFieldType.OBJECT, \"%s\", sharedRealm.getTable(\"%s%s\"))",
+                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName)
+                        .emitStatement("%s%s.initTable(sharedRealm)", fieldTypeSimpleName, Constants.PROXY_SUFFIX)
+                    .endControlFlow()
+                    .emitStatement("table.addColumnLink(RealmFieldType.OBJECT, \"%s\", sharedRealm.getTable(\"%s%s\"))",
                         fieldName, Constants.TABLE_PREFIX, fieldTypeSimpleName);
             } else if (Utils.isRealmList(field)) {
                 String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
-                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
-                writer.emitStatement("%s.initTable(sharedRealm)", Utils.getProxyClassName(genericTypeSimpleName));
-                writer.endControlFlow();
-                writer.emitStatement("table.addColumnLink(RealmFieldType.LIST, \"%s\", sharedRealm.getTable(\"%s%s\"))",
+                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName)
+                        .emitStatement("%s.initTable(sharedRealm)", Utils.getProxyClassName(genericTypeSimpleName))
+                    .endControlFlow()
+                    .emitStatement("table.addColumnLink(RealmFieldType.LIST, \"%s\", sharedRealm.getTable(\"%s%s\"))",
                         fieldName, Constants.TABLE_PREFIX, genericTypeSimpleName);
             }
         }
@@ -606,212 +669,292 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
         }
 
         writer.emitStatement("return table");
+
         writer.endControlFlow();
+
         writer.emitStatement("return sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
-        writer.endMethod();
-        writer.emitEmptyLine();
+        writer.endMethod()
+            .emitEmptyLine();
     }
 
     private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                columnInfoClassName(),        // Return type
-                "validateTable",              // Method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "SharedRealm", "sharedRealm", // Argument type & argument name
-                "boolean", "allowExtraColumns");
+            columnInfoClassName(),        // Return type
+            "validateTable",              // Method name
+            EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
+            "SharedRealm", "sharedRealm", // Argument type & argument name
+            "boolean", "allowExtraColumns");
+
+            writer.beginControlFlow(
+            "if (!sharedRealm.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
+        emitMigrationNeededException(writer, "\"The '%s' class is missing from the schema for this Realm.\")",
+            metadata.getSimpleClassName());
+        writer.endControlFlow();
 
-        writer.beginControlFlow("if (sharedRealm.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
-        writer.emitStatement("Table table = sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
+        writer.emitStatement(
+            "Table table = sharedRealm.getTable(\"%s%s\")",
+            Constants.TABLE_PREFIX,
+            this.simpleClassName);
 
         // verify number of columns
         writer.emitStatement("final long columnCount = table.getColumnCount()");
         writer.beginControlFlow("if (columnCount != %d)", metadata.getFields().size());
-            writer.beginControlFlow("if (columnCount < %d)", metadata.getFields().size());
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Field count is less than expected - expected %d but was \" + columnCount)",
-                        metadata.getFields().size());
-            writer.endControlFlow();
-            writer.beginControlFlow("if (allowExtraColumns)");
-                writer.emitStatement("RealmLog.debug(\"Field count is more than expected - expected %d but was %%1$d\", columnCount)",
-                        metadata.getFields().size());
-            writer.nextControlFlow("else");
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Field count is more than expected - expected %d but was \" + columnCount)",
-                        metadata.getFields().size());
-            writer.endControlFlow();
+        writer.beginControlFlow("if (columnCount < %d)", metadata.getFields().size());
+        emitMigrationNeededException(writer, "\"Field count is less than expected - expected %d but was \" + columnCount)",
+            metadata.getFields().size());
+        writer.endControlFlow();
+        writer.beginControlFlow("if (allowExtraColumns)");
+        writer.emitStatement(
+            "RealmLog.debug(\"Field count is more than expected - expected %d but was %%1$d\", columnCount)",
+            metadata.getFields().size());
+        writer.nextControlFlow("else");
+        emitMigrationNeededException(writer, "\"Field count is more than expected - expected %d but was \" + columnCount)",
+            metadata.getFields().size());
+        writer.endControlFlow();
         writer.endControlFlow();
 
         // create type dictionary for lookup
         writer.emitStatement("Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>()");
-        writer.beginControlFlow("for (long i = 0; i < columnCount; i++)");
-        writer.emitStatement("columnTypes.put(table.getColumnName(i), table.getColumnType(i))");
-        writer.endControlFlow();
-        writer.emitEmptyLine();
+        writer.beginControlFlow("for (long i = 0; i < columnCount; i++)")
+                .emitStatement("columnTypes.put(table.getColumnName(i), table.getColumnType(i))")
+            .endControlFlow()
+            .emitEmptyLine();
 
         // create an instance of ColumnInfo
-        writer.emitStatement("final %1$s columnInfo = new %1$s(sharedRealm.getPath(), table)", columnInfoClassName());
-        writer.emitEmptyLine();
+        writer.emitStatement("final %1$s columnInfo = new %1$s(sharedRealm.getPath(), table)", columnInfoClassName())
+            .emitEmptyLine();
 
         // verify primary key definition was not altered
         if (metadata.hasPrimaryKey()) {
             // the current model defines a PK, make sure it's defined in the Realm schema
             String fieldName = metadata.getPrimaryKey().getSimpleName().toString();
-            writer.beginControlFlow("if (!table.hasPrimaryKey())")
-                    .emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Primary key not defined for field '%s' in existing Realm file. @PrimaryKey was added.\")", metadata.getPrimaryKey().getSimpleName().toString())
-                    .nextControlFlow("else")
-                    .beginControlFlow("if (table.getPrimaryKey() != columnInfo.%sIndex)", fieldName)
-                    .emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Primary Key annotation definition was changed, from field \" + table.getColumnName(table.getPrimaryKey()) + \" to field %s\")" ,metadata.getPrimaryKey().getSimpleName().toString())
-                    .endControlFlow()
-                    .endControlFlow();
-        } else {
+            writer.beginControlFlow("if (!table.hasPrimaryKey())");
+            emitMigrationNeededException(writer, "\"Primary key not defined for field '%s' in existing Realm file. @PrimaryKey was added.\")",
+                    metadata.getPrimaryKey().getSimpleName().toString());
+            writer.nextControlFlow("else")
+                .beginControlFlow("if (table.getPrimaryKey() != columnInfo.%sIndex)", fieldName);
+            emitMigrationNeededException(writer, "\"Primary Key annotation definition was changed, from field \" + table.getColumnName(table.getPrimaryKey()) + \" to field %s\")",
+                    metadata.getPrimaryKey().getSimpleName().toString());
+            writer.endControlFlow()
+                .endControlFlow();
+        }
+        else {
             // the current model doesn't define a PK, make sure it's not defined in the Realm schema
-            writer.beginControlFlow("if (table.hasPrimaryKey())")
-                    .emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Primary Key defined for field \" + table.getColumnName(table.getPrimaryKey()) + \" was removed.\")")
-                    .endControlFlow();
+            writer.beginControlFlow("if (table.hasPrimaryKey())");
+            emitMigrationNeededException(writer, "\"Primary Key defined for field \" + table.getColumnName(table.getPrimaryKey()) + \" was removed.\")");
+            writer.endControlFlow();
         }
         writer.emitEmptyLine();
 
         // For each field verify there is a corresponding
-        long fieldIndex = 0;
+        long fieldIndex = -1;
         for (VariableElement field : metadata.getFields()) {
+            fieldIndex++;
             String fieldName = field.getSimpleName().toString();
             String fieldTypeQualifiedName = Utils.getFieldTypeQualifiedName(field);
-            String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
-
             if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeQualifiedName)) {
-                // make sure types align
-                writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Missing field '%s' in existing Realm file. " +
-                        "Either remove field or migrate using io.realm.internal.Table.addColumn()." +
-                        "\")", fieldName);
-                writer.endControlFlow();
-                writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)",
-                        fieldName, Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeQualifiedName));
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Invalid type '%s' for field '%s' in existing Realm file.\")",
-                        fieldTypeSimpleName, fieldName);
-                writer.endControlFlow();
+                emitValidateRealmType(writer, field, fieldName, fieldTypeQualifiedName);
+            }
+            else if (Utils.isRealmModel(field)) { // Links
+                emitValidateRealmModelType(writer, field, fieldIndex, fieldName);
+            }
+            else if (Utils.isRealmList(field)) { // Link Lists
+                emitValidateRealmListType(writer, field, fieldIndex, fieldName);
+            }
+        }
 
-                // make sure that nullability matches
-                if (metadata.isNullable(field)) {
-                    writer.beginControlFlow("if (!table.isColumnNullable(%s))", fieldIndexVariableReference(field));
-                    // Check if the existing PrimaryKey does support null value for String, Byte, Short, Integer, & Long
-                    if (metadata.isPrimaryKey(field)) {
-                        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                "\"@PrimaryKey field '%s' does not support null values in the existing Realm file. " +
-                                "Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.\")",
-                                fieldName);
-                    // nullability check for boxed types
-                    } else if (Utils.isBoxedType(fieldTypeQualifiedName)) {
-                        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                "\"Field '%s' does not support null values in the existing Realm file. " +
-                                "Either set @Required, use the primitive type for field '%s' " +
-                                "or migrate using RealmObjectSchema.setNullable().\")",
-                                fieldName, fieldName);
-                    } else {
-                        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                " \"Field '%s' is required. Either set @Required to field '%s' " +
-                                "or migrate using RealmObjectSchema.setNullable().\")",
-                                fieldName, fieldName);
-                    }
-                    writer.endControlFlow();
-                } else {
-                    // check before migrating a nullable field containing null value to not-nullable PrimaryKey field for Realm version 0.89+
-                    if (metadata.isPrimaryKey(field)) {
-                        writer
-                            .beginControlFlow("if (table.isColumnNullable(%s) && table.findFirstNull(%s) != Table.NO_MATCH)",
-                                    fieldIndexVariableReference(field), fieldIndexVariableReference(field))
-                            .emitStatement("throw new IllegalStateException(\"Cannot migrate an object with null value in field '%s'." +
-                                    " Either maintain the same type for primary key field '%s', or remove the object with null value before migration.\")",
-                                    fieldName, fieldName)
-                            .endControlFlow();
-                    } else {
-                        writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
-                        if (Utils.isPrimitiveType(fieldTypeQualifiedName)) {
-                            writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                    " \"Field '%s' does support null values in the existing Realm file. " +
-                                    "Use corresponding boxed type for field '%s' or migrate using RealmObjectSchema.setNullable().\")",
-                                    fieldName, fieldName);
-                        } else {
-                            writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                    " \"Field '%s' does support null values in the existing Realm file. " +
-                                    "Remove @Required or @PrimaryKey from field '%s' or migrate using RealmObjectSchema.setNullable().\")",
-                                    fieldName, fieldName);
-                        }
-                        writer.endControlFlow();
-                    }
-                }
+        // verify the backlinks
+        Set<Backlink> backlinks = metadata.getBacklinkFields();
+        if (backlinks.size() > 0) {
+            writer.emitEmptyLine()
+                .emitStatement("long backlinkFieldIndex")
+                .emitStatement("Table backlinkSourceTable")
+                .emitStatement("Table backlinkTargetTable")
+                .emitStatement("RealmFieldType backlinkFieldType");
+            for (Backlink backlink : metadata.getBacklinkFields()) {
+                emitValidateBacklink(writer, backlink);
+            }
+        }
 
-                // Validate @Index
-                if (metadata.getIndexedFields().contains(field)) {
-                    writer.beginControlFlow("if (!table.hasSearchIndex(table.getColumnIndex(\"%s\")))", fieldName);
-                    writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Index not defined for field '%s' in existing Realm file. " +
-                            "Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().\")", fieldName);
-                    writer.endControlFlow();
-                }
+        writer.emitEmptyLine();
+        writer.emitStatement("return %s", "columnInfo");
 
-            } else if (Utils.isRealmModel(field)) { // Links
-                writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Missing field '%s' in existing Realm file. " +
-                        "Either remove field or migrate using io.realm.internal.Table.addColumn().\")", fieldName);
-                writer.endControlFlow();
-                writer.beginControlFlow("if (columnTypes.get(\"%s\") != RealmFieldType.OBJECT)", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Invalid type '%s' for field '%s'\")",
-                        fieldTypeSimpleName, fieldName);
-                writer.endControlFlow();
-                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Missing class '%s%s' for field '%s'\")",
-                        Constants.TABLE_PREFIX, fieldTypeSimpleName, fieldName);
-                writer.endControlFlow();
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
 
-                writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, fieldTypeSimpleName);
-                writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
-                        fieldIndexVariableReference(field), fieldIndex);
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Invalid RealmObject for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
-                        fieldName, fieldIndexVariableReference(field), fieldIndex);
-                writer.endControlFlow();
-            } else if (Utils.isRealmList(field)) { // Link Lists
-                String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
-                writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Missing field '%s'\")", fieldName);
-                writer.endControlFlow();
-                writer.beginControlFlow("if (columnTypes.get(\"%s\") != RealmFieldType.LIST)", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Invalid type '%s' for field '%s'\")",
-                        genericTypeSimpleName, fieldName);
-                writer.endControlFlow();
-                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Missing class '%s%s' for field '%s'\")",
-                        Constants.TABLE_PREFIX, genericTypeSimpleName, fieldName);
-                writer.endControlFlow();
+    private void emitValidateRealmType(JavaWriter writer, VariableElement field, String fieldName, String fieldTypeQualifiedName)
+        throws IOException {
 
-                writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, genericTypeSimpleName);
-                writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
-                        fieldIndexVariableReference(field), fieldIndex);
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Invalid RealmList type for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
-                        fieldName, fieldIndexVariableReference(field), fieldIndex);
+        // make sure types align
+        writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
+        emitMigrationNeededException(writer, "\"Missing field '%s' in existing Realm file. " +
+                "Either remove field or migrate using io.realm.internal.Table.addColumn()." +
+                "\")", fieldName);
+        writer.endControlFlow();
+        writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)",
+                fieldName, Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeQualifiedName));
+        emitMigrationNeededException(writer, "\"Invalid type '%s' for field '%s' in existing Realm file.\")",
+            Utils.getFieldTypeSimpleName(field), fieldName);
+        writer.endControlFlow();
+
+        // make sure that nullability matches
+        if (metadata.isNullable(field)) {
+            writer.beginControlFlow("if (!table.isColumnNullable(%s))", fieldIndexVariableReference(field));
+            // Check if the existing PrimaryKey does support null value for String, Byte, Short, Integer, & Long
+            if (metadata.isPrimaryKey(field)) {
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
+                        "\"@PrimaryKey field '%s' does not support null values in the existing Realm file. " +
+                        "Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.\")",
+                        fieldName);
+            // nullability check for boxed types
+            } else if (Utils.isBoxedType(fieldTypeQualifiedName)) {
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
+                        "\"Field '%s' does not support null values in the existing Realm file. " +
+                        "Either set @Required, use the primitive type for field '%s' " +
+                        "or migrate using RealmObjectSchema.setNullable().\")",
+                        fieldName, fieldName);
+            } else {
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
+                        " \"Field '%s' is required. Either set @Required to field '%s' " +
+                        "or migrate using RealmObjectSchema.setNullable().\")",
+                        fieldName, fieldName);
+            }
+            writer.endControlFlow();
+        } else {
+            // check before migrating a nullable field containing null value to not-nullable PrimaryKey field for Realm version 0.89+
+            if (metadata.isPrimaryKey(field)) {
+                writer
+                    .beginControlFlow("if (table.isColumnNullable(%s) && table.findFirstNull(%s) != Table.NO_MATCH)",
+                            fieldIndexVariableReference(field), fieldIndexVariableReference(field))
+                    .emitStatement("throw new IllegalStateException(\"Cannot migrate an object with null value in field '%s'." +
+                            " Either maintain the same type for primary key field '%s', or remove the object with null value before migration.\")",
+                            fieldName, fieldName)
+                    .endControlFlow();
+            } else {
+                writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
+                if (Utils.isPrimitiveType(fieldTypeQualifiedName)) {
+                    writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
+                            " \"Field '%s' does support null values in the existing Realm file. " +
+                            "Use corresponding boxed type for field '%s' or migrate using RealmObjectSchema.setNullable().\")",
+                            fieldName, fieldName);
+                } else {
+                    writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
+                            " \"Field '%s' does support null values in the existing Realm file. " +
+                            "Remove @Required or @PrimaryKey from field '%s' or migrate using RealmObjectSchema.setNullable().\")",
+                            fieldName, fieldName);
+                }
                 writer.endControlFlow();
             }
-            fieldIndex++;
         }
 
-        writer.emitStatement("return %s", "columnInfo");
+        // Validate @Index
+        if (metadata.getIndexedFields().contains(field)) {
+            writer.beginControlFlow("if (!table.hasSearchIndex(table.getColumnIndex(\"%s\")))", fieldName);
+            emitMigrationNeededException(writer, "\"Index not defined for field '%s' in existing Realm file. " +
+                    "Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().\")", fieldName);
+            writer.endControlFlow();
+        }
+    }
 
-        writer.nextControlFlow("else");
-        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"The '%s' class is missing from the schema for this Realm.\")", metadata.getSimpleClassName());
+    private void emitValidateRealmModelType(JavaWriter writer, VariableElement field, long fieldIndex, String fieldName)
+        throws IOException {
+        String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
+
+        writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
+        emitMigrationNeededException(writer, "\"Missing field '%s' in existing Realm file. " +
+            "Either remove field or migrate using io.realm.internal.Table.addColumn().\")", fieldName);
+        writer.endControlFlow();
+        writer.beginControlFlow("if (columnTypes.get(\"%s\") != RealmFieldType.OBJECT)", fieldName);
+        emitMigrationNeededException(writer, "\"Invalid type '%s' for field '%s'\")",
+            fieldTypeSimpleName, fieldName);
+        writer.endControlFlow();
+        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
+        emitMigrationNeededException(writer, "\"Missing class '%s%s' for field '%s'\")",
+            Constants.TABLE_PREFIX, fieldTypeSimpleName, fieldName);
+        writer.endControlFlow();
+
+        writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, fieldTypeSimpleName);
+        writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
+            fieldIndexVariableReference(field), fieldIndex);
+        emitMigrationNeededException(writer, "\"Invalid RealmObject for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
+            fieldName, fieldIndexVariableReference(field), fieldIndex);
+        writer.endControlFlow();
+    }
+
+    private void emitValidateRealmListType(JavaWriter writer, VariableElement field, long fieldIndex, String fieldName)
+        throws IOException
+    {
+        String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
+        writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
+        emitMigrationNeededException(writer, "\"Missing field '%s'\")", fieldName);
+        writer.endControlFlow();
+        writer.beginControlFlow("if (columnTypes.get(\"%s\") != RealmFieldType.LIST)", fieldName);
+        emitMigrationNeededException(writer, "\"Invalid type '%s' for field '%s'\")",
+            genericTypeSimpleName, fieldName);
+        writer.endControlFlow();
+        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
+        emitMigrationNeededException(writer, "\"Missing class '%s%s' for field '%s'\")",
+            Constants.TABLE_PREFIX, genericTypeSimpleName, fieldName);
+        writer.endControlFlow();
+
+        writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, genericTypeSimpleName);
+        writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
+            fieldIndexVariableReference(field), fieldIndex);
+        emitMigrationNeededException(writer, "\"Invalid RealmList type for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
+            fieldName, fieldIndexVariableReference(field), fieldIndex);
+        writer.endControlFlow();
+    }
+
+    private void emitValidateBacklink(JavaWriter writer, Backlink backlink) throws IOException {
+        String targetField = backlink.getTargetField();
+        String targetClass = backlink.getTargetClass();
+
+        // Preceding code has already verified that the backlink field is not in the table.
+        // If it were, either the column count would be wrong, or some field would be missing.
+
+        // verify that the source class exists
+        String sourceClass = backlink.getSimpleSourceClass();
+        String fullyQualifiedSourceClass = backlink.getSourceClass();
+        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, sourceClass);
+        emitMigrationNeededException(writer, "\"Cannot find source class '%s' for @LinkingObjects field '%s.%s'\")",
+            fullyQualifiedSourceClass, targetClass, targetField);
+        writer.endControlFlow();
+
+        // verify that the source class contains the source field
+        String sourceField = backlink.getSourceField();
+        writer.emitStatement("backlinkSourceTable = sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, sourceClass);
+        writer.emitStatement("backlinkFieldIndex = backlinkSourceTable.getColumnIndex(\"%s\")", sourceField);
+        writer.beginControlFlow("if (backlinkFieldIndex == Table.NO_MATCH)");
+        emitMigrationNeededException(writer, "\"Cannot find source field '%s.%s' for @LinkingObjects field '%s.%s'\")",
+            fullyQualifiedSourceClass, sourceField, targetClass, targetField);
+        writer.endControlFlow();
+
+        // verify that the source field type is target class
+        writer.emitStatement("backlinkFieldType = backlinkSourceTable.getColumnType(backlinkFieldIndex)");
+        writer.beginControlFlow("if ((backlinkFieldType != RealmFieldType.OBJECT) && (backlinkFieldType != RealmFieldType.LIST))");
+        emitMigrationNeededException(writer, "\"Source field '%s.%s' for @LinkingObjects field '%s.%s' is not a RealmObject type\")",
+            fullyQualifiedSourceClass, sourceField, targetClass, targetField);
+        writer.endControlFlow();
+        writer.emitStatement("backlinkTargetTable = backlinkSourceTable.getLinkTarget(backlinkFieldIndex)");
+        writer.beginControlFlow("if (!table.hasSameSchema(backlinkTargetTable))");
+        emitMigrationNeededException(writer, "\"Source field '%s.%s' for @LinkingObjects field '%s.%s' has wrong type '\" + backlinkTargetTable.getName() + \"'\")",
+            fullyQualifiedSourceClass, sourceField, targetClass, targetField);
         writer.endControlFlow();
-        writer.endMethod();
-        writer.emitEmptyLine();
     }
 
     private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
-        writer.beginMethod("String", "getTableName", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
-        writer.emitStatement("return \"%s%s\"", Constants.TABLE_PREFIX, simpleClassName);
-        writer.endMethod();
-        writer.emitEmptyLine();
+        writer.beginMethod("String", "getTableName", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
+            .emitStatement("return \"%s%s\"", Constants.TABLE_PREFIX, simpleClassName)
+            .endMethod()
+            .emitEmptyLine();
     }
 
     private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
-        writer.beginMethod("List<String>", "getFieldNames", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
-        writer.emitStatement("return FIELD_NAMES");
-        writer.endMethod();
-        writer.emitEmptyLine();
+        writer.beginMethod("List<String>", "getFieldNames", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
+            .emitStatement("return FIELD_NAMES")
+            .endMethod()
+            .emitEmptyLine();
     }
 
     private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
@@ -907,8 +1050,8 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
             }
 
         writer.endControlFlow();
-        writer.endMethod();
-        writer.emitEmptyLine();
+        writer.endMethod()
+            .emitEmptyLine();
     }
 
     private void setTableValues(JavaWriter writer, String fieldType, String fieldName, String interfaceName, String getter, boolean isUpdate) throws IOException {
@@ -1039,7 +1182,7 @@ private void emitInsertMethod(JavaWriter writer) throws IOException {
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String fieldType = field.asType().toString();
-            String getter = metadata.getGetter(fieldName);
+            String getter = metadata.getInternalGetter(fieldName);
 
             if (Utils.isRealmModel(field)) {
                 writer
@@ -1081,8 +1224,8 @@ private void emitInsertMethod(JavaWriter writer) throws IOException {
         }
 
         writer.emitStatement("return rowIndex");
-        writer.endMethod();
-        writer.emitEmptyLine();
+        writer.endMethod()
+            .emitEmptyLine();
     }
 
     private void emitInsertListMethod(JavaWriter writer) throws IOException {
@@ -1102,8 +1245,8 @@ private void emitInsertListMethod(JavaWriter writer) throws IOException {
         }
         writer.emitStatement("%s object = null", qualifiedClassName);
 
-        writer.beginControlFlow("while (objects.hasNext())");
-        writer.emitStatement("object = (%s) objects.next()", qualifiedClassName);
+        writer.beginControlFlow("while (objects.hasNext())")
+            .emitStatement("object = (%s) objects.next()", qualifiedClassName);
         writer.beginControlFlow("if(!cache.containsKey(object))");
 
         writer.beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))");
@@ -1116,7 +1259,7 @@ private void emitInsertListMethod(JavaWriter writer) throws IOException {
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String fieldType = field.asType().toString();
-            String getter = metadata.getGetter(fieldName);
+            String getter = metadata.getInternalGetter(fieldName);
 
             if (Utils.isRealmModel(field)) {
                 writer
@@ -1190,7 +1333,7 @@ private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String fieldType = field.asType().toString();
-            String getter = metadata.getGetter(fieldName);
+            String getter = metadata.getInternalGetter(fieldName);
 
             if (Utils.isRealmModel(field)) {
                 writer
@@ -1236,8 +1379,8 @@ private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
 
         writer.emitStatement("return rowIndex");
 
-        writer.endMethod();
-        writer.emitEmptyLine();
+        writer.endMethod()
+            .emitEmptyLine();
     }
 
     private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException {
@@ -1270,7 +1413,7 @@ private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String fieldType = field.asType().toString();
-            String getter = metadata.getGetter(fieldName);
+            String getter = metadata.getInternalGetter(fieldName);
 
             if (Utils.isRealmModel(field)) {
                 writer
@@ -1402,8 +1545,8 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
             for (VariableElement field : metadata.getFields()) {
                 String fieldName = field.getSimpleName().toString();
                 String fieldType = field.asType().toString();
-                String setter = metadata.getSetter(fieldName);
-                String getter = metadata.getGetter(fieldName);
+                String setter = metadata.getInternalSetter(fieldName);
+                String getter = metadata.getInternalGetter(fieldName);
 
                 if (metadata.isPrimaryKey(field)) {
                     // PK has been set when creating object.
@@ -1489,8 +1632,8 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
 
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
-            String setter = metadata.getSetter(fieldName);
-            String getter = metadata.getGetter(fieldName);
+            String setter = metadata.getInternalSetter(fieldName);
+            String getter = metadata.getInternalGetter(fieldName);
 
             if (Utils.isRealmModel(field)) {
                 writer
@@ -1541,8 +1684,8 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
 
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
-            String setter = metadata.getSetter(fieldName);
-            String getter = metadata.getGetter(fieldName);
+            String setter = metadata.getInternalSetter(fieldName);
+            String getter = metadata.getInternalGetter(fieldName);
             if (Utils.isRealmModel(field)) {
                 writer
                     .emitStatement("%s %sObj = ((%s) newObject).%s()",
@@ -1602,50 +1745,52 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
             return;
         }
         writer.emitAnnotation("Override");
-        writer.beginMethod("String", "toString", EnumSet.of(Modifier.PUBLIC));
-        writer.beginControlFlow("if (!RealmObject.isValid(this))");
-        writer.emitStatement("return \"Invalid object\"");
-        writer.endControlFlow();
+        writer.emitAnnotation("SuppressWarnings", "\"ArrayToString\"")
+            .beginMethod("String", "toString", EnumSet.of(Modifier.PUBLIC))
+            .beginControlFlow("if (!RealmObject.isValid(this))")
+                .emitStatement("return \"Invalid object\"")
+            .endControlFlow();
         writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = [\")", simpleClassName);
-        List<VariableElement> fields = metadata.getFields();
-        for (int i = 0; i < fields.size(); i++) {
-            VariableElement field = fields.get(i);
-            String fieldName = field.getSimpleName().toString();
+
+        Collection<VariableElement> fields = metadata.getFields();
+        int i = fields.size() - 1;
+        for (VariableElement field: fields) {
+             String fieldName = field.getSimpleName().toString();
 
             writer.emitStatement("stringBuilder.append(\"{%s:\")", fieldName);
             if (Utils.isRealmModel(field)) {
                 String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
                 writer.emitStatement(
                         "stringBuilder.append(%s() != null ? \"%s\" : \"null\")",
-                        metadata.getGetter(fieldName),
+                        metadata.getInternalGetter(fieldName),
                         fieldTypeSimpleName
                 );
             } else if (Utils.isRealmList(field)) {
                 String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
                 writer.emitStatement("stringBuilder.append(\"RealmList<%s>[\").append(%s().size()).append(\"]\")",
                         genericTypeSimpleName,
-                        metadata.getGetter(fieldName));
+                        metadata.getInternalGetter(fieldName));
             } else {
                 if (metadata.isNullable(field)) {
                     writer.emitStatement("stringBuilder.append(%s() != null ? %s() : \"null\")",
-                            metadata.getGetter(fieldName),
-                            metadata.getGetter(fieldName)
+                            metadata.getInternalGetter(fieldName),
+                            metadata.getInternalGetter(fieldName)
                     );
                 } else {
-                    writer.emitStatement("stringBuilder.append(%s())", metadata.getGetter(fieldName));
+                    writer.emitStatement("stringBuilder.append(%s())", metadata.getInternalGetter(fieldName));
                 }
             }
             writer.emitStatement("stringBuilder.append(\"}\")");
 
-            if (i < fields.size() - 1) {
+            if (i-- > 0) {
                 writer.emitStatement("stringBuilder.append(\",\")");
             }
         }
 
         writer.emitStatement("stringBuilder.append(\"]\")");
         writer.emitStatement("return stringBuilder.toString()");
-        writer.endMethod();
-        writer.emitEmptyLine();
+        writer.endMethod()
+            .emitEmptyLine();
     }
 
     /**
@@ -1657,19 +1802,19 @@ private void emitHashcodeMethod(JavaWriter writer) throws IOException {
         if (metadata.containsHashCode()) {
             return;
         }
-        writer.emitAnnotation("Override");
-        writer.beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC));
-        writer.emitStatement("String realmName = proxyState.getRealm$realm().getPath()");
-        writer.emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()");
-        writer.emitStatement("long rowIndex = proxyState.getRow$realm().getIndex()");
-        writer.emitEmptyLine();
-        writer.emitStatement("int result = 17");
-        writer.emitStatement("result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0)");
-        writer.emitStatement("result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0)");
-        writer.emitStatement("result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32))");
-        writer.emitStatement("return result");
-        writer.endMethod();
-        writer.emitEmptyLine();
+        writer.emitAnnotation("Override")
+            .beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC))
+                .emitStatement("String realmName = proxyState.getRealm$realm().getPath()")
+                .emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()")
+                .emitStatement("long rowIndex = proxyState.getRow$realm().getIndex()")
+                .emitEmptyLine()
+                .emitStatement("int result = 17")
+                .emitStatement("result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0)")
+                .emitStatement("result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0)")
+                .emitStatement("result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32))")
+                .emitStatement("return result")
+            .endMethod()
+            .emitEmptyLine();
     }
 
     private void emitEqualsMethod(JavaWriter writer) throws IOException {
@@ -1678,25 +1823,25 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
         }
         String proxyClassName = Utils.getProxyClassName(simpleClassName);
         String otherObjectVarName = "a" + simpleClassName;
-        writer.emitAnnotation("Override");
-        writer.beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o");
-        writer.emitStatement("if (this == o) return true");
-        writer.emitStatement("if (o == null || getClass() != o.getClass()) return false");
-        writer.emitStatement("%s %s = (%s)o", proxyClassName, otherObjectVarName, proxyClassName);  // FooRealmProxy aFoo = (FooRealmProxy)o
-        writer.emitEmptyLine();
-        writer.emitStatement("String path = proxyState.getRealm$realm().getPath()");
-        writer.emitStatement("String otherPath = %s.proxyState.getRealm$realm().getPath()", otherObjectVarName);
-        writer.emitStatement("if (path != null ? !path.equals(otherPath) : otherPath != null) return false");
-        writer.emitEmptyLine();
-        writer.emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()");
-        writer.emitStatement("String otherTableName = %s.proxyState.getRow$realm().getTable().getName()", otherObjectVarName);
-        writer.emitStatement("if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false");
-        writer.emitEmptyLine();
-        writer.emitStatement("if (proxyState.getRow$realm().getIndex() != %s.proxyState.getRow$realm().getIndex()) return false", otherObjectVarName);
-        writer.emitEmptyLine();
-        writer.emitStatement("return true");
-        writer.endMethod();
-        writer.emitEmptyLine();
+        writer.emitAnnotation("Override")
+            .beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o")
+                .emitStatement("if (this == o) return true")
+                .emitStatement("if (o == null || getClass() != o.getClass()) return false")
+                .emitStatement("%s %s = (%s)o", proxyClassName, otherObjectVarName, proxyClassName)  // FooRealmProxy aFoo = (FooRealmProxy)o
+                .emitEmptyLine()
+                .emitStatement("String path = proxyState.getRealm$realm().getPath()")
+                .emitStatement("String otherPath = %s.proxyState.getRealm$realm().getPath()", otherObjectVarName)
+                .emitStatement("if (path != null ? !path.equals(otherPath) : otherPath != null) return false")
+                .emitEmptyLine()
+                .emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()")
+                .emitStatement("String otherTableName = %s.proxyState.getRow$realm().getTable().getName()", otherObjectVarName)
+                .emitStatement("if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false")
+                .emitEmptyLine()
+                .emitStatement("if (proxyState.getRow$realm().getIndex() != %s.proxyState.getRow$realm().getIndex()) return false", otherObjectVarName)
+                .emitEmptyLine()
+                .emitStatement("return true")
+            .endMethod()
+            .emitEmptyLine();
     }
 
     private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
@@ -1775,7 +1920,7 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
             if (Utils.isRealmModel(field)) {
                 RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(
                         interfaceName,
-                        metadata.getSetter(fieldName),
+                        metadata.getInternalSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
                         Utils.getProxyClassSimpleName(field),
@@ -1785,8 +1930,8 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
             } else if (Utils.isRealmList(field)) {
                 RealmJsonTypeHelper.emitFillRealmListWithJsonValue(
                         interfaceName,
-                        metadata.getGetter(fieldName),
-                        metadata.getSetter(fieldName),
+                        metadata.getInternalGetter(fieldName),
+                        metadata.getInternalSetter(fieldName),
                         fieldName,
                         ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
                         Utils.getProxyClassSimpleName(field),
@@ -1795,7 +1940,7 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
             } else {
                 RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
                         interfaceName,
-                        metadata.getSetter(fieldName),
+                        metadata.getInternalSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
                         writer
@@ -1808,7 +1953,7 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
         writer.emitEmptyLine();
     }
 
-    private void buildExcludeFieldsList(JavaWriter writer, List<VariableElement> fields) throws IOException {
+    private void buildExcludeFieldsList(JavaWriter writer, Collection<VariableElement> fields) throws IOException {
         for (VariableElement field : fields) {
             if (Utils.isRealmModel(field) || Utils.isRealmList(field)) {
                 final String fieldName = field.getSimpleName().toString();
@@ -1838,22 +1983,18 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         writer.emitStatement("reader.beginObject()");
         writer.beginControlFlow("while (reader.hasNext())");
         writer.emitStatement("String name = reader.nextName()");
+        writer.beginControlFlow("if (false)");
 
-        List<VariableElement> fields = metadata.getFields();
-        for (int i = 0; i < fields.size(); i++) {
-            VariableElement field = fields.get(i);
+        Collection<VariableElement> fields = metadata.getFields();
+        for (VariableElement field: fields) {
             String fieldName = field.getSimpleName().toString();
             String qualifiedFieldType = field.asType().toString();
+            writer.nextControlFlow("else if (name.equals(\"%s\"))", fieldName);
 
-            if (i == 0) {
-                writer.beginControlFlow("if (name.equals(\"%s\"))", fieldName);
-            } else {
-                writer.nextControlFlow("else if (name.equals(\"%s\"))", fieldName);
-            }
             if (Utils.isRealmModel(field)) {
                 RealmJsonTypeHelper.emitFillRealmObjectFromStream(
                         interfaceName,
-                        metadata.getSetter(fieldName),
+                        metadata.getInternalSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
                         Utils.getProxyClassSimpleName(field),
@@ -1863,8 +2004,8 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
             } else if (Utils.isRealmList(field)) {
                 RealmJsonTypeHelper.emitFillRealmListFromStream(
                         interfaceName,
-                        metadata.getGetter(fieldName),
-                        metadata.getSetter(fieldName),
+                        metadata.getInternalGetter(fieldName),
+                        metadata.getInternalSetter(fieldName),
                         ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
                         Utils.getProxyClassSimpleName(field),
                         writer);
@@ -1880,23 +2021,27 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
             }
         }
 
-        if (fields.size() > 0) {
-            writer.nextControlFlow("else");
-            writer.emitStatement("reader.skipValue()");
-            writer.endControlFlow();
-        }
+        writer.nextControlFlow("else");
+        writer.emitStatement("reader.skipValue()");
+        writer.endControlFlow();
+
         writer.endControlFlow();
         writer.emitStatement("reader.endObject()");
+
         if (metadata.hasPrimaryKey()) {
-            writer.beginControlFlow("if (!jsonHasPrimaryKey)");
-            writer.emitStatement(Constants.STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON, metadata.getPrimaryKey());
-            writer.endControlFlow();
+            writer.beginControlFlow("if (!jsonHasPrimaryKey)")
+                    .emitStatement(Constants.STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON, metadata.getPrimaryKey())
+                .endControlFlow();
         }
+
         writer.emitStatement("obj = realm.copyToRealm(obj)");
         writer.emitStatement("return obj");
         writer.endMethod();
         writer.emitEmptyLine();
+    }
 
+    private void emitMigrationNeededException(JavaWriter writer, String message, Object... args) throws IOException {
+        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), " + message, args);
     }
 
     private String columnInfoClassName() {
@@ -1911,7 +2056,7 @@ private String fieldIndexVariableReference(VariableElement variableElement) {
         return "columnInfo." + columnIndexVarName(variableElement);
     }
 
-    private static int countModelOrListFields(List<VariableElement> fields) {
+    private static int countModelOrListFields(Collection<VariableElement> fields) {
         int count = 0;
         for (VariableElement f : fields) {
             if (Utils.isRealmModel(f) || Utils.isRealmList(f)) {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
index 9613b09df9..b653a27f3b 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
@@ -59,18 +59,29 @@ public void generate() throws IOException {
                 writer
                         .beginMethod(
                                 fieldTypeCanonicalName,
-                                metaData.getGetter(fieldName),
+                                metaData.getInternalGetter(fieldName),
                                 EnumSet.of(Modifier.PUBLIC))
                         .endMethod()
                         .beginMethod(
                                 "void",
-                                metaData.getSetter(fieldName),
+                                metaData.getInternalSetter(fieldName),
                                 EnumSet.of(Modifier.PUBLIC),
                                 fieldTypeCanonicalName,
                                 "value")
                         .endMethod();
             }
         }
+
+        // backlinks are final and have only a getter.
+        for (Backlink backlink : metaData.getBacklinkFields()) {
+            writer
+                .beginMethod(
+                    backlink.getTargetFieldType(),
+                    metaData.getInternalGetter(backlink.getTargetField()),
+                    EnumSet.of(Modifier.PUBLIC))
+                .endMethod();
+        }
+
         writer.endType();
         writer.close();
     }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
index 09b7792bf0..bcf57bf780 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
@@ -16,29 +16,27 @@
 
 package io.realm.processor;
 
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.tools.Diagnostic;
-import java.io.*;
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
 import java.net.HttpURLConnection;
 import java.net.URL;
 
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.tools.Diagnostic;
+
 public class RealmVersionChecker {
     public static final String REALM_ANDROID_DOWNLOAD_URL = "http://static.realm.io/downloads/java/latest";
 
-    private static RealmVersionChecker instance = null;
-    private static boolean isFirstRound = true;
-
     private static final String VERSION_URL = "http://static.realm.io/update/java?";
     private static final String REALM_VERSION = Version.VERSION;
     private static final String REALM_VERSION_PATTERN = "\\d+\\.\\d+\\.\\d+";
     private static final int READ_TIMEOUT = 2000;
     private static final int CONNECT_TIMEOUT = 4000;
 
-    private ProcessingEnvironment processingEnvironment;
+    private static RealmVersionChecker instance = null;
 
-    private RealmVersionChecker(ProcessingEnvironment processingEnvironment) {
-        this.processingEnvironment = processingEnvironment;
-    }
+    private ProcessingEnvironment processingEnvironment;
 
     public static RealmVersionChecker getInstance(ProcessingEnvironment processingEnvironment) {
         if (instance == null) {
@@ -47,6 +45,28 @@ public static RealmVersionChecker getInstance(ProcessingEnvironment processingEn
         return instance;
     }
 
+    private RealmVersionChecker(ProcessingEnvironment processingEnvironment) {
+        this.processingEnvironment = processingEnvironment;
+    }
+
+    public void executeRealmVersionUpdate() {
+        Thread backgroundThread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                launchRealmCheck();
+            }
+        });
+
+        backgroundThread.start();
+
+        try {
+            backgroundThread.join(CONNECT_TIMEOUT + READ_TIMEOUT);
+        }
+        catch (InterruptedException ignore) {
+            // We ignore this exception on purpose not to break the build system if this class fails
+        }
+    }
+
     private void launchRealmCheck() {
         //Check Realm version server
         String latestVersionStr = checkLatestVersion();
@@ -55,24 +75,6 @@ private void launchRealmCheck() {
         }
     }
 
-    public void executeRealmVersionUpdate() {
-        if (isFirstRound) {
-            isFirstRound = false;
-            Thread backgroundThread = new Thread(new Runnable() {
-                @Override
-                public void run() {
-                    launchRealmCheck();
-                }
-            });
-            backgroundThread.start();
-            try {
-                backgroundThread.join(CONNECT_TIMEOUT + READ_TIMEOUT);
-            } catch (InterruptedException e) {
-                // We ignore this exception on purpose not to break the build system if this class fails
-            }
-        }
-    }
-
     private String checkLatestVersion() {
         String result = REALM_VERSION;
         try {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
index 9ed30c70eb..d7ee9217e1 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -10,6 +10,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
@@ -22,6 +23,7 @@
     public static Types typeUtils;
     private static Messager messager;
     private static DeclaredType realmList;
+    private static DeclaredType realmResults;
     private static DeclaredType markerInterface;
     private static TypeMirror realmModel;
 
@@ -30,6 +32,8 @@ public static void initialize(ProcessingEnvironment env) {
         messager = env.getMessager();
         realmList = typeUtils.getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmList"),
                 typeUtils.getWildcardType(null, null));
+        realmResults = typeUtils.getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmResults"),
+                typeUtils.getWildcardType(null, null));
         realmModel = env.getElementUtils().getTypeElement("io.realm.RealmModel").asType();
         markerInterface = env.getTypeUtils().getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmModel"));
     }
@@ -155,6 +159,42 @@ public static boolean isRealmModel(VariableElement field) {
         return typeUtils.isAssignable(field.asType(), realmModel);
     }
 
+    public static boolean isRealmResults(VariableElement field) {
+        return typeUtils.isAssignable(field.asType(), realmResults);
+    }
+
+    // get the fully-qualified type name for the generic type of a RealmResults
+    public static String getRealmResultsType(VariableElement field) {
+        if (!Utils.isRealmResults(field)) { return null; }
+        DeclaredType type = getGenericTypeForContainer(field);
+        if (null == type) { return null; }
+        return type.toString();
+    }
+
+    // get the fully-qualified type name for the generic type of a RealmList
+    public static String getRealmListType(VariableElement field) {
+        if (!Utils.isRealmList(field)) { return null; }
+        DeclaredType type = getGenericTypeForContainer(field);
+        if (null == type) { return null; }
+        return type.toString();
+    }
+
+    // Note that, because subclassing subclasses of RealmObject is forbidden,
+    // there is no need to deal with constructs like:  <code>RealmResults&lt;? extends Foos&lt;</code>.
+    public static DeclaredType getGenericTypeForContainer(VariableElement field) {
+        TypeMirror fieldType = field.asType();
+        TypeKind kind = fieldType.getKind();
+        if (kind != TypeKind.DECLARED) { return null; }
+
+        List<? extends TypeMirror> args = ((DeclaredType) fieldType).getTypeArguments();
+        if (args.size() <= 0) { return null; }
+
+        fieldType = args.get(0);
+        kind = fieldType.getKind();
+        if (kind != TypeKind.DECLARED) { return null; }
+
+        return (DeclaredType) fieldType;
+    }
 
     /**
      * @return the qualified type name for a field.
@@ -167,11 +207,24 @@ public static String getFieldTypeQualifiedName(VariableElement field) {
      * @return the simple type name for a field.
      */
     public static String getFieldTypeSimpleName(VariableElement field) {
-        String fieldTypeQualifiedName = getFieldTypeQualifiedName(field);
-        if (!fieldTypeQualifiedName.contains(".")) {
-            return fieldTypeQualifiedName;
+        return  (null == field) ? null : getFieldTypeSimpleName(getFieldTypeQualifiedName(field));
+    }
+
+    /**
+     * @return the simple type name for a field.
+     */
+    public static String getFieldTypeSimpleName(DeclaredType type) {
+        return (null == type) ? null : getFieldTypeSimpleName(type.toString());
+    }
+
+    /**
+     * @return the simple type name for a field.
+     */
+    public static String getFieldTypeSimpleName(String fieldTypeQualifiedName) {
+        if ((null != fieldTypeQualifiedName) && (fieldTypeQualifiedName.contains("."))) {
+            fieldTypeQualifiedName = fieldTypeQualifiedName.substring(fieldTypeQualifiedName.lastIndexOf('.') + 1);
         }
-        return fieldTypeQualifiedName.substring(fieldTypeQualifiedName.lastIndexOf('.') + 1);
+        return fieldTypeQualifiedName;
     }
 
     /**
@@ -231,4 +284,5 @@ public static Element getSuperClass(TypeElement classType) {
     public static String getProxyInterfaceName(String className) {
         return className + Constants.INTERFACE_SUFFIX;
     }
+
 }
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
index d7eff132bd..b888290450 100644
--- a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
@@ -56,6 +56,17 @@
     private JavaFileObject UseExtendRealmList = JavaFileObjects.forResource("some/test/UseExtendRealmList.java");
     private JavaFileObject SimpleRealmModel = JavaFileObjects.forResource("some/test/SimpleRealmModel.java");
     private JavaFileObject customInterface = JavaFileObjects.forResource("some/test/CustomInterface.java");
+    private JavaFileObject backlinks = JavaFileObjects.forResource("some/test/Backlinks.java");
+    private JavaFileObject backlinksTarget = JavaFileObjects.forResource("some/test/BacklinkTarget.java");
+    private JavaFileObject backlinksInvalidField = JavaFileObjects.forResource("some/test/Backlinks_InvalidFieldType.java");
+    private JavaFileObject backlinksLinked = JavaFileObjects.forResource("some/test/Backlinks_LinkedFields.java");
+    private JavaFileObject backlinksMissingParam = JavaFileObjects.forResource("some/test/Backlinks_MissingParameter.java");
+    private JavaFileObject backlinksMissingGeneric = JavaFileObjects.forResource("some/test/Backlinks_MissingGeneric.java");
+    private JavaFileObject backlinksRequired = JavaFileObjects.forResource("some/test/Backlinks_Required.java");
+    private JavaFileObject backlinksIgnored = JavaFileObjects.forResource("some/test/Backlinks_Ignored.java");
+    private JavaFileObject backlinksNotFound = JavaFileObjects.forResource("some/test/Backlinks_NotFound.java");
+    private JavaFileObject backlinksNonFinalField = JavaFileObjects.forResource("some/test/Backlinks_NotFinal.java");
+    private JavaFileObject backlinksWrongType = JavaFileObjects.forResource("some/test/Backlinks_WrongType.java");
 
     @Test
     public void compileSimpleFile() {
@@ -183,7 +194,8 @@ public void compileLibraryModulesCustomClasses() throws Exception {
     @Test
     public void compileAppModuleMixedParametersFail() throws Exception {
         ASSERT.about(javaSources())
-                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/InvalidAppModuleMixedParameters.java")))
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource(
+                    "some/test/InvalidAllTypesModuleMixedParameters.java")))
                 .processedWith(new RealmProcessor())
                 .failsToCompile();
     }
@@ -191,7 +203,8 @@ public void compileAppModuleMixedParametersFail() throws Exception {
     @Test
     public void compileAppModuleWrongTypeFail() throws Exception {
         ASSERT.about(javaSources())
-                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/InvalidAppModuleWrongType.java")))
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource(
+                    "some/test/InvalidAllTypesModuleWrongType.java")))
                 .processedWith(new RealmProcessor())
                 .failsToCompile();
     }
@@ -460,4 +473,92 @@ public void compileWithInterfaceForObject() {
                 .processedWith(new RealmProcessor())
                 .failsToCompile();
     }
+
+    @Test
+    public void compileBacklinks() {
+        ASSERT.about(javaSources())
+            .that(Arrays.asList(backlinks, backlinksTarget))
+            .processedWith(new RealmProcessor())
+            .compilesWithoutError();
+    }
+
+    @Test
+    public void failOnLinkingObjectsWithInvalidFieldType() {
+        ASSERT.about(javaSources())
+            .that(Arrays.asList(backlinks, backlinksTarget, backlinksInvalidField))
+            .processedWith(new RealmProcessor())
+            .failsToCompile()
+            .withErrorContaining("Fields annotated with @LinkingObjects must be RealmResults");
+    }
+
+    @Test
+    public void failOnLinkingObjectsWithNonFinalField() {
+        ASSERT.about(javaSources())
+            .that(Arrays.asList(backlinks, backlinksTarget, backlinksNonFinalField))
+            .processedWith(new RealmProcessor())
+            .failsToCompile()
+            .withErrorContaining("must be final");
+    }
+
+    @Test
+    public void failsOnLinkingObjectsWithLinkedFields() {
+        ASSERT.about(javaSources())
+            .that(Arrays.asList(backlinks, backlinksTarget, backlinksLinked))
+            .processedWith(new RealmProcessor())
+            .failsToCompile()
+            .withErrorContaining("The use of '.' to specify fields in referenced classes is not supported");
+    }
+
+    @Test
+    public void failsOnLinkingObjectsMissingFieldName() {
+        ASSERT.about(javaSources())
+            .that(Arrays.asList(backlinks, backlinksTarget, backlinksMissingParam))
+            .processedWith(new RealmProcessor())
+            .failsToCompile()
+            .withErrorContaining("must have a parameter identifying the link target");
+    }
+
+    @Test
+    public void failsOnLinkingObjectsMissingGeneric() {
+        ASSERT.about(javaSources())
+            .that(Arrays.asList(backlinks, backlinksTarget, backlinksMissingGeneric))
+            .processedWith(new RealmProcessor())
+            .failsToCompile()
+            .withErrorContaining("must specify a generic type");
+    }
+
+    @Test
+    public void failsOnLinkingObjectsWithRequiredFields() {
+        ASSERT.about(javaSources())
+            .that(Arrays.asList(backlinks, backlinksTarget, backlinksRequired))
+            .processedWith(new RealmProcessor())
+            .failsToCompile()
+            .withErrorContaining("cannot be @Required");
+    }
+
+    @Test
+    public void failsOnLinkingObjectsWithIgnoreFields() {
+        ASSERT.about(javaSources())
+            .that(Arrays.asList(backlinks, backlinksTarget, backlinksIgnored))
+            .processedWith(new RealmProcessor())
+            .compilesWithoutError();
+    }
+
+    @Test
+    public void failsOnLinkingObjectsFieldNotFound() {
+        ASSERT.about(javaSources())
+            .that(Arrays.asList(backlinks, backlinksTarget, backlinksNotFound))
+            .processedWith(new RealmProcessor())
+            .failsToCompile()
+            .withErrorContaining("does not exist in class");
+    }
+
+    @Test
+    public void failsOnLinkingObjectsWithFieldWrongType() {
+        ASSERT.about(javaSources())
+            .that(Arrays.asList(backlinks, backlinksTarget, backlinksWrongType))
+            .processedWith(new RealmProcessor())
+            .failsToCompile()
+            .withErrorContaining("instead of");
+    }
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 7666014010..18aa93ce89 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -93,6 +93,7 @@ public final AllTypesColumnInfo clone() {
     private AllTypesColumnInfo columnInfo;
     private ProxyState<some.test.AllTypes> proxyState;
     private RealmList<some.test.AllTypes> columnRealmListRealmList;
+    private RealmResults<some.test.AllTypes> parentObjectsBacklinks;
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -126,12 +127,14 @@ public final AllTypesColumnInfo clone() {
         proxyState.setExcludeFields$realm(context.getExcludeFields());
     }
 
+    @Override
     @SuppressWarnings("cast")
     public String realmGet$columnString() {
         proxyState.getRealm$realm().checkIfValid();
         return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.columnStringIndex);
     }
 
+    @Override
     public void realmSet$columnString(String value) {
         if (proxyState.isUnderConstruction()) {
             // default value of the primary key is always ignored.
@@ -142,12 +145,14 @@ public final AllTypesColumnInfo clone() {
         throw new io.realm.exceptions.RealmException("Primary key field 'columnString' cannot be changed after object was created.");
     }
 
+    @Override
     @SuppressWarnings("cast")
     public long realmGet$columnLong() {
         proxyState.getRealm$realm().checkIfValid();
         return (long) proxyState.getRow$realm().getLong(columnInfo.columnLongIndex);
     }
 
+    @Override
     public void realmSet$columnLong(long value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -162,12 +167,14 @@ public final AllTypesColumnInfo clone() {
         proxyState.getRow$realm().setLong(columnInfo.columnLongIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public float realmGet$columnFloat() {
         proxyState.getRealm$realm().checkIfValid();
         return (float) proxyState.getRow$realm().getFloat(columnInfo.columnFloatIndex);
     }
 
+    @Override
     public void realmSet$columnFloat(float value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -182,12 +189,14 @@ public final AllTypesColumnInfo clone() {
         proxyState.getRow$realm().setFloat(columnInfo.columnFloatIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public double realmGet$columnDouble() {
         proxyState.getRealm$realm().checkIfValid();
         return (double) proxyState.getRow$realm().getDouble(columnInfo.columnDoubleIndex);
     }
 
+    @Override
     public void realmSet$columnDouble(double value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -202,12 +211,14 @@ public final AllTypesColumnInfo clone() {
         proxyState.getRow$realm().setDouble(columnInfo.columnDoubleIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public boolean realmGet$columnBoolean() {
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.columnBooleanIndex);
     }
 
+    @Override
     public void realmSet$columnBoolean(boolean value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -222,12 +233,14 @@ public final AllTypesColumnInfo clone() {
         proxyState.getRow$realm().setBoolean(columnInfo.columnBooleanIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Date realmGet$columnDate() {
         proxyState.getRealm$realm().checkIfValid();
         return (java.util.Date) proxyState.getRow$realm().getDate(columnInfo.columnDateIndex);
     }
 
+    @Override
     public void realmSet$columnDate(Date value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -248,12 +261,14 @@ public final AllTypesColumnInfo clone() {
         proxyState.getRow$realm().setDate(columnInfo.columnDateIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public byte[] realmGet$columnBinary() {
         proxyState.getRealm$realm().checkIfValid();
         return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.columnBinaryIndex);
     }
 
+    @Override
     public void realmSet$columnBinary(byte[] value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -274,6 +289,7 @@ public final AllTypesColumnInfo clone() {
         proxyState.getRow$realm().setBinaryByteArray(columnInfo.columnBinaryIndex, value);
     }
 
+    @Override
     public some.test.AllTypes realmGet$columnObject() {
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNullLink(columnInfo.columnObjectIndex)) {
@@ -282,6 +298,7 @@ public final AllTypesColumnInfo clone() {
         return proxyState.getRealm$realm().get(some.test.AllTypes.class, proxyState.getRow$realm().getLink(columnInfo.columnObjectIndex), false, Collections.<String>emptyList());
     }
 
+    @Override
     public void realmSet$columnObject(some.test.AllTypes value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -323,6 +340,7 @@ public final AllTypesColumnInfo clone() {
         proxyState.getRow$realm().setLink(columnInfo.columnObjectIndex, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex());
     }
 
+    @Override
     public RealmList<some.test.AllTypes> realmGet$columnRealmList() {
         proxyState.getRealm$realm().checkIfValid();
         // use the cached value if available
@@ -335,6 +353,7 @@ public final AllTypesColumnInfo clone() {
         }
     }
 
+    @Override
     public void realmSet$columnRealmList(RealmList<some.test.AllTypes> value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -374,6 +393,15 @@ public final AllTypesColumnInfo clone() {
         }
     }
 
+    public RealmResults<some.test.AllTypes> realmGet$parentObjects() {
+        BaseRealm realm = proxyState.getRealm$realm();
+        realm.checkIfValid();
+        if (parentObjectsBacklinks == null) {
+            parentObjectsBacklinks = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), some.test.AllTypes.class, "columnObject");
+        }
+        return parentObjectsBacklinks;
+    }
+
     public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
         if (!realmSchema.contains("AllTypes")) {
             RealmObjectSchema realmObjectSchema = realmSchema.create("AllTypes");
@@ -423,130 +451,151 @@ public static Table initTable(SharedRealm sharedRealm) {
     }
 
     public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
-        if (sharedRealm.hasTable("class_AllTypes")) {
-            Table table = sharedRealm.getTable("class_AllTypes");
-            final long columnCount = table.getColumnCount();
-            if (columnCount != 9) {
-                if (columnCount < 9) {
-                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 9 but was " + columnCount);
-                }
-                if (allowExtraColumns) {
-                    RealmLog.debug("Field count is more than expected - expected 9 but was %1$d", columnCount);
-                } else {
-                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 9 but was " + columnCount);
-                }
-            }
-            Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
-            for (long i = 0; i < columnCount; i++) {
-                columnTypes.put(table.getColumnName(i), table.getColumnType(i));
+        if (!sharedRealm.hasTable("class_AllTypes")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'AllTypes' class is missing from the schema for this Realm.");
+        }
+        Table table = sharedRealm.getTable("class_AllTypes");
+        final long columnCount = table.getColumnCount();
+        if (columnCount != 9) {
+            if (columnCount < 9) {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 9 but was " + columnCount);
+            }
+            if (allowExtraColumns) {
+                RealmLog.debug("Field count is more than expected - expected 9 but was %1$d", columnCount);
+            } else {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 9 but was " + columnCount);
             }
+        }
+        Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
+        for (long i = 0; i < columnCount; i++) {
+            columnTypes.put(table.getColumnName(i), table.getColumnType(i));
+        }
 
-            final AllTypesColumnInfo columnInfo = new AllTypesColumnInfo(sharedRealm.getPath(), table);
+        final AllTypesColumnInfo columnInfo = new AllTypesColumnInfo(sharedRealm.getPath(), table);
 
-            if (!table.hasPrimaryKey()) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. @PrimaryKey was added.");
-            } else {
-                if (table.getPrimaryKey() != columnInfo.columnStringIndex) {
-                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key annotation definition was changed, from field " + table.getColumnName(table.getPrimaryKey()) + " to field columnString");
-                }
+        if (!table.hasPrimaryKey()) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. @PrimaryKey was added.");
+        } else {
+            if (table.getPrimaryKey() != columnInfo.columnStringIndex) {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key annotation definition was changed, from field " + table.getColumnName(table.getPrimaryKey()) + " to field columnString");
             }
+        }
 
-            if (!columnTypes.containsKey("columnString")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnString' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("columnString") != RealmFieldType.STRING) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'columnString' in existing Realm file.");
-            }
-            if (!table.isColumnNullable(columnInfo.columnStringIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(),"@PrimaryKey field 'columnString' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.");
-            }
-            if (!table.hasSearchIndex(table.getColumnIndex("columnString"))) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Index not defined for field 'columnString' in existing Realm file. Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().");
-            }
-            if (!columnTypes.containsKey("columnLong")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnLong' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("columnLong") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'long' for field 'columnLong' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.columnLongIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnLong' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnLong' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("columnFloat")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnFloat' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("columnFloat") != RealmFieldType.FLOAT) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'float' for field 'columnFloat' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.columnFloatIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnFloat' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnFloat' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("columnDouble")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnDouble' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("columnDouble") != RealmFieldType.DOUBLE) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'double' for field 'columnDouble' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.columnDoubleIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDouble' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnDouble' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("columnBoolean")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("columnBoolean") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'columnBoolean' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.columnBooleanIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnBoolean' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("columnDate")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnDate' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("columnDate") != RealmFieldType.DATE) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'columnDate' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.columnDateIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDate' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnDate' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("columnBinary")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnBinary' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("columnBinary") != RealmFieldType.BINARY) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'columnBinary' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.columnBinaryIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("columnObject")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnObject' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("columnObject") != RealmFieldType.OBJECT) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'AllTypes' for field 'columnObject'");
-            }
-            if (!sharedRealm.hasTable("class_AllTypes")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
-            }
-            Table table_7 = sharedRealm.getTable("class_AllTypes");
-            if (!table.getLinkTarget(columnInfo.columnObjectIndex).hasSameSchema(table_7)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(columnInfo.columnObjectIndex).getName() + "' expected - was '" + table_7.getName() + "'");
-            }
-            if (!columnTypes.containsKey("columnRealmList")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnRealmList'");
-            }
-            if (columnTypes.get("columnRealmList") != RealmFieldType.LIST) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'AllTypes' for field 'columnRealmList'");
-            }
-            if (!sharedRealm.hasTable("class_AllTypes")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
-            }
-            Table table_8 = sharedRealm.getTable("class_AllTypes");
-            if (!table.getLinkTarget(columnInfo.columnRealmListIndex).hasSameSchema(table_8)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmList type for field 'columnRealmList': '" + table.getLinkTarget(columnInfo.columnRealmListIndex).getName() + "' expected - was '" + table_8.getName() + "'");
-            }
-            return columnInfo;
-        } else {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'AllTypes' class is missing from the schema for this Realm.");
+        if (!columnTypes.containsKey("columnString")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnString' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("columnString") != RealmFieldType.STRING) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'columnString' in existing Realm file.");
+        }
+        if (!table.isColumnNullable(columnInfo.columnStringIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(),"@PrimaryKey field 'columnString' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.");
+        }
+        if (!table.hasSearchIndex(table.getColumnIndex("columnString"))) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Index not defined for field 'columnString' in existing Realm file. Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().");
+        }
+        if (!columnTypes.containsKey("columnLong")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnLong' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("columnLong") != RealmFieldType.INTEGER) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'long' for field 'columnLong' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.columnLongIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnLong' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnLong' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("columnFloat")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnFloat' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("columnFloat") != RealmFieldType.FLOAT) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'float' for field 'columnFloat' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.columnFloatIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnFloat' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnFloat' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("columnDouble")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnDouble' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("columnDouble") != RealmFieldType.DOUBLE) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'double' for field 'columnDouble' in existing Realm file.");
         }
+        if (table.isColumnNullable(columnInfo.columnDoubleIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDouble' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnDouble' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("columnBoolean")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("columnBoolean") != RealmFieldType.BOOLEAN) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'columnBoolean' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.columnBooleanIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnBoolean' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("columnDate")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnDate' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("columnDate") != RealmFieldType.DATE) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'columnDate' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.columnDateIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDate' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnDate' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("columnBinary")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnBinary' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("columnBinary") != RealmFieldType.BINARY) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'columnBinary' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.columnBinaryIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("columnObject")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnObject' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("columnObject") != RealmFieldType.OBJECT) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'AllTypes' for field 'columnObject'");
+        }
+        if (!sharedRealm.hasTable("class_AllTypes")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
+        }
+        Table table_7 = sharedRealm.getTable("class_AllTypes");
+        if (!table.getLinkTarget(columnInfo.columnObjectIndex).hasSameSchema(table_7)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(columnInfo.columnObjectIndex).getName() + "' expected - was '" + table_7.getName() + "'");
+        }
+        if (!columnTypes.containsKey("columnRealmList")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnRealmList'");
+        }
+        if (columnTypes.get("columnRealmList") != RealmFieldType.LIST) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'AllTypes' for field 'columnRealmList'");
+        }
+        if (!sharedRealm.hasTable("class_AllTypes")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
+        }
+        Table table_8 = sharedRealm.getTable("class_AllTypes");
+        if (!table.getLinkTarget(columnInfo.columnRealmListIndex).hasSameSchema(table_8)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmList type for field 'columnRealmList': '" + table.getLinkTarget(columnInfo.columnRealmListIndex).getName() + "' expected - was '" + table_8.getName() + "'");
+        }
+
+        long backlinkFieldIndex;
+        Table backlinkSourceTable;
+        Table backlinkTargetTable;
+        RealmFieldType backlinkFieldType;
+        if (!sharedRealm.hasTable("class_AllTypes")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Cannot find source class 'some.test.AllTypes' for @LinkingObjects field 'some.test.AllTypes.parentObjects'");
+        }
+        backlinkSourceTable = sharedRealm.getTable("class_AllTypes");
+        backlinkFieldIndex = backlinkSourceTable.getColumnIndex("columnObject");
+        if (backlinkFieldIndex == Table.NO_MATCH) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Cannot find source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects'");
+        }
+        backlinkFieldType = backlinkSourceTable.getColumnType(backlinkFieldIndex);
+        if ((backlinkFieldType != RealmFieldType.OBJECT) && (backlinkFieldType != RealmFieldType.LIST)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects' is not a RealmObject type");
+        }
+        backlinkTargetTable = backlinkSourceTable.getLinkTarget(backlinkFieldIndex);
+        if (!table.hasSameSchema(backlinkTargetTable)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects' has wrong type '" + backlinkTargetTable.getName() + "'");
+        }
+
+        return columnInfo;
     }
 
     public static String getTableName() {
@@ -677,7 +726,8 @@ public static String getTableName() {
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
-            if (name.equals("columnString")) {
+            if (false) {
+            } else if (name.equals("columnString")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
                     ((AllTypesRealmProxyInterface) obj).realmSet$columnString(null);
@@ -1191,6 +1241,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
     }
 
     @Override
+    @SuppressWarnings("ArrayToString")
     public String toString() {
         if (!RealmObject.isValid(this)) {
             return "Invalid object";
@@ -1236,7 +1287,7 @@ public String toString() {
     }
 
     @Override
-    public ProxyState realmGet$proxyState() {
+    public ProxyState<?> realmGet$proxyState() {
         return proxyState;
     }
 
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index 8906eb90e6..c630f1f176 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -100,12 +100,14 @@ public final BooleansColumnInfo clone() {
         proxyState.setExcludeFields$realm(context.getExcludeFields());
     }
 
+    @Override
     @SuppressWarnings("cast")
     public boolean realmGet$done() {
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.doneIndex);
     }
 
+    @Override
     public void realmSet$done(boolean value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -120,12 +122,14 @@ public final BooleansColumnInfo clone() {
         proxyState.getRow$realm().setBoolean(columnInfo.doneIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public boolean realmGet$isReady() {
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.isReadyIndex);
     }
 
+    @Override
     public void realmSet$isReady(boolean value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -140,12 +144,14 @@ public final BooleansColumnInfo clone() {
         proxyState.getRow$realm().setBoolean(columnInfo.isReadyIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public boolean realmGet$mCompleted() {
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.mCompletedIndex);
     }
 
+    @Override
     public void realmSet$mCompleted(boolean value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -160,12 +166,14 @@ public final BooleansColumnInfo clone() {
         proxyState.getRow$realm().setBoolean(columnInfo.mCompletedIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public boolean realmGet$anotherBoolean() {
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.anotherBooleanIndex);
     }
 
+    @Override
     public void realmSet$anotherBoolean(boolean value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -206,70 +214,70 @@ public static Table initTable(SharedRealm sharedRealm) {
     }
 
     public static BooleansColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
-        if (sharedRealm.hasTable("class_Booleans")) {
-            Table table = sharedRealm.getTable("class_Booleans");
-            final long columnCount = table.getColumnCount();
-            if (columnCount != 4) {
-                if (columnCount < 4) {
-                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 4 but was " + columnCount);
-                }
-                if (allowExtraColumns) {
-                    RealmLog.debug("Field count is more than expected - expected 4 but was %1$d", columnCount);
-                } else {
-                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 4 but was " + columnCount);
-                }
+        if (!sharedRealm.hasTable("class_Booleans")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'Booleans' class is missing from the schema for this Realm.");
+        }
+        Table table = sharedRealm.getTable("class_Booleans");
+        final long columnCount = table.getColumnCount();
+        if (columnCount != 4) {
+            if (columnCount < 4) {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 4 but was " + columnCount);
             }
-            Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
-            for (long i = 0; i < columnCount; i++) {
-                columnTypes.put(table.getColumnName(i), table.getColumnType(i));
+            if (allowExtraColumns) {
+                RealmLog.debug("Field count is more than expected - expected 4 but was %1$d", columnCount);
+            } else {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 4 but was " + columnCount);
             }
+        }
+        Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
+        for (long i = 0; i < columnCount; i++) {
+            columnTypes.put(table.getColumnName(i), table.getColumnType(i));
+        }
 
-            final BooleansColumnInfo columnInfo = new BooleansColumnInfo(sharedRealm.getPath(), table);
+        final BooleansColumnInfo columnInfo = new BooleansColumnInfo(sharedRealm.getPath(), table);
 
-            if (table.hasPrimaryKey()) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
-            }
+        if (table.hasPrimaryKey()) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
+        }
 
-            if (!columnTypes.containsKey("done")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'done' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("done") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'done' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.doneIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'done' does support null values in the existing Realm file. Use corresponding boxed type for field 'done' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("isReady")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'isReady' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("isReady") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'isReady' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.isReadyIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'isReady' does support null values in the existing Realm file. Use corresponding boxed type for field 'isReady' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("mCompleted")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'mCompleted' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("mCompleted") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'mCompleted' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.mCompletedIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'mCompleted' does support null values in the existing Realm file. Use corresponding boxed type for field 'mCompleted' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("anotherBoolean")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'anotherBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("anotherBoolean") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'anotherBoolean' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.anotherBooleanIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'anotherBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'anotherBoolean' or migrate using RealmObjectSchema.setNullable().");
-            }
-            return columnInfo;
-        } else {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'Booleans' class is missing from the schema for this Realm.");
+        if (!columnTypes.containsKey("done")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'done' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("done") != RealmFieldType.BOOLEAN) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'done' in existing Realm file.");
         }
+        if (table.isColumnNullable(columnInfo.doneIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'done' does support null values in the existing Realm file. Use corresponding boxed type for field 'done' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("isReady")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'isReady' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("isReady") != RealmFieldType.BOOLEAN) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'isReady' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.isReadyIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'isReady' does support null values in the existing Realm file. Use corresponding boxed type for field 'isReady' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("mCompleted")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'mCompleted' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("mCompleted") != RealmFieldType.BOOLEAN) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'mCompleted' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.mCompletedIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'mCompleted' does support null values in the existing Realm file. Use corresponding boxed type for field 'mCompleted' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("anotherBoolean")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'anotherBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("anotherBoolean") != RealmFieldType.BOOLEAN) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'anotherBoolean' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.anotherBooleanIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'anotherBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'anotherBoolean' or migrate using RealmObjectSchema.setNullable().");
+        }
+
+        return columnInfo;
     }
 
     public static String getTableName() {
@@ -324,7 +332,8 @@ public static String getTableName() {
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
-            if (name.equals("done")) {
+            if (false) {
+            } else if (name.equals("done")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'done' to null.");
@@ -495,6 +504,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
     }
 
     @Override
+    @SuppressWarnings("ArrayToString")
     public String toString() {
         if (!RealmObject.isValid(this)) {
             return "Invalid object";
@@ -520,7 +530,7 @@ public String toString() {
     }
 
     @Override
-    public ProxyState realmGet$proxyState() {
+    public ProxyState<?> realmGet$proxyState() {
         return proxyState;
     }
 
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index a541004034..fa041cfb80 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -185,12 +185,14 @@ public final NullTypesColumnInfo clone() {
         proxyState.setExcludeFields$realm(context.getExcludeFields());
     }
 
+    @Override
     @SuppressWarnings("cast")
     public String realmGet$fieldStringNotNull() {
         proxyState.getRealm$realm().checkIfValid();
         return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.fieldStringNotNullIndex);
     }
 
+    @Override
     public void realmSet$fieldStringNotNull(String value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -211,12 +213,14 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setString(columnInfo.fieldStringNotNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public String realmGet$fieldStringNull() {
         proxyState.getRealm$realm().checkIfValid();
         return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.fieldStringNullIndex);
     }
 
+    @Override
     public void realmSet$fieldStringNull(String value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -239,12 +243,14 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setString(columnInfo.fieldStringNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Boolean realmGet$fieldBooleanNotNull() {
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.fieldBooleanNotNullIndex);
     }
 
+    @Override
     public void realmSet$fieldBooleanNotNull(Boolean value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -265,6 +271,7 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setBoolean(columnInfo.fieldBooleanNotNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Boolean realmGet$fieldBooleanNull() {
         proxyState.getRealm$realm().checkIfValid();
@@ -274,6 +281,7 @@ public final NullTypesColumnInfo clone() {
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.fieldBooleanNullIndex);
     }
 
+    @Override
     public void realmSet$fieldBooleanNull(Boolean value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -296,12 +304,14 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setBoolean(columnInfo.fieldBooleanNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public byte[] realmGet$fieldBytesNotNull() {
         proxyState.getRealm$realm().checkIfValid();
         return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.fieldBytesNotNullIndex);
     }
 
+    @Override
     public void realmSet$fieldBytesNotNull(byte[] value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -322,12 +332,14 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setBinaryByteArray(columnInfo.fieldBytesNotNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public byte[] realmGet$fieldBytesNull() {
         proxyState.getRealm$realm().checkIfValid();
         return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.fieldBytesNullIndex);
     }
 
+    @Override
     public void realmSet$fieldBytesNull(byte[] value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -350,12 +362,14 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setBinaryByteArray(columnInfo.fieldBytesNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Byte realmGet$fieldByteNotNull() {
         proxyState.getRealm$realm().checkIfValid();
         return (byte) proxyState.getRow$realm().getLong(columnInfo.fieldByteNotNullIndex);
     }
 
+    @Override
     public void realmSet$fieldByteNotNull(Byte value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -376,6 +390,7 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setLong(columnInfo.fieldByteNotNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Byte realmGet$fieldByteNull() {
         proxyState.getRealm$realm().checkIfValid();
@@ -385,6 +400,7 @@ public final NullTypesColumnInfo clone() {
         return (byte) proxyState.getRow$realm().getLong(columnInfo.fieldByteNullIndex);
     }
 
+    @Override
     public void realmSet$fieldByteNull(Byte value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -407,12 +423,14 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setLong(columnInfo.fieldByteNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Short realmGet$fieldShortNotNull() {
         proxyState.getRealm$realm().checkIfValid();
         return (short) proxyState.getRow$realm().getLong(columnInfo.fieldShortNotNullIndex);
     }
 
+    @Override
     public void realmSet$fieldShortNotNull(Short value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -433,6 +451,7 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setLong(columnInfo.fieldShortNotNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Short realmGet$fieldShortNull() {
         proxyState.getRealm$realm().checkIfValid();
@@ -442,6 +461,7 @@ public final NullTypesColumnInfo clone() {
         return (short) proxyState.getRow$realm().getLong(columnInfo.fieldShortNullIndex);
     }
 
+    @Override
     public void realmSet$fieldShortNull(Short value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -464,12 +484,14 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setLong(columnInfo.fieldShortNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Integer realmGet$fieldIntegerNotNull() {
         proxyState.getRealm$realm().checkIfValid();
         return (int) proxyState.getRow$realm().getLong(columnInfo.fieldIntegerNotNullIndex);
     }
 
+    @Override
     public void realmSet$fieldIntegerNotNull(Integer value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -490,6 +512,7 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setLong(columnInfo.fieldIntegerNotNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Integer realmGet$fieldIntegerNull() {
         proxyState.getRealm$realm().checkIfValid();
@@ -499,6 +522,7 @@ public final NullTypesColumnInfo clone() {
         return (int) proxyState.getRow$realm().getLong(columnInfo.fieldIntegerNullIndex);
     }
 
+    @Override
     public void realmSet$fieldIntegerNull(Integer value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -521,12 +545,14 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setLong(columnInfo.fieldIntegerNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Long realmGet$fieldLongNotNull() {
         proxyState.getRealm$realm().checkIfValid();
         return (long) proxyState.getRow$realm().getLong(columnInfo.fieldLongNotNullIndex);
     }
 
+    @Override
     public void realmSet$fieldLongNotNull(Long value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -547,6 +573,7 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setLong(columnInfo.fieldLongNotNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Long realmGet$fieldLongNull() {
         proxyState.getRealm$realm().checkIfValid();
@@ -556,6 +583,7 @@ public final NullTypesColumnInfo clone() {
         return (long) proxyState.getRow$realm().getLong(columnInfo.fieldLongNullIndex);
     }
 
+    @Override
     public void realmSet$fieldLongNull(Long value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -578,12 +606,14 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setLong(columnInfo.fieldLongNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Float realmGet$fieldFloatNotNull() {
         proxyState.getRealm$realm().checkIfValid();
         return (float) proxyState.getRow$realm().getFloat(columnInfo.fieldFloatNotNullIndex);
     }
 
+    @Override
     public void realmSet$fieldFloatNotNull(Float value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -604,6 +634,7 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setFloat(columnInfo.fieldFloatNotNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Float realmGet$fieldFloatNull() {
         proxyState.getRealm$realm().checkIfValid();
@@ -613,6 +644,7 @@ public final NullTypesColumnInfo clone() {
         return (float) proxyState.getRow$realm().getFloat(columnInfo.fieldFloatNullIndex);
     }
 
+    @Override
     public void realmSet$fieldFloatNull(Float value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -635,12 +667,14 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setFloat(columnInfo.fieldFloatNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Double realmGet$fieldDoubleNotNull() {
         proxyState.getRealm$realm().checkIfValid();
         return (double) proxyState.getRow$realm().getDouble(columnInfo.fieldDoubleNotNullIndex);
     }
 
+    @Override
     public void realmSet$fieldDoubleNotNull(Double value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -661,6 +695,7 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setDouble(columnInfo.fieldDoubleNotNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Double realmGet$fieldDoubleNull() {
         proxyState.getRealm$realm().checkIfValid();
@@ -670,6 +705,7 @@ public final NullTypesColumnInfo clone() {
         return (double) proxyState.getRow$realm().getDouble(columnInfo.fieldDoubleNullIndex);
     }
 
+    @Override
     public void realmSet$fieldDoubleNull(Double value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -692,12 +728,14 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setDouble(columnInfo.fieldDoubleNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Date realmGet$fieldDateNotNull() {
         proxyState.getRealm$realm().checkIfValid();
         return (java.util.Date) proxyState.getRow$realm().getDate(columnInfo.fieldDateNotNullIndex);
     }
 
+    @Override
     public void realmSet$fieldDateNotNull(Date value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -718,6 +756,7 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setDate(columnInfo.fieldDateNotNullIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public Date realmGet$fieldDateNull() {
         proxyState.getRealm$realm().checkIfValid();
@@ -727,6 +766,7 @@ public final NullTypesColumnInfo clone() {
         return (java.util.Date) proxyState.getRow$realm().getDate(columnInfo.fieldDateNullIndex);
     }
 
+    @Override
     public void realmSet$fieldDateNull(Date value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -749,6 +789,7 @@ public final NullTypesColumnInfo clone() {
         proxyState.getRow$realm().setDate(columnInfo.fieldDateNullIndex, value);
     }
 
+    @Override
     public some.test.NullTypes realmGet$fieldObjectNull() {
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNullLink(columnInfo.fieldObjectNullIndex)) {
@@ -757,6 +798,7 @@ public final NullTypesColumnInfo clone() {
         return proxyState.getRealm$realm().get(some.test.NullTypes.class, proxyState.getRow$realm().getLink(columnInfo.fieldObjectNullIndex), false, Collections.<String>emptyList());
     }
 
+    @Override
     public void realmSet$fieldObjectNull(some.test.NullTypes value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -864,227 +906,227 @@ public static Table initTable(SharedRealm sharedRealm) {
     }
 
     public static NullTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
-        if (sharedRealm.hasTable("class_NullTypes")) {
-            Table table = sharedRealm.getTable("class_NullTypes");
-            final long columnCount = table.getColumnCount();
-            if (columnCount != 21) {
-                if (columnCount < 21) {
-                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 21 but was " + columnCount);
-                }
-                if (allowExtraColumns) {
-                    RealmLog.debug("Field count is more than expected - expected 21 but was %1$d", columnCount);
-                } else {
-                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 21 but was " + columnCount);
-                }
+        if (!sharedRealm.hasTable("class_NullTypes")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'NullTypes' class is missing from the schema for this Realm.");
+        }
+        Table table = sharedRealm.getTable("class_NullTypes");
+        final long columnCount = table.getColumnCount();
+        if (columnCount != 21) {
+            if (columnCount < 21) {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 21 but was " + columnCount);
             }
-            Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
-            for (long i = 0; i < columnCount; i++) {
-                columnTypes.put(table.getColumnName(i), table.getColumnType(i));
+            if (allowExtraColumns) {
+                RealmLog.debug("Field count is more than expected - expected 21 but was %1$d", columnCount);
+            } else {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 21 but was " + columnCount);
             }
+        }
+        Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
+        for (long i = 0; i < columnCount; i++) {
+            columnTypes.put(table.getColumnName(i), table.getColumnType(i));
+        }
 
-            final NullTypesColumnInfo columnInfo = new NullTypesColumnInfo(sharedRealm.getPath(), table);
+        final NullTypesColumnInfo columnInfo = new NullTypesColumnInfo(sharedRealm.getPath(), table);
 
-            if (table.hasPrimaryKey()) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
-            }
+        if (table.hasPrimaryKey()) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
+        }
 
-            if (!columnTypes.containsKey("fieldStringNotNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldStringNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldStringNotNull") != RealmFieldType.STRING) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'fieldStringNotNull' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.fieldStringNotNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldStringNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldStringNotNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldStringNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldStringNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldStringNull") != RealmFieldType.STRING) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'fieldStringNull' in existing Realm file.");
-            }
-            if (!table.isColumnNullable(columnInfo.fieldStringNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldStringNull' is required. Either set @Required to field 'fieldStringNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldBooleanNotNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBooleanNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldBooleanNotNull") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNotNull' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.fieldBooleanNotNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBooleanNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBooleanNotNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldBooleanNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBooleanNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldBooleanNull") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNull' in existing Realm file.");
-            }
-            if (!table.isColumnNullable(columnInfo.fieldBooleanNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldBooleanNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldBooleanNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldBytesNotNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBytesNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldBytesNotNull") != RealmFieldType.BINARY) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNotNull' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.fieldBytesNotNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBytesNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBytesNotNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldBytesNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBytesNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldBytesNull") != RealmFieldType.BINARY) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNull' in existing Realm file.");
-            }
-            if (!table.isColumnNullable(columnInfo.fieldBytesNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBytesNull' is required. Either set @Required to field 'fieldBytesNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldByteNotNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldByteNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldByteNotNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Byte' for field 'fieldByteNotNull' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.fieldByteNotNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldByteNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldByteNotNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldByteNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldByteNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldByteNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Byte' for field 'fieldByteNull' in existing Realm file.");
-            }
-            if (!table.isColumnNullable(columnInfo.fieldByteNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldByteNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldByteNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldShortNotNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldShortNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldShortNotNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Short' for field 'fieldShortNotNull' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.fieldShortNotNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldShortNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldShortNotNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldShortNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldShortNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldShortNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Short' for field 'fieldShortNull' in existing Realm file.");
-            }
-            if (!table.isColumnNullable(columnInfo.fieldShortNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldShortNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldShortNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldIntegerNotNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldIntegerNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldIntegerNotNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNotNull' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.fieldIntegerNotNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldIntegerNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldIntegerNotNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldIntegerNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldIntegerNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldIntegerNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNull' in existing Realm file.");
-            }
-            if (!table.isColumnNullable(columnInfo.fieldIntegerNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldIntegerNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldIntegerNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldLongNotNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldLongNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldLongNotNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Long' for field 'fieldLongNotNull' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.fieldLongNotNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldLongNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldLongNotNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldLongNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldLongNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldLongNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Long' for field 'fieldLongNull' in existing Realm file.");
-            }
-            if (!table.isColumnNullable(columnInfo.fieldLongNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldLongNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldLongNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldFloatNotNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldFloatNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldFloatNotNull") != RealmFieldType.FLOAT) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Float' for field 'fieldFloatNotNull' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.fieldFloatNotNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldFloatNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldFloatNotNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldFloatNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldFloatNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldFloatNull") != RealmFieldType.FLOAT) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Float' for field 'fieldFloatNull' in existing Realm file.");
-            }
-            if (!table.isColumnNullable(columnInfo.fieldFloatNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldFloatNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldFloatNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldDoubleNotNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDoubleNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldDoubleNotNull") != RealmFieldType.DOUBLE) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Double' for field 'fieldDoubleNotNull' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.fieldDoubleNotNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDoubleNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDoubleNotNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldDoubleNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDoubleNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldDoubleNull") != RealmFieldType.DOUBLE) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Double' for field 'fieldDoubleNull' in existing Realm file.");
-            }
-            if (!table.isColumnNullable(columnInfo.fieldDoubleNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldDoubleNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldDoubleNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldDateNotNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDateNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldDateNotNull") != RealmFieldType.DATE) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'fieldDateNotNull' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.fieldDateNotNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDateNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDateNotNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldDateNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDateNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldDateNull") != RealmFieldType.DATE) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'fieldDateNull' in existing Realm file.");
-            }
-            if (!table.isColumnNullable(columnInfo.fieldDateNullIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDateNull' is required. Either set @Required to field 'fieldDateNull' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("fieldObjectNull")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldObjectNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("fieldObjectNull") != RealmFieldType.OBJECT) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'NullTypes' for field 'fieldObjectNull'");
-            }
-            if (!sharedRealm.hasTable("class_NullTypes")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_NullTypes' for field 'fieldObjectNull'");
-            }
-            Table table_20 = sharedRealm.getTable("class_NullTypes");
-            if (!table.getLinkTarget(columnInfo.fieldObjectNullIndex).hasSameSchema(table_20)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'fieldObjectNull': '" + table.getLinkTarget(columnInfo.fieldObjectNullIndex).getName() + "' expected - was '" + table_20.getName() + "'");
-            }
-            return columnInfo;
-        } else {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'NullTypes' class is missing from the schema for this Realm.");
+        if (!columnTypes.containsKey("fieldStringNotNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldStringNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldStringNotNull") != RealmFieldType.STRING) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'fieldStringNotNull' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.fieldStringNotNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldStringNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldStringNotNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldStringNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldStringNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldStringNull") != RealmFieldType.STRING) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'fieldStringNull' in existing Realm file.");
+        }
+        if (!table.isColumnNullable(columnInfo.fieldStringNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldStringNull' is required. Either set @Required to field 'fieldStringNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldBooleanNotNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBooleanNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldBooleanNotNull") != RealmFieldType.BOOLEAN) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNotNull' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.fieldBooleanNotNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBooleanNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBooleanNotNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldBooleanNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBooleanNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldBooleanNull") != RealmFieldType.BOOLEAN) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNull' in existing Realm file.");
+        }
+        if (!table.isColumnNullable(columnInfo.fieldBooleanNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldBooleanNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldBooleanNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldBytesNotNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBytesNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldBytesNotNull") != RealmFieldType.BINARY) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNotNull' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.fieldBytesNotNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBytesNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBytesNotNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldBytesNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBytesNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldBytesNull") != RealmFieldType.BINARY) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNull' in existing Realm file.");
+        }
+        if (!table.isColumnNullable(columnInfo.fieldBytesNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBytesNull' is required. Either set @Required to field 'fieldBytesNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldByteNotNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldByteNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldByteNotNull") != RealmFieldType.INTEGER) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Byte' for field 'fieldByteNotNull' in existing Realm file.");
         }
+        if (table.isColumnNullable(columnInfo.fieldByteNotNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldByteNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldByteNotNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldByteNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldByteNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldByteNull") != RealmFieldType.INTEGER) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Byte' for field 'fieldByteNull' in existing Realm file.");
+        }
+        if (!table.isColumnNullable(columnInfo.fieldByteNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldByteNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldByteNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldShortNotNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldShortNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldShortNotNull") != RealmFieldType.INTEGER) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Short' for field 'fieldShortNotNull' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.fieldShortNotNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldShortNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldShortNotNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldShortNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldShortNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldShortNull") != RealmFieldType.INTEGER) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Short' for field 'fieldShortNull' in existing Realm file.");
+        }
+        if (!table.isColumnNullable(columnInfo.fieldShortNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldShortNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldShortNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldIntegerNotNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldIntegerNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldIntegerNotNull") != RealmFieldType.INTEGER) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNotNull' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.fieldIntegerNotNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldIntegerNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldIntegerNotNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldIntegerNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldIntegerNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldIntegerNull") != RealmFieldType.INTEGER) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNull' in existing Realm file.");
+        }
+        if (!table.isColumnNullable(columnInfo.fieldIntegerNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldIntegerNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldIntegerNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldLongNotNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldLongNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldLongNotNull") != RealmFieldType.INTEGER) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Long' for field 'fieldLongNotNull' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.fieldLongNotNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldLongNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldLongNotNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldLongNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldLongNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldLongNull") != RealmFieldType.INTEGER) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Long' for field 'fieldLongNull' in existing Realm file.");
+        }
+        if (!table.isColumnNullable(columnInfo.fieldLongNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldLongNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldLongNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldFloatNotNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldFloatNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldFloatNotNull") != RealmFieldType.FLOAT) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Float' for field 'fieldFloatNotNull' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.fieldFloatNotNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldFloatNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldFloatNotNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldFloatNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldFloatNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldFloatNull") != RealmFieldType.FLOAT) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Float' for field 'fieldFloatNull' in existing Realm file.");
+        }
+        if (!table.isColumnNullable(columnInfo.fieldFloatNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldFloatNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldFloatNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldDoubleNotNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDoubleNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldDoubleNotNull") != RealmFieldType.DOUBLE) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Double' for field 'fieldDoubleNotNull' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.fieldDoubleNotNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDoubleNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDoubleNotNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldDoubleNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDoubleNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldDoubleNull") != RealmFieldType.DOUBLE) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Double' for field 'fieldDoubleNull' in existing Realm file.");
+        }
+        if (!table.isColumnNullable(columnInfo.fieldDoubleNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldDoubleNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldDoubleNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldDateNotNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDateNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldDateNotNull") != RealmFieldType.DATE) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'fieldDateNotNull' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.fieldDateNotNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDateNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDateNotNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldDateNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDateNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldDateNull") != RealmFieldType.DATE) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'fieldDateNull' in existing Realm file.");
+        }
+        if (!table.isColumnNullable(columnInfo.fieldDateNullIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDateNull' is required. Either set @Required to field 'fieldDateNull' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("fieldObjectNull")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldObjectNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("fieldObjectNull") != RealmFieldType.OBJECT) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'NullTypes' for field 'fieldObjectNull'");
+        }
+        if (!sharedRealm.hasTable("class_NullTypes")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_NullTypes' for field 'fieldObjectNull'");
+        }
+        Table table_20 = sharedRealm.getTable("class_NullTypes");
+        if (!table.getLinkTarget(columnInfo.fieldObjectNullIndex).hasSameSchema(table_20)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'fieldObjectNull': '" + table.getLinkTarget(columnInfo.fieldObjectNullIndex).getName() + "' expected - was '" + table_20.getName() + "'");
+        }
+
+        return columnInfo;
     }
 
     public static String getTableName() {
@@ -1272,7 +1314,8 @@ public static String getTableName() {
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
-            if (name.equals("fieldStringNotNull")) {
+            if (false) {
+            } else if (name.equals("fieldStringNotNull")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
                     ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNotNull(null);
@@ -2044,6 +2087,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
     }
 
     @Override
+    @SuppressWarnings("ArrayToString")
     public String toString() {
         if (!RealmObject.isValid(this)) {
             return "Invalid object";
@@ -2137,7 +2181,7 @@ public String toString() {
     }
 
     @Override
-    public ProxyState realmGet$proxyState() {
+    public ProxyState<?> realmGet$proxyState() {
         return proxyState;
     }
 
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 694515e02c..8336e88e4b 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -90,12 +90,14 @@ public final SimpleColumnInfo clone() {
         proxyState.setExcludeFields$realm(context.getExcludeFields());
     }
 
+    @Override
     @SuppressWarnings("cast")
     public String realmGet$name() {
         proxyState.getRealm$realm().checkIfValid();
         return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.nameIndex);
     }
 
+    @Override
     public void realmSet$name(String value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -118,12 +120,14 @@ public final SimpleColumnInfo clone() {
         proxyState.getRow$realm().setString(columnInfo.nameIndex, value);
     }
 
+    @Override
     @SuppressWarnings("cast")
     public int realmGet$age() {
         proxyState.getRealm$realm().checkIfValid();
         return (int) proxyState.getRow$realm().getLong(columnInfo.ageIndex);
     }
 
+    @Override
     public void realmSet$age(int value) {
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
@@ -160,52 +164,52 @@ public static Table initTable(SharedRealm sharedRealm) {
     }
 
     public static SimpleColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
-        if (sharedRealm.hasTable("class_Simple")) {
-            Table table = sharedRealm.getTable("class_Simple");
-            final long columnCount = table.getColumnCount();
-            if (columnCount != 2) {
-                if (columnCount < 2) {
-                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 2 but was " + columnCount);
-                }
-                if (allowExtraColumns) {
-                    RealmLog.debug("Field count is more than expected - expected 2 but was %1$d", columnCount);
-                } else {
-                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 2 but was " + columnCount);
-                }
+        if (!sharedRealm.hasTable("class_Simple")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'Simple' class is missing from the schema for this Realm.");
+        }
+        Table table = sharedRealm.getTable("class_Simple");
+        final long columnCount = table.getColumnCount();
+        if (columnCount != 2) {
+            if (columnCount < 2) {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 2 but was " + columnCount);
             }
-            Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
-            for (long i = 0; i < columnCount; i++) {
-                columnTypes.put(table.getColumnName(i), table.getColumnType(i));
+            if (allowExtraColumns) {
+                RealmLog.debug("Field count is more than expected - expected 2 but was %1$d", columnCount);
+            } else {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 2 but was " + columnCount);
             }
+        }
+        Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
+        for (long i = 0; i < columnCount; i++) {
+            columnTypes.put(table.getColumnName(i), table.getColumnType(i));
+        }
 
-            final SimpleColumnInfo columnInfo = new SimpleColumnInfo(sharedRealm.getPath(), table);
+        final SimpleColumnInfo columnInfo = new SimpleColumnInfo(sharedRealm.getPath(), table);
 
-            if (table.hasPrimaryKey()) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
-            }
+        if (table.hasPrimaryKey()) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
+        }
 
-            if (!columnTypes.containsKey("name")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'name' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("name") != RealmFieldType.STRING) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'name' in existing Realm file.");
-            }
-            if (!table.isColumnNullable(columnInfo.nameIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'name' is required. Either set @Required to field 'name' or migrate using RealmObjectSchema.setNullable().");
-            }
-            if (!columnTypes.containsKey("age")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'age' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-            }
-            if (columnTypes.get("age") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'int' for field 'age' in existing Realm file.");
-            }
-            if (table.isColumnNullable(columnInfo.ageIndex)) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'age' does support null values in the existing Realm file. Use corresponding boxed type for field 'age' or migrate using RealmObjectSchema.setNullable().");
-            }
-            return columnInfo;
-        } else {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'Simple' class is missing from the schema for this Realm.");
+        if (!columnTypes.containsKey("name")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'name' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        }
+        if (columnTypes.get("name") != RealmFieldType.STRING) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'name' in existing Realm file.");
+        }
+        if (!table.isColumnNullable(columnInfo.nameIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'name' is required. Either set @Required to field 'name' or migrate using RealmObjectSchema.setNullable().");
+        }
+        if (!columnTypes.containsKey("age")) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'age' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
         }
+        if (columnTypes.get("age") != RealmFieldType.INTEGER) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'int' for field 'age' in existing Realm file.");
+        }
+        if (table.isColumnNullable(columnInfo.ageIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'age' does support null values in the existing Realm file. Use corresponding boxed type for field 'age' or migrate using RealmObjectSchema.setNullable().");
+        }
+
+        return columnInfo;
     }
 
     public static String getTableName() {
@@ -246,7 +250,8 @@ public static String getTableName() {
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
-            if (name.equals("name")) {
+            if (false) {
+            } else if (name.equals("name")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
                     ((SimpleRealmProxyInterface) obj).realmSet$name(null);
@@ -407,7 +412,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
     }
 
     @Override
-    public ProxyState realmGet$proxyState() {
+    public ProxyState<?> realmGet$proxyState() {
         return proxyState;
     }
 
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java b/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
index b0961f76de..80d74d91b9 100644
--- a/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
@@ -20,12 +20,15 @@
 
 import io.realm.RealmList;
 import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
 import io.realm.annotations.PrimaryKey;
 import io.realm.annotations.Required;
 
 public class AllTypes extends RealmObject {
 
     public static final String TAG = "AllTypes";
+    public static final String FIELD_PARENTS = "columnObject";
 
     @PrimaryKey
     private String columnString;
@@ -39,6 +42,8 @@
     private byte[] columnBinary;
     private AllTypes columnObject;
     private RealmList<AllTypes> columnRealmList;
+    @LinkingObjects(FIELD_PARENTS)
+    private final RealmResults<AllTypes> parentObjects = null;
 
     public String getColumnString() {
         return realmGet$columnString();
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/BacklinkTarget.java b/realm/realm-annotations-processor/src/test/resources/some/test/BacklinkTarget.java
new file mode 100644
index 0000000000..40632c1a7d
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/BacklinkTarget.java
@@ -0,0 +1,12 @@
+package some.test;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class BacklinkTarget extends RealmObject {
+    private String id;
+    private Backlinks child;
+    private RealmList<Backlinks> children;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks.java b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks.java
new file mode 100644
index 0000000000..8ad6f6e435
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks.java
@@ -0,0 +1,16 @@
+package some.test;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class Backlinks extends RealmObject {
+    private int id;
+
+    @LinkingObjects("child")
+    private final RealmResults<BacklinkTarget> simpleParents = null;
+
+    @LinkingObjects("children")
+    private final RealmResults<BacklinkTarget> listParents = null;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_Ignored.java b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_Ignored.java
new file mode 100644
index 0000000000..acceae1ffb
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_Ignored.java
@@ -0,0 +1,15 @@
+package some.test;
+
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+import io.realm.annotations.Ignore;
+
+public class Backlinks_Ignored extends RealmObject {
+    private int id;
+
+    // An  @Ignored, backlinked field is completely ignored
+    @Ignore
+    @LinkingObjects("foo")
+    private int parents = 0;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_InvalidFieldType.java b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_InvalidFieldType.java
new file mode 100644
index 0000000000..4c6afb1098
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_InvalidFieldType.java
@@ -0,0 +1,13 @@
+package some.test;
+
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class Backlinks_InvalidFieldType extends RealmObject {
+    private int id;
+
+    // Backlinks must be RealmResults
+    @LinkingObjects("child")
+    private final BacklinkTarget parents = null;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_LinkedFields.java b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_LinkedFields.java
new file mode 100644
index 0000000000..d2522269e4
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_LinkedFields.java
@@ -0,0 +1,14 @@
+package some.test;
+
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class Backlinks_LinkedFields extends RealmObject {
+    private int id;
+
+    // Defining a backlink more than one levels back is not supported.
+    // It can be queried though: `equalTo("selectedFieldParents.selectedFieldParents")
+    @LinkingObjects("child.id")
+    private final RealmResults<BacklinkTarget> parents = null;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_MissingGeneric.java b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_MissingGeneric.java
new file mode 100644
index 0000000000..ababc626a7
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_MissingGeneric.java
@@ -0,0 +1,13 @@
+package some.test;
+
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class Backlinks_MissingGeneric extends RealmObject {
+    private int id;
+
+    // Forgot to specify the backlink generic param
+    @LinkingObjects("child")
+    private final RealmResults parents = null;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_MissingParameter.java b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_MissingParameter.java
new file mode 100644
index 0000000000..dec9d6a6ec
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_MissingParameter.java
@@ -0,0 +1,13 @@
+package some.test;
+
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class Backlinks_MissingParameter extends RealmObject {
+    private int id;
+
+    // Forgot to specify the backlinked field
+    @LinkingObjects
+    private final RealmResults<BacklinkTarget> parents = null;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_NotFinal.java b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_NotFinal.java
new file mode 100644
index 0000000000..97c406b82d
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_NotFinal.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class Backlinks_NotFinal extends RealmObject {
+    private int id;
+
+    // The field named in the @LinkingObjects annotation must be final
+    @LinkingObjects("child")
+    private RealmResults<BacklinkTarget> simpleParents = null;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_NotFound.java b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_NotFound.java
new file mode 100644
index 0000000000..05692a71fb
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_NotFound.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class Backlinks_NotFound extends RealmObject {
+    private int id;
+
+    // The argument to the @LinkingObjects annotation must name a field in the target class
+    @LinkingObjects("xxx")
+    private final RealmResults<BacklinkTarget> parents = null;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_Required.java b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_Required.java
new file mode 100644
index 0000000000..5f70fcbbfc
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_Required.java
@@ -0,0 +1,15 @@
+package some.test;
+
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+import io.realm.annotations.Required;
+
+public class Backlinks_Required extends RealmObject {
+    private int id;
+
+    // A backlinked field may not be @Required
+    @Required
+    @LinkingObjects("child")
+    private final RealmResults<BacklinkTarget> parents = null;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_WrongType.java b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_WrongType.java
new file mode 100644
index 0000000000..a09363cab4
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_WrongType.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class Backlinks_WrongType extends RealmObject {
+    private int id;
+
+    // The type of the field named in the @LinkingObjects annotation must match
+    // the generic type of the annotated field
+    @LinkingObjects("child")
+    private final RealmResults<BacklinkTarget> parents = null;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/FieldRealmResults.java b/realm/realm-annotations-processor/src/test/resources/some/test/FieldRealmResults.java
new file mode 100644
index 0000000000..95c68945f7
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/FieldRealmResults.java
@@ -0,0 +1,10 @@
+package some.test;
+
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+
+public class FieldRealmResults extends RealmObject {
+
+    // RealmResults should only be allowed if combined with a @LinkingObjects annotation
+    private RealmResults<FieldRealmResults> results;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InvalidAppModuleMixedParameters.java b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidAllTypesModuleMixedParameters.java
similarity index 100%
rename from realm/realm-annotations-processor/src/test/resources/some/test/InvalidAppModuleMixedParameters.java
rename to realm/realm-annotations-processor/src/test/resources/some/test/InvalidAllTypesModuleMixedParameters.java
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InvalidAppModuleWrongType.java b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidAllTypesModuleWrongType.java
similarity index 100%
rename from realm/realm-annotations-processor/src/test/resources/some/test/InvalidAppModuleWrongType.java
rename to realm/realm-annotations-processor/src/test/resources/some/test/InvalidAllTypesModuleWrongType.java
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InvalidModelRealmModel_3.java b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidModelRealmModel_3.java
index d4adc862a8..9e0b5130eb 100644
--- a/realm/realm-annotations-processor/src/test/resources/some/test/InvalidModelRealmModel_3.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidModelRealmModel_3.java
@@ -22,6 +22,6 @@
 
 // Invalid POJO, you can't extends from another class besides RealmObject
 @RealmClass
-public class ValidModelPojo_3 extends Booleans implements RealmModel {
+public class InvalidModelRealmModel_3 extends Booleans implements RealmModel {
     public String id;
 }
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index b7b5097c1f..6d22e5dda3 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -124,12 +124,18 @@ repositories {
 }
 
 dependencies {
-    objectServerAnnotationProcessor project(':realm-annotations-processor')
+
     provided 'io.reactivex:rxjava:1.1.0'
     provided 'com.google.code.findbugs:findbugs-annotations:3.0.1'
+
     compile "io.realm:realm-annotations:${version}"
     compile 'com.getkeepsafe.relinker:relinker:1.2.2'
+
+    objectServerAnnotationProcessor project(':realm-annotations-processor')
     objectServerCompile 'com.squareup.okhttp3:okhttp:3.4.1'
+
+    androidTestAnnotationProcessor project(':realm-annotations-processor')
+    androidTestCompile fileTree(dir: 'testLibs', include: ['*.jar'])
     androidTestCompile 'io.reactivex:rxjava:1.1.0'
     androidTestCompile 'com.android.support:support-annotations:25.2.0'
     androidTestCompile 'com.android.support.test:runner:0.5'
@@ -139,7 +145,6 @@ dependencies {
     androidTestCompile 'org.hamcrest:hamcrest-library:1.3'
     androidTestCompile 'com.opencsv:opencsv:3.4'
     androidTestCompile 'dk.ilios:spanner:0.6.0'
-    androidTestAnnotationProcessor project(':realm-annotations-processor')
 }
 
 task sourcesJar(type: Jar) {
diff --git a/realm/realm-library/src/androidTest/assets/backlinks-fieldInUse.realm b/realm/realm-library/src/androidTest/assets/backlinks-fieldInUse.realm
new file mode 100644
index 0000000000..a55bd44ac3
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/backlinks-fieldInUse.realm differ
diff --git a/realm/realm-library/src/androidTest/assets/backlinks-missingSourceClass.realm b/realm/realm-library/src/androidTest/assets/backlinks-missingSourceClass.realm
new file mode 100644
index 0000000000..34a6e03968
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/backlinks-missingSourceClass.realm differ
diff --git a/realm/realm-library/src/androidTest/assets/backlinks-missingSourceField.realm b/realm/realm-library/src/androidTest/assets/backlinks-missingSourceField.realm
new file mode 100644
index 0000000000..6fe07400b3
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/backlinks-missingSourceField.realm differ
diff --git a/realm/realm-library/src/androidTest/assets/backlinks-sourceFieldWrongType.realm b/realm/realm-library/src/androidTest/assets/backlinks-sourceFieldWrongType.realm
new file mode 100644
index 0000000000..0cc76c03f2
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/backlinks-sourceFieldWrongType.realm differ
diff --git a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
index 09b297ae05..ba33c31d0c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
@@ -145,7 +145,7 @@ public void insert_realmModel() {
         allTypes.columnDouble = 3.1415;
         allTypes.columnFloat = 1.234567f;
         allTypes.columnString = "test data";
-        allTypes.columnByte = 0b0010_1010;
+        allTypes.columnByte = 0x2A;
 
         realm.beginTransaction();
         realm.insert(allTypes);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
index 44ee9ddb91..e0208b45b5 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
@@ -1241,7 +1241,7 @@ public void toString_nullValues() {
         assertTrue(str.contains(NullTypes.FIELD_LIST_NULL + ":RealmList<NullTypes>[0]"));
     }
 
-
+    @Test
     public void testExceptionMessage() {
         // Tests for https://github.com/realm/realm-java/issues/2141
         realm.beginTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index 1f82f9326b..b5b1202400 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -295,7 +295,7 @@ public void execute(DynamicRealm realm) {
 
     @Test
     public void executeTransaction_cancelled() {
-        final AtomicReference<RuntimeException> thrownException = new AtomicReference<>(null);
+        final AtomicReference<RuntimeException> thrownException = new AtomicReference<RuntimeException>(null);
 
         assertEquals(0, realm.where(Owner.CLASS_NAME).count());
         try {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
new file mode 100644
index 0000000000..766d85799e
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.rule.TestRealmConfigurationFactory;
+
+@RunWith(AndroidJUnit4.class)
+public class LinkingObjectsDynamicTests {
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private Realm realm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void dynamicQuery_invalidSyntax() {
+        String[] invalidBacklinks = new String[] {
+            "linkingObject(x",
+            "linkingObject(x.y",
+            "linkingObject(x.y)",
+            "linkingObject(x.y).",
+            "linkingObject(x.y)..z",
+            "linkingObject(x.y).linkingObjects(x1.y1).z"
+        };
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
new file mode 100644
index 0000000000..729a6b3d71
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
@@ -0,0 +1,853 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.BacklinksMissingFieldSourceModule;
+import io.realm.entities.BacklinksMissingFieldTargetModule;
+import io.realm.entities.BacklinksSource;
+import io.realm.entities.BacklinksTarget;
+import io.realm.entities.BacklinksWrongTypeSourceModule;
+import io.realm.entities.BacklinksWrongTypeTargetModule;
+import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class LinkingObjectsManagedTests {
+    private interface PostConditions {
+        void run(Realm realm);
+    }
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Realm realm;
+    private Context context;
+
+    @Before
+    public void setUp() {
+        context = InstrumentationRegistry.getInstrumentation().getContext();
+
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    // Setting the linked object field creates the correct backlink
+    @Test
+    public void basic_singleBacklinkObject() {
+        realm.beginTransaction();
+        AllJavaTypes child = realm.createObject(AllJavaTypes.class, 1);
+        AllJavaTypes parent = realm.createObject(AllJavaTypes.class, 2);
+        parent.setFieldObject(child);
+        realm.commitTransaction();
+
+        assertEquals(1, child.getObjectParents().size());
+        assertTrue(child.getObjectParents().contains(parent));
+    }
+
+    // Setting a linked list field creates the correct backlink
+    @Test
+    public void basic_singleBacklinkList() {
+        realm.beginTransaction();
+        AllJavaTypes child = realm.createObject(AllJavaTypes.class, 1);
+        AllJavaTypes parent = realm.createObject(AllJavaTypes.class, 2);
+        parent.getFieldList().add(child);
+        realm.commitTransaction();
+
+        assertEquals(1, child.getListParents().size());
+        assertTrue(child.getListParents().contains(parent));
+    }
+
+    // Setting multiple object links creates multiple backlinks
+    @Test
+    public void basic_multipleBacklinksObject() {
+        realm.beginTransaction();
+        AllJavaTypes child = realm.createObject(AllJavaTypes.class, 1);
+        AllJavaTypes parent1 = realm.createObject(AllJavaTypes.class, 2);
+        AllJavaTypes parent2 = realm.createObject(AllJavaTypes.class, 3);
+        parent1.setFieldObject(child);
+        parent2.setFieldObject(child);
+        realm.commitTransaction();
+        assertEquals(2, child.getObjectParents().size());
+    }
+
+    // Setting multiple list links creates multiple backlinks
+    @Test
+    public void basic_multipleBacklinksList() {
+        realm.beginTransaction();
+        AllJavaTypes child = realm.createObject(AllJavaTypes.class, 1);
+        AllJavaTypes parent1 = realm.createObject(AllJavaTypes.class, 2);
+        AllJavaTypes parent2 = realm.createObject(AllJavaTypes.class, 3);
+        parent1.getFieldList().add(child);
+        parent2.getFieldList().add(child);
+        realm.commitTransaction();
+        assertEquals(2, child.getListParents().size());
+    }
+
+    // Adding multiple list links creates multiple backlinks,
+    // even if the links are to a single object
+    @Test
+    public void basic_multipleReferencesFromParentList() {
+        realm.beginTransaction();
+        AllJavaTypes child = realm.createObject(AllJavaTypes.class, 1);
+        AllJavaTypes parent = realm.createObject(AllJavaTypes.class, 2);
+        parent.getFieldList().add(child);
+        parent.getFieldList().add(child);
+        realm.commitTransaction();
+
+        // One entry for each reference, so two references from a LinkList will
+        // result in two backlinks.
+        assertEquals(2, child.getListParents().size());
+        assertEquals(parent, child.getListParents().first());
+        assertEquals(parent, child.getListParents().last());
+    }
+
+    // A listener registered on the backlinked object should be called when a commit adds a backlink
+    @Test
+    @RunTestInLooperThread
+    public void notification_onCommitModelObject() {
+        final Realm looperThreadRealm = looperThread.realm;
+
+        looperThreadRealm.beginTransaction();
+        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
+        looperThreadRealm.commitTransaction();
+
+        final AtomicInteger counter = new AtomicInteger(0);
+        RealmChangeListener<AllJavaTypes> listener = new RealmChangeListener<AllJavaTypes>() {
+            @Override
+            public void onChange(AllJavaTypes object) {
+                counter.incrementAndGet();
+            }
+        };
+        child.addChangeListener(listener);
+
+        looperThreadRealm.beginTransaction();
+        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);
+        parent.setFieldObject(child);
+        looperThreadRealm.commitTransaction();
+
+        verifyPostConditions(
+            looperThreadRealm,
+            new PostConditions() {
+                public void run(Realm realm) {
+                    assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                    assertEquals(1, counter.get());
+                }
+            },
+            child, parent);
+    }
+
+
+
+    // A listener registered on the backlinked object should not be called after the listener is removed
+    @Test
+    @RunTestInLooperThread
+    public void notification_notSentAfterUnregisterListenerModelObject() {
+        final Realm looperThreadRealm = looperThread.realm;
+
+        looperThreadRealm.beginTransaction();
+        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
+        looperThreadRealm.commitTransaction();
+
+        RealmChangeListener<AllJavaTypes> listener = new RealmChangeListener<AllJavaTypes>() {
+            @Override
+            public void onChange(AllJavaTypes object) {
+                fail("Not expecting notification after unregister");
+            }
+        };
+        child.addChangeListener(listener);
+        child.removeChangeListener(listener);
+
+        looperThreadRealm.beginTransaction();
+        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);
+        parent.setFieldObject(child);
+        looperThreadRealm.commitTransaction();
+
+        verifyPostConditions(
+            looperThreadRealm,
+            new PostConditions() {
+                public void run(Realm realm) {
+                    assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                }
+            },
+            child, parent);
+    }
+
+    // A listener registered on the backlinked object should be called when a backlinked object is deleted
+    @Test
+    @RunTestInLooperThread
+    public void notification_onDeleteModelObject() {
+        final Realm looperThreadRealm = looperThread.realm;
+
+        looperThreadRealm.beginTransaction();
+        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
+        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);
+        parent.setFieldObject(child);
+        looperThreadRealm.commitTransaction();
+
+        final AtomicInteger counter = new AtomicInteger(0);
+        RealmChangeListener<AllJavaTypes> listener = new RealmChangeListener<AllJavaTypes>() {
+            @Override
+            public void onChange(AllJavaTypes object) {
+                counter.incrementAndGet();
+            }
+        };
+        child.addChangeListener(listener);
+
+        looperThreadRealm.beginTransaction();
+        looperThreadRealm.where(AllJavaTypes.class).equalTo("fieldId", 1).findAll().deleteAllFromRealm();
+        looperThreadRealm.commitTransaction();
+
+        verifyPostConditions(
+            looperThreadRealm,
+            new PostConditions() {
+                public void run(Realm realm) {
+                    assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                    assertEquals(1, counter.get());
+                }
+            },
+            child, parent);
+    }
+
+    // A listener registered on the backlinked object is called
+    // for an unrelated change on the an object of the same type!!
+    // This test exists only to document existing (but odd) behavior.
+    @Test
+    @RunTestInLooperThread
+    public void notification_notSentOnUnrelatedChangeModelObject() {
+        final Realm looperThreadRealm = looperThread.realm;
+
+        looperThreadRealm.beginTransaction();
+        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
+        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);
+        looperThreadRealm.commitTransaction();
+
+        final AtomicInteger counter = new AtomicInteger(0);
+        RealmChangeListener<AllJavaTypes> listener = new RealmChangeListener<AllJavaTypes>() {
+            @Override
+            public void onChange(AllJavaTypes object) {
+                counter.incrementAndGet();
+            }
+        };
+        child.addChangeListener(listener);
+
+        looperThreadRealm.beginTransaction();
+        looperThreadRealm.where(AllJavaTypes.class).equalTo("fieldId", 1).findAll().deleteAllFromRealm();
+        looperThreadRealm.commitTransaction();
+
+        verifyPostConditions(
+            looperThreadRealm,
+            new PostConditions() {
+                public void run(Realm realm) {
+                    assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                    assertEquals(1, counter.get());
+                }
+            },
+            child, parent);
+    }
+
+    // A listener registered on the backlinked field should be called when a commit adds a backlink
+    @Test
+    @RunTestInLooperThread
+    public void notification_onCommitRealmResults() {
+        final Realm looperThreadRealm = looperThread.realm;
+
+        looperThreadRealm.beginTransaction();
+        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
+        looperThreadRealm.commitTransaction();
+
+        final AtomicInteger counter = new AtomicInteger(0);
+        RealmChangeListener<RealmResults<AllJavaTypes>> listener = new RealmChangeListener<RealmResults<AllJavaTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllJavaTypes> object) {
+                counter.incrementAndGet();
+            }
+        };
+        child.getObjectParents().addChangeListener(listener);
+
+        looperThreadRealm.beginTransaction();
+        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);
+        parent.setFieldObject(child);
+        looperThreadRealm.commitTransaction();
+
+        verifyPostConditions(
+            looperThreadRealm,
+            new PostConditions() {
+                public void run(Realm realm) {
+                    assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                    assertEquals(1, counter.get());
+                }
+            },
+            child, parent);
+    }
+
+    // A listener registered on the backlinked field should not be called after the listener is removed
+    @Test
+    @RunTestInLooperThread
+    public void notification_notSentAfterUnregisterListenerRealmResults() {
+        final Realm looperThreadRealm = looperThread.realm;
+
+        looperThreadRealm.beginTransaction();
+        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
+        looperThreadRealm.commitTransaction();
+
+        RealmChangeListener<RealmResults<AllJavaTypes>> listener = new RealmChangeListener<RealmResults<AllJavaTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllJavaTypes> object) {
+                fail("Not expecting notification after unregister");
+            }
+        };
+        RealmResults<AllJavaTypes> objParents = child.getObjectParents();
+        objParents.addChangeListener(listener);
+        objParents.removeChangeListener(listener);
+
+        looperThreadRealm.beginTransaction();
+        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);
+        parent.setFieldObject(child);
+        looperThreadRealm.commitTransaction();
+
+        verifyPostConditions(
+            looperThreadRealm,
+            new PostConditions() {
+                public void run(Realm realm) {
+                    assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                }
+            },
+            child, parent);
+    }
+
+    // A listener registered on the backlinked object should be called when a backlinked object is deleted
+    @Test
+    @RunTestInLooperThread
+    public void notification_onDeleteRealmResults() {
+        final Realm looperThreadRealm = looperThread.realm;
+
+        looperThreadRealm.beginTransaction();
+        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
+        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);
+        parent.setFieldObject(child);
+        looperThreadRealm.commitTransaction();
+
+        final AtomicInteger counter = new AtomicInteger(0);
+        RealmChangeListener<RealmResults<AllJavaTypes>> listener = new RealmChangeListener<RealmResults<AllJavaTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllJavaTypes> object) {
+                counter.incrementAndGet();
+            }
+        };
+        child.getObjectParents().addChangeListener(listener);
+
+        looperThreadRealm.beginTransaction();
+        looperThreadRealm.where(AllJavaTypes.class).equalTo("fieldId", 1).findAll().deleteAllFromRealm();
+        looperThreadRealm.commitTransaction();
+
+        verifyPostConditions(
+            looperThreadRealm,
+            new PostConditions() {
+                public void run(Realm realm) {
+                    assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                    assertEquals(1, counter.get());
+                }
+            },
+            child, parent);
+    }
+
+    // A listener registered on the backlinked object should not called for an unrelated change
+    @Test
+    @RunTestInLooperThread
+    public void notification_notSentOnUnrelatedChangeRealmResults() {
+        final Realm looperThreadRealm = looperThread.realm;
+
+        looperThreadRealm.beginTransaction();
+        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
+        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);
+        looperThreadRealm.commitTransaction();
+
+        RealmChangeListener<RealmResults<AllJavaTypes>> listener = new RealmChangeListener<RealmResults<AllJavaTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllJavaTypes> object) {
+                fail("Not expecting notification after unregister");
+            }
+        };
+        child.getObjectParents().addChangeListener(listener);
+
+        looperThreadRealm.beginTransaction();
+        looperThreadRealm.where(AllJavaTypes.class).equalTo("fieldId", 1).findAll().deleteAllFromRealm();
+        looperThreadRealm.commitTransaction();
+
+        verifyPostConditions(
+            looperThreadRealm,
+            new PostConditions() {
+                public void run(Realm realm) {
+                    assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                }
+            },
+            child, parent);
+    }
+
+    // Fields annotated with @LinkingObjects should not be affected by JSON updates
+    @Test
+    public void json_updateObject() {
+        realm.beginTransaction();
+        AllJavaTypes child = realm.createObject(AllJavaTypes.class, 1);
+        AllJavaTypes parent = realm.createObject(AllJavaTypes.class, 2);
+        parent.setFieldObject(child);
+        realm.commitTransaction();
+
+        RealmResults<AllJavaTypes> parents = child.getObjectParents();
+        assertNotNull(parents);
+        assertEquals(1, parents.size());
+        assertTrue(parents.contains(parent));
+
+        realm.beginTransaction();
+        try {
+            realm.createOrUpdateAllFromJson(AllJavaTypes.class, "[{ \"fieldId\" : 1, \"objectParents\" : null }]");
+        } catch (RealmException e) {
+            fail("Failed loading JSON" + e);
+        }
+        realm.commitTransaction();
+
+        parents = child.getObjectParents();
+        assertNotNull(parents);
+        assertEquals(1, parents.size());
+        assertTrue(parents.contains(parent));
+    }
+
+    // Fields annotated with @LinkingObjects should not be affected by JSON updates
+    @Test
+    public void json_updateList() {
+        realm.beginTransaction();
+        AllJavaTypes child = realm.createObject(AllJavaTypes.class, 1);
+        AllJavaTypes parent = realm.createObject(AllJavaTypes.class, 2);
+        parent.getFieldList().add(child);
+        realm.commitTransaction();
+
+        RealmResults<AllJavaTypes> parents = child.getListParents();
+        assertNotNull(parents);
+        assertEquals(1, parents.size());
+        assertTrue(parents.contains(parent));
+
+        realm.beginTransaction();
+        try {
+            realm.createOrUpdateAllFromJson(AllJavaTypes.class, "[{ \"fieldId\" : 1, \"listParents\" : null }]");
+        } catch (RealmException e) {
+            fail("Failed loading JSON" + e);
+        }
+        realm.commitTransaction();
+
+        parents = child.getListParents();
+        assertNotNull(parents);
+        assertEquals(1, parents.size());
+        assertTrue(parents.contains(parent));
+    }
+
+    // A JSON update should generate a notifcation
+    @Test
+    @RunTestInLooperThread
+    public void json_jsonUpdateCausesNotification() {
+        final Realm looperThreadRealm = looperThread.realm;
+
+        looperThreadRealm.beginTransaction();
+        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 1);
+        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 2);
+        parent.setFieldObject(child);
+        looperThreadRealm.commitTransaction();
+
+        RealmResults<AllJavaTypes> results = looperThreadRealm.where(AllJavaTypes.class).equalTo("fieldId", 1).findAll();
+        assertNotNull(results);
+        assertEquals(results.size(), 1);
+        child = results.first();
+
+        RealmResults<AllJavaTypes> parents = child.getObjectParents();
+        assertNotNull(parents);
+        assertEquals(1, parents.size());
+
+        final AtomicInteger counter = new AtomicInteger(0);
+        RealmChangeListener<AllJavaTypes> listener = new RealmChangeListener<AllJavaTypes>() {
+            @Override
+            public void onChange(AllJavaTypes object) {
+                counter.incrementAndGet();
+            }
+        };
+        child.addChangeListener(listener);
+
+        looperThreadRealm.beginTransaction();
+        try {
+            looperThreadRealm.createOrUpdateAllFromJson(AllJavaTypes.class, "[{ \"fieldId\" : 2, \"fieldObject\" : null }]");
+        } catch (RealmException e) {
+            fail("Failed loading JSON" + e);
+        }
+        looperThreadRealm.commitTransaction();
+
+        verifyPostConditions(
+            looperThreadRealm,
+            new PostConditions() {
+                public void run(Realm realm) {
+                    RealmResults<AllJavaTypes> results = looperThreadRealm.where(AllJavaTypes.class).equalTo("fieldId", 1).findAll();
+                    assertNotNull(results);
+                    assertEquals(results.size(), 1);
+                    AllJavaTypes child = results.first();
+
+                    RealmResults<AllJavaTypes> parents = child.getObjectParents();
+                    assertNotNull(parents);
+                    assertEquals(0, parents.size());
+                    assertEquals(1, counter.get());
+                }
+            },
+            child, parent);
+    }
+
+    /**
+     * Table validation should fail if the backinked column already exists in the target table.
+     * The realm `backlinks-fieldInUse.realm` contains the classes `BacklinksSource` and `BacklinksTarget`
+     * except that in the definition of `BacklinksTarget`, the field parent is defined as:
+     * <pre>
+     * {@code
+     *     private RealmList<BacklinksSource> parents;
+     * }
+     * </pre>
+     */
+    @Test
+    public void migration_backlinkedFieldInUse() {
+        final String realmName = "backlinks-fieldInUse.realm";
+
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+            .name(realmName)
+            .schema(BacklinksSource.class, BacklinksTarget.class)
+            .build();
+
+        try {
+            configFactory.copyRealmFromAssets(context, realmName, realmName);
+
+            Realm localRealm = Realm.getInstance(realmConfig);
+            localRealm.close();
+            fail("A migration should have been required");
+        } catch (IOException e) {
+            fail("Failed copying realm");
+        } catch (RealmMigrationNeededException expected) {
+            assertTrue(expected.getMessage().contains("Field count is"));
+        } finally {
+            Realm.deleteRealm(realmConfig);
+        }
+    }
+
+    /**
+     * Table validation should fail if the backinked column points to a non-existent class.
+     * The realm `backlinks-missingSourceClass.realm` contains two tables very like those
+     * defined by `BacklinksSource` and `BacklinksTarget`.  In it, though, the source class
+     * is named XXXBacklinksSource, like so:
+     * <pre>
+     * {@code
+     * @LinkingObjects("child")
+     *     private final RealmResults<XXXBacklinksSource> parents = null;
+     * }
+     * </pre>
+     * If the both classes were used in the configuration, the test would fail because of the
+     * missing class.  Since the configuration contains only the single class `BacklinksTarget`,
+     * basic validation passes.  Backlink validation, however, should fail, seeking the
+     * `BacklinksSource` table.
+     */
+    @Test
+    public void migration_backlinkedSourceClassDoesntExist() throws IOException {
+        final String realmName = "backlinks-missingSourceClass.realm";
+
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+            .name(realmName)
+            .schema(BacklinksTarget.class)
+            .build();
+
+        try {
+            configFactory.copyRealmFromAssets(context, realmName, realmName);
+
+            Realm localRealm = Realm.getInstance(realmConfig);
+            localRealm.close();
+            fail("A migration should have been required");
+        } catch (IOException e) {
+            fail("Failed copying realm");
+        } catch (RealmMigrationNeededException expected) {
+            assertTrue(expected.getMessage().contains("Cannot find source class"));
+        } finally {
+            Realm.deleteRealm(realmConfig);
+        }
+    }
+
+    /**
+     * Table validation should fail if the backlinked column points to a non-existent field in the source class.
+     * This test is quite a chore to construct!
+     * The realm `backlinks-missingSourceField.realm` was constructed with classes `BacklinksMissingFieldTarget`
+     * and `BacklinksMissingFieldSource`.  They are identical in their definitions to `BacklinkSource` and
+     * `BacklinkTarget` except for their names.  The library `backlinks-missing-field-source.jar` contains
+     * the class `BacklinksMissingFieldSource` and all of its annotation generated code.  The library
+     * `backlinks-missing-field-target.jar` however, contains a version of `BacklinksMissingFieldTarget` that
+     * was compiled with its backlink field referring to a field in `BacklinksMissingFieldSource`, called
+     * `xxxchild`.  Clearly, in order to compile successfully, the definition of `BacklinksMissingFieldSource`
+     * had to be changed accordingly.  The modified version, however, is *NOT* the version that is in
+     * `backlinks-missing-field-source.jar`!
+     * So, now, the proxy in `backlinks-missing-field-source.jar` will correctly validate the its table
+     * (it generated it!). Similarly, the proxy in `backlinks-missing-field-target.jar` will successfully
+     * validate its table.  If we have been living clean lives, though, the validator for
+     * `BacklinksMissingFieldTarget` should notice that there is no field named `BacklinksMissingFieldSource.xxxchild`.
+     */
+    @Test
+    public void migration_backlinkedSourceFieldDoesntExist() {
+        final String realmName = "backlinks-missingSourceField.realm";
+
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+            .name(realmName)
+            .modules(new BacklinksMissingFieldSourceModule(), new BacklinksMissingFieldTargetModule())
+            .build();
+
+        try {
+            configFactory.copyRealmFromAssets(context, realmName, realmName);
+
+            Realm localRealm = Realm.getInstance(realmConfig);
+            localRealm.close();
+            fail("A migration should have been required");
+        } catch (IOException e) {
+            fail("Failed copying realm");
+        } catch (RealmMigrationNeededException expected) {
+            assertTrue(expected.getMessage().contains("Cannot find source field"));
+        } finally {
+            Realm.deleteRealm(realmConfig);
+        }
+    }
+
+    /**
+     * Table validation should fail if the backinked column points to a field of the wrong type.
+     * This test is built in almost exactly the way as was `migration_backlinkedSourceFieldDoesntExist`
+     * The realm `backlinks-sourceFieldWrongType.realm` was constructed with classes `BacklinksWrongTypeTarget`
+     * and `BacklinksWrongTypeSource`.  Again, these two classes are nearly identical in their counterparts
+     * `BacklinkSource` and `BacklinkTarget` except for their names.  Unlike `BacklinkSource`,
+     * `BacklinksWrongTypeSource` has two fields, `child` and `childId`. The first is exactly as it is in
+     * `BacklinkSource`, the second is of type `Integer`.  To construct `backlinks-wrong-type-target.jar`
+     * I reversed the names of the two fields in `BacklinkSource`, and made then adjusted `parents` in
+     * `BacklinkTarget` to point to `childId`.
+     * All of the proxies in in the two jars should correctly validate their tables.  The backlink validation
+     * for `BacklinksWrongTypeTarget` should notice, though, that its `parents` field points to an object
+     * of the wrong type, `Integer`, instead of `BacklinksWrongTypeSource`.
+     */
+    @Test
+    public void migration_backlinkedSourceFieldWrongType() {
+        final String realmName = "backlinks-sourceFieldWrongType.realm";
+
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+            .name(realmName)
+            .modules(new BacklinksWrongTypeSourceModule(), new BacklinksWrongTypeTargetModule())
+            .build();
+
+        try {
+            configFactory.copyRealmFromAssets(context, realmName, realmName);
+
+            Realm localRealm = Realm.getInstance(realmConfig);
+            localRealm.close();
+            fail("A migration should have been required");
+        } catch (IOException e) {
+            fail("Failed copying realm");
+        } catch (RealmMigrationNeededException expected) {
+            assertTrue(expected.getMessage().contains("is not a RealmObject type"));
+        } finally {
+            Realm.deleteRealm(realmConfig);
+        }
+    }
+
+    // Distinct works for backlinks
+    @Test
+    public void query_multipleReferencesWithDistinct() {
+        realm.beginTransaction();
+        AllJavaTypes child = realm.createObject(AllJavaTypes.class, 1);
+        AllJavaTypes parent = realm.createObject(AllJavaTypes.class, 2);
+        parent.getFieldList().add(child);
+        parent.getFieldList().add(child);
+        realm.commitTransaction();
+
+        assertEquals(2, child.getListParents().size());
+
+        RealmResults<AllJavaTypes> distinctParents = child.getListParents().where().distinct("fieldId");
+        assertEquals(1, distinctParents.size());
+        assertTrue(child.getListParents().contains(parent));
+    }
+
+    // Query on a field descriptor starting with a backlink
+    // The test objects are:
+    //             gen1
+    //             / \
+    //         gen2A gen2B
+    //           \\   //
+    //            gen3
+    //  /  = object ref
+    //  // = list ref
+    @Test
+    @Ignore
+    public void query_startWithBacklink() {
+        realm.beginTransaction();
+        AllJavaTypes gen1 = realm.createObject(AllJavaTypes.class, 10);
+
+        AllJavaTypes gen2A = realm.createObject(AllJavaTypes.class, 1);
+        gen2A.setFieldObject(gen1);
+
+        AllJavaTypes gen2B = realm.createObject(AllJavaTypes.class, 2);
+        gen2B.setFieldObject(gen1);
+
+        AllJavaTypes gen3 = realm.createObject(AllJavaTypes.class, 3);
+        RealmList<AllJavaTypes> parents = gen3.getFieldList();
+        parents.add(gen2A);
+        parents.add(gen2B);
+
+        realm.commitTransaction();
+
+        RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class)
+            .greaterThan("objectParents.fieldId", 1)
+            .findAll();
+        assertEquals(1, result.size());
+        assertTrue(result.contains(gen2B));
+    }
+
+    // Query on a field descriptor that ends with a backlink
+    // The test objects are:
+    //             gen1
+    //             / \
+    //         gen2A gen2B
+    //           \\   //
+    //            gen3
+    //  /  = object ref
+    //  // = list ref
+    @Test
+    @Ignore
+    public void query_endWithBacklink() {
+        realm.beginTransaction();
+        AllJavaTypes gen1 = realm.createObject(AllJavaTypes.class, 10);
+
+        AllJavaTypes gen2A = realm.createObject(AllJavaTypes.class, 1);
+        gen2A.setFieldObject(gen1);
+
+        AllJavaTypes gen2B = realm.createObject(AllJavaTypes.class, 2);
+        gen2B.setFieldObject(gen1);
+
+        AllJavaTypes gen3 = realm.createObject(AllJavaTypes.class, 3);
+        RealmList<AllJavaTypes> parents = gen3.getFieldList();
+        parents.add(gen2A);
+        parents.add(gen2B);
+
+        realm.commitTransaction();
+
+        RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class)
+            .isNotNull("objectParents.listParents")
+            .findAll();
+        assertEquals(2, result.size());
+        assertTrue(result.contains(gen2A));
+        assertTrue(result.contains(gen2B));
+    }
+
+    // Query on a field descriptor that has a backlink in the middle
+    // The test objects are:
+    //             gen1
+    //             / \
+    //         gen2A gen2B
+    //           \\   //
+    //            gen3
+    //  /  = object ref
+    //  // = list ref
+    @Test
+    @Ignore
+    public void query_backlinkInMiddle() {
+        realm.beginTransaction();
+        AllJavaTypes gen1 = realm.createObject(AllJavaTypes.class, 10);
+
+        AllJavaTypes gen2A = realm.createObject(AllJavaTypes.class, 1);
+        gen2A.setFieldObject(gen1);
+
+        AllJavaTypes gen2B = realm.createObject(AllJavaTypes.class, 2);
+        gen2B.setFieldObject(gen1);
+
+        AllJavaTypes gen3 = realm.createObject(AllJavaTypes.class, 3);
+        RealmList<AllJavaTypes> parents = gen3.getFieldList();
+        parents.add(gen2A);
+        parents.add(gen2B);
+
+        realm.commitTransaction();
+
+        RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class)
+            .lessThan("objectParents.listParents.fieldId", 4)
+            .findAll();
+        assertEquals(2, result.size());
+    }
+
+    // Based on a quick conversation with Christian Melchior and Mark Rowe,
+    // it appears that notifications are enqueued, briefly, on a non-Java
+    // thread.  That makes their delivery onto the looper thread unpredictable.
+    // Fortunately, it appears that beginning a transaction forces the delivery of
+    // any outstanding notifications.
+    // The closure passed to this method will be run *after* the body of the test
+    // completes, and *after* the notifications have been delivered.  Because the
+    // test method has been popped off the stack any objects referenced only from
+    // the stack are subject to GC.  To hang on to them, until the test completes,
+    // just pass them to the final vararg to this method.
+    // @zaki50 has some evidence that notifications are delivered on a commit.
+    // If that is the case, we may be able to eliminate the ugly begin-commit
+    // that is the prologue to this method.
+    private void verifyPostConditions(final Realm realm, final PostConditions test, final Object... refs) {
+        realm.beginTransaction();
+        realm.commitTransaction();
+
+        // Runnable is guaranteed to be enqueued on the Looper queue, after the notifications
+        looperThread.keepStrongReference.addAll(Arrays.asList(refs));
+        looperThread.postRunnable(
+            new Runnable() {
+                @Override
+                public void run() {
+                    test.run(realm);
+                    looperThread.testComplete();
+                }
+            });
+    }
+}
+
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsUnmanagedTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsUnmanagedTests.java
new file mode 100644
index 0000000000..94fc826d44
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsUnmanagedTests.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import dk.ilios.spanner.All;
+import io.realm.entities.AllJavaTypes;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+@RunWith(AndroidJUnit4.class)
+public class LinkingObjectsUnmanagedTests {
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private Realm realm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    // When unmanaged, an object's backlinks fields have their initialized value (probably null).
+    @Test
+    public void copyFromRealm() {
+        realm.beginTransaction();
+        AllJavaTypes child = realm.createObject(AllJavaTypes.class, 1);
+        AllJavaTypes parent = realm.createObject(AllJavaTypes.class, 2);
+        parent.setFieldObject(child);
+        realm.commitTransaction();
+        assertEquals(1, child.getObjectParents().size());
+        assertEquals(parent, child.getObjectParents().first());
+
+        AllJavaTypes unmanagedChild = realm.copyFromRealm(child);
+        assertEquals(new AllJavaTypes().getObjectParents(), unmanagedChild.getObjectParents());
+    }
+
+    // When managed, an object's backlinks fields get live.
+    @Test
+    public void copyToRealm() {
+        AllJavaTypes unmanagedChild = new AllJavaTypes(1);
+
+        realm.beginTransaction();
+        AllJavaTypes parent = realm.createObject(AllJavaTypes.class, 2);
+        realm.commitTransaction();
+        assertEquals(new AllJavaTypes().getObjectParents(), unmanagedChild.getObjectParents());
+
+        realm.beginTransaction();
+        AllJavaTypes child = realm.copyToRealm(unmanagedChild);
+        parent.setFieldObject(child);
+        realm.commitTransaction();
+
+        RealmResults<AllJavaTypes> parents = child.getObjectParents();
+        assertNotNull(parents);
+        assertEquals(1, parents.size());
+        assertEquals(parent, parents.first());
+    }
+
+    // Test round-trip
+    @Test
+    public void copyToAndFromRealm() {
+        AllJavaTypes unmanagedChild = new AllJavaTypes(1);
+
+        realm.beginTransaction();
+        AllJavaTypes parent = realm.createObject(AllJavaTypes.class, 2);
+        realm.commitTransaction();
+        assertEquals(new AllJavaTypes().getObjectParents(), unmanagedChild.getObjectParents());
+
+        realm.beginTransaction();
+        AllJavaTypes child = realm.copyToRealm(unmanagedChild);
+        parent.setFieldObject(child);
+        realm.commitTransaction();
+
+        RealmResults<AllJavaTypes> parents = child.getObjectParents();
+        assertNotNull(parents);
+        assertEquals(1, parents.size());
+        assertEquals(parent, parents.first());
+
+        unmanagedChild = realm.copyFromRealm(child);
+        assertEquals(unmanagedChild.getFieldId(), 1);
+        assertEquals(new AllJavaTypes().getObjectParents(), unmanagedChild.getObjectParents());
+
+        RealmResults<AllJavaTypes> queryResults = realm.where(AllJavaTypes.class).equalTo("fieldId", 1).findAll();
+        assertEquals(1, queryResults.size());
+
+        child = queryResults.first();
+        parents = child.getObjectParents();
+        assertNotNull(parents);
+        assertEquals(1, parents.size());
+        assertEquals(parent, parents.first());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
index bb873d1956..8e81f62878 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
@@ -796,6 +796,7 @@ public Boolean call() throws Exception {
                         case SORT_2FIELDS:
                         case SORT_MULTI:
                             expected = UnsupportedOperationException.class;
+                            break;
                         default:
                             break;
                     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
index 809dbdf5f7..9cd511e157 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
@@ -760,13 +760,16 @@ public void mutableMethodsOutsideTransactions() {
                     case REMOVE_ALL:
                     case RETAIN_ALL:
                         expected = UnsupportedOperationException.class;
+                        break;
+                    default:
+                        // use default exception
                 }
             }
 
             try {
                 switch (method) {
                     case DELETE_ALL: collection.deleteAllFromRealm(); break;
-                    case ADD_OBJECT: collection.add(new AllJavaTypes());
+                    case ADD_OBJECT: collection.add(new AllJavaTypes()); break;
                     case ADD_ALL_OBJECTS: collection.addAll(Collections.singletonList(new AllJavaTypes())); break;
                     case CLEAR: collection.clear(); break;
                     case REMOVE_OBJECT: collection.remove(new AllJavaTypes()); break;
@@ -847,6 +850,9 @@ public Boolean call() throws Exception {
                         case REMOVE_ALL:
                         case RETAIN_ALL:
                             expected = UnsupportedOperationException.class;
+                            break;
+                        default:
+                            // use default exception
                     }
                 }
 
@@ -854,8 +860,8 @@ public Boolean call() throws Exception {
                     switch (method) {
                         case ADD_OBJECT: collection.add(new AllJavaTypes()); break;
                         case ADD_ALL_OBJECTS: collection.addAll(Collections.singletonList(new AllJavaTypes())); break;
-                        case CLEAR: collection.clear();
-                        case CONTAINS:
+                        case CLEAR: collection.clear(); break;
+                        case CONTAINS: collection.contains(tempObject); break;
                         case CONTAINS_ALL: collection.containsAll(Collections.singletonList(tempObject)); break;
                         case EQUALS:
                             //noinspection ResultOfMethodCallIgnored
diff --git a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
index fd7d5d8035..8e3f499af6 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
@@ -564,7 +564,8 @@ public void looperThreadQuitsLooperEarly() throws InterruptedException {
 
         // Starts background looper and let it hang.
         ExecutorService executorService = Executors.newSingleThreadExecutor();
-        executorService.submit(new Runnable() {
+        //noinspection unused
+        final Future<?> future = executorService.submit(new Runnable() {
             @Override
             public void run() {
                 Looper.prepare(); // Fake background thread with a looper, eg. a IntentService.
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
index ac34cedc51..534730bb58 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
@@ -528,6 +528,11 @@ public void listIterator_closedRealm_methods() {
 
     @Test
     public void listIterator_deleteManagedObjectIndirectly() {
+        if (skipTest(CollectionClass.REALMRESULTS_SNAPSHOT_LIST_BASE,
+                CollectionClass.REALMRESULTS_SNAPSHOT_RESULTS_BASE)) {
+            return;
+        }
+
         realm.beginTransaction();
         ListIterator<AllJavaTypes> it = collection.listIterator();
         it.next();
@@ -542,6 +547,9 @@ public void listIterator_deleteManagedObjectIndirectly() {
             case UNMANAGED_REALMLIST:
                 assertEquals(TEST_SIZE, collection.size());
                 break;
+            default:
+                fail();
+                return;
         }
         it.previous();
         AllJavaTypes types = it.next(); // Iterator can still access the deleted object
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
index d722f024de..5a9ef34cb2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
@@ -369,9 +369,9 @@ public void methods_indexOutOfBounds() {
                     case ADD_ALL_INDEX: collection.addAll(1, Collections.singleton(new AllJavaTypes())); break;
                     case GET_INDEX: collection.get(1); break;
                     case LIST_ITERATOR_INDEX: collection.listIterator(1); break;
-                    case REMOVE_INDEX: collection.remove(1);
-                    case SET: collection.set(1, new AllJavaTypes());
-                    case SUBLIST: collection.subList(1, 2);
+                    case REMOVE_INDEX: collection.remove(1); break;
+                    case SET: collection.set(1, new AllJavaTypes()); break;
+                    case SUBLIST: collection.subList(1, 2); break;
 
                     // Cannot fail with IndexOutOfBounds
                     case FIRST:
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
index 99375d1b2d..1085a371b6 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
@@ -106,6 +106,7 @@ public void getInstanceClearsCacheWhenFailed() {
         realm.close();
         try {
             Realm.getInstance(configB); // Tries to open with key 2.
+            fail();
         } catch (RealmFileException expected) {
             assertEquals(expected.getKind(), RealmFileException.Kind.ACCESS_ERROR);
             // Deletes Realm so key 2 works. This should work as a Realm shouldn't be cached
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index 0986180f0c..7b191920be 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -391,7 +391,7 @@ public void upgradeVersionWithNoMigration() {
             fail();
         } catch (RealmMigrationNeededException expected) {
             // And it should come with a cause.
-            assertNotNull(expected.getCause());
+            assertEquals("Realm on disk need to migrate from v0 to v42", expected.getMessage());
         }
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
index 718abc0f41..351024dcd8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
@@ -37,6 +37,7 @@
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.charset.Charset;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Date;
@@ -66,6 +67,8 @@
 
 @RunWith(AndroidJUnit4.class)
 public class RealmJsonTests {
+    private static final Charset UTF_8 = Charset.forName("UTF-8");
+
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
@@ -87,7 +90,7 @@ public void tearDown() {
     }
 
     private InputStream convertJsonObjectToStream(JSONObject obj) {
-        return new ByteArrayInputStream(obj.toString().getBytes());
+        return new ByteArrayInputStream(obj.toString().getBytes(UTF_8));
     }
 
     // Asserts that the list of AllTypesPrimaryKey objects where inserted and updated properly.
@@ -198,7 +201,7 @@ public void createObjectFromJson_allSimpleObjectAllTypes() throws JSONException
         json.put("columnFloat", 1.23F);
         json.put("columnDouble", 1.23D);
         json.put("columnBoolean", true);
-        json.put("columnBinary", new String(Base64.encode(new byte[] {1,2,3}, Base64.DEFAULT)));
+        json.put("columnBinary", new String(Base64.encode(new byte[] {1,2,3}, Base64.DEFAULT), UTF_8));
 
         realm.beginTransaction();
         realm.createObjectFromJson(AllTypes.class, json);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
index cd9d35516a..cd4e057f84 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
@@ -746,8 +746,8 @@ public void realmMethods_onDeletedLinkView() {
                     case SORT: results.sort(CyclicType.FIELD_NAME); break;
                     case SORT_FIELD: results.sort(CyclicType.FIELD_NAME, Sort.ASCENDING); break;
                     case SORT_2FIELDS: results.sort(CyclicType.FIELD_NAME, Sort.ASCENDING, CyclicType.FIELD_DATE, Sort.DESCENDING); break;
-                    case SORT_MULTI: results.sort(new String[] { CyclicType.FIELD_NAME, CyclicType.FIELD_DATE }, new Sort[] { Sort.ASCENDING, Sort.DESCENDING});
-                    case CREATE_SNAPSHOT: results.createSnapshot();
+                    case SORT_MULTI: results.sort(new String[] { CyclicType.FIELD_NAME, CyclicType.FIELD_DATE }, new Sort[] { Sort.ASCENDING, Sort.DESCENDING}); break;
+                    case CREATE_SNAPSHOT: results.createSnapshot(); break;
                 }
                 fail(method + " should have thrown an Exception");
             } catch (IllegalStateException ignored) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index 6789108cd1..7a5d21a4e5 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -1280,6 +1280,27 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         realm.close();
     }
 
+    // Tests that if a migration is required and no migration block was provided, then the
+    // original RealmMigrationNeededException is thrown instead of IllegalArgumentException
+    @Test
+    public void migrationRequired_throwsOriginalException() {
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
+                // .migration() No migration block provided, but one is required
+                .assetFile("default0.realm") // This Realm does not have the correct schema
+                .build();
+
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(config);
+            fail();
+        } catch (RealmMigrationNeededException ignored) {
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+    
     // TODO Add unit tests for default nullability
     // TODO Add unit tests for default Indexing for Primary keys
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
index 8447b2ce2e..387f098153 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
@@ -94,7 +94,7 @@ private void populateTestRealm(Realm realm, int objects) {
             allTypes.columnDouble = 3.1415 + i;
             allTypes.columnFloat = 1.234567f;
             allTypes.columnString = "test data ";
-            allTypes.columnByte = 0b0010_1010;
+            allTypes.columnByte = 0x2A;
             realm.copyToRealm(allTypes);
         }
         realm.commitTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index a29dbee7d4..01745e62f6 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -111,7 +111,7 @@ public boolean isNullable() {
         BOOLEAN(Boolean.class), PRIMITIVE_BOOLEAN(boolean.class),
         DATE(Date.class);
 
-        Class<?> clazz;
+        private final Class<?> clazz;
 
         public Class<?> getType() {
             return clazz;
@@ -129,7 +129,7 @@ public boolean isNullable() {
         OBJECT(RealmObject.class),
         LIST(RealmList.class);
 
-        Class<?> clazz;
+        private final Class<?> clazz;
 
         public Class<?> getType() {
             return clazz;
@@ -148,7 +148,7 @@ public boolean isNullable() {
         LONG(Long.class), PRIMITIVE_LONG(long.class),
         BYTE(Byte.class), PRIMITIVE_BYTE(byte.class);
 
-        Class<?> clazz;
+        private final Class<?> clazz;
 
         public Class<?> getType() {
             return clazz;
@@ -168,7 +168,7 @@ public boolean isNullable() {
         OBJECT(RealmObject.class),
         LIST(RealmList.class);
 
-        Class<?> clazz;
+        private final Class<?> clazz;
 
         public Class<?> getType() {
             return clazz;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index 2feb6876e7..4df192b9a3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -703,7 +703,7 @@ public void setter_link_objectFromAnotherThread() throws InterruptedException {
         final CountDownLatch createLatch = new CountDownLatch(1);
         final CountDownLatch testEndLatch = new CountDownLatch(1);
 
-        final AtomicReference<CyclicType> objFromAnotherThread = new AtomicReference<>();
+        final AtomicReference<CyclicType> objFromAnotherThread = new AtomicReference<CyclicType>();
 
         java.lang.Thread thread = new java.lang.Thread() {
             @Override
@@ -754,7 +754,7 @@ public void setter_list_withUnmanagedObject() {
         try {
             CyclicType target = realm.createObject(CyclicType.class);
 
-            RealmList<CyclicType> list = new RealmList<>();
+            RealmList<CyclicType> list = new RealmList<CyclicType>();
             list.add(realm.createObject(CyclicType.class));
             list.add(unmanaged); // List contains an unmanaged object
             list.add(realm.createObject(CyclicType.class));
@@ -778,7 +778,7 @@ public void setter_list_withDeletedObject() {
             CyclicType removed = realm.createObject(CyclicType.class);
             removed.deleteFromRealm();
 
-            RealmList<CyclicType> list = new RealmList<>();
+            RealmList<CyclicType> list = new RealmList<CyclicType>();
             list.add(realm.createObject(CyclicType.class));
             list.add(removed); // List contains a deleted object.
             list.add(realm.createObject(CyclicType.class));
@@ -806,7 +806,7 @@ public void setter_list_withClosedObject() {
         try {
             CyclicType target = realm.createObject(CyclicType.class);
 
-            RealmList<CyclicType> list = new RealmList<>();
+            RealmList<CyclicType> list = new RealmList<CyclicType>();
             list.add(realm.createObject(CyclicType.class));
             list.add(closed); // List contains a closed object.
             list.add(realm.createObject(CyclicType.class));
@@ -835,7 +835,7 @@ public void setter_list_withObjectFromAnotherRealm() {
             try {
                 CyclicType target = realm.createObject(CyclicType.class);
 
-                RealmList<CyclicType> list = new RealmList<>();
+                RealmList<CyclicType> list = new RealmList<CyclicType>();
                 list.add(realm.createObject(CyclicType.class));
                 list.add(objFromAnotherRealm); // List contains an object from another Realm.
                 list.add(realm.createObject(CyclicType.class));
@@ -858,7 +858,7 @@ public void setter_list_withObjectFromAnotherThread() throws InterruptedExceptio
         final CountDownLatch createLatch = new CountDownLatch(1);
         final CountDownLatch testEndLatch = new CountDownLatch(1);
 
-        final AtomicReference<CyclicType> objFromAnotherThread = new AtomicReference<>();
+        final AtomicReference<CyclicType> objFromAnotherThread = new AtomicReference<CyclicType>();
 
         java.lang.Thread thread = new java.lang.Thread() {
             @Override
@@ -888,7 +888,7 @@ public void run() {
         try {
             CyclicType target = realm.createObject(CyclicType.class);
 
-            RealmList<CyclicType> list = new RealmList<>();
+            RealmList<CyclicType> list = new RealmList<CyclicType>();
             list.add(realm.createObject(CyclicType.class));
             list.add(objFromAnotherThread.get()); // List contains an object from another thread.
             list.add(realm.createObject(CyclicType.class));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
index 1546c13524..023cca9f73 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
@@ -63,7 +63,7 @@ public void validateTable_noDuplicateIndexInIndexFields() {
         CatRealmProxy.CatColumnInfo columnInfo;
         columnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
 
-        final Set<Long> indexSet = new HashSet<>();
+        final Set<Long> indexSet = new HashSet<Long>();
         int indexCount = 0;
 
         indexSet.add(columnInfo.nameIndex);
@@ -92,7 +92,7 @@ public void validateTable_noDuplicateIndexInIndicesMap() {
         CatRealmProxy.CatColumnInfo columnInfo;
         columnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
 
-        final Set<Long> indexSet = new HashSet<>();
+        final Set<Long> indexSet = new HashSet<Long>();
         int indexCount = 0;
 
         // Gets index for each field and then put into set.
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index c1939d26aa..b10f607f14 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -99,14 +99,14 @@ private void populateTestRealm(Realm testRealm, int dataSize) {
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
             allTypes.setColumnDate(new Date(DECADE_MILLIS * (i - (dataSize / 2))));
             allTypes.setColumnDouble(3.1415);
-            allTypes.setColumnFloat(1.234567f + i);
+            allTypes.setColumnFloat(1.2345f + i);
             allTypes.setColumnString("test data " + i);
             allTypes.setColumnLong(i);
             NonLatinFieldNames nonLatinFieldNames = testRealm.createObject(NonLatinFieldNames.class);
             nonLatinFieldNames.set(i);
             nonLatinFieldNames.set(i);
-            nonLatinFieldNames.set(1.234567f + i);
-            nonLatinFieldNames.set(1.234567f + i);
+            nonLatinFieldNames.set(1.2345f + i);
+            nonLatinFieldNames.set(1.2345f + i);
 
             Dog dog = testRealm.createObject(Dog.class);
             dog.setAge(i);
@@ -137,8 +137,8 @@ private void populateNoPrimaryKeyNullTypesRows(Realm testRealm, int dataSize) {
             noPrimaryKeyNullTypes.setFieldIntegerNotNull(i);
             noPrimaryKeyNullTypes.setFieldLongNull((i % 3) == 0 ? null : (long) i);
             noPrimaryKeyNullTypes.setFieldLongNotNull((long) i);
-            noPrimaryKeyNullTypes.setFieldFloatNull((i % 3) == 0 ? null : 1.234567f + i);
-            noPrimaryKeyNullTypes.setFieldFloatNotNull(1.234567f + i);
+            noPrimaryKeyNullTypes.setFieldFloatNull((i % 3) == 0 ? null : 1.2345f + i);
+            noPrimaryKeyNullTypes.setFieldFloatNotNull(1.2345f + i);
             noPrimaryKeyNullTypes.setFieldDoubleNull((i % 3) == 0 ? null : 3.1415 + i);
             noPrimaryKeyNullTypes.setFieldDoubleNotNull(3.1415 + i);
             noPrimaryKeyNullTypes.setFieldDateNull((i % 3) == 0 ? null : new Date(DECADE_MILLIS * (i - (dataSize / 2))));
@@ -467,14 +467,14 @@ public void greaterThan() {
         populateTestRealm(realm, TEST_OBJECTS_COUNT);
 
         RealmResults<AllTypes> resultList = realm.where(AllTypes.class)
-                .greaterThan(AllTypes.FIELD_FLOAT, 10.234567f).findAll();
+                .greaterThan(AllTypes.FIELD_FLOAT, 10.2345f).findAll();
         assertEquals(TEST_OBJECTS_COUNT - 10, resultList.size());
 
         resultList = realm.where(AllTypes.class).beginsWith(AllTypes.FIELD_STRING, "test data 1")
-                .greaterThan(AllTypes.FIELD_FLOAT, 50.234567f).findAll();
-        assertEquals(TEST_OBJECTS_COUNT - 100, resultList.size());
+                .greaterThan(AllTypes.FIELD_FLOAT, 150.2345f).findAll();
+        assertEquals(TEST_OBJECTS_COUNT - 150, resultList.size());
 
-        RealmQuery<AllTypes> query = realm.where(AllTypes.class).greaterThan(AllTypes.FIELD_FLOAT, 11.234567f);
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).greaterThan(AllTypes.FIELD_FLOAT, 11.2345f);
         resultList = query.between(AllTypes.FIELD_LONG, 1, 20).findAll();
         assertEquals(10, resultList.size());
     }
@@ -504,15 +504,15 @@ public void greaterThanOrEqualTo() {
         populateTestRealm(realm, TEST_OBJECTS_COUNT);
 
         RealmResults<AllTypes> resultList = realm.where(AllTypes.class)
-                .greaterThanOrEqualTo(AllTypes.FIELD_FLOAT, 10.234567f).findAll();
+                .greaterThanOrEqualTo(AllTypes.FIELD_FLOAT, 10.2345f).findAll();
         assertEquals(TEST_OBJECTS_COUNT - 9, resultList.size());
 
         resultList = realm.where(AllTypes.class).beginsWith(AllTypes.FIELD_STRING, "test data 1")
-                .greaterThanOrEqualTo(AllTypes.FIELD_FLOAT, 50.234567f).findAll();
+                .greaterThanOrEqualTo(AllTypes.FIELD_FLOAT, 50.2345f).findAll();
         assertEquals(TEST_OBJECTS_COUNT - 100, resultList.size());
 
         RealmQuery<AllTypes> query = realm.where(AllTypes.class)
-                .greaterThanOrEqualTo(AllTypes.FIELD_FLOAT, 11.234567f);
+                .greaterThanOrEqualTo(AllTypes.FIELD_FLOAT, 11.2345f);
         query = query.between(AllTypes.FIELD_LONG, 1, 20);
 
         resultList = query.beginsWith(AllTypes.FIELD_STRING, "test data 15").findAll();
@@ -541,7 +541,7 @@ public void greaterThanOrEqualTo_date() {
     public void or() {
         populateTestRealm(realm, 200);
 
-        RealmQuery<AllTypes> query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_FLOAT, 31.234567f);
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_FLOAT, 31.2345f);
         RealmResults<AllTypes> resultList = query.or().between(AllTypes.FIELD_LONG, 1, 20).findAll();
         assertEquals(21, resultList.size());
 
@@ -559,12 +559,12 @@ public void or_missingFilters() {
 
     @Test(expected = UnsupportedOperationException.class)
     public void or_missingFilterBefore() {
-        realm.where(AllTypes.class).or().equalTo(AllTypes.FIELD_FLOAT, 31.234567f).findAll();
+        realm.where(AllTypes.class).or().equalTo(AllTypes.FIELD_FLOAT, 31.2345f).findAll();
     }
 
     @Test(expected = UnsupportedOperationException.class)
     public void or_missingFilterAfter() {
-        realm.where(AllTypes.class).or().equalTo(AllTypes.FIELD_FLOAT, 31.234567f).findAll();
+        realm.where(AllTypes.class).or().equalTo(AllTypes.FIELD_FLOAT, 31.2345f).findAll();
     }
 
     @Test
@@ -608,11 +608,11 @@ public void not_aloneThrows() {
     public void and_implicit() {
         populateTestRealm(realm, 200);
 
-        RealmQuery<AllTypes> query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_FLOAT, 31.234567f);
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_FLOAT, 31.2345f);
         RealmResults<AllTypes> resultList = query.between(AllTypes.FIELD_LONG, 1, 10).findAll();
         assertEquals(0, resultList.size());
 
-        query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_FLOAT, 81.234567f);
+        query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_FLOAT, 81.2345f);
         resultList = query.between(AllTypes.FIELD_LONG, 1, 100).findAll();
         assertEquals(1, resultList.size());
     }
@@ -623,9 +623,9 @@ public void lessThan() {
         populateTestRealm(realm, TEST_OBJECTS_COUNT);
 
         RealmResults<AllTypes> resultList = realm.where(AllTypes.class).
-                lessThan(AllTypes.FIELD_FLOAT, 31.234567f).findAll();
+                lessThan(AllTypes.FIELD_FLOAT, 31.2345f).findAll();
         assertEquals(30, resultList.size());
-        RealmQuery<AllTypes> query = realm.where(AllTypes.class).lessThan(AllTypes.FIELD_FLOAT, 31.234567f);
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).lessThan(AllTypes.FIELD_FLOAT, 31.2345f);
         resultList = query.between(AllTypes.FIELD_LONG, 1, 10).findAll();
         assertEquals(10, resultList.size());
     }
@@ -654,9 +654,9 @@ public void lessThanOrEqualTo() {
         populateTestRealm(realm, TEST_OBJECTS_COUNT);
 
         RealmResults<AllTypes> resultList = realm.where(AllTypes.class)
-                .lessThanOrEqualTo(AllTypes.FIELD_FLOAT, 31.234567f).findAll();
+                .lessThanOrEqualTo(AllTypes.FIELD_FLOAT, 31.2345f).findAll();
         assertEquals(31, resultList.size());
-        resultList = realm.where(AllTypes.class).lessThanOrEqualTo(AllTypes.FIELD_FLOAT, 31.234567f)
+        resultList = realm.where(AllTypes.class).lessThanOrEqualTo(AllTypes.FIELD_FLOAT, 31.2345f)
                 .between(AllTypes.FIELD_LONG, 11, 20).findAll();
         assertEquals(10, resultList.size());
     }
@@ -684,7 +684,7 @@ public void equalTo() {
         populateTestRealm(realm, 200);
 
         RealmResults<AllTypes> resultList = realm.where(AllTypes.class)
-                .equalTo(AllTypes.FIELD_FLOAT, 31.234567f).findAll();
+                .equalTo(AllTypes.FIELD_FLOAT, 31.2345f).findAll();
         assertEquals(1, resultList.size());
         resultList = realm.where(AllTypes.class).greaterThan(AllTypes.FIELD_FLOAT, 11.0f)
                 .equalTo(AllTypes.FIELD_LONG, 10).findAll();
@@ -843,13 +843,13 @@ private void doTestForInFloat(String targetField) {
             fail();
         } catch (IllegalArgumentException ignored) {
         }
-        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Float[]{1.234567f + 1}).findAll();
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Float[]{1.2345f + 1}).findAll();
         assertEquals(1, resultList.size());
-        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Float[]{1.234567f + 2}).findAll();
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Float[]{1.2345f + 2}).findAll();
         assertEquals(1, resultList.size());
-        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Float[]{1.234567f + 1, 1.234567f + 2}).findAll();
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Float[]{1.2345f + 1, 1.2345f + 2}).findAll();
         assertEquals(2, resultList.size());
-        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Float[]{1.234567f + 1, 1.234567f + 2}).findAll();
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Float[]{1.2345f + 1, 1.2345f + 2}).findAll();
         assertEquals(198, resultList.size());
     }
 
@@ -1013,7 +1013,7 @@ public void in_doubleNull() {
     public void in_floatNotNull() {
         doTestForInFloat(NoPrimaryKeyNullTypes.FIELD_FLOAT_NOT_NULL);
         try {
-            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_FLOAT_NOT_NULL, new Float[]{1.234567f + 1, null, 1.234567f + 2}).findAll();
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_FLOAT_NOT_NULL, new Float[]{1.2345f + 1, null, 1.2345f + 2}).findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -1022,7 +1022,7 @@ public void in_floatNotNull() {
     @Test
     public void in_floatNull() {
         doTestForInFloat(NoPrimaryKeyNullTypes.FIELD_FLOAT_NULL);
-        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_FLOAT_NULL, new Float[]{1.234567f + 1, null, 1.234567f + 2}).findAll();
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_FLOAT_NULL, new Float[]{1.2345f + 1, null, 1.2345f + 2}).findAll();
         assertEquals(131, resultList.size());
     }
 
@@ -1103,11 +1103,11 @@ public void notEqualTo() {
                 .notEqualTo(AllTypes.FIELD_LONG, 31).findAll();
         assertEquals(TEST_OBJECTS_COUNT - 1, resultList.size());
 
-        resultList = realm.where(AllTypes.class).notEqualTo(AllTypes.FIELD_FLOAT, 11.234567f)
+        resultList = realm.where(AllTypes.class).notEqualTo(AllTypes.FIELD_FLOAT, 11.2345f)
                 .equalTo(AllTypes.FIELD_LONG, 10).findAll();
         assertEquals(0, resultList.size());
 
-        resultList = realm.where(AllTypes.class).notEqualTo(AllTypes.FIELD_FLOAT, 11.234567f)
+        resultList = realm.where(AllTypes.class).notEqualTo(AllTypes.FIELD_FLOAT, 11.2345f)
                 .equalTo(AllTypes.FIELD_LONG, 1).findAll();
         assertEquals(1, resultList.size());
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index 78946420d6..b9030ae3e8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -128,10 +128,10 @@ public void unsupportedMethods() {
         for (CollectionMutatorMethod method : CollectionMutatorMethod.values()) {
             try {
                 switch (method) {
-                    case ADD_OBJECT: collection.add(new AllTypes());
+                    case ADD_OBJECT: collection.add(new AllTypes()); break;
                     case ADD_ALL_OBJECTS: collection.addAll(Collections.singletonList(new AllTypes())); break;
                     case CLEAR: collection.clear(); break;
-                    case REMOVE_OBJECT: collection.remove(new AllTypes());
+                    case REMOVE_OBJECT: collection.remove(new AllTypes()); break;
                     case REMOVE_ALL: collection.removeAll(Collections.singletonList(new AllTypes())); break;
                     case RETAIN_ALL: collection.retainAll(Collections.singletonList(new AllTypes())); break;
 
@@ -1136,7 +1136,7 @@ public void execute(Realm realm) {
                 fieldObjectValue.setFieldInt(fieldObjectIntValue);
                 obj.setFieldObject(fieldObjectValue);
 
-                final RealmList<RandomPrimaryKey> list = new RealmList<>();
+                final RealmList<RandomPrimaryKey> list = new RealmList<RandomPrimaryKey>();
                 final RandomPrimaryKey listItem = new RandomPrimaryKey();
                 listItem.setFieldInt(fieldListIntValue);
                 list.add(listItem);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 37aaa12769..92774d8fee 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -200,6 +200,7 @@ public void getInstance_writeProtectedFile() throws IOException {
                     .directory(folder)
                     .name(REALM_FILE)
                     .build());
+            fail();
         } catch (RealmFileException expected) {
             assertEquals(expected.getKind(), RealmFileException.Kind.PERMISSION_DENIED);
         }
@@ -216,6 +217,7 @@ public void getInstance_writeProtectedFileWithContext() throws IOException {
 
         try {
             Realm.getInstance(new RealmConfiguration.Builder(context).directory(folder).name(REALM_FILE).build());
+            fail();
         } catch (RealmFileException expected) {
             assertEquals(expected.getKind(), RealmFileException.Kind.PERMISSION_DENIED);
         }
@@ -658,7 +660,7 @@ public void execute(Realm realm) {
 
     @Test
     public void executeTransaction_canceled() {
-        final AtomicReference<RuntimeException> thrownException = new AtomicReference<>(null);
+        final AtomicReference<RuntimeException> thrownException = new AtomicReference<RuntimeException>(null);
 
         assertEquals(0, realm.where(Owner.class).count());
         try {
@@ -1795,7 +1797,7 @@ public void getInstance_differentEncryptionKeys() {
             try {
                 realm2 = Realm.getInstance(configFactory.createConfiguration(ENCRYPTED_REALM, key2));
             } catch (Exception e) {
-                fail();
+                fail("Unexpected exception: " + e);
             } finally {
                 if (realm2 != null) {
                     realm2.close();
@@ -2474,7 +2476,7 @@ public void copyToRealm_defaultValuesAreIgnored() {
             fieldObjectValue.setFieldInt(fieldObjectIntValue);
             obj.setFieldObject(fieldObjectValue);
 
-            final RealmList<RandomPrimaryKey> list = new RealmList<>();
+            final RealmList<RandomPrimaryKey> list = new RealmList<RandomPrimaryKey>();
             final RandomPrimaryKey listItem = new RandomPrimaryKey();
             listItem.setFieldInt(fieldListIntValue);
             list.add(listItem);
@@ -2529,7 +2531,7 @@ public void copyFromRealm_defaultValuesAreIgnored() {
             fieldObjectValue.setFieldInt(RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1);
             obj.setFieldObject(fieldObjectValue);
 
-            final RealmList<RandomPrimaryKey> list = new RealmList<>();
+            final RealmList<RandomPrimaryKey> list = new RealmList<RandomPrimaryKey>();
             final RandomPrimaryKey listItem = new RandomPrimaryKey();
             listItem.setFieldInt(RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 2);
             list.add(listItem);
@@ -3554,7 +3556,7 @@ public void run() {
                 Realm realm = Realm.getInstance(realmConfig);
                 bgRealm.set(realm);
                 bgRealmOpened.countDown();
-                bgRealmWaitResult.set(new Boolean(realm.waitForChange()));
+                bgRealmWaitResult.set(realm.waitForChange());
                 realm.close();
                 bgRealmClosed.countDown();
             }
@@ -3572,7 +3574,7 @@ public void run() {
         // Now we'll stop realm from waiting.
         bgRealm.get().stopWaitForChange();
         TestHelper.awaitOrFail(bgRealmClosed);
-        assertFalse(bgRealmWaitResult.get().booleanValue());
+        assertFalse(bgRealmWaitResult.get());
     }
 
     @Test
@@ -3821,7 +3823,7 @@ public boolean accept(File dir, String name) {
                 return name.matches("realm_.*cv");
             }
         });
-        assertEquals(1, files.length);
+        assertEquals(2, files.length);
 
         // Tests if it works when the namedPipeDir and the named pipe files already exist.
         realmOnExternalStorage = Realm.getInstance(config);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index 92059c90cc..548515114f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -68,6 +68,8 @@
 
 public class TestHelper {
 
+    private static final Charset UTF_8 = Charset.forName("UTF-8");
+
     public static class ExpectedCountCallback implements RealmCache.Callback {
 
         private int expectedCount;
@@ -124,7 +126,7 @@ public static String streamToString(InputStream in) throws IOException {
         StringBuilder sb = new StringBuilder();
         String line;
         try {
-            br = new BufferedReader(new InputStreamReader(in));
+            br = new BufferedReader(new InputStreamReader(in, UTF_8));
             while ((line = br.readLine()) != null) {
                 sb.append(line);
             }
@@ -138,7 +140,7 @@ public static String streamToString(InputStream in) throws IOException {
     }
 
     public static InputStream stringToStream(String str) {
-        return new ByteArrayInputStream(str.getBytes(Charset.forName("UTF-8")));
+        return new ByteArrayInputStream(str.getBytes(UTF_8));
     }
 
     // Creates a simple migration step in order to support null.
@@ -256,12 +258,10 @@ public int read() throws IOException {
     public static byte[] SHA512(String str) {
         try {
             MessageDigest md = MessageDigest.getInstance("SHA-512");
-            md.update(str.getBytes("UTF-8"), 0, str.length());
+            md.update(str.getBytes(UTF_8), 0, str.length());
             return md.digest();
         } catch (NoSuchAlgorithmException e) {
             throw new RuntimeException(e);
-        } catch (UnsupportedEncodingException e) {
-            throw new RuntimeException(e);
         }
     }
 
@@ -368,10 +368,10 @@ public static void populateTestRealmWithBytePrimaryKey(Realm testRealm, Byte pri
         userObj.setId(primaryFieldValue);
         userObj.setName(secondaryFieldValue);
         testRealm.copyToRealm(userObj);
-        byte idValue = (byte)iteratorBeginValue;
+        byte idValue = (byte) iteratorBeginValue;
         for (int i = 0; i < numberOfPopulation - 1; ++i, ++idValue) {
             PrimaryKeyAsBoxedByte obj = new PrimaryKeyAsBoxedByte();
-            obj.setId(new Byte(idValue));
+            obj.setId(idValue);
             obj.setName(String.valueOf(idValue));
             testRealm.copyToRealm(obj);
         }
@@ -404,7 +404,7 @@ public static void populateTestRealmWithShortPrimaryKey(Realm testRealm, Short p
         short idValue = (short)iteratorBeginValue;
         for (int i = 0; i < numberOfPopulation - 1; ++i, ++idValue) {
             PrimaryKeyAsBoxedShort obj = new PrimaryKeyAsBoxedShort();
-            obj.setId(new Short(idValue));
+            obj.setId(idValue);
             obj.setName(String.valueOf(idValue));
             testRealm.copyToRealm(obj);
         }
@@ -437,7 +437,7 @@ public static void populateTestRealmWithIntegerPrimaryKey(Realm testRealm, Integ
         int idValue = iteratorBeginValue;
         for (int i = 0; i < numberOfPopulation - 1; ++i, ++idValue) {
             PrimaryKeyAsBoxedInteger obj = new PrimaryKeyAsBoxedInteger();
-            obj.setId(new Integer(idValue));
+            obj.setId(idValue);
             obj.setName(String.valueOf(idValue));
             testRealm.copyToRealm(obj);
         }
@@ -470,7 +470,7 @@ public static void populateTestRealmWithLongPrimaryKey(Realm testRealm, Long pri
         long idValue = iteratorBeginValue;
         for (long i = 0; i < numberOfPopulation - 1; ++i, ++idValue) {
             PrimaryKeyAsBoxedLong obj = new PrimaryKeyAsBoxedLong();
-            obj.setId(new Long(idValue));
+            obj.setId(idValue);
             obj.setName(String.valueOf(idValue));
             testRealm.copyToRealm(obj);
         }
@@ -1047,7 +1047,7 @@ public static boolean isSelinuxEnforcing() {
         try {
             final Process process = new ProcessBuilder("/system/bin/getenforce").start();
             try {
-                final BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
+                final BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream(), UTF_8));
                 //noinspection TryFinallyCanBeTryWithResources
                 try {
                     return reader.readLine().toLowerCase(Locale.ENGLISH).equals("enforcing");
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
index c219ab9742..e3150acf8c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
@@ -24,13 +24,13 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.charset.Charset;
 import java.util.Date;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -54,6 +54,8 @@
 @RunWith(AndroidJUnit4.class)
 public class TypeBasedNotificationsTests {
 
+    private static final Charset UTF_8 = Charset.forName("UTF-8");
+
     @Rule
     public final RunInLooperThread looperThread = new RunInLooperThread();
     @Rule
@@ -321,7 +323,7 @@ public void run() {
             json.put("columnFloat", 1.23f);
             json.put("columnDouble", 1.23d);
             json.put("columnBoolean", true);
-            json.put("columnBinary", new String(Base64.encode(new byte[]{1, 2, 3}, Base64.DEFAULT)));
+            json.put("columnBinary", new String(Base64.encode(new byte[]{1, 2, 3}, Base64.DEFAULT), UTF_8));
 
             realm.beginTransaction();
             final AllTypes objectFromJson = realm.createObjectFromJson(AllTypes.class, json);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
index 515eea403c..38e3f84443 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
@@ -20,27 +20,30 @@
 
 import io.realm.RealmList;
 import io.realm.RealmObject;
+import io.realm.RealmResults;
 import io.realm.annotations.Ignore;
 import io.realm.annotations.Index;
+import io.realm.annotations.LinkingObjects;
 import io.realm.annotations.PrimaryKey;
 
 public class AllJavaTypes extends RealmObject {
 
     public static final String CLASS_NAME = "AllJavaTypes";
-    public static String FIELD_IGNORED = "fieldIgnored";
-    public static String FIELD_STRING = "fieldString";
-    public static String FIELD_SHORT = "fieldShort";
-    public static String FIELD_INT = "fieldInt";
-    public static String FIELD_LONG = "fieldLong";
-    public static String FIELD_ID = "fieldId";
-    public static String FIELD_BYTE = "fieldByte";
-    public static String FIELD_FLOAT = "fieldFloat";
-    public static String FIELD_DOUBLE = "fieldDouble";
-    public static String FIELD_BOOLEAN = "fieldBoolean";
-    public static String FIELD_DATE = "fieldDate";
-    public static String FIELD_BINARY = "fieldBinary";
-    public static String FIELD_OBJECT = "fieldObject";
-    public static String FIELD_LIST = "fieldList";
+
+    public static final String FIELD_IGNORED = "fieldIgnored";
+    public static final String FIELD_STRING = "fieldString";
+    public static final String FIELD_SHORT = "fieldShort";
+    public static final String FIELD_INT = "fieldInt";
+    public static final String FIELD_LONG = "fieldLong";
+    public static final String FIELD_ID = "fieldId";
+    public static final String FIELD_BYTE = "fieldByte";
+    public static final String FIELD_FLOAT = "fieldFloat";
+    public static final String FIELD_DOUBLE = "fieldDouble";
+    public static final String FIELD_BOOLEAN = "fieldBoolean";
+    public static final String FIELD_DATE = "fieldDate";
+    public static final String FIELD_BINARY = "fieldBinary";
+    public static final String FIELD_OBJECT = "fieldObject";
+    public static final String FIELD_LIST = "fieldList";
 
     public static final String   INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT = AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY;
     public static final String[] INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT = new String[]{FIELD_OBJECT + "." + FIELD_BINARY, FIELD_OBJECT + "." + FIELD_OBJECT, FIELD_OBJECT + "." + FIELD_LIST};
@@ -60,6 +63,12 @@
     private AllJavaTypes fieldObject;
     private RealmList<AllJavaTypes> fieldList;
 
+    @LinkingObjects("fieldObject")
+    private final RealmResults<AllJavaTypes> objectParents = null;
+
+    @LinkingObjects("fieldList")
+    private final RealmResults<AllJavaTypes> listParents = null;
+
     public AllJavaTypes() {
 
     }
@@ -180,4 +189,12 @@ public void setFieldObject(AllJavaTypes columnRealmObject) {
     public void setFieldList(RealmList<AllJavaTypes> columnRealmList) {
         this.fieldList = columnRealmList;
     }
+
+    public RealmResults<AllJavaTypes> getObjectParents() {
+        return objectParents;
+    }
+
+    public RealmResults<AllJavaTypes> getListParents() {
+        return listParents;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java b/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java
new file mode 100644
index 0000000000..1419d5368b
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.RealmObject;
+
+public class BacklinksSource extends RealmObject {
+    private BacklinksTarget child;
+
+    public BacklinksTarget getChild() {
+        return child;
+    }
+
+    public void setChild(BacklinksTarget child) {
+        this.child = child;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java b/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java
new file mode 100644
index 0000000000..ddb0ea6f80
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class BacklinksTarget extends RealmObject {
+    private int id;
+
+    @LinkingObjects("child")
+    private final RealmResults<BacklinksSource> parents = null;
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public RealmResults<BacklinksSource> getParents() {
+        return parents;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/ExtraTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/ExtraTests.java
index 3a422eaf09..427b30ad86 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/ExtraTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/test/ExtraTests.java
@@ -45,6 +45,7 @@ public static void assertDateArrayEquals(Object[] expecteds, Date[] actuals)
     }
 
     private static class ExactComparisonCriteria extends ComparisonCriteria {
+        @Override
         protected void assertElementsEqual(Object expected, Object actual)
         {
             assertEquals(expected, actual);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
index b81238326a..704deb9485 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
@@ -31,6 +31,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
 import java.util.concurrent.ThreadFactory;
 
 import io.realm.Realm;
@@ -108,7 +109,8 @@ public Thread newThread(Runnable runnable) {
                             return new Thread(runnable, threadName);
                         }
                     });
-                    executorService.submit(new Runnable() {
+                    //noinspection unused
+                    final Future<?> submit = executorService.submit(new Runnable() {
                         @Override
                         public void run() {
                             Looper.prepare();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
index 65e81bdea4..979717e96a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
@@ -32,9 +32,13 @@
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
+import io.realm.DynamicRealm;
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
+import io.realm.RealmMigration;
+import io.realm.RealmObject;
 import io.realm.TestHelper;
+import io.realm.annotations.RealmModule;
 
 import static org.junit.Assert.assertTrue;
 
@@ -45,8 +49,8 @@
  * The temp directory will be deleted regardless if the {@link Realm#deleteRealm(RealmConfiguration)} fails or not.
  */
 public class TestRealmConfigurationFactory extends TemporaryFolder {
-    private Map<RealmConfiguration, Boolean> map = new ConcurrentHashMap<RealmConfiguration, Boolean>();
-    private Set<RealmConfiguration> configurations = Collections.newSetFromMap(map);
+    private final Map<RealmConfiguration, Boolean> map = new ConcurrentHashMap<RealmConfiguration, Boolean>();
+    private final Set<RealmConfiguration> configurations = Collections.newSetFromMap(map);
     protected boolean unitTestFailed = false;
 
     @Override
@@ -94,50 +98,58 @@ protected void after() {
         }
     }
 
+    // This builder creates a configuration that is *NOT* managed.
+    // You have to delete it yourself.
+    public RealmConfiguration.Builder createConfigurationBuilder() {
+        return new RealmConfiguration.Builder().directory(getRoot());
+    }
+
     public RealmConfiguration createConfiguration() {
-        RealmConfiguration configuration = new RealmConfiguration.Builder()
-                .directory(getRoot())
-                .build();
+        return createConfiguration(null);
+    }
 
-        configurations.add(configuration);
-        return configuration;
+    public RealmConfiguration createConfiguration(String name) {
+        return createConfiguration(null, name);
     }
 
     public RealmConfiguration createConfiguration(String subDir, String name) {
-        final File folder = new File(getRoot(), subDir);
-        assertTrue(folder.mkdirs());
-        RealmConfiguration configuration = new RealmConfiguration.Builder()
-                .directory(folder)
-                .name(name)
-                .build();
-
-        configurations.add(configuration);
-        return configuration;
+        return createConfiguration(subDir, name, null, null);
     }
 
-    public RealmConfiguration createConfiguration(String name) {
-        RealmConfiguration configuration = new RealmConfiguration.Builder()
-                .directory(getRoot())
-                .name(name)
-                .build();
+    public RealmConfiguration createConfiguration(String name, byte[] key) {
+        return createConfiguration(null, name, null, key);
+    }
 
-        configurations.add(configuration);
-        return configuration;
+    public RealmConfiguration createConfiguration(String name, Object module) {
+        return createConfiguration(null, name, module, null);
     }
 
-    public RealmConfiguration createConfiguration(String name, byte[] key) {
-        RealmConfiguration configuration = new RealmConfiguration.Builder()
-                .directory(getRoot())
-                .name(name)
-                .encryptionKey(key)
-                .build();
+    public RealmConfiguration createConfiguration(String subDir, String name, Object module, byte[] key) {
+        RealmConfiguration.Builder builder = createConfigurationBuilder();
+
+        File folder = getRoot();
+        if (subDir != null) {
+            folder = new File(folder, subDir);
+            assertTrue(folder.mkdirs());
+        }
+        builder.directory(folder);
+
+        if (name != null) {
+            builder.name(name);
+        }
 
+        if (module != null) {
+            builder.modules(module);
+        }
+
+        if (key != null) {
+            builder.encryptionKey(key);
+        }
+
+        RealmConfiguration configuration = builder.build();
         configurations.add(configuration);
-        return configuration;
-    }
 
-    public RealmConfiguration.Builder createConfigurationBuilder() {
-        return new RealmConfiguration.Builder().directory(getRoot());
+        return configuration;
     }
 
     // Copies a Realm file from assets to temp dir
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java
index 8143418f05..c0a5d4fffc 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java
@@ -138,7 +138,7 @@ public void custom() {
 
     @Test
     public void custom_invalidUserName() {
-        Map<String, Object> userInfo = new HashMap<>();
+        Map<String, Object> userInfo = new HashMap<String, Object>();
 
         String[] invalidInput = {null, ""};
         for (String username : invalidInput) {
@@ -152,7 +152,7 @@ public void custom_invalidUserName() {
 
     @Test
     public void custom_invalidProvider() {
-        Map<String, Object> userInfo = new HashMap<>();
+        Map<String, Object> userInfo = new HashMap<String, Object>();
 
         try {
             SyncCredentials.custom("foo", null, userInfo);
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index 537dfb67e5..2c53ce2bd5 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -23,10 +23,15 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import io.realm.rule.TestRealmConfigurationFactory;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestSyncConfigurationFactory;
 
 import static io.realm.util.SyncTestUtils.createTestUser;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
 public class SessionTests {
@@ -37,7 +42,10 @@
     private SyncUser user;
 
     @Rule
-    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    public final TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
 
     @Before
     public void setUp() {
@@ -52,4 +60,77 @@ public void get_syncValues() {
         assertEquals(user, session.getUser());
         assertEquals(configuration, session.getConfiguration());
     }
+
+    // Check that a Client Reset is correctly reported.
+    @Test
+    @RunTestInLooperThread
+    public void errorHandler_clientResetReported() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user , url)
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        fail("Wrong error " + error.toString());
+                    }
+
+                    @Override
+                    public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
+                        String filePathFromError = handler.getOriginalFile().getAbsolutePath();
+                        String filePathFromConfig = session.getConfiguration().getPath();
+                        assertEquals(filePathFromError, filePathFromConfig);
+                        assertFalse(handler.getBackupFile().exists());
+                        assertTrue(handler.getOriginalFile().exists());
+                        looperThread.testComplete();
+                    }
+                })
+                .build();
+
+        Realm realm = Realm.getInstance(config);
+        looperThread.testRealms.add(realm);
+
+        // Trigger error
+        SyncManager.simulateClientReset(SyncManager.getSession(config));
+    }
+
+    // Check that we can manually execute the Client Reset.
+    @Test
+    @RunTestInLooperThread
+    public void errorHandler_manualExecuteClientReset() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user , url)
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        fail("Wrong error " + error.toString());
+                    }
+
+                    @Override
+                    public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
+                        try {
+                            handler.executeClientReset();
+                            fail("All Realms should be closed before executing Client Reset can be allowed");
+                        } catch(IllegalStateException ignored) {
+                        }
+
+                        // Execute Client Reset
+                        looperThread.testRealms.get(0).close();
+                        handler.executeClientReset();
+
+                        // Validate that files have been moved
+                        assertFalse(handler.getOriginalFile().exists());
+                        assertTrue(handler.getBackupFile().exists());
+                        looperThread.testComplete();
+                    }
+                })
+                .build();
+
+        Realm realm = Realm.getInstance(config);
+        looperThread.testRealms.add(realm);
+
+        // Trigger error
+        SyncManager.simulateClientReset(SyncManager.getSession(config));
+    }
+
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
index 3b7a2a466f..2e294ffe75 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
@@ -225,6 +225,11 @@ public void errorHandler() {
             public void onError(SyncSession session, ObjectServerError error) {
 
             }
+
+            @Override
+            public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
+
+            }
         };
         SyncConfiguration config = builder.errorHandler(errorHandler).build();
         assertEquals(errorHandler, config.getErrorHandler());
@@ -238,6 +243,11 @@ public void errorHandler_fromSyncManager() {
             public void onError(SyncSession session, ObjectServerError error) {
 
             }
+
+            @Override
+            public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
+
+            }
         };
         SyncManager.setDefaultSessionErrorHandler(errorHandler);
 
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
index cb296dc293..de368019a5 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
@@ -24,6 +24,7 @@
 
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
+import io.realm.SyncSession;
 import io.realm.SyncUser;
 import io.realm.internal.network.AuthenticateResponse;
 import io.realm.internal.objectserver.ObjectServerUser;
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java
index f8737f2fb2..54e69d495d 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java
@@ -22,6 +22,7 @@
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
+import java.nio.charset.Charset;
 import java.text.DecimalFormat;
 
 import dk.ilios.spanner.model.Trial;
@@ -46,7 +47,7 @@ public CSVResultProcessor(File resultFile) {
         this.resultFile = resultFile;
         this.workFile = new File(resultFile.getPath() + ".tmp");
         try {
-            writer = new CSVWriter(new FileWriter(resultFile));
+            writer = new CSVWriter(Files.newWriter(resultFile, Charset.forName("UTF-8")));
             addLabels();
         } catch (IOException e) {
             throw new RuntimeException(e);
diff --git a/realm/realm-library/src/main/cpp/.clang-format b/realm/realm-library/src/main/cpp/.clang-format
new file mode 100644
index 0000000000..9361184616
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/.clang-format
@@ -0,0 +1,89 @@
+---
+Language:        Cpp
+AccessModifierOffset: -4
+AlignAfterOpenBracket: Align
+AlignConsecutiveAssignments: false
+AlignConsecutiveDeclarations: false
+AlignEscapedNewlinesLeft: false
+AlignOperands:   true
+AlignTrailingComments: true
+AllowAllParametersOfDeclarationOnNextLine: true
+AllowShortBlocksOnASingleLine: false
+AllowShortCaseLabelsOnASingleLine: false
+AllowShortFunctionsOnASingleLine: Empty
+AllowShortIfStatementsOnASingleLine: false
+AllowShortLoopsOnASingleLine: false
+AlwaysBreakAfterDefinitionReturnType: None
+AlwaysBreakAfterReturnType: None
+AlwaysBreakBeforeMultilineStrings: false
+AlwaysBreakTemplateDeclarations: true
+BinPackArguments: true
+BinPackParameters: true
+BraceWrapping:   
+  AfterClass:      false
+  AfterControlStatement: false
+  AfterEnum:       false
+  AfterFunction:   true
+  AfterNamespace:  false
+  AfterObjCDeclaration: false
+  AfterStruct:     false
+  AfterUnion:      false
+  BeforeCatch:     true
+  BeforeElse:      true
+  IndentBraces:    false
+BreakBeforeBinaryOperators: None
+BreakBeforeBraces: Custom
+BreakBeforeTernaryOperators: true
+BreakConstructorInitializersBeforeComma: true
+ColumnLimit:     118
+CommentPragmas:  '^ IWYU pragma:'
+ConstructorInitializerAllOnOneLineOrOnePerLine: false
+ConstructorInitializerIndentWidth: 4
+ContinuationIndentWidth: 4
+Cpp11BracedListStyle: true
+DerivePointerAlignment: false
+DisableFormat:   false
+ExperimentalAutoDetectBinPacking: false
+ForEachMacros:   [ foreach, Q_FOREACH, BOOST_FOREACH ]
+IncludeCategories: 
+  - Regex:           '^"(llvm|llvm-c|clang|clang-c)/'
+    Priority:        2
+  - Regex:           '^(<|"(gtest|isl|json)/)'
+    Priority:        3
+  - Regex:           '.*'
+    Priority:        1
+IndentCaseLabels: true
+IndentWidth:     4
+IndentWrappedFunctionNames: false
+KeepEmptyLinesAtTheStartOfBlocks: true
+MacroBlockBegin: ''
+MacroBlockEnd:   ''
+MaxEmptyLinesToKeep: 2
+NamespaceIndentation: None
+ObjCBlockIndentWidth: 2
+ObjCSpaceAfterProperty: false
+ObjCSpaceBeforeProtocolList: true
+PenaltyBreakBeforeFirstCallParameter: 19
+PenaltyBreakComment: 300
+PenaltyBreakFirstLessLess: 120
+PenaltyBreakString: 1000
+PenaltyExcessCharacter: 1000000
+PenaltyReturnTypeOnItsOwnLine: 60
+PointerAlignment: Left
+ReflowComments:  true
+SortIncludes:    false
+SpaceAfterCStyleCast: false
+SpaceBeforeAssignmentOperators: true
+SpaceBeforeParens: ControlStatements
+SpaceInEmptyParentheses: false
+SpacesBeforeTrailingComments: 1
+SpacesInAngles:  false
+SpacesInContainerLiterals: true
+SpacesInCStyleCastParentheses: false
+SpacesInParentheses: false
+SpacesInSquareBrackets: false
+Standard:        Cpp11
+TabWidth:        4
+UseTab:          Never
+...
+
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index 1b44bb360b..0b64588552 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -45,7 +45,9 @@ set(classes_LIST
 set(jni_headers_PATH /./${PROJECT_BINARY_DIR}/jni_include)
 if (build_SYNC)
     list(APPEND classes_LIST
-        io.realm.SyncManager io.realm.SyncSession io.realm.RealmFileUserStore)
+        io.realm.ClientResetHandler io.realm.RealmFileUserStore
+        io.realm.SyncManager io.realm.SyncSession
+    )
 endif()
 create_javah(TARGET jni_headers
     CLASSES ${classes_LIST}
@@ -153,9 +155,11 @@ file(GLOB jni_SRC
 # Those source file are only needed for sync.
 if (NOT build_SYNC)
     list(REMOVE_ITEM jni_SRC
+        ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_ClientResetHandler.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_RealmFileUserStore.cpp
         ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_SyncManager.cpp
         ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_SyncSession.cpp
-        ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_RealmFileUserStore.cpp)
+    )
 endif()
 
 # Object Store source files
diff --git a/realm/realm-library/src/main/cpp/io_realm_ClientResetHandler.cpp b/realm/realm-library/src/main/cpp/io_realm_ClientResetHandler.cpp
new file mode 100644
index 0000000000..61a72c1145
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_ClientResetHandler.cpp
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+
+#include <sync/sync_manager.hpp>
+
+#include "util.hpp"
+#include "io_realm_ClientResetHandler.h"
+
+using namespace realm;
+
+JNIEXPORT void JNICALL Java_io_realm_ClientResetHandler_nativeExecuteClientReset(JNIEnv* env, jobject,
+                                                                               jstring localRealmPath)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor local_realm_path(env, localRealmPath);
+        if (!SyncManager::shared().immediately_run_file_actions(std::string(local_realm_path))) {
+            ThrowException(
+                env, IllegalState,
+                concat_stringdata("Realm was not configured correctly. Client Reset could not be run for Realm at: ",
+                                  local_realm_path));
+            return;
+        }
+    }
+    CATCH_STD()
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_Property.cpp b/realm/realm-library/src/main/cpp/io_realm_Property.cpp
index b107982b07..3aaedada73 100644
--- a/realm/realm-library/src/main/cpp/io_realm_Property.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_Property.cpp
@@ -25,18 +25,18 @@
 
 using namespace realm;
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_Property_nativeCreateProperty__Ljava_lang_String_2IZZZ(JNIEnv *env, jclass, jstring name_,
-                                                                     jint type, jboolean is_primary, jboolean is_indexed,
-                                                                     jboolean is_nullable) {
+JNIEXPORT jlong JNICALL Java_io_realm_Property_nativeCreateProperty__Ljava_lang_String_2IZZZ(
+    JNIEnv* env, jclass, jstring name_, jint type, jboolean is_primary, jboolean is_indexed, jboolean is_nullable)
+{
     TR_ENTER()
     try {
         JStringAccessor str(env, name_);
         PropertyType p_type = static_cast<PropertyType>(static_cast<int>(type));
-        std::unique_ptr<Property> property(new Property(str, p_type, "", "", to_bool(is_primary), to_bool(is_indexed), to_bool(is_nullable)));
+        std::unique_ptr<Property> property(
+            new Property(str, p_type, "", "", to_bool(is_primary), to_bool(is_indexed), to_bool(is_nullable)));
         if (to_bool(is_indexed) && !property->is_indexable()) {
             throw std::invalid_argument(
-                    "This field cannot be indexed - Only String/byte/short/int/long/boolean/Date fields are supported.");
+                "This field cannot be indexed - Only String/byte/short/int/long/boolean/Date fields are supported.");
         }
         if (to_bool(is_primary) && p_type != PropertyType::Int && p_type != PropertyType::String) {
             std::string typ = property->type_string();
@@ -48,10 +48,9 @@ Java_io_realm_Property_nativeCreateProperty__Ljava_lang_String_2IZZZ(JNIEnv *env
     return 0;
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_Property_nativeCreateProperty__Ljava_lang_String_2ILjava_lang_String_2(JNIEnv *env, jclass,
-                                                                                     jstring name_, jint type,
-                                                                                     jstring linkedToName_) {
+JNIEXPORT jlong JNICALL Java_io_realm_Property_nativeCreateProperty__Ljava_lang_String_2ILjava_lang_String_2(
+    JNIEnv* env, jclass, jstring name_, jint type, jstring linkedToName_)
+{
     TR_ENTER()
     try {
         JStringAccessor name(env, name_);
@@ -65,11 +64,11 @@ Java_io_realm_Property_nativeCreateProperty__Ljava_lang_String_2ILjava_lang_Stri
     return 0;
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_Property_nativeClose(JNIEnv *env, jclass, jlong property_ptr) {
+JNIEXPORT void JNICALL Java_io_realm_Property_nativeClose(JNIEnv* env, jclass, jlong property_ptr)
+{
     TR_ENTER_PTR(property_ptr)
     try {
-        Property *property = reinterpret_cast<Property *>(property_ptr);
+        Property* property = reinterpret_cast<Property*>(property_ptr);
         delete property;
     }
     CATCH_STD()
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
index 348693b7dc..313a2d169b 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
@@ -25,54 +25,55 @@ using namespace realm;
 
 static const char* ERR_COULD_NOT_ALLOCATE_MEMORY = "Could not allocate memory to return all users.";
 
-static jstring
-to_user_string_or_null (JNIEnv *env, const std::shared_ptr<SyncUser>& user)
+static jstring to_user_string_or_null(JNIEnv* env, const std::shared_ptr<SyncUser>& user)
 {
     if (user) {
         return to_jstring(env, user->refresh_token().data());
-    } else {
+    }
+    else {
         return nullptr;
     }
 }
 
-JNIEXPORT jstring JNICALL
-Java_io_realm_RealmFileUserStore_nativeGetCurrentUser (JNIEnv *env, jclass)
+JNIEXPORT jstring JNICALL Java_io_realm_RealmFileUserStore_nativeGetCurrentUser(JNIEnv* env, jclass)
 {
     TR_ENTER()
     try {
         const std::shared_ptr<SyncUser>& user = SyncManager::shared().get_current_user();
         return to_user_string_or_null(env, user);
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return nullptr;
 }
 
-JNIEXPORT jstring JNICALL
-Java_io_realm_RealmFileUserStore_nativeGetUser (JNIEnv *env, jclass, jstring identity)
+JNIEXPORT jstring JNICALL Java_io_realm_RealmFileUserStore_nativeGetUser(JNIEnv* env, jclass, jstring identity)
 {
     TR_ENTER()
     try {
         JStringAccessor id(env, identity); // throws
         const std::shared_ptr<SyncUser>& user = SyncManager::shared().get_existing_logged_in_user(id);
         return to_user_string_or_null(env, user);
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return nullptr;
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_RealmFileUserStore_nativeUpdateOrCreateUser (JNIEnv *env, jclass, jstring identity, jstring jsonToken, jstring url)
+JNIEXPORT void JNICALL Java_io_realm_RealmFileUserStore_nativeUpdateOrCreateUser(JNIEnv* env, jclass,
+                                                                                 jstring identity, jstring jsonToken,
+                                                                                 jstring url)
 {
     TR_ENTER()
     try {
-        JStringAccessor user_identity(env, identity); // throws
+        JStringAccessor user_identity(env, identity);    // throws
         JStringAccessor user_json_token(env, jsonToken); // throws
-        JStringAccessor auth_url(env, url); // throws
+        JStringAccessor auth_url(env, url);              // throws
 
         SyncManager::shared().get_user(user_identity, user_json_token, std::string(auth_url));
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_RealmFileUserStore_nativeLogoutUser (JNIEnv *env, jclass, jstring identity)
+JNIEXPORT void JNICALL Java_io_realm_RealmFileUserStore_nativeLogoutUser(JNIEnv* env, jclass, jstring identity)
 {
     TR_ENTER()
     try {
@@ -81,12 +82,11 @@ Java_io_realm_RealmFileUserStore_nativeLogoutUser (JNIEnv *env, jclass, jstring
         if (user) {
             user->log_out();
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-
-JNIEXPORT jobjectArray JNICALL
-Java_io_realm_RealmFileUserStore_nativeGetAllUsers (JNIEnv *env, jclass)
+JNIEXPORT jobjectArray JNICALL Java_io_realm_RealmFileUserStore_nativeGetAllUsers(JNIEnv* env, jclass)
 {
     TR_ENTER()
     std::vector<std::shared_ptr<SyncUser>> all_users = SyncManager::shared().all_logged_in_users();
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmObjectSchema.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmObjectSchema.cpp
index a2227dacad..e6804a0ad5 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmObjectSchema.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmObjectSchema.cpp
@@ -23,12 +23,13 @@
 #include "util.hpp"
 using namespace realm;
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_RealmObjectSchema_nativeCreateRealmObjectSchema(JNIEnv *env, jclass, jstring className_) {
+JNIEXPORT jlong JNICALL Java_io_realm_RealmObjectSchema_nativeCreateRealmObjectSchema(JNIEnv* env, jclass,
+                                                                                      jstring className_)
+{
     TR_ENTER()
     try {
         JStringAccessor name(env, className_);
-        ObjectSchema *object_schema = new ObjectSchema();
+        ObjectSchema* object_schema = new ObjectSchema();
         object_schema->name = name;
         return reinterpret_cast<jlong>(object_schema);
     }
@@ -36,8 +37,8 @@ Java_io_realm_RealmObjectSchema_nativeCreateRealmObjectSchema(JNIEnv *env, jclas
     return 0;
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_RealmObjectSchema_nativeClose(JNIEnv *env, jclass, jlong native_ptr) {
+JNIEXPORT void JNICALL Java_io_realm_RealmObjectSchema_nativeClose(JNIEnv* env, jclass, jlong native_ptr)
+{
     TR_ENTER_PTR(native_ptr)
     try {
         ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(native_ptr);
@@ -47,8 +48,9 @@ Java_io_realm_RealmObjectSchema_nativeClose(JNIEnv *env, jclass, jlong native_pt
 }
 
 
-JNIEXPORT void JNICALL
-Java_io_realm_RealmObjectSchema_nativeAddProperty(JNIEnv *env, jclass, jlong native_ptr, jlong property_ptr) {
+JNIEXPORT void JNICALL Java_io_realm_RealmObjectSchema_nativeAddProperty(JNIEnv* env, jclass, jlong native_ptr,
+                                                                         jlong property_ptr)
+{
     TR_ENTER_PTR(native_ptr)
     try {
         ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(native_ptr);
@@ -61,8 +63,8 @@ Java_io_realm_RealmObjectSchema_nativeAddProperty(JNIEnv *env, jclass, jlong nat
     CATCH_STD()
 }
 
-JNIEXPORT jstring JNICALL
-Java_io_realm_RealmObjectSchema_nativeGetClassName(JNIEnv *env, jclass, jlong nativePtr) {
+JNIEXPORT jstring JNICALL Java_io_realm_RealmObjectSchema_nativeGetClassName(JNIEnv* env, jclass, jlong nativePtr)
+{
     TR_ENTER_PTR(nativePtr)
     try {
         ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(nativePtr);
@@ -71,11 +73,11 @@ Java_io_realm_RealmObjectSchema_nativeGetClassName(JNIEnv *env, jclass, jlong na
     }
     CATCH_STD()
 
-    return NULL;
+    return nullptr;
 }
 
-JNIEXPORT jlongArray JNICALL
-Java_io_realm_RealmObjectSchema_nativeGetProperties(JNIEnv *env, jclass, jlong nativePtr) {
+JNIEXPORT jlongArray JNICALL Java_io_realm_RealmObjectSchema_nativeGetProperties(JNIEnv* env, jclass, jlong nativePtr)
+{
     TR_ENTER_PTR(nativePtr)
     try {
         ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(nativePtr);
@@ -96,6 +98,5 @@ Java_io_realm_RealmObjectSchema_nativeGetProperties(JNIEnv *env, jclass, jlong n
     }
     CATCH_STD()
 
-    return NULL;
+    return nullptr;
 }
-
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmSchema.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmSchema.cpp
index 9c6f1992e3..7bc774c51c 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmSchema.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmSchema.cpp
@@ -25,8 +25,9 @@
 using namespace realm;
 
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_RealmSchema_nativeCreateFromList(JNIEnv *env, jclass, jlongArray objectSchemaPtrs_) {
+JNIEXPORT jlong JNICALL Java_io_realm_RealmSchema_nativeCreateFromList(JNIEnv* env, jclass,
+                                                                       jlongArray objectSchemaPtrs_)
+{
     TR_ENTER()
     try {
         std::vector<ObjectSchema> object_schemas;
@@ -35,22 +36,22 @@ Java_io_realm_RealmSchema_nativeCreateFromList(JNIEnv *env, jclass, jlongArray o
             ObjectSchema object_schema = *reinterpret_cast<ObjectSchema*>(array[i]);
             object_schemas.push_back(std::move(object_schema));
         }
-        auto *schema = new Schema(object_schemas);
+        auto* schema = new Schema(object_schemas);
         return reinterpret_cast<jlong>(schema);
     }
     CATCH_STD()
     return 0;
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_RealmSchema_nativeClose(JNIEnv*, jclass, jlong nativePtr) {
+JNIEXPORT void JNICALL Java_io_realm_RealmSchema_nativeClose(JNIEnv*, jclass, jlong nativePtr)
+{
     TR_ENTER_PTR(nativePtr)
     Schema* schema = reinterpret_cast<Schema*>(nativePtr);
     delete schema;
 }
 
-JNIEXPORT jlongArray JNICALL
-Java_io_realm_RealmSchema_nativeGetAll(JNIEnv *env, jclass, jlong nativePtr) {
+JNIEXPORT jlongArray JNICALL Java_io_realm_RealmSchema_nativeGetAll(JNIEnv* env, jclass, jlong nativePtr)
+{
     TR_ENTER_PTR(nativePtr)
     try {
         Schema* schema = reinterpret_cast<Schema*>(nativePtr);
@@ -70,6 +71,5 @@ Java_io_realm_RealmSchema_nativeGetAll(JNIEnv *env, jclass, jlong nativePtr) {
         return native_ptr_array;
     }
     CATCH_STD()
-    return NULL;
+    return nullptr;
 }
-
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
index a4056c74e5..bb9d1dab0d 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
@@ -14,80 +14,89 @@
  * limitations under the License.
  */
 
-#include <jni.h>
-
-#include <chrono>
-#include <functional>
-#include <mutex>
-#include <vector>
+#include "io_realm_SyncManager.h"
 
 #include <realm/group_shared.hpp>
-#include <realm/sync/history.hpp>
-#include <realm/sync/client.hpp>
-
-#include "io_realm_SyncManager.h"
 
-#include "object-store/src/sync/sync_manager.hpp"
+#include <sync/sync_manager.hpp>
+#include <sync/sync_session.hpp>
+#include <binding_callback_thread_observer.hpp>
 
-#include "binding_callback_thread_observer.hpp"
 #include "util.hpp"
-
 #include "jni_util/jni_utils.hpp"
 #include "jni_util/java_method.hpp"
 
 using namespace realm;
-using namespace realm::sync;
 using namespace realm::jni_util;
 
-std::unique_ptr<Client> sync_client;
-
 struct AndroidClientListener : public realm::BindingCallbackThreadObserver {
 
-    void did_create_thread() override {
+    void did_create_thread() override
+    {
         Log::d("SyncClient thread created");
         // Attach the sync client thread to the JVM so errors can be returned properly
         JniUtils::get_env(true);
     }
 
-    void will_destroy_thread() override {
+    void will_destroy_thread() override
+    {
         Log::d("SyncClient thread destroyed");
         // Failing to detach the JVM before closing the thread will crash on ART
         JniUtils::detach_current_thread();
     }
 } s_client_thread_listener;
 
-JNIEXPORT void JNICALL Java_io_realm_SyncManager_nativeInitializeSyncClient
-    (JNIEnv* env, jclass)
+struct AndroidSyncLoggerFactory : public realm::SyncLoggerFactory {
+    std::unique_ptr<util::Logger> make_logger(Logger::Level level) override
+    {
+        auto logger = std::make_unique<CoreLoggerBridge>(std::string("REALM_SYNC"));
+        logger->set_level_threshold(level);
+        // Cast to std::unique_ptr<util::Logger>
+        return std::move(logger);
+    }
+} s_sync_logger_factory;
+
+JNIEXPORT void JNICALL Java_io_realm_SyncManager_nativeReset(JNIEnv* env, jclass)
 {
     TR_ENTER()
-    if (sync_client) return;
-
     try {
-        // Setup SyncManager
-        g_binding_callback_thread_observer = &s_client_thread_listener;
-
-        // Create SyncClient
-        sync::Client::Config config;
-        config.logger = &CoreLoggerBridge::shared();
-        sync_client = std::make_unique<Client>(std::move(config)); // Throws
-    } CATCH_STD()
+        SyncManager::shared().reset_for_testing();
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_SyncManager_nativeReset(JNIEnv* env, jclass) {
-
+JNIEXPORT void JNICALL Java_io_realm_SyncManager_nativeInitializeSyncManager(JNIEnv* env, jclass, jstring sync_base_dir)
+{
     TR_ENTER()
     try {
-        SyncManager::shared().reset_for_testing();
-    } CATCH_STD()
+        JStringAccessor base_file_path(env, sync_base_dir); // throws
+        SyncManager::shared().configure_file_system(base_file_path, SyncManager::MetadataMode::NoEncryption);
+
+        // Register Sync Client thread start/stop callback
+        g_binding_callback_thread_observer = &s_client_thread_listener;
+
+        // init logger
+        SyncManager::shared().set_logger_factory(s_sync_logger_factory);
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_SyncManager_nativeConfigureMetaDataSystem(JNIEnv *env, jclass,
-                                                        jstring baseFile) {
+JNIEXPORT void JNICALL Java_io_realm_SyncManager_nativeSimulateSyncError(JNIEnv* env, jclass, jstring local_realm_path,
+                                                                         jint err_code, jstring err_message,
+                                                                         jboolean is_fatal)
+{
     TR_ENTER()
     try {
-        JStringAccessor base_file_path(env, baseFile); // throws
-        SyncManager::shared().configure_file_system(base_file_path, SyncManager::MetadataMode::NoEncryption);
-    } CATCH_STD()
+        JStringAccessor path(env, local_realm_path);
+        JStringAccessor message(env, err_message);
+
+        auto session = SyncManager::shared().get_existing_active_session(path);
+        if (!session) {
+            ThrowException(env, IllegalArgument, concat_stringdata("Session not found: ", path));
+            return;
+        }
+        std::error_code code = std::error_code{static_cast<int>(err_code), realm::sync::protocol_error_category()};
+        SyncSession::OnlyForTesting::handle_error(*session, {code, std::string(message), to_bool(is_fatal)});
+    }
+    CATCH_STD()
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
index b419a697f6..142e64d0c4 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
@@ -21,26 +21,28 @@
 
 using namespace realm;
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnCount
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnCount(JNIEnv* env, jobject obj,
+                                                                               jlong nativeRowPtr)
 {
-    if (!ROW(nativeRowPtr)->is_attached())
+    if (!ROW(nativeRowPtr)->is_attached()) {
         return 0;
+    }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetColumnCount(env, obj, nativeRowPtr);
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnName
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnName(JNIEnv* env, jobject obj,
+                                                                                jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!ROW_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr), columnIndex))
+    if (!ROW_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr), columnIndex)) {
         return NULL;
+    }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetColumnName(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnIndex
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jstring columnName)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnIndex(JNIEnv* env, jobject obj,
+                                                                               jlong nativeRowPtr, jstring columnName)
 {
     if (!ROW(nativeRowPtr)->is_attached())
         return 0;
@@ -56,182 +58,206 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnIndex
     }
 }
 
-JNIEXPORT jint JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnType
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jint JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnType(JNIEnv* env, jobject obj,
+                                                                             jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!ROW_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr), columnIndex))
+    if (!ROW_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr), columnIndex)) {
         return 0;
+    }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetColumnType(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLong
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLong(JNIEnv* env, jobject obj, jlong nativeRowPtr,
+                                                                        jlong columnIndex)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Int))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Int)) {
         return 0;
+    }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetLong(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeGetBoolean
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeGetBoolean(JNIEnv* env, jobject obj,
+                                                                              jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Bool))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Bool)) {
         return 0;
+    }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetBoolean(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_CheckedRow_nativeGetFloat
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jfloat JNICALL Java_io_realm_internal_CheckedRow_nativeGetFloat(JNIEnv* env, jobject obj,
+                                                                          jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Float))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Float)) {
         return 0;
+    }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetFloat(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_CheckedRow_nativeGetDouble
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_CheckedRow_nativeGetDouble(JNIEnv* env, jobject obj,
+                                                                            jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Double))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Double)) {
         return 0;
+    }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetDouble(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetTimestamp
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetTimestamp(JNIEnv* env, jobject obj,
+                                                                             jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Timestamp))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Timestamp)) {
         return 0;
+    }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetTimestamp(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetString
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetString(JNIEnv* env, jobject obj,
+                                                                            jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_String))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_String)) {
         return 0;
+    }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetString(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_CheckedRow_nativeGetByteArray
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_CheckedRow_nativeGetByteArray(JNIEnv* env, jobject obj,
+                                                                                  jlong nativeRowPtr,
+                                                                                  jlong columnIndex)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Binary))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Binary)) {
         return 0;
+    }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetByteArray(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLink
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLink(JNIEnv* env, jobject obj, jlong nativeRowPtr,
+                                                                        jlong columnIndex)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link)) {
         return 0;
+    }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetLink(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNullLink
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNullLink(JNIEnv* env, jobject obj,
+                                                                              jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link)) {
         return 0;
+    }
 
     return Java_io_realm_internal_UncheckedRow_nativeIsNullLink(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLinkView
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLinkView(JNIEnv* env, jobject obj,
+                                                                            jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_LinkList))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_LinkList)) {
         return 0;
+    }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetLinkView(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLong
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLong(JNIEnv* env, jobject obj, jlong nativeRowPtr,
+                                                                       jlong columnIndex, jlong value)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Int))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Int)) {
         return;
+    }
 
     Java_io_realm_internal_UncheckedRow_nativeSetLong(env, obj, nativeRowPtr, columnIndex, value);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetBoolean
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jboolean value)
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetBoolean(JNIEnv* env, jobject obj,
+                                                                          jlong nativeRowPtr, jlong columnIndex,
+                                                                          jboolean value)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Bool))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Bool)) {
         return;
+    }
 
     Java_io_realm_internal_UncheckedRow_nativeSetBoolean(env, obj, nativeRowPtr, columnIndex, value);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetFloat
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jfloat value)
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetFloat(JNIEnv* env, jobject obj, jlong nativeRowPtr,
+                                                                        jlong columnIndex, jfloat value)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Float))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Float)) {
         return;
+    }
 
     Java_io_realm_internal_UncheckedRow_nativeSetFloat(env, obj, nativeRowPtr, columnIndex, value);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDouble
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jdouble value)
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDouble(JNIEnv* env, jobject obj, jlong nativeRowPtr,
+                                                                         jlong columnIndex, jdouble value)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Double))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Double)) {
         return;
+    }
 
     Java_io_realm_internal_UncheckedRow_nativeSetDouble(env, obj, nativeRowPtr, columnIndex, value);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetTimestamp
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetTimestamp(JNIEnv* env, jobject obj,
+                                                                            jlong nativeRowPtr, jlong columnIndex,
+                                                                            jlong value)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Timestamp))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Timestamp)) {
         return;
+    }
 
     Java_io_realm_internal_UncheckedRow_nativeSetTimestamp(env, obj, nativeRowPtr, columnIndex, value);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetString
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jstring value)
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetString(JNIEnv* env, jobject obj, jlong nativeRowPtr,
+                                                                         jlong columnIndex, jstring value)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_String))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_String)) {
         return;
+    }
 
     Java_io_realm_internal_UncheckedRow_nativeSetString(env, obj, nativeRowPtr, columnIndex, value);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetByteArray
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jbyteArray value)
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetByteArray(JNIEnv* env, jobject obj,
+                                                                            jlong nativeRowPtr, jlong columnIndex,
+                                                                            jbyteArray value)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Binary))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Binary)) {
         return;
+    }
 
     Java_io_realm_internal_UncheckedRow_nativeSetByteArray(env, obj, nativeRowPtr, columnIndex, value);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLink
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLink(JNIEnv* env, jobject obj, jlong nativeRowPtr,
+                                                                       jlong columnIndex, jlong value)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link)) {
         return;
+    }
 
     Java_io_realm_internal_UncheckedRow_nativeSetLink(env, obj, nativeRowPtr, columnIndex, value);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeNullifyLink
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeNullifyLink(JNIEnv* env, jobject obj,
+                                                                           jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link)) {
         return;
+    }
 
     Java_io_realm_internal_UncheckedRow_nativeNullifyLink(env, obj, nativeRowPtr, columnIndex);
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
index e17d47f692..057f7a79ba 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
@@ -38,7 +38,11 @@ struct ResultsWrapper {
     Results m_results;
 
     ResultsWrapper(Results& results)
-    : m_collection_weak_ref(), m_notification_token(), m_results(std::move(results)) {}
+        : m_collection_weak_ref()
+        , m_notification_token()
+        , m_results(std::move(results))
+    {
+    }
 
     ResultsWrapper(ResultsWrapper&&) = delete;
     ResultsWrapper& operator=(ResultsWrapper&&) = delete;
@@ -46,7 +50,9 @@ struct ResultsWrapper {
     ResultsWrapper(ResultsWrapper const&) = delete;
     ResultsWrapper& operator=(ResultsWrapper const&) = delete;
 
-    ~ResultsWrapper() {}
+    ~ResultsWrapper()
+    {
+    }
 };
 
 static void finalize_results(jlong ptr);
@@ -57,9 +63,10 @@ static void finalize_results(jlong ptr)
     delete reinterpret_cast<ResultsWrapper*>(ptr);
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_Collection_nativeCreateResults(JNIEnv* env, jclass, jlong shared_realm_ptr, jlong query_ptr,
-        jobject sort_desc, jobject distinct_desc)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResults(JNIEnv* env, jclass,
+                                                                              jlong shared_realm_ptr, jlong query_ptr,
+                                                                              jobject sort_desc,
+                                                                              jobject distinct_desc)
 {
     TR_ENTER()
     try {
@@ -69,35 +76,35 @@ Java_io_realm_internal_Collection_nativeCreateResults(JNIEnv* env, jclass, jlong
         }
 
         auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-        Results results(shared_realm, *query,
-                        SortDescriptor(JavaSortDescriptor(env, sort_desc)),
+        Results results(shared_realm, *query, SortDescriptor(JavaSortDescriptor(env, sort_desc)),
                         SortDescriptor(JavaSortDescriptor(env, distinct_desc)));
         auto wrapper = new ResultsWrapper(results);
 
         return reinterpret_cast<jlong>(wrapper);
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_Collection_nativeCreateResultsFromLinkView(JNIEnv* env, jclass, jlong shared_realm_ptr,
-                                                                  jlong link_view_ptr, jobject sort_desc)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResultsFromLinkView(JNIEnv* env, jclass,
+                                                                                          jlong shared_realm_ptr,
+                                                                                          jlong link_view_ptr,
+                                                                                          jobject sort_desc)
 {
     TR_ENTER()
     try {
         auto link_view_ref = reinterpret_cast<LinkViewRef*>(link_view_ptr);
         auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-        Results results(shared_realm, *link_view_ref, util::none,
-                        SortDescriptor(JavaSortDescriptor(env, sort_desc)));
+        Results results(shared_realm, *link_view_ref, util::none, SortDescriptor(JavaSortDescriptor(env, sort_desc)));
         auto wrapper = new ResultsWrapper(results);
 
         return reinterpret_cast<jlong>(wrapper);
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_Collection_nativeCreateSnapshot(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateSnapshot(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr);
     try {
@@ -105,12 +112,13 @@ Java_io_realm_internal_Collection_nativeCreateSnapshot(JNIEnv* env, jclass, jlon
         auto snapshot_results = wrapper->m_results.snapshot();
         auto snapshot_wrapper = new ResultsWrapper(snapshot_results);
         return reinterpret_cast<jlong>(snapshot_wrapper);
-    } CATCH_STD();
+    }
+    CATCH_STD();
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jboolean JNICALL
-Java_io_realm_internal_Collection_nativeContains(JNIEnv *env, jclass, jlong native_ptr, jlong native_row_ptr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeContains(JNIEnv* env, jclass, jlong native_ptr,
+                                                                            jlong native_row_ptr)
 {
     TR_ENTER_PTR(native_ptr);
     try {
@@ -118,24 +126,25 @@ Java_io_realm_internal_Collection_nativeContains(JNIEnv *env, jclass, jlong nati
         auto row = reinterpret_cast<Row*>(native_row_ptr);
         size_t index = wrapper->m_results.index_of(*row);
         return to_jbool(index != not_found);
-    } CATCH_STD();
+    }
+    CATCH_STD();
     return JNI_FALSE;
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_Collection_nativeGetRow(JNIEnv *env, jclass, jlong native_ptr, jint index)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeGetRow(JNIEnv* env, jclass, jlong native_ptr,
+                                                                       jint index)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
         auto row = wrapper->m_results.get(static_cast<size_t>(index));
         return reinterpret_cast<jlong>(new Row(std::move(row)));
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_Collection_nativeFirstRow(JNIEnv *env, jclass, jlong native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeFirstRow(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
@@ -144,13 +153,12 @@ Java_io_realm_internal_Collection_nativeFirstRow(JNIEnv *env, jclass, jlong nati
         if (optional_row) {
             return reinterpret_cast<jlong>(new Row(std::move(optional_row.value())));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return reinterpret_cast<jlong>(nullptr);
-
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_Collection_nativeLastRow(JNIEnv *env, jclass, jlong native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeLastRow(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
@@ -159,34 +167,34 @@ Java_io_realm_internal_Collection_nativeLastRow(JNIEnv *env, jclass, jlong nativ
         if (optional_row) {
             return reinterpret_cast<jlong>(new Row(std::move(optional_row.value())));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_Collection_nativeClear(JNIEnv *env, jclass, jlong native_ptr)
+JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeClear(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
         wrapper->m_results.clear();
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_Collection_nativeSize(JNIEnv *env, jclass, jlong native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeSize(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
         return static_cast<jlong>(wrapper->m_results.size());
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jobject JNICALL
-Java_io_realm_internal_Collection_nativeAggregate(JNIEnv *env, jclass, jlong native_ptr, jlong column_index,
-        jbyte agg_func)
+JNIEXPORT jobject JNICALL Java_io_realm_internal_Collection_nativeAggregate(JNIEnv* env, jclass, jlong native_ptr,
+                                                                            jlong column_index, jbyte agg_func)
 {
     TR_ENTER_PTR(native_ptr)
     try {
@@ -231,35 +239,39 @@ Java_io_realm_internal_Collection_nativeAggregate(JNIEnv *env, jclass, jlong nat
             default:
                 throw std::invalid_argument("Excepted numeric type");
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return static_cast<jobject>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_Collection_nativeSort(JNIEnv *env, jclass, jlong native_ptr, jobject sort_desc)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeSort(JNIEnv* env, jclass, jlong native_ptr,
+                                                                     jobject sort_desc)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
         auto sorted_result = wrapper->m_results.sort(JavaSortDescriptor(env, sort_desc));
         return reinterpret_cast<jlong>(new ResultsWrapper(sorted_result));
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_Collection_nativeDistinct(JNIEnv *env, jclass, jlong native_ptr, jobject distinct_desc) {
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeDistinct(JNIEnv* env, jclass, jlong native_ptr,
+                                                                         jobject distinct_desc)
+{
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
         auto distinct_result = wrapper->m_results.distinct(JavaSortDescriptor(env, distinct_desc));
         return reinterpret_cast<jlong>(new ResultsWrapper(distinct_result));
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_Collection_nativeStartListening(JNIEnv* env, jobject instance, jlong native_ptr)
+JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeStartListening(JNIEnv* env, jobject instance,
+                                                                              jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
 
@@ -273,62 +285,65 @@ Java_io_realm_internal_Collection_nativeStartListening(JNIEnv* env, jobject inst
 
         auto cb = [=](CollectionChangeSet const& changes, std::exception_ptr err) {
             // OS will call all notifiers' callback in one run, so check the Java exception first!!
-            if (env->ExceptionCheck()) return;
+            if (env->ExceptionCheck())
+                return;
 
             if (err) {
                 try {
                     std::rethrow_exception(err);
-                } catch(const std::exception& e) {
+                }
+                catch (const std::exception& e) {
                     realm::jni_util::Log::e("Caught exception in collection change callback %1", e.what());
                     return;
                 }
             }
 
-            wrapper->m_collection_weak_ref.call_with_local_ref(env, [&] (JNIEnv* local_env, jobject collection_obj) {
-                local_env->CallVoidMethod(collection_obj, notify_change_listeners,
-                                          reinterpret_cast<jlong>(changes.empty() ? 0 : new CollectionChangeSet(changes)));
+            wrapper->m_collection_weak_ref.call_with_local_ref(env, [&](JNIEnv* local_env, jobject collection_obj) {
+                local_env->CallVoidMethod(
+                    collection_obj, notify_change_listeners,
+                    reinterpret_cast<jlong>(changes.empty() ? 0 : new CollectionChangeSet(changes)));
             });
         };
 
-        wrapper->m_notification_token =  wrapper->m_results.add_notification_callback(cb);
-    } CATCH_STD()
+        wrapper->m_notification_token = wrapper->m_results.add_notification_callback(cb);
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_Collection_nativeStopListening(JNIEnv *env, jobject, jlong native_ptr)
+JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeStopListening(JNIEnv* env, jobject, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
 
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
         wrapper->m_notification_token = {};
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_Collection_nativeGetFinalizerPtr(JNIEnv *, jclass)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeGetFinalizerPtr(JNIEnv*, jclass)
 {
     TR_ENTER()
     return reinterpret_cast<jlong>(&finalize_results);
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_Collection_nativeWhere(JNIEnv *env, jclass, jlong native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeWhere(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
 
         auto table_view = wrapper->m_results.get_tableview();
-        Query *query = new Query(table_view.get_parent(),
-                                 std::unique_ptr<TableViewBase>(new TableView(std::move(table_view))));
+        Query* query =
+            new Query(table_view.get_parent(), std::unique_ptr<TableViewBase>(new TableView(std::move(table_view))));
         return reinterpret_cast<jlong>(query);
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_Collection_nativeIndexOf(JNIEnv *env, jclass, jlong native_ptr, jlong row_native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeIndexOf(JNIEnv* env, jclass, jlong native_ptr,
+                                                                        jlong row_native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
@@ -336,13 +351,14 @@ Java_io_realm_internal_Collection_nativeIndexOf(JNIEnv *env, jclass, jlong nativ
         auto row = reinterpret_cast<Row*>(row_native_ptr);
 
         return static_cast<jlong>(wrapper->m_results.index_of(*row));
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return npos;
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_Collection_nativeIndexOfBySourceRowIndex(JNIEnv *env, jclass, jlong native_ptr,
-                                                                jlong source_row_index)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeIndexOfBySourceRowIndex(JNIEnv* env, jclass,
+                                                                                        jlong native_ptr,
+                                                                                        jlong source_row_index)
 {
     TR_ENTER_PTR(native_ptr)
     try {
@@ -350,13 +366,12 @@ Java_io_realm_internal_Collection_nativeIndexOfBySourceRowIndex(JNIEnv *env, jcl
         auto index = static_cast<size_t>(source_row_index);
 
         return static_cast<jlong>(wrapper->m_results.index_of(index));
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return npos;
-
 }
 
-JNIEXPORT jboolean JNICALL
-Java_io_realm_internal_Collection_nativeDeleteLast(JNIEnv *env, jclass, jlong native_ptr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeDeleteLast(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
@@ -366,12 +381,12 @@ Java_io_realm_internal_Collection_nativeDeleteLast(JNIEnv *env, jclass, jlong na
             row->move_last_over();
             return JNI_TRUE;
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return JNI_FALSE;
 }
 
-JNIEXPORT jboolean JNICALL
-Java_io_realm_internal_Collection_nativeDeleteFirst(JNIEnv *env, jclass, jlong native_ptr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeDeleteFirst(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
 
@@ -382,12 +397,13 @@ Java_io_realm_internal_Collection_nativeDeleteFirst(JNIEnv *env, jclass, jlong n
             row->move_last_over();
             return JNI_TRUE;
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return JNI_FALSE;
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_Collection_nativeDelete(JNIEnv *env, jclass, jlong native_ptr, jlong index)
+JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeDelete(JNIEnv* env, jclass, jlong native_ptr,
+                                                                      jlong index)
 {
     TR_ENTER_PTR(native_ptr)
 
@@ -397,22 +413,22 @@ Java_io_realm_internal_Collection_nativeDelete(JNIEnv *env, jclass, jlong native
         if (row.is_attached()) {
             row.move_last_over();
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT jboolean JNICALL
-Java_io_realm_internal_Collection_nativeIsValid(JNIEnv *env, jclass, jlong native_ptr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeIsValid(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
         return wrapper->m_results.is_valid();
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return JNI_FALSE;
 }
 
-JNIEXPORT jbyte JNICALL
-Java_io_realm_internal_Collection_nativeGetMode(JNIEnv *env, jclass, jlong native_ptr)
+JNIEXPORT jbyte JNICALL Java_io_realm_internal_Collection_nativeGetMode(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
@@ -429,7 +445,30 @@ Java_io_realm_internal_Collection_nativeGetMode(JNIEnv *env, jclass, jlong nativ
             case Results::Mode::TableView:
                 return io_realm_internal_Collection_MODE_TABLEVIEW;
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return -1; // Invalid mode value
 }
 
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResultsFromBacklinks(JNIEnv *env, jclass,
+                                                                                           jlong shared_realm_ptr,
+                                                                                           jlong row_ptr,
+                                                                                           jlong src_table_ptr,
+                                                                                           jlong src_col_index)
+{
+    TR_ENTER_PTR(row_ptr)
+    Row* row = ROW(row_ptr);
+    if (!ROW_VALID(env, row)) {
+        return reinterpret_cast<jlong>(nullptr);
+    }
+    try {
+        Table* src_table = TBL(src_table_ptr);
+        TableView backlink_view = row->get_table()->get_backlink_view(row->get_index(), src_table, src_col_index);
+        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        Results results(shared_realm, std::move(backlink_view));
+        auto wrapper = new ResultsWrapper(results);
+        return reinterpret_cast<jlong>(wrapper);
+    }
+    CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_CollectionChangeSet.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_CollectionChangeSet.cpp
index 450324c171..f85fb853af 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_CollectionChangeSet.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_CollectionChangeSet.cpp
@@ -46,9 +46,9 @@ static jintArray index_set_to_jint_array(JNIEnv* env, const IndexSet& index_set)
 
     if (ranges_vector.size() > io_realm_internal_CollectionChangeSet_MAX_ARRAY_LENGTH) {
         std::ostringstream error_msg;
-        error_msg << "There are too many ranges changed in this change set. They cannot fit into an array." <<
-            " ranges_vector's size: " << ranges_vector.size() <<
-            " Java array's max size: " << io_realm_internal_CollectionChangeSet_MAX_ARRAY_LENGTH << ".";
+        error_msg << "There are too many ranges changed in this change set. They cannot fit into an array."
+                  << " ranges_vector's size: " << ranges_vector.size()
+                  << " Java array's max size: " << io_realm_internal_CollectionChangeSet_MAX_ARRAY_LENGTH << ".";
         ThrowException(env, IllegalState, error_msg.str());
         return nullptr;
     }
@@ -69,9 +69,9 @@ static jintArray index_set_to_indices_array(JNIEnv* env, const IndexSet& index_s
     }
     if (indices_vector.size() > io_realm_internal_CollectionChangeSet_MAX_ARRAY_LENGTH) {
         std::ostringstream error_msg;
-        error_msg << "There are too many indices in this change set. They cannot fit into an array." <<
-            " indices_vector's size: " << indices_vector.size() <<
-            " Java array's max size: " << io_realm_internal_CollectionChangeSet_MAX_ARRAY_LENGTH << ".";
+        error_msg << "There are too many indices in this change set. They cannot fit into an array."
+                  << " indices_vector's size: " << indices_vector.size()
+                  << " Java array's max size: " << io_realm_internal_CollectionChangeSet_MAX_ARRAY_LENGTH << ".";
         ThrowException(env, IllegalState, error_msg.str());
         return nullptr;
     }
@@ -80,15 +80,14 @@ static jintArray index_set_to_indices_array(JNIEnv* env, const IndexSet& index_s
     return jint_array;
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_CollectionChangeSet_nativeGetFinalizerPtr(JNIEnv*, jclass)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CollectionChangeSet_nativeGetFinalizerPtr(JNIEnv*, jclass)
 {
     TR_ENTER()
     return reinterpret_cast<jlong>(&finalize_changeset);
 }
 
-JNIEXPORT jintArray JNICALL
-Java_io_realm_internal_CollectionChangeSet_nativeGetRanges(JNIEnv *env, jclass, jlong native_ptr, jint type)
+JNIEXPORT jintArray JNICALL Java_io_realm_internal_CollectionChangeSet_nativeGetRanges(JNIEnv* env, jclass,
+                                                                                       jlong native_ptr, jint type)
 {
     TR_ENTER_PTR(native_ptr)
     // no throws
@@ -102,12 +101,11 @@ Java_io_realm_internal_CollectionChangeSet_nativeGetRanges(JNIEnv *env, jclass,
             return index_set_to_jint_array(env, change_set.modifications_new);
         default:
             REALM_UNREACHABLE();
-            break;
     }
 }
 
-JNIEXPORT jintArray JNICALL
-Java_io_realm_internal_CollectionChangeSet_nativeGetIndices(JNIEnv *env, jclass, jlong native_ptr, jint type)
+JNIEXPORT jintArray JNICALL Java_io_realm_internal_CollectionChangeSet_nativeGetIndices(JNIEnv* env, jclass,
+                                                                                        jlong native_ptr, jint type)
 {
     TR_ENTER_PTR(native_ptr)
     // no throws
@@ -121,7 +119,5 @@ Java_io_realm_internal_CollectionChangeSet_nativeGetIndices(JNIEnv *env, jclass,
             return index_set_to_indices_array(env, change_set.modifications_new);
         default:
             REALM_UNREACHABLE();
-            break;
     }
 }
-
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp
index 119cdf30fb..4ad4066411 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp
@@ -21,204 +21,216 @@ using namespace realm;
 
 static void finalize_link_view(jlong ptr);
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetRow
-  (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetRow(JNIEnv* env, jobject, jlong nativeLinkViewPtr,
+                                                                     jlong pos)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkViewRef *lv = LV(nativeLinkViewPtr);
+    LinkViewRef* lv = LV(nativeLinkViewPtr);
     if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return -1;
     }
     try {
         LinkViewRef lvr = *lv;
-        Row* row = new Row( (*lvr)[ S(pos) ] );
+        Row* row = new Row((*lvr)[S(pos)]);
         return reinterpret_cast<jlong>(row);
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetRowIndex
-  (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong linkViewIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetRowIndex(JNIEnv* env, jobject,
+                                                                                jlong nativeLinkViewPtr,
+                                                                                jlong linkViewIndex)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkViewRef *lv = LV(nativeLinkViewPtr);
+    LinkViewRef* lv = LV(nativeLinkViewPtr);
     if (!ROW_INDEX_VALID(env, *lv, linkViewIndex)) {
         return -1;
     }
     try {
         LinkViewRef lvr = *lv;
         return lvr->get(S(linkViewIndex)).get_index();
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
 
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeAdd
-  (JNIEnv* env, jclass, jlong nativeLinkViewPtr, jlong rowIndex)
+JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeAdd(JNIEnv* env, jclass, jlong nativeLinkViewPtr,
+                                                                 jlong rowIndex)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkViewRef *lv = LV(nativeLinkViewPtr);
+    LinkViewRef* lv = LV(nativeLinkViewPtr);
     try {
         LinkViewRef lvr = *lv;
-        lvr->add( S(rowIndex) );
-    } CATCH_STD()
+        lvr->add(S(rowIndex));
+    }
+    CATCH_STD()
 }
 
 
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeInsert
-  (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos, jlong rowIndex)
+JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeInsert(JNIEnv* env, jobject, jlong nativeLinkViewPtr,
+                                                                    jlong pos, jlong rowIndex)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkViewRef *lv = LV(nativeLinkViewPtr);
+    LinkViewRef* lv = LV(nativeLinkViewPtr);
     try {
         LinkViewRef lvr = *lv;
-        lvr->insert( S(pos), S(rowIndex) );
-    } CATCH_STD()
+        lvr->insert(S(pos), S(rowIndex));
+    }
+    CATCH_STD()
 }
 
 
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeSet
-  (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos, jlong rowIndex)
+JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeSet(JNIEnv* env, jobject, jlong nativeLinkViewPtr,
+                                                                 jlong pos, jlong rowIndex)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkViewRef *lv = LV(nativeLinkViewPtr);
+    LinkViewRef* lv = LV(nativeLinkViewPtr);
     if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return;
     }
     try {
         LinkViewRef lvr = *lv;
-        lvr->set( S(pos), S(rowIndex) );
-    } CATCH_STD()
+        lvr->set(S(pos), S(rowIndex));
+    }
+    CATCH_STD()
 }
 
 
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeMove
-  (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong old_pos, jlong new_pos)
+JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeMove(JNIEnv* env, jobject, jlong nativeLinkViewPtr,
+                                                                  jlong old_pos, jlong new_pos)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef* lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
         size_t size = lvr->size();
         if (old_pos < 0 || new_pos < 0 || size_t(old_pos) >= size || size_t(new_pos) >= size) {
-            ThrowException(env, IndexOutOfBounds,
-                "Indices must be within range [0, " + num_to_string(size) + "[. " +
-                "Yours were (" + num_to_string(old_pos) + "," + num_to_string(new_pos) + ")");
+            ThrowException(env, IndexOutOfBounds, "Indices must be within range [0, " + num_to_string(size) + "[. " +
+                                                      "Yours were (" + num_to_string(old_pos) + "," +
+                                                      num_to_string(new_pos) + ")");
             return;
         }
-        lvr->move( S(old_pos), S(new_pos) );
-    } CATCH_STD()
+        lvr->move(S(old_pos), S(new_pos));
+    }
+    CATCH_STD()
 }
 
 
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemove
-  (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
+JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemove(JNIEnv* env, jobject, jlong nativeLinkViewPtr,
+                                                                    jlong pos)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkViewRef *lv = LV(nativeLinkViewPtr);
+    LinkViewRef* lv = LV(nativeLinkViewPtr);
     if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return;
     }
     try {
         LinkViewRef lvr = *lv;
-        return lvr->remove( S(pos) );
-    } CATCH_STD()
+        return lvr->remove(S(pos));
+    }
+    CATCH_STD()
 }
 
 
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClear
-  (JNIEnv* env, jclass, jlong nativeLinkViewPtr)
+JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClear(JNIEnv* env, jclass, jlong nativeLinkViewPtr)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef* lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
         return lvr->clear();
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeSize
-  (JNIEnv* env, jobject, jlong nativeLinkViewPtr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeSize(JNIEnv* env, jobject, jlong nativeLinkViewPtr)
 {
-    
+
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef* lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
-        return lvr->size();
-    } CATCH_STD()
+        return static_cast<jlong>(lvr->size());
+    }
+    CATCH_STD()
     return 0;
 }
 
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsEmpty
-  (JNIEnv* env, jobject, jlong nativeLinkViewPtr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsEmpty(JNIEnv* env, jobject,
+                                                                         jlong nativeLinkViewPtr)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef* lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
-        return lvr->is_empty();
-    } CATCH_STD()
+        return to_jbool(lvr->is_empty());
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeWhere
-  (JNIEnv *env, jobject, jlong nativeLinkViewPtr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeWhere(JNIEnv* env, jobject, jlong nativeLinkViewPtr)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef* lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
-        Query *queryPtr = new Query(lvr->get_target_table().where(LinkViewRef(lvr)));
+        Query* queryPtr = new Query(lvr->get_target_table().where(LinkViewRef(lvr)));
         return reinterpret_cast<jlong>(queryPtr);
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsAttached
-  (JNIEnv *env, jobject, jlong nativeLinkViewPtr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsAttached(JNIEnv* env, jobject,
+                                                                            jlong nativeLinkViewPtr)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef* lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
-        return lvr->is_attached();
-    } CATCH_STD()
+        return to_jbool(lvr->is_attached());
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeFind
-  (JNIEnv *env, jobject, jlong nativeLinkViewPtr, jlong targetRowIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeFind(JNIEnv* env, jobject, jlong nativeLinkViewPtr,
+                                                                   jlong targetRowIndex)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef* lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
         if (!ROW_INDEX_VALID(env, &lvr->get_target_table(), targetRowIndex)) {
             return -1;
         }
-        size_t ndx = lvr->find(targetRowIndex);
+        size_t ndx = lvr->find(static_cast<size_t>(targetRowIndex));
         return to_jlong_or_not_found(ndx);
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return -1;
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveAllTargetRows
-  (JNIEnv *env, jobject, jlong nativeLinkViewPtr)
+JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveAllTargetRows(JNIEnv* env, jobject,
+                                                                                 jlong nativeLinkViewPtr)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
         LinkViewRef* lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
         lvr->remove_all_target_rows();
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetTable
-  (JNIEnv*, jobject, jlong nativeLinkViewPtr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetTable(JNIEnv*, jobject,
+                                                                             jlong nativeLinkViewPtr)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
 
@@ -230,8 +242,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetTable
     return reinterpret_cast<jlong>(pTable);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveTargetRow
-  (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
+JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveTargetRow(JNIEnv* env, jobject,
+                                                                             jlong nativeLinkViewPtr, jlong pos)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     LinkViewRef* lv = LV(nativeLinkViewPtr);
@@ -240,8 +252,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveTargetRow
     }
     try {
         LinkViewRef lvr = *lv;
-        return lvr->remove_target_row( S(pos) );
-    } CATCH_STD()
+        return lvr->remove_target_row(S(pos));
+    }
+    CATCH_STD()
 }
 
 static void finalize_link_view(jlong ptr)
@@ -250,8 +263,7 @@ static void finalize_link_view(jlong ptr)
     LangBindHelper::unbind_linklist_ptr(*LV(ptr));
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetFinalizerPtr
-  (JNIEnv *, jclass)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetFinalizerPtr(JNIEnv*, jclass)
 {
     TR_ENTER()
     return reinterpret_cast<jlong>(&finalize_link_view);
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_NativeObjectReference.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_NativeObjectReference.cpp
index ab5de83fc5..134936046d 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_NativeObjectReference.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_NativeObjectReference.cpp
@@ -18,8 +18,10 @@
 
 typedef void (*FinalizeFunc)(jlong);
 
-JNIEXPORT void JNICALL Java_io_realm_internal_NativeObjectReference_nativeCleanUp
-(JNIEnv *, jclass, jlong finalizer_ptr, jlong native_ptr) {
+JNIEXPORT void JNICALL Java_io_realm_internal_NativeObjectReference_nativeCleanUp(JNIEnv*, jclass,
+                                                                                  jlong finalizer_ptr,
+                                                                                  jlong native_ptr)
+{
     FinalizeFunc finalize_func = reinterpret_cast<FinalizeFunc>(finalizer_ptr);
     finalize_func(native_ptr);
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index ab6f952cdd..531611f4d1 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -85,10 +85,19 @@ class JniConfigWrapper {
         auto error_handler = [=](std::shared_ptr<SyncSession> session, SyncError error) {
             realm::jni_util::Log::d("error_handler lambda invoked");
 
-            JNIEnv* env = realm::jni_util::JniUtils::get_env(true);
+            auto error_message = error.message;
+            auto error_code = error.error_code.value();
+            if (error.is_client_reset_requested()) {
+                // Hack the error message to send information about the location of the backup.
+                // If more uses of the user_info map surfaces. Refactor this to send the full
+                // map instead.
+                error_message = error.user_info[SyncError::c_recovery_file_path_key];
+                error_code = 7; // See ErrorCode.java
+            }
 
-            env->CallStaticVoidMethod(java_syncmanager, java_error_callback_method, error.error_code.value(),
-                                      to_jstring(env, error.message), to_jstring(env, session.get()->path()));
+            JNIEnv* env = realm::jni_util::JniUtils::get_env(true);
+            env->CallStaticVoidMethod(java_syncmanager, java_error_callback_method, error_code,
+                                      to_jstring(env, error_message), to_jstring(env, session.get()->path()));
         };
 
         // path on disk of the Realm file.
@@ -108,6 +117,7 @@ class JniConfigWrapper {
                 session->refresh_access_token(access_token, realm::util::Optional<std::string>(syncConfig.realm_url));
             }
         };
+
         // Get logged in user
         JStringAccessor user_identity(env, sync_user_identity);
         JStringAccessor realm_url(env, sync_realm_url);
@@ -138,7 +148,6 @@ class JniConfigWrapper {
     Realm::Config m_config;
 };
 
-
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeInit(JNIEnv* env, jclass,
                                                                      jstring temporary_directory_path)
 {
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index 60e7bcf85a..eca86a2800 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -25,15 +25,12 @@ using namespace realm;
 
 static void finalize_table(jlong ptr);
 
-inline static bool is_allowed_to_index(JNIEnv* env, DataType column_type) {
-    if (!(column_type == type_String ||
-                column_type == type_Int ||
-                column_type == type_Bool ||
-                column_type == type_Timestamp ||
-                column_type == type_OldDateTime)) {
-        ThrowException(env, IllegalArgument,
-                "This field cannot be indexed - "
-                "Only String/byte/short/int/long/boolean/Date fields are supported.");
+inline static bool is_allowed_to_index(JNIEnv* env, DataType column_type)
+{
+    if (!(column_type == type_String || column_type == type_Int || column_type == type_Bool ||
+          column_type == type_Timestamp || column_type == type_OldDateTime)) {
+        ThrowException(env, IllegalArgument, "This field cannot be indexed - "
+                                             "Only String/byte/short/int/long/boolean/Date fields are supported.");
         return false;
     }
     return true;
@@ -43,51 +40,59 @@ inline static bool is_allowed_to_index(JNIEnv* env, DataType column_type) {
 // A spec is shared on subtables that are not in Mixed columns.
 //
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumn
-  (JNIEnv *env, jobject, jlong nativeTablePtr, jint colType, jstring name, jboolean isNullable)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumn(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                     jint colType, jstring name, jboolean isNullable)
 {
-    if (!TABLE_VALID(env, TBL(nativeTablePtr)))
+    if (!TABLE_VALID(env, TBL(nativeTablePtr))) {
         return 0;
+    }
     if (TBL(nativeTablePtr)->has_shared_type()) {
-        ThrowException(env, UnsupportedOperation, "Not allowed to add field in subtable. Use getSubtableSchema() on root table instead.");
+        ThrowException(env, UnsupportedOperation,
+                       "Not allowed to add field in subtable. Use getSubtableSchema() on root table instead.");
         return 0;
     }
     try {
         JStringAccessor name2(env, name); // throws
-        bool is_column_nullable = isNullable != 0 ? true : false;
+        bool is_column_nullable = to_bool(isNullable);
 
         DataType dataType = DataType(colType);
         if (is_column_nullable && dataType == type_LinkList) {
-             ThrowException(env, IllegalArgument, "List fields cannot be nullable.");
+            ThrowException(env, IllegalArgument, "List fields cannot be nullable.");
         }
-        return TBL(nativeTablePtr)->add_column(dataType, name2, is_column_nullable);
-    } CATCH_STD()
+        return static_cast<jlong>(TBL(nativeTablePtr)->add_column(dataType, name2, is_column_nullable));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumnLink
-  (JNIEnv* env, jobject, jlong nativeTablePtr, jint colType, jstring name, jlong targetTablePtr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumnLink(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                         jint colType, jstring name,
+                                                                         jlong targetTablePtr)
 {
-    if (!TABLE_VALID(env, TBL(nativeTablePtr)))
-            return 0;
-        if (TBL(nativeTablePtr)->has_shared_type()) {
-            ThrowException(env, UnsupportedOperation, "Not allowed to add field in subtable. Use getSubtableSchema() on root table instead.");
-            return 0;
-        }
-        if (!TBL(targetTablePtr)->is_group_level()) {
-            ThrowException(env, UnsupportedOperation, "Links can only be made to toplevel tables.");
-            return 0;
-        }
-        try {
-            JStringAccessor name2(env, name); // throws
-            return TBL(nativeTablePtr)->add_column_link(DataType(colType), name2, *TBL(targetTablePtr));
-        } CATCH_STD()
+    if (!TABLE_VALID(env, TBL(nativeTablePtr))) {
         return 0;
+    }
+    if (TBL(nativeTablePtr)->has_shared_type()) {
+        ThrowException(env, UnsupportedOperation,
+                       "Not allowed to add field in subtable. Use getSubtableSchema() on root table instead.");
+        return 0;
+    }
+    if (!TBL(targetTablePtr)->is_group_level()) {
+        ThrowException(env, UnsupportedOperation, "Links can only be made to toplevel tables.");
+        return 0;
+    }
+    try {
+        JStringAccessor name2(env, name); // throws
+        return static_cast<jlong>(TBL(nativeTablePtr)->add_column_link(DataType(colType), name2, *TBL(targetTablePtr)));
+    }
+    CATCH_STD()
+    return 0;
 }
 
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativePivot
-(JNIEnv *env, jobject, jlong dataTablePtr, jlong stringCol, jlong intCol, jint operation, jlong resultTablePtr)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativePivot(JNIEnv* env, jobject, jlong dataTablePtr,
+                                                                jlong stringCol, jlong intCol, jint operation,
+                                                                jlong resultTablePtr)
 {
     Table* dataTable = TBL(dataTablePtr);
     Table* resultTable = TBL(resultTablePtr);
@@ -115,56 +120,65 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativePivot
 
     try {
         dataTable->aggregate(S(stringCol), S(intCol), pivotOp, *resultTable);
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveColumn
-  (JNIEnv *env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveColumn(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                       jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex))
+    if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex)) {
         return;
+    }
     if (TBL(nativeTablePtr)->has_shared_type()) {
-        ThrowException(env, UnsupportedOperation, "Not allowed to remove field in subtable. Use getSubtableSchema() on root table instead.");
+        ThrowException(env, UnsupportedOperation,
+                       "Not allowed to remove field in subtable. Use getSubtableSchema() on root table instead.");
         return;
     }
     try {
         TBL(nativeTablePtr)->remove_column(S(columnIndex));
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRenameColumn
-  (JNIEnv *env, jobject, jlong nativeTablePtr, jlong columnIndex, jstring name)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRenameColumn(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                       jlong columnIndex, jstring name)
 {
-    if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex))
+    if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex)) {
         return;
+    }
     if (TBL(nativeTablePtr)->has_shared_type()) {
-        ThrowException(env, UnsupportedOperation, "Not allowed to rename field in subtable. Use getSubtableSchema() on root table instead.");
+        ThrowException(env, UnsupportedOperation,
+                       "Not allowed to rename field in subtable. Use getSubtableSchema() on root table instead.");
         return;
     }
     try {
         JStringAccessor name2(env, name); // throws
         TBL(nativeTablePtr)->rename_column(S(columnIndex), name2);
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsColumnNullable
-  (JNIEnv *env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsColumnNullable(JNIEnv* env, jobject,
+                                                                               jlong nativeTablePtr,
+                                                                               jlong columnIndex)
 {
-    Table *table = TBL(nativeTablePtr);
+    Table* table = TBL(nativeTablePtr);
     if (!TBL_AND_COL_INDEX_VALID(env, table, columnIndex)) {
-        return false;
+        return JNI_FALSE;
     }
     if (table->has_shared_type()) {
         ThrowException(env, UnsupportedOperation, "Not allowed to convert field in subtable.");
-        return false;
+        return JNI_FALSE;
     }
     size_t column_index = S(columnIndex);
-    return table->is_nullable(column_index);
+    return to_jbool(table->is_nullable(column_index));
 }
 
 
 // General comments about the implementation of
-// Java_io_realm_internal_Table_nativeConvertColumnToNullable and Java_io_realm_internal_Table_nativeConvertColumnToNotNullable
+// Java_io_realm_internal_Table_nativeConvertColumnToNullable and
+// Java_io_realm_internal_Table_nativeConvertColumnToNotNullable
 //
 // 1. converting a (not-)nullable column is idempotent (and is implemented as a no-op)
 // 2. not all column types can be converted (cannot be (not-)nullable)
@@ -177,10 +191,11 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsColumnNullable
 // 5. search indexing must be preserved
 // 6. removing the original column and renaming the temporary column will make it look like original is being modified
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullable
-  (JNIEnv *env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullable(JNIEnv* env, jobject,
+                                                                                  jlong nativeTablePtr,
+                                                                                  jlong columnIndex)
 {
-    Table *table = TBL(nativeTablePtr);
+    Table* table = TBL(nativeTablePtr);
     if (!TBL_AND_COL_INDEX_VALID(env, table, columnIndex)) {
         return;
     }
@@ -196,9 +211,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullabl
 
         std::string column_name = table->get_column_name(column_index);
         DataType column_type = table->get_column_type(column_index);
-        if (column_type == type_Link ||
-            column_type == type_LinkList ||
-            column_type == type_Mixed ||
+        if (column_type == type_Link || column_type == type_LinkList || column_type == type_Mixed ||
             column_type == type_Table) {
             ThrowException(env, IllegalArgument, "Wrong type - cannot be converted to nullable.");
         }
@@ -221,7 +234,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullabl
 
         for (size_t i = 0; i < table->size(); ++i) {
             switch (column_type) {
-               case type_String: {
+                case type_String: {
                     // Payload copy is needed
                     StringData sd(table->get_string(column_index + 1, i));
                     table->set_string(column_index, i, sd);
@@ -265,13 +278,15 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullabl
         }
         table->remove_column(column_index + 1);
         table->rename_column(table->get_column_index(tmp_column_name), column_name);
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNullable
-  (JNIEnv *env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNullable(JNIEnv* env, jobject,
+                                                                                     jlong nativeTablePtr,
+                                                                                     jlong columnIndex)
 {
-    Table *table = TBL(nativeTablePtr);
+    Table* table = TBL(nativeTablePtr);
     if (!TBL_AND_COL_INDEX_VALID(env, table, columnIndex)) {
         return;
     }
@@ -287,9 +302,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNull
 
         std::string column_name = table->get_column_name(column_index);
         DataType column_type = table->get_column_type(column_index);
-        if (column_type == type_Link ||
-            column_type == type_LinkList ||
-            column_type == type_Mixed ||
+        if (column_type == type_Link || column_type == type_LinkList || column_type == type_Mixed ||
             column_type == type_Table) {
             ThrowException(env, IllegalArgument, "Wrong type - cannot be converted to nullable.");
         }
@@ -391,177 +404,199 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNull
         }
         table->remove_column(column_index + 1);
         table->rename_column(table->get_column_index(tmp_column_name), column_name);
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSize(
-    JNIEnv* env, jobject, jlong nativeTablePtr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSize(JNIEnv* env, jobject, jlong nativeTablePtr)
 {
-    if (!TABLE_VALID(env, TBL(nativeTablePtr)))
+    if (!TABLE_VALID(env, TBL(nativeTablePtr))) {
         return 0;
-    return TBL(nativeTablePtr)->size();     // noexcept
+    }
+    return static_cast<jlong>(TBL(nativeTablePtr)->size()); // noexcept
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClear(
-    JNIEnv* env, jobject, jlong nativeTablePtr)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClear(JNIEnv* env, jobject, jlong nativeTablePtr)
 {
-    if (!TABLE_VALID(env, TBL(nativeTablePtr)))
+    if (!TABLE_VALID(env, TBL(nativeTablePtr))) {
         return;
+    }
     try {
         TBL(nativeTablePtr)->clear();
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
 
 // -------------- Column information
 
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetColumnCount(
-    JNIEnv* env, jobject, jlong nativeTablePtr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetColumnCount(JNIEnv* env, jobject, jlong nativeTablePtr)
 {
-    if (!TABLE_VALID(env, TBL(nativeTablePtr)))
+    if (!TABLE_VALID(env, TBL(nativeTablePtr))) {
         return 0;
-    return TBL(nativeTablePtr)->get_column_count(); // noexcept
+    }
+    return static_cast<jlong>(TBL(nativeTablePtr)->get_column_count()); // noexcept
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetColumnName(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetColumnName(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                           jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex))
-        return NULL;
+    if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex)) {
+        return nullptr;
+    }
     try {
-        return to_jstring(env, TBL(nativeTablePtr)->get_column_name( S(columnIndex)));
-    } CATCH_STD();
-    return NULL;
+        return to_jstring(env, TBL(nativeTablePtr)->get_column_name(S(columnIndex)));
+    }
+    CATCH_STD();
+    REALM_UNREACHABLE();
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetColumnIndex(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jstring columnName)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetColumnIndex(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                          jstring columnName)
 {
-    if (!TABLE_VALID(env, TBL(nativeTablePtr)))
+    if (!TABLE_VALID(env, TBL(nativeTablePtr))) {
         return 0;
+    }
     try {
-        JStringAccessor columnName2(env, columnName); // throws
-        return to_jlong_or_not_found( TBL(nativeTablePtr)->get_column_index(columnName2) ); // noexcept
-    } CATCH_STD()
+        JStringAccessor columnName2(env, columnName);                                     // throws
+        return to_jlong_or_not_found(TBL(nativeTablePtr)->get_column_index(columnName2)); // noexcept
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jint JNICALL Java_io_realm_internal_Table_nativeGetColumnType(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jint JNICALL Java_io_realm_internal_Table_nativeGetColumnType(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                        jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex))
+    if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex)) {
         return 0;
+    }
 
-    return static_cast<jint>( TBL(nativeTablePtr)->get_column_type( S(columnIndex)) ); // noexcept
+    return static_cast<jint>(TBL(nativeTablePtr)->get_column_type(S(columnIndex))); // noexcept
 }
 
 
 // ---------------- Row handling
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddEmptyRow(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong rows)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddEmptyRow(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                       jlong rows)
 {
     Table* pTable = TBL(nativeTablePtr);
-    if (!TABLE_VALID(env, pTable))
+    if (!TABLE_VALID(env, pTable)) {
         return 0;
-    if (pTable->get_column_count() < 1){
+    }
+    if (pTable->get_column_count() < 1) {
         ThrowException(env, IndexOutOfBounds, concat_stringdata("Table has no columns: ", pTable->get_name()));
         return 0;
     }
     try {
-        return static_cast<jlong>( pTable->add_empty_row( S(rows)) );
-    } CATCH_STD()
+        return static_cast<jlong>(pTable->add_empty_row(S(rows)));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemove(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong rowIndex)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemove(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                 jlong rowIndex)
 {
-    if (!TBL_AND_ROW_INDEX_VALID(env, TBL(nativeTablePtr), rowIndex))
+    if (!TBL_AND_ROW_INDEX_VALID(env, TBL(nativeTablePtr), rowIndex)) {
         return;
+    }
     try {
         TBL(nativeTablePtr)->remove(S(rowIndex));
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveLast(
-    JNIEnv* env, jobject, jlong nativeTablePtr)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveLast(JNIEnv* env, jobject, jlong nativeTablePtr)
 {
-    if (!TABLE_VALID(env, TBL(nativeTablePtr)))
+    if (!TABLE_VALID(env, TBL(nativeTablePtr))) {
         return;
+    }
     try {
         TBL(nativeTablePtr)->remove_last();
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMoveLastOver
-  (JNIEnv *env, jobject, jlong nativeTablePtr, jlong rowIndex)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMoveLastOver(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                       jlong rowIndex)
 {
-    if (!TBL_AND_ROW_INDEX_VALID_OFFSET(env, TBL(nativeTablePtr), rowIndex, false))
+    if (!TBL_AND_ROW_INDEX_VALID_OFFSET(env, TBL(nativeTablePtr), rowIndex, false)) {
         return;
+    }
     try {
         TBL(nativeTablePtr)->move_last_over(S(rowIndex));
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
 // ----------------- Get cell
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLong(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLong(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                   jlong columnIndex, jlong rowIndex)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Int))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Int)) {
         return 0;
-    return TBL(nativeTablePtr)->get_int( S(columnIndex), S(rowIndex));  // noexcept
+    }
+    return TBL(nativeTablePtr)->get_int(S(columnIndex), S(rowIndex)); // noexcept
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeGetBoolean(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeGetBoolean(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                         jlong columnIndex, jlong rowIndex)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Bool))
-        return false;
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Bool)) {
+        return JNI_FALSE;
+    }
 
-    return TBL(nativeTablePtr)->get_bool( S(columnIndex), S(rowIndex));  // noexcept
+    return to_jbool(TBL(nativeTablePtr)->get_bool(S(columnIndex), S(rowIndex))); // noexcept
 }
 
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_Table_nativeGetFloat(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+JNIEXPORT jfloat JNICALL Java_io_realm_internal_Table_nativeGetFloat(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                     jlong columnIndex, jlong rowIndex)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Float))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Float)) {
         return 0;
+    }
 
-    return TBL(nativeTablePtr)->get_float( S(columnIndex), S(rowIndex));  // noexcept
+    return TBL(nativeTablePtr)->get_float(S(columnIndex), S(rowIndex)); // noexcept
 }
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeGetDouble(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeGetDouble(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                       jlong columnIndex, jlong rowIndex)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Double))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Double)) {
         return 0;
+    }
 
-    return TBL(nativeTablePtr)->get_double( S(columnIndex), S(rowIndex));  // noexcept
+    return TBL(nativeTablePtr)->get_double(S(columnIndex), S(rowIndex)); // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetTimestamp(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetTimestamp(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                        jlong columnIndex, jlong rowIndex)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Timestamp))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Timestamp)) {
         return 0;
+    }
     try {
-        return to_milliseconds(TBL(nativeTablePtr)->get_timestamp( S(columnIndex), S(rowIndex)));
-    } CATCH_STD()
+        return to_milliseconds(TBL(nativeTablePtr)->get_timestamp(S(columnIndex), S(rowIndex)));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetString(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetString(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                       jlong columnIndex, jlong rowIndex)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_String))
-        return NULL;
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_String)) {
+        return nullptr;
+    }
     try {
-        return to_jstring(env, TBL(nativeTablePtr)->get_string( S(columnIndex), S(rowIndex)));
-    } CATCH_STD()
-    return NULL;
+        return to_jstring(env, TBL(nativeTablePtr)->get_string(S(columnIndex), S(rowIndex)));
+    }
+    CATCH_STD()
+    return nullptr;
 }
 
 
@@ -577,159 +612,191 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_Table_nativeGetByteBuffer(
 }
 */
 
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Table_nativeGetByteArray(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Table_nativeGetByteArray(JNIEnv* env, jobject,
+                                                                             jlong nativeTablePtr, jlong columnIndex,
+                                                                             jlong rowIndex)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Binary))
-        return NULL;
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Binary)) {
+        return nullptr;
+    }
 
-    return tbl_GetByteArray<Table>(env, nativeTablePtr, columnIndex, rowIndex);  // noexcept
+    return tbl_GetByteArray<Table>(env, nativeTablePtr, columnIndex, rowIndex); // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLink
-  (JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLink(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                   jlong columnIndex, jlong rowIndex)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Link))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Link)) {
         return 0;
-    return TBL(nativeTablePtr)->get_link( S(columnIndex), S(rowIndex));  // noexcept
+    }
+    return static_cast<jlong>(TBL(nativeTablePtr)->get_link(S(columnIndex), S(rowIndex))); // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkView
-        (JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkView(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                       jlong columnIndex, jlong rowIndex)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_LinkList))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_LinkList)) {
         return 0;
+    }
     try {
-        LinkViewRef* link_view_ptr = new LinkViewRef(TBL(nativeTablePtr)->get_linklist( S(columnIndex), S(rowIndex)));
+        LinkViewRef* link_view_ptr = new LinkViewRef(TBL(nativeTablePtr)->get_linklist(S(columnIndex), S(rowIndex)));
         return reinterpret_cast<jlong>(link_view_ptr);
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkTarget
-  (JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkTarget(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                         jlong columnIndex)
 {
     try {
-        Table* pTable = &(*TBL(nativeTablePtr)->get_link_target( S(columnIndex) ));
+        Table* pTable = &(*TBL(nativeTablePtr)->get_link_target(S(columnIndex)));
         LangBindHelper::bind_table_ptr(pTable);
-        return (jlong)pTable;
-    } CATCH_STD()
+        return reinterpret_cast<jlong>(pTable);
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsNull
-        (JNIEnv*, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsNull(JNIEnv*, jobject, jlong nativeTablePtr,
+                                                                     jlong columnIndex, jlong rowIndex)
 {
-    return TBL(nativeTablePtr)->is_null( S(columnIndex), S(rowIndex)) ? JNI_TRUE : JNI_FALSE;  // noexcept
+    return to_jbool(TBL(nativeTablePtr)->is_null(S(columnIndex), S(rowIndex))); // noexcept
 }
 
 // ----------------- Set cell
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLink
-  (JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong targetRowIndex, jboolean isDefault)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLink(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                  jlong columnIndex, jlong rowIndex,
+                                                                  jlong targetRowIndex, jboolean isDefault)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Link))
+    if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Link)) {
         return;
+    }
     try {
-        TBL(nativeTablePtr)->set_link( S(columnIndex), S(rowIndex), S(targetRowIndex), B(isDefault));
-    } CATCH_STD()
+        TBL(nativeTablePtr)->set_link(S(columnIndex), S(rowIndex), S(targetRowIndex), B(isDefault));
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLong(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong value, jboolean isDefault)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLong(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                  jlong columnIndex, jlong rowIndex, jlong value,
+                                                                  jboolean isDefault)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Int))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Int)) {
         return;
+    }
     try {
-        TBL(nativeTablePtr)->set_int( S(columnIndex), S(rowIndex), value, B(isDefault));
-    } CATCH_STD()
+        TBL(nativeTablePtr)->set_int(S(columnIndex), S(rowIndex), value, B(isDefault));
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_Table_nativeSetLongUnique(JNIEnv *env, jclass, jlong nativeTablePtr, jlong columnIndex,
-                                                 jlong rowIndex, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLongUnique(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                        jlong columnIndex, jlong rowIndex,
+                                                                        jlong value)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Int))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Int)) {
         return;
+    }
     try {
-        TBL(nativeTablePtr)->set_int_unique( S(columnIndex), S(rowIndex), value);
-    } CATCH_STD()
+        TBL(nativeTablePtr)->set_int_unique(S(columnIndex), S(rowIndex), value);
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetBoolean(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jboolean value, jboolean isDefault)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetBoolean(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                     jlong columnIndex, jlong rowIndex,
+                                                                     jboolean value, jboolean isDefault)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Bool))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Bool)) {
         return;
+    }
     try {
-        TBL(nativeTablePtr)->set_bool( S(columnIndex), S(rowIndex), B(value), B(isDefault));
-    } CATCH_STD()
+        TBL(nativeTablePtr)->set_bool(S(columnIndex), S(rowIndex), B(value), B(isDefault));
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetFloat(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jfloat value, jboolean isDefault)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetFloat(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                   jlong columnIndex, jlong rowIndex, jfloat value,
+                                                                   jboolean isDefault)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Float))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Float)) {
         return;
+    }
     try {
-        TBL(nativeTablePtr)->set_float( S(columnIndex), S(rowIndex), value, B(isDefault));
-    } CATCH_STD()
+        TBL(nativeTablePtr)->set_float(S(columnIndex), S(rowIndex), value, B(isDefault));
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDouble(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jdouble value, jboolean isDefault)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDouble(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                    jlong columnIndex, jlong rowIndex, jdouble value,
+                                                                    jboolean isDefault)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Double))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Double)) {
         return;
+    }
     try {
-        TBL(nativeTablePtr)->set_double( S(columnIndex), S(rowIndex), value, B(isDefault));
-    } CATCH_STD()
+        TBL(nativeTablePtr)->set_double(S(columnIndex), S(rowIndex), value, B(isDefault));
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jstring value, jboolean isDefault)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                    jlong columnIndex, jlong rowIndex, jstring value,
+                                                                    jboolean isDefault)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_String))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_String)) {
         return;
+    }
     try {
-        if (value == NULL) {
+        if (value == nullptr) {
             if (!TBL_AND_COL_NULLABLE(env, TBL(nativeTablePtr), columnIndex)) {
                 return;
             }
         }
         JStringAccessor value2(env, value); // throws
-        TBL(nativeTablePtr)->set_string( S(columnIndex), S(rowIndex), value2, B(isDefault));
-    } CATCH_STD()
+        TBL(nativeTablePtr)->set_string(S(columnIndex), S(rowIndex), value2, B(isDefault));
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_Table_nativeSetStringUnique(JNIEnv *env, jclass, jlong nativeTablePtr, jlong columnIndex,
-                                                   jlong rowIndex, jstring value)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetStringUnique(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                          jlong columnIndex, jlong rowIndex,
+                                                                          jstring value)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_String))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_String)) {
         return;
+    }
     try {
-        if (value == NULL) {
+        if (value == nullptr) {
             if (!TBL_AND_COL_NULLABLE(env, TBL(nativeTablePtr), columnIndex)) {
                 return;
             }
             TBL(nativeTablePtr)->set_string_unique(S(columnIndex), S(rowIndex), null{});
-        } else {
+        }
+        else {
             JStringAccessor value2(env, value); // throws
             TBL(nativeTablePtr)->set_string_unique(S(columnIndex), S(rowIndex), value2);
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetTimestamp(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong timestampValue, jboolean isDefault)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetTimestamp(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                       jlong columnIndex, jlong rowIndex,
+                                                                       jlong timestampValue, jboolean isDefault)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Timestamp))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Timestamp)) {
         return;
+    }
     try {
-        TBL(nativeTablePtr)->set_timestamp( S(columnIndex), S(rowIndex), from_milliseconds(timestampValue),
-                                            B(isDefault));
-    } CATCH_STD()
+        TBL(nativeTablePtr)
+            ->set_timestamp(S(columnIndex), S(rowIndex), from_milliseconds(timestampValue), B(isDefault));
+    }
+    CATCH_STD()
 }
 
 /*
@@ -744,443 +811,516 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteBuffer(
 }
 */
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jbyteArray dataArray, jboolean isDefault)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                       jlong columnIndex, jlong rowIndex,
+                                                                       jbyteArray dataArray, jboolean isDefault)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Binary))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Binary)) {
         return;
+    }
     try {
-        if (dataArray == NULL && !TBL_AND_COL_NULLABLE(env, TBL(nativeTablePtr), columnIndex)) {
-                return;
+        if (dataArray == nullptr && !TBL_AND_COL_NULLABLE(env, TBL(nativeTablePtr), columnIndex)) {
+            return;
         }
 
         JniByteArray byteAccessor(env, dataArray);
         TBL(nativeTablePtr)->set_binary(S(columnIndex), S(rowIndex), byteAccessor, B(isDefault));
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jboolean isDefault)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                  jlong columnIndex, jlong rowIndex,
+                                                                  jboolean isDefault)
 {
     Table* pTable = TBL(nativeTablePtr);
-    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
+    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex)) {
         return;
-    if (!TBL_AND_ROW_INDEX_VALID(env, pTable, rowIndex))
+    }
+    if (!TBL_AND_ROW_INDEX_VALID(env, pTable, rowIndex)) {
         return;
-    if (!TBL_AND_COL_NULLABLE(env, pTable, columnIndex))
+    }
+    if (!TBL_AND_COL_NULLABLE(env, pTable, columnIndex)) {
         return;
+    }
+
     try {
         pTable->set_null(S(columnIndex), S(rowIndex), B(isDefault));
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_Table_nativeSetNullUnique(JNIEnv *env, jclass, jlong nativeTablePtr, jlong columnIndex,
-                                                 jlong rowIndex)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNullUnique(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                        jlong columnIndex, jlong rowIndex)
 {
     Table* pTable = TBL(nativeTablePtr);
-    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
+    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex)) {
         return;
-    if (!TBL_AND_ROW_INDEX_VALID(env, pTable, rowIndex))
+    }
+    if (!TBL_AND_ROW_INDEX_VALID(env, pTable, rowIndex)) {
         return;
-    if (!TBL_AND_COL_NULLABLE(env, pTable, columnIndex))
+    }
+    if (!TBL_AND_COL_NULLABLE(env, pTable, columnIndex)) {
         return;
+    }
+
     try {
         pTable->set_null_unique(S(columnIndex), S(rowIndex));
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetRowPtr
-  (JNIEnv* env, jobject, jlong nativeTablePtr, jlong index)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetRowPtr(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                     jlong index)
 {
     try {
-        Row* row = new Row( (*TBL(nativeTablePtr))[ S(index) ] );
+        Row* row = new Row((*TBL(nativeTablePtr))[S(index)]);
         return reinterpret_cast<jlong>(row);
-    } CATCH_STD()
-    return 0;
+    }
+    CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
 }
 
 //--------------------- Indexing methods:
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeAddSearchIndex(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeAddSearchIndex(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                         jlong columnIndex)
 {
     Table* pTable = TBL(nativeTablePtr);
-    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
+    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex)) {
         return;
+    }
 
-    DataType column_type = pTable->get_column_type (S(columnIndex));
+    DataType column_type = pTable->get_column_type(S(columnIndex));
     if (!is_allowed_to_index(env, column_type)) {
         return;
     }
 
     try {
-        pTable->add_search_index( S(columnIndex));
-    } CATCH_STD()
+        pTable->add_search_index(S(columnIndex));
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveSearchIndex(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveSearchIndex(JNIEnv* env, jobject,
+                                                                            jlong nativeTablePtr, jlong columnIndex)
 {
     Table* pTable = TBL(nativeTablePtr);
-    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
+    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex)) {
         return;
-    DataType column_type = pTable->get_column_type (S(columnIndex));
+    }
+    DataType column_type = pTable->get_column_type(S(columnIndex));
     if (!is_allowed_to_index(env, column_type)) {
         return;
     }
     try {
-        pTable->remove_search_index( S(columnIndex));
-    } CATCH_STD()
+        pTable->remove_search_index(S(columnIndex));
+    }
+    CATCH_STD()
 }
 
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSearchIndex(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSearchIndex(JNIEnv* env, jobject,
+                                                                             jlong nativeTablePtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex))
-        return false;
+    if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex)) {
+        return JNI_FALSE;
+    }
     try {
-        return TBL(nativeTablePtr)->has_search_index( S(columnIndex));
-    } CATCH_STD()
-    return false;
+        return to_jbool(TBL(nativeTablePtr)->has_search_index(S(columnIndex)));
+    }
+    CATCH_STD()
+    return JNI_FALSE;
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsNullLink
-  (JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsNullLink(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                         jlong columnIndex, jlong rowIndex)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Link))
-        return 0;
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Link)) {
+        return JNI_FALSE;
+    }
 
-    return TBL(nativeTablePtr)->is_null_link(S(columnIndex), S(rowIndex));
+    return to_jbool(TBL(nativeTablePtr)->is_null_link(S(columnIndex), S(rowIndex)));
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeNullifyLink
-  (JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeNullifyLink(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                      jlong columnIndex, jlong rowIndex)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Link))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Link)) {
         return;
+    }
     try {
         TBL(nativeTablePtr)->nullify_link(S(columnIndex), S(rowIndex));
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
 //---------------------- Aggregate methods for integers
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSumInt(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSumInt(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                  jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int)) {
         return 0;
+    }
     try {
-        return TBL(nativeTablePtr)->sum_int( S(columnIndex));
-    } CATCH_STD()
+        return TBL(nativeTablePtr)->sum_int(S(columnIndex));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumInt(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumInt(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                      jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int)) {
         return 0;
+    }
     try {
-        return TBL(nativeTablePtr)->maximum_int( S(columnIndex));
-    } CATCH_STD()
+        return TBL(nativeTablePtr)->maximum_int(S(columnIndex));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumInt(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumInt(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                      jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int)) {
         return 0;
+    }
     try {
-        return TBL(nativeTablePtr)->minimum_int( S(columnIndex));
-    } CATCH_STD()
+        return TBL(nativeTablePtr)->minimum_int(S(columnIndex));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageInt(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageInt(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                        jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int)) {
         return 0;
+    }
     try {
-        return TBL(nativeTablePtr)->average_int( S(columnIndex));
-    } CATCH_STD()
+        return TBL(nativeTablePtr)->average_int(S(columnIndex));
+    }
+    CATCH_STD()
     return 0;
 }
 
 //--------------------- Aggregate methods for float
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeSumFloat(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeSumFloat(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                      jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float)) {
         return 0;
+    }
     try {
-        return TBL(nativeTablePtr)->sum_float( S(columnIndex));
-    } CATCH_STD()
+        return TBL(nativeTablePtr)->sum_float(S(columnIndex));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_Table_nativeMaximumFloat(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jfloat JNICALL Java_io_realm_internal_Table_nativeMaximumFloat(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                         jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float)) {
         return 0;
+    }
     try {
-        return TBL(nativeTablePtr)->maximum_float( S(columnIndex));
-    } CATCH_STD()
+        return TBL(nativeTablePtr)->maximum_float(S(columnIndex));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_Table_nativeMinimumFloat(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jfloat JNICALL Java_io_realm_internal_Table_nativeMinimumFloat(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                         jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float)) {
         return 0;
+    }
     try {
-        return TBL(nativeTablePtr)->minimum_float( S(columnIndex));
-    } CATCH_STD()
+        return TBL(nativeTablePtr)->minimum_float(S(columnIndex));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageFloat(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageFloat(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                          jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float)) {
         return 0;
+    }
     try {
-        return TBL(nativeTablePtr)->average_float( S(columnIndex));
-    } CATCH_STD()
+        return TBL(nativeTablePtr)->average_float(S(columnIndex));
+    }
+    CATCH_STD()
     return 0;
 }
 
 
 //--------------------- Aggregate methods for double
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeSumDouble(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeSumDouble(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                       jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double)) {
         return 0;
+    }
     try {
-        return TBL(nativeTablePtr)->sum_double( S(columnIndex));
-    } CATCH_STD()
+        return TBL(nativeTablePtr)->sum_double(S(columnIndex));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeMaximumDouble(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeMaximumDouble(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                           jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double)) {
         return 0;
+    }
     try {
-        return TBL(nativeTablePtr)->maximum_double( S(columnIndex));
-    } CATCH_STD()
+        return TBL(nativeTablePtr)->maximum_double(S(columnIndex));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeMinimumDouble(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeMinimumDouble(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                           jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double)) {
         return 0;
+    }
     try {
-        return TBL(nativeTablePtr)->minimum_double( S(columnIndex));
-    } CATCH_STD()
+        return TBL(nativeTablePtr)->minimum_double(S(columnIndex));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageDouble(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageDouble(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                           jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double)) {
         return 0;
+    }
     try {
-        return TBL(nativeTablePtr)->average_double( S(columnIndex));
-    } CATCH_STD()
+        return TBL(nativeTablePtr)->average_double(S(columnIndex));
+    }
+    CATCH_STD()
     return 0;
 }
 
 
 //--------------------- Aggregate methods for date
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumTimestamp(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumTimestamp(JNIEnv* env, jobject,
+                                                                            jlong nativeTablePtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp)) {
         return 0;
+    }
     try {
-        return to_milliseconds(TBL(nativeTablePtr)->maximum_timestamp( S(columnIndex)));
-    } CATCH_STD()
+        return to_milliseconds(TBL(nativeTablePtr)->maximum_timestamp(S(columnIndex)));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumTimestamp(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumTimestamp(JNIEnv* env, jobject,
+                                                                            jlong nativeTablePtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp)) {
         return 0;
+    }
     try {
-        return to_milliseconds(TBL(nativeTablePtr)->minimum_timestamp( S(columnIndex)));
-    } CATCH_STD()
+        return to_milliseconds(TBL(nativeTablePtr)->minimum_timestamp(S(columnIndex)));
+    }
+    CATCH_STD()
     return 0;
 }
 
 //---------------------- Count
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountLong(
-    JNIEnv *env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong value)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountLong(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                     jlong columnIndex, jlong value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int)) {
         return 0;
+    }
     try {
-        return TBL(nativeTablePtr)->count_int( S(columnIndex), value);
-    } CATCH_STD()
+        return static_cast<jlong>(TBL(nativeTablePtr)->count_int(S(columnIndex), value));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountFloat(
-    JNIEnv *env, jobject, jlong nativeTablePtr, jlong columnIndex, jfloat value)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountFloat(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                      jlong columnIndex, jfloat value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float)) {
         return 0;
+    }
     try {
-        return TBL(nativeTablePtr)->count_float( S(columnIndex), value);
-    } CATCH_STD()
+        return static_cast<jlong>(TBL(nativeTablePtr)->count_float(S(columnIndex), value));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountDouble(
-    JNIEnv *env, jobject, jlong nativeTablePtr, jlong columnIndex, jdouble value)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountDouble(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                       jlong columnIndex, jdouble value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double)) {
         return 0;
+    }
     try {
-        return TBL(nativeTablePtr)->count_double( S(columnIndex), value);
-    } CATCH_STD()
+        return static_cast<jlong>(TBL(nativeTablePtr)->count_double(S(columnIndex), value));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountString(
-    JNIEnv *env, jobject, jlong nativeTablePtr, jlong columnIndex, jstring value)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountString(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                       jlong columnIndex, jstring value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_String))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_String)) {
         return 0;
-
+    }
     try {
         JStringAccessor value2(env, value); // throws
-        return TBL(nativeTablePtr)->count_string( S(columnIndex), value2);
-    } CATCH_STD()
+        return static_cast<jlong>(TBL(nativeTablePtr)->count_string(S(columnIndex), value2));
+    }
+    CATCH_STD()
     return 0;
 }
 
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeWhere(
-    JNIEnv *env, jobject, jlong nativeTablePtr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeWhere(JNIEnv* env, jobject, jlong nativeTablePtr)
 {
-    if (!TABLE_VALID(env, TBL(nativeTablePtr)))
+    if (!TABLE_VALID(env, TBL(nativeTablePtr))) {
         return 0;
+    }
     try {
-        Query *queryPtr = new Query(TBL(nativeTablePtr)->where());
+        Query* queryPtr = new Query(TBL(nativeTablePtr)->where());
         return reinterpret_cast<jlong>(queryPtr);
-    } CATCH_STD()
-    return 0;
+    }
+    CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
 }
 
 //----------------------- FindFirst
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstInt(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong value)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstInt(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                        jlong columnIndex, jlong value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int)) {
         return 0;
+    }
     try {
-        return to_jlong_or_not_found( TBL(nativeTablePtr)->find_first_int( S(columnIndex), value) );
-    } CATCH_STD()
+        return to_jlong_or_not_found(TBL(nativeTablePtr)->find_first_int(S(columnIndex), value));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstBool(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jboolean value)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstBool(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                         jlong columnIndex, jboolean value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Bool))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Bool)) {
         return 0;
+    }
     try {
-        return to_jlong_or_not_found( TBL(nativeTablePtr)->find_first_bool( S(columnIndex), value != 0 ? true : false) );
-    } CATCH_STD()
+        return to_jlong_or_not_found(TBL(nativeTablePtr)->find_first_bool(S(columnIndex), to_bool(value)));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstFloat(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jfloat value)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstFloat(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                          jlong columnIndex, jfloat value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float)) {
         return 0;
+    }
     try {
-        return to_jlong_or_not_found( TBL(nativeTablePtr)->find_first_float( S(columnIndex), value) );
-    } CATCH_STD()
+        return to_jlong_or_not_found(TBL(nativeTablePtr)->find_first_float(S(columnIndex), value));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstDouble(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jdouble value)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstDouble(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                           jlong columnIndex, jdouble value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double)) {
         return 0;
+    }
     try {
-        return to_jlong_or_not_found( TBL(nativeTablePtr)->find_first_double( S(columnIndex), value) );
-    } CATCH_STD()
+        return to_jlong_or_not_found(TBL(nativeTablePtr)->find_first_double(S(columnIndex), value));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstTimestamp(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong dateTimeValue)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstTimestamp(JNIEnv* env, jobject,
+                                                                              jlong nativeTablePtr, jlong columnIndex,
+                                                                              jlong dateTimeValue)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp)) {
         return 0;
+    }
     try {
-        size_t res = TBL(nativeTablePtr)->find_first_timestamp( S(columnIndex), from_milliseconds(dateTimeValue));
+        size_t res = TBL(nativeTablePtr)->find_first_timestamp(S(columnIndex), from_milliseconds(dateTimeValue));
         return to_jlong_or_not_found(res);
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstString(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jstring value)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstString(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                           jlong columnIndex, jstring value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_String))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_String)) {
         return 0;
+    }
 
     try {
         JStringAccessor value2(env, value); // throws
-        return to_jlong_or_not_found( TBL(nativeTablePtr)->find_first_string( S(columnIndex), value2) );
-    } CATCH_STD()
+        return to_jlong_or_not_found(TBL(nativeTablePtr)->find_first_string(S(columnIndex), value2));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstNull(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstNull(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                         jlong columnIndex)
 {
     Table* pTable = TBL(nativeTablePtr);
-    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
-        return jlong(-1);
-    if (!TBL_AND_COL_NULLABLE(env, pTable, columnIndex))
-        return jlong(-1);
+    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex)) {
+        return static_cast<jlong>(realm::not_found);
+    }
+    if (!TBL_AND_COL_NULLABLE(env, pTable, columnIndex)) {
+        return static_cast<jlong>(realm::not_found);
+    }
     try {
-        return to_jlong_or_not_found( pTable->find_first_null( S(columnIndex) ) );
-    } CATCH_STD()
-    return jlong(-1);
+        return to_jlong_or_not_found(pTable->find_first_null(S(columnIndex)));
+    }
+    CATCH_STD()
+    return static_cast<jlong>(realm::not_found);
 }
 
 // FindAll
 
 
-
-
 // FIXME: reenable when find_first_timestamp() is implemented
 /*
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllTimestamp(
@@ -1189,7 +1329,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllTimestamp(
     if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp))
         return 0;
     try {
-        TableView* pTableView = new TableView(TBL(nativeTablePtr)->find_all_timestamp(S(columnIndex), from_milliseconds(dateTimeValue)));
+        TableView* pTableView = new TableView(TBL(nativeTablePtr)->find_all_timestamp(S(columnIndex),
+from_milliseconds(dateTimeValue)));
         return reinterpret_cast<jlong>(pTableView);
     } CATCH_STD()
     return 0;
@@ -1197,40 +1338,45 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllTimestamp(
 */
 
 
-
 // experimental
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeLowerBoundInt(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong value)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeLowerBoundInt(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                         jlong columnIndex, jlong value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int)) {
         return 0;
+    }
 
     Table* pTable = TBL(nativeTablePtr);
     try {
-        return pTable->lower_bound_int(S(columnIndex), S(value));
-    } CATCH_STD()
+        return static_cast<jlong>(pTable->lower_bound_int(S(columnIndex), S(value)));
+    }
+    CATCH_STD()
     return 0;
 }
 
 
 // experimental
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeUpperBoundInt(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong value)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeUpperBoundInt(JNIEnv* env, jobject, jlong nativeTablePtr,
+                                                                         jlong columnIndex, jlong value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int)) {
         return 0;
+    }
 
     Table* pTable = TBL(nativeTablePtr);
     try {
-        return pTable->upper_bound_int(S(columnIndex), S(value));
-    } CATCH_STD()
+        return static_cast<jlong>(pTable->upper_bound_int(S(columnIndex), S(value)));
+    }
+    CATCH_STD()
     return 0;
 }
 
 //
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(
-   JNIEnv *env, jobject, jlong nativeTablePtr, jlongArray columnIndices, jbooleanArray ascending)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(JNIEnv* env, jobject,
+                                                                              jlong nativeTablePtr,
+                                                                              jlongArray columnIndices,
+                                                                              jbooleanArray ascending)
 {
     Table* pTable = TBL(nativeTablePtr);
 
@@ -1256,10 +1402,10 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(
     std::vector<bool> ascendings(S(arr_len));
 
     for (int i = 0; i < arr_len; ++i) {
-        if (!TBL_AND_COL_INDEX_VALID(env, pTable, S(long_arr[i]) )) {
+        if (!TBL_AND_COL_INDEX_VALID(env, pTable, S(long_arr[i]))) {
             return 0;
         }
-        int colType = pTable->get_column_type( S(long_arr[i]) );
+        int colType = pTable->get_column_type(S(long_arr[i]));
         switch (colType) {
             case type_Int:
             case type_Bool:
@@ -1267,11 +1413,12 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(
             case type_Double:
             case type_Float:
             case type_Timestamp:
-                indices[i] = std::vector<size_t> { S(long_arr[i]) };
+                indices[i] = std::vector<size_t>{S(long_arr[i])};
                 ascendings[i] = S(bool_arr[i]);
                 break;
             default:
-                ThrowException(env, IllegalArgument, "Sort is only support on String, Date, boolean, byte, short, int, long and their boxed variants.");
+                ThrowException(env, IllegalArgument, "Sort is only support on String, Date, boolean, byte, short, "
+                                                     "int, long and their boxed variants.");
                 return 0;
         }
     }
@@ -1279,29 +1426,31 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(
     try {
         TableView* pTableView = new TableView(pTable->get_sorted_view(SortDescriptor(*pTable, indices, ascendings)));
         return reinterpret_cast<jlong>(pTableView);
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetName(
-    JNIEnv *env, jobject, jlong nativeTablePtr)
+JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetName(JNIEnv* env, jobject, jlong nativeTablePtr)
 {
     try {
         Table* table = TBL(nativeTablePtr);
-        if (!TABLE_VALID(env, table))
-            return NULL;
+        if (!TABLE_VALID(env, table)) {
+            return nullptr;
+        }
         return to_jstring(env, table->get_name());
-    } CATCH_STD()
-    return NULL;
+    }
+    CATCH_STD()
+    return nullptr;
 }
 
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToJson(
-    JNIEnv *env, jobject, jlong nativeTablePtr)
+JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToJson(JNIEnv* env, jobject, jlong nativeTablePtr)
 {
     Table* table = TBL(nativeTablePtr);
-    if (!TABLE_VALID(env, table))
-        return NULL;
+    if (!TABLE_VALID(env, table)) {
+        return nullptr;
+    }
 
     // Write table to string in JSON format
     try {
@@ -1310,23 +1459,24 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToJson(
         table->to_json(ss);
         const string str = ss.str();
         return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
+    }
+    CATCH_STD()
+    return nullptr;
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsValid(
-    JNIEnv*, jobject, jlong nativeTablePtr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsValid(JNIEnv*, jobject, jlong nativeTablePtr)
 {
     TR_ENTER_PTR(nativeTablePtr)
-    return TBL(nativeTablePtr)->is_attached();  // noexcept
+    return to_jbool(TBL(nativeTablePtr)->is_attached()); // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_createNative(JNIEnv *env, jobject)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_createNative(JNIEnv* env, jobject)
 {
     TR_ENTER()
     try {
         return reinterpret_cast<jlong>(LangBindHelper::new_table());
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
@@ -1343,7 +1493,7 @@ static bool check_valid_primary_key_column(JNIEnv* env, Table* table, StringData
     DataType column_type = table->get_column_type(column_index);
     TableView results = table->get_sorted_view(column_index);
 
-    switch(column_type) {
+    switch (column_type) {
         case type_Int:
             if (results.size() > 1) {
                 int64_t val = results.get_int(column_index, 0);
@@ -1388,21 +1538,23 @@ static bool check_valid_primary_key_column(JNIEnv* env, Table* table, StringData
     }
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
-    JNIEnv* env, jobject, jlong nativePrivateKeyTablePtr, jlong nativeTablePtr, jstring columnName)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(JNIEnv* env, jobject,
+                                                                         jlong nativePrivateKeyTablePtr,
+                                                                         jlong nativeTablePtr, jstring columnName)
 {
     try {
         Table* table = TBL(nativeTablePtr);
         Table* pk_table = TBL(nativePrivateKeyTablePtr);
         const std::string table_name(table->get_name().substr(TABLE_PREFIX.length())); // Remove "class_" prefix
-        size_t row_index = pk_table->find_first_string(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, table_name);
+        size_t row_index =
+            pk_table->find_first_string(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, table_name);
 
         if (columnName == NULL || env->GetStringLength(columnName) == 0) {
             // No primary key provided => remove previous set keys
             if (row_index != realm::not_found) {
                 pk_table->remove(row_index);
             }
-            return jlong(io_realm_internal_Table_NO_PRIMARY_KEY);
+            return io_realm_internal_Table_NO_PRIMARY_KEY;
         }
         else {
             JStringAccessor new_primary_key_column_name(env, columnName);
@@ -1411,24 +1563,29 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
                 // No primary key is currently set
                 if (check_valid_primary_key_column(env, table, new_primary_key_column_name)) {
                     row_index = pk_table->add_empty_row();
-                    pk_table->set_string_unique(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, row_index, table_name);
-                    pk_table->set_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index, new_primary_key_column_name);
+                    pk_table->set_string_unique(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, row_index,
+                                                table_name);
+                    pk_table->set_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index,
+                                         new_primary_key_column_name);
                 }
             }
             else {
                 // Primary key already exists
                 // We only wish to check for duplicate values if a column isn't already a primary key
-                StringData current_primary_key = pk_table->get_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index);
+                StringData current_primary_key =
+                    pk_table->get_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index);
                 if (new_primary_key_column_name != current_primary_key) {
                     if (check_valid_primary_key_column(env, table, new_primary_key_column_name)) {
-                        pk_table->set_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index, new_primary_key_column_name);
+                        pk_table->set_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index,
+                                             new_primary_key_column_name);
                     }
                 }
             }
 
-            return jlong(primary_key_column_index);
+            return static_cast<jlong>(primary_key_column_index);
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
@@ -1451,8 +1608,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
 
 // This methods converts the old (wrong) table format (string, integer) to the right (string,string) format and strips
 // any class names in the col[0] of their "class_" prefix
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded
-    (JNIEnv*, jclass, jlong groupNativePtr, jlong privateKeyTableNativePtr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded(
+    JNIEnv*, jclass, jlong groupNativePtr, jlong privateKeyTableNativePtr)
 {
     const size_t CLASS_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX;
     const size_t FIELD_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX;
@@ -1505,7 +1662,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyT
 }
 
 JNIEXPORT jboolean JNICALL
-Java_io_realm_internal_Table_nativePrimaryKeyTableNeedsMigration(JNIEnv *, jclass, jlong primaryKeyTableNativePtr)
+Java_io_realm_internal_Table_nativePrimaryKeyTableNeedsMigration(JNIEnv*, jclass, jlong primaryKeyTableNativePtr)
 {
 
     const size_t CLASS_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX;
@@ -1533,17 +1690,16 @@ Java_io_realm_internal_Table_nativePrimaryKeyTableNeedsMigration(JNIEnv *, jclas
     return JNI_FALSE;
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSameSchema
-  (JNIEnv*, jobject, jlong thisTablePtr, jlong otherTablePtr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSameSchema(JNIEnv*, jobject, jlong thisTablePtr,
+                                                                            jlong otherTablePtr)
 {
-    return *TBL(thisTablePtr)->get_descriptor() == *TBL(otherTablePtr)->get_descriptor();
+    return to_jbool(*TBL(thisTablePtr)->get_descriptor() == *TBL(otherTablePtr)->get_descriptor());
 }
 
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeVersion(
-        JNIEnv* env, jobject, jlong nativeTablePtr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeVersion(JNIEnv* env, jobject, jlong nativeTablePtr)
 {
-    bool valid = (TBL(nativeTablePtr) != NULL);
+    bool valid = (TBL(nativeTablePtr) != nullptr);
     if (valid) {
         if (!TBL(nativeTablePtr)->is_attached()) {
             ThrowException(env, IllegalState, "The Realm has been closed and is no longer accessible.");
@@ -1551,8 +1707,9 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeVersion(
         }
     }
     try {
-        return (jlong) TBL(nativeTablePtr)->get_version_counter();
-    } CATCH_STD()
+        return static_cast<jlong>(TBL(nativeTablePtr)->get_version_counter());
+    }
+    CATCH_STD()
     return 0;
 }
 
@@ -1562,10 +1719,8 @@ static void finalize_table(jlong ptr)
     LangBindHelper::unbind_table_ptr(TBL(ptr));
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetFinalizerPtr
-  (JNIEnv *, jclass)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetFinalizerPtr(JNIEnv*, jclass)
 {
     TR_ENTER()
     return reinterpret_cast<jlong>(&finalize_table);
 }
-
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
index e7583bf7fc..ca9baad7ef 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
@@ -29,9 +29,9 @@ using namespace realm;
 using namespace realm::jni_util;
 
 #if 1
-#define QUERY_COL_TYPE_VALID(env, jPtr, col, type)  query_col_type_valid(env, jPtr, col, type)
+#define QUERY_COL_TYPE_VALID(env, jPtr, col, type) query_col_type_valid(env, jPtr, col, type)
 #else
-#define QUERY_COL_TYPE_VALID(env, jPtr, col, type)  (true)
+#define QUERY_COL_TYPE_VALID(env, jPtr, col, type) (true)
 #endif
 
 static void finalize_table_query(jlong ptr);
@@ -46,22 +46,24 @@ const char* ERR_IMPORT_CLOSED_REALM = "Can not import results from a closed Real
 const char* ERR_SORT_NOT_SUPPORTED = "Sort is not supported on binary data, object references and RealmList";
 //-------------------------------------------------------
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableQuery_nativeValidateQuery
-(JNIEnv *env, jobject, jlong nativeQueryPtr)
+JNIEXPORT jstring JNICALL Java_io_realm_internal_TableQuery_nativeValidateQuery(JNIEnv* env, jobject,
+                                                                                jlong nativeQueryPtr)
 {
     try {
         const std::string str = Q(nativeQueryPtr)->validate();
         StringData sd(str);
         return to_jstring(env, sd);
-    } CATCH_STD();
-    return NULL;
+    }
+    CATCH_STD();
+    return nullptr;
 }
 
 
 // helper functions
 
 // Return TableRef used for build link queries
-static TableRef getTableForLinkQuery(jlong nativeQueryPtr, JniLongArray& indicesArray) {
+static TableRef getTableForLinkQuery(jlong nativeQueryPtr, JniLongArray& indicesArray)
+{
     TableRef table_ref = Q(nativeQueryPtr)->get_table();
     jsize link_element_count = indicesArray.len() - 1;
     for (int i = 0; i < link_element_count; i++) {
@@ -71,7 +73,8 @@ static TableRef getTableForLinkQuery(jlong nativeQueryPtr, JniLongArray& indices
 }
 
 // Return TableRef point to original table or the link table
-static TableRef getTableByArray(jlong nativeQueryPtr, JniLongArray& indicesArray) {
+static TableRef getTableByArray(jlong nativeQueryPtr, JniLongArray& indicesArray)
+{
     TableRef table_ref = Q(nativeQueryPtr)->get_table();
     jsize link_element_count = indicesArray.len() - 1;
     for (int i = 0; i < link_element_count; i++) {
@@ -81,40 +84,47 @@ static TableRef getTableByArray(jlong nativeQueryPtr, JniLongArray& indicesArray
 }
 
 template <typename coretype, typename cpptype, typename javatype>
-Query numeric_link_equal(TableRef tbl, jlong columnIndex, javatype value) {
+Query numeric_link_equal(TableRef tbl, jlong columnIndex, javatype value)
+{
     return tbl->column<coretype>(size_t(columnIndex)) == cpptype(value);
 }
 
 template <typename coretype, typename cpptype, typename javatype>
-Query numeric_link_notequal(TableRef tbl, jlong columnIndex, javatype value) {
+Query numeric_link_notequal(TableRef tbl, jlong columnIndex, javatype value)
+{
     return tbl->column<coretype>(size_t(columnIndex)) != cpptype(value);
 }
 
 template <typename coretype, typename cpptype, typename javatype>
-Query numeric_link_greater(TableRef tbl, jlong columnIndex, javatype value) {
+Query numeric_link_greater(TableRef tbl, jlong columnIndex, javatype value)
+{
     return tbl->column<coretype>(size_t(columnIndex)) > cpptype(value);
 }
 
 template <typename coretype, typename cpptype, typename javatype>
-Query numeric_link_greaterequal(TableRef tbl, jlong columnIndex, javatype value) {
+Query numeric_link_greaterequal(TableRef tbl, jlong columnIndex, javatype value)
+{
     return tbl->column<coretype>(size_t(columnIndex)) >= cpptype(value);
 }
 
 template <typename coretype, typename cpptype, typename javatype>
-Query numeric_link_less(TableRef tbl, jlong columnIndex, javatype value) {
+Query numeric_link_less(TableRef tbl, jlong columnIndex, javatype value)
+{
     return tbl->column<coretype>(size_t(columnIndex)) < cpptype(value);
 }
 
 template <typename coretype, typename cpptype, typename javatype>
-Query numeric_link_lessequal(TableRef tbl, jlong columnIndex, javatype value) {
+Query numeric_link_lessequal(TableRef tbl, jlong columnIndex, javatype value)
+{
     return tbl->column<coretype>(size_t(columnIndex)) <= cpptype(value);
 }
 
 
 // Integer
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JJ(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JJ(JNIEnv* env, jobject,
+                                                                            jlong nativeQueryPtr,
+                                                                            jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -127,13 +137,16 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JJ(
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_equal<Int, int64_t, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)->and_query(numeric_link_equal<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JJ(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JJ(JNIEnv* env, jobject,
+                                                                                       jlong nativeQueryPtr,
+                                                                                       jlongArray columnIndexes,
+                                                                                       jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -146,13 +159,16 @@ JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual_
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_notequal<Int, int64_t, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_notequal<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JJ(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JJ(JNIEnv* env, jobject,
+                                                                              jlong nativeQueryPtr,
+                                                                              jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -165,13 +181,17 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JJ(
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_greater<Int, int64_t, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_greater<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JJ(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JJ(JNIEnv* env, jobject,
+                                                                                   jlong nativeQueryPtr,
+                                                                                   jlongArray columnIndexes,
+                                                                                   jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -184,13 +204,15 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Int, int64_t, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_greaterequal<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JJ(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JJ(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                           jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -203,13 +225,15 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JJ(
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_less<Int, int64_t, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)->and_query(numeric_link_less<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JJ(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JJ(JNIEnv* env, jobject,
+                                                                                jlong nativeQueryPtr,
+                                                                                jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -222,13 +246,17 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JJ(
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Int, int64_t, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_lessequal<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JJJ(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value1, jlong value2)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JJJ(JNIEnv* env, jobject,
+                                                                               jlong nativeQueryPtr,
+                                                                               jlongArray columnIndexes, jlong value1,
+                                                                               jlong value2)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -238,7 +266,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JJJ(
         }
         try {
             Q(nativeQueryPtr)->between(S(arr[0]), static_cast<int64_t>(value1), static_cast<int64_t>(value2));
-        } CATCH_STD()
+        }
+        CATCH_STD()
     }
     else {
         ThrowException(env, IllegalArgument, "between() does not support queries using child object fields.");
@@ -247,8 +276,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JJJ(
 
 // Float
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JF(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JF(JNIEnv* env, jobject,
+                                                                            jlong nativeQueryPtr,
+                                                                            jlongArray columnIndexes, jfloat value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -261,13 +291,17 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JF(
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_equal<Float, float, jfloat>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_equal<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JF(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
+JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JF(JNIEnv* env, jobject,
+                                                                                       jlong nativeQueryPtr,
+                                                                                       jlongArray columnIndexes,
+                                                                                       jfloat value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -280,13 +314,16 @@ JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual_
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_notequal<Float, float, jfloat>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_notequal<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JF(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JF(JNIEnv* env, jobject,
+                                                                              jlong nativeQueryPtr,
+                                                                              jlongArray columnIndexes, jfloat value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -299,13 +336,17 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JF(
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_greater<Float, float, jfloat>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_greater<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JF(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JF(JNIEnv* env, jobject,
+                                                                                   jlong nativeQueryPtr,
+                                                                                   jlongArray columnIndexes,
+                                                                                   jfloat value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -318,13 +359,15 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Float, float, jfloat>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_greaterequal<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JF(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JF(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                           jlongArray columnIndexes, jfloat value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -337,13 +380,16 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JF(
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_less<Float, float, jfloat>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)->and_query(numeric_link_less<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JF(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JF(JNIEnv* env, jobject,
+                                                                                jlong nativeQueryPtr,
+                                                                                jlongArray columnIndexes,
+                                                                                jfloat value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -356,13 +402,17 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JF(
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Float, float, jfloat>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_lessequal<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JFF(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value1, jfloat value2)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JFF(JNIEnv* env, jobject,
+                                                                               jlong nativeQueryPtr,
+                                                                               jlongArray columnIndexes,
+                                                                               jfloat value1, jfloat value2)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -376,14 +426,16 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JFF(
         else {
             ThrowException(env, IllegalArgument, "between() does not support queries using child object fields.");
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
 
 // Double
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JD(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JD(JNIEnv* env, jobject,
+                                                                            jlong nativeQueryPtr,
+                                                                            jlongArray columnIndexes, jdouble value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -396,13 +448,17 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JD(
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_equal<Double, double, jdouble>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_equal<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JD(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
+JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JD(JNIEnv* env, jobject,
+                                                                                       jlong nativeQueryPtr,
+                                                                                       jlongArray columnIndexes,
+                                                                                       jdouble value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -415,13 +471,16 @@ JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual_
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_notequal<Double, double, jdouble>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_notequal<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JD(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JD(JNIEnv* env, jobject,
+                                                                              jlong nativeQueryPtr,
+                                                                              jlongArray columnIndexes, jdouble value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -434,13 +493,17 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JD(
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_greater<Double, double, jdouble>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_greater<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JD(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JD(JNIEnv* env, jobject,
+                                                                                   jlong nativeQueryPtr,
+                                                                                   jlongArray columnIndexes,
+                                                                                   jdouble value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -453,13 +516,15 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Double, double, jdouble>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_greaterequal<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JD(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JD(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                           jlongArray columnIndexes, jdouble value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -472,13 +537,17 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JD(
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_less<Double, double, jdouble>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_less<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JD(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JD(JNIEnv* env, jobject,
+                                                                                jlong nativeQueryPtr,
+                                                                                jlongArray columnIndexes,
+                                                                                jdouble value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -491,13 +560,17 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JD(
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Double, double, jdouble>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_lessequal<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JDD(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value1, jdouble value2)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JDD(JNIEnv* env, jobject,
+                                                                               jlong nativeQueryPtr,
+                                                                               jlongArray columnIndexes,
+                                                                               jdouble value1, jdouble value2)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -511,14 +584,16 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JDD(
         else {
             ThrowException(env, IllegalArgument, "between() does not support queries using child object fields.");
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
 
 // Timestamp
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualTimestamp(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualTimestamp(JNIEnv* env, jobject,
+                                                                              jlong nativeQueryPtr,
+                                                                              jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -531,13 +606,18 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualTimestamp(
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_equal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_equal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                                                                                from_milliseconds(value)));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualTimestamp(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualTimestamp(JNIEnv* env, jobject,
+                                                                                         jlong nativeQueryPtr,
+                                                                                         jlongArray columnIndexes,
+                                                                                         jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -550,13 +630,17 @@ JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualT
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_notequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_notequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                                                                                   from_milliseconds(value)));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterTimestamp(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterTimestamp(JNIEnv* env, jobject,
+                                                                                jlong nativeQueryPtr,
+                                                                                jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -569,13 +653,18 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterTimestamp(
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_greater<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_greater<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                                                                                  from_milliseconds(value)));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualTimestamp(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualTimestamp(JNIEnv* env, jobject,
+                                                                                     jlong nativeQueryPtr,
+                                                                                     jlongArray columnIndexes,
+                                                                                     jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -588,13 +677,17 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualTimes
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_greaterequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                                                                                       from_milliseconds(value)));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessTimestamp(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessTimestamp(JNIEnv* env, jobject,
+                                                                             jlong nativeQueryPtr,
+                                                                             jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -607,13 +700,18 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessTimestamp(
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_less<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_less<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                                                                               from_milliseconds(value)));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualTimestamp(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualTimestamp(JNIEnv* env, jobject,
+                                                                                  jlong nativeQueryPtr,
+                                                                                  jlongArray columnIndexes,
+                                                                                  jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -626,13 +724,18 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualTimestam
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_lessequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                                                                                    from_milliseconds(value)));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenTimestamp(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value1, jlong value2)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenTimestamp(JNIEnv* env, jobject,
+                                                                                jlong nativeQueryPtr,
+                                                                                jlongArray columnIndexes,
+                                                                                jlong value1, jlong value2)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -641,21 +744,26 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenTimestamp(
             if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater_equal(S(arr[0]), from_milliseconds(value1)).less_equal(S(arr[0]), from_milliseconds(value2));
+            Q(nativeQueryPtr)
+                ->greater_equal(S(arr[0]), from_milliseconds(value1))
+                .less_equal(S(arr[0]), from_milliseconds(value2));
         }
         else {
             ThrowException(env, IllegalArgument, "between() does not support queries using child object fields.");
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
 // Bool
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JZ(
-  JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jboolean value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JZ(JNIEnv* env, jobject,
+                                                                            jlong nativeQueryPtr,
+                                                                            jlongArray columnIndexes, jboolean value)
 {
     JniLongArray arr(env, columnIndexes);
-    try {    jsize arr_len = arr.len();
+    try {
+        jsize arr_len = arr.len();
 
         if (arr_len == 1) {
             if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Bool)) {
@@ -665,29 +773,26 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JZ(
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_equal<Bool, bool, jboolean>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)
+                ->and_query(numeric_link_equal<Bool, bool, jboolean>(table_ref, arr[arr_len - 1], value));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
 // String
 
-enum StringPredicate {
-    StringEqual,
-    StringNotEqual,
-    StringContains,
-    StringBeginsWith,
-    StringEndsWith,
-    StringLike
-};
+enum StringPredicate { StringEqual, StringNotEqual, StringContains, StringBeginsWith, StringEndsWith, StringLike };
 
 
-static void TableQuery_StringPredicate(JNIEnv *env, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive, StringPredicate predicate) {
+static void TableQuery_StringPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value,
+                                       jboolean caseSensitive, StringPredicate predicate)
+{
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
         if (value == NULL) {
-            if (!TBL_AND_COL_NULLABLE(env, getTableByArray(nativeQueryPtr, arr).get(), arr[arr_len-1])) {
+            if (!TBL_AND_COL_NULLABLE(env, getTableByArray(nativeQueryPtr, arr).get(), arr[arr_len - 1])) {
                 return;
             }
         }
@@ -698,103 +803,119 @@ static void TableQuery_StringPredicate(JNIEnv *env, jlong nativeQueryPtr, jlongA
                 return;
             }
             switch (predicate) {
-            case StringEqual:
-                Q(nativeQueryPtr)->equal(S(arr[0]), value2, is_case_sensitive);
-                break;
-            case StringNotEqual:
-                Q(nativeQueryPtr)->not_equal(S(arr[0]), value2, is_case_sensitive);
-                break;
-            case StringContains:
-                Q(nativeQueryPtr)->contains(S(arr[0]), value2, is_case_sensitive);
-                break;
-            case StringBeginsWith:
-                Q(nativeQueryPtr)->begins_with(S(arr[0]), value2, is_case_sensitive);
-                break;
-            case StringEndsWith:
-                Q(nativeQueryPtr)->ends_with(S(arr[0]), value2, is_case_sensitive);
-                break;
-            case StringLike:
-                Q(nativeQueryPtr)->like(S(arr[0]), value2, is_case_sensitive);
-                break;
+                case StringEqual:
+                    Q(nativeQueryPtr)->equal(S(arr[0]), value2, is_case_sensitive);
+                    break;
+                case StringNotEqual:
+                    Q(nativeQueryPtr)->not_equal(S(arr[0]), value2, is_case_sensitive);
+                    break;
+                case StringContains:
+                    Q(nativeQueryPtr)->contains(S(arr[0]), value2, is_case_sensitive);
+                    break;
+                case StringBeginsWith:
+                    Q(nativeQueryPtr)->begins_with(S(arr[0]), value2, is_case_sensitive);
+                    break;
+                case StringEndsWith:
+                    Q(nativeQueryPtr)->ends_with(S(arr[0]), value2, is_case_sensitive);
+                    break;
+                case StringLike:
+                    Q(nativeQueryPtr)->like(S(arr[0]), value2, is_case_sensitive);
+                    break;
             }
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
             switch (predicate) {
-            case StringEqual:
-                Q(nativeQueryPtr)->and_query(table_ref->column<String>(size_t(arr[arr_len-1])).equal(StringData(value2), is_case_sensitive));
-                break;
-            case StringNotEqual:
-                Q(nativeQueryPtr)->and_query(table_ref->column<String>(size_t(arr[arr_len-1])).not_equal(StringData(value2), is_case_sensitive));
-                break;
-            case StringContains:
-                Q(nativeQueryPtr)->and_query(table_ref->column<String>(size_t(arr[arr_len-1])).contains(StringData(value2), is_case_sensitive));
-                break;
-            case StringBeginsWith:
-                Q(nativeQueryPtr)->and_query(table_ref->column<String>(size_t(arr[arr_len-1])).begins_with(StringData(value2), is_case_sensitive));
-                break;
-            case StringEndsWith:
-                Q(nativeQueryPtr)->and_query(table_ref->column<String>(size_t(arr[arr_len-1])).ends_with(StringData(value2), is_case_sensitive));
-                break;
-            case StringLike:
-                Q(nativeQueryPtr)->and_query(table_ref->column<String>(size_t(arr[arr_len-1])).like(StringData(value2), is_case_sensitive));
-                break;
+                case StringEqual:
+                    Q(nativeQueryPtr)
+                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                                        .equal(StringData(value2), is_case_sensitive));
+                    break;
+                case StringNotEqual:
+                    Q(nativeQueryPtr)
+                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                                        .not_equal(StringData(value2), is_case_sensitive));
+                    break;
+                case StringContains:
+                    Q(nativeQueryPtr)
+                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                                        .contains(StringData(value2), is_case_sensitive));
+                    break;
+                case StringBeginsWith:
+                    Q(nativeQueryPtr)
+                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                                        .begins_with(StringData(value2), is_case_sensitive));
+                    break;
+                case StringEndsWith:
+                    Q(nativeQueryPtr)
+                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                                        .ends_with(StringData(value2), is_case_sensitive));
+                    break;
+                case StringLike:
+                    Q(nativeQueryPtr)
+                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                                        .like(StringData(value2), is_case_sensitive));
+                    break;
             }
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JLjava_lang_String_2Z(
-    JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
 {
     TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringEqual);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JLjava_lang_String_2Z(
-    JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
 {
     TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringNotEqual);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBeginsWith(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBeginsWith(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                          jlongArray columnIndexes, jstring value,
+                                                                          jboolean caseSensitive)
 {
     TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringBeginsWith);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEndsWith(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEndsWith(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                        jlongArray columnIndexes, jstring value,
+                                                                        jboolean caseSensitive)
 {
     TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringEndsWith);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLike(
-        JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLike(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                    jlongArray columnIndexes, jstring value,
+                                                                    jboolean caseSensitive)
 {
     TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringLike);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeContains(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeContains(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                        jlongArray columnIndexes, jstring value,
+                                                                        jboolean caseSensitive)
 {
     TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringContains);
 }
 
 // Binary
 
-enum BinaryPredicate {
-    BinaryEqual,
-    BinaryNotEqual
-};
+enum BinaryPredicate { BinaryEqual, BinaryNotEqual };
 
-static void TableQuery_BinaryPredicate(JNIEnv *env, jlong nativeQueryPtr, jlongArray columnIndices, jbyteArray value, BinaryPredicate predicate) {
+static void TableQuery_BinaryPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongArray columnIndices, jbyteArray value,
+                                       BinaryPredicate predicate)
+{
     JniLongArray arr(env, columnIndices);
     jsize arr_len = arr.len();
     try {
         JniByteArray bytes(env, value);
         BinaryData value2;
         if (value == NULL) {
-            if (!TBL_AND_COL_NULLABLE(env, getTableByArray(nativeQueryPtr, arr).get(), arr[arr_len-1])) {
+            if (!TBL_AND_COL_NULLABLE(env, getTableByArray(nativeQueryPtr, arr).get(), arr[arr_len - 1])) {
                 return;
             }
             value2 = BinaryData();
@@ -812,36 +933,41 @@ static void TableQuery_BinaryPredicate(JNIEnv *env, jlong nativeQueryPtr, jlongA
                 return;
             }
             switch (predicate) {
-            case BinaryEqual:
-                Q(nativeQueryPtr)->equal(S(arr[0]), value2);
-                break;
-            case BinaryNotEqual:
-                Q(nativeQueryPtr)->not_equal(S(arr[0]), value2);
-                break;
+                case BinaryEqual:
+                    Q(nativeQueryPtr)->equal(S(arr[0]), value2);
+                    break;
+                case BinaryNotEqual:
+                    Q(nativeQueryPtr)->not_equal(S(arr[0]), value2);
+                    break;
             }
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
             switch (predicate) {
-            case BinaryEqual:
-                Q(nativeQueryPtr)->and_query(table_ref->column<Binary>(size_t(arr[arr_len-1])) == value2);
-                break;
-            case BinaryNotEqual:
-                Q(nativeQueryPtr)->and_query(table_ref->column<Binary>(size_t(arr[arr_len-1])) != value2);
-                break;
+                case BinaryEqual:
+                    Q(nativeQueryPtr)->and_query(table_ref->column<Binary>(size_t(arr[arr_len - 1])) == value2);
+                    break;
+                case BinaryNotEqual:
+                    Q(nativeQueryPtr)->and_query(table_ref->column<Binary>(size_t(arr[arr_len - 1])) != value2);
+                    break;
             }
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3B
-  (JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndices, jbyteArray value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3B(JNIEnv* env, jobject,
+                                                                              jlong nativeQueryPtr,
+                                                                              jlongArray columnIndices,
+                                                                              jbyteArray value)
 {
     TableQuery_BinaryPredicate(env, nativeQueryPtr, columnIndices, value, BinaryEqual);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3B
-  (JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndices, jbyteArray value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3B(JNIEnv* env, jobject,
+                                                                                 jlong nativeQueryPtr,
+                                                                                 jlongArray columnIndices,
+                                                                                 jbyteArray value)
 {
     TableQuery_BinaryPredicate(env, nativeQueryPtr, columnIndices, value, BinaryNotEqual);
 }
@@ -852,398 +978,429 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3B
 // as they are called for each method when building up the query.
 // Consider to reduce to just the "action" methods on Query
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGroup(
-    JNIEnv* env, jobject, jlong nativeQueryPtr)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGroup(JNIEnv* env, jobject, jlong nativeQueryPtr)
 {
     Query* pQuery = Q(nativeQueryPtr);
-    if (!QUERY_VALID(env, pQuery))
+    if (!QUERY_VALID(env, pQuery)) {
         return;
+    }
     try {
         pQuery->group();
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEndGroup(
-    JNIEnv* env, jobject, jlong nativeQueryPtr)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEndGroup(JNIEnv* env, jobject, jlong nativeQueryPtr)
 {
     Query* pQuery = Q(nativeQueryPtr);
-    if (!QUERY_VALID(env, pQuery))
+    if (!QUERY_VALID(env, pQuery)) {
         return;
+    }
     try {
         pQuery->end_group();
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeOr(
-    JNIEnv* env, jobject, jlong nativeQueryPtr)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeOr(JNIEnv* env, jobject, jlong nativeQueryPtr)
 {
     // No verification of parameters needed?
     Query* pQuery = Q(nativeQueryPtr);
-    if (!QUERY_VALID(env, pQuery))
+    if (!QUERY_VALID(env, pQuery)) {
         return;
+    }
     try {
         pQuery->Or();
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNot(
-    JNIEnv* env, jobject, jlong nativeQueryPtr)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNot(JNIEnv* env, jobject, jlong nativeQueryPtr)
 {
     Query* pQuery = Q(nativeQueryPtr);
-    if (!QUERY_VALID(env, pQuery))
+    if (!QUERY_VALID(env, pQuery)) {
         return;
+    }
     try {
         pQuery->Not();
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
 // Find --------------------------------------
 
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong fromTableRow)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                     jlong fromTableRow)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery))
+    if (!QUERY_VALID(env, pQuery)) {
         return -1;
+    }
     // It's valid to go 1 past the end index
     if ((fromTableRow < 0) || (S(fromTableRow) > pTable->size())) {
         // below check will fail with appropriate exception
-        (void) ROW_INDEX_VALID(env, pTable, fromTableRow);
+        (void)ROW_INDEX_VALID(env, pTable, fromTableRow);
         return -1;
     }
 
     try {
-        size_t r = pQuery->find( S(fromTableRow) );
+        size_t r = pQuery->find(S(fromTableRow));
         return (r == not_found) ? jlong(-1) : jlong(r);
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return -1;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong start, jlong end, jlong limit)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                        jlong start, jlong end, jlong limit)
 {
     TR_ENTER()
     Query* query = Q(nativeQueryPtr);
-    TableRef table =  query->get_table();
-    if (!QUERY_VALID(env, query) ||
-        !ROW_INDEXES_VALID(env, table.get(), start, end, limit))
+    TableRef table = query->get_table();
+    if (!QUERY_VALID(env, query) || !ROW_INDEXES_VALID(env, table.get(), start, end, limit)) {
         return -1;
+    }
     try {
-        TableView* tableView = new TableView( query->find_all(S(start), S(end), S(limit)) );
+        TableView* tableView = new TableView(query->find_all(S(start), S(end), S(limit)));
         return reinterpret_cast<jlong>(tableView);
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return -1;
 }
 
 // Integer Aggregates
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeSumInt(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeSumInt(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                       jlong columnIndex, jlong start, jlong end,
+                                                                       jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Int) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+    if (!QUERY_VALID(env, pQuery) || !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Int) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit)) {
         return 0;
+    }
     try {
         return pQuery->sum_int(S(columnIndex), NULL, S(start), S(end), S(limit));
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumInt(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumInt(JNIEnv* env, jobject,
+                                                                             jlong nativeQueryPtr, jlong columnIndex,
+                                                                             jlong start, jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Int) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return NULL;
+    if (!QUERY_VALID(env, pQuery) || !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Int) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit)) {
+        return nullptr;
+    }
     try {
         size_t return_ndx;
         int64_t result = pQuery->maximum_int(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
         if (return_ndx != npos) {
             return NewLong(env, result);
         }
-    } CATCH_STD()
-    return NULL;
+    }
+    CATCH_STD()
+    return nullptr;
 }
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumInt(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumInt(JNIEnv* env, jobject,
+                                                                             jlong nativeQueryPtr, jlong columnIndex,
+                                                                             jlong start, jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Int) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return NULL;
+    if (!QUERY_VALID(env, pQuery) || !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Int) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit)) {
+        return nullptr;
+    }
     try {
         size_t return_ndx;
         int64_t result = pQuery->minimum_int(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
         if (return_ndx != npos) {
             return NewLong(env, result);
         }
-    } CATCH_STD()
-    return NULL;
+    }
+    CATCH_STD()
+    return nullptr;
 }
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageInt(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageInt(JNIEnv* env, jobject,
+                                                                             jlong nativeQueryPtr, jlong columnIndex,
+                                                                             jlong start, jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Int) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+    if (!QUERY_VALID(env, pQuery) || !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Int) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit)) {
         return 0;
+    }
     try {
         size_t resultcount;
-        //TODO: return resultcount?
+        // TODO: return resultcount?
         double avg = pQuery->average_int(S(columnIndex), &resultcount, S(start), S(end), S(limit));
-        //fprintf(stderr, "!!!Average(%d, %d) = %f (%d results)\n", start, end, avg, resultcount); fflush(stderr);
+        // fprintf(stderr, "!!!Average(%d, %d) = %f (%d results)\n", start, end, avg, resultcount); fflush(stderr);
         return avg;
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
 
 // float Aggregates
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeSumFloat(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeSumFloat(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                           jlong columnIndex, jlong start, jlong end,
+                                                                           jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Float) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+    if (!QUERY_VALID(env, pQuery) || !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Float) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit)) {
         return 0;
+    }
     try {
         return pQuery->sum_float(S(columnIndex), NULL, S(start), S(end), S(limit));
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumFloat(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumFloat(JNIEnv* env, jobject,
+                                                                               jlong nativeQueryPtr,
+                                                                               jlong columnIndex, jlong start,
+                                                                               jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Float) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return NULL;
+    if (!QUERY_VALID(env, pQuery) || !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Float) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit)) {
+        return nullptr;
+    }
     try {
         size_t return_ndx;
         float result = pQuery->maximum_float(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
         if (return_ndx != npos) {
             return NewFloat(env, result);
         }
-    } CATCH_STD()
-    return NULL;
+    }
+    CATCH_STD()
+    return nullptr;
 }
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumFloat(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumFloat(JNIEnv* env, jobject,
+                                                                               jlong nativeQueryPtr,
+                                                                               jlong columnIndex, jlong start,
+                                                                               jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Float) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return NULL;
+    if (!QUERY_VALID(env, pQuery) || !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Float) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit)) {
+        return nullptr;
+    }
     try {
         size_t return_ndx;
         float result = pQuery->minimum_float(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
         if (return_ndx != npos) {
             return NewFloat(env, result);
         }
-    } CATCH_STD()
-    return NULL;
+    }
+    CATCH_STD()
+    return nullptr;
 }
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageFloat(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageFloat(JNIEnv* env, jobject,
+                                                                               jlong nativeQueryPtr,
+                                                                               jlong columnIndex, jlong start,
+                                                                               jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Float) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+    if (!QUERY_VALID(env, pQuery) || !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Float) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit)) {
         return 0;
+    }
     try {
         size_t resultcount;
         double avg = pQuery->average_float(S(columnIndex), &resultcount, S(start), S(end), S(limit));
         return avg;
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
 // double Aggregates
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeSumDouble(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeSumDouble(JNIEnv* env, jobject,
+                                                                            jlong nativeQueryPtr, jlong columnIndex,
+                                                                            jlong start, jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Double) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+    if (!QUERY_VALID(env, pQuery) || !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Double) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit)) {
         return 0;
+    }
     try {
         return pQuery->sum_double(S(columnIndex), NULL, S(start), S(end), S(limit));
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDouble(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDouble(JNIEnv* env, jobject,
+                                                                                jlong nativeQueryPtr,
+                                                                                jlong columnIndex, jlong start,
+                                                                                jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Double) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return NULL;
+    if (!QUERY_VALID(env, pQuery) || !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Double) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit)) {
+        return nullptr;
+    }
     try {
         size_t return_ndx;
         double result = pQuery->maximum_double(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
         if (return_ndx != npos) {
             return NewDouble(env, result);
         }
-    } CATCH_STD()
-    return NULL;
+    }
+    CATCH_STD()
+    return nullptr;
 }
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDouble(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDouble(JNIEnv* env, jobject,
+                                                                                jlong nativeQueryPtr,
+                                                                                jlong columnIndex, jlong start,
+                                                                                jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Double) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return NULL;
+    if (!QUERY_VALID(env, pQuery) || !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Double) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit)) {
+        return nullptr;
+    }
     try {
         size_t return_ndx;
         double result = pQuery->minimum_double(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
         if (return_ndx != npos) {
             return NewDouble(env, result);
         }
-    } CATCH_STD()
-    return NULL;
+    }
+    CATCH_STD()
+    return nullptr;
 }
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageDouble(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageDouble(JNIEnv* env, jobject,
+                                                                                jlong nativeQueryPtr,
+                                                                                jlong columnIndex, jlong start,
+                                                                                jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Double) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+    if (!QUERY_VALID(env, pQuery) || !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Double) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit)) {
         return 0;
+    }
     try {
-        //TODO: Return resultcount
+        // TODO: Return resultcount
         size_t resultcount;
         double avg = pQuery->average_double(S(columnIndex), &resultcount, S(start), S(end), S(limit));
         return avg;
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
 
 // date aggregates
 // FIXME: This is a rough workaround while waiting for https://github.com/realm/realm-core/issues/1745 to be solved
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumTimestamp(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumTimestamp(JNIEnv* env, jobject,
+                                                                                   jlong nativeQueryPtr,
+                                                                                   jlong columnIndex, jlong start,
+                                                                                   jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Timestamp) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return NULL;
+    if (!QUERY_VALID(env, pQuery) || !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Timestamp) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit)) {
+        return nullptr;
+    }
     try {
         size_t return_ndx;
         Timestamp result = pQuery->find_all().maximum_timestamp(S(columnIndex), &return_ndx);
         if (return_ndx != npos && !result.is_null()) {
             return NewLong(env, to_milliseconds(result));
         }
-    } CATCH_STD()
-    return NULL;
+    }
+    CATCH_STD()
+    return nullptr;
 }
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumTimestamp(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumTimestamp(JNIEnv* env, jobject,
+                                                                                   jlong nativeQueryPtr,
+                                                                                   jlong columnIndex, jlong start,
+                                                                                   jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Timestamp) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return NULL;
+    if (!QUERY_VALID(env, pQuery) || !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Timestamp) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit)) {
+        return nullptr;
+    }
     try {
         size_t return_ndx;
         Timestamp result = pQuery->find_all().minimum_timestamp(S(columnIndex), &return_ndx);
         if (return_ndx != npos && !result.is_null()) {
             return NewLong(env, to_milliseconds(result));
         }
-    } CATCH_STD()
-    return NULL;
+    }
+    CATCH_STD()
+    return nullptr;
 }
 
 // Count, Remove
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeCount(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong start, jlong end, jlong limit)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeCount(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                      jlong start, jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+    if (!QUERY_VALID(env, pQuery) || !ROW_INDEXES_VALID(env, pTable, start, end, limit)) {
         return 0;
+    }
     try {
-        return pQuery->count(S(start), S(end), S(limit));
-    } CATCH_STD()
+        return static_cast<jlong>(pQuery->count(S(start), S(end), S(limit)));
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeRemove(
-    JNIEnv* env, jobject, jlong nativeQueryPtr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeRemove(JNIEnv* env, jobject, jlong nativeQueryPtr)
 {
     Query* pQuery = Q(nativeQueryPtr);
-    if (!QUERY_VALID(env, pQuery))
+    if (!QUERY_VALID(env, pQuery)) {
         return 0;
+    }
     try {
-        return pQuery->remove();
-    } CATCH_STD()
+        return static_cast<jlong>(pQuery->remove());
+    }
+    CATCH_STD()
     return 0;
 }
 
 // isNull and isNotNull
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(
-    JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                      jlongArray columnIndexes)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -1251,7 +1408,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(
 
     try {
         TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-        jlong column_idx = arr[arr_len-1];
+        jlong column_idx = arr[arr_len - 1];
         TableRef table_ref = getTableByArray(nativeQueryPtr, arr);
         if (!TBL_AND_COL_NULLABLE(env, table_ref.get(), column_idx)) {
             return;
@@ -1279,11 +1436,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(
                     Q(nativeQueryPtr)->equal(S(column_idx), realm::null());
                     break;
                 default:
-                    // this point is unreachable
-                    ThrowException(env, FatalError, "This is not reachable.");
-                    return;
+                    REALM_UNREACHABLE();
             }
-        } else {
+        }
+        else {
             switch (col_type) {
                 case type_Link:
                     ThrowException(env, IllegalArgument, "isNull() by nested query for link field is not supported.");
@@ -1314,60 +1470,65 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(
                     pQuery->and_query(src_table_ref->column<Timestamp>(S(column_idx)) == realm::null());
                     break;
                 default:
-                    // this point is unreachable
-                    ThrowException(env, FatalError, "This is not reachable.");
-                    return;
+                    REALM_UNREACHABLE();
             }
         }
-    } CATCH_STD()
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRowIntoSharedGroup
-  (JNIEnv *env, jclass, jlong handoverPtr, jlong callerSharedGrpPtr)
-  {
-      TR_ENTER_PTR(handoverPtr)
-      SharedGroup::Handover<Row> *handoverRowPtr = HO(Row, handoverPtr);
-      std::unique_ptr<SharedGroup::Handover<Row>> handoverRow(handoverRowPtr);
-
-      try {
-          // import_from_handover will free (delete) the handover
-          auto sharedRealm = *(reinterpret_cast<SharedRealm*>(callerSharedGrpPtr));
-          if (!sharedRealm->is_closed()) {
-              using rf = realm::_impl::RealmFriend;
-              auto row = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverRow));
-              return reinterpret_cast<jlong>(row.release());
-          } else {
-              ThrowException(env, RuntimeError, ERR_IMPORT_CLOSED_REALM);
-          }
-      } CATCH_STD()
-      return 0;
-  }
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery
-   (JNIEnv* env, jobject, jlong bgSharedRealmPtr, jlong nativeQueryPtr)
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRowIntoSharedGroup(
+    JNIEnv* env, jclass, jlong handoverPtr, jlong callerSharedGrpPtr)
+{
+    TR_ENTER_PTR(handoverPtr)
+    SharedGroup::Handover<Row>* handoverRowPtr = HO(Row, handoverPtr);
+    std::unique_ptr<SharedGroup::Handover<Row>> handoverRow(handoverRowPtr);
+
+    try {
+        // import_from_handover will free (delete) the handover
+        auto sharedRealm = *(reinterpret_cast<SharedRealm*>(callerSharedGrpPtr));
+        if (!sharedRealm->is_closed()) {
+            using rf = realm::_impl::RealmFriend;
+            auto row = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverRow));
+            return reinterpret_cast<jlong>(row.release());
+        }
+        else {
+            ThrowException(env, RuntimeError, ERR_IMPORT_CLOSED_REALM);
+        }
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery(JNIEnv* env, jobject,
+                                                                              jlong bgSharedRealmPtr,
+                                                                              jlong nativeQueryPtr)
 {
     TR_ENTER_PTR(nativeQueryPtr)
     Query* pQuery = Q(nativeQueryPtr);
-    if (!QUERY_VALID(env, pQuery))
+    if (!QUERY_VALID(env, pQuery)) {
         return 0;
+    }
     try {
         auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
         using rf = realm::_impl::RealmFriend;
         auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(*pQuery, ConstSourcePayload::Copy);
         return reinterpret_cast<jlong>(handover.release());
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return 0;
 }
 
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull
-  (JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes) {
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                         jlongArray columnIndexes)
+{
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     Query* pQuery = Q(nativeQueryPtr);
     try {
         TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-        jlong column_idx = arr[arr_len-1];
+        jlong column_idx = arr[arr_len - 1];
         TableRef table_ref = getTableByArray(nativeQueryPtr, arr);
 
         if (!TBL_AND_COL_NULLABLE(env, table_ref.get(), column_idx)) {
@@ -1396,15 +1557,14 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull
                     pQuery->not_equal(S(column_idx), realm::null());
                     break;
                 default:
-                    // this point is unreachable
-                    ThrowException(env, FatalError, "This is not reachable.");
-                    return;
+                    REALM_UNREACHABLE();
             }
         }
         else {
             switch (col_type) {
                 case type_Link:
-                    ThrowException(env, IllegalArgument, "isNotNull() by nested query for link field is not supported.");
+                    ThrowException(env, IllegalArgument,
+                                   "isNotNull() by nested query for link field is not supported.");
                     break;
                 case type_LinkList:
                     // Cannot get here. Exception will be thrown in TBL_AND_COL_NULLABLE
@@ -1432,16 +1592,16 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull
                     pQuery->and_query(src_table_ref->column<Timestamp>(S(column_idx)) != realm::null());
                     break;
                 default:
-                    // this point is unreachable
-                    ThrowException(env, FatalError, "This is not reachable.");
-                    return;
+                    REALM_UNREACHABLE();
             }
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty
-    (JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes) {
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                       jlongArray columnIndexes)
+{
 
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
@@ -1494,11 +1654,13 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty
                 case type_Double:
                 case type_Timestamp:
                 default:
-                    ThrowException(env, IllegalArgument, "isEmpty() only works on String, byte[] and RealmList across links.");
+                    ThrowException(env, IllegalArgument,
+                                   "isEmpty() only works on String, byte[] and RealmList across links.");
                     return;
             }
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
 static void finalize_table_query(jlong ptr)
@@ -1507,8 +1669,7 @@ static void finalize_table_query(jlong ptr)
     delete Q(ptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetFinalizerPtr
-  (JNIEnv *, jclass)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetFinalizerPtr(JNIEnv*, jclass)
 {
     TR_ENTER()
     return reinterpret_cast<jlong>(&finalize_table_query);
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp
index a5b34275c4..6eab915b78 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp
@@ -1,28 +1,25 @@
 #include "io_realm_internal_TestUtil.h"
 #include "util.hpp"
 
-static jstring throwOrGetExpectedMessage(JNIEnv *env, jlong testcase, bool should_throw);
+static jstring throwOrGetExpectedMessage(JNIEnv* env, jlong testcase, bool should_throw);
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_TestUtil_getMaxExceptionNumber(JNIEnv*, jclass)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TestUtil_getMaxExceptionNumber(JNIEnv*, jclass)
 {
     return ExceptionKindMax;
 }
 
-JNIEXPORT jstring JNICALL
-Java_io_realm_internal_TestUtil_getExpectedMessage(JNIEnv *env, jclass, jlong exception_kind)
+JNIEXPORT jstring JNICALL Java_io_realm_internal_TestUtil_getExpectedMessage(JNIEnv* env, jclass,
+                                                                             jlong exception_kind)
 {
     return throwOrGetExpectedMessage(env, exception_kind, false);
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_TestUtil_testThrowExceptions(JNIEnv *env, jclass, jlong exception_kind)
+JNIEXPORT void JNICALL Java_io_realm_internal_TestUtil_testThrowExceptions(JNIEnv* env, jclass, jlong exception_kind)
 {
     throwOrGetExpectedMessage(env, exception_kind, true);
 }
 
-static jstring
-throwOrGetExpectedMessage(JNIEnv *env, jlong testcase, bool should_throw)
+static jstring throwOrGetExpectedMessage(JNIEnv* env, jlong testcase, bool should_throw)
 {
     std::string expect;
 
@@ -79,7 +76,7 @@ throwOrGetExpectedMessage(JNIEnv *env, jlong testcase, bool should_throw)
             break;
     }
     if (should_throw) {
-        return NULL;
+        return nullptr;
     }
     return to_jstring(env, expect);
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
index b55fdc68e2..bdb36b7709 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
@@ -21,269 +21,306 @@ using namespace realm;
 
 static void finalize_unchecked_row(jlong ptr);
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnCount
-  (JNIEnv*, jobject, jlong nativeRowPtr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnCount(JNIEnv*, jobject, jlong nativeRowPtr)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW(nativeRowPtr)->is_attached())
+    if (!ROW(nativeRowPtr)->is_attached()) {
         return 0;
+    }
 
-    return ROW(nativeRowPtr)->get_column_count(); // noexcept
+    return static_cast<jlong>(ROW(nativeRowPtr)->get_column_count()); // noexcept
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnName
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnName(JNIEnv* env, jobject,
+                                                                                  jlong nativeRowPtr,
+                                                                                  jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return 0;
+    }
 
     try {
-        return to_jstring(env, ROW(nativeRowPtr)->get_column_name( S(columnIndex)));
-    } CATCH_STD();
+        return to_jstring(env, ROW(nativeRowPtr)->get_column_name(S(columnIndex)));
+    }
+    CATCH_STD();
     return NULL;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnIndex
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jstring columnName)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnIndex(JNIEnv* env, jobject,
+                                                                                 jlong nativeRowPtr,
+                                                                                 jstring columnName)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW(nativeRowPtr)->is_attached())
+    if (!ROW(nativeRowPtr)->is_attached()) {
         return 0;
+    }
 
     try {
-        JStringAccessor columnName2(env, columnName); // throws
-        return to_jlong_or_not_found( ROW(nativeRowPtr)->get_column_index(columnName2) ); // noexcept
-    } CATCH_STD()
+        JStringAccessor columnName2(env, columnName);                                   // throws
+        return to_jlong_or_not_found(ROW(nativeRowPtr)->get_column_index(columnName2)); // noexcept
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnType
-  (JNIEnv*, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnType(JNIEnv*, jobject, jlong nativeRowPtr,
+                                                                               jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    return static_cast<jint>( ROW(nativeRowPtr)->get_column_type( S(columnIndex)) ); // noexcept
+    return static_cast<jint>(ROW(nativeRowPtr)->get_column_type(S(columnIndex))); // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetIndex
-  (JNIEnv* env, jobject, jlong nativeRowPtr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetIndex(JNIEnv* env, jobject, jlong nativeRowPtr)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return 0;
+    }
 
-    return ROW(nativeRowPtr)->get_index();
+    return static_cast<jlong>(ROW(nativeRowPtr)->get_index());
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLong
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLong(JNIEnv* env, jobject, jlong nativeRowPtr,
+                                                                          jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return 0;
+    }
 
-    return ROW(nativeRowPtr)->get_int( S(columnIndex) );
+    return ROW(nativeRowPtr)->get_int(S(columnIndex));
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeGetBoolean
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeGetBoolean(JNIEnv* env, jobject,
+                                                                                jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return 0;
+    }
 
-    return ROW(nativeRowPtr)->get_bool( S(columnIndex) );
+    return to_jbool(ROW(nativeRowPtr)->get_bool(S(columnIndex)));
 }
 
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_UncheckedRow_nativeGetFloat
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jfloat JNICALL Java_io_realm_internal_UncheckedRow_nativeGetFloat(JNIEnv* env, jobject, jlong nativeRowPtr,
+                                                                            jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return 0;
+    }
 
-    return ROW(nativeRowPtr)->get_float( S(columnIndex) );
+    return ROW(nativeRowPtr)->get_float(S(columnIndex));
 }
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDouble
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDouble(JNIEnv* env, jobject,
+                                                                              jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return 0;
+    }
 
-    return ROW(nativeRowPtr)->get_double( S(columnIndex) );
+    return ROW(nativeRowPtr)->get_double(S(columnIndex));
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetTimestamp
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetTimestamp(JNIEnv* env, jobject,
+                                                                               jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return 0;
+    }
 
-    return to_milliseconds(ROW(nativeRowPtr)->get_timestamp( S(columnIndex) ));
+    return to_milliseconds(ROW(nativeRowPtr)->get_timestamp(S(columnIndex)));
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetString
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetString(JNIEnv* env, jobject,
+                                                                              jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
-        return 0;
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
+        return nullptr;
+    }
 
     try {
-        StringData value = ROW(nativeRowPtr)->get_string( S(columnIndex) );
-        return to_jstring(env,  value);
-    } CATCH_STD()
-    return NULL;
+        StringData value = ROW(nativeRowPtr)->get_string(S(columnIndex));
+        return to_jstring(env, value);
+    }
+    CATCH_STD()
+    return nullptr;
 }
 
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_UncheckedRow_nativeGetByteArray
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_UncheckedRow_nativeGetByteArray(JNIEnv* env, jobject,
+                                                                                    jlong nativeRowPtr,
+                                                                                    jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
-        return 0;
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
+        return nullptr;
+    }
 
-    BinaryData bin = ROW(nativeRowPtr)->get_binary( S(columnIndex) );
+    BinaryData bin = ROW(nativeRowPtr)->get_binary(S(columnIndex));
     if (bin.is_null()) {
-        return NULL;
+        return nullptr;
     }
     else if (bin.size() <= MAX_JSIZE) {
         jbyteArray jresult = env->NewByteArray(static_cast<jsize>(bin.size()));
-        if (jresult)
-            env->SetByteArrayRegion(jresult, 0, static_cast<jsize>(bin.size()), reinterpret_cast<const jbyte*>(bin.data()));  // throws
+        if (jresult) {
+            env->SetByteArrayRegion(jresult, 0, static_cast<jsize>(bin.size()),
+                                    reinterpret_cast<const jbyte*>(bin.data())); // throws
+        }
         return jresult;
     }
     else {
         ThrowException(env, IllegalArgument, "Length of ByteArray is larger than an Int.");
-        return NULL;
+        return nullptr;
     }
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLink
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLink(JNIEnv* env, jobject, jlong nativeRowPtr,
+                                                                          jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return 0;
+    }
 
-    if (ROW(nativeRowPtr)->is_null_link( S(columnIndex) ))
+    if (ROW(nativeRowPtr)->is_null_link(S(columnIndex))) {
         return jlong(-1);
+    }
 
-    return ROW(nativeRowPtr)->get_link( S(columnIndex) );
+    return static_cast<jlong>(ROW(nativeRowPtr)->get_link(S(columnIndex)));
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNullLink
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNullLink(JNIEnv* env, jobject,
+                                                                                jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return 0;
+    }
 
-    return ROW(nativeRowPtr)->is_null_link( S(columnIndex) );
+    return to_jbool(ROW(nativeRowPtr)->is_null_link(S(columnIndex)));
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView(JNIEnv* env, jobject,
+                                                                              jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return 0;
+    }
 
-    LinkViewRef* link_view_ptr = const_cast<LinkViewRef*>(&(LangBindHelper::get_linklist_ptr(*ROW(nativeRowPtr), S(columnIndex))));
+    LinkViewRef* link_view_ptr =
+        const_cast<LinkViewRef*>(&(LangBindHelper::get_linklist_ptr(*ROW(nativeRowPtr), S(columnIndex))));
     return reinterpret_cast<jlong>(link_view_ptr);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLong
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLong(JNIEnv* env, jobject, jlong nativeRowPtr,
+                                                                         jlong columnIndex, jlong value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return;
+    }
 
     try {
-        ROW(nativeRowPtr)->set_int( S(columnIndex), value);
-    } CATCH_STD()
+        ROW(nativeRowPtr)->set_int(S(columnIndex), value);
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetBoolean
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jboolean value)
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetBoolean(JNIEnv* env, jobject, jlong nativeRowPtr,
+                                                                            jlong columnIndex, jboolean value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return;
+    }
 
     try {
-        ROW(nativeRowPtr)->set_bool( S(columnIndex), value);
-    } CATCH_STD()
+        ROW(nativeRowPtr)->set_bool(S(columnIndex), value);
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetFloat
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jfloat value)
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetFloat(JNIEnv* env, jobject, jlong nativeRowPtr,
+                                                                          jlong columnIndex, jfloat value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return;
+    }
 
     try {
-        ROW(nativeRowPtr)->set_float( S(columnIndex), value);
-    } CATCH_STD()
+        ROW(nativeRowPtr)->set_float(S(columnIndex), value);
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDouble
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jdouble value)
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDouble(JNIEnv* env, jobject, jlong nativeRowPtr,
+                                                                           jlong columnIndex, jdouble value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return;
+    }
 
     try {
-        ROW(nativeRowPtr)->set_double( S(columnIndex), value);
-    } CATCH_STD()
+        ROW(nativeRowPtr)->set_double(S(columnIndex), value);
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetTimestamp
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetTimestamp(JNIEnv* env, jobject,
+                                                                              jlong nativeRowPtr, jlong columnIndex,
+                                                                              jlong value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return;
+    }
 
     try {
-        ROW(nativeRowPtr)->set_timestamp( S(columnIndex), from_milliseconds(value));
-    } CATCH_STD()
+        ROW(nativeRowPtr)->set_timestamp(S(columnIndex), from_milliseconds(value));
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetString
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jstring value)
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetString(JNIEnv* env, jobject, jlong nativeRowPtr,
+                                                                           jlong columnIndex, jstring value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return;
+    }
 
     try {
-        if ((value == NULL) && !(ROW(nativeRowPtr)->get_table()->is_nullable( S(columnIndex) ))) {
+        if ((value == nullptr) && !(ROW(nativeRowPtr)->get_table()->is_nullable(S(columnIndex)))) {
             ThrowNullValueException(env, ROW(nativeRowPtr)->get_table(), S(columnIndex));
             return;
         }
         JStringAccessor value2(env, value); // throws
-        ROW(nativeRowPtr)->set_string( S(columnIndex), value2);
-    } CATCH_STD()
+        ROW(nativeRowPtr)->set_string(S(columnIndex), value2);
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetByteArray
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jbyteArray value)
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetByteArray(JNIEnv* env, jobject,
+                                                                              jlong nativeRowPtr, jlong columnIndex,
+                                                                              jbyteArray value)
 {
     TR_ENTER_PTR(nativeRowPtr)
 
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return;
+    }
 
-    jbyte* bytePtr = NULL;
+    jbyte* bytePtr = nullptr;
     try {
-        if (value == NULL) {
+        if (value == nullptr) {
             if (!(ROW(nativeRowPtr)->get_table()->is_nullable(S(columnIndex)))) {
                 ThrowNullValueException(env, ROW(nativeRowPtr)->get_table(), S(columnIndex));
                 return;
@@ -297,69 +334,78 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetByteArray
                 return;
             }
             size_t dataLen = S(env->GetArrayLength(value));
-            ROW(nativeRowPtr)->set_binary( S(columnIndex), BinaryData(reinterpret_cast<char*>(bytePtr), dataLen));
+            ROW(nativeRowPtr)->set_binary(S(columnIndex), BinaryData(reinterpret_cast<char*>(bytePtr), dataLen));
         }
-    } CATCH_STD()
+    }
+    CATCH_STD()
 
     if (bytePtr) {
         env->ReleaseByteArrayElements(value, bytePtr, JNI_ABORT);
     }
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLink
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLink(JNIEnv* env, jobject, jlong nativeRowPtr,
+                                                                         jlong columnIndex, jlong value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return;
+    }
 
     try {
-        ROW(nativeRowPtr)->set_link( S(columnIndex), value);
-    } CATCH_STD()
+        ROW(nativeRowPtr)->set_link(S(columnIndex), value);
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeNullifyLink
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeNullifyLink(JNIEnv* env, jobject, jlong nativeRowPtr,
+                                                                             jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return;
+    }
 
     try {
-        ROW(nativeRowPtr)->nullify_link( S(columnIndex) );
-    } CATCH_STD()
+        ROW(nativeRowPtr)->nullify_link(S(columnIndex));
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsAttached
-  (JNIEnv*, jobject, jlong nativeRowPtr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsAttached(JNIEnv*, jobject, jlong nativeRowPtr)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    return ROW(nativeRowPtr)->is_attached();
+    return to_jbool(ROW(nativeRowPtr)->is_attached());
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeHasColumn
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jstring columnName)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeHasColumn(JNIEnv* env, jobject obj,
+                                                                               jlong nativeRowPtr, jstring columnName)
 {
     jlong ndx = Java_io_realm_internal_UncheckedRow_nativeGetColumnIndex(env, obj, nativeRowPtr, columnName);
-    return ndx != to_jlong_or_not_found(realm::not_found);
+    return to_jbool(ndx != to_jlong_or_not_found(realm::not_found));
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNull
-  (JNIEnv*, jobject, jlong nativeRowPtr, jlong columnIndex) {
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNull(JNIEnv*, jobject, jlong nativeRowPtr,
+                                                                            jlong columnIndex)
+{
     TR_ENTER_PTR(nativeRowPtr)
-    return ROW(nativeRowPtr)->is_null(columnIndex);
+    return to_jbool(ROW(nativeRowPtr)->is_null(columnIndex));
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetNull
-  (JNIEnv *env, jobject, jlong nativeRowPtr, jlong columnIndex) {
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetNull(JNIEnv* env, jobject, jlong nativeRowPtr,
+                                                                         jlong columnIndex)
+{
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
         return;
-    if (!TBL_AND_COL_NULLABLE(env, ROW(nativeRowPtr)->get_table(), columnIndex))
+    }
+    if (!TBL_AND_COL_NULLABLE(env, ROW(nativeRowPtr)->get_table(), columnIndex)) {
         return;
+    }
     try {
         ROW(nativeRowPtr)->set_null(columnIndex);
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
 static void finalize_unchecked_row(jlong ptr)
@@ -368,10 +414,8 @@ static void finalize_unchecked_row(jlong ptr)
     delete ROW(ptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetFinalizerPtr
-  (JNIEnv *, jclass)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetFinalizerPtr(JNIEnv*, jclass)
 {
     TR_ENTER()
     return reinterpret_cast<jlong>(&finalize_unchecked_row);
 }
-
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
index fbd421bc9b..070de208b9 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
@@ -29,7 +29,7 @@ using namespace realm::jni_util;
 
 //#define USE_VLD
 #if defined(_MSC_VER) && defined(_DEBUG) && defined(USE_VLD)
-    #include "C:\\Program Files (x86)\\Visual Leak Detector\\include\\vld.h"
+#include "C:\\Program Files (x86)\\Visual Leak Detector\\include\\vld.h"
 #endif
 
 const string TABLE_PREFIX("class_");
@@ -38,25 +38,24 @@ const string TABLE_PREFIX("class_");
 JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
 {
     JNIEnv* env;
-    if (vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
+    if (vm->GetEnv((void**)&env, JNI_VERSION_1_6) != JNI_OK) {
         return JNI_ERR;
     }
     else {
         JniUtils::initialize(vm, JNI_VERSION_1_6);
         // Loading classes and constructors for later use - used by box typed fields and a few methods' return value
-        java_lang_long        = GetClass(env, "java/lang/Long");
-        java_lang_long_init   = env->GetMethodID(java_lang_long, "<init>", "(J)V");
-        java_lang_float       = GetClass(env, "java/lang/Float");
-        java_lang_float_init  = env->GetMethodID(java_lang_float, "<init>", "(F)V");
-        java_lang_double      = GetClass(env, "java/lang/Double");
-        java_lang_string      = GetClass(env, "java/lang/String");
+        java_lang_long = GetClass(env, "java/lang/Long");
+        java_lang_long_init = env->GetMethodID(java_lang_long, "<init>", "(J)V");
+        java_lang_float = GetClass(env, "java/lang/Float");
+        java_lang_float_init = env->GetMethodID(java_lang_float, "<init>", "(F)V");
+        java_lang_double = GetClass(env, "java/lang/Double");
+        java_lang_string = GetClass(env, "java/lang/String");
         java_lang_double_init = env->GetMethodID(java_lang_double, "<init>", "(D)V");
-        java_util_date        = GetClass(env, "java/util/Date");
-        java_util_date_init   = env->GetMethodID(java_util_date, "<init>", "(J)V");
+        java_util_date = GetClass(env, "java/util/Date");
+        java_util_date_init = env->GetMethodID(java_util_date, "<init>", "(J)V");
 #if REALM_ENABLE_SYNC
         java_syncmanager = GetClass(env, "io/realm/SyncManager");
 #endif
-
     }
 
     return JNI_VERSION_1_6;
@@ -65,7 +64,7 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
 JNIEXPORT void JNI_OnUnload(JavaVM* vm, void*)
 {
     JNIEnv* env;
-    if (vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
+    if (vm->GetEnv((void**)&env, JNI_VERSION_1_6) != JNI_OK) {
         return;
     }
     else {
@@ -83,11 +82,10 @@ JNIEXPORT void JNI_OnUnload(JavaVM* vm, void*)
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Util_nativeGetMemUsage(JNIEnv*, jclass)
 {
-    return GetMemUsage();
+    return static_cast<jlong>(GetMemUsage());
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeGetTablePrefix(
-    JNIEnv* env, jclass)
+JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeGetTablePrefix(JNIEnv* env, jclass)
 {
     realm::StringData sd(TABLE_PREFIX);
     return to_jstring(env, sd);
diff --git a/realm/realm-library/src/main/cpp/io_realm_log_RealmLog.cpp b/realm/realm-library/src/main/cpp/io_realm_log_RealmLog.cpp
index 45aa8a72c2..d18455b97b 100644
--- a/realm/realm-library/src/main/cpp/io_realm_log_RealmLog.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_log_RealmLog.cpp
@@ -21,64 +21,64 @@
 using namespace realm::util;
 using namespace realm::jni_util;
 
-JNIEXPORT void JNICALL
-Java_io_realm_log_RealmLog_nativeAddLogger(JNIEnv *env, jclass, jobject java_logger)
+JNIEXPORT void JNICALL Java_io_realm_log_RealmLog_nativeAddLogger(JNIEnv* env, jclass, jobject java_logger)
 {
     try {
         Log::shared().add_java_logger(env, java_logger);
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_log_RealmLog_nativeRemoveLogger(JNIEnv *env, jclass, jobject java_logger)
+JNIEXPORT void JNICALL Java_io_realm_log_RealmLog_nativeRemoveLogger(JNIEnv* env, jclass, jobject java_logger)
 {
     try {
         Log::shared().remove_java_logger(env, java_logger);
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_log_RealmLog_nativeClearLoggers(JNIEnv *env, jclass)
+JNIEXPORT void JNICALL Java_io_realm_log_RealmLog_nativeClearLoggers(JNIEnv* env, jclass)
 {
     try {
         Log::shared().clear_loggers();
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_log_RealmLog_nativeRegisterDefaultLogger(JNIEnv *env, jclass)
+JNIEXPORT void JNICALL Java_io_realm_log_RealmLog_nativeRegisterDefaultLogger(JNIEnv* env, jclass)
 {
     try {
         Log::shared().register_default_logger();
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_log_RealmLog_nativeLog(JNIEnv *env, jclass, jint level, jstring tag, jthrowable throwable,
-                                     jstring message)
+JNIEXPORT void JNICALL Java_io_realm_log_RealmLog_nativeLog(JNIEnv* env, jclass, jint level, jstring tag,
+                                                            jthrowable throwable, jstring message)
 {
     try {
         JStringAccessor tag_accessor(env, tag);
         JStringAccessor message_accessor(env, message);
         Log::shared().log(static_cast<Log::Level>(level), std::string(tag_accessor).c_str(), throwable,
                           std::string(message_accessor).c_str());
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_log_RealmLog_nativeSetLogLevel(JNIEnv *env, jclass, jint level)
+JNIEXPORT void JNICALL Java_io_realm_log_RealmLog_nativeSetLogLevel(JNIEnv* env, jclass, jint level)
 {
     try {
         Log::shared().set_level(static_cast<Log::Level>(level));
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT jint JNICALL
-Java_io_realm_log_RealmLog_nativeGetLogLevel(JNIEnv *env, jclass)
+JNIEXPORT jint JNICALL Java_io_realm_log_RealmLog_nativeGetLogLevel(JNIEnv* env, jclass)
 {
     try {
         return static_cast<jint>(Log::shared().get_level());
-    } CATCH_STD()
+    }
+    CATCH_STD()
 
     return static_cast<jint>(Log::Level::all);
 }
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.cpp b/realm/realm-library/src/main/cpp/java_binding_context.cpp
index 525c70fc36..7c4480d004 100644
--- a/realm/realm-library/src/main/cpp/java_binding_context.cpp
+++ b/realm/realm-library/src/main/cpp/java_binding_context.cpp
@@ -29,7 +29,7 @@ void JavaBindingContext::before_notify()
         return;
     }
     if (m_java_notifier) {
-        m_java_notifier.call_with_local_ref([&] (JNIEnv* env, jobject notifier_obj) {
+        m_java_notifier.call_with_local_ref([&](JNIEnv* env, jobject notifier_obj) {
             // Method IDs from RealmNotifier implementation. Cache them as member vars.
             static JavaMethod notify_by_other_method(env, notifier_obj, "beforeNotify", "()V");
             env->CallVoidMethod(notifier_obj, notify_by_other_method);
@@ -37,9 +37,8 @@ void JavaBindingContext::before_notify()
     }
 }
 
-void JavaBindingContext::did_change(std::vector<BindingContext::ObserverState> const&,
-                        std::vector<void*> const&,
-                        bool version_changed)
+void JavaBindingContext::did_change(std::vector<BindingContext::ObserverState> const&, std::vector<void*> const&,
+                                    bool version_changed)
 {
     auto env = JniUtils::get_env();
 
@@ -47,10 +46,9 @@ void JavaBindingContext::did_change(std::vector<BindingContext::ObserverState> c
         return;
     }
     if (version_changed) {
-        m_java_notifier.call_with_local_ref(env, [&] (JNIEnv*, jobject notifier_obj) {
+        m_java_notifier.call_with_local_ref(env, [&](JNIEnv*, jobject notifier_obj) {
             static JavaMethod realm_notifier_did_change_method(env, notifier_obj, "didChange", "()V");
             env->CallVoidMethod(notifier_obj, realm_notifier_did_change_method);
         });
     }
 }
-
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.hpp b/realm/realm-library/src/main/cpp/java_binding_context.hpp
index a459058c36..de3a15c62c 100644
--- a/realm/realm-library/src/main/cpp/java_binding_context.hpp
+++ b/realm/realm-library/src/main/cpp/java_binding_context.hpp
@@ -41,14 +41,15 @@ class JavaBindingContext final : public BindingContext {
     jni_util::JavaGlobalWeakRef m_java_notifier;
 
 public:
-    virtual ~JavaBindingContext() { };
+    virtual ~JavaBindingContext(){};
     virtual void before_notify();
-    virtual void did_change(std::vector<ObserverState> const& observers,
-                            std::vector<void*> const& invalidated,
-                            bool version_changed=true);
+    virtual void did_change(std::vector<ObserverState> const& observers, std::vector<void*> const& invalidated,
+                            bool version_changed = true);
 
     explicit JavaBindingContext(const ConcreteJavaBindContext& concrete_context)
-            : m_java_notifier(concrete_context.jni_env, concrete_context.java_notifier) { }
+        : m_java_notifier(concrete_context.jni_env, concrete_context.java_notifier)
+    {
+    }
     JavaBindingContext(const JavaBindingContext&) = delete;
     JavaBindingContext& operator=(const JavaBindingContext&) = delete;
     JavaBindingContext(JavaBindingContext&&) = delete;
@@ -65,4 +66,3 @@ class JavaBindingContext final : public BindingContext {
 } // namespace realm
 
 #endif
-
diff --git a/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp b/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp
index 5c894bc73f..b26c76309b 100644
--- a/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp
+++ b/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp
@@ -35,9 +35,8 @@ JavaSortDescriptor::operator realm::SortDescriptor() const noexcept
     static JavaMethod getTablePtr(m_env, m_sort_desc_obj, "getTablePtr", "()J");
 
     jobjectArray column_indices =
-            static_cast<jobjectArray>(m_env->CallObjectMethod(m_sort_desc_obj, getColumnIndices));
-    jbooleanArray ascendings =
-            static_cast<jbooleanArray >(m_env->CallObjectMethod(m_sort_desc_obj, getAscendings));
+        static_cast<jobjectArray>(m_env->CallObjectMethod(m_sort_desc_obj, getColumnIndices));
+    jbooleanArray ascendings = static_cast<jbooleanArray>(m_env->CallObjectMethod(m_sort_desc_obj, getAscendings));
     jlong table_ptr = m_env->CallLongMethod(m_sort_desc_obj, getTablePtr);
 
     JniArrayOfArrays<JniLongArray, jlongArray> arrays(m_env, column_indices);
@@ -51,7 +50,7 @@ JavaSortDescriptor::operator realm::SortDescriptor() const noexcept
         JniLongArray& jni_long_array = arrays[i];
         std::vector<size_t> col_indices;
         for (int j = 0; j < jni_long_array.len(); ++j) {
-            col_indices.push_back(static_cast<size_t >(jni_long_array[j]));
+            col_indices.push_back(static_cast<size_t>(jni_long_array[j]));
         }
         indices.push_back(std::move(col_indices));
         if (ascendings) {
@@ -59,9 +58,7 @@ JavaSortDescriptor::operator realm::SortDescriptor() const noexcept
         }
     }
 
-    return ascendings ?
-           SortDescriptor(*reinterpret_cast<Table*>(table_ptr), std::move(indices), std::move(ascending_list))
-                      : SortDescriptor(*reinterpret_cast<Table*>(table_ptr), std::move(indices));
+    return ascendings
+               ? SortDescriptor(*reinterpret_cast<Table*>(table_ptr), std::move(indices), std::move(ascending_list))
+               : SortDescriptor(*reinterpret_cast<Table*>(table_ptr), std::move(indices));
 }
-
-
diff --git a/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp b/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp
index 613b16ece7..39c175254c 100644
--- a/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp
+++ b/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp
@@ -30,7 +30,11 @@ namespace _impl {
 // doesn't make too much sense and causes troubles with memory management.
 class JavaSortDescriptor {
 public:
-    JavaSortDescriptor(JNIEnv* env, jobject sort_desc_obj) : m_env(env), m_sort_desc_obj(sort_desc_obj) {}
+    JavaSortDescriptor(JNIEnv* env, jobject sort_desc_obj)
+        : m_env(env)
+        , m_sort_desc_obj(sort_desc_obj)
+    {
+    }
 
     JavaSortDescriptor(const JavaSortDescriptor&) = delete;
     JavaSortDescriptor& operator=(const JavaSortDescriptor&) = delete;
@@ -46,4 +50,4 @@ class JavaSortDescriptor {
 
 } // namespace _impl
 } // namespace realm
-#endif //JAVA_SORT_DESCRIPTOR_HPP
+#endif // JAVA_SORT_DESCRIPTOR_HPP
diff --git a/realm/realm-library/src/main/cpp/jni_impl/android_logger.cpp b/realm/realm-library/src/main/cpp/jni_impl/android_logger.cpp
index b50ff1902a..8e3972aea0 100644
--- a/realm/realm-library/src/main/cpp/jni_impl/android_logger.cpp
+++ b/realm/realm-library/src/main/cpp/jni_impl/android_logger.cpp
@@ -32,7 +32,8 @@ std::shared_ptr<AndroidLogger> AndroidLogger::shared()
     return android_logger;
 }
 
-void AndroidLogger::log(Log::Level level, const char* tag, jthrowable, const char* message) {
+void AndroidLogger::log(Log::Level level, const char* tag, jthrowable, const char* message)
+{
     android_LogPriority android_log_priority;
     switch (level) {
         case Log::Level::trace:
@@ -53,7 +54,7 @@ void AndroidLogger::log(Log::Level level, const char* tag, jthrowable, const cha
         case Log::Level::fatal:
             android_log_priority = ANDROID_LOG_FATAL;
             break;
-        default:// Cannot get here.
+        default: // Cannot get here.
             throw std::invalid_argument(format("Invalid log level: %1.", level));
     }
     if (message) {
@@ -74,7 +75,8 @@ void AndroidLogger::print(android_LogPriority priority, const char* tag, const c
             __android_log_write(priority, tag, tmp_str.c_str());
             start += count;
         }
-    } else {
+    }
+    else {
         __android_log_write(priority, tag, log_string);
     }
 }
@@ -86,8 +88,5 @@ std::shared_ptr<JniLogger> get_default_logger()
 {
     return std::static_pointer_cast<JniLogger>(AndroidLogger::shared());
 }
-
 }
 }
-
-
diff --git a/realm/realm-library/src/main/cpp/jni_impl/android_logger.hpp b/realm/realm-library/src/main/cpp/jni_impl/android_logger.hpp
index 6b90c0f6c6..53bd485407 100644
--- a/realm/realm-library/src/main/cpp/jni_impl/android_logger.hpp
+++ b/realm/realm-library/src/main/cpp/jni_impl/android_logger.hpp
@@ -23,7 +23,7 @@
 namespace realm {
 namespace jni_impl {
 
-//Default logger implementation for Android.
+// Default logger implementation for Android.
 class AndroidLogger : public realm::jni_util::JniLogger {
 public:
     static std::shared_ptr<AndroidLogger> shared();
@@ -32,11 +32,10 @@ class AndroidLogger : public realm::jni_util::JniLogger {
     void log(realm::jni_util::Log::Level level, const char* tag, jthrowable throwable, const char* message) override;
 
 private:
-    AndroidLogger() {};
+    AndroidLogger(){};
     static void print(android_LogPriority priority, const char* tag, const char* log_string);
     static const size_t LOG_ENTRY_MAX_LENGTH = 4000;
 };
-
 }
 }
 
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.cpp b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.cpp
index ceac7d8466..10718df40c 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.cpp
@@ -38,4 +38,3 @@ bool JavaGlobalWeakRef::call_with_local_ref(std::function<Callback> callback)
 {
     return call_with_local_ref(JniUtils::get_env(), callback);
 }
-
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp
index 59b50c36b0..4e6c60df56 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp
@@ -28,8 +28,14 @@ namespace jni_util {
 // RAII wrapper for weak global ref.
 class JavaGlobalWeakRef {
 public:
-    JavaGlobalWeakRef() : m_weak(nullptr) {}
-    JavaGlobalWeakRef(JNIEnv* env, jobject obj) : m_weak(obj ? env->NewWeakGlobalRef(obj) : nullptr) { }
+    JavaGlobalWeakRef()
+        : m_weak(nullptr)
+    {
+    }
+    JavaGlobalWeakRef(JNIEnv* env, jobject obj)
+        : m_weak(obj ? env->NewWeakGlobalRef(obj) : nullptr)
+    {
+    }
     ~JavaGlobalWeakRef()
     {
         if (m_weak) {
@@ -37,10 +43,15 @@ class JavaGlobalWeakRef {
         }
     }
 
-    JavaGlobalWeakRef(JavaGlobalWeakRef&& rhs) : m_weak(rhs.m_weak) { rhs.m_weak = nullptr; }
-    JavaGlobalWeakRef& operator=(JavaGlobalWeakRef&& rhs) {
+    JavaGlobalWeakRef(JavaGlobalWeakRef&& rhs)
+        : m_weak(rhs.m_weak)
+    {
+        rhs.m_weak = nullptr;
+    }
+    JavaGlobalWeakRef& operator=(JavaGlobalWeakRef&& rhs)
+    {
         this->~JavaGlobalWeakRef();
-        new(this) JavaGlobalWeakRef(std::move(rhs));
+        new (this) JavaGlobalWeakRef(std::move(rhs));
         return *this;
     }
 
@@ -68,4 +79,3 @@ class JavaGlobalWeakRef {
 } // namespace realm
 
 #endif // REALM_JNI_UTIL_JAVA_GLOBAL_WEAK_REF_HPP
-
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
index 7b38bb69a8..283c948fba 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
@@ -22,29 +22,43 @@
 namespace realm {
 namespace jni_util {
 
-struct NeedToCreateLocalRef {};
+struct NeedToCreateLocalRef {
+};
 static constexpr NeedToCreateLocalRef need_to_create_local_ref{};
 
 // Wraps jobject and automatically calls DeleteLocalRef when this object is destroyed.
 // DeleteLocalRef is not necessary to be called in most cases since all local references will be cleaned up when the
-// program returns to Java from native. But if the local ref is created in a loop, consider to use this class to wrap it
+// program returns to Java from native. But if the local ref is created in a loop, consider to use this class to wrap
+// it
 // because the size of local reference table is relative small (512 bytes on Android).
 template <typename T>
 class JavaLocalRef {
 public:
     // need_to_create is useful when acquire a local ref from a global weak ref.
-    inline JavaLocalRef(JNIEnv* env, T obj) noexcept : m_jobject(obj), m_env(env) {};
+    inline JavaLocalRef(JNIEnv* env, T obj) noexcept
+        : m_jobject(obj)
+        , m_env(env){};
     inline JavaLocalRef(JNIEnv* env, T obj, NeedToCreateLocalRef) noexcept
-            : m_jobject(env->NewLocalRef(obj)), m_env(env) {};
-    inline ~JavaLocalRef() { m_env->DeleteLocalRef(m_jobject); }
+        : m_jobject(env->NewLocalRef(obj))
+        , m_env(env){};
+    inline ~JavaLocalRef()
+    {
+        m_env->DeleteLocalRef(m_jobject);
+    }
 
     JavaLocalRef(const JavaLocalRef&) = delete;
     JavaLocalRef& operator=(const JavaLocalRef&) = delete;
     JavaLocalRef(JavaLocalRef&& rhs) = delete;
     JavaLocalRef& operator=(JavaLocalRef&& rhs) = delete;
 
-    inline operator bool() const noexcept { return m_jobject != nullptr; };
-    inline operator T() const noexcept { return m_jobject; }
+    inline operator bool() const noexcept
+    {
+        return m_jobject != nullptr;
+    };
+    inline operator T() const noexcept
+    {
+        return m_jobject;
+    }
 
 private:
     T m_jobject;
@@ -54,4 +68,3 @@ class JavaLocalRef {
 } // namespace realm
 } // namespace jni_util
 #endif // REALM_JNI_UTIL_JAVA_LOCAL_REF_HPP
-
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_method.hpp b/realm/realm-library/src/main/cpp/jni_util/java_method.hpp
index d6829d9871..d582399fd3 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_method.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_method.hpp
@@ -26,20 +26,32 @@ namespace jni_util {
 // safe to have a static JavaMethod object to avoid calling GetMethodID multiple times.
 class JavaMethod {
 public:
-    JavaMethod() : m_method_id(nullptr) {}
-    JavaMethod(JNIEnv *env, jclass cls, const char* method_name, const char* signature, bool static_method = false);
-    JavaMethod(JNIEnv *env, jobject obj, const char* method_name, const char* signature);
-    JavaMethod(JNIEnv *env, const char* class_name, const char* method_name, const char* signature, bool static_method = false);
+    JavaMethod()
+        : m_method_id(nullptr)
+    {
+    }
+    JavaMethod(JNIEnv* env, jclass cls, const char* method_name, const char* signature, bool static_method = false);
+    JavaMethod(JNIEnv* env, jobject obj, const char* method_name, const char* signature);
+    JavaMethod(JNIEnv* env, const char* class_name, const char* method_name, const char* signature,
+               bool static_method = false);
 
     JavaMethod(const JavaMethod&) = default;
     JavaMethod& operator=(const JavaMethod&) = default;
     JavaMethod(JavaMethod&& rhs) = delete;
     JavaMethod& operator=(JavaMethod&& rhs) = delete;
 
-    ~JavaMethod() { }
+    ~JavaMethod()
+    {
+    }
 
-    inline operator bool() const noexcept { return m_method_id != nullptr; }
-    inline operator const jmethodID&() const noexcept { return m_method_id; }
+    inline operator bool() const noexcept
+    {
+        return m_method_id != nullptr;
+    }
+    inline operator const jmethodID&() const noexcept
+    {
+        return m_method_id;
+    }
 
 private:
     jmethodID m_method_id;
@@ -48,4 +60,4 @@ class JavaMethod {
 } // namespace realm
 } // namespace jni_util
 
-#endif //REALM_JNI_UTIL_JAVA_METHOD_HPP
+#endif // REALM_JNI_UTIL_JAVA_METHOD_HPP
diff --git a/realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp b/realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp
index 64088750ca..88a23ebb01 100644
--- a/realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp
@@ -24,13 +24,15 @@ using namespace realm::jni_util;
 
 static std::unique_ptr<JniUtils> s_instance;
 
-void JniUtils::initialize(JavaVM *vm, jint vm_version) noexcept {
+void JniUtils::initialize(JavaVM* vm, jint vm_version) noexcept
+{
     REALM_ASSERT_DEBUG(!s_instance);
 
     s_instance = std::unique_ptr<JniUtils>(new JniUtils(vm, vm_version));
 }
 
-JNIEnv* JniUtils::get_env(bool attach_if_needed) {
+JNIEnv* JniUtils::get_env(bool attach_if_needed)
+{
     REALM_ASSERT_DEBUG(s_instance);
 
     JNIEnv* env;
@@ -38,7 +40,8 @@ JNIEnv* JniUtils::get_env(bool attach_if_needed) {
         if (attach_if_needed) {
             jint ret = s_instance->m_vm->AttachCurrentThread(&env, nullptr);
             REALM_ASSERT_RELEASE(ret == JNI_OK);
-        } else {
+        }
+        else {
             REALM_ASSERT_RELEASE(false);
         }
     }
@@ -46,6 +49,7 @@ JNIEnv* JniUtils::get_env(bool attach_if_needed) {
     return env;
 }
 
-void JniUtils::detach_current_thread()  {
+void JniUtils::detach_current_thread()
+{
     s_instance->m_vm->DetachCurrentThread();
 }
diff --git a/realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp b/realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp
index a8d9303786..7d2bcf4b9d 100644
--- a/realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp
@@ -25,7 +25,9 @@ namespace jni_util {
 // Util functions for JNI.
 class JniUtils {
 public:
-    ~JniUtils() {}
+    ~JniUtils()
+    {
+    }
 
     // Call this only once in JNI_OnLoad.
     static void initialize(JavaVM* vm, jint vm_version) noexcept;
@@ -37,7 +39,11 @@ class JniUtils {
     static void detach_current_thread();
 
 private:
-    JniUtils(JavaVM* vm, jint vm_version) noexcept : m_vm(vm), m_vm_version(vm_version) {}
+    JniUtils(JavaVM* vm, jint vm_version) noexcept
+        : m_vm(vm)
+        , m_vm_version(vm_version)
+    {
+    }
 
     JavaVM* m_vm;
     jint m_vm_version;
@@ -46,4 +52,4 @@ class JniUtils {
 } // namespace realm
 } // namespace jni_util
 
-#endif //REALM_JNI_UTIL_JNI_UTILS_HPP
+#endif // REALM_JNI_UTIL_JNI_UTILS_HPP
diff --git a/realm/realm-library/src/main/cpp/jni_util/log.cpp b/realm/realm-library/src/main/cpp/jni_util/log.cpp
index b22b45fd41..d8b804549d 100644
--- a/realm/realm-library/src/main/cpp/jni_util/log.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/log.cpp
@@ -22,7 +22,6 @@ using namespace realm;
 using namespace realm::jni_util;
 using namespace realm::util;
 
-const char* CoreLoggerBridge::TAG = "REALM_CORE";
 const char* Log::REALM_JNI_TAG = "REALM_JNI";
 Log::Level Log::s_level = Log::Level::warn;
 
@@ -45,8 +44,8 @@ class JavaLogger : public JniLogger {
 
     inline JNIEnv* get_current_env() noexcept
     {
-        JNIEnv *env;
-        if (m_jvm->GetEnv((void **)&env, JNI_VERSION_1_6) != JNI_OK) {
+        JNIEnv* env;
+        if (m_jvm->GetEnv((void**)&env, JNI_VERSION_1_6) != JNI_OK) {
             m_jvm->AttachCurrentThread(&env, nullptr); // Should never fail
         }
         return env;
@@ -54,17 +53,17 @@ class JavaLogger : public JniLogger {
 };
 
 JniLogger::JniLogger()
-    :m_is_java_logger(false)
+    : m_is_java_logger(false)
 {
 }
 
 JniLogger::JniLogger(bool is_java_logger)
-    :m_is_java_logger(is_java_logger)
+    : m_is_java_logger(is_java_logger)
 {
 }
 
 JavaLogger::JavaLogger(JNIEnv* env, jobject java_logger)
-    :JniLogger(true)
+    : JniLogger(true)
 {
     jint ret = env->GetJavaVM(&m_jvm);
     if (ret != 0) {
@@ -82,13 +81,14 @@ JavaLogger::~JavaLogger()
 
 void JavaLogger::log(Log::Level level, const char* tag, jthrowable throwable, const char* message)
 {
-    JNIEnv *env = get_current_env();
+    JNIEnv* env = get_current_env();
 
     // NOTE: If a Java exception has been thrown in native code, the below call will trigger an JNI exception
-    // "JNI called with pending exception". This is something that should be avoided when printing log in JNI -- Always
+    // "JNI called with pending exception". This is something that should be avoided when printing log in JNI --
+    // Always
     // print log before calling env->ThrowNew. Doing env->ExceptionCheck() here creates overhead for normal cases.
-    env->CallVoidMethod(m_java_logger, m_log_method, level, env->NewStringUTF(tag),
-            throwable, env->NewStringUTF(message));
+    env->CallVoidMethod(m_java_logger, m_log_method, level, env->NewStringUTF(tag), throwable,
+                        env->NewStringUTF(message));
 }
 
 bool JavaLogger::is_same_object(JNIEnv* env, jobject java_logger)
@@ -117,9 +117,13 @@ void Log::add_java_logger(JNIEnv* env, const jobject java_logger)
 void Log::remove_java_logger(JNIEnv* env, const jobject java_logger)
 {
     std::lock_guard<std::mutex> lock(m_mutex);
-    m_loggers.erase(std::remove_if(m_loggers.begin(), m_loggers.end(), [&](const auto& obj) {
-        return obj->m_is_java_logger && std::static_pointer_cast<JavaLogger>(obj)->is_same_object(env, java_logger);
-    }), m_loggers.end());
+    m_loggers.erase(std::remove_if(m_loggers.begin(), m_loggers.end(),
+                                   [&](const auto& obj) {
+                                       return obj->m_is_java_logger &&
+                                              std::static_pointer_cast<JavaLogger>(obj)->is_same_object(env,
+                                                                                                        java_logger);
+                                   }),
+                    m_loggers.end());
 }
 
 void Log::add_logger(std::shared_ptr<JniLogger> logger)
@@ -134,12 +138,13 @@ void Log::remove_logger(std::shared_ptr<JniLogger> logger)
 {
     std::lock_guard<std::mutex> lock(m_mutex);
 
-    m_loggers.erase(std::remove_if(m_loggers.begin(), m_loggers.end(), [&](const auto& obj) {
-        return obj == logger;
-    }), m_loggers.end());
+    m_loggers.erase(
+        std::remove_if(m_loggers.begin(), m_loggers.end(), [&](const auto& obj) { return obj == logger; }),
+        m_loggers.end());
 }
 
-void Log::register_default_logger() {
+void Log::register_default_logger()
+{
     add_logger(get_default_logger());
 }
 
@@ -169,22 +174,28 @@ void CoreLoggerBridge::do_log(realm::util::Logger::Level level, std::string msg)
     // Ignore the level threshold from the root logger.
     Log::Level jni_level = Log::all; // Initial value to suppress the false positive compile warning.
     switch (level) {
-        case Level::trace: jni_level = Log::trace; break;
+        case Level::trace:
+            jni_level = Log::trace;
+            break;
         case Level::debug: // Fall through. Map to same level debug.
-        case Level::detail: jni_level = Log::debug; break;
-        case Level::info: jni_level = Log::info; break;
-        case Level::warn: jni_level = Log::warn; break;
-        case Level::error: jni_level = Log::error; break;
-        case Level::fatal: jni_level = Log::fatal; break;
+        case Level::detail:
+            jni_level = Log::debug;
+            break;
+        case Level::info:
+            jni_level = Log::info;
+            break;
+        case Level::warn:
+            jni_level = Log::warn;
+            break;
+        case Level::error:
+            jni_level = Log::error;
+            break;
+        case Level::fatal:
+            jni_level = Log::fatal;
+            break;
         case Level::all: // Fall through.
         case Level::off: // Fall through.
             throw std::invalid_argument(format("Invalid log level."));
     }
-    Log::shared().log(jni_level, TAG, msg.c_str());
-}
-
-CoreLoggerBridge& CoreLoggerBridge::shared()
-{
-    static CoreLoggerBridge log_bridge;
-    return log_bridge;
+    Log::shared().log(jni_level, m_tag.c_str(), msg.c_str());
 }
diff --git a/realm/realm-library/src/main/cpp/jni_util/log.hpp b/realm/realm-library/src/main/cpp/jni_util/log.hpp
index 930fe81889..d138f287d2 100644
--- a/realm/realm-library/src/main/cpp/jni_util/log.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/log.hpp
@@ -29,13 +29,13 @@
 #include "realm/util/logger.hpp"
 #include "util/format.hpp"
 
-#define TR_ENTER() \
-    if (realm::jni_util::Log::s_level <= realm::jni_util::Log::trace) { \
-        realm::jni_util::Log::t(" --> %1", __FUNCTION__); \
+#define TR_ENTER()                                                                                                   \
+    if (realm::jni_util::Log::s_level <= realm::jni_util::Log::trace) {                                              \
+        realm::jni_util::Log::t(" --> %1", __FUNCTION__);                                                            \
     }
-#define TR_ENTER_PTR(ptr) \
-    if (realm::jni_util::Log::s_level <= realm::jni_util::Log::trace) { \
-        realm::jni_util::Log::t(" --> %1 %2", __FUNCTION__, static_cast<int64_t>(ptr)); \
+#define TR_ENTER_PTR(ptr)                                                                                            \
+    if (realm::jni_util::Log::s_level <= realm::jni_util::Log::trace) {                                              \
+        realm::jni_util::Log::t(" --> %1 %2", __FUNCTION__, static_cast<int64_t>(ptr));                              \
     }
 
 namespace realm {
@@ -73,7 +73,8 @@ class Log {
     void register_default_logger();
 
     void set_level(Level level);
-    inline Level get_level() {
+    inline Level get_level()
+    {
         return s_level;
     };
 
@@ -110,33 +111,34 @@ class Log {
         shared().log(fatal, REALM_JNI_TAG, nullptr, message);
     }
 
-    template<typename... Args>
+    template <typename... Args>
     inline static void t(const char* fmt, Args&&... args)
     {
         shared().log(trace, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
     }
-    template<typename... Args>
+    template <typename... Args>
     inline static void d(const char* fmt, Args&&... args)
     {
         shared().log(debug, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
     }
-    template<typename... Args>
+    template <typename... Args>
     inline static void i(const char* fmt, Args&&... args)
     {
         shared().log(info, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
     }
-    template<typename... Args>
+    template <typename... Args>
     inline static void w(const char* fmt, Args&&... args)
     {
         shared().log(warn, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
     }
-    template<typename... Args>
+    template <typename... Args>
     inline static void e(const char* fmt, Args&&... args)
     {
         shared().log(error, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
     }
-    template<typename... Args>
-    inline static void f(const char* fmt, Args&&... args) {
+    template <typename... Args>
+    inline static void f(const char* fmt, Args&&... args)
+    {
         shared().log(fatal, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
     }
 
@@ -147,6 +149,7 @@ class Log {
     // Accessing to this var won't be thread safe and it is not necessary to be. Changing log level concurrently
     // won't be a critical issue for commons cases.
     static Level s_level;
+
 private:
     Log();
 
@@ -154,7 +157,6 @@ class Log {
     std::mutex m_mutex;
     // Log tag for generic Realm JNI.
     static const char* REALM_JNI_TAG;
-
 };
 
 // Base Logger class.
@@ -178,13 +180,11 @@ extern std::shared_ptr<JniLogger> get_default_logger();
 
 class CoreLoggerBridge : public realm::util::RootLogger {
 public:
+    CoreLoggerBridge(std::string tag) : m_tag(std::move(tag)) {}
     void do_log(Logger::Level, std::string msg) override;
-    static CoreLoggerBridge& shared();
 
 private:
-    CoreLoggerBridge() {};
-    // Log tag for Realm core & sync.
-    static const char* TAG;
+    const std::string m_tag;
 };
 
 } // namespace jni_util
diff --git a/realm/realm-library/src/main/cpp/mem_usage.cpp b/realm/realm-library/src/main/cpp/mem_usage.cpp
index d4e337d528..21a81ef15a 100644
--- a/realm/realm-library/src/main/cpp/mem_usage.cpp
+++ b/realm/realm-library/src/main/cpp/mem_usage.cpp
@@ -20,7 +20,7 @@
 
 size_t GetMemUsage()
 {
-  return 0;
+    return 0;
 }
 
 #elif defined(_MSC_VER) // Microsoft Windows
@@ -37,16 +37,16 @@ DWORD CalculateWSPrivate(DWORD processID);
 // Calculate Private Working Set
 // Source: http://www.codeproject.com/KB/cpp/XPWSPrivate.aspx
 
-int Compare( const void * Val1, const void * Val2 )
+int Compare(const void* Val1, const void* Val2)
 {
-    if ( *(PDWORD)Val1 == *(PDWORD)Val2 )
-    return 0;
+    if (*(PDWORD)Val1 == *(PDWORD)Val2)
+        return 0;
 
     return *(PDWORD)Val1 > *(PDWORD)Val2 ? 1 : -1;
 }
 
-DWORD dWorkingSetPages[ 1024 * 128 ]; // hold the working set
-                // information get from QueryWorkingSet()
+DWORD dWorkingSetPages[1024 * 128]; // hold the working set
+                                    // information get from QueryWorkingSet()
 DWORD dPageSize = 0x1000;
 
 DWORD CalculateWSPrivate(DWORD processID)
@@ -55,23 +55,20 @@ DWORD CalculateWSPrivate(DWORD processID)
     DWORD dPrivatePages = 0;
     DWORD dPageTablePages = 0;
 
-    HANDLE hProcess = OpenProcess( PROCESS_QUERY_INFORMATION |
-        PROCESS_VM_READ, FALSE, processID );
+    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processID);
 
-    if ( !hProcess )
-    return 0;
+    if (!hProcess)
+        return 0;
 
-    __try
-    {
-        if ( !QueryWorkingSet(hProcess, dWorkingSetPages, sizeof(dWorkingSetPages)) )
-        __leave;
+    __try {
+        if (!QueryWorkingSet(hProcess, dWorkingSetPages, sizeof(dWorkingSetPages)))
+            __leave;
 
         DWORD dPages = dWorkingSetPages[0];
 
-        qsort( &dWorkingSetPages[1], dPages, sizeof(DWORD), Compare );
+        qsort(&dWorkingSetPages[1], dPages, sizeof(DWORD), Compare);
 
-        for ( DWORD i = 1; i <= dPages; i++ )
-        {
+        for (DWORD i = 1; i <= dPages; i++) {
             DWORD dCurrentPageStatus = 0;
             DWORD dCurrentPageAddress;
             DWORD dNextPageAddress;
@@ -79,38 +76,35 @@ DWORD CalculateWSPrivate(DWORD processID)
             DWORD dPageAddress = dWorkingSetPages[i] & 0xFFFFF000;
             DWORD dPageFlags = dWorkingSetPages[i] & 0x00000FFF;
 
-            while ( i <= dPages ) // iterate all pages
+            while (i <= dPages) // iterate all pages
             {
                 dCurrentPageStatus++;
 
-                if ( i == dPages ) //if last page
-                break;
+                if (i == dPages) // if last page
+                    break;
 
                 dCurrentPageAddress = dWorkingSetPages[i] & 0xFFFFF000;
-                dNextPageAddress = dWorkingSetPages[i+1] & 0xFFFFF000;
-                dNextPageFlags = dWorkingSetPages[i+1] & 0x00000FFF;
+                dNextPageAddress = dWorkingSetPages[i + 1] & 0xFFFFF000;
+                dNextPageFlags = dWorkingSetPages[i + 1] & 0x00000FFF;
 
-                //decide whether iterate further or exit
+                // decide whether iterate further or exit
                 //(this is non-contiguous page or have different flags)
-                if ( (dNextPageAddress == (dCurrentPageAddress + dPageSize))
-            && (dNextPageFlags == dPageFlags) )
-                {
+                if ((dNextPageAddress == (dCurrentPageAddress + dPageSize)) && (dNextPageFlags == dPageFlags)) {
                     i++;
                 }
                 else
-                break;
+                    break;
             }
 
-            if ( (dPageAddress < 0xC0000000) || (dPageAddress > 0xE0000000) )
-            {
-                if ( dPageFlags & 0x100 ) // this is shared one
-                dSharedPages += dCurrentPageStatus;
+            if ((dPageAddress < 0xC0000000) || (dPageAddress > 0xE0000000)) {
+                if (dPageFlags & 0x100) // this is shared one
+                    dSharedPages += dCurrentPageStatus;
 
                 else // private one
-                dPrivatePages += dCurrentPageStatus;
+                    dPrivatePages += dCurrentPageStatus;
             }
             else
-            dPageTablePages += dCurrentPageStatus; //page table region
+                dPageTablePages += dCurrentPageStatus; // page table region
         }
 
         DWORD dTotal = dPages * 4;
@@ -119,9 +113,8 @@ DWORD CalculateWSPrivate(DWORD processID)
 
         return WSPrivate;
     }
-    __finally
-    {
-        CloseHandle( hProcess );
+    __finally {
+        CloseHandle(hProcess);
     }
     return -1;
 }
@@ -134,7 +127,7 @@ size_t GetMemUsage()
 }
 
 
-#elif defined (__APPLE__) // Mac / Darwin
+#elif defined(__APPLE__) // Mac / Darwin
 
 
 #include <mach/mach.h>
@@ -145,7 +138,8 @@ size_t GetMemUsage()
 
     mach_msg_type_number_t t_info_count = TASK_BASIC_INFO_COUNT;
 
-    if (KERN_SUCCESS != task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&t_info, &t_info_count)) return -1;
+    if (KERN_SUCCESS != task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&t_info, &t_info_count))
+        return -1;
 
     // resident size is in t_info.resident_size;
     // virtual size is in t_info.virtual_size;
@@ -164,9 +158,9 @@ size_t GetMemUsage()
 
 size_t GetMemUsage()
 {
-  struct proc_t usage;
-  look_up_our_self(&usage);
-  return usage.vsize;
+    struct proc_t usage;
+    look_up_our_self(&usage);
+    return usage.vsize;
 }
 
 
diff --git a/realm/realm-library/src/main/cpp/tablebase_tpl.hpp b/realm/realm-library/src/main/cpp/tablebase_tpl.hpp
index bf7ea21178..54db725c51 100644
--- a/realm/realm-library/src/main/cpp/tablebase_tpl.hpp
+++ b/realm/realm-library/src/main/cpp/tablebase_tpl.hpp
@@ -22,22 +22,25 @@
 template <class T>
 jbyteArray tbl_GetByteArray(JNIEnv* env, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
 {
-    if (!TBL_AND_INDEX_VALID(env, reinterpret_cast<T*>(nativeTablePtr), columnIndex, rowIndex))
-        return NULL;
+    if (!TBL_AND_INDEX_VALID(env, reinterpret_cast<T*>(nativeTablePtr), columnIndex, rowIndex)) {
+        return nullptr;
+    }
 
-    realm::BinaryData bin = reinterpret_cast<T*>(nativeTablePtr)->get_binary( S(columnIndex), S(rowIndex));
+    realm::BinaryData bin = reinterpret_cast<T*>(nativeTablePtr)->get_binary(S(columnIndex), S(rowIndex));
     if (bin.is_null()) {
-        return NULL;
+        return nullptr;
     }
     if (bin.size() <= MAX_JSIZE) {
         jbyteArray jresult = env->NewByteArray(static_cast<jsize>(bin.size()));
-        if (jresult)
-            env->SetByteArrayRegion(jresult, 0, static_cast<jsize>(bin.size()), reinterpret_cast<const jbyte*>(bin.data()));  // throws
+        if (jresult) {
+            env->SetByteArrayRegion(jresult, 0, static_cast<jsize>(bin.size()),
+                                    reinterpret_cast<const jbyte *>(bin.data())); // throws
+        }
         return jresult;
     }
     else {
         ThrowException(env, IllegalArgument, "Length of ByteArray is larger than an Int.");
-        return NULL;
+        return nullptr;
     }
 }
 
diff --git a/realm/realm-library/src/main/cpp/utf8.hpp b/realm/realm-library/src/main/cpp/utf8.hpp
index 3f76edefe4..5a156f7f08 100644
--- a/realm/realm-library/src/main/cpp/utf8.hpp
+++ b/realm/realm-library/src/main/cpp/utf8.hpp
@@ -35,7 +35,8 @@ namespace util {
 ///
 /// \tparam Traits16 Must define to_int_type() and to_char_type() for
 /// \a Char16.
-template<class Char16, class Traits16 = std::char_traits<Char16> > struct Utf8x16 {
+template <class Char16, class Traits16 = std::char_traits<Char16>>
+struct Utf8x16 {
     /// Transcode as much as possible of the specified UTF-8 input, to
     /// UTF-16. Returns true if all input characters were transcoded, or
     /// transcoding stopped because the next character did not fit into the
@@ -46,14 +47,13 @@ template<class Char16, class Traits16 = std::char_traits<Char16> > struct Utf8x1
     /// advanced to the position where transcoding stopped.
     ///
     /// Throws only if Traits16::to_char_type() throws.
-    static size_t to_utf16(const char*& in_begin, const char* in_end,
-                           Char16*& out_begin, Char16* out_end);
+    static size_t to_utf16(const char*& in_begin, const char* in_end, Char16*& out_begin, Char16* out_end);
 
     /// Same as to_utf16(), but in reverse.
     ///
     /// Throws only if Traits16::to_int_type() throws.
-    static size_t to_utf8(const Char16*& in_begin, const Char16* in_end,
-                        char*& out_begin, char* out_end, size_t& error_code);
+    static size_t to_utf8(const Char16*& in_begin, const Char16* in_end, char*& out_begin, char* out_end,
+                          size_t& error_code);
 
     /// Summarize the number of UTF-16 elements needed to hold the result of
     /// transcoding the specified UTF-8 string. Upon return, if \a in_begin !=
@@ -76,17 +76,14 @@ template<class Char16, class Traits16 = std::char_traits<Char16> > struct Utf8x1
 };
 
 
-
-
-
 // Implementation:
 
 // Adapted from reference implementation.
 // http://www.unicode.org/resources/utf8.html
 // http://www.bsdua.org/files/unicode.tar.gz
-template<class Char16, class Traits16>
-inline size_t Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const char* in_end,
-                                                  Char16*& out_begin, Char16* out_end)
+template <class Char16, class Traits16>
+inline size_t Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const char* in_end, Char16*& out_begin,
+                                                  Char16* out_end)
 {
     using namespace std;
     typedef char_traits<char> traits8;
@@ -119,8 +116,7 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const c
                 invalid = 2;
                 break; // Invalid continuation byte
             }
-            uint_fast16_t v = uint_fast16_t(((v1 & 0x1F) << 6) |
-                                            ((v2 & 0x3F) << 0));
+            uint_fast16_t v = uint_fast16_t(((v1 & 0x1F) << 6) | ((v2 & 0x3F) << 0));
             if (REALM_UNLIKELY(v < 0x80)) {
                 invalid = 3;
                 break; // Overlong encoding is invalid
@@ -141,9 +137,7 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const c
                 invalid = true;
                 break; // Invalid continuation byte
             }
-            uint_fast16_t v = uint_fast16_t(((v1 & 0x0F) << 12) |
-                                            ((v2 & 0x3F) <<  6) |
-                                            ((v3 & 0x3F) <<  0));
+            uint_fast16_t v = uint_fast16_t(((v1 & 0x0F) << 12) | ((v2 & 0x3F) << 6) | ((v3 & 0x3F) << 0));
             if (REALM_UNLIKELY(v < 0x800)) {
                 invalid = 5;
                 break; // Overlong encoding is invalid
@@ -164,21 +158,19 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const c
                 invalid = 7;
                 break; // Incomplete UTF-8 sequence
             }
-            uint_fast32_t w1 = uint_fast32_t(v1); // 16 bit -> 32 bit
+            uint_fast32_t w1 = uint_fast32_t(v1);                          // 16 bit -> 32 bit
             uint_fast32_t v2 = uint_fast32_t(traits8::to_int_type(in[1])); // 32 bit intended
             uint_fast16_t v3 = uint_fast16_t(traits8::to_int_type(in[2])); // 16 bit intended
             uint_fast16_t v4 = uint_fast16_t(traits8::to_int_type(in[3])); // 16 bit intended
             // UTF-8 layout: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
-            if (REALM_UNLIKELY((v2 & 0xC0) != 0x80 || (v3 & 0xC0) != 0x80 ||
-                                 (v4 & 0xC0) != 0x80)) {
+            if (REALM_UNLIKELY((v2 & 0xC0) != 0x80 || (v3 & 0xC0) != 0x80 || (v4 & 0xC0) != 0x80)) {
                 invalid = 8;
                 break; // Invalid continuation byte
             }
-            uint_fast32_t v =
-                uint_fast32_t(((w1 & 0x07) << 18) | // Parenthesis is 32 bit partial result
-                              ((v2 & 0x3F) << 12) | // Parenthesis is 32 bit partial result
-                              ((v3 & 0x3F) <<  6) | // Parenthesis is 16 bit partial result
-                              ((v4 & 0x3F) <<  0)); // Parenthesis is 16 bit partial result
+            uint_fast32_t v = uint_fast32_t(((w1 & 0x07) << 18) | // Parenthesis is 32 bit partial result
+                                            ((v2 & 0x3F) << 12) | // Parenthesis is 32 bit partial result
+                                            ((v3 & 0x3F) << 6) |  // Parenthesis is 16 bit partial result
+                                            ((v4 & 0x3F) << 0));  // Parenthesis is 16 bit partial result
             if (REALM_UNLIKELY(v < 0x10000)) {
                 invalid = 9;
                 break; // Overlong encoding is invalid
@@ -198,15 +190,14 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const c
         break;
     }
 
-    in_begin  = in;
+    in_begin = in;
     out_begin = out;
     return invalid;
 }
 
 
-template<class Char16, class Traits16>
-inline std::size_t Utf8x16<Char16, Traits16>::find_utf16_buf_size(const char*& in_begin,
-                                                                  const char*  in_end,
+template <class Char16, class Traits16>
+inline std::size_t Utf8x16<Char16, Traits16>::find_utf16_buf_size(const char*& in_begin, const char* in_end,
                                                                   size_t& error_code)
 {
     using namespace std;
@@ -257,18 +248,17 @@ inline std::size_t Utf8x16<Char16, Traits16>::find_utf16_buf_size(const char*& i
         break;
     }
 
-    in_begin  = in;
+    in_begin = in;
     return num_out;
 }
 
 
-
 // Adapted from reference implementation.
 // http://www.unicode.org/resources/utf8.html
 // http://www.bsdua.org/files/unicode.tar.gz
-template<class Char16, class Traits16>
-inline size_t Utf8x16<Char16, Traits16>::to_utf8(const Char16*& in_begin, const Char16* in_end,
-                                               char*& out_begin, char* out_end, size_t& error_code)
+template <class Char16, class Traits16>
+inline size_t Utf8x16<Char16, Traits16>::to_utf8(const Char16*& in_begin, const Char16* in_end, char*& out_begin,
+                                                 char* out_end, size_t& error_code)
 {
     using namespace std;
     typedef char_traits<char> traits8;
@@ -343,15 +333,14 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf8(const Char16*& in_begin, const
         in += 2;
     }
 
-    in_begin  = in;
+    in_begin = in;
     out_begin = out;
     return !invalid;
 }
 
 
-template<class Char16, class Traits16>
-inline std::size_t Utf8x16<Char16, Traits16>::find_utf8_buf_size(const Char16*& in_begin,
-                                                                 const Char16*  in_end,
+template <class Char16, class Traits16>
+inline std::size_t Utf8x16<Char16, Traits16>::find_utf8_buf_size(const Char16*& in_begin, const Char16* in_end,
                                                                  size_t& error_code)
 {
     using namespace std;
@@ -394,7 +383,7 @@ inline std::size_t Utf8x16<Char16, Traits16>::find_utf8_buf_size(const Char16*&
         }
     }
 
-    in_begin  = in;
+    in_begin = in;
     return num_out;
 }
 } // namespace util
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index 93c6875949..a2f4516ede 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -49,7 +49,7 @@ jclass java_syncmanager;
 
 void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind);
 
-void ConvertException(JNIEnv* env, const char *file, int line)
+void ConvertException(JNIEnv* env, const char* file, int line)
 {
     ostringstream ss;
     try {
@@ -72,11 +72,11 @@ void ConvertException(JNIEnv* env, const char *file, int line)
         ThrowException(env, IllegalArgument, ss.str());
     }
     catch (RealmFileException& e) {
-        ss << e.what() << " (" <<  e.underlying() << ") (" << e.path() << ") in " << file << " line " << line;
+        ss << e.what() << " (" << e.underlying() << ") (" << e.path() << ") in " << file << " line " << line;
         ThrowRealmFileException(env, ss.str(), e.kind());
     }
     catch (File::AccessError& e) {
-        ss << e.what() << " (" <<  e.get_path() <<  ") in " << file << " line " << line;
+        ss << e.what() << " (" << e.get_path() << ") in " << file << " line " << line;
         ThrowException(env, FatalError, ss.str());
     }
     catch (InvalidTransactionException& e) {
@@ -88,18 +88,17 @@ void ConvertException(JNIEnv* env, const char *file, int line)
         ThrowException(env, IllegalArgument, ss.str());
     }
     catch (Results::OutOfBoundsIndexException& e) {
-        ss << "Out of range  in " << file << " line " << line
-           << "(requested: " << e.requested << " valid: " << e.valid_count << ")";
+        ss << "Out of range  in " << file << " line " << line << "(requested: " << e.requested
+           << " valid: " << e.valid_count << ")";
         ThrowException(env, IndexOutOfBounds, ss.str());
     }
     catch (Results::IncorrectTableException& e) {
-        ss << "Incorrect class in " << file << " line " << line
-           << "(actual: " << e.actual << " expected: " << e.expected << ")";
+        ss << "Incorrect class in " << file << " line " << line << "(actual: " << e.actual
+           << " expected: " << e.expected << ")";
         ThrowException(env, IllegalArgument, ss.str());
     }
     catch (Results::UnsupportedColumnTypeException& e) {
-        ss << "Unsupported type in " << file << " line " << line
-           << "(field name: " << e.column_name << ")";
+        ss << "Unsupported type in " << file << " line " << line << "(field name: " << e.column_name << ")";
         ThrowException(env, IllegalArgument, ss.str());
     }
     catch (Results::InvalidatedException& e) {
@@ -120,7 +119,7 @@ void ConvertException(JNIEnv* env, const char *file, int line)
     /* catch (...) is not needed if we only throw exceptions derived from std::exception */
 }
 
-void ThrowException(JNIEnv* env, ExceptionKind exception, const char *classStr)
+void ThrowException(JNIEnv* env, ExceptionKind exception, const char* classStr)
 {
     ThrowException(env, exception, classStr, "");
 }
@@ -239,17 +238,15 @@ jclass GetClass(JNIEnv* env, const char* classStr)
         return NULL;
     }
 
-    jclass myClass = reinterpret_cast<jclass>( env->NewGlobalRef(localRefClass) );
+    jclass myClass = reinterpret_cast<jclass>(env->NewGlobalRef(localRefClass));
     env->DeleteLocalRef(localRefClass);
     return myClass;
 }
 
-void ThrowNullValueException(JNIEnv* env, Table* table, size_t col_ndx) {
+void ThrowNullValueException(JNIEnv* env, Table* table, size_t col_ndx)
+{
     std::ostringstream ss;
-    ss << "Trying to set a non-nullable field '"
-       << table->get_column_name(col_ndx)
-       << "' in '"
-       << table->get_name()
+    ss << "Trying to set a non-nullable field '" << table->get_column_name(col_ndx) << "' in '" << table->get_name()
        << "' to null.";
     ThrowException(env, IllegalArgument, ss.str());
 }
@@ -281,19 +278,36 @@ namespace {
 // non-sign value bits, that is, an unsigned 16-bit integer, or any
 // signed or unsigned integer with more than 16 bits.
 struct JcharTraits {
-    static jchar to_int_type(jchar c)  noexcept { return c; }
-    static jchar to_char_type(jchar i) noexcept { return i; }
+    static jchar to_int_type(jchar c) noexcept
+    {
+        return c;
+    }
+    static jchar to_char_type(jchar i) noexcept
+    {
+        return i;
+    }
 };
 
 struct JStringCharsAccessor {
-    JStringCharsAccessor(JNIEnv* e, jstring s):
-        m_env(e), m_string(s), m_data(e->GetStringChars(s,0)), m_size(get_size(e,s)) {}
+    JStringCharsAccessor(JNIEnv* e, jstring s)
+        : m_env(e)
+        , m_string(s)
+        , m_data(e->GetStringChars(s, 0))
+        , m_size(get_size(e, s))
+    {
+    }
     ~JStringCharsAccessor()
     {
         m_env->ReleaseStringChars(m_string, m_data);
     }
-    const jchar* data() const noexcept { return m_data; }
-    size_t size() const noexcept { return m_size; }
+    const jchar* data() const noexcept
+    {
+        return m_data;
+    }
+    size_t size() const noexcept
+    {
+        return m_size;
+    }
 
 private:
     JNIEnv* const m_env;
@@ -313,10 +327,11 @@ struct JStringCharsAccessor {
 } // anonymous namespace
 
 static string string_to_hex(const string& message, StringData& str, const char* in_begin, const char* in_end,
-                     jchar* out_curr, jchar* out_end, size_t retcode, size_t error_code) {
+                            jchar* out_curr, jchar* out_end, size_t retcode, size_t error_code)
+{
     ostringstream ret;
 
-    const char *s = str.data();
+    const char* s = str.data();
     ret << message << " ";
     ret << "error_code = " << error_code << "; ";
     ret << "retcode = " << retcode << "; ";
@@ -333,17 +348,19 @@ static string string_to_hex(const string& message, StringData& str, const char*
     return ret.str();
 }
 
-static string string_to_hex(const string& message, const jchar *str, size_t size, size_t error_code) {
+static string string_to_hex(const string& message, const jchar* str, size_t size, size_t error_code)
+{
     ostringstream ret;
 
     ret << message << "; ";
     ret << "error_code = " << error_code << "; ";
-    for (size_t i = 0; i < size; ++i)
-        ret << " 0x" << std::hex << std::setfill('0') << std::setw(4) << (int)str[i];
+    for (size_t i = 0; i < size; ++i) {
+        ret << " 0x" << std::hex << std::setfill('0') << std::setw(4) << (int) str[i];
+    }
     return ret.str();
 }
 
-string concat_stringdata(const char *message, StringData strData)
+string concat_stringdata(const char* message, StringData strData)
 {
     if (strData.is_null()) {
         return std::string(message);
@@ -368,47 +385,55 @@ jstring to_jstring(JNIEnv* env, StringData str)
     std::unique_ptr<jchar[]> dyn_buf;
 
     const char* in_begin = str.data();
-    const char* in_end   = str.data() + str.size();
+    const char* in_end = str.data() + str.size();
     jchar* out_begin = stack_buf;
-    jchar* out_curr  = stack_buf;
-    jchar* out_end   = stack_buf + stack_buf_size;
+    jchar* out_curr = stack_buf;
+    jchar* out_end = stack_buf + stack_buf_size;
 
     typedef Utf8x16<jchar, JcharTraits> Xcode;
 
     if (str.size() <= stack_buf_size) {
         size_t retcode = Xcode::to_utf16(in_begin, in_end, out_curr, out_end);
-        if (retcode != 0)
-            throw runtime_error(string_to_hex("Failure when converting short string to UTF-16",  str, in_begin, in_end, out_curr, out_end, size_t(0), retcode));
-        if (in_begin == in_end)
+        if (retcode != 0) {
+            throw runtime_error(string_to_hex("Failure when converting short string to UTF-16", str, in_begin, in_end,
+                                              out_curr, out_end, size_t(0), retcode));
+        }
+        if (in_begin == in_end) {
             goto transcode_complete;
+        }
     }
 
     {
         const char* in_begin2 = in_begin;
         size_t error_code;
         size_t size = Xcode::find_utf16_buf_size(in_begin2, in_end, error_code);
-        if (in_begin2 != in_end)
-            throw runtime_error(string_to_hex("Failure when computing UTF-16 size", str, in_begin, in_end, out_curr, out_end, size, error_code));
-        if (int_add_with_overflow_detect(size, stack_buf_size))
+        if (in_begin2 != in_end) {
+            throw runtime_error(string_to_hex("Failure when computing UTF-16 size", str, in_begin, in_end, out_curr,
+                                              out_end, size, error_code));
+        }
+        if (int_add_with_overflow_detect(size, stack_buf_size)) {
             throw runtime_error("String size overflow");
+        }
         dyn_buf.reset(new jchar[size]);
         out_curr = copy(out_begin, out_curr, dyn_buf.get());
         out_begin = dyn_buf.get();
-        out_end   = dyn_buf.get() + size;
+        out_end = dyn_buf.get() + size;
         size_t retcode = Xcode::to_utf16(in_begin, in_end, out_curr, out_end);
-        if (retcode != 0)
-            throw runtime_error(string_to_hex("Failure when converting long string to UTF-16", str, in_begin, in_end, out_curr, out_end, size_t(0), retcode));
+        if (retcode != 0) {
+            throw runtime_error(string_to_hex("Failure when converting long string to UTF-16", str, in_begin, in_end,
+                                              out_curr, out_end, size_t(0), retcode));
+        }
         REALM_ASSERT(in_begin == in_end);
     }
 
-  transcode_complete:
-    {
-        jsize out_size;
-        if (int_cast_with_overflow_detect(out_curr - out_begin, out_size))
-            throw runtime_error("String size overflow");
-
-        return env->NewString(out_begin, out_size);
+transcode_complete : {
+    jsize out_size;
+    if (int_cast_with_overflow_detect(out_curr - out_begin, out_size)) {
+        throw runtime_error("String size overflow");
     }
+
+    return env->NewString(out_begin, out_size);
+}
 }
 
 
@@ -431,14 +456,14 @@ JStringAccessor::JStringAccessor(JNIEnv* env, jstring str)
 
     typedef Utf8x16<jchar, JcharTraits> Xcode;
     size_t max_project_size = 48;
-    REALM_ASSERT(max_project_size <= numeric_limits<size_t>::max()/4);
+    REALM_ASSERT(max_project_size <= numeric_limits<size_t>::max() / 4);
     size_t buf_size;
     if (chars.size() <= max_project_size) {
         buf_size = chars.size() * 4;
     }
     else {
         const jchar* begin = chars.data();
-        const jchar* end   = begin + chars.size();
+        const jchar* end = begin + chars.size();
         size_t error_code;
         buf_size = Xcode::find_utf8_buf_size(begin, end, error_code);
     }
@@ -446,19 +471,20 @@ JStringAccessor::JStringAccessor(JNIEnv* env, jstring str)
     m_data.reset(tmp_char_array);
     {
         const jchar* in_begin = chars.data();
-        const jchar* in_end   = in_begin + chars.size();
+        const jchar* in_end = in_begin + chars.size();
         char* out_begin = m_data.get();
-        char* out_end   = m_data.get() + buf_size;
+        char* out_end = m_data.get() + buf_size;
         size_t error_code;
         if (!Xcode::to_utf8(in_begin, in_end, out_begin, out_end, error_code)) {
-            throw invalid_argument(string_to_hex("Failure when converting to UTF-8", chars.data(), chars.size(), error_code));
+            throw invalid_argument(
+                string_to_hex("Failure when converting to UTF-8", chars.data(), chars.size(), error_code));
         }
         if (in_begin != in_end) {
-            throw invalid_argument(string_to_hex("in_begin != in_end when converting to UTF-8", chars.data(), chars.size(), error_code));
+            throw invalid_argument(
+                string_to_hex("in_begin != in_end when converting to UTF-8", chars.data(), chars.size(), error_code));
         }
         m_size = out_begin - m_data.get();
         // FIXME: Does this help on string issues? Or does it only help lldb?
         std::memset(tmp_char_array + m_size, 0, buf_size - m_size);
     }
 }
-
diff --git a/realm/realm-library/src/main/cpp/util.hpp b/realm/realm-library/src/main/cpp/util.hpp
index 06c574c3ea..76378a8e42 100644
--- a/realm/realm-library/src/main/cpp/util.hpp
+++ b/realm/realm-library/src/main/cpp/util.hpp
@@ -38,13 +38,13 @@
 
 #include "jni_util/log.hpp"
 
-#define CHECK_PARAMETERS    1       // Check all parameters in API and throw exceptions in java if invalid
+#define CHECK_PARAMETERS 1 // Check all parameters in API and throw exceptions in java if invalid
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved);
+JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);
 
 #ifdef __cplusplus
 }
@@ -54,35 +54,36 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved);
 #define STRINGIZE(x) STRINGIZE_DETAIL(x)
 
 // Exception handling
-#define CATCH_STD() \
-    catch (...) { \
-        ConvertException(env, __FILE__, __LINE__); \
+#define CATCH_STD()                                                                                                  \
+    catch (...)                                                                                                      \
+    {                                                                                                                \
+        ConvertException(env, __FILE__, __LINE__);                                                                   \
     }
 
 template <typename T>
 std::string num_to_string(T pNumber)
 {
- std::ostringstream oOStrStream;
- oOStrStream << pNumber;
- return oOStrStream.str();
+    std::ostringstream oOStrStream;
+    oOStrStream << pNumber;
+    return oOStrStream.str();
 }
 
 
-#define MAX_JINT   0x7FFFFFFFL
-#define MAX_JSIZE  MAX_JINT
+#define MAX_JINT 0x7FFFFFFFL
+#define MAX_JSIZE MAX_JINT
 
 // TODO: Clean up those marcos. Casting with marcos reduces the readability, and it is actually breaking the C++ type
 // conversion. e.g.: You cannot cast a pointer with S64 below.
 // Helper macros for better readability
-#define S(x)    static_cast<size_t>(x)
-#define B(x)    static_cast<bool>(x)
-#define S64(x)  static_cast<int64_t>(x)
-#define TBL(x)  reinterpret_cast<realm::Table*>(x)
-#define TV(x)   reinterpret_cast<realm::TableView*>(x)
-#define LV(x)   reinterpret_cast<realm::LinkViewRef*>(x)
-#define Q(x)    reinterpret_cast<realm::Query*>(x)
-#define ROW(x)  reinterpret_cast<realm::Row*>(x)
-#define HO(T, ptr) reinterpret_cast<realm::SharedGroup::Handover <T>* >(ptr)
+#define S(x) static_cast<size_t>(x)
+#define B(x) static_cast<bool>(x)
+#define S64(x) static_cast<int64_t>(x)
+#define TBL(x) reinterpret_cast<realm::Table*>(x)
+#define TV(x) reinterpret_cast<realm::TableView*>(x)
+#define LV(x) reinterpret_cast<realm::LinkViewRef*>(x)
+#define Q(x) reinterpret_cast<realm::Query*>(x)
+#define ROW(x) reinterpret_cast<realm::Row*>(x)
+#define HO(T, ptr) reinterpret_cast<realm::SharedGroup::Handover<T>*>(ptr)
 
 // Exception handling
 enum ExceptionKind {
@@ -103,84 +104,86 @@ enum ExceptionKind {
     ExceptionKindMax // Always keep this as the last one!
 };
 
-void ConvertException(JNIEnv* env, const char *file, int line);
-void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& classStr, const std::string& itemStr="");
-void ThrowException(JNIEnv* env, ExceptionKind exception, const char *classStr);
-void ThrowNullValueException(JNIEnv* env, realm::Table *table, size_t col_ndx);
+void ConvertException(JNIEnv* env, const char* file, int line);
+void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& classStr,
+                    const std::string& itemStr = "");
+void ThrowException(JNIEnv* env, ExceptionKind exception, const char* classStr);
+void ThrowNullValueException(JNIEnv* env, realm::Table* table, size_t col_ndx);
 
 jclass GetClass(JNIEnv* env, const char* classStr);
 
 
 // Check parameters
 
-#define TABLE_VALID(env,ptr)    TableIsValid(env, ptr)
-#define ROW_VALID(env,ptr)      RowIsValid(env, ptr)
-#define QUERY_VALID(env, ptr)   QueryIsValid(env, ptr)
+#define TABLE_VALID(env, ptr) TableIsValid(env, ptr)
+#define ROW_VALID(env, ptr) RowIsValid(env, ptr)
+#define QUERY_VALID(env, ptr) QueryIsValid(env, ptr)
 
 #if CHECK_PARAMETERS
 
-#define ROW_INDEXES_VALID(env,ptr,start,end, range)             RowIndexesValid(env, ptr, start, end, range)
-#define ROW_INDEX_VALID(env,ptr,row)                            RowIndexValid(env, ptr, row)
-#define ROW_INDEX_VALID_OFFSET(env,ptr,row)                     RowIndexValid(env, ptr, row, true)
-#define TBL_AND_ROW_INDEX_VALID(env,ptr,row)                    TblRowIndexValid(env, ptr, row)
-#define TBL_AND_ROW_INDEX_VALID_OFFSET(env,ptr,row, offset)     TblRowIndexValid(env, ptr, row, offset)
-#define COL_INDEX_VALID(env,ptr,col)                            ColIndexValid(env, ptr, col)
-#define TBL_AND_COL_INDEX_VALID(env,ptr,col)                    TblColIndexValid(env, ptr, col)
-#define COL_INDEX_AND_TYPE_VALID(env,ptr,col,type)              ColIndexAndTypeValid(env, ptr, col, type)
-#define TBL_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)     TblColIndexAndTypeValid(env, ptr, col, type)
-#define TBL_AND_COL_INDEX_AND_LINK_OR_LINKLIST(env,ptr,col)     TblColIndexAndLinkOrLinkList(env, ptr, col)
-#define TBL_AND_COL_NULLABLE(env,ptr,col)                       TblColIndexAndNullable(env, ptr, col)
-#define INDEX_VALID(env,ptr,col,row)                            IndexValid(env, ptr, col, row)
-#define TBL_AND_INDEX_VALID(env,ptr,col,row)                    TblIndexValid(env, ptr, col, row)
-#define TBL_AND_INDEX_INSERT_VALID(env,ptr,col,row)             TblIndexInsertValid(env, ptr, col, row)
-#define INDEX_AND_TYPE_VALID(env,ptr,col,row,type)              IndexAndTypeValid(env, ptr, col, row, type)
-#define TBL_AND_INDEX_AND_TYPE_VALID(env,ptr,col,row,type)      TblIndexAndTypeValid(env, ptr, col, row, type)
-#define TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env,ptr,col,row,type) TblIndexAndTypeInsertValid(env, ptr, col, row, type)
-
-#define ROW_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col,type)     RowColIndexAndTypeValid(env, ptr, col, type)
-#define ROW_AND_COL_INDEX_VALID(env,ptr,col)                    RowColIndexValid(env, ptr, col)
+#define ROW_INDEXES_VALID(env, ptr, start, end, range) RowIndexesValid(env, ptr, start, end, range)
+#define ROW_INDEX_VALID(env, ptr, row) RowIndexValid(env, ptr, row)
+#define ROW_INDEX_VALID_OFFSET(env, ptr, row) RowIndexValid(env, ptr, row, true)
+#define TBL_AND_ROW_INDEX_VALID(env, ptr, row) TblRowIndexValid(env, ptr, row)
+#define TBL_AND_ROW_INDEX_VALID_OFFSET(env, ptr, row, offset) TblRowIndexValid(env, ptr, row, offset)
+#define COL_INDEX_VALID(env, ptr, col) ColIndexValid(env, ptr, col)
+#define TBL_AND_COL_INDEX_VALID(env, ptr, col) TblColIndexValid(env, ptr, col)
+#define COL_INDEX_AND_TYPE_VALID(env, ptr, col, type) ColIndexAndTypeValid(env, ptr, col, type)
+#define TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ptr, col, type) TblColIndexAndTypeValid(env, ptr, col, type)
+#define TBL_AND_COL_INDEX_AND_LINK_OR_LINKLIST(env, ptr, col) TblColIndexAndLinkOrLinkList(env, ptr, col)
+#define TBL_AND_COL_NULLABLE(env, ptr, col) TblColIndexAndNullable(env, ptr, col)
+#define INDEX_VALID(env, ptr, col, row) IndexValid(env, ptr, col, row)
+#define TBL_AND_INDEX_VALID(env, ptr, col, row) TblIndexValid(env, ptr, col, row)
+#define TBL_AND_INDEX_INSERT_VALID(env, ptr, col, row) TblIndexInsertValid(env, ptr, col, row)
+#define INDEX_AND_TYPE_VALID(env, ptr, col, row, type) IndexAndTypeValid(env, ptr, col, row, type)
+#define TBL_AND_INDEX_AND_TYPE_VALID(env, ptr, col, row, type) TblIndexAndTypeValid(env, ptr, col, row, type)
+#define TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, ptr, col, row, type)                                                \
+    TblIndexAndTypeInsertValid(env, ptr, col, row, type)
+
+#define ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ptr, col, type) RowColIndexAndTypeValid(env, ptr, col, type)
+#define ROW_AND_COL_INDEX_VALID(env, ptr, col) RowColIndexValid(env, ptr, col)
 
 #else
 
-#define ROW_INDEXES_VALID(env,ptr,start,end, range)             (true)
-#define ROW_INDEX_VALID(env,ptr,row)                            (true)
-#define ROW_INDEX_VALID_OFFSET(env,ptr,row)                     (true)
-#define TBL_AND_ROW_INDEX_VALID(env,ptr,row)                    (true)
-#define TBL_AND_ROW_INDEX_VALID_OFFSET(env,ptr,row, offset)     (true)
-#define COL_INDEX_VALID(env,ptr,col)                            (true)
-#define TBL_AND_COL_INDEX_VALID(env,ptr,col)                    (true)
-#define COL_INDEX_AND_TYPE_VALID(env,ptr,col,type)              (true)
-#define TBL_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)     (true)
-#define TBL_AND_COL_INDEX_AND_LINK_OR_LINKLIST(env,ptr,col)     (true)
-#define TBL_AND_COL_NULLABLE(env,ptr,col)                       (true)
-#define INDEX_VALID(env,ptr,col,row)                            (true)
-#define TBL_AND_INDEX_VALID(env,ptr,col,row)                    (true)
-#define TBL_AND_INDEX_INSERT_VALID(env,ptr,col,row)             (true)
-#define INDEX_AND_TYPE_VALID(env,ptr,col,row,type)              (true)
-#define TBL_AND_INDEX_AND_TYPE_VALID(env,ptr,col,row,type)      (true)
-#define TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env,ptr,col,row,type) (true)
-
-#define ROW_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)     (true)
-#define ROW_AND_COL_INDEX_VALID(env,ptr,col)                    (true)
+#define ROW_INDEXES_VALID(env, ptr, start, end, range) (true)
+#define ROW_INDEX_VALID(env, ptr, row) (true)
+#define ROW_INDEX_VALID_OFFSET(env, ptr, row) (true)
+#define TBL_AND_ROW_INDEX_VALID(env, ptr, row) (true)
+#define TBL_AND_ROW_INDEX_VALID_OFFSET(env, ptr, row, offset) (true)
+#define COL_INDEX_VALID(env, ptr, col) (true)
+#define TBL_AND_COL_INDEX_VALID(env, ptr, col) (true)
+#define COL_INDEX_AND_TYPE_VALID(env, ptr, col, type) (true)
+#define TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ptr, col, type) (true)
+#define TBL_AND_COL_INDEX_AND_LINK_OR_LINKLIST(env, ptr, col) (true)
+#define TBL_AND_COL_NULLABLE(env, ptr, col) (true)
+#define INDEX_VALID(env, ptr, col, row) (true)
+#define TBL_AND_INDEX_VALID(env, ptr, col, row) (true)
+#define TBL_AND_INDEX_INSERT_VALID(env, ptr, col, row) (true)
+#define INDEX_AND_TYPE_VALID(env, ptr, col, row, type) (true)
+#define TBL_AND_INDEX_AND_TYPE_VALID(env, ptr, col, row, type) (true)
+#define TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, ptr, col, row, type) (true)
+
+#define ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ptr, col, type) (true)
+#define ROW_AND_COL_INDEX_VALID(env, ptr, col) (true)
 
 #endif
 
 
-inline jlong to_jlong_or_not_found(size_t res) {
+inline jlong to_jlong_or_not_found(size_t res)
+{
     return (res == realm::not_found) ? jlong(-1) : jlong(res);
 }
 
 template <class T>
 inline bool TableIsValid(JNIEnv* env, T* objPtr)
 {
-    bool valid = (objPtr != NULL);
+    bool valid = (objPtr != nullptr);
     if (valid) {
         // Check if Table is valid
         if (std::is_same<realm::Table, T>::value) {
             valid = TBL(objPtr)->is_attached();
         }
         // TODO: Add check for TableView
-
     }
     if (!valid) {
         realm::jni_util::Log::e("Table %1 is no longer attached!", reinterpret_cast<int64_t>(objPtr));
@@ -194,7 +197,8 @@ inline bool RowIsValid(JNIEnv* env, realm::Row* rowPtr)
     bool valid = (rowPtr != NULL && rowPtr->is_attached());
     if (!valid) {
         realm::jni_util::Log::e("Row %1 is no longer attached!", reinterpret_cast<int64_t>(rowPtr));
-        ThrowException(env, IllegalState, "Object is no longer valid to operate on. Was it deleted by another thread?");
+        ThrowException(env, IllegalState,
+                       "Object is no longer valid to operate on. Was it deleted by another thread?");
     }
     return valid;
 }
@@ -210,8 +214,9 @@ template <class T>
 bool RowIndexesValid(JNIEnv* env, T* pTable, jlong startIndex, jlong endIndex, jlong range)
 {
     size_t maxIndex = pTable->size();
-    if (endIndex == -1)
+    if (endIndex == -1) {
         endIndex = maxIndex;
+    }
     if (startIndex < 0) {
         realm::jni_util::Log::e("startIndex %1 < 0 - invalid!", S64(startIndex));
         ThrowException(env, IndexOutOfBounds, "startIndex < 0.");
@@ -229,8 +234,7 @@ bool RowIndexesValid(JNIEnv* env, T* pTable, jlong startIndex, jlong endIndex, j
         return false;
     }
     if (startIndex > endIndex) {
-        realm::jni_util::Log::e(
-                "startIndex %1 > endIndex %2 - invalid!", S64(startIndex), S64(endIndex));
+        realm::jni_util::Log::e("startIndex %1 > endIndex %2 - invalid!", S64(startIndex), S64(endIndex));
         ThrowException(env, IndexOutOfBounds, "startIndex > endIndex.");
         return false;
     }
@@ -245,31 +249,32 @@ bool RowIndexesValid(JNIEnv* env, T* pTable, jlong startIndex, jlong endIndex, j
 }
 
 template <class T>
-inline bool RowIndexValid(JNIEnv* env, T pTable, jlong rowIndex, bool offset=false)
+inline bool RowIndexValid(JNIEnv* env, T pTable, jlong rowIndex, bool offset = false)
 {
     if (rowIndex < 0) {
         ThrowException(env, IndexOutOfBounds, "rowIndex is less than 0.");
         return false;
     }
     size_t size = pTable->size();
-    if (size > 0 && offset)
+    if (size > 0 && offset) {
         size -= 1;
+    }
     bool rowErr = realm::util::int_greater_than_or_equal(rowIndex, size);
     if (rowErr) {
         realm::jni_util::Log::e("rowIndex %1 > %2 - invalid!", S64(rowIndex), S64(size));
         ThrowException(env, IndexOutOfBounds,
-            "rowIndex > available rows: " +
-            num_to_string(rowIndex) + " > " + num_to_string(size));
+                       "rowIndex > available rows: " + num_to_string(rowIndex) + " > " + num_to_string(size));
     }
     return !rowErr;
 }
 
 template <class T>
-inline bool TblRowIndexValid(JNIEnv* env, T* pTable, jlong rowIndex, bool offset=false)
+inline bool TblRowIndexValid(JNIEnv* env, T* pTable, jlong rowIndex, bool offset = false)
 {
     if (std::is_same<realm::Table, T>::value) {
-        if (!TableIsValid(env, TBL(pTable)))
+        if (!TableIsValid(env, TBL(pTable))) {
             return false;
+        }
     }
     return RowIndexValid(env, pTable, rowIndex, offset);
 }
@@ -283,8 +288,7 @@ inline bool ColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
     }
     bool colErr = realm::util::int_greater_than_or_equal(columnIndex, pTable->get_column_count());
     if (colErr) {
-        realm::jni_util::Log::e(
-                "columnIndex %1 > %2 - invalid!", S64(columnIndex), S64(pTable->get_column_count()));
+        realm::jni_util::Log::e("columnIndex %1 > %2 - invalid!", S64(columnIndex), S64(pTable->get_column_count()));
         ThrowException(env, IndexOutOfBounds, "columnIndex > available columns.");
     }
     return !colErr;
@@ -294,8 +298,9 @@ template <class T>
 inline bool TblColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
 {
     if (std::is_same<realm::Table, T>::value) {
-        if (!TableIsValid(env, TBL(pTable)))
+        if (!TableIsValid(env, TBL(pTable))) {
             return false;
+        }
     }
     return ColIndexValid(env, pTable, columnIndex);
 }
@@ -308,28 +313,26 @@ inline bool RowColIndexValid(JNIEnv* env, realm::Row* pRow, jlong columnIndex)
 template <class T>
 inline bool IndexValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex)
 {
-    return ColIndexValid(env, pTable, columnIndex)
-        && RowIndexValid(env, pTable, rowIndex);
+    return ColIndexValid(env, pTable, columnIndex) && RowIndexValid(env, pTable, rowIndex);
 }
 
 template <class T>
 inline bool TblIndexValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex)
 {
-    return TableIsValid(env, pTable)
-        && IndexValid(env, pTable, columnIndex, rowIndex);
+    return TableIsValid(env, pTable) && IndexValid(env, pTable, columnIndex, rowIndex);
 }
 
 template <class T>
 inline bool TblIndexInsertValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex)
 {
-    if (!TblColIndexValid(env, pTable, columnIndex))
+    if (!TblColIndexValid(env, pTable, columnIndex)) {
         return false;
-    bool rowErr = realm::util::int_greater_than(rowIndex, pTable->size()+1);
+    }
+    bool rowErr = realm::util::int_greater_than(rowIndex, pTable->size() + 1);
     if (rowErr) {
         realm::jni_util::Log::e("rowIndex %1 > %2 - invalid!", S64(rowIndex), S64(pTable->size()));
-        ThrowException(env, IndexOutOfBounds,
-            "rowIndex " + num_to_string(rowIndex) +
-            " > available rows " + num_to_string(pTable->size()) + ".");
+        ThrowException(env, IndexOutOfBounds, "rowIndex " + num_to_string(rowIndex) + " > available rows " +
+                                                  num_to_string(pTable->size()) + ".");
     }
     return !rowErr;
 }
@@ -356,8 +359,8 @@ inline bool TypeIsLinkLike(JNIEnv* env, T* pTable, jlong columnIndex)
         return true;
     }
 
-    realm::jni_util::Log::e(
-            "Expected columnType %1 or %2, but got %3", realm::type_Link, realm::type_LinkList, colType);
+    realm::jni_util::Log::e("Expected columnType %1 or %2, but got %3", realm::type_Link, realm::type_LinkList,
+                            colType);
     ThrowException(env, IllegalArgument, "ColumnType invalid: expected type_Link or type_LinkList");
     return false;
 }
@@ -388,41 +391,37 @@ inline bool ColIsNullable(JNIEnv* env, T* pTable, jlong columnIndex)
 template <class T>
 inline bool ColIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, int expectColType)
 {
-    return ColIndexValid(env, pTable, columnIndex)
-        && TypeValid(env, pTable, columnIndex, expectColType);
+    return ColIndexValid(env, pTable, columnIndex) && TypeValid(env, pTable, columnIndex, expectColType);
 }
 template <class T>
 inline bool TblColIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, int expectColType)
 {
-    return TableIsValid(env, pTable)
-        && ColIndexAndTypeValid(env, pTable, columnIndex, expectColType);
+    return TableIsValid(env, pTable) && ColIndexAndTypeValid(env, pTable, columnIndex, expectColType);
 }
 
 template <class T>
-inline bool TblColIndexAndLinkOrLinkList(JNIEnv* env, T* pTable, jlong columnIndex) {
-    return TableIsValid(env, pTable)
-        && TypeIsLinkLike(env, pTable, columnIndex);
+inline bool TblColIndexAndLinkOrLinkList(JNIEnv* env, T* pTable, jlong columnIndex)
+{
+    return TableIsValid(env, pTable) && TypeIsLinkLike(env, pTable, columnIndex);
 }
 
 // FIXME Usually this is called after TBL_AND_INDEX_AND_TYPE_VALID which will validate Table as well.
 // Try to avoid duplicated checks to improve performance.
 template <class T>
-inline bool TblColIndexAndNullable(JNIEnv* env, T* pTable, jlong columnIndex) {
-    return TableIsValid(env, pTable)
-        && ColIsNullable(env, pTable, columnIndex);
+inline bool TblColIndexAndNullable(JNIEnv* env, T* pTable, jlong columnIndex)
+{
+    return TableIsValid(env, pTable) && ColIsNullable(env, pTable, columnIndex);
 }
 
 inline bool RowColIndexAndTypeValid(JNIEnv* env, realm::Row* pRow, jlong columnIndex, int expectColType)
 {
-    return RowIsValid(env, pRow)
-        && ColIndexAndTypeValid(env, pRow->get_table(), columnIndex, expectColType);
+    return RowIsValid(env, pRow) && ColIndexAndTypeValid(env, pRow->get_table(), columnIndex, expectColType);
 }
 
 template <class T>
 inline bool IndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType)
 {
-    return IndexValid(env, pTable, columnIndex, rowIndex)
-        && TypeValid(env, pTable, columnIndex, expectColType);
+    return IndexValid(env, pTable, columnIndex, rowIndex) && TypeValid(env, pTable, columnIndex, expectColType);
 }
 template <class T>
 inline bool TblIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType)
@@ -433,8 +432,8 @@ inline bool TblIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlon
 template <class T>
 inline bool TblIndexAndTypeInsertValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType)
 {
-    return TblIndexInsertValid(env, pTable, columnIndex, rowIndex)
-        && TypeValid(env, pTable, columnIndex, expectColType);
+    return TblIndexInsertValid(env, pTable, columnIndex, rowIndex) &&
+           TypeValid(env, pTable, columnIndex, expectColType);
 }
 
 bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, realm::BinaryData& data);
@@ -442,7 +441,7 @@ bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, realm::BinaryData& data);
 
 // Utility function for appending StringData, which is returned
 // by a lot of core functions, and might potentially be NULL.
-std::string concat_stringdata(const char *message, realm::StringData data);
+std::string concat_stringdata(const char* message, realm::StringData data);
 
 // Note: JNI offers methods to convert between modified UTF-8 and
 // UTF-16. Unfortunately these methods are not appropriate in this
@@ -459,7 +458,7 @@ jstring to_jstring(JNIEnv*, realm::StringData);
 
 class JStringAccessor {
 public:
-    JStringAccessor(JNIEnv*, jstring);  // throws
+    JStringAccessor(JNIEnv*, jstring); // throws
 
     operator realm::StringData() const noexcept
     {
@@ -492,17 +491,18 @@ class JniLongArray {
         , m_javaArray(javaArray)
         , m_arrayLength(javaArray == NULL ? 0 : env->GetArrayLength(javaArray))
         , m_array(javaArray == NULL ? NULL : env->GetLongArrayElements(javaArray, NULL))
-        , m_releaseMode(JNI_ABORT) {
+        , m_releaseMode(JNI_ABORT)
+    {
     }
 
     JniLongArray(JniLongArray& other) = delete;
 
     JniLongArray(JniLongArray&& other)
-            : m_env(other.m_env)
-            , m_javaArray(other.m_javaArray)
-            , m_arrayLength(other.m_arrayLength)
-            , m_array(other.m_array)
-            , m_releaseMode(other.m_releaseMode)
+        : m_env(other.m_env)
+        , m_javaArray(other.m_javaArray)
+        , m_arrayLength(other.m_arrayLength)
+        , m_array(other.m_array)
+        , m_releaseMode(other.m_releaseMode)
     {
         other.m_env = nullptr;
         other.m_javaArray = nullptr;
@@ -538,20 +538,20 @@ class JniLongArray {
     }
 
 private:
-    JNIEnv*    m_env;
+    JNIEnv* m_env;
     jlongArray m_javaArray;
-    jsize      m_arrayLength;
-    jlong*     m_array;
-    jint       m_releaseMode;
+    jsize m_arrayLength;
+    jlong* m_array;
+    jint m_releaseMode;
 };
 
 template <typename T, typename J>
 class JniArrayOfArrays {
 public:
     JniArrayOfArrays(JNIEnv* env, jobjectArray javaArray)
-            : m_env(env)
-            , m_javaArray(javaArray)
-            , m_arrayLength(javaArray == nullptr ? 0 : env->GetArrayLength(javaArray))
+        : m_env(env)
+        , m_javaArray(javaArray)
+        , m_arrayLength(javaArray == nullptr ? 0 : env->GetArrayLength(javaArray))
     {
         for (int i = 0; i < m_arrayLength; ++i) {
             // No type checking. Internal use only.
@@ -588,10 +588,12 @@ class JniByteArray {
         , m_javaArray(javaArray)
         , m_arrayLength(javaArray == NULL ? 0 : env->GetArrayLength(javaArray))
         , m_array(javaArray == NULL ? NULL : env->GetByteArrayElements(javaArray, NULL))
-        , m_releaseMode(JNI_ABORT) {
+        , m_releaseMode(JNI_ABORT)
+    {
         if (m_javaArray != nullptr && m_array == nullptr) {
             // javaArray is not null but GetByteArrayElements returns null, something is really wrong.
-            throw std::runtime_error(realm::util::format("GetByteArrayElements failed on byte array %x", m_javaArray));
+            throw std::runtime_error(
+                realm::util::format("GetByteArrayElements failed on byte array %x", m_javaArray));
         }
     }
 
@@ -617,11 +619,13 @@ class JniByteArray {
         return m_array[index];
     }
 
-    inline operator realm::BinaryData() const noexcept {
-        return realm::BinaryData(reinterpret_cast<const char *>(m_array), m_arrayLength);
+    inline operator realm::BinaryData() const noexcept
+    {
+        return realm::BinaryData(reinterpret_cast<const char*>(m_array), m_arrayLength);
     }
 
-    inline operator std::vector<char>() const noexcept {
+    inline operator std::vector<char>() const noexcept
+    {
         if (m_array == nullptr) {
             return {};
         }
@@ -637,11 +641,11 @@ class JniByteArray {
     }
 
 private:
-    JNIEnv*    const m_env;
+    JNIEnv* const m_env;
     jbyteArray const m_javaArray;
-    jsize      const m_arrayLength;
-    jbyte*     const m_array;
-    jint             m_releaseMode;
+    jsize const m_arrayLength;
+    jbyte* const m_array;
+    jint m_releaseMode;
 };
 
 class JniBooleanArray {
@@ -651,7 +655,8 @@ class JniBooleanArray {
         , m_javaArray(javaArray)
         , m_arrayLength(javaArray == NULL ? 0 : env->GetArrayLength(javaArray))
         , m_array(javaArray == NULL ? NULL : env->GetBooleanArrayElements(javaArray, NULL))
-        , m_releaseMode(JNI_ABORT) {
+        , m_releaseMode(JNI_ABORT)
+    {
     }
 
     ~JniBooleanArray()
@@ -682,11 +687,11 @@ class JniBooleanArray {
     }
 
 private:
-    JNIEnv*       const m_env;
+    JNIEnv* const m_env;
     jbooleanArray const m_javaArray;
-    jsize         const m_arrayLength;
-    jboolean*     const m_array;
-    jint                m_releaseMode;
+    jsize const m_arrayLength;
+    jboolean* const m_array;
+    jint m_releaseMode;
 };
 
 extern jclass java_lang_long;
@@ -735,18 +740,21 @@ inline realm::Timestamp from_milliseconds(jlong milliseconds)
     return realm::Timestamp(seconds, nanoseconds);
 }
 
-inline jobject NewDate(JNIEnv* env, const realm::Timestamp& ts) {
+inline jobject NewDate(JNIEnv* env, const realm::Timestamp& ts)
+{
     return env->NewObject(java_util_date, java_util_date_init, to_milliseconds(ts));
 }
 
 extern const std::string TABLE_PREFIX;
 
-static inline bool to_bool(jboolean b) {
+static inline bool to_bool(jboolean b)
+{
     return b == JNI_TRUE;
 }
 
-static inline jboolean to_jbool(bool b) {
-    return b?JNI_TRUE:JNI_FALSE;
+static inline jboolean to_jbool(bool b)
+{
+    return b ? JNI_TRUE : JNI_FALSE;
 }
 
 #endif // REALM_JAVA_UTIL_HPP
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 0369321866..63881a0153 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -269,7 +269,9 @@ static Realm createInstance(RealmConfiguration configuration, ColumnIndices[] gl
                 deleteRealm(configuration);
             } else {
                 try {
-                    migrateRealm(configuration, e);
+                    if (configuration.getMigration() != null) {
+                        migrateRealm(configuration, e);
+                    }
                 } catch (FileNotFoundException fileNotFoundException) {
                     // Should never happen.
                     throw new RealmFileException(RealmFileException.Kind.NOT_FOUND, fileNotFoundException);
@@ -341,11 +343,14 @@ private static void initializeRealm(Realm realm) {
             final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
 
             final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
-            for (Class<? extends RealmModel> modelClass : modelClasses) {
-                // Creates and validates table.
-                if (unversioned) {
+            if (unversioned) {
+                // Create all of the tables.
+                for (Class<? extends RealmModel> modelClass : modelClasses) {
                     mediator.createTable(modelClass, realm.sharedRealm);
                 }
+            }
+            for (Class<? extends RealmModel> modelClass : modelClasses) {
+                // Now that they have all been created, validate them.
                 columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
             }
 
@@ -1421,8 +1426,8 @@ public void run() {
                     return;
                 }
 
-                final SharedRealm.VersionID[] versionID = new SharedRealm.VersionID[1];
-                final Throwable[] exception = new Throwable[1];
+                SharedRealm.VersionID versionID = null;
+                Throwable exception = null;
 
                 final Realm bgRealm = Realm.getInstance(realmConfiguration);
                 bgRealm.beginTransaction();
@@ -1436,18 +1441,24 @@ public void run() {
                     bgRealm.commitTransaction();
                     // The bgRealm needs to be closed before post event to caller's handler to avoid concurrency
                     // problem. This is currently guaranteed by posting callbacks later below.
-                    versionID[0] = bgRealm.sharedRealm.getVersionID();
+                    versionID = bgRealm.sharedRealm.getVersionID();
                 } catch (final Throwable e) {
-                    exception[0] = e;
+                    exception = e;
                 } finally {
-                    // SharedGroup::close() will cancel the transaction if needed.
-                    bgRealm.close();
+                    try {
+                        if (bgRealm.isInTransaction()) {
+                            bgRealm.cancelTransaction();
+                        }
+                    } finally {
+                        bgRealm.close();
+                    }
                 }
 
-                final Throwable backgroundException = exception[0];
+                final Throwable backgroundException = exception;
+                final SharedRealm.VersionID backgroundVersionID = versionID;
                 // Cannot be interrupted anymore.
                 if (canDeliverNotification ) {
-                    if (versionID[0] != null && onSuccess != null) {
+                    if (backgroundVersionID != null && onSuccess != null) {
                         realmNotifier.post(new Runnable() {
                             @Override
                             public void run() {
@@ -1458,7 +1469,7 @@ public void run() {
                                     return;
                                 }
 
-                                if (sharedRealm.getVersionID().compareTo(versionID[0]) < 0) {
+                                if (sharedRealm.getVersionID().compareTo(backgroundVersionID) < 0) {
                                     sharedRealm.realmNotifier.addTransactionCallback(new Runnable() {
                                         @Override
                                         public void run() {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCollection.java b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
index 722d1253d3..120103c780 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
@@ -172,5 +172,6 @@
      * @throws NullPointerException if the object to look for is {@code null} and this {@code Collection} doesn't
      *                              support {@code null} elements.
      */
+    @Override
     boolean contains(Object object);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index d3ede7d912..04b06fb12f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -119,6 +119,7 @@ public RealmList(E... objects) {
     /**
      * {@inheritDoc}
      */
+    @Override
     public boolean isValid() {
         if (realm == null) {
             return true;
@@ -133,6 +134,7 @@ public boolean isValid() {
     /**
      * {@inheritDoc}
      */
+    @Override
     public boolean isManaged() {
         return realm != null;
     }
@@ -459,6 +461,7 @@ public E get(int location) {
     /**
      * {@inheritDoc}
      */
+    @Override
     public E first() {
         return firstImpl(true, null);
     }
@@ -466,6 +469,7 @@ public E first() {
     /**
     * {@inheritDoc}
     */
+    @Override
     public E first(E defaultValue) {
         return firstImpl(false, defaultValue);
     }
@@ -490,6 +494,7 @@ private E firstImpl(boolean shouldThrow, E defaultValue) {
     /**
      * {@inheritDoc}
      */
+    @Override
     public E last() {
         return lastImpl(true, null);
     }
@@ -497,6 +502,7 @@ public E last() {
     /**
      * {@inheritDoc}
      */
+    @Override
     public E last(E defaultValue) {
         return lastImpl(false, defaultValue);
     }
@@ -596,6 +602,7 @@ public int size() {
      * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
      * @see io.realm.RealmQuery
      */
+    @Override
     public RealmQuery<E> where() {
         if (isManaged()) {
             checkValidView();
@@ -977,6 +984,7 @@ public void removeAllChangeListeners() {
         /**
          * {@inheritDoc}
          */
+        @Override
         public boolean hasNext() {
             realm.checkIfValid();
             checkConcurrentModification();
@@ -986,6 +994,7 @@ public boolean hasNext() {
         /**
          * {@inheritDoc}
          */
+        @Override
         public E next() {
             realm.checkIfValid();
             checkConcurrentModification();
@@ -1004,6 +1013,7 @@ public E next() {
         /**
          * {@inheritDoc}
          */
+        @Override
         public void remove() {
             realm.checkIfValid();
             if (lastRet < 0) {
@@ -1049,6 +1059,7 @@ final void checkConcurrentModification() {
         /**
          * {@inheritDoc}
          */
+        @Override
         public boolean hasPrevious() {
             return cursor != 0;
         }
@@ -1056,6 +1067,7 @@ public boolean hasPrevious() {
         /**
          * {@inheritDoc}
          */
+        @Override
         public E previous() {
             checkConcurrentModification();
             int i = cursor - 1;
@@ -1072,6 +1084,7 @@ public E previous() {
         /**
          * {@inheritDoc}
          */
+        @Override
         public int nextIndex() {
             return cursor;
         }
@@ -1079,6 +1092,7 @@ public int nextIndex() {
         /**
          * {@inheritDoc}
          */
+        @Override
         public int previousIndex() {
             return cursor - 1;
         }
@@ -1086,6 +1100,7 @@ public int previousIndex() {
         /**
          * {@inheritDoc}
          */
+        @Override
         public void set(E e) {
             realm.checkIfValid();
             if (lastRet < 0) {
@@ -1107,6 +1122,7 @@ public void set(E e) {
          *
          * @see #add(RealmModel)
          */
+        @Override
         public void add(E e) {
             realm.checkIfValid();
             checkConcurrentModification();
@@ -1121,5 +1137,4 @@ public void add(E e) {
             }
         }
     }
-
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index f52e59c2db..03266e7308 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -273,7 +273,7 @@ protected RealmObjectSchema add(Property property) {
     private Set<Property> getProperties() {
         if (realm == null) {
             long[] ptrs = nativeGetProperties(nativePtr);
-            Set<Property> properties = new LinkedHashSet<>(ptrs.length);
+            Set<Property> properties = new LinkedHashSet<Property>(ptrs.length);
             for (int i = 0; i < ptrs.length; i++) {
                 properties.add(new Property(ptrs[i]));
             }
@@ -556,7 +556,7 @@ public String getPrimaryKey() {
      */
     public Set<String> getFieldNames() {
         int columnCount = (int) table.getColumnCount();
-        Set<String> columnNames = new LinkedHashSet<>(columnCount);
+        Set<String> columnNames = new LinkedHashSet<String>(columnCount);
         for (int i = 0; i < columnCount; i++) {
             columnNames.add(table.getColumnName(i));
         }
@@ -604,7 +604,7 @@ private void addModifiers(String fieldName, FieldAttribute[] attributes) {
             if (indexAdded) {
                 table.removeSearchIndex(columnIndex);
             }
-            throw e;
+            throw (RuntimeException) e;
         }
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index e6a55ab77e..ff36830844 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -20,7 +20,10 @@
 import android.os.Looper;
 
 import io.realm.internal.Collection;
+import io.realm.internal.Row;
 import io.realm.internal.SortDescriptor;
+import io.realm.internal.Table;
+import io.realm.internal.UncheckedRow;
 import rx.Observable;
 
 /**
@@ -51,6 +54,18 @@
  * @see Realm#executeTransaction(Realm.Transaction)
  */
 public class RealmResults<E extends RealmModel> extends OrderedRealmCollectionImpl<E> {
+    static <T extends RealmModel> RealmResults<T> createBacklinkResults(BaseRealm realm, Row row, Class<T> srcTableType, String srcFieldName) {
+        if (!(row instanceof UncheckedRow)) {
+            throw new IllegalArgumentException("Row is " + row.getClass());
+        }
+        UncheckedRow uncheckedRow = (UncheckedRow) row;
+        Table srcTable = realm.getSchema().getTable(srcTableType);
+        return new RealmResults<T>(
+            realm,
+            Collection.createBacklinksCollection(realm.sharedRealm, uncheckedRow, srcTable, srcFieldName),
+            srcTableType);
+    }
+
 
     RealmResults(BaseRealm realm, Collection collection, Class<E> clazz) {
         super(realm, collection, clazz);
@@ -84,6 +99,7 @@
      * @return {@code true} if the query has completed and the data is available, {@code false} if the query is still
      * running in the background.
      */
+    @Override
     public boolean isLoaded() {
         realm.checkIfValid();
         return collection.isLoaded();
@@ -95,6 +111,7 @@ public boolean isLoaded() {
      *
      * @return {@code true} if it successfully completed the query, {@code false} otherwise.
      */
+    @Override
     public boolean load() {
         // The Collection doesn't have to be loaded before accessing it if the query has not returned.
         // Instead, accessing the Collection will just trigger the execution of query if needed. We add this flag is
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index 2584b4278f..61e067dd23 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -131,14 +131,14 @@ public RealmObjectSchema get(String className) {
     public Set<RealmObjectSchema> getAll() {
         if (realm == null) {
             long[] ptrs = nativeGetAll(nativePtr);
-            Set<RealmObjectSchema> schemas = new LinkedHashSet<>(ptrs.length);
+            Set<RealmObjectSchema> schemas = new LinkedHashSet<RealmObjectSchema>(ptrs.length);
             for (int i = 0; i < ptrs.length; i++) {
                 schemas.add(new RealmObjectSchema(ptrs[i]));
             }
             return schemas;
         } else {
             int tableCount = (int) realm.sharedRealm.size();
-            Set<RealmObjectSchema> schemas = new LinkedHashSet<>(tableCount);
+            Set<RealmObjectSchema> schemas = new LinkedHashSet<RealmObjectSchema>(tableCount);
             for (int i = 0; i < tableCount; i++) {
                 String tableName = realm.sharedRealm.getTableName(i);
                 if (!Table.isModelTable(tableName)) {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
index 9e0e762086..ca458a44a0 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
@@ -107,27 +107,50 @@ public void setNull(long columnIndex) {
         }
     }
 
+    @Override
     protected native long nativeGetColumnCount(long nativeTablePtr);
+    @Override
     protected native String nativeGetColumnName(long nativeTablePtr, long columnIndex);
+    @Override
     protected native long nativeGetColumnIndex(long nativeTablePtr, String columnName);
+    @Override
     protected native int nativeGetColumnType(long nativeTablePtr, long columnIndex);
+    @Override
     protected native long nativeGetLong(long nativeRowPtr, long columnIndex);
+    @Override
     protected native boolean nativeGetBoolean(long nativeRowPtr, long columnIndex);
+    @Override
     protected native float nativeGetFloat(long nativeRowPtr, long columnIndex);
+    @Override
     protected native double nativeGetDouble(long nativeRowPtr, long columnIndex);
+    @Override
     protected native long nativeGetTimestamp(long nativeRowPtr, long columnIndex);
+    @Override
     protected native String nativeGetString(long nativePtr, long columnIndex);
+    @Override
     protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
+    @Override
     protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
+    @Override
     protected native long nativeGetLinkView(long nativePtr, long columnIndex);
+    @Override
     protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
+    @Override
     protected native void nativeSetBoolean(long nativeRowPtr, long columnIndex, boolean value);
+    @Override
     protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
+    @Override
     protected native long nativeGetLink(long nativeRowPtr, long columnIndex);
+    @Override
     protected native void nativeSetDouble(long nativeRowPtr, long columnIndex, double value);
+    @Override
     protected native void nativeSetTimestamp(long nativeRowPtr, long columnIndex, long dateTimeValue);
+    @Override
     protected native void nativeSetString(long nativeRowPtr, long columnIndex, String value);
+    @Override
     protected native void nativeSetByteArray(long nativePtr, long columnIndex, byte[] data);
+    @Override
     protected native void nativeSetLink(long nativeRowPtr, long columnIndex, long value);
+    @Override
     protected native void nativeNullifyLink(long nativeRowPtr, long columnIndex);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Collection.java b/realm/realm-library/src/main/java/io/realm/internal/Collection.java
index 704e8cbdff..07f19d1a15 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Collection.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Collection.java
@@ -31,7 +31,7 @@
 @Keep
 public class Collection implements NativeObject {
 
-    private class CollectionObserverPair<T> extends ObserverPairList.ObserverPair<T, Object> {
+    private static class CollectionObserverPair<T> extends ObserverPairList.ObserverPair<T, Object> {
         public CollectionObserverPair(T observer, Object listener) {
             super(observer, listener);
         }
@@ -135,6 +135,7 @@ public T next() {
          *
          * @throws UnsupportedOperationException
          */
+        @Override
         @Deprecated
         public void remove() {
             throw new UnsupportedOperationException("remove() is not supported by RealmResults iterators.");
@@ -318,6 +319,15 @@ static Mode getByValue(byte value) {
         }
     }
 
+    public static Collection createBacklinksCollection(SharedRealm realm, UncheckedRow row, Table srcTable, String srcFieldName) {
+        long backlinksPtr = nativeCreateResultsFromBacklinks(
+            realm.getNativePtr(),
+            row.getNativePtr(),
+            srcTable.getNativePtr(),
+            srcTable.getColumnIndex(srcFieldName));
+        return new Collection(realm, row.getTable(), backlinksPtr, true);
+    }
+
     public Collection(SharedRealm sharedRealm, TableQuery query,
                       SortDescriptor sortDescriptor, SortDescriptor distinctDescriptor) {
         query.validateQuery();
@@ -355,12 +365,16 @@ public Collection(SharedRealm sharedRealm, LinkView linkView, SortDescriptor sor
     }
 
     private Collection(SharedRealm sharedRealm, Table table, long nativePtr) {
+        this(sharedRealm, table, nativePtr, false);
+    }
+
+    private Collection(SharedRealm sharedRealm, Table table, long nativePtr, boolean loaded) {
         this.sharedRealm = sharedRealm;
         this.context = sharedRealm.context;
         this.table = table;
         this.nativePtr = nativePtr;
         this.context.addReference(this);
-        this.loaded = false;
+        this.loaded = loaded;
     }
 
     public Collection createSnapshot() {
@@ -560,4 +574,5 @@ private static native long nativeCreateResultsFromLinkView(long sharedRealmNativ
     private static native long nativeIndexOfBySourceRowIndex(long nativePtr, long sourceRowIndex);
     private static native boolean nativeIsValid(long nativePtr);
     private static native byte nativeGetMode(long nativePtr);
+    private static native long nativeCreateResultsFromBacklinks(long sharedRealmNativePtr, long rowNativePtr, long srcTableNativePtr, long srColIndex);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
index 0e89e649ed..8f8dd28694 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
@@ -69,7 +69,7 @@ public ColumnIndices clone() {
     }
 
     private Map<Class<? extends RealmModel>, ColumnInfo> duplicateColumnInfoMap() {
-        final Map<Class<? extends RealmModel>, ColumnInfo> copy = new HashMap<>();
+        final Map<Class<? extends RealmModel>, ColumnInfo> copy = new HashMap<Class<? extends RealmModel>, ColumnInfo>();
         for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classes.entrySet()) {
             copy.put(entry.getKey(), entry.getValue().clone());
         }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
index 37ae3b752b..d21f2e971f 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
@@ -18,6 +18,8 @@
 
 import android.content.Context;
 
+import java.lang.reflect.InvocationTargetException;
+
 import io.realm.RealmConfiguration;
 import io.realm.exceptions.RealmException;
 
@@ -34,12 +36,17 @@
         //noinspection TryWithIdenticalCatches
         try {
             Class syncFacadeClass = Class.forName("io.realm.internal.SyncObjectServerFacade");
-            syncFacade = (ObjectServerFacade) syncFacadeClass.newInstance();
+            //noinspection unchecked
+            syncFacade = (ObjectServerFacade) syncFacadeClass.getDeclaredConstructor().newInstance();
         } catch (ClassNotFoundException ignored) {
         } catch (InstantiationException e) {
             throw new RealmException("Failed to init SyncObjectServerFacade", e);
         } catch (IllegalAccessException e) {
             throw new RealmException("Failed to init SyncObjectServerFacade", e);
+        } catch (NoSuchMethodException e) {
+            throw new RealmException("Failed to init SyncObjectServerFacade", e);
+        } catch (InvocationTargetException e) {
+            throw new RealmException("Failed to init SyncObjectServerFacade", e.getTargetException());
         }
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index a5b0b5c35c..5f29de65fa 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -237,7 +237,7 @@ public void renameColumn(long columnIndex, String newName) {
                 // We failed to rename the pk meta table. roll back the column name, not pk meta table
                 // then rethrow.
                 nativeRenameColumn(nativePtr, columnIndex, oldName);
-                throw e;
+                throw new RuntimeException(e);
             }
         }
     }
@@ -1101,6 +1101,7 @@ public String toJson() {
         return nativeToJson(nativePtr);
     }
 
+    @Override
     public String toString() {
         long columnCount = getColumnCount();
         String name = getName();
diff --git a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
index 9c99b7a621..c583278793 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
@@ -23,18 +23,18 @@
 /**
  * Wrapper around a Row in Realm Core.
  *
- * IMPORTANT: All access to methods using this class are non-checking. Safety guarantees are given by the annotation
- * processor and {@link RealmProxyMediator#validateTable(Class, SharedRealm)} which is called before the typed
- * API can be used.
+ * IMPORTANT: All access to methods using this class are non-checking. Safety guarantees are given by the
+ * annotation processor and {@link RealmProxyMediator#validateTable(Class, SharedRealm, boolean)}
+ * which is called before the typed API can be used.
  *
  * For low-level access to Row data where error checking is required, use {@link CheckedRow}.
  */
 public class UncheckedRow implements NativeObject, Row {
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
 
-    final Context context; // This is only kept because for now it's needed by the constructor of LinkView
+    private final Context context; // This is only kept because for now it's needed by the constructor of LinkView
     private final Table parent;
     private final long nativePtr;
-    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
 
     UncheckedRow(Context context, Table parent, long nativePtr) {
         this.context = context;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/RealmAsyncTaskImpl.java b/realm/realm-library/src/main/java/io/realm/internal/async/RealmAsyncTaskImpl.java
index d523c9ae28..4427f98e77 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/RealmAsyncTaskImpl.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/RealmAsyncTaskImpl.java
@@ -34,6 +34,7 @@ public RealmAsyncTaskImpl(Future<?> pendingTask, ThreadPoolExecutor service) {
     /**
      * {@inheritDoc}
      */
+    @Override
     public void cancel() {
         pendingTask.cancel(true);
         isCancelled = true;
@@ -53,6 +54,7 @@ public void cancel() {
     /**
      * {@inheritDoc}
      */
+    @Override
     public boolean isCancelled() {
         return isCancelled;
     }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
index 4f387d012d..091f954e9f 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
@@ -27,7 +27,7 @@
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.regex.Pattern;
 
-import edu.umd.cs.findbugs.annotations.SuppressWarnings;
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 
 /**
  * Custom thread pool settings, instances of this executor can be paused, and resumed, this will also set
@@ -66,7 +66,7 @@ public static RealmThreadPoolExecutor newSingleThreadExecutor() {
      *
      * @return the number of threads to be allocated for the executor pool
      */
-    @SuppressWarnings("DMI_HARDCODED_ABSOLUTE_FILENAME")
+    @SuppressFBWarnings("DMI_HARDCODED_ABSOLUTE_FILENAME")
     private static int calculateCorePoolSize() {
         int cpus = countFilesInDir(SYS_CPU_DIR, "cpu[0-9]+");
         if (cpus <= 0) {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index 0800ae230b..eadf8ba645 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -49,7 +49,7 @@
     private final Map<Class<? extends RealmModel>, RealmProxyMediator> mediators;
 
     public CompositeMediator(RealmProxyMediator... mediators) {
-        final HashMap<Class<? extends RealmModel>, RealmProxyMediator> tempMediators = new HashMap<>();
+        final HashMap<Class<? extends RealmModel>, RealmProxyMediator> tempMediators = new HashMap<Class<? extends RealmModel>, RealmProxyMediator>();
         if (mediators != null) {
             for (RealmProxyMediator mediator : mediators) {
                 for (Class<? extends RealmModel> realmClass : mediator.getModelClasses()) {
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ClientResetHandler.java b/realm/realm-library/src/objectServer/java/io/realm/ClientResetHandler.java
new file mode 100644
index 0000000000..1fdc1adf8b
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/ClientResetHandler.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.io.File;
+
+/**
+ * Class encapsulating information needed for handling a Client Reset event.
+ *
+ * @see io.realm.SyncSession.ErrorHandler#onClientResetRequired(SyncSession, ClientResetHandler) for more information
+ *      about when and why Client Reset occurs and how to deal with it.
+ */
+public class ClientResetHandler extends ObjectServerError {
+
+    private final RealmConfiguration configuration;
+    private final File backupFile;
+    private final File originalFile;
+
+    public ClientResetHandler(ErrorCode errorCode, String errorMessage, String backupFilePath, RealmConfiguration configuration) {
+        super(errorCode, errorMessage);
+        this.configuration = configuration;
+        this.backupFile = new File(backupFilePath);
+        this.originalFile = new File(configuration.getPath());
+    }
+
+    /**
+     * Calling this method will execute the Client Reset manually instead of waiting until next app restart. This will
+     * only be possible if all instances of that Realm have been closed, otherwise a {@link IllegalStateException} will
+     * be thrown.
+     * <p>
+     * After this method returns, the backup file can be found in the location returned by {@link #getBackupFile()}.
+     * The file at {@link #getOriginalFile()} have been deleted, but will be recreated from scratch next time a
+     * Realm instance is opened.
+     *
+     * @throws IllegalStateException if not all instances have been closed.
+     */
+    public void executeClientReset()  {
+        synchronized (Realm.class) {
+            if (Realm.getGlobalInstanceCount(configuration) > 0) {
+                throw new IllegalStateException("Realm has not been fully closed. Client Reset cannot run before all " +
+                        "instances have been closed.");
+            }
+            nativeExecuteClientReset(configuration.getPath());
+        }
+    }
+
+    /**
+     * Returns the location of the backed up Realm file. The file will not be present until the Client Reset has been
+     * fully executed.
+     *
+     * @return a reference to the location of the backup file once Client Reset has been executed.
+     *         Use {@code file.exists()} to check if the file exists or not.
+     *
+     */
+    public File getBackupFile() {
+        return backupFile;
+    }
+
+    /**
+     * Returns the location of the original Realm file. After the Client Reset has completed, the file at this location
+     * will be deleted.
+     *
+     * @return a reference to the location of the original Realm file. After Client Reset has been executed this file
+     *         will no longer exists. Use {@code file.exists()} to check this.
+     */
+    public File getOriginalFile() {
+        return originalFile;
+    }
+
+    // PRECONDITION: All Realm instances for this path must have been closed.
+    private native void nativeExecuteClientReset(String originalPath);
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
index 191bf89c78..a8e4a827ec 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
@@ -27,6 +27,7 @@
     UNKNOWN(-1),                                // Catch-all
     IO_EXCEPTION(0, Category.RECOVERABLE),      // Some IO error while either contacting the server or reading the response
     JSON_EXCEPTION(1),                          // JSON input could not be parsed correctly
+    CLIENT_RESET(7),                            // Client Reset required. Don't change this value without modifying io_realm_internal_SharedRealm.cpp
 
     // Realm Object Server errors (100 - 199)
     // Connection level and protocol errors.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java b/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
index fcf681a3ec..272ead6c89 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
@@ -41,7 +41,7 @@ public static void init(Context context) {
         // init the "sync_manager.cpp" metadata Realm, this is also needed later, when re try
         // to schedule a client reset. in realm-java#master this is already done, when initialising
         // the RealmFileUserStore (not available now on releases)
-        SyncManager.nativeConfigureMetaDataSystem(context.getFilesDir().getPath());
+        SyncManager.nativeInitializeSyncManager(context.getFilesDir().getPath());
 
         // Configure default UserStore
         UserStore userStore = new RealmFileUserStore();
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index ce463ff77a..691538c59b 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -83,6 +83,11 @@ public void onError(SyncSession session, ObjectServerError error) {
                     throw new IllegalArgumentException("Unsupported error category: " + error.getErrorCode().getCategory());
             }
         }
+
+        @Override
+        public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
+            RealmLog.error("Client Reset required for: " + session.getConfiguration().getPath());
+        }
     };
     // keeps track of SyncSession, using 'realm_path'. Java interface with the ObjectStore using the 'realm_path'
     private static Map<String, SyncSession> sessions = new HashMap<String, SyncSession>();
@@ -99,9 +104,6 @@ public void onError(SyncSession session, ObjectServerError error) {
     static void init(String appId, UserStore userStore) {
         SyncManager.APP_ID = appId;
         SyncManager.userStore = userStore;
-
-        // Initialize underlying Sync Network Client
-        nativeInitializeSyncClient();
     }
 
     /**
@@ -283,8 +285,22 @@ static synchronized void reset() {
         sessions.clear();
     }
 
-    private static native void nativeInitializeSyncClient();
-    // init and load the Metadata Realm containing SyncUsers
-    protected static native void nativeConfigureMetaDataSystem(String baseFile);
+    /**
+     * Simulate a Client Reset by triggering the Object Store error handler with Sync Error Code that will be
+     * converted to a Client Reset (211 - Diverging Histories).
+     *
+     * Only call this method when testing.
+     *
+     * @param session Session to trigger Client Reset for.
+     */
+    static void simulateClientReset(SyncSession session) {
+        nativeSimulateSyncError(session.getConfiguration().getPath(),
+                ErrorCode.DIVERGING_HISTORIES.intValue(),
+                "Simulate Client Reset",
+                true);
+    }
+
+    protected static native void nativeInitializeSyncManager(String syncBaseDir);
     private static native void nativeReset();
+    private static native void nativeSimulateSyncError(String realmPath, int errorCode, String errorMessage, boolean isFatal);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index 1572c34abc..f2c40281ba 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -96,9 +96,17 @@ public URI getServerUrl() {
     // This callback will happen on the thread running the Sync Client.
     @KeepMember
     void notifySessionError(int errorCode, String errorMessage) {
-        ObjectServerError error = new ObjectServerError(ErrorCode.fromInt(errorCode), errorMessage);
-        if (errorHandler != null) {
-            errorHandler.onError(this, error);
+        if (errorHandler == null) {
+            return;
+        }
+        ErrorCode errCode = ErrorCode.fromInt(errorCode);
+        if (errCode == ErrorCode.CLIENT_RESET) {
+            // errorMessage contains the path to the backed up file
+            errorHandler.onClientResetRequired(this, new ClientResetHandler(errCode, "A Client Reset is required. " +
+                    "Read more here: https://realm.io/docs/realm-object-server/#client-recovery-from-a-backup.",
+                    errorMessage, getConfiguration()));
+        } else {
+            errorHandler.onError(this, new ObjectServerError(errCode, errorMessage));
         }
     }
 
@@ -127,6 +135,46 @@ void close() {
          * @param error type of error.
          */
         void onError(SyncSession session, ObjectServerError error);
+
+        /**
+         * An error that indicates the Realm needs to be reset.
+         * <p>
+         * A synced Realm may need to be reset because the Realm Object Server encountered an error and had
+         * to be restored from a backup. If the backup copy of the remote Realm is of an earlier version
+         * than the local copy of the Realm, the server will ask the client to reset the Realm.
+         * <p>
+         * The reset process is as follows: the local copy of the Realm is copied into a recovery directory
+         * for safekeeping, and then deleted from the original location. The next time the Realm for that
+         * URL is opened, the Realm will automatically be re-downloaded from the Realm Object Server, and
+         * can be used as normal.
+         * <p>
+         * Data written to the Realm after the local copy of the Realm diverged from the backup remote copy
+         * will be present in the local recovery copy of the Realm file. The re-downloaded Realm will
+         * initially contain only the data present at the time the Realm was backed up on the server.
+         * <p>
+         * The client reset process can be initiated in one of two ways:
+         * <ol>
+         *     <li>
+         *         Run {@link ClientResetHandler#executeClientReset()} manually. All Realm instances must be
+         *         closed before this method is called.
+         *     </li>
+         *     <li>
+         *         If Client Reset isn't executed manually, it will automatically be carried out the next time all
+         *         Realm instances have been closed and re-opened. This will most likely be
+         *         when the app is restarted.
+         *     </li>
+         * </ol>
+         *
+         * <b>WARNING:</b>
+         * Any writes to the Realm file between this callback and Client Reset has been executed, will not be
+         * synchronized to the Object Server. Those changes will only be present in the backed up file. It is therefore
+         * recommended to close all open Realm instances as soon as possible.
+         *
+         * @param session {@link SyncSession} this error happened on.
+         * @param handler reference to the specific Client Reset error.
+         * @see <a href="https://realm.io/docs/realm-object-server/#client-recovery-from-a-backup">Client Recovery From A Backup</a>
+         */
+        void onClientResetRequired(SyncSession session, ClientResetHandler handler);
     }
 
     String accessToken(final AuthenticationServer authServer) {
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index f0406cf086..899411cd70 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -74,6 +74,11 @@ public void onError(SyncSession session, ObjectServerError error) {
                                         user.getIdentity(),
                                         error.toString()));
                             }
+
+                            @Override
+                            public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
+                                RealmLog.error("Client Reset required for users management Realm: " + user.toString());
+                            }
                         })
                         .modules(new PermissionModule())
                         .build();
@@ -315,7 +320,8 @@ public void logout() {
             // Finally revoke server token. The local user is logged out in any case.
             final AuthenticationServer server = SyncManager.getAuthServer();
             ThreadPoolExecutor networkPoolExecutor = SyncManager.NETWORK_POOL_EXECUTOR;
-            networkPoolExecutor.submit(new ExponentialBackoffTask<LogoutResponse>() {
+            //noinspection unused
+            final Future<?> future = networkPoolExecutor.submit(new ExponentialBackoffTask<LogoutResponse>() {
 
                 @Override
                 protected LogoutResponse execute() {
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java
index ce356546eb..6a0181ca95 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java
@@ -80,6 +80,7 @@ private LogoutResponse() {
      *
      * @return {@code true} if valid.
      */
+    @Override
     public boolean isValid() {
         return (error == null) || (error.getErrorCode() == ErrorCode.EXPIRED_REFRESH_TOKEN);
     }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/NetworkStateReceiver.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/NetworkStateReceiver.java
index d7f426d350..5f337b1504 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/NetworkStateReceiver.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/NetworkStateReceiver.java
@@ -77,6 +77,7 @@ public static boolean isOnline(Context context) {
     }
 
 
+    @Override
     public void onReceive(Context context, Intent intent) {
         boolean connected = isOnline(context);
         for (ConnectionListener listener : listeners) {
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index ae1cda7ac7..b25ce7f907 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -6,6 +6,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import io.realm.ClientResetHandler;
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
@@ -73,6 +74,11 @@ public void onSuccess(SyncUser user) {
                             public void onError(SyncSession session, ObjectServerError error) {
                                 fail("Session failed: " + error);
                             }
+
+                            @Override
+                            public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
+                                fail("Client Reset");
+                            }
                         })
                         .build();
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
index d1695c13ba..2754115d44 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
@@ -26,6 +26,7 @@
 import java.util.Date;
 import java.util.concurrent.atomic.AtomicReference;
 
+import io.realm.ClientResetHandler;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
@@ -34,7 +35,6 @@
 import io.realm.SyncSession;
 import io.realm.SyncUser;
 import io.realm.entities.Dog;
-import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.UserFactory;
@@ -67,6 +67,11 @@ public void create_acceptOffer() {
                     public void onError(SyncSession session, ObjectServerError error) {
                         fail("Realm 1 unexpected error: " + error);
                     }
+
+                    @Override
+                    public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
+                        fail("Client Reset");
+                    }
                 })
                 .build();
         final Realm realm1 = Realm.getInstance(config1);
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
index 68ce590f3e..ffb20cd32c 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
@@ -22,8 +22,6 @@
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -31,8 +29,10 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
+import io.realm.ClientResetHandler;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
@@ -45,7 +45,6 @@
 import io.realm.objectserver.service.SendOneCommit;
 import io.realm.objectserver.service.SendsALot;
 import io.realm.objectserver.utils.Constants;
-import io.realm.objectserver.utils.HttpUtils;
 import io.realm.objectserver.utils.UserFactory;
 
 import static org.junit.Assert.assertEquals;
@@ -62,7 +61,8 @@ public void expectServerCommit() throws Throwable {
         final Throwable[] exception = new Throwable[1];
         final CountDownLatch testFinished = new CountDownLatch(1);
         ExecutorService service = Executors.newSingleThreadExecutor();
-        service.submit(new Runnable() {
+        //noinspection unused
+        final Future<?> future = service.submit(new Runnable() {
             @Override
             public void run() {
                 try {
@@ -78,6 +78,11 @@ public void run() {
                                 public void onError(SyncSession session, ObjectServerError error) {
                                     fail("Sync failure: " + error);
                                 }
+
+                                @Override
+                                public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
+                                    fail("Client Reset");
+                                }
                             })
                             .build();
                     Realm.deleteRealm(syncConfig);//TODO do this in Rule as async tests
@@ -122,7 +127,8 @@ public void expectALot() throws Throwable {
         final Throwable[] exception = new Throwable[1];
         final CountDownLatch testFinished = new CountDownLatch(1);
         ExecutorService service = Executors.newSingleThreadExecutor();
-        service.submit(new Runnable() {
+        //noinspection unused
+        final Future<?> future = service.submit(new Runnable() {
             @Override
             public void run() {
                 try {
@@ -138,6 +144,11 @@ public void run() {
                                 public void onError(SyncSession session, ObjectServerError error) {
                                     fail("Sync failure: " + error);
                                 }
+
+                                @Override
+                                public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
+                                    fail("Client Reset");
+                                }
                             })
                             .build();
                     Realm.deleteRealm(syncConfig);//TODO do this in Rule as async tests
diff --git a/realm/realm-library/testLibs/backlinks-missing-field-source.jar b/realm/realm-library/testLibs/backlinks-missing-field-source.jar
new file mode 100644
index 0000000000..a34490c3ca
Binary files /dev/null and b/realm/realm-library/testLibs/backlinks-missing-field-source.jar differ
diff --git a/realm/realm-library/testLibs/backlinks-missing-field-target.jar b/realm/realm-library/testLibs/backlinks-missing-field-target.jar
new file mode 100644
index 0000000000..91a513c5b3
Binary files /dev/null and b/realm/realm-library/testLibs/backlinks-missing-field-target.jar differ
diff --git a/realm/realm-library/testLibs/backlinks-wrong-type-source.jar b/realm/realm-library/testLibs/backlinks-wrong-type-source.jar
new file mode 100644
index 0000000000..67cbdbefea
Binary files /dev/null and b/realm/realm-library/testLibs/backlinks-wrong-type-source.jar differ
diff --git a/realm/realm-library/testLibs/backlinks-wrong-type-target.jar b/realm/realm-library/testLibs/backlinks-wrong-type-target.jar
new file mode 100644
index 0000000000..3745742b94
Binary files /dev/null and b/realm/realm-library/testLibs/backlinks-wrong-type-target.jar differ
diff --git a/realm/tools/backlink-ut-source/missingField/source/io/realm/entities/BacklinksMissingFieldSource.java b/realm/tools/backlink-ut-source/missingField/source/io/realm/entities/BacklinksMissingFieldSource.java
new file mode 100644
index 0000000000..5564843455
--- /dev/null
+++ b/realm/tools/backlink-ut-source/missingField/source/io/realm/entities/BacklinksMissingFieldSource.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.RealmObject;
+
+public class BacklinksMissingFieldSource extends RealmObject {
+    private BacklinksMissingFieldTarget child;
+
+    public BacklinksMissingFieldTarget getChild() {
+        return child;
+    }
+
+    public void setChild(BacklinksMissingFieldTarget child) {
+        this.child = child;
+    }
+}
diff --git a/realm/tools/backlink-ut-source/missingField/source/io/realm/entities/BacklinksMissingFieldSourceModule.java b/realm/tools/backlink-ut-source/missingField/source/io/realm/entities/BacklinksMissingFieldSourceModule.java
new file mode 100644
index 0000000000..20c860a076
--- /dev/null
+++ b/realm/tools/backlink-ut-source/missingField/source/io/realm/entities/BacklinksMissingFieldSourceModule.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.annotations.RealmModule;
+
+@RealmModule(classes = {BacklinksMissingFieldSource.class})
+public class BacklinksMissingFieldSourceModule {
+}
diff --git a/realm/tools/backlink-ut-source/missingField/source/io/realm/entities/BacklinksMissingFieldTarget.java b/realm/tools/backlink-ut-source/missingField/source/io/realm/entities/BacklinksMissingFieldTarget.java
new file mode 100644
index 0000000000..eeb4884a15
--- /dev/null
+++ b/realm/tools/backlink-ut-source/missingField/source/io/realm/entities/BacklinksMissingFieldTarget.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class BacklinksMissingFieldTarget extends RealmObject {
+    private int id;
+
+    @LinkingObjects("child")
+    private final RealmResults<BacklinksMissingFieldSource> parents = null;
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public RealmResults<BacklinksMissingFieldSource> getParents() {
+        return parents;
+    }
+}
diff --git a/realm/tools/backlink-ut-source/missingField/source/io/realm/entities/BacklinksMissingFieldTargetModule.java b/realm/tools/backlink-ut-source/missingField/source/io/realm/entities/BacklinksMissingFieldTargetModule.java
new file mode 100644
index 0000000000..d34d5076d8
--- /dev/null
+++ b/realm/tools/backlink-ut-source/missingField/source/io/realm/entities/BacklinksMissingFieldTargetModule.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.annotations.RealmModule;
+
+@RealmModule(classes = {BacklinksMissingFieldTarget.class})
+public class BacklinksMissingFieldTargetModule {
+}
diff --git a/realm/tools/backlink-ut-source/missingField/target/io/realm/entities/BacklinksMissingFieldSource.java b/realm/tools/backlink-ut-source/missingField/target/io/realm/entities/BacklinksMissingFieldSource.java
new file mode 100644
index 0000000000..1f10ebc756
--- /dev/null
+++ b/realm/tools/backlink-ut-source/missingField/target/io/realm/entities/BacklinksMissingFieldSource.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.RealmObject;
+
+public class BacklinksMissingFieldSource extends RealmObject {
+    private BacklinksMissingFieldTarget xxxchild;
+
+    public BacklinksMissingFieldTarget getChild() {
+        return xxxchild;
+    }
+
+    public void setChild(BacklinksMissingFieldTarget child) {
+        this.xxxchild = child;
+    }
+}
diff --git a/realm/tools/backlink-ut-source/missingField/target/io/realm/entities/BacklinksMissingFieldSourceModule.java b/realm/tools/backlink-ut-source/missingField/target/io/realm/entities/BacklinksMissingFieldSourceModule.java
new file mode 100644
index 0000000000..20c860a076
--- /dev/null
+++ b/realm/tools/backlink-ut-source/missingField/target/io/realm/entities/BacklinksMissingFieldSourceModule.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.annotations.RealmModule;
+
+@RealmModule(classes = {BacklinksMissingFieldSource.class})
+public class BacklinksMissingFieldSourceModule {
+}
diff --git a/realm/tools/backlink-ut-source/missingField/target/io/realm/entities/BacklinksMissingFieldTarget.java b/realm/tools/backlink-ut-source/missingField/target/io/realm/entities/BacklinksMissingFieldTarget.java
new file mode 100644
index 0000000000..47c2894d3e
--- /dev/null
+++ b/realm/tools/backlink-ut-source/missingField/target/io/realm/entities/BacklinksMissingFieldTarget.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class BacklinksMissingFieldTarget extends RealmObject {
+    private int id;
+
+    @LinkingObjects("xxxchild")
+    private final RealmResults<BacklinksMissingFieldSource> parents = null;
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public RealmResults<BacklinksMissingFieldSource> getParents() {
+        return parents;
+    }
+}
diff --git a/realm/tools/backlink-ut-source/missingField/target/io/realm/entities/BacklinksMissingFieldTargetModule.java b/realm/tools/backlink-ut-source/missingField/target/io/realm/entities/BacklinksMissingFieldTargetModule.java
new file mode 100644
index 0000000000..d34d5076d8
--- /dev/null
+++ b/realm/tools/backlink-ut-source/missingField/target/io/realm/entities/BacklinksMissingFieldTargetModule.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.annotations.RealmModule;
+
+@RealmModule(classes = {BacklinksMissingFieldTarget.class})
+public class BacklinksMissingFieldTargetModule {
+}
diff --git a/realm/tools/backlink-ut-source/wrongType/source/io/realm/entities/BacklinksWrongTypeSource.java b/realm/tools/backlink-ut-source/wrongType/source/io/realm/entities/BacklinksWrongTypeSource.java
new file mode 100644
index 0000000000..85dc2dd094
--- /dev/null
+++ b/realm/tools/backlink-ut-source/wrongType/source/io/realm/entities/BacklinksWrongTypeSource.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.RealmObject;
+
+public class BacklinksWrongTypeSource extends RealmObject {
+    private Integer childId;
+
+    private BacklinksWrongTypeTarget child;
+
+    public Integer getChildId() {
+        return childId;
+    }
+
+    public void setChildId(Integer childId) {
+        this.childId = childId;
+    }
+
+    public BacklinksWrongTypeTarget getChild() {
+        return child;
+    }
+
+    public void setChild(BacklinksWrongTypeTarget child) {
+        this.child = child;
+    }
+}
diff --git a/realm/tools/backlink-ut-source/wrongType/source/io/realm/entities/BacklinksWrongTypeSourceModule.java b/realm/tools/backlink-ut-source/wrongType/source/io/realm/entities/BacklinksWrongTypeSourceModule.java
new file mode 100644
index 0000000000..8e4a3f4f5b
--- /dev/null
+++ b/realm/tools/backlink-ut-source/wrongType/source/io/realm/entities/BacklinksWrongTypeSourceModule.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.annotations.RealmModule;
+
+@RealmModule(classes = {BacklinksWrongTypeSource.class})
+public class BacklinksWrongTypeSourceModule {
+}
diff --git a/realm/tools/backlink-ut-source/wrongType/source/io/realm/entities/BacklinksWrongTypeTarget.java b/realm/tools/backlink-ut-source/wrongType/source/io/realm/entities/BacklinksWrongTypeTarget.java
new file mode 100644
index 0000000000..243d25aea4
--- /dev/null
+++ b/realm/tools/backlink-ut-source/wrongType/source/io/realm/entities/BacklinksWrongTypeTarget.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class BacklinksWrongTypeTarget extends RealmObject {
+    private int id;
+
+    @LinkingObjects("child")
+    private final RealmResults<BacklinksWrongTypeSource> parents = null;
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public RealmResults<BacklinksWrongTypeSource> getParents() {
+        return parents;
+    }
+}
diff --git a/realm/tools/backlink-ut-source/wrongType/source/io/realm/entities/BacklinksWrongTypeTargetModule.java b/realm/tools/backlink-ut-source/wrongType/source/io/realm/entities/BacklinksWrongTypeTargetModule.java
new file mode 100644
index 0000000000..b9275496a7
--- /dev/null
+++ b/realm/tools/backlink-ut-source/wrongType/source/io/realm/entities/BacklinksWrongTypeTargetModule.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.annotations.RealmModule;
+
+@RealmModule(classes = {BacklinksWrongTypeTarget.class})
+public class BacklinksWrongTypeTargetModule {
+}
diff --git a/realm/tools/backlink-ut-source/wrongType/target/io/realm/entities/BacklinksWrongTypeSource.java b/realm/tools/backlink-ut-source/wrongType/target/io/realm/entities/BacklinksWrongTypeSource.java
new file mode 100644
index 0000000000..477c236a6e
--- /dev/null
+++ b/realm/tools/backlink-ut-source/wrongType/target/io/realm/entities/BacklinksWrongTypeSource.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.RealmObject;
+
+public class BacklinksWrongTypeSource extends RealmObject {
+    private Integer child;
+
+    private BacklinksWrongTypeTarget childId;
+
+    public Integer getChildId() {
+        return child;
+    }
+
+    public void setChildId(Integer childId) {
+        this.child = childId;
+    }
+
+    public BacklinksWrongTypeTarget getChild() {
+        return childId;
+    }
+
+    public void setChild(BacklinksWrongTypeTarget child) {
+        this.childId = childId;
+    }
+}
diff --git a/realm/tools/backlink-ut-source/wrongType/target/io/realm/entities/BacklinksWrongTypeSourceModule.java b/realm/tools/backlink-ut-source/wrongType/target/io/realm/entities/BacklinksWrongTypeSourceModule.java
new file mode 100644
index 0000000000..8e4a3f4f5b
--- /dev/null
+++ b/realm/tools/backlink-ut-source/wrongType/target/io/realm/entities/BacklinksWrongTypeSourceModule.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.annotations.RealmModule;
+
+@RealmModule(classes = {BacklinksWrongTypeSource.class})
+public class BacklinksWrongTypeSourceModule {
+}
diff --git a/realm/tools/backlink-ut-source/wrongType/target/io/realm/entities/BacklinksWrongTypeTarget.java b/realm/tools/backlink-ut-source/wrongType/target/io/realm/entities/BacklinksWrongTypeTarget.java
new file mode 100644
index 0000000000..ac6451d267
--- /dev/null
+++ b/realm/tools/backlink-ut-source/wrongType/target/io/realm/entities/BacklinksWrongTypeTarget.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class BacklinksWrongTypeTarget extends RealmObject {
+    private int id;
+
+    @LinkingObjects("childId")
+    private final RealmResults<BacklinksWrongTypeSource> parents = null;
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public RealmResults<BacklinksWrongTypeSource> getParents() {
+        return parents;
+    }
+}
diff --git a/realm/tools/backlink-ut-source/wrongType/target/io/realm/entities/BacklinksWrongTypeTargetModule.java b/realm/tools/backlink-ut-source/wrongType/target/io/realm/entities/BacklinksWrongTypeTargetModule.java
new file mode 100644
index 0000000000..b9275496a7
--- /dev/null
+++ b/realm/tools/backlink-ut-source/wrongType/target/io/realm/entities/BacklinksWrongTypeTargetModule.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.annotations.RealmModule;
+
+@RealmModule(classes = {BacklinksWrongTypeTarget.class})
+public class BacklinksWrongTypeTargetModule {
+}
diff --git a/realm/tools/bin/cgen b/realm/tools/bin/cgen
new file mode 100755
index 0000000000..806974356c
--- /dev/null
+++ b/realm/tools/bin/cgen
@@ -0,0 +1,55 @@
+#!/bin/bash
+
+# Customize as necessary
+REALM_JAVA=~/Working/java
+GRADLE_CACHE=~/.gradle
+ANDROID_SDK=~/Library/Android/sdk
+
+if [ $# -lt 2 ] ; then
+  echo "Usage: $0 <destination folder> <java file>..."
+  exit 1
+fi
+
+TARGET_DIR="$1"
+shift
+
+if [ ! -d "$TARGET_DIR" ] ; then
+  echo "$TARGET_DIR is not a directory"
+  exit 1
+fi
+
+REALM_ANNOTATIONS=`find "$REALM_JAVA/realm-annotations/build" -name 'realm-annotations-*.jar'`
+if [ ! -f "$REALM_ANNOTATIONS" ] ; then
+  echo "Cannot find the Realm Annotations jar in $REALM_JAVA"
+  exit 1
+fi
+
+REALM_ANNOTATION_PROCESSOR=`find "$REALM_JAVA/realm/realm-annotations-processor" -name 'realm-annotations-processor-*.jar'`
+if [ ! -f "$REALM_ANNOTATION_PROCESSOR" ] ; then
+  echo "Cannot find the Realm Annotation Processor jar in $REALM_JAVA"
+  exit 1
+fi
+
+REALM_CLASSES="$REALM_JAVA/realm/realm-library/build/intermediates/classes/base/release"
+if [ ! -d "$REALM_CLASSES" ] ; then
+  echo "Cannot find the Realm classes in $REALM_JAVA"
+  exit 1
+fi
+
+JAVAWRITER=`find "$GRADLE_CACHE/caches/jars"* -name 'javawriter-2.5*.jar' | head -1`
+if [ ! -f "$JAVAWRITER" ] ; then
+  echo "Cannot find JavaWriter jar in $GRADLE_CACHE"
+  exit 1
+fi
+
+CLASSPATH="$REALM_ANNOTATION_PROCESSOR":"$JAVAWRITER":"$REALM_ANNOTATIONS":"$REALM_CLASSES"
+
+javac \
+  -d "$TARGET_DIR" \
+  -bootclasspath "$ANDROID_SDK/platforms/android-24/android.jar" \
+  -source 7 \
+  -target 7 \
+  -cp "$CLASSPATH" \
+  -processor io.realm.processor.RealmProcessor \
+  $*
+
