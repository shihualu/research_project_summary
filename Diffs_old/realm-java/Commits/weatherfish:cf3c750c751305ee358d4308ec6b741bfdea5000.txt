diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
index 187ea46746..4d223c132d 100644
--- a/.github/ISSUE_TEMPLATE.md
+++ b/.github/ISSUE_TEMPLATE.md
@@ -38,6 +38,8 @@
 #### Version of Realm and tooling
 Realm version(s): ?
 
+Realm sync feature enabled: yes/no
+
 Android Studio version: ?
 
 Which Android version and device: ?
diff --git a/.gitignore b/.gitignore
index 22df2e0956..7d38506f03 100644
--- a/.gitignore
+++ b/.gitignore
@@ -11,6 +11,7 @@ local.properties
 # Core
 core
 core-*
+realm-sync-android-*
 
 # Android Studio
 .idea
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 33c3bb1160..370ea45df5 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,7 +1,91 @@
+## 2.1.1
+
+### Object Server API Changes (In Beta)
+
+* Set default RxFactory to `SyncConfiguration`.
+
+### Bug fixes
+
+* ProGuard configuration introduced in 2.1.0 unexpectedly kept classes that did not have the @KeepMember annotation (#3689).
+
+## 2.1.0
+
+### Breaking changes
+
+* * `SecureUserStore` has been moved to its own GitHub repository: https://github.com/realm/realm-android-user-store
+  See https://github.com/realm/realm-android-user-store/blob/master/README.md for further info on how to include it.
+
+
+### Object Server API Changes (In Beta)
+
+* Renamed `User` to `SyncUser`, `Credentials` to `SyncCredentials` and `Session` to `SyncSession` to align names with Cocoa.
+* Removed `SyncManager.setLogLevel()`. Use `RealmLog.setLevel()` instead.
+* `SyncUser.logout()` now correctly clears `SyncUser.currentUser()` (#3638).
+* Missing ProGuard configuration for libraries used by Sync extension (#3596).
+* Error handler was not called when sync session failed (#3597).
+* Added `User.all()` that returns all known Realm Object Server users.
+* Upgraded Realm Sync to 1.0.0-BETA-3.2
+
+### Deprecated
+
+* `Logger`. Use `RealmLogger` instead.
+* `AndroidLogger`. The logger for Android is implemented in native code instead.
+
+### Bug fixes
+
+* The following were not kept by ProGuard: names of native methods not in the `io.realm.internal` package, names of classes used in method signature (#3596).
+* Permission error when a database file was located on external storage (#3140).
+* Memory leak when unsubscribing from a RealmResults/RealmObject RxJava Observable (#3552).
+
+### Enhancement
+
+* `Realm.compactRealm()` now works for encrypted Realms.
+* Added `first(E defaultValue)` and `last(E defaultValue)` methods to `RealmList` and `RealmResult`. These methods will return the provided object instead of throwing an `IndexOutOfBoundsException` if the list is empty.
+* Reduce transformer logger verbosity (#3608).
+* `RealmLog.setLevel(int)` for setting the log level across all loggers.
+
+### Internal
+
+* Upgraded Realm Core to 2.1.3
+
+### Credits
+
+* Thanks to Max Furman (@maxfurman) for adding support for `first()` and `last()` default values.
+
+## 2.0.2
+
+This release is not protocol-compatible with previous versions of the Realm Mobile Platform. The base library is still fully compatible.
+
+### Bug fixes
+
+* Build error when using Java 7 (#3563).
+
+### Internal
+
+* Upgraded Realm Core to 2.1.0
+* Upgraded Realm Sync to 1.0.0-BETA-2.0.
+
+## 2.0.1
+
+### Bug fixes
+
+* `android.net.conn.CONNECTIVITY_CHANGE` broadcast caused `RuntimeException` if sync extension was disabled (#3505).
+* `android.net.conn.CONNECTIVITY_CHANGE` was not delivered on Android 7 devices.
+* `distinctAsync` did not respect other query parameters (#3537).
+* `ConcurrentModificationException` from Gradle when building an application (#3501).
+
+### Internal
+
+* Upgraded to Realm Core 2.0.1 / Realm Sync 1.3-BETA
+
 ## 2.0.0
 
+This release introduces support for the Realm Mobile Platform!
+See <https://realm.io/news/introducing-realm-mobile-platform/> for an overview of these great new features.
+
 ### Breaking Changes
 
+* Files written by Realm 2.0 cannot be read by 1.x or earlier versions. Old files can still be opened.
 * It is now required to call `Realm.init(Context)` before calling any other Realm API.
 * Removed `RealmConfiguration.Builder(Context)`, `RealmConfiguration.Builder(Context, File)` and `RealmConfiguration.Builder(File)` constructors.
 * `isValid()` now always returns `true` instead of `false` for unmanaged `RealmObject` and `RealmList`. This puts it in line with the behaviour of the Cocoa and .NET API's (#3101).
@@ -23,18 +107,22 @@
 * Added `RealmConfiguration.Builder.directory(File)`.
 * `RealmLog` has been moved to the public API. It is now possible to control which events Realm emit to Logcat. See the `RealmLog` class for more details.
 * Typed `RealmObject`s can now continue to access their fields properly even though the schema was changed while the Realm was open (#3409).
+* A `RealmMigrationNeededException` will be thrown with a cause to show the detailed message when a migration is needed and the migration block is not in the `RealmConfiguration`.
+
 
 ### Bug fixes
 
 * Fixed a lint error in proxy classes when the 'minSdkVersion' of user's project is smaller than 11 (#3356).
 * Fixed a potential crash when there were lots of async queries waiting in the queue.
 * Fixed a bug causing the Realm Transformer to not transform field access in the model's constructors (#3361).
+* Fixed a bug causing a build failure when the Realm Transformer adds accessors to a model class that was already transformed in other project (#3469).
 * Fixed a bug causing the `NullPointerException` when calling getters/setters in the model's constructors (#2536).
 
 ### Internal
 
 * Moved JNI build to CMake.
-* Updated Realm Core to 2.0.0-rc4.
+* Updated Realm Core to 2.0.0.
+* Updated ReLinker to 1.2.2.
 
 ## 1.2.0
 
@@ -85,6 +173,7 @@
 ### Internal
 
 * Updated Realm Core to 1.4.2.
+* Improved sorting speed.
 
 ## 1.1.0
 
@@ -197,7 +286,7 @@ No changes since 0.91.1.
 * Removed `HandlerController` from the public API.
 * Removed constructor of `RealmAsyncTask` from the public API (#1594).
 * `RealmBaseAdapter` has been moved to its own GitHub repository: https://github.com/realm/realm-android-adapters
-  See https://github.com/realm/realm-android-adapters/README.md for further info on how to include it.
+  See https://github.com/realm/realm-android-adapters/blob/master/README.md for further info on how to include it.
 * File format of Realm files is changed. Files will be automatically upgraded but opening a Realm file with older
   versions of Realm is not possible.
 
diff --git a/Dockerfile b/Dockerfile
index f3c06ffa5e..b3a8820a23 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -11,19 +11,33 @@ ENV JAVA_HOME /usr/lib/jvm/java-8-openjdk-amd64
 ENV ANDROID_HOME /opt/android-sdk-linux
 # Need by cmake
 ENV ANDROID_NDK_HOME /opt/android-ndk
+ENV ANDROID_NDK /opt/android-ndk
 ENV PATH ${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
 ENV PATH ${PATH}:${NDK_HOME}
+ENV NDK_CCACHE /usr/bin/ccache
+ENV NDK_LCACHE /usr/bin/lcache
 
-# Install the JDK
-# We are going to need some 32 bit binaries because aapt requires it
-# file is need by the script that creates NDK toolchains
+# The 32 bit binaries because aapt requires it
+# `file` is need by the script that creates NDK toolchains
+# Keep the packages in alphabetical order to make it easy to avoid duplication
 RUN DEBIAN_FRONTEND=noninteractive dpkg --add-architecture i386 \
     && apt-get update -qq \
-    && apt-get install -y file git curl wget zip unzip \
-                       bsdmainutils \
-                       build-essential \
-                       openjdk-8-jdk-headless \
-                       libc6:i386 libstdc++6:i386 libgcc1:i386 libncurses5:i386 libz1:i386 \
+    && apt-get install -y bsdmainutils \
+                          build-essential \
+                          ccache \
+                          curl \
+                          file \
+                          git \
+                          libc6:i386 \
+                          libgcc1:i386 \
+                          libncurses5:i386 \
+                          libstdc++6:i386 \
+                          libz1:i386 \
+                          openjdk-8-jdk-headless \
+                          s3cmd \
+                          unzip \
+                          wget \
+                          zip \
     && apt-get clean
 
 # Install the Android SDK
@@ -59,3 +73,7 @@ RUN mkdir /opt/cmake-tmp && \
 
 # Make the SDK universally readable
 RUN chmod -R a+rX ${ANDROID_HOME}
+
+# Install lcache
+RUN wget -q https://github.com/beeender/lcache/releases/download/v0.0.2/lcache-linux -O /usr/bin/lcache && \
+    chmod +x /usr/bin/lcache
diff --git a/Jenkinsfile b/Jenkinsfile
index de5d3ebddd..4e73462a90 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -3,68 +3,107 @@
 import groovy.json.JsonOutput
 
 def buildSuccess = false
+def rosContainer
 try {
   node('android') {
     // Allocate a custom workspace to avoid having % in the path (it breaks ld)
     ws('/tmp/realm-java') {
-      stage 'SCM'
-      checkout scm
-      // Make sure not to delete the folder that Jenkins allocates to store scripts
-      sh 'git clean -ffdx -e .????????'
-      // Update submodule for object-store
-      sh 'git submodule sync'
-      sh 'git submodule update --init --force'
-
-      stage 'Docker build'
-      def buildEnv = docker.build 'realm-java:snapshot'
-      buildEnv.inside("-e HOME=/tmp -e _JAVA_OPTIONS=-Duser.home=/tmp --privileged -v /dev/bus/usb:/dev/bus/usb -v ${env.HOME}/gradle-cache:/tmp/.gradle -v ${env.HOME}/.android:/tmp/.android") {
-        stage 'JVM tests'
-        try {
-          gradle 'assemble check javadoc'
-        } finally {
-          storeJunitResults 'realm/realm-annotations-processor/build/test-results/TEST-*.xml'
-          storeJunitResults 'examples/unitTestExample/build/test-results/**/TEST-*.xml'
-          step([$class: 'LintPublisher'])
-        }
-
-        stage 'Static code analysis'
-        try {
-          gradle('realm', 'findbugs pmd checkstyle')
-        } finally {
-          publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/findbugs', reportFiles: 'findbugs-output.html', reportName: 'Findbugs issues'])
-          publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/reports/pmd', reportFiles: 'pmd.html', reportName: 'PMD Issues'])
-          step([$class: 'CheckStylePublisher',
-          canComputeNew: false,
-          defaultEncoding: '',
-          healthy: '',
-          pattern: 'realm/realm-library/build/reports/checkstyle/checkstyle.xml',
-          unHealthy: ''
-          ])
-        }
-
-        stage 'Run instrumented tests'
-        boolean archiveLog = true
-        String backgroundPid
-        try {
-          backgroundPid = startLogCatCollector()
-          gradle('realm', 'connectedUnitTests')
-          archiveLog = false;
-        } finally {
-          stopLogCatCollector(backgroundPid, archiveLog)
-          storeJunitResults 'realm/realm-library/build/outputs/androidTest-results/connected/TEST-*.xml'
-        }
-
-        // TODO: add support for running monkey on the example apps
-
-        if (env.BRANCH_NAME == 'master') {
-          stage 'Collect metrics'
-          collectAarMetrics()
-
-          stage 'Publish to OJO'
-          withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: 'bintray', passwordVariable: 'BINTRAY_KEY', usernameVariable: 'BINTRAY_USER']]) {
-            sh "chmod +x gradlew && ./gradlew -PbintrayUser=${env.BINTRAY_USER} -PbintrayKey=${env.BINTRAY_KEY} assemble ojoUpload --stacktrace"
+      stage('SCM') {
+        checkout([
+          $class: 'GitSCM',
+          branches: scm.branches,
+          gitTool: 'native git',
+          extensions: scm.extensions + [[$class: 'CleanCheckout']],
+          userRemoteConfigs: scm.userRemoteConfigs
+        ])
+        sh 'git submodule sync'
+        sh 'git submodule update --init --recursive'
+        // Make sure not to delete the folder that Jenkins allocates to store scripts
+        sh 'git clean -ffdx -e .????????'
+      }
+
+      def buildEnv
+      def rosEnv
+      stage('Docker build') {
+        // Docker image for build
+        buildEnv = docker.build 'realm-java:snapshot'
+        // Docker image for testing Realm Object Server
+        def dependProperties = readProperties file: 'dependencies.list'
+        def rosDeVersion = dependProperties["REALM_OBJECT_SERVER_DE_VERSION"]
+        rosEnv = docker.build 'ros:snapshot', "--build-arg ROS_DE_VERSION=${rosDeVersion} tools/sync_test_server"
+      }
+
+      rosContainer = rosEnv.run("-v /tmp=/tmp/.ros " +
+              "--name ros")
+
+      try {
+          buildEnv.inside("-e HOME=/tmp " +
+                  "-e _JAVA_OPTIONS=-Duser.home=/tmp " +
+                  "--privileged " +
+                  "-v /dev/bus/usb:/dev/bus/usb " +
+                  "-v ${env.HOME}/gradle-cache:/tmp/.gradle " +
+                  "-v ${env.HOME}/.android:/tmp/.android " +
+                  "-v ${env.HOME}/ccache:/tmp/.ccache " +
+                  "-v ${env.HOME}/lcache:/tmp/.lcache " +
+                  "--network container:ros") {
+            stage('JVM tests') {
+              try {
+                withCredentials([[$class: 'FileBinding', credentialsId: 'c0cc8f9e-c3f1-4e22-b22f-6568392e26ae', variable: 'S3CFG']]) {
+                  sh "chmod +x gradlew && ./gradlew assemble check javadoc -Ps3cfg=${env.S3CFG}"
+                }
+              } finally {
+                storeJunitResults 'realm/realm-annotations-processor/build/test-results/test/TEST-*.xml'
+                storeJunitResults 'examples/unitTestExample/build/test-results/**/TEST-*.xml'
+                step([$class: 'LintPublisher'])
+              }
+            }
+
+            stage('Static code analysis') {
+              try {
+                gradle('realm', 'findbugs pmd checkstyle')
+              } finally {
+                publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/findbugs', reportFiles: 'findbugs-output.html', reportName: 'Findbugs issues'])
+                publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/reports/pmd', reportFiles: 'pmd.html', reportName: 'PMD Issues'])
+                step([$class: 'CheckStylePublisher',
+                canComputeNew: false,
+                defaultEncoding: '',
+                healthy: '',
+                pattern: 'realm/realm-library/build/reports/checkstyle/checkstyle.xml',
+                unHealthy: ''
+                ])
+              }
+            }
+
+            stage('Run instrumented tests') {
+              boolean archiveLog = true
+              String backgroundPid
+              try {
+                backgroundPid = startLogCatCollector()
+                forwardAdbPorts()
+                gradle('realm', 'connectedUnitTests')
+                archiveLog = false;
+              } finally {
+                stopLogCatCollector(backgroundPid, archiveLog)
+                storeJunitResults 'realm/realm-library/build/outputs/androidTest-results/connected/**/TEST-*.xml'
+              }
+            }
+
+            // TODO: add support for running monkey on the example apps
+
+            if (env.BRANCH_NAME == 'master') {
+              stage('Collect metrics') {
+                collectAarMetrics()
+              }
+
+              stage('Publish to OJO') {
+                withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: 'bintray', passwordVariable: 'BINTRAY_KEY', usernameVariable: 'BINTRAY_USER']]) {
+                  sh "chmod +x gradlew && ./gradlew -PbintrayUser=${env.BINTRAY_USER} -PbintrayKey=${env.BINTRAY_KEY} assemble ojoUpload --stacktrace"
+                }
+              }
+            }
           }
-        }
+      } finally {
+          rosContainer.stop()
       }
     }
   }
@@ -93,6 +132,12 @@ try {
   }
 }
 
+def forwardAdbPorts() {
+  sh ''' adb reverse tcp:7800 tcp:7800 &&
+      adb reverse tcp:8080 tcp:8080 &&
+      adb reverse tcp:8888 tcp:8888
+  '''
+}
 
 def String startLogCatCollector() {
   sh '''adb logcat -c
@@ -111,19 +156,19 @@ def stopLogCatCollector(String backgroundPid, boolean archiveLog) {
       'glob' : 'logcat.txt'
     ])
   }
-  sh 'rm logcat.txt '
+  sh 'rm logcat.txt'
 }
 
-def sendMetrics(String metric, String value) {
+def sendMetrics(String metricName, String metricValue, Map<String, String> tags) {
+  def tagsString = getTagsString(tags)
   withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: '5b8ad2d9-61a4-43b5-b4df-b8ff6b1f16fa', passwordVariable: 'influx_pass', usernameVariable: 'influx_user']]) {
-    sh "curl -i -XPOST 'https://greatscott-pinheads-70.c.influxdb.com:8086/write?db=realm' --data-binary '${metric} value=${value}i' --user '${env.influx_user}:${env.influx_pass}'"
+    sh "curl -i -XPOST 'https://greatscott-pinheads-70.c.influxdb.com:8086/write?db=realm' --data-binary '${metricName},${tagsString} value=${metricValue}i' --user '${env.influx_user}:${env.influx_pass}'"
   }
 }
 
-def sendTaggedMetric(String metric, String value, String tagName, String tagValue) {
-  withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: '5b8ad2d9-61a4-43b5-b4df-b8ff6b1f16fa', passwordVariable: 'influx_pass', usernameVariable: 'influx_user']]) {
-    sh "curl -i -XPOST 'https://greatscott-pinheads-70.c.influxdb.com:8086/write?db=realm' --data-binary '${metric},${tagName}=${tagValue} value=${value}i' --user '${env.influx_user}:${env.influx_pass}'"
-  }
+@NonCPS
+def getTagsString(Map<String, String> tags) {
+  return tags.collect { k,v -> "$k=$v" }.join(',')
 }
 
 def storeJunitResults(String path) {
@@ -134,24 +179,30 @@ def storeJunitResults(String path) {
 }
 
 def collectAarMetrics() {
-  sh '''set -xe
-  cd realm/realm-library/build/outputs/aar
-  unzip realm-android-library-release.aar -d unzipped
-  find $ANDROID_HOME -name dx | sort -r | head -n 1 > dx
-  $(cat dx) --dex --output=temp.dex unzipped/classes.jar
-  cat temp.dex | head -c 92 | tail -c 4 | hexdump -e '1/4 "%d"' > methods
-  '''
-
-  sendMetrics('methods', readFile('realm/realm-library/build/outputs/aar/methods'))
-
-  def aarFile = findFiles(glob: 'realm/realm-library/build/outputs/aar/realm-android-library-release.aar')[0]
-  sendMetrics('aar_size', aarFile.length as String)
-
-  def soFiles = findFiles(glob: 'realm/realm-library/build/outputs/aar/unzipped/jni/*/librealm-jni.so')
-  for (int i = 0; i < soFiles.length; i++) {
-      def abiName = soFiles[i].path.tokenize('/')[-2]
-      def libSize = soFiles[i].length as String
-      sendTaggedMetric('abi_size', libSize, 'type', abiName)
+  def flavors = ['base', 'objectServer']
+  for (def i = 0; i < flavors.size(); i++) {
+    def flavor = flavors[i]
+    sh """set -xe
+      cd realm/realm-library/build/outputs/aar
+      unzip realm-android-library-${flavor}-release.aar -d unzipped${flavor}
+      find \$ANDROID_HOME -name dx | sort -r | head -n 1 > dx
+      \$(cat dx) --dex --output=temp${flavor}.dex unzipped${flavor}/classes.jar
+      cat temp${flavor}.dex | head -c 92 | tail -c 4 | hexdump -e '1/4 \"%d\"' > methods${flavor}
+    """
+
+    def methods = readFile("realm/realm-library/build/outputs/aar/methods${flavor}")
+    sendMetrics('methods', methods, ['flavor':flavor])
+
+    def aarFile = findFiles(glob: "realm/realm-library/build/outputs/aar/realm-android-library-${flavor}-release.aar")[0]
+    sendMetrics('aar_size', aarFile.length as String, ['flavor':flavor])
+
+    def soFiles = findFiles(glob: "realm/realm-library/build/outputs/aar/unzipped${flavor}/jni/*/librealm-jni.so")
+    for (def j = 0; j < soFiles.size(); j++) {
+        def soFile = soFiles[j]
+        def abiName = soFile.path.tokenize('/')[-2]
+        def libSize = soFile.length as String
+        sendMetrics('abi_size', libSize, ['flavor':flavor, 'type':abiName])
+    }
   }
 }
 
diff --git a/LICENSE b/LICENSE
index 62e2f9e364..273b4d5f7b 100644
--- a/LICENSE
+++ b/LICENSE
@@ -4,7 +4,7 @@ TABLE OF CONTENTS
 2. Realm Components
 3. Export Compliance
 
--------------------------------------------------------------------------------
+1. -------------------------------------------------------------------------------
 
                                  Apache License
                            Version 2.0, January 2004
@@ -183,31 +183,7 @@ TABLE OF CONTENTS
 
    END OF TERMS AND CONDITIONS
 
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "{}"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright {yyyy} {name of copyright owner}
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
+2. -------------------------------------------------------------------------------
 
 REALM COMPONENTS
 
@@ -215,11 +191,11 @@ This software contains components with separate copyright and license terms.
 Your use of these components is subject to the terms and conditions of the
 following licenses.
 
-For the Realm Core component
+For the Realm Platform Extensions component
 
-  Realm Core Binary License
+  Realm Platform Extensions License
 
-  Copyright (c) 2011-2015 Realm Inc All rights reserved
+  Copyright (c) 2011-2016 Realm Inc All rights reserved
 
   Redistribution and use in binary form, with or without modification, is
   permitted provided that the following conditions are met:
@@ -250,6 +226,8 @@ For the Realm Core component
   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.
 
+3. -------------------------------------------------------------------------------
+
 EXPORT COMPLIANCE
 
 You understand that the Software may contain cryptographic functions that may be
diff --git a/README.md b/README.md
index 9f0eeec413..e552001903 100644
--- a/README.md
+++ b/README.md
@@ -59,6 +59,8 @@ In case you don't want to use the precompiled version, you can build Realm yours
 
  * Make sure `make` is available in your `$PATH`.
  * Download the [**JDK 7**](http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html) or [**JDK 8**](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) from Oracle and install it.
+ * Download & install s3cmd (`brew install s3cmd` on Mac, `sudo apt-get install s3cmd` on Ubuntu).
+ * Get `.s3cfg` file and put it in your home directory. If you'd like to put it other location, add `s3cfg=<path to .s3cfg>` in `~/.gradle/gradle.properties`.
  * Download & install the Android SDK **Build-Tools 24.0.0**, **Android N (API 24)** (for example through Android Studioâ€™s **Android SDK Manager**).
  * Download the **Android NDK (= r10e)** for [OS X](http://dl.google.com/android/ndk/android-ndk-r10e-darwin-x86_64.bin) or [Linux](http://dl.google.com/android/ndk/android-ndk-r10e-linux-x86_64.bin).
  * Install CMake from SDK manager in Android Studio ("SDK Tools" -> "CMake").
@@ -162,6 +164,30 @@ The `./examples` folder contain a number of example projects showing how Realm c
 
 Standalone examples can be [downloaded from website](https://realm.io/docs/java/latest/#getting-started).
 
+## Running Tests Using The Realm Object Server
+
+Tests in `realm/realm-library/src/syncIntegrationTest` require a running testing server to work.
+A docker image can be built from `tools/sync_test_server/Dockerfile` to run the test server.
+`tools/sync_test_server/start_server.sh` will build the docker image automatically.
+
+To run a testing server locally:
+
+1. Install docker.
+
+2. Run `tools/sync_test_server/start_server.sh`:
+
+```sh
+cd tools/sync_test_server
+./start_server.sh
+```
+
+3. Run instrumentation tests:
+
+```sh
+cd realm
+./gradlew connectedObjectServerDebugAndroidTest
+```
+
 ## Contributing
 
 See [CONTRIBUTING.md](CONTRIBUTING.md) for more details!
diff --git a/build.gradle b/build.gradle
index 228c2813a0..cd7c5facad 100644
--- a/build.gradle
+++ b/build.gradle
@@ -14,7 +14,7 @@ def currentVersion = file("${projectDir}/version.txt").text.trim();
 def props = new Properties()
 props.load(new FileInputStream("${rootDir}/realm.properties"))
 props.each { key, val ->
-    project.set(key, val)
+    project.ext.set(key, val)
 }
 
 task assembleAnnotations(type:GradleBuild) {
@@ -28,7 +28,7 @@ task installAnnotations(type:GradleBuild) {
     group = 'Install'
     description = 'Install the jar realm-annotations into mavenLocal()'
     buildFile = file('realm-annotations/build.gradle')
-    tasks = ['install']
+    tasks = ['publishToMavenLocal']
 }
 
 task assembleTransformer(type:GradleBuild) {
@@ -44,7 +44,7 @@ task installTransformer(type:GradleBuild) {
     description = 'Install the jar realm-transformer into mavenLocal()'
     dependsOn installAnnotations
     buildFile = file('realm-transformer/build.gradle')
-    tasks = ['install']
+    tasks = ['publishToMavenLocal']
 }
 
 task assembleRealm(type:GradleBuild) {
@@ -57,6 +57,9 @@ task assembleRealm(type:GradleBuild) {
     if (project.hasProperty('buildTargetABIs')) {
         startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
     }
+    if (project.hasProperty('s3cfg')) {
+        startParameter.projectProperties += [s3cfg: project.getProperty('s3cfg')]
+    }
 }
 
 task checkExamples(type:GradleBuild) {
@@ -102,10 +105,13 @@ task installRealm(type:GradleBuild) {
     description = 'Install the artifacts of Realm libraries into mavenLocal()'
     dependsOn installTransformer
     buildFile = file('realm/build.gradle')
-    tasks = ['install']
+    tasks = ['publishToMavenLocal']
     if (project.hasProperty('buildTargetABIs')) {
         startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
     }
+    if (project.hasProperty('s3cfg')) {
+        startParameter.projectProperties += [s3cfg: project.getProperty('s3cfg')]
+    }
 }
 
 task assembleGradlePlugin(type:GradleBuild) {
@@ -123,7 +129,7 @@ task installGradlePlugin(type:GradleBuild) {
     dependsOn installRealm
     dependsOn installTransformer
     buildFile = file('gradle-plugin/build.gradle')
-    tasks = ['install']
+    tasks = ['publishToMavenLocal']
 }
 
 task installRealmJava(type:Task) {
@@ -348,7 +354,7 @@ task ojoRealm(type: GradleBuild) {
     description = 'Publish the Realm AAR and AP SNAPSHOT to Bintray'
     group = 'Publishing'
     buildFile = file('realm/build.gradle')
-    tasks = ['artifactoryPublish']
+    tasks = ['ojoUpload']
     startParameter.projectProperties = gradle.startParameter.projectProperties
     if (project.hasProperty('buildTargetABIs')) {
         startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
diff --git a/dependencies.list b/dependencies.list
new file mode 100644
index 0000000000..de35027e6e
--- /dev/null
+++ b/dependencies.list
@@ -0,0 +1,8 @@
+# Realm Sync Core release used by Realm Java
+# https://github.com/realm/realm-sync/releases
+REALM_SYNC_VERSION=1.0.0-BETA-3.2
+REALM_SYNC_SHA256=999f4fabe9f377ab03ced221e82317d6e02361da67e0a9928c66ddb56798e58e
+
+# Object Server Release used by Integration tests
+# https://packagecloud.io/realm/realm?filter=debs
+REALM_OBJECT_SERVER_DE_VERSION=1.0.0-BETA-2.3-310
\ No newline at end of file
diff --git a/examples/encryptionExample/lint.xml b/examples/encryptionExample/lint.xml
index 0666c5455c..6793b0702b 100644
--- a/examples/encryptionExample/lint.xml
+++ b/examples/encryptionExample/lint.xml
@@ -6,4 +6,5 @@
     <issue id="TrulyRandom" severity="ignore" />
     <issue id="PrngFix" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/gradle.properties b/examples/gradle.properties
new file mode 100644
index 0000000000..4a9594aeec
--- /dev/null
+++ b/examples/gradle.properties
@@ -0,0 +1 @@
+org.gradle.jvmargs=-Xmx2048M
\ No newline at end of file
diff --git a/examples/gradle/wrapper/gradle-wrapper.jar b/examples/gradle/wrapper/gradle-wrapper.jar
index e8c6bf7bb4..3baa851b28 100644
Binary files a/examples/gradle/wrapper/gradle-wrapper.jar and b/examples/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/examples/gradle/wrapper/gradle-wrapper.properties b/examples/gradle/wrapper/gradle-wrapper.properties
index f71002edb7..f930473763 100644
--- a/examples/gradle/wrapper/gradle-wrapper.properties
+++ b/examples/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Jan 05 14:18:17 CET 2016
+#Tue Sep 20 14:25:59 CST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
diff --git a/examples/gradlew b/examples/gradlew
index 97fac783e1..27309d9231 100755
--- a/examples/gradlew
+++ b/examples/gradlew
@@ -6,12 +6,30 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,26 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -85,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
diff --git a/examples/gradlew.bat b/examples/gradlew.bat
index aec99730b4..f6d5974e72 100644
--- a/examples/gradlew.bat
+++ b/examples/gradlew.bat
@@ -8,14 +8,14 @@
 @rem Set local scope for the variables with windows NT shell
 if "%OS%"=="Windows_NT" setlocal
 
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
 set DIRNAME=%~dp0
 if "%DIRNAME%" == "" set DIRNAME=.
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
@@ -46,7 +46,7 @@ echo location of your Java installation.
 goto fail
 
 :init
-@rem Get command-line arguments, handling Windowz variants
+@rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
 if "%@eval[2+2]" == "4" goto 4NT_args
diff --git a/examples/gridViewExample/lint.xml b/examples/gridViewExample/lint.xml
index 3af2534ba6..6a9810cdcb 100644
--- a/examples/gridViewExample/lint.xml
+++ b/examples/gridViewExample/lint.xml
@@ -6,4 +6,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/introExample/lint.xml b/examples/introExample/lint.xml
index 3af2534ba6..6a9810cdcb 100644
--- a/examples/introExample/lint.xml
+++ b/examples/introExample/lint.xml
@@ -6,4 +6,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
index 684960e753..faa6b1eb78 100644
--- a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
+++ b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
@@ -24,7 +24,6 @@
 import android.widget.TextView;
 
 import io.realm.Realm;
-import io.realm.RealmConfiguration;
 import io.realm.RealmResults;
 import io.realm.Sort;
 import io.realm.examples.intro.model.Cat;
@@ -37,7 +36,6 @@
     private LinearLayout rootLayout = null;
 
     private Realm realm;
-    private RealmConfiguration realmConfig;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -146,9 +144,9 @@ private void basicLinkQuery(Realm realm) {
     private String complexReadWrite() {
         String status = "\nPerforming complex Read/Write operation...";
 
-        // Open the default realm. All threads must use it's own reference to the realm.
+        // Open the default realm. All threads must use its own reference to the realm.
         // Those can not be transferred across threads.
-        Realm realm = Realm.getInstance(realmConfig);
+        Realm realm = Realm.getDefaultInstance();
 
         // Add ten persons in one transaction
         realm.executeTransaction(new Realm.Transaction() {
@@ -204,7 +202,7 @@ public void execute(Realm realm) {
     private String complexQuery() {
         String status = "\n\nPerforming complex Query operation...";
 
-        Realm realm = Realm.getInstance(realmConfig);
+        Realm realm = Realm.getDefaultInstance();
         status += "\nNumber of persons: " + realm.where(Person.class).count();
 
         // Find all persons where age between 7 and 9 and name begins with "Person".
diff --git a/examples/jsonExample/lint.xml b/examples/jsonExample/lint.xml
index 6a7edc9890..a443370a1a 100644
--- a/examples/jsonExample/lint.xml
+++ b/examples/jsonExample/lint.xml
@@ -5,4 +5,5 @@
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="PrngFix" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index a7baf526da..8741e4a82f 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -1,5 +1,5 @@
 buildscript {
-    ext.kotlin_version = '1.0.3'
+    ext.kotlin_version = '1.0.4'
     repositories {
         jcenter()
         mavenCentral()
@@ -51,6 +51,5 @@ android {
 
 dependencies {
     compile "org.jetbrains.kotlin:kotlin-stdlib:${kotlin_version}"
-    compile "org.jetbrains.kotlin:kotlin-reflect:${kotlin_version}"
     compile 'org.jetbrains.anko:anko-sdk15:0.8.2'
 }
diff --git a/examples/kotlinExample/lint.xml b/examples/kotlinExample/lint.xml
index cc4d461aee..7d530f741e 100644
--- a/examples/kotlinExample/lint.xml
+++ b/examples/kotlinExample/lint.xml
@@ -5,4 +5,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
index f519715041..d903e5a208 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
@@ -23,7 +23,6 @@ import android.widget.LinearLayout
 import android.widget.TextView
 import io.realm.Realm
 import io.realm.Sort
-import io.realm.RealmConfiguration
 import io.realm.examples.kotlin.model.Cat
 import io.realm.examples.kotlin.model.Dog
 import io.realm.examples.kotlin.model.Person
@@ -31,16 +30,14 @@ import org.jetbrains.anko.async
 import org.jetbrains.anko.uiThread
 import kotlin.properties.Delegates
 
-
 class KotlinExampleActivity : Activity() {
 
     companion object {
-        val TAG: String = KotlinExampleActivity::class.qualifiedName as String
+        val TAG: String = KotlinExampleActivity::class.java.simpleName
     }
 
     private var rootLayout: LinearLayout by Delegates.notNull()
     private var realm: Realm by Delegates.notNull()
-    private var realmConfig: RealmConfiguration by Delegates.notNull()
 
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
@@ -52,7 +49,7 @@ class KotlinExampleActivity : Activity() {
         // we can generally safely run them on the UI thread.
 
         // Open the realm for the UI thread.
-        realm = Realm.getDefaultInstance();
+        realm = Realm.getDefaultInstance()
 
         basicCRUD(realm)
         basicQuery(realm)
@@ -96,14 +93,13 @@ class KotlinExampleActivity : Activity() {
         // All writes must be wrapped in a transaction to facilitate safe multi threading
         realm.executeTransaction {
             // Add a person
-            var person = realm.createObject(Person::class.java)
-            person.id = 1
+            val person = realm.createObject(Person::class.java, 1)
             person.name = "Young Person"
             person.age = 14
         }
 
         // Find the first person (no query conditions) and read a field
-        var person = realm.where(Person::class.java).findFirst()
+        val person = realm.where(Person::class.java).findFirst()
         showStatus(person.name + ": " + person.age)
 
         // Update person in a transaction
@@ -135,9 +131,9 @@ class KotlinExampleActivity : Activity() {
     private fun complexReadWrite(): String {
         var status = "\nPerforming complex Read/Write operation..."
 
-        // Open the default realm. All threads must use it's own reference to the realm.
+        // Open the default realm. All threads must use its own reference to the realm.
         // Those can not be transferred across threads.
-        val realm = Realm.getInstance(realmConfig)
+        val realm = Realm.getDefaultInstance()
 
         // Add ten persons in one transaction
         realm.executeTransaction {
@@ -180,7 +176,7 @@ class KotlinExampleActivity : Activity() {
         }
 
         // Sorting
-        val sortedPersons = realm.where(Person::class.java).findAllSorted("age", Sort.DESCENDING);
+        val sortedPersons = realm.where(Person::class.java).findAllSorted("age", Sort.DESCENDING)
         check(realm.where(Person::class.java).findAll().last().name == sortedPersons.first().name)
         status += "\nSorting ${sortedPersons.last().name} == ${realm.where(Person::class.java).findAll().first().name}"
 
@@ -193,7 +189,7 @@ class KotlinExampleActivity : Activity() {
 
         // Realm implements the Closable interface, therefore we can make use of Kotlin's built-in
         // extension method 'use' (pun intended).
-        Realm.getInstance(realmConfig).use {
+        Realm.getDefaultInstance().use {
             // 'it' is the implicit lambda parameter of type Realm
             status += "\nNumber of persons: ${it.where(Person::class.java).count()}"
 
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
index 36deb5c3dc..c408a12472 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
@@ -30,7 +30,9 @@ open class Person(
         // All properties are by default persisted.
         // Properties can be annotated with PrimaryKey or Index.
         // If you use non-nullable types, properties must be initialized with non-null values.
-        @PrimaryKey open var name: String = "",
+        @PrimaryKey open var id: Long = 0,
+
+        open var name: String = "",
 
         open var age: Int = 0,
 
@@ -41,9 +43,8 @@ open class Person(
         open var cats: RealmList<Cat> = RealmList(),
 
         // You can instruct Realm to ignore a field and not persist it.
-        @Ignore open var tempReference: Int = 0,
+        @Ignore open var tempReference: Int = 0
 
-        open var id: Long = 0
 ) : RealmObject() {
     // The Kotlin compiler generates standard getters and setters.
     // Realm will overload them and code inside them is ignored.
diff --git a/examples/migrationExample/lint.xml b/examples/migrationExample/lint.xml
index 1d3dbb0011..1f5e37cb86 100644
--- a/examples/migrationExample/lint.xml
+++ b/examples/migrationExample/lint.xml
@@ -4,4 +4,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/moduleExample/app/build.gradle b/examples/moduleExample/app/build.gradle
index 957f094945..c8e16e60d3 100644
--- a/examples/moduleExample/app/build.gradle
+++ b/examples/moduleExample/app/build.gradle
@@ -25,9 +25,8 @@ android {
 
     buildTypes {
         release {
-            minifyEnabled true
-            proguardFiles getDefaultProguardFile('proguard-android.txt'),
-                    'proguard-rules.pro'
+            minifyEnabled false // FIXME Why is this suddenly broken?
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
             signingConfig signingConfigs.release
         }
     }
diff --git a/examples/moduleExample/app/lint.xml b/examples/moduleExample/app/lint.xml
index 1d3dbb0011..1f5e37cb86 100644
--- a/examples/moduleExample/app/lint.xml
+++ b/examples/moduleExample/app/lint.xml
@@ -4,4 +4,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/moduleExample/library/lint.xml b/examples/moduleExample/library/lint.xml
index 3af2534ba6..6a9810cdcb 100644
--- a/examples/moduleExample/library/lint.xml
+++ b/examples/moduleExample/library/lint.xml
@@ -6,4 +6,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/newsreaderExample/lint.xml b/examples/newsreaderExample/lint.xml
index 1d3dbb0011..1f5e37cb86 100644
--- a/examples/newsreaderExample/lint.xml
+++ b/examples/newsreaderExample/lint.xml
@@ -4,4 +4,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/objectServerExample/README.md b/examples/objectServerExample/README.md
new file mode 100644
index 0000000000..f9ec43ab2d
--- /dev/null
+++ b/examples/objectServerExample/README.md
@@ -0,0 +1,14 @@
+# Using this example
+
+This example shows a minimal example on how to connect to and use the
+Realm Object Server to synchronize changes between devices.
+
+The example will assume that the Object Server is running on the machine
+building the example and the IP address will automatically be injected
+into the build configuration.
+
+If this for some reasons does not work, please insert the IP Address into
+the `build.gradle` accordingly.
+
+To read more about the Realm Object Server and how to deploy it, see
+https://realm.io/news/introducing-realm-mobile-platform/
diff --git a/examples/objectServerExample/build.gradle b/examples/objectServerExample/build.gradle
new file mode 100644
index 0000000000..dd0e37e1ae
--- /dev/null
+++ b/examples/objectServerExample/build.gradle
@@ -0,0 +1,67 @@
+apply plugin: 'com.android.application'
+apply plugin: 'android-command'
+apply plugin: 'realm-android'
+
+// Credit: http://jeremie-martinez.com/2015/05/05/inject-host-gradle/
+def getIP() {
+    InetAddress result = null;
+    Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();
+    while (interfaces.hasMoreElements()) {
+        Enumeration<InetAddress> addresses = interfaces.nextElement().getInetAddresses();
+        while (addresses.hasMoreElements()) {
+            InetAddress address = addresses.nextElement();
+            if (!address.isLoopbackAddress()) {
+                if (address.isSiteLocalAddress()) {
+                    return address.getHostAddress();
+                } else if (result == null) {
+                    result = address;
+                }
+            }
+        }
+    }
+    return (result != null ? result : InetAddress.getLocalHost()).getHostAddress();
+}
+
+android {
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
+
+    defaultConfig {
+        applicationId 'io.realm.examples.objectserver'
+        targetSdkVersion rootProject.sdkVersion
+        minSdkVersion 15
+        versionCode 1
+        versionName "1.0"
+    }
+
+    buildTypes {
+        // This will automatically try to detect the IP address of the machine
+        // building the example. It is assumed that this machine is also running
+        // the Object Server. If not, replace 'host' with the IP of the machine
+        // hosting the server. In some cases the wrong IP address will also
+        // be detected. In that case also insert the IP address manually.
+        def host = getIP()
+        debug {
+            buildConfigField "String", "OBJECT_SERVER_IP", "\"${host}\""
+        }
+        release {
+            minifyEnabled false
+            buildConfigField "String", "OBJECT_SERVER_IP", "\"${host}\""
+        }
+    }
+
+    command {
+        events 2000
+    }
+}
+
+realm {
+    syncEnabled = true
+}
+
+dependencies {
+    compile 'com.android.support:support-v4:24.2.0'
+    compile 'com.android.support:design:24.2.0'
+    compile 'com.jakewharton:butterknife:8.3.0'
+    apt 'com.jakewharton:butterknife-compiler:8.3.0'
+}
diff --git a/examples/objectServerExample/lint.xml b/examples/objectServerExample/lint.xml
new file mode 100644
index 0000000000..6a9810cdcb
--- /dev/null
+++ b/examples/objectServerExample/lint.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Disable the given check in this project -->
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
+</lint>
diff --git a/examples/objectServerExample/src/main/AndroidManifest.xml b/examples/objectServerExample/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..45e5d52c1c
--- /dev/null
+++ b/examples/objectServerExample/src/main/AndroidManifest.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="io.realm.examples.objectserver" >
+
+    <application
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name"
+        android:name="io.realm.examples.objectserver.MyApplication"
+        android:theme="@style/AppTheme" >
+        <activity
+            android:name="io.realm.examples.objectserver.CounterActivity"
+            android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+        <activity
+            android:name="io.realm.examples.objectserver.LoginActivity"
+            android:label="Login" >
+        </activity>
+    </application>
+
+</manifest>
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
new file mode 100644
index 0000000000..97c67d2443
--- /dev/null
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.objectserver;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v7.app.AppCompatActivity;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.widget.TextView;
+
+import java.util.Locale;
+
+import butterknife.BindView;
+import butterknife.ButterKnife;
+import butterknife.OnClick;
+import io.realm.Realm;
+import io.realm.RealmChangeListener;
+import io.realm.SyncConfiguration;
+import io.realm.SyncUser;
+import io.realm.examples.objectserver.model.CRDTCounter;
+
+public class CounterActivity extends AppCompatActivity {
+
+    private static final String REALM_URL = "realm://" + BuildConfig.OBJECT_SERVER_IP + ":9080/~/default";
+
+    private Realm realm;
+    private CRDTCounter counter;
+    private SyncUser user;
+
+    @BindView(R.id.text_counter) TextView counterView;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_counter);
+        ButterKnife.bind(this);
+
+        // Check if we have a valid user, otherwise redirect to login
+        if (SyncUser.currentUser() == null) {
+            gotoLoginActivity();
+        }
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        user = SyncUser.currentUser();
+        if (user != null) {
+            // Create a RealmConfiguration for our user
+            SyncConfiguration config = new SyncConfiguration.Builder(user, REALM_URL)
+                    .initialData(new Realm.Transaction() {
+                        @Override
+                        public void execute(Realm realm) {
+                            realm.createObject(CRDTCounter.class, 1);
+                        }
+                    })
+                    .build();
+
+            // This will automatically sync all changes in the background for as long as the Realm is open
+            realm = Realm.getInstance(config);
+
+            counter = realm.where(CRDTCounter.class).findFirstAsync();
+            counter.addChangeListener(new RealmChangeListener<CRDTCounter>() {
+                @Override
+                public void onChange(CRDTCounter counter) {
+                    if (counter.isValid()) {
+                        counterView.setText(String.format(Locale.US, "%d", counter.getCount()));
+                    } else {
+                        counterView.setText("-");
+                    }
+                }
+            });
+            counterView.setText("0");
+        }
+    }
+
+    @Override
+    protected void onStop() {
+        super.onStop();
+        closeRealm();
+        user = null;
+    }
+
+    private void closeRealm() {
+        if (realm != null && !realm.isClosed()) {
+            realm.close();
+        }
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        getMenuInflater().inflate(R.menu.menu_counter, menu);
+        return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch(item.getItemId()) {
+            case R.id.action_logout:
+                closeRealm();
+                user.logout();
+                gotoLoginActivity();
+                return true;
+
+            default:
+                return super.onOptionsItemSelected(item);
+        }
+    }
+
+    @OnClick(R.id.upper)
+    public void incrementCounter() {
+        adjustCounter(1);
+    }
+
+    @OnClick(R.id.lower)
+    public void decrementCounter() {
+        adjustCounter(-1);
+    }
+
+    private void adjustCounter(final int adjustment) {
+        // A synchronized Realm can get written to at any point in time, so doing synchronous writes on the UI
+        // thread is HIGHLY discouraged as it might block longer than intended. Only use async transactions.
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                CRDTCounter counter = realm.where(CRDTCounter.class).findFirst();
+                counter.add(adjustment);
+            }
+        });
+    }
+
+    private void gotoLoginActivity() {
+        Intent intent = new Intent(this, LoginActivity.class);
+        startActivity(intent);
+    }
+}
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java
new file mode 100644
index 0000000000..5ce56afb27
--- /dev/null
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.objectserver;
+
+import android.app.ProgressDialog;
+import android.os.Bundle;
+import android.support.v7.app.AppCompatActivity;
+import android.view.View;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.Toast;
+
+import butterknife.BindView;
+import butterknife.ButterKnife;
+import io.realm.SyncCredentials;
+import io.realm.ObjectServerError;
+import io.realm.SyncUser;
+import io.realm.UserStore;
+
+import static io.realm.ErrorCode.UNKNOWN_ACCOUNT;
+
+public class LoginActivity extends AppCompatActivity {
+
+    @BindView(R.id.input_username) EditText username;
+    @BindView(R.id.input_password) EditText password;
+    @BindView(R.id.button_login) Button loginButton;
+    @BindView(R.id.button_create) Button createUserButton;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_login);
+        ButterKnife.bind(this);
+        loginButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                login(false);
+            }
+        });
+        createUserButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                login(true);
+            }
+        });
+    }
+
+    public void login(boolean createUser) {
+        if (!validate()) {
+            onLoginFailed("Invalid username or password");
+            return;
+        }
+
+        createUserButton.setEnabled(false);
+        loginButton.setEnabled(false);
+
+        final ProgressDialog progressDialog = new ProgressDialog(LoginActivity.this);
+        progressDialog.setIndeterminate(true);
+        progressDialog.setMessage("Authenticating...");
+        progressDialog.show();
+
+        String username = this.username.getText().toString();
+        String password = this.password.getText().toString();
+
+        SyncCredentials creds = SyncCredentials.usernamePassword(username, password, createUser);
+        String authUrl = "http://" + BuildConfig.OBJECT_SERVER_IP + ":9080/auth";
+        SyncUser.Callback callback = new SyncUser.Callback() {
+            @Override
+            public void onSuccess(SyncUser user) {
+                progressDialog.dismiss();
+                onLoginSuccess();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                progressDialog.dismiss();
+                String errorMsg;
+                switch (error.getErrorCode()) {
+                    case UNKNOWN_ACCOUNT:
+                        errorMsg = "Account does not exists.";
+                        break;
+                    case INVALID_CREDENTIALS:
+                        errorMsg = "User name and password does not match";
+                        break;
+                    default:
+                        errorMsg = error.toString();
+                }
+                onLoginFailed(errorMsg);
+            }
+        };
+
+        SyncUser.loginAsync(creds, authUrl, callback);
+    }
+
+    @Override
+    public void onBackPressed() {
+        // Disable going back to the MainActivity
+        moveTaskToBack(true);
+    }
+
+    public void onLoginSuccess() {
+        loginButton.setEnabled(true);
+        createUserButton.setEnabled(true);
+        finish();
+    }
+
+    public void onLoginFailed(String errorMsg) {
+        loginButton.setEnabled(true);
+        createUserButton.setEnabled(true);
+        Toast.makeText(getBaseContext(), errorMsg, Toast.LENGTH_LONG).show();
+    }
+
+    public boolean validate() {
+        boolean valid = true;
+        String email = username.getText().toString();
+        String password = this.password.getText().toString();
+
+        if (email.isEmpty()) {
+            valid = false;
+        }
+
+        if (password.isEmpty()) {
+            valid = false;
+        }
+
+        return valid;
+    }
+}
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/MyApplication.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/MyApplication.java
new file mode 100644
index 0000000000..8fb13a829b
--- /dev/null
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/MyApplication.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.objectserver;
+
+import android.app.Application;
+import android.util.Log;
+
+import io.realm.Realm;
+import io.realm.log.RealmLog;
+
+public class MyApplication extends Application {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        Realm.init(this);
+
+        // Enable full log output when debugging
+        if (BuildConfig.DEBUG) {
+            RealmLog.setLevel(Log.VERBOSE);
+        }
+    }
+}
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CRDTCounter.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CRDTCounter.java
new file mode 100644
index 0000000000..93096e3ac6
--- /dev/null
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CRDTCounter.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.objectserver.model;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+
+/**
+ * Counter class that is eventually consistent. Two devices can simultaneous increment this and eventually reach
+ * the same value.
+ *
+ * @see <href ref="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">Conflict Free Replicated Data Structures</href>
+ */
+public class CRDTCounter extends RealmObject {
+
+    @PrimaryKey
+    private long id;
+    private RealmList<CounterOperation> operations;
+
+    public CRDTCounter() {
+        // Required by Realm
+    }
+
+    public CRDTCounter(long id) {
+        this.id = id;
+    }
+
+    public long getCount() {
+        return operations.where().sum("adjustment").longValue();
+    }
+
+    public void add(long val) {
+        operations.add(new CounterOperation(val));
+    }
+}
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CounterOperation.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CounterOperation.java
new file mode 100644
index 0000000000..53342f648d
--- /dev/null
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CounterOperation.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.objectserver.model;
+
+import io.realm.RealmObject;
+
+public class CounterOperation extends RealmObject {
+    public long adjustment;
+    public CounterOperation() {};
+    public CounterOperation(long adjustment) {
+        this.adjustment = adjustment;
+    }
+}
diff --git a/examples/objectServerExample/src/main/res/drawable-xxhdpi/ic_exit_to_app_white_24dp.png b/examples/objectServerExample/src/main/res/drawable-xxhdpi/ic_exit_to_app_white_24dp.png
new file mode 100644
index 0000000000..c04fe6e0e3
Binary files /dev/null and b/examples/objectServerExample/src/main/res/drawable-xxhdpi/ic_exit_to_app_white_24dp.png differ
diff --git a/examples/objectServerExample/src/main/res/drawable-xxxhdpi/ic_exit_to_app_white_24dp.png b/examples/objectServerExample/src/main/res/drawable-xxxhdpi/ic_exit_to_app_white_24dp.png
new file mode 100644
index 0000000000..27a9d7b05a
Binary files /dev/null and b/examples/objectServerExample/src/main/res/drawable-xxxhdpi/ic_exit_to_app_white_24dp.png differ
diff --git a/examples/objectServerExample/src/main/res/drawable/button_counter.xml b/examples/objectServerExample/src/main/res/drawable/button_counter.xml
new file mode 100644
index 0000000000..0d8fd827aa
--- /dev/null
+++ b/examples/objectServerExample/src/main/res/drawable/button_counter.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:drawable="@color/touch_area_pressed" android:state_pressed="true"/>
+    <item android:drawable="@color/touch_area_pressed" android:state_focused="true"/>
+    <item android:drawable="@android:color/background_light"/>
+</selector>
diff --git a/examples/objectServerExample/src/main/res/drawable/logo.png b/examples/objectServerExample/src/main/res/drawable/logo.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/objectServerExample/src/main/res/drawable/logo.png differ
diff --git a/examples/objectServerExample/src/main/res/layout/activity_counter.xml b/examples/objectServerExample/src/main/res/layout/activity_counter.xml
new file mode 100644
index 0000000000..62127eca0d
--- /dev/null
+++ b/examples/objectServerExample/src/main/res/layout/activity_counter.xml
@@ -0,0 +1,37 @@
+<RelativeLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:orientation="vertical"
+        android:weightSum="1.0">
+
+        <View
+            android:id="@+id/upper"
+            android:layout_width="match_parent"
+            android:layout_height="0dp"
+            android:layout_weight="0.5"
+            android:background="@drawable/button_counter">
+        </View>
+
+        <View
+            android:id="@+id/lower"
+            android:layout_width="match_parent"
+            android:layout_height="0dp"
+            android:layout_weight="0.5"
+            android:background="@drawable/button_counter">
+        </View>
+    </LinearLayout>
+
+    <TextView
+        android:id="@+id/text_counter"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerInParent="true"
+        android:fontFamily="sans-serif-light"
+        android:textSize="160sp"/>
+
+</RelativeLayout>
diff --git a/examples/objectServerExample/src/main/res/layout/activity_login.xml b/examples/objectServerExample/src/main/res/layout/activity_login.xml
new file mode 100644
index 0000000000..142ad539e1
--- /dev/null
+++ b/examples/objectServerExample/src/main/res/layout/activity_login.xml
@@ -0,0 +1,67 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:fitsSystemWindows="true">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical"
+        android:paddingLeft="24dp"
+        android:paddingRight="24dp"
+        android:paddingTop="56dp">
+
+        <ImageView
+            android:layout_width="wrap_content"
+            android:layout_height="72dp"
+            android:layout_gravity="center_horizontal"
+            android:layout_marginBottom="24dp"
+            android:src="@drawable/logo"/>
+
+        <android.support.design.widget.TextInputLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginBottom="8dp"
+            android:layout_marginTop="8dp">
+
+            <EditText
+                android:id="@+id/input_username"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:hint="Username"
+                android:inputType="text"/>
+        </android.support.design.widget.TextInputLayout>
+
+        <android.support.design.widget.TextInputLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginBottom="8dp"
+            android:layout_marginTop="8dp">
+
+            <EditText
+                android:id="@+id/input_password"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:hint="Password"
+                android:inputType="textPassword"/>
+        </android.support.design.widget.TextInputLayout>
+
+        <android.support.v7.widget.AppCompatButton
+            android:id="@+id/button_login"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginBottom="12dp"
+            android:layout_marginTop="24dp"
+            android:padding="12dp"
+            android:text="Login" />
+
+        <android.support.v7.widget.AppCompatButton
+            android:id="@+id/button_create"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginBottom="24dp"
+            android:padding="12dp"
+            android:text="Create account and login" />
+    </LinearLayout>
+</ScrollView>
\ No newline at end of file
diff --git a/examples/objectServerExample/src/main/res/menu/menu_counter.xml b/examples/objectServerExample/src/main/res/menu/menu_counter.xml
new file mode 100644
index 0000000000..858fd2e7e8
--- /dev/null
+++ b/examples/objectServerExample/src/main/res/menu/menu_counter.xml
@@ -0,0 +1,11 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+      xmlns:app="http://schemas.android.com/apk/res-auto"
+      xmlns:tools="http://schemas.android.com/tools"
+      tools:context=".CounterActivity">
+    <item
+        android:id="@+id/action_logout"
+        android:orderInCategory="100"
+        android:title="Logout"
+        android:icon="@drawable/ic_exit_to_app_white_24dp"
+        app:showAsAction="always"/>
+</menu>
diff --git a/examples/objectServerExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/objectServerExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/objectServerExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/objectServerExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/objectServerExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/objectServerExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/objectServerExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/objectServerExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/objectServerExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/objectServerExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/objectServerExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/objectServerExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/threadExample/src/main/res/values-w820dp/dimens.xml b/examples/objectServerExample/src/main/res/values-w820dp/dimens.xml
similarity index 100%
rename from examples/threadExample/src/main/res/values-w820dp/dimens.xml
rename to examples/objectServerExample/src/main/res/values-w820dp/dimens.xml
diff --git a/examples/objectServerExample/src/main/res/values/dimens.xml b/examples/objectServerExample/src/main/res/values/dimens.xml
new file mode 100644
index 0000000000..47c8224673
--- /dev/null
+++ b/examples/objectServerExample/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/examples/objectServerExample/src/main/res/values/realm_colors.xml b/examples/objectServerExample/src/main/res/values/realm_colors.xml
new file mode 100644
index 0000000000..aada8ea195
--- /dev/null
+++ b/examples/objectServerExample/src/main/res/values/realm_colors.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    // Grays
+    <color name="charcoal">#1C233F</color>
+    <color name="elephant">#9A9BA5</color>
+    <color name="elephant_half">#b1b3bf</color>
+    <color name="dove">#EBEBF2</color>
+
+    // Orb colors
+    <color name="ultramarine">#39477F</color>
+    <color name="indigo">#59569E</color>
+    <color name="grape_jelly">#9A59A5</color>
+    <color name="mulberry">#D34CA3</color>
+    <color name="flamingo">#F25192</color>
+    <color name="sexy_salmon">#F77C88</color>
+    <color name="peach">#FC9F95</color>
+    <color name="melon">#FCC397</color>
+
+    // Material adjustments
+    <color name="flamingo_darker">#d64881</color>
+    <color name="touch_area_pressed">#dadada</color>
+
+</resources>
\ No newline at end of file
diff --git a/examples/objectServerExample/src/main/res/values/strings.xml b/examples/objectServerExample/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..10e43bd0a9
--- /dev/null
+++ b/examples/objectServerExample/src/main/res/values/strings.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">Object Server Example</string>
+</resources>
diff --git a/examples/objectServerExample/src/main/res/values/styles.xml b/examples/objectServerExample/src/main/res/values/styles.xml
new file mode 100644
index 0000000000..333a4944af
--- /dev/null
+++ b/examples/objectServerExample/src/main/res/values/styles.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
+        <item name="colorPrimary">@color/flamingo</item>
+        <item name="colorPrimaryDark">@color/flamingo_darker</item>
+        <item name="colorAccent">@color/ultramarine</item>
+    </style>
+</resources>
+
diff --git a/examples/rxJavaExample/lint.xml b/examples/rxJavaExample/lint.xml
index cc4d461aee..7d530f741e 100644
--- a/examples/rxJavaExample/lint.xml
+++ b/examples/rxJavaExample/lint.xml
@@ -5,4 +5,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java
index 15a792100c..6a5c27991b 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java
@@ -75,7 +75,7 @@ protected void onResume() {
                     @Override
                     public Boolean call(RealmResults<Person> persons) {
                         // Only continue once data is actually loaded
-                        // RealmObservables will emit the unloaded (empty) list as it's first item
+                        // RealmObservables will emit the unloaded (empty) list as its first item
                         return persons.isLoaded();
                     }
                 })
diff --git a/examples/secureTokenAndroidKeyStore/build.gradle b/examples/secureTokenAndroidKeyStore/build.gradle
new file mode 100644
index 0000000000..7222838bea
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/build.gradle
@@ -0,0 +1,38 @@
+apply plugin: 'com.android.application'
+apply plugin: 'realm-android'
+
+android {
+    compileSdkVersion 24
+    buildToolsVersion "24.0.0"
+
+    defaultConfig {
+        applicationId "io.realm.examples.securetokenandroidkeystore"
+        minSdkVersion 9
+        targetSdkVersion 24
+        versionCode 1
+        versionName "1.0"
+
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
+        exclude group: 'com.android.support', module: 'support-annotations'
+    })
+    compile 'com.android.support:appcompat-v7:24.2.0'
+    testCompile 'junit:junit:4.12'
+    compile 'io.realm:android-secure-userstore:1.0.0'
+}
+
+realm {
+    syncEnabled = true
+}
\ No newline at end of file
diff --git a/examples/secureTokenAndroidKeyStore/lint.xml b/examples/secureTokenAndroidKeyStore/lint.xml
new file mode 100644
index 0000000000..5f242796c5
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/lint.xml
@@ -0,0 +1,5 @@
+<lint>
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+</lint>
diff --git a/examples/secureTokenAndroidKeyStore/proguard-rules.pro b/examples/secureTokenAndroidKeyStore/proguard-rules.pro
new file mode 100644
index 0000000000..740907a636
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Users/Nabil/Library/Android/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/examples/secureTokenAndroidKeyStore/src/main/AndroidManifest.xml b/examples/secureTokenAndroidKeyStore/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..15f02a70aa
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/src/main/AndroidManifest.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.example.securetokenandroidkeystore">
+
+    <application android:allowBackup="true" android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"
+        android:name="examples.io.realm.securetokenandroidkeystore.MyApplication">
+        <activity android:name="examples.io.realm.securetokenandroidkeystore.MainActivity">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+</manifest>
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/layout/activity_main.xml b/examples/secureTokenAndroidKeyStore/src/main/res/layout/activity_main.xml
new file mode 100644
index 0000000000..eff5fd5e7b
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/src/main/res/layout/activity_main.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:tools="http://schemas.android.com/tools"
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_height="match_parent"
+    android:layout_width="match_parent"
+    android:orientation="horizontal"
+    android:gravity="center">
+
+    <TextView
+        android:id="@+id/txtLabelKeyStore"
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+        android:text="@string/locked_text"
+        android:background="@color/colorLocked"
+        android:textSize="18sp"/>
+
+</RelativeLayout>
+
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/values/colors.xml b/examples/secureTokenAndroidKeyStore/src/main/res/values/colors.xml
new file mode 100644
index 0000000000..59411e9175
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/src/main/res/values/colors.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <color name="colorPrimary">#3F51B5</color>
+    <color name="colorPrimaryDark">#303F9F</color>
+    <color name="colorAccent">#FF4081</color>
+    <color name="colorActivated">#00CC00</color>
+    <color name="colorLocked">#CC0000</color>
+</resources>
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/values/strings.xml b/examples/secureTokenAndroidKeyStore/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..d028dcda8a
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/src/main/res/values/strings.xml
@@ -0,0 +1,5 @@
+<resources>
+    <string name="app_name">secureTokenAndroidKeyStore</string>
+    <string name="locked_text">Key Store Locked/Uninitialised:\nYou can not encrypt the Token</string>
+    <string name="unlocked_text">Key Store Unlocked:\nYou can encrypt the Token</string>
+</resources>
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/values/styles.xml b/examples/secureTokenAndroidKeyStore/src/main/res/values/styles.xml
new file mode 100644
index 0000000000..daa2a5c2f0
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/src/main/res/values/styles.xml
@@ -0,0 +1,11 @@
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="Theme.AppCompat">
+        <!-- Customize your theme here. -->
+        <item name="colorPrimary">@color/colorPrimary</item>
+        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
+        <item name="colorAccent">@color/colorAccent</item>
+    </style>
+
+</resources>
diff --git a/examples/settings.gradle b/examples/settings.gradle
index 9b18f1e779..0f9f5242bd 100644
--- a/examples/settings.gradle
+++ b/examples/settings.gradle
@@ -1,3 +1,4 @@
+include 'secureTokenAndroidKeyStore'
 include 'encryptionExample'
 include 'gridViewExample'
 include 'introExample'
@@ -11,6 +12,7 @@ include 'threadExample'
 include 'unitTestExample'
 include 'newsreaderExample'
 include 'rxJavaExample'
+include 'objectServerExample'
 
 rootProject.name = 'realm-examples'
 
diff --git a/examples/threadExample/lint.xml b/examples/threadExample/lint.xml
index 3af2534ba6..6a9810cdcb 100644
--- a/examples/threadExample/lint.xml
+++ b/examples/threadExample/lint.xml
@@ -6,4 +6,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
index c64cf21644..566bd07ef3 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
@@ -100,10 +100,9 @@ public void onActivityCreated(Bundle savedInstanceState) {
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-                person = realm.createObject(Person.class);
+                person = realm.createObject(Person.class, UUID.randomUUID().toString());
                 person.setName("Jane");
                 person.setAge(42);
-                person.setId(UUID.randomUUID().toString());
             }
         });
         textContent.setText(person.toString());
diff --git a/examples/unitTestExample/lint.xml b/examples/unitTestExample/lint.xml
index 1d3dbb0011..1f5e37cb86 100644
--- a/examples/unitTestExample/lint.xml
+++ b/examples/unitTestExample/lint.xml
@@ -4,4 +4,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
index c380633bd0..97b51b752d 100644
--- a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -176,6 +177,7 @@ public void setup() throws Exception {
     }
 
 
+    @Ignore("FIXME: Some problems mocking OKHttp")
     @Test
     public void shouldBeAbleToAccessActivityAndVerifyRealmInteractions() {
         doCallRealMethod().when(mockRealm).executeTransaction(Mockito.any(Realm.Transaction.class));
@@ -221,6 +223,7 @@ public void shouldBeAbleToAccessActivityAndVerifyRealmInteractions() {
      * Have to verify the transaction execution in a different test because
      * of a problem with Powermock: https://github.com/jayway/powermock/issues/649
      */
+    @Ignore("FIXME: Some problems mocking OKHttp")
     @Test
     public void shouldBeAbleToVerifyTransactionCalls() {
 
diff --git a/gradle-plugin/build.gradle b/gradle-plugin/build.gradle
index 2bcb843bee..945728116b 100644
--- a/gradle-plugin/build.gradle
+++ b/gradle-plugin/build.gradle
@@ -17,7 +17,7 @@ apply plugin: 'com.jfrog.bintray'
 def props = new Properties()
 props.load(new FileInputStream("${rootDir}/../realm.properties"))
 props.each { key, val ->
-    project.set(key, val)
+    project.ext.set(key, val)
 }
 
 repositories {
@@ -112,6 +112,19 @@ publishing {
             }
         }
     }
+    repositories {
+        maven {
+            credentials(AwsCredentials) {
+                accessKey project.hasProperty('s3AccessKey') ? s3AccessKey : 'noAccessKey'
+                secretKey project.hasProperty('s3SecretKey') ? s3SecretKey : 'noSecretKey'
+            }
+            if(project.version.endsWith('-SNAPSHOT')) {
+                url "s3://realm-ci-artifacts/maven/snapshots/"
+            } else {
+                url "s3://realm-ci-artifacts/maven/releases/"
+            }
+        }
+    }
 }
 
 bintray {
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar
index b761216703..3baa851b28 100644
Binary files a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar and b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
index f71002edb7..4912622457 100644
--- a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Jan 05 14:18:17 CET 2016
+#Tue Sep 20 14:21:04 CST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
diff --git a/gradle-plugin/gradlew b/gradle-plugin/gradlew
index 91a7e269e1..27309d9231 100755
--- a/gradle-plugin/gradlew
+++ b/gradle-plugin/gradlew
@@ -6,12 +6,30 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,31 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -90,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
@@ -114,6 +113,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
diff --git a/gradle-plugin/gradlew.bat b/gradle-plugin/gradlew.bat
index aec99730b4..f6d5974e72 100644
--- a/gradle-plugin/gradlew.bat
+++ b/gradle-plugin/gradlew.bat
@@ -8,14 +8,14 @@
 @rem Set local scope for the variables with windows NT shell
 if "%OS%"=="Windows_NT" setlocal
 
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
 set DIRNAME=%~dp0
 if "%DIRNAME%" == "" set DIRNAME=.
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
@@ -46,7 +46,7 @@ echo location of your Java installation.
 goto fail
 
 :init
-@rem Get command-line arguments, handling Windowz variants
+@rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
 if "%@eval[2+2]" == "4" goto 4NT_args
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
index c533258ce2..f3557026e5 100644
--- a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
@@ -23,6 +23,8 @@ import io.realm.transformer.RealmTransformer
 import org.gradle.api.GradleException
 import org.gradle.api.Plugin
 import org.gradle.api.Project
+import org.gradle.api.artifacts.DependencyResolutionListener
+import org.gradle.api.artifacts.ResolvableDependencies
 
 class Realm implements Plugin<Project> {
 
@@ -39,6 +41,9 @@ class Realm implements Plugin<Project> {
             throw new GradleException('Realm gradle plugin only supports android gradle plugin 1.5.0 or later.')
         }
 
+        def syncEnabledDefault = false
+        project.extensions.create('realm', RealmPluginExtension, project, syncEnabledDefault)
+
         def usesKotlinPlugin = project.plugins.findPlugin('kotlin-android') != null
         def usesAptPlugin = project.plugins.findPlugin('com.neenbedankt.android-apt') != null
 
@@ -49,8 +54,8 @@ class Realm implements Plugin<Project> {
         }
 
         project.android.registerTransform(new RealmTransformer(project))
+
         project.repositories.add(project.getRepositories().jcenter())
-        project.dependencies.add("compile", "io.realm:realm-android-library:${Version.VERSION}")
         project.dependencies.add("compile", "io.realm:realm-annotations:${Version.VERSION}")
         if (isKaptProject) {
             project.dependencies.add("kapt", "io.realm:realm-annotations:${Version.VERSION}")
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy
new file mode 100644
index 0000000000..ac2fc4012a
--- /dev/null
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.gradle
+
+import org.gradle.api.Project
+
+class RealmPluginExtension {
+    private Project project
+    def boolean syncEnabled
+
+    RealmPluginExtension(Project project, boolean syncEnabledDefault) {
+        this.project = project
+        setSyncEnabled(syncEnabledDefault)
+    }
+
+    void setSyncEnabled(value) {
+        this.syncEnabled = value;
+
+        // remove realm android library first
+        def iterator = project.getConfigurations().getByName("compile").getDependencies().iterator();
+        while (iterator.hasNext()) {
+            def item = iterator.next()
+            if (item.group == 'io.realm' && item.name.startsWith('realm-android-library')) {
+                iterator.remove()
+            }
+        }
+
+        // then add again
+        def artifactName = "realm-android-library${syncEnabled ? '-object-server' : ''}"
+        project.dependencies.add("compile", "io.realm:${artifactName}:${Version.VERSION}")
+    }
+}
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index e8c6bf7bb4..3baa851b28 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index f71002edb7..bc6b7c4622 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Jan 05 14:18:17 CET 2016
+#Tue Sep 20 14:03:29 CST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
diff --git a/gradlew b/gradlew
index 97fac783e1..27309d9231 100755
--- a/gradlew
+++ b/gradlew
@@ -6,12 +6,30 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,26 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -85,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
diff --git a/gradlew.bat b/gradlew.bat
index aec99730b4..f6d5974e72 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -8,14 +8,14 @@
 @rem Set local scope for the variables with windows NT shell
 if "%OS%"=="Windows_NT" setlocal
 
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
 set DIRNAME=%~dp0
 if "%DIRNAME%" == "" set DIRNAME=.
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
@@ -46,7 +46,7 @@ echo location of your Java installation.
 goto fail
 
 :init
-@rem Get command-line arguments, handling Windowz variants
+@rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
 if "%@eval[2+2]" == "4" goto 4NT_args
diff --git a/realm-annotations/build.gradle b/realm-annotations/build.gradle
index 5fd63be38b..a372797de3 100644
--- a/realm-annotations/build.gradle
+++ b/realm-annotations/build.gradle
@@ -54,6 +54,19 @@ publishing {
             }
         }
     }
+    repositories {
+        maven {
+            credentials(AwsCredentials) {
+                accessKey project.hasProperty('s3AccessKey') ? s3AccessKey : 'noAccessKey'
+                secretKey project.hasProperty('s3SecretKey') ? s3SecretKey : 'noSecretKey'
+            }
+            if(project.version.endsWith('-SNAPSHOT')) {
+                url "s3://realm-ci-artifacts/maven/snapshots/"
+            } else {
+                url "s3://realm-ci-artifacts/maven/releases/"
+            }
+        }
+    }
 }
 
 bintray {
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.jar b/realm-annotations/gradle/wrapper/gradle-wrapper.jar
index e8c6bf7bb4..3baa851b28 100644
Binary files a/realm-annotations/gradle/wrapper/gradle-wrapper.jar and b/realm-annotations/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.properties b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
index f71002edb7..a18e4af3f9 100644
--- a/realm-annotations/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Jan 05 14:18:17 CET 2016
+#Tue Sep 20 14:22:29 CST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
diff --git a/realm-annotations/gradlew b/realm-annotations/gradlew
index 97fac783e1..27309d9231 100755
--- a/realm-annotations/gradlew
+++ b/realm-annotations/gradlew
@@ -6,12 +6,30 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,26 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -85,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
diff --git a/realm-annotations/gradlew.bat b/realm-annotations/gradlew.bat
index 8a0b282aa6..f6d5974e72 100644
--- a/realm-annotations/gradlew.bat
+++ b/realm-annotations/gradlew.bat
@@ -1,90 +1,90 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windowz variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/realm-annotations/src/main/java/io/realm/annotations/Beta.java b/realm-annotations/src/main/java/io/realm/annotations/Beta.java
new file mode 100644
index 0000000000..f35dd4da23
--- /dev/null
+++ b/realm-annotations/src/main/java/io/realm/annotations/Beta.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation is added to classes, constructors or methods which are considered in beta phase.
+ * It indicates that any public interface can change without prior announcements.
+ * Moreover, classes, constructors, and methods annotated as beta are not considered at production
+ * quality, and should be used with care.
+ */
+@Retention(RetentionPolicy.SOURCE)
+@Target({ElementType.TYPE, ElementType.CONSTRUCTOR, ElementType.METHOD})
+public @interface Beta {
+}
diff --git a/realm-transformer/build.gradle b/realm-transformer/build.gradle
index 5b98178bea..2dc0dadb96 100644
--- a/realm-transformer/build.gradle
+++ b/realm-transformer/build.gradle
@@ -18,6 +18,11 @@ apply plugin: 'com.jfrog.bintray'
 group = 'io.realm'
 version = file("${projectDir}/../version.txt").text.trim();
 
+def properties = new Properties()
+properties.load(new FileInputStream("${projectDir}/../dependencies.list"))
+
+def syncVersion = properties.getProperty('REALM_SYNC_VERSION')
+
 sourceCompatibility = '1.6'
 targetCompatibility = '1.6'
 
@@ -59,7 +64,7 @@ import org.apache.tools.ant.filters.ReplaceTokens
 task generateVersionClass(type: Copy) {
     from 'src/main/templates/Version.java'
     into 'build/generated-src/main/java/io/realm/transformer'
-    filter(ReplaceTokens, tokens: [version: version])
+    filter(ReplaceTokens, tokens: [version: version, syncVersion: syncVersion])
     outputs.upToDateWhen { false }
 }
 
@@ -99,6 +104,19 @@ publishing {
             }
         }
     }
+    repositories {
+        maven {
+            credentials(AwsCredentials) {
+                accessKey project.hasProperty('s3AccessKey') ? s3AccessKey : 'noAccessKey'
+                secretKey project.hasProperty('s3SecretKey') ? s3SecretKey : 'noSecretKey'
+            }
+            if(project.version.endsWith('-SNAPSHOT')) {
+                url "s3://realm-ci-artifacts/maven/snapshots/"
+            } else {
+                url "s3://realm-ci-artifacts/maven/releases/"
+            }
+        }
+    }
 }
 
 bintray {
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.jar b/realm-transformer/gradle/wrapper/gradle-wrapper.jar
index e8c6bf7bb4..3baa851b28 100644
Binary files a/realm-transformer/gradle/wrapper/gradle-wrapper.jar and b/realm-transformer/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.properties b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
index f71002edb7..e9bd4ba64f 100644
--- a/realm-transformer/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Jan 05 14:18:17 CET 2016
+#Tue Sep 20 14:33:05 CST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
diff --git a/realm-transformer/gradlew b/realm-transformer/gradlew
index 97fac783e1..27309d9231 100755
--- a/realm-transformer/gradlew
+++ b/realm-transformer/gradlew
@@ -6,12 +6,30 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,26 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -85,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
diff --git a/realm-transformer/gradlew.bat b/realm-transformer/gradlew.bat
index 8a0b282aa6..f6d5974e72 100644
--- a/realm-transformer/gradlew.bat
+++ b/realm-transformer/gradlew.bat
@@ -1,90 +1,90 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windowz variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
index ce1fc39801..82f3ac292b 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
@@ -37,14 +37,14 @@ class BytecodeModifier {
      * @param clazz the CtClass to add accessors to.
      */
     public static void addRealmAccessors(CtClass clazz) {
-        logger.info "  Realm: Adding accessors to ${clazz.simpleName}"
+        logger.debug "  Realm: Adding accessors to ${clazz.simpleName}"
         def methods = clazz.getDeclaredMethods()*.name
         clazz.declaredFields.each { CtField field ->
             if (!Modifier.isStatic(field.getModifiers()) && !field.hasAnnotation(Ignore.class)) {
-                if (!methods.contains("realmGet\$${field.name}")) {
+                if (!methods.contains("realmGet\$${field.name}".toString())) {
                     clazz.addMethod(CtNewMethod.getter("realmGet\$${field.name}", field))
                 }
-                if (!methods.contains("realmSet\$${field.name}")) {
+                if (!methods.contains("realmSet\$${field.name}".toString())) {
                     clazz.addMethod(CtNewMethod.setter("realmSet\$${field.name}", field))
                 }
             }
@@ -59,7 +59,7 @@ class BytecodeModifier {
      */
     public static void useRealmAccessors(CtClass clazz, List<CtField> managedFields) {
         clazz.getDeclaredBehaviors().each { behavior ->
-            logger.info "    Behavior: ${behavior.name}"
+            logger.debug "    Behavior: ${behavior.name}"
             if (
                 (
                     behavior instanceof CtMethod &&
@@ -104,13 +104,13 @@ class BytecodeModifier {
 
         @Override
         void edit(FieldAccess fieldAccess) throws CannotCompileException {
-            logger.info "      Field being accessed: ${fieldAccess.className}.${fieldAccess.fieldName}"
+            logger.debug "      Field being accessed: ${fieldAccess.className}.${fieldAccess.fieldName}"
             def isRealmFieldAccess = managedFields.find {
                 fieldAccess.className.equals(it.declaringClass.name) && fieldAccess.fieldName.equals(it.name)
             }
             if (isRealmFieldAccess != null) {
-                logger.info "        Realm: Manipulating ${ctClass.simpleName}.${behavior.name}(): ${fieldAccess.fieldName}"
-                logger.info "        Methods: ${ctClass.declaredMethods}"
+                logger.debug "        Realm: Manipulating ${ctClass.simpleName}.${behavior.name}(): ${fieldAccess.fieldName}"
+                logger.debug "        Methods: ${ctClass.declaredMethods}"
                 def fieldName = fieldAccess.fieldName
                 if (fieldAccess.isReader()) {
                     fieldAccess.replace('$_ = $0.realmGet$' + fieldName + '();')
@@ -127,7 +127,7 @@ class BytecodeModifier {
      * @param clazz The CtClass to modify.
      */
     public static void overrideTransformedMarker(CtClass clazz) {
-        logger.info "  Realm: Marking as transformed ${clazz.simpleName}"
+        logger.debug "  Realm: Marking as transformed ${clazz.simpleName}"
         try {
             clazz.getDeclaredMethod("transformerApplied", new CtClass[0])
         } catch (NotFoundException ignored) {
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
index ba85db84ab..857cd304b2 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
@@ -94,7 +94,7 @@ class RealmTransformer extends Transform {
         // javassist. See https://github.com/realm/realm-java/issues/2703.
         addBootClassesToClassPool(classPool)
 
-        logger.info "ClassPool contains Realm classes: ${classPool.getOrNull('io.realm.RealmList') != null}"
+        logger.debug "ClassPool contains Realm classes: ${classPool.getOrNull('io.realm.RealmList') != null}"
 
         // mark as transformed
         def baseProxyMediator = classPool.get('io.realm.internal.RealmProxyMediator')
@@ -103,7 +103,7 @@ class RealmTransformer extends Transform {
                 .findAll { it.matches(mediatorPattern) }
                 .collect { classPool.getCtClass(it) }
                 .findAll { it.superclass?.equals(baseProxyMediator) }
-        logger.info "Proxy Mediator Classes: ${proxyMediatorClasses*.name}"
+        logger.debug "Proxy Mediator Classes: ${proxyMediatorClasses*.name}"
         proxyMediatorClasses.each {
             BytecodeModifier.overrideTransformedMarker(it);
         }
@@ -116,7 +116,7 @@ class RealmTransformer extends Transform {
         def inputModelClasses = allModelClasses.findAll {
             inputClassNames.contains(it.name)
         }
-        logger.info "Model Classes: ${allModelClasses*.name}"
+        logger.debug "Model Classes: ${allModelClasses*.name}"
 
         // Populate a list of the fields that need to be managed with bytecode manipulation
         def allManagedFields = []
@@ -125,7 +125,7 @@ class RealmTransformer extends Transform {
                 !it.hasAnnotation(Ignore.class) && !Modifier.isStatic(it.getModifiers())
             })
         }
-        logger.info "Managed Fields: ${allManagedFields*.name}"
+        logger.debug "Managed Fields: ${allManagedFields*.name}"
 
         // Add accessors to the model classes in the target project
         inputModelClasses.each {
@@ -135,7 +135,7 @@ class RealmTransformer extends Transform {
 
         // Use accessors instead of direct field access
         inputClassNames.each {
-            logger.info "  Modifying class ${it}"
+            logger.debug "  Modifying class ${it}"
             def ctClass = classPool.getCtClass(it)
             BytecodeModifier.useRealmAccessors(ctClass, allManagedFields)
             ctClass.writeFile(getOutputFile(outputProvider).canonicalPath)
@@ -144,9 +144,9 @@ class RealmTransformer extends Transform {
         copyResourceFiles(inputs, outputProvider)
 
         def toc = System.currentTimeMillis()
-        logger.info "Realm Transform time: ${toc-tic} milliseconds"
+        logger.debug "Realm Transform time: ${toc-tic} milliseconds"
 
-        sendAnalytics(inputs, inputModelClasses)
+        this.sendAnalytics(inputs, inputModelClasses)
     }
 
     /**
@@ -154,7 +154,7 @@ class RealmTransformer extends Transform {
      * @param inputs the inputs provided by the Transform API
      * @param inputModelClasses a list of ctClasses describing the Realm models
      */
-    private static sendAnalytics(Collection<TransformInput> inputs, List<CtClass> inputModelClasses) {
+    private sendAnalytics(Collection<TransformInput> inputs, List<CtClass> inputModelClasses) {
         def containsKotlin = false
         inputs.each {
             it.directoryInputs.each {
@@ -177,7 +177,8 @@ class RealmTransformer extends Transform {
         def env = System.getenv()
         def disableAnalytics = env["REALM_DISABLE_ANALYTICS"]
         if (disableAnalytics == null || disableAnalytics != "true") {
-            def analytics = RealmAnalytics.getInstance(packages as Set, containsKotlin)
+            boolean sync = project?.realm?.syncEnabled != null && project.realm.syncEnabled
+            def analytics = new RealmAnalytics(packages as Set, containsKotlin, sync)
             analytics.execute()
         }
     }
@@ -246,7 +247,7 @@ class RealmTransformer extends Transform {
                     // The jar might not using File.separatorChar as the path separator. So we just replace both `\` and
                     // `/`. It depends on how the jar file was created.
                     // See http://stackoverflow.com/questions/13846000/file-separators-of-path-name-of-zipentry
-                    def className = path.substring(0, path.length() - SdkConstants.DOT_CLASS.length())
+                    String className = path.substring(0, path.length() - SdkConstants.DOT_CLASS.length())
                             .replace('/' as char , '.' as char)
                             .replace('\\' as char , '.' as char)
                     classNames.add(className)
@@ -262,7 +263,7 @@ class RealmTransformer extends Transform {
                 def dirPath = it.file.absolutePath
                 it.file.eachFileRecurse(FileType.FILES) {
                     if (!it.absolutePath.endsWith(SdkConstants.DOT_CLASS)) {
-                        logger.info "  Copying resource ${it}"
+                        logger.debug "  Copying resource ${it}"
                         def dest = new File(getOutputFile(outputProvider),
                                 it.absolutePath.substring(dirPath.length()))
                         dest.parentFile.mkdirs()
@@ -293,13 +294,13 @@ class RealmTransformer extends Transform {
         try {
             project.android.bootClasspath.each {
                 String path = it.absolutePath
-                logger.info "Add boot class " + path + " to class pool."
+                logger.debug "Add boot class " + path + " to class pool."
                 classPool.appendClassPath(path)
             }
         } catch (Exception e) {
             // Just log it. It might not impact the transforming if the method which needs to be transformer doesn't
             // contain classes from android.jar.
-            logger.info("Cannot get bootClasspath caused by:", e)
+            logger.debug("Cannot get bootClasspath caused by:", e)
         }
     }
 }
diff --git a/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java b/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
index bd1709453b..18dd7b827b 100644
--- a/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
+++ b/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
@@ -19,11 +19,9 @@
 import java.io.UnsupportedEncodingException;
 import java.net.HttpURLConnection;
 import java.net.MalformedURLException;
-import java.net.NetworkInterface;
 import java.net.SocketException;
 import java.net.URL;
 import java.security.NoSuchAlgorithmException;
-import java.util.Enumeration;
 import java.util.Set;
 
 // Asynchronously submits build information to Realm when the annotation
@@ -69,6 +67,7 @@
             + "      \"Anonymized Bundle ID\": \"%APP_ID%\",\n"
             + "      \"Binding\": \"java\",\n"
             + "      \"Language\": \"%LANGUAGE%\",\n"
+            + "      \"Sync Version\": %SYNC_VERSION%,\n"
             + "      \"Realm Version\": \"%REALM_VERSION%\",\n"
             + "      \"Host OS Type\": \"%OS_TYPE%\",\n"
             + "      \"Host OS Version\": \"%OS_VERSION%\",\n"
@@ -80,17 +79,12 @@
     private Set<String> packages;
 
     private boolean usesKotlin;
+    private boolean usesSync;
 
-    private RealmAnalytics(Set<String> packages, boolean usesKotlin) {
+    public RealmAnalytics(Set<String> packages, boolean usesKotlin, boolean usesSync) {
         this.packages = packages;
         this.usesKotlin = usesKotlin;
-    }
-
-    public static RealmAnalytics getInstance(Set<String> packages, boolean usesKotlin) {
-        if (instance == null) {
-            instance = new RealmAnalytics(packages, usesKotlin);
-        }
-        return instance;
+        this.usesSync = usesSync;
     }
 
     private void send() {
@@ -135,7 +129,8 @@ public String generateJson() throws SocketException, NoSuchAlgorithmException {
                 .replaceAll("%TOKEN%", TOKEN)
                 .replaceAll("%USER_ID%", ComputerIdentifierGenerator.get())
                 .replaceAll("%APP_ID%", getAnonymousAppId())
-                .replaceAll("%LANGUAGE%", usesKotlin?"kotlin":"java")
+                .replaceAll("%LANGUAGE%", usesKotlin ? "kotlin" : "java")
+                .replaceAll("%SYNC_VERSION%", usesSync ? "\"" + Version.SYNC_VERSION + "\"": "null")
                 .replaceAll("%REALM_VERSION%", Version.VERSION)
                 .replaceAll("%OS_TYPE%", System.getProperty("os.name"))
                 .replaceAll("%OS_VERSION%", System.getProperty("os.version"));
diff --git a/realm-transformer/src/main/templates/Version.java b/realm-transformer/src/main/templates/Version.java
index e1d6208e55..9239f52d3e 100644
--- a/realm-transformer/src/main/templates/Version.java
+++ b/realm-transformer/src/main/templates/Version.java
@@ -2,4 +2,5 @@
 
 public class Version {
     public static final String VERSION = "@version@";
+    public static final String SYNC_VERSION = "@syncVersion@";
 }
diff --git a/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy b/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
index 6a8b6ee34d..495289af6d 100644
--- a/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
+++ b/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
@@ -52,6 +52,68 @@ class BytecodeModifierTest extends Specification {
         }
     }
 
+    // https://github.com/realm/realm-java/issues/3469
+    def "AddRealmAccessors_duplicateSetter"() {
+        setup: 'generate an empty class'
+        def classPool = ClassPool.getDefault()
+        def ctClass = classPool.makeClass('testClass')
+
+        and: 'add a field'
+        def ctField = new CtField(CtClass.intType, 'age', ctClass)
+        ctClass.addField(ctField)
+
+        and: 'add a setter'
+        def setter = CtNewMethod.setter('realmSet$age', ctField)
+        ctClass.addMethod(setter)
+
+        when: 'addRealmAccessors is called'
+        BytecodeModifier.addRealmAccessors(ctClass)
+
+        then: 'a getter for the field is generated'
+        def ctMethods = ctClass.getDeclaredMethods()
+        def methodNames = ctMethods.name
+        methodNames.contains('realmGet$age')
+
+        and: 'the setter is not changed'
+        ctMethods.find {it.name.equals('realmSet$age')} == setter
+
+        and: 'the accessors are public'
+        ctMethods.each {
+            it.getModifiers() == Modifier.PUBLIC
+        }
+    }
+
+    // https://github.com/realm/realm-java/issues/3469
+    def "AddRealmAccessors_duplicateGetter"() {
+        setup: 'generate an empty class'
+        def classPool = ClassPool.getDefault()
+        def ctClass = classPool.makeClass('testClass')
+
+        and: 'add a field'
+        def ctField = new CtField(CtClass.intType, 'age', ctClass)
+        ctClass.addField(ctField)
+
+        and: 'add a getter'
+        def getter = CtNewMethod.getter('realmGet$age', ctField)
+        ctClass.addMethod(getter)
+
+        when: 'addRealmAccessors is called'
+        BytecodeModifier.addRealmAccessors(ctClass)
+
+        then: 'a setter for the field is generated'
+        def ctMethods = ctClass.getDeclaredMethods()
+        def methodNames = ctMethods.name
+        methodNames.contains('realmSet$age')
+
+        and: 'the getter is not changed'
+        ctMethods.find {it.name.equals('realmGet$age')} == getter
+
+        and: 'the accessors are public'
+        ctMethods.each {
+            it.getModifiers() == Modifier.PUBLIC
+        }
+    }
+
     def "AddRealmAccessors_IgnoreAnnotation"() {
         setup: 'generate an empty class'
         def classPool = ClassPool.getDefault()
diff --git a/realm/build.gradle b/realm/build.gradle
index 429b20fbe0..02d42b21b4 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -9,12 +9,12 @@ buildscript {
         classpath 'com.android.tools.build:gradle:2.2.0'
         classpath 'de.undercouch:gradle-download-task:3.1.1'
         classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
-        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1'
+        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5'
         classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
         classpath 'com.github.skhatri:gradle-s3-plugin:1.0.2'
         classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.4.0'
-        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.0.1'
-        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
+        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.4.5'
+        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7'
         classpath "io.realm:realm-transformer:${file('../version.txt').text.trim()}"
     }
 }
@@ -23,7 +23,7 @@ allprojects {
     def props = new Properties()
     props.load(new FileInputStream("${rootDir}/../realm.properties"))
     props.each { key, val ->
-        project.set(key, val)
+        project.ext.set(key, val)
     }
 
     group = 'io.realm'
diff --git a/realm/config/findbugs/findbugs-filter.xml b/realm/config/findbugs/findbugs-filter.xml
index b6503d5337..e2c1a8b2e1 100644
--- a/realm/config/findbugs/findbugs-filter.xml
+++ b/realm/config/findbugs/findbugs-filter.xml
@@ -27,6 +27,16 @@
         <Field name="minDepth" />
         <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD" />
     </Match>
+    <Match>
+        <Class name="io.realm.SyncManager" />
+        <Field name="APP_ID" />
+        <Bug pattern="MS_SHOULD_BE_FINAL" />
+    </Match>
+    <Match>
+        <Class name="io.realm.SyncManager" />
+        <Field name="APP_ID" />
+        <Bug pattern="MS_CANNOT_BE_FINAL" />
+    </Match>
 
     <!-- Unit tests -->
     <Match>
diff --git a/realm/config/pmd/ruleset.xml b/realm/config/pmd/ruleset.xml
index a3596aa24e..c777aa8319 100644
--- a/realm/config/pmd/ruleset.xml
+++ b/realm/config/pmd/ruleset.xml
@@ -8,10 +8,6 @@
         Realm PMD ruleset
     </description>
 
-    <rule ref="rulesets/java/basic.xml">
-        <exclude name="UselessParentheses"/>
-    </rule>
-
     <rule ref="rulesets/java/android.xml"/>
 
-</ruleset>
\ No newline at end of file
+</ruleset>
diff --git a/realm/gradle.properties b/realm/gradle.properties
index 033fd72f9a..f3f16fcaac 100644
--- a/realm/gradle.properties
+++ b/realm/gradle.properties
@@ -1 +1 @@
-org.gradle.jvmargs=-Xms256m -Xmx2048m
+org.gradle.jvmargs=-Xms512m -Xmx2048m
diff --git a/realm/gradle/wrapper/gradle-wrapper.jar b/realm/gradle/wrapper/gradle-wrapper.jar
index e8c6bf7bb4..3baa851b28 100644
Binary files a/realm/gradle/wrapper/gradle-wrapper.jar and b/realm/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm/gradle/wrapper/gradle-wrapper.properties b/realm/gradle/wrapper/gradle-wrapper.properties
index f71002edb7..897f3bf902 100644
--- a/realm/gradle/wrapper/gradle-wrapper.properties
+++ b/realm/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Jan 05 14:18:17 CET 2016
+#Tue Sep 20 14:03:59 CST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
diff --git a/realm/gradlew b/realm/gradlew
index 97fac783e1..27309d9231 100755
--- a/realm/gradlew
+++ b/realm/gradlew
@@ -6,12 +6,30 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,26 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -85,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
diff --git a/realm/gradlew.bat b/realm/gradlew.bat
index aec99730b4..f6d5974e72 100644
--- a/realm/gradlew.bat
+++ b/realm/gradlew.bat
@@ -8,14 +8,14 @@
 @rem Set local scope for the variables with windows NT shell
 if "%OS%"=="Windows_NT" setlocal
 
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
 set DIRNAME=%~dp0
 if "%DIRNAME%" == "" set DIRNAME=.
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
@@ -46,7 +46,7 @@ echo location of your Java installation.
 goto fail
 
 :init
-@rem Get command-line arguments, handling Windowz variants
+@rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
 if "%@eval[2+2]" == "4" goto 4NT_args
diff --git a/realm/realm-annotations-processor/build.gradle b/realm/realm-annotations-processor/build.gradle
index b6ca11d063..6c2c3cd3cd 100644
--- a/realm/realm-annotations-processor/build.gradle
+++ b/realm/realm-annotations-processor/build.gradle
@@ -11,7 +11,7 @@ dependencies {
     compile group:'com.squareup', name:'javawriter', version:'2.5.0'
     compile "io.realm:realm-annotations:${version}"
 
-    testCompile files('../realm-library/build/intermediates/bundles/release/classes.jar') // Java projects cannot depend on AAR files
+    testCompile files('../realm-library/build/intermediates/bundles/base/release/classes.jar') // Java projects cannot depend on AAR files
     testCompile files("${System.properties['java.home']}/../lib/tools.jar") // This is needed otherwise compile-testing won't be able to find it
     testCompile group:'junit', name:'junit', version:'4.12'
     testCompile group:'com.google.testing.compile', name:'compile-testing', version:'0.6'
@@ -74,6 +74,19 @@ publishing {
             }
         }
     }
+    repositories {
+        maven {
+            credentials(AwsCredentials) {
+                accessKey project.hasProperty('s3AccessKey') ? s3AccessKey : 'noAccessKey'
+                secretKey project.hasProperty('s3SecretKey') ? s3SecretKey : 'noSecretKey'
+            }
+            if(project.version.endsWith('-SNAPSHOT')) {
+                url "s3://realm-ci-artifacts/maven/snapshots/"
+            } else {
+                url "s3://realm-ci-artifacts/maven/releases/"
+            }
+        }
+    }
 }
 
 bintray {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 646a12790d..972a0f6314 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -373,6 +373,16 @@ public boolean isNullable(VariableElement variableElement) {
         return nullableFields.contains(variableElement);
     }
 
+    /**
+     * Checks if a VariableElement is indexed.
+     *
+     * @param variableElement the element/field
+     * @return {@code true} if a VariableElement is indexed, {@code false} otherwise.
+     */
+    public boolean isIndexed(VariableElement variableElement) {
+        return indexedFields.contains(variableElement);
+    }
+
     /**
      * Checks if a VariableElement is a primary key.
      *
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index a9cbc092cd..b092637530 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -66,9 +66,12 @@ public void generate() throws IOException, UnsupportedOperationException {
         imports.add("android.os.Build");
         imports.add("android.util.JsonReader");
         imports.add("android.util.JsonToken");
+        imports.add("io.realm.RealmObjectSchema");
+        imports.add("io.realm.RealmSchema");
         imports.add("io.realm.exceptions.RealmMigrationNeededException");
         imports.add("io.realm.internal.ColumnInfo");
         imports.add("io.realm.internal.RealmObjectProxy");
+        imports.add("io.realm.internal.Row");
         imports.add("io.realm.internal.Table");
         imports.add("io.realm.internal.TableOrView");
         imports.add("io.realm.internal.SharedRealm");
@@ -107,6 +110,7 @@ public void generate() throws IOException, UnsupportedOperationException {
         emitConstructor(writer);
         emitInjectContextMethod(writer);
         emitAccessors(writer);
+        emitCreateRealmObjectSchemaMethod(writer);
         emitInitTableMethod(writer);
         emitValidateTableMethod(writer);
         emitGetTableNameMethod(writer);
@@ -232,8 +236,8 @@ private void emitConstructor(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
-    private void emitAccessors(JavaWriter writer) throws IOException {
-        for (VariableElement field : metadata.getFields()) {
+    private void emitAccessors(final JavaWriter writer) throws IOException {
+        for (final VariableElement field : metadata.getFields()) {
             final String fieldName = field.getSimpleName().toString();
             final String fieldTypeCanonicalName = field.asType().toString();
 
@@ -241,12 +245,12 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                 /**
                  * Primitives and boxed types
                  */
-                String realmType = Constants.JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
+                final String realmType = Constants.JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
 
                 // Getter
                 writer.emitAnnotation("SuppressWarnings", "\"cast\"");
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
-                emitCodeForInjectingObjectContext(writer, field, false, metadata.isPrimaryKey(field));
+                emitCodeForInjectingObjectContext(writer);
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
 
                 // For String and bytes[], null value will be returned by JNI code. Try to save one JNI call here.
@@ -272,7 +276,30 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // Setter
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-                emitCodeForInjectingObjectContext(writer, field, true, metadata.isPrimaryKey(field));
+                emitCodeForInjectingObjectContext(writer);
+                emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
+                    @Override
+                    public void emit(JavaWriter writer) throws IOException {
+                        // set value as default value
+                        writer.emitStatement("final Row row = proxyState.getRow$realm()");
+
+                        if (metadata.isNullable(field)) {
+                            writer.beginControlFlow("if (value == null)")
+                                    .emitStatement("row.getTable().setNull(%s, row.getIndex(), true)",
+                                            fieldIndexVariableReference(field))
+                                    .emitStatement("return")
+                                .endControlFlow();
+                        } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
+                            writer.beginControlFlow("if (value == null)")
+                                    .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
+                                .endControlFlow();
+                        }
+                        writer.emitStatement(
+                                "row.getTable().set%s(%s, row.getIndex(), value, true)",
+                                realmType, fieldIndexVariableReference(field));
+                        writer.emitStatement("return");
+                    }
+                });
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 // Although setting null value for String and bytes[] can be handled by the JNI code, we still generate the same code here.
                 // Compared with getter, null value won't trigger more native calls in setter which is relatively cheaper.
@@ -304,7 +331,7 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // Getter
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
-                emitCodeForInjectingObjectContext(writer, field, false, metadata.isPrimaryKey(field));
+                emitCodeForInjectingObjectContext(writer);
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 writer.beginControlFlow("if (proxyState.getRow$realm().isNullLink(%s))", fieldIndexVariableReference(field));
                         writer.emitStatement("return null");
@@ -316,7 +343,37 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // Setter
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-                emitCodeForInjectingObjectContext(writer, field, true, metadata.isPrimaryKey(field));
+                emitCodeForInjectingObjectContext(writer);
+                emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
+                    @Override
+                    public void emit(JavaWriter writer) throws IOException {
+                        // check excludeFields
+                        writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
+                                field.getSimpleName().toString())
+                                .emitStatement("return")
+                            .endControlFlow();
+                        writer.beginControlFlow("if (value != null && !RealmObject.isManaged(value))")
+                                .emitStatement("value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value)")
+                            .endControlFlow();
+
+                        // set value as default value
+                        writer.emitStatement("final Row row = proxyState.getRow$realm()");
+                        writer.beginControlFlow("if (value == null)")
+                                .emitSingleLineComment("Table#nullifyLink() does not support default value. Just using Row.")
+                                .emitStatement("row.nullifyLink(%s)", fieldIndexVariableReference(field))
+                                .emitStatement("return")
+                            .endControlFlow();
+                        writer.beginControlFlow("if (!RealmObject.isValid(value))")
+                                .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
+                            .endControlFlow();
+                        writer.beginControlFlow("if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
+                                .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
+                            .endControlFlow();
+                        writer.emitStatement("row.getTable().setLink(%s, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true)",
+                                fieldIndexVariableReference(field));
+                        writer.emitStatement("return");
+                    }
+                });
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 writer.beginControlFlow("if (value == null)");
                     writer.emitStatement("proxyState.getRow$realm().nullifyLink(%s)", fieldIndexVariableReference(field));
@@ -338,7 +395,7 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // Getter
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
-                emitCodeForInjectingObjectContext(writer, field, false, metadata.isPrimaryKey(field));
+                emitCodeForInjectingObjectContext(writer);
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 writer.emitSingleLineComment("use the cached value if available");
                 writer.beginControlFlow("if (" + fieldName + "RealmList != null)");
@@ -355,8 +412,33 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // Setter
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
+                emitCodeForInjectingObjectContext(writer);
+                emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
+                    @Override
+                    public void emit(JavaWriter writer) throws IOException {
+                        // check excludeFields
+                        writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
+                                field.getSimpleName().toString())
+                                .emitStatement("return")
+                                .endControlFlow();
+                        final String modelFqcn = Utils.getGenericTypeQualifiedName(field);
+                        writer.beginControlFlow("if (value != null && !value.isManaged())")
+                                .emitStatement("final Realm realm = (Realm) proxyState.getRealm$realm()")
+                                .emitStatement("final RealmList<%1$s> original = value", modelFqcn)
+                                .emitStatement("value = new RealmList<%1$s>()", modelFqcn)
+                                .beginControlFlow("for (%1$s item : original)", modelFqcn)
+                                    .beginControlFlow("if (item == null || RealmObject.isManaged(item))")
+                                        .emitStatement("value.add(item)")
+                                    .nextControlFlow("else")
+                                        .emitStatement("value.add(realm.copyToRealm(item))")
+                                    .endControlFlow()
+                                .endControlFlow()
+                            .endControlFlow();
+
+                        // LinkView currently does not support default value feature. Just fallback to normal code.
+                    }
+                });
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
-                emitCodeForInjectingObjectContext(writer, field, true, metadata.isPrimaryKey(field));
                 writer.emitStatement("LinkView links = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field));
                 writer.emitStatement("links.clear()");
                 writer.beginControlFlow("if (value == null)");
@@ -380,7 +462,7 @@ private void emitAccessors(JavaWriter writer) throws IOException {
         }
     }
 
-    private void emitCodeForInjectingObjectContext(JavaWriter writer, VariableElement field, boolean isSetter, boolean isPrimaryKey) throws IOException {
+    private void emitCodeForInjectingObjectContext(JavaWriter writer) throws IOException {
         // if invoked from model's constructor, inject BaseRealm and Row
         writer.beginControlFlow("if (proxyState == null)");
         {
@@ -389,51 +471,26 @@ private void emitCodeForInjectingObjectContext(JavaWriter writer, VariableElemen
         }
         writer.endControlFlow();
         writer.emitEmptyLine();
+    }
 
-        if (isSetter) {
-            writer.beginControlFlow("if (proxyState.isUnderConstruction())");
-            {
-                if (isPrimaryKey) {
-                    writer.emitSingleLineComment("default value of the primary key is always ignored.");
-                    writer.emitStatement("return");
-                } else {
-                    writer.beginControlFlow("if (!proxyState.getAcceptDefaultValue$realm())")
-                            .emitStatement("return")
-                            .endControlFlow();
-                    if (Utils.isRealmModel(field)) {
-                        // check excludeFields
-                        writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
-                                field.getSimpleName().toString())
-                                .emitStatement("return")
-                                .endControlFlow();
-                        writer.beginControlFlow("if (value != null && !RealmObject.isManaged(value))")
-                                .emitStatement("value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value)")
-                                .endControlFlow();
-                    } else if (Utils.isRealmList(field)) {
-                        // check excludeFields
-                        writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
-                                field.getSimpleName().toString())
-                                .emitStatement("return")
-                                .endControlFlow();
-                        final String modelFqcn = Utils.getGenericTypeQualifiedName(field);
-                        writer.beginControlFlow("if (value != null && !value.isManaged())")
-                                .emitStatement("final Realm realm = (Realm) proxyState.getRealm$realm()")
-                                .emitStatement("final RealmList<%1$s> original = value", modelFqcn)
-                                .emitStatement("value = new RealmList<%1$s>()", modelFqcn)
-                                .beginControlFlow("for (%1$s item : original)", modelFqcn)
-                                    .beginControlFlow("if (item == null || RealmObject.isManaged(item))")
-                                        .emitStatement("value.add(item)")
-                                    .nextControlFlow("else")
-                                        .emitStatement("value.add(realm.copyToRealm(item))")
-                                    .endControlFlow()
-                                .endControlFlow()
-                            .endControlFlow();
-                    }
-                }
-            }
-            writer.endControlFlow()
-                    .emitEmptyLine();
+    private interface CodeEmitter {
+        void emit(JavaWriter writer) throws IOException;
+    }
+
+    private void emitCodeForUnderConstruction(JavaWriter writer, boolean isPrimaryKey,
+                                              CodeEmitter defaultValueCodeEmitter) throws IOException {
+        writer.beginControlFlow("if (proxyState.isUnderConstruction())");
+        if (isPrimaryKey) {
+            writer.emitSingleLineComment("default value of the primary key is always ignored.");
+            writer.emitStatement("return");
+        } else {
+            writer.beginControlFlow("if (!proxyState.getAcceptDefaultValue$realm())")
+                    .emitStatement("return")
+                    .endControlFlow();
+            defaultValueCodeEmitter.emit(writer);
         }
+        writer.endControlFlow();
+        writer.emitEmptyLine();
     }
 
     private void emitInjectContextMethod(JavaWriter writer) throws IOException {
@@ -464,6 +521,54 @@ private void emitRealmObjectProxyImplementation(JavaWriter writer) throws IOExce
         writer.emitEmptyLine();
     }
 
+    private void emitCreateRealmObjectSchemaMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod(
+                "RealmObjectSchema", // Return type
+                "createRealmObjectSchema", // Method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
+                "RealmSchema", "realmSchema"); // Argument type & argument name
+
+        writer.beginControlFlow("if (!realmSchema.contains(\"" + this.simpleClassName + "\"))");
+        writer.emitStatement("RealmObjectSchema realmObjectSchema = realmSchema.create(\"%s\")", this.simpleClassName);
+
+        // For each field generate corresponding table index constant
+        for (VariableElement field : metadata.getFields()) {
+            String fieldName = field.getSimpleName().toString();
+            String fieldTypeCanonicalName = field.asType().toString();
+            String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
+
+            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
+                String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
+                String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
+                String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
+                writer.emitStatement("realmObjectSchema.add(new Property(\"%s\", %s, %s, %s, %s))",
+                        fieldName,
+                        Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
+                        primaryKeyFlag,
+                        indexedFlag,
+                        nullableFlag);
+            } else if (Utils.isRealmModel(field)) {
+                writer.beginControlFlow("if (!realmSchema.contains(\"" + fieldTypeSimpleName + "\"))");
+                writer.emitStatement("%s%s.createRealmObjectSchema(realmSchema)", fieldTypeSimpleName, Constants.PROXY_SUFFIX);
+                writer.endControlFlow();
+                writer.emitStatement("realmObjectSchema.add(new Property(\"%s\", RealmFieldType.OBJECT, realmSchema.get(\"%s\")))",
+                        fieldName, fieldTypeSimpleName);
+            } else if (Utils.isRealmList(field)) {
+                String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
+                writer.beginControlFlow("if (!realmSchema.contains(\"" + genericTypeSimpleName +"\"))");
+                writer.emitStatement("%s%s.createRealmObjectSchema(realmSchema)", genericTypeSimpleName, Constants.PROXY_SUFFIX);
+                writer.endControlFlow();
+                writer.emitStatement("realmObjectSchema.add(new Property(\"%s\", RealmFieldType.LIST, realmSchema.get(\"%s\")))",
+                        fieldName, genericTypeSimpleName);
+            }
+        }
+        writer.emitStatement("return realmObjectSchema");
+        writer.endControlFlow();
+        writer.emitStatement("return realmSchema.get(\"" + this.simpleClassName + "\")");
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
     private void emitInitTableMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
                 "Table", // Return type
@@ -817,7 +922,7 @@ private void setTableValues(JavaWriter writer, String fieldType, String fieldNam
                 || "int".equals(fieldType)
                 || "short".equals(fieldType)
                 || "byte".equals(fieldType)) {
-            writer.emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s())", fieldName, interfaceName, getter);
+            writer.emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s(), false)", fieldName, interfaceName, getter);
 
         } else if ("java.lang.Long".equals(fieldType)
                 || "java.lang.Integer".equals(fieldType)
@@ -826,52 +931,52 @@ private void setTableValues(JavaWriter writer, String fieldType, String fieldNam
             writer
                     .emitStatement("Number %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue())", fieldName, getter);
+                        .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter);
                     if (isUpdate) {
                         writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
                     }
                     writer.endControlFlow();
 
         } else if ("double".equals(fieldType)) {
-            writer.emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s())", fieldName, interfaceName, getter);
+            writer.emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s(), false)", fieldName, interfaceName, getter);
 
         } else if("java.lang.Double".equals(fieldType)) {
             writer
                     .emitStatement("Double %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                        .emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
                     if (isUpdate) {
                         writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
                     }
                     writer.endControlFlow();
 
         } else if ("float".equals(fieldType)) {
-            writer.emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s())", fieldName, interfaceName, getter);
+            writer.emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s(), false)", fieldName, interfaceName, getter);
 
         } else if ("java.lang.Float".equals(fieldType)) {
             writer
                     .emitStatement("Float %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                        .emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
                     if (isUpdate) {
                         writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
                     }
                     writer.endControlFlow();
 
         } else if ("boolean".equals(fieldType)) {
-            writer.emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s())", fieldName, interfaceName, getter);
+            writer.emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s(), false)", fieldName, interfaceName, getter);
 
         } else if ("java.lang.Boolean".equals(fieldType)) {
             writer
                     .emitStatement("Boolean %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                        .emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
                     if (isUpdate) {
                         writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
                     }
                     writer.endControlFlow();
 
@@ -879,10 +984,10 @@ private void setTableValues(JavaWriter writer, String fieldType, String fieldNam
             writer
                     .emitStatement("byte[] %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetByteArray(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                        .emitStatement("Table.nativeSetByteArray(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
                     if (isUpdate) {
                         writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
                     }
                     writer.endControlFlow();
 
@@ -891,10 +996,10 @@ private void setTableValues(JavaWriter writer, String fieldType, String fieldNam
             writer
                     .emitStatement("java.util.Date %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetTimestamp(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.getTime())", fieldName, getter);
+                        .emitStatement("Table.nativeSetTimestamp(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.getTime(), false)", fieldName, getter);
                     if (isUpdate) {
                         writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
                     }
                     writer.endControlFlow();
 
@@ -902,10 +1007,10 @@ private void setTableValues(JavaWriter writer, String fieldType, String fieldNam
             writer
                     .emitStatement("String %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetString(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                        .emitStatement("Table.nativeSetString(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
                     if (isUpdate) {
                         writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
                     }
                     writer.endControlFlow();
         } else {
@@ -954,7 +1059,7 @@ private void emitInsertMethod(JavaWriter writer) throws IOException {
                                         Utils.getProxyClassSimpleName(field),
                                         fieldName)
                             .endControlFlow()
-                           .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s)", fieldName)
+                           .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .endControlFlow();
             } else if (Utils.isRealmList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
@@ -1032,7 +1137,7 @@ private void emitInsertListMethod(JavaWriter writer) throws IOException {
                                         Utils.getProxyClassSimpleName(field),
                                         fieldName)
                                 .endControlFlow()
-                        .emitStatement("table.setLink(columnInfo.%1$sIndex, rowIndex, cache%1$s)", fieldName)
+                        .emitStatement("table.setLink(columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .endControlFlow();
             } else if (Utils.isRealmList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
@@ -1106,7 +1211,7 @@ private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
                                         fieldName,
                                         Utils.getProxyClassSimpleName(field))
                             .endControlFlow()
-                            .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s)", fieldName)
+                            .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .nextControlFlow("else")
                                 // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                             .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
@@ -1187,7 +1292,7 @@ private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException
                                         fieldName,
                                         Utils.getProxyClassSimpleName(field))
                                     .endControlFlow()
-                            .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s)", fieldName)
+                            .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .nextControlFlow("else")
                                 // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                             .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index 69f14ae529..ee9e2beab9 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -79,6 +79,7 @@ public void generate() throws IOException {
                 "io.realm.internal.RealmProxyMediator",
                 "io.realm.internal.Row",
                 "io.realm.internal.Table",
+                "io.realm.RealmObjectSchema",
                 "org.json.JSONException",
                 "org.json.JSONObject"
         );
@@ -95,6 +96,7 @@ public void generate() throws IOException {
 
         emitFields(writer);
         emitCreateTableMethod(writer);
+        emitCreateRealmObjectSchema(writer);
         emitValidateTableMethod(writer);
         emitGetFieldNamesMethod(writer);
         emitGetTableNameMethod(writer);
@@ -124,6 +126,24 @@ private void emitFields(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
+    private void emitCreateRealmObjectSchema(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "RealmObjectSchema",
+                "createRealmObjectSchema",
+                EnumSet.of(Modifier.PUBLIC),
+                "Class<? extends RealmModel>", "clazz", "RealmSchema", "realmSchema"
+        );
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("return %s.createRealmObjectSchema(realmSchema)", qualifiedProxyClasses.get(i));
+            }
+        }, writer);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
     private void emitCreateTableMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 17697142ad..3ceaa5677f 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -5,10 +5,13 @@
 import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
+import io.realm.RealmObjectSchema;
+import io.realm.RealmSchema;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
@@ -170,6 +173,9 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setLong(columnInfo.columnLongIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -197,6 +203,9 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setFloat(columnInfo.columnFloatIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -224,6 +233,9 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setDouble(columnInfo.columnDoubleIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -251,6 +263,9 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setBoolean(columnInfo.columnBooleanIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -278,6 +293,12 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'columnDate' to null.");
+            }
+            row.getTable().setDate(columnInfo.columnDateIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -308,6 +329,12 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'columnBinary' to null.");
+            }
+            row.getTable().setBinaryByteArray(columnInfo.columnBinaryIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -346,6 +373,20 @@ private void injectObjectContext() {
             if (value != null && !RealmObject.isManaged(value)) {
                 value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value);
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                // Table#nullifyLink() does not support default value. Just use Row.
+                row.nullifyLink(columnInfo.columnObjectIndex);
+                return;
+            }
+            if (!RealmObject.isValid(value)) {
+                throw new IllegalArgumentException("'value' is not a valid managed object.");
+            }
+            if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
+                throw new IllegalArgumentException("'value' belongs to a different Realm.");
+            }
+            row.getTable().setLink(columnInfo.columnObjectIndex, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -380,7 +421,6 @@ private void injectObjectContext() {
     }
 
     public void realmSet$columnRealmList(RealmList<some.test.AllTypes> value) {
-        proxyState.getRealm$realm().checkIfValid();
         if (proxyState == null) {
             // Called from model's constructor. Inject context.
             injectObjectContext();
@@ -407,6 +447,7 @@ private void injectObjectContext() {
             }
         }
 
+        proxyState.getRealm$realm().checkIfValid();
         LinkView links = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
         links.clear();
         if (value == null) {
@@ -423,6 +464,29 @@ private void injectObjectContext() {
         }
     }
 
+    public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
+        if (!realmSchema.contains("AllTypes")) {
+            RealmObjectSchema realmObjectSchema = realmSchema.create("AllTypes");
+            realmObjectSchema.add(new Property("columnString", RealmFieldType.STRING, Property.PRIMARY_KEY, Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("columnLong", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("columnFloat", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("columnDouble", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("columnBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("columnDate", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("columnBinary", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            if (!realmSchema.contains("AllTypes")) {
+                AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
+            }
+            realmObjectSchema.add(new Property("columnObject", RealmFieldType.OBJECT, realmSchema.get("AllTypes")));
+            if (!realmSchema.contains("AllTypes")) {
+                AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
+            }
+            realmObjectSchema.add(new Property("columnRealmList", RealmFieldType.LIST, realmSchema.get("AllTypes")));
+            return realmObjectSchema;
+        }
+        return realmSchema.get("AllTypes");
+    }
+
     public static Table initTable(SharedRealm sharedRealm) {
         if (!sharedRealm.hasTable("class_AllTypes")) {
             Table table = sharedRealm.getTable("class_AllTypes");
@@ -897,17 +961,17 @@ public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel
             Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
         }
         cache.put(object, rowIndex);
-        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong());
-        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat());
-        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble());
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean());
+        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong(), false);
+        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat(), false);
+        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean(), false);
         java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
         if (realmGet$columnDate != null) {
-            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime());
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
         }
         byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
         if (realmGet$columnBinary != null) {
-            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary);
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
         }
 
         some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
@@ -916,7 +980,7 @@ public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel
             if (cachecolumnObject == null) {
                 cachecolumnObject = AllTypesRealmProxy.insert(realm, columnObjectObj, cache);
             }
-            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject);
+            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
         }
 
         RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
@@ -961,17 +1025,17 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                     Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
                 }
                 cache.put(object, rowIndex);
-                Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong());
-                Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat());
-                Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble());
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean());
+                Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong(), false);
+                Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat(), false);
+                Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble(), false);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean(), false);
                 java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
                 if (realmGet$columnDate != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime());
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
                 }
                 byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
                 if (realmGet$columnBinary != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary);
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
                 }
 
                 some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
@@ -980,7 +1044,7 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                     if (cachecolumnObject == null) {
                         cachecolumnObject = AllTypesRealmProxy.insert(realm, columnObjectObj, cache);
                     }
-                    table.setLink(columnInfo.columnObjectIndex, rowIndex, cachecolumnObject);
+                    table.setLink(columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
                 }
 
                 RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
@@ -1019,21 +1083,21 @@ public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<Re
             rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
         }
         cache.put(object, rowIndex);
-        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong());
-        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat());
-        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble());
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean());
+        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong(), false);
+        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat(), false);
+        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean(), false);
         java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
         if (realmGet$columnDate != null) {
-            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime());
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex, false);
         }
         byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
         if (realmGet$columnBinary != null) {
-            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary);
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, false);
         }
 
         some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
@@ -1042,7 +1106,7 @@ public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<Re
             if (cachecolumnObject == null) {
                 cachecolumnObject = AllTypesRealmProxy.insertOrUpdate(realm, columnObjectObj, cache);
             }
-            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject);
+            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
         } else {
             Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
         }
@@ -1088,21 +1152,21 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                     rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
                 }
                 cache.put(object, rowIndex);
-                Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong());
-                Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat());
-                Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble());
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean());
+                Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong(), false);
+                Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat(), false);
+                Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble(), false);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean(), false);
                 java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
                 if (realmGet$columnDate != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime());
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex, false);
                 }
                 byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
                 if (realmGet$columnBinary != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary);
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, false);
                 }
 
                 some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
@@ -1111,7 +1175,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                     if (cachecolumnObject == null) {
                         cachecolumnObject = AllTypesRealmProxy.insertOrUpdate(realm, columnObjectObj, cache);
                     }
-                    Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject);
+                    Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
                 } else {
                     Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
                 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index 7621195151..54abdab25d 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -5,10 +5,13 @@
 import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
+import io.realm.RealmObjectSchema;
+import io.realm.RealmSchema;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
@@ -118,6 +121,9 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setBoolean(columnInfo.doneIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -145,6 +151,9 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setBoolean(columnInfo.isReadyIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -172,6 +181,9 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setBoolean(columnInfo.mCompletedIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -199,12 +211,27 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setBoolean(columnInfo.anotherBooleanIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setBoolean(columnInfo.anotherBooleanIndex, value);
     }
 
+    public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
+        if (!realmSchema.contains("Booleans")) {
+            RealmObjectSchema realmObjectSchema = realmSchema.create("Booleans");
+            realmObjectSchema.add(new Property("done", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("isReady", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("mCompleted", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("anotherBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            return realmObjectSchema;
+        }
+        return realmSchema.get("Booleans");
+    }
+
     public static Table initTable(SharedRealm sharedRealm) {
         if (!sharedRealm.hasTable("class_Booleans")) {
             Table table = sharedRealm.getTable("class_Booleans");
@@ -411,10 +438,10 @@ public static long insert(Realm realm, some.test.Booleans object, Map<RealmModel
         BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
         long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
         cache.put(object, rowIndex);
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean(), false);
         return rowIndex;
     }
 
@@ -432,10 +459,10 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                 }
                 long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
                 cache.put(object, rowIndex);
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done(), false);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady(), false);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted(), false);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean(), false);
             }
         }
     }
@@ -449,10 +476,10 @@ public static long insertOrUpdate(Realm realm, some.test.Booleans object, Map<Re
         BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
         long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
         cache.put(object, rowIndex);
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean(), false);
         return rowIndex;
     }
 
@@ -470,10 +497,10 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                 }
                 long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
                 cache.put(object, rowIndex);
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done(), false);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady(), false);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted(), false);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean(), false);
             }
         }
     }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index b8b1322464..272de1cf78 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -5,10 +5,13 @@
 import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
+import io.realm.RealmObjectSchema;
+import io.realm.RealmSchema;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
@@ -203,6 +206,12 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldStringNotNull' to null.");
+            }
+            row.getTable().setString(columnInfo.fieldStringNotNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -233,6 +242,13 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldStringNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setString(columnInfo.fieldStringNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -264,6 +280,12 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldBooleanNotNull' to null.");
+            }
+            row.getTable().setBoolean(columnInfo.fieldBooleanNotNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -297,6 +319,13 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldBooleanNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setBoolean(columnInfo.fieldBooleanNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -328,6 +357,12 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldBytesNotNull' to null.");
+            }
+            row.getTable().setBinaryByteArray(columnInfo.fieldBytesNotNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -358,6 +393,13 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldBytesNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setBinaryByteArray(columnInfo.fieldBytesNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -389,6 +431,12 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldByteNotNull' to null.");
+            }
+            row.getTable().setLong(columnInfo.fieldByteNotNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -422,6 +470,13 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldByteNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setLong(columnInfo.fieldByteNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -453,6 +508,12 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldShortNotNull' to null.");
+            }
+            row.getTable().setLong(columnInfo.fieldShortNotNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -486,6 +547,13 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldShortNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setLong(columnInfo.fieldShortNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -517,6 +585,12 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldIntegerNotNull' to null.");
+            }
+            row.getTable().setLong(columnInfo.fieldIntegerNotNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -550,6 +624,13 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldIntegerNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setLong(columnInfo.fieldIntegerNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -581,6 +662,12 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldLongNotNull' to null.");
+            }
+            row.getTable().setLong(columnInfo.fieldLongNotNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -614,6 +701,13 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldLongNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setLong(columnInfo.fieldLongNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -645,6 +739,12 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldFloatNotNull' to null.");
+            }
+            row.getTable().setFloat(columnInfo.fieldFloatNotNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -678,6 +778,13 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldFloatNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setFloat(columnInfo.fieldFloatNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -709,6 +816,12 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldDoubleNotNull' to null.");
+            }
+            row.getTable().setDouble(columnInfo.fieldDoubleNotNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -742,6 +855,13 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldDoubleNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setDouble(columnInfo.fieldDoubleNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -773,6 +893,12 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldDateNotNull' to null.");
+            }
+            row.getTable().setDate(columnInfo.fieldDateNotNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -806,6 +932,13 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldDateNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setDate(columnInfo.fieldDateNullIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -845,6 +978,20 @@ private void injectObjectContext() {
             if (value != null && !RealmObject.isManaged(value)) {
                 value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value);
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                // Table#nullifyLink() does not support default value. Just use Row.
+                row.nullifyLink(columnInfo.fieldObjectNullIndex);
+                return;
+            }
+            if (!RealmObject.isValid(value)) {
+                throw new IllegalArgumentException("'value' is not a valid managed object.");
+            }
+            if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
+                throw new IllegalArgumentException("'value' belongs to a different Realm.");
+            }
+            row.getTable().setLink(columnInfo.fieldObjectNullIndex, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -861,6 +1008,38 @@ private void injectObjectContext() {
         proxyState.getRow$realm().setLink(columnInfo.fieldObjectNullIndex, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex());
     }
 
+    public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
+        if (!realmSchema.contains("NullTypes")) {
+            RealmObjectSchema realmObjectSchema = realmSchema.create("NullTypes");
+            realmObjectSchema.add(new Property("fieldStringNotNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldStringNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldBooleanNotNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldBooleanNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldBytesNotNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldBytesNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldByteNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldByteNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldShortNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldShortNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldIntegerNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldIntegerNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldLongNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldLongNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldFloatNotNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldFloatNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldDoubleNotNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldDoubleNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldDateNotNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldDateNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            if (!realmSchema.contains("NullTypes")) {
+                NullTypesRealmProxy.createRealmObjectSchema(realmSchema);
+            }
+            realmObjectSchema.add(new Property("fieldObjectNull", RealmFieldType.OBJECT, realmSchema.get("NullTypes")));
+            return realmObjectSchema;
+        }
+        return realmSchema.get("NullTypes");
+    }
+
     public static Table initTable(SharedRealm sharedRealm) {
         if (!sharedRealm.hasTable("class_NullTypes")) {
             Table table = sharedRealm.getTable("class_NullTypes");
@@ -1537,83 +1716,83 @@ public static long insert(Realm realm, some.test.NullTypes object, Map<RealmMode
         cache.put(object, rowIndex);
         String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
         if (realmGet$fieldStringNotNull != null) {
-            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull);
+            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull, false);
         }
         String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
         if (realmGet$fieldStringNull != null) {
-            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull);
+            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull, false);
         }
         Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
         if (realmGet$fieldBooleanNotNull != null) {
-            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull, false);
         }
         Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
         if (realmGet$fieldBooleanNull != null) {
-            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull, false);
         }
         byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
         if (realmGet$fieldBytesNotNull != null) {
-            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull);
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull, false);
         }
         byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
         if (realmGet$fieldBytesNull != null) {
-            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull);
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull, false);
         }
         Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
         if (realmGet$fieldByteNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue(), false);
         }
         Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
         if (realmGet$fieldByteNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue(), false);
         }
         Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
         if (realmGet$fieldShortNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue(), false);
         }
         Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
         if (realmGet$fieldShortNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue(), false);
         }
         Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
         if (realmGet$fieldIntegerNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue(), false);
         }
         Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
         if (realmGet$fieldIntegerNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue(), false);
         }
         Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
         if (realmGet$fieldLongNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue(), false);
         }
         Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
         if (realmGet$fieldLongNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
         }
         Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
         if (realmGet$fieldFloatNotNull != null) {
-            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull);
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
         }
         Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
         if (realmGet$fieldFloatNull != null) {
-            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull);
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
         }
         Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
         if (realmGet$fieldDoubleNotNull != null) {
-            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull);
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
         }
         Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
         if (realmGet$fieldDoubleNull != null) {
-            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull);
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
         }
         java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
         if (realmGet$fieldDateNotNull != null) {
-            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime());
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
         }
         java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
         if (realmGet$fieldDateNull != null) {
-            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime());
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
         }
 
         some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
@@ -1622,7 +1801,7 @@ public static long insert(Realm realm, some.test.NullTypes object, Map<RealmMode
             if (cachefieldObjectNull == null) {
                 cachefieldObjectNull = NullTypesRealmProxy.insert(realm, fieldObjectNullObj, cache);
             }
-            Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull);
+            Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
         }
         return rowIndex;
     }
@@ -1643,83 +1822,83 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                 cache.put(object, rowIndex);
                 String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
                 if (realmGet$fieldStringNotNull != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull);
+                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull, false);
                 }
                 String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
                 if (realmGet$fieldStringNull != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull);
+                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull, false);
                 }
                 Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
                 if (realmGet$fieldBooleanNotNull != null) {
-                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull);
+                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull, false);
                 }
                 Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
                 if (realmGet$fieldBooleanNull != null) {
-                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull);
+                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull, false);
                 }
                 byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
                 if (realmGet$fieldBytesNotNull != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull);
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull, false);
                 }
                 byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
                 if (realmGet$fieldBytesNull != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull);
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull, false);
                 }
                 Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
                 if (realmGet$fieldByteNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue(), false);
                 }
                 Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
                 if (realmGet$fieldByteNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue(), false);
                 }
                 Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
                 if (realmGet$fieldShortNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue(), false);
                 }
                 Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
                 if (realmGet$fieldShortNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue(), false);
                 }
                 Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
                 if (realmGet$fieldIntegerNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue(), false);
                 }
                 Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
                 if (realmGet$fieldIntegerNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue(), false);
                 }
                 Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
                 if (realmGet$fieldLongNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue(), false);
                 }
                 Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
                 if (realmGet$fieldLongNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
                 }
                 Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
                 if (realmGet$fieldFloatNotNull != null) {
-                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull);
+                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
                 }
                 Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
                 if (realmGet$fieldFloatNull != null) {
-                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull);
+                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
                 }
                 Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
                 if (realmGet$fieldDoubleNotNull != null) {
-                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull);
+                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
                 }
                 Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
                 if (realmGet$fieldDoubleNull != null) {
-                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull);
+                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
                 }
                 java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
                 if (realmGet$fieldDateNotNull != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime());
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
                 }
                 java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
                 if (realmGet$fieldDateNull != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime());
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
                 }
 
                 some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
@@ -1728,7 +1907,7 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                     if (cachefieldObjectNull == null) {
                         cachefieldObjectNull = NullTypesRealmProxy.insert(realm, fieldObjectNullObj, cache);
                     }
-                    table.setLink(columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull);
+                    table.setLink(columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
                 }
             }
         }
@@ -1745,123 +1924,123 @@ public static long insertOrUpdate(Realm realm, some.test.NullTypes object, Map<R
         cache.put(object, rowIndex);
         String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
         if (realmGet$fieldStringNotNull != null) {
-            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull);
+            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, false);
         }
         String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
         if (realmGet$fieldStringNull != null) {
-            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull);
+            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, false);
         }
         Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
         if (realmGet$fieldBooleanNotNull != null) {
-            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, false);
         }
         Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
         if (realmGet$fieldBooleanNull != null) {
-            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, false);
         }
         byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
         if (realmGet$fieldBytesNotNull != null) {
-            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull);
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, false);
         }
         byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
         if (realmGet$fieldBytesNull != null) {
-            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull);
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, false);
         }
         Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
         if (realmGet$fieldByteNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, false);
         }
         Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
         if (realmGet$fieldByteNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, false);
         }
         Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
         if (realmGet$fieldShortNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, false);
         }
         Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
         if (realmGet$fieldShortNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, false);
         }
         Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
         if (realmGet$fieldIntegerNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, false);
         }
         Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
         if (realmGet$fieldIntegerNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, false);
         }
         Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
         if (realmGet$fieldLongNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, false);
         }
         Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
         if (realmGet$fieldLongNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, false);
         }
         Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
         if (realmGet$fieldFloatNotNull != null) {
-            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull);
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, false);
         }
         Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
         if (realmGet$fieldFloatNull != null) {
-            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull);
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, false);
         }
         Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
         if (realmGet$fieldDoubleNotNull != null) {
-            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull);
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, false);
         }
         Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
         if (realmGet$fieldDoubleNull != null) {
-            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull);
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, false);
         }
         java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
         if (realmGet$fieldDateNotNull != null) {
-            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime());
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, false);
         }
         java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
         if (realmGet$fieldDateNull != null) {
-            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime());
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, false);
         }
 
         some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
@@ -1870,7 +2049,7 @@ public static long insertOrUpdate(Realm realm, some.test.NullTypes object, Map<R
             if (cachefieldObjectNull == null) {
                 cachefieldObjectNull = NullTypesRealmProxy.insertOrUpdate(realm, fieldObjectNullObj, cache);
             }
-            Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull);
+            Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
         } else {
             Table.nativeNullifyLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex);
         }
@@ -1893,123 +2072,123 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                 cache.put(object, rowIndex);
                 String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
                 if (realmGet$fieldStringNotNull != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull);
+                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, false);
                 }
                 String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
                 if (realmGet$fieldStringNull != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull);
+                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, false);
                 }
                 Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
                 if (realmGet$fieldBooleanNotNull != null) {
-                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull);
+                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, false);
                 }
                 Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
                 if (realmGet$fieldBooleanNull != null) {
-                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull);
+                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, false);
                 }
                 byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
                 if (realmGet$fieldBytesNotNull != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull);
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, false);
                 }
                 byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
                 if (realmGet$fieldBytesNull != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull);
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, false);
                 }
                 Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
                 if (realmGet$fieldByteNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, false);
                 }
                 Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
                 if (realmGet$fieldByteNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, false);
                 }
                 Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
                 if (realmGet$fieldShortNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, false);
                 }
                 Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
                 if (realmGet$fieldShortNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, false);
                 }
                 Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
                 if (realmGet$fieldIntegerNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, false);
                 }
                 Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
                 if (realmGet$fieldIntegerNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, false);
                 }
                 Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
                 if (realmGet$fieldLongNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, false);
                 }
                 Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
                 if (realmGet$fieldLongNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, false);
                 }
                 Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
                 if (realmGet$fieldFloatNotNull != null) {
-                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull);
+                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, false);
                 }
                 Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
                 if (realmGet$fieldFloatNull != null) {
-                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull);
+                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, false);
                 }
                 Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
                 if (realmGet$fieldDoubleNotNull != null) {
-                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull);
+                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, false);
                 }
                 Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
                 if (realmGet$fieldDoubleNull != null) {
-                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull);
+                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, false);
                 }
                 java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
                 if (realmGet$fieldDateNotNull != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime());
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, false);
                 }
                 java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
                 if (realmGet$fieldDateNull != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime());
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, false);
                 }
 
                 some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
@@ -2018,7 +2197,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                     if (cachefieldObjectNull == null) {
                         cachefieldObjectNull = NullTypesRealmProxy.insertOrUpdate(realm, fieldObjectNullObj, cache);
                     }
-                    Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull);
+                    Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
                 } else {
                     Table.nativeNullifyLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex);
                 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
index 0edbe6cb1f..51049b4d90 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -2,6 +2,7 @@
 
 
 import android.util.JsonReader;
+import io.realm.RealmObjectSchema;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
@@ -41,6 +42,17 @@ public Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRe
         }
     }
 
+    @Override
+    public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema realmSchema) {
+        checkClass(clazz);
+
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return io.realm.AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
+        } else {
+            throw getMissingProxyClassException(clazz);
+        }
+    }
+
     @Override
     public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm, boolean allowExtraColumns) {
         checkClass(clazz);
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index c25a606f1f..7190607f14 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -5,10 +5,13 @@
 import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
+import io.realm.RealmObjectSchema;
+import io.realm.RealmSchema;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
@@ -108,6 +111,13 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.nameIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setString(columnInfo.nameIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
@@ -139,12 +149,25 @@ private void injectObjectContext() {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
             }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setLong(columnInfo.ageIndex, row.getIndex(), value, true);
+            return;
         }
 
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setLong(columnInfo.ageIndex, value);
     }
 
+    public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
+        if (!realmSchema.contains("Simple")) {
+            RealmObjectSchema realmObjectSchema = realmSchema.create("Simple");
+            realmObjectSchema.add(new Property("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("age", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            return realmObjectSchema;
+        }
+        return realmSchema.get("Simple");
+    }
+
     public static Table initTable(SharedRealm sharedRealm) {
         if (!sharedRealm.hasTable("class_Simple")) {
             Table table = sharedRealm.getTable("class_Simple");
@@ -303,9 +326,9 @@ public static long insert(Realm realm, some.test.Simple object, Map<RealmModel,L
         cache.put(object, rowIndex);
         String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
         if (realmGet$name != null) {
-            Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
+            Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name, false);
         }
-        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
+        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age(), false);
         return rowIndex;
     }
 
@@ -325,9 +348,9 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                 cache.put(object, rowIndex);
                 String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
                 if (realmGet$name != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
+                    Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name, false);
                 }
-                Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
+                Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age(), false);
             }
         }
     }
@@ -343,11 +366,11 @@ public static long insertOrUpdate(Realm realm, some.test.Simple object, Map<Real
         cache.put(object, rowIndex);
         String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
         if (realmGet$name != null) {
-            Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
+            Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex, false);
         }
-        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
+        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age(), false);
         return rowIndex;
     }
 
@@ -367,11 +390,11 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                 cache.put(object, rowIndex);
                 String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
                 if (realmGet$name != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
+                    Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex, false);
                 }
-                Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
+                Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age(), false);
             }
         }
     }
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index c26ff09921..ca07f306a0 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -5,16 +5,18 @@ apply plugin: 'com.neenbedankt.android-apt'
 apply plugin: 'com.github.dcendents.android-maven'
 apply plugin: 'maven-publish'
 apply plugin: 'com.jfrog.artifactory'
-apply plugin: 'com.jfrog.bintray'
 apply plugin: 'findbugs'
 apply plugin: 'pmd'
 apply plugin: 'checkstyle'
 apply plugin: 'com.github.kt3k.coveralls'
 apply plugin: 'de.undercouch.download'
 
-ext.coreVersion = '2.0.0-rc4'
+def properties = new Properties()
+properties.load(new FileInputStream("${projectDir}/../../dependencies.list"))
+
+ext.coreVersion = properties.getProperty('REALM_SYNC_VERSION')
 // empty or comment out this to disable hash checking
-ext.coreSha256Hash = '760d8e889b8d678da36f63be2a49924969bfc8370176696ee977659d59677717'
+ext.coreSha256Hash = properties.getProperty('REALM_SYNC_SHA256')
 ext.forceDownloadCore =
         project.hasProperty('forceDownloadCore') ? project.getProperty('forceDownloadCore').toBoolean() : false
 // Set the core source code path. By setting this, the core will be built from source. And coreVersion will be read from
@@ -25,9 +27,11 @@ ext.coreArchiveDir = System.getenv("REALM_CORE_DOWNLOAD_DIR")
 if (!ext.coreArchiveDir) {
     ext.coreArchiveDir = ".."
 }
-ext.coreArchiveFile = rootProject.file("${ext.coreArchiveDir}/core-android-${project.coreVersion}.tar.gz")
+ext.coreArchiveFile = rootProject.file("${ext.coreArchiveDir}/realm-sync-android-${project.coreVersion}.tar.gz")
 ext.coreDistributionDir = file("${projectDir}/distribution/realm-core/")
 ext.coreDir = file("${project.coreDistributionDir.getAbsolutePath()}/core-${project.coreVersion}")
+ext.ccachePath = project.findProperty('ccachePath') ?: System.getenv('NDK_CCACHE')
+ext.lcachePath = project.findProperty('lcachePath') ?: System.getenv('NDK_LCACHE')
 
 android {
     compileSdkVersion 24
@@ -37,7 +41,6 @@ android {
         minSdkVersion 9
         targetSdkVersion 24
         project.archivesBaseName = "realm-android-library"
-        consumerProguardFiles 'proguard-rules.pro'
         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
         externalNativeBuild {
             cmake {
@@ -48,7 +51,9 @@ android {
                           // JNI build currently (lack of lto linking support).
                           // This file should be removed and use the one from Android SDK cmake package when it supports lto.
                         "-DCMAKE_TOOLCHAIN_FILE=${project.file('src/main/cpp/android.toolchain.cmake').path}"
-                if (!project.hasProperty('android.injected.build.abi') && project.hasProperty('buildTargetABIs')) {
+                if (project.ccachePath) arguments "-DNDK_CCACHE=$project.ccachePath"
+                if (project.lcachePath) arguments "-DNDK_LCACHE=$project.lcachePath"
+                if (project.hasProperty('buildTargetABIs')) {
                     abiFilters(*project.getProperty('buildTargetABIs').trim().split('\\s*,\\s*'))
                 } else {
                     // armeabi is not supported anymore.
@@ -74,6 +79,9 @@ android {
         androidTest {
             java.srcDirs += 'src/benchmarks/java'
         }
+        androidTestObjectServer {
+            java.srcDirs += 'src/syncIntegrationTest/java'
+        }
     }
 
     packagingOptions {
@@ -84,8 +92,26 @@ android {
     lintOptions {
         abortOnError false
     }
-}
 
+    productFlavors {
+        base {
+            externalNativeBuild {
+                cmake {
+                    arguments "-DREALM_FLAVOR=base"
+                }
+            }
+            consumerProguardFiles 'proguard-rules-common.pro', 'proguard-rules-base.pro'
+        }
+        objectServer {
+            externalNativeBuild {
+                cmake {
+                    arguments "-DREALM_FLAVOR=objectServer"
+                }
+            }
+            consumerProguardFiles 'proguard-rules-common.pro', 'proguard-rules-objectServer.pro'
+        }
+    }
+}
 
 coveralls.jacocoReportPath = "${buildDir}/reports/coverage/debug/report.xml"
 
@@ -100,8 +126,8 @@ repositories {
 dependencies {
     provided 'io.reactivex:rxjava:1.1.0'
     compile "io.realm:realm-annotations:${version}"
-    compile 'com.getkeepsafe.relinker:relinker:1.2.1'
-
+    compile 'com.getkeepsafe.relinker:relinker:1.2.2'
+    objectServerCompile 'com.squareup.okhttp3:okhttp:3.4.1'
     androidTestCompile 'io.reactivex:rxjava:1.1.0'
     androidTestCompile 'com.android.support:support-annotations:24.0.0'
     androidTestCompile 'com.android.support.test:runner:0.5'
@@ -110,16 +136,22 @@ dependencies {
     androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'
     androidTestCompile 'com.opencsv:opencsv:3.4'
     androidTestCompile 'dk.ilios:spanner:0.6.0'
-
     androidTestApt project(':realm-annotations-processor')
 }
 
 task sourcesJar(type: Jar) {
+    from android.sourceSets.objectServer.java.srcDirs
     from android.sourceSets.main.java.srcDirs
     classifier = 'sources'
 }
 
+def betaTag = 'Beta:a:<div style="border-style:solid;border-width:2px">This software is considered in beta phase. ' +
+        'It indicates that any public interface can change without prior announcements. ' +
+        'Moreover, classes, constructors, and methods annotated as beta are not ' +
+        'considered at production quality, and should be used with care.</div>'
+
 task javadoc(type: Javadoc) {
+    source android.sourceSets.objectServer.java.srcDirs
     source android.sourceSets.main.java.srcDirs
     source "../../realm-annotations/src/main/java"
     classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
@@ -135,6 +167,8 @@ task javadoc(type: Javadoc) {
         links "https://docs.oracle.com/javase/7/docs/api/"
         links "http://reactivex.io/RxJava/javadoc/"
         linksOffline "https://developer.android.com/reference/", "${project.android.sdkDirectory}/docs/reference"
+
+        tags = [ betaTag ]
     }
     exclude '**/internal/**'
     exclude '**/BuildConfig.java'
@@ -180,7 +214,6 @@ task pmd(type: Pmd) {
 
     source = fileTree('src/main/java')
     ruleSetFiles = files("${projectDir}/../config/pmd/ruleset.xml")
-    ruleSets = [] // This needs to be here to remove the default checks
 
     reports {
         xml.enabled = false
@@ -257,25 +290,70 @@ install {
     }
 }
 
-bintray {
-    user = project.hasProperty('bintrayUser') ? bintrayUser : 'noUser'
-    key = project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
+// The publications doesn't know about our AAR dependencies, so we have to manually add them to the pom
+// Credit: http://stackoverflow.com/questions/24743562/gradle-not-including-dependencies-in-published-pom-xml
+def createPomDependencies(configurationNames) {
+    return {
+        def dependenciesNode = asNode().appendNode('dependencies')
+        configurationNames.each { configurationName ->
+            configurations[configurationName].allDependencies.each {
+                if (it.group != null && it.name != null) {
+                    def dependencyNode = dependenciesNode.appendNode('dependency')
+                    dependencyNode.appendNode('groupId', it.group)
+                    dependencyNode.appendNode('artifactId', it.name)
+                    dependencyNode.appendNode('version', it.version)
+
+                    //If there are any exclusions in dependency
+                    if (it.excludeRules.size() > 0) {
+                        def exclusionsNode = dependencyNode.appendNode('exclusions')
+                        it.excludeRules.each { rule ->
+                            def exclusionNode = exclusionsNode.appendNode('exclusion')
+                            exclusionNode.appendNode('groupId', rule.group)
+                            exclusionNode.appendNode('artifactId', rule.module)
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
 
-    dryRun = false
-    publish = false
+publishing {
+    publications {
+        basePublication(MavenPublication) {
+            groupId 'io.realm'
+            artifactId 'realm-android-library'
+            version project.version
+            artifact file("${rootDir}/realm-library/build/outputs/aar/realm-android-library-base-release.aar")
+            artifact sourcesJar
+            artifact javadocJar
+
+            pom.withXml(createPomDependencies(["baseCompile", "compile"]))
+        }
 
-    configurations = ['archives']
+        objectServerPublication(MavenPublication) {
+            groupId 'io.realm'
+            artifactId 'realm-android-library-object-server'
+            version project.version
+            artifact file("${rootDir}/realm-library/build/outputs/aar/realm-android-library-objectServer-release.aar")
+            artifact sourcesJar
+            artifact javadocJar
 
-    pkg {
-        repo = 'maven'
-        name = 'realm-android-library'
-        desc = 'Realm for Android'
-        websiteUrl = 'http://realm.io'
-        issueTrackerUrl = 'https://github.com/realm/realm-java/issues'
-        vcsUrl = 'https://github.com/realm/realm-java.git'
-        licenses = ['Apache-2.0']
-        labels = ['android', 'realm']
-        publicDownloadNumbers = false
+            pom.withXml(createPomDependencies(["objectServerCompile", "compile"]))
+        }
+    }
+    repositories {
+        maven {
+            credentials(AwsCredentials) {
+                accessKey project.hasProperty('s3AccessKey') ? s3AccessKey : 'noAccessKey'
+                secretKey project.hasProperty('s3SecretKey') ? s3SecretKey : 'noSecretKey'
+            }
+            if(project.version.endsWith('-SNAPSHOT')) {
+                url "s3://realm-ci-artifacts/maven/snapshots/"
+            } else {
+                url "s3://realm-ci-artifacts/maven/releases/"
+            }
+        }
     }
 }
 
@@ -289,7 +367,7 @@ artifactory {
             maven = true
         }
         defaults {
-            publishConfigs('archives')
+            publishConfigs('basePublication', 'objectServerPublication')
             publishPom = true
             publishIvy = false
         }
@@ -304,13 +382,15 @@ artifacts {
 
 def coreDownloaded = false
 
-task downloadCore(group: 'build setup', description: 'Download the latest version of Realm Core') {
+task downloadCore() {
+    group = 'build setup'
+    description = 'Download the latest version of Realm Core'
     def isHashCheckingEnabled = {
         return project.hasProperty('coreSha256Hash') && !project.coreSha256Hash.empty
     }
 
     def calcSha256Hash = {File targetFile ->
-        MessageDigest sha = MessageDigest.getInstance("SHA-256");
+        MessageDigest sha = MessageDigest.getInstance("SHA-256")
         Formatter hexHash = new Formatter()
         sha.digest(targetFile.bytes).each { b -> hexHash.format('%02x', b) }
         return hexHash.toString()
@@ -341,7 +421,7 @@ task downloadCore(group: 'build setup', description: 'Download the latest versio
     doLast {
         if (shouldDownloadCore()) {
             download {
-                src "http://static.realm.io/downloads/core/realm-core-android-${project.coreVersion}.tar.gz"
+                src "http://static.realm.io/downloads/sync/realm-sync-android-${project.coreVersion}.tar.gz"
                 dest project.coreArchiveFile
                 onlyIfNewer false
             }
@@ -383,7 +463,7 @@ task compileCore(group: 'build setup', description: 'Compile the core library fr
         copy {
             from "${coreSourcePath}/realm-core-android-${coreVersion}.tar.gz"
             into project.coreArchiveFile.parent
-            rename "realm-core-android-${coreVersion}.tar.gz", "core-android-${coreVersion}.tar.gz"
+            rename "realm-core-android-${coreVersion}.tar.gz", "realm-sync-android-${coreVersion}.tar.gz"
         }
     }
 }
@@ -418,6 +498,7 @@ task deployCore(group: 'build setup', description: 'Deploy the latest version of
     }
 }
 
+publishToMavenLocal.dependsOn assemble
 preBuild.dependsOn deployCore
 
 if (project.hasProperty('dontCleanJniFiles')) {
@@ -429,13 +510,10 @@ if (project.hasProperty('dontCleanJniFiles')) {
         }
     }
 } else {
-    task cleanJniHeaders(type: Delete) {
-        delete project.file('src/main/cpp/jni_include')
-    }
-    clean.dependsOn cleanJniHeaders
-
     task cleanExternalBuildFiles(type: Delete) {
         delete project.file('.externalNativeBuild')
+        // Clean .so files that were created by old build script (realm/realm-jni/build.gradle).
+        delete project.file('src/main/jniLibs')
     }
     clean.dependsOn cleanExternalBuildFiles
 }
@@ -472,6 +550,150 @@ task checkNdk() << {
     }
 }
 
+android.productFlavors.all { flavor ->
+    def librarySuffix = flavor.name == 'base' ? '' : '-object-server'
+    def userName = project.findProperty('bintrayUser') ?: 'noUser'
+    def accessKey = project.findProperty('bintrayKey') ?: 'noKey'
+
+    // BINTRAY
+
+    task("bintrayAar${flavor.name.capitalize()}", type: Exec) {
+        dependsOn "assemble${flavor.name.capitalize()}"
+        group = 'Publishing'
+        commandLine 'curl',
+            '-X',
+            'PUT',
+            '-T',
+            "${buildDir}/outputs/aar/realm-android-library-${flavor.name}-release.aar",
+            '-u',
+            "${userName}:${accessKey}",
+            "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.aar?publish=0"
+    }
+
+    task("bintraySources${flavor.name.capitalize()}", type: Exec) {
+        dependsOn sourcesJar
+        group = 'Publishing'
+        commandLine 'curl',
+            '-X',
+            'PUT',
+            '-T',
+            "${buildDir}/libs/realm-android-library-${project.version}-sources.jar",
+            '-u',
+            "${userName}:${accessKey}",
+            "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-sources.jar?publish=0"
+    }
+
+    task("bintrayJavadoc${flavor.name.capitalize()}", type: Exec) {
+        dependsOn javadocJar
+        group = 'Publishing'
+        commandLine 'curl',
+            '-X',
+            'PUT',
+            '-T',
+            "${buildDir}/libs/realm-android-library-${project.version}-javadoc.jar",
+            '-u',
+            "${userName}:${accessKey}",
+            "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-javadoc.jar?publish=0"
+    }
+
+    task("bintrayPom${flavor.name.capitalize()}", type: Exec) {
+        dependsOn "publish${flavor.name.capitalize()}PublicationPublicationToMavenLocal"
+        group = 'Publishing'
+        commandLine 'curl',
+            '-X',
+            'PUT',
+            '-T',
+            "${buildDir}/publications/${flavor.name}Publication/pom-default.xml",
+            '-u',
+            "${userName}:${accessKey}",
+            "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.pom?publish=0"
+    }
+
+    // OJO
+
+    task("ojoAar${flavor.name.capitalize()}", type: Exec) {
+        dependsOn "assemble${flavor.name.capitalize()}"
+        group = 'Publishing'
+        commandLine 'curl',
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/outputs/aar/realm-android-library-${flavor.name}-release.aar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://oss.jfrog.org/artifactory/oss-snapshot-local/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.aar?publish=0"
+    }
+
+    task("ojoSources${flavor.name.capitalize()}", type: Exec) {
+        dependsOn sourcesJar
+        group = 'Publishing'
+        commandLine 'curl',
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/libs/realm-android-library-${project.version}-sources.jar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://oss.jfrog.org/artifactory/oss-snapshot-local/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-sources.jar?publish=0"
+    }
+
+    task("ojoJavadoc${flavor.name.capitalize()}", type: Exec) {
+        dependsOn javadocJar
+        group = 'Publishing'
+        commandLine 'curl',
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/libs/realm-android-library-${project.version}-javadoc.jar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://oss.jfrog.org/artifactory/oss-snapshot-local/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-javadoc.jar?publish=0"
+    }
+
+    task("ojoPom${flavor.name.capitalize()}", type: Exec) {
+        dependsOn "publish${flavor.name.capitalize()}PublicationPublicationToMavenLocal"
+        group = 'Publishing'
+        commandLine 'curl',
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/publications/${flavor.name}Publication/pom-default.xml",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://oss.jfrog.org/artifactory/oss-snapshot-local/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.pom?publish=0"
+    }
+
+    task("bintray${flavor.name.capitalize()}") {
+        dependsOn "bintrayAar${flavor.name.capitalize()}"
+        dependsOn "bintraySources${flavor.name.capitalize()}"
+        dependsOn "bintrayJavadoc${flavor.name.capitalize()}"
+        dependsOn "bintrayPom${flavor.name.capitalize()}"
+        group = 'Publishing'
+    }
+
+    task("ojo${flavor.name.capitalize()}") {
+        dependsOn "ojoAar${flavor.name.capitalize()}"
+        dependsOn "ojoSources${flavor.name.capitalize()}"
+        dependsOn "ojoJavadoc${flavor.name.capitalize()}"
+        dependsOn "ojoPom${flavor.name.capitalize()}"
+        group = 'Publishing'
+    }
+}
+
+task bintrayUpload() {
+    android.productFlavors.all { flavor ->
+        dependsOn "bintray${flavor.name.capitalize()}"
+    }
+    group = 'Publishing'
+}
+
+task ojoUpload() {
+    android.productFlavors.all { flavor ->
+        dependsOn "ojo${flavor.name.capitalize()}"
+    }
+    group = 'Publishing'
+}
+
 def checkNdk(String ndkPath) {
     def detectedNdkVersion
     def releaseFile = new File(ndkPath, 'RELEASE.TXT')
diff --git a/realm/realm-library/proguard-rules-base.pro b/realm/realm-library/proguard-rules-base.pro
new file mode 100644
index 0000000000..26e41702f8
--- /dev/null
+++ b/realm/realm-library/proguard-rules-base.pro
@@ -0,0 +1,2 @@
+# It's OK not to exist SyncObjectServerFacade in base library.
+-dontnote io.realm.internal.objectserver.SyncObjectServerFacade
diff --git a/realm/realm-library/proguard-rules-common.pro b/realm/realm-library/proguard-rules-common.pro
new file mode 100644
index 0000000000..e4bb7abb4f
--- /dev/null
+++ b/realm/realm-library/proguard-rules-common.pro
@@ -0,0 +1,18 @@
+-keep class io.realm.annotations.RealmModule
+-keep @io.realm.annotations.RealmModule class *
+
+-keep class io.realm.internal.Keep
+-keep,includedescriptorclasses @io.realm.internal.Keep class * { *; }
+
+-keep class io.realm.internal.KeepMember
+-keep,includedescriptorclasses @io.realm.internal.KeepMember class * { @io.realm.internal.KeepMember *; }
+
+-dontwarn javax.**
+-dontwarn io.realm.**
+-keep class io.realm.RealmCollection
+-keep class io.realm.OrderedRealmCollection
+-keepclasseswithmembernames,includedescriptorclasses class io.realm.** {
+    native <methods>;
+}
+
+-dontnote rx.Observable
\ No newline at end of file
diff --git a/realm/realm-library/proguard-rules-objectServer.pro b/realm/realm-library/proguard-rules-objectServer.pro
new file mode 100644
index 0000000000..d4b249abb8
--- /dev/null
+++ b/realm/realm-library/proguard-rules-objectServer.pro
@@ -0,0 +1,7 @@
+-dontnote android.security.KeyStore
+-dontwarn okio.Okio
+-dontwarn okio.DeflaterSink
+
+-dontnote com.android.org.conscrypt.SSLParametersImpl
+-dontnote org.apache.harmony.xnet.provider.jsse.SSLParametersImpl
+-dontnote sun.security.ssl.SSLContextImpl
diff --git a/realm/realm-library/proguard-rules.pro b/realm/realm-library/proguard-rules.pro
deleted file mode 100644
index 2ad1784f1a..0000000000
--- a/realm/realm-library/proguard-rules.pro
+++ /dev/null
@@ -1,11 +0,0 @@
--keep class io.realm.annotations.RealmModule
--keep @io.realm.annotations.RealmModule class *
--keep class io.realm.internal.Keep
--keep @io.realm.internal.Keep class * { *; }
--dontwarn javax.**
--dontwarn io.realm.**
--keep class io.realm.RealmCollection
--keep class io.realm.OrderedRealmCollection
--keepclasseswithmembernames class io.realm.internal.** {
-    native <methods>;
-}
diff --git a/realm/realm-library/src/androidTest/AndroidManifest.xml b/realm/realm-library/src/androidTest/AndroidManifest.xml
index 357f8f7ef8..a44988ce92 100644
--- a/realm/realm-library/src/androidTest/AndroidManifest.xml
+++ b/realm/realm-library/src/androidTest/AndroidManifest.xml
@@ -3,6 +3,8 @@
           xmlns:android="http://schemas.android.com/apk/res/android"
           xmlns:tools="http://schemas.android.com/tools">
 
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
index 14c9e278bb..9386beb7cb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
@@ -151,7 +151,12 @@ public void typedGetter_illegalFieldNameThrows() {
             // of failing values. Only difference is the wrong type column has to be different.
             List<String> args = (type == SupportedType.STRING) ? stringArguments : arguments;
             try {
-                callGetter(type, args);
+                callGetter(dObjTyped, type, args);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            try {
+                callGetter(dObjDynamic, type, args);
                 fail();
             } catch (IllegalArgumentException ignored) {
             }
@@ -164,9 +169,19 @@ public void typedGetter_wrongUnderlyingTypeThrows() {
             try {
                 // Make sure we hit the wrong underlying type for all types.
                 if (type == SupportedType.DOUBLE) {
-                    callGetter(type, Arrays.asList(AllJavaTypes.FIELD_STRING));
+                    callGetter(dObjTyped, type, Arrays.asList(AllJavaTypes.FIELD_STRING));
+                } else {
+                    callGetter(dObjTyped, type, Arrays.asList(AllJavaTypes.FIELD_DOUBLE));
+                }
+                fail(type + " failed to throw.");
+            } catch (IllegalArgumentException ignored) {
+            }
+            try {
+                // Make sure we hit the wrong underlying type for all types.
+                if (type == SupportedType.DOUBLE) {
+                    callGetter(dObjDynamic, type, Arrays.asList(AllJavaTypes.FIELD_STRING));
                 } else {
-                    callGetter(type, Arrays.asList(AllJavaTypes.FIELD_DOUBLE));
+                    callGetter(dObjDynamic, type, Arrays.asList(AllJavaTypes.FIELD_DOUBLE));
                 }
                 fail(type + " failed to throw.");
             } catch (IllegalArgumentException ignored) {
@@ -175,21 +190,21 @@ public void typedGetter_wrongUnderlyingTypeThrows() {
     }
 
     // Helper method for calling getters with different field names
-    private void callGetter(SupportedType type, List<String> fieldNames) {
+    private static void callGetter(DynamicRealmObject target, SupportedType type, List<String> fieldNames) {
         for (String fieldName : fieldNames) {
             switch (type) {
-                case BOOLEAN: dObjTyped.getBoolean(fieldName); break;
-                case SHORT: dObjTyped.getShort(fieldName); break;
-                case INT: dObjTyped.getInt(fieldName); break;
-                case LONG: dObjTyped.getLong(fieldName); break;
-                case BYTE: dObjTyped.getByte(fieldName); break;
-                case FLOAT: dObjTyped.getFloat(fieldName); break;
-                case DOUBLE: dObjTyped.getDouble(fieldName); break;
-                case STRING: dObjTyped.getString(fieldName); break;
-                case BINARY: dObjTyped.getBlob(fieldName); break;
-                case DATE: dObjTyped.getDate(fieldName); break;
-                case OBJECT: dObjTyped.getObject(fieldName); break;
-                case LIST: dObjTyped.getList(fieldName); break;
+                case BOOLEAN: target.getBoolean(fieldName); break;
+                case SHORT: target.getShort(fieldName); break;
+                case INT: target.getInt(fieldName); break;
+                case LONG: target.getLong(fieldName); break;
+                case BYTE: target.getByte(fieldName); break;
+                case FLOAT: target.getFloat(fieldName); break;
+                case DOUBLE: target.getDouble(fieldName); break;
+                case STRING: target.getString(fieldName); break;
+                case BINARY: target.getBlob(fieldName); break;
+                case DATE: target.getDate(fieldName); break;
+                case OBJECT: target.getObject(fieldName); break;
+                case LIST: target.getList(fieldName); break;
                 default:
                     fail();
             }
@@ -209,7 +224,12 @@ public void typedSetter_illegalFieldNameThrows() {
         for (SupportedType type : SupportedType.values()) {
             List<String> args = (type == SupportedType.STRING) ? stringArguments : arguments;
             try {
-                callSetter(type, args);
+                callSetter(dObjTyped, type, args);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            try {
+                callSetter(dObjDynamic, type, args);
                 fail();
             } catch (IllegalArgumentException ignored) {
             }
@@ -223,15 +243,28 @@ public void typedSetter_wrongUnderlyingTypeThrows() {
             try {
                 // Make sure we hit the wrong underlying type for all types.
                 if (type == SupportedType.STRING) {
-                    callSetter(type, Arrays.asList(AllJavaTypes.FIELD_BOOLEAN));
+                    callSetter(dObjTyped, type, Arrays.asList(AllJavaTypes.FIELD_BOOLEAN));
                 } else {
-                    callSetter(type, Arrays.asList(AllJavaTypes.FIELD_STRING));
+                    callSetter(dObjTyped, type, Arrays.asList(AllJavaTypes.FIELD_STRING));
                 }
                 fail();
             } catch (IllegalArgumentException ignored) {
             } finally {
                 realm.cancelTransaction();
             }
+            dynamicRealm.beginTransaction();
+            try {
+                // Make sure we hit the wrong underlying type for all types.
+                if (type == SupportedType.STRING) {
+                    callSetter(dObjDynamic, type, Arrays.asList(AllJavaTypes.FIELD_BOOLEAN));
+                } else {
+                    callSetter(dObjDynamic, type, Arrays.asList(AllJavaTypes.FIELD_STRING));
+                }
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            } finally {
+                dynamicRealm.cancelTransaction();
+            }
         }
     }
 
@@ -280,21 +313,21 @@ public void typedSetter_changePrimaryKeyThrows() {
     }
 
     // Helper method for calling setters with different field names
-    private void callSetter(SupportedType type, List<String> fieldNames) {
+    private static void callSetter(DynamicRealmObject target, SupportedType type, List<String> fieldNames) {
         for (String fieldName : fieldNames) {
             switch (type) {
-                case BOOLEAN: dObjTyped.setBoolean(fieldName, false); break;
-                case SHORT: dObjTyped.setShort(fieldName, (short) 1); break;
-                case INT: dObjTyped.setInt(fieldName, 1); break;
-                case LONG: dObjTyped.setLong(fieldName, 1L); break;
-                case BYTE: dObjTyped.setByte(fieldName, (byte) 4); break;
-                case FLOAT: dObjTyped.setFloat(fieldName, 1.23f); break;
-                case DOUBLE: dObjTyped.setDouble(fieldName, 1.23d); break;
-                case STRING: dObjTyped.setString(fieldName, "foo"); break;
-                case BINARY: dObjTyped.setBlob(fieldName, new byte[]{}); break;
-                case DATE: dObjTyped.getDate(fieldName); break;
-                case OBJECT: dObjTyped.setObject(fieldName, null); break;
-                case LIST: dObjTyped.setList(fieldName, null); break;
+                case BOOLEAN: target.setBoolean(fieldName, false); break;
+                case SHORT: target.setShort(fieldName, (short) 1); break;
+                case INT: target.setInt(fieldName, 1); break;
+                case LONG: target.setLong(fieldName, 1L); break;
+                case BYTE: target.setByte(fieldName, (byte) 4); break;
+                case FLOAT: target.setFloat(fieldName, 1.23f); break;
+                case DOUBLE: target.setDouble(fieldName, 1.23d); break;
+                case STRING: target.setString(fieldName, "foo"); break;
+                case BINARY: target.setBlob(fieldName, new byte[]{}); break;
+                case DATE: target.getDate(fieldName); break;
+                case OBJECT: target.setObject(fieldName, null); target.setObject(fieldName, target); break;
+                case LIST: target.setList(fieldName, new RealmList<DynamicRealmObject>()); break;
                 default:
                     fail();
             }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index 9821c20c12..cca89c96ca 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -382,6 +382,7 @@ public void onChange(RealmResults<DynamicRealmObject> object) {
                 looperThread.testComplete();
             }
         });
+        looperThread.keepStrongReference.add(allTypes);
     }
 
     @Test
@@ -406,6 +407,7 @@ public void onChange(RealmResults<DynamicRealmObject> object) {
                 looperThread.testComplete();
             }
         });
+        looperThread.keepStrongReference.add(allTypes);
     }
 
     // Initialize a Dynamic Realm used by the *Async tests and keep it ref in the looperThread.
@@ -522,6 +524,8 @@ public void onChange(RealmResults<DynamicRealmObject> object) {
                 signalCallbackDone.run();
             }
         });
+        looperThread.keepStrongReference.add(realmResults1);
+        looperThread.keepStrongReference.add(realmResults2);
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
index 90625fc4f8..0a8979656f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
@@ -47,7 +47,8 @@
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.Dog;
-import io.realm.log.Logger;
+import io.realm.log.LogLevel;
+import io.realm.log.RealmLogger;
 import io.realm.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
@@ -647,7 +648,7 @@ public void run() {
         // Create a commit on another thread
         TestHelper.awaitOrFail(backgroundLooperStartedAndStopped);
         Realm realm = Realm.getInstance(realmConfig);
-        Logger logger = TestHelper.getFailureLogger(Log.WARN);
+        RealmLogger logger = TestHelper.getFailureLogger(Log.WARN);
         RealmLog.add(logger);
 
         realm.beginTransaction();
@@ -1180,9 +1181,11 @@ public void warnIfMixingSyncWritesAndAsyncQueries() {
         final AtomicBoolean warningLogged = new AtomicBoolean(false);
         final TestHelper.TestLogger testLogger = new TestHelper.TestLogger() {
             @Override
-            public void warn(Throwable t, String message, Object... args) {
+            public void log(int level, String tag, Throwable throwable, String message) {
                 assertTrue(message.contains("Mixing asynchronous queries with local writes should be avoided."));
-                warningLogged.set(true);
+                if (level == LogLevel.WARN) {
+                    warningLogged.set(true);
+                }
             }
         };
         RealmLog.add(testLogger);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
index 4d4665e4d7..8bee6afa70 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
@@ -220,6 +220,14 @@ public void first_emptyCollection() {
         }
     }
 
+    @Test
+    public void first_withDefault() {
+        AllJavaTypes defaultObject = new AllJavaTypes();
+        collection = createEmptyCollection(realm, collectionClass);
+        assertEquals(defaultObject, collection.first(defaultObject));
+        assertEquals(null, collection.first(null)); // Null is an acceptable default
+    }
+
     @Test
     public void last() {
         assertEquals(collection.get(TEST_SIZE - 1), collection.last());
@@ -235,6 +243,14 @@ public void last_emptyCollection() {
         }
     }
 
+    @Test
+    public void last_withDefault() {
+        AllJavaTypes defaultObject = new AllJavaTypes();
+        collection = createEmptyCollection(realm, collectionClass);
+        assertEquals(defaultObject, collection.last(defaultObject));
+        assertEquals(null, collection.last(null)); // Null is an acceptable default
+    }
+
     @Test
     public void get_validIndex() {
         AllJavaTypes first = collection.get(0);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index dc17dab814..9375d6efd8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -424,6 +424,7 @@ public void onChange(RealmResults<AllTypes> object) {
                 looperThread.testComplete();
             }
         });
+        looperThread.keepStrongReference.add(results);
 
         assertFalse(results.isLoaded());
         assertEquals(0, results.size());
@@ -1620,6 +1621,31 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
         });
     }
 
+    @Test
+    @RunTestInLooperThread()
+    public void distinctAsync_rememberQueryParams() {
+        final Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        final int TEST_SIZE = 10;
+        for (int i = 0; i < TEST_SIZE; i++) {
+            realm.createObject(AllJavaTypes.class, i);
+        }
+        realm.commitTransaction();
+
+        RealmResults<AllJavaTypes> results = realm.where(AllJavaTypes.class)
+                .notEqualTo(AllJavaTypes.FIELD_ID, TEST_SIZE / 2)
+                .distinctAsync(AllJavaTypes.FIELD_ID);
+
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllJavaTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllJavaTypes> results) {
+                assertEquals(TEST_SIZE - 1, results.size());
+                assertEquals(0, results.where().equalTo(AllJavaTypes.FIELD_ID, TEST_SIZE / 2).count());
+                looperThread.testComplete();
+            }
+        });
+    }
+
     @Test
     @RunTestInLooperThread
     public void distinctAsync_notIndexedFields() throws Throwable {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index effdab153d..2763ab5b16 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -389,7 +389,9 @@ public void upgradeVersionWithNoMigration() {
                     .schemaVersion(42)
                     .build());
             fail();
-        } catch (RealmMigrationNeededException ignored) {
+        } catch (RealmMigrationNeededException expected) {
+            // And it should come with a cause.
+            assertNotNull(expected.getCause());
         }
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmLogTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmLogTests.java
new file mode 100644
index 0000000000..e91ae3ba16
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmLogTests.java
@@ -0,0 +1,156 @@
+package io.realm;
+
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.log.LogLevel;
+import io.realm.log.Logger;
+import io.realm.log.RealmLog;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNull;
+import static junit.framework.Assert.assertTrue;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmLogTests {
+
+    @Before
+    public void setUp() {
+        Realm.init(InstrumentationRegistry.getTargetContext());
+    }
+
+    @Test
+    public void add_remove() {
+        TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
+        RealmLog.add(testLogger);
+        RealmLog.fatal("TEST");
+        assertEquals("TEST", testLogger.message);
+        RealmLog.remove(testLogger);
+        RealmLog.fatal("TEST_AGAIN");
+        assertEquals("TEST", testLogger.message);
+    }
+
+    @Test
+    public void set_get_logLevel() {
+        TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
+        RealmLog.add(testLogger);
+
+        RealmLog.setLevel(LogLevel.FATAL);
+        assertEquals(LogLevel.FATAL, RealmLog.getLevel());
+        RealmLog.debug("TEST_DEBUG");
+        assertNull(testLogger.message);
+
+        RealmLog.setLevel(LogLevel.DEBUG);
+        RealmLog.debug("TEST_DEBUG");
+        assertEquals("TEST_DEBUG", testLogger.message);
+        RealmLog.fatal("TEST_FATAL");
+        assertEquals("TEST_FATAL", testLogger.message);
+
+        RealmLog.remove(testLogger);
+    }
+
+    @Test
+    public void clear() {
+        TestHelper.TestLogger testLogger1 = new TestHelper.TestLogger();
+        TestHelper.TestLogger testLogger2 = new TestHelper.TestLogger();
+        RealmLog.add(testLogger1);
+        RealmLog.add(testLogger2);
+        RealmLog.fatal("TEST");
+
+        assertEquals("TEST", testLogger1.message);
+        assertEquals("TEST", testLogger2.message);
+
+        RealmLog.clear();
+
+        RealmLog.fatal("TEST_AGAIN");
+        assertEquals("TEST", testLogger1.message);
+        assertEquals("TEST", testLogger2.message);
+
+        RealmLog.registerDefaultLogger();
+    }
+
+    @Test
+    public void throwable_passedToTheJavaLogger() {
+        TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
+        RealmLog.add(testLogger);
+        Throwable throwable;
+
+        try {
+            throw new RuntimeException("Test exception.");
+        } catch (RuntimeException e) {
+            throwable = e;
+            RealmLog.fatal(e);
+        }
+
+        // Throwable has been passed.
+        assertEquals(throwable, testLogger.throwable);
+        // Message is the stacktrace.
+        assertTrue(testLogger.message.contains("RealmLogTests.java"));
+        RealmLog.remove(testLogger);
+    }
+
+    static class TestOldLogger implements Logger {
+        String message;
+        Throwable throwable;
+
+        @Override
+        public int getMinimumNativeDebugLevel() {
+            return 0;
+        }
+
+        @Override
+        public void trace(Throwable throwable, String message, Object... args) {
+        }
+
+        @Override
+        public void debug(Throwable throwable, String message, Object... args) {
+        }
+
+        @Override
+        public void info(Throwable throwable, String message, Object... args) {
+        }
+
+        @Override
+        public void warn(Throwable throwable, String message, Object... args) {
+        }
+
+        @Override
+        public void error(Throwable throwable, String message, Object... args) {
+        }
+
+        @Override
+        public void fatal(Throwable throwable, String message, Object... args) {
+            this.throwable = throwable;
+            this.message = message;
+        }
+    }
+
+    @Test
+    public void loggerAdaptor() {
+        TestOldLogger testLogger = new TestOldLogger();
+        RealmLog.add(testLogger);
+        Throwable throwable;
+
+        try {
+            throw new RuntimeException("Test exception.");
+        } catch (RuntimeException e) {
+            throwable = e;
+            RealmLog.fatal(e);
+        }
+
+        // Throwable has been passed.
+        assertEquals(throwable, testLogger.throwable);
+        assertTrue(testLogger.message.contains("RealmLogTests.java"));
+
+        RealmLog.remove(testLogger);
+        RealmLog.fatal("new string");
+
+        // Logger has been removed, nothing should be changed.
+        assertEquals(throwable, testLogger.throwable);
+        assertTrue(testLogger.message.contains("RealmLogTests.java"));
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 9f44948320..5c570e7df7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -31,6 +31,7 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.junit.After;
+import org.junit.Assume;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
@@ -65,6 +66,7 @@
 import io.realm.entities.CyclicTypePrimaryKey;
 import io.realm.entities.DefaultValueConstructor;
 import io.realm.entities.DefaultValueOfField;
+import io.realm.entities.DefaultValueOverwriteNullLink;
 import io.realm.entities.DefaultValueSetter;
 import io.realm.entities.Dog;
 import io.realm.entities.DogPrimaryKey;
@@ -981,27 +983,26 @@ public void compactRealm_encryptedEmptyRealm() {
         RealmConfiguration realmConfig = configFactory.createConfiguration("enc.realm", TestHelper.getRandomKey());
         Realm realm = Realm.getInstance(realmConfig);
         realm.close();
-        // TODO: remove try/catch block when compacting encrypted Realms is supported
-        try {
-            assertTrue(Realm.compactRealm(realmConfig));
-            fail();
-        } catch (IllegalArgumentException expected) {
-        }
+        assertTrue(Realm.compactRealm(realmConfig));
+        realm = Realm.getInstance(realmConfig);
+        assertFalse(realm.isClosed());
+        assertTrue(realm.isEmpty());
+        realm.close();
     }
 
     @Test
     public void compactRealm_encryptedPopulatedRealm() {
+        final int DATA_SIZE = 100;
         RealmConfiguration realmConfig = configFactory.createConfiguration("enc.realm", TestHelper.getRandomKey());
         Realm realm = Realm.getInstance(realmConfig);
 
-        populateTestRealm(realm, 100);
+        populateTestRealm(realm, DATA_SIZE);
+        realm.close();
+        assertTrue(Realm.compactRealm(realmConfig));
+        realm = Realm.getInstance(realmConfig);
+        assertFalse(realm.isClosed());
+        assertEquals(DATA_SIZE, realm.where(AllTypes.class).count());
         realm.close();
-        // TODO: remove try/catch block when compacting encrypted Realms is supported
-        try {
-            assertTrue(Realm.compactRealm(realmConfig));
-            fail();
-        } catch (IllegalArgumentException expected) {
-        }
     }
 
     @Test
@@ -2330,6 +2331,16 @@ public void execute(Realm realm) {
                 RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
     }
 
+    @Test
+    public void createObject_overwriteNullifiedLinkWithDefaultValue() {
+        final DefaultValueOverwriteNullLink created;
+        realm.beginTransaction();
+        created = realm.createObject(DefaultValueOverwriteNullLink.class);
+        realm.commitTransaction();
+
+        assertEquals(created.getExpectedKeyOfFieldObject(), created.getFieldObject().getFieldRandomPrimaryKey());
+    }
+
     @Test
     public void createObject_defaultValueFromModelConstructor() {
         realm.executeTransaction(new Realm.Transaction() {
@@ -3747,4 +3758,92 @@ public void execute(Realm realm) {
         //noinspection ConstantConditions
         assertEquals("pochi", realm.where(Cat.class).findFirst().getName());
     }
+
+    @Test
+    public void getGlobalInstanceCount() {
+        final CountDownLatch bgDone = new CountDownLatch(1);
+
+        final RealmConfiguration config = configFactory.createConfiguration("globalCountTest");
+        assertEquals(0, Realm.getGlobalInstanceCount(config));
+
+        // Open thread local Realm
+        Realm realm = Realm.getInstance(config);
+        assertEquals(1, Realm.getGlobalInstanceCount(config));
+
+        // Open thread local DynamicRealm
+        DynamicRealm dynRealm = DynamicRealm.getInstance(config);
+        assertEquals(2, Realm.getGlobalInstanceCount(config));
+
+        // Open Realm in another thread
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(config);
+                assertEquals(3, Realm.getGlobalInstanceCount(config));
+                realm.close();
+                assertEquals(2, Realm.getGlobalInstanceCount(config));
+                bgDone.countDown();
+            }
+        }).start();
+
+        TestHelper.awaitOrFail(bgDone);
+        dynRealm.close();
+        assertEquals(1, Realm.getGlobalInstanceCount(config));
+        realm.close();
+        assertEquals(0, Realm.getGlobalInstanceCount(config));
+    }
+
+    @Test
+    public void getLocalInstanceCount() {
+        final RealmConfiguration config = configFactory.createConfiguration("localInstanceCount");
+        assertEquals(0, Realm.getGlobalInstanceCount(config));
+
+        // Open thread local Realm
+        Realm realm = Realm.getInstance(config);
+        assertEquals(1, Realm.getGlobalInstanceCount(config));
+
+        // Open thread local DynamicRealm
+        DynamicRealm dynRealm = DynamicRealm.getInstance(config);
+        assertEquals(2, Realm.getGlobalInstanceCount(config));
+
+        dynRealm.close();
+        assertEquals(1, Realm.getGlobalInstanceCount(config));
+        realm.close();
+        assertEquals(0, Realm.getGlobalInstanceCount(config));
+    }
+
+    @Test
+    public void namedPipeDirForExternalStorage() {
+
+        // test for https://github.com/realm/realm-java/issues/3140
+        realm.close();
+        realm = null;
+
+        final File namedPipeDir = SharedRealm.getTemporaryDirectory();
+        assertTrue(namedPipeDir.isDirectory());
+        TestHelper.deleteRecursively(namedPipeDir);
+        //noinspection ResultOfMethodCallIgnored
+        namedPipeDir.mkdirs();
+
+        final File externalFilesDir = context.getExternalFilesDir(null);
+        final RealmConfiguration config = new RealmConfiguration.Builder()
+                .directory(externalFilesDir)
+                .name("external.realm")
+                .build();
+        Realm.deleteRealm(config);
+
+        // test if it works when the namedPipeDir is empty.
+        Realm realmOnExternalStorage = Realm.getInstance(config);
+        realmOnExternalStorage.close();
+
+        assertTrue(namedPipeDir.isDirectory());
+
+        Assume.assumeTrue("SELinux is not enforced on this device.", TestHelper.isSelinuxEnforcing());
+
+        assertEquals(2, namedPipeDir.list().length);
+
+        // test if it works when the namedPipeDir and the named pipe files already exist.
+        realmOnExternalStorage = Realm.getInstance(config);
+        realmOnExternalStorage.close();
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index cade67abf7..321c5d927c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -18,6 +18,7 @@
 
 import android.content.Context;
 import android.content.res.AssetManager;
+import android.os.Build;
 import android.os.Looper;
 import android.support.test.InstrumentationRegistry;
 import android.util.Log;
@@ -38,6 +39,7 @@
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.Date;
+import java.util.Locale;
 import java.util.Random;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
@@ -57,14 +59,12 @@
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.async.RealmThreadPoolExecutor;
-import io.realm.log.AndroidLogger;
 import io.realm.log.LogLevel;
-import io.realm.log.Logger;
+import io.realm.log.RealmLogger;
 import io.realm.rule.TestRealmConfigurationFactory;
 
-import static android.R.id.message;
+import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.fail;
-import static org.junit.Assert.assertEquals;
 
 public class TestHelper {
 
@@ -169,50 +169,23 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     }
 
     /**
-     * Returns a Logger that will fail if it is asked to log a message above a certain level.
+     * Returns a RealmLogger that will fail if it is asked to log a message above a certain level.
      *
      * @param failureLevel {@link Log} level from which the unit test will fail.
-     * @return Logger implementation
+     * @return RealmLogger implementation
      */
-    public static Logger getFailureLogger(final int failureLevel) {
-        return new AndroidLogger(Log.VERBOSE) {
-
-            private void failIfEqualOrAbove(int logLevel, int failureLevel) {
+    public static RealmLogger getFailureLogger(final int failureLevel) {
+        return new RealmLogger() {
+            private void failIfEqualOrAbove(int logLevel) {
                 if (logLevel >= failureLevel) {
                     fail("Message logged that was above valid level: " + logLevel + " >= " + failureLevel);
                 }
             }
 
             @Override
-            public void trace(Throwable t, String message, Object... args) {
-                failIfEqualOrAbove(Log.VERBOSE, failureLevel);
-            }
-
-            @Override
-            public void debug(Throwable t, String message, Object... args) {
-                failIfEqualOrAbove(Log.DEBUG, failureLevel);
+            public void log(int level, String tag, Throwable throwable, String message) {
+                failIfEqualOrAbove(level);
             }
-
-            @Override
-            public void info(Throwable t, String message, Object... args) {
-                failIfEqualOrAbove(Log.INFO, failureLevel);
-            }
-
-            @Override
-            public void warn(Throwable t, String message, Object... args) {
-                failIfEqualOrAbove(Log.WARN, failureLevel);
-            }
-
-            @Override
-            public void error(Throwable t, String message, Object... args) {
-                failIfEqualOrAbove(Log.ERROR, failureLevel);
-            }
-
-            @Override
-            public void fatal(Throwable t, String message, Object... args) {
-                failIfEqualOrAbove(Log.ERROR, failureLevel);
-            }
-
         };
     }
 
@@ -228,7 +201,7 @@ public static String getRandomString(int length) {
     /**
      * Returns a naive logger that can be used to test the values that are sent to the logger.
      */
-    public static class TestLogger implements Logger {
+    public static class TestLogger implements RealmLogger {
 
         private final int minimumLevel;
         public String message;
@@ -243,53 +216,10 @@ public TestLogger(int minimumLevel) {
         }
 
         @Override
-        public int getMinimumNativeDebugLevel() {
-            return minimumLevel;
-        }
-
-        @Override
-        public void trace(Throwable t, String message, Object... args) {
-            if (minimumLevel <= LogLevel.TRACE) {
-                this.message = (message != null) ? String.format(message, args) : null;
-                this.throwable = t;
-            }
-        }
-
-        @Override
-        public void debug(Throwable t, String message, Object... args) {
-            if (minimumLevel <= LogLevel.DEBUG) {
-                this.message = (message != null) ? String.format(message, args) : null;
-                this.throwable = t;
-            }
-        }
-
-        @Override
-        public void info(Throwable t, String message, Object... args) {
-            if (minimumLevel <= LogLevel.INFO) {
-                this.message = (message != null) ? String.format(message, args) : null;
-                this.throwable = t;
-            }
-        }
-
-        @Override
-        public void warn(Throwable t, String message, Object... args) {
-            this.message = (message != null) ? String.format(message, args) : null;
-            this.throwable = t;
-        }
-
-        @Override
-        public void error(Throwable t, String message, Object... args) {
-            if (minimumLevel <= LogLevel.ERROR) {
-                this.message = (message != null) ? String.format(message, args) : null;
-                this.throwable = t;
-            }
-        }
-
-        @Override
-        public void fatal(Throwable t, String message, Object... args) {
-            if (minimumLevel <= LogLevel.FATAL) {
-                this.message = (message != null) ? String.format(message, args) : null;
-                this.throwable = t;
+        public void log(int level, String tag, Throwable throwable, String message) {
+            if (minimumLevel <= level) {
+                this.message = message;
+                this.throwable = throwable;
             }
         }
     }
@@ -1087,4 +1017,50 @@ public void run() {
             throw throwable;
         }
     }
+
+    @SuppressWarnings("WeakerAccess")
+    public static void deleteRecursively(File file) {
+        if (!file.exists()) {
+            return;
+        }
+        if (file.isDirectory()) {
+            for (File f : file.listFiles()) {
+                deleteRecursively(f);
+            }
+        }
+
+        if (!file.delete()) {
+            throw new AssertionError("failed to delete " + file.getAbsolutePath());
+        }
+    }
+
+    @SuppressWarnings("WeakerAccess")
+    public static boolean isSelinuxEnforcing() {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            // SELinux is not enabled for these versions.
+            return false;
+        }
+        try {
+            final Process process = new ProcessBuilder("/system/bin/getenforce").start();
+            try {
+                final BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
+                //noinspection TryFinallyCanBeTryWithResources
+                try {
+                    return reader.readLine().toLowerCase(Locale.ENGLISH).equals("enforcing");
+                } finally {
+                    try {
+                        reader.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+            } finally {
+                try {
+                    process.waitFor();
+                } catch (InterruptedException ignored) {
+                }
+            }
+        } catch (IOException e) {
+            return false;
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOverwriteNullLink.java b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOverwriteNullLink.java
new file mode 100644
index 0000000000..e6f673de3a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOverwriteNullLink.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import java.util.Date;
+import java.util.UUID;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.Ignore;
+import io.realm.annotations.PrimaryKey;
+
+public class DefaultValueOverwriteNullLink extends RealmObject {
+
+    public static final String CLASS_NAME = "DefaultValueOverwriteNullLink";
+    public static String FIELD_OBJECT = "fieldObject";
+    public static String EXPECTED_KEY_OF_FIELD_OBJECT = "expectedKeyOfFieldObject";
+
+    private RandomPrimaryKey fieldObject;
+    private String expectedKeyOfFieldObject;
+
+    public DefaultValueOverwriteNullLink() {
+        final RandomPrimaryKey firstDefaultValue = new RandomPrimaryKey();
+        final RandomPrimaryKey secondDefaultValue = new RandomPrimaryKey();
+
+        expectedKeyOfFieldObject = secondDefaultValue.getFieldRandomPrimaryKey();
+
+        fieldObject = firstDefaultValue;
+        fieldObject = null;
+        fieldObject = secondDefaultValue;
+    }
+
+    public RandomPrimaryKey getFieldObject() {
+        return fieldObject;
+    }
+
+    public void setFieldObject(RandomPrimaryKey fieldObject) {
+        this.fieldObject = fieldObject;
+    }
+
+    public String getExpectedKeyOfFieldObject() {
+        return expectedKeyOfFieldObject;
+    }
+
+    public void setExpectedKeyOfFieldObject(String expectedKeyOfFieldObject) {
+        this.expectedKeyOfFieldObject = expectedKeyOfFieldObject;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java
index d7c477cd7a..5cbffdd653 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java
@@ -18,7 +18,6 @@
 
 import android.test.AndroidTestCase;
 
-import io.realm.RealmFieldType;
 import io.realm.TestHelper;
 
 public class JNICloseTest extends AndroidTestCase {
@@ -30,14 +29,14 @@ public void testQueryAccessibleAfterTableClose() throws Throwable{
         Table table = TestHelper.getTableWithAllColumnTypes();
         table.addEmptyRows(10);
         for (long i=0; i<table.size(); i++)
-            table.setLong(5, i, i);
+            table.setLong(5, i, i, false);
         TableQuery query = table.where();
         // Closes the table, it _should_ be allowed to access the query thereafter
         Table.nativeClose(table.nativePtr);
         Table table2 = TestHelper.getTableWithAllColumnTypes();
         table2.addEmptyRows(10);
         for (int i=0; i<table2.size(); i++)
-            table2.setLong(5, i, 117+i);
+            table2.setLong(5, i, 117 + i, false);
 
         TableView tv = query.findAll();
         assertEquals(10, tv.size());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java
index c4b962149e..95499e8a4a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java
@@ -65,7 +65,7 @@ public void testLinkColumns() {
         table1.addColumnLink(RealmFieldType.OBJECT, "Link", table2);
 
         table1.addEmptyRow();
-        table1.setLink(0, 0, 1);
+        table1.setLink(0, 0, 1, false);
 
         Table target = table1.getLinkTarget(0);
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
index 5df16b658b..057b2f3009 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -17,13 +17,18 @@
 package io.realm.internal;
 
 import android.support.test.runner.AndroidJUnit4;
+import android.util.Pair;
 
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.util.Arrays;
 import java.util.Date;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.Locale;
 
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
@@ -188,8 +193,8 @@ public void setNulls() {
         t.addColumn(RealmFieldType.BINARY, "");
         t.add("String val", new Date(), new byte[]{1, 2, 3});
 
-        try { t.setString(0, 0, null);  fail("null string not allowed"); } catch (IllegalArgumentException ignored) { }
-        try { t.setDate(1, 0, null);    fail("null Date not allowed"); } catch (IllegalArgumentException ignored) { }
+        try { t.setString(0, 0, null, false);  fail("null string not allowed"); } catch (IllegalArgumentException ignored) { }
+        try { t.setDate(1, 0, null, false);    fail("null Date not allowed"); } catch (IllegalArgumentException ignored) { }
     }
 
     @Test
@@ -207,14 +212,19 @@ public void getName() {
         Realm.deleteRealm(configuration);
 
         SharedRealm sharedRealm = SharedRealm.getInstance(configuration);
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
 
-        // Write transaction must be run so we are sure a db exists with the correct table
-        sharedRealm.beginTransaction();
-        sharedRealm.getTable(TABLE_NAME);
-        sharedRealm.commitTransaction();
+            // Write transaction must be run so we are sure a db exists with the correct table
+            sharedRealm.beginTransaction();
+            sharedRealm.getTable(TABLE_NAME);
+            sharedRealm.commitTransaction();
 
-        Table table = sharedRealm.getTable(TABLE_NAME);
-        assertEquals(TABLE_NAME, table.getName());
+            Table table = sharedRealm.getTable(TABLE_NAME);
+            assertEquals(TABLE_NAME, table.getName());
+        } finally {
+            sharedRealm.close();
+        }
     }
 
     @Test
@@ -291,8 +301,8 @@ public void tableNumbers() {
         assertEquals(4, t.findFirstFloat(2, 300.0f)); // Find rows index for first float value of 300.0 in column 2
 
         // Set double and float
-        t.setDouble(1, 2, -2.0d);
-        t.setFloat(2, 2, -3.0f);
+        t.setDouble(1, 2, -2.0d, false);
+        t.setFloat(2, 2, -3.0f, false);
 
         // Get double tests
         assertEquals(-2.0d, t.getDouble(1, 2));
@@ -350,26 +360,26 @@ public void convertToNullable() {
                     table.addColumn(RealmFieldType.BOOLEAN, "bool");
                     table.addEmptyRow();
                     if (columnType == RealmFieldType.BOOLEAN) {
-                        table.setBoolean(colIndex, 0, true);
+                        table.setBoolean(colIndex, 0, true, false);
                     } else if (columnType == RealmFieldType.DATE) {
-                        table.setDate(colIndex, 0, new Date(0));
+                        table.setDate(colIndex, 0, new Date(0), false);
                     } else if (columnType == RealmFieldType.DOUBLE) {
-                        table.setDouble(colIndex, 0, 1.0);
+                        table.setDouble(colIndex, 0, 1.0, false);
                     } else if (columnType == RealmFieldType.FLOAT) {
-                        table.setFloat(colIndex, 0, 1.0f);
+                        table.setFloat(colIndex, 0, 1.0f, false);
                     } else if (columnType == RealmFieldType.INTEGER) {
-                        table.setLong(colIndex, 0, 1);
+                        table.setLong(colIndex, 0, 1, false);
                     } else if (columnType == RealmFieldType.BINARY) {
-                        table.setBinaryByteArray(colIndex, 0, new byte[]{0});
+                        table.setBinaryByteArray(colIndex, 0, new byte[]{0}, false);
                     } else if (columnType == RealmFieldType.STRING) {
-                        table.setString(colIndex, 0, "Foo");
+                        table.setString(colIndex, 0, "Foo", false);
                     }
                     try {
                         table.addEmptyRow();
                         if (columnType == RealmFieldType.BINARY) {
-                            table.setBinaryByteArray(colIndex, 1, null);
+                            table.setBinaryByteArray(colIndex, 1, null, false);
                         } else if (columnType == RealmFieldType.STRING) {
-                            table.setString(colIndex, 1, null);
+                            table.setString(colIndex, 1, null, false);
                         } else {
                             table.getCheckedRow(1).setNull(colIndex);
                         }
@@ -391,9 +401,9 @@ public void convertToNullable() {
 
                     table.addEmptyRow();
                     if (columnType == RealmFieldType.BINARY) {
-                        table.setBinaryByteArray(colIndex, 0, null);
+                        table.setBinaryByteArray(colIndex, 0, null, false);
                     } else if (columnType == RealmFieldType.STRING) {
-                        table.setString(colIndex, 0, null);
+                        table.setString(colIndex, 0, null, false);
                     } else {
                         table.getCheckedRow(0).setNull(colIndex);
                     }
@@ -426,25 +436,25 @@ public void convertToNotNullable() {
                     table.addColumn(RealmFieldType.BOOLEAN, "bool");
                     table.addEmptyRow();
                     if (columnType == RealmFieldType.BOOLEAN)
-                        table.setBoolean(colIndex, 0, true);
+                        table.setBoolean(colIndex, 0, true, false);
                     else if (columnType == RealmFieldType.DATE)
-                        table.setDate(colIndex, 0, new Date(1));
+                        table.setDate(colIndex, 0, new Date(1), false);
                     else if (columnType == RealmFieldType.DOUBLE)
-                        table.setDouble(colIndex, 0, 1.0);
+                        table.setDouble(colIndex, 0, 1.0, false);
                     else if (columnType == RealmFieldType.FLOAT)
-                        table.setFloat(colIndex, 0, 1.0f);
+                        table.setFloat(colIndex, 0, 1.0f, false);
                     else if (columnType == RealmFieldType.INTEGER)
-                        table.setLong(colIndex, 0, 1);
+                        table.setLong(colIndex, 0, 1, false);
                     else if (columnType == RealmFieldType.BINARY)
-                        table.setBinaryByteArray(colIndex, 0, new byte[]{0});
+                        table.setBinaryByteArray(colIndex, 0, new byte[]{0}, false);
                     else if (columnType == RealmFieldType.STRING)
-                        table.setString(colIndex, 0, "Foo");
+                        table.setString(colIndex, 0, "Foo", false);
                     try {
                         table.addEmptyRow();
                         if (columnType == RealmFieldType.BINARY) {
-                            table.setBinaryByteArray(colIndex, 1, null);
+                            table.setBinaryByteArray(colIndex, 1, null, false);
                         } else if (columnType == RealmFieldType.STRING) {
-                            table.setString(colIndex, 1, null);
+                            table.setString(colIndex, 1, null, false);
                         } else {
                             table.getCheckedRow(1).setNull(colIndex);
                         }
@@ -466,9 +476,9 @@ else if (columnType == RealmFieldType.STRING)
                     table.addEmptyRow();
                     try {
                         if (columnType == RealmFieldType.BINARY) {
-                            table.setBinaryByteArray(colIndex, 0, null);
+                            table.setBinaryByteArray(colIndex, 0, null, false);
                         } else if (columnType == RealmFieldType.STRING) {
-                            table.setString(colIndex, 0, null);
+                            table.setString(colIndex, 0, null, false);
                         } else {
                             table.getCheckedRow(0).setNull(colIndex);
                         }
@@ -513,4 +523,423 @@ public void isNullable() {
         assertFalse(table.isColumnNullable(0));
         assertTrue(table.isColumnNullable(1));
     }
+
+    @Test
+    public void defaultValue_setAndGet() {
+        // t is not used in this test
+        t = null;
+        final SharedRealm sharedRealm = SharedRealm.getInstance(configFactory.createConfiguration());
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            sharedRealm.beginTransaction();
+            final Table table = sharedRealm.getTable(Table.TABLE_PREFIX + "DefaultValueTest");
+            sharedRealm.commitTransaction();
+
+            List<Pair<RealmFieldType, Object>> columnInfoList = Arrays.asList(
+                    new Pair<RealmFieldType, Object>(RealmFieldType.STRING, "string value"),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.INTEGER, 100L),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BOOLEAN, true),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[]{123}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.DATE, new Date(123456)),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, 1.234f),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, Math.PI),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, 0L)
+                    // currently, LIST does not support default value
+                    //new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
+            );
+
+            for (Pair<RealmFieldType, Object> columnInfo : columnInfoList) {
+                final RealmFieldType type = columnInfo.first;
+                if (type == RealmFieldType.OBJECT || type == RealmFieldType.LIST) {
+                    table.addColumnLink(type, type.name().toLowerCase(Locale.ENGLISH) + "Col", table);
+                } else {
+                    table.addColumn(type, type.name().toLowerCase(Locale.ENGLISH) + "Col");
+                }
+            }
+
+            sharedRealm.beginTransaction();
+            table.addEmptyRow();
+
+            ListIterator<Pair<RealmFieldType, Object>> it = columnInfoList.listIterator();
+            for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
+                Pair<RealmFieldType, Object> columnInfo = it.next();
+                final RealmFieldType type = columnInfo.first;
+                final Object value = columnInfo.second;
+
+                switch (type) {
+                    case STRING:
+                        table.setString(columnIndex, 0, (String) value, true);
+                        assertEquals(value, table.getString(columnIndex, 0));
+                        break;
+                    case INTEGER:
+                        table.setLong(columnIndex, 0, (long) value, true);
+                        assertEquals(value, table.getLong(columnIndex, 0));
+                        break;
+                    case BOOLEAN:
+                        table.setBoolean(columnIndex, 0, (boolean) value, true);
+                        assertEquals(value, table.getBoolean(columnIndex, 0));
+                        break;
+                    case BINARY:
+                        table.setBinaryByteArray(columnIndex, 0, (byte[]) value, true);
+                        assertTrue(Arrays.equals((byte[]) value, table.getBinaryByteArray(columnIndex, 0)));
+                        break;
+                    case DATE:
+                        table.setDate(columnIndex, 0, (Date) value, true);
+                        assertEquals(value, table.getDate(columnIndex, 0));
+                        break;
+                    case FLOAT:
+                        table.setFloat(columnIndex, 0, (float) value, true);
+                        assertEquals(value, table.getFloat(columnIndex, 0));
+                        break;
+                    case DOUBLE:
+                        table.setDouble(columnIndex, 0, (double) value, true);
+                        assertEquals(value, table.getDouble(columnIndex, 0));
+                        break;
+                    case OBJECT:
+                        table.setLink(columnIndex, 0, (long) value, true);
+                        assertEquals(value, table.getLink(columnIndex, 0));
+                        break;
+                    default:
+                        throw new RuntimeException("unexpected field type: " + type);
+                }
+            }
+            sharedRealm.commitTransaction();
+
+            // check if the value can be read after committing transaction
+            it = columnInfoList.listIterator();
+            for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
+                Pair<RealmFieldType, Object> columnInfo = it.next();
+                final RealmFieldType type = columnInfo.first;
+                final Object value = columnInfo.second;
+
+                switch (type) {
+                    case STRING:
+                        assertEquals(value, table.getString(columnIndex, 0));
+                        break;
+                    case INTEGER:
+                        assertEquals(value, table.getLong(columnIndex, 0));
+                        break;
+                    case BOOLEAN:
+                        assertEquals(value, table.getBoolean(columnIndex, 0));
+                        break;
+                    case BINARY:
+                        assertTrue(Arrays.equals((byte[]) value, table.getBinaryByteArray(columnIndex, 0)));
+                        break;
+                    case DATE:
+                        assertEquals(value, table.getDate(columnIndex, 0));
+                        break;
+                    case FLOAT:
+                        assertEquals(value, table.getFloat(columnIndex, 0));
+                        break;
+                    case DOUBLE:
+                        assertEquals(value, table.getDouble(columnIndex, 0));
+                        break;
+                    case OBJECT:
+                        assertEquals(value, table.getLink(columnIndex, 0));
+                        break;
+                    default:
+                        throw new RuntimeException("unexpected field type: " + type);
+                }
+            }
+
+        } finally {
+            sharedRealm.close();
+        }
+    }
+
+    @Test
+    public void defaultValue_setMultipleTimes() {
+        // t is not used in this test
+        t = null;
+        final SharedRealm sharedRealm = SharedRealm.getInstance(configFactory.createConfiguration());
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            sharedRealm.beginTransaction();
+            final Table table = sharedRealm.getTable(Table.TABLE_PREFIX + "DefaultValueTest");
+            sharedRealm.commitTransaction();
+
+            List<Pair<RealmFieldType, Object>> columnInfoList = Arrays.asList(
+                    new Pair<RealmFieldType, Object>(RealmFieldType.STRING, new String[] {"string value1", "string value2"}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.INTEGER, new Long[] {100L, 102L}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BOOLEAN, new Boolean[] {false, true}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[][] {new byte[]{123}, new byte[]{-123}}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.DATE, new Date[] {new Date(123456), new Date(13579)}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, new Float[] {1.234f, 100f}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, new Double[] {Math.PI, Math.E}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, new Long[] {0L, 1L})
+                    // currently, LIST does not support default value
+                    //new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
+            );
+
+            for (Pair<RealmFieldType, Object> columnInfo : columnInfoList) {
+                final RealmFieldType type = columnInfo.first;
+                if (type == RealmFieldType.OBJECT || type == RealmFieldType.LIST) {
+                    table.addColumnLink(type, type.name().toLowerCase(Locale.ENGLISH) + "Col", table);
+                } else {
+                    table.addColumn(type, type.name().toLowerCase(Locale.ENGLISH) + "Col");
+                }
+            }
+
+            sharedRealm.beginTransaction();
+            table.addEmptyRow();
+            table.addEmptyRow(); // for link field update
+
+            ListIterator<Pair<RealmFieldType, Object>> it = columnInfoList.listIterator();
+            for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
+                Pair<RealmFieldType, Object> columnInfo = it.next();
+                final RealmFieldType type = columnInfo.first;
+                final Object value1 = ((Object[]) columnInfo.second)[0];
+                final Object value2 = ((Object[]) columnInfo.second)[1];
+
+                switch (type) {
+                    case STRING:
+                        table.setString(columnIndex, 0, (String) value1, true);
+                        table.setString(columnIndex, 0, (String) value2, true);
+                        assertEquals(value2, table.getString(columnIndex, 0));
+                        break;
+                    case INTEGER:
+                        table.setLong(columnIndex, 0, (long) value1, true);
+                        table.setLong(columnIndex, 0, (long) value2, true);
+                        assertEquals(value2, table.getLong(columnIndex, 0));
+                        break;
+                    case BOOLEAN:
+                        table.setBoolean(columnIndex, 0, (boolean) value1, true);
+                        table.setBoolean(columnIndex, 0, (boolean) value2, true);
+                        assertEquals(value2, table.getBoolean(columnIndex, 0));
+                        break;
+                    case BINARY:
+                        table.setBinaryByteArray(columnIndex, 0, (byte[]) value1, true);
+                        table.setBinaryByteArray(columnIndex, 0, (byte[]) value2, true);
+                        assertTrue(Arrays.equals((byte[]) value2, table.getBinaryByteArray(columnIndex, 0)));
+                        break;
+                    case DATE:
+                        table.setDate(columnIndex, 0, (Date) value1, true);
+                        table.setDate(columnIndex, 0, (Date) value2, true);
+                        assertEquals(value2, table.getDate(columnIndex, 0));
+                        break;
+                    case FLOAT:
+                        table.setFloat(columnIndex, 0, (float) value1, true);
+                        table.setFloat(columnIndex, 0, (float) value2, true);
+                        assertEquals(value2, table.getFloat(columnIndex, 0));
+                        break;
+                    case DOUBLE:
+                        table.setDouble(columnIndex, 0, (double) value1, true);
+                        table.setDouble(columnIndex, 0, (double) value2, true);
+                        assertEquals(value2, table.getDouble(columnIndex, 0));
+                        break;
+                    case OBJECT:
+                        table.setLink(columnIndex, 0, (long) value1, true);
+                        table.setLink(columnIndex, 0, (long) value2, true);
+                        assertEquals(value2, table.getLink(columnIndex, 0));
+                        break;
+                    default:
+                        throw new RuntimeException("unexpected field type: " + type);
+                }
+            }
+            sharedRealm.commitTransaction();
+
+            // check if the value can be read after committing transaction
+            it = columnInfoList.listIterator();
+            for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
+                Pair<RealmFieldType, Object> columnInfo = it.next();
+                final RealmFieldType type = columnInfo.first;
+                final Object value2 = ((Object[]) columnInfo.second)[1];
+
+                switch (type) {
+                    case STRING:
+                        assertEquals(value2, table.getString(columnIndex, 0));
+                        break;
+                    case INTEGER:
+                        assertEquals(value2, table.getLong(columnIndex, 0));
+                        break;
+                    case BOOLEAN:
+                        assertEquals(value2, table.getBoolean(columnIndex, 0));
+                        break;
+                    case BINARY:
+                        assertTrue(Arrays.equals((byte[]) value2, table.getBinaryByteArray(columnIndex, 0)));
+                        break;
+                    case DATE:
+                        assertEquals(value2, table.getDate(columnIndex, 0));
+                        break;
+                    case FLOAT:
+                        assertEquals(value2, table.getFloat(columnIndex, 0));
+                        break;
+                    case DOUBLE:
+                        assertEquals(value2, table.getDouble(columnIndex, 0));
+                        break;
+                    case OBJECT:
+                        assertEquals(value2, table.getLink(columnIndex, 0));
+                        break;
+                    default:
+                        throw new RuntimeException("unexpected field type: " + type);
+                }
+            }
+        } finally {
+            sharedRealm.close();
+        }
+    }
+
+    @Test
+    public void defaultValue_overwrittenByNonDefault() {
+        // t is not used in this test
+        t = null;
+        final SharedRealm sharedRealm = SharedRealm.getInstance(configFactory.createConfiguration());
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            sharedRealm.beginTransaction();
+            final Table table = sharedRealm.getTable(Table.TABLE_PREFIX + "DefaultValueTest");
+            sharedRealm.commitTransaction();
+
+            List<Pair<RealmFieldType, Object>> columnInfoList = Arrays.asList(
+                    new Pair<RealmFieldType, Object>(RealmFieldType.STRING, new String[] {"string value1", "string value2"}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.INTEGER, new Long[] {100L, 102L}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BOOLEAN, new Boolean[] {false, true}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[][] {new byte[]{123}, new byte[]{-123}}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.DATE, new Date[] {new Date(123456), new Date(13579)}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, new Float[] {1.234f, 100f}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, new Double[] {Math.PI, Math.E}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, new Long[] {0L, 1L})
+                    // currently, LIST does not support default value
+                    //new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
+            );
+
+            for (Pair<RealmFieldType, Object> columnInfo : columnInfoList) {
+                final RealmFieldType type = columnInfo.first;
+                if (type == RealmFieldType.OBJECT || type == RealmFieldType.LIST) {
+                    table.addColumnLink(type, type.name().toLowerCase(Locale.ENGLISH) + "Col", table);
+                } else {
+                    table.addColumn(type, type.name().toLowerCase(Locale.ENGLISH) + "Col");
+                }
+            }
+
+            sharedRealm.beginTransaction();
+            table.addEmptyRow();
+            table.addEmptyRow(); // for link field update
+
+            // set as default
+            ListIterator<Pair<RealmFieldType, Object>> it = columnInfoList.listIterator();
+            for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
+                Pair<RealmFieldType, Object> columnInfo = it.next();
+                final RealmFieldType type = columnInfo.first;
+                final Object value1 = ((Object[]) columnInfo.second)[0];
+
+                switch (type) {
+                    case STRING:
+                        table.setString(columnIndex, 0, (String) value1, true);
+                        break;
+                    case INTEGER:
+                        table.setLong(columnIndex, 0, (long) value1, true);
+                        break;
+                    case BOOLEAN:
+                        table.setBoolean(columnIndex, 0, (boolean) value1, true);
+                        break;
+                    case BINARY:
+                        table.setBinaryByteArray(columnIndex, 0, (byte[]) value1, true);
+                        break;
+                    case DATE:
+                        table.setDate(columnIndex, 0, (Date) value1, true);
+                        break;
+                    case FLOAT:
+                        table.setFloat(columnIndex, 0, (float) value1, true);
+                        break;
+                    case DOUBLE:
+                        table.setDouble(columnIndex, 0, (double) value1, true);
+                        break;
+                    case OBJECT:
+                        table.setLink(columnIndex, 0, (long) value1, true);
+                        break;
+                    default:
+                        throw new RuntimeException("unexpected field type: " + type);
+                }
+            }
+            sharedRealm.commitTransaction();
+
+            // update as non default
+            sharedRealm.beginTransaction();
+            it = columnInfoList.listIterator();
+            for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
+                Pair<RealmFieldType, Object> columnInfo = it.next();
+                final RealmFieldType type = columnInfo.first;
+                final Object value2 = ((Object[]) columnInfo.second)[1];
+
+                switch (type) {
+                    case STRING:
+                        table.setString(columnIndex, 0, (String) value2, false);
+                        assertEquals(value2, table.getString(columnIndex, 0));
+                        break;
+                    case INTEGER:
+                        table.setLong(columnIndex, 0, (long) value2, false);
+                        assertEquals(value2, table.getLong(columnIndex, 0));
+                        break;
+                    case BOOLEAN:
+                        table.setBoolean(columnIndex, 0, (boolean) value2, false);
+                        assertEquals(value2, table.getBoolean(columnIndex, 0));
+                        break;
+                    case BINARY:
+                        table.setBinaryByteArray(columnIndex, 0, (byte[]) value2, false);
+                        assertTrue(Arrays.equals((byte[]) value2, table.getBinaryByteArray(columnIndex, 0)));
+                        break;
+                    case DATE:
+                        table.setDate(columnIndex, 0, (Date) value2, false);
+                        assertEquals(value2, table.getDate(columnIndex, 0));
+                        break;
+                    case FLOAT:
+                        table.setFloat(columnIndex, 0, (float) value2, false);
+                        assertEquals(value2, table.getFloat(columnIndex, 0));
+                        break;
+                    case DOUBLE:
+                        table.setDouble(columnIndex, 0, (double) value2, false);
+                        assertEquals(value2, table.getDouble(columnIndex, 0));
+                        break;
+                    case OBJECT:
+                        table.setLink(columnIndex, 0, (long) value2, false);
+                        assertEquals(value2, table.getLink(columnIndex, 0));
+                        break;
+                    default:
+                        throw new RuntimeException("unexpected field type: " + type);
+                }
+            }
+            sharedRealm.commitTransaction();
+
+            // check if the value was overwritten
+            it = columnInfoList.listIterator();
+            for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
+                Pair<RealmFieldType, Object> columnInfo = it.next();
+                final RealmFieldType type = columnInfo.first;
+                final Object value2 = ((Object[]) columnInfo.second)[1];
+
+                switch (type) {
+                    case STRING:
+                        assertEquals(value2, table.getString(columnIndex, 0));
+                        break;
+                    case INTEGER:
+                        assertEquals(value2, table.getLong(columnIndex, 0));
+                        break;
+                    case BOOLEAN:
+                        assertEquals(value2, table.getBoolean(columnIndex, 0));
+                        break;
+                    case BINARY:
+                        assertTrue(Arrays.equals((byte[]) value2, table.getBinaryByteArray(columnIndex, 0)));
+                        break;
+                    case DATE:
+                        assertEquals(value2, table.getDate(columnIndex, 0));
+                        break;
+                    case FLOAT:
+                        assertEquals(value2, table.getFloat(columnIndex, 0));
+                        break;
+                    case DOUBLE:
+                        assertEquals(value2, table.getDouble(columnIndex, 0));
+                        break;
+                    case OBJECT:
+                        assertEquals(value2, table.getLink(columnIndex, 0));
+                        break;
+                    default:
+                        throw new RuntimeException("unexpected field type: " + type);
+                }
+            }
+        } finally {
+            sharedRealm.close();
+        }
+    }
 }
+
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableViewTest.java
new file mode 100644
index 0000000000..e1088af833
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableViewTest.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+
+import io.realm.RealmFieldType;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+
+@RunWith(AndroidJUnit4.class)
+public class JNITableViewTest {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private static final String TABLE_NAME = Table.TABLE_PREFIX + "JNITableViewTest";
+    private static final int ROW_COUNT = 10;
+
+    private static final List<RealmFieldType> FIELDS = Arrays.asList(
+            RealmFieldType.INTEGER,
+            RealmFieldType.BOOLEAN,
+            RealmFieldType.STRING,
+            RealmFieldType.BINARY,
+            RealmFieldType.DATE,
+            RealmFieldType.FLOAT,
+            RealmFieldType.DOUBLE);
+    private static final long INTEGER_COLUMN_INDEX = 0;
+    private static final long STRING_COLUMN_INDEX = 2;
+
+    private SharedRealm sharedRealm;
+
+    private Table table;
+
+    @Before
+    public void setUp() {
+        sharedRealm = SharedRealm.getInstance(configFactory.createConfiguration());
+        sharedRealm.beginTransaction();
+        try {
+            table = sharedRealm.getTable(TABLE_NAME);
+
+            for (RealmFieldType field : FIELDS) {
+                final long index = table.addColumn(field, field.name().toLowerCase(Locale.ENGLISH) + "Column");
+                table.convertColumnToNullable(index);
+            }
+
+            for (int i = 0; i < ROW_COUNT; i++) {
+                table.add(i, true, "abcd", new byte[]{123, -123}, new Date(12345), 1.234f, 3.446d);
+            }
+        } finally {
+            sharedRealm.commitTransaction();
+        }
+    }
+
+    @Test
+    public void setNull() {
+        TableQuery query = table.where();
+        for (int i = 0; i < ROW_COUNT; i++) {
+            if (isOdd(i)) {
+                query = query.or().equalTo(new long[]{INTEGER_COLUMN_INDEX}, (long) i);
+            }
+        }
+        final TableView oddRows = query.findAll();
+
+        sharedRealm.beginTransaction();
+        for (int i = 0; i < oddRows.size(); i++) {
+            oddRows.setNull(STRING_COLUMN_INDEX, i, false);
+        }
+        sharedRealm.commitTransaction();
+
+        // check if TableView#setNull() worked as expected
+        for (int i = 0; i < table.size(); i++) {
+            assertEquals("index: " + i, isOdd(i), table.isNull(STRING_COLUMN_INDEX, i));
+        }
+    }
+
+    @Test
+    public void isNull() {
+
+        sharedRealm.beginTransaction();
+        for (int i = 0; i < table.size(); i++) {
+            if (isOdd(i)) {
+                table.setNull(STRING_COLUMN_INDEX, i, false);
+            }
+        }
+        sharedRealm.commitTransaction();
+
+        TableQuery query = table.where();
+        for (int i = 0; i < ROW_COUNT; i++) {
+            if (isOdd(i)) {
+                query = query.or().equalTo(new long[]{INTEGER_COLUMN_INDEX}, (long) i);
+            }
+        }
+        final TableView oddRows = query.findAll();
+        for (int i = 0; i < oddRows.size(); i++) {
+            assertEquals("index: " + i, true, oddRows.isNull(STRING_COLUMN_INDEX, i));
+        }
+
+        query = table.where();
+        for (int i = 0; i < ROW_COUNT; i++) {
+            if (isEven(i)) {
+                query = query.or().equalTo(new long[]{INTEGER_COLUMN_INDEX}, (long) i);
+            }
+        }
+        final TableView evenRows = query.findAll();
+        for (int i = 0; i < evenRows.size(); i++) {
+            assertEquals("index: " + i, false, evenRows.isNull(STRING_COLUMN_INDEX, i));
+        }
+    }
+
+    private static boolean isEven(int i) {
+        return i % 2 == 0;
+    }
+    private static boolean isOdd(int i) {
+        return i % 2 == 1;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
index 9a3d5669e7..661e6c1a6d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
@@ -131,7 +131,7 @@ public void testSetBinary() {
 
         byte[] arr2 = new byte[] {1,2,3, 4, 5};
 
-        view.setBinaryByteArray(0, 0, arr2);
+        view.setBinaryByteArray(0, 0, arr2, false);
 
         MoreAsserts.assertEquals(arr2, view.getBinaryByteArray(0, 0));
     }
@@ -372,7 +372,7 @@ public void testViewShouldInvalidate() {
         assertEquals(1, view.size());
 
         // access view after change in value is ok
-        t.setLong(0, 0, 3);
+        t.setLong(0, 0, 3, false);
         accessingViewOk(view);
 
         // access view after additions to table must fail
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
new file mode 100644
index 0000000000..3ba437ac44
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
@@ -0,0 +1,257 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+
+import io.realm.RealmConfiguration;
+import io.realm.RealmFieldType;
+import io.realm.exceptions.RealmError;
+import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmPrimaryKeyConstraintException;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertFalse;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class PrimaryKeyTests {
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private android.content.Context context;
+    private RealmConfiguration config;
+    private SharedRealm sharedRealm;
+
+    @Before
+    public void setUp() throws Exception {
+        config = configFactory.createConfiguration();
+        context = InstrumentationRegistry.getInstrumentation().getContext();
+    }
+
+    @After
+    public void tearDown() {
+        if (sharedRealm != null && !sharedRealm.isClosed()) {
+            sharedRealm.close();
+        }
+    }
+
+    private Table getTableWithStringPrimaryKey() {
+        sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+        Table t = sharedRealm.getTable("TestTable");
+        long column = t.addColumn(RealmFieldType.STRING, "colName", true);
+        t.addSearchIndex(column);
+        t.setPrimaryKey("colName");
+        return t;
+    }
+
+    private Table getTableWithIntegerPrimaryKey() {
+        sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+        Table t = sharedRealm.getTable("TestTable");
+        long column = t.addColumn(RealmFieldType.INTEGER, "colName");
+        t.addSearchIndex(column);
+        t.setPrimaryKey("colName");
+        return t;
+    }
+
+    // Test that primary key constraints are actually removed
+    @Test
+    public void removingPrimaryKeyRemovesConstraint_typeSetters() {
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .name("removeConstraints").build();
+        SharedRealm sharedRealm = SharedRealm.getInstance(config);
+
+        sharedRealm.beginTransaction();
+        Table tbl = sharedRealm.getTable("EmployeeTable");
+        tbl.addColumn(RealmFieldType.STRING, "name");
+        tbl.setPrimaryKey("name");
+
+        // Create first entry with name "Foo"
+        tbl.setString(0, tbl.addEmptyRow(), "Foo", false);
+
+        long rowIndex = tbl.addEmptyRow();
+        try {
+            tbl.setString(0, rowIndex, "Foo", false); // Try to create 2nd entry with name Foo
+        } catch (RealmPrimaryKeyConstraintException e1) {
+            tbl.setPrimaryKey(""); // Primary key check worked, now remove it and try again.
+            try {
+                tbl.setString(0, rowIndex, "Foo", false);
+                return;
+            } catch (RealmException e2) {
+                fail("Primary key not removed");
+            }
+        }
+
+        fail("Primary key not enforced.");
+        sharedRealm.close();
+    }
+
+    @Test
+    public void addEmptyRowWithPrimaryKeyWrongTypeStringThrows() {
+        Table t = getTableWithStringPrimaryKey();
+        try {
+            t.addEmptyRowWithPrimaryKey(42);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        sharedRealm.cancelTransaction();
+    }
+
+    @Test
+    public void addEmptyRowWithPrimaryKeyNullString() {
+        Table t = getTableWithStringPrimaryKey();
+        t.addEmptyRowWithPrimaryKey(null);
+        assertEquals(1, t.size());
+        sharedRealm.cancelTransaction();
+    }
+
+    @Test
+    public void addEmptyRowWithPrimaryKeyWrongTypeIntegerThrows() {
+        Table t = getTableWithIntegerPrimaryKey();
+        try {
+            t.addEmptyRowWithPrimaryKey("Foo");
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        sharedRealm.cancelTransaction();
+    }
+
+    @Test
+    public void addEmptyRowWithPrimaryKeyString() {
+        Table t = getTableWithStringPrimaryKey();
+        long rowIndex = t.addEmptyRowWithPrimaryKey("Foo");
+        assertEquals(1, t.size());
+        assertEquals("Foo", t.getUncheckedRow(rowIndex).getString(0));
+        sharedRealm.cancelTransaction();
+    }
+
+    @Test
+    public void addEmptyRowWithPrimaryKeyLong() {
+        Table t = getTableWithIntegerPrimaryKey();
+        long rowIndex = t.addEmptyRowWithPrimaryKey(42);
+        assertEquals(1, t.size());
+        assertEquals(42L, t.getUncheckedRow(rowIndex).getLong(0));
+        sharedRealm.cancelTransaction();
+    }
+
+    @Test
+    public void migratePrimaryKeyTableIfNeeded_first() throws IOException {
+        configFactory.copyRealmFromAssets(context, "080_annotationtypes.realm", "default.realm");
+        sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+        assertTrue(Table.migratePrimaryKeyTableIfNeeded(sharedRealm));
+        sharedRealm.commitTransaction();
+        Table t = sharedRealm.getTable("class_AnnotationTypes");
+        assertTrue(t.hasPrimaryKey());
+        assertEquals(t.getColumnIndex("id"), t.getPrimaryKey());
+        assertEquals(RealmFieldType.STRING, sharedRealm.getTable("pk").getColumnType(0));
+    }
+
+    @Test
+    public void migratePrimaryKeyTableIfNeeded_second() throws IOException {
+        configFactory.copyRealmFromAssets(context, "0841_annotationtypes.realm", "default.realm");
+        sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+        assertTrue(Table.migratePrimaryKeyTableIfNeeded(sharedRealm));
+        sharedRealm.commitTransaction();
+        Table t = sharedRealm.getTable("class_AnnotationTypes");
+        assertTrue(t.hasPrimaryKey());
+        assertEquals(t.getColumnIndex("id"), t.getPrimaryKey());
+        assertEquals("AnnotationTypes", sharedRealm.getTable("pk").getString(0, 0));
+    }
+
+    // See https://github.com/realm/realm-java/issues/1775 .
+    // Before 0.84.2, pk table added prefix "class_" to every class's name.
+    // After 0.84.2, the pk table should be migrated automatically to remove the "class_".
+    // In 0.84.2, the class names in pk table has been renamed to some incorrect names like "Thclass", "Mclass",
+    // "NClass", "Meclass" and etc..
+    // The 0841_pk_migration.realm is made to produce the issue.
+    @Test
+    public void migratePrimaryKeyTableIfNeeded_primaryKeyTableMigratedWithRightName() throws IOException {
+        List<String> tableNames = Arrays.asList(
+                "ChatList", "Drafts", "Member", "Message", "Notifs", "NotifyLink", "PopularPost",
+                "Post", "Tags", "Threads", "User");
+
+        configFactory.copyRealmFromAssets(context, "0841_pk_migration.realm", "default.realm");
+        sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+        assertTrue(Table.migratePrimaryKeyTableIfNeeded(sharedRealm));
+        sharedRealm.commitTransaction();
+
+        Table table = sharedRealm.getTable("pk");
+        for (int i = 0; i < table.size(); i++) {
+            UncheckedRow row = table.getUncheckedRow(i);
+            // io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX 0LL
+            assertTrue(tableNames.contains(row.getString(0)));
+        }
+    }
+
+    // PK table's column 'pk_table' needs search index in order to use set_string_unique.
+    // See https://github.com/realm/realm-java/pull/3488
+    @Test
+    public void migratePrimaryKeyTableIfNeeded_primaryKeyTableNeedSearchIndex() {
+        sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+        Table table = sharedRealm.getTable("TestTable");
+        long column = table.addColumn(RealmFieldType.INTEGER, "PKColumn");
+        table.addSearchIndex(column);
+        table.setPrimaryKey(column);
+        sharedRealm.commitTransaction();
+
+        assertEquals(table.getPrimaryKey(), table.getColumnIndex("PKColumn"));
+        // Now we have a pk table with search index.
+
+        sharedRealm.beginTransaction();
+        Table pkTable = sharedRealm.getTable("pk");
+        long classColumn = pkTable.getColumnIndex("pk_table");
+        pkTable.removeSearchIndex(classColumn);
+
+        // Try to add a pk for another table
+        Table table2 = sharedRealm.getTable("TestTable2");
+        long column2 = table2.addColumn(RealmFieldType.INTEGER, "PKColumn");
+        table2.addSearchIndex(column2);
+        try {
+            table2.setPrimaryKey(column2);
+        } catch (RealmError ignored) {
+            // Column has no search index
+        }
+
+        assertFalse(pkTable.hasSearchIndex(classColumn));
+
+        Table.migratePrimaryKeyTableIfNeeded(sharedRealm);
+        assertTrue(pkTable.hasSearchIndex(classColumn));
+        // Now it works.
+        table2.addSearchIndex(column2);
+        sharedRealm.cancelTransaction();
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
new file mode 100644
index 0000000000..a9646a0bea
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
@@ -0,0 +1,89 @@
+package io.realm;
+
+
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+
+import io.realm.internal.network.AuthenticateRequest;
+import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.objectserver.Token;
+import io.realm.util.SyncTestUtils;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.when;
+
+@RunWith(AndroidJUnit4.class)
+public class AuthenticateRequestTests {
+
+    @Before
+    public void setUp() {
+        Realm.init(InstrumentationRegistry.getTargetContext());
+    }
+
+    // Tests based on the schemas described here: https://github.com/realm/realm-sync-services/blob/master/doc/index.apib
+
+    @Test
+    public void realmLogin() throws URISyntaxException, JSONException {
+        Token t = SyncTestUtils.createTestUser().getSyncUser().getUserToken();
+        AuthenticateRequest request = AuthenticateRequest.realmLogin(t, new URI("realm://objectserver/" + t.value() + "/default"));
+
+        JSONObject obj = new JSONObject(request.toJson());
+        assertEquals("/" + t.value() + "/default", obj.get("path"));
+        assertEquals(t.value(), obj.get("data"));
+        assertEquals("realm", obj.get("provider"));
+    }
+
+    @Test
+    public void userLogin() throws URISyntaxException, JSONException {
+        AuthenticateRequest request = AuthenticateRequest.userLogin(SyncCredentials.facebook("foo"));
+
+        JSONObject obj = new JSONObject(request.toJson());
+        assertFalse(obj.has("path"));
+        assertEquals("foo", obj.get("data"));
+        assertEquals("facebook", obj.get("provider"));
+    }
+
+    @Test
+    public void userRefresh() throws URISyntaxException, JSONException {
+        Token t = SyncTestUtils.createTestUser().getSyncUser().getUserToken();
+        AuthenticateRequest request = AuthenticateRequest.userRefresh(t);
+
+        JSONObject obj = new JSONObject(request.toJson());
+        assertFalse(obj.has("path"));
+        assertEquals(t.value(), obj.get("data"));
+        assertEquals("realm", obj.get("provider"));
+    }
+
+
+    @Test
+    public void errorsNotWrapped() {
+        AuthenticationServer originalAuthServer = SyncManager.getAuthServer();
+        AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
+        when(authServer.loginUser(any(SyncCredentials.class), any(URL.class))).thenReturn(SyncTestUtils.createErrorResponse(ErrorCode.ACCESS_DENIED));
+        SyncManager.setAuthServerImpl(authServer);
+
+        try {
+            SyncUser.login(SyncCredentials.facebook("foo"), "http://foo.bar/auth");
+            fail();
+        } catch (ObjectServerError e) {
+            assertEquals(ErrorCode.ACCESS_DENIED, e.getErrorCode());
+        } finally {
+            // Reset the auth server implementation for other tests.
+            SyncManager.setAuthServerImpl(originalAuthServer);
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java
new file mode 100644
index 0000000000..eaac178bb9
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java
@@ -0,0 +1,139 @@
+package io.realm;
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class CredentialsTests {
+
+    // See https://github.com/realm/realm-sync-services/blob/master/doc/index.apib for a description of the fields
+    // needed by each identity provider.
+
+    @Test
+    public void getUserInfo_isUnmodifiable() {
+        SyncCredentials creds = SyncCredentials.custom("foo", "bar", null);
+        Map<java.lang.String, Object> userInfo = creds.getUserInfo();
+        try {
+            userInfo.put("boom", null);
+            fail();
+        } catch (UnsupportedOperationException ignored) {
+        }
+    }
+
+    @Test
+    public void facebook() {
+        SyncCredentials creds = SyncCredentials.facebook("foo");
+
+        assertEquals(SyncCredentials.IdentityProvider.FACEBOOK, creds.getIdentityProvider());
+        assertEquals("foo", creds.getUserIdentifier());
+        assertTrue(creds.getUserInfo().isEmpty());
+    }
+
+    @Test
+    public void google() {
+        SyncCredentials creds = SyncCredentials.google("foo");
+
+        assertEquals(SyncCredentials.IdentityProvider.GOOGLE, creds.getIdentityProvider());
+        assertEquals("foo", creds.getUserIdentifier());
+        assertTrue(creds.getUserInfo().isEmpty());
+    }
+
+    @Test
+    public void facebook_invalidInput() {
+        String[] invalidInput = { null, ""};
+        for (String input : invalidInput) {
+            try {
+                SyncCredentials.facebook(input);
+                fail(input + " should have failed");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void usernamePassword() {
+        SyncCredentials creds = SyncCredentials.usernamePassword("foo", "bar", true);
+        assertEquals("foo", creds.getUserIdentifier());
+        Map<String, Object> userInfo = creds.getUserInfo();
+
+        assertEquals(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, creds.getIdentityProvider());
+        assertEquals("bar", userInfo.get("password"));
+        assertTrue((Boolean) userInfo.get("register"));
+    }
+
+    // Only validate username. All passwords are allowed
+    @Test
+    public void usernamePassword_invalidUserName() {
+        String[] invalidInput = { null, ""};
+        for (String input : invalidInput) {
+            try {
+                SyncCredentials.usernamePassword(input, "bar", true);
+                fail(input + " should have failed");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void custom_invalidUserName() {
+        Map<String, Object> userInfo = new HashMap<>();
+        userInfo.put("custom", "property");
+        for (String username : new String[]{null, ""}) {
+            try {
+                SyncCredentials.custom("facebook", username, userInfo);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void custom() {
+        Map<java.lang.String, Object> userInfo = new HashMap<String, Object>();
+        userInfo.put("custom", "property");
+        SyncCredentials creds = SyncCredentials.custom("customProvider", "foo", userInfo);
+
+        assertEquals("foo", creds.getUserIdentifier());
+        assertEquals("customProvider", creds.getIdentityProvider());
+        assertEquals(1, creds.getUserInfo().size());
+        assertEquals("property", creds.getUserInfo().get("custom"));
+    }
+
+    @Test
+    public void custom_invalidProvider() {
+        Map<String, Object> userInfo = new HashMap<>();
+        userInfo.put("custom", "property");
+
+        for (String provider : new String[]{null, ""}) {
+            try {
+                SyncCredentials.custom(null, "foo", userInfo);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java
new file mode 100644
index 0000000000..d9dd20f801
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.entities.StringOnly;
+import io.realm.rule.TestRealmConfigurationFactory;
+import io.realm.util.SyncTestUtils;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.TestCase.assertFalse;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class SchemaTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private SyncConfiguration config;
+
+    @Before
+    public void setUp() {
+        SyncUser user = SyncTestUtils.createTestUser();
+        config = new SyncConfiguration.Builder(user, "realm://objectserver.realm.io/~/default").build();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        Realm.deleteRealm(config);
+    }
+
+    @Test
+    public void getInstance() {
+        Realm realm = Realm.getInstance(config);
+        assertFalse(realm.isClosed());
+        realm.close();
+        assertTrue(realm.isClosed());
+    }
+
+    @Test
+    public void createObject() {
+        Realm realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        assertTrue(realm.getSchema().contains("StringOnly"));
+        StringOnly stringOnly= realm.createObject(StringOnly.class);
+        stringOnly.setChars("TEST");
+        realm.commitTransaction();
+        assertEquals(1, realm.where(StringOnly.class).count());
+        realm.close();
+    }
+
+    @Test
+    public void disallow_removeClass() {
+        Realm realm = Realm.getInstance(config);
+        String className = "StringOnly";
+        realm.beginTransaction();
+        assertTrue(realm.getSchema().contains(className));
+        try {
+            realm.getSchema().remove(className);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+            realm.close();
+        }
+    }
+
+    @Test
+    public void allow_createClass() {
+        Realm realm = Realm.getInstance(config);
+        String className = "Dogplace";
+        realm.beginTransaction();
+        realm.getSchema().create("Dogplace");
+        realm.commitTransaction();
+        assertTrue(realm.getSchema().contains(className));
+        realm.close();
+    }
+
+    @Test
+    public void disallow_renameClass() {
+        Realm realm = Realm.getInstance(config);
+        String className = "StringOnly";
+        realm.beginTransaction();
+        try {
+            realm.getSchema().rename(className, "Dogplace");
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+            assertTrue(realm.getSchema().contains(className));
+            realm.close();
+        }
+    }
+
+    @Test
+    public void disallow_removeField() {
+        Realm realm = Realm.getInstance(config);
+        String className = "StringOnly";
+        String fieldName = "chars";
+        realm.beginTransaction();
+        assertTrue(realm.getSchema().get(className).hasField(fieldName));
+        try {
+            realm.getSchema().get(className).removeField(fieldName);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+            realm.close();
+        }
+    }
+
+    @Test
+    public void allow_addField() {
+        String className = "StringOnly";
+        Realm realm = Realm.getInstance(config);
+
+        realm.beginTransaction();
+        realm.getSchema().get(className).addField("foo", String.class);
+        realm.commitTransaction();
+
+        assertTrue(realm.getSchema().get(className).hasField("foo"));
+
+        realm.close();
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
new file mode 100644
index 0000000000..66a072e05f
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.OkHttpAuthenticationServer;
+import io.realm.internal.objectserver.ObjectServerSession;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.util.SyncTestUtils.createTestUser;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+@RunWith(AndroidJUnit4.class)
+public class SessionTests {
+
+    private static String REALM_URI = "realm://objectserver.realm.io/~/default";
+
+    private Context context;
+    private AuthenticationServer authServer;
+    private SyncConfiguration configuration;
+    private SyncUser user;
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    @Before
+    public void setUp() {
+        context = InstrumentationRegistry.getContext();
+        user = createTestUser();
+        authServer = new OkHttpAuthenticationServer();
+        configuration = new SyncConfiguration.Builder(user, REALM_URI).build();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+    }
+
+    @Test
+    public void get_syncValues() {
+        ObjectServerSession internalSession = new ObjectServerSession(
+                configuration,
+                authServer,
+                configuration.getUser().getSyncUser(),
+                configuration.getSyncPolicy(),
+                configuration.getErrorHandler()
+        );
+        SyncSession session = new SyncSession(internalSession);
+
+        assertEquals("realm://objectserver.realm.io/JohnDoe/default", session.getServerUrl().toString());
+        assertEquals(user, session.getUser());
+        assertEquals(configuration, session.getConfiguration());
+        assertNull(session.getState());
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
new file mode 100644
index 0000000000..f4d102aa2e
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
@@ -0,0 +1,394 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.rules.TemporaryFolder;
+import org.junit.runner.RunWith;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+import io.realm.entities.StringOnly;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.util.SyncTestUtils.createTestUser;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class SyncConfigurationTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Rule
+    public final TemporaryFolder tempFolder = new TemporaryFolder();
+
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Context context;
+
+    @Before
+    public void setUp() {
+        context = InstrumentationRegistry.getContext();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+    }
+
+    @Test
+    public void user() {
+//        new SyncConfiguration.Builder(context);
+        // Check that user can be added
+        // That the default local path is correct
+    }
+
+    @Test
+    public void user_invalidUserThrows() {
+        try {
+            new SyncConfiguration.Builder(null, "realm://ros.realm.io/default");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        SyncUser user = createTestUser(0); // Create user that has expired credentials
+        try {
+            new SyncConfiguration.Builder(user, "realm://ros.realm.io/default");
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    @Test
+    public void serverUrl_setsFolderAndFileName() {
+        SyncUser user = createTestUser();
+        String[][] validUrls = {
+                // <URL>, <Folder>, <FileName>
+                { "realm://objectserver.realm.io/~/default", "realm-object-server/" + user.getIdentity(), "default" },
+                { "realm://objectserver.realm.io/~/sub/default", "realm-object-server/" + user.getIdentity() + "/sub", "default" }
+        };
+
+        for (String[] validUrl : validUrls) {
+            String serverUrl  = validUrl[0];
+            String expectedFolder = validUrl[1];
+            String expectedFileName = validUrl[2];
+
+            SyncConfiguration config = new SyncConfiguration.Builder(user, serverUrl).build();
+
+            assertEquals(new File(context.getFilesDir(), expectedFolder), config.getRealmDirectory());
+            assertEquals(expectedFileName, config.getRealmFileName());
+        }
+    }
+
+    @Test
+    public void serverUrl_invalidUrlThrows() {
+        String[] invalidUrls = {
+            null,
+// TODO Should these two fail?
+//            "objectserver.realm.io/~/default", // Missing protocol. TODO Should we just default to one?
+//            "/~/default", // Missing server
+            "realm://objectserver.realm.io/~/default.realm", // Ending with .realm
+            "realm://objectserver.realm.io/~/default.realm.lock", // Ending with .realm.lock
+            "realm://objectserver.realm.io/~/default.realm.management", // Ending with .realm.management
+            "realm://objectserver.realm.io/<~>/default.realm", // Invalid chars <>
+            "realm://objectserver.realm.io/~/default.realm/", // Ending with /
+            "realm://objectserver.realm.io/~/Î‘Î¸Î®Î½Î±", // Non-ascii
+            "realm://objectserver.realm.io/~/foo/../bar", // .. is not allowed
+            "realm://objectserver.realm.io/~/foo/./bar", // . is not allowed
+            "http://objectserver.realm.io/~/default", // wrong scheme
+        };
+
+        for (String invalidUrl : invalidUrls) {
+            try {
+                new SyncConfiguration.Builder(createTestUser(), invalidUrl);
+                fail(invalidUrl + " should have failed.");
+            } catch (IllegalArgumentException ignore) {
+            }
+        }
+    }
+
+    private String makeServerUrl(int len) {
+        StringBuilder builder = new StringBuilder("realm://objectserver.realm.io/~/");
+        for (int i = 0; i < len; i++) {
+            builder.append('A');
+        }
+        return builder.toString();
+    }
+
+    @Test
+    public void serverUrl_length() {
+        int[] lengths = {1, SyncConfiguration.MAX_FILE_NAME_LENGTH - 1,
+                SyncConfiguration.MAX_FILE_NAME_LENGTH, SyncConfiguration.MAX_FILE_NAME_LENGTH + 1, 1000};
+
+        for (int len : lengths) {
+            SyncConfiguration config = new SyncConfiguration.Builder(createTestUser(), makeServerUrl(len)).build();
+            assertTrue("Length: " + len, config.getRealmFileName().length() <= SyncConfiguration.MAX_FILE_NAME_LENGTH);
+            assertTrue("Length: " + len, config.getPath().length() <= SyncConfiguration.MAX_FULL_PATH_LENGTH);
+        }
+    }
+
+    @Test
+    public void serverUrl_invalidChars() {
+        SyncConfiguration.Builder builder = new SyncConfiguration.Builder(createTestUser(), "realm://objectserver.realm.io/~/?");
+        SyncConfiguration config = builder.build();
+        assertFalse(config.getRealmFileName().contains("?"));
+    }
+
+    @Test
+    public void serverUrl_port() {
+        Map<String, Integer> urlPort = new HashMap<String, Integer>();
+        urlPort.put("realm://objectserver.realm.io/~/default", -1); // default port - handled by sync client
+        urlPort.put("realms://objectserver.realm.io/~/default", -1); // default port - handled by sync client
+        urlPort.put("realm://objectserver.realm.io:8080/~/default", 8080);
+        urlPort.put("realms://objectserver.realm.io:2443/~/default", 2443);
+
+        for (String url : urlPort.keySet()) {
+            SyncConfiguration config = new SyncConfiguration.Builder(createTestUser(), url).build();
+            assertEquals(urlPort.get(url).intValue(), config.getServerUrl().getPort());
+        }
+    }
+
+    @Test
+    public void errorHandler() {
+        SyncConfiguration.Builder builder = new SyncConfiguration.Builder(createTestUser(), "realm://objectserver.realm.io/default");
+        SyncSession.ErrorHandler errorHandler = new SyncSession.ErrorHandler() {
+            @Override
+            public void onError(SyncSession session, ObjectServerError error) {
+
+            }
+        };
+        SyncConfiguration config = builder.errorHandler(errorHandler).build();
+        assertEquals(errorHandler, config.getErrorHandler());
+    }
+
+    @Test
+    public void errorHandler_fromSyncManager() {
+        // Set default error handler
+        SyncSession.ErrorHandler errorHandler = new SyncSession.ErrorHandler() {
+            @Override
+            public void onError(SyncSession session, ObjectServerError error) {
+
+            }
+        };
+        SyncManager.setDefaultSessionErrorHandler(errorHandler);
+
+        // Create configuration using the default handler
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url).build();
+        assertEquals(errorHandler, config.getErrorHandler());
+        SyncManager.setDefaultSessionErrorHandler(null);
+    }
+
+
+    @Test
+    public void errorHandler_nullThrows() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration.Builder builder = new SyncConfiguration.Builder(user, url);
+
+        try {
+            builder.errorHandler(null);
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    @Test
+    public void equals() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url)
+                .build();
+        assertTrue(config.equals(config));
+    }
+
+    @Test
+    public void not_equals_same() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration config1 = new SyncConfiguration.Builder(user, url).build();
+        SyncConfiguration config2 = new SyncConfiguration.Builder(user, url).build();
+
+        assertFalse(config1.equals(config2));
+    }
+
+    @Test
+    public void equals_not() {
+        SyncUser user = createTestUser();
+        String url1 = "realm://objectserver.realm.io/default1";
+        String url2 = "realm://objectserver.realm.io/default2";
+        SyncConfiguration config1 = new SyncConfiguration.Builder(user, url1).build();
+        SyncConfiguration config2 = new SyncConfiguration.Builder(user, url2).build();
+        assertFalse(config1.equals(config2));
+    }
+
+    @Test
+    public void hashCode_equal() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url)
+                .build();
+
+        assertEquals(config.hashCode(), config.hashCode());
+    }
+
+    @Test
+    public void hashCode_notEquals() {
+        SyncUser user = createTestUser();
+        String url1 = "realm://objectserver.realm.io/default1";
+        String url2 = "realm://objectserver.realm.io/default2";
+        SyncConfiguration config1 = new SyncConfiguration.Builder(user, url1).build();
+        SyncConfiguration config2 = new SyncConfiguration.Builder(user, url2).build();
+        assertNotEquals(config1.hashCode(), config2.hashCode());
+    }
+
+    @Test
+    public void get_syncSpecificValues() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url).build();
+        assertTrue(user.equals(config.getUser()));
+        assertEquals("realm://objectserver.realm.io/default", config.getServerUrl().toString());
+        assertFalse(config.shouldDeleteRealmOnLogout());
+        assertTrue(config.isSyncConfiguration());
+    }
+
+    @Test
+    public void encryption() {
+       SyncUser user = createTestUser();
+       String url = "realm://objectserver.realm.io/default";
+       SyncConfiguration config = new SyncConfiguration.Builder(user, url)
+               .encryptionKey(TestHelper.getRandomKey())
+               .build();
+       assertNotNull(config.getEncryptionKey());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void encryption_invalid_null() {
+       SyncUser user = createTestUser();
+       String url = "realm://objectserver.realm.io/default";
+
+       new SyncConfiguration.Builder(user, url).encryptionKey(null);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void encryption_invalid_wrong_length() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+
+        new SyncConfiguration.Builder(user, url).encryptionKey(new byte[]{1, 2, 3});
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void directory_null() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        new SyncConfiguration.Builder(user, url).directory(null);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void directory_writeProtectedDir() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+
+        File dir = new File("/");
+        new SyncConfiguration.Builder(user, url).directory(dir);
+    }
+
+    @Test
+    public void directory_dirIsAFile() throws IOException {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+
+        File dir = configFactory.getRoot();
+        File file = new File(dir, "dummyfile");
+        assertTrue(file.createNewFile());
+        thrown.expect(IllegalArgumentException.class);
+        new SyncConfiguration.Builder(user, url).directory(file);
+        file.delete(); // clean up
+    }
+
+    /* FIXME: deleteRealmOnLogout is not supported by now
+    @Test
+    public void deleteOnLogout() {
+        User user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url)
+                .deleteRealmOnLogout()
+                .build();
+        assertTrue(config.shouldDeleteRealmOnLogout());
+    }
+    */
+
+    @Test
+    public void initialData() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url)
+                .initialData(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                        StringOnly stringOnly = realm.createObject(StringOnly.class);
+                        stringOnly.setChars("TEST 42");
+                    }
+                })
+                .build();
+
+        assertNotNull(config.getInitialDataTransaction());
+
+        // open the first time - initialData must be triggered
+        Realm realm1 = Realm.getInstance(config);
+        RealmResults<StringOnly> results = realm1.where(StringOnly.class).findAll();
+        assertEquals(1, results.size());
+        assertEquals("TEST 42", results.first().getChars());
+        realm1.close();
+
+        // open the second time - initialData must not be triggered
+        Realm realm2 = Realm.getInstance(config);
+        assertEquals(1, realm2.where(StringOnly.class).count());
+        realm2.close();
+    }
+
+    @Test
+    public void defaultRxFactory() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url).build();
+
+        assertNotNull(config.getRxFactory());
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
new file mode 100644
index 0000000000..15d366a4da
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
@@ -0,0 +1,178 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.util.Collection;
+import java.util.Set;
+
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.util.SyncTestUtils.createTestUser;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(AndroidJUnit4.class)
+public class SyncManagerTests {
+
+    private Context context;
+    private UserStore userStore;
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    @Before
+    public void setUp() {
+        context = InstrumentationRegistry.getContext();
+        userStore = new UserStore() {
+            @Override
+            public SyncUser put(String key, SyncUser user) {
+                return null;
+            }
+
+            @Override
+            public SyncUser get(String key) {
+                return null;
+            }
+
+            @Override
+            public SyncUser remove(String key) {
+                return null;
+            }
+
+            @Override
+            public Collection<SyncUser> allUsers() {
+                return null;
+            }
+
+            @Override
+            public void clear() {
+            }
+        };
+    }
+
+    @After
+    public void tearDown() {
+    }
+
+    @Test
+    public void init() {
+        // Realm.init() calls SyncManager.init() wihich will start a thread for the sync client
+        boolean found = false;
+        Set<Thread> threads = Thread.getAllStackTraces().keySet();
+        for (Thread thread : threads) {
+            if (thread.getName().equals("RealmSyncClient")) {
+                found = true;
+                break;
+            }
+        }
+        assertTrue(found);
+    }
+
+    @Test
+    public void set_userStore() {
+        SyncManager.setUserStore(userStore);
+        assertTrue(userStore.equals(SyncManager.getUserStore()));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void set_userStore_null() {
+        SyncManager.setUserStore(null);
+    }
+
+    @Test
+    public void authListener() {
+        SyncUser user = createTestUser();
+        final int[] counter = {0, 0};
+
+        AuthenticationListener authenticationListener = new AuthenticationListener() {
+            @Override
+            public void loggedIn(SyncUser user) {
+                counter[0]++;
+            }
+
+            @Override
+            public void loggedOut(SyncUser user) {
+                counter[1]++;
+            }
+        };
+
+        SyncManager.addAuthenticationListener(authenticationListener);
+        SyncManager.notifyUserLoggedIn(user);
+        SyncManager.notifyUserLoggedOut(user);
+        assertEquals(1, counter[0]);
+        assertEquals(1, counter[1]);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void authListener_null() {
+        SyncManager.addAuthenticationListener(null);
+    }
+
+    @Test
+    public void authListener_remove() {
+        SyncUser user = createTestUser();
+        final int[] counter = {0, 0};
+
+        AuthenticationListener authenticationListener = new AuthenticationListener() {
+            @Override
+            public void loggedIn(SyncUser user) {
+                counter[0]++;
+            }
+
+            @Override
+            public void loggedOut(SyncUser user) {
+                counter[1]++;
+            }
+        };
+
+        SyncManager.addAuthenticationListener(authenticationListener);
+
+        SyncManager.removeAuthenticationListener(authenticationListener);
+
+        SyncManager.notifyUserLoggedIn(user);
+        SyncManager.notifyUserLoggedOut(user);
+
+        // no listener to update counters
+        assertEquals(0, counter[0]);
+        assertEquals(0, counter[1]);
+    }
+
+    @Test
+    public void session() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url)
+                .build();
+
+        SyncSession session = SyncManager.getSession(config);
+        assertEquals(user, session.getUser()); // see also SessionTests
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/UserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/UserTests.java
new file mode 100644
index 0000000000..794b41fc30
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/UserTests.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Collection;
+
+import io.realm.android.SharedPrefsUserStore;
+import io.realm.rule.RunInLooperThread;
+import io.realm.util.SyncTestUtils;
+
+import static io.realm.util.SyncTestUtils.createTestUser;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(AndroidJUnit4.class)
+public class UserTests {
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Before
+    public void setUp() {
+        Realm.init(InstrumentationRegistry.getTargetContext());
+        SyncManager.getUserStore().clear();
+    }
+
+    @Test
+    public void toAndFromJson() {
+        SyncUser user1 = createTestUser();
+        SyncUser user2 = SyncUser.fromJson(user1.toJson());
+        assertEquals(user1, user2);
+    }
+
+    // Tests that the UserStore does not return users that have expired
+    @Test
+    public void currentUser_returnsNullIfUserExpired() {
+        // Add an expired user to the user store
+        UserStore userStore = new SharedPrefsUserStore(InstrumentationRegistry.getContext());
+        SyncManager.setUserStore(userStore);
+        userStore.put(UserStore.CURRENT_USER_KEY, SyncTestUtils.createTestUser(Long.MIN_VALUE));
+
+        // Invalid users should not be returned when asking the for the current user
+        assertNull(SyncUser.currentUser());
+    }
+
+    // Test that current user is cleared if it is logged out
+    @Test
+    public void currentUser_clearedOnLogout() {
+        // Add an expired user to the user store
+        SyncUser user = SyncTestUtils.createTestUser(Long.MAX_VALUE);
+        UserStore userStore = new SharedPrefsUserStore(InstrumentationRegistry.getContext());
+        SyncManager.setUserStore(userStore);
+        userStore.put(UserStore.CURRENT_USER_KEY, user);
+
+        SyncUser savedUser = SyncUser.currentUser();
+        assertEquals(user, savedUser);
+        savedUser.logout();
+        assertNull(SyncUser.currentUser());
+    }
+
+    // `all()` returns an empty list if no users are logged in
+    @Test
+    public void all_empty() {
+        Collection<SyncUser> users = SyncUser.all();
+        assertTrue(users.isEmpty());
+    }
+
+    // `all()` returns only valid users. Invalid users are filtered.
+    @Test
+    public void all_validUsers() {
+        // Add 1 expired user and 1 valid user to the user store
+        UserStore userStore = new SharedPrefsUserStore(InstrumentationRegistry.getContext());
+        SyncManager.setUserStore(userStore);
+        userStore.put(UserStore.CURRENT_USER_KEY, SyncTestUtils.createTestUser(Long.MIN_VALUE));
+        userStore.put(UserStore.CURRENT_USER_KEY, SyncTestUtils.createTestUser(Long.MAX_VALUE));
+
+        Collection<SyncUser> users = SyncUser.all();
+        assertEquals(1, users.size());
+        assertTrue(users.iterator().next().isValid());
+    }
+
+    // Tests that the user store returns the last user to login
+    /* FIXME: This test fails because of wrong JSON string.
+    @Test
+    public void currentUser_returnsUserAfterLogin() {
+        AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
+        when(authServer.loginUser(any(Credentials.class), any(URL.class))).thenReturn(SyncTestUtils.createLoginResponse(Long.MAX_VALUE));
+
+        User user = User.login(Credentials.facebook("foo"), "http://bar.com/auth");
+        assertEquals(user, User.currentUser());
+    }
+    */
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
new file mode 100644
index 0000000000..a882b255a6
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.util;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.UUID;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.SyncUser;
+import io.realm.internal.network.AuthenticateResponse;
+import io.realm.internal.objectserver.ObjectServerUser;
+import io.realm.internal.objectserver.Token;
+
+public class SyncTestUtils {
+
+    public static String USER_TOKEN = UUID.randomUUID().toString();
+    public static String REALM_TOKEN = UUID.randomUUID().toString();
+
+    public static SyncUser createTestUser() {
+        return createTestUser(Long.MAX_VALUE);
+    }
+
+    public static SyncUser createTestUser(long expires) {
+        Token userToken = new Token(USER_TOKEN, "JohnDoe", null, expires, null);
+        Token accessToken = new Token(REALM_TOKEN, "JohnDoe", "/foo", expires, new Token.Permission[] {Token.Permission.DOWNLOAD });
+        ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(accessToken, "/data/data/myapp/files/default", false);
+
+        JSONObject obj = new JSONObject();
+        try {
+            JSONArray realmList = new JSONArray();
+            JSONObject realmDesc = new JSONObject();
+            realmDesc.put("uri", "realm://objectserver.realm.io/default");
+            realmDesc.put("description", desc.toJson());
+            realmList.put(realmDesc);
+
+            obj.put("authUrl", "http://objectserver.realm.io/auth");
+            obj.put("userToken", userToken.toJson());
+            obj.put("realms", realmList);
+            return SyncUser.fromJson(obj.toString());
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static AuthenticateResponse createLoginResponse(long expires) {
+        try {
+            Token userToken = new Token(USER_TOKEN, "JohnDoe", null, expires, null);
+            JSONObject response = new JSONObject();
+            response.put("refresh_token", userToken.toJson());
+            return AuthenticateResponse.from(response.toString());
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static AuthenticateResponse createRefreshResponse() {
+        try {
+            Token userToken = new Token(USER_TOKEN, "JohnDoe", null, Long.MAX_VALUE, null);
+            JSONObject response = new JSONObject();
+            response.put("refresh_token", userToken.toJson());
+            return AuthenticateResponse.from(response.toString());
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static AuthenticateResponse createErrorResponse(ErrorCode code) {
+        return AuthenticateResponse.from(new ObjectServerError(code, "dummy"));
+    }
+}
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index 22adbba0cf..8d9ce2b0ad 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -17,21 +17,41 @@ set(CMAKE_VERBOSE_MAKEFILE ON)
 # Generate compile_commands.json
 set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
 
-if (CMAKE_BUILD_TYPE STREQUAL "Release")
-    set(classes_PATH ${CMAKE_SOURCE_DIR}/../../../build/intermediates/classes/release/)
+# Setup lcache
+if(NDK_LCACHE)
+    set(CMAKE_CXX_CREATE_SHARED_LIBRARY "${NDK_LCACHE} ${CMAKE_CXX_CREATE_SHARED_LIBRARY}")
+endif()
+
+# Set flag build_SYNC
+if (REALM_FLAVOR STREQUAL base)
+    set(build_SYNC OFF)
 else()
-    set(classes_PATH ${CMAKE_SOURCE_DIR}/../../../build/intermediates/classes/debug/)
+    set(build_SYNC ON)
 endif()
 
+# Generate JNI header files. Each build has its own JNI header in its build_dir/jni_include.
+string(TOLOWER ${CMAKE_BUILD_TYPE} build_type_FOLDER)
+set(classes_PATH ${CMAKE_SOURCE_DIR}/../../../build/intermediates/classes/${REALM_FLAVOR}/${build_type_FOLDER}/)
+set(classes_LIST
+    io.realm.internal.Table io.realm.internal.TableView io.realm.internal.CheckedRow
+    io.realm.internal.LinkView io.realm.internal.Util io.realm.internal.UncheckedRow
+    io.realm.internal.TableQuery io.realm.internal.SharedRealm io.realm.internal.TestUtil
+    io.realm.log.LogLevel io.realm.log.RealmLog io.realm.Property io.realm.RealmSchema
+    io.realm.RealmObjectSchema
+)
+# /./ is the workaround for the problem that AS cannot find the jni headers.
+# See https://github.com/googlesamples/android-ndk/issues/319
+set(jni_headers_PATH /./${PROJECT_BINARY_DIR}/jni_include)
+if (build_SYNC)
+    list(APPEND classes_LIST
+        io.realm.SyncManager io.realm.internal.objectserver.ObjectServerSession)
+endif()
 create_javah(TARGET jni_headers
-  CLASSES io.realm.internal.Table io.realm.internal.TableView io.realm.internal.CheckedRow
-  io.realm.internal.LinkView io.realm.internal.Util io.realm.internal.UncheckedRow
-  io.realm.internal.TableQuery io.realm.internal.SharedRealm io.realm.internal.TestUtil
-  io.realm.log.LogLevel
-
-  CLASSPATH ${classes_PATH}
-  OUTPUT_DIR ${CMAKE_SOURCE_DIR}/jni_include
-  DEPENDS ${classes_PATH}
+    CLASSES ${classes_LIST}
+
+    CLASSPATH ${classes_PATH}
+    OUTPUT_DIR ${jni_headers_PATH}
+    DEPENDS ${classes_PATH}
 )
 
 # TODO: Ideally the debug build should link with core's debug build. But core dbg lib has
@@ -59,13 +79,32 @@ endif()
 add_library(lib_realm_core STATIC IMPORTED)
 set_target_properties(lib_realm_core PROPERTIES IMPORTED_LOCATION ${core_lib_PATH})
 
+# Sync static library
+set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-${ANDROID_ABI}.a)
+# Workaround for old core's funny ABI nicknames
+if (NOT EXISTS ${sync_lib_PATH})
+    if (ARMEABI)
+        set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm.a)
+    elseif (ARMEABI_V7A)
+        set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm-v7a.a)
+    elseif (ARM64_V8A)
+        set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm64.a)
+    else()
+        message(FATAL_ERROR "Cannot find core lib file: ${core_lib_PATH}")
+    endif()
+endif()
+add_library(lib_realm_sync STATIC IMPORTED)
+set_target_properties(lib_realm_sync PROPERTIES IMPORTED_LOCATION ${sync_lib_PATH})
+
 # build application's shared lib
 include_directories(${REALM_CORE_DIST_DIR}/include
     ${CMAKE_SOURCE_DIR}
-    ${CMAKE_SOURCE_DIR}/jni_include
+    ${jni_headers_PATH}
     ${CMAKE_SOURCE_DIR}/object-store/src)
 
 set(ANDROID_STL "gnustl_static")
+set(ANDROID_NO_UNDEFINED OFF)
+set(ANDROID_SO_UNDEFINED ON)
 
 if (ARMEABI)
     set(ABI_CXX_FLAGS "-mthumb")
@@ -77,41 +116,78 @@ endif()
 #      d.init(ValueBase::m_from_link_list, ValueBase::m_values, D{});
 #FIXME maybe-uninitialized is reported by table_view.cpp:272:15:
 #     'best.m_nanoseconds' was declared here
-set(WARNING_CXX_FLAGS "-Werror -Wall -Wextra -pedantic -Wno-long-long -Wno-variadic-macros \
+set(WARNING_CXX_FLAGS "-Wall -Wextra -pedantic -Wno-long-long -Wno-variadic-macros \
 -Wno-missing-field-initializers -Wmissing-declarations -Wno-error=uninitialized -Wno-error=maybe-uninitialized")
-set(REALM_COMMON_CXX_FLAGS "-DREALM_ANDROID -DREALM_HAVE_CONFIG -DPIC -pthread -fvisibility=hidden -std=c++14")
+set(REALM_COMMON_CXX_FLAGS "-DREALM_ANDROID -DREALM_HAVE_CONFIG -DPIC -pthread -fvisibility=hidden -std=c++14 -fsigned-char")
+if (build_SYNC)
+    set(REALM_COMMON_CXX_FLAGS "${REALM_COMMON_CXX_FLAGS} -DREALM_SYNC")
+endif()
 # There might be an issue with -Os of ndk gcc 4.9. It will hang the encryption related tests.
 # And this issue doesn't seem to impact the core compiling.
-set(CMAKE_CXX_FLAGS_RELEASE "-O2 -DNDEBUG -flto")
+set(CMAKE_CXX_FLAGS_RELEASE "-O2 -DNDEBUG")
 #-ggdb doesn't play well with -flto
 set(CMAKE_CXX_FLAGS_DEBUG "-ggdb -Og -DNDEBUG")
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${REALM_COMMON_CXX_FLAGS} ${WARNING_CXX_FLAGS} ${ABI_CXX_FLAGS}")
 
 # Set link flags
 set(REALM_LINKER_FLAGS "")
+if (build_SYNC)
+    set(REALM_LINKER_FLAGS "${REALM_LINKER_FLAGS} -lz")
+endif()
 set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ${REALM_LINKER_FLAGS}")
 
+# JNI source files
 file(GLOB jni_SRC
     "*.cpp"
+    "jni_util/*.cpp"
+    "jni_impl/android_logger.cpp"
 )
+# Those source file are only needed for sync.
+if (NOT build_SYNC)
+    list(REMOVE_ITEM jni_SRC
+        ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_SyncManager.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_internal_objectserver_ObjectServerSession.cpp)
+endif()
+
+# Object Store source files
 file(GLOB objectstore_SRC
-    "object-store/src/*.cpp"
-    "object-store/src/impl/*.cpp"
+    "object-store/src/collection_notifications.cpp"
+    "object-store/src/object_schema.cpp"
+    "object-store/src/object_store.cpp"
+    "object-store/src/schema.cpp"
+    "object-store/src/index_set.cpp"
+    "object-store/src/shared_realm.cpp"
+    "object-store/src/impl/realm_coordinator.cpp"
+    "object-store/src/impl/collection_notifier.cpp"
+    "object-store/src/impl/collection_change_builder.cpp"
+    "object-store/src/impl/transact_log_handler.cpp"
+    "object-store/src/impl/weak_realm_notifier.cpp"
     "object-store/src/impl/android/*.cpp"
-    "object-store/src/util/*.cpp"
-)
-add_library(realm-jni SHARED ${jni_SRC} ${objectstore_SRC})
+    "object-store/src/util/*.cpp")
+# Sync needed Object Store files
+if (build_SYNC)
+    file(GLOB objectstore_sync_SRC
+        "object-store/src/sync_manager.cpp"
+        "object-store/src/sync_session.cpp")
+endif()
+
+add_library(realm-jni SHARED ${jni_SRC} ${objectstore_SRC} ${objectstore_sync_SRC})
 add_dependencies(realm-jni jni_headers)
 # -latomic is not set by default for mips. See https://code.google.com/p/android/issues/detail?id=182094
+if (build_SYNC)
+# FIXME: The order matters! lib_realm_sync needs to be in front of lib_realm_core!! Find out why!!
+target_link_libraries(realm-jni log android atomic lib_realm_sync lib_realm_core)
+else()
 target_link_libraries(realm-jni log android atomic lib_realm_core)
+endif()
 
 # Strip the release so files and backup the unstripped versions
 if (CMAKE_BUILD_TYPE STREQUAL "Release")
-    set(unstripped_SO_DIR "${CMAKE_SOURCE_DIR}/../../../build/outputs/jniLibs-unstripped/${ANDROID_ABI}")
+    set(unstripped_SO_DIR
+        "${CMAKE_SOURCE_DIR}/../../../build/outputs/jniLibs-unstripped/${REALM_FLAVOR}/${ANDROID_ABI}")
     add_custom_command(TARGET realm-jni
         POST_BUILD
         COMMAND ${CMAKE_COMMAND} -E make_directory ${unstripped_SO_DIR}
         COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:realm-jni> ${unstripped_SO_DIR}
         COMMAND ${CMAKE_STRIP} $<TARGET_FILE:realm-jni>)
 endif()
-
diff --git a/realm/realm-library/src/main/cpp/io_realm_Property.cpp b/realm/realm-library/src/main/cpp/io_realm_Property.cpp
new file mode 100644
index 0000000000..b107982b07
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_Property.cpp
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+#include "io_realm_Property.h"
+
+#include <stdexcept>
+#include <object-store/src/property.hpp>
+#include <object-store/src/object_store.hpp>
+
+#include "util.hpp"
+
+using namespace realm;
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_Property_nativeCreateProperty__Ljava_lang_String_2IZZZ(JNIEnv *env, jclass, jstring name_,
+                                                                     jint type, jboolean is_primary, jboolean is_indexed,
+                                                                     jboolean is_nullable) {
+    TR_ENTER()
+    try {
+        JStringAccessor str(env, name_);
+        PropertyType p_type = static_cast<PropertyType>(static_cast<int>(type));
+        std::unique_ptr<Property> property(new Property(str, p_type, "", "", to_bool(is_primary), to_bool(is_indexed), to_bool(is_nullable)));
+        if (to_bool(is_indexed) && !property->is_indexable()) {
+            throw std::invalid_argument(
+                    "This field cannot be indexed - Only String/byte/short/int/long/boolean/Date fields are supported.");
+        }
+        if (to_bool(is_primary) && p_type != PropertyType::Int && p_type != PropertyType::String) {
+            std::string typ = property->type_string();
+            throw std::invalid_argument("Invalid primary key type: " + typ);
+        }
+        return reinterpret_cast<jlong>(property.release());
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_Property_nativeCreateProperty__Ljava_lang_String_2ILjava_lang_String_2(JNIEnv *env, jclass,
+                                                                                     jstring name_, jint type,
+                                                                                     jstring linkedToName_) {
+    TR_ENTER()
+    try {
+        JStringAccessor name(env, name_);
+        JStringAccessor link_name(env, linkedToName_);
+        PropertyType p_type = static_cast<PropertyType>(static_cast<int>(type));
+        bool is_nullable = (p_type == PropertyType::Object);
+        std::unique_ptr<Property> property(new Property(name, p_type, link_name, "", false, false, is_nullable));
+        return reinterpret_cast<jlong>(property.release());
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_Property_nativeClose(JNIEnv *env, jclass, jlong property_ptr) {
+    TR_ENTER_PTR(property_ptr)
+    try {
+        Property *property = reinterpret_cast<Property *>(property_ptr);
+        delete property;
+    }
+    CATCH_STD()
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmObjectSchema.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmObjectSchema.cpp
new file mode 100644
index 0000000000..a2227dacad
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmObjectSchema.cpp
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+#include "io_realm_RealmObjectSchema.h"
+
+#include <object-store/src/object_schema.hpp>
+#include <object-store/src/property.hpp>
+
+#include "util.hpp"
+using namespace realm;
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_RealmObjectSchema_nativeCreateRealmObjectSchema(JNIEnv *env, jclass, jstring className_) {
+    TR_ENTER()
+    try {
+        JStringAccessor name(env, className_);
+        ObjectSchema *object_schema = new ObjectSchema();
+        object_schema->name = name;
+        return reinterpret_cast<jlong>(object_schema);
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_RealmObjectSchema_nativeClose(JNIEnv *env, jclass, jlong native_ptr) {
+    TR_ENTER_PTR(native_ptr)
+    try {
+        ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(native_ptr);
+        delete object_schema;
+    }
+    CATCH_STD()
+}
+
+
+JNIEXPORT void JNICALL
+Java_io_realm_RealmObjectSchema_nativeAddProperty(JNIEnv *env, jclass, jlong native_ptr, jlong property_ptr) {
+    TR_ENTER_PTR(native_ptr)
+    try {
+        ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(native_ptr);
+        Property* property = reinterpret_cast<Property*>(property_ptr);
+        object_schema->persisted_properties.push_back(*property);
+        if (property->is_primary) {
+            object_schema->primary_key = property->name;
+        }
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT jstring JNICALL
+Java_io_realm_RealmObjectSchema_nativeGetClassName(JNIEnv *env, jclass, jlong nativePtr) {
+    TR_ENTER_PTR(nativePtr)
+    try {
+        ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(nativePtr);
+        auto name = object_schema->name;
+        return to_jstring(env, name);
+    }
+    CATCH_STD()
+
+    return NULL;
+}
+
+JNIEXPORT jlongArray JNICALL
+Java_io_realm_RealmObjectSchema_nativeGetProperties(JNIEnv *env, jclass, jlong nativePtr) {
+    TR_ENTER_PTR(nativePtr)
+    try {
+        ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(nativePtr);
+        size_t size = object_schema->persisted_properties.size();
+        jlongArray native_ptr_array = env->NewLongArray(static_cast<jsize>(size));
+        jlong* tmp = new jlong[size];
+        auto it = object_schema->persisted_properties.begin();
+        size_t index = 0;
+        while (it != object_schema->persisted_properties.end()) {
+            Property property = *it;
+            tmp[index] = reinterpret_cast<jlong>(new Property(std::move(property)));
+            ++index;
+            ++it;
+        }
+        env->SetLongArrayRegion(native_ptr_array, 0, static_cast<jsize>(size), tmp);
+        delete tmp;
+        return native_ptr_array;
+    }
+    CATCH_STD()
+
+    return NULL;
+}
+
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmSchema.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmSchema.cpp
new file mode 100644
index 0000000000..98649caff4
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmSchema.cpp
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+#include "io_realm_RealmSchema.h"
+
+#include <object-store/src/schema.hpp>
+#include <object-store/src/object_schema.hpp>
+#include <object-store/src/property.hpp>
+
+#include "util.hpp"
+using namespace realm;
+
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_RealmSchema_nativeCreateFromList(JNIEnv *env, jclass, jlongArray objectSchemaPtrs_) {
+    TR_ENTER()
+    try {
+        std::vector<ObjectSchema> object_schemas;
+        JniLongArray array(env, objectSchemaPtrs_);
+        for (jsize i = 0; i < array.len(); ++i) {
+            ObjectSchema object_schema = *reinterpret_cast<ObjectSchema*>(array[i]);
+            object_schemas.push_back(std::move(object_schema));
+        }
+        auto *schema = new Schema(object_schemas);
+        return reinterpret_cast<jlong>(schema);
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_RealmSchema_nativeClose(JNIEnv *env, jclass, jlong nativePtr) {
+    TR_ENTER_PTR(nativePtr)
+    Schema* schema = reinterpret_cast<Schema*>(nativePtr);
+    delete schema;
+}
+
+JNIEXPORT jlongArray JNICALL
+Java_io_realm_RealmSchema_nativeGetAll(JNIEnv *env, jclass, jlong nativePtr) {
+    TR_ENTER_PTR(nativePtr)
+    try {
+        Schema* schema = reinterpret_cast<Schema*>(nativePtr);
+        size_t size = schema->size();
+        jlongArray native_ptr_array = env->NewLongArray(static_cast<jsize>(size));
+        jlong* tmp = new jlong[size];
+        auto it = schema->begin();
+        size_t index = 0;
+        while (it != schema->end()) {
+            auto object_schema = *it;
+            tmp[index] = reinterpret_cast<jlong>(new ObjectSchema(std::move(object_schema)));
+            ++index;
+            ++it;
+        }
+        env->SetLongArrayRegion(native_ptr_array, 0, static_cast<jsize>(size), tmp);
+        delete tmp;
+        return native_ptr_array;
+    }
+    CATCH_STD()
+    return NULL;
+}
+
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
new file mode 100644
index 0000000000..e7da1e400c
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+
+#include <chrono>
+#include <functional>
+#include <mutex>
+#include <vector>
+
+#include <realm/group_shared.hpp>
+#include <realm/sync/history.hpp>
+#include <realm/sync/client.hpp>
+
+#include "objectserver_shared.hpp"
+
+#include "io_realm_SyncManager.h"
+
+#include "jni_util/log.hpp"
+
+using namespace realm;
+using namespace realm::sync;
+using namespace realm::jni_util;
+
+std::unique_ptr<Client> sync_client;
+
+static jclass sync_manager = nullptr;
+static jmethodID sync_manager_notify_error_handler = nullptr;
+
+static void error_handler(int error_code, std::string message)
+{
+    JNIEnv* env;
+    if (g_vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
+        throw std::runtime_error("JVM is not attached to this thread. Called in error_handler.");
+    }
+
+    env->CallStaticVoidMethod(sync_manager,
+                              sync_manager_notify_error_handler, error_code, env->NewStringUTF(message.c_str()));
+}
+
+JNIEXPORT void JNICALL Java_io_realm_SyncManager_nativeInitializeSyncClient
+    (JNIEnv *env, jclass sync_manager_class)
+{
+    TR_ENTER()
+    if (sync_client) return;
+
+    try {
+        sync::Client::Config config;
+        config.logger = &CoreLoggerBridge::shared();
+        sync_client = std::make_unique<Client>(std::move(config)); // Throws
+
+        // This function should only be called once, so below is safe.
+        sync_manager = reinterpret_cast<jclass>(env->NewGlobalRef(sync_manager_class));
+        sync_manager_notify_error_handler = env->GetStaticMethodID(sync_manager,
+                                                                   "notifyErrorHandler", "(ILjava/lang/String;)V");
+        sync_client->set_error_handler(error_handler);
+    } CATCH_STD()
+}
+
+// Create the thread from java side to avoid some strange errors when native throws.
+JNIEXPORT void JNICALL
+Java_io_realm_SyncManager_nativeRunClient(JNIEnv *env, jclass)
+{
+    try {
+        sync_client->run();
+    } CATCH_STD()
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
index e9116d021b..b419a697f6 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
@@ -147,7 +147,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNullLink
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLinkView
-  (JNIEnv* env, jclass obj, jlong nativeRowPtr, jlong columnIndex)
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
 {
     if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_LinkList))
         return 0;
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp
index d1c4b5c580..52079074e5 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp
@@ -29,7 +29,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClose
 JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetRow
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
 {
-    TR_ENTER_PTR(env, nativeLinkViewPtr)
+    TR_ENTER_PTR(nativeLinkViewPtr)
     LinkViewRef *lv = LV(nativeLinkViewPtr);
     if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return -1;
@@ -46,7 +46,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetRow
 JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetRowIndex
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong linkViewIndex)
 {
-    TR_ENTER_PTR(env, nativeLinkViewPtr)
+    TR_ENTER_PTR(nativeLinkViewPtr)
     LinkViewRef *lv = LV(nativeLinkViewPtr);
     if (!ROW_INDEX_VALID(env, *lv, linkViewIndex)) {
         return -1;
@@ -62,7 +62,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetRowIndex
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeAdd
   (JNIEnv* env, jclass, jlong nativeLinkViewPtr, jlong rowIndex)
 {
-    TR_ENTER_PTR(env, nativeLinkViewPtr)
+    TR_ENTER_PTR(nativeLinkViewPtr)
     LinkViewRef *lv = LV(nativeLinkViewPtr);
     try {
         LinkViewRef lvr = *lv;
@@ -74,7 +74,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeAdd
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeInsert
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos, jlong rowIndex)
 {
-    TR_ENTER_PTR(env, nativeLinkViewPtr)
+    TR_ENTER_PTR(nativeLinkViewPtr)
     LinkViewRef *lv = LV(nativeLinkViewPtr);
     try {
         LinkViewRef lvr = *lv;
@@ -86,7 +86,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeInsert
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeSet
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos, jlong rowIndex)
 {
-    TR_ENTER_PTR(env, nativeLinkViewPtr)
+    TR_ENTER_PTR(nativeLinkViewPtr)
     LinkViewRef *lv = LV(nativeLinkViewPtr);
     if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return;
@@ -101,7 +101,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeSet
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeMove
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong old_pos, jlong new_pos)
 {
-    TR_ENTER_PTR(env, nativeLinkViewPtr)
+    TR_ENTER_PTR(nativeLinkViewPtr)
     try {
         LinkViewRef *lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
@@ -120,7 +120,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeMove
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemove
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
 {
-    TR_ENTER_PTR(env, nativeLinkViewPtr)
+    TR_ENTER_PTR(nativeLinkViewPtr)
     LinkViewRef *lv = LV(nativeLinkViewPtr);
     if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return;
@@ -135,7 +135,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemove
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClear
   (JNIEnv* env, jclass, jlong nativeLinkViewPtr)
 {
-    TR_ENTER_PTR(env, nativeLinkViewPtr)
+    TR_ENTER_PTR(nativeLinkViewPtr)
     try {
         LinkViewRef *lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
@@ -148,7 +148,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeSize
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr)
 {
     
-    TR_ENTER_PTR(env, nativeLinkViewPtr)
+    TR_ENTER_PTR(nativeLinkViewPtr)
     try {
         LinkViewRef *lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
@@ -161,7 +161,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeSize
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsEmpty
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr)
 {
-    TR_ENTER_PTR(env, nativeLinkViewPtr)
+    TR_ENTER_PTR(nativeLinkViewPtr)
     try {
         LinkViewRef *lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
@@ -173,7 +173,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsEmpty
 JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeWhere
   (JNIEnv *env, jobject, jlong nativeLinkViewPtr)
 {
-    TR_ENTER_PTR(env, nativeLinkViewPtr)
+    TR_ENTER_PTR(nativeLinkViewPtr)
     try {
         LinkViewRef *lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
@@ -186,7 +186,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeWhere
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsAttached
   (JNIEnv *env, jobject, jlong nativeLinkViewPtr)
 {
-    TR_ENTER_PTR(env, nativeLinkViewPtr)
+    TR_ENTER_PTR(nativeLinkViewPtr)
     try {
         LinkViewRef *lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
@@ -198,7 +198,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsAttached
 JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeFind
   (JNIEnv *env, jobject, jlong nativeLinkViewPtr, jlong targetRowIndex)
 {
-    TR_ENTER_PTR(env, nativeLinkViewPtr)
+    TR_ENTER_PTR(nativeLinkViewPtr)
     try {
         LinkViewRef *lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
@@ -214,7 +214,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeFind
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveAllTargetRows
   (JNIEnv *env, jobject, jlong nativeLinkViewPtr)
 {
-    TR_ENTER_PTR(env, nativeLinkViewPtr)
+    TR_ENTER_PTR(nativeLinkViewPtr)
     try {
         LinkViewRef* lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
@@ -225,7 +225,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveAllTargetRows
 JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetTable
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr)
 {
-    TR_ENTER_PTR(env, nativeLinkViewPtr)
+    TR_ENTER_PTR(nativeLinkViewPtr)
 
     LinkViewRef* lv = LV(nativeLinkViewPtr);
     LinkViewRef lvr = *lv;
@@ -238,7 +238,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetTable
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveTargetRow
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
 {
-    TR_ENTER_PTR(env, nativeLinkViewPtr)
+    TR_ENTER_PTR(nativeLinkViewPtr)
     LinkViewRef* lv = LV(nativeLinkViewPtr);
     if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return;
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index 90d9b6b0eb..6d200de454 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -1,3 +1,4 @@
+#include <object-store/src/sync_manager.hpp>
 #include "io_realm_internal_SharedRealm.h"
 
 #include "object_store.hpp"
@@ -5,6 +6,9 @@
 
 #include "java_binding_context.hpp"
 #include "util.hpp"
+#ifdef REALM_SYNC
+#include "sync_config.hpp"
+#endif
 
 using namespace realm;
 using namespace realm::_impl;
@@ -20,12 +24,23 @@ static_assert(SchemaMode::Additive ==
 static_assert(SchemaMode::Manual ==
               static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_MANUAL), "");
 
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeInit(JNIEnv *env, jclass, jstring temporary_directory_path)
+{
+    TR_ENTER()
+
+    try {
+        JStringAccessor path(env, temporary_directory_path); // throws
+        realm::set_temporary_directory(std::string(path)); // throws
+    } CATCH_STD()
+}
+
 JNIEXPORT jlong JNICALL
 Java_io_realm_internal_SharedRealm_nativeCreateConfig(JNIEnv *env, jclass, jstring realm_path, jbyteArray key,
         jbyte schema_mode, jboolean in_memory, jboolean cache, jboolean disable_format_upgrade,
-        jboolean auto_change_notification)
+        jboolean auto_change_notification, jstring sync_server_url, jstring sync_user_token)
 {
-    TR_ENTER(env)
+    TR_ENTER()
 
     try {
         JStringAccessor path(env, realm_path); // throws
@@ -38,6 +53,15 @@ Java_io_realm_internal_SharedRealm_nativeCreateConfig(JNIEnv *env, jclass, jstri
         config->cache = cache;
         config->disable_format_upgrade = disable_format_upgrade;
         config->automatic_change_notifications = auto_change_notification;
+#ifdef REALM_SYNC
+        if (sync_server_url) {
+            JStringAccessor url(env, sync_server_url);
+            JStringAccessor token(env, sync_user_token);
+            config->sync_config = std::make_shared<SyncConfig>(token, url, nullptr, SyncSessionStopPolicy::Immediately);
+            // FIXME: Sync session is handled by java now. Remove this when adapt to OS sync implementation.
+            config->sync_config->create_session = false;
+        }
+#endif
         return reinterpret_cast<jlong>(config);
     } CATCH_STD()
 
@@ -47,7 +71,7 @@ Java_io_realm_internal_SharedRealm_nativeCreateConfig(JNIEnv *env, jclass, jstri
 JNIEXPORT void JNICALL
 Java_io_realm_internal_SharedRealm_nativeCloseConfig(JNIEnv* env, jclass, jlong config_ptr)
 {
-    TR_ENTER_PTR(env, config_ptr)
+    TR_ENTER_PTR(config_ptr)
 
     auto config = reinterpret_cast<realm::Realm::Config*>(config_ptr);
     delete config;
@@ -56,7 +80,7 @@ Java_io_realm_internal_SharedRealm_nativeCloseConfig(JNIEnv* env, jclass, jlong
 JNIEXPORT jlong JNICALL
 Java_io_realm_internal_SharedRealm_nativeGetSharedRealm(JNIEnv *env, jclass, jlong config_ptr, jobject notifier)
 {
-    TR_ENTER_PTR(env, config_ptr)
+    TR_ENTER_PTR(config_ptr)
 
     auto config = reinterpret_cast<realm::Realm::Config*>(config_ptr);
     try {
@@ -72,7 +96,7 @@ Java_io_realm_internal_SharedRealm_nativeGetSharedRealm(JNIEnv *env, jclass, jlo
 JNIEXPORT void JNICALL
 Java_io_realm_internal_SharedRealm_nativeCloseSharedRealm(JNIEnv* env, jclass, jlong shared_realm_ptr)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto ptr = reinterpret_cast<SharedRealm*>(shared_realm_ptr);
     delete ptr;
@@ -81,7 +105,7 @@ Java_io_realm_internal_SharedRealm_nativeCloseSharedRealm(JNIEnv* env, jclass, j
 JNIEXPORT void JNICALL
 Java_io_realm_internal_SharedRealm_nativeBeginTransaction(JNIEnv *env, jclass, jlong shared_realm_ptr)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -92,7 +116,7 @@ Java_io_realm_internal_SharedRealm_nativeBeginTransaction(JNIEnv *env, jclass, j
 JNIEXPORT void JNICALL
 Java_io_realm_internal_SharedRealm_nativeCommitTransaction(JNIEnv *env, jclass, jlong shared_realm_ptr)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -103,7 +127,7 @@ Java_io_realm_internal_SharedRealm_nativeCommitTransaction(JNIEnv *env, jclass,
 JNIEXPORT void JNICALL
 Java_io_realm_internal_SharedRealm_nativeCancelTransaction(JNIEnv *env, jclass, jlong shared_realm_ptr)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -115,7 +139,7 @@ Java_io_realm_internal_SharedRealm_nativeCancelTransaction(JNIEnv *env, jclass,
 JNIEXPORT jboolean JNICALL
 Java_io_realm_internal_SharedRealm_nativeIsInTransaction(JNIEnv* env, jclass, jlong shared_realm_ptr)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     return static_cast<jboolean>(shared_realm->is_in_transaction());
@@ -124,7 +148,7 @@ Java_io_realm_internal_SharedRealm_nativeIsInTransaction(JNIEnv* env, jclass, jl
 JNIEXPORT jlong JNICALL
 Java_io_realm_internal_SharedRealm_nativeReadGroup(JNIEnv *env, jclass , jlong shared_realm_ptr)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -137,21 +161,18 @@ Java_io_realm_internal_SharedRealm_nativeReadGroup(JNIEnv *env, jclass , jlong s
 JNIEXPORT jlong JNICALL
 Java_io_realm_internal_SharedRealm_nativeGetVersion(JNIEnv *env, jclass, jlong shared_realm_ptr)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return static_cast<jlong>(ObjectStore::get_schema_version(shared_realm->read_group()));
     } CATCH_STD()
-
-    // FIXME: Use constant value
-    return -1;
 }
 
 JNIEXPORT void JNICALL
 Java_io_realm_internal_SharedRealm_nativeSetVersion(JNIEnv *env, jclass, jlong shared_realm_ptr, jlong version)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -169,7 +190,7 @@ Java_io_realm_internal_SharedRealm_nativeSetVersion(JNIEnv *env, jclass, jlong s
 JNIEXPORT jboolean JNICALL
 Java_io_realm_internal_SharedRealm_nativeIsEmpty(JNIEnv *env, jclass, jlong shared_realm_ptr)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -181,7 +202,7 @@ Java_io_realm_internal_SharedRealm_nativeIsEmpty(JNIEnv *env, jclass, jlong shar
 JNIEXPORT void JNICALL
 Java_io_realm_internal_SharedRealm_nativeRefresh__J(JNIEnv *env, jclass, jlong shared_realm_ptr)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -193,7 +214,7 @@ JNIEXPORT void JNICALL
 Java_io_realm_internal_SharedRealm_nativeRefresh__JJJ(JNIEnv *env, jclass, jlong shared_realm_ptr, jlong version,
         jlong index)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     SharedGroup::VersionID version_id(static_cast<SharedGroup::version_type>(version),
@@ -208,7 +229,7 @@ Java_io_realm_internal_SharedRealm_nativeRefresh__JJJ(JNIEnv *env, jclass, jlong
 JNIEXPORT jlongArray JNICALL
 Java_io_realm_internal_SharedRealm_nativeGetVersionID(JNIEnv *env, jclass, jlong shared_realm_ptr)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -235,7 +256,7 @@ Java_io_realm_internal_SharedRealm_nativeGetVersionID(JNIEnv *env, jclass, jlong
 JNIEXPORT jboolean JNICALL
 Java_io_realm_internal_SharedRealm_nativeIsClosed(JNIEnv* env, jclass, jlong shared_realm_ptr)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     return static_cast<jboolean>(shared_realm->is_closed());
@@ -245,7 +266,7 @@ Java_io_realm_internal_SharedRealm_nativeIsClosed(JNIEnv* env, jclass, jlong sha
 JNIEXPORT jlong JNICALL
 Java_io_realm_internal_SharedRealm_nativeGetTable(JNIEnv *env, jclass, jlong shared_realm_ptr, jstring table_name)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     try {
         JStringAccessor name(env, table_name); // throws
@@ -267,7 +288,7 @@ JNIEXPORT jstring JNICALL
 Java_io_realm_internal_SharedRealm_nativeGetTableName(JNIEnv *env, jclass, jlong shared_realm_ptr, jint index)
 {
 
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -279,7 +300,7 @@ Java_io_realm_internal_SharedRealm_nativeGetTableName(JNIEnv *env, jclass, jlong
 JNIEXPORT jboolean JNICALL
 Java_io_realm_internal_SharedRealm_nativeHasTable(JNIEnv *env, jclass, jlong shared_realm_ptr, jstring table_name)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -293,7 +314,7 @@ JNIEXPORT void JNICALL
 Java_io_realm_internal_SharedRealm_nativeRenameTable(JNIEnv *env, jclass, jlong shared_realm_ptr,
         jstring old_table_name, jstring new_table_name)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -312,7 +333,7 @@ Java_io_realm_internal_SharedRealm_nativeRenameTable(JNIEnv *env, jclass, jlong
 JNIEXPORT void JNICALL
 Java_io_realm_internal_SharedRealm_nativeRemoveTable(JNIEnv *env, jclass, jlong shared_realm_ptr, jstring table_name)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -330,7 +351,7 @@ Java_io_realm_internal_SharedRealm_nativeRemoveTable(JNIEnv *env, jclass, jlong
 JNIEXPORT jlong JNICALL
 Java_io_realm_internal_SharedRealm_nativeSize(JNIEnv *env, jclass, jlong shared_realm_ptr)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -344,7 +365,7 @@ JNIEXPORT void JNICALL
 Java_io_realm_internal_SharedRealm_nativeWriteCopy(JNIEnv *env, jclass, jlong shared_realm_ptr, jstring path,
         jbyteArray key)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr);
+    TR_ENTER_PTR(shared_realm_ptr);
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -357,7 +378,7 @@ Java_io_realm_internal_SharedRealm_nativeWriteCopy(JNIEnv *env, jclass, jlong sh
 JNIEXPORT jboolean JNICALL
 Java_io_realm_internal_SharedRealm_nativeWaitForChange(JNIEnv *env, jclass, jlong shared_realm_ptr)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr);
+    TR_ENTER_PTR(shared_realm_ptr);
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -371,7 +392,7 @@ Java_io_realm_internal_SharedRealm_nativeWaitForChange(JNIEnv *env, jclass, jlon
 JNIEXPORT void JNICALL
 Java_io_realm_internal_SharedRealm_nativeStopWaitForChange(JNIEnv *env, jclass, jlong shared_realm_ptr)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr);
+    TR_ENTER_PTR(shared_realm_ptr);
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -383,7 +404,7 @@ Java_io_realm_internal_SharedRealm_nativeStopWaitForChange(JNIEnv *env, jclass,
 JNIEXPORT jboolean JNICALL
 Java_io_realm_internal_SharedRealm_nativeCompact(JNIEnv *env, jclass, jlong shared_realm_ptr)
 {
-    TR_ENTER_PTR(env, shared_realm_ptr);
+    TR_ENTER_PTR(shared_realm_ptr);
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
@@ -392,3 +413,31 @@ Java_io_realm_internal_SharedRealm_nativeCompact(JNIEnv *env, jclass, jlong shar
 
     return JNI_FALSE;
 }
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_SharedRealm_nativeGetSnapshotVersion(JNIEnv *env, jclass, jlong sharedRealmPtr)
+{
+    TR_ENTER_PTR(sharedRealmPtr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(sharedRealmPtr));
+    try {
+        using rf = realm::_impl::RealmFriend;
+        auto& shared_group = rf::get_shared_group(*shared_realm);
+        return LangBindHelper::get_version_of_latest_snapshot(shared_group);
+    } CATCH_STD ()
+    return 0;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeUpdateSchema(JNIEnv *env, jclass, jlong nativePtr,
+                                                      jlong nativeSchemaPtr, jlong version) {
+    TR_ENTER()
+    try {
+        auto shared_realm = *(reinterpret_cast<SharedRealm*>(nativePtr));
+        auto *schema = reinterpret_cast<Schema*>(nativeSchemaPtr);
+        shared_realm->update_schema(*schema, static_cast<uint64_t>(version));
+    }
+    CATCH_STD()
+}
+
+
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index 0f1eb70bed..6d1aac6c62 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -615,26 +615,31 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkTarget
     return 0;
 }
 
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsNull
+        (JNIEnv*, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+{
+    return TBL(nativeTablePtr)->is_null( S(columnIndex), S(rowIndex)) ? JNI_TRUE : JNI_FALSE;  // noexcept
+}
 
 // ----------------- Set cell
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLink
-  (JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong targetRowIndex)
+  (JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong targetRowIndex, jboolean isDefault)
 {
     if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Link))
         return;
     try {
-        TBL(nativeTablePtr)->set_link( S(columnIndex), S(rowIndex), S(targetRowIndex));
+        TBL(nativeTablePtr)->set_link( S(columnIndex), S(rowIndex), S(targetRowIndex), B(isDefault));
     } CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLong(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong value, jboolean isDefault)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Int))
         return;
     try {
-        TBL(nativeTablePtr)->set_int( S(columnIndex), S(rowIndex), value);
+        TBL(nativeTablePtr)->set_int( S(columnIndex), S(rowIndex), value, B(isDefault));
     } CATCH_STD()
 }
 
@@ -650,37 +655,37 @@ Java_io_realm_internal_Table_nativeSetLongUnique(JNIEnv *env, jclass, jlong nati
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetBoolean(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jboolean value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jboolean value, jboolean isDefault)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Bool))
         return;
     try {
-        TBL(nativeTablePtr)->set_bool( S(columnIndex), S(rowIndex), value == JNI_TRUE ? true : false);
+        TBL(nativeTablePtr)->set_bool( S(columnIndex), S(rowIndex), B(value), B(isDefault));
     } CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetFloat(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jfloat value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jfloat value, jboolean isDefault)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Float))
         return;
     try {
-        TBL(nativeTablePtr)->set_float( S(columnIndex), S(rowIndex), value);
+        TBL(nativeTablePtr)->set_float( S(columnIndex), S(rowIndex), value, B(isDefault));
     } CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDouble(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jdouble value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jdouble value, jboolean isDefault)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Double))
         return;
     try {
-        TBL(nativeTablePtr)->set_double( S(columnIndex), S(rowIndex), value);
+        TBL(nativeTablePtr)->set_double( S(columnIndex), S(rowIndex), value, B(isDefault));
     } CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jstring value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jstring value, jboolean isDefault)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_String))
         return;
@@ -691,7 +696,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString(
             }
         }
         JStringAccessor value2(env, value); // throws
-        TBL(nativeTablePtr)->set_string( S(columnIndex), S(rowIndex), value2);
+        TBL(nativeTablePtr)->set_string( S(columnIndex), S(rowIndex), value2, B(isDefault));
     } CATCH_STD()
 }
 
@@ -706,20 +711,22 @@ Java_io_realm_internal_Table_nativeSetStringUnique(JNIEnv *env, jclass, jlong na
             if (!TBL_AND_COL_NULLABLE(env, TBL(nativeTablePtr), columnIndex)) {
                 return;
             }
+            TBL(nativeTablePtr)->set_string_unique(S(columnIndex), S(rowIndex), null{});
+        } else {
+            JStringAccessor value2(env, value); // throws
+            TBL(nativeTablePtr)->set_string_unique(S(columnIndex), S(rowIndex), value2);
         }
-        JStringAccessor value2(env, value); // throws
-        // FIXME: Check if we need to call set_null_unique when core support it.
-        TBL(nativeTablePtr)->set_string_unique(S(columnIndex), S(rowIndex), value2);
     } CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetTimestamp(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong timestampValue)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong timestampValue, jboolean isDefault)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Timestamp))
         return;
     try {
-        TBL(nativeTablePtr)->set_timestamp( S(columnIndex), S(rowIndex), from_milliseconds(timestampValue));
+        TBL(nativeTablePtr)->set_timestamp( S(columnIndex), S(rowIndex), from_milliseconds(timestampValue),
+                                            B(isDefault));
     } CATCH_STD()
 }
 
@@ -736,7 +743,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteBuffer(
 */
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jbyteArray dataArray)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jbyteArray dataArray, jboolean isDefault)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Binary))
         return;
@@ -746,12 +753,12 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray(
         }
 
         JniByteArray byteAccessor(env, dataArray);
-        TBL(nativeTablePtr)->set_binary(S(columnIndex), S(rowIndex), byteAccessor);
+        TBL(nativeTablePtr)->set_binary(S(columnIndex), S(rowIndex), byteAccessor, B(isDefault));
     } CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jboolean isDefault)
 {
     Table* pTable = TBL(nativeTablePtr);
     if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
@@ -761,10 +768,27 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull(
     if (!TBL_AND_COL_NULLABLE(env, pTable, columnIndex))
         return;
     try {
-        pTable->set_null(S(columnIndex), S(rowIndex));
+        pTable->set_null(S(columnIndex), S(rowIndex), B(isDefault));
     } CATCH_STD()
 }
 
+JNIEXPORT void JNICALL
+Java_io_realm_internal_Table_nativeSetNullUnique(JNIEnv *env, jclass, jlong nativeTablePtr, jlong columnIndex,
+                                                 jlong rowIndex)
+{
+    Table* pTable = TBL(nativeTablePtr);
+    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
+        return;
+    if (!TBL_AND_ROW_INDEX_VALID(env, pTable, rowIndex))
+        return;
+    if (!TBL_AND_COL_NULLABLE(env, pTable, columnIndex))
+        return;
+    try {
+        pTable->set_null_unique(S(columnIndex), S(rowIndex));
+    } CATCH_STD()
+}
+
+
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetRowPtr
   (JNIEnv* env, jobject, jlong nativeTablePtr, jlong index)
 {
@@ -1384,13 +1408,13 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsValid(
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClose(
     JNIEnv* env, jclass, jlong nativeTablePtr)
 {
-    TR_ENTER_PTR(env, nativeTablePtr)
+    TR_ENTER_PTR(nativeTablePtr)
     LangBindHelper::unbind_table_ptr(TBL(nativeTablePtr));
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_createNative(JNIEnv *env, jobject)
 {
-    TR_ENTER(env)
+    TR_ENTER()
     try {
         return reinterpret_cast<jlong>(LangBindHelper::new_table());
     } CATCH_STD()
@@ -1478,7 +1502,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
                 // No primary key is currently set
                 if (check_valid_primary_key_column(env, table, new_primary_key_column_name)) {
                     row_index = pk_table->add_empty_row();
-                    pk_table->set_string(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, row_index, table_name);
+                    pk_table->set_string_unique(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, row_index, table_name);
                     pk_table->set_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index, new_primary_key_column_name);
                 }
             }
@@ -1511,17 +1535,23 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
 // - All Realms created by Cocoa and used by Realm-android up to 0.84.1
 // - All Realms created by Realm-Android 0.84.1 and below
 // See https://github.com/realm/realm-java/issues/1703
+//
+// 3> PK table's column 'pk_table' needs search index in order to use set_string_unique.
+// This affects:
+// - All Realms created by Cocoa and used by Realm-java before 2.0.0
+// See https://github.com/realm/realm-java/pull/3488
 
 // This methods converts the old (wrong) table format (string, integer) to the right (string,string) format and strips
 // any class names in the col[0] of their "class_" prefix
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded
-    (JNIEnv*, jobject, jlong groupNativePtr, jlong privateKeyTableNativePtr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded
+    (JNIEnv*, jclass, jlong groupNativePtr, jlong privateKeyTableNativePtr)
 {
     const size_t CLASS_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX;
     const size_t FIELD_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX;
 
     auto group = reinterpret_cast<Group*>(groupNativePtr);
     Table* pk_table = TBL(privateKeyTableNativePtr);
+    jboolean changed = JNI_FALSE;
 
     // Fix wrong types (string, int) -> (string, string)
     if (pk_table->get_column_type(FIELD_COLUMN_INDEX) == type_Int) {
@@ -1542,6 +1572,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTable
         // The column index for the renamed column will then be the same as the deleted old column
         pk_table->remove_column(FIELD_COLUMN_INDEX);
         pk_table->rename_column(pk_table->get_column_index(tmp_col_name), StringData("pk_property"));
+        changed = JNI_TRUE;
     }
 
     // If needed remove "class_" prefix from class names
@@ -1553,8 +1584,45 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTable
             std::string str(table_name.substr(TABLE_PREFIX.length()));
             StringData sd(str);
             pk_table->set_string(CLASS_COLUMN_INDEX, row_ndx, sd);
+            changed = JNI_TRUE;
         }
     }
+
+    // From realm-java 2.0.0, pk table's class column requires a search index.
+    if (!pk_table->has_search_index(CLASS_COLUMN_INDEX)) {
+        pk_table->add_search_index(CLASS_COLUMN_INDEX);
+        changed = JNI_TRUE;
+    }
+    return changed;
+}
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_Table_nativePrimaryKeyTableNeedsMigration(JNIEnv *, jclass, jlong primaryKeyTableNativePtr)
+{
+
+    const size_t CLASS_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX;
+    const size_t FIELD_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX;
+
+    Table* pk_table = TBL(primaryKeyTableNativePtr);
+
+    // Fix wrong types (string, int) -> (string, string)
+    if (pk_table->get_column_type(FIELD_COLUMN_INDEX) == type_Int) {
+        return JNI_TRUE;
+    }
+
+    // If needed remove "class_" prefix from class names
+    size_t number_of_rows = pk_table->size();
+    for (size_t row_ndx = 0; row_ndx < number_of_rows; row_ndx++) {
+        StringData table_name = pk_table->get_string(CLASS_COLUMN_INDEX, row_ndx);
+        if (table_name.begins_with(TABLE_PREFIX)) {
+            return JNI_TRUE;
+        }
+    }
+    // From realm-java 2.0.0, pk table's class column requires a search index.
+    if (!pk_table->has_search_index(CLASS_COLUMN_INDEX)) {
+        return JNI_TRUE;
+    }
+    return JNI_FALSE;
 }
 
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSameSchema
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
index 2f038e1d69..b5e89f153b 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
@@ -47,7 +47,7 @@ const char* ERR_SORT_NOT_SUPPORTED = "Sort is not supported on binary data, obje
 //-------------------------------------------------------
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeClose(JNIEnv* env, jclass, jlong nativeQueryPtr) {
-    TR_ENTER_PTR(env, nativeQueryPtr)
+    TR_ENTER_PTR(nativeQueryPtr)
     delete Q(nativeQueryPtr);
 }
 
@@ -87,7 +87,7 @@ static TableRef getTableByArray(jlong nativeQueryPtr, JniLongArray& indicesArray
 
 static jlong findAllWithHandover(JNIEnv* env, jlong bgSharedRealmPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit)
 {
-    TR_ENTER(env)
+    TR_ENTER()
     TableRef table = query.get()->get_table();
     if (!QUERY_VALID(env, query.get()) ||
         !ROW_INDEXES_VALID(env, table.get(), start, end, limit)) {
@@ -116,7 +116,8 @@ static jlong getDistinctViewWithHandover
             case type_Int:
             case type_Timestamp:
             case type_String: {
-                TableView tableView(table->get_distinct_view(S(columnIndex)) );
+                TableView tableView(query->find_all());
+                tableView.distinct(S(columnIndex));
 
                 // handover the result
                 auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
@@ -1099,7 +1100,7 @@ static std::unique_ptr<Query> handoverQueryToWorker(jlong bgSharedRealmPtr, jlon
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover(
     JNIEnv* env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong fromTableRow)
 {
-    TR_ENTER(env)
+    TR_ENTER()
     try {
         std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, false); // throws
         TableRef table = query->get_table();
@@ -1135,7 +1136,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlong start, jlong end, jlong limit)
 {
-    TR_ENTER(env)
+    TR_ENTER()
     Query* query = Q(nativeQueryPtr);
     TableRef table =  query->get_table();
     if (!QUERY_VALID(env, query) ||
@@ -1152,7 +1153,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll(
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllWithHandover
   (JNIEnv* env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong start, jlong end, jlong limit)
   {
-      TR_ENTER(env)
+      TR_ENTER()
       try {
           std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, true); // throws
           return findAllWithHandover(env, bgSharedRealmPtr, std::move(query), start, end, limit);
@@ -1173,7 +1174,7 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdate
          jobjectArray  multi_sorted_indices_matrix,
          jobjectArray  multi_sorted_order_matrix)
 {
-    TR_ENTER(env)
+    TR_ENTER()
     try {
         JniLongArray handover_queries_pointer_array(env, handover_queries_array);
 
@@ -1289,7 +1290,7 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdate
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetDistinctViewWithHandover
         (JNIEnv *env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong columnIndex)
 {
-    TR_ENTER(env)
+    TR_ENTER()
     try {
         std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, true); // throws
         return getDistinctViewWithHandover(env, bgSharedRealmPtr, std::move(query), columnIndex);
@@ -1300,7 +1301,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetDistinctViewW
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllSortedWithHandover
   (JNIEnv *env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlong columnIndex, jboolean ascending)
   {
-      TR_ENTER(env)
+      TR_ENTER()
       try {
           std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, true); // throws
           return findAllSortedWithHandover(env, bgSharedRealmPtr, std::move(query), start, end, limit, columnIndex, ascending);
@@ -1311,7 +1312,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllSortedWit
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllMultiSortedWithHandover
   (JNIEnv *env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlongArray columnIndices, jbooleanArray ascending)
   {
-      TR_ENTER(env)
+      TR_ENTER()
       try {
           // import the handover query pointer using the background SharedRealm
           std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, true); // throws
@@ -1709,7 +1710,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverTableViewIntoSharedGroup
   (JNIEnv *env, jobject, jlong handoverPtr, jlong callerSharedGrpPtr)
   {
-    TR_ENTER_PTR(env, handoverPtr)
+    TR_ENTER_PTR(handoverPtr)
     SharedGroup::Handover<TableView> *handoverTableViewPtr = HO(TableView, handoverPtr);
     std::unique_ptr<SharedGroup::Handover<TableView>> handoverTableView(handoverTableViewPtr);
     try {
@@ -1729,7 +1730,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverTa
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRowIntoSharedGroup
   (JNIEnv *env, jclass, jlong handoverPtr, jlong callerSharedGrpPtr)
   {
-      TR_ENTER_PTR(env, handoverPtr)
+      TR_ENTER_PTR(handoverPtr)
       SharedGroup::Handover<Row> *handoverRowPtr = HO(Row, handoverPtr);
       std::unique_ptr<SharedGroup::Handover<Row>> handoverRow(handoverRowPtr);
 
@@ -1750,7 +1751,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRo
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery
    (JNIEnv* env, jobject, jlong bgSharedRealmPtr, jlong nativeQueryPtr)
 {
-    TR_ENTER_PTR(env, nativeQueryPtr)
+    TR_ENTER_PTR(nativeQueryPtr)
     Query* pQuery = Q(nativeQueryPtr);
     if (!QUERY_VALID(env, pQuery))
         return 0;
@@ -1767,7 +1768,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseQueryHandover
   (JNIEnv* env, jclass, jlong nativeHandoverQuery)
   {
-    TR_ENTER_PTR(env, nativeHandoverQuery)
+    TR_ENTER_PTR(nativeHandoverQuery)
     delete HO(Query, nativeHandoverQuery);
   }
 
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TableView.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TableView.cpp
index b4d561be94..8d9aa78bd5 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_TableView.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TableView.cpp
@@ -317,6 +317,17 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetLink
     return TV(nativeViewPtr)->get_link( S(columnIndex), S(rowIndex));  // noexcept
 }
 
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_TableView_nativeIsNull
+        (JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
+{
+    try {
+        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
+            return 0;
+        return TV(nativeViewPtr)->get_parent().is_null( S(columnIndex), TV(nativeViewPtr)->get_source_ndx(S(rowIndex))) ? JNI_TRUE : JNI_FALSE;  // noexcept
+    } CATCH_STD()
+    return 0;
+}
+
 // Setters
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetLong(
@@ -934,7 +945,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToJson(
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere(
     JNIEnv *env, jobject, jlong nativeViewPtr)
 {
-    TR_ENTER_PTR(env, nativeViewPtr)
+    TR_ENTER_PTR(nativeViewPtr)
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
             return 0;
@@ -964,7 +975,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSyncIfNeeded(
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindBySourceNdx
         (JNIEnv *env, jobject, jlong nativeViewPtr, jlong sourceIndex)
 {
-    TR_ENTER_PTR(env, nativeViewPtr);
+    TR_ENTER_PTR(nativeViewPtr);
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) || !ROW_INDEX_VALID(env, &(TV(nativeViewPtr)->get_parent()), sourceIndex))
             return -1;
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
index 5f2fc6c1d7..6ee249c77e 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
@@ -22,7 +22,7 @@ using namespace realm;
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnCount
   (JNIEnv *env, jobject, jlong nativeRowPtr)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW(nativeRowPtr)->is_attached())
         return 0;
 
@@ -32,7 +32,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnCount
 JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnName
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -45,7 +45,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnNam
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnIndex
   (JNIEnv* env, jobject, jlong nativeRowPtr, jstring columnName)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW(nativeRowPtr)->is_attached())
         return 0;
 
@@ -59,14 +59,14 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnIndex
 JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnType
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     return static_cast<jint>( ROW(nativeRowPtr)->get_column_type( S(columnIndex)) ); // noexcept
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetIndex
   (JNIEnv* env, jobject, jlong nativeRowPtr)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -76,7 +76,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetIndex
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLong
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -86,7 +86,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLong
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeGetBoolean
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -96,7 +96,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeGetBoolean
 JNIEXPORT jfloat JNICALL Java_io_realm_internal_UncheckedRow_nativeGetFloat
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -106,7 +106,7 @@ JNIEXPORT jfloat JNICALL Java_io_realm_internal_UncheckedRow_nativeGetFloat
 JNIEXPORT jdouble JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDouble
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -116,7 +116,7 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDouble
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetTimestamp
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -126,7 +126,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetTimestamp
 JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetString
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -140,7 +140,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetString
 JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_UncheckedRow_nativeGetByteArray
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -163,7 +163,7 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_UncheckedRow_nativeGetByteAr
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -176,7 +176,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLink
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNullLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -184,9 +184,9 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNullLink
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView
-  (JNIEnv* env, jclass, jlong nativeRowPtr, jlong columnIndex)
+  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -197,7 +197,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLong
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
@@ -209,7 +209,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLong
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetBoolean
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jboolean value)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
@@ -221,7 +221,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetBoolean
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetFloat
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jfloat value)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
@@ -233,7 +233,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetFloat
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDouble
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jdouble value)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
@@ -245,7 +245,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDouble
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetTimestamp
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
@@ -257,7 +257,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetTimestamp
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetString
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jstring value)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
@@ -274,7 +274,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetString
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetByteArray
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jbyteArray value)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
 
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
@@ -307,7 +307,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetByteArray
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
@@ -319,7 +319,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLink
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeNullifyLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
@@ -331,14 +331,14 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeNullifyLink
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeClose
   (JNIEnv* env, jclass, jlong nativeRowPtr)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     delete ROW(nativeRowPtr);
 }
 
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsAttached
   (JNIEnv* env, jobject, jlong nativeRowPtr)
 {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     return ROW(nativeRowPtr)->is_attached();
 }
 
@@ -351,13 +351,13 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeHasColumn
 
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNull
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex) {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     return ROW(nativeRowPtr)->is_null(columnIndex);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetNull
   (JNIEnv *env, jobject, jlong nativeRowPtr, jlong columnIndex) {
-    TR_ENTER_PTR(env, nativeRowPtr)
+    TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
     if (!TBL_AND_COL_NULLABLE(env, ROW(nativeRowPtr)->get_table(), columnIndex))
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
index 2641cc5ca5..241ce22908 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
@@ -19,7 +19,6 @@
 #include <realm/string_data.hpp>
 #include <realm/unicode.hpp>
 
-#include "io_realm_log_LogLevel.h"
 #include "mem_usage.hpp"
 #include "util.hpp"
 
@@ -30,16 +29,6 @@ using std::string;
     #include "C:\\Program Files (x86)\\Visual Leak Detector\\include\\vld.h"
 #endif
 
-// used by logging
-int trace_level = 0;
-jclass realmlog_class;
-jmethodID log_trace;
-jmethodID log_debug;
-jmethodID log_info;
-jmethodID log_warn;
-jmethodID log_error;
-jmethodID log_fatal;
-
 const string TABLE_PREFIX("class_");
 
 
@@ -50,6 +39,7 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
         return JNI_ERR;
     }
     else {
+        g_vm = vm;
         // Loading classes and constructors for later use - used by box typed fields and a few methods' return value
         java_lang_long        = GetClass(env, "java/lang/Long");
         java_lang_long_init   = env->GetMethodID(java_lang_long, "<init>", "(J)V");
@@ -57,13 +47,6 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
         java_lang_float_init  = env->GetMethodID(java_lang_float, "<init>", "(F)V");
         java_lang_double      = GetClass(env, "java/lang/Double");
         java_lang_double_init = env->GetMethodID(java_lang_double, "<init>", "(D)V");
-        realmlog_class        = GetClass(env, "io/realm/log/RealmLog");
-        log_trace             = env->GetStaticMethodID(realmlog_class, "trace", "(Ljava/lang/String;[Ljava/lang/Object;)V");
-        log_debug             = env->GetStaticMethodID(realmlog_class, "debug", "(Ljava/lang/String;[Ljava/lang/Object;)V");
-        log_info              = env->GetStaticMethodID(realmlog_class, "info", "(Ljava/lang/String;[Ljava/lang/Object;)V");
-        log_warn              = env->GetStaticMethodID(realmlog_class, "warn", "(Ljava/lang/String;[Ljava/lang/Object;)V");
-        log_error             = env->GetStaticMethodID(realmlog_class, "error", "(Ljava/lang/String;[Ljava/lang/Object;)V");
-        log_fatal             = env->GetStaticMethodID(realmlog_class, "fatal", "(Ljava/lang/String;[Ljava/lang/Object;)V");
     }
 
     return JNI_VERSION_1_6;
@@ -82,21 +65,6 @@ JNIEXPORT void JNI_OnUnload(JavaVM* vm, void*)
     }
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Util_nativeSetDebugLevel(JNIEnv*, jclass, jint level)
-{
-    /**
-     * level should match one of the levels defined in LogLevel.java
-     * ALL = 1
-     * TRACE = 2
-     * DEBUG = 3
-     * INFO = 4
-     * WARN = 5
-     * ERROR = 6
-     * FATAL = 7
-     * OFF = 8
-     */
-    trace_level = level;
-}
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Util_nativeGetMemUsage(JNIEnv*, jclass)
 {
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_objectserver_ObjectServerSession.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_objectserver_ObjectServerSession.cpp
new file mode 100644
index 0000000000..ea0ebecc4a
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_objectserver_ObjectServerSession.cpp
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+
+#include "io_realm_internal_objectserver_ObjectServerSession.h"
+#include "objectserver_shared.hpp"
+#include "util.hpp"
+#include <realm/group_shared.hpp>
+#include <realm/replication.hpp>
+
+#include <realm/sync/history.hpp>
+#include <realm/sync/client.hpp>
+#include <realm/util/logger.hpp>
+#include <mutex>
+#include <thread>
+#include <vector>
+#include <chrono>
+#include <functional>
+#include <android/log.h>
+
+using namespace std;
+using namespace realm;
+using namespace sync;
+
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_objectserver_ObjectServerSession_nativeCreateSession
+  (JNIEnv *env, jobject obj, jstring localRealmPath)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor local_path(env, localRealmPath);
+        JniSession* jni_session = new JniSession(env, local_path, obj);
+        return reinterpret_cast<jlong>(jni_session);
+    } CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectserver_ObjectServerSession_nativeBind
+  (JNIEnv *env, jobject, jlong sessionPointer, jstring remoteUrl, jstring accessToken)
+{
+    TR_ENTER()
+    try {
+        auto *session_wrapper = reinterpret_cast<JniSession*>(sessionPointer);
+
+        const char *token_tmp = env->GetStringUTFChars(accessToken, NULL);
+        std::string access_token(token_tmp);
+        env->ReleaseStringUTFChars(accessToken, token_tmp);
+
+        JStringAccessor url_tmp(env, remoteUrl); // throws
+        StringData remote_url = StringData(url_tmp);
+
+        // Bind the local Realm to the remote one
+        session_wrapper->get_session()->bind(remote_url, access_token);
+    } CATCH_STD()
+}
+
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectserver_ObjectServerSession_nativeUnbind
+  (JNIEnv *env, jobject, jlong sessionPointer)
+{
+    TR_ENTER()
+    JniSession* session = SS(sessionPointer);
+    session->close(env);
+    delete session; // TODO Can we avoid killing the session here?
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectserver_ObjectServerSession_nativeRefresh
+  (JNIEnv *env, jobject, jlong sessionPointer, jstring accessToken)
+{
+    TR_ENTER()
+    try {
+        JniSession* session_wrapper = SS(sessionPointer);
+
+        JStringAccessor token_tmp(env, accessToken); // throws
+        StringData access_token = StringData(token_tmp);
+
+        session_wrapper->get_session()->refresh(access_token);
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_objectserver_ObjectServerSession_nativeNotifyCommitHappened
+  (JNIEnv *env, jobject, jlong sessionPointer, jlong version)
+{
+    TR_ENTER()
+    try {
+        JniSession* session_wrapper = SS(sessionPointer);
+        session_wrapper->get_session()->nonsync_transact_notify(version);
+    } CATCH_STD()
+}
+
+
diff --git a/realm/realm-library/src/main/cpp/io_realm_log_RealmLog.cpp b/realm/realm-library/src/main/cpp/io_realm_log_RealmLog.cpp
new file mode 100644
index 0000000000..45aa8a72c2
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_log_RealmLog.cpp
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_log_RealmLog.h"
+#include "jni_util/log.hpp"
+#include "util.hpp"
+
+using namespace realm::util;
+using namespace realm::jni_util;
+
+JNIEXPORT void JNICALL
+Java_io_realm_log_RealmLog_nativeAddLogger(JNIEnv *env, jclass, jobject java_logger)
+{
+    try {
+        Log::shared().add_java_logger(env, java_logger);
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_log_RealmLog_nativeRemoveLogger(JNIEnv *env, jclass, jobject java_logger)
+{
+    try {
+        Log::shared().remove_java_logger(env, java_logger);
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_log_RealmLog_nativeClearLoggers(JNIEnv *env, jclass)
+{
+    try {
+        Log::shared().clear_loggers();
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_log_RealmLog_nativeRegisterDefaultLogger(JNIEnv *env, jclass)
+{
+    try {
+        Log::shared().register_default_logger();
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_log_RealmLog_nativeLog(JNIEnv *env, jclass, jint level, jstring tag, jthrowable throwable,
+                                     jstring message)
+{
+    try {
+        JStringAccessor tag_accessor(env, tag);
+        JStringAccessor message_accessor(env, message);
+        Log::shared().log(static_cast<Log::Level>(level), std::string(tag_accessor).c_str(), throwable,
+                          std::string(message_accessor).c_str());
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_log_RealmLog_nativeSetLogLevel(JNIEnv *env, jclass, jint level)
+{
+    try {
+        Log::shared().set_level(static_cast<Log::Level>(level));
+    } CATCH_STD()
+}
+
+JNIEXPORT jint JNICALL
+Java_io_realm_log_RealmLog_nativeGetLogLevel(JNIEnv *env, jclass)
+{
+    try {
+        return static_cast<jint>(Log::shared().get_level());
+    } CATCH_STD()
+
+    return static_cast<jint>(Log::Level::all);
+}
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.hpp b/realm/realm-library/src/main/cpp/java_binding_context.hpp
index ee96a000a5..a058691b3e 100644
--- a/realm/realm-library/src/main/cpp/java_binding_context.hpp
+++ b/realm/realm-library/src/main/cpp/java_binding_context.hpp
@@ -51,7 +51,12 @@ class JavaBindingContext final : public BindingContext {
     virtual ~JavaBindingContext();
     virtual void changes_available();
 
-    JavaBindingContext(const ConcreteJavaBindContext&);
+    explicit JavaBindingContext(const ConcreteJavaBindContext&);
+    JavaBindingContext(const JavaBindingContext&) = delete;
+    JavaBindingContext& operator=(const JavaBindingContext&) = delete;
+    JavaBindingContext(JavaBindingContext&&) = delete;
+    JavaBindingContext& operator=(JavaBindingContext&&) = delete;
+
     static inline std::unique_ptr<JavaBindingContext> create(JNIEnv* env, jobject notifier)
     {
         return std::make_unique<JavaBindingContext>(ConcreteJavaBindContext{env, notifier});
diff --git a/realm/realm-library/src/main/cpp/jni_impl/android_logger.cpp b/realm/realm-library/src/main/cpp/jni_impl/android_logger.cpp
new file mode 100644
index 0000000000..b50ff1902a
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_impl/android_logger.cpp
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <cstring>
+
+#include "util/format.hpp"
+
+#include "android_logger.hpp"
+
+using namespace realm;
+using namespace realm::jni_util;
+using namespace realm::jni_impl;
+using namespace realm::util;
+
+std::shared_ptr<AndroidLogger> AndroidLogger::shared()
+{
+    // Private constructor, make_shared is not available.
+    static std::shared_ptr<AndroidLogger> android_logger(new AndroidLogger());
+    return android_logger;
+}
+
+void AndroidLogger::log(Log::Level level, const char* tag, jthrowable, const char* message) {
+    android_LogPriority android_log_priority;
+    switch (level) {
+        case Log::Level::trace:
+            android_log_priority = ANDROID_LOG_VERBOSE;
+            break;
+        case Log::Level::debug:
+            android_log_priority = ANDROID_LOG_DEBUG;
+            break;
+        case Log::Level::info:
+            android_log_priority = ANDROID_LOG_INFO;
+            break;
+        case Log::Level::warn:
+            android_log_priority = ANDROID_LOG_WARN;
+            break;
+        case Log::Level::error:
+            android_log_priority = ANDROID_LOG_ERROR;
+            break;
+        case Log::Level::fatal:
+            android_log_priority = ANDROID_LOG_FATAL;
+            break;
+        default:// Cannot get here.
+            throw std::invalid_argument(format("Invalid log level: %1.", level));
+    }
+    if (message) {
+        print(android_log_priority, tag, message);
+    }
+}
+
+void AndroidLogger::print(android_LogPriority priority, const char* tag, const char* log_string)
+{
+    size_t log_size = strlen(log_string);
+
+    if (log_size > LOG_ENTRY_MAX_LENGTH) {
+        size_t start = 0;
+
+        while (start < log_size) {
+            size_t count = log_size - start > LOG_ENTRY_MAX_LENGTH ? LOG_ENTRY_MAX_LENGTH : log_size - start;
+            std::string tmp_str(log_string, start, count);
+            __android_log_write(priority, tag, tmp_str.c_str());
+            start += count;
+        }
+    } else {
+        __android_log_write(priority, tag, log_string);
+    }
+}
+
+namespace realm {
+namespace jni_util {
+
+std::shared_ptr<JniLogger> get_default_logger()
+{
+    return std::static_pointer_cast<JniLogger>(AndroidLogger::shared());
+}
+
+}
+}
+
+
diff --git a/realm/realm-library/src/main/cpp/jni_impl/android_logger.hpp b/realm/realm-library/src/main/cpp/jni_impl/android_logger.hpp
new file mode 100644
index 0000000000..6b90c0f6c6
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_impl/android_logger.hpp
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_IMPL_ANDROID_LOGGER_HPP
+#define REALM_JNI_IMPL_ANDROID_LOGGER_HPP
+
+#include <android/log.h>
+#include "jni_util/log.hpp"
+
+namespace realm {
+namespace jni_impl {
+
+//Default logger implementation for Android.
+class AndroidLogger : public realm::jni_util::JniLogger {
+public:
+    static std::shared_ptr<AndroidLogger> shared();
+
+protected:
+    void log(realm::jni_util::Log::Level level, const char* tag, jthrowable throwable, const char* message) override;
+
+private:
+    AndroidLogger() {};
+    static void print(android_LogPriority priority, const char* tag, const char* log_string);
+    static const size_t LOG_ENTRY_MAX_LENGTH = 4000;
+};
+
+}
+}
+
+#endif // REALM_JNI_IMPL_ANDROID_LOGGER_HPP
diff --git a/realm/realm-library/src/main/cpp/jni_util/log.cpp b/realm/realm-library/src/main/cpp/jni_util/log.cpp
new file mode 100644
index 0000000000..2e9ed01ae0
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/log.cpp
@@ -0,0 +1,191 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <algorithm>
+
+#include "jni_util/log.hpp"
+#include "util/format.hpp"
+
+using namespace realm;
+using namespace realm::jni_util;
+using namespace realm::util;
+
+const char* CoreLoggerBridge::TAG = "REALM_CORE";
+const char* Log::REALM_JNI_TAG = "REALM_JNI";
+Log::Level Log::s_level = Log::Level::warn;
+
+// Native wrapper for Java RealmLogger class
+class JavaLogger : public JniLogger {
+public:
+    JavaLogger(JNIEnv* env, jobject java_logger);
+    ~JavaLogger();
+
+    bool is_same_object(JNIEnv* env, jobject java_logger);
+
+protected:
+    void log(Log::Level level, const char* tag, jthrowable throwable, const char* message) override;
+
+private:
+    JavaVM* m_jvm;
+    // Global ref of the logger object.
+    jobject m_java_logger;
+    jmethodID m_log_method;
+
+    inline JNIEnv* get_current_env() noexcept
+    {
+        JNIEnv *env;
+        if (m_jvm->GetEnv((void **)&env, JNI_VERSION_1_6) != JNI_OK) {
+            m_jvm->AttachCurrentThread(&env, nullptr); // Should never fail
+        }
+        return env;
+    }
+};
+
+JniLogger::JniLogger()
+    :m_is_java_logger(false)
+{
+}
+
+JniLogger::JniLogger(bool is_java_logger)
+    :m_is_java_logger(is_java_logger)
+{
+}
+
+JavaLogger::JavaLogger(JNIEnv* env, jobject java_logger)
+    :JniLogger(true)
+{
+    jint ret = env->GetJavaVM(&m_jvm);
+    if (ret != 0) {
+        throw std::runtime_error(util::format("Failed to get Java vm. Error: %d", ret));
+    }
+    m_java_logger = env->NewGlobalRef(java_logger);
+    jclass cls = env->GetObjectClass(m_java_logger);
+    m_log_method = env->GetMethodID(cls, "log", "(ILjava/lang/String;Ljava/lang/Throwable;Ljava/lang/String;)V");
+}
+
+JavaLogger::~JavaLogger()
+{
+    get_current_env()->DeleteGlobalRef(m_java_logger);
+}
+
+void JavaLogger::log(Log::Level level, const char* tag, jthrowable throwable, const char* message)
+{
+    JNIEnv *env = get_current_env();
+
+    // NOTE: If a Java exception has been thrown in native code, the below call will trigger an JNI exception
+    // "JNI called with pending exception". This is something that should be avoided when printing log in JNI -- Always
+    // print log before calling env->ThrowNew. Doing env->ExceptionCheck() here creates overhead for normal cases.
+    env->CallVoidMethod(m_java_logger, m_log_method, level, env->NewStringUTF(tag),
+            throwable, env->NewStringUTF(message));
+}
+
+bool JavaLogger::is_same_object(JNIEnv* env, jobject java_logger)
+{
+    return env->IsSameObject(m_java_logger, java_logger);
+}
+
+Log::Log()
+    : m_loggers()
+{
+    add_logger(get_default_logger());
+}
+
+Log& Log::shared()
+{
+    static Log log;
+    return log;
+}
+
+void Log::add_java_logger(JNIEnv* env, const jobject java_logger)
+{
+    std::shared_ptr<JniLogger> logger = std::make_shared<JavaLogger>(env, java_logger);
+    add_logger(logger);
+}
+
+void Log::remove_java_logger(JNIEnv* env, const jobject java_logger)
+{
+    std::lock_guard<std::mutex> lock(m_mutex);
+    m_loggers.erase(std::remove_if(m_loggers.begin(), m_loggers.end(), [&](const auto& obj) {
+        return obj->m_is_java_logger && std::static_pointer_cast<JavaLogger>(obj)->is_same_object(env, java_logger);
+    }), m_loggers.end());
+}
+
+void Log::add_logger(std::shared_ptr<JniLogger> logger)
+{
+    std::lock_guard<std::mutex> lock(m_mutex);
+    if (std::find(m_loggers.begin(), m_loggers.end(), logger) == m_loggers.end()) {
+        m_loggers.push_back(logger);
+    }
+}
+
+void Log::remove_logger(std::shared_ptr<JniLogger> logger)
+{
+    std::lock_guard<std::mutex> lock(m_mutex);
+
+    m_loggers.erase(std::remove_if(m_loggers.begin(), m_loggers.end(), [&](const auto& obj) {
+        return obj == logger;
+    }), m_loggers.end());
+}
+
+void Log::register_default_logger() {
+    add_logger(get_default_logger());
+}
+
+void Log::clear_loggers()
+{
+    std::lock_guard<std::mutex> lock(m_mutex);
+    m_loggers.clear();
+}
+
+void Log::set_level(Level level)
+{
+    s_level = level;
+}
+
+void Log::log(Level level, const char* tag, jthrowable throwable, const char* message)
+{
+    if (s_level <= level) {
+        std::lock_guard<std::mutex> lock(m_mutex);
+        for (auto& logger : m_loggers) {
+            logger->log(level, tag, throwable, message);
+        }
+    }
+}
+
+void CoreLoggerBridge::do_log(realm::util::Logger::Level level, std::string msg)
+{
+    // Ignore the level threshold from the root logger.
+    Log::Level jni_level;
+    switch (level) {
+        case Level::trace: jni_level = Log::trace; break;
+        case Level::debug: // Fall through. Map to same level debug.
+        case Level::detail: jni_level = Log::debug; break;
+        case Level::info: jni_level = Log::info; break;
+        case Level::warn: jni_level = Log::warn; break;
+        case Level::error: jni_level = Log::error; break;
+        case Level::fatal: jni_level = Log::fatal; break;
+        case Level::all: // Fall through.
+        case Level::off: // Fall through.
+            throw std::invalid_argument(format("Invalid log level."));
+    }
+    Log::shared().log(jni_level, TAG, msg.c_str());
+}
+
+CoreLoggerBridge& CoreLoggerBridge::shared()
+{
+    static CoreLoggerBridge log_bridge;
+    return log_bridge;
+}
diff --git a/realm/realm-library/src/main/cpp/jni_util/log.hpp b/realm/realm-library/src/main/cpp/jni_util/log.hpp
new file mode 100644
index 0000000000..ad29c6ede7
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/log.hpp
@@ -0,0 +1,193 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_UTIL_LOG_HPP
+#define REALM_JNI_UTIL_LOG_HPP
+
+#include <jni.h>
+
+#include <memory>
+#include <mutex>
+#include <string>
+#include <vector>
+
+#include "io_realm_log_LogLevel.h"
+
+#include "realm/util/logger.hpp"
+#include "util/format.hpp"
+
+#define TR_ENTER() \
+    if (realm::jni_util::Log::s_level <= realm::jni_util::Log::trace) { \
+        realm::jni_util::Log::t(" --> %1", __FUNCTION__); \
+    }
+#define TR_ENTER_PTR(ptr) \
+    if (realm::jni_util::Log::s_level <= realm::jni_util::Log::trace) { \
+        realm::jni_util::Log::t(" --> %1 %2", __FUNCTION__, static_cast<int64_t>(ptr)); \
+    }
+
+namespace realm {
+
+namespace jni_util {
+
+class JniLogger;
+
+// This is built for Realm logging, bother for Java and native side.
+// Multiple loggers can be registered. All registered loggers will receive the same log events.
+class Log {
+public:
+    enum Level {
+        all = io_realm_log_LogLevel_ALL,
+        trace = io_realm_log_LogLevel_TRACE,
+        debug = io_realm_log_LogLevel_DEBUG,
+        info = io_realm_log_LogLevel_INFO,
+        warn = io_realm_log_LogLevel_WARN,
+        error = io_realm_log_LogLevel_ERROR,
+        fatal = io_realm_log_LogLevel_FATAL,
+        off = io_realm_log_LogLevel_OFF
+    };
+
+    // Add & Remove a Java RealmLogger. A Java logger needs to be implemented from io.realm.log.RealmLogger interface.
+    void add_java_logger(JNIEnv* env, const jobject java_logger);
+    void remove_java_logger(JNIEnv* env, const jobject java_logger);
+
+    void add_logger(std::shared_ptr<JniLogger> logger);
+    void remove_logger(std::shared_ptr<JniLogger> logger);
+
+    // Remove all custom loggers, but keep the default logger.
+    void clear_loggers();
+
+    // Add the default logger if it has been removed before.
+    void register_default_logger();
+
+    void set_level(Level level);
+    inline Level get_level() {
+        return s_level;
+    };
+
+    void log(Level level, const char* tag, jthrowable throwable, const char* message);
+
+    inline void log(Level level, const char* tag, const char* message)
+    {
+        log(level, tag, nullptr, message);
+    }
+
+    // Helper functions for logging with REALM_JNI tag.
+    inline static void t(const char* message)
+    {
+        shared().log(error, REALM_JNI_TAG, nullptr, message);
+    }
+    inline static void d(const char* message)
+    {
+        shared().log(error, REALM_JNI_TAG, nullptr, message);
+    }
+    inline static void i(const char* message)
+    {
+        shared().log(error, REALM_JNI_TAG, nullptr, message);
+    }
+    inline static void w(const char* message)
+    {
+        shared().log(error, REALM_JNI_TAG, nullptr, message);
+    }
+    inline static void e(const char* message)
+    {
+        shared().log(error, REALM_JNI_TAG, nullptr, message);
+    }
+    inline static void f(const char* message)
+    {
+        shared().log(error, REALM_JNI_TAG, nullptr, message);
+    }
+
+    template<typename... Args>
+    inline static void t(const char* fmt, Args&&... args)
+    {
+        shared().log(trace, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
+    }
+    template<typename... Args>
+    inline static void d(const char* fmt, Args&&... args)
+    {
+        shared().log(debug, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
+    }
+    template<typename... Args>
+    inline static void i(const char* fmt, Args&&... args)
+    {
+        shared().log(info, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
+    }
+    template<typename... Args>
+    inline static void w(const char* fmt, Args&&... args)
+    {
+        shared().log(warn, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
+    }
+    template<typename... Args>
+    inline static void e(const char* fmt, Args&&... args)
+    {
+        shared().log(error, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
+    }
+    template<typename... Args>
+    inline static void f(const char* fmt, Args&&... args) {
+        shared().log(fatal, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
+    }
+
+    // Get the shared Log instance.
+    static Log& shared();
+
+    // public & static for reading faster. For TR_ENTER check.
+    // Accessing to this var won't be thread safe and it is not necessary to be. Changing log level concurrently
+    // won't be a critical issue for commons cases.
+    static Level s_level;
+private:
+    Log();
+
+    std::vector<std::shared_ptr<JniLogger>> m_loggers;
+    std::mutex m_mutex;
+    // Log tag for generic Realm JNI.
+    static const char* REALM_JNI_TAG;
+
+};
+
+// Base Logger class.
+class JniLogger {
+protected:
+    JniLogger();
+    // Used by JavaLogger.
+    JniLogger(bool is_java_logger);
+    // Indicate if this is a wrapper for Java RealmLogger class. See JavaLogger
+    bool m_is_java_logger;
+
+protected:
+    // Overwrite this method to handle the log event.
+    // throwable is the Throwable passed from Java which could be null.
+    virtual void log(Log::Level level, const char* tag, jthrowable throwable, const char* message) = 0;
+    friend class Log;
+};
+
+// Implement this function to return the default logger which will be registered during initialization.
+extern std::shared_ptr<JniLogger> get_default_logger();
+
+class CoreLoggerBridge : public realm::util::RootLogger {
+public:
+    void do_log(Logger::Level, std::string msg) override;
+    static CoreLoggerBridge& shared();
+
+private:
+    CoreLoggerBridge() {};
+    // Log tag for Realm core & sync.
+    static const char* TAG;
+};
+
+} // namespace jni_util
+} // namespace realm
+
+#endif // REALM_JNI_UTIL_LOG_HPP
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 4100b8fc40..bafafb1464 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 4100b8fc407176cdf09e6f394bd111595a6412aa
+Subproject commit bafafb1464494d0a731a036399aa5c944d92a5bf
diff --git a/realm/realm-library/src/main/cpp/objectserver_shared.hpp b/realm/realm-library/src/main/cpp/objectserver_shared.hpp
new file mode 100644
index 0000000000..1253f539d4
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/objectserver_shared.hpp
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef REALM_OBJECTSERVER_SHARED_HPP
+#define REALM_OBJECTSERVER_SHARED_HPP
+
+#include <jni.h>
+#include <string>
+#include <thread>
+
+#include <realm/sync/history.hpp>
+#include <realm/sync/client.hpp>
+#include <realm/util/logger.hpp>
+#include <object-store/src/impl/realm_coordinator.hpp>
+#include <object-store/src/sync_manager.hpp>
+
+#include "util.hpp"
+
+
+// Wrapper class for realm::Session. This allows us to manage the C++ session and callback lifecycle correctly.
+// TODO Use OS SyncSession instead
+class JniSession {
+
+public:
+    JniSession(const JniSession&) = delete;
+    JniSession& operator=(const JniSession&) = delete;
+    JniSession(JniSession&&) = delete;
+    JniSession& operator=(JniSession&&) = delete;
+
+    JniSession(JNIEnv* env, std::string local_realm_path, jobject java_session_obj)
+    {
+        extern std::unique_ptr<realm::sync::Client> sync_client;
+        // Get the coordinator for the given path, or null if there is none
+        m_sync_session = new realm::sync::Session(*sync_client, local_realm_path);
+        m_java_session_ref = env->NewGlobalRef(java_session_obj);
+        jobject global_obj_ref_tmp(m_java_session_ref);
+        auto sync_transact_callback = [local_realm_path](realm::VersionID, realm::VersionID) {
+            auto coordinator = realm::_impl::RealmCoordinator::get_existing_coordinator(
+                    realm::StringData(local_realm_path));
+            if (coordinator) {
+                coordinator->notify_others();
+            }
+        };
+        auto error_handler = [&, global_obj_ref_tmp](int error_code, std::string message) {
+            JNIEnv *local_env;
+            g_vm->AttachCurrentThread(&local_env, nullptr);
+            jclass java_session_class = local_env->GetObjectClass(global_obj_ref_tmp);
+            jmethodID notify_error_handler = local_env->GetMethodID(java_session_class,
+                                                                       "notifySessionError", "(ILjava/lang/String;)V");
+            local_env->CallVoidMethod(global_obj_ref_tmp,
+                                      notify_error_handler, error_code, env->NewStringUTF(message.c_str()));
+        };
+        m_sync_session->set_sync_transact_callback(sync_transact_callback);
+        m_sync_session->set_error_handler(std::move(error_handler));
+    }
+
+    inline realm::sync::Session* get_session() const noexcept
+    {
+        return m_sync_session;
+    }
+
+    // Call this just before destroying the object to release JNI resources.
+    inline void close(JNIEnv* env)
+    {
+        env->DeleteGlobalRef(m_java_session_ref);
+    }
+
+    ~JniSession()
+    {
+        delete m_sync_session;
+    }
+
+private:
+    realm::sync::Session* m_sync_session;
+    jobject m_java_session_ref;
+};
+
+#endif // REALM_OBJECTSERVER_SHARED_HPP
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index f1bba74329..1ba8e3e2b1 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -29,14 +29,18 @@
 using namespace std;
 using namespace realm;
 using namespace realm::util;
+using namespace realm::jni_util;
 
 // Caching classes and constructors for boxed types.
+JavaVM* g_vm;
 jclass java_lang_long;
 jmethodID java_lang_long_init;
 jclass java_lang_float;
 jmethodID java_lang_float_init;
 jclass java_lang_double;
 jmethodID java_lang_double_init;
+jclass session_class_ref;
+jmethodID session_error_handler;
 
 void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind);
 
@@ -91,7 +95,7 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
     string message;
     jclass jExceptionClass = NULL;
 
-    TR_ERR(env, "jni: ThrowingException %d, %s, %s.", exception, classStr.c_str(), itemStr.c_str())
+    Log::e("jni: ThrowingException %1, %2, %3.", exception, classStr.c_str(), itemStr.c_str());
 
     switch (exception) {
         case ClassNotFound:
@@ -145,11 +149,11 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
             break;
     }
     if (jExceptionClass != NULL) {
+        Log::e("Exception has been throw: %1", message.c_str());
         env->ThrowNew(jExceptionClass, message.c_str());
-        TR_ERR(env, "Exception has been throw: %s", message.c_str())
     }
     else {
-        TR_ERR(env, "ERROR: Couldn't throw exception.", NULL)
+        Log::e("ERROR: Couldn't throw exception.");
     }
 
     env->DeleteLocalRef(jExceptionClass);
@@ -160,6 +164,7 @@ void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::Rea
     jclass cls = env->FindClass("io/realm/exceptions/RealmFileException");
 
     jmethodID constructor = env->GetMethodID(cls, "<init>", "(BLjava/lang/String;)V");
+    // Initial value to suppress gcc warning.
     jbyte kind_code;
     switch (kind) {
         case realm::RealmFileException::Kind::AccessError:
@@ -175,7 +180,7 @@ void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::Rea
             kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_NOT_FOUND;
             break;
         case realm::RealmFileException::Kind::IncompatibleLockFile:
-            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_IMCOMPATIBLE_LOCK_FILE;
+            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_INCOMPATIBLE_LOCK_FILE;
             break;
         case realm::RealmFileException::Kind::FormatUpgradeRequired:
             kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED;
diff --git a/realm/realm-library/src/main/cpp/util.hpp b/realm/realm-library/src/main/cpp/util.hpp
index 9bdad05fa4..68b9a89ee6 100644
--- a/realm/realm-library/src/main/cpp/util.hpp
+++ b/realm/realm-library/src/main/cpp/util.hpp
@@ -24,7 +24,6 @@
 #include <jni.h>
 
 // Used by logging
-#define __STDC_FORMAT_MACROS
 #include <inttypes.h>
 
 #include <realm.hpp>
@@ -32,13 +31,14 @@
 #include <realm/timestamp.hpp>
 #include <realm/util/meta.hpp>
 #include <realm/util/safe_int_ops.hpp>
+#include <realm/sync/client.hpp>
 
 #include <util/format.hpp>
 
 #include "io_realm_internal_Util.h"
-#include "io_realm_log_LogLevel.h"
 
-#define TRACE               1       // disable for performance
+#include "jni_util/log.hpp"
+
 #define CHECK_PARAMETERS    1       // Check all parameters in API and throw exceptions in java if invalid
 
 #ifdef __cplusplus
@@ -86,6 +86,8 @@ std::string num_to_string(T pNumber)
 #define Q(x)    reinterpret_cast<realm::Query*>(x)
 #define ROW(x)  reinterpret_cast<realm::Row*>(x)
 #define HO(T, ptr) reinterpret_cast<realm::SharedGroup::Handover <T>* >(ptr)
+#define SC(ptr) reinterpret_cast<realm::sync::Client*>(ptr)
+#define SS(ptr) reinterpret_cast<JniSession*>(ptr)
 
 // Exception handling
 enum ExceptionKind {
@@ -114,51 +116,6 @@ void ThrowNullValueException(JNIEnv* env, realm::Table *table, size_t col_ndx);
 jclass GetClass(JNIEnv* env, const char* classStr);
 
 
-// Debug trace
-extern int trace_level;
-extern jclass realmlog_class;
-extern jmethodID log_trace;
-extern jmethodID log_debug;
-extern jmethodID log_info;
-extern jmethodID log_warn;
-extern jmethodID log_error;
-extern jmethodID log_fatal;
-
-
-// Inspired by From http://www.netmite.com/android/mydroid/system/core/liblog/logd_write.c
-inline void log_message(JNIEnv *env, jmethodID log_method, const char *msg, ...)
-{
-    // Check if a exception has already bee cast. In that case trying to log anything will crash.
-    if (env->ExceptionCheck()) {
-        return;
-    }
-
-    va_list ap;
-    char buf[1024]; // Max logcat line length
-    va_start(ap, msg);
-    // Do formatting in C++. I gave up trying to send C++ variadic arguments back as Java var args.
-    vsnprintf(buf, 1024, msg, ap);
-    va_end(ap);
-
-    jstring log_message = env->NewStringUTF(buf);
-    env->CallStaticVoidMethod(realmlog_class, log_method, log_message, NULL);
-    env->DeleteLocalRef(log_message);
-}
-
-#if TRACE
-    #define TR_ENTER(env) if (trace_level <= io_realm_log_LogLevel_TRACE) { log_message(env, log_trace, " --> %s", __FUNCTION__); } else {}
-    #define TR_ENTER_PTR(env, ptr) if (trace_level <= io_realm_log_LogLevel_TRACE) { log_message(env, log_trace, " --> %s %" PRId64, __FUNCTION__, static_cast<int64_t>(ptr)); } else {}
-    #define TR(env, msg, ...) if (trace_level <= io_realm_log_LogLevel_TRACE) { log_message(env, log_trace, msg, __VA_ARGS__)); } else {}
-    #define TR_ERR(env, msg, ...) if (trace_level <= io_realm_log_LogLevel_ERROR) { log_message(env, log_error, msg, __VA_ARGS__); } else {}
-    #define TR_LEAVE(env) if (trace_level <= io_realm_log_LogLevel_TRACE) { log_message(env, log_trace, " <-- %s", __FUNCTION__); } else {}
-#else // TRACE - these macros must be empty
-    #define TR_ENTER(env)
-    #define TR_ENTER_PTR(env, ptr)
-    #define TR(env, msg, ...)
-    #define TR_ERR(env, msg, ...)
-    #define TR_LEAVE(env)
-#endif
-
 // Check parameters
 
 #define TABLE_VALID(env,ptr)    TableIsValid(env, ptr)
@@ -230,7 +187,7 @@ inline bool TableIsValid(JNIEnv* env, T* objPtr)
 
     }
     if (!valid) {
-        TR_ERR(env, "Table %p is no longer attached!", VOID_PTR(objPtr))
+        realm::jni_util::Log::e("Table %1 is no longer attached!", VOID_PTR(objPtr));
         ThrowException(env, IllegalState, "Table is no longer valid to operate on.");
     }
     return valid;
@@ -240,7 +197,7 @@ inline bool RowIsValid(JNIEnv* env, realm::Row* rowPtr)
 {
     bool valid = (rowPtr != NULL && rowPtr->is_attached());
     if (!valid) {
-        TR_ERR(env, "Row %p is no longer attached!", VOID_PTR(rowPtr))
+        realm::jni_util::Log::e("Row %1 is no longer attached!", VOID_PTR(rowPtr));
         ThrowException(env, IllegalState, "Object is no longer valid to operate on. Was it deleted by another thread?");
     }
     return valid;
@@ -254,29 +211,30 @@ bool RowIndexesValid(JNIEnv* env, T* pTable, jlong startIndex, jlong endIndex, j
     if (endIndex == -1)
         endIndex = maxIndex;
     if (startIndex < 0) {
-        TR_ERR(env, "startIndex %" PRId64 " < 0 - invalid!", S64(startIndex))
+        realm::jni_util::Log::e("startIndex %1 < 0 - invalid!", S64(startIndex));
         ThrowException(env, IndexOutOfBounds, "startIndex < 0.");
         return false;
     }
     if (realm::util::int_greater_than(startIndex, maxIndex)) {
-        TR_ERR(env, "startIndex %" PRId64 " > %" PRId64 " - invalid!", S64(startIndex), S64(maxIndex))
+        realm::jni_util::Log::e("startIndex %1 > %2 - invalid!", S64(startIndex), S64(maxIndex));
         ThrowException(env, IndexOutOfBounds, "startIndex > available rows.");
         return false;
     }
 
     if (realm::util::int_greater_than(endIndex, maxIndex)) {
-        TR_ERR(env, "endIndex %" PRId64 " > %" PRId64 " - invalid!", S64(endIndex), S64(maxIndex))
+        realm::jni_util::Log::e("endIndex %1 > %2 - invalid!", S64(endIndex), S64(maxIndex));
         ThrowException(env, IndexOutOfBounds, "endIndex > available rows.");
         return false;
     }
     if (startIndex > endIndex) {
-        TR_ERR(env, "startIndex %" PRId64 " > endIndex %" PRId64 " - invalid!", S64(startIndex), S64(endIndex))
+        realm::jni_util::Log::e(
+                "startIndex %1 > endIndex %2 - invalid!", S64(startIndex), S64(endIndex));
         ThrowException(env, IndexOutOfBounds, "startIndex > endIndex.");
         return false;
     }
 
     if (range != -1 && range < 0) {
-        TR_ERR(env, "range %" PRId64 " < 0 - invalid!", S64(range))
+        realm::jni_util::Log::e("range %1 < 0 - invalid!", S64(range));
         ThrowException(env, IndexOutOfBounds, "range < 0.");
         return false;
     }
@@ -296,7 +254,7 @@ inline bool RowIndexValid(JNIEnv* env, T pTable, jlong rowIndex, bool offset=fal
         size -= 1;
     bool rowErr = realm::util::int_greater_than_or_equal(rowIndex, size);
     if (rowErr) {
-        TR_ERR(env, "rowIndex %" PRId64 " > %" PRId64 " - invalid!", S64(rowIndex), S64(size))
+        realm::jni_util::Log::e("rowIndex %1 > %2 - invalid!", S64(rowIndex), S64(size));
         ThrowException(env, IndexOutOfBounds,
             "rowIndex > available rows: " +
             num_to_string(rowIndex) + " > " + num_to_string(size));
@@ -323,7 +281,8 @@ inline bool ColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
     }
     bool colErr = realm::util::int_greater_than_or_equal(columnIndex, pTable->get_column_count());
     if (colErr) {
-        TR_ERR(env, "columnIndex %" PRId64 " > %" PRId64 " - invalid!", S64(columnIndex), S64(pTable->get_column_count()))
+        realm::jni_util::Log::e(
+                "columnIndex %1 > %2 - invalid!", S64(columnIndex), S64(pTable->get_column_count()));
         ThrowException(env, IndexOutOfBounds, "columnIndex > available columns.");
     }
     return !colErr;
@@ -365,7 +324,7 @@ inline bool TblIndexInsertValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong
         return false;
     bool rowErr = realm::util::int_greater_than(rowIndex, pTable->size()+1);
     if (rowErr) {
-        TR_ERR(env, "rowIndex %" PRId64 " > %" PRId64 " - invalid!", S64(rowIndex), S64(pTable->size()))
+        realm::jni_util::Log::e("rowIndex %1 > %2 - invalid!", S64(rowIndex), S64(pTable->size()));
         ThrowException(env, IndexOutOfBounds,
             "rowIndex " + num_to_string(rowIndex) +
             " > available rows " + num_to_string(pTable->size()) + ".");
@@ -379,7 +338,7 @@ inline bool TypeValid(JNIEnv* env, T* pTable, jlong columnIndex, int expectColTy
     size_t col = static_cast<size_t>(columnIndex);
     int colType = pTable->get_column_type(col);
     if (colType != expectColType) {
-        TR_ERR(env, "Expected columnType %d, but got %d.", expectColType, pTable->get_column_type(col))
+        realm::jni_util::Log::e("Expected columnType %1, but got %2.", expectColType, pTable->get_column_type(col));
         ThrowException(env, IllegalArgument, "ColumnType invalid.");
         return false;
     }
@@ -395,7 +354,8 @@ inline bool TypeIsLinkLike(JNIEnv* env, T* pTable, jlong columnIndex)
         return true;
     }
 
-    TR_ERR(env, "Expected columnType %d or %d, but got %d", realm::type_Link, realm::type_LinkList, colType)
+    realm::jni_util::Log::e(
+            "Expected columnType %1 or %2, but got %3", realm::type_Link, realm::type_LinkList, colType);
     ThrowException(env, IllegalArgument, "ColumnType invalid: expected type_Link or type_LinkList");
     return false;
 }
@@ -418,7 +378,7 @@ inline bool ColIsNullable(JNIEnv* env, T* pTable, jlong columnIndex)
         return true;
     }
 
-    TR_ERR(env, "Expected nullable column type", NULL)
+    realm::jni_util::Log::e("Expected nullable column type");
     ThrowException(env, IllegalArgument, "This field is not nullable.");
     return false;
 }
@@ -699,6 +659,7 @@ class JniLocalRef {
     JNIEnv* m_env;
 };
 
+extern JavaVM* g_vm;
 extern jclass java_lang_long;
 extern jmethodID java_lang_long_init;
 extern jclass java_lang_float;
@@ -706,6 +667,10 @@ extern jmethodID java_lang_float_init;
 extern jclass java_lang_double;
 extern jmethodID java_lang_double_init;
 
+// FIXME Move to own library
+extern jclass session_class_ref;
+extern jmethodID session_error_handler;
+
 inline jobject NewLong(JNIEnv* env, int64_t value)
 {
     return env->NewObject(java_lang_long, java_lang_long_init, value);
@@ -741,4 +706,8 @@ inline realm::Timestamp from_milliseconds(jlong milliseconds)
 
 extern const std::string TABLE_PREFIX;
 
+static inline bool to_bool(jboolean b) {
+    return b == JNI_TRUE;
+}
+
 #endif // REALM_JAVA_UTIL_HPP
diff --git a/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java b/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java
index b3f881bfa4..b0f1c194ae 100644
--- a/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java
+++ b/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java
@@ -28,7 +28,6 @@
 /**
  * Implementation of {@link RealmNotifier} for Android based on {@link Handler}.
  */
-// FIXME: Please move me to the io.realm.internal when HandlerController is there.
 class AndroidNotifier implements RealmNotifier {
     private Handler handler;
 
@@ -66,7 +65,6 @@ public void notifyCommitByLocalThread() {
 
     // This is called by OS when other thread/process changes the Realm.
     // This is getting called on the same thread which created the Realm.
-    // FIXME: The whole calling routine is twisted and needs to be rewritten in the near future.
     // |---------------------------------------------------------------+--------------+------------------------------------------------|
     // | Thread A                                                      | Thread B     | Daemon Thread                                  |
     // |---------------------------------------------------------------+--------------+------------------------------------------------|
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index d3cf9a78de..c61b2cefae 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -19,12 +19,10 @@
 import android.content.Context;
 import android.os.Handler;
 import android.os.Looper;
-import android.util.Log;
 
 import java.io.Closeable;
 import java.io.File;
 import java.io.FileNotFoundException;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -38,9 +36,10 @@
 import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.UncheckedRow;
+import io.realm.internal.Util;
 import io.realm.internal.async.RealmThreadPoolExecutor;
-import io.realm.log.AndroidLogger;
 import io.realm.log.RealmLog;
+import io.realm.internal.ObjectServerFacade;
 import rx.Observable;
 
 /**
@@ -61,6 +60,7 @@
     private static final String NOT_IN_TRANSACTION_MESSAGE =
             "Changing Realm data can only be done from inside a transaction.";
 
+    
     volatile static Context applicationContext;
 
     // Thread pool for all async operations (Query & transaction)
@@ -73,6 +73,7 @@
     RealmSchema schema;
     HandlerController handlerController;
 
+
     protected BaseRealm(RealmConfiguration configuration) {
         this.threadId = Thread.currentThread().getId();
         this.configuration = configuration;
@@ -346,6 +347,8 @@ public void commitTransaction() {
     void commitTransaction(boolean notifyLocalThread) {
         checkIfValid();
         sharedRealm.commitTransaction();
+        ObjectServerFacade.getFacade(configuration.isSyncConfiguration())
+                .notifyCommit(configuration, sharedRealm.getLastSnapshotVersion());
 
         // Sometimes we don't want to notify the local thread about commits, e.g. creating a completely new Realm
         // file will make a commit in order to create the schema. Users should not be notified about that.
@@ -396,6 +399,16 @@ protected void checkIfValidAndInTransaction() {
         }
     }
 
+    /**
+     * Check if the Realm is not built with a SyncRealmConfiguration
+     */
+    void checkNotInSync() {
+        if (configuration.isSyncConfiguration()) {
+            throw new IllegalArgumentException("You cannot perform changes to a schema. " +
+                    "Please update app and restart.");
+        }
+    }
+
     /**
      * Returns the canonical path to where this Realm is persisted on disk.
      *
@@ -449,6 +462,9 @@ void doClose() {
             sharedRealm.close();
             sharedRealm = null;
         }
+        if (schema != null) {
+            schema.close();
+        }
     }
 
     /**
@@ -502,14 +518,14 @@ public RealmSchema getSchema() {
     // Used by RealmList/RealmResults
     // Invariant: if dynamicClassName != null -> clazz == DynamicRealmObject
     <E extends RealmModel> E get(Class<E> clazz, String dynamicClassName, long rowIndex) {
-        final Table table = (dynamicClassName != null) ? schema.getTable(dynamicClassName) : schema.getTable(clazz);
+        final boolean isDynamicRealmObject = dynamicClassName != null;
+        final Table table = isDynamicRealmObject ? schema.getTable(dynamicClassName) : schema.getTable(clazz);
 
         E result;
-        if (dynamicClassName != null) {
+        if (isDynamicRealmObject) {
             @SuppressWarnings("unchecked")
             E dynamicObj = (E) new DynamicRealmObject(this,
-                    (rowIndex != Table.NO_MATCH) ? table.getUncheckedRow(rowIndex) : InvalidRow.INSTANCE,
-                    false);
+                    (rowIndex != Table.NO_MATCH) ? table.getCheckedRow(rowIndex) : InvalidRow.INSTANCE);
             result = dynamicObj;
         } else {
             result = configuration.getSchemaMediator().newInstance(clazz, this,
@@ -537,36 +553,11 @@ public void deleteAll() {
         }
     }
 
-    static private boolean deletes(String canonicalPath, File rootFolder, String realmFileName) {
-        final AtomicBoolean realmDeleted = new AtomicBoolean(true);
-
-        List<File> filesToDelete = Arrays.asList(
-                new File(rootFolder, realmFileName),
-                new File(rootFolder, realmFileName + ".lock"),
-                // Old core log file naming styles
-                new File(rootFolder, realmFileName + ".log_a"),
-                new File(rootFolder, realmFileName + ".log_b"),
-                new File(rootFolder, realmFileName + ".log"),
-                new File(canonicalPath));
-        for (File fileToDelete : filesToDelete) {
-            if (fileToDelete.exists()) {
-                boolean deleteResult = fileToDelete.delete();
-                if (!deleteResult) {
-                    realmDeleted.set(false);
-                    RealmLog.warn("Could not delete the file %s", fileToDelete);
-                }
-            }
-        }
-        return realmDeleted.get();
-    }
-
     /**
      * Deletes the Realm file defined by the given configuration.
      */
     static boolean deleteRealm(final RealmConfiguration configuration) {
-        final String management = ".management";
         final AtomicBoolean realmDeleted = new AtomicBoolean(true);
-
         RealmCache.invokeWithGlobalRefCount(configuration, new RealmCache.Callback() {
             @Override
             public void onResult(int count) {
@@ -578,23 +569,9 @@ public void onResult(int count) {
                 String canonicalPath = configuration.getPath();
                 File realmFolder = configuration.getRealmDirectory();
                 String realmFileName = configuration.getRealmFileName();
-                File managementFolder = new File(realmFolder, realmFileName + management);
-
-                // delete files in management directory and the directory
-                // there is no subfolders in the management directory
-                File[] files = managementFolder.listFiles();
-                if (files != null) {
-                    for (File file : files) {
-                        realmDeleted.set(realmDeleted.get() && file.delete());
-                    }
-                }
-                realmDeleted.set(realmDeleted.get() && managementFolder.delete());
-
-                // delete specific files in root directory
-                realmDeleted.set(realmDeleted.get() && deletes(canonicalPath, realmFolder, realmFileName));
+                realmDeleted.set(Util.deleteRealm(canonicalPath, realmFolder, realmFileName));
             }
         });
-
         return realmDeleted.get();
     }
 
@@ -606,10 +583,6 @@ public void onResult(int count) {
      * @return {@code true} if compaction succeeded, {@code false} otherwise.
      */
     static boolean compactRealm(final RealmConfiguration configuration) {
-        // FIXME: Move this check to OS?
-        if (configuration.getEncryptionKey() != null) {
-            throw new IllegalArgumentException("Cannot currently compact an encrypted Realm.");
-        }
         SharedRealm sharedRealm = SharedRealm.getInstance(configuration);
         Boolean result = sharedRealm.compact();
         sharedRealm.close();
@@ -622,15 +595,17 @@ static boolean compactRealm(final RealmConfiguration configuration) {
      * @param configuration configuration for the Realm that should be migrated.
      * @param migration if set, this migration block will override what is set in {@link RealmConfiguration}.
      * @param callback callback for specific Realm type behaviors.
+     * @param cause which triggers this migration.
      * @throws FileNotFoundException if the Realm file doesn't exist.
      */
     protected static void migrateRealm(final RealmConfiguration configuration, final RealmMigration migration,
-                                       final MigrationCallback callback) throws FileNotFoundException {
+                                       final MigrationCallback callback, final RealmMigrationNeededException cause)
+            throws FileNotFoundException {
         if (configuration == null) {
             throw new IllegalArgumentException("RealmConfiguration must be provided");
         }
         if (migration == null && configuration.getMigration() == null) {
-            throw new RealmMigrationNeededException(configuration.getPath(), "RealmMigration must be provided");
+            throw new RealmMigrationNeededException(configuration.getPath(), "RealmMigration must be provided", cause);
         }
 
         final AtomicBoolean fileNotFound = new AtomicBoolean(false);
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index 4af7ad524b..9b529e0f24 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -95,12 +95,12 @@ public DynamicRealmObject createObject(String className) {
      * @throws RealmException if object could not be created due to the primary key being invalid.
      * @throws IllegalStateException if the model clazz does not have an primary key defined.
      * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
-     *                                  expectd value.
+     *                                  expected value.
      */
     public DynamicRealmObject createObject(String className, Object primaryKeyValue) {
         Table table = schema.getTable(className);
         long index = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
-        return new DynamicRealmObject(this, table.getCheckedRow(index), false);
+        return new DynamicRealmObject(this, table.getCheckedRow(index));
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index 88ec5cd14e..95c4ae2014 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -32,6 +32,7 @@
  * Class that wraps a normal RealmObject in order to allow dynamic access instead of a typed interface.
  * Using a DynamicRealmObject is slower than using the regular RealmObject class.
  */
+@SuppressWarnings("WeakerAccess")
 public final class DynamicRealmObject extends RealmObject implements RealmObjectProxy {
 
     private final ProxyState proxyState = new ProxyState(this);
@@ -67,24 +68,18 @@ public DynamicRealmObject(RealmModel obj) {
         proxyState.setConstructionFinished();
     }
 
-    DynamicRealmObject(BaseRealm realm, Row row, boolean convertTocheckedRow) {
+    // row must not be an instance of UncheckedRow
+    DynamicRealmObject(BaseRealm realm, Row row) {
         proxyState.setRealm$realm(realm);
-        if (convertTocheckedRow) {
-            proxyState.setRow$realm((row instanceof CheckedRow) ? (CheckedRow) row : ((UncheckedRow) row).convertToChecked());
-        } else {
-            proxyState.setRow$realm(row);
-        }
+        proxyState.setRow$realm(row);
         proxyState.setConstructionFinished();
     }
 
-    DynamicRealmObject(String className, BaseRealm realm, Row row, boolean convertTocheckedRow) {
+    // row must not be an instance of UncheckedRow
+    DynamicRealmObject(String className, BaseRealm realm, Row row) {
         proxyState.setClassName(className);
         proxyState.setRealm$realm(realm);
-        if (convertTocheckedRow) {
-            proxyState.setRow$realm((row instanceof CheckedRow) ? (CheckedRow) row : ((UncheckedRow) row).convertToChecked());
-        } else {
-            proxyState.setRow$realm(row);
-        }
+        proxyState.setRow$realm(row);
         proxyState.setConstructionFinished();
     }
 
@@ -129,8 +124,12 @@ public DynamicRealmObject(RealmModel obj) {
      */
     public boolean getBoolean(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        checkFieldType(fieldName, columnIndex, RealmFieldType.BOOLEAN);
-        return proxyState.getRow$realm().getBoolean(columnIndex);
+        try {
+            return proxyState.getRow$realm().getBoolean(columnIndex);
+        } catch (IllegalArgumentException e) {
+            checkFieldType(fieldName, columnIndex, RealmFieldType.BOOLEAN);
+            throw e;
+        }
     }
 
     /**
@@ -176,8 +175,12 @@ public short getShort(String fieldName) {
      */
     public long getLong(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        checkFieldType(fieldName, columnIndex, RealmFieldType.INTEGER);
-        return proxyState.getRow$realm().getLong(columnIndex);
+        try {
+            return proxyState.getRow$realm().getLong(columnIndex);
+        } catch (IllegalArgumentException e) {
+            checkFieldType(fieldName, columnIndex, RealmFieldType.INTEGER);
+            throw e;
+        }
     }
 
     /**
@@ -208,8 +211,12 @@ public byte getByte(String fieldName) {
      */
     public float getFloat(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        checkFieldType(fieldName, columnIndex, RealmFieldType.FLOAT);
-        return proxyState.getRow$realm().getFloat(columnIndex);
+        try {
+            return proxyState.getRow$realm().getFloat(columnIndex);
+        } catch (IllegalArgumentException e) {
+            checkFieldType(fieldName, columnIndex, RealmFieldType.FLOAT);
+            throw e;
+        }
     }
 
     /**
@@ -225,8 +232,12 @@ public float getFloat(String fieldName) {
      */
     public double getDouble(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        checkFieldType(fieldName, columnIndex, RealmFieldType.DOUBLE);
-        return proxyState.getRow$realm().getDouble(columnIndex);
+        try {
+            return proxyState.getRow$realm().getDouble(columnIndex);
+        } catch (IllegalArgumentException e) {
+            checkFieldType(fieldName, columnIndex, RealmFieldType.DOUBLE);
+            throw e;
+        }
     }
 
     /**
@@ -238,8 +249,12 @@ public double getDouble(String fieldName) {
      */
     public byte[] getBlob(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        checkFieldType(fieldName, columnIndex, RealmFieldType.BINARY);
-        return proxyState.getRow$realm().getBinaryByteArray(columnIndex);
+        try {
+            return proxyState.getRow$realm().getBinaryByteArray(columnIndex);
+        } catch (IllegalArgumentException e) {
+            checkFieldType(fieldName, columnIndex, RealmFieldType.BINARY);
+            throw e;
+        }
     }
 
     /**
@@ -251,8 +266,12 @@ public double getDouble(String fieldName) {
      */
     public String getString(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        checkFieldType(fieldName, columnIndex, RealmFieldType.STRING);
-        return proxyState.getRow$realm().getString(columnIndex);
+        try {
+            return proxyState.getRow$realm().getString(columnIndex);
+        } catch (IllegalArgumentException e) {
+            checkFieldType(fieldName, columnIndex, RealmFieldType.STRING);
+            throw e;
+        }
     }
 
     /**
@@ -287,7 +306,7 @@ public DynamicRealmObject getObject(String fieldName) {
         } else {
             long linkRowIndex = proxyState.getRow$realm().getLink(columnIndex);
             CheckedRow linkRow = proxyState.getRow$realm().getTable().getLinkTarget(columnIndex).getCheckedRow(linkRowIndex);
-            return new DynamicRealmObject(proxyState.getRealm$realm(), linkRow, false);
+            return new DynamicRealmObject(proxyState.getRealm$realm(), linkRow);
         }
     }
 
@@ -300,10 +319,14 @@ public DynamicRealmObject getObject(String fieldName) {
      */
     public RealmList<DynamicRealmObject> getList(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        checkFieldType(fieldName, columnIndex, RealmFieldType.LIST);
-        LinkView linkView = proxyState.getRow$realm().getLinkList(columnIndex);
-        String className = RealmSchema.getSchemaForTable(linkView.getTargetTable());
-        return new RealmList<DynamicRealmObject>(className, linkView, proxyState.getRealm$realm());
+        try {
+            LinkView linkView = proxyState.getRow$realm().getLinkList(columnIndex);
+            String className = RealmSchema.getSchemaForTable(linkView.getTargetTable());
+            return new RealmList<DynamicRealmObject>(className, linkView, proxyState.getRealm$realm());
+        } catch (IllegalArgumentException e) {
+            checkFieldType(fieldName, columnIndex, RealmFieldType.LIST);
+            throw e;
+        }
     }
 
     /**
@@ -693,7 +716,7 @@ private void checkFieldType(String fieldName, long columnIndex, RealmFieldType e
                 expectedIndefiniteVowel = "n";
             }
             String columnTypeIndefiniteVowel = "";
-            if (expectedType == RealmFieldType.INTEGER || expectedType == RealmFieldType.OBJECT) {
+            if (columnType == RealmFieldType.INTEGER || columnType == RealmFieldType.OBJECT) {
                 columnTypeIndefiniteVowel = "n";
             }
             throw new IllegalArgumentException(String.format("'%s' is not a%s '%s', but a%s '%s'.",
diff --git a/realm/realm-library/src/main/java/io/realm/HandlerController.java b/realm/realm-library/src/main/java/io/realm/HandlerController.java
index 3a04ddff21..071dcc6b77 100644
--- a/realm/realm-library/src/main/java/io/realm/HandlerController.java
+++ b/realm/realm-library/src/main/java/io/realm/HandlerController.java
@@ -42,7 +42,6 @@
 import io.realm.internal.async.QueryUpdateTask;
 import io.realm.log.RealmLog;
 
-import static android.R.attr.version;
 import static io.realm.internal.HandlerControllerConstants.LOCAL_COMMIT;
 import static io.realm.internal.HandlerControllerConstants.REALM_CHANGED;
 
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
index 29376bff76..724ec56cf5 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
@@ -34,6 +34,13 @@
      */
     E first();
 
+    /**
+     * Gets the first object from the collection. If the collection is empty, the provided default will be used instead.
+     *
+     * @return the first object or the provided default.
+     */
+    E first(E defaultValue);
+
     /**
      * Gets the last object from the collection.
      *
@@ -42,6 +49,13 @@
      */
     E last();
 
+    /**
+     * Gets the last object from the collection. If the collection is empty, the provided default will be used instead.
+     *
+     * @return the last object or the provided default.
+     */
+    E last(E defaultValue);
+
     /**
      * Sorts a collection based on the provided field in ascending order.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/Property.java b/realm/realm-library/src/main/java/io/realm/Property.java
new file mode 100644
index 0000000000..82fb4a0655
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/Property.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+
+/**
+ * Class for handling properties/fields.
+ */
+
+public class Property {
+    public static boolean PRIMARY_KEY = true;
+    public static boolean REQUIRED    = true;
+    public static boolean INDEXED     = true;
+
+    private final long nativePtr;
+
+    public Property(String name, RealmFieldType type, boolean isPrimary, boolean isIndexed, boolean isRequired) {
+        this.nativePtr = nativeCreateProperty(name, type.getNativeValue(), isPrimary, isIndexed, !isRequired);
+    }
+
+    public Property(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
+        String linkedToName = linkedTo.getClassName();
+        this.nativePtr = nativeCreateProperty(name, type.getNativeValue(), linkedToName);
+    }
+
+    protected Property(long nativePtr) {
+        this.nativePtr = nativePtr;
+    }
+
+    protected long getNativePtr() {
+        return nativePtr;
+    }
+
+    public void close() {
+        if (nativePtr != 0) {
+            nativeClose(nativePtr);
+        }
+    }
+
+    private static native long nativeCreateProperty(String name, int type, boolean isPrimary, boolean isIndexed, boolean isNullable);
+    private static native long nativeCreateProperty(String name, int type, String linkedToName);
+    private static native void nativeClose(long nativePtr);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index de51d80733..a6a6844345 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -23,8 +23,6 @@
 import android.util.JsonReader;
 import android.util.Log;
 
-import com.getkeepsafe.relinker.BuildConfig;
-
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -46,17 +44,20 @@
 import java.util.Scanner;
 import java.util.Set;
 import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.ColumnInfo;
+import io.realm.internal.ObjectServerFacade;
 import io.realm.internal.RealmCore;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
-import io.realm.log.AndroidLogger;
+import io.realm.internal.async.RealmAsyncTaskImpl;
 import io.realm.log.RealmLog;
 import rx.Observable;
 
@@ -186,9 +187,10 @@ public static synchronized void init(Context context) {
                 throw new IllegalArgumentException("Non-null context required.");
             }
             RealmCore.loadLibrary(context);
-            RealmLog.add(BuildConfig.DEBUG ? new AndroidLogger(Log.DEBUG) : new AndroidLogger(Log.WARN));
             defaultConfiguration = new RealmConfiguration.Builder(context).build();
+            ObjectServerFacade.getSyncFacadeIfPossible().init(context);
             BaseRealm.applicationContext = context.getApplicationContext();
+            SharedRealm.initialize(new File(context.getFilesDir(), ".realm.temp"));
         }
     }
 
@@ -268,7 +270,7 @@ static Realm createInstance(RealmConfiguration configuration, ColumnIndices[] gl
                 deleteRealm(configuration);
             } else {
                 try {
-                    migrateRealm(configuration);
+                    migrateRealm(configuration, e);
                 } catch (FileNotFoundException fileNotFoundException) {
                     // Should never happen
                     throw new RealmFileException(RealmFileException.Kind.NOT_FOUND, fileNotFoundException);
@@ -313,23 +315,42 @@ static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices[]
     private static void initializeRealm(Realm realm) {
         long version = realm.getVersion();
         boolean commitNeeded = false;
+        boolean syncAvailable = realm.configuration.isSyncConfiguration();
+
         try {
-            realm.beginTransaction();
-            if (version == UNVERSIONED) {
-                commitNeeded = true;
-                realm.setVersion(realm.configuration.getSchemaVersion());
+            if (!syncAvailable) {
+                realm.beginTransaction();
+                if (version == UNVERSIONED) {
+                    commitNeeded = true;
+                    realm.setVersion(realm.configuration.getSchemaVersion());
+                }
             }
 
             RealmProxyMediator mediator = realm.configuration.getSchemaMediator();
             final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
             final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap;
             columnInfoMap = new HashMap<Class<? extends RealmModel>, ColumnInfo>(modelClasses.size());
+            ArrayList<RealmObjectSchema> realmObjectSchemas = new ArrayList<>();
+            RealmSchema realmSchemaCache = new RealmSchema();
             for (Class<? extends RealmModel> modelClass : modelClasses) {
                 // Create and validate table
-                if (version == UNVERSIONED) {
+                if (version == UNVERSIONED && !syncAvailable) {
                     mediator.createTable(modelClass, realm.sharedRealm);
                 }
-                columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
+                if (syncAvailable) {
+                    RealmObjectSchema realmObjectSchema = mediator.createRealmObjectSchema(modelClass, realmSchemaCache);
+                    realmObjectSchemas.add(realmObjectSchema);
+                } else {
+                    columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
+                }
+            }
+            if (syncAvailable) {
+                RealmSchema schema = new RealmSchema(realmObjectSchemas);
+                // Assumption: when SyncConfiguration then additive schema update mode
+                realm.sharedRealm.updateSchema(schema, version);
+                for (Class<? extends RealmModel> modelClass : modelClasses) {
+                    columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
+                }
             }
             realm.schema.columnIndices = new ColumnIndices(
                     (version == UNVERSIONED) ? realm.configuration.getSchemaVersion() : version,
@@ -338,14 +359,27 @@ private static void initializeRealm(Realm realm) {
             if (version == UNVERSIONED) {
                 final Transaction transaction = realm.getConfiguration().getInitialDataTransaction();
                 if (transaction != null) {
-                    transaction.execute(realm);
+                    if (syncAvailable) {
+                        realm.executeTransaction(transaction);
+                        realm.executeTransaction(new Transaction() {
+                            @Override
+                            public void execute(Realm realm) {
+                                realm.setVersion(realm.configuration.getSchemaVersion());
+                            }
+                        });
+                    } else {
+                        transaction.execute(realm);
+                    }
                 }
+
             }
         } finally {
-            if (commitNeeded) {
-                realm.commitTransaction(false);
-            } else {
-                realm.cancelTransaction();
+            if (!syncAvailable) {
+                if (commitNeeded) {
+                    realm.commitTransaction(false);
+                } else {
+                    realm.cancelTransaction();
+                }
             }
         }
     }
@@ -366,6 +400,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || json == null) {
             return;
         }
+        checkIfValid();
 
         for (int i = 0; i < json.length(); i++) {
             try {
@@ -395,6 +430,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || json == null) {
             return;
         }
+        checkIfValid();
         checkHasPrimaryKey(clazz);
         for (int i = 0; i < json.length(); i++) {
             try {
@@ -450,6 +486,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || json == null || json.length() == 0) {
             return;
         }
+        checkIfValid();
         checkHasPrimaryKey(clazz);
 
         JSONArray arr;
@@ -481,6 +518,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || inputStream == null) {
             return;
         }
+        checkIfValid();
 
         JsonReader reader = new JsonReader(new InputStreamReader(inputStream, "UTF-8"));
         try {
@@ -516,6 +554,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || in == null) {
             return;
         }
+        checkIfValid();
         checkHasPrimaryKey(clazz);
 
         // As we need the primary key value we have to first parse the entire input stream as in the general
@@ -553,6 +592,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || json == null) {
             return null;
         }
+        checkIfValid();
 
         try {
             return configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json, false);
@@ -580,6 +620,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || json == null) {
             return null;
         }
+        checkIfValid();
         checkHasPrimaryKey(clazz);
         try {
             E realmObject = configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json, true);
@@ -636,6 +677,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || json == null || json.length() == 0) {
             return null;
         }
+        checkIfValid();
         checkHasPrimaryKey(clazz);
 
         JSONObject obj;
@@ -668,6 +710,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || inputStream == null) {
             return null;
         }
+        checkIfValid();
         E realmObject;
         Table table = schema.getTable(clazz);
         if (table.hasPrimaryKey()) {
@@ -720,6 +763,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || in == null) {
             return null;
         }
+        checkIfValid();
         checkHasPrimaryKey(clazz);
 
         // As we need the primary key value we have to first parse the entire input stream as in the general
@@ -1118,7 +1162,7 @@ public void insertOrUpdate(RealmModel object) {
      * The copied object(s) are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
      * <p>
-     * *WARNING*: Any changes to copied objects can be merged back into Realm using 
+     * *WARNING*: Any changes to copied objects can be merged back into Realm using
      * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed.
      * This includes references to other objects, and can potentially override changes made by other threads.
      *
@@ -1139,9 +1183,9 @@ public void insertOrUpdate(RealmModel object) {
      * The copied object(s) are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
      * <p>
-     * *WARNING*: Any changes to copied objects can be merged back into Realm using 
-     * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed. 
-     * This includes references to other objects even though they might be {@code null} due to {@code maxDepth} being 
+     * *WARNING*: Any changes to copied objects can be merged back into Realm using
+     * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed.
+     * This includes references to other objects even though they might be {@code null} due to {@code maxDepth} being
      * reached. This can also potentially override changes made by other threads.
      *
      * @param realmObject {@link RealmObject} to copy.
@@ -1391,7 +1435,7 @@ public void run() {
             }
         });
 
-        return new RealmAsyncTask(pendingTransaction);
+        return new RealmAsyncTaskImpl(pendingTransaction, asyncTaskExecutor);
     }
 
     /**
@@ -1455,7 +1499,23 @@ private void checkMaxDepth(int maxDepth) {
      * @throws FileNotFoundException if the Realm file doesn't exist.
      */
     public static void migrateRealm(RealmConfiguration configuration) throws FileNotFoundException {
-        migrateRealm(configuration, null);
+        migrateRealm(configuration, (RealmMigration) null);
+    }
+
+    /**
+     * Called when migration needed in the Realm initialization.
+     *
+     * @param configuration {@link RealmConfiguration}
+     * @param cause which triggers this migration.
+     * @throws FileNotFoundException if the Realm file doesn't exist.
+     */
+    private static void migrateRealm(final RealmConfiguration configuration, final RealmMigrationNeededException cause)
+            throws FileNotFoundException {
+        BaseRealm.migrateRealm(configuration, null, new MigrationCallback() {
+            @Override
+            public void migrationComplete() {
+            }
+        }, cause);
     }
 
     /**
@@ -1472,7 +1532,7 @@ public static void migrateRealm(RealmConfiguration configuration, RealmMigration
             @Override
             public void migrationComplete() {
             }
-        });
+        }, null);
     }
 
     /**
@@ -1504,17 +1564,6 @@ public static boolean compactRealm(RealmConfiguration configuration) {
         return BaseRealm.compactRealm(configuration);
     }
 
-    // Get the canonical path for a given file
-    static String getCanonicalPath(File realmFile) {
-        try {
-            return realmFile.getCanonicalPath();
-        } catch (IOException e) {
-            throw new RealmFileException(RealmFileException.Kind.ACCESS_ERROR,
-                    "Could not resolve the canonical path to the Realm file: " + realmFile.getAbsolutePath(),
-                    e);
-        }
-    }
-
     Table getTable(Class<? extends RealmModel> clazz) {
         return schema.getTable(clazz);
     }
@@ -1586,6 +1635,35 @@ public static Object getDefaultModule() {
         }
     }
 
+    /**
+     * Returns the current number of open Realm instances across all threads that are using this configuration.
+     * This includes both dynamic and normal Realms.
+     *
+     * @param configuration the {@link io.realm.RealmConfiguration} for the Realm.
+     * @return number of open Realm instances across all threads.
+     */
+    public static int getGlobalInstanceCount(RealmConfiguration configuration) {
+        final AtomicInteger globalCount = new AtomicInteger(0);
+        RealmCache.invokeWithGlobalRefCount(configuration, new RealmCache.Callback() {
+            @Override
+            public void onResult(int count) {
+                globalCount.set(count);
+            }
+        });
+        return globalCount.get();
+    }
+
+    /**
+     * Returns the current number of open Realm instances on the thread calling this method. This include both
+     * dynamic and normal Realms.
+     *
+     * @param configuration the {@link io.realm.RealmConfiguration} for the Realm.
+     * @return number of open Realm instances across all threads.
+     */
+    public static int getLocalInstanceCount(RealmConfiguration configuration) {
+        return RealmCache.getLocalThreadCount(configuration);
+    }
+
     /**
      * Encapsulates a Realm transaction.
      * <p>
diff --git a/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java b/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
index aa53c0ce8e..28fceabc74 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
@@ -16,8 +16,6 @@
 
 package io.realm;
 
-import java.util.concurrent.Future;
-
 /**
  * Represents a pending asynchronous Realm transaction.
  * <p>
@@ -25,39 +23,18 @@
  * case of a configuration change for example (to avoid memory leak, as the transaction will post the result to the
  * caller's thread callback).
  */
-public final class RealmAsyncTask {
-    private final Future<?> pendingQuery;
-    private volatile boolean isCancelled = false;
-
-    RealmAsyncTask(Future<?> pendingQuery) {
-        this.pendingQuery = pendingQuery;
-    }
+public interface RealmAsyncTask {
 
     /**
      * Attempts to cancel execution of this transaction (if it hasn't already completed or previously cancelled).
      */
-    public void cancel() {
-        pendingQuery.cancel(true);
-        isCancelled = true;
-
-        // From "Java Threads": By Scott Oaks & Henry Wong
-        // cancelled tasks are never executed, but may
-        // accumulate in work queues, which may causes a memory leak
-        // if the task hold references (to an enclosing class for example)
-        // we can use purge() but one caveat applies: if a second thread attempts to add
-        // something to the pool (using the execute() method) at the same time the
-        // first thread is attempting to purge the queue the attempt to purge
-        // the queue fails and the cancelled object remain in the queue.
-        // A better way to cancel objects with thread pools is to use the remove()
-        Realm.asyncTaskExecutor.getQueue().remove(pendingQuery);
-    }
+    void cancel();
 
     /**
      * Checks whether an attempt to cancel the transaction was performed.
      *
      * @return {@code true} if {@link #cancel()} has already been called, {@code false} otherwise.
      */
-    public boolean isCancelled() {
-        return isCancelled;
-    }
+    boolean isCancelled();
 }
+
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index dd7cd65632..09f9a60eca 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -26,7 +26,10 @@
 
 import io.realm.exceptions.RealmFileException;
 import io.realm.internal.ColumnIndices;
+import io.realm.internal.SharedRealm;
+import io.realm.internal.Table;
 import io.realm.log.RealmLog;
+import io.realm.internal.ObjectServerFacade;
 
 /**
  * To cache {@link Realm}, {@link DynamicRealm} instances and related resources.
@@ -117,6 +120,19 @@ private RealmCache(RealmConfiguration config) {
 
         RefAndCount refAndCount = cache.refAndCountMap.get(RealmCacheType.valueOf(realmClass));
 
+        if (refAndCount.globalCount == 0) {
+            SharedRealm sharedRealm = SharedRealm.getInstance(configuration);
+            if (Table.primaryKeyTableNeedsMigration(sharedRealm)) {
+                sharedRealm.beginTransaction();
+                if (Table.migratePrimaryKeyTableIfNeeded(sharedRealm)) {
+                    sharedRealm.commitTransaction();
+                } else {
+                    sharedRealm.cancelTransaction();
+                }
+            }
+            sharedRealm.close();
+        }
+
         if (refAndCount.localRealm.get() == null) {
             // Create a new local Realm instance
             BaseRealm realm;
@@ -155,6 +171,11 @@ private RealmCache(RealmConfiguration config) {
 
         @SuppressWarnings("unchecked")
         E realm = (E) refAndCount.localRealm.get();
+
+        // Notify SyncPolicy that the Realm has been opened for the first time
+        if (refAndCount.globalCount == 1) {
+            ObjectServerFacade.getFacade(configuration.isSyncConfiguration()).realmOpened(configuration);
+        }
         return realm;
     }
 
@@ -210,13 +231,17 @@ static synchronized void release(BaseRealm realm) {
             for (RealmCacheType type : RealmCacheType.values()) {
                 totalRefCount += cache.refAndCountMap.get(type).globalCount;
             }
+
+            // No more local reference to this Realm in current thread, close the instance.
+            realm.doClose();
+
             // No more instance of typed Realm and dynamic Realm. Remove the configuration from cache.
             if (totalRefCount == 0) {
                 cachesMap.remove(canonicalPath);
+                ObjectServerFacade.getFacade(realm.getConfiguration().isSyncConfiguration())
+                        .realmClosed(realm.getConfiguration());
             }
 
-            // No more local reference to this Realm in current thread, close the instance.
-            realm.doClose();
         } else {
             refAndCount.localCount.set(refCount);
         }
@@ -370,6 +395,19 @@ private static void copyAssetFileIfNeeded(RealmConfiguration configuration) {
         }
     }
 
+    static int getLocalThreadCount(RealmConfiguration configuration) {
+        RealmCache cache = cachesMap.get(configuration.getPath());
+        if (cache == null) {
+            return 0;
+        } else {
+            int totalRefCount = 0;
+            for (RealmCacheType type : RealmCacheType.values()) {
+                totalRefCount += cache.refAndCountMap.get(type).localCount.get();
+            }
+            return totalRefCount;
+        }
+    }
+
     /**
      * Finds an entry for specified schema version in the array.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index 630a50c1a1..7cd6d6fcd4 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -22,7 +22,6 @@
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
-import java.lang.ref.WeakReference;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.util.Arrays;
@@ -30,9 +29,9 @@
 import java.util.HashSet;
 import java.util.Set;
 
-import io.realm.annotations.PrimaryKey;
 import io.realm.annotations.RealmModule;
 import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmFileException;
 import io.realm.internal.RealmCore;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.SharedRealm;
@@ -61,7 +60,7 @@
  * <li>It has its schema version set to 0.</li>
  * </ul>
  */
-public final class RealmConfiguration {
+public class RealmConfiguration {
 
     public static final String DEFAULT_REALM_NAME = "default.realm";
     public static final int KEY_LENGTH = 64;
@@ -98,19 +97,32 @@
     private final RxObservableFactory rxObservableFactory;
     private final Realm.Transaction initialDataTransaction;
 
-    private RealmConfiguration(Builder builder) {
-        this.realmDirectory = builder.directory;
-        this.realmFileName = builder.fileName;
-        this.canonicalPath = Realm.getCanonicalPath(new File(realmDirectory, realmFileName));
-        this.assetFilePath = builder.assetFilePath;
-        this.key = builder.key;
-        this.schemaVersion = builder.schemaVersion;
-        this.deleteRealmIfMigrationNeeded = builder.deleteRealmIfMigrationNeeded;
-        this.migration = builder.migration;
-        this.durability = builder.durability;
-        this.schemaMediator = createSchemaMediator(builder);
-        this.rxObservableFactory = builder.rxFactory;
-        this.initialDataTransaction = builder.initialDataTransaction;
+    // We need to enumerate all parameters since SyncConfiguration and RealmConfiguration supports different
+    // subsets of them.
+    protected RealmConfiguration(File realmDirectory,
+                              String realmFileName,
+                              String canonicalPath,
+                              String assetFilePath,
+                              byte[] key,
+                              long schemaVersion,
+                              RealmMigration migration,
+                              boolean deleteRealmIfMigrationNeeded,
+                              SharedRealm.Durability durability,
+                              RealmProxyMediator schemaMediator,
+                              RxObservableFactory rxObservableFactory,
+                              Realm.Transaction initialDataTransaction) {
+        this.realmDirectory = realmDirectory;
+        this.realmFileName = realmFileName;
+        this.canonicalPath = canonicalPath;
+        this.assetFilePath = assetFilePath;
+        this.key = key;
+        this.schemaVersion = schemaVersion;
+        this.migration = migration;
+        this.deleteRealmIfMigrationNeeded = deleteRealmIfMigrationNeeded;
+        this.durability = durability;
+        this.schemaMediator = schemaMediator;
+        this.rxObservableFactory = rxObservableFactory;
+        this.initialDataTransaction = initialDataTransaction;
     }
 
     public File getRealmDirectory() {
@@ -225,9 +237,12 @@ public boolean equals(Object obj) {
         //noinspection SimplifiableIfStatement
         if (rxObservableFactory != null ? !rxObservableFactory.equals(that.rxObservableFactory) : that.rxObservableFactory != null) return false;
         if (initialDataTransaction != null ? !initialDataTransaction.equals(that.initialDataTransaction) : that.initialDataTransaction != null) return false;
+
         return schemaMediator.equals(that.schemaMediator);
     }
 
+
+
     @Override
     public int hashCode() {
         int result = realmDirectory.hashCode();
@@ -246,10 +261,8 @@ public int hashCode() {
     }
 
     // Creates the mediator that defines the current schema
-    private RealmProxyMediator createSchemaMediator(Builder builder) {
-
-        Set<Object> modules = builder.modules;
-        Set<Class<? extends RealmModel>> debugSchema = builder.debugSchema;
+    protected static RealmProxyMediator createSchemaMediator(Set<Object> modules,
+                                                             Set<Class<? extends RealmModel>> debugSchema) {
 
         // If using debug schema, use special mediator
         if (debugSchema.size() > 0) {
@@ -324,7 +337,7 @@ public String toString() {
      *
      * @return {@code true} if RxJava dependency exist, {@code false} otherwise.
      */
-    private static synchronized boolean isRxJavaAvailable() {
+    static synchronized boolean isRxJavaAvailable() {
         if (rxJavaAvailable == null) {
             try {
                 Class.forName("rx.Observable");
@@ -336,10 +349,27 @@ private static synchronized boolean isRxJavaAvailable() {
         return rxJavaAvailable;
     }
 
+    // Get the canonical path for a given file
+    protected static String getCanonicalPath(File realmFile) {
+        try {
+            return realmFile.getCanonicalPath();
+        } catch (IOException e) {
+            throw new RealmFileException(RealmFileException.Kind.ACCESS_ERROR,
+                    "Could not resolve the canonical path to the Realm file: " + realmFile.getAbsolutePath(),
+                    e);
+        }
+    }
+
+    // Check if this configuration is a SyncConfiguration instance.
+    boolean isSyncConfiguration() {
+        return false;
+    }
+
     /**
      * RealmConfiguration.Builder used to construct instances of a RealmConfiguration in a fluent manner.
      */
-    public static final class Builder {
+    public static class Builder {
+         // IMPORTANT: When adding any new methods to this class also add them to SyncConfiguration.
         private File directory;
         private String fileName;
         private String assetFilePath;
@@ -622,7 +652,20 @@ public RealmConfiguration build() {
             if (rxFactory == null && isRxJavaAvailable()) {
                 rxFactory = new RealmObservableFactory();
             }
-            return new RealmConfiguration(this);
+
+            return new RealmConfiguration(directory,
+                    fileName,
+                    getCanonicalPath(new File(directory, fileName)),
+                    assetFilePath,
+                    key,
+                    schemaVersion,
+                    migration,
+                    deleteRealmIfMigrationNeeded,
+                    durability,
+                    createSchemaMediator(modules, debugSchema),
+                    rxFactory,
+                    initialDataTransaction
+            );
         }
 
         private void checkModule(Object module) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index 9ba427a4c4..3b0f54afcd 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -456,30 +456,62 @@ public E get(int location) {
      * {@inheritDoc}
      */
     public E first() {
+        return firstImpl(true, null);
+    }
+
+    /**
+    * {@inheritDoc}
+    */
+    public E first(E defaultValue) {
+        return firstImpl(false, defaultValue);
+    }
+
+    private E firstImpl(boolean shouldThrow, E defaultValue) {
         if (managedMode) {
             checkValidView();
             if (!view.isEmpty()) {
                 return get(0);
             }
-        } else if (unmanagedList != null && unmanagedList.size() > 0) {
+        } else if (unmanagedList != null && !unmanagedList.isEmpty()) {
             return unmanagedList.get(0);
         }
-        throw new IndexOutOfBoundsException("The list is empty.");
+        
+        if (shouldThrow) {
+            throw new IndexOutOfBoundsException("The list is empty.");
+        } else {
+            return defaultValue;
+        }
     }
 
     /**
      * {@inheritDoc}
      */
     public E last() {
+        return lastImpl(true, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public E last(E defaultValue) {
+        return lastImpl(false, defaultValue);
+    }
+
+    private E lastImpl(boolean shouldThrow, E defaultValue) {
         if (managedMode) {
             checkValidView();
             if (!view.isEmpty()) {
                 return get((int) view.size() - 1);
             }
-        } else if (unmanagedList != null && unmanagedList.size() > 0) {
+        } else if (unmanagedList != null && !unmanagedList.isEmpty()) {
             return unmanagedList.get(unmanagedList.size() - 1);
         }
-        throw new IndexOutOfBoundsException("The list is empty.");
+
+        if (shouldThrow) {
+            throw new IndexOutOfBoundsException("The list is empty.");
+        } else {
+            return defaultValue;
+        }
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index cd41670a83..febc7e89db 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -16,10 +16,6 @@
 
 package io.realm;
 
-import io.realm.annotations.Required;
-import io.realm.internal.Table;
-import io.realm.internal.TableOrView;
-
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Date;
@@ -28,6 +24,10 @@
 import java.util.Map;
 import java.util.Set;
 
+import io.realm.annotations.Required;
+import io.realm.internal.Table;
+import io.realm.internal.TableOrView;
+
 /**
  * Class for interacting with the schema for a given RealmObject class. This makes it possible to
  * add, delete or change the fields for given class.
@@ -68,6 +68,7 @@
     private final BaseRealm realm;
     final Table table;
     private final Map<String, Long> columnIndices;
+    private final long nativePtr;
 
     /**
      * Creates a schema object for a given Realm class.
@@ -80,6 +81,47 @@
         this.realm = realm;
         this.table = table;
         this.columnIndices = columnIndices;
+        this.nativePtr = 0;
+    }
+
+    /**
+     * Creates a schema object using object store. This constructor is intended to be used by
+     * the validation of schema, object schemas and prorperties through the object store. Even though the constructor
+     * is public, there is never a purpose which justifies calling it!
+     *
+     * @param className name of the class
+     */
+    RealmObjectSchema(String className) {
+        this.realm = null;
+        this.table = null;
+        this.columnIndices = null;
+        this.nativePtr = nativeCreateRealmObjectSchema(className);
+    }
+
+    protected RealmObjectSchema(long nativePtr) {
+        this.realm = null;
+        this.table = null;
+        this.columnIndices = null;
+        this.nativePtr = nativePtr;
+    }
+
+    /**
+     * Closes/frees native resource. Even though the method is public, there is never a purpose which justifies calling
+     * it!
+     */
+    public void close() {
+        if (nativePtr != 0) {
+            Set<Property> properties = getProperties();
+            for (Property property : properties) {
+                property.close();
+            }
+            nativeClose(nativePtr);
+        }
+    }
+
+
+    protected long getNativePtr() {
+        return nativePtr;
     }
 
     /**
@@ -93,7 +135,11 @@
      * @return the name of the RealmObject class represented by this schema.
      */
     public String getClassName() {
-        return table.getName().substring(Table.TABLE_PREFIX.length());
+        if (realm == null) {
+            return nativeGetClassName(nativePtr);
+        } else {
+            return table.getName().substring(Table.TABLE_PREFIX.length());
+        }
     }
 
     /**
@@ -105,9 +151,9 @@ public String getClassName() {
      * @see RealmSchema#rename(String, String)
      */
     public RealmObjectSchema setClassName(String className) {
+        realm.checkNotInSync(); // renaming a table is not permitted
         checkEmpty(className);
         String internalTableName = Table.TABLE_PREFIX + className;
-        //FIXME : when core implements class name length check, please remove.
         if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
             throw new IllegalArgumentException("Class name is to long. Limit is 56 characters: \'" + className + "\' (" + Integer.toString(className.length()) + ")");
         }
@@ -208,6 +254,34 @@ public RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema o
         return this;
     }
 
+    /**
+     * Adds a property to an object schema. This method should only be used by proxy classes to set up a schema.
+     *
+     * @param property the property to add.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the method is called after opening a Realm.
+     */
+    protected RealmObjectSchema add(Property property) {
+        if (realm != null && nativePtr == 0) {
+            throw new IllegalArgumentException("Don't use this method.");
+        }
+        nativeAddProperty(nativePtr, property.getNativePtr());
+        return this;
+    }
+
+    private Set<Property> getProperties() {
+        if (realm == null) {
+            long[] ptrs = nativeGetProperties(nativePtr);
+            Set<Property> properties = new LinkedHashSet<>(ptrs.length);
+            for (int i = 0; i < ptrs.length; i++) {
+                properties.add(new Property(ptrs[i]));
+            }
+            return properties;
+        } else {
+            throw new IllegalArgumentException("Not possible");
+        }
+    }
+
     /**
      * Removes a field from the class.
      *
@@ -216,6 +290,7 @@ public RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema o
      * @throws IllegalArgumentException if field name doesn't exist.
      */
     public RealmObjectSchema removeField(String fieldName) {
+        realm.checkNotInSync(); // destructive modification of a schema is not permitted
         checkLegalName(fieldName);
         if (!hasField(fieldName)) {
             throw new IllegalStateException(fieldName + " does not exist.");
@@ -237,6 +312,7 @@ public RealmObjectSchema removeField(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
      */
     public RealmObjectSchema renameField(String currentFieldName, String newFieldName) {
+        realm.checkNotInSync(); // destructive modification of a schema is not permitted
         checkLegalName(currentFieldName);
         checkFieldExists(currentFieldName);
         checkLegalName(newFieldName);
@@ -302,6 +378,7 @@ public boolean hasIndex(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
      */
     public RealmObjectSchema removeIndex(String fieldName) {
+        realm.checkNotInSync(); // destructive modifications are not permitted
         checkLegalName(fieldName);
         checkFieldExists(fieldName);
         long columnIndex = getColumnIndex(fieldName);
@@ -344,6 +421,7 @@ public RealmObjectSchema addPrimaryKey(String fieldName) {
      * @throws IllegalArgumentException if the class doesn't have a primary key defined.
      */
     public RealmObjectSchema removePrimaryKey() {
+        realm.checkNotInSync(); // destructive modifications are not permitted
         if (!table.hasPrimaryKey()) {
             throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
         }
@@ -492,7 +570,7 @@ public RealmObjectSchema transform(Function function) {
         if (function != null) {
             long size = table.size();
             for (long i = 0; i < size; i++) {
-                function.apply(new DynamicRealmObject(realm, table.getCheckedRow(i), false));
+                function.apply(new DynamicRealmObject(realm, table.getCheckedRow(i)));
             }
         }
 
@@ -775,4 +853,10 @@ public int size() {
             throw new UnsupportedOperationException();
         }
     }
+
+    static native long nativeCreateRealmObjectSchema(String className);
+    static native void nativeAddProperty(long nativePtr, long nativePropertyPtr);
+    static native long[] nativeGetProperties(long nativePtr);
+    static native void nativeClose(long nativePtr);
+    static native String nativeGetClassName(long nativePtr);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index d50cad7172..566a050d44 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -2102,7 +2102,7 @@ public E findFirstAsync() {
         final E result;
         if (isDynamicQuery()) {
             //noinspection unchecked
-            result = (E) new DynamicRealmObject(className, realm, Row.EMPTY_ROW, false);
+            result = (E) new DynamicRealmObject(className, realm, Row.EMPTY_ROW);
         } else {
             result = realm.getConfiguration().getSchemaMediator().newInstance(
                     clazz, realm, Row.EMPTY_ROW, realm.getSchema().getColumnInfo(clazz),
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index ea37900e37..7bc4df26c5 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -225,10 +225,26 @@ public E get(int location) {
      */
     @Override
     public E first() {
-        if (size() > 0) {
+        return firstImpl(true, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E first(E defaultValue) {
+        return firstImpl(false, defaultValue);
+    }
+
+    private E firstImpl(boolean shouldThrow, E defaultValue) {
+        if (!isEmpty()) {
             return get(0);
         } else {
-            throw new IndexOutOfBoundsException("No results were found.");
+            if (shouldThrow) {
+                throw new IndexOutOfBoundsException("No results were found.");
+            } else {
+                return defaultValue;
+            }
         }
     }
 
@@ -237,11 +253,27 @@ public E first() {
      */
     @Override
     public E last() {
-        int size = size();
-        if (size > 0) {
-            return get(size - 1);
+        return lastImpl(true, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E last(E defaultValue) {
+        return lastImpl(false, defaultValue);
+        
+    }
+
+    private E lastImpl(boolean shouldThrow, E defaultValue) {
+        if (!isEmpty()) {
+            return get(size() - 1);
         } else {
-            throw new IndexOutOfBoundsException("No results were found.");
+            if (shouldThrow) {
+                throw new IndexOutOfBoundsException("No results were found.");
+            } else {
+                return defaultValue;
+            }
         }
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index 0780595495..99264bf6b1 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -16,6 +16,7 @@
 
 package io.realm;
 
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.LinkedHashSet;
 import java.util.Map;
@@ -49,6 +50,7 @@
     private final Map<String, RealmObjectSchema> dynamicClassToSchema = new HashMap<String, RealmObjectSchema>();
 
     private final BaseRealm realm;
+    private long nativePtr;
     ColumnIndices columnIndices; // Cached field look up
 
     /**
@@ -56,6 +58,43 @@
      */
     RealmSchema(BaseRealm realm) {
         this.realm = realm;
+        this.nativePtr = 0;
+    }
+
+    /**
+     * Creates a wrappor to easily manipulate Object Store schemas. This constructor should only be called by
+     * proxy classes during validation of schema.
+     */
+    RealmSchema() {
+        // This is the case where the schema is created from the proxy classes.
+        // dynamicClassToSchema is used to keep track of which model classes have been processed.
+        this.realm = null;
+        this.nativePtr = 0;
+        // TODO: create a Object Store realm::Schema object and store the native pointer
+    }
+
+
+    RealmSchema(ArrayList<RealmObjectSchema> realmObjectSchemas) {
+        long list[] = new long[realmObjectSchemas.size()];
+        for (int i = 0; i < realmObjectSchemas.size(); i++) {
+            list[i] = realmObjectSchemas.get(i).getNativePtr();
+        }
+        this.nativePtr = nativeCreateFromList(list);
+        this.realm = null;
+    }
+
+    public long getNativePtr() {
+        return this.nativePtr;
+    }
+
+    public void close() {
+        if (nativePtr != 0) {
+            Set<RealmObjectSchema> schemas = getAll();
+            for (RealmObjectSchema schema : schemas) {
+                schema.close();
+            }
+            nativeClose(nativePtr);
+        }
     }
 
     /**
@@ -67,13 +106,21 @@
      */
     public RealmObjectSchema get(String className) {
         checkEmpty(className, EMPTY_STRING_MSG);
-        String internalClassName = TABLE_PREFIX + className;
-        if (realm.sharedRealm.hasTable(internalClassName)) {
-            Table table = realm.sharedRealm.getTable(internalClassName);
-            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-            return new RealmObjectSchema(realm, table, columnIndices);
+        if (realm == null) {
+            if (contains(className)) {
+                return dynamicClassToSchema.get(className);
+            } else {
+                return null;
+            }
         } else {
-            return null;
+            String internalClassName = TABLE_PREFIX + className;
+            if (realm.sharedRealm.hasTable(internalClassName)) {
+                Table table = realm.sharedRealm.getTable(internalClassName);
+                RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
+                return new RealmObjectSchema(realm, table, columnIndices);
+            } else {
+                return null;
+            }
         }
     }
 
@@ -83,18 +130,27 @@ public RealmObjectSchema get(String className) {
      * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
      */
     public Set<RealmObjectSchema> getAll() {
-        int tableCount = (int) realm.sharedRealm.size();
-        Set<RealmObjectSchema> schemas = new LinkedHashSet<>(tableCount);
-        for (int i = 0; i < tableCount; i++) {
-            String tableName = realm.sharedRealm.getTableName(i);
-            if (!Table.isModelTable(tableName)) {
-                continue;
+        if (realm == null) {
+            long[] ptrs = nativeGetAll(nativePtr);
+            Set<RealmObjectSchema> schemas = new LinkedHashSet<>(ptrs.length);
+            for (int i = 0; i < ptrs.length; i++) {
+                schemas.add(new RealmObjectSchema(ptrs[i]));
             }
-            Table table = realm.sharedRealm.getTable(tableName);
-            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-            schemas.add(new RealmObjectSchema(realm, table, columnIndices));
+            return schemas;
+        } else {
+            int tableCount = (int) realm.sharedRealm.size();
+            Set<RealmObjectSchema> schemas = new LinkedHashSet<>(tableCount);
+            for (int i = 0; i < tableCount; i++) {
+                String tableName = realm.sharedRealm.getTableName(i);
+                if (!Table.isModelTable(tableName)) {
+                    continue;
+                }
+                Table table = realm.sharedRealm.getTable(tableName);
+                RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
+                schemas.add(new RealmObjectSchema(realm, table, columnIndices));
+            }
+            return schemas;
         }
-        return schemas;
     }
 
     /**
@@ -104,17 +160,24 @@ public RealmObjectSchema get(String className) {
      * @return a Realm schema object for that class.
      */
     public RealmObjectSchema create(String className) {
+        // adding a class is always permitted
         checkEmpty(className, EMPTY_STRING_MSG);
-        String internalTableName = TABLE_PREFIX + className;
-        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
-            throw new IllegalArgumentException("Class name is to long. Limit is 57 characters: " + className.length());
-        }
-        if (realm.sharedRealm.hasTable(internalTableName)) {
-            throw new IllegalArgumentException("Class already exists: " + className);
+        if (realm == null) {
+            RealmObjectSchema realmObjectSchema = new RealmObjectSchema(className);
+            dynamicClassToSchema.put(className, realmObjectSchema);
+            return realmObjectSchema;
+        } else {
+            String internalTableName = TABLE_PREFIX + className;
+            if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
+                throw new IllegalArgumentException("Class name is to long. Limit is 57 characters: " + className.length());
+            }
+            if (realm.sharedRealm.hasTable(internalTableName)) {
+                throw new IllegalArgumentException("Class already exists: " + className);
+            }
+            Table table = realm.sharedRealm.getTable(internalTableName);
+            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
+            return new RealmObjectSchema(realm, table, columnIndices);
         }
-        Table table = realm.sharedRealm.getTable(internalTableName);
-        RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-        return new RealmObjectSchema(realm, table, columnIndices);
     }
 
     /**
@@ -124,6 +187,7 @@ public RealmObjectSchema create(String className) {
      * @param className name of the class to remove.
      */
     public void remove(String className) {
+        realm.checkNotInSync(); // destructive modifications are not permitted
         checkEmpty(className, EMPTY_STRING_MSG);
         String internalTableName = TABLE_PREFIX + className;
         checkHasTable(className, "Cannot remove class because it is not in this Realm: " + className);
@@ -142,6 +206,7 @@ public void remove(String className) {
      * @return a schema object for renamed class.
      */
     public RealmObjectSchema rename(String oldClassName, String newClassName) {
+        realm.checkNotInSync(); // destructive modifications are not permitted
         checkEmpty(oldClassName, "Class names cannot be empty or null");
         checkEmpty(newClassName, "Class names cannot be empty or null");
         String oldInternalName = TABLE_PREFIX + oldClassName;
@@ -178,7 +243,11 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
      * @return {@code true} if the class already exists. {@code false} otherwise.
      */
     public boolean contains(String className) {
-        return realm.sharedRealm.hasTable(Table.TABLE_PREFIX + className);
+        if (realm == null) {
+            return dynamicClassToSchema.containsKey(className);
+        } else {
+            return realm.sharedRealm.hasTable(Table.TABLE_PREFIX + className);
+        }
     }
 
     private void checkEmpty(String str, String error) {
@@ -279,4 +348,8 @@ RealmObjectSchema getSchemaForClass(String className) {
     static String getSchemaForTable(Table table) {
         return table.getName().substring(Table.TABLE_PREFIX.length());
     }
+
+    static native long nativeCreateFromList(long[] objectSchemaPtrs);
+    static native void nativeClose(long nativePtr);
+    static native long[] nativeGetAll(long nativePtr);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
index a12f94368a..5c7ba906d2 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
@@ -65,7 +65,7 @@ static Kind getKind(byte value) {
                     return EXISTS;
                 case SharedRealm.FILE_EXCEPTION_KIND_NOT_FOUND:
                     return NOT_FOUND;
-                case SharedRealm.FILE_EXCEPTION_KIND_IMCOMPATIBLE_LOCK_FILE:
+                case SharedRealm.FILE_EXCEPTION_KIND_INCOMPATIBLE_LOCK_FILE:
                     return INCOMPATIBLE_LOCK_FILE;
                 case SharedRealm.FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED:
                     return FORMAT_UPGRADE_REQUIRED;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
index 42c89a20c1..e969452972 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
@@ -27,7 +27,7 @@
  */
 public class CheckedRow extends UncheckedRow {
 
-    // Used if created from other row. This keeps a strong reference to avoid GC'ing the original object, and it's
+    // Used if created from other row. This keeps a strong reference to avoid GC'ing the original object, and its
     // underlying native data.
     @SuppressWarnings("unused")
     private UncheckedRow originalRow;
@@ -124,7 +124,7 @@ public void setNull(long columnIndex) {
     protected native String nativeGetString(long nativePtr, long columnIndex);
     protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
     protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
-    public static native long nativeGetLinkView(long nativePtr, long columnIndex);
+    protected native long nativeGetLinkView(long nativePtr, long columnIndex);
     protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
     protected native void nativeSetBoolean(long nativeRowPtr, long columnIndex, boolean value);
     protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Keep.java b/realm/realm-library/src/main/java/io/realm/internal/Keep.java
index 45f86dc70a..598ebccc48 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Keep.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Keep.java
@@ -24,7 +24,7 @@
 /**
  * This annotation is used to mark the classes to be kept by ProGuard/DexGuard.
  * The ProGuard configuration must have '-keep class io.realm.internal.Keep'
- * and '-keep @io.realm.internal.Keep class *'.
+ * and '-keep,includedescriptorclasses @io.realm.internal.Keep class * { *; }'.
  */
 @Retention(RetentionPolicy.CLASS)
 @Target(ElementType.TYPE)
diff --git a/realm/realm-library/src/main/java/io/realm/internal/KeepMember.java b/realm/realm-library/src/main/java/io/realm/internal/KeepMember.java
new file mode 100644
index 0000000000..e1308a9f21
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/KeepMember.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation is used to mark the fields and methods to be kept by ProGuard/DexGuard.
+ * The ProGuard configuration must have '-keep class io.realm.internal.KeepMember'
+ * and '-keep,includedescriptorclasses @io.realm.internal.KeepMember class * { @io.realm.internal.KeepMember *; }'.
+ * This annotation must be added to class as well to work.
+ */
+@Retention(RetentionPolicy.CLASS)
+@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
+public @interface KeepMember {
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
new file mode 100644
index 0000000000..8bb11bf554
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import android.content.Context;
+
+import io.realm.RealmConfiguration;
+import io.realm.exceptions.RealmException;
+
+/**
+ * Class acting as an mediator between the basic Realm APIs and the Object Server APIs.
+ * This breaks the cyclic dependency between ObjectServer and Realm code.
+ */
+public class ObjectServerFacade {
+
+    private final static ObjectServerFacade nonSyncFacade = new ObjectServerFacade();
+    private static ObjectServerFacade syncFacade = null;
+
+    static {
+        //noinspection TryWithIdenticalCatches
+        try {
+            Class syncFacadeClass = Class.forName("io.realm.internal.objectserver.SyncObjectServerFacade");
+            syncFacade = (ObjectServerFacade) syncFacadeClass.newInstance();
+        } catch (ClassNotFoundException ignored) {
+        } catch (InstantiationException e) {
+            throw new RealmException("Failed to init SyncObjectServerFacade", e);
+        } catch (IllegalAccessException e) {
+            throw new RealmException("Failed to init SyncObjectServerFacade", e);
+        }
+    }
+
+    /**
+     * Initialize the Object Server library
+     * @param context
+     */
+    public void init(Context context) {
+    }
+
+    /**
+     * Notify the session for this configuration that a local commit was made.
+     */
+    public void notifyCommit(RealmConfiguration configuration, long lastSnapshotVersion) {
+    }
+
+    /**
+     * The first instance of this Realm was opened.
+     */
+    public void realmClosed(RealmConfiguration configuration) {
+    }
+
+    /**
+     * The last instance of this Realm was closed.
+     */
+    public void realmOpened(RealmConfiguration configuration) {
+    }
+
+    public String[] getUserAndServerUrl(RealmConfiguration config) {
+        return new String[2];
+    }
+
+    public static ObjectServerFacade getFacade(boolean needSyncFacade) {
+        if (needSyncFacade) {
+            return syncFacade;
+        }
+        return nonSyncFacade;
+    }
+
+    // Returns a SyncObjectServerFacade instance if the class exists. Otherwise returns a non-sync one.
+    public static ObjectServerFacade getSyncFacadeIfPossible() {
+        if (syncFacade != null) {
+            return syncFacade;
+        }
+        return nonSyncFacade;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java b/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java
index 72e043dc1d..1890f18271 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java
@@ -21,7 +21,9 @@
 import com.getkeepsafe.relinker.ReLinker;
 
 import java.io.File;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
 import java.util.Locale;
 
 /**
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java b/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
index d3464b2027..aaf97b6b5d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
@@ -34,7 +34,7 @@
      * This is getting called on the same thread which created this Realm when the same Realm file has been changed by
      * other thread. The changes on the same thread should not trigger this call.
      */
-    @SuppressWarnings("unused")
+    @SuppressWarnings("unused") // called from java_binding_context.cpp
     void notifyCommitByOtherThread();
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index b0ec6a9bfa..bd72e4f7b8 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -29,6 +29,8 @@
 import io.realm.Realm;
 import io.realm.RealmModel;
 import io.realm.RealmObject;
+import io.realm.RealmObjectSchema;
+import io.realm.RealmSchema;
 import io.realm.exceptions.RealmException;
 
 /**
@@ -42,6 +44,15 @@
  */
 public abstract class RealmProxyMediator {
 
+    /**
+     * Create a object schema for the given RealmObject class.
+     *
+     * @param clazz the {@link RealmObject} model class to create object schema for.
+     * @param realmSchema the {@link RealmSchema} to associate the object schema with.
+     * @return The object schema.
+     */
+    public abstract RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema realmSchema);
+
     /**
      * Creates the backing table in Realm for the given RealmObject class.
      *
@@ -166,7 +177,7 @@ public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz,
      * @param clazz the type of {@link RealmObject}
      * @param realm the reference to {@link Realm} where to create the object.
      * @param json the JSON data
-     * @param update {@code true} if Realm should try to update a existing object. This requires that the RealmObject 
+     * @param update {@code true} if Realm should try to update a existing object. This requires that the RealmObject
      *               class has a @PrimaryKey.
      * @return RealmObject that has been created or updated.
      * @throws JSONException if the JSON mapping doesn't match the expected class.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 8fa0cf6f22..e7ad6c0417 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -20,7 +20,7 @@
 import java.io.File;
 
 import io.realm.RealmConfiguration;
-import io.realm.RealmFieldType;
+import io.realm.RealmSchema;
 import io.realm.internal.async.BadVersionException;
 
 public final class SharedRealm implements Closeable {
@@ -30,9 +30,36 @@
     public static final byte FILE_EXCEPTION_KIND_PERMISSION_DENIED = 1;
     public static final byte FILE_EXCEPTION_KIND_EXISTS = 2;
     public static final byte FILE_EXCEPTION_KIND_NOT_FOUND = 3;
-    public static final byte FILE_EXCEPTION_KIND_IMCOMPATIBLE_LOCK_FILE = 4;
+    public static final byte FILE_EXCEPTION_KIND_INCOMPATIBLE_LOCK_FILE = 4;
     public static final byte FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED = 5;
 
+    public static void initialize(File tempDirectory) {
+        if (SharedRealm.temporaryDirectory != null) {
+            // already initialized
+            return;
+        }
+        if (tempDirectory == null) {
+            throw new IllegalArgumentException("'tempDirectory' must not be null.");
+        }
+
+        String temporaryDirectoryPath = tempDirectory.getAbsolutePath();
+        if (!tempDirectory.isDirectory() && !tempDirectory.mkdirs() && !tempDirectory.isDirectory()) {
+            throw new IOException("failed to create temporary directory: " + temporaryDirectoryPath);
+        }
+
+        if (!temporaryDirectoryPath.endsWith("/")) {
+            temporaryDirectoryPath += "/";
+        }
+        nativeInit(temporaryDirectoryPath);
+        SharedRealm.temporaryDirectory = tempDirectory;
+    }
+
+    public static File getTemporaryDirectory() {
+        return temporaryDirectory;
+    }
+
+    private volatile static File temporaryDirectory;
+
     public enum Durability {
         FULL(0),
         MEM_ONLY(1);
@@ -67,14 +94,19 @@
         SchemaMode(byte value) {
             this .value = value;
         }
+
+        public byte getNativeValue() {
+            return value;
+        }
     }
 
     // JNI will only hold a weak global ref to this.
     public final RealmNotifier realmNotifier;
+    public final ObjectServerFacade objectServerFacade;
 
     public static class VersionID implements Comparable<VersionID> {
-        final long version;
-        final long index;
+        public final long version;
+        public final long index;
 
         VersionID(long version, long index) {
             this.version = version;
@@ -143,6 +175,7 @@ private SharedRealm(long nativePtr, RealmConfiguration configuration, RealmNotif
         this.schemaChangeListener = schemaVersionListener;
         context = new Context();
         this.lastSchemaVersion = schemaVersionListener == null ? -1L : getSchemaVersion();
+        objectServerFacade = null;
     }
 
     public static SharedRealm getInstance(RealmConfiguration config) {
@@ -151,14 +184,22 @@ public static SharedRealm getInstance(RealmConfiguration config) {
 
     public static SharedRealm getInstance(RealmConfiguration config, RealmNotifier realmNotifier,
                                           SchemaVersionListener schemaVersionListener) {
+        String[] userAndServer = ObjectServerFacade.getSyncFacadeIfPossible().getUserAndServerUrl(config);
+        String rosServerUrl = userAndServer[0];
+        String rosUserToken = userAndServer[1];
+        boolean enable_caching = false; // Handled in Java currently
+        boolean disableFormatUpgrade = false; // TODO Double negatives :/
+        boolean autoChangeNotifications = true;
         long nativeConfigPtr = nativeCreateConfig(
                 config.getPath(),
                 config.getEncryptionKey(),
-                SchemaMode.SCHEMA_MODE_MANUAL.value,
+                rosServerUrl != null ? SchemaMode.SCHEMA_MODE_ADDITIVE.getNativeValue() : SchemaMode.SCHEMA_MODE_MANUAL.getNativeValue(),
                 config.getDurability() == Durability.MEM_ONLY,
-                false,
-                false,
-                true);
+                enable_caching,
+                disableFormatUpgrade,
+                autoChangeNotifications,
+                rosServerUrl,
+                rosUserToken);
         try {
             return new SharedRealm(
                     nativeGetSharedRealm(nativeConfigPtr, realmNotifier),
@@ -255,6 +296,10 @@ public void refresh(SharedRealm.VersionID version) throws BadVersionException {
         return new SharedRealm.VersionID(versionId[0], versionId[1]);
     }
 
+    public long getLastSnapshotVersion() {
+        return nativeGetSnapshotVersion(nativePtr);
+    }
+
     public boolean isClosed() {
         return nativePtr == 0 || nativeIsClosed(nativePtr);
     }
@@ -278,6 +323,10 @@ public boolean compact() {
         return nativeCompact(nativePtr);
     }
 
+    public void updateSchema(RealmSchema schema, long version) {
+        nativeUpdateSchema(nativePtr, schema.getNativePtr(), version);
+    }
+
     @Override
     public void close() {
         if (realmNotifier != null) {
@@ -318,9 +367,11 @@ public void invokeSchemaChangeListenerIfSchemaChanged() {
         }
     }
 
+    private static native void nativeInit(String temporaryDirectoryPath);
     private static native long nativeCreateConfig(String realmPath, byte[] key, byte schemaMode, boolean inMemory,
                                                   boolean cache, boolean disableFormatUpgrade,
-                                                  boolean autoChangeNotification);
+                                                  boolean autoChangeNotification,
+                                                  String syncServerURL, String syncUserToken);
     private static native void nativeCloseConfig(long nativeConfigPtr);
     private static native long nativeGetSharedRealm(long nativeConfigPtr, RealmNotifier notifier);
     private static native void nativeCloseSharedRealm(long nativeSharedRealmPtr);
@@ -330,6 +381,7 @@ private static native long nativeCreateConfig(String realmPath, byte[] key, byte
     private static native void nativeCancelTransaction(long nativeSharedRealmPtr);
     private static native boolean nativeIsInTransaction(long nativeSharedRealmPtr);
     private static native long nativeGetVersion(long nativeSharedRealmPtr);
+    private static native long nativeGetSnapshotVersion(long nativeSharedRealmPtr);
     private static native void nativeSetVersion(long nativeSharedRealmPtr, long version);
     private static native long nativeReadGroup(long nativeSharedRealmPtr);
     private static native boolean nativeIsEmpty(long nativeSharedRealmPtr);
@@ -346,4 +398,5 @@ private static native long nativeCreateConfig(String realmPath, byte[] key, byte
     private static native boolean nativeWaitForChange(long nativeSharedRealmPtr);
     private static native void nativeStopWaitForChange(long nativeSharedRealmPtr);
     private static native boolean nativeCompact(long nativeSharedRealmPtr);
+    private static native void nativeUpdateSchema(long nativePtr, long nativeSchemaPtr, long version);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index ad5c39f35b..88ba67d577 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -33,10 +33,6 @@
     public static final int TABLE_MAX_LENGTH = 56; // Max length of class names without prefix
     public static final String TABLE_PREFIX = Util.getTablePrefix();
     public static final long INFINITE = -1;
-    @SuppressWarnings("WeakerAccess")
-    public static final String STRING_DEFAULT_VALUE = "";
-    @SuppressWarnings("WeakerAccess")
-    public static final long INTEGER_DEFAULT_VALUE = 0;
     public static final boolean NULLABLE = true;
     public static final boolean NOT_NULLABLE = false;
 
@@ -218,7 +214,7 @@ public void renameColumn(long columnIndex, String newName) {
                 }
                 long pkRowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, className);
                 if (pkRowIndex != NO_MATCH) {
-                    pkTable.setString(PRIMARY_KEY_FIELD_COLUMN_INDEX, pkRowIndex, newName);
+                    nativeSetString(pkTable.nativePtr, PRIMARY_KEY_FIELD_COLUMN_INDEX, pkRowIndex, newName, false);
                 } else {
                     throw new IllegalStateException("Non-existent PrimaryKey column cannot be renamed");
                 }
@@ -408,7 +404,6 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue, boolean validation
         long primaryKeyColumnIndex = getPrimaryKey();
         RealmFieldType type = getColumnType(primaryKeyColumnIndex);
         long rowIndex;
-        UncheckedRow row;
 
         // Add with primary key initially set
         if (primaryKeyValue == null) {
@@ -419,9 +414,11 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue, boolean validation
                         throwDuplicatePrimaryKeyException("null");
                     }
                     rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                    row = getUncheckedRow(rowIndex);
-                    // FIXME: Use core's set_null_unique when core supports it.
-                    row.setNull(primaryKeyColumnIndex);
+                    if (type == RealmFieldType.STRING) {
+                        nativeSetStringUnique(nativePtr, primaryKeyColumnIndex, rowIndex, null);
+                    } else {
+                        nativeSetNullUnique(nativePtr, primaryKeyColumnIndex, rowIndex);
+                    }
                     break;
 
                 default:
@@ -523,43 +520,43 @@ protected long add(Object... values) {
             Object value = values[(int)columnIndex];
             switch (colTypes[(int)columnIndex]) {
             case BOOLEAN:
-                nativeSetBoolean(nativePtr, columnIndex, rowIndex, (Boolean)value);
+                nativeSetBoolean(nativePtr, columnIndex, rowIndex, (Boolean)value, false);
                 break;
             case INTEGER:
                 if (value == null) {
                     checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
-                    nativeSetNull(nativePtr, columnIndex, rowIndex);
+                    nativeSetNull(nativePtr, columnIndex, rowIndex, false);
                 } else {
                     long intValue = ((Number) value).longValue();
                     checkIntValueIsLegal(columnIndex, rowIndex, intValue);
-                    nativeSetLong(nativePtr, columnIndex, rowIndex, intValue);
+                    nativeSetLong(nativePtr, columnIndex, rowIndex, intValue, false);
                 }
                 break;
             case FLOAT:
-                nativeSetFloat(nativePtr, columnIndex, rowIndex, (Float) value);
+                nativeSetFloat(nativePtr, columnIndex, rowIndex, (Float) value, false);
                 break;
             case DOUBLE:
-                nativeSetDouble(nativePtr, columnIndex, rowIndex, (Double) value);
+                nativeSetDouble(nativePtr, columnIndex, rowIndex, (Double) value, false);
                 break;
             case STRING:
                 if (value == null) {
                     checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
-                    nativeSetNull(nativePtr, columnIndex, rowIndex);
+                    nativeSetNull(nativePtr, columnIndex, rowIndex, false);
                 } else {
                     String stringValue = (String) value;
                     checkStringValueIsLegal(columnIndex, rowIndex, stringValue);
-                    nativeSetString(nativePtr, columnIndex, rowIndex, (String) value);
+                    nativeSetString(nativePtr, columnIndex, rowIndex, (String) value, false);
                 }
                 break;
             case DATE:
                 if (value == null)
                     throw new IllegalArgumentException("Null Date is not allowed.");
-                nativeSetTimestamp(nativePtr, columnIndex, rowIndex, ((Date) value).getTime());
+                nativeSetTimestamp(nativePtr, columnIndex, rowIndex, ((Date) value).getTime(), false);
                 break;
             case BINARY:
                 if (value == null)
                     throw new IllegalArgumentException("Null Array is not allowed");
-                nativeSetByteArray(nativePtr, columnIndex, rowIndex, (byte[])value);
+                nativeSetByteArray(nativePtr, columnIndex, rowIndex, (byte[])value, false);
                 break;
             case UNSUPPORTED_MIXED:
             case UNSUPPORTED_TABLE:
@@ -713,6 +710,7 @@ public String getString(long columnIndex, long rowIndex) {
         return nativeGetByteArray(nativePtr, columnIndex, rowIndex);
     }
 
+    @Override
     public long getLink(long columnIndex, long rowIndex) {
         return nativeGetLink(nativePtr, columnIndex, rowIndex);
     }
@@ -731,6 +729,11 @@ public Table getLinkTarget(long columnIndex) {
         }
     }
 
+    @Override
+    public boolean isNull(long columnIndex, long rowIndex) {
+        return nativeIsNull(nativePtr, columnIndex, rowIndex);
+    }
+
     /**
      * Returns a non-checking Row. Incorrect use of this Row will cause a hard core crash.
      * If error checking is required, use {@link #getCheckedRow(long)} instead.
@@ -771,36 +774,36 @@ public CheckedRow getCheckedRow(long index) {
     //
 
     @Override
-    public void setLong(long columnIndex, long rowIndex, long value) {
+    public void setLong(long columnIndex, long rowIndex, long value, boolean isDefault) {
         checkImmutable();
         checkIntValueIsLegal(columnIndex, rowIndex, value);
-        nativeSetLong(nativePtr, columnIndex, rowIndex, value);
+        nativeSetLong(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
     @Override
-    public void setBoolean(long columnIndex, long rowIndex, boolean value) {
+    public void setBoolean(long columnIndex, long rowIndex, boolean value, boolean isDefault) {
         checkImmutable();
-        nativeSetBoolean(nativePtr, columnIndex, rowIndex, value);
+        nativeSetBoolean(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
     @Override
-    public void setFloat(long columnIndex, long rowIndex, float value) {
+    public void setFloat(long columnIndex, long rowIndex, float value, boolean isDefault) {
         checkImmutable();
-        nativeSetFloat(nativePtr, columnIndex, rowIndex, value);
+        nativeSetFloat(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
     @Override
-    public void setDouble(long columnIndex, long rowIndex, double value) {
+    public void setDouble(long columnIndex, long rowIndex, double value, boolean isDefault) {
         checkImmutable();
-        nativeSetDouble(nativePtr, columnIndex, rowIndex, value);
+        nativeSetDouble(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
     @Override
-    public void setDate(long columnIndex, long rowIndex, Date date) {
+    public void setDate(long columnIndex, long rowIndex, Date date, boolean isDefault) {
         if (date == null)
             throw new IllegalArgumentException("Null Date is not allowed.");
         checkImmutable();
-        nativeSetTimestamp(nativePtr, columnIndex, rowIndex, date.getTime());
+        nativeSetTimestamp(nativePtr, columnIndex, rowIndex, date.getTime(), isDefault);
     }
 
     /**
@@ -811,26 +814,33 @@ public void setDate(long columnIndex, long rowIndex, Date date) {
      * @param value a String value to set in the cell.
      */
     @Override
-    public void setString(long columnIndex, long rowIndex, String value) {
+    public void setString(long columnIndex, long rowIndex, String value, boolean isDefault) {
         checkImmutable();
         if (value == null) {
             checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
-            nativeSetNull(nativePtr, columnIndex, rowIndex);
+            nativeSetNull(nativePtr, columnIndex, rowIndex, isDefault);
         } else {
             checkStringValueIsLegal(columnIndex, rowIndex, value);
-            nativeSetString(nativePtr, columnIndex, rowIndex, value);
+            nativeSetString(nativePtr, columnIndex, rowIndex, value, isDefault);
         }
     }
 
     @Override
-    public void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data) {
+    public void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data, boolean isDefault) {
+        checkImmutable();
+        nativeSetByteArray(nativePtr, columnIndex, rowIndex, data, isDefault);
+    }
+
+    @Override
+    public void setLink(long columnIndex, long rowIndex, long value, boolean isDefault) {
         checkImmutable();
-        nativeSetByteArray(nativePtr, columnIndex, rowIndex, data);
+        nativeSetLink(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
-    public void setLink(long columnIndex, long rowIndex, long value) {
+    public void setNull(long columnIndex, long rowIndex, boolean isDefault) {
         checkImmutable();
-        nativeSetLink(nativePtr, columnIndex, rowIndex, value);
+        checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
+        nativeSetNull(nativePtr, columnIndex, rowIndex, isDefault);
     }
 
     public void addSearchIndex(long columnIndex) {
@@ -869,10 +879,10 @@ private Table getPrimaryKeyTable() {
         }
         Table pkTable = sharedRealm.getTable(PRIMARY_KEY_TABLE_NAME);
         if (pkTable.getColumnCount() == 0) {
-            pkTable.addColumn(RealmFieldType.STRING, PRIMARY_KEY_CLASS_COLUMN_NAME);
+            checkImmutable();
+            long columnIndex = pkTable.addColumn(RealmFieldType.STRING, PRIMARY_KEY_CLASS_COLUMN_NAME);
+            pkTable.addSearchIndex(columnIndex);
             pkTable.addColumn(RealmFieldType.STRING, PRIMARY_KEY_FIELD_COLUMN_NAME);
-        } else {
-            migratePrimaryKeyTableIfNeeded(sharedRealm.getGroupNative(), pkTable);
         }
 
         return pkTable;
@@ -894,18 +904,35 @@ private void invalidateCachedPrimaryKeyIndex() {
      * This will remove the prefix "class_" from all table names in the pk_column
      * Any database created on Realm-Java 0.84.1 and below will have this error.
      */
-    private void migratePrimaryKeyTableIfNeeded(long groupNativePtr, Table pkTable) {
-        nativeMigratePrimaryKeyTableIfNeeded(groupNativePtr, pkTable.nativePtr);
+    public static boolean migratePrimaryKeyTableIfNeeded(SharedRealm sharedRealm) {
+        if (sharedRealm == null || !sharedRealm.isInTransaction()) {
+            throwImmutable();
+        }
+        if (!sharedRealm.hasTable(PRIMARY_KEY_TABLE_NAME)) {
+            return false;
+        }
+        Table pkTable = sharedRealm.getTable(PRIMARY_KEY_TABLE_NAME);
+        return nativeMigratePrimaryKeyTableIfNeeded(sharedRealm.getGroupNative(), pkTable.nativePtr);
+    }
+
+    public static boolean primaryKeyTableNeedsMigration(SharedRealm sharedRealm) {
+        if (!sharedRealm.hasTable(PRIMARY_KEY_TABLE_NAME)) {
+            return false;
+        }
+        Table pkTable = sharedRealm.getTable(PRIMARY_KEY_TABLE_NAME);
+        return nativePrimaryKeyTableNeedsMigration(pkTable.nativePtr);
     }
 
     public boolean hasSearchIndex(long columnIndex) {
         return nativeHasSearchIndex(nativePtr, columnIndex);
     }
 
+    @Override
     public boolean isNullLink(long columnIndex, long rowIndex) {
         return nativeIsNullLink(nativePtr, columnIndex, rowIndex);
     }
 
+    @Override
     public void nullifyLink(long columnIndex, long rowIndex) {
         nativeNullifyLink(nativePtr, columnIndex, rowIndex);
     }
@@ -1254,7 +1281,7 @@ public long syncIfNeeded() {
         throw new RuntimeException("Not supported for tables");
     }
 
-    private void throwImmutable() {
+    private static void throwImmutable() {
         throw new IllegalStateException("Changing Realm data can only be done from inside a transaction.");
     }
 
@@ -1328,20 +1355,24 @@ public static String tableNameToClassName(String tableName) {
     private native long nativeGetLink(long nativePtr, long columnIndex, long rowIndex);
     public static native long nativeGetLinkView(long nativePtr, long columnIndex, long rowIndex);
     private native long nativeGetLinkTarget(long nativePtr, long columnIndex);
+    private native boolean nativeIsNull(long nativePtr, long columnIndex, long rowIndex);
     native long nativeGetRowPtr(long nativePtr, long index);
-    public static native void nativeSetLong(long nativeTablePtr, long columnIndex, long rowIndex, long value);
+    public static native void nativeSetLong(long nativeTablePtr, long columnIndex, long rowIndex, long value, boolean isDefault);
     public static native void nativeSetLongUnique(long nativeTablePtr, long columnIndex, long rowIndex, long value);
-    public static native void nativeSetBoolean(long nativeTablePtr, long columnIndex, long rowIndex, boolean value);
-    public static native void nativeSetFloat(long nativeTablePtr, long columnIndex, long rowIndex, float value);
-    public static native void nativeSetDouble(long nativeTablePtr, long columnIndex, long rowIndex, double value);
-    public static native void nativeSetTimestamp(long nativeTablePtr, long columnIndex, long rowIndex, long dateTimeValue);
-    public static native void nativeSetString(long nativeTablePtr, long columnIndex, long rowIndex, String value);
+    public static native void nativeSetBoolean(long nativeTablePtr, long columnIndex, long rowIndex, boolean value, boolean isDefault);
+    public static native void nativeSetFloat(long nativeTablePtr, long columnIndex, long rowIndex, float value, boolean isDefault);
+    public static native void nativeSetDouble(long nativeTablePtr, long columnIndex, long rowIndex, double value, boolean isDefault);
+    public static native void nativeSetTimestamp(long nativeTablePtr, long columnIndex, long rowIndex, long dateTimeValue, boolean isDefault);
+    public static native void nativeSetString(long nativeTablePtr, long columnIndex, long rowIndex, String value, boolean isDefault);
     public static native void nativeSetStringUnique(long nativeTablePtr, long columnIndex, long rowIndex, String value);
-    public static native void nativeSetNull(long nativeTablePtr, long columnIndex, long rowIndex);
-    public static native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data);
-    public static native void nativeSetLink(long nativeTablePtr, long columnIndex, long rowIndex, long value);
+    public static native void nativeSetNull(long nativeTablePtr, long columnIndex, long rowIndex, boolean isDefault);
+    // Use nativeSetStringUnique(null) for String column!
+    public static native void nativeSetNullUnique(long nativeTablePtr, long columnIndex, long rowIndex);
+    public static native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data, boolean isDefault);
+    public static native void nativeSetLink(long nativeTablePtr, long columnIndex, long rowIndex, long value, boolean isDefault);
     private native long nativeSetPrimaryKey(long privateKeyTableNativePtr, long nativePtr, String columnName);
-    private native void nativeMigratePrimaryKeyTableIfNeeded(long groupNativePtr, long primaryKeyTableNativePtr);
+    private static native boolean nativeMigratePrimaryKeyTableIfNeeded(long groupNativePtr, long primaryKeyTableNativePtr);
+    private static native boolean nativePrimaryKeyTableNeedsMigration(long primaryKeyTableNativePtr);
     private native void nativeAddSearchIndex(long nativePtr, long columnIndex);
     private native void nativeRemoveSearchIndex(long nativePtr, long columnIndex);
     private native boolean nativeHasSearchIndex(long nativePtr, long columnIndex);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
index ff39eb50ef..58404ee5bf 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
@@ -151,7 +151,7 @@
      * @param rowIndex
      * @param value
      */
-    void setLong(long columnIndex, long rowIndex, long value);
+    void setLong(long columnIndex, long rowIndex, long value, boolean isDefault);
 
     /**
      * Sets the boolean value of a cell identified by the columnIndex and the rowIndex of that cell.
@@ -160,7 +160,7 @@
      * @param rowIndex
      * @param value
      */
-    void setBoolean(long columnIndex, long rowIndex, boolean value);
+    void setBoolean(long columnIndex, long rowIndex, boolean value, boolean isDefault);
 
     /**
      * Sets the float value of a cell identified by the columnIndex and the rowIndex of that cell.
@@ -169,7 +169,7 @@
      * @param rowIndex
      * @param value
      */
-    void setFloat(long columnIndex, long rowIndex, float value);
+    void setFloat(long columnIndex, long rowIndex, float value, boolean isDefault);
 
     /**
      * Sets the double value of a cell identified by the columnIndex and the rowIndex of that cell.
@@ -178,7 +178,7 @@
      * @param rowIndex
      * @param value
      */
-    void setDouble(long columnIndex, long rowIndex, double value);
+    void setDouble(long columnIndex, long rowIndex, double value, boolean isDefault);
 
     /**
      * Sets the string value of a particular cell of the table/view identified by the columnIndex and the rowIndex of
@@ -188,7 +188,7 @@
      * @param rowIndex
      * @param value
      */
-    void setString(long columnIndex, long rowIndex, String value);
+    void setString(long columnIndex, long rowIndex, String value, boolean isDefault);
 
     /**
      * Sets the binary value for a particular cell identified by the rowIndex and columnIndex of the cell.
@@ -199,9 +199,9 @@
      */
     //void setBinaryByteBuffer(long columnIndex, long rowIndex, ByteBuffer data);
 
-    void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data);
+    void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data, boolean isDefault);
 
-    void setDate(long columnIndex, long rowIndex, Date date);
+    void setDate(long columnIndex, long rowIndex, Date date, boolean isDefault);
 
     boolean isNullLink(long columnIndex, long rowIndex);
 
@@ -214,7 +214,11 @@
      * @param rowIndex
      * @param value
      */
-    void setLink(long columnIndex, long rowIndex, long value);
+    void setLink(long columnIndex, long rowIndex, long value, boolean isDefault);
+
+    void setNull(long columnIndex, long rowIndex, boolean isDefault);
+
+    boolean isNull(long columnIndex, long rowIndex);
 
     long sumLong(long columnIndex);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableView.java b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
index fa3ce44194..746e206b8d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
@@ -253,6 +253,11 @@ public long getLink(long columnIndex, long rowIndex){
         return nativeGetLink(nativePtr, columnIndex, rowIndex);
     }
 
+    @Override
+    public boolean isNull(long columnIndex, long rowIndex) {
+        return nativeIsNull(nativePtr, columnIndex, rowIndex);
+    }
+
     // Methods for setting values.
 
     /**
@@ -263,7 +268,7 @@ public long getLink(long columnIndex, long rowIndex){
      * @param value the value.
      */
     @Override
-    public void setLong(long columnIndex, long rowIndex, long value){
+    public void setLong(long columnIndex, long rowIndex, long value, boolean isDefault){
         if (parent.isImmutable()) throwImmutable();
         nativeSetLong(nativePtr, columnIndex, rowIndex, value);
     }
@@ -276,7 +281,7 @@ public void setLong(long columnIndex, long rowIndex, long value){
      * @param value the value.
      */
     @Override
-    public void setBoolean(long columnIndex, long rowIndex, boolean value){
+    public void setBoolean(long columnIndex, long rowIndex, boolean value, boolean isDefault){
         if (parent.isImmutable()) throwImmutable();
         nativeSetBoolean(nativePtr, columnIndex, rowIndex, value);
     }
@@ -289,7 +294,7 @@ public void setBoolean(long columnIndex, long rowIndex, boolean value){
      * @param value the value.
      */
     @Override
-    public void setFloat(long columnIndex, long rowIndex, float value){
+    public void setFloat(long columnIndex, long rowIndex, float value, boolean isDefault){
         if (parent.isImmutable()) throwImmutable();
         nativeSetFloat(nativePtr, columnIndex, rowIndex, value);
     }
@@ -302,7 +307,7 @@ public void setFloat(long columnIndex, long rowIndex, float value){
      * @param value the value.
      */
     @Override
-    public void setDouble(long columnIndex, long rowIndex, double value){
+    public void setDouble(long columnIndex, long rowIndex, double value, boolean isDefault){
         if (parent.isImmutable()) throwImmutable();
         nativeSetDouble(nativePtr, columnIndex, rowIndex, value);
     }
@@ -315,7 +320,7 @@ public void setDouble(long columnIndex, long rowIndex, double value){
      * @param value the value.
      */
     @Override
-    public void setDate(long columnIndex, long rowIndex, Date value){
+    public void setDate(long columnIndex, long rowIndex, Date value, boolean isDefault){
         if (parent.isImmutable()) throwImmutable();
         nativeSetTimestampValue(nativePtr, columnIndex, rowIndex, value.getTime());
     }
@@ -328,7 +333,7 @@ public void setDate(long columnIndex, long rowIndex, Date value){
      * @param value the value.
      */
     @Override
-    public void setString(long columnIndex, long rowIndex, String value){
+    public void setString(long columnIndex, long rowIndex, String value, boolean isDefault){
         if (parent.isImmutable()) throwImmutable();
         nativeSetString(nativePtr, columnIndex, rowIndex, value);
     }
@@ -351,20 +356,29 @@ public void setBinaryByteBuffer(long columnIndex, long rowIndex, ByteBuffer data
     */
 
     @Override
-    public void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data){
+    public void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data, boolean isDefault){
         if (parent.isImmutable()) throwImmutable();
         nativeSetByteArray(nativePtr, columnIndex, rowIndex, data);
     }
 
-    public void setLink(long columnIndex, long rowIndex, long value){
+    @Override
+    public void setLink(long columnIndex, long rowIndex, long value, boolean isDefault){
         if (parent.isImmutable()) throwImmutable();
         nativeSetLink(nativePtr, columnIndex, rowIndex, value);
     }
 
+    @Override
+    public void setNull(long columnIndex, long rowIndex, boolean isDefault) {
+        if (parent.isImmutable()) throwImmutable();
+        getTable().setNull(columnIndex, getSourceRowIndex(rowIndex), isDefault);
+    }
+
+    @Override
     public boolean isNullLink(long columnIndex, long rowIndex) {
         return nativeIsNullLink(nativePtr, columnIndex, rowIndex);
     }
 
+    @Override
     public void nullifyLink(long columnIndex, long rowIndex) {
         nativeNullifyLink(nativePtr, columnIndex, rowIndex);
     }
@@ -788,6 +802,7 @@ public long syncIfNeeded() {
     private native String nativeGetString(long nativeViewPtr, long columnIndex, long rowIndex);
     private native byte[] nativeGetByteArray(long nativePtr, long columnIndex, long rowIndex);
     private native long nativeGetLink(long nativeViewPtr, long columnIndex, long rowIndex);
+    private native boolean nativeIsNull(long nativePtr, long columnIndex, long rowIndex);
     private native void nativeSetLong(long nativeViewPtr, long columnIndex, long rowIndex, long value);
     private native void nativeSetBoolean(long nativeViewPtr, long columnIndex, long rowIndex, boolean value);
     private native void nativeSetFloat(long nativeViewPtr, long columnIndex, long rowIndex, float value);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
index b867d42d6b..6e4bb8e9a4 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
@@ -296,7 +296,7 @@ public boolean hasColumn(String fieldName) {
     protected native String nativeGetString(long nativePtr, long columnIndex);
     protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
     protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
-    public static native long nativeGetLinkView(long nativePtr, long columnIndex);
+    protected native long nativeGetLinkView(long nativePtr, long columnIndex);
     protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
     protected native void nativeSetBoolean(long nativeRowPtr, long columnIndex, boolean value);
     protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Util.java b/realm/realm-library/src/main/java/io/realm/internal/Util.java
index 107350f769..d262452289 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Util.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Util.java
@@ -16,8 +16,18 @@
 
 package io.realm.internal;
 
+import android.os.Build;
+
+import java.io.File;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
 import io.realm.RealmModel;
 import io.realm.RealmObject;
+import io.realm.log.RealmLog;
 
 public class Util {
 
@@ -26,12 +36,6 @@ public static long getNativeMemUsage() {
     }
     static native long nativeGetMemUsage();
 
-    // Set to level=1 to get some trace from JNI native part.
-    public static void setDebugLevel(int level) {
-        nativeSetDebugLevel(level);
-    }
-    static native void nativeSetDebugLevel(int level);
-
     // Called by JNI. Do not remove
     static void javaPrint(String txt) {
         System.out.print(txt);
@@ -58,4 +62,81 @@ public static String getTablePrefix() {
 
         return clazz;
     }
+
+    //-----------------------------------------------------------------------
+    /**
+     * <p>Gets the stack trace from a Throwable as a String.</p>
+     *
+     * <p>The result of this method vary by JDK version as this method
+     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.
+     * On JDK1.3 and earlier, the cause exception will not be shown
+     * unless the specified throwable alters printStackTrace.</p>
+     *
+     * @param throwable  the <code>Throwable</code> to be examined
+     * @return the stack trace as generated by the exception's
+     *  <code>printStackTrace(PrintWriter)</code> method
+     *
+     * Credit: https://commons.apache.org/proper/commons-lang/apidocs/src-html/org/apache/commons/lang3/exception/ExceptionUtils.html
+     */
+     public static String getStackTrace(final Throwable throwable) {
+        final StringWriter sw = new StringWriter();
+        final PrintWriter pw = new PrintWriter(sw, true);
+        throwable.printStackTrace(pw);
+        return sw.getBuffer().toString();
+     }
+
+    // Credit: http://stackoverflow.com/questions/2799097/how-can-i-detect-when-an-android-application-is-running-in-the-emulator
+    public static boolean isEmulator() {
+        return Build.FINGERPRINT.startsWith("generic")
+                || Build.FINGERPRINT.startsWith("unknown")
+                || Build.MODEL.contains("google_sdk")
+                || Build.MODEL.contains("Emulator")
+                || Build.MODEL.contains("Android SDK built for x86")
+                || Build.MANUFACTURER.contains("Genymotion")
+                || (Build.BRAND.startsWith("generic") && Build.DEVICE.startsWith("generic"))
+                || "google_sdk".equals(Build.PRODUCT);
+    }
+
+    public static boolean deleteRealm(String canonicalPath, File realmFolder, String realmFileName) {
+        boolean realmDeleted = true;
+        final String management = ".management";
+        File managementFolder = new File(realmFolder, realmFileName + management);
+
+        // delete files in management directory and the directory
+        // there is no subfolders in the management directory
+        File[] files = managementFolder.listFiles();
+        if (files != null) {
+            for (File file : files) {
+                realmDeleted = realmDeleted && file.delete();
+            }
+        }
+        realmDeleted = realmDeleted && managementFolder.delete();
+
+        // delete specific files in root directory
+        return realmDeleted && deletes(canonicalPath, realmFolder, realmFileName);
+    }
+
+    private static boolean deletes(String canonicalPath, File rootFolder, String realmFileName) {
+        final AtomicBoolean realmDeleted = new AtomicBoolean(true);
+
+        List<File> filesToDelete = Arrays.asList(
+                new File(rootFolder, realmFileName),
+                new File(rootFolder, realmFileName + ".lock"),
+                // Old core log file naming styles
+                new File(rootFolder, realmFileName + ".log_a"),
+                new File(rootFolder, realmFileName + ".log_b"),
+                new File(rootFolder, realmFileName + ".log"),
+                new File(canonicalPath));
+        for (File fileToDelete : filesToDelete) {
+            if (fileToDelete.exists()) {
+                boolean deleteResult = fileToDelete.delete();
+                if (!deleteResult) {
+                    realmDeleted.set(false);
+                    RealmLog.warn("Could not delete the file %s", fileToDelete);
+                }
+            }
+        }
+        return realmDeleted.get();
+    }
+
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/RealmAsyncTaskImpl.java b/realm/realm-library/src/main/java/io/realm/internal/async/RealmAsyncTaskImpl.java
new file mode 100644
index 0000000000..d523c9ae28
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/RealmAsyncTaskImpl.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.async;
+
+import java.util.concurrent.Future;
+import java.util.concurrent.ThreadPoolExecutor;
+
+import io.realm.RealmAsyncTask;
+
+public final class RealmAsyncTaskImpl implements RealmAsyncTask {
+    private final Future<?> pendingTask;
+    private final ThreadPoolExecutor service;
+    private volatile boolean isCancelled = false;
+
+    public RealmAsyncTaskImpl(Future<?> pendingTask, ThreadPoolExecutor service) {
+        this.pendingTask = pendingTask;
+        this.service = service;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void cancel() {
+        pendingTask.cancel(true);
+        isCancelled = true;
+
+        // From "Java Threads": By Scott Oaks & Henry Wong
+        // cancelled tasks are never executed, but may
+        // accumulate in work queues, which may causes a memory leak
+        // if the task hold references (to an enclosing class for example)
+        // we can use purge() but one caveat applies: if a second thread attempts to add
+        // something to the pool (using the execute() method) at the same time the
+        // first thread is attempting to purge the queue the attempt to purge
+        // the queue fails and the cancelled object remain in the queue.
+        // A better way to cancel objects with thread pools is to use the remove()
+        service.getQueue().remove(pendingTask);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isCancelled() {
+        return isCancelled;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
index 482cbdc1b6..7f251618a2 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
@@ -92,6 +92,16 @@ private RealmThreadPoolExecutor(int corePoolSize, int maxPoolSize) {
         return super.submit(new BgPriorityCallable<T>(task));
     }
 
+    /**
+     * Submits a runnable for executing a network request.
+     *
+     * @param task the task to submit
+     * @return a future representing pending completion of the task
+     */
+    public Future<?> submitNetworkRequest(Runnable task) {
+        return super.submit(new BgPriorityRunnable(task));
+    }
+
     /**
      * Method invoked prior to executing the given Runnable to pause execution of the thread.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index 4b94846c22..0800ae230b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -31,6 +31,8 @@
 
 import io.realm.Realm;
 import io.realm.RealmModel;
+import io.realm.RealmObjectSchema;
+import io.realm.RealmSchema;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
@@ -58,6 +60,12 @@ public CompositeMediator(RealmProxyMediator... mediators) {
         this.mediators = Collections.unmodifiableMap(tempMediators);
     }
 
+    @Override
+    public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema schema) {
+        RealmProxyMediator mediator = getMediator(clazz);
+        return mediator.createRealmObjectSchema(clazz, schema);
+    }
+
     @Override
     public Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm) {
         RealmProxyMediator mediator = getMediator(clazz);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
index af48ac87da..3374d337be 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
@@ -31,6 +31,8 @@
 
 import io.realm.Realm;
 import io.realm.RealmModel;
+import io.realm.RealmObjectSchema;
+import io.realm.RealmSchema;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
@@ -73,6 +75,11 @@ public RealmProxyMediator getOriginalMediator() {
         return originalMediator;
     }
 
+    @Override
+    public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema schema) {
+        checkSchemaHasClass(clazz);
+        return originalMediator.createRealmObjectSchema(clazz, schema);
+    }
     @Override
     public Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm) {
         checkSchemaHasClass(clazz);
diff --git a/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java b/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java
index 9f460aeeed..d39f536486 100644
--- a/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java
+++ b/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java
@@ -36,6 +36,9 @@
  *     <td>{@link LogLevel#OFF}</td><td>Not supported. Remove the logger instead.</td>
  * </tr>
  * </table>
+ *
+ * @deprecated The new {@link RealmLogger} for Android is implemented in native code. This class will be removed in a
+ * future release.
  */
 public class AndroidLogger implements Logger {
 
diff --git a/realm/realm-library/src/main/java/io/realm/log/LogLevel.java b/realm/realm-library/src/main/java/io/realm/log/LogLevel.java
index 8333656322..2811a67b93 100644
--- a/realm/realm-library/src/main/java/io/realm/log/LogLevel.java
+++ b/realm/realm-library/src/main/java/io/realm/log/LogLevel.java
@@ -22,7 +22,7 @@
  * Realm uses the log levels defined by Log4J:
  * https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/Level.html
  *
- * @see RealmLog#add(Logger)
+ * @see RealmLog#add(RealmLogger)
  */
 public class LogLevel {
 
diff --git a/realm/realm-library/src/main/java/io/realm/log/Logger.java b/realm/realm-library/src/main/java/io/realm/log/Logger.java
index 7da472b4a8..6e36fed33f 100644
--- a/realm/realm-library/src/main/java/io/realm/log/Logger.java
+++ b/realm/realm-library/src/main/java/io/realm/log/Logger.java
@@ -19,6 +19,7 @@
 /**
  * Interface for custom loggers that can be registered at {@link RealmLog#add(Logger)}.
  * The different log levels are described in {@link LogLevel}.
+ * @deprecated Use {@link RealmLogger} instead.
  */
 public interface Logger {
 
diff --git a/realm/realm-library/src/main/java/io/realm/log/RealmLog.java b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
index f83173214a..e16d1be4b6 100644
--- a/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
+++ b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
@@ -16,48 +16,110 @@
 
 package io.realm.log;
 
-import java.util.ArrayList;
-import java.util.List;
+import android.util.Log;
 
-import io.realm.internal.Keep;
-import io.realm.internal.Util;
+import java.util.IdentityHashMap;
+import java.util.Map;
 
 /**
  * Global logger used by all Realm components.
- * Custom loggers can be added by registering classes implementing {@link Logger}.
+ * Custom loggers can be added by registering classes implementing {@link RealmLogger}.
  */
-@Keep
 public final class RealmLog {
 
-    private static final Logger[] NO_LOGGERS = new Logger[0];
+    @SuppressWarnings("FieldCanBeLocal")
+    private static String REALM_JAVA_TAG = "REALM_JAVA";
 
-    // All of the below should be modified together under under a lock on LOGGERS.
-    private static final List<Logger> LOGGERS = new ArrayList<>();
-    private static volatile Logger[] loggersAsArray = NO_LOGGERS;
-    private static int minimumNativeLogLevel = Integer.MAX_VALUE;
+    /**
+     * To convert the old {@link Logger} to the new {@link RealmLogger}.
+     */
+    private static class LoggerAdapter implements RealmLogger {
+        private Logger logger;
+        private static final Map<Logger, LoggerAdapter> loggerMap = new IdentityHashMap<Logger, LoggerAdapter>();
+
+        LoggerAdapter(Logger logger) {
+            this.logger = logger;
+            if (loggerMap.containsKey(logger)) {
+                throw new IllegalStateException(String.format("Logger %s exists in the map!", logger.toString()));
+            }
+            loggerMap.put(logger, this);
+        }
+
+        static RealmLogger removeLogger(Logger logger) {
+            return loggerMap.remove(logger);
+        }
+
+        static void clear() {
+            loggerMap.clear();
+        }
+
+        @Override
+        public void log(int level, String tag, Throwable throwable, String message) {
+            switch (level) {
+                case LogLevel.TRACE:
+                    logger.trace(throwable, message);
+                    break;
+                case LogLevel.INFO:
+                    logger.info(throwable, message);
+                    break;
+                case LogLevel.DEBUG:
+                    logger.debug(throwable, message);
+                    break;
+                case LogLevel.WARN:
+                    logger.warn(throwable, message);
+                    break;
+                case LogLevel.ERROR:
+                    logger.error(throwable, message);
+                    break;
+                case LogLevel.FATAL:
+                    logger.fatal(throwable, message);
+                    break;
+                default:
+                    throw new IllegalArgumentException("Level: " + level + " cannot be logged.");
+            }
+        }
+    }
 
     /**
      * Adds a logger implementation that will be notified on log events.
      *
-     * @param logger the reference to a {@link Logger} implementation.
+     * @param logger the reference to a {@link RealmLogger} implementation.
      */
-    public static void add(Logger logger) {
+    public static void add(RealmLogger logger) {
         if (logger == null) {
             throw new IllegalArgumentException("A non-null logger has to be provided");
         }
-        synchronized (LOGGERS) {
-            LOGGERS.add(logger);
-            int minimumLogLevel = logger.getMinimumNativeDebugLevel();
-            if (minimumLogLevel < minimumNativeLogLevel) {
-                setMinimumNativeDebugLevel(minimumLogLevel);
-            }
-            loggersAsArray = LOGGERS.toArray(new Logger[LOGGERS.size()]);
+        nativeAddLogger(logger);
+    }
+
+    /**
+     * Adds a logger implementation that will be notified on log events.
+     *
+     * @param logger the reference to a {@link Logger} implementation.
+     * @deprecated use {@link #add(RealmLogger)} instead.
+     */
+    public static void add(Logger logger) {
+        synchronized (LoggerAdapter.class) {
+            add(new LoggerAdapter(logger));
         }
     }
 
-    private static void setMinimumNativeDebugLevel(int nativeDebugLevel) {
-        minimumNativeLogLevel = nativeDebugLevel;
-        Util.setDebugLevel(nativeDebugLevel); // Log level for Realm Core
+    /**
+     * Sets the current {@link LogLevel}. Setting this will affect all registered loggers.
+     *
+     * @param level see {@link LogLevel}.
+     */
+    public static void setLevel(int level) {
+        nativeSetLogLevel(level);
+    }
+
+    /**
+     * Get the current {@link LogLevel}.
+     *
+     * @return the current {@link LogLevel}.
+     */
+    public static int getLevel() {
+        return nativeGetLogLevel();
     }
 
     /**
@@ -65,36 +127,52 @@ private static void setMinimumNativeDebugLevel(int nativeDebugLevel) {
      *
      * @return {@code true} if the logger was removed, {@code false} otherwise.
      */
-    public static boolean remove(Logger logger) {
+    public static boolean remove(RealmLogger logger) {
         if (logger == null) {
             throw new IllegalArgumentException("A non-null logger has to be provided");
         }
-        synchronized (LOGGERS) {
-            LOGGERS.remove(logger);
-            int newMinLevel = Integer.MAX_VALUE;
-            for (int i = 0; i < LOGGERS.size(); i++) {
-                int logMin = LOGGERS.get(i).getMinimumNativeDebugLevel();
-                if (logMin < newMinLevel) {
-                    newMinLevel = logMin;
-                }
+        nativeRemoveLogger(logger);
+        return true;
+    }
+
+    /**
+     * Removes the given logger if it is currently added.
+     *
+     * @return {@code true} if the logger was removed, {@code false} otherwise.
+     * @deprecated use {@link #remove(RealmLogger)} instead.
+     */
+    public static boolean remove(Logger logger) {
+        synchronized (LoggerAdapter.class) {
+            if (logger == null) {
+                throw new IllegalArgumentException("A non-null logger has to be provided");
+            }
+            RealmLogger adaptor = LoggerAdapter.removeLogger(logger);
+            if (adaptor != null) {
+                nativeRemoveLogger(adaptor);
             }
-            setMinimumNativeDebugLevel(newMinLevel);
-            loggersAsArray = LOGGERS.toArray(new Logger[LOGGERS.size()]);
         }
         return true;
     }
 
     /**
-     * Remove all loggers.
+     * Removes all loggers. The default native logger will be removed as well. Use {@link #registerDefaultLogger()} to
+     * add it back.
      */
     public static void clear() {
-        synchronized (LOGGERS) {
-            LOGGERS.clear();
-            setMinimumNativeDebugLevel(Integer.MAX_VALUE);
-            loggersAsArray = NO_LOGGERS;
+        synchronized (LoggerAdapter.class) {
+            nativeClearLoggers();
+            LoggerAdapter.clear();
         }
     }
 
+    /**
+     * Adds default native logger if it has been removed before. If the default logger has been registered already,
+     * it won't be added again. The default logger on Android will log to logcat.
+     */
+    public static void registerDefaultLogger() {
+        nativeRegisterDefaultLogger();
+    }
+
     /**
      * Logs a {@link LogLevel#TRACE} exception.
      *
@@ -122,11 +200,7 @@ public static void trace(String message, Object... args) {
      * @param args optional args used to format the message using {@link String#format(String, Object...)}.
      */
     public static void trace(Throwable throwable, String message, Object... args) {
-        Logger[] loggers = loggersAsArray;
-        //noinspection ForLoopReplaceableByForEach
-        for (int i = 0; i < loggers.length; i++) {
-            loggers[i].trace(throwable, message, args);
-        }
+        log(LogLevel.TRACE, throwable, message, args);
     }
 
     /**
@@ -156,11 +230,7 @@ public static void debug(String message, Object... args) {
      * @param args optional args used to format the message using {@link String#format(String, Object...)}.
      */
     public static void debug(Throwable throwable, String message, Object... args) {
-        Logger[] loggers = loggersAsArray;
-        //noinspection ForLoopReplaceableByForEach
-        for (int i = 0; i < loggers.length; i++) {
-            loggers[i].debug(throwable, message, args);
-        }
+        log(LogLevel.DEBUG, throwable, message, args);
     }
 
     /**
@@ -190,11 +260,7 @@ public static void info(String message, Object... args) {
      * @param args optional args used to format the message using {@link String#format(String, Object...)}.
      */
     public static void info(Throwable throwable, String message, Object... args) {
-        Logger[] loggers = loggersAsArray;
-        //noinspection ForLoopReplaceableByForEach
-        for (int i = 0; i < loggers.length; i++) {
-            loggers[i].info(throwable, message, args);
-        }
+        log(LogLevel.INFO, throwable, message, args);
     }
 
     /**
@@ -224,11 +290,7 @@ public static void warn(String message, Object... args) {
      * @param args optional args used to format the message using {@link String#format(String, Object...)}.
      */
     public static void warn(Throwable throwable, String message, Object... args) {
-        Logger[] loggers = loggersAsArray;
-        //noinspection ForLoopReplaceableByForEach
-        for (int i = 0; i < loggers.length; i++) {
-            loggers[i].warn(throwable, message, args);
-        }
+        log(LogLevel.WARN, throwable, message, args);
     }
 
     /**
@@ -258,11 +320,7 @@ public static void error(String message, Object... args) {
      * @param args optional args used to format the message using {@link String#format(String, Object...)}.
      */
     public static void error(Throwable throwable, String message, Object... args) {
-        Logger[] loggers = loggersAsArray;
-        //noinspection ForLoopReplaceableByForEach
-        for (int i = 0; i < loggers.length; i++) {
-            loggers[i].error(throwable, message, args);
-        }
+        log(LogLevel.ERROR, throwable, message, args);
     }
 
     /**
@@ -292,10 +350,32 @@ public static void fatal(String message, Object... args) {
      * @param args optional args used to format the message using {@link String#format(String, Object...)}.
      */
     public static void fatal(Throwable throwable, String message, Object... args) {
-        Logger[] loggers = loggersAsArray;
-        //noinspection ForLoopReplaceableByForEach
-        for (int i = 0; i < loggers.length; i++) {
-            loggers[i].fatal(throwable, message, args);
+        log(LogLevel.FATAL, throwable, message, args);
+    }
+
+    // Format the message, parse the stacktrace of given throwable and pass them to nativeLog.
+    private static void log(int level, Throwable throwable, String message, Object... args) {
+        StringBuilder stringBuilder = new StringBuilder();
+        if (args != null && args.length > 0) {
+            message = String.format(message, args);
+        }
+        if (throwable != null) {
+            stringBuilder.append(Log.getStackTraceString(throwable));
         }
+        if (message != null) {
+            if (throwable != null) {
+                stringBuilder.append("\n");
+            }
+            stringBuilder.append(message);
+        }
+        nativeLog(level,REALM_JAVA_TAG, throwable, stringBuilder.toString());
     }
+
+    private static native void nativeAddLogger(RealmLogger logger);
+    private static native void nativeRemoveLogger(RealmLogger logger);
+    private static native void nativeClearLoggers();
+    private static native void nativeRegisterDefaultLogger();
+    private static native void nativeLog(int level, String tag, Throwable throwable, String message);
+    private static native void nativeSetLogLevel(int level);
+    private static native int nativeGetLogLevel();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/log/RealmLogger.java b/realm/realm-library/src/main/java/io/realm/log/RealmLogger.java
new file mode 100644
index 0000000000..f94c7859d6
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/log/RealmLogger.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.log;
+
+import io.realm.internal.KeepMember;
+
+/**
+ * Interface for custom loggers that can be registered at {@link RealmLog#add(RealmLogger)}.
+ * The different log levels are described in {@link LogLevel}.
+ */
+@KeepMember
+public interface RealmLogger {
+
+    /**
+     * Handles a log event.
+     *
+     * @param level for this log event. It can only be a value between {@link LogLevel#TRACE} and
+     * {@link LogLevel#FATAL}
+     * @param tag for this log event.
+     * @param throwable optional exception to log.
+     * @param message optional additional message.
+     */
+    @KeepMember
+    void log(int level, String tag, Throwable throwable, String message);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
index 285388bbc8..7c89ecd45a 100644
--- a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
+++ b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
@@ -322,10 +322,12 @@ public void releaseReference(K object) {
             Integer count = references.get(object);
             if (count == null) {
                 throw new IllegalStateException("Object does not have any references: " + object);
-            } else if (count > 0) {
+            } else if (count > 1) {
                 references.put(object, count - 1);
-            } else {
+            } else if (count == 1) {
                 references.remove(object);
+            } else {
+                throw new IllegalStateException("Invalid reference count: " + count);
             }
         }
     }
diff --git a/realm/realm-library/src/objectServer/AndroidManifest.xml b/realm/realm-library/src/objectServer/AndroidManifest.xml
new file mode 100644
index 0000000000..0a7a9b5299
--- /dev/null
+++ b/realm/realm-library/src/objectServer/AndroidManifest.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="io.realm" >
+
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+    <uses-permission android:name="android.permission.INTERNET" />
+
+</manifest>
\ No newline at end of file
diff --git a/realm/realm-library/src/objectServer/java/io/realm/AuthenticationListener.java b/realm/realm-library/src/objectServer/java/io/realm/AuthenticationListener.java
new file mode 100644
index 0000000000..c769a7d693
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/AuthenticationListener.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.annotations.Beta;
+
+/**
+ * @Beta
+ * Interface describing events related to Users and their authentication
+ */
+@Beta
+public interface AuthenticationListener {
+    /**
+     * A user was logged into the Object Server
+     *
+     * @param user {@link SyncUser} that is now logged in.
+     */
+    void loggedIn(SyncUser user);
+
+    /**
+     * A user was successfully logged out from the Object Server.
+     *
+     * @param user {@link SyncUser} that was successfully logged out.
+     */
+    void loggedOut(SyncUser user);
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
new file mode 100644
index 0000000000..17e0365396
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.annotations.Beta;
+
+/**
+ * @Beta
+ * This class enumerate all potential errors related to using the Object Server or synchronizing data.
+ */
+@Beta
+public enum ErrorCode {
+
+    // See https://github.com/realm/realm-sync/blob/master/doc/protocol.md
+
+    // Realm Java errors (0-49)
+    UNKNOWN(-1),                                // Catch-all
+    IO_EXCEPTION(0, Category.RECOVERABLE),      // Some IO error while either contacting the server or reading the response
+    JSON_EXCEPTION(1),                          // JSON input could not be parsed correctly
+
+    // Realm Object Server errors (100 - 199)
+    // Connection level and protocol errors.
+    CONNECTION_CLOSED(100),          // Connection closed (no error)
+    OTHER_ERROR(101),                // Other connection level error
+    UNKNOWN_MESSAGE(102),            // Unknown type of input message
+    BAD_SYNTAX(103),                 // Bad syntax in input message head
+    LIMITS_EXCEEDED(104),            // Limits exceeded in input message
+    WRONG_PROTOCOL_VERSION(105),     // Wrong protocol version (CLIENT)
+    BAD_SESSION_IDENT(106),          // Bad session identifier in input message
+    REUSE_OF_SESSION_IDENT(107),     // Overlapping reuse of session identifier (BIND)
+    BOUND_IN_OTHER_SESSION(108),     // Client file bound in other session (IDENT)
+    BAD_MESSAGE_ORDER(109),          // Bad input message order
+
+    // Session level errors (200 - 299)
+    SESSION_CLOSED(200, Category.RECOVERABLE),      // Session closed (no error)
+    OTHER_SESSION_ERROR(201, Category.RECOVERABLE), // Other session level error
+    TOKEN_EXPIRED(202, Category.RECOVERABLE),       // Access token expired
+
+    // Session fatal: Auth wrong. Cannot be fixed without a new User/SyncConfiguration.
+    BAD_AUTHENTICATION(203),                        // Bad user authentication (BIND, REFRESH)
+    ILLEGAL_REALM_PATH(204),                        // Illegal Realm path (BIND)
+    NO_SUCH_PATH(205),                              // No such Realm (BIND)
+    PERMISSION_DENIED(206),                         // Permission denied (BIND, REFRESH)
+
+    // Fatal: Wrong server/client versions. Trying to sync incompatible files or the file was corrupted.
+    BAD_SERVER_FILE_IDENT(207),                     // Bad server file identifier (IDENT)
+    BAD_CLIENT_FILE_IDENT(208),                     // Bad client file identifier (IDENT)
+    BAD_SERVER_VERSION(209),                        // Bad server version (IDENT, UPLOAD)
+    BAD_CLIENT_VERSION(210),                        // Bad client version (IDENT, UPLOAD)
+    DIVERGING_HISTORIES(211),                       // Diverging histories (IDENT)
+    BAD_CHANGESET(212),                             // Bad changeset (UPLOAD)
+
+    // 300 - 599 Reserved for Standard HTTP error codes
+
+    // Realm Authentication Server response errors (600 - 699)
+    INVALID_PARAMETERS(601),
+    MISSING_PARAMETERS(602),
+    INVALID_CREDENTIALS(611),
+    UNKNOWN_ACCOUNT(612),
+    EXISTING_ACCOUNT(613),
+    ACCESS_DENIED(614),
+    EXPIRED_REFRESH_TOKEN(615);
+
+    private final int code;
+    private final Category category;
+
+    ErrorCode(int errorCode) {
+        this(errorCode, Category.FATAL);
+    }
+
+    ErrorCode(int errorCode, Category category) {
+        this.code = errorCode;
+        this.category = category;
+    }
+
+    @Override
+    public String toString() {
+        return super.toString() + "(" + code + ")";
+    }
+
+    /**
+     * Returns the numerical value for this error code.
+     *
+     * @return the error code as an unique {@code int} value.
+     */
+    public int intValue() {
+        return code;
+    }
+
+    /**
+     * Returns the getCategory of the error.
+     * <p>
+     * Errors come in 2 categories: FATAL, RECOVERABLE
+     * <p>
+     * FATAL: The session cannot be recovered and needs to be re-created. A likely cause is that the User does not
+     * have access to this Realm. Check that the {@link SyncConfiguration} is correct. Any fatal error will cause
+     * the session to be become {@link SessionState#STOPPED}.
+     * <p>
+     * RECOVERABLE: Temporary error. The session becomes {@link SessionState#UNBOUND}, but will automatically try to
+     * recover as soon as possible.
+     * <p>
+     *
+     * @return the severity of the error.
+     */
+    public Category getCategory() {
+        return category;
+    }
+
+    public static ErrorCode fromInt(int errorCode) {
+        ErrorCode[] errorCodes = values();
+        for (int i = 0; i < errorCodes.length; i++) {
+            ErrorCode error = errorCodes[i];
+            if (error.intValue() == errorCode) {
+                return error;
+            }
+        }
+        throw new IllegalArgumentException("Unknown error code: " + errorCode);
+    }
+
+public enum Category {
+        FATAL,          // Abort session as soon as possible
+        RECOVERABLE    // Still possible to recover the session by either rebinding or providing the required information.
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java b/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
new file mode 100644
index 0000000000..38b0c0c1cb
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.content.pm.PackageInfo;
+
+import io.realm.android.SharedPrefsUserStore;
+import io.realm.annotations.Beta;
+import io.realm.internal.Keep;
+
+/**
+ * @Beta
+ * Internal initializer class for the Object Server.
+ * Use to keep the `SyncManager` free from Android dependencies
+ */
+@SuppressWarnings("unused")
+@Keep
+@Beta
+class ObjectServer {
+
+    public static void init(Context context) {
+        // Setup AppID
+        String appId = "unknown";
+        try {
+            PackageInfo pi = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
+            appId = pi.packageName;
+        } catch (Exception ignore) {
+        }
+
+        // Configure default UserStore
+        UserStore userStore = new SharedPrefsUserStore(context);
+
+        SyncManager.init(appId, userStore);
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ObjectServerError.java b/realm/realm-library/src/objectServer/java/io/realm/ObjectServerError.java
new file mode 100644
index 0000000000..56109037f8
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/ObjectServerError.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.annotations.Beta;
+import io.realm.internal.Util;
+
+/**
+ * @Beta
+ * This class is a wrapper for all errors happening when communicating with the Realm Object Server.
+ * This include both exceptions and protocol errors.
+ *
+ * Only {@link #getErrorCode()} is guaranteed to contain a value. If the error was caused by an underlying exception
+ * {@link #getErrorMessage()} is {@code null} and {@link #getException()} is set, while if the error was a protocol error
+ * {@link #getErrorMessage()} is set and {@link #getException()} is null.
+ *
+ * @see ErrorCode for a list of possible errors.
+ */
+@Beta
+public class ObjectServerError extends RuntimeException {
+
+    private final ErrorCode error;
+    private final String errorMessage;
+    private final Throwable exception;
+
+    /**
+     * Create an error caused by an error in the protocol when communicating with the Object Server.
+     *
+     * @param errorCode error code for this type of error.
+     * @param errorMessage detailed error message.
+     */
+    public ObjectServerError(ErrorCode errorCode, String errorMessage) {
+        this(errorCode, errorMessage, (Throwable) null);
+    }
+
+    /**
+     * Create an error caused by an an exception when communicating with the Object Server.
+     *
+     * @param errorCode error code for this type of error.
+     * @param exception underlying exception causing this error.
+     */
+    public ObjectServerError(ErrorCode errorCode, Throwable exception) {
+        this(errorCode, null, exception);
+    }
+
+    /**
+     * Generic error happening that could happen anywhere.
+     *
+     * @param errorCode error code for this type of error.
+     * @param errorMessage detailed error message.
+     * @param exception underlying exception if the error was caused by this.
+     */
+    public ObjectServerError(ErrorCode errorCode, String errorMessage, Throwable exception) {
+        this.error = errorCode;
+        this.errorMessage = errorMessage;
+        this.exception = exception;
+    }
+
+    /**
+     * Errors happening while trying to authenticate a user.
+     *
+     * @param errorCode error code for this type of error.
+     * @param title Title for this type of error.
+     * @param hint a hint for resolving the error.
+     */
+    public ObjectServerError(ErrorCode errorCode, String title, String hint) {
+        this(errorCode, (hint != null) ? title + " : " + hint : title, (Throwable) null);
+    }
+
+    /**
+     * Returns the error code uniquely identifying this type of error.
+     *
+     * @return the error code identifying the type of error.
+     * @see ErrorCode
+     */
+    public ErrorCode getErrorCode() {
+        return error;
+    }
+
+    /**
+     * Returns a more detailed error message about the cause of this error.
+     *
+     * @return a detailed error message or {@code null} if one was not available.
+     */
+    public String getErrorMessage() {
+        return errorMessage;
+    }
+
+    /**
+     * Returns the underlying exception causing this error, if any.
+     *
+     * @return the underlying exception causing this error, or {@code null} if not caused by an exception.
+     */
+    public Throwable getException() {
+        return exception;
+    }
+
+    /**
+     * Returns the {@link ErrorCode.Category} category for this error.
+     * Errors that are {@link ErrorCode.Category#RECOVERABLE} mean that it is still possible for a
+     * given {@link SyncSession} to resume synchronization. {@link ErrorCode.Category#FATAL} errors
+     * means that session has stopped and cannot be recovered.
+     *
+     * @return the error category.
+     */
+    public ErrorCode.Category getCategory() {
+        return error.getCategory();
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder(getErrorCode().toString());
+        if (errorMessage != null) {
+            sb.append('\n');
+            sb.append(errorMessage);
+        }
+        if (exception != null) {
+            sb.append('\n');
+            sb.append(Util.getStackTrace(exception));
+        }
+        return sb.toString();
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SessionState.java b/realm/realm-library/src/objectServer/java/io/realm/SessionState.java
new file mode 100644
index 0000000000..9ede02c3fc
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/SessionState.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.annotations.Beta;
+
+/**
+ * @Beta
+ * Enum describing the various states the Session Finite-State-Machine can be in.
+ */
+@Beta
+public enum SessionState {
+    INITIAL,          // Initial starting state
+    UNBOUND,          // Start done, Realm is unbound.
+    BINDING,          // bind() has been called. Can take a while.
+    AUTHENTICATING,   // Trying to authenticate credentials. Can take a while.
+    BOUND,            // Local realm was successfully bound to the remote Realm. Changes are being synchronized.
+    STOPPED           // Terminal state. Session can no longer be used.
+}
+
+
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
new file mode 100644
index 0000000000..d268398d76
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -0,0 +1,647 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+
+import java.io.File;
+import java.io.UnsupportedEncodingException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import io.realm.annotations.Beta;
+import io.realm.annotations.RealmModule;
+import io.realm.exceptions.RealmException;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.SharedRealm;
+import io.realm.internal.syncpolicy.AutomaticSyncPolicy;
+import io.realm.internal.syncpolicy.SyncPolicy;
+import io.realm.rx.RealmObservableFactory;
+import io.realm.rx.RxObservableFactory;
+
+/**
+ * @Beta
+ * An {@link SyncConfiguration} is used to setup a Realm that can be synchronized between devices using the Realm
+ * Object Server.
+ * <p>
+ * A valid {@link SyncUser} is required to create a {@link SyncConfiguration}. See {@link SyncCredentials} and
+ * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)} for more information on
+ * how to get a user object.
+ * <p>
+ * A minimal {@link SyncConfiguration} can be found below.
+ * <pre>
+ * {@code
+ * SyncConfiguration config = new SyncConfiguration.Builder(context)
+ *   .serverUrl("realm://objectserver.realm.io/~/default")
+ *   .user(myUser)
+ *   .build();
+ * }
+ * </pre>
+ *
+ * Synchronized Realms only support additive migrations which can be detected and performed automatically, so
+ * the following builder options are not accessible compared to a normal Realm:
+ *
+ * <ul>
+ *     <li>{@code deleteRealmIfMigrationNeeded()}</li>
+ *     <li>{@code schemaVersion(long version)}</li>
+ *     <li>{@code migration(Migration)}</li>
+ * </ul>
+ *
+ * Synchronized Realms are created by using {@link Realm#getInstance(RealmConfiguration)} and
+ * {@link Realm#getDefaultInstance()} like ordinary unsynchronized Realms.
+ */
+@Beta
+public final class SyncConfiguration extends RealmConfiguration {
+
+    public static final int PORT_REALM = 80;
+    public static final int PORT_REALMS = 443;
+
+    // The FAT file system has limitations of length. Also, not all characters are permitted.
+    // https://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx
+    public static final int MAX_FULL_PATH_LENGTH = 256;
+    public static final int MAX_FILE_NAME_LENGTH = 255;
+    private static final char[] INVALID_CHARS = {'<', '>', ':', '"', '/', '\\', '|', '?', '*'};
+
+    private final URI serverUrl;
+    private final SyncUser user;
+    private final SyncPolicy syncPolicy;
+    private final SyncSession.ErrorHandler errorHandler;
+    private final boolean deleteRealmOnLogout;
+
+    private SyncConfiguration(File directory,
+                                String filename,
+                                String canonicalPath,
+                                String assetFilePath,
+                                byte[] key,
+                                long schemaVersion,
+                                RealmMigration migration,
+                                boolean deleteRealmIfMigrationNeeded,
+                                SharedRealm.Durability durability,
+                                RealmProxyMediator schemaMediator,
+                                RxObservableFactory rxFactory,
+                                Realm.Transaction initialDataTransaction,
+                                SyncUser user,
+                                URI serverUrl,
+                                SyncPolicy syncPolicy,
+                                SyncSession.ErrorHandler errorHandler,
+                                boolean deleteRealmOnLogout
+    ) {
+        super(directory,
+                filename,
+                canonicalPath,
+                assetFilePath,
+                key,
+                schemaVersion,
+                migration,
+                deleteRealmIfMigrationNeeded,
+                durability,
+                schemaMediator,
+                rxFactory,
+                initialDataTransaction
+        );
+
+        this.user = user;
+        this.serverUrl = serverUrl;
+        this.syncPolicy = syncPolicy;
+        this.errorHandler = errorHandler;
+        this.deleteRealmOnLogout = deleteRealmOnLogout;
+    }
+
+    static URI resolveServerUrl(URI serverUrl, String userIdentifier) {
+        try {
+            return new URI(serverUrl.toString().replace("/~/", "/" + userIdentifier + "/"));
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException("Could not replace '/~/' with a valid user ID.", e);
+        }
+    }
+
+    // Extract the full server path, minus the file name
+    private static String getServerPath(URI serverUrl) {
+        String path = serverUrl.getPath();
+        int endIndex = path.lastIndexOf("/");
+        if (endIndex == -1 ) {
+            return path;
+        } else if (endIndex == 0) {
+            return path.substring(1);
+        } else {
+            return path.substring(1, endIndex); // Also strip leading /
+        }
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+
+        SyncConfiguration that = (SyncConfiguration) o;
+
+        if (deleteRealmOnLogout != that.deleteRealmOnLogout) return false;
+        if (!serverUrl.equals(that.serverUrl)) return false;
+        if (!user.equals(that.user)) return false;
+        if (!syncPolicy.equals(that.syncPolicy)) return false;
+        if (!errorHandler.equals(that.errorHandler)) return false;
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode();
+        result = 31 * result + serverUrl.hashCode();
+        result = 31 * result + user.hashCode();
+        result = 31 * result + (deleteRealmOnLogout ? 1 : 0);
+        result = 31 * result + syncPolicy.hashCode();
+        result = 31 * result + errorHandler.hashCode();
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder stringBuilder = new StringBuilder();
+        // TODO
+        return stringBuilder.toString();
+    }
+
+    // Keeping this package protected for now. The API might still be subject to change.
+    SyncPolicy getSyncPolicy() {
+        return syncPolicy;
+    }
+
+    /**
+     * Returns the user.
+     *
+     * @return the user.
+     */
+    public SyncUser getUser() {
+        return user;
+    }
+
+    /**
+     * Returns the fully disambiguated URI for the remote Realm i.e., the {@code /~/} placeholder has been replaced
+     * by the proper user ID.
+     *
+     * @return {@link URI} identifying the remote Realm this local Realm is synchronized with.
+     */
+    public URI getServerUrl() {
+        return serverUrl;
+    }
+
+    public SyncSession.ErrorHandler getErrorHandler() {
+        return errorHandler;
+    }
+
+    /**
+     * Returns {@code true} if the Realm file must be deleted once the {@link SyncUser} owning it logs out.
+     *
+     * @return {@code true} if the Realm file must be deleted if the {@link SyncUser} logs out. {@code false} if the file
+     *         is allowed to remain behind.
+     */
+    public boolean shouldDeleteRealmOnLogout() {
+        return deleteRealmOnLogout;
+    }
+
+    @Override
+    boolean isSyncConfiguration() {
+        return true;
+    }
+
+    /**
+     * Builder used to construct instances of a SyncConfiguration in a fluent manner.
+     */
+    public static final class Builder  {
+
+        private File directory;
+        private boolean overrideDefaultFolder = false;
+        private String fileName;
+        private boolean overrideDefaultLocalFileName = false;
+        private byte[] key;
+        private HashSet<Object> modules = new HashSet<Object>();
+        private HashSet<Class<? extends RealmModel>> debugSchema = new HashSet<Class<? extends RealmModel>>();
+        private RxObservableFactory rxFactory;
+        private Realm.Transaction initialDataTransaction;
+        private URI serverUrl;
+        private SyncUser user = null;
+        private SyncPolicy syncPolicy = new AutomaticSyncPolicy();
+        private SyncSession.ErrorHandler errorHandler = SyncManager.defaultSessionErrorHandler;
+        private File defaultFolder;
+        private String defaultLocalFileName;
+        private SharedRealm.Durability durability = SharedRealm.Durability.FULL;
+        private boolean deleteRealmOnLogout = false;
+        private final Pattern pattern = Pattern.compile("^[A-Za-z0-9_\\-\\.]+$"); // for checking serverUrl
+
+
+        /**
+         * Creates an instance of the Builder for the SyncConfiguration.
+         * <p>
+         * Opening a synchronized Realm requires a valid user and an unique URI that identifies that Realm. In URIs,
+         * {@code /~/} can be used as a placeholder for a user ID in case the Realm should only be available to one
+         * user e.g., {@code "realm://objectserver.realm.io/~/default"}.
+         * <p>
+         * The URL cannot end with {@code .realm}, {@code .realm.lock} or {@code .realm.management}.
+         * <p>
+         * The {@code /~/} will automatically be replaced with the user ID when creating the {@link SyncConfiguration}.
+         * <p>
+         * Moreover, the URI defines the local location on disk. The default location of a synchronized Realm file is
+         * {@code /data/data/<packageName>/files/realm-object-server/<user-id>/<last-path-segment>}, but this behavior
+         * can be overwritten using {@link #name(String)} and {@link #directory(File)}.
+         * <p>
+         * Many Android devices are using FAT32 file systems. FAT32 file systems have a limitation that
+         * file names cannot be longer than 255 characters. Moreover, the entire URI should not exceed 256 characters.
+         * If file name and underlying path are too long to handle for FAT32, a shorter unique name will be generated.
+         * See also @{link https://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx}.
+         *
+         * @param user the user for this Realm. An authenticated {@link SyncUser} is required to open any Realm managed
+         *             by a Realm Object Server.
+         * @param uri URI identifying the Realm.
+         *
+         * @see SyncUser#isValid()
+         */
+        public Builder(SyncUser user, String uri) {
+            this(BaseRealm.applicationContext, user, uri);
+        }
+
+        Builder(Context context, SyncUser user, String url) {
+            if (context == null) {
+                throw new IllegalStateException("Call `Realm.init(Context)` before creating a SyncConfiguration");
+            }
+            this.defaultFolder = new File(context.getFilesDir(), "realm-object-server");
+            if (Realm.getDefaultModule() != null) {
+                this.modules.add(Realm.getDefaultModule());
+            }
+
+            validateAndSet(user);
+            validateAndSet(url);
+        }
+
+        private void validateAndSet(SyncUser user) {
+            if (user == null) {
+                throw new IllegalArgumentException("Non-null `user` required.");
+            }
+            if (!user.isValid()) {
+                throw new IllegalArgumentException("User not authenticated or authentication expired.");
+            }
+            this.user = user;
+        }
+
+        private void validateAndSet(String uri) {
+            if (uri == null) {
+                throw new IllegalArgumentException("Non-null 'uri' required.");
+            }
+
+            try {
+                serverUrl = new URI(uri);
+            } catch (URISyntaxException e) {
+                throw new IllegalArgumentException("Invalid URI: " + uri, e);
+            }
+
+            // scheme must be realm or realms
+            String scheme = serverUrl.getScheme();
+            if (!scheme.equals("realm") && !scheme.equals("realms")) {
+                throw new IllegalArgumentException("Invalid scheme: " + scheme);
+            }
+
+            // Detect last path segment as it is the default file name
+            String path = serverUrl.getPath();
+            if (path == null) {
+                throw new IllegalArgumentException("Invalid URI: " + uri);
+            }
+
+            String[] pathSegments = path.split("/");
+            for (int i = 1; i < pathSegments.length; i++) {
+                String segment = pathSegments[i];
+                if (segment.equals("~")) {
+                    continue;
+                }
+                if (segment.equals("..") || segment.equals(".")) {
+                    throw new IllegalArgumentException("The URI has an invalid segment: " + segment);
+                }
+                Matcher m = pattern.matcher(segment);
+                if (!m.matches()) {
+                    throw new IllegalArgumentException("The URI must only contain characters 0-9, a-z, A-Z, ., _, and -: " + segment);
+                }
+            }
+
+            this.defaultLocalFileName = pathSegments[pathSegments.length - 1];
+
+            // Validate filename
+            // TODO Lift this restriction on the Object Server
+            if (defaultLocalFileName.endsWith(".realm")
+                    || defaultLocalFileName.endsWith(".realm.lock")
+                    || defaultLocalFileName.endsWith(".realm.management")) {
+                throw new IllegalArgumentException("The URI must not end with '.realm', '.realm.lock' or '.realm.management: " + uri);
+            }
+        }
+
+        /**
+         * Sets the local file name for the Realm.
+         * This will override the default name defined by the Realm URL.
+         *
+         * @param filename name of the local file on disk.
+         * @throws IllegalArgumentException if file name is {@code null} or empty.
+         */
+        public Builder name(String filename) {
+            if (filename == null || filename.isEmpty()) {
+                throw new IllegalArgumentException("A non-empty filename must be provided");
+            }
+            this.fileName = filename;
+            this.overrideDefaultLocalFileName = true;
+            return this;
+        }
+
+        /**
+         * Sets the local root directory where synchronized Realm files can be saved.
+         * <p>
+         * Synchronized Realms will not be saved directly in the provided directory, but instead in a
+         * subfolder that matches the path defined by Realm URI. As Realm server URIs are unique
+         * this means that multiple users can save their Realms on disk without the risk of them overwriting
+         * each other files.
+         * <p>
+         * The default location is {@code context.getFilesDir()}.
+         *
+         * @param directory directory on disk where the Realm file can be saved.
+         * @throws IllegalArgumentException if the directory is not valid.
+         */
+        public Builder directory(File directory) {
+            if (directory == null) {
+                throw new IllegalArgumentException("Non-null 'directory' required.");
+            }
+            if (directory.isFile()) {
+                throw new IllegalArgumentException("'directory' is a file, not a directory: " +
+                        directory.getAbsolutePath() + ".");
+            }
+            if (!directory.exists() && !directory.mkdirs()) {
+                throw new IllegalArgumentException("Could not create the specified directory: " +
+                        directory.getAbsolutePath() + ".");
+            }
+            if (!directory.canWrite()) {
+                throw new IllegalArgumentException("Realm directory is not writable: " +
+                        directory.getAbsolutePath() + ".");
+            }
+            this.directory = directory;
+            overrideDefaultFolder = true;
+            return this;
+        }
+
+        /**
+         * Sets the {@value io.realm.RealmConfiguration#KEY_LENGTH} bytes key used to encrypt and decrypt the Realm file.
+         *
+         * @param key the encryption key.
+         * @throws IllegalArgumentException if key is invalid.
+         */
+        public Builder encryptionKey(byte[] key) {
+            if (key == null) {
+                throw new IllegalArgumentException("A non-null key must be provided");
+            }
+            if (key.length != KEY_LENGTH) {
+                throw new IllegalArgumentException(String.format("The provided key must be %s bytes. Yours was: %s",
+                        KEY_LENGTH, key.length));
+            }
+            this.key = Arrays.copyOf(key, key.length);
+            return this;
+        }
+
+        /**
+         * Replaces the existing module(s) with one or more {@link RealmModule}s. Using this method will replace the
+         * current schema for this Realm with the schema defined by the provided modules.
+         * <p>
+         * A reference to the default Realm module containing all Realm classes in the project (but not dependencies),
+         * can be found using {@link Realm#getDefaultModule()}. Combining the schema from the app project and a library
+         * dependency is thus done using the following code:
+         * <p>
+         * {@code builder.modules(Realm.getDefaultMode(), new MyLibraryModule()); }
+         * <p>
+         * @param baseModule the first Realm module (required).
+         * @param additionalModules the additional Realm modules
+         * @throws IllegalArgumentException if any of the modules don't have the {@link RealmModule} annotation.
+         * @see Realm#getDefaultModule()
+         */
+        public Builder modules(Object baseModule, Object... additionalModules) {
+            modules.clear();
+            addModule(baseModule);
+            if (additionalModules != null) {
+                for (Object module : additionalModules) {
+                    addModule(module);
+                }
+            }
+            return this;
+        }
+
+        /**
+         * Sets the {@link RxObservableFactory} used to create Rx Observables from Realm objects.
+         * The default factory is {@link RealmObservableFactory}.
+         *
+         * @param factory factory to use.
+         */
+        public Builder rxFactory(RxObservableFactory factory) {
+            rxFactory = factory;
+            return this;
+        }
+
+        /**
+         * Sets the initial data in {@link io.realm.Realm}. This transaction will be executed only the first time
+         * the Realm file is opened (created) or while migrating the data if
+         * {@link RealmConfiguration.Builder#deleteRealmIfMigrationNeeded()} is set.
+         *
+         * @param transaction transaction to execute.
+         */
+        public Builder initialData(Realm.Transaction transaction) {
+            initialDataTransaction = transaction;
+            return this;
+        }
+
+        /**
+         * Setting this will create an in-memory Realm instead of saving it to disk. In-memory Realms might still use
+         * disk space if memory is running low, but all files created by an in-memory Realm will be deleted when the
+         * Realm is closed.
+         * <p>
+         * Note that because in-memory Realms are not persisted, you must be sure to hold on to at least one non-closed
+         * reference to the in-memory Realm object with the specific name as long as you want the data to last.
+         */
+        public Builder inMemory() {
+            this.durability = SharedRealm.Durability.MEM_ONLY;
+            return this;
+        }
+
+        /**
+         * Sets the {@link SyncPolicy} used to control when changes should be synchronized with the remote Realm.
+         * The default policy is {@link AutomaticSyncPolicy}.
+         *
+         * @param syncPolicy policy to use.
+         *
+         * @see SyncSession
+         */
+        Builder syncPolicy(SyncPolicy syncPolicy) {
+            // Package protected until SyncPolicy API is more stable.
+            this.syncPolicy = syncPolicy;
+            return this;
+        }
+
+        /**
+         * Sets the error handler used by this configuration. This will override any handler set by calling
+         * {@link SyncManager#setDefaultSessionErrorHandler(SyncSession.ErrorHandler)}.
+         * <p>
+         * Only errors not handled by the defined {@code SyncPolicy} will be reported to this error handler.
+         *
+         * @param errorHandler error handler used to report back errors when communicating with the Realm Object Server.
+         * @throws IllegalArgumentException if {@code null} is given as an error handler.
+         */
+        public Builder errorHandler(SyncSession.ErrorHandler errorHandler) {
+            if (errorHandler == null) {
+                throw new IllegalArgumentException("Non-null 'errorHandler' required.");
+            }
+            this.errorHandler = errorHandler;
+            return this;
+        }
+
+        private String MD5(String in) {
+            try {
+                MessageDigest digest = MessageDigest.getInstance("MD5");
+                byte[] buf = digest.digest(in.getBytes("UTF-8"));
+                StringBuilder builder = new StringBuilder();
+                for (byte b : buf) {
+                    builder.append(String.format("%02X", b));
+                }
+                return builder.toString();
+            } catch (NoSuchAlgorithmException e) {
+                throw new RealmException(e.getMessage());
+            } catch (UnsupportedEncodingException e) {
+                throw new RealmException(e.getMessage());
+            }
+        }
+
+        /**
+         * Setting this will cause the local Realm file used to synchronize changes to be deleted if the {@link SyncUser}
+         * owning this Realm logs out from the device using {@link SyncUser#logout()}.
+         * <p>
+         * The default behavior is that the Realm file is allowed to stay behind, making it possible for users to log
+         * in again and have access to their data faster.
+         */
+        /* FIXME: Disable this API since we cannot support it without https://github.com/realm/realm-core/issues/2165
+        public Builder deleteRealmOnLogout() {
+            this.deleteRealmOnLogout = true;
+            return this;
+        }
+        */
+
+        /**
+         * Creates the RealmConfiguration based on the builder parameters.
+         *
+         * @return the created {@link SyncConfiguration}.
+         * @throws IllegalStateException if the configuration parameters are invalid or inconsistent.
+         */
+        public SyncConfiguration build() {
+            if (serverUrl == null || user == null) {
+                throw new IllegalStateException("serverUrl() and user() are both required.");
+            }
+
+            // Check if the user has an identifier, if not, it cannot use /~/.
+            if (serverUrl.toString().contains("/~/") && user.getIdentity() == null) {
+                throw new IllegalStateException("The serverUrl contains a /~/, but the user does not have an identity." +
+                        " Most likely it hasn't been authenticated yet or has been created directly from an" +
+                        " access token. Use a path without /~/.");
+            }
+
+            if (rxFactory == null && isRxJavaAvailable()) {
+                rxFactory = new RealmObservableFactory();
+            }
+
+            // Determine location on disk
+            // Use the serverUrl + user to create a unique filepath unless it has been explicitly overridden.
+            // <rootDir>/<serverPath>/<serverFileNameOrOverriddenFileName>
+            URI resolvedServerUrl = resolveServerUrl(serverUrl, user.getIdentity());
+            File rootDir = overrideDefaultFolder ? directory : defaultFolder;
+            String realmPathFromRootDir = getServerPath(resolvedServerUrl);
+            File realmFileDirectory = new File(rootDir, realmPathFromRootDir);
+
+            String realmFileName = overrideDefaultLocalFileName ? fileName : defaultLocalFileName;
+            String fullPathName = realmFileDirectory.getAbsolutePath() + File.pathSeparator + realmFileName;
+            // full path must not exceed 256 characters (on FAT)
+            if (fullPathName.length() > MAX_FULL_PATH_LENGTH) {
+                // path is too long, so we make the file name shorter
+                realmFileName = MD5(realmFileName);
+                fullPathName = realmFileDirectory.getAbsolutePath() + File.pathSeparator + realmFileName;
+                if (fullPathName.length() > MAX_FULL_PATH_LENGTH) {
+                    // use rootDir/userIdentify as directory instead as it is shorter
+                    realmFileDirectory = new File(rootDir, user.getIdentity());
+                    fullPathName = realmFileDirectory.getAbsolutePath() + File.pathSeparator + realmFileName;
+                    if (fullPathName.length() > MAX_FULL_PATH_LENGTH) { // we are out of ideas
+                        throw new IllegalStateException(String.format("Full path name must not exceed %d characters: %s",
+                                MAX_FULL_PATH_LENGTH, fullPathName));
+                    }
+                }
+            }
+
+            if (realmFileName.length() > MAX_FILE_NAME_LENGTH) {
+                throw new IllegalStateException(String.format("File name exceed %d characters: %d", MAX_FILE_NAME_LENGTH,
+                        realmFileName.length()));
+            }
+
+            // substitute invalid characters
+            for (char c : INVALID_CHARS) {
+                realmFileName = realmFileName.replace(c, '_');
+            }
+
+            // Create the folder on disk (if needed)
+            if (!realmFileDirectory.exists() && !realmFileDirectory.mkdirs()) {
+                throw new IllegalStateException("Could not create directory for saving the Realm: " + realmFileDirectory);
+            }
+
+            return new SyncConfiguration(
+                    // Realm Configuration options
+                    realmFileDirectory,
+                    realmFileName,
+                    getCanonicalPath(new File(realmFileDirectory, realmFileName)),
+                    null, // assetFile not supported by Sync. See https://github.com/realm/realm-sync/issues/241
+                    key,
+                    0,
+                    null, // Custom migrations not supported
+                    false, // MigrationNeededException is never thrown
+                    durability,
+                    createSchemaMediator(modules, debugSchema),
+                    rxFactory,
+                    initialDataTransaction,
+
+                    // Sync Configuration specific
+                    user,
+                    resolvedServerUrl,
+                    syncPolicy,
+                    errorHandler,
+                    deleteRealmOnLogout
+            );
+        }
+
+        private void addModule(Object module) {
+            if (module != null) {
+                checkModule(module);
+                modules.add(module);
+            }
+        }
+
+        private void checkModule(Object module) {
+            if (!module.getClass().isAnnotationPresent(RealmModule.class)) {
+                throw new IllegalArgumentException(module.getClass().getCanonicalName() + " is not a RealmModule. " +
+                        "Add @RealmModule to the class definition.");
+            }
+        }
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
new file mode 100644
index 0000000000..827f1265cf
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+import io.realm.annotations.Beta;
+
+/**
+ * @Beta
+ * Credentials represent a login with a 3rd party login provider in an OAuth2 login flow, and are used by the Realm
+ * Object Server to verify the user and grant access.
+ * <p>
+ * Logging into the Realm Object Server consists of the following steps:
+ * <ol>
+ * <li>
+ *     Log in to 3rd party provider (Facebook or Google). The result is usually an Authorization Grant that must be
+ *     saved in a {@link SyncCredentials} object of the proper type e.g., {@link SyncCredentials#facebook(String)} for a
+ *     Facebook login.
+ * </li>
+ * <li>
+ *     Authenticate a {@link SyncUser} through the Object Server using these credentials. Once authenticated,
+ *     an Object Server user is returned. Then this user can be attached to a {@link SyncConfiguration}, which
+ *     will make it possible to synchronize data between the local and remote Realm.
+ *     <p>
+ *     It is possible to persist the user object e.g., using the {@link UserStore}. That means, logging
+ *     into an OAuth2 provider is only required the first time the app is used.
+ * </li>
+ * </ol>
+ *
+ * <pre>
+ * {@code
+ * // Example
+ *
+ * Credentials credentials = Credentials.facebook(getFacebookToken());
+ * User.login(credentials, "http://objectserver.realm.io/auth", new User.Callback() {
+ *     \@Override
+ *     public void onSuccess(User user) {
+ *          // User is now authenticated and be be used to open Realms.
+ *     }
+ *
+ *     \@Override
+ *     public void onError(ObjectServerError error) {
+ *
+ *     }
+ * });
+ * }
+ * </pre>
+ */
+@Beta
+public class SyncCredentials {
+
+    private String identityProvider;
+    private String userIdentifier;
+    private Map<String, Object> userInfo;
+
+    // Factory constructors
+
+    /**
+     * Creates credentials based on a login with username and password. These credentials will only be verified
+     * by the Object Server.
+     *
+     * @param username username of the user.
+     * @param password the users password.
+     * @param createUser {@code true} if the user should be created, {@code false} otherwise. It is not possible to
+     *                   create a user twice when logging in, so this flag should only be set to {@code true} the first
+     *                   time a users log in.
+     * @return a set of credentials that can be used to log into the Object Server using
+     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * @throws IllegalArgumentException if user name is either {@code null} or empty.
+     */
+    public static SyncCredentials usernamePassword(String username, String password, boolean createUser) {
+        if (username == null || username.equals("")) {
+            throw new IllegalArgumentException("Non-null 'username' required.");
+        }
+        Map<String, Object> userInfo = new HashMap<String, Object>();
+        userInfo.put("register", createUser);
+        userInfo.put("password", password);
+        return new SyncCredentials(IdentityProvider.USERNAME_PASSWORD, username, userInfo);
+    }
+
+    /**
+     * Creates credentials based on a Facebook login.
+     *
+     * @param facebookToken a facebook userIdentifier acquired by logging into Facebook.
+     * @return a set of credentials that can be used to log into the Object Server using
+     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}
+     * @throws IllegalArgumentException if user name is either {@code null} or empty.
+     */
+    public static SyncCredentials facebook(String facebookToken) {
+        if (facebookToken == null || facebookToken.equals("")) {
+            throw new IllegalArgumentException("Non-null 'facebookToken' required.");
+        }
+        return new SyncCredentials(IdentityProvider.FACEBOOK, facebookToken, null);
+    }
+
+    /**
+     * Creates credentials based on a Google login.
+     *
+     * @param googleToken a google userIdentifier acquired by logging into Google.
+     * @return a set of credentials that can be used to log into the Object Server using
+     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}
+     * @throws IllegalArgumentException if user name is either {@code null} or empty.
+     */
+    public static SyncCredentials google(String googleToken) {
+        if (googleToken == null || googleToken.equals("")) {
+            throw new IllegalArgumentException("Non-null 'googleToken' required.");
+        }
+        return new SyncCredentials(IdentityProvider.GOOGLE, googleToken, null);
+    }
+
+    /**
+     * Creates a custom set of credentials. The behaviour will depend on the type of {@code identityProvider} and
+     * {@code userInfo} used.
+     *
+     * @param identityProvider provider used to verify the credentials.
+     * @param userIdentifier String identifying the user. Usually a username of userIdentifier.
+     * @param userInfo data describing the user further or {@code null} if the user does not have any extra data. The
+     *              data will be serialized to JSON, so all values must be mappable to a valid JSON data type. Custom
+     *              classes will be converted using {@code toString()}.
+     * @return a set of credentials that can be used to log into the Object Server using
+     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * @throws IllegalArgumentException if any parameter is either {@code null} or empty.
+     */
+    public static SyncCredentials custom(String identityProvider, String userIdentifier, Map<String, Object> userInfo) {
+        if (identityProvider == null || identityProvider.equals("")) {
+            throw new IllegalArgumentException("Non-null 'identityProvider' required.");
+        }
+        if (userIdentifier == null || userIdentifier.equals("")) {
+            throw new IllegalArgumentException("Non-null 'userIdentifier' required.");
+        }
+        if (userInfo == null) {
+            userInfo = new HashMap<String, Object>();
+        }
+        return new SyncCredentials(identityProvider, userIdentifier, userInfo);
+    }
+
+    private SyncCredentials(String identityProvider, String token, Map<String, Object> userInfo) {
+        this.identityProvider = identityProvider;
+        this.userIdentifier = token;
+        this.userInfo = (userInfo == null) ? new HashMap<String, Object>() : userInfo;
+    }
+
+    /**
+     * Returns the provider used by the Object Server to validate these credentials.
+     *
+     * @return the login type.
+     */
+    public String getIdentityProvider() {
+        return identityProvider;
+    }
+
+    /**
+     * Returns a String that identifies the user. The value will depend on the type of {@link IdentityProvider} used.
+     *
+     * @return a String identifying the user.
+     */
+    public String getUserIdentifier() {
+        return userIdentifier;
+    }
+
+    /**
+     * Returns any custom user information associated with this credential.
+     * The type of information will depend on the type of {@link SyncCredentials.IdentityProvider}
+     * used.
+     *
+     * @return a map of additional information about the user.
+     */
+    public Map<String, Object> getUserInfo() {
+        return Collections.unmodifiableMap(userInfo);
+    }
+
+    /**
+     * Enumeration of the different types of identity providers. An identity provider is the entity responsible for
+     * verifying that a given credential is valid.
+     */
+    public static final class IdentityProvider {
+        /**
+         * Any credentials verified by the debug identity provider will always be considered valid.
+         * It is only available if configured on the Object Server, and it is disabled by default.
+         */
+        public static final String DEBUG = "debug";
+
+        /**
+         * Credentials will be verified by Facebook.
+         */
+        public static final String FACEBOOK = "facebook";
+
+        /**
+         * Credentials will be verified by Google.
+         */
+        public static final String GOOGLE = "google";
+
+        /**
+         * Credentials will be verified by the Object Server.
+         *
+         * @see #usernamePassword(String, String, boolean)
+         */
+        public static final String USERNAME_PASSWORD = "password";
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
new file mode 100644
index 0000000000..59341b4fb7
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -0,0 +1,236 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.annotations.Beta;
+import io.realm.internal.Keep;
+import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.OkHttpAuthenticationServer;
+import io.realm.internal.objectserver.SessionStore;
+import io.realm.internal.objectserver.ObjectServerSession;
+import io.realm.log.RealmLog;
+
+/**
+ * @Beta
+ * The SyncManager is the central controller for interacting with the Realm Object Server.
+ * It handles the creation of {@link SyncSession}s and it is possible to configure session defaults and the underlying
+ * network client using this class.
+ * <p>
+ * Through the SyncManager, it is possible to add authentication listeners. An authentication listener will
+ * response to events like user logging in or out.
+ * <p>
+ * Default error handling for any {@link SyncConfiguration} can be added using the SyncManager.
+ *
+ */
+@Keep
+@Beta
+public final class SyncManager {
+
+    /**
+     * APP ID sent to the Realm Object Server. Is automatically initialized to the package name for the app.
+     */
+    public static String APP_ID = null;
+
+    // Thread pool used when doing network requests against the Realm Authentication Server.
+    // FIXME Set proper parameters
+    public static final ThreadPoolExecutor NETWORK_POOL_EXECUTOR = new ThreadPoolExecutor(
+            10, 10, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(100));
+
+    private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {
+        @Override
+        public void onError(SyncSession session, ObjectServerError error) {
+            String errorMsg = String.format("Session Error[%s]: %s",
+                    session.getConfiguration().getServerUrl(),
+                    error.toString());
+            switch (error.getErrorCode().getCategory()) {
+                case FATAL:
+                    RealmLog.error(errorMsg);
+                    break;
+                case RECOVERABLE:
+                    RealmLog.info(errorMsg);
+                    break;
+                default:
+                    throw new IllegalArgumentException("Unsupported error category: " + error.getErrorCode().getCategory());
+            }
+        }
+    };
+
+    private static CopyOnWriteArrayList<AuthenticationListener> authListeners = new CopyOnWriteArrayList<AuthenticationListener>();
+
+    // The Sync Client is lightweight, but consider creating/removing it when there is no sessions.
+    // Right now it just lives and dies together with the process.
+    private static volatile AuthenticationServer authServer = new OkHttpAuthenticationServer();
+    private static volatile UserStore userStore;
+
+    static volatile SyncSession.ErrorHandler defaultSessionErrorHandler = SESSION_NO_OP_ERROR_HANDLER;
+    @SuppressWarnings("FieldCanBeLocal")
+    private static Thread clientThread;
+
+    // Initialize the SyncManager
+    static void init(String appId, UserStore userStore) {
+
+        SyncManager.APP_ID = appId;
+        SyncManager.userStore = userStore;
+
+        // Initialize underlying Sync Network Client
+        nativeInitializeSyncClient();
+
+        // Create the client thread in java to avoid problems when exceptions are being thrown. We need to attach
+        // any thread to the JVM anyway in order to send back log events.
+        SyncManager.clientThread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                nativeRunClient();
+            }
+        }, "RealmSyncClient");
+        SyncManager.clientThread.start();
+    }
+
+    /**
+     * Set the {@link UserStore} used by the Realm Object Server to save user information.
+     * If no Userstore is specified {@link SyncUser#currentUser()} will always return {@code null}.
+     *
+     * @param userStore {@link UserStore} to use.
+     * @throws IllegalArgumentException if {@code userStore} is {@code null}.
+     */
+    public static void setUserStore(UserStore userStore) {
+        if (userStore == null) {
+            throw new IllegalArgumentException("Non-null 'userStore' required.");
+        }
+        SyncManager.userStore = userStore;
+    }
+
+    /**
+     * Sets a global authentication listener that will be notified about User events like
+     * login and logout.
+     *
+     * @param listener listener to register.
+     * @throws IllegalArgumentException if {@code listener} is {@code null}.
+     */
+    public static void addAuthenticationListener(AuthenticationListener listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("Non-null 'listener' required.");
+        }
+        authListeners.add(listener);
+    }
+
+    /**
+     * Removes the provided global authentication listener.
+     *
+     * @param listener listener to remove.
+     */
+    public static void removeAuthenticationListener(AuthenticationListener listener) {
+        if (listener == null) {
+            return;
+        }
+        authListeners.remove(listener);
+    }
+
+    /**
+     * Sets the default error handler used by all {@link SyncConfiguration} objects when they are created.
+     *
+     * @param errorHandler the default error handler used when interacting with a Realm managed by a Realm Object Server.
+     */
+    public static void setDefaultSessionErrorHandler(SyncSession.ErrorHandler errorHandler) {
+        if (errorHandler == null) {
+            defaultSessionErrorHandler = SESSION_NO_OP_ERROR_HANDLER;
+        } else {
+            defaultSessionErrorHandler = errorHandler;
+        }
+    }
+
+    /**
+     * Gets any cached {@link SyncSession} for the given {@link SyncConfiguration} or create a new one if
+     * no one exists.
+     *
+     * @param syncConfiguration configuration object for the synchronized Realm.
+     * @return the {@link SyncSession} for the specified Realm.
+     * @throws IllegalArgumentException if syncConfiguration is {@code null}.
+     */
+    public static synchronized SyncSession getSession(SyncConfiguration syncConfiguration) {
+        if (syncConfiguration == null) {
+            throw new IllegalArgumentException("A non-empty 'syncConfiguration' is required.");
+        }
+
+        if (SessionStore.hasSession(syncConfiguration)) {
+            return SessionStore.getPublicSession(syncConfiguration);
+        } else {
+            ObjectServerSession internalSession = new ObjectServerSession(
+                    syncConfiguration,
+                    authServer,
+                    syncConfiguration.getUser().getSyncUser(),
+                    syncConfiguration.getSyncPolicy(),
+                    syncConfiguration.getErrorHandler()
+            );
+            SyncSession publicSession = new SyncSession(internalSession);
+            SessionStore.addSession(publicSession, internalSession);
+            syncConfiguration.getUser().getSyncUser().addSession(publicSession);
+            syncConfiguration.getSyncPolicy().onSessionCreated(internalSession);
+            return publicSession;
+        }
+    }
+
+    public static AuthenticationServer getAuthServer() {
+        return authServer;
+    }
+
+    /**
+     * Sets the auth server implementation used when validating credentials.
+     */
+    static void setAuthServerImpl(AuthenticationServer authServerImpl) {
+        authServer = authServerImpl;
+    }
+
+    // Return the currently configured User store.
+    static UserStore getUserStore() {
+        return userStore;
+    }
+
+    // This is called from SyncManager.cpp from the worker thread the Sync Client is running on
+    // Right now Core doesn't send these errors to the proper session, so instead we need to notify all sessions
+    // from here. This can be removed once better error propagation is implemented in Sync Core.
+    @SuppressWarnings("unused")
+    private static void notifyErrorHandler(int errorCode, String errorMessage) {
+        ObjectServerError error = new ObjectServerError(ErrorCode.fromInt(errorCode), errorMessage);
+        for (ObjectServerSession session : SessionStore.getAllSessions()) {
+            session.onError(error);
+        }
+    }
+
+    // Notify listeners that a user logged in
+    static void notifyUserLoggedIn(SyncUser user) {
+        for (AuthenticationListener authListener : authListeners) {
+            authListener.loggedIn(user);
+        }
+    }
+
+    // Notify listeners that a user logged out successfully
+    static void notifyUserLoggedOut(SyncUser user) {
+        for (AuthenticationListener authListener : authListeners) {
+            authListener.loggedOut(user);
+        }
+    }
+
+    private static native void nativeInitializeSyncClient();
+    private static native void nativeRunClient();
+
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
new file mode 100644
index 0000000000..64db6280f7
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.net.URI;
+
+import io.realm.annotations.Beta;
+import io.realm.internal.Keep;
+import io.realm.log.RealmLog;
+import io.realm.internal.objectserver.ObjectServerSession;
+
+/**
+ * @Beta
+ * This class represents the connection to the Realm Object Server for one {@link SyncConfiguration}.
+ * <p>
+ * A Session is created by either calling {@link SyncManager#getSession(SyncConfiguration)} or by opening
+ * a Realm instance using that configuration. Once a session has been created, it will continue to exist until the app
+ * is closed or the {@link SyncConfiguration} is no longer used.
+ * <p>
+ * A session is fully controlled by Realm, but can provide additional information in case of errors.
+ * It is passed along in all {@link SyncSession.ErrorHandler}s.
+ * <p>
+ * This object is thread safe.
+ *
+ * @see SessionState
+ */
+@Keep
+@Beta
+public final class SyncSession {
+
+    private final ObjectServerSession osSession;
+
+    SyncSession(ObjectServerSession osSession) {
+        this.osSession = osSession;
+        osSession.setUserSession(this);
+    }
+
+    /**
+     * Returns the {@link SyncConfiguration} that is responsible for controlling the session.
+     *
+     * @return SyncConfiguration that defines and controls this session.
+     */
+    public SyncConfiguration getConfiguration() {
+        return osSession.getConfiguration();
+    }
+
+    /**
+     * Returns the {@link SyncUser} defined by the {@link SyncConfiguration} that is used to connect to the
+     * Realm Object Server.
+     *
+     * @return {@link SyncUser} used to authenticate the session on the Realm Object Server.
+     */
+    public SyncUser getUser() {
+        return osSession.getConfiguration().getUser();
+    }
+
+    /**
+     * Returns the {@link URI} describing the remote Realm which this session connects to and synchronizes changes with.
+     *
+     * @return {@link URI} describing the remote Realm.
+     */
+    public URI getServerUrl() {
+        return osSession.getConfiguration().getServerUrl();
+    }
+
+    /**
+     * Returns the state of this session.
+     *
+     * @return the current {@link SessionState} for this session.
+     */
+    public SessionState getState() {
+        return osSession.getState();
+    }
+
+    ObjectServerSession getOsSession() {
+        return osSession;
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        super.finalize();
+        if (osSession.getState() != SessionState.STOPPED) {
+            RealmLog.warn("Session was not closed before being finalized. This is a potential resource leak.");
+            osSession.stop();
+        }
+    }
+
+    /**
+     * Interface used to report any session errors.
+     *
+     * @see SyncManager#setDefaultSessionErrorHandler(ErrorHandler)
+     * @see SyncConfiguration.Builder#errorHandler(ErrorHandler)
+     */
+    public interface ErrorHandler {
+        /**
+         * Callback for errors on a session object.
+         *
+         * @param session {@link SyncSession} this error happened on.
+         * @param error type of error.
+         */
+        void onError(SyncSession session, ObjectServerError error);
+    }
+}
+
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
new file mode 100644
index 0000000000..808ae04c0a
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -0,0 +1,382 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.Handler;
+import android.os.Looper;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.File;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.Future;
+import java.util.concurrent.ThreadPoolExecutor;
+
+import io.realm.annotations.Beta;
+import io.realm.internal.Util;
+import io.realm.internal.async.RealmAsyncTaskImpl;
+import io.realm.internal.network.AuthenticateResponse;
+import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.ExponentialBackoffTask;
+import io.realm.internal.network.LogoutResponse;
+import io.realm.internal.objectserver.ObjectServerUser;
+import io.realm.internal.objectserver.Token;
+import io.realm.log.RealmLog;
+
+/**
+ * @Beta
+ * This class represents a user on the Realm Object Server. The credentials are provided by various 3rd party
+ * providers (Facebook, Google, etc.).
+ * <p>
+ * A user can log in to the Realm Object Server, and if access is granted, it is possible to synchronize the local
+ * and the remote Realm. Moreover, synchronization is halted when the user is logged out.
+ * <p>
+ * It is possible to persist a user. By retrieving a user, there is no need to log in to the 3rd party provider again.
+ * Persisting a user between sessions, the user's credentials are stored locally on the device, and should be treated
+ * as sensitive data.
+ */
+@Beta
+public class SyncUser {
+
+    private final ObjectServerUser syncUser;
+
+    private SyncUser(ObjectServerUser user) {
+        this.syncUser = user;
+    }
+
+    /**
+     * Returns the last user that has logged in and who is still valid.
+     * A user is invalidated when he/she logs out or the user's access token expire.
+     *
+     * @return last {@link SyncUser} that has logged in and who is still valid. {@code null} if no current user or user has
+     *         been invalidated.
+     */
+    public static SyncUser currentUser() {
+        SyncUser user = SyncManager.getUserStore().get(UserStore.CURRENT_USER_KEY);
+        if (user != null && user.isValid()) {
+            return user;
+        }
+        return null;
+    }
+
+    /**
+     * Returns all valid users known by this device.
+     * A user is invalidated when he/she logs out or the user's access token expires.
+     *
+     * @return a list of all known valid users.
+     */
+    public static Collection<SyncUser> all() {
+        UserStore userStore = SyncManager.getUserStore();
+        Collection<SyncUser> storedUsers = userStore.allUsers();
+        List<SyncUser> result = new ArrayList<SyncUser>(storedUsers.size());
+        for (SyncUser user : storedUsers) {
+            if (user.isValid()) {
+                result.add(user);
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Loads a user that has previously been serialized using {@link #toJson()}.
+     *
+     * @param user JSON string representing the user.
+     *
+     * @return the user object.
+     * @throws IllegalArgumentException if the JSON couldn't be converted to a valid {@link SyncUser} object.
+     */
+    public static SyncUser fromJson(String user) {
+        try {
+            JSONObject obj = new JSONObject(user);
+            URL authUrl = new URL(obj.getString("authUrl"));
+            Token userToken = Token.from(obj.getJSONObject("userToken"));
+            ObjectServerUser syncUser = new ObjectServerUser(userToken, authUrl);
+            JSONArray realmTokens = obj.getJSONArray("realms");
+            for (int i = 0; i < realmTokens.length(); i++) {
+                JSONObject token = realmTokens.getJSONObject(i);
+                URI uri = new URI(token.getString("uri"));
+                ObjectServerUser.AccessDescription realmDesc = ObjectServerUser.AccessDescription.fromJson(token.getJSONObject("description"));
+                syncUser.addRealm(uri, realmDesc);
+            }
+            return new SyncUser(syncUser);
+        } catch (JSONException e) {
+            throw new IllegalArgumentException("Could not parse user json: " + user, e);
+        } catch (MalformedURLException e) {
+            throw new IllegalArgumentException("URL in JSON not valid: " + user, e);
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException("URI is not valid: " + user, e);
+        }
+    }
+
+    /**
+     * Logs in the user to the Realm Object Server. This is done synchronously, so calling this method on the Android
+     * UI thread will always crash. A logged in user is required to be able to create a {@link SyncConfiguration}.
+     *
+     * @param credentials credentials to use.
+     * @param authenticationUrl server that can authenticate against.
+     * @throws ObjectServerError if the login failed.
+     * @throws IllegalArgumentException if the URL is malformed.
+     */
+    public static SyncUser login(final SyncCredentials credentials, final String authenticationUrl) throws ObjectServerError {
+        final URL authUrl;
+        try {
+            authUrl = new URL(authenticationUrl);
+        } catch (MalformedURLException e) {
+            throw new IllegalArgumentException("Invalid URL " + authenticationUrl + ".", e);
+        }
+
+        final AuthenticationServer server = SyncManager.getAuthServer();
+        ObjectServerError error;
+        try {
+            AuthenticateResponse result = server.loginUser(credentials, authUrl);
+            if (result.isValid()) {
+                ObjectServerUser syncUser = new ObjectServerUser(result.getRefreshToken(), authUrl);
+                SyncUser user = new SyncUser(syncUser);
+                RealmLog.info("Succeeded authenticating user.\n%s", user);
+                SyncManager.getUserStore().put(UserStore.CURRENT_USER_KEY, user);
+                SyncManager.notifyUserLoggedIn(user);
+                return user;
+            } else {
+                RealmLog.info("Failed authenticating user.\n%s", result.getError());
+                error = result.getError();
+            }
+        } catch (Throwable e) {
+            throw new ObjectServerError(ErrorCode.UNKNOWN, e);
+        }
+        throw error;
+    }
+
+    /**
+     * Logs in the user to the Realm Object Server. A logged in user is required to be able to create a
+     * {@link SyncConfiguration}.
+     *
+     * @param credentials credentials to use.
+     * @param authenticationUrl server that the user is authenticated against.
+     * @param callback callback when login has completed or failed. The callback will always happen on the same thread
+     *                 as this this method is called on.
+     * @throws IllegalArgumentException if not on a Looper thread.
+     */
+    public static RealmAsyncTask loginAsync(final SyncCredentials credentials, final String authenticationUrl, final Callback callback) {
+        if (Looper.myLooper() == null) {
+            throw new IllegalStateException("Asynchronous login is only possible from looper threads.");
+        }
+        final Handler handler = new Handler(Looper.myLooper());
+        ThreadPoolExecutor networkPoolExecutor = SyncManager.NETWORK_POOL_EXECUTOR;
+        Future<?> authenticateRequest = networkPoolExecutor.submit(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    SyncUser user = login(credentials, authenticationUrl);
+                    postSuccess(user);
+                } catch (ObjectServerError e) {
+                    postError(e);
+                }
+            }
+
+            private void postError(final ObjectServerError error) {
+                if (callback != null) {
+                    handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            callback.onError(error);
+                        }
+                    });
+                }
+            }
+
+            private void postSuccess(final SyncUser user) {
+                if (callback != null) {
+                    handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            callback.onSuccess(user);
+                        }
+                    });
+                }
+            }
+        });
+
+        return new RealmAsyncTaskImpl(authenticateRequest, networkPoolExecutor);
+    }
+
+    /**
+     * Logs out the user from the Realm Object Server. Once the Object Server has confirmed the logout any registered
+     * {@link AuthenticationListener} will be notified and user credentials will be deleted from this device.
+     *
+     * @throws IllegalStateException if any Realms owned by this user is still open. They should be closed before
+     *         logging out.
+     */
+    /* FIXME: Add this back to the javadoc when enable SyncConfiguration.Builder#deleteRealmOnLogout()
+     <p>
+     Any Realms owned by the user will be deleted if {@link SyncConfiguration.Builder#deleteRealmOnLogout()} is
+     also set.
+     */
+    public void logout() {
+        // Acquire lock to prevent users creating new instances
+        synchronized (Realm.class) {
+            if (!syncUser.isLoggedIn()) {
+                return; // Already logged out
+            }
+
+            // Ensure that we can log out. If any Realm file is still open we should abort before doing anything
+            // else.
+            Collection<SyncSession> sessions = syncUser.getSessions();
+            for (SyncSession session : sessions) {
+                SyncConfiguration config = session.getConfiguration();
+                if (Realm.getGlobalInstanceCount(config) > 0) {
+                    throw new IllegalStateException("A Realm controlled by this user is still open. Close all Realms " +
+                            "before logging out: " + config.getPath());
+                }
+            }
+
+            // Stop all active sessions immediately. If we waited until after talking to the server
+            // there is a high chance errors would be reported from the Sync Client first which would
+            // be confusing.
+            for (SyncSession session : sessions) {
+                session.getOsSession().stop();
+            }
+
+            // Remove all local tokens, preventing further connections.
+            // FIXME We still need to cache the user token so it can be revoked.
+            syncUser.clearTokens();
+
+            if (SyncUser.this.equals(SyncUser.currentUser())) {
+                SyncManager.getUserStore().remove(UserStore.CURRENT_USER_KEY);
+            }
+
+            // Delete all Realms if needed.
+            for (ObjectServerUser.AccessDescription desc : syncUser.getRealms()) {
+                // FIXME: This will always be false since SyncConfiguration.Builder.deleteRealmOnLogout() is
+                // disabled. Make sure this works for Realm opened in the client thread/other processes.
+                if (desc.deleteOnLogout) {
+                    File realmFile = new File(desc.localPath);
+                    if (realmFile.exists() && !Util.deleteRealm(desc.localPath, realmFile.getParentFile(), realmFile.getName())) {
+                        RealmLog.error("Could not delete Realm when user logged out: " + desc.localPath);
+                    }
+                }
+            }
+
+            // Finally revoke server token. The local user is logged out in any case.
+            final AuthenticationServer server = SyncManager.getAuthServer();
+            ThreadPoolExecutor networkPoolExecutor = SyncManager.NETWORK_POOL_EXECUTOR;
+            networkPoolExecutor.submit(new ExponentialBackoffTask<LogoutResponse>() {
+
+                @Override
+                protected LogoutResponse execute() {
+                    return server.logout(SyncUser.this, syncUser.getAuthenticationUrl());
+                }
+
+                @Override
+                protected void onSuccess(LogoutResponse response) {
+                    SyncManager.notifyUserLoggedOut(SyncUser.this);
+                }
+
+                @Override
+                protected void onError(LogoutResponse response) {
+                    RealmLog.error("Failed to log user out.\n" + response.getError().toString());
+                }
+            });
+        }
+    }
+
+    /**
+     * Returns a JSON token representing this user.
+     * <p>
+     * Possession of this JSON token can potentially grant access to data stored on the Realm Object Server, so it
+     * should be treated as sensitive data.
+     *
+     * @return JSON string representing this user. It can be converted back into a real user object using
+     *         {@link #fromJson(String)}.
+     *
+     * @see #fromJson(String)
+     */
+    public String toJson() {
+        return syncUser.toJson();
+    }
+
+    /**
+     * Returns {@code true} if the user is logged into the Realm Object Server. If this method returns {@code true} it
+     * implies that the user has valid credentials that have not expired.
+     * <p>
+     * The user might still be have been logged out by the Realm Object Server which will not be detected before the
+     * user tries to actively synchronize a Realm. If a logged out user tries to synchronize a Realm, an error will be
+     * reported to the {@link SyncSession.ErrorHandler} defined by
+     * {@link SyncConfiguration.Builder#errorHandler(SyncSession.ErrorHandler)}.
+     *
+     * @return {@code true} if the User is logged into the Realm Object Server, {@code false} otherwise.
+     */
+    public boolean isValid() {
+        Token userToken = getSyncUser().getUserToken();
+        return syncUser.isLoggedIn() && userToken != null && userToken.expiresMs() > System.currentTimeMillis();
+    }
+
+    /**
+     * Returns the identity of this user on the Realm Object Server. The identity is a guaranteed to be unique
+     * among all users on the Realm Object Server.
+     *
+     * @return identity of the user on the Realm Object Server. If the user has logged out or the login has expired
+     *         {@code null} is returned.
+     */
+    public String getIdentity() {
+        return syncUser.getIdentity();
+    }
+
+    /**
+     * Returns this user's access token. This is the users credential for accessing the Realm Object Server and should
+     * be treated as sensitive data.
+     *
+     * @return the user's access token. If this user has logged out or the login has expired {@code null} is returned.
+     */
+    public String getAccessToken() {
+        Token userToken = syncUser.getUserToken();
+        return (userToken != null) ? userToken.value() : null;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        SyncUser user = (SyncUser) o;
+
+        return syncUser.equals(user.syncUser);
+
+    }
+
+    @Override
+    public int hashCode() {
+        return syncUser.hashCode();
+    }
+
+    // Expose internal representation for other package protected classes
+    ObjectServerUser getSyncUser() {
+        return syncUser;
+    }
+
+    public interface Callback {
+        void onSuccess(SyncUser user);
+        void onError(ObjectServerError error);
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/UserStore.java b/realm/realm-library/src/objectServer/java/io/realm/UserStore.java
new file mode 100644
index 0000000000..528cae598b
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/UserStore.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.Collection;
+
+import io.realm.android.SharedPrefsUserStore;
+import io.realm.annotations.Beta;
+
+/**
+ * @Beta
+ * Interface for classes responsible for saving and retrieving Object Server users again.
+ * <p>
+ * Any implementation of a User Store is expected to not perform lengthy blocking operations as it might
+ * be called on the Main Thread. All implementations of this interface should be thread safe.
+ *
+ * @see SyncManager#setUserStore(UserStore)
+ * @see SharedPrefsUserStore
+ */
+@Beta
+public interface UserStore {
+
+    String CURRENT_USER_KEY = "realm$currentUser";
+
+    /**
+     * Saves a {@link SyncUser} object under the given key. If another user already exists, it will be replaced.
+     *
+     * @param key key used to store the User.
+     * @param user {@link SyncUser} object to store.
+     * @return The previous user saved with this key or {@code null} if no user was replaced.
+     *
+     */
+    SyncUser put(String key, SyncUser user);
+
+    /**
+     * Retrieves the {@link SyncUser} with the given key.
+     *
+     * @param key {@link SyncUser} saved under the given key or {@code null} if no user exists for that key.
+     */
+    SyncUser get(String key);
+
+    /**
+     * Removes the user with the given key from the store.
+     *
+     * @param key key for the user to remove.
+     * @return {@link SyncUser} that was removed or {@code null} if no user matched the key.
+     */
+    SyncUser remove(String key);
+
+    /**
+     * Returns a collection of all users saved in the User store.
+     *
+     * @return Collection of all users. If no users exist, an empty collection is returned.
+     */
+    Collection<SyncUser> allUsers();
+
+
+    /**
+     * Removes all saved users.
+     */
+    void clear();
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/android/SharedPrefsUserStore.java b/realm/realm-library/src/objectServer/java/io/realm/android/SharedPrefsUserStore.java
new file mode 100644
index 0000000000..31d4b2b1b5
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/android/SharedPrefsUserStore.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.android;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+
+import io.realm.SyncUser;
+import io.realm.UserStore;
+
+/**
+ * A User Store backed by a SharedPreferences file.
+ */
+public class SharedPrefsUserStore implements UserStore {
+
+    private final SharedPreferences sp;
+    private SyncUser cachedCurrentUser; // Keep a quick reference to the current user
+
+    public SharedPrefsUserStore(Context context) {
+        sp = context.getSharedPreferences("realm_object_server_users", Context.MODE_PRIVATE);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public SyncUser put(String key, SyncUser user) {
+        String previousUser = sp.getString(key, null);
+        SharedPreferences.Editor editor = sp.edit();
+        editor.putString(key, user.toJson());
+        // Optimistically save. If the user isn't saved due to a process crash it isn't dangerous.
+        editor.apply();
+
+        if (UserStore.CURRENT_USER_KEY.equals(key)) {
+            cachedCurrentUser = user;
+        }
+
+        if (previousUser != null) {
+            return SyncUser.fromJson(previousUser);
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public SyncUser get(String key) {
+        if (UserStore.CURRENT_USER_KEY.equals(key) && cachedCurrentUser != null) {
+            return cachedCurrentUser;
+        }
+
+        String userData = sp.getString(key, "");
+        if (userData.equals("")) {
+            return null;
+        }
+
+        SyncUser user = SyncUser.fromJson(userData);
+        if (UserStore.CURRENT_USER_KEY.equals(key)) {
+            cachedCurrentUser = user;
+        }
+        return user;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public SyncUser remove(String key) {
+        String currentUser = sp.getString(key, null);
+        SharedPreferences.Editor editor = sp.edit();
+        editor.putString(key, null);
+        editor.apply();
+
+        if (UserStore.CURRENT_USER_KEY.equals(key) && cachedCurrentUser != null) {
+            cachedCurrentUser = null;
+        }
+
+        if (currentUser != null) {
+            return SyncUser.fromJson(currentUser);
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Collection<SyncUser> allUsers() {
+        Map<String, ?> all = sp.getAll();
+        ArrayList<SyncUser> users = new ArrayList<SyncUser>(all.size());
+        for (Object userJson : all.values()) {
+            users.add(SyncUser.fromJson((String) userJson));
+        }
+        return users;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void clear() {
+        Set<String> all = sp.getAll().keySet();
+        SharedPreferences.Editor editor = sp.edit();
+        for (String key : all) {
+            editor.remove(key);
+        }
+        editor.apply();
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java
new file mode 100644
index 0000000000..cad9ce933a
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java
@@ -0,0 +1,75 @@
+package io.realm.internal.network;
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+
+/**
+ * Base class for all response types from the Realm Authentication Server.
+ */
+public class AuthServerResponse {
+
+    protected ObjectServerError error;
+
+    /**
+     * Checks if this response was valid.
+     *
+     * @return {@code true} if valid, {@code false} otherwise.
+     */
+    public boolean isValid() {
+        return (error == null);
+    }
+
+    /**
+     * If {@link #isValid()} returns {@code false}, this method will return the error causing this.
+     *
+     * @return the error.
+     */
+    public ObjectServerError getError() {
+        return error;
+    }
+
+    protected void setError(ObjectServerError error) {
+        this.error = error;
+    }
+
+
+
+    /**
+     * Parse an HTTP error from a Realm Authentication Server. The server returns errors following
+     * https://tools.ietf.org/html/rfc7807 with an extra "code" field for Realm specific error codes.
+     *
+     * @param response the server response.
+     * @param httpErrorCode the HTTP error code.
+     * @return an server error.
+     */
+    public static ObjectServerError createError(String response, int httpErrorCode) {
+        try {
+            JSONObject obj = new JSONObject(response);
+            String title = obj.optString("title", null);
+            String hint = obj.optString("hint", null);
+            ErrorCode errorCode = ErrorCode.fromInt(obj.optInt("code", -1));
+            return new ObjectServerError(errorCode, title, hint);
+        } catch (JSONException e) {
+            return new ObjectServerError(ErrorCode.JSON_EXCEPTION, "Server failed with " +
+                    httpErrorCode + ", but could not parse error.", e);
+        }
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java
new file mode 100644
index 0000000000..6b27dfc7d7
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.net.URI;
+import java.util.Collections;
+import java.util.Map;
+
+import io.realm.internal.objectserver.Token;
+import io.realm.SyncCredentials;
+import io.realm.SyncManager;
+
+/**
+ * This class encapsulates a request to authenticate a user on the Realm Authentication Server. It is responsible for
+ * constructing the JSON understood by the Realm Authentication Server.
+ */
+public class AuthenticateRequest {
+
+    private final String provider;
+    private final String data;
+    private final String appId;
+    private final Map<String, Object> userInfo;
+    private final String path;
+
+    /**
+     * Generates a proper login request for a new user.
+     */
+    public static AuthenticateRequest userLogin(SyncCredentials credentials) {
+        if (credentials == null) {
+           throw new IllegalArgumentException("Non-null credentials required.");
+        }
+        String provider = credentials.getIdentityProvider();
+        String data = credentials.getUserIdentifier();
+        Map<String, Object> userInfo = credentials.getUserInfo();
+        String appId = SyncManager.APP_ID;
+        return new AuthenticateRequest(provider, data, appId, null, userInfo);
+    }
+
+    /**
+     * Generates a request for refreshing a user token.
+     */
+    public static AuthenticateRequest userRefresh(Token userToken) {
+        return new AuthenticateRequest("realm",
+                userToken.value(),
+                SyncManager.APP_ID,
+                null,
+                Collections.<String, Object>emptyMap()
+        );
+    }
+
+    /**
+     * Generates a request for accessing a Realm
+     */
+    public static AuthenticateRequest realmLogin(Token userToken, URI serverUrl) {
+        // Authenticate a given Realm path using an already logged in user.
+        return new AuthenticateRequest("realm",
+                userToken.value(),
+                SyncManager.APP_ID,
+                serverUrl.getPath(),
+                Collections.<String, Object>emptyMap()
+        );
+    }
+
+    private AuthenticateRequest(String provider, String data, String appId, String path, Map<String, Object> userInfo) {
+        this.provider = provider;
+        this.data = data;
+        this.appId = appId;
+        this.path = path;
+        this.userInfo = userInfo;
+    }
+
+    /**
+     * Converts the request into a JSON payload.
+     */
+    public String toJson() {
+        JSONObject request = new JSONObject();
+        try {
+            request.put("provider", provider);
+            request.put("data", data);
+            request.put("app_id", appId);
+            if (path != null) {
+                request.put("path", path);
+            }
+            request.put("user_info", new JSONObject(userInfo));
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+
+        return request.toString();
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java
new file mode 100644
index 0000000000..75e31a0818
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.internal.objectserver.Token;
+import io.realm.log.RealmLog;
+import okhttp3.Response;
+
+/**
+ * This class represents the response for an authenticate request.
+ */
+public class AuthenticateResponse extends AuthServerResponse {
+
+    private static final String JSON_FIELD_ACCESS_TOKEN = "access_token";
+    private static final String JSON_FIELD_REFRESH_TOKEN = "refresh_token";
+
+    private final Token accessToken;
+    private final Token refreshToken;
+
+    /**
+     * Helper method for creating the proper Authenticate response. This method will set the appropriate error
+     * depending on any HTTP response codes or IO errors.
+     *
+     * @param response the HTTP response.
+     * @return an authenticate response.
+     */
+    public static AuthenticateResponse from(Response response) {
+        String serverResponse;
+        try {
+            serverResponse = response.body().string();
+        } catch (IOException e) {
+            ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
+            return new AuthenticateResponse(error);
+        }
+        if (response.code() != 200) {
+            return new AuthenticateResponse(AuthServerResponse.createError(serverResponse, response.code()));
+        } else {
+            return new AuthenticateResponse(serverResponse);
+        }
+    }
+
+    /**
+     * Helper method for creating the response from a JSON string.
+     */
+    public static AuthenticateResponse from(String json) {
+        return new AuthenticateResponse(json);
+    }
+
+    /**
+     * Helper method for creating a failed response.
+     */
+    public static AuthenticateResponse from(ObjectServerError error) {
+        return new AuthenticateResponse(error);
+    }
+
+    /**
+     * Creates an unsuccessful authentication response. This should only happen in case of network or I/O related
+     * issues.
+     *
+     * @param error the network or I/O error.
+     */
+    private AuthenticateResponse(ObjectServerError error) {
+        RealmLog.debug("AuthenticateResponse. Error " + error.getErrorMessage());
+        setError(error);
+        this.accessToken = null;
+        this.refreshToken = null;
+    }
+
+    /**
+     * Parses a valid (200) server response. It might still result in an unsuccessful authentication attempt, if the
+     * JSON response could not be parsed correctly.
+     *
+     * @param serverResponse the server response.
+     */
+    private AuthenticateResponse(String serverResponse) {
+        ObjectServerError error;
+        Token accessToken;
+        Token refreshToken;
+        String message;
+        try {
+            JSONObject obj = new JSONObject(serverResponse);
+            accessToken = obj.has(JSON_FIELD_ACCESS_TOKEN) ?
+                    Token.from(obj.getJSONObject(JSON_FIELD_ACCESS_TOKEN)) : null;
+            refreshToken = obj.has(JSON_FIELD_REFRESH_TOKEN) ?
+                    Token.from(obj.getJSONObject(JSON_FIELD_REFRESH_TOKEN)) : null;
+            error = null;
+            if (accessToken == null) {
+                message = "accessToken = null";
+            } else {
+                message = String.format("Identity %s; Path %s", accessToken.identity(), accessToken.path());
+            }
+        } catch (JSONException ex) {
+            accessToken = null;
+            refreshToken = null;
+            //noinspection ThrowableInstanceNeverThrown
+            error = new ObjectServerError(ErrorCode.JSON_EXCEPTION, ex);
+            message = String.format("Error %s", error.getErrorMessage());
+        }
+        RealmLog.debug("AuthenticateResponse. " + message);
+        setError(error);
+        this.accessToken = accessToken;
+        this.refreshToken = refreshToken;
+    }
+
+    public Token getAccessToken() {
+        return accessToken;
+    }
+
+    public Token getRefreshToken() {
+        return refreshToken;
+    }
+
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
new file mode 100644
index 0000000000..5cde174353
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import java.net.URI;
+import java.net.URL;
+
+import io.realm.SyncCredentials;
+import io.realm.SyncUser;
+import io.realm.internal.objectserver.Token;
+
+/**
+ * Interface for handling communication with Realm Object Servers.
+ * <p>
+ * Note, no implementation of this class is responsible for handling retries or error handling. It is
+ * only responsible for executing a given network request.
+ */
+public interface AuthenticationServer {
+    /**
+     * Login a User on the Object Server. This will create a "UserToken" (Currently called RefreshToken) that acts as
+     * the users credentials.
+     */
+    AuthenticateResponse loginUser(SyncCredentials credentials, URL authenticationUrl);
+
+    /**
+     * Requests access to a specific Realm. Only users with a valid user token can ask for permission to a remote Realm.
+     * Permission to a Realm is granted through an "AccessToken". Each Realm have their own access token, and all
+     * tokens should be managed by {@link SyncUser}.
+     */
+    AuthenticateResponse loginToRealm(Token userToken, URI serverUrl,  URL authenticationUrl);
+
+    /**
+     * When the Object Server returns the user token, it also sends a timestamp for when the token expires.
+     * Before it expires, the client should try to refresh the token, effectively keeping the user logged in on the
+     * Object Server. Failing to do so will cause a "soft logout", where the User will have limited access rights.
+     */
+    AuthenticateResponse refreshUser(Token userToken, URL authenticationUrl);
+
+    /**
+     * Logs out the user on the Object Server by invalidating the refresh token. Each device should be given their
+     * own refresh token, but if the refresh token for some reason was shared or stolen all these devices will be
+     * logged out as well.
+     */
+    LogoutResponse logout(SyncUser user, URL authenticationUrl);
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java
new file mode 100644
index 0000000000..aa613c8357
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import java.util.concurrent.TimeUnit;
+
+import io.realm.ErrorCode;
+
+/**
+ * Abstracts the concept of running an network task with incremental backoff. It will run forever until interrupted.
+ */
+public abstract class ExponentialBackoffTask<T extends AuthServerResponse> implements Runnable {
+
+    // Task to perform
+    protected abstract T execute();
+
+    // Check if the task was successful
+    protected boolean isSuccess(T result) {
+        return result.isValid();
+    }
+
+    // Return true if based on the task result that this task will never complete
+    protected boolean shouldAbortTask(T response) {
+        // Only retry in case of IO exceptions, since that might be network timeouts etc.
+        // All other errors indicate a bigger problem, so just stop the task.
+        if (!response.isValid()) {
+            return response.getError().getErrorCode() != ErrorCode.IO_EXCEPTION;
+        } else {
+            return false;
+        }
+    }
+
+    // Callback when task is have succeeded
+    protected abstract void onSuccess(T response);
+
+    // Callback when task has failed
+    protected abstract void onError(T response);
+
+    @Override
+    public void run() {
+        int attempt = 0;
+        while (true) {
+            attempt++;
+            long sleep = calculateExponentialDelay(attempt - 1, TimeUnit.MINUTES.toMillis(5));
+            if (sleep > 0) {
+                try {
+                    Thread.sleep(sleep);
+                } catch (InterruptedException e) {
+                    return; // Abort if interrupted
+                }
+            }
+            T response = execute();
+
+            if (isSuccess(response)) {
+                onSuccess(response);
+                break;
+            } else {
+                if (shouldAbortTask(response)) {
+                    onError(response);
+                    break;
+                }
+            }
+        }
+    }
+
+    private static long calculateExponentialDelay(int failedAttempts, long maxDelayInMs) {
+        // https://en.wikipedia.org/wiki/Exponential_backoff
+        //Attempt = FailedAttempts + 1
+        //Attempt 1     0s     0s
+        //Attempt 2     2s     2s
+        //Attempt 3     4s     4s
+        //Attempt 4     8s     8s
+        //Attempt 5     16s    16s
+        //Attempt 6     32s    32s
+        //Attempt 7     64s    1m 4s
+        //Attempt 8     128s   2m 8s
+        //Attempt 9     256s   4m 16s
+        //Attempt 10    512    8m 32s
+        //Attempt 11    1024   17m 4s
+        //Attempt 12    2048   34m 8s
+        //Attempt 13    4096   1h 8m 16s
+        //Attempt 14    8192   2h 16m 32s
+        //Attempt 15    16384  4h 33m 4s
+        double SCALE = 1.0D; // Scale the exponential backoff
+        double delayInMs = ((Math.pow(2.0D, failedAttempts) - 1d) / 2.0D) * 1000 * SCALE;
+
+        // Just use maximum back-off value. We are not afraid of many threads using this value
+        // to trigger at once.
+        return maxDelayInMs < delayInMs ? maxDelayInMs : (long) delayInMs;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java
new file mode 100644
index 0000000000..c7706c27e5
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import io.realm.SyncUser;
+
+/**
+ * This class encapsulates a request to log out a user on the Realm Authentication Server. It is responsible for
+ * constructing the JSON understood by the Realm Authentication Server.
+ */
+public class LogoutRequest {
+    // TODO Endpoint not finished yet
+
+    LogoutRequest fromUser(SyncUser user) {
+        return new LogoutRequest();
+    }
+
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java
new file mode 100644
index 0000000000..5439f9f769
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import java.io.IOException;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.log.RealmLog;
+import okhttp3.Response;
+
+/**
+ * This class represents the response for a log out request.
+ */
+public class LogoutResponse extends AuthServerResponse {
+
+    private final ObjectServerError error;
+
+    /**
+     * Helper method for creating the proper Authenticate response. This method will set the appropriate error
+     * depending on any HTTP response codes or I/O errors.
+     *
+     * @param response the server response.
+     * @return the log out response.
+     */
+    static LogoutResponse createFrom(Response response) {
+        String serverResponse;
+        try {
+            serverResponse = response.body().string();
+        } catch (IOException e) {
+            ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
+            return new LogoutResponse(error);
+        }
+        RealmLog.debug("Authenticate response: " + serverResponse);
+        if (response.code() != 200) {
+            return new LogoutResponse(AuthServerResponse.createError(serverResponse, response.code()));
+        } else {
+            return new LogoutResponse(serverResponse);
+        }
+    }
+
+    /**
+     * Creates an unsuccessful authentication response. This should only happen in case of network or I/O
+     * related issues.
+     *
+     * @param error an authentication response error.
+     */
+    private LogoutResponse(ObjectServerError error) {
+        this.error = error;
+    }
+
+    /**
+     * Parses a valid (200) server response.
+     *
+     * @param serverResponse the server response.
+     */
+    private LogoutResponse(String serverResponse) {
+        this.error = null;
+        // TODO endpoint not finalized
+    }
+
+    /**
+     * Checks if response was valid.
+     *
+     * @return {@code true} if valid.
+     */
+    public boolean isValid() {
+//        return (error == null);
+        return true;
+    }
+
+    /**
+     * Returns the error.
+     *
+     * @return the error.
+     */
+    public ObjectServerError getError() {
+        return error;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/NetworkStateReceiver.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/NetworkStateReceiver.java
new file mode 100644
index 0000000000..5fa68176a9
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/NetworkStateReceiver.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import io.realm.internal.Util;
+
+/**
+ * This class is responsible for keeping track of system events related to the network so it can delegate them to
+ * interested parties.
+ */
+public class NetworkStateReceiver extends BroadcastReceiver {
+
+    private static List<ConnectionListener> listeners = new CopyOnWriteArrayList<ConnectionListener>();
+
+    /**
+     * Add a listener to be notified about any network changes.
+     * This method is thread safe.
+     * <p>
+     * IMPORTANT: Not removing it again will result in major leaks.
+     *
+     * @param listener the listener.
+     */
+    public static void addListener(ConnectionListener listener) {
+        listeners.add(listener);
+    }
+
+    /**
+     * Removes a network listener.
+     * This method is thread safe.
+     *
+     * @param listener the listener.
+     */
+    public static synchronized void removeListener(ConnectionListener listener) {
+        listeners.remove(listener);
+    }
+
+    /**
+     * Attempt to detect if a device is online and can transmit or receive data.
+     * This method is thread safe.
+     * <p>
+     * An emulator is always considered online, as `getActiveNetworkInfo()` does not report the correct value.
+     *
+     * @param context an Android context.
+     * @return {@code true} if device is online, otherwise {@code false}.
+     */
+    public static boolean isOnline(Context context) {
+        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkInfo networkInfo = cm.getActiveNetworkInfo();
+        return ((networkInfo != null && networkInfo.isConnectedOrConnecting()) || Util.isEmulator());
+    }
+
+
+    public void onReceive(Context context, Intent intent) {
+        boolean connected = isOnline(context);
+        for (ConnectionListener listener : listeners) {
+            listener.onChange(connected);
+        }
+    }
+
+    public interface ConnectionListener {
+        void onChange(boolean connectionAvailable);
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
new file mode 100644
index 0000000000..c84d408a12
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import java.net.URI;
+import java.net.URL;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.SyncCredentials;
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.SyncUser;
+import io.realm.internal.objectserver.Token;
+import okhttp3.Call;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+
+public class OkHttpAuthenticationServer implements AuthenticationServer {
+
+    public static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
+
+    private final OkHttpClient client = new OkHttpClient.Builder()
+            .connectTimeout(10, TimeUnit.SECONDS)
+            .writeTimeout(10, TimeUnit.SECONDS)
+            .readTimeout(30, TimeUnit.SECONDS)
+            .build();
+
+    /**
+     * Authenticate the given credentials on the specified Realm Authentication Server.
+     */
+    @Override
+    public AuthenticateResponse loginUser(SyncCredentials credentials, URL authenticationUrl) {
+        try {
+            String requestBody = AuthenticateRequest.userLogin(credentials).toJson();
+            return authenticate(authenticationUrl, requestBody);
+        } catch (Exception e) {
+            return AuthenticateResponse.from(new ObjectServerError(ErrorCode.UNKNOWN, e));
+        }
+    }
+
+    @Override
+    public AuthenticateResponse loginToRealm(Token refreshToken, URI serverUrl, URL authenticationUrl) {
+        try {
+            String requestBody = AuthenticateRequest.realmLogin(refreshToken, serverUrl).toJson();
+            return authenticate(authenticationUrl, requestBody);
+        } catch (Exception e) {
+            return AuthenticateResponse.from(new ObjectServerError(ErrorCode.UNKNOWN, e));
+        }
+    }
+
+    @Override
+    public AuthenticateResponse refreshUser(Token userToken, URL authenticationUrl) {
+        try {
+            String requestBody = AuthenticateRequest.userRefresh(userToken).toJson();
+            return authenticate(authenticationUrl, requestBody);
+        } catch (Exception e) {
+            return AuthenticateResponse.from(new ObjectServerError(ErrorCode.UNKNOWN, e));
+        }
+    }
+
+    @Override
+    public LogoutResponse logout(SyncUser user, URL authenticationUrl) {
+        throw new UnsupportedOperationException("Not yet implemented");
+    }
+
+    private AuthenticateResponse authenticate(URL authenticationUrl, String requestBody) throws Exception {
+        Request request = new Request.Builder()
+                .url(authenticationUrl)
+                .addHeader("Content-Type", "application/json")
+                .addHeader("Accept", "application/json")
+                .addHeader("Connection", "close") //  See https://github.com/square/okhttp/issues/2363
+                .post(RequestBody.create(JSON, requestBody))
+                .build();
+        Call call = client.newCall(request);
+        Response response = call.execute();
+        return AuthenticateResponse.from(response);
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/AuthenticatingState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/AuthenticatingState.java
new file mode 100644
index 0000000000..9ca21ecf9e
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/AuthenticatingState.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import io.realm.ObjectServerError;
+import io.realm.SyncSession;
+import io.realm.SessionState;
+import io.realm.internal.network.NetworkStateReceiver;
+import io.realm.log.RealmLog;
+
+/**
+ * AUTHENTICATING State. This step is needed if the user does not have proper access or credentials to access the
+ * Realm when attempting to bind it. Reasons for not having proper access or invalid credentials include:
+ *
+ * <ol>
+ *     <li>
+ *          <b>Refresh token has expired:</b>
+ *          This effectively means the user has been logged out from the Realm Object Server and credentials have
+ *          to be re-verified by the Authentication Server. Since verification involves creating a new User object,
+ *          this session will be stopped and an error reported.
+ *     </li>
+ *     <li>
+ *          <b>Access token has expired:</b>
+ *          In this case, the token is automatically refreshed and will retry binding the Realm.
+ *     </li>
+ *     <li>
+ *          <b>Access token does not exist:</b>
+ *          This state means the user has logged in, but not yet gained a specific access token for the Realm.
+ *          The access token will automatically be fetched and binding the Realm is retried.
+ *      </li>
+ * </ol>
+ */
+class AuthenticatingState extends FsmState {
+
+    @Override
+    public void onEnterState() {
+        if (NetworkStateReceiver.isOnline(SyncObjectServerFacade.getApplicationContext())) {
+            authenticate(session);
+        } else {
+            // Wait for connection to become available, before trying again.
+            // The Session might potentially stay in this state for the lifetime of the application.
+            // This is acceptable.
+            session.networkListener = new NetworkStateReceiver.ConnectionListener() {
+                @Override
+                public void onChange(boolean connectionAvailable) {
+                    if (connectionAvailable) {
+                        authenticate(session);
+                        NetworkStateReceiver.removeListener(this);
+                    }
+                }
+            };
+            NetworkStateReceiver.addListener(session.networkListener);
+        }
+    }
+
+    @Override
+    public void onExitState() {
+        // Abort any current network request.
+        if (session.networkRequest != null) {
+            session.networkRequest.cancel();
+            session.networkRequest = null;
+        }
+
+        // Release listener if we were waiting for network to become available.
+        if (session.networkListener != null) {
+            NetworkStateReceiver.removeListener(session.networkListener);
+            session.networkListener = null;
+        }
+    }
+
+    @Override
+    public void onBind() {
+        gotoNextState(SessionState.BINDING); // Equivalent to forcing a retry
+    }
+
+    @Override
+    public void onUnbind() {
+        gotoNextState(SessionState.UNBOUND); // Treat this as user wanting to exit a binding in progress.
+    }
+
+    @Override
+    public void onStop() {
+        gotoNextState(SessionState.STOPPED);
+    }
+
+    private synchronized void authenticate(final ObjectServerSession session) {
+        session.authenticateRealm(new Runnable() {
+            @Override
+            public void run() {
+                RealmLog.debug("Session[%s]: Access token acquired", session.getConfiguration().getPath());
+                gotoNextState(SessionState.BINDING);
+            }
+        }, new SyncSession.ErrorHandler() {
+            @Override
+            public void onError(SyncSession s, ObjectServerError error) {
+                RealmLog.debug("Session[%s]: Failed to get access token (%d)", session.getConfiguration().getPath(), error.getErrorCode());
+                session.onError(error);
+            }
+        });
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BindingState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BindingState.java
new file mode 100644
index 0000000000..fbd3a14f5b
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BindingState.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import io.realm.ObjectServerError;
+import io.realm.SessionState;
+
+/**
+ * BINDING State. After {@code bind()} is called, the state will attempt to bind the local Realm to the remote. This is an
+ * asynchronous operation which must be interruptible.
+ */
+class BindingState extends FsmState {
+
+    @Override
+    public void onEnterState() {
+        if (session.isAuthenticated(session.configuration)) {
+            // FIXME How to handle errors?
+            session.bindWithTokens();
+            gotoNextState(SessionState.BOUND);
+        } else {
+            // Not access token available. We need to authenticateUser first.
+            gotoNextState(SessionState.AUTHENTICATING);
+        }
+    }
+
+    @Override
+    public void onExitState() {
+        // TODO Abort any async stuff going on, possible in `session.bindWithTokens()`
+    }
+
+    @Override
+    public void onBind() {
+        gotoNextState(SessionState.BINDING); // Will trigger a retry.
+    }
+
+    @Override
+    public void onUnbind() {
+        gotoNextState(SessionState.UNBOUND);
+    }
+
+    @Override
+    public void onError(ObjectServerError error) {
+        // Ignore all errors. This is just a transient state. We are not bound yet, and any error should not
+        // happen until we are BOUND.
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BoundState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BoundState.java
new file mode 100644
index 0000000000..a941440867
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BoundState.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.SessionState;
+
+/**
+ * BOUND State. In this state the local Realm is bound to the remote Realm and changes are sent in both
+ * directions immediately.
+ */
+class BoundState extends FsmState {
+
+    @Override
+    public void onEnterState() {
+        // Do nothing. If everything is setup correctly. We should now be synchronizing any changes
+        // between the local and remote Realm.
+    }
+
+    @Override
+    public void onExitState() {
+        // Do nothing. Entry states will stop the session if needed.
+    }
+
+    @Override
+    public void onUnbind() {
+        gotoNextState(SessionState.UNBOUND);
+    }
+
+    @Override
+    public void onStop() {
+        gotoNextState(SessionState.STOPPED);
+    }
+
+    @Override
+    public void onError(ObjectServerError error) {
+        // If a Realms access token has expired, trigger a rebind. If the user is still valid it will automatically
+        // refresh it.
+        if (error.getErrorCode() == ErrorCode.TOKEN_EXPIRED) {
+            gotoNextState(SessionState.BINDING);
+        } else {
+            switch (error.getCategory()) {
+                case FATAL: gotoNextState(SessionState.STOPPED); break;
+                case RECOVERABLE: gotoNextState(SessionState.UNBOUND); break;
+            }
+        }
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmAction.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmAction.java
new file mode 100644
index 0000000000..a4af906d3b
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmAction.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import io.realm.ObjectServerError;
+import io.realm.SyncSession;
+
+/**
+ * As {@link SyncSession} is modeled as a state machine, this interface describe all
+ * possible actions in that machine.
+ * <p>
+ * All states should implement this interface so all possible permutations of state/actions are covered.
+ *
+ */
+interface FsmAction {
+    void onStart();
+    void onBind();
+    void onUnbind();
+    void onStop();
+    void onError(ObjectServerError error);
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmState.java
new file mode 100644
index 0000000000..ee4089a848
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmState.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import io.realm.SyncSession;
+import io.realm.ObjectServerError;
+import io.realm.SessionState;
+
+/**
+ * Abstract class containing shared logic for all {@link SyncSession} states. All states must extend
+ * this class as it contains the logic for entering and leaving states.
+ */
+abstract class FsmState implements FsmAction {
+
+    volatile ObjectServerSession session; // This is non-null when this state is active.
+    private boolean exiting; // TODO: Remind me again what race condition necessitated this.
+
+    /**
+     * Entry into the state. This method is also responsible for executing any asynchronous work
+     * this state might run.
+     *
+     * This should only be called from {@link SyncSession}.
+     */
+    public void entry(ObjectServerSession session) {
+        this.session = session;
+        this.exiting = false;
+        onEnterState();
+    }
+
+    /**
+     * Called just before leaving the state. Once this method is called no more state changes can be triggered from
+     * this state until {@link #entry(ObjectServerSession)} has been called again.
+     * <p>
+     * This should only be called from {@link SyncSession}.
+     */
+    public void exit() {
+        exiting = true;
+        onExitState();
+    }
+
+    public void gotoNextState(SessionState state) {
+        if (!exiting) {
+            session.nextState(state);
+        }
+    }
+
+    protected abstract void onEnterState();
+    protected abstract void onExitState();
+
+    @Override
+    public void onStart() {
+        // Do nothing
+    }
+
+    @Override
+    public void onBind() {
+        // Do nothing
+    }
+
+    @Override
+    public void onUnbind() {
+        // Do nothing
+    }
+
+    @Override
+    public void onStop() {
+        // Do nothing
+    }
+
+    @Override
+    public void onError(ObjectServerError error) {
+        switch(error.getCategory()) {
+            case FATAL:
+                gotoNextState(SessionState.STOPPED);
+                break;
+            case RECOVERABLE:
+                gotoNextState(SessionState.UNBOUND);
+                break;
+        }
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/InitialState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/InitialState.java
new file mode 100644
index 0000000000..ed13957250
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/InitialState.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import io.realm.ObjectServerError;
+import io.realm.SessionState;
+
+/**
+ * INITIAL State. Starting point for the Session Finite-State-Machine.
+ */
+class InitialState extends FsmState {
+
+    @Override
+    public void onEnterState() {
+        // Do nothing. We start here
+    }
+
+    @Override
+    protected void onExitState() {
+        // Do nothing. Right now the underlying Realm Core session cannot bound/unbind multiple times, so instead
+        // we create a new session object each time the Session becomes unbound.
+    }
+
+    @Override
+    public void onStart() {
+        gotoNextState(SessionState.UNBOUND);
+    }
+
+    @Override
+    public void onError(ObjectServerError error) {
+        // Ignore all errors at this state. None of them would have any impact.
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java
new file mode 100644
index 0000000000..a0e4802df3
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java
@@ -0,0 +1,365 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import java.net.URI;
+import java.util.HashMap;
+import java.util.concurrent.Future;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.RealmAsyncTask;
+import io.realm.SyncSession;
+import io.realm.SessionState;
+import io.realm.SyncConfiguration;
+import io.realm.SyncManager;
+import io.realm.SyncUser;
+import io.realm.internal.KeepMember;
+import io.realm.internal.async.RealmAsyncTaskImpl;
+import io.realm.internal.network.AuthenticateResponse;
+import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.ExponentialBackoffTask;
+import io.realm.internal.network.NetworkStateReceiver;
+import io.realm.internal.syncpolicy.SyncPolicy;
+import io.realm.log.RealmLog;
+
+/**
+ * Internal class describing a Realm Object Server Session.
+ * There is currently a split between the public {@link SyncSession} and this class.
+ * This class is intended as a wrapper for Object Store's Sync Session, but it is not that yet.
+ * <p>
+ * A Session is created by either calling {@link SyncManager#getSession(SyncConfiguration)} or by opening
+ * a Realm instance. Once a session has been created, it will continue to exist until explicitly closed or the
+ * underlying Realm file is deleted.
+ * <p>
+ * It is typically not necessary to interact directly with a session. The interaction should be done by the {@code SyncPolicy}
+ * defined using {@code io.realm.SyncConfiguration.Builder#syncPolicy(SyncPolicy)}.
+ * <p>
+ * A session has a lifecycle consisting of the following states:
+ * <p>
+ * <dl>
+ * <li>
+ *     <b>INITIAL</b> Initial state when creating the Session object. No connections to the object server have been
+ *     created yet. At this point it is possible to register any relevant error and event listeners. Calling
+ *     {@link #start()} will cause the session to become <b>UNBOUND</b> and notify the {@code SyncPolicy} that the
+ *     session is ready by calling {@code SyncPolicy#onSessionCreated(Session)}.
+ * </li>
+ * <li>
+ *     <b>UNBOUND</b> When a session is unbound, no synchronization between the local and remote Realm is taking place.
+ *     Call {@link #bind()} to start synchronizing changes.
+ * </li>
+ * <li>
+ *     <b>BINDING</b> A session is in the process of binding a local Realm to a remote one. Calling {@link #unbind()}
+ *     at this stage, will cancel the process. If binding fails, the session will revert to being INBOUND and an error
+ *     will be reported to the error handler.
+ * </li>
+ * <li>
+ *     <b>AUTHENTICATING</b> During binding, if a users access has expired, the session will be <b>AUTHENTICATING</b>.
+ *     During this state, Realm will automatically try to acquire new valid credentials. If it succeed <b>BINDING</b>
+ *     will automatically be resumed, if not, the session will become <b>UNBOUND</b> or <b>STOPPED</b> and an
+ *     appropriate error reported.
+ * </li>
+ * <li>
+ *     <b>BOUND</b> A bound session has an active connection to the remote Realm and will synchronize any changes
+ *     immediately.
+ * </li>
+ * <li>
+ *     <b>STOPPED</b> The session are in an unrecoverable state. Check the error log for additional information, but
+ *     the type of errors is usually wrong credentials for the Realm being accessed or a mismatching Object Server.
+ *     Most problems can be solved by creating a new {@link SyncConfiguration} with a new {@code serverUrl} and
+ *     {@code user}.
+ * </li>
+ * </dl>
+ *
+ * This object is thread safe.
+ */
+@KeepMember
+public final class ObjectServerSession {
+
+    private final HashMap<SessionState, FsmState> FSM = new HashMap<SessionState, FsmState>();
+
+    // Variables used by the FSM
+    final SyncConfiguration configuration;
+    private final AuthenticationServer authServer;
+    private final SyncSession.ErrorHandler errorHandler;
+    private long nativeSessionPointer;
+    private final ObjectServerUser user;
+    RealmAsyncTask networkRequest;
+    NetworkStateReceiver.ConnectionListener networkListener;
+    private SyncPolicy syncPolicy;
+
+    // Keeping track of current FSM state
+    private SessionState currentStateDescription;
+    private FsmState currentState;
+    private SyncSession userSession;
+    private SyncSession publicSession;
+
+    /**
+     * Creates a new Object Server Session.
+     *
+     * @param syncConfiguration Sync configuration defining this session
+     * @param authServer Authentication server used to refresh credentials if needed
+     * @param policy Sync Policy to use by this Session.
+     */
+    public ObjectServerSession(SyncConfiguration syncConfiguration,
+                               AuthenticationServer authServer,
+                               ObjectServerUser user,
+                               SyncPolicy policy,
+                               SyncSession.ErrorHandler errorHandler) {
+        this.configuration = syncConfiguration;
+        this.user = user;
+        this.authServer = authServer;
+        this.errorHandler = errorHandler;
+        this.syncPolicy = policy;
+        setupStateMachine();
+    }
+
+    private void setupStateMachine() {
+        FSM.put(SessionState.INITIAL, new InitialState());
+        FSM.put(SessionState.UNBOUND, new UnboundState());
+        FSM.put(SessionState.BINDING, new BindingState());
+        FSM.put(SessionState.AUTHENTICATING, new AuthenticatingState());
+        FSM.put(SessionState.BOUND, new BoundState());
+        FSM.put(SessionState.STOPPED, new StoppedState());
+        RealmLog.debug("Session started: " + configuration.getServerUrl());
+        currentState = FSM.get(SessionState.INITIAL);
+        currentState.entry(this);
+    }
+
+    // Goto the next state. The FsmState classes are responsible for calling this method as a reaction to a FsmAction
+    // being called or an internal action triggering a state transition.
+    void nextState(SessionState nextStateDescription) {
+        currentState.exit();
+        FsmState nextState = FSM.get(nextStateDescription);
+        if (nextState == null) {
+            throw new IllegalStateException("No state was configured to handle: " + nextStateDescription);
+        }
+        RealmLog.debug("Session[%s]: %s -> %s", configuration.getServerUrl(), currentStateDescription, nextStateDescription);
+        currentStateDescription = nextStateDescription;
+        currentState = nextState;
+        nextState.entry(this);
+    }
+
+    /**
+     * Starts the session. This will cause the session to come <b>UNBOUND</b>. {@link #bind()} must be called to
+     * actually start synchronizing data.
+     */
+    public synchronized void start() {
+        currentState.onStart();
+    }
+
+    /**
+     * Stops the session. The session can no longer be used.
+     */
+    public synchronized void stop() {
+        currentState.onStop();
+    }
+
+    /**
+     * Binds the local Realm to the remote Realm. Once bound, changes to either the local or Remote Realm will be
+     * synchronized immediately.
+     * <p>
+     * While this method will return immediately, binding a Realm is not guaranteed to succeed. Possible reasons for
+     * failure could be if the device is offline or credentials have expired. Binding is an asynchronous
+     * operation and all errors will be sent first to {@code SyncPolicy#onError(Session, ObjectServerError)} and if the
+     * SyncPolicy doesn't handle it, to the {@link SyncSession.ErrorHandler} defined by
+     * {@link SyncConfiguration.Builder#errorHandler(SyncSession.ErrorHandler)}.
+     */
+    public synchronized void bind() {
+        currentState.onBind();
+    }
+
+    /**
+     * Stops a local Realm from synchronizing changes with the remote Realm.
+     * <p>
+     * It is possible to call {@link #bind()} again after a Realm has been unbound.
+     */
+    public synchronized void unbind() {
+        currentState.onUnbind();
+    }
+
+    /**
+     * Notify the session that an error has occurred.
+     *
+     * @param error the kind of err
+     */
+    public synchronized void onError(ObjectServerError error) {
+        currentState.onError(error); // FSM needs to respond to the error first, before notifying the User
+        if (errorHandler != null) {
+            errorHandler.onError(getUserSession(), error);
+        }
+    }
+
+    // Called from JniSession in native code.
+    // This callback will happen on the thread running the Sync Client.
+    @SuppressWarnings("unused")
+    @KeepMember
+    private void notifySessionError(int errorCode, String errorMessage) {
+        ObjectServerError error = new ObjectServerError(ErrorCode.fromInt(errorCode), errorMessage);
+        onError(error);
+    }
+
+    /**
+     * Checks if the local Realm is bound to the remote Realm and can synchronize any changes happening on either
+     * sides.
+     *
+     * @return {@code true} if the local Realm is bound to the remote Realm, {@code false} otherwise.
+     */
+    boolean isBound() {
+        return currentStateDescription == SessionState.BOUND;
+    }
+
+    //
+    // Package protected methods used by the FSM states to manipulate session variables.
+    //
+
+    // Create a native session. The session abstraction in Realm Core doesn't support multiple calls to bind()/unbind()
+    // yet, so the Java SyncSession must manually create/and close the native sessions as needed.
+    void createNativeSession() {
+        nativeSessionPointer = nativeCreateSession(configuration.getPath());
+    }
+
+    void stopNativeSession() {
+        if (nativeSessionPointer != 0) {
+            nativeUnbind(nativeSessionPointer);
+            nativeSessionPointer = 0;
+        }
+    }
+
+    // Bind with proper access tokens
+    // Access tokens are presumed to be present and valid at this point
+    void bindWithTokens() {
+        Token accessToken = user.getAccessToken(configuration.getServerUrl());
+        if (accessToken == null) {
+            throw new IllegalStateException("User '" + user.toString() + "' does not have an access token for "
+                    + configuration.getServerUrl());
+        }
+        nativeBind(nativeSessionPointer, configuration.getServerUrl().toString(), accessToken.value());
+    }
+
+    // Authenticate by getting access tokens for the specific Realm
+    void authenticateRealm(final Runnable onSuccess, final SyncSession.ErrorHandler errorHandler) {
+        if (networkRequest != null) {
+            networkRequest.cancel();
+        }
+        // Authenticate in a background thread. This allows incremental backoff and retries in a safe manner.
+        Future<?> task = SyncManager.NETWORK_POOL_EXECUTOR.submit(new ExponentialBackoffTask<AuthenticateResponse>() {
+            @Override
+            protected AuthenticateResponse execute() {
+                return authServer.loginToRealm(
+                        user.getUserToken(),
+                        configuration.getServerUrl(),
+                        user.getAuthenticationUrl()
+                );
+            }
+
+            @Override
+            protected void onSuccess(AuthenticateResponse response) {
+                ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(
+                        response.getAccessToken(),
+                        configuration.getPath(),
+                        configuration.shouldDeleteRealmOnLogout()
+                );
+                user.addRealm(configuration.getServerUrl(), desc);
+                onSuccess.run();
+            }
+
+            @Override
+            protected void onError(AuthenticateResponse response) {
+                errorHandler.onError(getUserSession(), response.getError());
+            }
+        });
+        networkRequest = new RealmAsyncTaskImpl(task, SyncManager.NETWORK_POOL_EXECUTOR);
+    }
+
+    /**
+     * Checks if a user has valid credentials for accessing this Realm.
+     *
+     * @param configuration the configuration.
+     * @return {@code true} if credentials are valid, {@code false} otherwise.
+     */
+    boolean isAuthenticated(SyncConfiguration configuration) {
+        return user.isAuthenticated(configuration);
+    }
+
+    /**
+     * Returns the {@link SyncConfiguration} that is responsible for controlling this session.
+     *
+     * @return SyncConfiguration that defines and controls this session.
+     */
+    public SyncConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    /**
+     * Returns the {@link SyncUser} defined by the {@link SyncConfiguration} that is used to connect to the
+     * Realm Object Server.
+     *
+     * @return {@link SyncUser} used to authenticate the session on the Realm Object Server.
+     */
+    public SyncUser getUser() {
+        return configuration.getUser();
+    }
+
+    /**
+     * Returns the {@link URI} describing the remote Realm this session connects to and synchronizes changes with.
+     *
+     * @return {@link URI} describing the remote Realm.
+     */
+    public URI getServerUrl() {
+        return configuration.getServerUrl();
+    }
+
+    /**
+     * Returns the state of this session.
+     *
+     * @return The current {@link SessionState} for this session.
+     */
+    public SessionState getState() {
+        return currentStateDescription;
+    }
+
+    /**
+     * Notify session that a commit on the device has happened.
+     *
+     * @param version the commit number/version.
+     */
+    public void notifyCommit(long version) {
+        if (isBound()) {
+            nativeNotifyCommitHappened(nativeSessionPointer, version);
+        }
+    }
+
+    public SyncPolicy getSyncPolicy() {
+        return syncPolicy;
+    }
+
+    public SyncSession getUserSession() {
+        return userSession;
+    }
+
+    public void setUserSession(SyncSession userSession) {
+        this.userSession = userSession;
+    }
+
+    private native long nativeCreateSession(String localRealmPath);
+    private native void nativeBind(long nativeSessionPointer, String remoteRealmUrl, String userToken);
+    private native void nativeUnbind(long nativeSessionPointer);
+    private native void nativeRefresh(long nativeSessionPointer, String userToken);
+    private native void nativeNotifyCommitHappened(long sessionPointer, long version);
+}
+
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
new file mode 100644
index 0000000000..f74c9dd0a9
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
@@ -0,0 +1,242 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.net.URI;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import io.realm.SyncSession;
+import io.realm.SyncConfiguration;
+
+/**
+ * Internal representation of a user on the Realm Object Server.
+ * The public API is defined by {@link io.realm.SyncUser}.
+ */
+public class ObjectServerUser {
+
+    private final String identity;
+    private Token refreshToken;
+    private URL authenticationUrl;
+    private Map<URI, AccessDescription> realms = new HashMap<URI, AccessDescription>();
+    private List<SyncSession> sessions = new ArrayList<SyncSession>();
+    private boolean loggedIn;
+
+    /**
+     * Create a new Realm Object Server User
+     */
+    public ObjectServerUser(Token refreshToken, URL authenticationUrl) {
+        this.identity = refreshToken.identity();
+        this.authenticationUrl = authenticationUrl;
+        setRefreshToken(refreshToken);
+        this.loggedIn = true;
+    }
+
+    public void setRefreshToken(final Token refreshToken) {
+        this.refreshToken = refreshToken; // Replace any existing token. TODO re-save the user with latest token.
+    }
+
+    /**
+     * Checks if the user has access to the given Realm. Being authenticated means that the
+     * user is know by the Realm Object Server and have been granted access to the given Realm.
+     *
+     * Authenticating will happen automatically as part of opening a Realm.
+     */
+    public boolean isAuthenticated(SyncConfiguration configuration) {
+        Token token = getAccessToken(configuration.getServerUrl());
+        return token != null && token.expiresMs() > System.currentTimeMillis();
+    }
+
+    public String toJson() {
+        JSONObject obj = new JSONObject();
+        try {
+            obj.put("authUrl", authenticationUrl);
+            obj.put("userToken", refreshToken.toJson());
+            JSONArray realmList = new JSONArray();
+            for (Map.Entry<URI, AccessDescription> entry : realms.entrySet()) {
+                JSONObject token = new JSONObject();
+                token.put("uri", entry.getKey().toString());
+                token.put("description", entry.getValue().toJson());
+                realmList.put(token);
+            }
+            obj.put("realms", realmList);
+            return obj.toString();
+        } catch (JSONException e) {
+            throw new RuntimeException("Could not convert User to JSON", e);
+        }
+    }
+
+    public String getIdentity() {
+        return identity;
+    }
+
+    public Token getAccessToken(URI serverUrl) {
+        AccessDescription accessDescription = realms.get(serverUrl);
+        return (accessDescription != null) ? accessDescription.accessToken : null;
+    }
+
+    public void addRealm(URI uri, AccessDescription description) {
+        realms.put(uri, description);
+    }
+
+    // When a session is started, add it to the user so it can be tracked
+    public void addSession(SyncSession session) {
+        sessions.add(session);
+    }
+
+    /**
+     * Adds an access token to this user.
+     * <p>
+     * An access token is a token granting access to one remote Realm. Access Tokens are normally fetched transparently
+     * when opening a Realm, but using this method it is possible to add tokens upfront if they have been fetched or
+     * created manually.
+     *
+     * @param uri {@link java.net.URI} pointing to a remote Realm.
+     * @param accessToken
+     */
+    public void addRealm(URI uri, String accessToken, String localPath, boolean deleteOnLogout) {
+        if (uri == null || accessToken == null) {
+            throw new IllegalArgumentException("Non-null 'uri' and 'accessToken' required.");
+        }
+        uri = SyncUtil.getFullServerUrl(uri, identity);
+
+        // Optimistically create a long-lived token with all permissions. If this is incorrect the Object Server
+        // will reject it anyway. If tokens are added manually it is up to the user to ensure they are also used
+        // correctly.
+        Token token = new Token(accessToken, null, uri.toString(), Long.MAX_VALUE, Token.Permission.values());
+        addRealm(uri, new AccessDescription(token, localPath, deleteOnLogout));
+    }
+
+    public URL getAuthenticationUrl() {
+        return authenticationUrl;
+    }
+
+    public Token getUserToken() {
+        return refreshToken;
+    }
+
+    public List<SyncSession> getSessions() {
+        return sessions;
+    }
+
+    public void clearTokens() {
+        realms.clear();
+        refreshToken = null;
+    }
+
+    public boolean isLoggedIn() {
+        return loggedIn;
+    }
+
+    // Local Logout means that the user is no longer able to create new sync configurations,
+    // nor synchronize changes
+    public void localLogout() {
+        loggedIn = false;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        ObjectServerUser syncUser = (ObjectServerUser) o;
+
+        if (!identity.equals(syncUser.identity)) return false;
+        if (!refreshToken.equals(syncUser.refreshToken)) return false;
+        if (!authenticationUrl.toString().equals(syncUser.authenticationUrl.toString())) return false;
+        return realms.equals(syncUser.realms);
+
+    }
+
+    @Override
+    public int hashCode() {
+        int result = identity.hashCode();
+        result = 31 * result + refreshToken.hashCode();
+        result = 31 * result + authenticationUrl.toString().hashCode();
+        result = 31 * result + realms.hashCode();
+        return result;
+    }
+
+    public Collection<AccessDescription> getRealms() {
+        return realms.values();
+    }
+
+    // Wrapper for all Realm data needed by a User that might get serialized.
+    public static class AccessDescription {
+        public Token accessToken;
+        public String localPath;
+        public boolean deleteOnLogout;
+
+        public AccessDescription(Token accessToken, String localPath, boolean deleteOnLogout) {
+            this.accessToken = accessToken;
+            this.localPath = localPath;
+            this.deleteOnLogout = deleteOnLogout;
+        }
+
+        public static AccessDescription fromJson(JSONObject json) {
+            try {
+                Token token = Token.from(json.getJSONObject("accessToken"));
+                String localPath = json.getString("localPath");
+                boolean deleteOnLogout = json.getBoolean("deleteOnLogout");
+                return new AccessDescription(token, localPath, deleteOnLogout);
+            } catch (JSONException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        public JSONObject toJson() {
+            try {
+                JSONObject obj = new JSONObject();
+                obj.put("accessToken", accessToken.toJson());
+                obj.put("localPath", localPath);
+                obj.put("deleteOnLogout", deleteOnLogout);
+                return obj;
+            } catch (JSONException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+
+            AccessDescription that = (AccessDescription) o;
+
+            if (deleteOnLogout != that.deleteOnLogout) return false;
+            if (!accessToken.equals(that.accessToken)) return false;
+            return localPath.equals(that.localPath);
+
+        }
+
+        @Override
+        public int hashCode() {
+            int result = accessToken.hashCode();
+            result = 31 * result + localPath.hashCode();
+            result = 31 * result + (deleteOnLogout ? 1 : 0);
+            return result;
+        }
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SessionStore.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SessionStore.java
new file mode 100644
index 0000000000..a40fe01fd1
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SessionStore.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import io.realm.SyncSession;
+import io.realm.SyncManager;
+import io.realm.SyncConfiguration;
+
+/**
+ * Private class for keeping track of sessions.
+ * If {@link SyncSession} and {@link ObjectServerSession} are combined at some point, this class can
+ * be folded into {@link SyncManager};
+ */
+public class SessionStore {
+
+    // Map of between a local Realm path and any associated sessionInfo
+    private static HashMap<String, SyncSession> sessions = new HashMap<String, SyncSession>();
+    private static HashMap<String, ObjectServerSession> privateSessions = new HashMap<String, ObjectServerSession>();
+
+    static synchronized void removeSession(SyncSession session) {
+        if (session == null) {
+            return;
+        }
+
+        Iterator<Map.Entry<String, SyncSession>> it = sessions.entrySet().iterator();
+        while (it.hasNext()) {
+            Map.Entry<String, SyncSession> entry = it.next();
+            if (entry.getValue().equals(session)) {
+                it.remove();
+                break;
+            }
+        }
+    }
+
+    public static synchronized void addSession(SyncSession publicSession, ObjectServerSession internalSession) {
+        String localPath = publicSession.getConfiguration().getPath();
+        sessions.put(localPath, publicSession);
+        privateSessions.put(localPath, internalSession);
+    }
+
+    public static synchronized boolean hasSession(SyncConfiguration config) {
+        String localPath = config.getPath();
+        return sessions.containsKey(localPath);
+    }
+
+    public static synchronized SyncSession getPublicSession(SyncConfiguration config) {
+        String localPath = config.getPath();
+        return sessions.get(localPath);
+    }
+
+    public static synchronized ObjectServerSession getPrivateSession(SyncSession session) {
+        String localPath = session.getConfiguration().getPath();
+        return privateSessions.get(localPath);
+    }
+
+    public static Collection<ObjectServerSession> getAllSessions() {
+        return privateSessions.values();
+    }
+
+}
+
+
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/StoppedState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/StoppedState.java
new file mode 100644
index 0000000000..f1b58008b0
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/StoppedState.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import io.realm.ObjectServerError;
+import io.realm.SyncSession;
+
+/**
+ * STOPPED State. This is the final state for a {@link SyncSession}. After this, all actions will throw an
+ * {@link IllegalStateException}.
+ */
+class StoppedState extends FsmState {
+
+    @Override
+    public void onEnterState() {
+        session.stopNativeSession();
+        session.getSyncPolicy().onSessionStopped(session);
+    }
+
+    @Override
+    protected void onExitState() {
+        // Cannot exit this state
+    }
+
+    @Override
+    public void onStart() {
+        // To harsh to to throw here as any SyncPolicy might not have been made aware
+        // that the Session is stopped. Just ignore the call instead.
+    }
+
+    @Override
+    public void onBind() {
+        // To harsh to to throw here as any SyncPolicy might not have been made aware
+        // that the Session is stopped. Just ignore the call instead.
+    }
+
+    @Override
+    public void onUnbind() {
+        // To harsh to to throw here as any SyncPolicy might not have been made aware
+        // that the Session is stopped. Just ignore the call instead.
+    }
+
+    @Override
+    public void onStop() {
+        // To harsh to to throw here as any SyncPolicy might not have been made aware
+        // that the Session is stopped. Just ignore the call instead.
+    }
+
+    @Override
+    public void onError(ObjectServerError error) {
+        // Ignore all errors at this state. None of them would have any impact.
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncObjectServerFacade.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncObjectServerFacade.java
new file mode 100644
index 0000000000..63e18261d4
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncObjectServerFacade.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import io.realm.RealmConfiguration;
+import io.realm.SyncSession;
+import io.realm.SyncConfiguration;
+import io.realm.SyncManager;
+import io.realm.exceptions.RealmException;
+import io.realm.internal.Keep;
+import io.realm.internal.ObjectServerFacade;
+import io.realm.internal.network.NetworkStateReceiver;
+
+@SuppressWarnings({"unused", "WeakerAccess"}) // Used through reflection. See ObjectServerFacade
+@Keep
+public class SyncObjectServerFacade extends ObjectServerFacade {
+
+    private static final String WRONG_TYPE_OF_CONFIGURATION =
+            "'configuration' has to be an instance of 'SyncConfiguration'.";
+    @SuppressLint("StaticFieldLeak") //
+    private static Context applicationContext;
+
+    @Override
+    public void init(Context context) {
+        // Trying to keep things out the public API is no fun :/
+        // Just use reflection on init. It is a one-time method call so should be acceptable.
+        //noinspection TryWithIdenticalCatches
+        try {
+            // FIXME: Reflection can be avoided by moving some functions of SyncManager and ObjectServer out of public
+            Class<?> syncManager = Class.forName("io.realm.ObjectServer");
+            Method method = syncManager.getDeclaredMethod("init", Context.class);
+            method.setAccessible(true);
+            method.invoke(null, context);
+        } catch (NoSuchMethodException e) {
+            throw new RealmException("Could not initialize the Realm Object Server", e);
+        } catch (InvocationTargetException e) {
+            throw new RealmException("Could not initialize the Realm Object Server", e);
+        } catch (IllegalAccessException e) {
+            throw new RealmException("Could not initialize the Realm Object Server", e);
+        } catch (ClassNotFoundException e) {
+            throw new RealmException("Could not initialize the Realm Object Server", e);
+        }
+        if (applicationContext == null) {
+            applicationContext = context;
+
+            applicationContext.registerReceiver(new NetworkStateReceiver(),
+                    new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
+        }
+    }
+
+    @Override
+    public void notifyCommit(RealmConfiguration configuration, long lastSnapshotVersion) {
+        if (configuration instanceof SyncConfiguration) {
+            SyncSession publicSession = SyncManager.getSession((SyncConfiguration) configuration);
+            ObjectServerSession session = SessionStore.getPrivateSession(publicSession);
+            session.notifyCommit(lastSnapshotVersion);
+        } else {
+            throw new IllegalArgumentException(WRONG_TYPE_OF_CONFIGURATION);
+        }
+    }
+
+    @Override
+    public void realmClosed(RealmConfiguration configuration) {
+        if (configuration instanceof SyncConfiguration) {
+            SyncSession publicSession = SyncManager.getSession((SyncConfiguration) configuration);
+            ObjectServerSession session = SessionStore.getPrivateSession(publicSession);
+            session.getSyncPolicy().onRealmClosed(session);
+        } else {
+            throw new IllegalArgumentException(WRONG_TYPE_OF_CONFIGURATION);
+        }
+    }
+
+    @Override
+    public void realmOpened(RealmConfiguration configuration) {
+        if (configuration instanceof SyncConfiguration) {
+            SyncSession publicSession = SyncManager.getSession((SyncConfiguration) configuration);
+            ObjectServerSession session = SessionStore.getPrivateSession(publicSession);
+            session.getSyncPolicy().onRealmOpened(session);
+        } else {
+            throw new IllegalArgumentException(WRONG_TYPE_OF_CONFIGURATION);
+        }
+    }
+
+    @Override
+    public String[] getUserAndServerUrl(RealmConfiguration config) {
+        if (config instanceof SyncConfiguration) {
+            SyncConfiguration syncConfig = (SyncConfiguration) config;
+            String rosServerUrl = syncConfig.getServerUrl().toString();
+            String rosUserToken = syncConfig.getUser().getAccessToken();
+            return new String[]{rosServerUrl, rosUserToken};
+        } else {
+            return new String[2];
+        }
+    }
+
+    static Context getApplicationContext() {
+        return applicationContext;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncUtil.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncUtil.java
new file mode 100644
index 0000000000..9d6b8f1e23
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncUtil.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+/**
+ * Helper class for Object Server classes.
+ */
+public class SyncUtil {
+
+    /**
+     * Fully resolve an URL so all placeholder objects are replaced with the user identity.
+     */
+    public static URI getFullServerUrl(URI serverUrl, String userIdentity) {
+        try {
+            return new URI(serverUrl.toString().replace("/~/", "/" + userIdentity + "/"));
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException("Could not replace '/~/' with a valid user ID.", e);
+        }
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java
new file mode 100644
index 0000000000..78f0acfb04
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.Arrays;
+import java.util.Locale;
+
+/**
+ * This class represents a value from the Realm Authentication Server.
+ */
+public class Token {
+
+    private final String value;
+    private final long expiresSec;
+    private final Permission[] permissions;
+    private final String identity;
+    private final String path;
+
+    public static Token from(JSONObject token) throws JSONException {
+        String value = token.getString("token");
+        JSONObject tokenData = token.getJSONObject("token_data");
+        String identity = tokenData.getString("identity");
+        String path = tokenData.optString("path");
+        long expiresSec = tokenData.getLong("expires");
+        Permission[] permissions;
+        JSONArray access = tokenData.getJSONArray("access");
+        if (access != null) {
+            permissions = new Permission[access.length()];
+            for (int i = 0; i < access.length(); i++) {
+                try {
+                    permissions[i] = Permission.valueOf(access.getString(i));
+                } catch (IllegalArgumentException e) {
+                    permissions[i] = Permission.UNKNOWN;
+                }
+            }
+        } else {
+            permissions = new Permission[0];
+        }
+
+        return new Token(value, identity, path, expiresSec, permissions);
+    }
+
+    public Token(String value, String identity, String path, long expiresSec, Permission[] permissions) {
+        this.value = value;
+        this.identity = identity;
+        this.path = path;
+        this.expiresSec = expiresSec;
+        if (permissions != null) {
+            this.permissions = Arrays.copyOf(permissions, permissions.length);
+        } else {
+            this.permissions = new Permission[0];
+        }
+    }
+
+    public String value() {
+        return value;
+    }
+
+    public String identity() { return identity; }
+
+    public String path() { return path; }
+
+    /**
+     * Returns when this token expires. Timestamp is in UTC seconds.
+     */
+    public long expiresSec() {
+        return expiresSec;
+    }
+
+    /**
+     * Returns when this token expires. Timestamp is in UTC milliseconds.
+     */
+    public long expiresMs() {
+        long expiresMs = expiresSec * 1000;
+        if (expiresMs < expiresSec) {
+            return Long.MAX_VALUE; // Prevent overflow
+        } else {
+            return expiresMs;
+        }
+    }
+
+    public Permission[] permissions() {
+        return Arrays.copyOf(permissions, permissions.length);
+    }
+
+    public JSONObject toJson() {
+        JSONObject obj = new JSONObject();
+        try {
+            obj.put("token", value);
+            JSONObject tokenData = new JSONObject();
+            tokenData.put("identity", identity);
+            tokenData.put("path", path);
+            tokenData.put("expires", expiresSec);
+            JSONArray perms = new JSONArray();
+            for (int i = 0; i < permissions.length; i++) {
+                perms.put(permissions[i].toString().toLowerCase(Locale.US));
+            }
+            tokenData.put("access", perms);
+            obj.put("token_data", tokenData);
+            return obj;
+        } catch (JSONException e) {
+            throw new RuntimeException("Could not convert Token to JSON.", e);
+        }
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        Token token = (Token) o;
+
+        if (expiresSec != token.expiresSec) return false;
+        if (!value.equals(token.value)) return false;
+        if (!Arrays.equals(permissions, token.permissions)) return false;
+        if (!identity.equals(token.identity)) return false;
+        return path != null ? path.equals(token.path) : token.path == null;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = value.hashCode();
+        result = 31 * result + (int) (expiresSec ^ (expiresSec >>> 32));
+        result = 31 * result + Arrays.hashCode(permissions);
+        result = 31 * result + identity.hashCode();
+        result = 31 * result + (path != null ? path.hashCode() : 0);
+        return result;
+    }
+
+    public enum Permission {
+        UNKNOWN,
+        UPLOAD,
+        DOWNLOAD,
+        REFRESH,
+        MANAGE;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/UnboundState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/UnboundState.java
new file mode 100644
index 0000000000..3471357544
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/UnboundState.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import io.realm.ObjectServerError;
+import io.realm.SessionState;
+
+/**
+ * UNBOUND State. This is the default state after a session has been started and no attempt at binding the local Realm
+ * has been made.
+ */
+class UnboundState extends FsmState {
+
+    @Override
+    public void onEnterState() {
+        // We can enter this state from multiple states which might have had an active session.
+        // In those cases cleanup any old native session
+        session.stopNativeSession();
+
+        // Create the native session so it is ready to be bound.
+        session.createNativeSession();
+    }
+
+    @Override
+    protected void onExitState() {
+        // Do nothing.
+    }
+
+    @Override
+    public void onBind() {
+        gotoNextState(SessionState.BINDING);
+    }
+
+    @Override
+    public void onError(ObjectServerError error) {
+        // Ignore all errors at this state. None of them would have any impact.
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/AutomaticSyncPolicy.java b/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/AutomaticSyncPolicy.java
new file mode 100644
index 0000000000..fc01484223
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/AutomaticSyncPolicy.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.syncpolicy;
+
+import io.realm.ObjectServerError;
+import io.realm.internal.objectserver.ObjectServerSession;
+
+/**
+ * This SyncPolicy will automatically start synchronizing changes to a Realm as soon as it is opened.
+ */
+public class AutomaticSyncPolicy implements SyncPolicy {
+
+    private Long lastError = null;
+    private int recurringErrors = 0;
+
+    @Override
+    public void onRealmOpened(ObjectServerSession session) {
+        session.bind(); // Bind Realm first time it is opened.
+    }
+
+    @Override
+    public void onRealmClosed(ObjectServerSession session) {
+        // TODO In order to preserve resources we should ideally close the session as well, but first
+        // we want to make sure that all local changes have been synchronized to the remote Realm.
+    }
+
+    @Override
+    public void onSessionCreated(ObjectServerSession session) {
+        session.start();
+    }
+
+    @Override
+    public void onSessionStopped(ObjectServerSession session) {
+        // Do nothing
+    }
+
+    @Override
+    public boolean onError(ObjectServerSession session, ObjectServerError error) {
+        switch(error.getCategory()) {
+            case FATAL:
+                return false;   // Report all fatal errors to the user
+            case RECOVERABLE:
+                return rebind(session);
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Returns {@code true} if we decide to rebind, {@code false} if the error was determined to no longer be solvable.
+     */
+    private boolean rebind(ObjectServerSession session) {
+        // Track all calls to rebind(). If some error reported as RECOVERABLE keeps happening, we need to abort to
+        // prevent run-away sessions. Right now we treat an error as recurring if it happens within 3 seconds of each
+        // other. After 5 of such errors we terminate the session.
+        //
+        // Standard IO errors are already handled using incremental backoff by e.g the AUTHENTICATING state, so
+        // re-occurring errors at this level are more serious.
+        long now = System.currentTimeMillis();
+        if (lastError - now < 3000) {
+            recurringErrors++;
+        } else {
+            recurringErrors = 1;
+        }
+        lastError = now;
+
+        if (recurringErrors == 5) {
+            session.stop(); // Abort session, some error that should be temporary keeps happening.
+            return false;
+        } else {
+            session.bind();
+            return true;
+        }
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/SyncPolicy.java b/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/SyncPolicy.java
new file mode 100644
index 0000000000..ae14b6af3e
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/SyncPolicy.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.syncpolicy;
+
+import io.realm.ObjectServerError;
+import io.realm.SyncSession;
+import io.realm.SyncConfiguration;
+import io.realm.internal.objectserver.ObjectServerSession;
+
+/**
+ * Interface describing a given synchronization policy with the Realm Object Server.
+ * <p>
+ * The sole purpose of classes implementing this interface is to call {@link ObjectServerSession#bind()} and
+ * {@link ObjectServerSession#unbind()} as needed, which will control when changes are synchronized between a local and
+ * remote Realm.
+ *
+ * The SyncPolicy is not responsible for managing the lifecycle of the {@link ObjectServerSession} in general. So any
+ * implementation of this class should avoid calling {@link ObjectServerSession#stop()} and
+ * {@link ObjectServerSession#start()}.
+ *
+ * If a session is stopped, {@link ObjectServerSession#unbind()} is automatically called and any further calls to
+ * {@link ObjectServerSession#bind()} and {@link ObjectServerSession#unbind()} are ignored.
+ * {@link #onSessionStopped(ObjectServerSession)} ()} will then be called so the sync policy have a chance to clean up
+ * any resources it might be using.
+ */
+// Internal until we are sure this is the API we want
+public interface SyncPolicy {
+
+    /**
+     * Called when the session object is created. At this point it is possible to register any relevant error and event
+     * listeners in either the Android framework or for the session itself.
+     *
+     * {@link ObjectServerSession#start()} will be automatically called after this method.
+     *
+     * @param session the {@link SyncSession} just created. It has not yet been started.
+     */
+    void onSessionCreated(ObjectServerSession session);
+
+    /**
+     * The {@link ObjectServerSession} has been stopped and will ignore any further calls to
+     * {@link ObjectServerSession#bind()} and {@link ObjectServerSession#unbind()}. All external resources should be
+     * cleaned up.
+     *
+     * @param session {@link ObjectServerSession} that has been stopped.
+     */
+    void onSessionStopped(ObjectServerSession session);
+
+    /**
+     * Called the first time a Realm is opened on any thread.
+     *
+     * @param session {@link ObjectServerSession} associated with this Realm.
+     */
+    void onRealmOpened(ObjectServerSession session);
+
+    /**
+     * Called when the last Realm instance across all threads have been closed.
+     *
+     * @param session {@link ObjectServerSession} associated with this Realm.
+     */
+    void onRealmClosed(ObjectServerSession session);
+
+    /**
+     * Called if an error occurred in the underlying session. In many cases this has caused the session to become
+     * unbound.
+     *
+     * @param error {@link ObjectServerError} object describing the error.
+     * @return {@code true} if the error was handled, or {@code false} if it should be propagated further out to the
+     * SyncConfigurations error handler.
+     *
+     * This method is always called from a background thread, never the UI thread.
+     *
+     * @see SyncConfiguration.Builder#errorHandler(SyncSession.ErrorHandler)
+     */
+    boolean onError(ObjectServerSession session, ObjectServerError error);
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
new file mode 100644
index 0000000000..ccf997a3b8
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -0,0 +1,69 @@
+package io.realm.objectserver;
+
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.SyncCredentials;
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.Realm;
+import io.realm.SyncUser;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.HttpUtils;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class AuthTests {
+    @Rule
+    public RunInLooperThread looperThread = new RunInLooperThread();
+
+    @BeforeClass
+    public static void setUp () throws Exception {
+        Realm.init(InstrumentationRegistry.getContext());
+        HttpUtils.startSyncServer();
+    }
+
+    @AfterClass
+    public static void tearDown () throws Exception {
+        HttpUtils.stopSyncServer();
+    }
+
+    @Test
+    public void login_userNotExist() {
+        SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
+        try {
+            SyncUser.login(credentials, Constants.AUTH_URL);
+            fail();
+        } catch (ObjectServerError expected) {
+            assertEquals(ErrorCode.INVALID_CREDENTIALS, expected.getErrorCode());
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void loginAsync_userNotExist() {
+        SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
+        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
+            @Override
+            public void onSuccess(SyncUser user) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.INVALID_CREDENTIALS, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
new file mode 100644
index 0000000000..6e465f53f9
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Looper;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.Realm;
+import io.realm.RealmChangeListener;
+import io.realm.RealmResults;
+import io.realm.SyncConfiguration;
+import io.realm.objectserver.model.ProcessInfo;
+import io.realm.objectserver.model.TestObject;
+import io.realm.objectserver.service.SendOneCommit;
+import io.realm.objectserver.service.SendsALot;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.HttpUtils;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class ProcessCommitTests {
+    @BeforeClass
+    public static void setUp () throws Exception {
+        HttpUtils.startSyncServer();
+    }
+
+    @AfterClass
+    public static void tearDown () throws Exception {
+        HttpUtils.stopSyncServer();
+    }
+
+    // FIXME: At least need one method in the test class
+    @Test
+    public void dummy() {
+
+    }
+
+    // FIXME: Disable for now.
+    /*
+    @Test
+    public void expectServerCommit() throws Throwable {
+        final Throwable[] exception = new Throwable[1];
+        final CountDownLatch testFinished = new CountDownLatch(1);
+        ExecutorService service = Executors.newSingleThreadExecutor();
+        service.submit(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    Looper.prepare();
+                    Context targetContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+
+                    final SyncConfiguration syncConfig = new SyncConfiguration.Builder()
+                            .name(SendOneCommit.class.getSimpleName())
+                            .serverUrl(Constants.SYNC_SERVER_URL )
+                            .user(UserFactory.createDefaultUser(Constants.SYNC_SERVER_URL, Constants.USER_TOKEN))
+                            .build();
+                    Realm.deleteRealm(syncConfig);//TODO do this in Rule as async tests
+                    final Realm realm = Realm.getInstance(syncConfig);
+                    Intent intent = new Intent(targetContext, SendOneCommit.class);
+                    targetContext.startService(intent);
+
+                    final RealmResults<ProcessInfo> all = realm.where(ProcessInfo.class).findAll();
+                    all.addChangeListener(new RealmChangeListener<RealmResults<ProcessInfo>>() {
+                        @Override
+                        public void onChange(RealmResults<ProcessInfo> element) {
+                            assertEquals(1, all.size());
+                            assertEquals("Background_Process1", all.get(0).getName());
+                            testFinished.countDown();
+                        }
+                    });
+
+                    Looper.loop();
+
+                } catch (Throwable e) {
+                    exception[0] = e;
+                    testFinished.countDown();
+                }
+            }
+        });
+        boolean testTimedOut = testFinished.await(300, TimeUnit.SECONDS);
+        if (exception[0] != null) {
+            throw exception[0];
+        } else if (!testTimedOut) {
+            fail("Test timed out ");
+        }
+    }
+    */
+
+    //TODO send string from service and match
+    //     replicate integration tests from Cocoa
+    //     add gradle task to start the sh script automatically (create pid file, ==> run or kill existing process
+    //     check the requirement for the issue again
+    /*
+    @Test
+    public void expectALot() throws Throwable {
+        final Throwable[] exception = new Throwable[1];
+        final CountDownLatch testFinished = new CountDownLatch(1);
+        ExecutorService service = Executors.newSingleThreadExecutor();
+        service.submit(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    Looper.prepare();
+                    Context targetContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+
+                    final SyncConfiguration syncConfig = new SyncConfiguration.Builder(targetContext)
+                            .name(SendsALot.class.getSimpleName())
+                            .serverUrl(Constants.SYNC_SERVER_URL_2)
+                            .user(UserFactory.createDefaultUser(Constants.SYNC_SERVER_URL_2, Constants.USER_TOKEN))
+                            .build();
+                    Realm.deleteRealm(syncConfig);//TODO do this in Rule as async tests
+                    final Realm realm = Realm.getInstance(syncConfig);
+                    Intent intent = new Intent(targetContext, SendsALot.class);
+                    targetContext.startService(intent);
+
+                    final RealmResults<TestObject> all = realm.where(TestObject.class).findAllSorted("intProp");
+                    all.addChangeListener(new RealmChangeListener<RealmResults<TestObject>>() {
+                        @Override
+                        public void onChange(RealmResults<TestObject> element) {
+                            assertEquals(100, element.size());
+                            for (int i = 0; i < 100; i++) {
+                                assertEquals(i, element.get(i).getIntProp());
+                                assertEquals("property " + i, element.get(i).getStringProp());
+                            }
+
+                            testFinished.countDown();
+                        }
+                    });
+
+                    Looper.loop();
+
+                } catch (Throwable e) {
+                    exception[0] = e;
+                    testFinished.countDown();
+                }
+            }
+        });
+        boolean testTimedOut = testFinished.await(30, TimeUnit.SECONDS);
+        if (exception[0] != null) {
+            throw exception[0];
+        } else if (!testTimedOut) {
+            fail("Test timed out ");
+        }
+    }
+    */
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/ProcessInfo.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/ProcessInfo.java
new file mode 100644
index 0000000000..62e8ddcfcc
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/ProcessInfo.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.model;
+
+import io.realm.RealmObject;
+
+public class ProcessInfo extends RealmObject {
+    private String name;
+    private int pid;
+    private long threadId;
+
+    public int getPid() {
+        return pid;
+    }
+
+    public void setPid(int pid) {
+        this.pid = pid;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public long getThreadId() {
+        return threadId;
+    }
+
+    public void setThreadId(long threadId) {
+        this.threadId = threadId;
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/TestObject.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/TestObject.java
new file mode 100644
index 0000000000..2bd27a6ef8
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/TestObject.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.model;
+
+import io.realm.RealmObject;
+
+public class TestObject extends RealmObject {
+    private int intProp;
+    private String stringProp;
+
+    public int getIntProp() {
+        return intProp;
+    }
+
+    public void setIntProp(int intProp) {
+        this.intProp = intProp;
+    }
+
+    public String getStringProp() {
+        return stringProp;
+    }
+
+    public void setStringProp(String stringProp) {
+        this.stringProp = stringProp;
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendOneCommit.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendOneCommit.java
new file mode 100644
index 0000000000..26c4f89de6
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendOneCommit.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.service;
+
+import android.app.Service;
+import android.content.Intent;
+import android.os.IBinder;
+
+/**
+ * Open a sync Realm on a different process, then send one commit.
+ */
+public class SendOneCommit extends Service {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        // FIXME: Disable for now
+        /*
+        final SyncConfiguration syncConfig = new SyncConfiguration.Builder(this)
+                .name(SendOneCommit.class.getSimpleName())
+                .serverUrl(Constants.SYNC_SERVER_URL)
+                .user(UserFactory.createDefaultUser(Constants.SYNC_SERVER_URL, Constants.USER_TOKEN))
+                .build();
+        Realm.deleteRealm(syncConfig);
+        Realm realm = Realm.getInstance(syncConfig);
+
+        realm.beginTransaction();
+        ProcessInfo processInfo = realm.createObject(ProcessInfo.class);
+        processInfo.setName("Background_Process1");
+        processInfo.setPid(android.os.Process.myPid());
+        processInfo.setThreadId(Thread.currentThread().getId());
+        realm.commitTransaction();
+
+        realm.close();//FIXME the close may not give a chance to the sync client to process/upload the changeset
+        */
+    }
+
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return null;
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendsALot.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendsALot.java
new file mode 100644
index 0000000000..2bcdd9d717
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendsALot.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.service;
+
+import android.app.Service;
+import android.content.Intent;
+import android.os.IBinder;
+
+/**
+ * Open a sync Realm on a different process, then send one commit.
+ */
+public class SendsALot extends Service {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        // FIXME: Disable for now.
+        /*
+        User user = UserFactory.createDefaultUser(Constants.SYNC_SERVER_URL_2, Constants.USER_TOKEN);
+        final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user)
+                .name(SendsALot.class.getSimpleName())
+                .serverUrl(Constants.SYNC_SERVER_URL_2)
+                .user()
+                .build();
+        Realm.deleteRealm(syncConfig);
+        Realm realm = Realm.getInstance(syncConfig);
+
+        realm.beginTransaction();
+
+        for (int i = 0; i < 100; i++) {
+            TestObject testObject = realm.createObject(TestObject.class);
+            testObject.setIntProp(i);
+            testObject.setStringProp("property " + i);
+        }
+        realm.commitTransaction();
+
+        realm.close();//FIXME the close may not give a chance to the sync client to process/upload the changeset
+        */
+    }
+
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return null;
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
new file mode 100644
index 0000000000..e346c04c3c
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.utils;
+
+public class Constants {
+    // to generate a valid token follow the guide in
+    //<root>/integration-tests/sync/test_server/keys/HowToGenerateKey.txt
+    public static String USER_TOKEN = "ewogICJpZGVudGl0eSI6ICJ0ZXN0MiIsCiAgImFjY2VzcyI6IFsKICAgICJkb3dubG9hZCIsCiAgICAidXBsb2FkIgogIF0sCiAgInRpbWVzdGFtcCI6IDE0NTU1MzA2MTQsCiAgImV4cGlyZXMiOiBudWxsLAogICJhcHBfaWQiOiAiaW8ucmVhbG0udGVzdHMuc3luYyIKfQ=="
+            + ":" +
+            "mR0/GMc0b5XHFNJEM4D9fb94oXMjho0jKxopaU1lQW4FqY1QPBa/bPiVCMhAosZVSNhEP6vEZxVjFHAxoPODKoml1Ry78geKt5Iql395HRvO6KCCN0VkMpx2eXy+SzF2pcEjU5jlldbTAcO6nMyVaQ9g2XF2SZPVjBqpkY1cy2IjMHN0HRWy9SfGelwZY/jW72jZM7+89kWpIB0SmNH8kEPKVZlnRMW4KwNAUPA8P0/+qyoRTr/4l7k7N6z5kBxIKB/+m55AeOUDiFsxA53QPlpHGvF7ThZpiv8i+UhyKZcQlXi1utoj8H1CzpeU/YzrrEf3xrr2qCO3/niU5WdnHA==";
+    public static String SYNC_SERVER_URL = "realm://127.0.0.1:7800/tests";
+    public static String SYNC_SERVER_URL_2 = "realm://127.0.0.1:7800/tests2";
+
+    public static String AUTH_SERVER_URL = "http://127.0.0.1:8080/";
+    public static String AUTH_URL = AUTH_SERVER_URL + "auth";
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
new file mode 100644
index 0000000000..d2cf5bf6ed
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.utils;
+
+import java.io.IOException;
+
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+/**
+ * Start and Stop the node server responsible of creating a
+ * temp directory & start a sync server on it for each unit test.
+ */
+public class HttpUtils {
+    private final static OkHttpClient client = new OkHttpClient();
+    // adb reverse tcp:8888 tcp:8888
+    // will forward this query to the host, running the integration test server on 8888
+    private final static String START_SERVER = "http://127.0.0.1:8888/start";
+    private final static String STOP_SERVER = "http://127.0.0.1:8888/stop";
+
+    public static void startSyncServer() throws Exception {
+        Request request = new Request.Builder()
+                .url(START_SERVER)
+                .build();
+
+        Response response = client.newCall(request).execute();
+        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+        Headers responseHeaders = response.headers();
+        for (int i = 0; i < responseHeaders.size(); i++) {
+            System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+        }
+
+        System.out.println(response.body().string());
+
+        // FIXME: Server ready checking should be done in the control server side!
+        if (!waitAuthServerReady()) {
+            stopSyncServer();
+            throw new RuntimeException("Auth server cannot be started.");
+        }
+    }
+
+    // Checking the server
+    private static boolean waitAuthServerReady() throws InterruptedException {
+        int retryTimes = 20;
+        Request request = new Request.Builder()
+                .url(Constants.AUTH_SERVER_URL)
+                .build();
+
+        while (retryTimes != 0) {
+            try {
+                Response response = client.newCall(request).execute();
+                if (response.isSuccessful()) {
+                    return true;
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+                Thread.sleep(50);
+            }
+            retryTimes--;
+        }
+
+        return false;
+    }
+
+    public static void stopSyncServer() throws Exception {
+        Request request = new Request.Builder()
+                .url(STOP_SERVER)
+                .build();
+
+        Response response = client.newCall(request).execute();
+        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+        Headers responseHeaders = response.headers();
+        for (int i = 0; i < responseHeaders.size(); i++) {
+            System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+        }
+
+        System.out.println(response.body().string());
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
new file mode 100644
index 0000000000..1ebb2d6ab5
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.utils;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import io.realm.SyncUser;
+import io.realm.objectserver.utils.Constants;
+
+// Must be in `io.realm.objectserver` to work around package protected methods.
+public class UserFactory {
+    // FIXME: Not working right now.
+    /*
+    public static User createDefaultUser(String SERVER_URL, String USER_TOKEN) {
+        try {
+            User user = User.createLocal();
+
+            user.addAccessToken(new URI(SERVER_URL), USER_TOKEN);
+            return user;
+        } catch (URISyntaxException e) {
+            throw new RuntimeException(e);
+        }
+    }
+    */
+}
diff --git a/tools/sync_test_server/Dockerfile b/tools/sync_test_server/Dockerfile
new file mode 100644
index 0000000000..e659183e3b
--- /dev/null
+++ b/tools/sync_test_server/Dockerfile
@@ -0,0 +1,17 @@
+FROM ubuntu:16.04
+
+ARG ROS_DE_VERSION
+
+# Add realm repo
+RUN apt-get update -qq \
+    && apt-get install -y curl npm \
+    && curl -s https://packagecloud.io/install/repositories/realm/realm/script.deb.sh | bash \
+    && npm install winston temp httpdispatcher
+COPY keys/private.pem keys/public.pem configuration.yml /
+COPY ros-testing-server.js /usr/bin/
+# Install realm object server
+RUN apt-get update -qq \
+    && apt-get install -y realm-object-server-de=$ROS_DE_VERSION \
+    && apt-get clean
+
+CMD /usr/bin/ros-testing-server.js /tmp/ros-testing-server.log
diff --git a/tools/sync_test_server/configuration.yml b/tools/sync_test_server/configuration.yml
new file mode 100644
index 0000000000..6080a3beda
--- /dev/null
+++ b/tools/sync_test_server/configuration.yml
@@ -0,0 +1,227 @@
+# Realm Object Server Configuration
+#
+# For each possible setting, the commented out values are the default values
+# unless another default is mentioned explicitly.
+#
+# Paths specified in this file can be either absolute or relative.
+# Relative paths are relative to the current working directory.
+
+
+## ----------------------------------------------------------------------------
+## The following options are MANDATORY, either by providing them in this file,
+## or as command-line options:
+## - storage: root_path
+## - auth:public_key_path
+## - auth:private_key_path
+## ----------------------------------------------------------------------------
+
+
+storage:
+  ## The directory in which the realm server will store all its data files.
+  ## This configuration option is MANDATORY.
+  root_path: /var/realm/sync-services
+
+## ----------------------------------------------------------------------------
+
+auth:
+  ## The path to the public and private keys (in PEM format) that will be used
+  ## to validate identity tokens sent by clients.
+  ## These configuration options are MANDATORY.
+  public_key_path: /public.pem
+  private_key_path: /private.pem
+
+  database:
+    ## The path for the administration database synchronisation endpoint. Do NOT
+    ## change this unless asked by Realm Support.
+    # sync_uri_path: '/public/admin'
+
+  ttls:
+    ## The validity duration for Refresh Tokens. This should be a fairly high
+    ## value, typically ranging 12 hours - 3 days. This value is represented in
+    ## seconds. Default: 24 hours.
+    # refresh_token: 86400
+
+    ## The validity duration for Access Tokens. This should be a fairly small
+    ## number, especially if you are concerned with revocations being applied
+    ## quickly. This value is represented in seconds. Default: 1 minute.
+    # access_token: 60
+
+## ----------------------------------------------------------------------------
+
+proxy:
+  ## Network settings for the externally accessible proxy module.
+  ## This can be enabled for both HTTP and HTTPS traffic simultaneously, and
+  ## forwards traffic to the sync and services internal modules.
+  ## It is possible to disable and replace the proxy module by another reverse proxy.
+  ##
+  ## Note: The proxy module forwards traffic to the internal modules on the
+  ## addresses and ports they listen on (as configured in the `network' section below).
+  ##
+  ## Shown below is a diagram of the default network configuration:
+  ##
+  ##                                                                     +----------------------+
+  ##                                                                     |                      |
+  ##                                                                     |     Sync module      |
+  ##                                                                     |                      |
+  ##                                                                     |      (internal)      |
+  ##                                                                     |                      |
+  ##                                                                 +-> |  Defaults:           |
+  ## +----------------+             +---------------------------+    |   |   Listen: 127.0.0.1  |
+  ## |                |             |                           |    |   |   Ports:             |
+  ## |  Realm Client  +------+      |        Proxy module       |    |   |    WS: tcp/27800     |
+  ## |                |      |      |                           |    |   |                      |
+  ## +-----------------      |      |  (externally accessible)  |    |   +----------------------+
+  ##                         +----> |                           |    |
+  ##                                |  Defaults:                |    |
+  ##                         +----> |   Listen: 0.0.0.0         +----+
+  ##      +------------      |      |   Ports:                  |    |   +----------------------+
+  ##      |           |      |      |    HTTP & WS: tcp/9080    |    |   |                      |
+  ##      |  Browser  +------+      |    HTTPS & WSS: tcp/9443  |    |   |    Services module   |
+  ##      |           |             |                           |    |   |                      |
+  ##      +-----------+             +---------------------------+    |   |      (internal)      |
+  ##                                                                 +-> |                      |
+  ##                                                                     |  Defaults:           |
+  ##                            Note: The proxy module can be            |   Listen: 127.0.0.1  |
+  ##                                  replaced by NGINX or other         |    Ports:            |
+  ##                                  reverse proxies                    |     HTTP: tcp/27080  |
+  ##                                                                     |                      |
+  ##                                                                     +----------------------+
+
+  http:
+    ## Whether or not to enable the HTTP proxy module. It enables multiplexing requests
+    ## by forwarding incoming requests on a single port to all services.
+    # enable: true
+
+    ## The address/interface on which the HTTP proxy module should listen. This defaults
+    ## to 127.0.0.1. If you wish to listen on all available interfaces,
+    ## uncomment the following line.
+    listen_address: '0.0.0.0'
+
+    ## The port that the HTTP proxy module should bind to.
+    # listen_port: 9080
+
+  https:
+    ## Whether or not to enable the HTTPS proxy module. It enables multiplexing requests
+    ## by forwarding incoming requests on a single port to all services.
+    ## Note that even if it enabled, the HTTPS proxy will only start if supplied
+    ## with a valid pair of certificates through certificate_path and private_key_path below.
+    # enable: false
+
+    ## The path to the certificate and private keys (in PEM format) that will be used
+    ## to set up the HTTPS server accepting connections.
+    ## These configuration options are MANDATORY to start the HTTPS proxy module.
+    # certificate_path: 'keys/https-proxy.crt'
+    # private_key_path: 'keys/https-proxy.key'
+
+    ## The address/interface on which the HTTPS proxy module should listen. This defaults
+    ## to 127.0.0.1. If you wish to listen on all available interfaces,
+    ## uncomment the following line.
+    # listen_address: '0.0.0.0'
+
+    ## The port that the HTTPS proxy module should bind to.
+    # listen_port: 9443
+
+## ----------------------------------------------------------------------------
+
+network:
+  ## Network settings for internal modules, to which traffic is forwarded from
+  ## the proxy module. The proxy module will automatically forward traffic to the
+  ## internal modules on the ports they are configured to listen on in this section.
+
+  sync:
+    ## The address/interface on which the server should listen. This defaults
+    ## to 127.0.0.1. If you wish to listen on all available interfaces,
+    ## uncomment the following line.
+    listen_address: '0.0.0.0'
+
+    ## The port on which to listen. The Realm sync server uses port 27800 by
+    ## default. For most deployments, there should not be a need to change this.
+    listen_port: 7800
+
+  http:
+    ## The address/interface on which the server should listen for HTTP
+    ## services. This includes Dashboard and Authentication APIs.
+    ## This defaults to 127.0.0.1. If you wish to listen on all available
+    ## interfaces, uncomment the following line.
+    listen_address: '0.0.0.0'
+
+    ## The port on which to listen for incoming requests to the Dashboard
+    ## and authentication APIs. This defaults to 27080.
+    listen_port: 8080
+
+## ----------------------------------------------------------------------------
+
+  providers:
+    ## Providers of authentication tokens. Each provider has a configuration
+    ## object associated with it. If a provider is included here and its
+    ## configuration is valid, it will be enabled.
+
+    ## Possible providers: cloudkit, debug, facebook, realm, password
+    ## Providers 'realm' and 'password' are always enabled:
+    ## - The 'realm' provider is used to derive access tokens from a refresh token.
+    ## - The 'password' provider is required for the dashboard to work. It supports
+    ##   authentication through username/password and uses a PBKDF2 implementation.
+
+    ## This enables login via CloudKit's user record name.
+    # cloudkit:
+      ## The key ID retrieved when adding the public key derived from the
+      ## specified private_key_path in CloudKit's Server-to-Server Keys,
+      ## available through the API Access settings in the CloudKit dashboard.
+      # key_id: '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef'
+
+      ## The path to the certificate.
+      # private_key_path: 'cloudkit_eckey.pem'
+
+      ## The container identifier in reverse domain name notation.
+      # container: "iCloud.io.realm.exampleApp.ios"
+
+      ## The environment in which CloudKit should be used. The default is
+      ## 'development'. For the production deployment for apps on the AppStore
+      ## you must specify 'production'.
+      # environment: 'development'
+
+    ## This enables authentication via a Google Sign-In access token for a
+    ## specific app.
+    # google:
+      ## The client ID as retrieved when setting up the app in the Google
+      ## Developer Console.
+      # clientId: '012345678901-abcdefghijklmnopqrstvuvwxyz01234.apps.googleusercontent.com'
+
+    ## This enables authentication via a Facebook access token for a specific app.
+    ## This provider needs no configuration (uncommenting the next line enables it).
+    # facebook: {}
+
+## ----------------------------------------------------------------------------
+
+logging:
+  ## The logging level of the server.
+  ##
+  ## Note: This used to be an integer, but has been updated to be more
+  ## descriptive. The integer values are no longer supported.
+  ##
+  ## Possible values (from most to least verbose):
+  ##
+  ##   all: no filtering
+  ##   trace
+  ##   debug
+  ##   detail
+  ##   info: good for production (default)
+  ##   warn
+  ##   error
+  ##   fatal
+  ##   off: all output suppressed
+  level: 'all'
+
+  ## The file to which the synchronisation server should log. This should
+  ## be a writable path from the perspective of the user under which the
+  ## server runs. If no path is specified, the server will log to stdout.
+  path: '/tmp/realm-sync.log'
+
+## ----------------------------------------------------------------------------
+
+performance:
+  ## The maximum number of Realm files that the server will have open
+  ## concurrently (LRU cache). The default is 256.
+  ## Only change this option if directed to by Realm support.
+  # max_open_files: 256
+
diff --git a/tools/sync_test_server/keys/HowToGenerateKey.txt b/tools/sync_test_server/keys/HowToGenerateKey.txt
new file mode 100644
index 0000000000..c3db0e9188
--- /dev/null
+++ b/tools/sync_test_server/keys/HowToGenerateKey.txt
@@ -0,0 +1,18 @@
+// The Base64-encoded user token is generated by the following command:
+//     cat test_token.json | base64
+// The Base64-encoded signature is generated by the following command:
+//     cat test_token.json | openssl dgst -sha256 -binary -sign private.pem | base64
+// The two are concatenated with a ':'.
+// This token does not contain a "path" field, and therefore grants access to
+// all Realms.
+
+// Example:
+g_signed_test_user_token =
+ // cat test_token.json | base64
+"ewogICJpZGVudGl0eSI6ICJ0ZXN0IiwKICAiYWNjZXNzIjogWwogICAgImRvd25sb2FkIiwKICAgICJ1cGxvYWQiCiAgXSwKICAidGltZXN0YW1wIjogMTQ1NTUzMDYxNCwKICAiZXhwaXJlcyI6IG51bGwsCiAgImFwcF9pZCI6ICJpby5yZWFsbS50ZXN0cy5zeW5jIgp9"
++ ":"
+// cat test_token.json | openssl dgst -sha256 -binary -sign private.pem | base64
+"Y5+K3Y+wd+McaZx6rte1MQvKpHgy7NoTqTzgF3CnGKcosMT7PkG1M71rLsq9/Fcldn6G26Bn3kb0vnw93TS2Ox4wa0FMiObK+N7VNdI6p/+dG5bDjBhtW2AFd2P0nOUCvx39EIdLVnGr3JUidJZEZGzFyFOdZVpnmIAnHNDaOIPOXt4vnASJ/dBjUTkOlexOwSRKIK1hvkA1GO9zpvnG5EbnVG6LuVSRM93Hp0tzuFdesns19P827/FsdZATDA9TFlwVTIa7vHz0KbzolSXKvIiOr5XWC2NXyDFEowxwFHyCuXN52jk9kylagFDTBvXu1ddmDZjWxg9SinJzS4lsYA=="
+
+
+Reference https://github.com/realm/realm-sync/blob/master/test/test_sync.cpp#L65
\ No newline at end of file
diff --git a/tools/sync_test_server/keys/private.pem b/tools/sync_test_server/keys/private.pem
new file mode 100644
index 0000000000..e8f1a123c3
--- /dev/null
+++ b/tools/sync_test_server/keys/private.pem
@@ -0,0 +1,27 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEpAIBAAKCAQEAo65ZQ8mFIVk0ZB22bHdNuBr4G3K7SwfFlUhmBmjQFb2EdopA
+nmu/XdXn+Zw3pmYlzIxe+3RX9M4eh8luIil0J2Nlb7tHOPZQkQAiuuud8JQ9RTND
+ixUQTGS4YmhyQv+7LA9cjdaczD3Bf3Nw/yZQTQQqw7vsbTUJeAMz+6EFLeMj2Lxn
+ZVLP7ePezxaSpKiQ8mp7eurQrZIqmvEC1xp8a7XvkgtqnMBepauIBiw6Wlpin0lP
+D3P5uMtrP+z5MmQXpP/GOp6XjBlULMQAMH/V03WYMwnevzMWmKhF2apepnjd65nB
+h29iaFuiE8tYvKpJxmrsmoU+aOvMt3ZORxj7LQIDAQABAoIBAGfSlWh8EOgAT00Z
+07alTjTzVmECu25yNY/lZmG2ZhcEKVuPgkF6kt4Qap5XyqzPqjY+65iQSaJMg+0Z
+hbRBmx3I3HSs1BZ7lssCzQTHo10QinS0ealk6Pur/5DcM23wDGd8LvcBJGAg4/XV
+4dzWDqVreTzCnMsAk0r+rSB1GHXr0/jMiivPvUzvxpVRZ+dyGPdxUFBQivPGC7h8
+3VJRLj8zBFlf0az7xeVCGgZMAtiaJhhGtG2QCBKhk3mqlDmhIB6jTai+b+vnL1KK
+tTOOhMsYXIhJXYeE6H2aXNn7z53sKoiRq2Zptzfl9csbQ5yelbtZ05CRC+nzAscr
+XOl2BjkCgYEA0QYexhXsd9OA8vU+kfm1WyLZmGc1biK+RLqV+nhXzy1lRy1DdaOq
+6raNgaZ9xgX5zHLqxk+2s5+dWMfyvbUxDPhl7C6R0yLNuXzW2tjsy3T5AI8ApWrA
+STUOaamLyaqRt0VB8AVSco2bvHCVEjyY+Bc7RD0LHnDfBUSwobr+FrMCgYEAyHd+
+nGsWhqGEabtfZCS8f1f1PnS4jge5VY9PFjgSLT9K6KJv00tmG9PGRhKXgGiLs+DW
+0EHiwWIYpAGHVOvnndWIUsxo14Mg8cRfJlA/a87RrXMNu6I/4rGPRwHqeRauNWmu
+wuNSJZTul09UYo7iHqtiEFOxpSEufC4965QUlp8CgYA/9qZ+KYFWXdPNBX1jQE3e
+GLkLqTGxhVJCR/LTVfZRAOxILrLBEheggcKl1SQR8Aw0I0py6zvWldaZr345zXO4
+K19NOicHvFPGGkzJZa54yE/WeuxQsm0rOeAyN17+lILI2ZnG8Gn9ghYRQUZs8TxC
+VyGczS1U4Gdu/kkrBMTyfwKBgQCRYh//fqZ6gx7Ns2bt8LqHvBmO7wV9c9qUU3du
+zMFZ8UH5Tvy8hz0JR1/PJ+KZ7LgMfy4rIO07hFIMd1NXYjK6w8a3DamnSmEVFW5Q
+Efi8zeRA32UBRB0C4fTf8WLD6I/1Cq0Eh+nmeYlDUPQI+kjBJ1faMWhvMo5M3xhn
+BiCcTwKBgQC/oQ5R6avo15UK7Tituj9TqduLf4leGJwn3ht6GsAPNDENDJZJc30A
+wL+ghnvUieG1fz3OelZPx3Ber5QdNzhM8+24klevCLaCdF8alhg9nIEtWFrGpXEv
+RLZ4jP2FUo1XJDNqXK4l17slzdWzEs1jiB7ePLvpoiA+GVcL3Anmkg==
+-----END RSA PRIVATE KEY-----
diff --git a/tools/sync_test_server/keys/public.pem b/tools/sync_test_server/keys/public.pem
new file mode 100644
index 0000000000..8f81325947
--- /dev/null
+++ b/tools/sync_test_server/keys/public.pem
@@ -0,0 +1,9 @@
+-----BEGIN PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAo65ZQ8mFIVk0ZB22bHdN
+uBr4G3K7SwfFlUhmBmjQFb2EdopAnmu/XdXn+Zw3pmYlzIxe+3RX9M4eh8luIil0
+J2Nlb7tHOPZQkQAiuuud8JQ9RTNDixUQTGS4YmhyQv+7LA9cjdaczD3Bf3Nw/yZQ
+TQQqw7vsbTUJeAMz+6EFLeMj2LxnZVLP7ePezxaSpKiQ8mp7eurQrZIqmvEC1xp8
+a7XvkgtqnMBepauIBiw6Wlpin0lPD3P5uMtrP+z5MmQXpP/GOp6XjBlULMQAMH/V
+03WYMwnevzMWmKhF2apepnjd65nBh29iaFuiE8tYvKpJxmrsmoU+aOvMt3ZORxj7
+LQIDAQAB
+-----END PUBLIC KEY-----
diff --git a/tools/sync_test_server/keys/test_token.json b/tools/sync_test_server/keys/test_token.json
new file mode 100644
index 0000000000..8d043f2fb7
--- /dev/null
+++ b/tools/sync_test_server/keys/test_token.json
@@ -0,0 +1,11 @@
+{
+  "identity": "test2",
+  "access": [
+    "download",
+    "upload"
+  ],
+  "timestamp": 1455530614,
+  "expires": null,
+  "app_id": "io.realm.tests.sync"
+}
+
diff --git a/tools/sync_test_server/ros-testing-server.js b/tools/sync_test_server/ros-testing-server.js
new file mode 100755
index 0000000000..c182652c39
--- /dev/null
+++ b/tools/sync_test_server/ros-testing-server.js
@@ -0,0 +1,86 @@
+#!/usr/bin/env nodejs
+
+var winston = require('winston');//logging
+const temp = require('temp');
+const spawn = require('child_process').spawn;
+var http = require('http');
+var dispatcher = require('httpdispatcher');
+
+// Automatically track and cleanup files at exit
+temp.track();
+
+if (process. argv. length <= 2) {
+    console.log("Usage: " + __filename + " somefile.log");
+    process.exit(-1);
+}
+const logFile = process.argv[2];
+winston.level = 'debug';
+winston.add(winston.transports.File, { filename: logFile });
+
+const PORT = 8888;
+
+function handleRequest(request, response) {
+    try {
+        //log the request on console
+        winston.log(request.url);
+        //Disptach
+        dispatcher.dispatch(request, response);
+    } catch(err) {
+        console.log(err);
+    }
+}
+
+var syncServerChildProcess = null;
+
+function startRealmObjectServer() {
+    stopRealmObjectServer();
+    temp.mkdir('ros', function(err, path) {
+        if (!err) {
+            winston.info("Starting sync server in ", path);
+            syncServerChildProcess = spawn('realm-object-server',
+                    ['--root', path,
+                    '--configuration', '/configuration.yml']);
+            // local config:
+            syncServerChildProcess.stdout.on('data', (data) => {
+                winston.info(`stdout: ${data}`);
+            });
+
+            syncServerChildProcess.stderr.on('data', (data) => {
+                winston.info(`stderr: ${data}`);
+            });
+
+            syncServerChildProcess.on('close', (code) => {
+                winston.info(`child process exited with code ${code}`);
+            });
+        }
+    });
+}
+
+function stopRealmObjectServer() {
+    if (syncServerChildProcess) {
+        syncServerChildProcess.kill();
+        syncServerChildProcess = null;
+    }
+}
+
+
+// start sync server
+dispatcher.onGet("/start", function(req, res) {
+    startRealmObjectServer();
+    res.writeHead(200, {'Content-Type': 'text/plain'});
+    res.end('Starting a server');
+});
+
+// stop a previously started sync server
+dispatcher.onGet("/stop", function(req, res) {
+    stopRealmObjectServer();
+    winston.info("Sync server stopped");
+    res.writeHead(200, {'Content-Type': 'text/plain'});
+    res.end('Stopping the server');
+});
+
+//Create and start the Http server
+var server = http.createServer(handleRequest);
+server.listen(PORT, function() {
+    winston.info("Integration test server listening on: 127.0.0.1:%s", PORT);
+});
diff --git a/tools/sync_test_server/start_server.sh b/tools/sync_test_server/start_server.sh
new file mode 100755
index 0000000000..00930f5eb1
--- /dev/null
+++ b/tools/sync_test_server/start_server.sh
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+# Get the script dir which contains the Dockerfile
+DOCKERFILE_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
+
+ROS_DE_VERSION=$(grep REALM_OBJECT_SERVER_DE_VERSION $DOCKERFILE_DIR/../../dependencies.list | cut -d'=' -f2)
+
+TMP_DIR=$(mktemp -d /tmp/sync-test.XXXX) || { echo "Failed to mktemp $TEST_TEMP_DIR" ; exit 1 ; }
+
+adb reverse tcp:7800 tcp:7800 && \
+adb reverse tcp:8080 tcp:8080 && \
+adb reverse tcp:8888 tcp:8888 || { echo "Failed to reverse adb port." ; exit 1 ; }
+
+docker build $DOCKERFILE_DIR --build-arg ROS_DE_VERSION=$ROS_DE_VERSION -t sync-test-server || { echo "Failed to build Docker image." ; exit 1 ; }
+
+echo "See log files in $TMP_DIR"
+docker run -p 8080:8080 -p 7800:7800 -p 8888:8888 -v$TMP_DIR:/tmp --name sync-test-server sync-test-server
diff --git a/tools/sync_test_server/stop_server.sh b/tools/sync_test_server/stop_server.sh
new file mode 100755
index 0000000000..6dd95f1fb4
--- /dev/null
+++ b/tools/sync_test_server/stop_server.sh
@@ -0,0 +1,4 @@
+#!/bin/sh
+
+docker stop sync-test-server -t0
+docker rm sync-test-server
diff --git a/version.txt b/version.txt
index 6753471d56..31941db520 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-2.0.0-SNAPSHOT
+2.2.0-SNAPSHOT
