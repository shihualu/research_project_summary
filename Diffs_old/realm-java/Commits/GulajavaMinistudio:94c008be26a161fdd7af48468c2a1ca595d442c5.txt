diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 474c39cc8f..b0ad1ef915 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -51,14 +51,14 @@
 public class ClassMetaData {
 
     private final TypeElement classType; // Reference to model class.
-    private String className; // Model class simple name.
+    private final String className; // Model class simple name.
+    private final List<VariableElement> fields = new ArrayList<VariableElement>(); // List of all fields in the class except those @Ignored.
+    private final List<VariableElement> indexedFields = new ArrayList<VariableElement>(); // list of all fields marked @Index.
+    private final Set<Backlink> backlinks = new HashSet<Backlink>();
+    private final Set<VariableElement> nullableFields = new HashSet<VariableElement>(); // Set of fields which can be nullable
     private String packageName; // package name for model class.
     private boolean hasDefaultConstructor; // True if model has a public no-arg constructor.
     private VariableElement primaryKey; // Reference to field used as primary key, if any.
-    private List<VariableElement> fields = new ArrayList<VariableElement>(); // List of all fields in the class except those @Ignored.
-    private List<VariableElement> indexedFields = new ArrayList<VariableElement>(); // list of all fields marked @Index.
-    private Set<Backlink> backlinks = new HashSet<Backlink>();
-    private Set<VariableElement> nullableFields = new HashSet<VariableElement>(); // Set of fields which can be nullable
     private boolean containsToString;
     private boolean containsEquals;
     private boolean containsHashCode;
@@ -117,7 +117,7 @@ public String getFullyQualifiedClassName() {
     }
 
     public Set<Backlink> getBacklinkFields() {
-        return backlinks;
+        return Collections.unmodifiableSet(backlinks);
     }
 
     public String getInternalGetter(String fieldName) {
@@ -129,7 +129,7 @@ public String getInternalSetter(String fieldName) {
     }
 
     public List<VariableElement> getIndexedFields() {
-        return indexedFields;
+        return Collections.unmodifiableList(indexedFields);
     }
 
     public boolean hasPrimaryKey() {
@@ -182,10 +182,7 @@ public boolean isIndexed(VariableElement variableElement) {
      * @return {@code true} if a VariableElement is primary key, {@code false} otherwise.
      */
     public boolean isPrimaryKey(VariableElement variableElement) {
-        if (primaryKey == null) {
-            return false;
-        }
-        return primaryKey.equals(variableElement);
+        return primaryKey != null && primaryKey.equals(variableElement);
     }
 
     /**
@@ -195,10 +192,7 @@ public boolean isPrimaryKey(VariableElement variableElement) {
      */
     public boolean isModelClass() {
         String type = classType.toString();
-        if (type.equals("io.realm.DynamicRealmObject")) {
-            return false;
-        }
-        return (!type.endsWith(".RealmObject") && !type.endsWith("RealmProxy"));
+        return !type.equals("io.realm.DynamicRealmObject") && !type.endsWith(".RealmObject") && !type.endsWith("RealmProxy");
     }
 
     /**
@@ -404,20 +398,20 @@ private boolean categorizeField(Element element) {
     private boolean categorizeIndexField(Element element, VariableElement variableElement) {
         // The field has the @Index annotation. It's only valid for column types:
         // STRING, DATE, INTEGER, BOOLEAN
-        String elementTypeCanonicalName = variableElement.asType().toString();
-        String columnType = Constants.JAVA_TO_COLUMN_TYPES.get(elementTypeCanonicalName);
-        if (columnType != null &&
-                (columnType.equals("RealmFieldType.STRING") ||
-                        columnType.equals("RealmFieldType.DATE") ||
-                        columnType.equals("RealmFieldType.INTEGER") ||
-                        columnType.equals("RealmFieldType.BOOLEAN"))) {
-            indexedFields.add(variableElement);
-        } else {
-            Utils.error(String.format("Field \"%s\" of type \"%s\" cannot be an @Index.", element, element.asType()));
-            return false;
+        Constants.RealmFieldType realmType = Constants.JAVA_TO_REALM_TYPES.get(variableElement.asType().toString());
+        if (realmType != null) {
+            switch (realmType) {
+                case STRING:
+                case DATE:
+                case INTEGER:
+                case BOOLEAN:
+                    indexedFields.add(variableElement);
+                    return true;
+            }
         }
 
-        return true;
+        Utils.error(String.format("Field \"%s\" of type \"%s\" cannot be an @Index.", element, element.asType()));
+        return false;
     }
 
     // The field has the @Required annotation
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
index 4cd364a843..2daa18769a 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
@@ -16,6 +16,7 @@
 
 package io.realm.processor;
 
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -37,73 +38,75 @@
     static final String STATEMENT_EXCEPTION_ILLEGAL_JSON_LOAD =
             "throw new io.realm.exceptions.RealmException(\"\\\"%s\\\" field \\\"%s\\\" cannot be loaded from json\")";
 
-    static final Map<String, String> JAVA_TO_REALM_TYPES;
 
-    static {
-        JAVA_TO_REALM_TYPES = new HashMap<String, String>();
-        JAVA_TO_REALM_TYPES.put("byte", "Long");
-        JAVA_TO_REALM_TYPES.put("short", "Long");
-        JAVA_TO_REALM_TYPES.put("int", "Long");
-        JAVA_TO_REALM_TYPES.put("long", "Long");
-        JAVA_TO_REALM_TYPES.put("float", "Float");
-        JAVA_TO_REALM_TYPES.put("double", "Double");
-        JAVA_TO_REALM_TYPES.put("boolean", "Boolean");
-        JAVA_TO_REALM_TYPES.put("java.lang.Byte", "Long");
-        JAVA_TO_REALM_TYPES.put("java.lang.Short", "Long");
-        JAVA_TO_REALM_TYPES.put("java.lang.Integer", "Long");
-        JAVA_TO_REALM_TYPES.put("java.lang.Long", "Long");
-        JAVA_TO_REALM_TYPES.put("java.lang.Float", "Float");
-        JAVA_TO_REALM_TYPES.put("java.lang.Double", "Double");
-        JAVA_TO_REALM_TYPES.put("java.lang.Boolean", "Boolean");
-        JAVA_TO_REALM_TYPES.put("java.lang.String", "String");
-        JAVA_TO_REALM_TYPES.put("java.util.Date", "Date");
-        JAVA_TO_REALM_TYPES.put("byte[]", "BinaryByteArray");
-        // TODO: add support for char and Char
-    }
+    /**
+     * Realm types and their corresponding Java types
+     */
+    public enum RealmFieldType {
+        NOTYPE(null, "Void"),
+        INTEGER("INTEGER", "Long"),
+        FLOAT("FLOAT", "Float"),
+        DOUBLE("DOUBLE", "Double"),
+        BOOLEAN("BOOLEAN", "Boolean"),
+        STRING("STRING", "String"),
+        DATE("DATE", "Date"),
+        BINARY("BINARY", "BinaryByteArray"),
+        OBJECT("OBJECT", "Object"),
+        LIST("LIST", "List"),
+        BACKLINK("BACKLINK", null);
 
-    static final Map<String, String> JAVA_TO_COLUMN_TYPES;
+        private final String realmType;
+        private final String javaType;
 
-    static {
-        JAVA_TO_COLUMN_TYPES = new HashMap<String, String>();
-        JAVA_TO_COLUMN_TYPES.put("byte", "RealmFieldType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("short", "RealmFieldType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("int", "RealmFieldType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("long", "RealmFieldType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("float", "RealmFieldType.FLOAT");
-        JAVA_TO_COLUMN_TYPES.put("double", "RealmFieldType.DOUBLE");
-        JAVA_TO_COLUMN_TYPES.put("boolean", "RealmFieldType.BOOLEAN");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.Byte", "RealmFieldType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.Short", "RealmFieldType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.Integer", "RealmFieldType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.Long", "RealmFieldType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.Float", "RealmFieldType.FLOAT");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.Double", "RealmFieldType.DOUBLE");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.Boolean", "RealmFieldType.BOOLEAN");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.String", "RealmFieldType.STRING");
-        JAVA_TO_COLUMN_TYPES.put("java.util.Date", "RealmFieldType.DATE");
-        JAVA_TO_COLUMN_TYPES.put("byte[]", "RealmFieldType.BINARY");
+        /**
+         * @param realmType The simple name of the Enum type used in the Java bindings, to represent this type.
+         * @param javaType The simple name of the Java type needed to store this Realm Type
+         */
+        RealmFieldType(String realmType, String javaType) {
+            this.realmType = "RealmFieldType." + realmType;
+            this.javaType = javaType;
+        }
+
+        /**
+         * Get the name of the enum, used in the Java bindings, used to represent the corresponding type.
+         * @return the name of the enum used to represent this Realm Type
+         */
+        public String getRealmType() {
+            return realmType;
+        }
+
+        /**
+         * Get the name of the Java type needed to store this Realm Type
+         * @return the simple name for the corresponding Java type
+         */
+        public String getJavaType() {
+            return javaType;
+        }
     }
 
-    static final Map<String, String> JAVA_TO_FIELD_SETTER;
+
+    static final Map<String, RealmFieldType> JAVA_TO_REALM_TYPES;
 
     static {
-        JAVA_TO_FIELD_SETTER = new HashMap<String, String>();
-        JAVA_TO_FIELD_SETTER.put("byte", "setByte");
-        JAVA_TO_FIELD_SETTER.put("short", "setShort");
-        JAVA_TO_FIELD_SETTER.put("int", "setInt");
-        JAVA_TO_FIELD_SETTER.put("long", "setLong");
-        JAVA_TO_FIELD_SETTER.put("float", "setFloat");
-        JAVA_TO_FIELD_SETTER.put("double", "setDouble");
-        JAVA_TO_FIELD_SETTER.put("boolean", "setBoolean");
-        JAVA_TO_FIELD_SETTER.put("java.lang.Byte", "set");
-        JAVA_TO_FIELD_SETTER.put("java.lang.Short", "set");
-        JAVA_TO_FIELD_SETTER.put("java.lang.Integer", "set");
-        JAVA_TO_FIELD_SETTER.put("java.lang.Long", "set");
-        JAVA_TO_FIELD_SETTER.put("java.lang.Float", "set");
-        JAVA_TO_FIELD_SETTER.put("java.lang.Double", "set");
-        JAVA_TO_FIELD_SETTER.put("java.lang.Boolean", "set");
-        JAVA_TO_FIELD_SETTER.put("java.lang.String", "set");
-        JAVA_TO_FIELD_SETTER.put("java.util.Date", "set");
-        JAVA_TO_FIELD_SETTER.put("byte[]", "set");
+        Map<String, RealmFieldType> m = new HashMap<String, RealmFieldType>();
+        m.put("byte", RealmFieldType.INTEGER);
+        m.put("short", RealmFieldType.INTEGER);
+        m.put("int", RealmFieldType.INTEGER);
+        m.put("long", RealmFieldType.INTEGER);
+        m.put("float", RealmFieldType.FLOAT);
+        m.put("double", RealmFieldType.DOUBLE);
+        m.put("boolean", RealmFieldType.BOOLEAN);
+        m.put("java.lang.Byte", RealmFieldType.INTEGER);
+        m.put("java.lang.Short", RealmFieldType.INTEGER);
+        m.put("java.lang.Integer", RealmFieldType.INTEGER);
+        m.put("java.lang.Long", RealmFieldType.INTEGER);
+        m.put("java.lang.Float", RealmFieldType.FLOAT);
+        m.put("java.lang.Double", RealmFieldType.DOUBLE);
+        m.put("java.lang.Boolean", RealmFieldType.BOOLEAN);
+        m.put("java.lang.String", RealmFieldType.STRING);
+        m.put("java.util.Date", RealmFieldType.DATE);
+        m.put("byte[]", RealmFieldType.BINARY);
+        // TODO: add support for char and Char
+        JAVA_TO_REALM_TYPES = Collections.unmodifiableMap(m);
     }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 6cb95cc33d..aff0f62628 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -109,7 +109,7 @@ public void generate() throws IOException, UnsupportedOperationException {
                 interfaceName)
                 .emitEmptyLine();
 
-        emitColumnIndicesClass(writer);
+        emitColumnInfoClass(writer);
 
         emitClassFields(writer);
         emitConstructor(writer);
@@ -141,75 +141,73 @@ public void generate() throws IOException, UnsupportedOperationException {
         writer.close();
     }
 
-    private void emitColumnIndicesClass(JavaWriter writer) throws IOException {
+    private void emitColumnInfoClass(JavaWriter writer) throws IOException {
         writer.beginType(
                 columnInfoClassName(),                       // full qualified name of the item to generate
                 "class",                                     // the type of the item
                 EnumSet.of(Modifier.STATIC, Modifier.FINAL), // modifiers to apply
-                "ColumnInfo",                                // base class
-                "Cloneable")                                 // interfaces
-                .emitEmptyLine();
+                "ColumnInfo");                               // base class
 
         // fields
         for (VariableElement variableElement : metadata.getFields()) {
-            writer.emitField("long", columnIndexVarName(variableElement),
-                    EnumSet.of(Modifier.PUBLIC));
+            writer.emitField("long", columnIndexVarName(variableElement));
         }
         writer.emitEmptyLine();
 
-        // constructor
-        writer.beginConstructor(EnumSet.noneOf(Modifier.class),
-                "String", "path",
-                "Table", "table");
-        writer.emitStatement("final Map<String, Long> indicesMap = new HashMap<String, Long>(%s)",
-                metadata.getFields().size());
-        for (VariableElement variableElement : metadata.getFields()) {
-            final String columnName = variableElement.getSimpleName().toString();
-            final String columnIndexVarName = columnIndexVarName(variableElement);
-            writer.emitStatement("this.%s = getValidColumnIndex(path, table, \"%s\", \"%s\")",
-                    columnIndexVarName, simpleClassName, columnName)
-                    .emitStatement("indicesMap.put(\"%s\", this.%s)", columnName, columnIndexVarName);
+        // constructor #1
+        writer.beginConstructor(
+                EnumSet.noneOf(Modifier.class),
+                "SharedRealm", "realm", "Table", "table");
+        writer.emitStatement("super(%s)", metadata.getFields().size());
+        for (VariableElement field : metadata.getFields()) {
+            writer.emitStatement(
+                    "this.%1$sIndex = addColumnDetails(table, \"%1$s\", %2$s)",
+                    field.getSimpleName().toString(), getRealmTypeChecked(field).getRealmType());
         }
+        for (Backlink backlink : metadata.getBacklinkFields()) {
+            writer.emitStatement(
+                    "addBacklinkDetails(realm, \"%1$s\", \"%2$s\", \"%3$s\")",
+                    backlink.getTargetField(), Utils.stripPackage(backlink.getSourceClass()), backlink.getSourceField());
+        }
+        writer.endConstructor()
+                .emitEmptyLine();
 
-        writer.emitEmptyLine()
-                .emitStatement("setIndicesMap(indicesMap)");
+        // constructor #2
+        writer.beginConstructor(
+                EnumSet.noneOf(Modifier.class),
+                "ColumnInfo", "src", "boolean", "mutable");
+        writer.emitStatement("super(src, mutable)")
+                .emitStatement("copy(src, this)");
         writer.endConstructor()
                 .emitEmptyLine();
 
-        // copyColumnInfoFrom method
+        // no-args copy method
         writer.emitAnnotation("Override")
                 .beginMethod(
-                        "void",                      // return type
-                        "copyColumnInfoFrom",        // method name
-                        EnumSet.of(Modifier.PUBLIC, Modifier.FINAL), // modifiers
-                        "ColumnInfo", "other");      // parameters
-        {
-            writer.emitStatement("final %1$s otherInfo = (%1$s) other", columnInfoClassName());
-
-            // copy field values
-            for (VariableElement variableElement : metadata.getFields()) {
-                writer.emitStatement("this.%1$s = otherInfo.%1$s", columnIndexVarName(variableElement));
-            }
-            writer.emitEmptyLine()
-                    .emitStatement("setIndicesMap(otherInfo.getIndicesMap())");
-        }
+                        "ColumnInfo",                                   // return type
+                        "copy",                                         // method name
+                        EnumSet.of(Modifier.PROTECTED, Modifier.FINAL), // modifiers
+                        "boolean", "mutable");     // parameters
+        writer.emitStatement("return new %s(this, mutable)", columnInfoClassName());
         writer.endMethod()
                 .emitEmptyLine();
 
-        // clone method
-        //@formatter:off
+        // copy method
         writer.emitAnnotation("Override")
-            .beginMethod(
-                columnInfoClassName(),       // return type
-                "clone",                     // method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.FINAL)) // modifiers
-                // method body
-                .emitStatement("return (%1$s) super.clone()", columnInfoClassName())
-                .endMethod()
-                .emitEmptyLine();
-        //@formatter:on
+                .beginMethod(
+                        "void",                                          // return type
+                        "copy",                                          // method name
+                        EnumSet.of(Modifier.PROTECTED, Modifier.FINAL),  // modifiers
+                        "ColumnInfo", "rawSrc", "ColumnInfo", "rawDst"); // parameters
+        writer.emitStatement("final %1$s src = (%1$s) rawSrc", columnInfoClassName());
+        writer.emitStatement("final %1$s dst = (%1$s) rawDst", columnInfoClassName());
+        for (VariableElement variableElement : metadata.getFields()) {
+            writer.emitStatement("dst.%1$s = src.%1$s", columnIndexVarName(variableElement));
+        }
+        writer.endMethod();
 
-        writer.endType();
+        writer.endType()
+                .emitEmptyLine();
     }
 
     private void emitClassFields(JavaWriter writer) throws IOException {
@@ -232,14 +230,14 @@ private void emitClassFields(JavaWriter writer) throws IOException {
 
         //@formatter:off
         writer.emitField("List<String>", "FIELD_NAMES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL))
-            .beginInitializer(true)
-            .emitStatement("List<String> fieldNames = new ArrayList<String>()");
+                .beginInitializer(true)
+                .emitStatement("List<String> fieldNames = new ArrayList<String>()");
         for (VariableElement field : metadata.getFields()) {
             writer.emitStatement("fieldNames.add(\"%s\")", field.getSimpleName().toString());
         }
         writer.emitStatement("FIELD_NAMES = Collections.unmodifiableList(fieldNames)")
-            .endInitializer()
-            .emitEmptyLine();
+                .endInitializer()
+                .emitEmptyLine();
         //@formatter:on
     }
 
@@ -247,9 +245,9 @@ private void emitClassFields(JavaWriter writer) throws IOException {
     private void emitConstructor(JavaWriter writer) throws IOException {
         // FooRealmProxy(ColumnInfo)
         writer.beginConstructor(EnumSet.noneOf(Modifier.class))
-            .emitStatement("proxyState.setConstructionFinished()")
-            .endConstructor()
-            .emitEmptyLine();
+                .emitStatement("proxyState.setConstructionFinished()")
+                .endConstructor()
+                .emitEmptyLine();
     }
     //@formatter:on
 
@@ -281,20 +279,21 @@ private void emitPrimitiveType(
             final VariableElement field,
             final String fieldName,
             String fieldTypeCanonicalName) throws IOException {
-        final String realmType = Constants.JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
+
+        final String fieldJavaType = getRealmTypeChecked(field).getJavaType();
 
         // Getter
         //@formatter:off
         writer.emitAnnotation("Override");
         writer.emitAnnotation("SuppressWarnings", "\"cast\"")
-            .beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
-            .emitStatement("proxyState.getRealm$realm().checkIfValid()");
+                .beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
+                .emitStatement("proxyState.getRealm$realm().checkIfValid()");
 
         // For String and bytes[], null value will be returned by JNI code. Try to save one JNI call here.
         if (metadata.isNullable(field) && !Utils.isString(field) && !Utils.isByteArray(field)) {
             writer.beginControlFlow("if (proxyState.getRow$realm().isNull(%s))", fieldIndexVariableReference(field))
-                .emitStatement("return null")
-                .endControlFlow();
+                    .emitStatement("return null")
+                    .endControlFlow();
         }
         //@formatter:on
 
@@ -308,7 +307,7 @@ private void emitPrimitiveType(
         }
         writer.emitStatement(
                 "return (%s) proxyState.getRow$realm().get%s(%s)",
-                castingBackType, realmType, fieldIndexVariableReference(field));
+                castingBackType, fieldJavaType, fieldIndexVariableReference(field));
         writer.endMethod()
                 .emitEmptyLine();
 
@@ -324,20 +323,20 @@ public void emit(JavaWriter writer) throws IOException {
                 //@formatter:off
                 if (metadata.isNullable(field)) {
                     writer.beginControlFlow("if (value == null)")
-                        .emitStatement("row.getTable().setNull(%s, row.getIndex(), true)",
-                            fieldIndexVariableReference(field))
-                        .emitStatement("return")
-                        .endControlFlow();
+                            .emitStatement("row.getTable().setNull(%s, row.getIndex(), true)",
+                                    fieldIndexVariableReference(field))
+                            .emitStatement("return")
+                            .endControlFlow();
                 } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
                     writer.beginControlFlow("if (value == null)")
-                        .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
-                        .endControlFlow();
+                            .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
+                            .endControlFlow();
                 }
                 //@formatter:on
 
                 writer.emitStatement(
                         "row.getTable().set%s(%s, row.getIndex(), value, true)",
-                        realmType, fieldIndexVariableReference(field));
+                        fieldJavaType, fieldIndexVariableReference(field));
                 writer.emitStatement("return");
             }
         });
@@ -351,20 +350,20 @@ public void emit(JavaWriter writer) throws IOException {
             //@formatter:off
             if (metadata.isNullable(field)) {
                 writer.beginControlFlow("if (value == null)")
-                    .emitStatement("proxyState.getRow$realm().setNull(%s)", fieldIndexVariableReference(field))
-                    .emitStatement("return")
-                    .endControlFlow();
+                        .emitStatement("proxyState.getRow$realm().setNull(%s)", fieldIndexVariableReference(field))
+                        .emitStatement("return")
+                        .endControlFlow();
             } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
                 // Same reason, throw IAE earlier.
                 writer
-                    .beginControlFlow("if (value == null)")
-                    .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
-                    .endControlFlow();
+                        .beginControlFlow("if (value == null)")
+                        .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
+                        .endControlFlow();
             }
             //@formatter:on
             writer.emitStatement(
                     "proxyState.getRow$realm().set%s(%s, value)",
-                    realmType, fieldIndexVariableReference(field));
+                    fieldJavaType, fieldIndexVariableReference(field));
         }
         writer.endMethod();
     }
@@ -374,23 +373,22 @@ public void emit(JavaWriter writer) throws IOException {
      */
     //@formatter:off
     private void emitRealmModel(
-        JavaWriter writer,
-        final VariableElement field,
-        String fieldName,
-        String fieldTypeCanonicalName) throws IOException
-    {
+            JavaWriter writer,
+            final VariableElement field,
+            String fieldName,
+            String fieldTypeCanonicalName) throws IOException {
 
         // Getter
         writer.emitAnnotation("Override");
         writer.beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
-            .emitStatement("proxyState.getRealm$realm().checkIfValid()")
-            .beginControlFlow("if (proxyState.getRow$realm().isNullLink(%s))", fieldIndexVariableReference(field))
+                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
+                .beginControlFlow("if (proxyState.getRow$realm().isNullLink(%s))", fieldIndexVariableReference(field))
                 .emitStatement("return null")
-            .endControlFlow()
-            .emitStatement("return proxyState.getRealm$realm().get(%s.class, proxyState.getRow$realm().getLink(%s), false, Collections.<String>emptyList())",
-                fieldTypeCanonicalName, fieldIndexVariableReference(field))
-            .endMethod()
-            .emitEmptyLine();
+                .endControlFlow()
+                .emitStatement("return proxyState.getRealm$realm().get(%s.class, proxyState.getRow$realm().getLink(%s), false, Collections.<String>emptyList())",
+                        fieldTypeCanonicalName, fieldIndexVariableReference(field))
+                .endMethod()
+                .emitEmptyLine();
 
         // Setter
         writer.emitAnnotation("Override");
@@ -400,44 +398,44 @@ private void emitRealmModel(
             public void emit(JavaWriter writer) throws IOException {
                 // check excludeFields
                 writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
-                    field.getSimpleName().toString())
-                    .emitStatement("return")
-                    .endControlFlow();
+                        field.getSimpleName().toString())
+                        .emitStatement("return")
+                        .endControlFlow();
                 writer.beginControlFlow("if (value != null && !RealmObject.isManaged(value))")
-                    .emitStatement("value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value)")
-                    .endControlFlow();
+                        .emitStatement("value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value)")
+                        .endControlFlow();
 
                 // set value as default value
                 writer.emitStatement("final Row row = proxyState.getRow$realm()");
                 writer.beginControlFlow("if (value == null)")
-                    .emitSingleLineComment("Table#nullifyLink() does not support default value. Just using Row.")
-                    .emitStatement("row.nullifyLink(%s)", fieldIndexVariableReference(field))
-                    .emitStatement("return")
-                    .endControlFlow();
+                        .emitSingleLineComment("Table#nullifyLink() does not support default value. Just using Row.")
+                        .emitStatement("row.nullifyLink(%s)", fieldIndexVariableReference(field))
+                        .emitStatement("return")
+                        .endControlFlow();
                 writer.beginControlFlow("if (!RealmObject.isValid(value))")
-                    .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
-                    .endControlFlow();
+                        .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
+                        .endControlFlow();
                 writer.beginControlFlow("if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
-                    .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
-                    .endControlFlow();
+                        .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
+                        .endControlFlow();
                 writer.emitStatement("row.getTable().setLink(%s, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true)",
-                    fieldIndexVariableReference(field));
+                        fieldIndexVariableReference(field));
                 writer.emitStatement("return");
             }
         });
         writer.emitStatement("proxyState.getRealm$realm().checkIfValid()")
-            .beginControlFlow("if (value == null)")
+                .beginControlFlow("if (value == null)")
                 .emitStatement("proxyState.getRow$realm().nullifyLink(%s)", fieldIndexVariableReference(field))
                 .emitStatement("return")
-            .endControlFlow()
-            .beginControlFlow("if (!(RealmObject.isManaged(value) && RealmObject.isValid(value)))")
+                .endControlFlow()
+                .beginControlFlow("if (!(RealmObject.isManaged(value) && RealmObject.isValid(value)))")
                 .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
-            .endControlFlow()
-            .beginControlFlow("if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
+                .endControlFlow()
+                .beginControlFlow("if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
                 .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
-            .endControlFlow()
-            .emitStatement("proxyState.getRow$realm().setLink(%s, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex())", fieldIndexVariableReference(field))
-            .endMethod();
+                .endControlFlow()
+                .emitStatement("proxyState.getRow$realm().setLink(%s, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex())", fieldIndexVariableReference(field))
+                .endMethod();
     }
     //@formatter:on
 
@@ -446,28 +444,27 @@ public void emit(JavaWriter writer) throws IOException {
      */
     //@formatter:off
     private void emitRealmList(
-        JavaWriter writer,
-        final VariableElement field,
-        String fieldName,
-        String fieldTypeCanonicalName) throws IOException
-    {
+            JavaWriter writer,
+            final VariableElement field,
+            String fieldName,
+            String fieldTypeCanonicalName) throws IOException {
         String genericType = Utils.getGenericTypeQualifiedName(field);
 
         // Getter
         writer.emitAnnotation("Override");
         writer.beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
-            .emitStatement("proxyState.getRealm$realm().checkIfValid()")
-            .emitSingleLineComment("use the cached value if available")
-            .beginControlFlow("if (" + fieldName + "RealmList != null)")
+                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
+                .emitSingleLineComment("use the cached value if available")
+                .beginControlFlow("if (" + fieldName + "RealmList != null)")
                 .emitStatement("return " + fieldName + "RealmList")
-            .nextControlFlow("else")
+                .nextControlFlow("else")
                 .emitStatement("LinkView linkView = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field))
                 .emitStatement(fieldName + "RealmList = new RealmList<%s>(%s.class, linkView, proxyState.getRealm$realm())",
-                    genericType, genericType)
+                        genericType, genericType)
                 .emitStatement("return " + fieldName + "RealmList")
-            .endControlFlow()
-            .endMethod()
-            .emitEmptyLine();
+                .endControlFlow()
+                .endMethod()
+                .emitEmptyLine();
 
         // Setter
         writer.emitAnnotation("Override");
@@ -486,33 +483,33 @@ public void emit(JavaWriter writer) throws IOException {
                         .emitStatement("final RealmList<%1$s> original = value", modelFqcn)
                         .emitStatement("value = new RealmList<%1$s>()", modelFqcn)
                         .beginControlFlow("for (%1$s item : original)", modelFqcn)
-                            .beginControlFlow("if (item == null || RealmObject.isManaged(item))")
-                                .emitStatement("value.add(item)")
-                            .nextControlFlow("else")
-                                .emitStatement("value.add(realm.copyToRealm(item))")
-                            .endControlFlow()
+                        .beginControlFlow("if (item == null || RealmObject.isManaged(item))")
+                        .emitStatement("value.add(item)")
+                        .nextControlFlow("else")
+                        .emitStatement("value.add(realm.copyToRealm(item))")
                         .endControlFlow()
-                    .endControlFlow();
+                        .endControlFlow()
+                        .endControlFlow();
 
                 // LinkView currently does not support default value feature. Just fallback to normal code.
             }
         });
         writer.emitStatement("proxyState.getRealm$realm().checkIfValid()")
-            .emitStatement("LinkView links = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field))
-            .emitStatement("links.clear()")
-            .beginControlFlow("if (value == null)")
+                .emitStatement("LinkView links = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field))
+                .emitStatement("links.clear()")
+                .beginControlFlow("if (value == null)")
                 .emitStatement("return")
-            .endControlFlow()
-            .beginControlFlow("for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value)")
+                .endControlFlow()
+                .beginControlFlow("for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value)")
                 .beginControlFlow("if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject)))")
-                    .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must be a valid managed object.\")")
+                .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must be a valid managed object.\")")
                 .endControlFlow()
                 .beginControlFlow("if (((RealmObjectProxy)linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
-                    .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must belong to the same Realm.\")")
+                .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must belong to the same Realm.\")")
                 .endControlFlow()
                 .emitStatement("links.add(((RealmObjectProxy)linkedObject).realmGet$proxyState().getRow$realm().getIndex())")
-            .endControlFlow()
-            .endMethod();
+                .endControlFlow()
+                .endMethod();
     }
     //@formatter:on
 
@@ -543,21 +540,21 @@ private void emitInjectContextMethod(JavaWriter writer) throws IOException {
                 "void", // Return type
                 "realm$injectObjectContext", // Method name
                 EnumSet.of(Modifier.PUBLIC) // Modifiers
-                ); // Argument type & argument name
+        ); // Argument type & argument name
 
         writer.beginControlFlow("if (this.proxyState != null)")
                 .emitStatement("return")
-            .endControlFlow()
-            .emitStatement("final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get()")
-            .emitStatement("this.columnInfo = (%1$s) context.getColumnInfo()", columnInfoClassName())
-            .emitStatement("this.proxyState = new ProxyState<%1$s>(this)", qualifiedClassName)
-            .emitStatement("proxyState.setRealm$realm(context.getRealm())")
-            .emitStatement("proxyState.setRow$realm(context.getRow())")
-            .emitStatement("proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue())")
-            .emitStatement("proxyState.setExcludeFields$realm(context.getExcludeFields())");
+                .endControlFlow()
+                .emitStatement("final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get()")
+                .emitStatement("this.columnInfo = (%1$s) context.getColumnInfo()", columnInfoClassName())
+                .emitStatement("this.proxyState = new ProxyState<%1$s>(this)", qualifiedClassName)
+                .emitStatement("proxyState.setRealm$realm(context.getRealm())")
+                .emitStatement("proxyState.setRow$realm(context.getRow())")
+                .emitStatement("proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue())")
+                .emitStatement("proxyState.setExcludeFields$realm(context.getExcludeFields())");
 
         writer.endMethod()
-            .emitEmptyLine();
+                .emitEmptyLine();
     }
     //@formatter:on
 
@@ -570,16 +567,16 @@ private void emitBacklinkFieldAccessors(JavaWriter writer) throws IOException {
             // Getter, no setter
             writer.emitAnnotation("Override");
             writer.beginMethod(realmResultsType, metadata.getInternalGetter(backlink.getTargetField()), EnumSet.of(Modifier.PUBLIC))
-                .emitStatement("BaseRealm realm = proxyState.getRealm$realm()")
-                .emitStatement("realm.checkIfValid()")
-                .emitStatement("proxyState.getRow$realm().checkIfAttached()")
-                .beginControlFlow("if (" + cacheFieldName + " == null)")
-                    .emitStatement(cacheFieldName + " = RealmResults.createBacklinkResults((Realm) realm, (UncheckedRow) proxyState.getRow$realm(), %s.class, \"%s\")",
-                        backlink.getSourceClass(), backlink.getSourceField())
-                .endControlFlow()
-                .emitStatement("return " + cacheFieldName)
-                .endMethod()
-                .emitEmptyLine();
+                    .emitStatement("BaseRealm realm = proxyState.getRealm$realm()")
+                    .emitStatement("realm.checkIfValid()")
+                    .emitStatement("proxyState.getRow$realm().checkIfAttached()")
+                    .beginControlFlow("if (" + cacheFieldName + " == null)")
+                    .emitStatement(cacheFieldName + " = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), %s.class, \"%s\")",
+                            backlink.getSourceClass(), backlink.getSourceField())
+                    .endControlFlow()
+                    .emitStatement("return " + cacheFieldName)
+                    .endMethod()
+                    .emitEmptyLine();
         }
     }
     //@formatter:on
@@ -587,10 +584,10 @@ private void emitBacklinkFieldAccessors(JavaWriter writer) throws IOException {
     //@formatter:off
     private void emitRealmObjectProxyImplementation(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override")
-            .beginMethod("ProxyState<?>", "realmGet$proxyState", EnumSet.of(Modifier.PUBLIC))
+                .beginMethod("ProxyState<?>", "realmGet$proxyState", EnumSet.of(Modifier.PUBLIC))
                 .emitStatement("return proxyState")
-            .endMethod()
-            .emitEmptyLine();
+                .endMethod()
+                .emitEmptyLine();
     }
     //@formatter:on
 
@@ -607,32 +604,41 @@ private void emitCreateRealmObjectSchemaMethod(JavaWriter writer) throws IOExcep
         // For each field generate corresponding table index constant
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
-            String fieldTypeCanonicalName = field.asType().toString();
             String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
 
-            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
-                String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
-                String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
-                String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
-                writer.emitStatement("realmObjectSchema.add(\"%s\", %s, %s, %s, %s)",
-                        fieldName,
-                        Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
-                        primaryKeyFlag,
-                        indexedFlag,
-                        nullableFlag);
-            } else if (Utils.isRealmModel(field)) {
-                writer.beginControlFlow("if (!realmSchema.contains(\"" + fieldTypeSimpleName + "\"))")
-                        .emitStatement("%s%s.createRealmObjectSchema(realmSchema)", fieldTypeSimpleName, Constants.PROXY_SUFFIX)
-                        .endControlFlow()
-                        .emitStatement("realmObjectSchema.add(\"%s\", RealmFieldType.OBJECT, realmSchema.get(\"%s\"))",
-                                fieldName, fieldTypeSimpleName);
-            } else if (Utils.isRealmList(field)) {
-                String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
-                writer.beginControlFlow("if (!realmSchema.contains(\"" + genericTypeSimpleName + "\"))")
-                        .emitStatement("%s%s.createRealmObjectSchema(realmSchema)", genericTypeSimpleName, Constants.PROXY_SUFFIX)
-                        .endControlFlow()
-                        .emitStatement("realmObjectSchema.add(\"%s\", RealmFieldType.LIST, realmSchema.get(\"%s\"))",
-                                fieldName, genericTypeSimpleName);
+            Constants.RealmFieldType fieldType = getRealmType(field);
+            switch (fieldType) {
+                case NOTYPE:
+                    // Perhaps this should fail quickly?
+                    break;
+
+                case OBJECT:
+                    writer.beginControlFlow("if (!realmSchema.contains(\"" + fieldTypeSimpleName + "\"))")
+                            .emitStatement("%s%s.createRealmObjectSchema(realmSchema)", fieldTypeSimpleName, Constants.PROXY_SUFFIX)
+                            .endControlFlow()
+                            .emitStatement("realmObjectSchema.add(\"%s\", RealmFieldType.OBJECT, realmSchema.get(\"%s\"))",
+                                    fieldName, fieldTypeSimpleName);
+                    break;
+
+                case LIST:
+                    String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
+                    writer.beginControlFlow("if (!realmSchema.contains(\"" + genericTypeSimpleName + "\"))")
+                            .emitStatement("%s%s.createRealmObjectSchema(realmSchema)", genericTypeSimpleName, Constants.PROXY_SUFFIX)
+                            .endControlFlow()
+                            .emitStatement("realmObjectSchema.add(\"%s\", RealmFieldType.LIST, realmSchema.get(\"%s\"))",
+                                    fieldName, genericTypeSimpleName);
+                    break;
+
+                default:
+                    String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
+                    String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
+                    String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
+                    writer.emitStatement("realmObjectSchema.add(\"%s\", %s, %s, %s, %s)",
+                            fieldName,
+                            fieldType.getRealmType(),
+                            primaryKeyFlag,
+                            indexedFlag,
+                            nullableFlag);
             }
         }
         writer.emitStatement("return realmObjectSchema");
@@ -686,7 +692,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 .emitEmptyLine();
 
         // create an instance of ColumnInfo
-        writer.emitStatement("final %1$s columnInfo = new %1$s(sharedRealm.getPath(), table)", columnInfoClassName())
+        writer.emitStatement("final %1$s columnInfo = new %1$s(sharedRealm, table)", columnInfoClassName())
                 .emitEmptyLine();
 
         // verify primary key definition was not altered
@@ -755,7 +761,7 @@ private void emitValidateRealmType(JavaWriter writer, VariableElement field, Str
                 "\")", fieldName);
         writer.endControlFlow();
         writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)",
-                fieldName, Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeQualifiedName));
+                fieldName, getRealmTypeChecked(field).getRealmType());
         emitMigrationNeededException(writer, "\"Invalid type '%s' for field '%s' in existing Realm file.\")",
                 Utils.getFieldTypeSimpleName(field), fieldName);
         writer.endControlFlow();
@@ -907,18 +913,18 @@ private void emitValidateBacklink(JavaWriter writer, Backlink backlink) throws I
     //@formatter:off
     private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
         writer.beginMethod("String", "getTableName", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
-            .emitStatement("return \"%s%s\"", Constants.TABLE_PREFIX, simpleClassName)
-            .endMethod()
-            .emitEmptyLine();
+                .emitStatement("return \"%s%s\"", Constants.TABLE_PREFIX, simpleClassName)
+                .endMethod()
+                .emitEmptyLine();
     }
     //@formatter:on
 
     //@formatter:off
     private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
         writer.beginMethod("List<String>", "getFieldNames", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
-            .emitStatement("return FIELD_NAMES")
-            .endMethod()
-            .emitEmptyLine();
+                .emitStatement("return FIELD_NAMES")
+                .endMethod()
+                .emitEmptyLine();
     }
     //@formatter:on
 
@@ -932,16 +938,16 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
         );
 
         writer
-            .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId)")
+                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId)")
                 .emitStatement("throw new IllegalArgumentException(\"Objects which belong to Realm instances in other" +
                         " threads cannot be copied into this Realm instance.\")")
-            .endControlFlow();
+                .endControlFlow();
 
         // If object is already in the Realm there is nothing to update
         writer
-            .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
+                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
                 .emitStatement("return object")
-            .endControlFlow();
+                .endControlFlow();
 
         writer.emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()");
 
@@ -950,74 +956,74 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                 .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
                 .nextControlFlow("else");
 
-            if (!metadata.hasPrimaryKey()) {
-                writer.emitStatement("return copy(realm, object, update, cache)");
-            } else {
-                writer
+        if (!metadata.hasPrimaryKey()) {
+            writer.emitStatement("return copy(realm, object, update, cache)");
+        } else {
+            writer
                     .emitStatement("%s realmObject = null", qualifiedClassName)
                     .emitStatement("boolean canUpdate = update")
                     .beginControlFlow("if (canUpdate)")
-                        .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
-                        .emitStatement("long pkColumnIndex = table.getPrimaryKey()");
+                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
+                    .emitStatement("long pkColumnIndex = table.getPrimaryKey()");
 
-                String primaryKeyGetter = metadata.getPrimaryKeyGetter();
-                VariableElement primaryKeyElement = metadata.getPrimaryKey();
-                if (metadata.isNullable(primaryKeyElement)) {
-                    if (Utils.isString(primaryKeyElement)) {
-                        writer
+            String primaryKeyGetter = metadata.getPrimaryKeyGetter();
+            VariableElement primaryKeyElement = metadata.getPrimaryKey();
+            if (metadata.isNullable(primaryKeyElement)) {
+                if (Utils.isString(primaryKeyElement)) {
+                    writer
                             .emitStatement("String value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                             .emitStatement("long rowIndex = Table.NO_MATCH")
                             .beginControlFlow("if (value == null)")
-                                .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                            .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
                             .nextControlFlow("else")
-                                .emitStatement("rowIndex = table.findFirstString(pkColumnIndex, value)")
+                            .emitStatement("rowIndex = table.findFirstString(pkColumnIndex, value)")
                             .endControlFlow();
-                    } else {
-                        writer
+                } else {
+                    writer
                             .emitStatement("Number value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                             .emitStatement("long rowIndex = Table.NO_MATCH")
                             .beginControlFlow("if (value == null)")
-                                .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                            .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
                             .nextControlFlow("else")
-                                .emitStatement("rowIndex = table.findFirstLong(pkColumnIndex, value.longValue())")
+                            .emitStatement("rowIndex = table.findFirstLong(pkColumnIndex, value.longValue())")
                             .endControlFlow();
-                    }
-                } else {
-                    String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
-                    writer.emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, ((%s) object).%s())",
-                            pkType, interfaceName, primaryKeyGetter);
                 }
+            } else {
+                String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
+                writer.emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, ((%s) object).%s())",
+                        pkType, interfaceName, primaryKeyGetter);
+            }
 
-                writer
+            writer
                     .beginControlFlow("if (rowIndex != Table.NO_MATCH)")
-                        .beginControlFlow("try")
-                            .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex)," +
-                                    " realm.schema.getColumnInfo(%s.class)," +
-                                    " false, Collections.<String> emptyList())", qualifiedClassName)
-                            .emitStatement("realmObject = new %s()", qualifiedGeneratedClassName)
-                            .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
-                        .nextControlFlow("finally")
-                            .emitStatement("objectContext.clear()")
-                        .endControlFlow()
+                    .beginControlFlow("try")
+                    .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex)," +
+                            " realm.schema.getColumnInfo(%s.class)," +
+                            " false, Collections.<String> emptyList())", qualifiedClassName)
+                    .emitStatement("realmObject = new %s()", qualifiedGeneratedClassName)
+                    .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
+                    .nextControlFlow("finally")
+                    .emitStatement("objectContext.clear()")
+                    .endControlFlow()
 
                     .nextControlFlow("else")
-                        .emitStatement("canUpdate = false")
+                    .emitStatement("canUpdate = false")
                     .endControlFlow();
 
-                writer.endControlFlow();
+            writer.endControlFlow();
 
-                writer
+            writer
                     .emitEmptyLine()
                     .beginControlFlow("if (canUpdate)")
-                        .emitStatement("return update(realm, realmObject, object, cache)")
+                    .emitStatement("return update(realm, realmObject, object, cache)")
                     .nextControlFlow("else")
-                        .emitStatement("return copy(realm, object, update, cache)")
+                    .emitStatement("return copy(realm, object, update, cache)")
                     .endControlFlow();
-            }
+        }
 
         writer.endControlFlow();
         writer.endMethod()
-            .emitEmptyLine();
+                .emitEmptyLine();
     }
     //@formatter:on
 
@@ -1036,26 +1042,26 @@ private void setTableValues(JavaWriter writer, String fieldType, String fieldNam
             writer
                     .emitStatement("Number %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter);
-                    if (isUpdate) {
-                        writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-                    }
-                    writer.endControlFlow();
+                    .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter);
+            if (isUpdate) {
+                writer.nextControlFlow("else")
+                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
+            }
+            writer.endControlFlow();
 
         } else if ("double".equals(fieldType)) {
             writer.emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s(), false)", fieldName, interfaceName, getter);
 
-        } else if("java.lang.Double".equals(fieldType)) {
+        } else if ("java.lang.Double".equals(fieldType)) {
             writer
                     .emitStatement("Double %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
-                    if (isUpdate) {
-                        writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-                    }
-                    writer.endControlFlow();
+                    .emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
+            if (isUpdate) {
+                writer.nextControlFlow("else")
+                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
+            }
+            writer.endControlFlow();
 
         } else if ("float".equals(fieldType)) {
             writer.emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s(), false)", fieldName, interfaceName, getter);
@@ -1064,12 +1070,12 @@ private void setTableValues(JavaWriter writer, String fieldType, String fieldNam
             writer
                     .emitStatement("Float %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
-                    if (isUpdate) {
-                        writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-                    }
-                    writer.endControlFlow();
+                    .emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
+            if (isUpdate) {
+                writer.nextControlFlow("else")
+                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
+            }
+            writer.endControlFlow();
 
         } else if ("boolean".equals(fieldType)) {
             writer.emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s(), false)", fieldName, interfaceName, getter);
@@ -1078,46 +1084,46 @@ private void setTableValues(JavaWriter writer, String fieldType, String fieldNam
             writer
                     .emitStatement("Boolean %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
-                    if (isUpdate) {
-                        writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-                    }
-                    writer.endControlFlow();
+                    .emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
+            if (isUpdate) {
+                writer.nextControlFlow("else")
+                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
+            }
+            writer.endControlFlow();
 
         } else if ("byte[]".equals(fieldType)) {
             writer
                     .emitStatement("byte[] %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetByteArray(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
-                    if (isUpdate) {
-                        writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-                    }
-                    writer.endControlFlow();
+                    .emitStatement("Table.nativeSetByteArray(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
+            if (isUpdate) {
+                writer.nextControlFlow("else")
+                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
+            }
+            writer.endControlFlow();
 
 
         } else if ("java.util.Date".equals(fieldType)) {
             writer
                     .emitStatement("java.util.Date %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetTimestamp(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.getTime(), false)", fieldName, getter);
-                    if (isUpdate) {
-                        writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-                    }
-                    writer.endControlFlow();
+                    .emitStatement("Table.nativeSetTimestamp(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.getTime(), false)", fieldName, getter);
+            if (isUpdate) {
+                writer.nextControlFlow("else")
+                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
+            }
+            writer.endControlFlow();
 
         } else if ("java.lang.String".equals(fieldType)) {
             writer
                     .emitStatement("String %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetString(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
-                    if (isUpdate) {
-                        writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-                    }
-                    writer.endControlFlow();
+                    .emitStatement("Table.nativeSetString(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
+            if (isUpdate) {
+                writer.nextControlFlow("else")
+                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
+            }
+            writer.endControlFlow();
         } else {
             throw new IllegalStateException("Unsupported type " + fieldType);
         }
@@ -1139,7 +1145,7 @@ private void emitInsertMethod(JavaWriter writer) throws IOException {
                 .endControlFlow();
 
         writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
-        writer.emitStatement("long tableNativePtr = table.getNativeTablePointer()");
+        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
         writer.emitStatement("%s columnInfo = (%s) realm.schema.getColumnInfo(%s.class)",
                 columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
 
@@ -1159,14 +1165,14 @@ private void emitInsertMethod(JavaWriter writer) throws IOException {
                         .emitEmptyLine()
                         .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sObj != null)", fieldName)
-                            .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
-                            .beginControlFlow("if (cache%s == null)", fieldName)
-                                .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
-                                        fieldName,
-                                        Utils.getProxyClassSimpleName(field),
-                                        fieldName)
-                            .endControlFlow()
-                           .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
+                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
+                        .beginControlFlow("if (cache%s == null)", fieldName)
+                        .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
+                                fieldName,
+                                Utils.getProxyClassSimpleName(field),
+                                fieldName)
+                        .endControlFlow()
+                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .endControlFlow();
             } else if (Utils.isRealmList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
@@ -1175,14 +1181,14 @@ private void emitInsertMethod(JavaWriter writer) throws IOException {
                         .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                 genericType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sList != null)", fieldName)
-                            .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
-                            .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
-                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
-                             .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
-                                .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
-                             .endControlFlow()
-                             .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
-                            .endControlFlow()
+                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
+                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                        .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                        .endControlFlow()
+                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
+                        .endControlFlow()
                         .endControlFlow()
                         .emitEmptyLine();
 
@@ -1208,7 +1214,7 @@ private void emitInsertListMethod(JavaWriter writer) throws IOException {
         );
 
         writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
-        writer.emitStatement("long tableNativePtr = table.getNativeTablePointer()");
+        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
         writer.emitStatement("%s columnInfo = (%s) realm.schema.getColumnInfo(%s.class)",
                 columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
         if (metadata.hasPrimaryKey()) {
@@ -1238,13 +1244,13 @@ private void emitInsertListMethod(JavaWriter writer) throws IOException {
                         .emitEmptyLine()
                         .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sObj != null)", fieldName)
-                            .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
-                         .beginControlFlow("if (cache%s == null)", fieldName)
-                                .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
-                                        fieldName,
-                                        Utils.getProxyClassSimpleName(field),
-                                        fieldName)
-                                .endControlFlow()
+                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
+                        .beginControlFlow("if (cache%s == null)", fieldName)
+                        .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
+                                fieldName,
+                                Utils.getProxyClassSimpleName(field),
+                                fieldName)
+                        .endControlFlow()
                         .emitStatement("table.setLink(columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .endControlFlow();
             } else if (Utils.isRealmList(field)) {
@@ -1254,12 +1260,12 @@ private void emitInsertListMethod(JavaWriter writer) throws IOException {
                         .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                 genericType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sList != null)", fieldName)
-                            .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
-                          .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
-                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
-                             .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
-                                    .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
-                             .endControlFlow()
+                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
+                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                        .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                        .endControlFlow()
                         .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                         .endControlFlow()
                         .endControlFlow()
@@ -1294,7 +1300,7 @@ private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
                 .endControlFlow();
 
         writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
-        writer.emitStatement("long tableNativePtr = table.getNativeTablePointer()");
+        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
         writer.emitStatement("%s columnInfo = (%s) realm.schema.getColumnInfo(%s.class)",
                 columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
 
@@ -1314,16 +1320,16 @@ private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
                         .emitEmptyLine()
                         .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sObj != null)", fieldName)
-                            .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
-                            .beginControlFlow("if (cache%s == null)", fieldName)
-                                .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
-                                        fieldName,
-                                        Utils.getProxyClassSimpleName(field))
-                            .endControlFlow()
-                            .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
+                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
+                        .beginControlFlow("if (cache%s == null)", fieldName)
+                        .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
+                                fieldName,
+                                Utils.getProxyClassSimpleName(field))
+                        .endControlFlow()
+                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .nextControlFlow("else")
-                                // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
-                            .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
+                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                        .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
                         .endControlFlow();
             } else if (Utils.isRealmList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
@@ -1334,13 +1340,13 @@ private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
                         .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                 genericType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sList != null)", fieldName)
-                            .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
-                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
-                                .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
-                                    .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
-                                .endControlFlow()
-                                .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
-                            .endControlFlow()
+                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                        .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                        .endControlFlow()
+                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
+                        .endControlFlow()
                         .endControlFlow()
                         .emitEmptyLine();
 
@@ -1367,7 +1373,7 @@ private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException
         );
 
         writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
-        writer.emitStatement("long tableNativePtr = table.getNativeTablePointer()");
+        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
         writer.emitStatement("%s columnInfo = (%s) realm.schema.getColumnInfo(%s.class)",
                 columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
         if (metadata.hasPrimaryKey()) {
@@ -1396,16 +1402,16 @@ private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException
                         .emitEmptyLine()
                         .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sObj != null)", fieldName)
-                            .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
-                            .beginControlFlow("if (cache%s == null)", fieldName)
-                                .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
-                                        fieldName,
-                                        Utils.getProxyClassSimpleName(field))
-                                    .endControlFlow()
-                            .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
+                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
+                        .beginControlFlow("if (cache%s == null)", fieldName)
+                        .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
+                                fieldName,
+                                Utils.getProxyClassSimpleName(field))
+                        .endControlFlow()
+                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .nextControlFlow("else")
-                                // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
-                            .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
+                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                        .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
                         .endControlFlow();
             } else if (Utils.isRealmList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
@@ -1416,13 +1422,13 @@ private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException
                         .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                 genericType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sList != null)", fieldName)
-                            .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
-                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
-                            .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
-                                    .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
-                                .endControlFlow()
-                            .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
-                            .endControlFlow()
+                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                        .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                        .endControlFlow()
+                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
+                        .endControlFlow()
                         .endControlFlow()
                         .emitEmptyLine();
 
@@ -1448,22 +1454,22 @@ private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfP
                 //@formatter:off
                 if (Utils.isString(primaryKeyElement)) {
                     writer
-                        .emitStatement("String primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
-                        .emitStatement("long rowIndex = Table.NO_MATCH")
-                        .beginControlFlow("if (primaryKeyValue == null)")
-                        .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
-                        .nextControlFlow("else")
-                        .emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue)")
-                        .endControlFlow();
+                            .emitStatement("String primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                            .emitStatement("long rowIndex = Table.NO_MATCH")
+                            .beginControlFlow("if (primaryKeyValue == null)")
+                            .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
+                            .nextControlFlow("else")
+                            .emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue)")
+                            .endControlFlow();
                 } else {
                     writer
-                        .emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
-                        .emitStatement("long rowIndex = Table.NO_MATCH")
-                        .beginControlFlow("if (primaryKeyValue == null)")
-                        .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
-                        .nextControlFlow("else")
-                        .emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter)
-                        .endControlFlow();
+                            .emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                            .emitStatement("long rowIndex = Table.NO_MATCH")
+                            .beginControlFlow("if (primaryKeyValue == null)")
+                            .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
+                            .nextControlFlow("else")
+                            .emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter)
+                            .endControlFlow();
                 }
                 //@formatter:on
             } else {
@@ -1533,51 +1539,51 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
             }
 
             //@formatter:off
-                if (Utils.isRealmModel(field)) {
-                    writer
+            if (Utils.isRealmModel(field)) {
+                writer
                         .emitEmptyLine()
                         .emitStatement("%s %sObj = ((%s) newObject).%s()", fieldType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sObj != null)", fieldName)
-                            .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
-                            .beginControlFlow("if (cache%s != null)", fieldName)
-                                .emitStatement("((%s) realmObject).%s(cache%s)", interfaceName, setter, fieldName)
-                            .nextControlFlow("else")
-                                .emitStatement("((%s) realmObject).%s(%s.copyOrUpdate(realm, %sObj, update, cache))",
-                                        interfaceName,
-                                        setter,
-                                        Utils.getProxyClassSimpleName(field),
-                                        fieldName)
-                            .endControlFlow()
+                        .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
+                        .beginControlFlow("if (cache%s != null)", fieldName)
+                        .emitStatement("((%s) realmObject).%s(cache%s)", interfaceName, setter, fieldName)
+                        .nextControlFlow("else")
+                        .emitStatement("((%s) realmObject).%s(%s.copyOrUpdate(realm, %sObj, update, cache))",
+                                interfaceName,
+                                setter,
+                                Utils.getProxyClassSimpleName(field),
+                                fieldName)
+                        .endControlFlow()
                         .nextControlFlow("else")
-                            // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
-                            .emitStatement("((%s) realmObject).%s(null)", interfaceName, setter)
+                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                        .emitStatement("((%s) realmObject).%s(null)", interfaceName, setter)
                         .endControlFlow();
-                } else if (Utils.isRealmList(field)) {
-                    final String genericType = Utils.getGenericTypeQualifiedName(field);
-                    writer
+            } else if (Utils.isRealmList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
+                writer
                         .emitEmptyLine()
                         .emitStatement("RealmList<%s> %sList = ((%s) newObject).%s()",
                                 genericType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sList != null)", fieldName)
-                            .emitStatement("RealmList<%s> %sRealmList = ((%s) realmObject).%s()",
-                                    genericType, fieldName, interfaceName, getter)
-                            .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
-                                    .emitStatement("%s %sItem = %sList.get(i)", genericType, fieldName, fieldName)
-                                    .emitStatement("%s cache%s = (%s) cache.get(%sItem)", genericType, fieldName, genericType, fieldName)
-                                    .beginControlFlow("if (cache%s != null)", fieldName)
-                                            .emitStatement("%sRealmList.add(cache%s)", fieldName, fieldName)
-                                    .nextControlFlow("else")
-                                            .emitStatement("%sRealmList.add(%s.copyOrUpdate(realm, %sList.get(i), update, cache))", fieldName, Utils.getProxyClassSimpleName(field), fieldName)
-                                    .endControlFlow()
-                            .endControlFlow()
+                        .emitStatement("RealmList<%s> %sRealmList = ((%s) realmObject).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
+                        .emitStatement("%s %sItem = %sList.get(i)", genericType, fieldName, fieldName)
+                        .emitStatement("%s cache%s = (%s) cache.get(%sItem)", genericType, fieldName, genericType, fieldName)
+                        .beginControlFlow("if (cache%s != null)", fieldName)
+                        .emitStatement("%sRealmList.add(cache%s)", fieldName, fieldName)
+                        .nextControlFlow("else")
+                        .emitStatement("%sRealmList.add(%s.copyOrUpdate(realm, %sList.get(i), update, cache))", fieldName, Utils.getProxyClassSimpleName(field), fieldName)
+                        .endControlFlow()
+                        .endControlFlow()
                         .endControlFlow()
                         .emitEmptyLine();
 
-                } else {
-                    writer.emitStatement("((%s) realmObject).%s(((%s) newObject).%s())",
-                            interfaceName, setter, interfaceName, getter);
-                }
-                //@formatter:on
+            } else {
+                writer.emitStatement("((%s) realmObject).%s(((%s) newObject).%s())",
+                        interfaceName, setter, interfaceName, getter);
+            }
+            //@formatter:on
         }
 
         writer.emitStatement("return realmObject");
@@ -1594,23 +1600,23 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                 qualifiedClassName, "realmObject", "int", "currentDepth", "int", "maxDepth", "Map<RealmModel, CacheData<RealmModel>>", "cache");
         writer
-            .beginControlFlow("if (currentDepth > maxDepth || realmObject == null)")
+                .beginControlFlow("if (currentDepth > maxDepth || realmObject == null)")
                 .emitStatement("return null")
-            .endControlFlow()
-            .emitStatement("CacheData<RealmModel> cachedObject = cache.get(realmObject)")
-            .emitStatement("%s unmanagedObject", qualifiedClassName)
-            .beginControlFlow("if (cachedObject != null)")
+                .endControlFlow()
+                .emitStatement("CacheData<RealmModel> cachedObject = cache.get(realmObject)")
+                .emitStatement("%s unmanagedObject", qualifiedClassName)
+                .beginControlFlow("if (cachedObject != null)")
                 .emitSingleLineComment("Reuse cached object or recreate it because it was encountered at a lower depth.")
                 .beginControlFlow("if (currentDepth >= cachedObject.minDepth)")
-                    .emitStatement("return (%s)cachedObject.object", qualifiedClassName)
+                .emitStatement("return (%s)cachedObject.object", qualifiedClassName)
                 .nextControlFlow("else")
-                    .emitStatement("unmanagedObject = (%s)cachedObject.object", qualifiedClassName)
-                    .emitStatement("cachedObject.minDepth = currentDepth")
+                .emitStatement("unmanagedObject = (%s)cachedObject.object", qualifiedClassName)
+                .emitStatement("cachedObject.minDepth = currentDepth")
                 .endControlFlow()
-            .nextControlFlow("else")
+                .nextControlFlow("else")
                 .emitStatement("unmanagedObject = new %s()", qualifiedClassName)
                 .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject))")
-            .endControlFlow();
+                .endControlFlow();
 
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
@@ -1619,29 +1625,29 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
 
             if (Utils.isRealmModel(field)) {
                 writer
-                    .emitEmptyLine()
-                    .emitSingleLineComment("Deep copy of %s", fieldName)
-                    .emitStatement("((%s) unmanagedObject).%s(%s.createDetachedCopy(((%s) realmObject).%s(), currentDepth + 1, maxDepth, cache))",
+                        .emitEmptyLine()
+                        .emitSingleLineComment("Deep copy of %s", fieldName)
+                        .emitStatement("((%s) unmanagedObject).%s(%s.createDetachedCopy(((%s) realmObject).%s(), currentDepth + 1, maxDepth, cache))",
                                 interfaceName, setter, Utils.getProxyClassSimpleName(field), interfaceName, getter);
             } else if (Utils.isRealmList(field)) {
                 writer
-                    .emitEmptyLine()
-                    .emitSingleLineComment("Deep copy of %s", fieldName)
-                    .beginControlFlow("if (currentDepth == maxDepth)")
+                        .emitEmptyLine()
+                        .emitSingleLineComment("Deep copy of %s", fieldName)
+                        .beginControlFlow("if (currentDepth == maxDepth)")
                         .emitStatement("((%s) unmanagedObject).%s(null)", interfaceName, setter)
-                    .nextControlFlow("else")
+                        .nextControlFlow("else")
                         .emitStatement("RealmList<%s> managed%sList = ((%s) realmObject).%s()",
-                                 Utils.getGenericTypeQualifiedName(field), fieldName, interfaceName, getter)
+                                Utils.getGenericTypeQualifiedName(field), fieldName, interfaceName, getter)
                         .emitStatement("RealmList<%1$s> unmanaged%2$sList = new RealmList<%1$s>()", Utils.getGenericTypeQualifiedName(field), fieldName)
                         .emitStatement("((%s) unmanagedObject).%s(unmanaged%sList)", interfaceName, setter, fieldName)
                         .emitStatement("int nextDepth = currentDepth + 1")
                         .emitStatement("int size = managed%sList.size()", fieldName)
                         .beginControlFlow("for (int i = 0; i < size; i++)")
-                            .emitStatement("%s item = %s.createDetachedCopy(managed%sList.get(i), nextDepth, maxDepth, cache)",
-                                    Utils.getGenericTypeQualifiedName(field), Utils.getProxyClassSimpleName(field), fieldName)
-                            .emitStatement("unmanaged%sList.add(item)", fieldName)
+                        .emitStatement("%s item = %s.createDetachedCopy(managed%sList.get(i), nextDepth, maxDepth, cache)",
+                                Utils.getGenericTypeQualifiedName(field), Utils.getProxyClassSimpleName(field), fieldName)
+                        .emitStatement("unmanaged%sList.add(item)", fieldName)
                         .endControlFlow()
-                    .endControlFlow();
+                        .endControlFlow();
             } else {
                 writer.emitStatement("((%s) unmanagedObject).%s(((%s) realmObject).%s())",
                         interfaceName, setter, interfaceName, getter);
@@ -1672,43 +1678,43 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
             //@formatter:off
             if (Utils.isRealmModel(field)) {
                 writer
-                    .emitStatement("%s %sObj = ((%s) newObject).%s()",
-                            Utils.getFieldTypeQualifiedName(field), fieldName, interfaceName, getter)
-                    .beginControlFlow("if (%sObj != null)", fieldName)
+                        .emitStatement("%s %sObj = ((%s) newObject).%s()",
+                                Utils.getFieldTypeQualifiedName(field), fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sObj != null)", fieldName)
                         .emitStatement("%s cache%s = (%s) cache.get(%sObj)", Utils.getFieldTypeQualifiedName(field), fieldName, Utils.getFieldTypeQualifiedName(field), fieldName)
                         .beginControlFlow("if (cache%s != null)", fieldName)
-                            .emitStatement("((%s) realmObject).%s(cache%s)", interfaceName, setter, fieldName)
+                        .emitStatement("((%s) realmObject).%s(cache%s)", interfaceName, setter, fieldName)
                         .nextControlFlow("else")
-                            .emitStatement("((%s) realmObject).%s(%s.copyOrUpdate(realm, %sObj, true, cache))",
-                                    interfaceName,
-                                    setter,
-                                    Utils.getProxyClassSimpleName(field),
-                                    fieldName
-                            )
+                        .emitStatement("((%s) realmObject).%s(%s.copyOrUpdate(realm, %sObj, true, cache))",
+                                interfaceName,
+                                setter,
+                                Utils.getProxyClassSimpleName(field),
+                                fieldName
+                        )
                         .endControlFlow()
-                    .nextControlFlow("else")
+                        .nextControlFlow("else")
                         // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                         .emitStatement("((%s) realmObject).%s(null)", interfaceName, setter)
-                    .endControlFlow();
+                        .endControlFlow();
             } else if (Utils.isRealmList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
-                    .emitStatement("RealmList<%s> %sList = ((%s) newObject).%s()",
-                            genericType, fieldName, interfaceName, getter)
-                    .emitStatement("RealmList<%s> %sRealmList = ((%s) realmObject).%s()",
-                            genericType, fieldName, interfaceName, getter)
-                    .emitStatement("%sRealmList.clear()", fieldName)
-                    .beginControlFlow("if (%sList != null)", fieldName)
+                        .emitStatement("RealmList<%s> %sList = ((%s) newObject).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .emitStatement("RealmList<%s> %sRealmList = ((%s) realmObject).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .emitStatement("%sRealmList.clear()", fieldName)
+                        .beginControlFlow("if (%sList != null)", fieldName)
                         .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
-                            .emitStatement("%s %sItem = %sList.get(i)", genericType, fieldName, fieldName)
-                            .emitStatement("%s cache%s = (%s) cache.get(%sItem)", genericType, fieldName, genericType, fieldName)
-                            .beginControlFlow("if (cache%s != null)", fieldName)
-                                .emitStatement("%sRealmList.add(cache%s)", fieldName, fieldName)
-                            .nextControlFlow("else")
-                                .emitStatement("%sRealmList.add(%s.copyOrUpdate(realm, %sList.get(i), true, cache))", fieldName, Utils.getProxyClassSimpleName(field), fieldName)
-                            .endControlFlow()
+                        .emitStatement("%s %sItem = %sList.get(i)", genericType, fieldName, fieldName)
+                        .emitStatement("%s cache%s = (%s) cache.get(%sItem)", genericType, fieldName, genericType, fieldName)
+                        .beginControlFlow("if (cache%s != null)", fieldName)
+                        .emitStatement("%sRealmList.add(cache%s)", fieldName, fieldName)
+                        .nextControlFlow("else")
+                        .emitStatement("%sRealmList.add(%s.copyOrUpdate(realm, %sList.get(i), true, cache))", fieldName, Utils.getProxyClassSimpleName(field), fieldName)
                         .endControlFlow()
-                    .endControlFlow();
+                        .endControlFlow()
+                        .endControlFlow();
 
             } else {
                 if (field == metadata.getPrimaryKey()) {
@@ -1789,7 +1795,7 @@ private void emitHashcodeMethod(JavaWriter writer) throws IOException {
             return;
         }
         writer.emitAnnotation("Override")
-            .beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC))
+                .beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC))
                 .emitStatement("String realmName = proxyState.getRealm$realm().getPath()")
                 .emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()")
                 .emitStatement("long rowIndex = proxyState.getRow$realm().getIndex()")
@@ -1799,8 +1805,8 @@ private void emitHashcodeMethod(JavaWriter writer) throws IOException {
                 .emitStatement("result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0)")
                 .emitStatement("result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32))")
                 .emitStatement("return result")
-            .endMethod()
-            .emitEmptyLine();
+                .endMethod()
+                .emitEmptyLine();
     }
     //@formatter:on
 
@@ -1812,7 +1818,7 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
         String proxyClassName = Utils.getProxyClassName(simpleClassName);
         String otherObjectVarName = "a" + simpleClassName;
         writer.emitAnnotation("Override")
-            .beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o")
+                .beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o")
                 .emitStatement("if (this == o) return true")
                 .emitStatement("if (o == null || getClass() != o.getClass()) return false")
                 .emitStatement("%s %s = (%s)o", proxyClassName, otherObjectVarName, proxyClassName)  // FooRealmProxy aFoo = (FooRealmProxy)o
@@ -1828,8 +1834,8 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
                 .emitStatement("if (proxyState.getRow$realm().getIndex() != %s.proxyState.getRow$realm().getIndex()) return false", otherObjectVarName)
                 .emitEmptyLine()
                 .emitStatement("return true")
-            .endMethod()
-            .emitEmptyLine();
+                .endMethod()
+                .emitEmptyLine();
     }
     //@formatter:on
 
@@ -1858,39 +1864,39 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
         } else {
             String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
             writer
-                .emitStatement("%s obj = null", qualifiedClassName)
-                .beginControlFlow("if (update)")
+                    .emitStatement("%s obj = null", qualifiedClassName)
+                    .beginControlFlow("if (update)")
                     .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
                     .emitStatement("long pkColumnIndex = table.getPrimaryKey()")
                     .emitStatement("long rowIndex = Table.NO_MATCH");
             if (metadata.isNullable(metadata.getPrimaryKey())) {
                 writer
-                    .beginControlFlow("if (json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
+                        .beginControlFlow("if (json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
                         .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
-                    .nextControlFlow("else")
+                        .nextControlFlow("else")
                         .emitStatement("rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
                                 pkType, pkType, metadata.getPrimaryKey().getSimpleName())
-                    .endControlFlow();
+                        .endControlFlow();
             } else {
                 writer
-                    .beginControlFlow("if (!json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
-                    .emitStatement("rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
-                            pkType, pkType, metadata.getPrimaryKey().getSimpleName())
-                    .endControlFlow();
+                        .beginControlFlow("if (!json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
+                        .emitStatement("rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
+                                pkType, pkType, metadata.getPrimaryKey().getSimpleName())
+                        .endControlFlow();
             }
             writer
                     .beginControlFlow("if (rowIndex != Table.NO_MATCH)")
-                        .emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
-                        .beginControlFlow("try")
-                            .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex)," +
-                                    " realm.schema.getColumnInfo(%s.class)," +
-                                    " false, Collections.<String> emptyList())", qualifiedClassName)
-                            .emitStatement("obj = new %s()", qualifiedGeneratedClassName)
-                        .nextControlFlow("finally")
-                            .emitStatement("objectContext.clear()")
-                        .endControlFlow()
+                    .emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
+                    .beginControlFlow("try")
+                    .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex)," +
+                            " realm.schema.getColumnInfo(%s.class)," +
+                            " false, Collections.<String> emptyList())", qualifiedClassName)
+                    .emitStatement("obj = new %s()", qualifiedGeneratedClassName)
+                    .nextControlFlow("finally")
+                    .emitStatement("objectContext.clear()")
                     .endControlFlow()
-                .endControlFlow();
+                    .endControlFlow()
+                    .endControlFlow();
 
             writer.beginControlFlow("if (obj == null)");
             buildExcludeFieldsList(writer, metadata.getFields());
@@ -2057,4 +2063,27 @@ private static int countModelOrListFields(Collection<VariableElement> fields) {
         }
         return count;
     }
+
+    private Constants.RealmFieldType getRealmType(VariableElement field) {
+        String fieldTypeCanonicalName = field.asType().toString();
+        Constants.RealmFieldType type = Constants.JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
+        if (type != null) {
+            return type;
+        }
+        if (Utils.isRealmModel(field)) {
+            return Constants.RealmFieldType.OBJECT;
+        }
+        if (Utils.isRealmList(field)) {
+            return Constants.RealmFieldType.LIST;
+        }
+        return Constants.RealmFieldType.NOTYPE;
+    }
+
+    private Constants.RealmFieldType getRealmTypeChecked(VariableElement field) {
+        Constants.RealmFieldType type = getRealmType(field);
+        if (type == Constants.RealmFieldType.NOTYPE) {
+            throw new IllegalStateException("Unsupported type " + field.asType().toString());
+        }
+        return type;
+    }
 }
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
index 1e43cb20b7..2f84e1f916 100644
--- a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
@@ -18,6 +18,7 @@
 
 import com.google.testing.compile.JavaFileObjects;
 
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.IOException;
@@ -29,6 +30,7 @@
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static org.truth0.Truth.ASSERT;
 
+
 public class RealmProcessorTest {
 
     private JavaFileObject simpleModel = JavaFileObjects.forResource("some/test/Simple.java");
@@ -195,7 +197,7 @@ public void compileLibraryModulesCustomClasses() throws Exception {
     public void compileAppModuleMixedParametersFail() throws Exception {
         ASSERT.about(javaSources())
                 .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource(
-                    "some/test/InvalidAllTypesModuleMixedParameters.java")))
+                        "some/test/InvalidAllTypesModuleMixedParameters.java")))
                 .processedWith(new RealmProcessor())
                 .failsToCompile();
     }
@@ -204,7 +206,7 @@ public void compileAppModuleMixedParametersFail() throws Exception {
     public void compileAppModuleWrongTypeFail() throws Exception {
         ASSERT.about(javaSources())
                 .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource(
-                    "some/test/InvalidAllTypesModuleWrongType.java")))
+                        "some/test/InvalidAllTypesModuleWrongType.java")))
                 .processedWith(new RealmProcessor())
                 .failsToCompile();
     }
@@ -265,7 +267,8 @@ public void compileMissingGenericType() {
                 .failsToCompile();
     }
 
-    // Disabled because it does not seem to find the generated Interface file @Test
+    @Test
+    @Ignore("Disabled because it does not find the generated Interface file")
     public void compileFieldNamesFiles() {
         ASSERT.about(javaSource())
                 .that(fieldNamesModel)
@@ -477,88 +480,88 @@ public void compileWithInterfaceForObject() {
     @Test
     public void compileBacklinks() {
         ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget))
-            .processedWith(new RealmProcessor())
-            .compilesWithoutError();
+                .that(Arrays.asList(backlinks, backlinksTarget))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
     }
 
     @Test
     public void failOnLinkingObjectsWithInvalidFieldType() {
         ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksInvalidField))
-            .processedWith(new RealmProcessor())
-            .failsToCompile()
-            .withErrorContaining("Fields annotated with @LinkingObjects must be RealmResults");
+                .that(Arrays.asList(backlinks, backlinksTarget, backlinksInvalidField))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("Fields annotated with @LinkingObjects must be RealmResults");
     }
 
     @Test
     public void failOnLinkingObjectsWithNonFinalField() {
         ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksNonFinalField))
-            .processedWith(new RealmProcessor())
-            .failsToCompile()
-            .withErrorContaining("must be final");
+                .that(Arrays.asList(backlinks, backlinksTarget, backlinksNonFinalField))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("must be final");
     }
 
     @Test
     public void failsOnLinkingObjectsWithLinkedFields() {
         ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksLinked))
-            .processedWith(new RealmProcessor())
-            .failsToCompile()
-            .withErrorContaining("The use of '.' to specify fields in referenced classes is not supported");
+                .that(Arrays.asList(backlinks, backlinksTarget, backlinksLinked))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("The use of '.' to specify fields in referenced classes is not supported");
     }
 
     @Test
     public void failsOnLinkingObjectsMissingFieldName() {
         ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksMissingParam))
-            .processedWith(new RealmProcessor())
-            .failsToCompile()
-            .withErrorContaining("must have a parameter identifying the link target");
+                .that(Arrays.asList(backlinks, backlinksTarget, backlinksMissingParam))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("must have a parameter identifying the link target");
     }
 
     @Test
     public void failsOnLinkingObjectsMissingGeneric() {
         ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksMissingGeneric))
-            .processedWith(new RealmProcessor())
-            .failsToCompile()
-            .withErrorContaining("must specify a generic type");
+                .that(Arrays.asList(backlinks, backlinksTarget, backlinksMissingGeneric))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("must specify a generic type");
     }
 
     @Test
     public void failsOnLinkingObjectsWithRequiredFields() {
         ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksRequired))
-            .processedWith(new RealmProcessor())
-            .failsToCompile()
-            .withErrorContaining("cannot be @Required");
+                .that(Arrays.asList(backlinks, backlinksTarget, backlinksRequired))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("cannot be @Required");
     }
 
     @Test
     public void failsOnLinkingObjectsWithIgnoreFields() {
         ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksIgnored))
-            .processedWith(new RealmProcessor())
-            .compilesWithoutError();
+                .that(Arrays.asList(backlinks, backlinksTarget, backlinksIgnored))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
     }
 
     @Test
     public void failsOnLinkingObjectsFieldNotFound() {
         ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksNotFound))
-            .processedWith(new RealmProcessor())
-            .failsToCompile()
-            .withErrorContaining("does not exist in class");
+                .that(Arrays.asList(backlinks, backlinksTarget, backlinksNotFound))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("does not exist in class");
     }
 
     @Test
     public void failsOnLinkingObjectsWithFieldWrongType() {
         ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksWrongType))
-            .processedWith(new RealmProcessor())
-            .failsToCompile()
-            .withErrorContaining("instead of");
+                .that(Arrays.asList(backlinks, backlinksTarget, backlinksWrongType))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("instead of");
     }
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 6a101e7c84..00265d3828 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -32,65 +32,57 @@
 public class AllTypesRealmProxy extends some.test.AllTypes
         implements RealmObjectProxy, AllTypesRealmProxyInterface {
 
-    static final class AllTypesColumnInfo extends ColumnInfo
-            implements Cloneable {
-
-        public long columnStringIndex;
-        public long columnLongIndex;
-        public long columnFloatIndex;
-        public long columnDoubleIndex;
-        public long columnBooleanIndex;
-        public long columnDateIndex;
-        public long columnBinaryIndex;
-        public long columnObjectIndex;
-        public long columnRealmListIndex;
-
-        AllTypesColumnInfo(String path, Table table) {
-            final Map<String, Long> indicesMap = new HashMap<String, Long>(9);
-            this.columnStringIndex = getValidColumnIndex(path, table, "AllTypes", "columnString");
-            indicesMap.put("columnString", this.columnStringIndex);
-            this.columnLongIndex = getValidColumnIndex(path, table, "AllTypes", "columnLong");
-            indicesMap.put("columnLong", this.columnLongIndex);
-            this.columnFloatIndex = getValidColumnIndex(path, table, "AllTypes", "columnFloat");
-            indicesMap.put("columnFloat", this.columnFloatIndex);
-            this.columnDoubleIndex = getValidColumnIndex(path, table, "AllTypes", "columnDouble");
-            indicesMap.put("columnDouble", this.columnDoubleIndex);
-            this.columnBooleanIndex = getValidColumnIndex(path, table, "AllTypes", "columnBoolean");
-            indicesMap.put("columnBoolean", this.columnBooleanIndex);
-            this.columnDateIndex = getValidColumnIndex(path, table, "AllTypes", "columnDate");
-            indicesMap.put("columnDate", this.columnDateIndex);
-            this.columnBinaryIndex = getValidColumnIndex(path, table, "AllTypes", "columnBinary");
-            indicesMap.put("columnBinary", this.columnBinaryIndex);
-            this.columnObjectIndex = getValidColumnIndex(path, table, "AllTypes", "columnObject");
-            indicesMap.put("columnObject", this.columnObjectIndex);
-            this.columnRealmListIndex = getValidColumnIndex(path, table, "AllTypes", "columnRealmList");
-            indicesMap.put("columnRealmList", this.columnRealmListIndex);
-
-            setIndicesMap(indicesMap);
+    static final class AllTypesColumnInfo extends ColumnInfo {
+        long columnStringIndex;
+        long columnLongIndex;
+        long columnFloatIndex;
+        long columnDoubleIndex;
+        long columnBooleanIndex;
+        long columnDateIndex;
+        long columnBinaryIndex;
+        long columnObjectIndex;
+        long columnRealmListIndex;
+
+        AllTypesColumnInfo(SharedRealm realm, Table table) {
+            super(9);
+            this.columnStringIndex = addColumnDetails(table, "columnString", RealmFieldType.STRING);
+            this.columnLongIndex = addColumnDetails(table, "columnLong", RealmFieldType.INTEGER);
+            this.columnFloatIndex = addColumnDetails(table, "columnFloat", RealmFieldType.FLOAT);
+            this.columnDoubleIndex = addColumnDetails(table, "columnDouble", RealmFieldType.DOUBLE);
+            this.columnBooleanIndex = addColumnDetails(table, "columnBoolean", RealmFieldType.BOOLEAN);
+            this.columnDateIndex = addColumnDetails(table, "columnDate", RealmFieldType.DATE);
+            this.columnBinaryIndex = addColumnDetails(table, "columnBinary", RealmFieldType.BINARY);
+            this.columnObjectIndex = addColumnDetails(table, "columnObject", RealmFieldType.OBJECT);
+            this.columnRealmListIndex = addColumnDetails(table, "columnRealmList", RealmFieldType.LIST);
+            addBacklinkDetails(realm, "parentObjects", "AllTypes", "columnObject");
+        }
+
+        AllTypesColumnInfo(ColumnInfo src, boolean mutable) {
+            super(src, mutable);
+            copy(src, this);
         }
 
         @Override
-        public final void copyColumnInfoFrom(ColumnInfo other) {
-            final AllTypesColumnInfo otherInfo = (AllTypesColumnInfo) other;
-            this.columnStringIndex = otherInfo.columnStringIndex;
-            this.columnLongIndex = otherInfo.columnLongIndex;
-            this.columnFloatIndex = otherInfo.columnFloatIndex;
-            this.columnDoubleIndex = otherInfo.columnDoubleIndex;
-            this.columnBooleanIndex = otherInfo.columnBooleanIndex;
-            this.columnDateIndex = otherInfo.columnDateIndex;
-            this.columnBinaryIndex = otherInfo.columnBinaryIndex;
-            this.columnObjectIndex = otherInfo.columnObjectIndex;
-            this.columnRealmListIndex = otherInfo.columnRealmListIndex;
-
-            setIndicesMap(otherInfo.getIndicesMap());
+        protected final ColumnInfo copy(boolean mutable) {
+            return new AllTypesColumnInfo(this, mutable);
         }
 
         @Override
-        public final AllTypesColumnInfo clone() {
-            return (AllTypesColumnInfo) super.clone();
+        protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
+            final AllTypesColumnInfo src = (AllTypesColumnInfo) rawSrc;
+            final AllTypesColumnInfo dst = (AllTypesColumnInfo) rawDst;
+            dst.columnStringIndex = src.columnStringIndex;
+            dst.columnLongIndex = src.columnLongIndex;
+            dst.columnFloatIndex = src.columnFloatIndex;
+            dst.columnDoubleIndex = src.columnDoubleIndex;
+            dst.columnBooleanIndex = src.columnBooleanIndex;
+            dst.columnDateIndex = src.columnDateIndex;
+            dst.columnBinaryIndex = src.columnBinaryIndex;
+            dst.columnObjectIndex = src.columnObjectIndex;
+            dst.columnRealmListIndex = src.columnRealmListIndex;
         }
-
     }
+
     private AllTypesColumnInfo columnInfo;
     private ProxyState<some.test.AllTypes> proxyState;
     private RealmList<some.test.AllTypes> columnRealmListRealmList;
@@ -400,7 +392,7 @@ public final AllTypesColumnInfo clone() {
         realm.checkIfValid();
         proxyState.getRow$realm().checkIfAttached();
         if (parentObjectsBacklinks == null) {
-            parentObjectsBacklinks = RealmResults.createBacklinkResults((Realm) realm, (UncheckedRow) proxyState.getRow$realm(), some.test.AllTypes.class, "columnObject");
+            parentObjectsBacklinks = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), some.test.AllTypes.class, "columnObject");
         }
         return parentObjectsBacklinks;
     }
@@ -449,7 +441,7 @@ public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean
             columnTypes.put(table.getColumnName(i), table.getColumnType(i));
         }
 
-        final AllTypesColumnInfo columnInfo = new AllTypesColumnInfo(sharedRealm.getPath(), table);
+        final AllTypesColumnInfo columnInfo = new AllTypesColumnInfo(sharedRealm, table);
 
         if (!table.hasPrimaryKey()) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. @PrimaryKey was added.");
@@ -888,7 +880,7 @@ public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel
             return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
         }
         Table table = realm.getTable(some.test.AllTypes.class);
-        long tableNativePtr = table.getNativeTablePointer();
+        long tableNativePtr = table.getNativePtr();
         AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
         long pkColumnIndex = table.getPrimaryKey();
         String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
@@ -943,7 +935,7 @@ public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel
 
     public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
         Table table = realm.getTable(some.test.AllTypes.class);
-        long tableNativePtr = table.getNativeTablePointer();
+        long tableNativePtr = table.getNativePtr();
         AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
         long pkColumnIndex = table.getPrimaryKey();
         some.test.AllTypes object = null;
@@ -1010,7 +1002,7 @@ public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<Re
             return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
         }
         Table table = realm.getTable(some.test.AllTypes.class);
-        long tableNativePtr = table.getNativeTablePointer();
+        long tableNativePtr = table.getNativePtr();
         AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
         long pkColumnIndex = table.getPrimaryKey();
         String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
@@ -1070,7 +1062,7 @@ public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<Re
 
     public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
         Table table = realm.getTable(some.test.AllTypes.class);
-        long tableNativePtr = table.getNativeTablePointer();
+        long tableNativePtr = table.getNativePtr();
         AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
         long pkColumnIndex = table.getPrimaryKey();
         some.test.AllTypes object = null;
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index 5a07ed0d92..cb4122faff 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -31,45 +31,41 @@
 public class BooleansRealmProxy extends some.test.Booleans
         implements RealmObjectProxy, BooleansRealmProxyInterface {
 
-    static final class BooleansColumnInfo extends ColumnInfo
-            implements Cloneable {
+    static final class BooleansColumnInfo extends ColumnInfo {
+        long doneIndex;
+        long isReadyIndex;
+        long mCompletedIndex;
+        long anotherBooleanIndex;
 
-        public long doneIndex;
-        public long isReadyIndex;
-        public long mCompletedIndex;
-        public long anotherBooleanIndex;
-
-        BooleansColumnInfo(String path, Table table) {
-            final Map<String, Long> indicesMap = new HashMap<String, Long>(4);
-            this.doneIndex = getValidColumnIndex(path, table, "Booleans", "done");
-            indicesMap.put("done", this.doneIndex);
-            this.isReadyIndex = getValidColumnIndex(path, table, "Booleans", "isReady");
-            indicesMap.put("isReady", this.isReadyIndex);
-            this.mCompletedIndex = getValidColumnIndex(path, table, "Booleans", "mCompleted");
-            indicesMap.put("mCompleted", this.mCompletedIndex);
-            this.anotherBooleanIndex = getValidColumnIndex(path, table, "Booleans", "anotherBoolean");
-            indicesMap.put("anotherBoolean", this.anotherBooleanIndex);
+        BooleansColumnInfo(SharedRealm realm, Table table) {
+            super(4);
+            this.doneIndex = addColumnDetails(table, "done", RealmFieldType.BOOLEAN);
+            this.isReadyIndex = addColumnDetails(table, "isReady", RealmFieldType.BOOLEAN);
+            this.mCompletedIndex = addColumnDetails(table, "mCompleted", RealmFieldType.BOOLEAN);
+            this.anotherBooleanIndex = addColumnDetails(table, "anotherBoolean", RealmFieldType.BOOLEAN);
+        }
 
-            setIndicesMap(indicesMap);
+        BooleansColumnInfo(ColumnInfo src, boolean mutable) {
+            super(src, mutable);
+            copy(src, this);
         }
 
         @Override
-        public final void copyColumnInfoFrom(ColumnInfo other) {
-            final BooleansColumnInfo otherInfo = (BooleansColumnInfo) other;
-            this.doneIndex = otherInfo.doneIndex;
-            this.isReadyIndex = otherInfo.isReadyIndex;
-            this.mCompletedIndex = otherInfo.mCompletedIndex;
-            this.anotherBooleanIndex = otherInfo.anotherBooleanIndex;
-
-            setIndicesMap(otherInfo.getIndicesMap());
+        protected final ColumnInfo copy(boolean mutable) {
+            return new BooleansColumnInfo(this, mutable);
         }
 
         @Override
-        public final BooleansColumnInfo clone() {
-            return (BooleansColumnInfo) super.clone();
+        protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
+            final BooleansColumnInfo src = (BooleansColumnInfo) rawSrc;
+            final BooleansColumnInfo dst = (BooleansColumnInfo) rawDst;
+            dst.doneIndex = src.doneIndex;
+            dst.isReadyIndex = src.isReadyIndex;
+            dst.mCompletedIndex = src.mCompletedIndex;
+            dst.anotherBooleanIndex = src.anotherBooleanIndex;
         }
-
     }
+
     private BooleansColumnInfo columnInfo;
     private ProxyState<some.test.Booleans> proxyState;
     private static final List<String> FIELD_NAMES;
@@ -221,7 +217,7 @@ public static BooleansColumnInfo validateTable(SharedRealm sharedRealm, boolean
             columnTypes.put(table.getColumnName(i), table.getColumnType(i));
         }
 
-        final BooleansColumnInfo columnInfo = new BooleansColumnInfo(sharedRealm.getPath(), table);
+        final BooleansColumnInfo columnInfo = new BooleansColumnInfo(sharedRealm, table);
 
         if (table.hasPrimaryKey()) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
@@ -394,7 +390,7 @@ public static long insert(Realm realm, some.test.Booleans object, Map<RealmModel
             return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
         }
         Table table = realm.getTable(some.test.Booleans.class);
-        long tableNativePtr = table.getNativeTablePointer();
+        long tableNativePtr = table.getNativePtr();
         BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
         long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
         cache.put(object, rowIndex);
@@ -407,7 +403,7 @@ public static long insert(Realm realm, some.test.Booleans object, Map<RealmModel
 
     public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
         Table table = realm.getTable(some.test.Booleans.class);
-        long tableNativePtr = table.getNativeTablePointer();
+        long tableNativePtr = table.getNativePtr();
         BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
         some.test.Booleans object = null;
         while (objects.hasNext()) {
@@ -432,7 +428,7 @@ public static long insertOrUpdate(Realm realm, some.test.Booleans object, Map<Re
             return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
         }
         Table table = realm.getTable(some.test.Booleans.class);
-        long tableNativePtr = table.getNativeTablePointer();
+        long tableNativePtr = table.getNativePtr();
         BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
         long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
         cache.put(object, rowIndex);
@@ -445,7 +441,7 @@ public static long insertOrUpdate(Realm realm, some.test.Booleans object, Map<Re
 
     public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
         Table table = realm.getTable(some.test.Booleans.class);
-        long tableNativePtr = table.getNativeTablePointer();
+        long tableNativePtr = table.getNativePtr();
         BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
         some.test.Booleans object = null;
         while (objects.hasNext()) {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index c91b122f0c..5fc1a098a3 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -31,113 +31,92 @@
 public class NullTypesRealmProxy extends some.test.NullTypes
         implements RealmObjectProxy, NullTypesRealmProxyInterface {
 
-    static final class NullTypesColumnInfo extends ColumnInfo
-            implements Cloneable {
-
-        public long fieldStringNotNullIndex;
-        public long fieldStringNullIndex;
-        public long fieldBooleanNotNullIndex;
-        public long fieldBooleanNullIndex;
-        public long fieldBytesNotNullIndex;
-        public long fieldBytesNullIndex;
-        public long fieldByteNotNullIndex;
-        public long fieldByteNullIndex;
-        public long fieldShortNotNullIndex;
-        public long fieldShortNullIndex;
-        public long fieldIntegerNotNullIndex;
-        public long fieldIntegerNullIndex;
-        public long fieldLongNotNullIndex;
-        public long fieldLongNullIndex;
-        public long fieldFloatNotNullIndex;
-        public long fieldFloatNullIndex;
-        public long fieldDoubleNotNullIndex;
-        public long fieldDoubleNullIndex;
-        public long fieldDateNotNullIndex;
-        public long fieldDateNullIndex;
-        public long fieldObjectNullIndex;
-
-        NullTypesColumnInfo(String path, Table table) {
-            final Map<String, Long> indicesMap = new HashMap<String, Long>(21);
-            this.fieldStringNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldStringNotNull");
-            indicesMap.put("fieldStringNotNull", this.fieldStringNotNullIndex);
-            this.fieldStringNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldStringNull");
-            indicesMap.put("fieldStringNull", this.fieldStringNullIndex);
-            this.fieldBooleanNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBooleanNotNull");
-            indicesMap.put("fieldBooleanNotNull", this.fieldBooleanNotNullIndex);
-            this.fieldBooleanNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBooleanNull");
-            indicesMap.put("fieldBooleanNull", this.fieldBooleanNullIndex);
-            this.fieldBytesNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBytesNotNull");
-            indicesMap.put("fieldBytesNotNull", this.fieldBytesNotNullIndex);
-            this.fieldBytesNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBytesNull");
-            indicesMap.put("fieldBytesNull", this.fieldBytesNullIndex);
-            this.fieldByteNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldByteNotNull");
-            indicesMap.put("fieldByteNotNull", this.fieldByteNotNullIndex);
-            this.fieldByteNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldByteNull");
-            indicesMap.put("fieldByteNull", this.fieldByteNullIndex);
-            this.fieldShortNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldShortNotNull");
-            indicesMap.put("fieldShortNotNull", this.fieldShortNotNullIndex);
-            this.fieldShortNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldShortNull");
-            indicesMap.put("fieldShortNull", this.fieldShortNullIndex);
-            this.fieldIntegerNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldIntegerNotNull");
-            indicesMap.put("fieldIntegerNotNull", this.fieldIntegerNotNullIndex);
-            this.fieldIntegerNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldIntegerNull");
-            indicesMap.put("fieldIntegerNull", this.fieldIntegerNullIndex);
-            this.fieldLongNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldLongNotNull");
-            indicesMap.put("fieldLongNotNull", this.fieldLongNotNullIndex);
-            this.fieldLongNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldLongNull");
-            indicesMap.put("fieldLongNull", this.fieldLongNullIndex);
-            this.fieldFloatNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldFloatNotNull");
-            indicesMap.put("fieldFloatNotNull", this.fieldFloatNotNullIndex);
-            this.fieldFloatNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldFloatNull");
-            indicesMap.put("fieldFloatNull", this.fieldFloatNullIndex);
-            this.fieldDoubleNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDoubleNotNull");
-            indicesMap.put("fieldDoubleNotNull", this.fieldDoubleNotNullIndex);
-            this.fieldDoubleNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDoubleNull");
-            indicesMap.put("fieldDoubleNull", this.fieldDoubleNullIndex);
-            this.fieldDateNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDateNotNull");
-            indicesMap.put("fieldDateNotNull", this.fieldDateNotNullIndex);
-            this.fieldDateNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDateNull");
-            indicesMap.put("fieldDateNull", this.fieldDateNullIndex);
-            this.fieldObjectNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldObjectNull");
-            indicesMap.put("fieldObjectNull", this.fieldObjectNullIndex);
-
-            setIndicesMap(indicesMap);
+    static final class NullTypesColumnInfo extends ColumnInfo {
+        long fieldStringNotNullIndex;
+        long fieldStringNullIndex;
+        long fieldBooleanNotNullIndex;
+        long fieldBooleanNullIndex;
+        long fieldBytesNotNullIndex;
+        long fieldBytesNullIndex;
+        long fieldByteNotNullIndex;
+        long fieldByteNullIndex;
+        long fieldShortNotNullIndex;
+        long fieldShortNullIndex;
+        long fieldIntegerNotNullIndex;
+        long fieldIntegerNullIndex;
+        long fieldLongNotNullIndex;
+        long fieldLongNullIndex;
+        long fieldFloatNotNullIndex;
+        long fieldFloatNullIndex;
+        long fieldDoubleNotNullIndex;
+        long fieldDoubleNullIndex;
+        long fieldDateNotNullIndex;
+        long fieldDateNullIndex;
+        long fieldObjectNullIndex;
+
+        NullTypesColumnInfo(SharedRealm realm, Table table) {
+            super(21);
+            this.fieldStringNotNullIndex = addColumnDetails(table, "fieldStringNotNull", RealmFieldType.STRING);
+            this.fieldStringNullIndex = addColumnDetails(table, "fieldStringNull", RealmFieldType.STRING);
+            this.fieldBooleanNotNullIndex = addColumnDetails(table, "fieldBooleanNotNull", RealmFieldType.BOOLEAN);
+            this.fieldBooleanNullIndex = addColumnDetails(table, "fieldBooleanNull", RealmFieldType.BOOLEAN);
+            this.fieldBytesNotNullIndex = addColumnDetails(table, "fieldBytesNotNull", RealmFieldType.BINARY);
+            this.fieldBytesNullIndex = addColumnDetails(table, "fieldBytesNull", RealmFieldType.BINARY);
+            this.fieldByteNotNullIndex = addColumnDetails(table, "fieldByteNotNull", RealmFieldType.INTEGER);
+            this.fieldByteNullIndex = addColumnDetails(table, "fieldByteNull", RealmFieldType.INTEGER);
+            this.fieldShortNotNullIndex = addColumnDetails(table, "fieldShortNotNull", RealmFieldType.INTEGER);
+            this.fieldShortNullIndex = addColumnDetails(table, "fieldShortNull", RealmFieldType.INTEGER);
+            this.fieldIntegerNotNullIndex = addColumnDetails(table, "fieldIntegerNotNull", RealmFieldType.INTEGER);
+            this.fieldIntegerNullIndex = addColumnDetails(table, "fieldIntegerNull", RealmFieldType.INTEGER);
+            this.fieldLongNotNullIndex = addColumnDetails(table, "fieldLongNotNull", RealmFieldType.INTEGER);
+            this.fieldLongNullIndex = addColumnDetails(table, "fieldLongNull", RealmFieldType.INTEGER);
+            this.fieldFloatNotNullIndex = addColumnDetails(table, "fieldFloatNotNull", RealmFieldType.FLOAT);
+            this.fieldFloatNullIndex = addColumnDetails(table, "fieldFloatNull", RealmFieldType.FLOAT);
+            this.fieldDoubleNotNullIndex = addColumnDetails(table, "fieldDoubleNotNull", RealmFieldType.DOUBLE);
+            this.fieldDoubleNullIndex = addColumnDetails(table, "fieldDoubleNull", RealmFieldType.DOUBLE);
+            this.fieldDateNotNullIndex = addColumnDetails(table, "fieldDateNotNull", RealmFieldType.DATE);
+            this.fieldDateNullIndex = addColumnDetails(table, "fieldDateNull", RealmFieldType.DATE);
+            this.fieldObjectNullIndex = addColumnDetails(table, "fieldObjectNull", RealmFieldType.OBJECT);
+        }
+
+        NullTypesColumnInfo(ColumnInfo src, boolean mutable) {
+            super(src, mutable);
+            copy(src, this);
         }
 
         @Override
-        public final void copyColumnInfoFrom(ColumnInfo other) {
-            final NullTypesColumnInfo otherInfo = (NullTypesColumnInfo) other;
-            this.fieldStringNotNullIndex = otherInfo.fieldStringNotNullIndex;
-            this.fieldStringNullIndex = otherInfo.fieldStringNullIndex;
-            this.fieldBooleanNotNullIndex = otherInfo.fieldBooleanNotNullIndex;
-            this.fieldBooleanNullIndex = otherInfo.fieldBooleanNullIndex;
-            this.fieldBytesNotNullIndex = otherInfo.fieldBytesNotNullIndex;
-            this.fieldBytesNullIndex = otherInfo.fieldBytesNullIndex;
-            this.fieldByteNotNullIndex = otherInfo.fieldByteNotNullIndex;
-            this.fieldByteNullIndex = otherInfo.fieldByteNullIndex;
-            this.fieldShortNotNullIndex = otherInfo.fieldShortNotNullIndex;
-            this.fieldShortNullIndex = otherInfo.fieldShortNullIndex;
-            this.fieldIntegerNotNullIndex = otherInfo.fieldIntegerNotNullIndex;
-            this.fieldIntegerNullIndex = otherInfo.fieldIntegerNullIndex;
-            this.fieldLongNotNullIndex = otherInfo.fieldLongNotNullIndex;
-            this.fieldLongNullIndex = otherInfo.fieldLongNullIndex;
-            this.fieldFloatNotNullIndex = otherInfo.fieldFloatNotNullIndex;
-            this.fieldFloatNullIndex = otherInfo.fieldFloatNullIndex;
-            this.fieldDoubleNotNullIndex = otherInfo.fieldDoubleNotNullIndex;
-            this.fieldDoubleNullIndex = otherInfo.fieldDoubleNullIndex;
-            this.fieldDateNotNullIndex = otherInfo.fieldDateNotNullIndex;
-            this.fieldDateNullIndex = otherInfo.fieldDateNullIndex;
-            this.fieldObjectNullIndex = otherInfo.fieldObjectNullIndex;
-
-            setIndicesMap(otherInfo.getIndicesMap());
+        protected final ColumnInfo copy(boolean mutable) {
+            return new NullTypesColumnInfo(this, mutable);
         }
 
         @Override
-        public final NullTypesColumnInfo clone() {
-            return (NullTypesColumnInfo) super.clone();
+        protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
+            final NullTypesColumnInfo src = (NullTypesColumnInfo) rawSrc;
+            final NullTypesColumnInfo dst = (NullTypesColumnInfo) rawDst;
+            dst.fieldStringNotNullIndex = src.fieldStringNotNullIndex;
+            dst.fieldStringNullIndex = src.fieldStringNullIndex;
+            dst.fieldBooleanNotNullIndex = src.fieldBooleanNotNullIndex;
+            dst.fieldBooleanNullIndex = src.fieldBooleanNullIndex;
+            dst.fieldBytesNotNullIndex = src.fieldBytesNotNullIndex;
+            dst.fieldBytesNullIndex = src.fieldBytesNullIndex;
+            dst.fieldByteNotNullIndex = src.fieldByteNotNullIndex;
+            dst.fieldByteNullIndex = src.fieldByteNullIndex;
+            dst.fieldShortNotNullIndex = src.fieldShortNotNullIndex;
+            dst.fieldShortNullIndex = src.fieldShortNullIndex;
+            dst.fieldIntegerNotNullIndex = src.fieldIntegerNotNullIndex;
+            dst.fieldIntegerNullIndex = src.fieldIntegerNullIndex;
+            dst.fieldLongNotNullIndex = src.fieldLongNotNullIndex;
+            dst.fieldLongNullIndex = src.fieldLongNullIndex;
+            dst.fieldFloatNotNullIndex = src.fieldFloatNotNullIndex;
+            dst.fieldFloatNullIndex = src.fieldFloatNullIndex;
+            dst.fieldDoubleNotNullIndex = src.fieldDoubleNotNullIndex;
+            dst.fieldDoubleNullIndex = src.fieldDoubleNullIndex;
+            dst.fieldDateNotNullIndex = src.fieldDateNotNullIndex;
+            dst.fieldDateNullIndex = src.fieldDateNullIndex;
+            dst.fieldObjectNullIndex = src.fieldObjectNullIndex;
         }
-
     }
+
     private NullTypesColumnInfo columnInfo;
     private ProxyState<some.test.NullTypes> proxyState;
     private static final List<String> FIELD_NAMES;
@@ -893,7 +872,7 @@ public static NullTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean
             columnTypes.put(table.getColumnName(i), table.getColumnType(i));
         }
 
-        final NullTypesColumnInfo columnInfo = new NullTypesColumnInfo(sharedRealm.getPath(), table);
+        final NullTypesColumnInfo columnInfo = new NullTypesColumnInfo(sharedRealm, table);
 
         if (table.hasPrimaryKey()) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
@@ -1514,7 +1493,7 @@ public static long insert(Realm realm, some.test.NullTypes object, Map<RealmMode
             return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
         }
         Table table = realm.getTable(some.test.NullTypes.class);
-        long tableNativePtr = table.getNativeTablePointer();
+        long tableNativePtr = table.getNativePtr();
         NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.schema.getColumnInfo(some.test.NullTypes.class);
         long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
         cache.put(object, rowIndex);
@@ -1612,7 +1591,7 @@ public static long insert(Realm realm, some.test.NullTypes object, Map<RealmMode
 
     public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
         Table table = realm.getTable(some.test.NullTypes.class);
-        long tableNativePtr = table.getNativeTablePointer();
+        long tableNativePtr = table.getNativePtr();
         NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.schema.getColumnInfo(some.test.NullTypes.class);
         some.test.NullTypes object = null;
         while (objects.hasNext()) {
@@ -1722,7 +1701,7 @@ public static long insertOrUpdate(Realm realm, some.test.NullTypes object, Map<R
             return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
         }
         Table table = realm.getTable(some.test.NullTypes.class);
-        long tableNativePtr = table.getNativeTablePointer();
+        long tableNativePtr = table.getNativePtr();
         NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.schema.getColumnInfo(some.test.NullTypes.class);
         long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
         cache.put(object, rowIndex);
@@ -1862,7 +1841,7 @@ public static long insertOrUpdate(Realm realm, some.test.NullTypes object, Map<R
 
     public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
         Table table = realm.getTable(some.test.NullTypes.class);
-        long tableNativePtr = table.getNativeTablePointer();
+        long tableNativePtr = table.getNativePtr();
         NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.schema.getColumnInfo(some.test.NullTypes.class);
         some.test.NullTypes object = null;
         while (objects.hasNext()) {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 030081db38..b5bb229267 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -31,37 +31,35 @@
 public class SimpleRealmProxy extends some.test.Simple
         implements RealmObjectProxy, SimpleRealmProxyInterface {
 
-    static final class SimpleColumnInfo extends ColumnInfo
-            implements Cloneable {
+    static final class SimpleColumnInfo extends ColumnInfo {
+        long nameIndex;
+        long ageIndex;
 
-        public long nameIndex;
-        public long ageIndex;
-
-        SimpleColumnInfo(String path, Table table) {
-            final Map<String, Long> indicesMap = new HashMap<String, Long>(2);
-            this.nameIndex = getValidColumnIndex(path, table, "Simple", "name");
-            indicesMap.put("name", this.nameIndex);
-            this.ageIndex = getValidColumnIndex(path, table, "Simple", "age");
-            indicesMap.put("age", this.ageIndex);
+        SimpleColumnInfo(SharedRealm realm, Table table) {
+            super(2);
+            this.nameIndex = addColumnDetails(table, "name", RealmFieldType.STRING);
+            this.ageIndex = addColumnDetails(table, "age", RealmFieldType.INTEGER);
+        }
 
-            setIndicesMap(indicesMap);
+        SimpleColumnInfo(ColumnInfo src, boolean mutable) {
+            super(src, mutable);
+            copy(src, this);
         }
 
         @Override
-        public final void copyColumnInfoFrom(ColumnInfo other) {
-            final SimpleColumnInfo otherInfo = (SimpleColumnInfo) other;
-            this.nameIndex = otherInfo.nameIndex;
-            this.ageIndex = otherInfo.ageIndex;
-
-            setIndicesMap(otherInfo.getIndicesMap());
+        protected final ColumnInfo copy(boolean mutable) {
+            return new SimpleColumnInfo(this, mutable);
         }
 
         @Override
-        public final SimpleColumnInfo clone() {
-            return (SimpleColumnInfo) super.clone();
+        protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
+            final SimpleColumnInfo src = (SimpleColumnInfo) rawSrc;
+            final SimpleColumnInfo dst = (SimpleColumnInfo) rawDst;
+            dst.nameIndex = src.nameIndex;
+            dst.ageIndex = src.ageIndex;
         }
-
     }
+
     private SimpleColumnInfo columnInfo;
     private ProxyState<some.test.Simple> proxyState;
     private static final List<String> FIELD_NAMES;
@@ -173,7 +171,7 @@ public static SimpleColumnInfo validateTable(SharedRealm sharedRealm, boolean al
             columnTypes.put(table.getColumnName(i), table.getColumnType(i));
         }
 
-        final SimpleColumnInfo columnInfo = new SimpleColumnInfo(sharedRealm.getPath(), table);
+        final SimpleColumnInfo columnInfo = new SimpleColumnInfo(sharedRealm, table);
 
         if (table.hasPrimaryKey()) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
@@ -298,7 +296,7 @@ public static long insert(Realm realm, some.test.Simple object, Map<RealmModel,L
             return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
         }
         Table table = realm.getTable(some.test.Simple.class);
-        long tableNativePtr = table.getNativeTablePointer();
+        long tableNativePtr = table.getNativePtr();
         SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(some.test.Simple.class);
         long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
         cache.put(object, rowIndex);
@@ -312,7 +310,7 @@ public static long insert(Realm realm, some.test.Simple object, Map<RealmModel,L
 
     public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
         Table table = realm.getTable(some.test.Simple.class);
-        long tableNativePtr = table.getNativeTablePointer();
+        long tableNativePtr = table.getNativePtr();
         SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(some.test.Simple.class);
         some.test.Simple object = null;
         while (objects.hasNext()) {
@@ -338,7 +336,7 @@ public static long insertOrUpdate(Realm realm, some.test.Simple object, Map<Real
             return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
         }
         Table table = realm.getTable(some.test.Simple.class);
-        long tableNativePtr = table.getNativeTablePointer();
+        long tableNativePtr = table.getNativePtr();
         SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(some.test.Simple.class);
         long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
         cache.put(object, rowIndex);
@@ -354,7 +352,7 @@ public static long insertOrUpdate(Realm realm, some.test.Simple object, Map<Real
 
     public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
         Table table = realm.getTable(some.test.Simple.class);
-        long tableNativePtr = table.getNativeTablePointer();
+        long tableNativePtr = table.getNativePtr();
         SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(some.test.Simple.class);
         some.test.Simple object = null;
         while (objects.hasNext()) {
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index 8d8616a30d..e27f97fb91 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -155,7 +155,7 @@ dependencies {
     androidTestAnnotationProcessor project(':realm-annotations-processor')
     androidTestCompile fileTree(dir: 'testLibs', include: ['*.jar'])
     androidTestCompile 'io.reactivex:rxjava:1.1.0'
-    androidTestCompile 'com.android.support:support-annotations:25.2.0'
+    androidTestCompile 'com.android.support:support-annotations:25.3.1'
     androidTestCompile 'com.android.support.test:runner:0.5'
     androidTestCompile 'com.android.support.test:rules:0.5'
     androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java b/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
index d8cfe9972b..82f9726ad9 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
@@ -39,6 +39,7 @@
 import static junit.framework.Assert.assertSame;
 import static org.junit.Assert.assertNotEquals;
 
+
 @RunWith(AndroidJUnit4.class)
 public class ColumnIndicesTests {
     @Rule
@@ -81,18 +82,20 @@ public void copyDeeply() {
         final long schemaVersion = 100;
 
         final ColumnIndices columnIndices = create(schemaVersion);
-        final ColumnIndices deepCopy = columnIndices.clone();
+        final ColumnIndices deepCopy = new ColumnIndices(columnIndices, true);
+        assertNotSame(columnIndices, deepCopy);
 
         assertEquals(schemaVersion, deepCopy.getSchemaVersion());
-        assertEquals(columnIndices.getColumnIndex(Cat.class, Cat.FIELD_NAME),
-                deepCopy.getColumnIndex(Cat.class, Cat.FIELD_NAME));
-        assertEquals(columnIndices.getColumnIndex(Dog.class, Dog.FIELD_AGE),
-                deepCopy.getColumnIndex(Dog.class, Dog.FIELD_AGE));
 
-        // Checks if those are different instance.
-        assertNotSame(columnIndices, deepCopy);
-        assertNotSame(columnIndices.getColumnInfo(Cat.class), deepCopy.getColumnInfo(Cat.class));
-        assertNotSame(columnIndices.getColumnInfo(Dog.class), deepCopy.getColumnInfo(Dog.class));
+        ColumnInfo colInfo = columnIndices.getColumnInfo(Cat.class);
+        ColumnInfo colInfoCopy = deepCopy.getColumnInfo(Cat.class);
+        assertNotSame(colInfo, colInfoCopy);
+        assertEquals(colInfo.getColumnIndex(Cat.FIELD_NAME), colInfoCopy.getColumnIndex(Cat.FIELD_NAME));
+
+        colInfo = columnIndices.getColumnInfo(Dog.class);
+        colInfoCopy = deepCopy.getColumnInfo(Dog.class);
+        assertNotSame(colInfo, colInfoCopy);
+        assertEquals(colInfo.getColumnIndex(Dog.FIELD_AGE), colInfoCopy.getColumnIndex(Dog.FIELD_AGE));
     }
 
     @Test
@@ -112,10 +115,11 @@ public void copyFrom() {
         assertNotEquals(catColumnInfoInSource.nameIndex, catColumnInfoInTarget.nameIndex);
         assertNotSame(catColumnInfoInSource.getIndicesMap(), catColumnInfoInTarget.getIndicesMap());
 
-        target.copyFrom(source,  mediator);
+        target.copyFrom(source);
 
         assertEquals(sourceSchemaVersion, target.getSchemaVersion());
         assertEquals(catColumnInfoInSource.nameIndex, catColumnInfoInTarget.nameIndex);
-        assertSame(catColumnInfoInSource.getIndicesMap(), catColumnInfoInTarget.getIndicesMap());
+        // update, not replace
+        assertSame(catColumnInfoInTarget, target.getColumnInfo(Cat.class));
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java b/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java
index 618c54d588..6fcebce670 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java
@@ -30,7 +30,8 @@
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertNotSame;
-import static junit.framework.Assert.assertSame;
+import static junit.framework.Assert.fail;
+
 
 @RunWith(AndroidJUnit4.class)
 public class ColumnInfoTests {
@@ -40,11 +41,13 @@
     public final ExpectedException thrown = ExpectedException.none();
 
     private Realm realm;
+    private RealmProxyMediator mediator;
 
     @Before
     public void setUp() {
         RealmConfiguration config = configFactory.createConfiguration();
         realm = Realm.getInstance(config);
+        mediator = realm.getConfiguration().getSchemaMediator();
     }
 
     @After
@@ -56,10 +59,10 @@ public void tearDown() {
 
     @Test
     public void copyColumnInfoFrom_checkIndex() {
-        final RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
-        final CatRealmProxy.CatColumnInfo sourceColumnInfo, targetColumnInfo;
-        sourceColumnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
-        targetColumnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+        CatRealmProxy.CatColumnInfo sourceColumnInfo
+                = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+        CatRealmProxy.CatColumnInfo targetColumnInfo
+                = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
 
         // Checks precondition.
         assertNotSame(sourceColumnInfo, targetColumnInfo);
@@ -83,26 +86,22 @@ public void copyColumnInfoFrom_checkIndex() {
         targetColumnInfo.ownerIndex = 0;
         targetColumnInfo.scaredOfDogIndex = 0;
 
-        targetColumnInfo.copyColumnInfoFrom(sourceColumnInfo);
-
-        assertEquals(1, targetColumnInfo.nameIndex);
-        assertEquals(2, targetColumnInfo.ageIndex);
-        assertEquals(3, targetColumnInfo.heightIndex);
-        assertEquals(4, targetColumnInfo.weightIndex);
-        assertEquals(5, targetColumnInfo.hasTailIndex);
-        assertEquals(6, targetColumnInfo.birthdayIndex);
-        assertEquals(7, targetColumnInfo.ownerIndex);
-        assertEquals(8, targetColumnInfo.scaredOfDogIndex);
+        targetColumnInfo.copyFrom(sourceColumnInfo);
 
-        // Current implementation shares the indices map.
-        assertSame(sourceColumnInfo.getIndicesMap(), targetColumnInfo.getIndicesMap());
+        assertEquals(sourceColumnInfo.nameIndex, targetColumnInfo.nameIndex);
+        assertEquals(sourceColumnInfo.ageIndex, targetColumnInfo.ageIndex);
+        assertEquals(sourceColumnInfo.heightIndex, targetColumnInfo.heightIndex);
+        assertEquals(sourceColumnInfo.weightIndex, targetColumnInfo.weightIndex);
+        assertEquals(sourceColumnInfo.hasTailIndex, targetColumnInfo.hasTailIndex);
+        assertEquals(sourceColumnInfo.birthdayIndex, targetColumnInfo.birthdayIndex);
+        assertEquals(sourceColumnInfo.ownerIndex, targetColumnInfo.ownerIndex);
+        assertEquals(sourceColumnInfo.scaredOfDogIndex, targetColumnInfo.scaredOfDogIndex);
     }
 
     @Test
-    public void clone_hasSameValue() {
-        final RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
-        final CatRealmProxy.CatColumnInfo columnInfo;
-        columnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+    public void copy_differentInstanceSameValues() {
+        final CatRealmProxy.CatColumnInfo columnInfo
+                = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
 
         columnInfo.nameIndex = 1;
         columnInfo.ageIndex = 2;
@@ -113,9 +112,21 @@ public void clone_hasSameValue() {
         columnInfo.ownerIndex = 7;
         columnInfo.scaredOfDogIndex = 8;
 
-        CatRealmProxy.CatColumnInfo copy = columnInfo.clone();
+        CatRealmProxy.CatColumnInfo copy = (CatRealmProxy.CatColumnInfo) columnInfo.copy(true);
 
-        // Modifies original object.
+        // verify that the copy is identical
+        assertNotSame(columnInfo, copy);
+        assertEquals(columnInfo.getIndicesMap(), copy.getIndicesMap());
+        assertEquals(columnInfo.nameIndex, copy.nameIndex);
+        assertEquals(columnInfo.ageIndex, copy.ageIndex);
+        assertEquals(columnInfo.heightIndex, copy.heightIndex);
+        assertEquals(columnInfo.weightIndex, copy.weightIndex);
+        assertEquals(columnInfo.hasTailIndex, copy.hasTailIndex);
+        assertEquals(columnInfo.birthdayIndex, copy.birthdayIndex);
+        assertEquals(columnInfo.ownerIndex, copy.ownerIndex);
+        assertEquals(columnInfo.scaredOfDogIndex, copy.scaredOfDogIndex);
+
+        // Modify original object
         columnInfo.nameIndex = 0;
         columnInfo.ageIndex = 0;
         columnInfo.heightIndex = 0;
@@ -125,8 +136,7 @@ public void clone_hasSameValue() {
         columnInfo.ownerIndex = 0;
         columnInfo.scaredOfDogIndex = 0;
 
-        assertNotSame(columnInfo, copy);
-
+        // the copy should not change
         assertEquals(1, copy.nameIndex);
         assertEquals(2, copy.ageIndex);
         assertEquals(3, copy.heightIndex);
@@ -135,8 +145,18 @@ public void clone_hasSameValue() {
         assertEquals(6, copy.birthdayIndex);
         assertEquals(7, copy.ownerIndex);
         assertEquals(8, copy.scaredOfDogIndex);
+    }
 
-        // Current implementation shares the indices map between copies.
-        assertSame(columnInfo.getIndicesMap(), copy.getIndicesMap());
+    @Test
+    public void copy_immutableThrows() {
+        final CatRealmProxy.CatColumnInfo original
+                = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+
+        CatRealmProxy.CatColumnInfo copy = (CatRealmProxy.CatColumnInfo) original.copy(false);
+        try {
+            copy.copyFrom(original);
+            fail("Attempt to copy to an immutable ColumnInfo should throwS");
+        } catch (UnsupportedOperationException ignore) {
+        }
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index a7c99b4fb4..400f618dc9 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -675,7 +675,7 @@ public void equalTo_noFieldObjectShouldThrow() {
         dynamicRealm.commitTransaction();
 
         thrown.expect(IllegalArgumentException.class);
-        thrown.expectMessage("Invalid query: field 'nonExisting' does not exist in table 'NoField'.");
+        thrown.expectMessage("Invalid query: field 'nonExisting' not found in table 'NoField'.");
         dynamicRealm.where(className).equalTo("nonExisting", 1);
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
index c11178f0eb..1d231e4d23 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
@@ -174,14 +174,17 @@ public void linkingObjects_invalidFieldType() {
         for (RealmFieldType fieldType : RealmFieldType.values()) {
             try {
                 switch (fieldType) {
+                    // skip unsupported types
+                    case UNSUPPORTED_TABLE: // fall-through
+                    case UNSUPPORTED_MIXED: // fall-through
+                    case UNSUPPORTED_DATE:
+                        continue;
                     // skip valid types
                     case OBJECT: // fall-through
                     case LIST:
                         continue;
-                        // skip unsupported types
-                    case UNSUPPORTED_TABLE: // fall-through
-                    case UNSUPPORTED_MIXED: // fall-through
-                    case UNSUPPORTED_DATE:
+                    // skip special case
+                    case LINKING_OBJECTS:
                         continue;
                     case INTEGER:
                         object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_INT);
@@ -213,6 +216,16 @@ public void linkingObjects_invalidFieldType() {
                 assertTrue(expected.getMessage().startsWith("Unexpected field type"));
             }
         }
+
+        // Linking Object fields are implicit and do not exist.
+        for (String field : new String[] {AllJavaTypes.FIELD_LO_OBJECT, AllJavaTypes.FIELD_LO_LIST}) {
+            try {
+                object.linkingObjects(AllJavaTypes.CLASS_NAME, field);
+                fail();
+            } catch (IllegalArgumentException expected) {
+                assertTrue(expected.getMessage().contains("does not exist"));
+            }
+        }
     }
 
     @Test
@@ -486,12 +499,12 @@ public void execute(DynamicRealm realm) {
     @Test
     public void dynamicQuery_invalidSyntax() {
         String[] invalidBacklinks = new String[] {
-            "linkingObject(x",
-            "linkingObject(x.y",
-            "linkingObject(x.y)",
-            "linkingObject(x.y).",
-            "linkingObject(x.y)..z",
-            "linkingObject(x.y).linkingObjects(x1.y1).z"
+                "linkingObject(x",
+                "linkingObject(x.y",
+                "linkingObject(x.y)",
+                "linkingObject(x.y).",
+                "linkingObject(x.y)..z",
+                "linkingObject(x.y).linkingObjects(x1.y1).z"
         };
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
index b729034259..2d61e6b637 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
@@ -29,7 +29,6 @@
 import org.junit.runner.RunWith;
 
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.entities.AllJavaTypes;
@@ -51,6 +50,7 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+
 @RunWith(AndroidJUnit4.class)
 public class LinkingObjectsManagedTests {
     private interface PostConditions {
@@ -148,6 +148,7 @@ public void basic_multipleReferencesFromParentList() {
         // One entry for each reference, so two references from a LinkList will
         // result in two backlinks.
         assertEquals(2, child.getListParents().size());
+
         assertEquals(parent, child.getListParents().first());
         assertEquals(parent, child.getListParents().last());
     }
@@ -193,14 +194,14 @@ public void onChange(AllJavaTypes object) {
         looperThreadRealm.commitTransaction();
 
         verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
-                }
-            },
-            child, parent);
+                looperThreadRealm,
+                new PostConditions() {
+                    @Override
+                    public void run(Realm realm) {
+                        assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                    }
+                },
+                child, parent);
     }
 
     // A listener registered on the backlinked field should be called when a commit adds a backlink
@@ -228,15 +229,15 @@ public void onChange(RealmResults<AllJavaTypes> object) {
         looperThreadRealm.commitTransaction();
 
         verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
-                    assertEquals(1, counter.get());
-                }
-            },
-            child, parent);
+                looperThreadRealm,
+                new PostConditions() {
+                    @Override
+                    public void run(Realm realm) {
+                        assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                        assertEquals(1, counter.get());
+                    }
+                },
+                child, parent);
     }
 
     // A listener registered on the backlinked field should not be called after the listener is removed
@@ -265,14 +266,14 @@ public void onChange(RealmResults<AllJavaTypes> object) {
         looperThreadRealm.commitTransaction();
 
         verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
-                }
-            },
-            child, parent);
+                looperThreadRealm,
+                new PostConditions() {
+                    @Override
+                    public void run(Realm realm) {
+                        assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                    }
+                },
+                child, parent);
     }
 
     // A listener registered on the backlinked object should be called when a backlinked object is deleted
@@ -301,15 +302,15 @@ public void onChange(RealmResults<AllJavaTypes> object) {
         looperThreadRealm.commitTransaction();
 
         verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
-                    assertEquals(1, counter.get());
-                }
-            },
-            child, parent);
+                looperThreadRealm,
+                new PostConditions() {
+                    @Override
+                    public void run(Realm realm) {
+                        assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                        assertEquals(1, counter.get());
+                    }
+                },
+                child, parent);
     }
 
     // A listener registered on the backlinked object should not called for an unrelated change
@@ -336,14 +337,14 @@ public void onChange(RealmResults<AllJavaTypes> object) {
         looperThreadRealm.commitTransaction();
 
         verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
-                }
-            },
-            child, parent);
+                looperThreadRealm,
+                new PostConditions() {
+                    @Override
+                    public void run(Realm realm) {
+                        assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                    }
+                },
+                child, parent);
     }
 
     // Fields annotated with @LinkingObjects should not be affected by JSON updates
@@ -516,9 +517,9 @@ public void migration_backlinkedFieldInUse() {
         final String realmName = "backlinks-fieldInUse.realm";
 
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
-            .name(realmName)
-            .schema(BacklinksSource.class, BacklinksTarget.class)
-            .build();
+                .name(realmName)
+                .schema(BacklinksSource.class, BacklinksTarget.class)
+                .build();
 
         try {
             configFactory.copyRealmFromAssets(context, realmName, realmName);
@@ -551,14 +552,15 @@ public void migration_backlinkedFieldInUse() {
      * basic validation passes.  Backlink validation, however, should fail, seeking the
      * `BacklinksSource` table.
      */
+    @Ignore("Need to rebuild the test library")
     @Test
     public void migration_backlinkedSourceClassDoesntExist() throws IOException {
         final String realmName = "backlinks-missingSourceClass.realm";
 
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
-            .name(realmName)
-            .schema(BacklinksTarget.class)
-            .build();
+                .name(realmName)
+                .schema(BacklinksTarget.class)
+                .build();
 
         try {
             configFactory.copyRealmFromAssets(context, realmName, realmName);
@@ -592,14 +594,15 @@ public void migration_backlinkedSourceClassDoesntExist() throws IOException {
      * validate its table.  If we have been living clean lives, though, the validator for
      * `BacklinksMissingFieldTarget` should notice that there is no field named `BacklinksMissingFieldSource.xxxchild`.
      */
+    @Ignore("Need to rebuild the test library")
     @Test
     public void migration_backlinkedSourceFieldDoesntExist() {
         final String realmName = "backlinks-missingSourceField.realm";
 
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
-            .name(realmName)
-            .modules(new BacklinksMissingFieldSourceModule(), new BacklinksMissingFieldTargetModule())
-            .build();
+                .name(realmName)
+                .modules(new BacklinksMissingFieldSourceModule(), new BacklinksMissingFieldTargetModule())
+                .build();
 
         try {
             configFactory.copyRealmFromAssets(context, realmName, realmName);
@@ -630,14 +633,15 @@ public void migration_backlinkedSourceFieldDoesntExist() {
      * for `BacklinksWrongTypeTarget` should notice, though, that its `parents` field points to an object
      * of the wrong type, `Integer`, instead of `BacklinksWrongTypeSource`.
      */
+    @Ignore("Need to rebuild the test library")
     @Test
     public void migration_backlinkedSourceFieldWrongType() {
         final String realmName = "backlinks-sourceFieldWrongType.realm";
 
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
-            .name(realmName)
-            .modules(new BacklinksWrongTypeSourceModule(), new BacklinksWrongTypeTargetModule())
-            .build();
+                .name(realmName)
+                .modules(new BacklinksWrongTypeSourceModule(), new BacklinksWrongTypeTargetModule())
+                .build();
 
         try {
             configFactory.copyRealmFromAssets(context, realmName, realmName);
@@ -671,111 +675,6 @@ public void query_multipleReferencesWithDistinct() {
         assertTrue(child.getListParents().contains(parent));
     }
 
-    // Query on a field descriptor starting with a backlink
-    // The test objects are:
-    //             gen1
-    //             / \
-    //         gen2A gen2B
-    //           \\   //
-    //            gen3
-    //  /  = object ref
-    //  // = list ref
-    @Test
-    @Ignore
-    public void query_startWithBacklink() {
-        realm.beginTransaction();
-        AllJavaTypes gen1 = realm.createObject(AllJavaTypes.class, 10);
-
-        AllJavaTypes gen2A = realm.createObject(AllJavaTypes.class, 1);
-        gen2A.setFieldObject(gen1);
-
-        AllJavaTypes gen2B = realm.createObject(AllJavaTypes.class, 2);
-        gen2B.setFieldObject(gen1);
-
-        AllJavaTypes gen3 = realm.createObject(AllJavaTypes.class, 3);
-        RealmList<AllJavaTypes> parents = gen3.getFieldList();
-        parents.add(gen2A);
-        parents.add(gen2B);
-
-        realm.commitTransaction();
-
-        RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class)
-            .greaterThan("objectParents.fieldId", 1)
-            .findAll();
-        assertEquals(1, result.size());
-        assertTrue(result.contains(gen2B));
-    }
-
-    // Query on a field descriptor that ends with a backlink
-    // The test objects are:
-    //             gen1
-    //             / \
-    //         gen2A gen2B
-    //           \\   //
-    //            gen3
-    //  /  = object ref
-    //  // = list ref
-    @Test
-    @Ignore
-    public void query_endWithBacklink() {
-        realm.beginTransaction();
-        AllJavaTypes gen1 = realm.createObject(AllJavaTypes.class, 10);
-
-        AllJavaTypes gen2A = realm.createObject(AllJavaTypes.class, 1);
-        gen2A.setFieldObject(gen1);
-
-        AllJavaTypes gen2B = realm.createObject(AllJavaTypes.class, 2);
-        gen2B.setFieldObject(gen1);
-
-        AllJavaTypes gen3 = realm.createObject(AllJavaTypes.class, 3);
-        RealmList<AllJavaTypes> parents = gen3.getFieldList();
-        parents.add(gen2A);
-        parents.add(gen2B);
-
-        realm.commitTransaction();
-
-        RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class)
-            .isNotNull("objectParents.listParents")
-            .findAll();
-        assertEquals(2, result.size());
-        assertTrue(result.contains(gen2A));
-        assertTrue(result.contains(gen2B));
-    }
-
-    // Query on a field descriptor that has a backlink in the middle
-    // The test objects are:
-    //             gen1
-    //             / \
-    //         gen2A gen2B
-    //           \\   //
-    //            gen3
-    //  /  = object ref
-    //  // = list ref
-    @Test
-    @Ignore
-    public void query_backlinkInMiddle() {
-        realm.beginTransaction();
-        AllJavaTypes gen1 = realm.createObject(AllJavaTypes.class, 10);
-
-        AllJavaTypes gen2A = realm.createObject(AllJavaTypes.class, 1);
-        gen2A.setFieldObject(gen1);
-
-        AllJavaTypes gen2B = realm.createObject(AllJavaTypes.class, 2);
-        gen2B.setFieldObject(gen1);
-
-        AllJavaTypes gen3 = realm.createObject(AllJavaTypes.class, 3);
-        RealmList<AllJavaTypes> parents = gen3.getFieldList();
-        parents.add(gen2A);
-        parents.add(gen2B);
-
-        realm.commitTransaction();
-
-        RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class)
-            .lessThan("objectParents.listParents.fieldId", 4)
-            .findAll();
-        assertEquals(2, result.size());
-    }
-
     // Based on a quick conversation with Christian Melchior and Mark Rowe,
     // it appears that notifications are enqueued, briefly, on a non-Java
     // thread.  That makes their delivery onto the looper thread unpredictable.
@@ -798,13 +697,13 @@ private void verifyPostConditions(final Realm realm, final PostConditions test,
             looperThread.keepStrongReference(ref);
         }
         looperThread.postRunnable(
-            new Runnable() {
-                @Override
-                public void run() {
-                    test.run(realm);
-                    looperThread.testComplete();
-                }
-            });
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        test.run(realm);
+                        looperThread.testComplete();
+                    }
+                });
     }
 }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsQueryTests.java
new file mode 100644
index 0000000000..70d5218ecc
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsQueryTests.java
@@ -0,0 +1,572 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Date;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.NullTypes;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@Ignore
+@RunWith(AndroidJUnit4.class)
+public class LinkingObjectsQueryTests extends QueryTests {
+
+    // All the basic tests for is[Not](Equal|Null) are in RealmQueryTests
+
+
+    // Query on a field descriptor starting with a backlink
+    // Build a simple object graph.
+    // The test objects are:
+    //             gen1
+    //             / \
+    //         gen2A gen2B
+    //           \\   //
+    //            gen3
+    //  /  = object ref
+    //  // = list ref
+    @Test
+    public void query_startWithBacklink() {
+        realm.beginTransaction();
+        AllJavaTypes gen1 = realm.createObject(AllJavaTypes.class, 10);
+
+        AllJavaTypes gen2A = realm.createObject(AllJavaTypes.class, 1);
+        gen2A.setFieldObject(gen1);
+
+        AllJavaTypes gen2B = realm.createObject(AllJavaTypes.class, 2);
+        gen2B.setFieldObject(gen1);
+
+        AllJavaTypes gen3 = realm.createObject(AllJavaTypes.class, 3);
+        RealmList<AllJavaTypes> parents = gen3.getFieldList();
+        parents.add(gen2A);
+        parents.add(gen2B);
+
+        realm.commitTransaction();
+
+        RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class)
+                .greaterThan(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_ID, 1)
+                .findAll();
+        assertEquals(1, result.size());
+        assertTrue(result.contains(gen1));
+    }
+
+    // Query on a field descriptor that has a backlink in the middle
+    // Build a simple object graph.
+    // The test objects are:
+    //             gen1
+    //             / \
+    //         gen2A gen2B
+    //           \\   //
+    //            gen3
+    //  /  = object ref
+    //  // = list ref
+    @Test
+    public void query_backlinkInMiddle() {
+        realm.beginTransaction();
+        AllJavaTypes gen1 = realm.createObject(AllJavaTypes.class, 10);
+
+        AllJavaTypes gen2A = realm.createObject(AllJavaTypes.class, 1);
+        gen2A.setFieldObject(gen1);
+
+        AllJavaTypes gen2B = realm.createObject(AllJavaTypes.class, 2);
+        gen2B.setFieldObject(gen1);
+
+        AllJavaTypes gen3 = realm.createObject(AllJavaTypes.class, 3);
+        RealmList<AllJavaTypes> parents = gen3.getFieldList();
+        parents.add(gen2A);
+        parents.add(gen2B);
+
+        realm.commitTransaction();
+
+        // TODO: Explain what this test is doing
+        RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class)
+                .lessThan(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_ID, 2)
+                .findAll();
+        assertEquals(1, result.size());
+        assertTrue(result.contains(gen2A));
+    }
+
+    // Tests isNotNull on link's nullable field.
+    @Test
+    public void isNull_object() {
+        populateTestRealmForNullTests(realm);
+
+        // 1 String
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_STRING_NULL).count());
+        // 2 Bytes
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_BYTES_NULL).count());
+        // 3 Boolean
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_BOOLEAN_NULL).count());
+        // 4 Byte
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_BYTE_NULL).count());
+        // 5 Short
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_SHORT_NULL).count());
+        // 6 Integer
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_INTEGER_NULL).count());
+        // 7 Long
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_LONG_NULL).count());
+        // 8 Float
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_FLOAT_NULL).count());
+        // 9 Double
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_DOUBLE_NULL).count());
+        // 10 Date
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_DATE_NULL).count());
+    }
+
+    // Tests isNull on link's nullable field.
+    @Test
+    public void isNull_list() {
+        populateTestRealmForNullTests(realm);
+
+        // 1 String
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_STRING_NULL).count());
+        // 2 Bytes
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_BYTES_NULL).count());
+        // 3 Boolean
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_BOOLEAN_NULL).count());
+        // 4 Byte
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_BYTE_NULL).count());
+        // 5 Short
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_SHORT_NULL).count());
+        // 6 Integer
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_INTEGER_NULL).count());
+        // 7 Long
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_LONG_NULL).count());
+        // 8 Float
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_FLOAT_NULL).count());
+        // 9 Double
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_DOUBLE_NULL).count());
+        // 10 Date
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_DATE_NULL).count());
+    }
+
+    @Test
+    public void isNull_unsupported() {
+        long result;
+
+        // Tests for other unsupported null types are in RealmQueryTests
+
+        try {
+            result = realm.where(NullTypes.class).isNull(NullTypes.FIELD_LO_OBJECT).count();
+            fail("isNull should throw on type LINKING_OBJECT(14) targeting an OBJECT");
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: LinkingObject from field fieldObjectNull is not nullable.", expected.getMessage());
+        }
+        try {
+            result = realm.where(NullTypes.class).isNull(NullTypes.FIELD_LO_LIST).count();
+            fail("isNull should throw on type LINKING_OBJECT(14) targeting a LIST");
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: LinkingObject from field fieldListNull is not nullable.", expected.getMessage());
+        }
+    }
+
+    @Test
+    public void isNull_unsupportedLinkedTypes() {
+        RealmQuery<NullTypes> result;
+
+        // Tests for other unsupported null types are in RealmQueryTests
+
+        try {
+            result = realm.where(NullTypes.class).isNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_LO_OBJECT);
+            fail("isNull should throw on nested linked fields (LINKING_OBJECT => OBJECT)");
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: LinkingObject from field fieldObjectNull is not nullable.", expected.getMessage());
+        }
+        try {
+            result = realm.where(NullTypes.class).isNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_LO_LIST);
+            fail("isNull should throw on nested linked fields (LINKING_OBJECT => LIST)");
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: LinkingObject from field fieldListNull is not nullable.", expected.getMessage());
+        }
+    }
+
+    // Tests isNotNull on link's nullable field.
+    @Test
+    public void isNotNull_object() {
+        populateTestRealmForNullTests(realm);
+
+        // 1 String
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_STRING_NULL).count());
+        // 2 Bytes
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_BYTES_NULL).count());
+        // 3 Boolean
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_BOOLEAN_NULL).count());
+        // 4 Byte
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_BYTE_NULL).count());
+        // 5 Short
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_SHORT_NULL).count());
+        // 6 Integer
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_INTEGER_NULL).count());
+        // 7 Long
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_LONG_NULL).count());
+        // 8 Float
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_FLOAT_NULL).count());
+        // 9 Double
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_DOUBLE_NULL).count());
+        // 10 Date
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_DATE_NULL).count());
+    }
+
+    // Tests isNotNull on link's nullable field.
+    @Test
+    public void isNotNull_list() {
+        populateTestRealmForNullTests(realm);
+
+        // 1 String
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_STRING_NULL).count());
+        // 2 Bytes
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_BYTES_NULL).count());
+        // 3 Boolean
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_BOOLEAN_NULL).count());
+        // 4 Byte
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_BYTE_NULL).count());
+        // 5 Short
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_SHORT_NULL).count());
+        // 6 Integer
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_INTEGER_NULL).count());
+        // 7 Long
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_LONG_NULL).count());
+        // 8 Float
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_FLOAT_NULL).count());
+        // 9 Double
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_DOUBLE_NULL).count());
+        // 10 Date
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_DATE_NULL).count());
+    }
+
+    @Test
+    public void isNotNull_unsupported() {
+        long result;
+
+        // Tests for other unsupported not null types are in RealmQueryTests
+
+        try {
+            result = realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_LO_OBJECT).count();
+            fail("isNotNull should throw on type LINKING_OBJECT(14) targeting an OBJECT");
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: LinkingObject from field fieldObjectNull is not nullable.", expected.getMessage());
+        }
+        try {
+            result = realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_LO_LIST).count();
+            fail("isNotNull should throw on type LINKING_OBJECT(14) targeting a LIST");
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: LinkingObject from field fieldListNull is not nullable.", expected.getMessage());
+        }
+    }
+
+    @Test
+    public void isNotNull_unsupportedLinkedTypes() {
+        RealmQuery<NullTypes> result;
+
+        // Tests for other unsupported not null types are in RealmQueryTests
+
+        try {
+            result = realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_LO_OBJECT);
+            fail("isNotNull should throw on nested linked fields (LINKING_OBJECT => OBJECT)");
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: LinkingObject from field fieldObjectNull is not nullable.", expected.getMessage());
+        }
+        try {
+            result = realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_LO_LIST);
+            fail("isNotNull should throw on nested linked fields (LINKING_OBJECT => LIST)");
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: LinkingObject from field fieldListNull is not nullable.", expected.getMessage());
+        }
+    }
+
+    @Test
+    public void isEmpty() {
+        createIsEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
+            switch (type) {
+                case LINKING_OBJECTS:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT).count());
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
+                default:
+                    // tested in RealmQueryTests
+            }
+        }
+    }
+
+    @Test
+    public void isEmpty_acrossLink() {
+        createIsEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
+            switch (type) {
+                case LINKING_OBJECTS:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
+                default:
+                    // tested in RealmQueryTests
+            }
+        }
+    }
+
+    @Test
+    public void isEmpty_acrossLinkingObjectObjectLink() {
+        createIsEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
+            switch (type) {
+                case STRING:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_STRING).count());
+                    break;
+                case BINARY:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_BINARY).count());
+                    break;
+                case LIST:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LIST).count());
+                    break;
+                case LINKING_OBJECTS:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
+                default:
+                    fail("Unknown type: " + type);
+            }
+        }
+    }
+
+    @Test
+    public void isEmpty_acrossLinkingObjectListLink() {
+        createIsEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
+            switch (type) {
+                case STRING:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_STRING).count());
+                    break;
+                case BINARY:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_BINARY).count());
+                    break;
+                case LIST:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LIST).count());
+                    break;
+                case LINKING_OBJECTS:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
+                default:
+                    fail("Unknown type: " + type);
+            }
+        }
+    }
+
+    @Test
+    public void isNotEmpty() {
+        createIsNotEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_NOT_EMPTY_TYPES) {
+            switch (type) {
+                case LINKING_OBJECTS:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT).count());
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
+                default:
+                    // tested in RealmQueryTests
+            }
+        }
+    }
+
+    @Test
+    public void isNotEmpty_acrossLink() {
+        createIsNotEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_NOT_EMPTY_TYPES) {
+            switch (type) {
+                case LINKING_OBJECTS:
+                    // tested in LinkingObjectsQueryTests;
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
+                default:
+                    // tested in RealmQueryTests
+            }
+        }
+    }
+
+    @Test
+    public void isNotEmpty_acrossLinkingObjectObjectLink() {
+        createIsEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
+            switch (type) {
+                case STRING:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_STRING).count());
+                    break;
+                case BINARY:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_BINARY).count());
+                    break;
+                case LIST:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LIST).count());
+                    break;
+                case LINKING_OBJECTS:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
+                default:
+                    fail("Unknown type: " + type);
+            }
+        }
+    }
+
+    @Test
+    public void isNotEmpty_acrossLinkingObjectListLink() {
+        createIsEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
+            switch (type) {
+                case STRING:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_STRING).count());
+                    break;
+                case BINARY:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_BINARY).count());
+                    break;
+                case LIST:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LIST).count());
+                    break;
+                case LINKING_OBJECTS:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
+                default:
+                    fail("Unknown type: " + type);
+            }
+        }
+    }
+
+    // Similar to the version in TestHelper, but with more Backlinks
+    // Creates 3 NullTypes objects. The objects are self-referenced (link) in
+    // order to test link queries.
+    //
+    // +-+--------+------+---------+--------+--------------------+
+    // | | string | link | numeric | binary | numeric (not null) |
+    // +-+--------+------+---------+--------+--------------------+
+    // |0| Fish   |    0 |       1 |    {0} |                  1 |
+    // |1| null   | null |    null |   null |                  0 |
+    // |2| Horse  |    1 |       3 |  {1,2} |                  3 |
+    // +-+--------+------+---------+--------+--------------------+
+    private void populateTestRealmForNullTests(Realm testRealm) {
+        // 1 String
+        String[] words = {"Fish", null, "Horse"};
+        // 2 Bytes
+        byte[][] binaries = {new byte[]{0}, null, new byte[]{1, 2}};
+        // 3 Boolean
+        Boolean[] booleans = {false, null, true};
+        // Numeric fields will be 1, 0/null, 3
+        // 10 Date
+        Date[] dates = {new Date(0), null, new Date(10000)};
+        NullTypes[] nullTypesArray = new NullTypes[3];
+
+        testRealm.beginTransaction();
+        for (int i = 0; i < 3; i++) {
+            NullTypes nullTypes = new NullTypes();
+            nullTypes.setId(i + 1);
+            // 1 String
+            nullTypes.setFieldStringNull(words[i]);
+            if (words[i] != null) {
+                nullTypes.setFieldStringNotNull(words[i]);
+            }
+            // 2 Bytes
+            nullTypes.setFieldBytesNull(binaries[i]);
+            if (binaries[i] != null) {
+                nullTypes.setFieldBytesNotNull(binaries[i]);
+            }
+            // 3 Boolean
+            nullTypes.setFieldBooleanNull(booleans[i]);
+            if (booleans[i] != null) {
+                nullTypes.setFieldBooleanNotNull(booleans[i]);
+            }
+            if (i != 1) {
+                int n = i + 1;
+                // 4 Byte
+                nullTypes.setFieldByteNull((byte) n);
+                nullTypes.setFieldByteNotNull((byte) n);
+                // 5 Short
+                nullTypes.setFieldShortNull((short) n);
+                nullTypes.setFieldShortNotNull((short) n);
+                // 6 Integer
+                nullTypes.setFieldIntegerNull(n);
+                nullTypes.setFieldIntegerNotNull(n);
+                // 7 Long
+                nullTypes.setFieldLongNull((long) n);
+                nullTypes.setFieldLongNotNull((long) n);
+                // 8 Float
+                nullTypes.setFieldFloatNull((float) n);
+                nullTypes.setFieldFloatNotNull((float) n);
+                // 9 Double
+                nullTypes.setFieldDoubleNull((double) n);
+                nullTypes.setFieldDoubleNotNull((double) n);
+            }
+            // 10 Date
+            nullTypes.setFieldDateNull(dates[i]);
+            if (dates[i] != null) {
+                nullTypes.setFieldDateNotNull(dates[i]);
+            }
+
+            nullTypesArray[i] = testRealm.copyToRealm(nullTypes);
+        }
+        nullTypesArray[0].setFieldObjectNull(nullTypesArray[0]);
+        nullTypesArray[1].setFieldObjectNull(null);
+        nullTypesArray[2].getFieldListNull().add(nullTypesArray[1]);
+        testRealm.commitTransaction();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
index fa0036e267..2bc3206cf4 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
@@ -16,8 +16,6 @@
 
 package io.realm;
 
-import android.util.Log;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -42,6 +40,7 @@
 import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertArrayEquals;
 
+
 // Tests for the ordered collection fine grained notifications for both RealmResults and RealmList.
 @RunWith(Parameterized.class)
 public class OrderedCollectionChangeSetTests {
@@ -96,7 +95,7 @@ private void populateData(Realm realm, int testSize) {
 
     // The args should be [startIndex1, length1, startIndex2, length2, ...]
     private void checkRanges(OrderedCollectionChangeSet.Range[] ranges, int... indexAndLen) {
-        if ((indexAndLen.length % 2 != 0))  {
+        if ((indexAndLen.length % 2 != 0)) {
             fail("The 'indexAndLen' array length is not an even number.");
         }
         if (ranges.length != indexAndLen.length / 2) {
@@ -193,7 +192,7 @@ public void check(OrderedCollectionChangeSet changeSet) {
                         0, 1,
                         2, 3,
                         8, 2);
-                assertArrayEquals(changeSet.getDeletions(), new int[]{0, 2, 3, 4, 8, 9});
+                assertArrayEquals(changeSet.getDeletions(), new int[] {0, 2, 3, 4, 8, 9});
                 assertEquals(0, changeSet.getChangeRanges().length);
                 assertEquals(0, changeSet.getInsertionRanges().length);
                 assertEquals(0, changeSet.getChanges().length);
@@ -228,7 +227,7 @@ public void check(OrderedCollectionChangeSet changeSet) {
                         1, 1,
                         3, 2,
                         8, 1);
-                assertArrayEquals(changeSet.getInsertions(), new int[]{1, 3, 4, 8});
+                assertArrayEquals(changeSet.getInsertions(), new int[] {1, 3, 4, 8});
                 assertEquals(0, changeSet.getChangeRanges().length);
                 assertEquals(0, changeSet.getDeletionRanges().length);
                 assertEquals(0, changeSet.getChanges().length);
@@ -258,7 +257,7 @@ public void check(OrderedCollectionChangeSet changeSet) {
                         0, 1,
                         2, 3,
                         8, 2);
-                assertArrayEquals(changeSet.getChanges(), new int[]{0, 2, 3, 4, 8, 9});
+                assertArrayEquals(changeSet.getChanges(), new int[] {0, 2, 3, 4, 8, 9});
                 assertEquals(0, changeSet.getInsertionRanges().length);
                 assertEquals(0, changeSet.getDeletionRanges().length);
                 assertEquals(0, changeSet.getInsertions().length);
@@ -288,11 +287,11 @@ public void check(OrderedCollectionChangeSet changeSet) {
                 checkRanges(changeSet.getDeletionRanges(),
                         0, 1,
                         9, 1);
-                assertArrayEquals(changeSet.getDeletions(), new int[]{0, 9});
+                assertArrayEquals(changeSet.getDeletions(), new int[] {0, 9});
                 checkRanges(changeSet.getInsertionRanges(),
                         0, 1,
                         9, 1);
-                assertArrayEquals(changeSet.getInsertions(), new int[]{0, 9});
+                assertArrayEquals(changeSet.getInsertions(), new int[] {0, 9});
                 assertEquals(0, changeSet.getChangeRanges().length);
                 assertEquals(0, changeSet.getChanges().length);
                 looperThread.testComplete();
@@ -317,17 +316,17 @@ public void check(OrderedCollectionChangeSet changeSet) {
                 checkRanges(changeSet.getDeletionRanges(),
                         0, 2,
                         5, 1);
-                assertArrayEquals(changeSet.getDeletions(), new int[]{0, 1, 5});
+                assertArrayEquals(changeSet.getDeletions(), new int[] {0, 1, 5});
 
                 checkRanges(changeSet.getInsertionRanges(),
                         0, 2,
                         9, 2);
-                assertArrayEquals(changeSet.getInsertions(), new int[]{0, 1, 9, 10});
+                assertArrayEquals(changeSet.getInsertions(), new int[] {0, 1, 9, 10});
 
                 checkRanges(changeSet.getChangeRanges(),
                         3, 2,
                         8, 1);
-                assertArrayEquals(changeSet.getChanges(), new int[]{3, 4, 8});
+                assertArrayEquals(changeSet.getChanges(), new int[] {3, 4, 8});
 
                 looperThread.testComplete();
             }
@@ -357,7 +356,7 @@ public void check(OrderedCollectionChangeSet changeSet) {
                 checkRanges(changeSet.getDeletionRanges(),
                         0, 2,
                         5, 1);
-                assertArrayEquals(changeSet.getDeletions(), new int[]{0, 1, 5});
+                assertArrayEquals(changeSet.getDeletions(), new int[] {0, 1, 5});
 
                 assertEquals(0, changeSet.getInsertionRanges().length);
                 assertEquals(0, changeSet.getInsertions().length);
@@ -406,14 +405,12 @@ public void run() {
     // The change set should empty when the async query returns at the first time.
     @Test
     @RunTestInLooperThread
-    public void emptyChangeSet_findAllAsync(){
+    public void emptyChangeSet_findAllAsync() {
         if (type == ObservablesType.REALM_LIST) {
             looperThread.testComplete();
             return;
         }
 
-        Log.d("####", "test running on thread: " + Thread.currentThread());
-
         Realm realm = looperThread.getRealm();
         populateData(realm, 10);
         final RealmResults<Dog> results = realm.where(Dog.class).findAllSortedAsync(Dog.FIELD_AGE);
@@ -434,8 +431,7 @@ public void onChange(RealmResults<Dog> collection, OrderedCollectionChangeSet ch
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Log.d("####", "runnable running on thread: " + Thread.currentThread());
-                Realm realm = Realm.getInstance(looperThread.getConfiguration())      ;
+                Realm realm = Realm.getInstance(looperThread.getConfiguration());
                 realm.beginTransaction();
                 realm.where(Dog.class).equalTo(Dog.FIELD_AGE, 0).findFirst().deleteFromRealm();
                 realm.commitTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/QueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/QueryTests.java
new file mode 100644
index 0000000000..38e53896d9
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/QueryTests.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.rules.ExpectedException;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+
+public abstract class QueryTests {
+    public static final int TEST_DATA_SIZE = 10;
+    public static final int TEST_NO_PRIMARY_KEY_NULL_TYPES_SIZE = 200;
+
+    public static final long DECADE_MILLIS = 10 * TimeUnit.DAYS.toMillis(365);
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    protected static final List<RealmFieldType> SUPPORTED_IS_EMPTY_TYPES;
+    protected static final List<RealmFieldType> NOT_SUPPORTED_IS_EMPTY_TYPES;
+    protected static final List<RealmFieldType> SUPPORTED_IS_NOT_EMPTY_TYPES;
+    protected static final List<RealmFieldType> NOT_SUPPORTED_IS_NOT_EMPTY_TYPES;
+
+    static {
+        ArrayList<RealmFieldType> list = new ArrayList<>(Arrays.asList(
+                RealmFieldType.STRING,
+                RealmFieldType.BINARY,
+                RealmFieldType.LIST));
+                // TODO: LINKING_OBJECTS should be supported
+        SUPPORTED_IS_EMPTY_TYPES = Collections.unmodifiableList(list);
+        SUPPORTED_IS_NOT_EMPTY_TYPES = Collections.unmodifiableList(list);
+
+        list = new ArrayList<>(Arrays.asList(RealmFieldType.values()));
+        list.removeAll(SUPPORTED_IS_EMPTY_TYPES);
+        list.remove(RealmFieldType.UNSUPPORTED_MIXED);
+        list.remove(RealmFieldType.UNSUPPORTED_TABLE);
+        list.remove(RealmFieldType.UNSUPPORTED_DATE);
+        list.remove(RealmFieldType.LINKING_OBJECTS);
+        NOT_SUPPORTED_IS_EMPTY_TYPES = Collections.unmodifiableList(list);
+        NOT_SUPPORTED_IS_NOT_EMPTY_TYPES = Collections.unmodifiableList(list);
+    }
+
+    protected Realm realm;
+
+    @Before
+    public void setUp() throws Exception {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    protected final void createIsEmptyDataSet(Realm realm) {
+        realm.beginTransaction();
+
+        AllJavaTypes emptyValues = new AllJavaTypes();
+        emptyValues.setFieldId(1);
+        emptyValues.setFieldString("");
+        emptyValues.setFieldBinary(new byte[0]);
+        emptyValues.setFieldObject(emptyValues);
+        emptyValues.setFieldList(new RealmList<AllJavaTypes>());
+        realm.copyToRealm(emptyValues);
+
+        AllJavaTypes nonEmpty = new AllJavaTypes();
+        nonEmpty.setFieldId(2);
+        nonEmpty.setFieldString("Foo");
+        nonEmpty.setFieldBinary(new byte[] {1, 2, 3});
+        nonEmpty.setFieldObject(nonEmpty);
+        nonEmpty.setFieldList(new RealmList<AllJavaTypes>(emptyValues));
+        realm.copyToRealmOrUpdate(nonEmpty);
+
+        realm.commitTransaction();
+    }
+
+    protected final void createIsNotEmptyDataSet(Realm realm) {
+        realm.beginTransaction();
+
+        AllJavaTypes emptyValues = new AllJavaTypes();
+        emptyValues.setFieldId(1);
+        emptyValues.setFieldString("");
+        emptyValues.setFieldBinary(new byte[0]);
+        emptyValues.setFieldObject(emptyValues);
+        emptyValues.setFieldList(new RealmList<AllJavaTypes>());
+        realm.copyToRealm(emptyValues);
+
+        AllJavaTypes notEmpty = new AllJavaTypes();
+        notEmpty.setFieldId(2);
+        notEmpty.setFieldString("Foo");
+        notEmpty.setFieldBinary(new byte[] {1, 2, 3});
+        notEmpty.setFieldObject(notEmpty);
+        notEmpty.setFieldList(new RealmList<AllJavaTypes>(emptyValues));
+        realm.copyToRealmOrUpdate(notEmpty);
+
+        realm.commitTransaction();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index d89911896d..d8fbb9c7bd 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -740,14 +740,14 @@ public void getFieldIndex() {
         dynamicRealm.beginTransaction();
         StandardRealmObjectSchema objectSchema = (StandardRealmObjectSchema) dynamicRealm.getSchema().create(className);
 
-        assertNull(objectSchema.getFieldIndex(fieldName));
+        assertTrue(objectSchema.getFieldIndex(fieldName) < 0);
 
         objectSchema.addField(fieldName, long.class);
         //noinspection ConstantConditions
         assertTrue(objectSchema.getFieldIndex(fieldName) >= 0);
 
         objectSchema.removeField(fieldName);
-        assertNull(objectSchema.getFieldIndex(fieldName));
+        assertTrue(objectSchema.getFieldIndex(fieldName) < 0);
 
         dynamicRealm.cancelTransaction();
         dynamicRealm.close();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
index 023cca9f73..b3acf5f0e8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
@@ -60,8 +60,7 @@ public void tearDown() {
     @Test
     public void validateTable_noDuplicateIndexInIndexFields() {
         RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
-        CatRealmProxy.CatColumnInfo columnInfo;
-        columnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+        CatRealmProxy.CatColumnInfo columnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
 
         final Set<Long> indexSet = new HashSet<Long>();
         int indexCount = 0;
@@ -100,7 +99,7 @@ public void validateTable_noDuplicateIndexInIndicesMap() {
             if (Modifier.isStatic(field.getModifiers())) {
                 continue;
             }
-            indexSet.add(columnInfo.getIndicesMap().get(field.getName()));
+            indexSet.add(columnInfo.getColumnIndex(field.getName()));
             indexCount++;
         }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 8be7cc00fa..0a8d50763c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -20,6 +20,7 @@
 
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -62,33 +63,7 @@
 import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
-public class RealmQueryTests {
-    @Rule
-    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
-    @Rule
-    public final ExpectedException thrown = ExpectedException.none();
-    @Rule
-    public final RunInLooperThread looperThread = new RunInLooperThread();
-
-    private final static int TEST_DATA_SIZE = 10;
-    private final static int TEST_NO_PRIMARY_KEY_NULL_TYPES_SIZE = 200;
-
-    private final static long DECADE_MILLIS = 10 * TimeUnit.DAYS.toMillis(365);
-
-    private Realm realm;
-
-    @Before
-    public void setUp() throws Exception {
-        RealmConfiguration realmConfig = configFactory.createConfiguration();
-        realm = Realm.getInstance(realmConfig);
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        if (realm != null) {
-            realm.close();
-        }
-    }
+public class RealmQueryTests extends QueryTests {
 
     private void populateTestRealm(Realm testRealm, int dataSize) {
         testRealm.beginTransaction();
@@ -1228,7 +1203,7 @@ public void like_caseSensitiveWithNonLatinCharacters() {
         realm.commitTransaction();
 
         RealmResults<AllTypes> resultList = realm.where(AllTypes.class).like("columnString", "**").findAll();
-         assertEquals(1, resultList.size());
+        assertEquals(1, resultList.size());
 
         resultList = realm.where(AllTypes.class).like("columnString", "**").findAll();
         assertEquals(2, resultList.size());
@@ -2587,7 +2562,8 @@ public void isNotNull_listFieldThrows() {
         }
     }
 
-    // @Test Disabled because of time consuming.
+    @Ignore("Disabled because it is time consuming")
+    @Test
     public void largeRealmMultipleThreads() throws InterruptedException {
         final int nObjects = 500000;
         final int nThreads = 3;
@@ -2706,44 +2682,6 @@ public void isValid_removedParent() {
         assertFalse(query.isValid());
     }
 
-
-    private static final List<RealmFieldType> SUPPORTED_IS_EMPTY_TYPES = Arrays.asList(
-            RealmFieldType.STRING,
-            RealmFieldType.BINARY,
-            RealmFieldType.LIST);
-
-    private static final List<RealmFieldType> NOT_SUPPORTED_IS_EMPTY_TYPES;
-    static {
-        final ArrayList<RealmFieldType> list = new ArrayList<RealmFieldType>(Arrays.asList(RealmFieldType.values()));
-        list.removeAll(SUPPORTED_IS_EMPTY_TYPES);
-        list.remove(RealmFieldType.UNSUPPORTED_MIXED);
-        list.remove(RealmFieldType.UNSUPPORTED_TABLE);
-        list.remove(RealmFieldType.UNSUPPORTED_DATE);
-        NOT_SUPPORTED_IS_EMPTY_TYPES = list;
-    }
-
-    private void createIsEmptyDataSet(Realm realm) {
-        realm.beginTransaction();
-
-        AllJavaTypes emptyValues = new AllJavaTypes();
-        emptyValues.setFieldId(1);
-        emptyValues.setFieldString("");
-        emptyValues.setFieldBinary(new byte[0]);
-        emptyValues.setFieldObject(emptyValues);
-        emptyValues.setFieldList(new RealmList<AllJavaTypes>());
-        realm.copyToRealm(emptyValues);
-
-        AllJavaTypes nonEmpty = new AllJavaTypes();
-        nonEmpty.setFieldId(2);
-        nonEmpty.setFieldString("Foo");
-        nonEmpty.setFieldBinary(new byte[]{1, 2, 3});
-        nonEmpty.setFieldObject(nonEmpty);
-        nonEmpty.setFieldList(new RealmList<AllJavaTypes>(emptyValues));
-        realm.copyToRealmOrUpdate(nonEmpty);
-
-        realm.commitTransaction();
-    }
-
     @Test
     public void isEmpty() {
         createIsEmptyDataSet(realm);
@@ -2829,44 +2767,6 @@ public void isEmpty_invalidFieldNameThrows() {
         }
     }
 
-    // Not-empty test harnesses.
-    private static final List<RealmFieldType> SUPPORTED_IS_NOT_EMPTY_TYPES = Arrays.asList(
-            RealmFieldType.STRING,
-            RealmFieldType.BINARY,
-            RealmFieldType.LIST);
-
-    private static final List<RealmFieldType> NOT_SUPPORTED_IS_NOT_EMPTY_TYPES;
-    static {
-        final ArrayList<RealmFieldType> list = new ArrayList<RealmFieldType>(Arrays.asList(RealmFieldType.values()));
-        list.removeAll(SUPPORTED_IS_NOT_EMPTY_TYPES);
-        list.remove(RealmFieldType.UNSUPPORTED_MIXED);
-        list.remove(RealmFieldType.UNSUPPORTED_TABLE);
-        list.remove(RealmFieldType.UNSUPPORTED_DATE);
-        NOT_SUPPORTED_IS_NOT_EMPTY_TYPES = list;
-    }
-
-    private void createIsNotEmptyDataSet(Realm realm) {
-        realm.beginTransaction();
-
-        AllJavaTypes emptyValues = new AllJavaTypes();
-        emptyValues.setFieldId(1);
-        emptyValues.setFieldString("");
-        emptyValues.setFieldBinary(new byte[0]);
-        emptyValues.setFieldObject(emptyValues);
-        emptyValues.setFieldList(new RealmList<AllJavaTypes>());
-        realm.copyToRealm(emptyValues);
-
-        AllJavaTypes notEmpty = new AllJavaTypes();
-        notEmpty.setFieldId(2);
-        notEmpty.setFieldString("Foo");
-        notEmpty.setFieldBinary(new byte[]{1, 2, 3});
-        notEmpty.setFieldObject(notEmpty);
-        notEmpty.setFieldList(new RealmList<AllJavaTypes>(emptyValues));
-        realm.copyToRealmOrUpdate(notEmpty);
-
-        realm.commitTransaction();
-    }
-
     @Test
     public void isNotEmpty() {
         createIsNotEmptyDataSet(realm);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
index da49a66229..57fd54362b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
@@ -20,6 +20,7 @@
 
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -190,8 +191,7 @@ public void remove_invalidArgumentThrows() {
 
     // Test that it if { A -> B  && B -> A } you should remove the individual fields first before removing the entire
     // class. This also include transitive dependencies.
-    // FIXME: Disabled until https://github.com/realm/realm-core/pull/1475#issuecomment-185192434 is fixed.
-    // @Test
+    @Test
     public void remove_classWithReferencesThrows() {
         try {
             realmSchema.remove("Cat");
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 5497ccf45b..9356203617 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -126,6 +126,7 @@
 import static org.mockito.Mockito.when;
 
 
+
 @RunWith(AndroidJUnit4.class)
 public class RealmTests {
     private final static int TEST_DATA_SIZE = 10;
@@ -177,18 +178,18 @@ private void populateTestRealm(Realm realm, int objects) {
         for (int i = 0; i < objects; ++i) {
             AllTypes allTypes = realm.createObject(AllTypes.class);
             allTypes.setColumnBoolean((i % 3) == 0);
-            allTypes.setColumnBinary(new byte[]{1, 2, 3});
+            allTypes.setColumnBinary(new byte[] {1, 2, 3});
             allTypes.setColumnDate(new Date());
             allTypes.setColumnDouble(Math.PI);
-            allTypes.setColumnFloat(1.234567f + i);
+            allTypes.setColumnFloat(1.234567F + i);
 
             allTypes.setColumnString("test data " + i);
             allTypes.setColumnLong(i);
             NonLatinFieldNames nonLatinFieldNames = realm.createObject(NonLatinFieldNames.class);
             nonLatinFieldNames.set(i);
             nonLatinFieldNames.set(i);
-            nonLatinFieldNames.set(1.234567f + i);
-            nonLatinFieldNames.set(1.234567f + i);
+            nonLatinFieldNames.set(1.234567F + i);
+            nonLatinFieldNames.set(1.234567F + i);
         }
         realm.commitTransaction();
     }
@@ -326,7 +327,7 @@ public void where_equalTo_wrongFieldTypeAsInput() throws IOException {
             }
 
             try {
-                realm.where(AllTypes.class).equalTo(columnData.get(i), 13.37d).findAll();
+                realm.where(AllTypes.class).equalTo(columnData.get(i), 13.37D).findAll();
                 if (i != 2) {
                     fail("Realm.where should fail with illegal argument");
                 }
@@ -334,7 +335,7 @@ public void where_equalTo_wrongFieldTypeAsInput() throws IOException {
             }
 
             try {
-                realm.where(AllTypes.class).equalTo(columnData.get(i), 13.3711f).findAll();
+                realm.where(AllTypes.class).equalTo(columnData.get(i), 13.3711F).findAll();
                 if (i != 3) {
                     fail("Realm.where should fail with illegal argument");
                 }
@@ -833,21 +834,20 @@ public void utf8Tests() {
         return chars_array;
     }
 
-    // This test is slow. Move it to another testsuite that runs once a day on Jenkins.
     // The test writes and reads random Strings.
-    // @Test TODO AndroidJUnit4 runner doesn't seem to respect the @Ignore annotation?
-    @Ignore
+    @Test
+    @Ignore("This test is slow. Move it to another testsuite that runs once a day on Jenkins")
     public void unicodeStrings() {
         List<String> chars_array = getCharacterArray();
         // Change seed value for new random values.
         long seed = 20;
         Random random = new Random(seed);
 
-        int random_value = 0;
 
         String test_char = "";
         String test_char_old = "";
 
+        int random_value;
         for (int i = 0; i < 1000; i++) {
             random_value = random.nextInt(25);
 
@@ -887,7 +887,7 @@ public void getInstance_referenceCounting() {
         try {
             realm = Realm.getInstance(configFactory.createConfiguration());
         } finally {
-            if (realm != null) realm.close();
+            if (realm != null) { realm.close(); }
         }
 
         try {
@@ -1115,12 +1115,12 @@ public void copyToRealm() {
 
         AllTypes allTypes = new AllTypes();
         allTypes.setColumnString("String");
-        allTypes.setColumnLong(1l);
-        allTypes.setColumnFloat(1f);
-        allTypes.setColumnDouble(1d);
+        allTypes.setColumnLong(1L);
+        allTypes.setColumnFloat(1F);
+        allTypes.setColumnDouble(1D);
         allTypes.setColumnBoolean(true);
         allTypes.setColumnDate(date);
-        allTypes.setColumnBinary(new byte[]{1, 2, 3});
+        allTypes.setColumnBinary(new byte[] {1, 2, 3});
         allTypes.setColumnRealmObject(dog);
         allTypes.setColumnRealmList(list);
 
@@ -1263,16 +1263,16 @@ public void copyToRealm_boxedNumberPrimaryKeyIsNull() {
         final String SECONDARY_FIELD_VALUE = "nullNumberPrimaryKeyObj";
         final Class[] CLASSES = {PrimaryKeyAsBoxedByte.class, PrimaryKeyAsBoxedShort.class, PrimaryKeyAsBoxedInteger.class, PrimaryKeyAsBoxedLong.class};
 
-        TestHelper.addBytePrimaryKeyObjectToTestRealm(realm,    (Byte) null,    SECONDARY_FIELD_VALUE);
-        TestHelper.addShortPrimaryKeyObjectToTestRealm(realm,   (Short) null,   SECONDARY_FIELD_VALUE);
+        TestHelper.addBytePrimaryKeyObjectToTestRealm(realm, (Byte) null, SECONDARY_FIELD_VALUE);
+        TestHelper.addShortPrimaryKeyObjectToTestRealm(realm, (Short) null, SECONDARY_FIELD_VALUE);
         TestHelper.addIntegerPrimaryKeyObjectToTestRealm(realm, (Integer) null, SECONDARY_FIELD_VALUE);
-        TestHelper.addLongPrimaryKeyObjectToTestRealm(realm,    (Long) null,    SECONDARY_FIELD_VALUE);
+        TestHelper.addLongPrimaryKeyObjectToTestRealm(realm, (Long) null, SECONDARY_FIELD_VALUE);
 
         for (Class clazz : CLASSES) {
             RealmResults results = realm.where(clazz).findAll();
             assertEquals(1, results.size());
-            assertEquals(null, ((NullPrimaryKey)results.first()).getId());
-            assertEquals(SECONDARY_FIELD_VALUE, ((NullPrimaryKey)results.first()).getName());
+            assertEquals(null, ((NullPrimaryKey) results.first()).getId());
+            assertEquals(SECONDARY_FIELD_VALUE, ((NullPrimaryKey) results.first()).getName());
         }
     }
 
@@ -1280,11 +1280,11 @@ public void copyToRealm_boxedNumberPrimaryKeyIsNull() {
     public void copyToRealm_duplicatedNullPrimaryKeyThrows() {
         final String[] PRIMARY_KEY_TYPES = {"String", "BoxedByte", "BoxedShort", "BoxedInteger", "BoxedLong"};
 
-        TestHelper.addStringPrimaryKeyObjectToTestRealm(realm,  (String) null,  0);
-        TestHelper.addBytePrimaryKeyObjectToTestRealm(realm,    (Byte) null,    (String) null);
-        TestHelper.addShortPrimaryKeyObjectToTestRealm(realm,   (Short) null,   (String) null);
+        TestHelper.addStringPrimaryKeyObjectToTestRealm(realm, (String) null, 0);
+        TestHelper.addBytePrimaryKeyObjectToTestRealm(realm, (Byte) null, (String) null);
+        TestHelper.addShortPrimaryKeyObjectToTestRealm(realm, (Short) null, (String) null);
         TestHelper.addIntegerPrimaryKeyObjectToTestRealm(realm, (Integer) null, (String) null);
-        TestHelper.addLongPrimaryKeyObjectToTestRealm(realm,    (Long) null,    (String) null);
+        TestHelper.addLongPrimaryKeyObjectToTestRealm(realm, (Long) null, (String) null);
 
         for (String className : PRIMARY_KEY_TYPES) {
             try {
@@ -1527,7 +1527,7 @@ public void execute(Realm realm) {
                 obj.setColumnFloat(1.23F);
                 obj.setColumnDouble(1.234D);
                 obj.setColumnBoolean(false);
-                obj.setColumnBinary(new byte[]{1, 2, 3});
+                obj.setColumnBinary(new byte[] {1, 2, 3});
                 obj.setColumnDate(new Date(1000));
                 obj.setColumnRealmObject(new DogPrimaryKey(1, "Dog1"));
                 obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, "Dog2")));
@@ -1540,7 +1540,7 @@ public void execute(Realm realm) {
                 obj2.setColumnFloat(2.23F);
                 obj2.setColumnDouble(2.234D);
                 obj2.setColumnBoolean(true);
-                obj2.setColumnBinary(new byte[]{2, 3, 4});
+                obj2.setColumnBinary(new byte[] {2, 3, 4});
                 obj2.setColumnDate(new Date(2000));
                 obj2.setColumnRealmObject(new DogPrimaryKey(3, "Dog3"));
                 obj2.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(4, "Dog4")));
@@ -1558,7 +1558,7 @@ public void execute(Realm realm) {
         assertEquals(2.23F, obj.getColumnFloat(), 0);
         assertEquals(2.234D, obj.getColumnDouble(), 0);
         assertEquals(true, obj.isColumnBoolean());
-        assertArrayEquals(new byte[]{2, 3, 4}, obj.getColumnBinary());
+        assertArrayEquals(new byte[] {2, 3, 4}, obj.getColumnBinary());
         assertEquals(new Date(2000), obj.getColumnDate());
         assertEquals("Dog3", obj.getColumnRealmObject().getName());
         assertEquals(1, obj.getColumnRealmList().size());
@@ -1602,7 +1602,7 @@ public void execute(Realm realm) {
                 obj.setColumnFloat(1.23F);
                 obj.setColumnDouble(1.234D);
                 obj.setColumnBoolean(false);
-                obj.setColumnBinary(new byte[]{1, 2, 3});
+                obj.setColumnBinary(new byte[] {1, 2, 3});
                 obj.setColumnDate(new Date(1000));
                 obj.setColumnRealmObject(new DogPrimaryKey(1, "Dog1"));
                 obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, "Dog2")));
@@ -1897,7 +1897,7 @@ public void writeEncryptedCopyTo() throws Exception {
 
     @Test
     public void writeEncryptedCopyTo_wrongKeyLength() {
-        byte[]  wrongLengthKey = new byte[42];
+        byte[] wrongLengthKey = new byte[42];
         File destination = new File(configFactory.getRoot(), "wrong_key.realm");
         thrown.expect(IllegalArgumentException.class);
         realm.writeEncryptedCopyTo(destination, wrongLengthKey);
@@ -2033,34 +2033,91 @@ public void callMutableMethodOutsideTransaction() throws JSONException, IOExcept
         InputStream jsonArrStream2 = TestHelper.stringToStream(jsonArrStr);
 
         // Tests all methods that should require a transaction.
-        try { realm.createObject(AllTypes.class);   fail(); } catch (IllegalStateException expected) {}
-        try { realm.copyToRealm(t);                 fail(); } catch (IllegalStateException expected) {}
-        try { realm.copyToRealm(ts);                fail(); } catch (IllegalStateException expected) {}
-        try { realm.copyToRealmOrUpdate(t);         fail(); } catch (IllegalStateException expected) {}
-        try { realm.copyToRealmOrUpdate(ts);        fail(); } catch (IllegalStateException expected) {}
-        try { realm.delete(AllTypes.class);         fail(); } catch (IllegalStateException expected) {}
-        try { realm.deleteAll();                    fail(); } catch (IllegalStateException expected) {}
-
-        try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObj);                fail(); } catch (IllegalStateException expected) {}
-        try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);             fail(); } catch (IllegalStateException expected) {}
+        try {
+            realm.createObject(AllTypes.class);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.copyToRealm(t);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.copyToRealm(ts);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.copyToRealmOrUpdate(t);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.copyToRealmOrUpdate(ts);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.delete(AllTypes.class);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.deleteAll();
+            fail();
+        } catch (IllegalStateException expected) {}
+
+        try {
+            realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObj);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);
+            fail();
+        } catch (IllegalStateException expected) {}
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-            try { realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, jsonObjStream);   fail(); } catch (IllegalStateException expected) {}
+            try {
+                realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, jsonObjStream);
+                fail();
+            } catch (IllegalStateException expected) {}
         }
-        try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObj);        fail(); } catch (IllegalStateException expected) {}
-        try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);     fail(); } catch (IllegalStateException expected) {}
+        try {
+            realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObj);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);
+            fail();
+        } catch (IllegalStateException expected) {}
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-            try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStream2); fail(); } catch (IllegalStateException expected) {}
+            try {
+                realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStream2);
+                fail();
+            } catch (IllegalStateException expected) {}
         }
 
-        try { realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArr);                   fail(); } catch (IllegalStateException expected) {}
-        try { realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);                fail(); } catch (IllegalStateException expected) {}
+        try {
+            realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArr);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);
+            fail();
+        } catch (IllegalStateException expected) {}
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-            try { realm.createAllFromJson(NoPrimaryKeyNullTypes.class, jsonArrStream);      fail(); } catch (IllegalStateException expected) {}
+            try {
+                realm.createAllFromJson(NoPrimaryKeyNullTypes.class, jsonArrStream);
+                fail();
+            } catch (IllegalStateException expected) {}
         }
-        try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArr);           fail(); } catch (IllegalStateException expected) {}
-        try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);        fail(); } catch (IllegalStateException expected) {}
+        try {
+            realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArr);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);
+            fail();
+        } catch (IllegalStateException expected) {}
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-            try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStream2);fail(); } catch (IllegalStateException expected) {}
+            try {
+                realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStream2);
+                fail();
+            } catch (IllegalStateException expected) {}
         }
     }
 
@@ -2263,7 +2320,7 @@ public void execute(Realm realm) {
                 DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueOfField.class,
                 DefaultValueOfField.FIELD_RANDOM_STRING, createdRandomString);
-        testOneObjectFound(realm, DefaultValueOfField.class,DefaultValueOfField.FIELD_SHORT,
+        testOneObjectFound(realm, DefaultValueOfField.class, DefaultValueOfField.FIELD_SHORT,
                 DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueOfField.class,
                 DefaultValueOfField.FIELD_INT,
@@ -2337,14 +2394,14 @@ public void execute(Realm realm) {
                 DefaultValueConstructor.FIELD_SHORT_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueConstructor.class,
                 DefaultValueConstructor.FIELD_INT,
-                DefaultValueConstructor.FIELD_INT_DEFAULT_VALUE);;
+                DefaultValueConstructor.FIELD_INT_DEFAULT_VALUE);
         // Default value for pk must be ignored.
         testNoObjectFound(realm, DefaultValueConstructor.class,
                 DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY,
-                        DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
+                DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueConstructor.class,
                 DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY,
-                        DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
+                DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
         testOneObjectFound(realm, DefaultValueConstructor.class,
                 DefaultValueConstructor.FIELD_LONG,
                 DefaultValueConstructor.FIELD_LONG_DEFAULT_VALUE);
@@ -2367,10 +2424,10 @@ public void execute(Realm realm) {
                 DefaultValueConstructor.FIELD_BINARY_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueConstructor.class,
                 DefaultValueConstructor.FIELD_OBJECT + "." + RandomPrimaryKey.FIELD_INT,
-                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+                RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueConstructor.class,
                 DefaultValueConstructor.FIELD_LIST + "." + RandomPrimaryKey.FIELD_INT,
-                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+                RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
     }
 
     @Test
@@ -2400,10 +2457,10 @@ public void execute(Realm realm) {
         // Default value for pk must be ignored.
         testNoObjectFound(realm, DefaultValueSetter.class,
                 DefaultValueSetter.FIELD_LONG_PRIMARY_KEY,
-                        DefaultValueSetter.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
+                DefaultValueSetter.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueSetter.class,
                 DefaultValueSetter.FIELD_LONG_PRIMARY_KEY,
-                        DefaultValueSetter.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
+                DefaultValueSetter.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
         testOneObjectFound(realm, DefaultValueSetter.class,
                 DefaultValueSetter.FIELD_LONG,
                 DefaultValueSetter.FIELD_LONG_DEFAULT_VALUE);
@@ -2427,13 +2484,13 @@ public void execute(Realm realm) {
                 DefaultValueSetter.FIELD_BINARY_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueSetter.class,
                 DefaultValueSetter.FIELD_OBJECT + "." + RandomPrimaryKey.FIELD_INT,
-                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+                RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueSetter.class,
                 DefaultValueSetter.FIELD_LIST + "." + RandomPrimaryKey.FIELD_INT,
-                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+                RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueSetter.class,
-                DefaultValueSetter.FIELD_LIST+ "." + RandomPrimaryKey.FIELD_INT,
-                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1);
+                DefaultValueSetter.FIELD_LIST + "." + RandomPrimaryKey.FIELD_INT,
+                RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1);
     }
 
     @Test
@@ -2464,7 +2521,8 @@ public void copyToRealm_defaultValuesAreIgnored() {
         final int fieldListIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 2;
 
         final DefaultValueOfField managedObj;
-        realm.beginTransaction(); {
+        realm.beginTransaction();
+        {
             final DefaultValueOfField obj = new DefaultValueOfField();
             obj.setFieldIgnored(fieldIgnoredValue);
             obj.setFieldString(fieldStringValue);
@@ -2503,8 +2561,8 @@ public void copyToRealm_defaultValuesAreIgnored() {
         assertEquals(fieldLongPrimaryKeyValue, managedObj.getFieldLongPrimaryKey());
         assertEquals(fieldLongValue, managedObj.getFieldLong());
         assertEquals(fieldByteValue, managedObj.getFieldByte());
-        assertEquals(fieldFloatValue, managedObj.getFieldFloat(), 0f);
-        assertEquals(fieldDoubleValue, managedObj.getFieldDouble(), 0d);
+        assertEquals(fieldFloatValue, managedObj.getFieldFloat(), 0F);
+        assertEquals(fieldDoubleValue, managedObj.getFieldDouble(), 0D);
         assertEquals(fieldBooleanValue, managedObj.isFieldBoolean());
         assertEquals(fieldDateValue, managedObj.getFieldDate());
         assertTrue(Arrays.equals(fieldBinaryValue, managedObj.getFieldBinary()));
@@ -2519,7 +2577,8 @@ public void copyToRealm_defaultValuesAreIgnored() {
     @Test
     public void copyFromRealm_defaultValuesAreIgnored() {
         final DefaultValueOfField managedObj;
-        realm.beginTransaction(); {
+        realm.beginTransaction();
+        {
             final DefaultValueOfField obj = new DefaultValueOfField();
             obj.setFieldIgnored(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE + ".modified");
             obj.setFieldString(DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE + ".modified");
@@ -2559,8 +2618,8 @@ public void copyFromRealm_defaultValuesAreIgnored() {
         assertEquals(managedObj.getFieldLongPrimaryKey(), copy.getFieldLongPrimaryKey());
         assertEquals(managedObj.getFieldLong(), copy.getFieldLong());
         assertEquals(managedObj.getFieldByte(), copy.getFieldByte());
-        assertEquals(managedObj.getFieldFloat(), copy.getFieldFloat(), 0f);
-        assertEquals(managedObj.getFieldDouble(), copy.getFieldDouble(), 0d);
+        assertEquals(managedObj.getFieldFloat(), copy.getFieldFloat(), 0F);
+        assertEquals(managedObj.getFieldDouble(), copy.getFieldDouble(), 0D);
         assertEquals(managedObj.isFieldBoolean(), copy.isFieldBoolean());
         assertEquals(managedObj.getFieldDate(), copy.getFieldDate());
         assertTrue(Arrays.equals(managedObj.getFieldBinary(), copy.getFieldBinary()));
@@ -3606,7 +3665,7 @@ public void run() {
     }
 
     // Cannot wait inside of a transaction.
-    @Test(expected= IllegalStateException.class)
+    @Test(expected = IllegalStateException.class)
     public void waitForChange_illegalWaitInsideTransaction() {
         realm.beginTransaction();
         realm.waitForChange();
@@ -3717,7 +3776,7 @@ public void execute(Realm realm) {
         // Verify that the index in the ColumnInfo has been updated.
         catColumnInfo = (CatRealmProxy.CatColumnInfo) realm.schema.getColumnInfo(Cat.class);
         assertEquals(nameIndexNew.get(), catColumnInfo.nameIndex);
-        assertEquals(nameIndexNew.get(), (long) catColumnInfo.getIndicesMap().get(Cat.FIELD_NAME));
+        assertEquals(nameIndexNew.get(), (long) catColumnInfo.getColumnIndex(Cat.FIELD_NAME));
 
         // Checks by actual get and set.
         realm.executeTransaction(new Realm.Transaction() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index a688249e8c..97d1a7e677 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -21,7 +21,6 @@
 import android.os.Build;
 import android.os.Looper;
 import android.support.test.InstrumentationRegistry;
-import android.util.Log;
 
 import org.junit.Assert;
 
@@ -177,7 +176,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     /**
      * Returns a RealmLogger that will fail if it is asked to log a message above a certain level.
      *
-     * @param failureLevel {@link Log} level from which the unit test will fail.
+     * @param failureLevel level at which the unit test will fail: {@see Log}.
      * @return RealmLogger implementation
      */
     public static RealmLogger getFailureLogger(final int failureLevel) {
@@ -506,7 +505,7 @@ public static void populateTestRealmForNullTests(Realm testRealm) {
         NullTypes[] nullTypesArray = new NullTypes[3];
 
         testRealm.beginTransaction();
-        for (int i = 0; i < words.length; i++) {
+        for (int i = 0; i < 3; i++) {
             NullTypes nullTypes = new NullTypes();
             nullTypes.setId(i + 1);
             // 1 String
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
index 38e3f84443..22e509c956 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
@@ -26,6 +26,7 @@
 import io.realm.annotations.LinkingObjects;
 import io.realm.annotations.PrimaryKey;
 
+
 public class AllJavaTypes extends RealmObject {
 
     public static final String CLASS_NAME = "AllJavaTypes";
@@ -44,13 +45,26 @@
     public static final String FIELD_BINARY = "fieldBinary";
     public static final String FIELD_OBJECT = "fieldObject";
     public static final String FIELD_LIST = "fieldList";
-
-    public static final String   INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT = AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY;
-    public static final String[] INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT = new String[]{FIELD_OBJECT + "." + FIELD_BINARY, FIELD_OBJECT + "." + FIELD_OBJECT, FIELD_OBJECT + "." + FIELD_LIST};
-
-    @Ignore private String fieldIgnored;
-    @Index private String fieldString;
-    @PrimaryKey private long fieldId;
+    public static final String FIELD_LO_OBJECT = "objectParents";
+    public static final String FIELD_LO_LIST = "listParents";
+
+    public static final String[] INVALID_FIELDS_FOR_DISTINCT
+            = new String[] {FIELD_OBJECT, FIELD_LIST, FIELD_DOUBLE, FIELD_FLOAT, FIELD_LO_OBJECT, FIELD_LO_LIST};
+
+    public static final String INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT
+            = AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY;
+
+    public static final String[] INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT = new String[] {
+            FIELD_OBJECT + "." + FIELD_BINARY,
+            FIELD_OBJECT + "." + FIELD_OBJECT,
+            FIELD_OBJECT + "." + FIELD_LIST};
+
+    @Ignore
+    private String fieldIgnored;
+    @Index
+    private String fieldString;
+    @PrimaryKey
+    private long fieldId;
     private long fieldLong;
     private short fieldShort;
     private int fieldInt;
@@ -63,14 +77,13 @@
     private AllJavaTypes fieldObject;
     private RealmList<AllJavaTypes> fieldList;
 
-    @LinkingObjects("fieldObject")
+    @LinkingObjects(FIELD_OBJECT)
     private final RealmResults<AllJavaTypes> objectParents = null;
 
-    @LinkingObjects("fieldList")
+    @LinkingObjects(FIELD_LIST)
     private final RealmResults<AllJavaTypes> listParents = null;
 
     public AllJavaTypes() {
-
     }
 
     public AllJavaTypes(long fieldLong) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java
index 5696701480..db8d4a2dbb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java
@@ -20,6 +20,8 @@
 
 import io.realm.RealmList;
 import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
 import io.realm.annotations.PrimaryKey;
 import io.realm.annotations.Required;
 
@@ -37,30 +39,32 @@
 // 11 Object
 public class NullTypes extends RealmObject {
 
-    public static String CLASS_NAME = "NullTypes";
-    public static String FIELD_ID = "id";
-    public static String FIELD_STRING_NOT_NULL = "fieldStringNotNull";
-    public static String FIELD_STRING_NULL = "fieldStringNull";
-    public static String FIELD_BYTES_NOT_NULL = "fieldBytesNotNull";
-    public static String FIELD_BYTES_NULL = "fieldBytesNull";
-    public static String FIELD_BOOLEAN_NOT_NULL = "fieldBooleanNotNull";
-    public static String FIELD_BOOLEAN_NULL = "fieldBooleanNull";
-    public static String FIELD_BYTE_NOT_NULL = "fieldByteNotNull";
-    public static String FIELD_BYTE_NULL = "fieldByteNull";
-    public static String FIELD_SHORT_NOT_NULL = "fieldShortNotNull";
-    public static String FIELD_SHORT_NULL = "fieldShortNull";
-    public static String FIELD_INTEGER_NOT_NULL = "fieldIntegerNotNull";
-    public static String FIELD_INTEGER_NULL = "fieldIntegerNull";
-    public static String FIELD_LONG_NOT_NULL = "fieldLongNotNull";
-    public static String FIELD_LONG_NULL = "fieldLongNull";
-    public static String FIELD_FLOAT_NOT_NULL = "fieldFloatNotNull";
-    public static String FIELD_FLOAT_NULL = "fieldFloatNull";
-    public static String FIELD_DOUBLE_NOT_NULL = "fieldDoubleNotNull";
-    public static String FIELD_DOUBLE_NULL = "fieldDoubleNull";
-    public static String FIELD_DATE_NOT_NULL = "fieldDateNotNull";
-    public static String FIELD_DATE_NULL = "fieldDateNull";
-    public static String FIELD_OBJECT_NULL = "fieldObjectNull";
-    public static String FIELD_LIST_NULL = "fieldListNull";
+    public static final String CLASS_NAME = "NullTypes";
+    public static final String FIELD_ID = "id";
+    public static final String FIELD_STRING_NOT_NULL = "fieldStringNotNull";
+    public static final String FIELD_STRING_NULL = "fieldStringNull";
+    public static final String FIELD_BYTES_NOT_NULL = "fieldBytesNotNull";
+    public static final String FIELD_BYTES_NULL = "fieldBytesNull";
+    public static final String FIELD_BOOLEAN_NOT_NULL = "fieldBooleanNotNull";
+    public static final String FIELD_BOOLEAN_NULL = "fieldBooleanNull";
+    public static final String FIELD_BYTE_NOT_NULL = "fieldByteNotNull";
+    public static final String FIELD_BYTE_NULL = "fieldByteNull";
+    public static final String FIELD_SHORT_NOT_NULL = "fieldShortNotNull";
+    public static final String FIELD_SHORT_NULL = "fieldShortNull";
+    public static final String FIELD_INTEGER_NOT_NULL = "fieldIntegerNotNull";
+    public static final String FIELD_INTEGER_NULL = "fieldIntegerNull";
+    public static final String FIELD_LONG_NOT_NULL = "fieldLongNotNull";
+    public static final String FIELD_LONG_NULL = "fieldLongNull";
+    public static final String FIELD_FLOAT_NOT_NULL = "fieldFloatNotNull";
+    public static final String FIELD_FLOAT_NULL = "fieldFloatNull";
+    public static final String FIELD_DOUBLE_NOT_NULL = "fieldDoubleNotNull";
+    public static final String FIELD_DOUBLE_NULL = "fieldDoubleNull";
+    public static final String FIELD_DATE_NOT_NULL = "fieldDateNotNull";
+    public static final String FIELD_DATE_NULL = "fieldDateNull";
+    public static final String FIELD_OBJECT_NULL = "fieldObjectNull";
+    public static final String FIELD_LIST_NULL = "fieldListNull";
+    public static final String FIELD_LO_OBJECT = "objectParents";
+    public static final String FIELD_LO_LIST = "listParents";
 
     @PrimaryKey
     private int id;
@@ -107,8 +111,17 @@
 
     private NullTypes fieldObjectNull;
 
+    // never nullable
     private RealmList<NullTypes> fieldListNull;
 
+    // never nullable
+    @LinkingObjects(FIELD_OBJECT_NULL)
+    private final RealmResults<NullTypes> objectParents = null;
+
+    // never nullable
+    @LinkingObjects(FIELD_LIST_NULL)
+    private final RealmResults<NullTypes> listParents = null;
+
     public int getId() {
         return id;
     }
@@ -292,4 +305,12 @@ public void setFieldObjectNull(NullTypes fieldObjectNull) {
     public void setFieldListNull(RealmList<NullTypes> fieldListNull) {
         this.fieldListNull = fieldListNull;
     }
+
+    public RealmResults<NullTypes> getObjectParents() {
+        return objectParents;
+    }
+
+    public RealmResults<NullTypes> getListParents() {
+        return listParents;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
index 83ca6db974..8a9a492201 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
@@ -55,6 +55,8 @@
     @Rule
     public final RunInLooperThread looperThread = new RunInLooperThread();
 
+    private final long[] oneNullTable = new long[] {NativeObject.NULLPTR};
+
     private RealmConfiguration config;
     private SharedRealm sharedRealm;
     private Table table;
@@ -130,7 +132,7 @@ private void addRow(SharedRealm sharedRealm) {
 
     @Test
     public void constructor_withDistinct() {
-        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(table, "firstName");
+        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(null, table, "firstName");
         Collection collection = new Collection(sharedRealm, table.where(), null, distinctDescriptor);
 
         assertEquals(collection.size(), 3);
@@ -166,8 +168,8 @@ public void size() {
     @Test
     public void where() {
         Collection collection = new Collection(sharedRealm, table.where());
-        Collection collection2 = new Collection(sharedRealm, collection.where().equalTo(new long[]{0}, "John"));
-        Collection collection3 =new Collection(sharedRealm, collection2.where().equalTo(new long[]{1}, "Anderson"));
+        Collection collection2 = new Collection(sharedRealm, collection.where().equalTo(new long[] {0}, oneNullTable, "John"));
+        Collection collection3 = new Collection(sharedRealm, collection2.where().equalTo(new long[] {1}, oneNullTable, "Anderson"));
 
         // A new native Results should be created.
         assertTrue(collection.getNativePtr() != collection2.getNativePtr());
@@ -180,8 +182,8 @@ public void where() {
 
     @Test
     public void sort() {
-        Collection collection = new Collection(sharedRealm, table.where().greaterThan(new long[]{2}, 1));
-        SortDescriptor sortDescriptor = new SortDescriptor(table, new long[] {2});
+        Collection collection = new Collection(sharedRealm, table.where().greaterThan(new long[] {2}, oneNullTable, 1));
+        SortDescriptor sortDescriptor = SortDescriptor.getTestInstance(table, new long[] {2});
 
         Collection collection2 = collection.sort(sortDescriptor);
 
@@ -213,7 +215,7 @@ public void contains() {
 
     @Test
     public void indexOf() {
-        SortDescriptor sortDescriptor = new SortDescriptor(table, new long[] {2});
+        SortDescriptor sortDescriptor = SortDescriptor.getTestInstance(table, new long[] {2});
 
         Collection collection = new Collection(sharedRealm, table.where(), sortDescriptor);
         UncheckedRow row = table.getUncheckedRow(0);
@@ -222,7 +224,7 @@ public void indexOf() {
 
     @Test
     public void indexOf_long() {
-        SortDescriptor sortDescriptor = new SortDescriptor(table, new long[] {2});
+        SortDescriptor sortDescriptor = SortDescriptor.getTestInstance(table, new long[] {2});
 
         Collection collection = new Collection(sharedRealm, table.where(), sortDescriptor);
         assertEquals(3, collection.indexOf(0));
@@ -230,9 +232,9 @@ public void indexOf_long() {
 
     @Test
     public void distinct() {
-        Collection collection = new Collection(sharedRealm, table.where().lessThan(new long[]{2}, 4));
+        Collection collection = new Collection(sharedRealm, table.where().lessThan(new long[] {2}, oneNullTable, 4));
 
-        SortDescriptor distinctDescriptor = new SortDescriptor(table, new long[] {2});
+        SortDescriptor distinctDescriptor = SortDescriptor.getTestInstance(table, new long[] {2});
         Collection collection2 = collection.distinct(distinctDescriptor);
 
         // A new native Results should be created.
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
index 7f9042057d..6d1e8570f0 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
@@ -30,7 +30,9 @@
 
 public class JNIQueryTest extends TestCase {
 
-    Table table;
+    private Table table;
+    private final long[] oneNullTable = new long[]{NativeObject.NULLPTR};
+
 
     @Override
     protected void setUp() throws Exception {
@@ -56,7 +58,7 @@ public void testShouldQuery() {
         init();
         TableQuery query = table.where();
 
-        long cnt = query.equalTo(new long[]{1}, "D").count();
+        long cnt = query.equalTo(new long[]{1}, oneNullTable, "D").count();
         assertEquals(2, cnt);
 
         cnt = query.minimumInt(0);
@@ -79,9 +81,9 @@ public void testNonCompleteQuery() {
         init();
 
         // All the following queries are not valid, e.g contain a group but not a closing group, an or() but not a second filter etc
-        try { table.where().equalTo(new long[]{0}, 1).or().validateQuery();       fail("missing a second filter"); }      catch (UnsupportedOperationException ignore) {}
+        try { table.where().equalTo(new long[]{0}, oneNullTable, 1).or().validateQuery();       fail("missing a second filter"); }      catch (UnsupportedOperationException ignore) {}
         try { table.where().or().validateQuery();                                 fail("just an or()"); }                 catch (UnsupportedOperationException ignore) {}
-        try { table.where().group().equalTo(new long[]{0}, 1).validateQuery();    fail("missing a closing group"); }      catch (UnsupportedOperationException ignore) {}
+        try { table.where().group().equalTo(new long[]{0}, oneNullTable, 1).validateQuery();    fail("missing a closing group"); }      catch (UnsupportedOperationException ignore) {}
 
         try { table.where().group().count();                                fail(); }                               catch (UnsupportedOperationException ignore) {}
         try { table.where().group().validateQuery();                              fail(); }                               catch (UnsupportedOperationException ignore) {}
@@ -91,12 +93,12 @@ public void testNonCompleteQuery() {
         try { table.where().group().sumInt(0);                              fail(); }                               catch (UnsupportedOperationException ignore) {}
         try { table.where().group().averageInt(0);                          fail(); }                               catch (UnsupportedOperationException ignore) {}
 
-        try { table.where().endGroup().equalTo(new long[]{0}, 1).validateQuery(); fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
-        try { table.where().equalTo(new long[]{0}, 1).endGroup().validateQuery(); fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
+        try { table.where().endGroup().equalTo(new long[]{0}, oneNullTable, 1).validateQuery(); fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
+        try { table.where().equalTo(new long[]{0}, oneNullTable, 1).endGroup().validateQuery(); fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
 
-        try { table.where().equalTo(new long[]{0}, 1).endGroup().find();    fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
-        try { table.where().equalTo(new long[]{0}, 1).endGroup().find(0);   fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
-        try { table.where().equalTo(new long[]{0}, 1).endGroup().find(1);   fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
+        try { table.where().equalTo(new long[]{0}, oneNullTable, 1).endGroup().find();    fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
+        try { table.where().equalTo(new long[]{0}, oneNullTable, 1).endGroup().find(0);   fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
+        try { table.where().equalTo(new long[]{0}, oneNullTable, 1).endGroup().find(1);   fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
     }
 
     public void testInvalidColumnIndexEqualTo() {
@@ -104,45 +106,45 @@ public void testInvalidColumnIndexEqualTo() {
         TableQuery query = table.where();
 
         // Boolean
-        try { query.equalTo(new long[]{-1}, true); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, true);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, true); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, oneNullTable, true); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, oneNullTable, true);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, oneNullTable, true); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Date
-        try { query.equalTo(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, oneNullTable, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, oneNullTable, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, oneNullTable, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Double
-        try { query.equalTo(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, oneNullTable, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, oneNullTable, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, oneNullTable, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
 
         // Float
-        try { query.equalTo(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, oneNullTable, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, oneNullTable, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, oneNullTable, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Int / long
-        try { query.equalTo(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, oneNullTable, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, oneNullTable, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, oneNullTable, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String
-        try { query.equalTo(new long[]{-1}, "a"); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, "a");  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, "a"); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, oneNullTable, "a"); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, oneNullTable, "a");  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, oneNullTable, "a"); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case true
-        try { query.equalTo(new long[]{-1}, "a", Case.SENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, "a", Case.SENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, "a", Case.SENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, oneNullTable, "a", Case.SENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, oneNullTable, "a", Case.SENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, oneNullTable, "a", Case.SENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case false
-        try { query.equalTo(new long[]{-1}, "a", Case.INSENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, "a", Case.INSENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, "a", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, oneNullTable, "a", Case.INSENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, oneNullTable, "a", Case.INSENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, oneNullTable, "a", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
     public void testInvalidColumnIndexNotEqualTo() {
@@ -151,40 +153,40 @@ public void testInvalidColumnIndexNotEqualTo() {
 
 
         // Date
-        try { query.notEqualTo(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, oneNullTable, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{9}, oneNullTable, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{10}, oneNullTable, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Double
-        try { query.notEqualTo(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, oneNullTable, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{9}, oneNullTable, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{10}, oneNullTable, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
 
         // Float
-        try { query.notEqualTo(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, oneNullTable, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{9}, oneNullTable, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{10}, oneNullTable, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Int / long
-        try { query.notEqualTo(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, oneNullTable, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{9}, oneNullTable, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{10}, oneNullTable, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String
-        try { query.notEqualTo(new long[]{-1}, "a"); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, "a");  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, "a"); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, oneNullTable, "a"); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{9}, oneNullTable, "a");  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{10}, oneNullTable, "a"); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case true
-        try { query.notEqualTo(new long[]{-1}, "a", Case.SENSITIVE); fail("-1column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, "a", Case.SENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, "a", Case.SENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, oneNullTable, "a", Case.SENSITIVE); fail("-1column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{9}, oneNullTable, "a", Case.SENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{10}, oneNullTable, "a", Case.SENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case false
-        try { query.notEqualTo(new long[]{-1}, "a", Case.INSENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, "a", Case.INSENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, "a", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, oneNullTable, "a", Case.INSENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{9}, oneNullTable, "a", Case.INSENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{10}, oneNullTable, "a", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
 
@@ -193,25 +195,25 @@ public void testInvalidColumnIndexGreaterThan() {
         TableQuery query = table.where();
 
         // Date
-        try { query.greaterThan(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{-1}, oneNullTable, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{9}, oneNullTable, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{10}, oneNullTable, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Double
-        try { query.greaterThan(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{-1}, oneNullTable, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{9}, oneNullTable, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{10}, oneNullTable, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
 
         // Float
-        try { query.greaterThan(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{-1}, oneNullTable, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{9}, oneNullTable, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{10}, oneNullTable, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Int / long
-        try { query.greaterThan(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{-1}, oneNullTable, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{9}, oneNullTable, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{10}, oneNullTable, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
 
@@ -220,25 +222,25 @@ public void testInvalidColumnIndexGreaterThanOrEqual() {
         TableQuery query = table.where();
 
         // Date
-        try { query.greaterThanOrEqual(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, new Date()); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{-1}, oneNullTable, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{9}, oneNullTable, new Date()); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{10}, oneNullTable, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Double
-        try { query.greaterThanOrEqual(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, 4.5d); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{-1}, oneNullTable, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{9}, oneNullTable, 4.5d); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{10}, oneNullTable, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
 
         // Float
-        try { query.greaterThanOrEqual(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, 1.4f); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{-1}, oneNullTable, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{9}, oneNullTable, 1.4f); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{10}, oneNullTable, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Int / long
-        try { query.greaterThanOrEqual(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, 1); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{-1}, oneNullTable, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{9}, oneNullTable, 1); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{10}, oneNullTable, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
 
@@ -247,25 +249,25 @@ public void testInvalidColumnIndexLessThan() {
         TableQuery query = table.where();
 
         // Date
-        try { query.lessThan(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{-1}, oneNullTable, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{9}, oneNullTable, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{10}, oneNullTable, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Double
-        try { query.lessThan(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{-1}, oneNullTable, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{9}, oneNullTable, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{10}, oneNullTable, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
 
         // Float
-        try { query.lessThan(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{-1}, oneNullTable, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{9}, oneNullTable, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{10}, oneNullTable, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Int / long
-        try { query.lessThan(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{-1}, oneNullTable, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{9}, oneNullTable, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{10}, oneNullTable, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
     public void testInvalidColumnIndexLessThanOrEqual() {
@@ -273,25 +275,25 @@ public void testInvalidColumnIndexLessThanOrEqual() {
         TableQuery query = table.where();
 
         // Date
-        try { query.lessThanOrEqual(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{-1}, oneNullTable, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{9}, oneNullTable, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{10}, oneNullTable, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Double
-        try { query.lessThanOrEqual(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{-1}, oneNullTable, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{9}, oneNullTable, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{10}, oneNullTable, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
 
         // Float
-        try { query.lessThanOrEqual(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, 1.4f); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{-1}, oneNullTable, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{9}, oneNullTable, 1.4f); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{10}, oneNullTable, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Int / long
-        try { query.lessThanOrEqual(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, 1); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{-1}, oneNullTable, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{9}, oneNullTable, 1); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{10}, oneNullTable, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
 
@@ -327,19 +329,19 @@ public void testInvalidColumnIndexContains() {
         TableQuery query = table.where();
 
         // String
-        try { query.contains(new long[]{-1}, "hey"); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{9}, "hey");  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{10}, "hey"); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{-1}, oneNullTable, "hey"); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{9}, oneNullTable, "hey");  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{10}, oneNullTable, "hey"); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case true
-        try { query.contains(new long[]{-1}, "hey", Case.SENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{9}, "hey", Case.SENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{10}, "hey", Case.SENSITIVE); fail("-0 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{-1}, oneNullTable, "hey", Case.SENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{9}, oneNullTable, "hey", Case.SENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{10}, oneNullTable, "hey", Case.SENSITIVE); fail("-0 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case false
-        try { query.contains(new long[]{-1}, "hey", Case.INSENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{9}, "hey", Case.INSENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{10}, "hey", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{-1}, oneNullTable, "hey", Case.INSENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{9}, oneNullTable, "hey", Case.INSENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{10}, oneNullTable, "hey", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
     public void testNullInputQuery() {
@@ -348,29 +350,29 @@ public void testNullInputQuery() {
         t.addColumn(RealmFieldType.STRING, "stringCol");
 
         Date nullDate = null;
-        try { t.where().equalTo(new long[]{0}, nullDate);               fail("Date is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().notEqualTo(new long[]{0}, nullDate);            fail("Date is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().greaterThan(new long[]{0}, nullDate);           fail("Date is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().greaterThanOrEqual(new long[]{0}, nullDate);    fail("Date is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().lessThan(new long[]{0}, nullDate);              fail("Date is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().lessThanOrEqual(new long[]{0}, nullDate);       fail("Date is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().equalTo(new long[]{0}, oneNullTable, nullDate);               fail("Date is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().notEqualTo(new long[]{0}, oneNullTable, nullDate);            fail("Date is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().greaterThan(new long[]{0}, oneNullTable, nullDate);           fail("Date is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().greaterThanOrEqual(new long[]{0}, oneNullTable, nullDate);    fail("Date is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().lessThan(new long[]{0}, oneNullTable, nullDate);              fail("Date is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().lessThanOrEqual(new long[]{0}, oneNullTable, nullDate);       fail("Date is null"); } catch (IllegalArgumentException e) { }
         try { t.where().between(new long[]{0}, nullDate, new Date());   fail("Date is null"); } catch (IllegalArgumentException e) { }
         try { t.where().between(new long[]{0}, new Date(), nullDate);   fail("Date is null"); } catch (IllegalArgumentException e) { }
         try { t.where().between(new long[]{0}, nullDate, nullDate);     fail("Dates are null"); } catch (IllegalArgumentException e) { }
 
         String nullString = null;
-        try { t.where().equalTo(new long[]{1}, nullString);                         fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().equalTo(new long[]{1}, nullString, Case.INSENSITIVE);       fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().notEqualTo(new long[]{1}, nullString);                      fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().notEqualTo(new long[]{1}, nullString, Case.INSENSITIVE);    fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().contains(new long[]{1}, nullString);                        fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().contains(new long[]{1}, nullString, Case.INSENSITIVE);      fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().beginsWith(new long[]{1}, nullString);                      fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().beginsWith(new long[]{1}, nullString, Case.INSENSITIVE);    fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().endsWith(new long[]{1}, nullString);                        fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().endsWith(new long[]{1}, nullString, Case.INSENSITIVE);      fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().like(new long[]{1}, nullString);                            fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().like(new long[]{1}, nullString, Case.INSENSITIVE);          fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().equalTo(new long[]{1}, oneNullTable, nullString);                         fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().equalTo(new long[]{1}, oneNullTable, nullString, Case.INSENSITIVE);       fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().notEqualTo(new long[]{1}, oneNullTable, nullString);                      fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().notEqualTo(new long[]{1}, oneNullTable, nullString, Case.INSENSITIVE);    fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().contains(new long[]{1}, oneNullTable, nullString);                        fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().contains(new long[]{1}, oneNullTable, nullString, Case.INSENSITIVE);      fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().beginsWith(new long[]{1}, oneNullTable, nullString);                      fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().beginsWith(new long[]{1}, oneNullTable, nullString, Case.INSENSITIVE);    fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().endsWith(new long[]{1}, oneNullTable, nullString);                        fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().endsWith(new long[]{1}, oneNullTable, nullString, Case.INSENSITIVE);      fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().like(new long[]{1}, oneNullTable, nullString);                            fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().like(new long[]{1}, oneNullTable, nullString, Case.INSENSITIVE);          fail("String is null"); } catch (IllegalArgumentException e) { }
     }
 
 
@@ -391,7 +393,7 @@ public void testShouldFind() {
         table.add("Bill", 564, true);       // 4
         table.add("Janet", 875, false);     // 5 *
 
-        TableQuery query = table.where().greaterThan(new long[]{1}, 600);
+        TableQuery query = table.where().greaterThan(new long[]{1}, oneNullTable, 600);
 
         // Finds first match.
         assertEquals(1, query.find());
@@ -425,7 +427,7 @@ public void testQueryTestForNoMatches() {
 
         t.add(new byte[]{1,2,3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, "string");
 
-        TableQuery q = t.where().greaterThan(new long[]{5}, 1000); // No matches
+        TableQuery q = t.where().greaterThan(new long[]{5}, oneNullTable, 1000); // No matches
 
         assertEquals(-1, q.find());
         assertEquals(-1, q.find(1));
@@ -442,57 +444,57 @@ public void testQueryWithWrongDataType() {
 
         // Compares strings in non string columns.
         for (int i = 0; i <= 6; i++) {
-            try { query.equalTo(new long[]{i}, "string");                 assert(false); } catch(IllegalArgumentException e) {}
-            try { query.notEqualTo(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
-            try { query.beginsWith(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
-            try { query.endsWith(new long[]{i}, "string");                assert(false); } catch(IllegalArgumentException e) {}
-            try { query.like(new long[]{i}, "string");                    assert(false); } catch(IllegalArgumentException e) {}
-            try { query.contains(new long[]{i}, "string");                assert(false); } catch(IllegalArgumentException e) {}
+            try { query.equalTo(new long[]{i}, oneNullTable, "string");                 assert(false); } catch(IllegalArgumentException e) {}
+            try { query.notEqualTo(new long[]{i}, oneNullTable, "string");              assert(false); } catch(IllegalArgumentException e) {}
+            try { query.beginsWith(new long[]{i}, oneNullTable, "string");              assert(false); } catch(IllegalArgumentException e) {}
+            try { query.endsWith(new long[]{i}, oneNullTable, "string");                assert(false); } catch(IllegalArgumentException e) {}
+            try { query.like(new long[]{i}, oneNullTable, "string");                    assert(false); } catch(IllegalArgumentException e) {}
+            try { query.contains(new long[]{i}, oneNullTable, "string");                assert(false); } catch(IllegalArgumentException e) {}
         }
 
         // Compares integer in non integer columns.
         for (int i = 0; i <= 6; i++) {
             if (i != 5) {
-                try { query.equalTo(new long[]{i}, 123);                      assert(false); } catch(IllegalArgumentException e) {}
-                try { query.notEqualTo(new long[]{i}, 123);                   assert(false); } catch(IllegalArgumentException e) {}
-                try { query.lessThan(new long[]{i}, 123);                     assert(false); } catch(IllegalArgumentException e) {}
-                try { query.lessThanOrEqual(new long[]{i}, 123);              assert(false); } catch(IllegalArgumentException e) {}
-                try { query.greaterThan(new long[]{i}, 123);                  assert(false); } catch(IllegalArgumentException e) {}
-                try { query.greaterThanOrEqual(new long[]{i}, 123);           assert(false); } catch(IllegalArgumentException e) {}
-                try { query.between(new long[]{i}, 123, 321);                 assert(false); } catch(IllegalArgumentException e) {}
+                try { query.equalTo(new long[]{i}, oneNullTable, 123);                      assert(false); } catch(IllegalArgumentException e) {}
+                try { query.notEqualTo(new long[]{i}, oneNullTable, 123);                   assert(false); } catch(IllegalArgumentException e) {}
+                try { query.lessThan(new long[]{i}, oneNullTable, 123);                     assert(false); } catch(IllegalArgumentException e) {}
+                try { query.lessThanOrEqual(new long[]{i}, oneNullTable, 123);              assert(false); } catch(IllegalArgumentException e) {}
+                try { query.greaterThan(new long[]{i}, oneNullTable, 123);                  assert(false); } catch(IllegalArgumentException e) {}
+                try { query.greaterThanOrEqual(new long[]{i}, oneNullTable, 123);           assert(false); } catch(IllegalArgumentException e) {}
+                try { query.between(new long[]{i}, 123, 321);                               assert(false); } catch(IllegalArgumentException e) {}
             }
         }
 
         // Compares float in non float columns.
         for (int i = 0; i <= 6; i++) {
             if (i != 4) {
-                try { query.equalTo(new long[]{i}, 123F);                     assert(false); } catch(IllegalArgumentException e) {}
-                try { query.notEqualTo(new long[]{i}, 123F);                  assert(false); } catch(IllegalArgumentException e) {}
-                try { query.lessThan(new long[]{i}, 123F);                    assert(false); } catch(IllegalArgumentException e) {}
-                try { query.lessThanOrEqual(new long[]{i}, 123F);             assert(false); } catch(IllegalArgumentException e) {}
-                try { query.greaterThan(new long[]{i}, 123F);                 assert(false); } catch(IllegalArgumentException e) {}
-                try { query.greaterThanOrEqual(new long[]{i}, 123F);          assert(false); } catch(IllegalArgumentException e) {}
-                try { query.between(new long[]{i}, 123F, 321F);               assert(false); } catch(IllegalArgumentException e) {}
+                try { query.equalTo(new long[]{i}, oneNullTable, 123F);                     assert(false); } catch(IllegalArgumentException e) {}
+                try { query.notEqualTo(new long[]{i}, oneNullTable, 123F);                  assert(false); } catch(IllegalArgumentException e) {}
+                try { query.lessThan(new long[]{i}, oneNullTable, 123F);                    assert(false); } catch(IllegalArgumentException e) {}
+                try { query.lessThanOrEqual(new long[]{i}, oneNullTable, 123F);             assert(false); } catch(IllegalArgumentException e) {}
+                try { query.greaterThan(new long[]{i}, oneNullTable, 123F);                 assert(false); } catch(IllegalArgumentException e) {}
+                try { query.greaterThanOrEqual(new long[]{i}, oneNullTable, 123F);          assert(false); } catch(IllegalArgumentException e) {}
+                try { query.between(new long[]{i}, 123F, 321F);                             assert(false); } catch(IllegalArgumentException e) {}
             }
         }
 
         // Compares double in non double columns.
         for (int i = 0; i <= 6; i++) {
             if (i != 3) {
-                try { query.equalTo(new long[]{i}, 123D);                     assert(false); } catch(IllegalArgumentException e) {}
-                try { query.notEqualTo(new long[]{i}, 123D);                  assert(false); } catch(IllegalArgumentException e) {}
-                try { query.lessThan(new long[]{i}, 123D);                    assert(false); } catch(IllegalArgumentException e) {}
-                try { query.lessThanOrEqual(new long[]{i}, 123D);             assert(false); } catch(IllegalArgumentException e) {}
-                try { query.greaterThan(new long[]{i}, 123D);                 assert(false); } catch(IllegalArgumentException e) {}
-                try { query.greaterThanOrEqual(new long[]{i}, 123D);          assert(false); } catch(IllegalArgumentException e) {}
-                try { query.between(new long[]{i}, 123D, 321D);               assert(false); } catch(IllegalArgumentException e) {}
+                try { query.equalTo(new long[]{i}, oneNullTable, 123D);                     assert(false); } catch(IllegalArgumentException e) {}
+                try { query.notEqualTo(new long[]{i}, oneNullTable, 123D);                  assert(false); } catch(IllegalArgumentException e) {}
+                try { query.lessThan(new long[]{i}, oneNullTable, 123D);                    assert(false); } catch(IllegalArgumentException e) {}
+                try { query.lessThanOrEqual(new long[]{i}, oneNullTable, 123D);             assert(false); } catch(IllegalArgumentException e) {}
+                try { query.greaterThan(new long[]{i}, oneNullTable, 123D);                 assert(false); } catch(IllegalArgumentException e) {}
+                try { query.greaterThanOrEqual(new long[]{i}, oneNullTable, 123D);          assert(false); } catch(IllegalArgumentException e) {}
+                try { query.between(new long[]{i}, 123D, 321D);                             assert(false); } catch(IllegalArgumentException e) {}
             }
         }
 
         // Compares boolean in non boolean columns.
         for (int i = 0; i <= 6; i++) {
             if (i != 1) {
-              try { query.equalTo(new long[]{i}, true);                       assert(false); } catch(IllegalArgumentException e) {}
+              try { query.equalTo(new long[]{i}, oneNullTable, true);                       assert(false); } catch(IllegalArgumentException e) {}
             }
         }
 
@@ -570,46 +572,46 @@ public void testColumnIndexOutOfBounds() {
         try { query.averageFloat(6);            assert(false); } catch(IllegalArgumentException e) {}
         try { query.averageDouble(6);           assert(false); } catch(IllegalArgumentException e) {}
         // Out of bounds for string
-        try { query.equalTo(new long[]{7}, "string");                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{7}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.beginsWith(new long[]{7}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.endsWith(new long[]{7}, "string");                assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.like(new long[]{7}, "string");                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{7}, "string");                assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, oneNullTable, "string");                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{7}, oneNullTable, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.beginsWith(new long[]{7}, oneNullTable, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.endsWith(new long[]{7}, oneNullTable, "string");                assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.like(new long[]{7}, oneNullTable, "string");                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{7}, oneNullTable, "string");                assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
 
 
         // Out of bounds for integer
-        try { query.equalTo(new long[]{7}, 123);                      assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{7}, 123);                   assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{7}, 123);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{7}, 123);              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{7}, 123);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{7}, 123);           assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{7}, 123, 321);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, oneNullTable, 123);                      assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{7}, oneNullTable, 123);                   assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{7}, oneNullTable, 123);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{7}, oneNullTable, 123);              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{7}, oneNullTable, 123);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{7}, oneNullTable, 123);           assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{7}, 123, 321);                               assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
 
 
         // Out of bounds for float
-        try { query.equalTo(new long[]{7}, 123F);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{7}, 123F);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{7}, 123F);                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{7}, 123F);             assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{7}, 123F);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{7}, 123F);          assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{7}, 123F, 321F);               assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, oneNullTable, 123F);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{7}, oneNullTable, 123F);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{7}, oneNullTable, 123F);                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{7}, oneNullTable, 123F);             assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{7}, oneNullTable, 123F);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{7}, oneNullTable, 123F);          assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{7}, 123F, 321F);                             assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
 
 
         // Out of bounds for double
-        try { query.equalTo(new long[]{7}, 123D);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{7}, 123D);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{7}, 123D);                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{7}, 123D);             assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{7}, 123D);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{7}, 123D);          assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{7}, 123D, 321D);               assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, oneNullTable, 123D);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{7}, oneNullTable, 123D);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{7}, oneNullTable, 123D);                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{7}, oneNullTable, 123D);             assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{7}, oneNullTable, 123D);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{7}, oneNullTable, 123D);          assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{7}, 123D, 321D);                             assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
 
 
         // Out of bounds for boolean
-        try { query.equalTo(new long[]{7}, true);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, oneNullTable, true);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
     }
 
     public void testMaximumDate() {
@@ -655,40 +657,40 @@ public void testDateQuery() throws Exception {
         table.add(past);
         table.add(distantPast);
 
-        assertEquals(1L, table.where().equalTo(new long[]{0}, distantPast).count());
-        assertEquals(6L, table.where().notEqualTo(new long[]{0}, distantPast).count());
-        assertEquals(0L, table.where().lessThan(new long[]{0}, distantPast).count());
-        assertEquals(1L, table.where().lessThanOrEqual(new long[]{0}, distantPast).count());
-        assertEquals(6L, table.where().greaterThan(new long[]{0}, distantPast).count());
-        assertEquals(7L, table.where().greaterThanOrEqual(new long[]{0}, distantPast).count());
-
-        assertEquals(1L, table.where().equalTo(new long[]{0}, past).count());
-        assertEquals(6L, table.where().notEqualTo(new long[]{0}, past).count());
-        assertEquals(1L, table.where().lessThan(new long[]{0}, past).count());
-        assertEquals(2L, table.where().lessThanOrEqual(new long[]{0}, past).count());
-        assertEquals(5L, table.where().greaterThan(new long[]{0}, past).count());
-        assertEquals(6L, table.where().greaterThanOrEqual(new long[]{0}, past).count());
-
-        assertEquals(1L, table.where().equalTo(new long[]{0}, new Date(0)).count());
-        assertEquals(6L, table.where().notEqualTo(new long[]{0}, new Date(0)).count());
-        assertEquals(2L, table.where().lessThan(new long[]{0}, new Date(0)).count());
-        assertEquals(3L, table.where().lessThanOrEqual(new long[]{0}, new Date(0)).count());
-        assertEquals(4L, table.where().greaterThan(new long[]{0}, new Date(0)).count());
-        assertEquals(5L, table.where().greaterThanOrEqual(new long[]{0}, new Date(0)).count());
-
-        assertEquals(1L, table.where().equalTo(new long[]{0}, future).count());
-        assertEquals(6L, table.where().notEqualTo(new long[]{0}, future).count());
-        assertEquals(5L, table.where().lessThan(new long[]{0}, future).count());
-        assertEquals(6L, table.where().lessThanOrEqual(new long[]{0}, future).count());
-        assertEquals(1L, table.where().greaterThan(new long[]{0}, future).count());
-        assertEquals(2L, table.where().greaterThanOrEqual(new long[]{0}, future).count());
-
-        assertEquals(1L, table.where().equalTo(new long[]{0}, distantFuture).count());
-        assertEquals(6L, table.where().notEqualTo(new long[]{0}, distantFuture).count());
-        assertEquals(6L, table.where().lessThan(new long[]{0}, distantFuture).count());
-        assertEquals(7L, table.where().lessThanOrEqual(new long[]{0}, distantFuture).count());
-        assertEquals(0L, table.where().greaterThan(new long[]{0}, distantFuture).count());
-        assertEquals(1L, table.where().greaterThanOrEqual(new long[]{0}, distantFuture).count());
+        assertEquals(1L, table.where().equalTo(new long[]{0}, oneNullTable, distantPast).count());
+        assertEquals(6L, table.where().notEqualTo(new long[]{0}, oneNullTable, distantPast).count());
+        assertEquals(0L, table.where().lessThan(new long[]{0}, oneNullTable, distantPast).count());
+        assertEquals(1L, table.where().lessThanOrEqual(new long[]{0}, oneNullTable, distantPast).count());
+        assertEquals(6L, table.where().greaterThan(new long[]{0}, oneNullTable, distantPast).count());
+        assertEquals(7L, table.where().greaterThanOrEqual(new long[]{0}, oneNullTable, distantPast).count());
+
+        assertEquals(1L, table.where().equalTo(new long[]{0}, oneNullTable, past).count());
+        assertEquals(6L, table.where().notEqualTo(new long[]{0}, oneNullTable, past).count());
+        assertEquals(1L, table.where().lessThan(new long[]{0}, oneNullTable, past).count());
+        assertEquals(2L, table.where().lessThanOrEqual(new long[]{0}, oneNullTable, past).count());
+        assertEquals(5L, table.where().greaterThan(new long[]{0}, oneNullTable, past).count());
+        assertEquals(6L, table.where().greaterThanOrEqual(new long[]{0}, oneNullTable, past).count());
+
+        assertEquals(1L, table.where().equalTo(new long[]{0}, oneNullTable, new Date(0)).count());
+        assertEquals(6L, table.where().notEqualTo(new long[]{0}, oneNullTable, new Date(0)).count());
+        assertEquals(2L, table.where().lessThan(new long[]{0}, oneNullTable, new Date(0)).count());
+        assertEquals(3L, table.where().lessThanOrEqual(new long[]{0}, oneNullTable, new Date(0)).count());
+        assertEquals(4L, table.where().greaterThan(new long[]{0}, oneNullTable, new Date(0)).count());
+        assertEquals(5L, table.where().greaterThanOrEqual(new long[]{0}, oneNullTable, new Date(0)).count());
+
+        assertEquals(1L, table.where().equalTo(new long[]{0}, oneNullTable, future).count());
+        assertEquals(6L, table.where().notEqualTo(new long[]{0}, oneNullTable, future).count());
+        assertEquals(5L, table.where().lessThan(new long[]{0}, oneNullTable, future).count());
+        assertEquals(6L, table.where().lessThanOrEqual(new long[]{0}, oneNullTable, future).count());
+        assertEquals(1L, table.where().greaterThan(new long[]{0}, oneNullTable, future).count());
+        assertEquals(2L, table.where().greaterThanOrEqual(new long[]{0}, oneNullTable, future).count());
+
+        assertEquals(1L, table.where().equalTo(new long[]{0}, oneNullTable, distantFuture).count());
+        assertEquals(6L, table.where().notEqualTo(new long[]{0}, oneNullTable, distantFuture).count());
+        assertEquals(6L, table.where().lessThan(new long[]{0}, oneNullTable, distantFuture).count());
+        assertEquals(7L, table.where().lessThanOrEqual(new long[]{0}, oneNullTable, distantFuture).count());
+        assertEquals(0L, table.where().greaterThan(new long[]{0}, oneNullTable, distantFuture).count());
+        assertEquals(1L, table.where().greaterThanOrEqual(new long[]{0}, oneNullTable, distantFuture).count());
 
         // between
 
@@ -752,12 +754,12 @@ public void testByteArrayQuery() throws Exception {
 
         // Equal to
 
-        assertEquals(1L, table.where().equalTo(new long[]{0}, binary1).count());
-        assertEquals(1L, table.where().equalTo(new long[]{0}, binary3).count());
+        assertEquals(1L, table.where().equalTo(new long[]{0}, oneNullTable, binary1).count());
+        assertEquals(1L, table.where().equalTo(new long[]{0}, oneNullTable, binary3).count());
 
         // Not equal to
 
-        assertEquals(3L, table.where().notEqualTo(new long[]{0}, binary2).count());
-        assertEquals(3L, table.where().notEqualTo(new long[]{0}, binary4).count());
+        assertEquals(3L, table.where().notEqualTo(new long[]{0}, oneNullTable, binary2).count());
+        assertEquals(3L, table.where().notEqualTo(new long[]{0}, oneNullTable, binary4).count());
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
index e387e92c1f..46411ee027 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -43,6 +43,7 @@
 import static junit.framework.Assert.assertTrue;
 import static junit.framework.Assert.fail;
 
+
 @RunWith(AndroidJUnit4.class)
 public class JNITableTest {
     @Rule
@@ -71,8 +72,7 @@ public void tableToString() {
     }
 
     @Test
-    public void rowOperationsOnZeroRow(){
-
+    public void rowOperationsOnZeroRow() {
         Table t = new Table();
         // Removes rows without columns.
         try { t.moveLastOver(0);  fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
@@ -82,7 +82,6 @@ public void rowOperationsOnZeroRow(){
         t.addColumn(RealmFieldType.STRING, "");
         try { t.moveLastOver(0);  fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
         try { t.moveLastOver(10); fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
-
     }
 
     @Test
@@ -90,27 +89,48 @@ public void zeroColOperations() {
         Table tableZeroCols = new Table();
 
         // Adds rows.
-        try { tableZeroCols.add("val");         fail("No columns in table"); } catch (IndexOutOfBoundsException ignored) {}
-        try { tableZeroCols.addEmptyRow();      fail("No columns in table"); } catch (IndexOutOfBoundsException ignored) {}
-        try { tableZeroCols.addEmptyRows(10);   fail("No columns in table"); } catch (IndexOutOfBoundsException ignored) {}
+        try {
+            tableZeroCols.add("val");
+            fail("No columns in table");
+        } catch (IndexOutOfBoundsException ignored) {}
+        try {
+            tableZeroCols.addEmptyRow();
+            fail("No columns in table");
+        } catch (IndexOutOfBoundsException ignored) {}
+        try {
+            tableZeroCols.addEmptyRows(10);
+            fail("No columns in table");
+        } catch (IndexOutOfBoundsException ignored) {}
 
 
         // Col operations
-        try { tableZeroCols.removeColumn(0);                fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
-        try { tableZeroCols.renameColumn(0, "newName");     fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
-        try { tableZeroCols.removeColumn(10);               fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
-        try { tableZeroCols.renameColumn(10, "newName");    fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try {
+            tableZeroCols.removeColumn(0);
+            fail("No columns in table");
+        } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try {
+            tableZeroCols.renameColumn(0, "newName");
+            fail("No columns in table");
+        } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try {
+            tableZeroCols.removeColumn(10);
+            fail("No columns in table");
+        } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try {
+            tableZeroCols.renameColumn(10, "newName");
+            fail("No columns in table");
+        } catch (ArrayIndexOutOfBoundsException ignored) {}
     }
 
     @Test
     public void findFirstNonExisting() {
         Table t = TestHelper.getTableWithAllColumnTypes();
-        t.add(new byte[]{1, 2, 3}, true, new Date(1384423149761L), 4.5d, 5.7f, 100, "string");
+        t.add(new byte[] {1, 2, 3}, true, new Date(1384423149761L), 4.5D, 5.7F, 100, "string");
 
         assertEquals(-1, t.findFirstBoolean(1, false));
-        // FIXME: reenable when core implements find_first_timestamp(): assertEquals(-1, t.findFirstDate(2, new Date(138442314986l)));
-        assertEquals(-1, t.findFirstDouble(3, 1.0d));
-        assertEquals(-1, t.findFirstFloat(4, 1.0f));
+        assertEquals(-1, t.findFirstDate(2, new Date(138442314986L)));
+        assertEquals(-1, t.findFirstDouble(3, 1.0D));
+        assertEquals(-1, t.findFirstFloat(4, 1.0F));
         assertEquals(-1, t.findFirstLong(5, 50));
     }
 
@@ -119,9 +139,9 @@ public void findFirst() {
         final int TEST_SIZE = 10;
         Table t = TestHelper.getTableWithAllColumnTypes();
         for (int i = 0; i < TEST_SIZE; i++) {
-            t.add(new byte[]{1,2,3}, true, new Date(i), (double)i, (float)i, i, "string " + i);
+            t.add(new byte[] {1, 2, 3}, true, new Date(i), (double) i, (float) i, i, "string " + i);
         }
-        t.add(new byte[]{1, 2, 3}, true, new Date(TEST_SIZE), (double) TEST_SIZE, (float) TEST_SIZE, TEST_SIZE, "");
+        t.add(new byte[] {1, 2, 3}, true, new Date(TEST_SIZE), (double) TEST_SIZE, (float) TEST_SIZE, TEST_SIZE, "");
 
         assertEquals(0, t.findFirstBoolean(1, true));
         for (int i = 0; i < TEST_SIZE; i++) {
@@ -147,33 +167,96 @@ public void getValuesFromNonExistingColumn() {
         Table t = TestHelper.getTableWithAllColumnTypes();
         t.addEmptyRows(10);
 
-        try { t.getBinaryByteArray(-1, 0);          fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getBinaryByteArray(-10, 0);         fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getBinaryByteArray(9, 0);           fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getBinaryByteArray(-1, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getBinaryByteArray(-10, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getBinaryByteArray(9, 0);
+            fail("Column does not exist");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
 
-        try { t.getBoolean(-1, 0);                  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getBoolean(-10, 0);                 fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getBoolean(9, 0);                   fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getBoolean(-1, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getBoolean(-10, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getBoolean(9, 0);
+            fail("Column does not exist");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
 
-        try { t.getDate(-1, 0);                     fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getDate(-10, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getDate(9, 0);                      fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getDate(-1, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getDate(-10, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getDate(9, 0);
+            fail("Column does not exist");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
 
-        try { t.getDouble(-1, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getDouble(-10, 0);                  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getDouble(9, 0);                    fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getDouble(-1, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getDouble(-10, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getDouble(9, 0);
+            fail("Column does not exist");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
 
-        try { t.getFloat(-1, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getFloat(-10, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getFloat(9, 0);                     fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getFloat(-1, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getFloat(-10, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getFloat(9, 0);
+            fail("Column does not exist");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
 
-        try { t.getLong(-1, 0);                     fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getLong(-10, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getLong(9, 0);                      fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getLong(-1, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getLong(-10, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getLong(9, 0);
+            fail("Column does not exist");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
 
-        try { t.getString(-1, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getString(-10, 0);                  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getString(9, 0);                    fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getString(-1, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getString(-10, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getString(9, 0);
+            fail("Column does not exist");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
     }
 
     @Test
@@ -182,7 +265,10 @@ public void getNonExistingColumn() {
         t.addColumn(RealmFieldType.INTEGER, "int");
 
         assertEquals(-1, t.getColumnIndex("non-existing column"));
-        try { t.getColumnIndex(null); fail("column name null"); } catch (IllegalArgumentException ignored) { }
+        try {
+            t.getColumnIndex(null);
+            fail("column name null");
+        } catch (IllegalArgumentException ignored) { }
     }
 
     @Test
@@ -191,10 +277,16 @@ public void setNulls() {
         t.addColumn(RealmFieldType.STRING, "");
         t.addColumn(RealmFieldType.DATE, "");
         t.addColumn(RealmFieldType.BINARY, "");
-        t.add("String val", new Date(), new byte[]{1, 2, 3});
+        t.add("String val", new Date(), new byte[] {1, 2, 3});
 
-        try { t.setString(0, 0, null, false);  fail("null string not allowed"); } catch (IllegalArgumentException ignored) { }
-        try { t.setDate(1, 0, null, false);    fail("null Date not allowed"); } catch (IllegalArgumentException ignored) { }
+        try {
+            t.setString(0, 0, null, false);
+            fail("null string not allowed");
+        } catch (IllegalArgumentException ignored) { }
+        try {
+            t.setDate(1, 0, null, false);
+            fail("null Date not allowed");
+        } catch (IllegalArgumentException ignored) { }
     }
 
     @Test
@@ -202,7 +294,10 @@ public void addNegativeEmptyRows() {
         Table t = new Table();
         t.addColumn(RealmFieldType.STRING, "colName");
 
-        try { t.addEmptyRows(-1); fail("Argument is negative"); } catch (IllegalArgumentException ignored) { }
+        try {
+            t.addEmptyRows(-1);
+            fail("Argument is negative");
+        } catch (IllegalArgumentException ignored) { }
     }
 
     @Test
@@ -233,7 +328,7 @@ public void shouldThrowWhenSetIndexOnWrongRealmFieldType() {
 
             // All types supported addSearchIndex and removeSearchIndex.
             boolean exceptionExpected = (
-                            t.getColumnType(colIndex) != RealmFieldType.STRING &&
+                    t.getColumnType(colIndex) != RealmFieldType.STRING &&
                             t.getColumnType(colIndex) != RealmFieldType.INTEGER &&
                             t.getColumnType(colIndex) != RealmFieldType.BOOLEAN &&
                             t.getColumnType(colIndex) != RealmFieldType.DATE);
@@ -266,7 +361,10 @@ public void shouldThrowWhenSetIndexOnWrongRealmFieldType() {
     @Test
     public void columnName() {
         Table t = new Table();
-        try { t.addColumn(RealmFieldType.STRING, "I am 64 characters.............................................."); fail("Only 63 characters supported"); } catch (IllegalArgumentException ignored) { }
+        try {
+            t.addColumn(RealmFieldType.STRING, "I am 64 characters..............................................");
+            fail("Only 63 characters supported");
+        } catch (IllegalArgumentException ignored) { }
         t.addColumn(RealmFieldType.STRING, "I am 63 characters.............................................");
     }
 
@@ -279,40 +377,40 @@ public void tableNumbers() {
         t.addColumn(RealmFieldType.STRING, "StringCol");
 
         // Adds 3 rows of data with same values in each column.
-        t.add(1, 2.0d, 3.0f, "s1");
-        t.add(1, 2.0d, 3.0f, "s1");
-        t.add(1, 2.0d, 3.0f, "s1");
+        t.add(1, 2.0D, 3.0F, "s1");
+        t.add(1, 2.0D, 3.0F, "s1");
+        t.add(1, 2.0D, 3.0F, "s1");
 
         // Adds other values.
-        t.add(10, 20.0d, 30.0f, "s10");
-        t.add(100, 200.0d, 300.0f, "s100");
-        t.add(1000, 2000.0d, 3000.0f, "s1000");
+        t.add(10, 20.0D, 30.0F, "s10");
+        t.add(100, 200.0D, 300.0F, "s100");
+        t.add(1000, 2000.0D, 3000.0F, "s1000");
 
         // Counts instances of values added in the first 3 rows.
         assertEquals(3, t.count(0, 1));
-        assertEquals(3, t.count(1, 2.0d));
-        assertEquals(3, t.count(2, 3.0f));
+        assertEquals(3, t.count(1, 2.0D));
+        assertEquals(3, t.count(2, 3.0F));
         assertEquals(3, t.count(3, "s1"));
 
 
-        assertEquals(3, t.findFirstDouble(1, 20.0d)); // Find rows index for first double value of 20.0 in column 1.
-        assertEquals(4, t.findFirstFloat(2, 300.0f)); // Find rows index for first float value of 300.0 in column 2.
+        assertEquals(3, t.findFirstDouble(1, 20.0D)); // Find rows index for first double value of 20.0 in column 1.
+        assertEquals(4, t.findFirstFloat(2, 300.0F)); // Find rows index for first float value of 300.0 in column 2.
 
         // Sets double and float.
-        t.setDouble(1, 2, -2.0d, false);
-        t.setFloat(2, 2, -3.0f, false);
+        t.setDouble(1, 2, -2.0D, false);
+        t.setFloat(2, 2, -3.0F, false);
 
         // Gets double tests.
-        assertEquals(-2.0d, t.getDouble(1, 2));
-        assertEquals(20.0d, t.getDouble(1, 3));
-        assertEquals(200.0d, t.getDouble(1, 4));
-        assertEquals(2000.0d, t.getDouble(1, 5));
+        assertEquals(-2.0D, t.getDouble(1, 2));
+        assertEquals(20.0D, t.getDouble(1, 3));
+        assertEquals(200.0D, t.getDouble(1, 4));
+        assertEquals(2000.0D, t.getDouble(1, 5));
 
         // Gets float test.
-        assertEquals(-3.0f, t.getFloat(2, 2));
-        assertEquals(30.0f, t.getFloat(2, 3));
-        assertEquals(300.0f, t.getFloat(2, 4));
-        assertEquals(3000.0f, t.getFloat(2, 5));
+        assertEquals(-3.0F, t.getFloat(2, 2));
+        assertEquals(30.0F, t.getFloat(2, 3));
+        assertEquals(300.0F, t.getFloat(2, 4));
+        assertEquals(3000.0F, t.getFloat(2, 5));
     }
 
     // Tests the migration of a string column to be nullable.
@@ -323,7 +421,7 @@ public void convertToNullable() {
         for (RealmFieldType columnType : columnTypes) {
             // Tests various combinations of column names and nullability.
             String[] columnNames = {"foobar", "__TMP__0"};
-            for (boolean nullable : new boolean[]{Table.NOT_NULLABLE, Table.NULLABLE}) {
+            for (boolean nullable : new boolean[] {Table.NOT_NULLABLE, Table.NULLABLE}) {
                 for (String columnName : columnNames) {
                     Table table = new Table();
                     long colIndex = table.addColumn(columnType, columnName, nullable);
@@ -336,11 +434,11 @@ public void convertToNullable() {
                     } else if (columnType == RealmFieldType.DOUBLE) {
                         table.setDouble(colIndex, 0, 1.0, false);
                     } else if (columnType == RealmFieldType.FLOAT) {
-                        table.setFloat(colIndex, 0, 1.0f, false);
+                        table.setFloat(colIndex, 0, 1.0F, false);
                     } else if (columnType == RealmFieldType.INTEGER) {
                         table.setLong(colIndex, 0, 1, false);
                     } else if (columnType == RealmFieldType.BINARY) {
-                        table.setBinaryByteArray(colIndex, 0, new byte[]{0}, false);
+                        table.setBinaryByteArray(colIndex, 0, new byte[] {0}, false);
                     } else if (columnType == RealmFieldType.STRING) {
                         table.setString(colIndex, 0, "Foo", false);
                     }
@@ -399,26 +497,25 @@ public void convertToNotNullable() {
         for (RealmFieldType columnType : columnTypes) {
             // Tests various combinations of column names and nullability.
             String[] columnNames = {"foobar", "__TMP__0"};
-            for (boolean nullable : new boolean[]{Table.NOT_NULLABLE, Table.NULLABLE}) {
+            for (boolean nullable : new boolean[] {Table.NOT_NULLABLE, Table.NULLABLE}) {
                 for (String columnName : columnNames) {
                     Table table = new Table();
                     long colIndex = table.addColumn(columnType, columnName, nullable);
                     table.addColumn(RealmFieldType.BOOLEAN, "bool");
                     table.addEmptyRow();
-                    if (columnType == RealmFieldType.BOOLEAN)
+                    if (columnType == RealmFieldType.BOOLEAN) {
                         table.setBoolean(colIndex, 0, true, false);
-                    else if (columnType == RealmFieldType.DATE)
+                    } else if (columnType == RealmFieldType.DATE) {
                         table.setDate(colIndex, 0, new Date(1), false);
-                    else if (columnType == RealmFieldType.DOUBLE)
+                    } else if (columnType == RealmFieldType.DOUBLE) {
                         table.setDouble(colIndex, 0, 1.0, false);
-                    else if (columnType == RealmFieldType.FLOAT)
-                        table.setFloat(colIndex, 0, 1.0f, false);
-                    else if (columnType == RealmFieldType.INTEGER)
+                    } else if (columnType == RealmFieldType.FLOAT) {
+                        table.setFloat(colIndex, 0, 1.0F, false);
+                    } else if (columnType == RealmFieldType.INTEGER) {
                         table.setLong(colIndex, 0, 1, false);
-                    else if (columnType == RealmFieldType.BINARY)
-                        table.setBinaryByteArray(colIndex, 0, new byte[]{0}, false);
-                    else if (columnType == RealmFieldType.STRING)
-                        table.setString(colIndex, 0, "Foo", false);
+                    } else if (columnType == RealmFieldType.BINARY) {
+                        table.setBinaryByteArray(colIndex, 0, new byte[] {0}, false);
+                    } else if (columnType == RealmFieldType.STRING) { table.setString(colIndex, 0, "Foo", false); }
                     try {
                         table.addEmptyRow();
                         if (columnType == RealmFieldType.BINARY) {
@@ -467,16 +564,17 @@ else if (columnType == RealmFieldType.STRING)
                         assertEquals("", table.getString(colIndex, 1));
                     } else {
                         assertFalse(table.getUncheckedRow(1).isNull(colIndex));
-                        if (columnType == RealmFieldType.BOOLEAN)
+                        if (columnType == RealmFieldType.BOOLEAN) {
                             assertEquals(false, table.getBoolean(colIndex, 1));
-                        else if (columnType == RealmFieldType.DATE)
+                        } else if (columnType == RealmFieldType.DATE) {
                             assertEquals(0, table.getDate(colIndex, 1).getTime());
-                        else if (columnType == RealmFieldType.DOUBLE)
+                        } else if (columnType == RealmFieldType.DOUBLE) {
                             assertEquals(0.0, table.getDouble(colIndex, 1));
-                        else if (columnType == RealmFieldType.FLOAT)
-                            assertEquals(0.0f, table.getFloat(colIndex, 1));
-                        else if (columnType == RealmFieldType.INTEGER)
+                        } else if (columnType == RealmFieldType.FLOAT) {
+                            assertEquals(0.0F, table.getFloat(colIndex, 1));
+                        } else if (columnType == RealmFieldType.INTEGER) {
                             assertEquals(0, table.getLong(colIndex, 1));
+                        }
                     }
                 }
             }
@@ -502,19 +600,19 @@ public void defaultValue_setAndGet() {
         //noinspection TryFinallyCanBeTryWithResources
         try {
             sharedRealm.beginTransaction();
-            final Table table = sharedRealm.getTable(Table.TABLE_PREFIX + "DefaultValueTest");
+            final Table table = sharedRealm.getTable(Table.getTableNameForClass("DefaultValueTest"));
             sharedRealm.commitTransaction();
 
             List<Pair<RealmFieldType, Object>> columnInfoList = Arrays.asList(
                     new Pair<RealmFieldType, Object>(RealmFieldType.STRING, "string value"),
                     new Pair<RealmFieldType, Object>(RealmFieldType.INTEGER, 100L),
                     new Pair<RealmFieldType, Object>(RealmFieldType.BOOLEAN, true),
-                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[]{123}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[] {123}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.DATE, new Date(123456)),
-                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, 1.234f),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, 1.234F),
                     new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, Math.PI),
                     new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, 0L)
-                    // Currently, LIST does not support default value.
+                    // FIXME: Currently, LIST does not support default value.
                     // new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
             );
 
@@ -625,19 +723,19 @@ public void defaultValue_setMultipleTimes() {
         //noinspection TryFinallyCanBeTryWithResources
         try {
             sharedRealm.beginTransaction();
-            final Table table = sharedRealm.getTable(Table.TABLE_PREFIX + "DefaultValueTest");
+            final Table table = sharedRealm.getTable(Table.getTableNameForClass("DefaultValueTest"));
             sharedRealm.commitTransaction();
 
             List<Pair<RealmFieldType, Object>> columnInfoList = Arrays.asList(
                     new Pair<RealmFieldType, Object>(RealmFieldType.STRING, new String[] {"string value1", "string value2"}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.INTEGER, new Long[] {100L, 102L}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.BOOLEAN, new Boolean[] {false, true}),
-                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[][] {new byte[]{123}, new byte[]{-123}}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[][] {new byte[] {123}, new byte[] {-123}}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.DATE, new Date[] {new Date(123456), new Date(13579)}),
-                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, new Float[] {1.234f, 100f}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, new Float[] {1.234F, 100F}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, new Double[] {Math.PI, Math.E}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, new Long[] {0L, 1L})
-                    // Currently, LIST does not support default value.
+                    // FIXME: Currently, LIST does not support default value.
                     // new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
             );
 
@@ -757,19 +855,19 @@ public void defaultValue_overwrittenByNonDefault() {
         //noinspection TryFinallyCanBeTryWithResources
         try {
             sharedRealm.beginTransaction();
-            final Table table = sharedRealm.getTable(Table.TABLE_PREFIX + "DefaultValueTest");
+            final Table table = sharedRealm.getTable(Table.getTableNameForClass("DefaultValueTest"));
             sharedRealm.commitTransaction();
 
             List<Pair<RealmFieldType, Object>> columnInfoList = Arrays.asList(
                     new Pair<RealmFieldType, Object>(RealmFieldType.STRING, new String[] {"string value1", "string value2"}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.INTEGER, new Long[] {100L, 102L}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.BOOLEAN, new Boolean[] {false, true}),
-                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[][] {new byte[]{123}, new byte[]{-123}}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[][] {new byte[] {123}, new byte[] {-123}}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.DATE, new Date[] {new Date(123456), new Date(13579)}),
-                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, new Float[] {1.234f, 100f}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, new Float[] {1.234F, 100F}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, new Double[] {Math.PI, Math.E}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, new Long[] {0L, 1L})
-                    // Currently, LIST does not support default value.
+                    // FIXME: Currently, LIST does not support default value.
                     // new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
             );
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
index 1212415ce0..61f67b779e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
@@ -25,8 +25,8 @@
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
-import java.util.ArrayList;
-import java.util.List;
+import java.util.HashSet;
+import java.util.Set;
 
 import io.realm.RealmConfiguration;
 import io.realm.RealmFieldType;
@@ -39,6 +39,7 @@
 import static junit.framework.Assert.assertTrue;
 import static junit.framework.Assert.fail;
 
+
 @RunWith(AndroidJUnit4.class)
 public class SortDescriptorTests {
     @Rule
@@ -64,14 +65,14 @@ public void tearDown() {
 
     @Test
     public void getInstanceForDistinct() {
-        for (RealmFieldType type : SortDescriptor.validFieldTypesForDistinct) {
+        for (RealmFieldType type : SortDescriptor.DISTINCT_VALID_FIELD_TYPES) {
             long column = table.addColumn(type, type.name());
             table.addSearchIndex(column);
         }
 
         long i = 0;
-        for (RealmFieldType type : SortDescriptor.validFieldTypesForDistinct) {
-            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForDistinct(table, type.name());
+        for (RealmFieldType type : SortDescriptor.DISTINCT_VALID_FIELD_TYPES) {
+            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForDistinct(null, table, type.name());
             assertEquals(1, sortDescriptor.getColumnIndices()[0].length);
             assertEquals(i, sortDescriptor.getColumnIndices()[0][0]);
             assertNull(sortDescriptor.getAscendings());
@@ -89,13 +90,13 @@ public void getInstanceForDistinct_shouldThrowOnLinkAndListListField() {
         table.addColumnLink(listType, listType.name(), table);
 
         try {
-            SortDescriptor.getInstanceForDistinct(table, String.format("%s.%s", listType.name(), type.name()));
+            SortDescriptor.getInstanceForDistinct(null, table, String.format("%s.%s", listType.name(), type.name()));
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         try {
-            SortDescriptor.getInstanceForDistinct(table, String.format("%s.%s", objectType.name(), type.name()));
+            SortDescriptor.getInstanceForDistinct(null, table, String.format("%s.%s", objectType.name(), type.name()));
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -110,8 +111,8 @@ public void getInstanceForDistinct_multipleFields() {
         long intColumn = table.addColumn(intType, intType.name());
         table.addSearchIndex(intColumn);
 
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForDistinct(table, new String[] {
-               stringType.name(), intType.name()});
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForDistinct(null, table, new String[] {
+                stringType.name(), intType.name()});
         assertEquals(2, sortDescriptor.getColumnIndices().length);
         assertNull(sortDescriptor.getAscendings());
         assertEquals(1, sortDescriptor.getColumnIndices()[0].length);
@@ -122,24 +123,11 @@ public void getInstanceForDistinct_multipleFields() {
 
     @Test
     public void getInstanceForDistinct_shouldThrowOnInvalidField() {
-        List<RealmFieldType> types = new ArrayList<RealmFieldType>();
-        for (RealmFieldType type : RealmFieldType.values()) {
-            if (!SortDescriptor.validFieldTypesForDistinct.contains(type) &&
-                    type != RealmFieldType.UNSUPPORTED_DATE &&
-                    type != RealmFieldType.UNSUPPORTED_TABLE &&
-                    type != RealmFieldType.UNSUPPORTED_MIXED) {
-                if (type == RealmFieldType.LIST || type == RealmFieldType.OBJECT) {
-                    table.addColumnLink(type, type.name(), table);
-                } else {
-                    table.addColumn(type, type.name());
-                }
-                types.add(type);
-            }
-        }
+        Set<RealmFieldType> types = getValidFieldTypes(SortDescriptor.DISTINCT_VALID_FIELD_TYPES);
 
         for (RealmFieldType type : types) {
             try {
-                SortDescriptor.getInstanceForDistinct(table, type.name());
+                SortDescriptor.getInstanceForDistinct(null, table, type.name());
                 fail();
             } catch (IllegalArgumentException ignored) {
                 assertTrue(ignored.getMessage().contains("Distinct is not supported"));
@@ -149,13 +137,13 @@ public void getInstanceForDistinct_shouldThrowOnInvalidField() {
 
     @Test
     public void getInstanceForSort() {
-        for (RealmFieldType type : SortDescriptor.validFieldTypesForSort) {
+        for (RealmFieldType type : SortDescriptor.SORT_VALID_FIELD_TYPES) {
             table.addColumn(type, type.name());
         }
 
         long i = 0;
-        for (RealmFieldType type : SortDescriptor.validFieldTypesForSort) {
-            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(table, type.name(), Sort.DESCENDING);
+        for (RealmFieldType type : SortDescriptor.SORT_VALID_FIELD_TYPES) {
+            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(null, table, type.name(), Sort.DESCENDING);
             assertEquals(1, sortDescriptor.getColumnIndices()[0].length);
             assertEquals(i, sortDescriptor.getColumnIndices()[0][0]);
             assertFalse(sortDescriptor.getAscendings()[0]);
@@ -165,7 +153,7 @@ public void getInstanceForSort() {
 
     @Test
     public void getInstanceForSort_linkField() {
-        for (RealmFieldType type : SortDescriptor.validFieldTypesForDistinct) {
+        for (RealmFieldType type : SortDescriptor.DISTINCT_VALID_FIELD_TYPES) {
             long column = table.addColumn(type, type.name());
             table.addSearchIndex(column);
         }
@@ -173,8 +161,8 @@ public void getInstanceForSort_linkField() {
         long columnLink = table.addColumnLink(objectType, objectType.name(), table);
 
         long i = 0;
-        for (RealmFieldType type : SortDescriptor.validFieldTypesForDistinct) {
-            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(table,
+        for (RealmFieldType type : SortDescriptor.DISTINCT_VALID_FIELD_TYPES) {
+            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(null, table,
                     String.format("%s.%s", objectType.name(), type.name()), Sort.ASCENDING);
             assertEquals(2, sortDescriptor.getColumnIndices()[0].length);
             assertEquals(columnLink, sortDescriptor.getColumnIndices()[0][0]);
@@ -191,7 +179,7 @@ public void getInstanceForSort_multipleFields() {
         RealmFieldType intType = RealmFieldType.INTEGER;
         long intColumn = table.addColumn(intType, intType.name());
 
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(table, new String[] {
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(null, table, new String[] {
                 stringType.name(), intType.name()}, new Sort[] {Sort.ASCENDING, Sort.DESCENDING});
 
         assertEquals(2, sortDescriptor.getAscendings().length);
@@ -216,31 +204,18 @@ public void getInstanceForSort_numOfFeildsAndSortOrdersNotMatch() {
 
         thrown.expect(IllegalArgumentException.class);
         thrown.expectMessage("Number of fields and sort orders do not match.");
-        SortDescriptor.getInstanceForSort(table,
-                new String[] { stringType.name(), intType.name()}, new Sort[] {Sort.ASCENDING});
+        SortDescriptor.getInstanceForSort(null, table,
+                new String[] {stringType.name(), intType.name()}, new Sort[] {Sort.ASCENDING});
 
     }
 
     @Test
     public void getInstanceForSort_shouldThrowOnInvalidField() {
-        List<RealmFieldType> types = new ArrayList<RealmFieldType>();
-        for (RealmFieldType type : RealmFieldType.values()) {
-            if (!SortDescriptor.validFieldTypesForSort.contains(type) &&
-                    type != RealmFieldType.UNSUPPORTED_DATE &&
-                    type != RealmFieldType.UNSUPPORTED_TABLE&&
-                    type != RealmFieldType.UNSUPPORTED_MIXED) {
-                if (type == RealmFieldType.LIST || type == RealmFieldType.OBJECT) {
-                    table.addColumnLink(type, type.name(), table);
-                } else {
-                    table.addColumn(type, type.name());
-                }
-                types.add(type);
-            }
-        }
+        Set<RealmFieldType> types = getValidFieldTypes(SortDescriptor.SORT_VALID_FIELD_TYPES);
 
         for (RealmFieldType type : types) {
             try {
-                SortDescriptor.getInstanceForSort(table, type.name(), Sort.ASCENDING);
+                SortDescriptor.getInstanceForSort(null, table, type.name(), Sort.ASCENDING);
                 fail();
             } catch (IllegalArgumentException ignored) {
                 assertTrue(ignored.getMessage().contains("Sort is not supported"));
@@ -256,7 +231,31 @@ public void getInstanceForSort_shouldThrowOnLinkListField() {
         table.addColumnLink(listType, listType.name(), table);
 
         thrown.expect(IllegalArgumentException.class);
-        thrown.expectMessage("is not a supported link field");
-        SortDescriptor.getInstanceForSort(table, String.format("%s.%s", listType.name(), type.name()), Sort.ASCENDING);
+        thrown.expectMessage("Invalid query: field 'LIST' in table 'test_table' is of invalid type 'LIST'.");
+        SortDescriptor.getInstanceForSort(null, table, String.format("%s.%s", listType.name(), type.name()), Sort.ASCENDING);
+    }
+
+    private Set<RealmFieldType> getValidFieldTypes(Set<RealmFieldType> filter) {
+        Set<RealmFieldType> types = new HashSet<>();
+        for (RealmFieldType type : RealmFieldType.values()) {
+            if (!filter.contains(type)) {
+                switch (type) {
+                    case UNSUPPORTED_DATE:
+                    case UNSUPPORTED_TABLE:
+                    case UNSUPPORTED_MIXED:
+                    case LINKING_OBJECTS: // TODO: should be supported?s
+                        break;
+                    case LIST:
+                    case OBJECT:
+                        table.addColumnLink(type, type.name(), table);
+                        types.add(type);
+                        break;
+                    default:
+                        table.addColumn(type, type.name());
+                        types.add(type);
+                }
+            }
+        }
+        return types;
     }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
index 3b7a2a466f..d539d0bd9c 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
@@ -22,6 +22,7 @@
 
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -377,18 +378,17 @@ public void directory_dirIsAFile() throws IOException {
         file.delete(); // clean up
     }
 
-    /* FIXME: deleteRealmOnLogout is not supported by now
+    @Ignore("deleteRealmOnLogout is not supported yet")
     @Test
     public void deleteOnLogout() {
-        User user = createTestUser();
+        SyncUser user = createTestUser();
         String url = "realm://objectserver.realm.io/default";
 
         SyncConfiguration config = new SyncConfiguration.Builder(user, url)
-                .deleteRealmOnLogout()
+                //.deleteRealmOnLogout()
                 .build();
         assertTrue(config.shouldDeleteRealmOnLogout());
     }
-    */
 
     @Test
     public void initialData() {
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index 487a95ff54..754c7f172b 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -22,6 +22,7 @@
 
 import org.junit.After;
 import org.junit.BeforeClass;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -188,16 +189,15 @@ public void isAdmin_allUsers() {
     }
 
     // Tests that the user store returns the last user to login
-    /* FIXME: This test fails because of wrong JSON string.
+    @Ignore("This test fails because of wrong JSON string.")
     @Test
     public void currentUser_returnsUserAfterLogin() {
         AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
-        when(authServer.loginUser(any(Credentials.class), any(URL.class))).thenReturn(SyncTestUtils.createLoginResponse(Long.MAX_VALUE));
+        when(authServer.loginUser(any(SyncCredentials.class), any(URL.class))).thenReturn(SyncTestUtils.createLoginResponse(Long.MAX_VALUE));
 
-        User user = User.login(Credentials.facebook("foo"), "http://bar.com/auth");
-        assertEquals(user, User.currentUser());
+        SyncUser user = SyncUser.login(SyncCredentials.facebook("foo"), "http://bar.com/auth");
+        assertEquals(user, SyncUser.currentUser());
     }
-    */
 
     @Test
     public void getManagementRealm() {
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
index bfa10d391f..01158eb045 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
@@ -62,12 +62,23 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableQuery_nativeValidateQuery(
 // helper functions
 
 // Return TableRef used for build link queries
-static TableRef getTableForLinkQuery(jlong nativeQueryPtr, JniLongArray& indicesArray)
+// Each element in the indicesArray is the index of a column to be used to link to the next TableRef.
+// If the corresponding entry in tablesArray is anything other than a nullptr, the link is a backlink.
+// In that case, the tablesArray element is the pointer to the backlink source table and the
+// indicesArray entry is the source column index in the source table.
+// FIXME!!!  This doesn't actually seem to be following backlinks.
+static TableRef getTableForLinkQuery(jlong nativeQueryPtr, JniLongArray& tablesArray, JniLongArray& indicesArray)
 {
     TableRef table_ref = Q(nativeQueryPtr)->get_table();
     jsize link_element_count = indicesArray.len() - 1;
     for (int i = 0; i < link_element_count; i++) {
-        table_ref->link(size_t(indicesArray[i]));
+        auto col_index = size_t(indicesArray[i]);
+        auto table_ptr = TBL(tablesArray[i]);
+        if (table_ptr == nullptr) {
+            table_ref->link(col_index);
+        }  else {
+            table_ref->backlink(*table_ptr, col_index);
+        }
     }
     return table_ref;
 }
@@ -83,6 +94,21 @@ static TableRef getTableByArray(jlong nativeQueryPtr, JniLongArray& indicesArray
     return table_ref;
 }
 
+// FIXME!!!  This is a hasty attempt to fix the nullable queries.
+// I am not at all sure that it is even the right idea, let alone correct code. --gbm
+static bool isNullable(JNIEnv* env, Table* src_table_ptr, TableRef table_ref, jlong column_idx)
+{
+    // if table_arr is not a nullptr, this is a backlink and not allowed.
+    if (src_table_ptr != nullptr) {
+        ThrowException(env, IllegalArgument, "LinkingObject from field " + std::string(src_table_ptr->get_column_name(column_idx)) + " is not nullable.");
+        return false;
+    }
+    if (!TBL_AND_COL_NULLABLE(env, table_ref.get(), column_idx)) {
+        return false;
+    }
+    return true;
+}
+
 template <typename coretype, typename cpptype, typename javatype>
 Query numeric_link_equal(TableRef tbl, jlong columnIndex, javatype value)
 {
@@ -122,132 +148,144 @@ Query numeric_link_lessequal(TableRef tbl, jlong columnIndex, javatype value)
 
 // Integer
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JJ(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3JJ(JNIEnv* env, jobject,
                                                                             jlong nativeQueryPtr,
-                                                                            jlongArray columnIndexes, jlong value)
+                                                                            jlongArray columnIndexes,
+                                                                            jlongArray tablePointers, jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Int)) {
                 return;
             }
-            Q(nativeQueryPtr)->equal(S(arr[0]), static_cast<int64_t>(value));
+            Q(nativeQueryPtr)->equal(S(index_arr[0]), static_cast<int64_t>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_equal<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_equal<Int, int64_t, jlong>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JJ(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3JJ(JNIEnv* env, jobject,
                                                                                        jlong nativeQueryPtr,
                                                                                        jlongArray columnIndexes,
+                                                                                       jlongArray tablePointers,
                                                                                        jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Int)) {
                 return;
             }
-            Q(nativeQueryPtr)->not_equal(S(arr[0]), static_cast<int64_t>(value));
+            Q(nativeQueryPtr)->not_equal(S(index_arr[0]), static_cast<int64_t>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_notequal<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_notequal<Int, int64_t, jlong>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JJ(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3J_3JJ(JNIEnv* env, jobject,
                                                                               jlong nativeQueryPtr,
-                                                                              jlongArray columnIndexes, jlong value)
+                                                                              jlongArray columnIndexes,
+                                                                              jlongArray tablePointers, jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Int)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater(S(arr[0]), static_cast<int64_t>(value));
+            Q(nativeQueryPtr)->greater(S(index_arr[0]), static_cast<int64_t>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_greater<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_greater<Int, int64_t, jlong>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JJ(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3J_3JJ(JNIEnv* env, jobject,
                                                                                    jlong nativeQueryPtr,
                                                                                    jlongArray columnIndexes,
+                                                                                   jlongArray tablePointers,
                                                                                    jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Int)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater_equal(S(arr[0]), static_cast<int64_t>(value));
+            Q(nativeQueryPtr)->greater_equal(S(index_arr[0]), static_cast<int64_t>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_greaterequal<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_greaterequal<Int, int64_t, jlong>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JJ(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                           jlongArray columnIndexes, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3J_3JJ(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                           jlongArray columnIndexes,
+                                                                           jlongArray tablePointers, jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Int)) {
                 return;
             }
-            Q(nativeQueryPtr)->less(S(arr[0]), static_cast<int64_t>(value));
+            Q(nativeQueryPtr)->less(S(index_arr[0]), static_cast<int64_t>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_less<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_less<Int, int64_t, jlong>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JJ(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3J_3JJ(JNIEnv* env, jobject,
                                                                                 jlong nativeQueryPtr,
-                                                                                jlongArray columnIndexes, jlong value)
+                                                                                jlongArray columnIndexes,
+                                                                                jlongArray tablePointers, jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Int)) {
                 return;
             }
-            Q(nativeQueryPtr)->less_equal(S(arr[0]), static_cast<int64_t>(value));
+            Q(nativeQueryPtr)->less_equal(S(index_arr[0]), static_cast<int64_t>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_lessequal<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_lessequal<Int, int64_t, jlong>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
@@ -276,134 +314,146 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JJJ(J
 
 // Float
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JF(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3JF(JNIEnv* env, jobject,
                                                                             jlong nativeQueryPtr,
-                                                                            jlongArray columnIndexes, jfloat value)
+                                                                            jlongArray columnIndexes,
+                                                                            jlongArray tablePointers, jfloat value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Float)) {
                 return;
             }
-            Q(nativeQueryPtr)->equal(S(arr[0]), static_cast<float>(value));
+            Q(nativeQueryPtr)->equal(S(index_arr[0]), static_cast<float>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_equal<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_equal<Float, float, jfloat>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JF(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3JF(JNIEnv* env, jobject,
                                                                                        jlong nativeQueryPtr,
                                                                                        jlongArray columnIndexes,
+                                                                                       jlongArray tablePointers,
                                                                                        jfloat value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Float)) {
                 return;
             }
-            Q(nativeQueryPtr)->not_equal(S(arr[0]), static_cast<float>(value));
+            Q(nativeQueryPtr)->not_equal(S(index_arr[0]), static_cast<float>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_notequal<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_notequal<Float, float, jfloat>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JF(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3J_3JF(JNIEnv* env, jobject,
                                                                               jlong nativeQueryPtr,
-                                                                              jlongArray columnIndexes, jfloat value)
+                                                                              jlongArray columnIndexes,
+                                                                              jlongArray tablePointers, jfloat value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Float)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater(S(arr[0]), static_cast<float>(value));
+            Q(nativeQueryPtr)->greater(S(index_arr[0]), static_cast<float>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_greater<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_greater<Float, float, jfloat>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JF(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3J_3JF(JNIEnv* env, jobject,
                                                                                    jlong nativeQueryPtr,
                                                                                    jlongArray columnIndexes,
+                                                                                   jlongArray tablePointers,
                                                                                    jfloat value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Float)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater_equal(S(arr[0]), static_cast<float>(value));
+            Q(nativeQueryPtr)->greater_equal(S(index_arr[0]), static_cast<float>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_greaterequal<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_greaterequal<Float, float, jfloat>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JF(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                           jlongArray columnIndexes, jfloat value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3J_3JF(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                           jlongArray columnIndexes,
+                                                                           jlongArray tablePointers, jfloat value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Float)) {
                 return;
             }
-            Q(nativeQueryPtr)->less(S(arr[0]), static_cast<float>(value));
+            Q(nativeQueryPtr)->less(S(index_arr[0]), static_cast<float>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_less<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_less<Float, float, jfloat>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JF(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3J_3JF(JNIEnv* env, jobject,
                                                                                 jlong nativeQueryPtr,
                                                                                 jlongArray columnIndexes,
+                                                                                jlongArray tablePointers,
                                                                                 jfloat value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Float)) {
                 return;
             }
-            Q(nativeQueryPtr)->less_equal(S(arr[0]), static_cast<float>(value));
+            Q(nativeQueryPtr)->less_equal(S(index_arr[0]), static_cast<float>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_lessequal<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_lessequal<Float, float, jfloat>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
@@ -433,135 +483,147 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JFF(J
 
 // Double
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JD(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3JD(JNIEnv* env, jobject,
                                                                             jlong nativeQueryPtr,
-                                                                            jlongArray columnIndexes, jdouble value)
+                                                                            jlongArray columnIndexes,
+                                                                            jlongArray tablePointers, jdouble value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Double)) {
                 return;
             }
-            Q(nativeQueryPtr)->equal(S(arr[0]), static_cast<double>(value));
+            Q(nativeQueryPtr)->equal(S(index_arr[0]), static_cast<double>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_equal<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_equal<Double, double, jdouble>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JD(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3JD(JNIEnv* env, jobject,
                                                                                        jlong nativeQueryPtr,
                                                                                        jlongArray columnIndexes,
+                                                                                       jlongArray tablePointers,
                                                                                        jdouble value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Double)) {
                 return;
             }
-            Q(nativeQueryPtr)->not_equal(S(arr[0]), static_cast<double>(value));
+            Q(nativeQueryPtr)->not_equal(S(index_arr[0]), static_cast<double>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_notequal<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_notequal<Double, double, jdouble>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JD(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3J_3JD(JNIEnv* env, jobject,
                                                                               jlong nativeQueryPtr,
-                                                                              jlongArray columnIndexes, jdouble value)
+                                                                              jlongArray columnIndexes,
+                                                                              jlongArray tablePointers, jdouble value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Double)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater(S(arr[0]), static_cast<double>(value));
+            Q(nativeQueryPtr)->greater(S(index_arr[0]), static_cast<double>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_greater<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_greater<Double, double, jdouble>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JD(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3J_3JD(JNIEnv* env, jobject,
                                                                                    jlong nativeQueryPtr,
                                                                                    jlongArray columnIndexes,
+                                                                                   jlongArray tablePointers,
                                                                                    jdouble value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Double)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater_equal(S(arr[0]), static_cast<double>(value));
+            Q(nativeQueryPtr)->greater_equal(S(index_arr[0]), static_cast<double>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_greaterequal<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_greaterequal<Double, double, jdouble>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JD(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                           jlongArray columnIndexes, jdouble value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3J_3JD(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                           jlongArray columnIndexes,
+                                                                           jlongArray tablePointers, jdouble value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Double)) {
                 return;
             }
-            Q(nativeQueryPtr)->less(S(arr[0]), static_cast<double>(value));
+            Q(nativeQueryPtr)->less(S(index_arr[0]), static_cast<double>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_less<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_less<Double, double, jdouble>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JD(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3J_3JD(JNIEnv* env, jobject,
                                                                                 jlong nativeQueryPtr,
                                                                                 jlongArray columnIndexes,
+                                                                                jlongArray tablePointers,
                                                                                 jdouble value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Double)) {
                 return;
             }
-            Q(nativeQueryPtr)->less_equal(S(arr[0]), static_cast<double>(value));
+            Q(nativeQueryPtr)->less_equal(S(index_arr[0]), static_cast<double>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_lessequal<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_lessequal<Double, double, jdouble>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
@@ -593,21 +655,23 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JDD(J
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualTimestamp(JNIEnv* env, jobject,
                                                                               jlong nativeQueryPtr,
-                                                                              jlongArray columnIndexes, jlong value)
+                                                                              jlongArray columnIndexes,
+                                                                              jlongArray tablePointers, jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->equal(S(arr[0]), from_milliseconds(value));
+            Q(nativeQueryPtr)->equal(S(index_arr[0]), from_milliseconds(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_equal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                ->and_query(numeric_link_equal<Timestamp, Timestamp, Timestamp>(table_ref, index_arr[arr_len - 1],
                                                                                 from_milliseconds(value)));
         }
     }
@@ -617,21 +681,23 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualTimestamp(JN
 JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualTimestamp(JNIEnv* env, jobject,
                                                                                          jlong nativeQueryPtr,
                                                                                          jlongArray columnIndexes,
+                                                                                         jlongArray tablePointers,
                                                                                          jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->not_equal(S(arr[0]), from_milliseconds(value));
+            Q(nativeQueryPtr)->not_equal(S(index_arr[0]), from_milliseconds(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_notequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                ->and_query(numeric_link_notequal<Timestamp, Timestamp, Timestamp>(table_ref, index_arr[arr_len - 1],
                                                                                    from_milliseconds(value)));
         }
     }
@@ -640,21 +706,23 @@ JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualT
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterTimestamp(JNIEnv* env, jobject,
                                                                                 jlong nativeQueryPtr,
-                                                                                jlongArray columnIndexes, jlong value)
+                                                                                jlongArray columnIndexes,
+                                                                                jlongArray tablePointers, jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater(S(arr[0]), from_milliseconds(value));
+            Q(nativeQueryPtr)->greater(S(index_arr[0]), from_milliseconds(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_greater<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                ->and_query(numeric_link_greater<Timestamp, Timestamp, Timestamp>(table_ref, index_arr[arr_len - 1],
                                                                                   from_milliseconds(value)));
         }
     }
@@ -664,21 +732,23 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterTimestamp(
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualTimestamp(JNIEnv* env, jobject,
                                                                                      jlong nativeQueryPtr,
                                                                                      jlongArray columnIndexes,
+                                                                                     jlongArray tablePointers,
                                                                                      jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater_equal(S(arr[0]), from_milliseconds(value));
+            Q(nativeQueryPtr)->greater_equal(S(index_arr[0]), from_milliseconds(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_greaterequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                ->and_query(numeric_link_greaterequal<Timestamp, Timestamp, Timestamp>(table_ref, index_arr[arr_len - 1],
                                                                                        from_milliseconds(value)));
         }
     }
@@ -687,21 +757,23 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualTimes
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessTimestamp(JNIEnv* env, jobject,
                                                                              jlong nativeQueryPtr,
-                                                                             jlongArray columnIndexes, jlong value)
+                                                                             jlongArray columnIndexes,
+                                                                             jlongArray tablePointers, jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->less(S(arr[0]), from_milliseconds(value));
+            Q(nativeQueryPtr)->less(S(index_arr[0]), from_milliseconds(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_less<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                ->and_query(numeric_link_less<Timestamp, Timestamp, Timestamp>(table_ref, index_arr[arr_len - 1],
                                                                                from_milliseconds(value)));
         }
     }
@@ -711,21 +783,23 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessTimestamp(JNI
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualTimestamp(JNIEnv* env, jobject,
                                                                                   jlong nativeQueryPtr,
                                                                                   jlongArray columnIndexes,
+                                                                                  jlongArray tablePointers,
                                                                                   jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->less_equal(S(arr[0]), from_milliseconds(value));
+            Q(nativeQueryPtr)->less_equal(S(index_arr[0]), from_milliseconds(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_lessequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                ->and_query(numeric_link_lessequal<Timestamp, Timestamp, Timestamp>(table_ref, index_arr[arr_len - 1],
                                                                                     from_milliseconds(value)));
         }
     }
@@ -757,24 +831,25 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenTimestamp(
 
 // Bool
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JZ(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3JZ(JNIEnv* env, jobject,
                                                                             jlong nativeQueryPtr,
-                                                                            jlongArray columnIndexes, jboolean value)
+                                                                            jlongArray columnIndexes,
+                                                                            jlongArray tablePointers, jboolean value)
 {
-    JniLongArray arr(env, columnIndexes);
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
-        jsize arr_len = arr.len();
-
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Bool)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Bool)) {
                 return;
             }
-            Q(nativeQueryPtr)->equal(S(arr[0]), value != 0 ? true : false);
+            Q(nativeQueryPtr)->equal(S(index_arr[0]), value != 0 ? true : false);
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_equal<Bool, bool, jboolean>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_equal<Bool, bool, jboolean>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
@@ -785,75 +860,77 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JZ(JNIE
 enum StringPredicate { StringEqual, StringNotEqual, StringContains, StringBeginsWith, StringEndsWith, StringLike };
 
 
-static void TableQuery_StringPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value,
+static void TableQuery_StringPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongArray columnIndexes,
+                                       jlongArray tablePointers, jstring value,
                                        jboolean caseSensitive, StringPredicate predicate)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         if (value == NULL) {
-            if (!TBL_AND_COL_NULLABLE(env, getTableByArray(nativeQueryPtr, arr).get(), arr[arr_len - 1])) {
+            if (!TBL_AND_COL_NULLABLE(env, getTableByArray(nativeQueryPtr, index_arr).get(), index_arr[arr_len - 1])) {
                 return;
             }
         }
         bool is_case_sensitive = caseSensitive ? true : false;
         JStringAccessor value2(env, value); // throws
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_String)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_String)) {
                 return;
             }
             switch (predicate) {
                 case StringEqual:
-                    Q(nativeQueryPtr)->equal(S(arr[0]), value2, is_case_sensitive);
+                    Q(nativeQueryPtr)->equal(S(index_arr[0]), value2, is_case_sensitive);
                     break;
                 case StringNotEqual:
-                    Q(nativeQueryPtr)->not_equal(S(arr[0]), value2, is_case_sensitive);
+                    Q(nativeQueryPtr)->not_equal(S(index_arr[0]), value2, is_case_sensitive);
                     break;
                 case StringContains:
-                    Q(nativeQueryPtr)->contains(S(arr[0]), value2, is_case_sensitive);
+                    Q(nativeQueryPtr)->contains(S(index_arr[0]), value2, is_case_sensitive);
                     break;
                 case StringBeginsWith:
-                    Q(nativeQueryPtr)->begins_with(S(arr[0]), value2, is_case_sensitive);
+                    Q(nativeQueryPtr)->begins_with(S(index_arr[0]), value2, is_case_sensitive);
                     break;
                 case StringEndsWith:
-                    Q(nativeQueryPtr)->ends_with(S(arr[0]), value2, is_case_sensitive);
+                    Q(nativeQueryPtr)->ends_with(S(index_arr[0]), value2, is_case_sensitive);
                     break;
                 case StringLike:
-                    Q(nativeQueryPtr)->like(S(arr[0]), value2, is_case_sensitive);
+                    Q(nativeQueryPtr)->like(S(index_arr[0]), value2, is_case_sensitive);
                     break;
             }
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             switch (predicate) {
                 case StringEqual:
                     Q(nativeQueryPtr)
-                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                        ->and_query(table_ref->column<String>(size_t(index_arr[arr_len - 1]))
                                         .equal(StringData(value2), is_case_sensitive));
                     break;
                 case StringNotEqual:
                     Q(nativeQueryPtr)
-                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                        ->and_query(table_ref->column<String>(size_t(index_arr[arr_len - 1]))
                                         .not_equal(StringData(value2), is_case_sensitive));
                     break;
                 case StringContains:
                     Q(nativeQueryPtr)
-                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                        ->and_query(table_ref->column<String>(size_t(index_arr[arr_len - 1]))
                                         .contains(StringData(value2), is_case_sensitive));
                     break;
                 case StringBeginsWith:
                     Q(nativeQueryPtr)
-                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                        ->and_query(table_ref->column<String>(size_t(index_arr[arr_len - 1]))
                                         .begins_with(StringData(value2), is_case_sensitive));
                     break;
                 case StringEndsWith:
                     Q(nativeQueryPtr)
-                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                        ->and_query(table_ref->column<String>(size_t(index_arr[arr_len - 1]))
                                         .ends_with(StringData(value2), is_case_sensitive));
                     break;
                 case StringLike:
                     Q(nativeQueryPtr)
-                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                        ->and_query(table_ref->column<String>(size_t(index_arr[arr_len - 1]))
                                         .like(StringData(value2), is_case_sensitive));
                     break;
             }
@@ -862,60 +939,68 @@ static void TableQuery_StringPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongA
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JLjava_lang_String_2Z(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3JLjava_lang_String_2Z(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes,
+    jlongArray tablePointers, jstring value, jboolean caseSensitive)
 {
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringEqual);
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, tablePointers, value, caseSensitive, StringEqual);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JLjava_lang_String_2Z(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3JLjava_lang_String_2Z(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes,
+    jlongArray tablePointers, jstring value, jboolean caseSensitive)
 {
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringNotEqual);
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, tablePointers, value, caseSensitive, StringNotEqual);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBeginsWith(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                          jlongArray columnIndexes, jstring value,
+                                                                          jlongArray columnIndexes,
+                                                                          jlongArray tablePointers, jstring value,
                                                                           jboolean caseSensitive)
 {
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringBeginsWith);
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, tablePointers, value, caseSensitive, StringBeginsWith);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEndsWith(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                        jlongArray columnIndexes, jstring value,
+                                                                        jlongArray columnIndexes,
+                                                                        jlongArray tablePointers, jstring value,
                                                                         jboolean caseSensitive)
 {
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringEndsWith);
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, tablePointers, value, caseSensitive, StringEndsWith);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLike(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                    jlongArray columnIndexes, jstring value,
+                                                                    jlongArray columnIndexes,
+                                                                    jlongArray tablePointers, jstring value,
                                                                     jboolean caseSensitive)
 {
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringLike);
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, tablePointers, value, caseSensitive, StringLike);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeContains(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                        jlongArray columnIndexes, jstring value,
+                                                                        jlongArray columnIndexes,
+                                                                        jlongArray tablePointers, jstring value,
                                                                         jboolean caseSensitive)
 {
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringContains);
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, tablePointers, value, caseSensitive, StringContains);
 }
 
 // Binary
 
 enum BinaryPredicate { BinaryEqual, BinaryNotEqual };
 
-static void TableQuery_BinaryPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongArray columnIndices, jbyteArray value,
+static void TableQuery_BinaryPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongArray columnIndexes,
+                                       jlongArray tablePointers, jbyteArray value,
                                        BinaryPredicate predicate)
 {
-    JniLongArray arr(env, columnIndices);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     try {
         JniByteArray bytes(env, value);
         BinaryData value2;
         if (value == NULL) {
-            if (!TBL_AND_COL_NULLABLE(env, getTableByArray(nativeQueryPtr, arr).get(), arr[arr_len - 1])) {
+            if (!TBL_AND_COL_NULLABLE(env, getTableByArray(nativeQueryPtr, index_arr).get(), index_arr[arr_len - 1])) {
                 return;
             }
             value2 = BinaryData();
@@ -929,26 +1014,26 @@ static void TableQuery_BinaryPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongA
         }
 
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Binary)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Binary)) {
                 return;
             }
             switch (predicate) {
                 case BinaryEqual:
-                    Q(nativeQueryPtr)->equal(S(arr[0]), value2);
+                    Q(nativeQueryPtr)->equal(S(index_arr[0]), value2);
                     break;
                 case BinaryNotEqual:
-                    Q(nativeQueryPtr)->not_equal(S(arr[0]), value2);
+                    Q(nativeQueryPtr)->not_equal(S(index_arr[0]), value2);
                     break;
             }
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             switch (predicate) {
                 case BinaryEqual:
-                    Q(nativeQueryPtr)->and_query(table_ref->column<Binary>(size_t(arr[arr_len - 1])) == value2);
+                    Q(nativeQueryPtr)->and_query(table_ref->column<Binary>(size_t(index_arr[arr_len - 1])) == value2);
                     break;
                 case BinaryNotEqual:
-                    Q(nativeQueryPtr)->and_query(table_ref->column<Binary>(size_t(arr[arr_len - 1])) != value2);
+                    Q(nativeQueryPtr)->and_query(table_ref->column<Binary>(size_t(index_arr[arr_len - 1])) != value2);
                     break;
             }
         }
@@ -956,20 +1041,22 @@ static void TableQuery_BinaryPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongA
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3B(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3J_3B(JNIEnv* env, jobject,
                                                                               jlong nativeQueryPtr,
                                                                               jlongArray columnIndices,
+                                                                              jlongArray tablePointers,
                                                                               jbyteArray value)
 {
-    TableQuery_BinaryPredicate(env, nativeQueryPtr, columnIndices, value, BinaryEqual);
+    TableQuery_BinaryPredicate(env, nativeQueryPtr, columnIndices, tablePointers, value, BinaryEqual);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3B(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3J_3B(JNIEnv* env, jobject,
                                                                                  jlong nativeQueryPtr,
                                                                                  jlongArray columnIndices,
+                                                                                 jlongArray tablePointers,
                                                                                  jbyteArray value)
 {
-    TableQuery_BinaryPredicate(env, nativeQueryPtr, columnIndices, value, BinaryNotEqual);
+    TableQuery_BinaryPredicate(env, nativeQueryPtr, columnIndices, tablePointers, value, BinaryNotEqual);
 }
 
 // General ----------------------------------------------------
@@ -1400,20 +1487,23 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeRemove(JNIEnv* e
 // isNull and isNotNull
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                      jlongArray columnIndexes)
+                                                                      jlongArray columnIndexes,
+                                                                      jlongArray tablePointers)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     Query* pQuery = Q(nativeQueryPtr);
-
     try {
-        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-        jlong column_idx = arr[arr_len - 1];
-        TableRef table_ref = getTableByArray(nativeQueryPtr, arr);
-        if (!TBL_AND_COL_NULLABLE(env, table_ref.get(), column_idx)) {
+        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+        jlong column_idx = index_arr[arr_len - 1];
+        TableRef table_ref = getTableByArray(nativeQueryPtr, index_arr);
+
+        if (!isNullable(env, TBL(table_arr[arr_len - 1]), table_ref, column_idx)) {
             return;
         }
 
+        // FIXME!!!  Support a backlink as the last column in a field descriptor
         int col_type = table_ref->get_column_type(S(column_idx));
         if (arr_len == 1) {
             switch (col_type) {
@@ -1440,6 +1530,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(JNIEnv* en
             }
         }
         else {
+            // FIXME!!!  Support a backlink as an internal column in a field descriptor
             switch (col_type) {
                 case type_Link:
                     ThrowException(env, IllegalArgument, "isNull() by nested query for link field is not supported.");
@@ -1520,18 +1611,21 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery(JN
 }
 
 
+
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                         jlongArray columnIndexes)
+                                                                         jlongArray columnIndexes,
+                                                                         jlongArray tablePointers)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     Query* pQuery = Q(nativeQueryPtr);
     try {
-        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-        jlong column_idx = arr[arr_len - 1];
-        TableRef table_ref = getTableByArray(nativeQueryPtr, arr);
+        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+        jlong column_idx = index_arr[arr_len - 1];
+        TableRef table_ref = getTableByArray(nativeQueryPtr, index_arr);
 
-        if (!TBL_AND_COL_NULLABLE(env, table_ref.get(), column_idx)) {
+        if (!isNullable(env, TBL(table_arr[arr_len - 1]), table_ref, column_idx)) {
             return;
         }
 
@@ -1600,17 +1694,19 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull(JNIEnv*
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                       jlongArray columnIndexes)
+                                                                       jlongArray columnIndexes,
+                                                                       jlongArray tablePointers)
 {
-
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
     Query* pQuery = Q(nativeQueryPtr);
     try {
-        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-        jlong column_idx = arr[arr_len - 1];
-        TableRef table_ref = getTableByArray(nativeQueryPtr, arr);
+        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+        jlong column_idx = index_arr[arr_len - 1];
+        TableRef table_ref = getTableByArray(nativeQueryPtr, index_arr);
 
+        // FIXME!!!  Support a backlink as the last column in a field descriptor
         int col_type = table_ref->get_column_type(S(column_idx));
         if (arr_len == 1) {
             // Field queries
@@ -1637,6 +1733,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty(JNIEnv* e
         }
         else {
             // Linked queries
+            // FIXME!!!  Support a backlink as an internal column in a field descriptor
             switch (col_type) {
                 case type_Binary:
                     pQuery->and_query(src_table_ref->column<Binary>(S(column_idx)) == BinaryData("", 0));
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 5b7993e62a..0a5352c989 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -74,7 +74,7 @@
     private RealmCache realmCache;
     protected SharedRealm sharedRealm;
 
-    protected final StandardRealmSchema schema;
+    protected final RealmSchema schema;
 
     // Create a realm instance and associate it to a RealmCache.
     BaseRealm(RealmCache cache) {
@@ -132,7 +132,7 @@ public boolean isAutoRefresh() {
      * <p>
      * WARNING: Calling this on a thread with async queries will turn those queries into synchronous queries.
      * In most cases it is better to use {@link RealmChangeListener}s to be notified about changes to the
-     * Realm on a given thread than it is to use this method. 
+     * Realm on a given thread than it is to use this method.
      *
      * @throws IllegalStateException if attempting to refresh from within a transaction.
      */
@@ -740,6 +740,7 @@ public void clear() {
         }
     }
 
+    // FIXME: This stuff doesn't appear to be used.  It should either be explained or deleted.
     static final class ThreadLocalRealmObjectContext extends ThreadLocal<RealmObjectContext> {
         @Override
         protected RealmObjectContext initialValue() {
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index 17c5a861f4..718b7044c7 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -137,7 +137,7 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
      */
     public RealmQuery<DynamicRealmObject> where(String className) {
         checkIfValid();
-        if (!sharedRealm.hasTable(Table.TABLE_PREFIX + className)) {
+        if (!sharedRealm.hasTable(Table.getTableNameForClass(className))) {
             throw new IllegalArgumentException("Class does not exist in the Realm and cannot be queried: " + className);
         }
         return RealmQuery.createDynamicQuery(this, className);
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index e8dcd1b15a..f4b0b3498c 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -37,7 +37,7 @@
 public class DynamicRealmObject extends RealmObject implements RealmObjectProxy {
     static final String MSG_LINK_QUERY_NOT_SUPPORTED = "Queries across relationships are not supported";
 
-    private final ProxyState proxyState = new ProxyState(this);
+    private final ProxyState<DynamicRealmObject> proxyState = new ProxyState<>(this);
 
     /**
      * Creates a dynamic Realm object based on an existing object.
@@ -344,7 +344,7 @@ public DynamicRealmObject getObject(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         try {
             LinkView linkView = proxyState.getRow$realm().getLinkList(columnIndex);
-            String className = RealmSchema.getSchemaForTable(linkView.getTargetTable());
+            String className = linkView.getTargetTable().getClassName();
             return new RealmList<>(className, linkView, proxyState.getRealm$realm());
         } catch (IllegalArgumentException e) {
             checkFieldType(fieldName, columnIndex, RealmFieldType.LIST);
@@ -705,7 +705,7 @@ public void setList(String fieldName, RealmList<DynamicRealmObject> list) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         LinkView links = proxyState.getRow$realm().getLinkList(columnIndex);
         Table linkTargetTable = links.getTargetTable();
-        final String linkTargetTableName = Table.tableNameToClassName(linkTargetTable.getName());
+        final String linkTargetTableName = linkTargetTable.getClassName();
 
         boolean typeValidated;
         if (list.className == null && list.clazz == null) {
@@ -714,7 +714,7 @@ public void setList(String fieldName, RealmList<DynamicRealmObject> list) {
             typeValidated = false;
         } else {
             String listType = list.className != null ? list.className
-                    : Table.tableNameToClassName(proxyState.getRealm$realm().getSchema().getTable(list.clazz).getName());
+                    : proxyState.getRealm$realm().getSchema().getTable(list.clazz).getClassName();
             if (!linkTargetTableName.equals(listType)) {
                 throw new IllegalArgumentException(String.format(Locale.ENGLISH,
                         "The elements in the list are not the proper type. " +
@@ -736,7 +736,7 @@ public void setList(String fieldName, RealmList<DynamicRealmObject> list) {
                         "Element at index %d is not the proper type. " +
                                 "Was '%s' expected '%s'.",
                         i,
-                        Table.tableNameToClassName(obj.realmGet$proxyState().getRow$realm().getTable().getName()),
+                        obj.realmGet$proxyState().getRow$realm().getTable().getClassName(),
                         linkTargetTableName));
             }
             indices[i] = obj.realmGet$proxyState().getRow$realm().getIndex();
@@ -777,7 +777,7 @@ public void setNull(String fieldName) {
     public String getType() {
         proxyState.getRealm$realm().checkIfValid();
 
-        return RealmSchema.getSchemaForTable(proxyState.getRow$realm().getTable());
+        return proxyState.getRow$realm().getTable().getClassName();
     }
 
     /**
@@ -873,7 +873,7 @@ public String toString() {
             return "Invalid object";
         }
 
-        final String className = Table.tableNameToClassName(proxyState.getRow$realm().getTable().getName());
+        final String className = proxyState.getRow$realm().getTable().getClassName();
         StringBuilder sb = new StringBuilder(className + " = [");
         String[] fields = getFieldNames();
         for (String field : fields) {
@@ -906,12 +906,11 @@ public String toString() {
                 case OBJECT:
                     sb.append(proxyState.getRow$realm().isNullLink(columnIndex)
                             ? "null"
-                            : Table.tableNameToClassName(proxyState.getRow$realm().getTable().getLinkTarget(columnIndex).getName()));
+                            : proxyState.getRow$realm().getTable().getLinkTarget(columnIndex).getClassName());
                     break;
                 case LIST:
-                    final String tableName = proxyState.getRow$realm().getTable().getLinkTarget(columnIndex).getName();
-                    String targetType = Table.tableNameToClassName(tableName);
-                    sb.append(String.format("RealmList<%s>[%s]", targetType, proxyState.getRow$realm().getLinkList(columnIndex).size()));
+                    String targetClassName = proxyState.getRow$realm().getTable().getLinkTarget(columnIndex).getClassName();
+                    sb.append(String.format("RealmList<%s>[%s]", targetClassName, proxyState.getRow$realm().getLinkList(columnIndex).size()));
                     break;
                 case UNSUPPORTED_TABLE:
                 case UNSUPPORTED_MIXED:
@@ -919,9 +918,9 @@ public String toString() {
                     sb.append("?");
                     break;
             }
-            sb.append("}, ");
+            sb.append("},");
         }
-        sb.replace(sb.length() - 2, sb.length(), "");
+        sb.replace(sb.length() - 1, sb.length(), "");
         sb.append("]");
         return sb.toString();
     }
@@ -968,7 +967,7 @@ public String toString() {
                     RealmFieldType.OBJECT.name(), RealmFieldType.LIST.name()));
         }
 
-        return RealmResults.createBacklinkResults(realm, (CheckedRow) proxyState.getRow$realm(), realmObjectSchema.getTable(), srcFieldName);
+        return RealmResults.createDynamicBacklinkResults(realm, (CheckedRow) proxyState.getRow$realm(), realmObjectSchema.getTable(), srcFieldName);
     }
 
     @Override
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
index e7852490d1..194aa13d72 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
@@ -23,21 +23,24 @@
             " 'OrderedRealmCollectionSnapshot'.";
 
     final BaseRealm realm;
-    Class<E> classSpec;   // Return type
-    String className;     // Class name used by DynamicRealmObjects
+    final Class<E> classSpec;   // Return type
+    final String className;     // Class name used by DynamicRealmObjects
 
     final Collection collection;
 
     OrderedRealmCollectionImpl(BaseRealm realm, Collection collection, Class<E> clazz) {
-        this.realm = realm;
-        this.classSpec = clazz;
-        this.collection = collection;
+        this(realm, collection, clazz, null);
     }
 
     OrderedRealmCollectionImpl(BaseRealm realm, Collection collection, String className) {
+        this(realm, collection, null, className);
+    }
+
+    private OrderedRealmCollectionImpl(BaseRealm realm, Collection collection, Class<E> clazz, String className) {
         this.realm = realm;
-        this.className = className;
         this.collection = collection;
+        this.classSpec = clazz;
+        this.className = className;
     }
 
     Table getTable() {
@@ -254,7 +257,7 @@ private long getColumnIndexForSort(String fieldName) {
     @Override
     public RealmResults<E> sort(String fieldName) {
         SortDescriptor sortDescriptor =
-                SortDescriptor.getInstanceForSort(collection.getTable(), fieldName, Sort.ASCENDING);
+                SortDescriptor.getInstanceForSort(getSchemaConnector(), collection.getTable(), fieldName, Sort.ASCENDING);
 
         Collection sortedCollection = collection.sort(sortDescriptor);
         return createLoadedResults(sortedCollection);
@@ -266,7 +269,7 @@ private long getColumnIndexForSort(String fieldName) {
     @Override
     public RealmResults<E> sort(String fieldName, Sort sortOrder) {
         SortDescriptor sortDescriptor =
-                SortDescriptor.getInstanceForSort(collection.getTable(), fieldName, sortOrder);
+                SortDescriptor.getInstanceForSort(getSchemaConnector(), collection.getTable(), fieldName, sortOrder);
 
         Collection sortedCollection = collection.sort(sortDescriptor);
         return createLoadedResults(sortedCollection);
@@ -278,7 +281,7 @@ private long getColumnIndexForSort(String fieldName) {
     @Override
     public RealmResults<E> sort(String fieldNames[], Sort sortOrders[]) {
         SortDescriptor sortDescriptor =
-                SortDescriptor.getInstanceForSort(collection.getTable(), fieldNames, sortOrders);
+                SortDescriptor.getInstanceForSort(getSchemaConnector(), collection.getTable(), fieldNames, sortOrders);
 
         Collection sortedCollection = collection.sort(sortDescriptor);
         return createLoadedResults(sortedCollection);
@@ -558,4 +561,8 @@ protected E convertRowToObject(UncheckedRow row) {
         results.load();
         return results;
     }
+
+    private SchemaConnector getSchemaConnector() {
+        return new SchemaConnector(realm.getSchema());
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/OsRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/OsRealmObjectSchema.java
index 6078699ec8..8da935e7a6 100644
--- a/realm/realm-library/src/main/java/io/realm/OsRealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/OsRealmObjectSchema.java
@@ -15,7 +15,6 @@
  */
 package io.realm;
 
-import java.util.LinkedHashSet;
 import java.util.Set;
 
 import io.realm.internal.Table;
@@ -29,13 +28,15 @@
      * the validation of schema, object schemas and properties through the object store. Even though the constructor
      * is public, there is never a purpose which justifies calling it!
      *
+     * @param schema The parent for this schema: the schema to which this object belongs
      * @param className name of the class
      */
-    OsRealmObjectSchema(String className) {
-        this.nativePtr = nativeCreateRealmObjectSchema(className);
+    OsRealmObjectSchema(RealmSchema schema, String className) {
+        this(schema, nativeCreateRealmObjectSchema(className));
     }
 
-    OsRealmObjectSchema(long nativePtr) {
+    private OsRealmObjectSchema(RealmSchema schema, long nativePtr) {
+        super(schema);
         this.nativePtr = nativePtr;
     }
 
@@ -162,11 +163,6 @@ public RealmFieldType getFieldType(String fieldName) {
         throw new UnsupportedOperationException();
     }
 
-    @Override
-    long[] getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
-        throw new UnsupportedOperationException();
-    }
-
     @Override
     OsRealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
         final Property property = new Property(name, type, primary, indexed, required);
@@ -189,10 +185,6 @@ OsRealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema link
         return this;
     }
 
-    long getNativePtr() {
-        return nativePtr;
-    }
-
     @Override
     Table getTable() {
         throw new UnsupportedOperationException();
@@ -203,6 +195,10 @@ long getAndCheckFieldIndex(String fieldName) {
         throw new UnsupportedOperationException();
     }
 
+    long getNativePtr() {
+        return nativePtr;
+    }
+
     static native long nativeCreateRealmObjectSchema(String className);
 
     static native void nativeAddProperty(long nativePtr, long nativePropertyPtr);
diff --git a/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java b/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
index 7d96117d9d..f047e5ec8d 100644
--- a/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
@@ -34,11 +34,11 @@
  */
 class OsRealmSchema extends RealmSchema {
     static final class Creator extends RealmSchema {
-        private final Map<String, RealmObjectSchema> schema = new HashMap<>();
+        private final Map<String, OsRealmObjectSchema> schema = new HashMap<>();
 
         @Override
         public void close() {
-            for (Map.Entry<String, RealmObjectSchema> entry : schema.entrySet()) {
+            for (Map.Entry<String, OsRealmObjectSchema> entry : schema.entrySet()) {
                 entry.getValue().close();
             }
             schema.clear();
@@ -52,13 +52,13 @@ public RealmObjectSchema get(String className) {
 
         @Override
         public Set<RealmObjectSchema> getAll() {
-            return new LinkedHashSet<>(schema.values());
+            return new LinkedHashSet<RealmObjectSchema>(schema.values());
         }
 
         @Override
         public RealmObjectSchema create(String className) {
             checkEmpty(className);
-            OsRealmObjectSchema realmObjectSchema = new OsRealmObjectSchema(className);
+            OsRealmObjectSchema realmObjectSchema = new OsRealmObjectSchema(this, className);
             schema.put(className, realmObjectSchema);
             return realmObjectSchema;
         }
@@ -103,6 +103,10 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
 
     private long nativePtr;
 
+    // TODO:
+    // Because making getAll return Set<? Extends RealmObjectSchema> is a breaking change
+    // Creator.getAll must return Set<RealmObjectSchema> instead of Set<? extends RealmObjectSchema>
+    // That necessitates the cast inside the loop below.
     OsRealmSchema(Creator creator) {
         Set<RealmObjectSchema> realmObjectSchemas = creator.getAll();
         long[] schemaNativePointers = new long[realmObjectSchemas.size()];
@@ -158,7 +162,7 @@ public RealmObjectSchema get(String className) {
     public RealmObjectSchema create(String className) {
         // Adding a class is always permitted.
         checkEmpty(className);
-        OsRealmObjectSchema realmObjectSchema = new OsRealmObjectSchema(className);
+        OsRealmObjectSchema realmObjectSchema = new OsRealmObjectSchema(this, className);
         dynamicClassToSchema.put(className, realmObjectSchema);
         return realmObjectSchema;
     }
@@ -204,7 +208,7 @@ OsRealmObjectSchema getSchemaForClass(String className) {
         throw new UnsupportedOperationException();
     }
 
-    static void checkEmpty(String str) {
+    private static void checkEmpty(String str) {
         if (str == null || str.isEmpty()) {
             throw new IllegalArgumentException("Null or empty class names are not allowed");
         }
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 1ee29a820d..025ec56556 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -489,10 +489,7 @@ private static void initializeSyncedRealm(Realm realm) {
             schemaCreator = null;
 
             long newVersion = configuration.getSchemaVersion();
-            // !!! FIXME: This appalling kludge is necessitated by current package structure/visiblity constraints.
-            // It absolutely breaks encapsulation and needs to be fixed!
-            long schemaNativePointer = schema.getNativePtr();
-            if (realm.sharedRealm.requiresMigration(schemaNativePointer)) {
+            if (realm.sharedRealm.requiresMigration(schema.getNativePtr())) {
                 if (currentVersion >= newVersion) {
                     throw new IllegalArgumentException(String.format(
                             "The schema was changed but the schema version was not updated. " +
@@ -500,7 +497,7 @@ private static void initializeSyncedRealm(Realm realm) {
                                     " in the Realm file (%d) in order to update the schema.",
                             newVersion, currentVersion));
                 }
-                realm.sharedRealm.updateSchema(schemaNativePointer, newVersion);
+                realm.sharedRealm.updateSchema(schema.getNativePtr(), newVersion);
                 // The OS currently does not handle setting the schema version. We have to do it manually.
                 realm.setVersion(newVersion);
                 commitChanges = true;
@@ -976,7 +973,7 @@ private Scanner getFullStringScanner(InputStream in) {
         // Checks and throws the exception earlier for a better exception message.
         if (table.hasPrimaryKey()) {
             throw new RealmException(String.format("'%s' has a primary key, use" +
-                    " 'createObject(Class<E>, Object)' instead.", Table.tableNameToClassName(table.getName())));
+                    " 'createObject(Class<E>, Object)' instead.", table.getClassName()));
         }
         long rowIndex = table.addEmptyRow();
         return get(clazz, rowIndex, acceptDefaultValue, excludeFields);
@@ -1601,8 +1598,8 @@ public void run() {
                     }
                 } else {
                     if (backgroundException != null) {
-                        // FIXME: ThreadPoolExecutor will never throw the exception in the background. We need a
-                        //        redesign of the async transaction API.
+                        // FIXME: ThreadPoolExecutor will never throw the exception in the background.
+                        // We need a redesign of the async transaction API.
                         // Throw in the worker thread since the caller thread cannot get notifications.
                         throw new RealmException("Async transaction failed", backgroundException);
                     }
@@ -1764,14 +1761,19 @@ ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
         }
 
         ColumnIndices createdGlobalCache = null;
-        final RealmProxyMediator mediator = getConfiguration().getSchemaMediator();
         ColumnIndices cacheForCurrentVersion = RealmCache.findColumnIndices(globalCacheArray,
                 currentSchemaVersion);
         if (cacheForCurrentVersion == null) {
+            final RealmProxyMediator mediator = getConfiguration().getSchemaMediator();
+
             // Not found in global cache. create it.
             final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
             final Map<Class<? extends RealmModel>, ColumnInfo> map;
             map = new HashMap<>(modelClasses.size());
+
+
+            // This code may throw a RealmMigrationNeededException
+            //noinspection CaughtExceptionImmediatelyRethrown
             try {
                 for (Class<? extends RealmModel> clazz : modelClasses) {
                     final ColumnInfo columnInfo = mediator.validateTable(clazz, sharedRealm, true);
@@ -1783,7 +1785,7 @@ ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
 
             cacheForCurrentVersion = createdGlobalCache = new ColumnIndices(currentSchemaVersion, map);
         }
-        schema.updateColumnIndices(cacheForCurrentVersion, mediator);
+        schema.updateColumnIndices(cacheForCurrentVersion);
         return createdGlobalCache;
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 6d479323a8..fcd0145c9b 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -87,16 +87,16 @@ static RealmCacheType valueOf(Class<? extends BaseRealm> clazz) {
     }
 
     private static class CreateRealmRunnable<T extends BaseRealm> implements Runnable {
-        private RealmConfiguration configuration;
-        private BaseRealm.InstanceCallback<T> callback;
-        private Class<T> realmClass;
-        private CountDownLatch canReleaseBackgroundInstanceLatch = new CountDownLatch(1);
-        private RealmNotifier notifier;
+        private final RealmConfiguration configuration;
+        private final BaseRealm.InstanceCallback<T> callback;
+        private final Class<T> realmClass;
+        private final CountDownLatch canReleaseBackgroundInstanceLatch = new CountDownLatch(1);
+        private final RealmNotifier notifier;
         // The Future this runnable belongs to.
         private Future future;
 
         CreateRealmRunnable(RealmNotifier notifier, RealmConfiguration configuration,
-                            BaseRealm.InstanceCallback<T> callback, Class<T> realmClass) {
+                BaseRealm.InstanceCallback<T> callback, Class<T> realmClass) {
             this.configuration = configuration;
             this.realmClass = realmClass;
             this.callback = callback;
@@ -251,7 +251,7 @@ private static RealmCache getCache(String realmPath, boolean createIfNotExist) {
         return cache.doCreateRealmOrGetFromCacheAsync(configuration, callback, realmClass);
     }
 
-    private synchronized  <T extends BaseRealm> RealmAsyncTask doCreateRealmOrGetFromCacheAsync(
+    private synchronized <T extends BaseRealm> RealmAsyncTask doCreateRealmOrGetFromCacheAsync(
             RealmConfiguration configuration, BaseRealm.InstanceCallback<T> callback, Class<T> realmClass) {
         Capabilities capabilities = new AndroidCapabilities();
         capabilities.checkCanDeliverNotification(ASYNC_NOT_ALLOWED_MSG);
@@ -355,7 +355,7 @@ private static RealmCache getCache(String realmPath, boolean createIfNotExist) {
 
             if (realmClass == Realm.class && refAndCount.globalCount == 0) {
                 // Stores a copy of local ColumnIndices as a global cache.
-                RealmCache.storeColumnIndices(typedColumnIndicesArray, realm.schema.cloneColumnIndices());
+                RealmCache.storeColumnIndices(typedColumnIndicesArray, realm.schema.getImmutableColumnIndicies());
             }
             // This is the first instance in current thread, increase the global count.
             refAndCount.globalCount++;
diff --git a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
index b66639dc4c..d235293a7c 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
@@ -42,17 +42,16 @@
     FLOAT(9),
     DOUBLE(10),
     OBJECT(12),
-    LIST(13);
-    // BACKLINK(14); Not exposed until needed.
+    LIST(13),
+    LINKING_OBJECTS(14);
 
     // Primitive array for fast mapping between between native values and their Realm type.
-    private static RealmFieldType[] typeList = new RealmFieldType[15];
+    private static final RealmFieldType[] typeList = new RealmFieldType[15];
 
     static {
         RealmFieldType[] columnTypes = values();
         for (int i = 0; i < columnTypes.length; i++) {
-            int v = columnTypes[i].nativeValue;
-            typeList[v] = columnTypes[i];
+            typeList[columnTypes[i].nativeValue] = columnTypes[i];
         }
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index ec33d39900..d59362b09e 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -246,7 +246,7 @@ private E copyToRealmIfNeeded(E object) {
             RealmObjectProxy proxy = (RealmObjectProxy) object;
 
             if (proxy instanceof DynamicRealmObject) {
-                String listClassName = StandardRealmSchema.getSchemaForTable(view.getTargetTable());
+                String listClassName = view.getTargetTable().getClassName();
                 if (proxy.realmGet$proxyState().getRealm$realm() == realm) {
                     String objectClassName = ((DynamicRealmObject) object).getType();
                     if (listClassName.equals(objectClassName)) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index bed6061e1f..f0a029fac9 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -20,6 +20,7 @@
 
 import io.realm.annotations.Required;
 import io.realm.internal.Table;
+import io.realm.internal.fields.FieldDescriptor;
 
 
 /**
@@ -29,6 +30,16 @@
  * @see io.realm.RealmMigration
  */
 public abstract class RealmObjectSchema {
+    private final RealmSchema schema;
+
+    /**
+     * Create a schema.
+     *
+     * @param schema The parent for this schema: the schema to which this object belongs
+     */
+    protected RealmObjectSchema(RealmSchema schema) {
+        this.schema = schema;
+    }
 
     /**
      * Release the object schema and any of native resources it might hold.
@@ -266,12 +277,29 @@
      */
     public abstract RealmFieldType getFieldType(String fieldName);
 
-    abstract long[] getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes);
+    /**
+     * Get a parser for a field descriptor.
+     *
+     * @param fieldDescription fieldName or link path to a field name.
+     * @param validColumnTypes valid field type for the last field in a linked field
+     * @return a FieldDescriptor
+     */
+    protected final FieldDescriptor getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
+        return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), fieldDescription, validColumnTypes);
+    }
 
     abstract RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required);
 
     abstract RealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo);
 
+    abstract long getAndCheckFieldIndex(String fieldName);
+
+    abstract Table getTable();
+
+    private SchemaConnector getSchemaConnector() {
+        return new SchemaConnector(schema);
+    }
+
     /**
      * Function interface, used when traversing all objects of the current class and apply a function on each.
      *
@@ -280,18 +308,4 @@
     public interface Function {
         void apply(DynamicRealmObject obj);
     }
-
-    // Tuple containing data about each supported Java type.
-    protected static class FieldMetaData {
-        protected final RealmFieldType realmType;
-        protected final boolean defaultNullable;
-
-        protected FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
-            this.realmType = realmType;
-            this.defaultNullable = defaultNullable;
-        }
-    }
-
-    abstract Table getTable();
-    abstract long getAndCheckFieldIndex(String fieldName);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index e9fbfdd5cb..f0c45e581f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -29,6 +29,7 @@
 import io.realm.internal.SortDescriptor;
 import io.realm.internal.Table;
 import io.realm.internal.TableQuery;
+import io.realm.internal.fields.FieldDescriptor;
 
 
 /**
@@ -60,7 +61,7 @@
     private LinkView linkView;
     private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
     private static final String EMPTY_VALUES = "Non-empty 'values' must be provided.";
-    static final String ASYNC_QUERY_WRONG_THREAD_MESSAGE = "Async query cannot be created on current thread.";
+    private static final String ASYNC_QUERY_WRONG_THREAD_MESSAGE = "Async query cannot be created on current thread.";
 
     /**
      * Creates a query for objects of a given class from a {@link Realm}.
@@ -93,14 +94,11 @@
      * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
      * to run it.
      */
-
     @SuppressWarnings("unchecked")
     public static <E extends RealmModel> RealmQuery<E> createQueryFromResult(RealmResults<E> queryResults) {
-        if (queryResults.classSpec != null) {
-            return new RealmQuery<>(queryResults, queryResults.classSpec);
-        } else {
-            return new RealmQuery(queryResults, queryResults.className);
-        }
+        return (queryResults.classSpec == null)
+                ? new RealmQuery(queryResults, queryResults.className)
+                : new RealmQuery<>(queryResults, queryResults.classSpec);
     }
 
     /**
@@ -112,11 +110,9 @@
      */
     @SuppressWarnings("unchecked")
     public static <E extends RealmModel> RealmQuery<E> createQueryFromList(RealmList<E> list) {
-        if (list.clazz != null) {
-            return new RealmQuery(list.realm, list.view, list.clazz);
-        } else {
-            return new RealmQuery(list.realm, list.view, list.className);
-        }
+        return (list.clazz == null)
+                ? new RealmQuery(list.realm, list.view, list.className)
+                : new RealmQuery(list.realm, list.view, list.clazz);
     }
 
     private RealmQuery(Realm realm, Class<E> clazz) {
@@ -203,10 +199,10 @@ public boolean isValid() {
     public RealmQuery<E> isNull(String fieldName) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName);
 
         // Checks that fieldName has the correct type is done in C++.
-        this.query.isNull(columnIndices);
+        this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         return this;
     }
 
@@ -221,10 +217,10 @@ public boolean isValid() {
     public RealmQuery<E> isNotNull(String fieldName) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName);
 
         // Checks that fieldName has the correct type is done in C++.
-        this.query.isNotNull(columnIndices);
+        this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         return this;
     }
 
@@ -256,8 +252,8 @@ public boolean isValid() {
     }
 
     private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, String value, Case casing) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
-        this.query.equalTo(columnIndices, value, casing);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
         return this;
     }
 
@@ -276,11 +272,11 @@ public boolean isValid() {
     }
 
     private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Byte value) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
-            this.query.isNull(columnIndices);
+            this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -296,11 +292,11 @@ public boolean isValid() {
     public RealmQuery<E> equalTo(String fieldName, byte[] value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.BINARY);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.BINARY);
         if (value == null) {
-            this.query.isNull(columnIndices);
+            this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -320,11 +316,11 @@ public boolean isValid() {
     }
 
     private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Short value) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
-            this.query.isNull(columnIndices);
+            this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -344,11 +340,11 @@ public boolean isValid() {
     }
 
     private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Integer value) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
-            this.query.isNull(columnIndices);
+            this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -368,11 +364,11 @@ public boolean isValid() {
     }
 
     private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Long value) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
-            this.query.isNull(columnIndices);
+            this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -392,11 +388,11 @@ public boolean isValid() {
     }
 
     private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Double value) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         if (value == null) {
-            this.query.isNull(columnIndices);
+            this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -416,11 +412,11 @@ public boolean isValid() {
     }
 
     private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Float value) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         if (value == null) {
-            this.query.isNull(columnIndices);
+            this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -440,11 +436,11 @@ public boolean isValid() {
     }
 
     private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Boolean value) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.BOOLEAN);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.BOOLEAN);
         if (value == null) {
-            this.query.isNull(columnIndices);
+            this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -464,8 +460,8 @@ public boolean isValid() {
     }
 
     private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Date value) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
-        this.query.equalTo(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -705,11 +701,11 @@ public boolean isValid() {
     public RealmQuery<E> notEqualTo(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
-        if (columnIndices.length > 1 && !casing.getValue()) {
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        if (fd.length() > 1 && !casing.getValue()) {
             throw new IllegalArgumentException("Link queries cannot be case insensitive - coming soon.");
         }
-        this.query.notEqualTo(columnIndices, value, casing);
+        this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
         return this;
     }
 
@@ -724,11 +720,11 @@ public boolean isValid() {
     public RealmQuery<E> notEqualTo(String fieldName, Byte value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.notEqualTo(columnIndices, value);
+            this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -744,11 +740,11 @@ public boolean isValid() {
     public RealmQuery<E> notEqualTo(String fieldName, byte[] value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.BINARY);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.BINARY);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.notEqualTo(columnIndices, value);
+            this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -764,11 +760,11 @@ public boolean isValid() {
     public RealmQuery<E> notEqualTo(String fieldName, Short value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.notEqualTo(columnIndices, value);
+            this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -784,11 +780,11 @@ public boolean isValid() {
     public RealmQuery<E> notEqualTo(String fieldName, Integer value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.notEqualTo(columnIndices, value);
+            this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -804,11 +800,11 @@ public boolean isValid() {
     public RealmQuery<E> notEqualTo(String fieldName, Long value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.notEqualTo(columnIndices, value);
+            this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -824,11 +820,11 @@ public boolean isValid() {
     public RealmQuery<E> notEqualTo(String fieldName, Double value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.notEqualTo(columnIndices, value);
+            this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -844,11 +840,11 @@ public boolean isValid() {
     public RealmQuery<E> notEqualTo(String fieldName, Float value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.notEqualTo(columnIndices, value);
+            this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -864,11 +860,11 @@ public boolean isValid() {
     public RealmQuery<E> notEqualTo(String fieldName, Boolean value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.BOOLEAN);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.BOOLEAN);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, !value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), !value);
         }
         return this;
     }
@@ -884,11 +880,11 @@ public boolean isValid() {
     public RealmQuery<E> notEqualTo(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.notEqualTo(columnIndices, value);
+            this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -904,8 +900,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThan(String fieldName, int value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.greaterThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.greaterThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -920,8 +916,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThan(String fieldName, long value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.greaterThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.greaterThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -936,8 +932,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThan(String fieldName, double value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
-        this.query.greaterThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        this.query.greaterThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -952,8 +948,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThan(String fieldName, float value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
-        this.query.greaterThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        this.query.greaterThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -968,8 +964,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThan(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
-        this.query.greaterThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.greaterThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -984,8 +980,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, int value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.greaterThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.greaterThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1000,8 +996,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, long value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.greaterThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.greaterThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1016,8 +1012,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, double value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
-        this.query.greaterThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        this.query.greaterThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1032,8 +1028,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, float value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
-        this.query.greaterThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        this.query.greaterThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1048,8 +1044,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
-        this.query.greaterThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.greaterThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1064,8 +1060,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, int value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.lessThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.lessThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1080,8 +1076,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, long value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.lessThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.lessThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1096,8 +1092,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, double value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
-        this.query.lessThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        this.query.lessThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1112,8 +1108,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, float value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
-        this.query.lessThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        this.query.lessThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1128,8 +1124,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
-        this.query.lessThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.lessThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1144,8 +1140,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, int value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.lessThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.lessThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1160,8 +1156,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, long value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.lessThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.lessThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1176,8 +1172,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, double value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
-        this.query.lessThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        this.query.lessThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1192,8 +1188,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, float value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
-        this.query.lessThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        this.query.lessThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1208,8 +1204,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
-        this.query.lessThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.lessThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1225,8 +1221,8 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, int from, int to) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.between(columnIndices, from, to);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.between(fd.getColumnIndices(), from, to);
         return this;
     }
 
@@ -1242,8 +1238,8 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, long from, long to) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.between(columnIndices, from, to);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.between(fd.getColumnIndices(), from, to);
         return this;
     }
 
@@ -1259,8 +1255,8 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, double from, double to) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
-        this.query.between(columnIndices, from, to);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        this.query.between(fd.getColumnIndices(), from, to);
         return this;
     }
 
@@ -1276,8 +1272,8 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, float from, float to) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
-        this.query.between(columnIndices, from, to);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        this.query.between(fd.getColumnIndices(), from, to);
         return this;
     }
 
@@ -1293,8 +1289,8 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, Date from, Date to) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
-        this.query.between(columnIndices, from, to);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.between(fd.getColumnIndices(), from, to);
         return this;
     }
 
@@ -1323,8 +1319,8 @@ public boolean isValid() {
     public RealmQuery<E> contains(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
-        this.query.contains(columnIndices, value, casing);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        this.query.contains(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
         return this;
     }
 
@@ -1352,8 +1348,8 @@ public boolean isValid() {
     public RealmQuery<E> beginsWith(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
-        this.query.beginsWith(columnIndices, value, casing);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        this.query.beginsWith(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
         return this;
     }
 
@@ -1381,8 +1377,8 @@ public boolean isValid() {
     public RealmQuery<E> endsWith(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
-        this.query.endsWith(columnIndices, value, casing);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        this.query.endsWith(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
         return this;
     }
 
@@ -1418,8 +1414,8 @@ public boolean isValid() {
     public RealmQuery<E> like(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
-        this.query.like(columnIndices, value, casing);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        this.query.like(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
         return this;
     }
 
@@ -1497,8 +1493,9 @@ public boolean isValid() {
     public RealmQuery<E> isEmpty(String fieldName) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST);
-        this.query.isEmpty(columnIndices);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST, RealmFieldType.LINKING_OBJECTS);
+        this.query.isEmpty(fd.getColumnIndices(), fd.getNativeTablePointers());
+
         return this;
     }
 
@@ -1513,8 +1510,9 @@ public boolean isValid() {
     public RealmQuery<E> isNotEmpty(String fieldName) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST);
-        this.query.isNotEmpty(columnIndices);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST, RealmFieldType.LINKING_OBJECTS);
+        this.query.isNotEmpty(fd.getColumnIndices(), fd.getNativeTablePointers());
+
         return this;
     }
 
@@ -1533,7 +1531,7 @@ public boolean isValid() {
     public RealmResults<E> distinct(String fieldName) {
         realm.checkIfValid();
 
-        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(query.getTable(), fieldName);
+        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(getSchemaConnector(), query.getTable(), fieldName);
         return createRealmResults(query, null, distinctDescriptor, true);
     }
 
@@ -1554,7 +1552,7 @@ public boolean isValid() {
         realm.checkIfValid();
 
         realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
-        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(query.getTable(), fieldName);
+        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(getSchemaConnector(), query.getTable(), fieldName);
         return createRealmResults(query, null, distinctDescriptor, false);
     }
 
@@ -1577,7 +1575,7 @@ public boolean isValid() {
 
         fieldNames[0] = firstFieldName;
         System.arraycopy(remainingFieldNames, 0, fieldNames, 1, remainingFieldNames.length);
-        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(table, fieldNames);
+        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(getSchemaConnector(), table, fieldNames);
         return createRealmResults(query, null, distinctDescriptor, true);
     }
 
@@ -1608,6 +1606,7 @@ public Number sum(String fieldName) {
 
     /**
      * Returns the average of a given field.
+     * Does not support dotted field notation.
      *
      * @param fieldName the field to calculate average on. Only number fields are supported.
      * @return the average for the given field amongst objects in query results. This will be of type double for all
@@ -1771,7 +1770,7 @@ public long count() {
     public RealmResults<E> findAllSorted(String fieldName, Sort sortOrder) {
         realm.checkIfValid();
 
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(query.getTable(), fieldName, sortOrder);
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldName, sortOrder);
         return createRealmResults(query, sortDescriptor, null, true);
     }
 
@@ -1788,7 +1787,7 @@ public long count() {
         realm.checkIfValid();
 
         realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(query.getTable(), fieldName, sortOrder);
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldName, sortOrder);
         return createRealmResults(query, sortDescriptor, null, false);
     }
 
@@ -1838,7 +1837,7 @@ public long count() {
     public RealmResults<E> findAllSorted(String[] fieldNames, Sort[] sortOrders) {
         realm.checkIfValid();
 
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(query.getTable(), fieldNames, sortOrders);
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldNames, sortOrders);
         return createRealmResults(query, sortDescriptor, null, true);
     }
 
@@ -1861,7 +1860,7 @@ private boolean isDynamicQuery() {
         realm.checkIfValid();
 
         realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(query.getTable(), fieldNames, sortOrders);
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldNames, sortOrders);
         return createRealmResults(query, sortDescriptor, null, false);
     }
 
@@ -1978,4 +1977,8 @@ public E findFirstAsync() {
     private long getSourceRowIndexForFirstObject() {
         return this.query.find();
     }
+
+    private SchemaConnector getSchemaConnector() {
+        return new SchemaConnector(realm.getSchema());
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index 6eae995442..82c7e62893 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -17,7 +17,9 @@
 package io.realm;
 
 
+import android.annotation.SuppressLint;
 import android.os.Looper;
+import android.util.Log;
 
 import io.realm.internal.CheckedRow;
 import io.realm.internal.Collection;
@@ -56,22 +58,26 @@
  * @see Realm#executeTransaction(Realm.Transaction)
  */
 public class RealmResults<E extends RealmModel> extends OrderedRealmCollectionImpl<E> {
-    static <T extends RealmModel> RealmResults<T> createBacklinkResults(Realm realm, UncheckedRow row, Class<T> srcTableType, String srcFieldName) {
+
+    // Called from Realm Proxy classes
+    @SuppressLint("unused")
+    static <T extends RealmModel> RealmResults<T> createBacklinkResults(BaseRealm realm, Row row, Class<T> srcTableType, String srcFieldName) {
+        UncheckedRow uncheckedRow = (UncheckedRow) row;
         Table srcTable = realm.getSchema().getTable(srcTableType);
-        return new RealmResults<T>(
+        return new RealmResults<>(
                 realm,
-                Collection.createBacklinksCollection(realm.sharedRealm, row, srcTable, srcFieldName),
+                Collection.createBacklinksCollection(realm.sharedRealm, uncheckedRow, srcTable, srcFieldName),
                 srcTableType);
     }
 
-    static RealmResults<DynamicRealmObject> createBacklinkResults(DynamicRealm realm, CheckedRow row, Table srcTable, String srcFieldName) {
+    // Abandon typing information, all ye who enter here
+    static RealmResults<DynamicRealmObject> createDynamicBacklinkResults(DynamicRealm realm, CheckedRow row, Table srcTable, String srcFieldName) {
         return new RealmResults<>(
                 realm,
                 Collection.createBacklinksCollection(realm.sharedRealm, row, srcTable, srcFieldName),
-                Table.tableNameToClassName(srcTable.getName()));
+                Table.getClassNameForTable(srcTable.getName()));
     }
 
-
     RealmResults(BaseRealm realm, Collection collection, Class<E> clazz) {
         super(realm, collection, clazz);
     }
@@ -255,7 +261,7 @@ public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmResul
      */
     @Deprecated
     public RealmResults<E> distinct(String fieldName) {
-        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(collection.getTable(), fieldName);
+        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(new SchemaConnector(realm.getSchema()), collection.getTable(), fieldName);
         Collection distinctCollection = collection.distinct(distinctDescriptor);
         return createLoadedResults(distinctCollection);
     }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index 0968433c78..f23f9a2f4c 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -21,7 +21,6 @@
 
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Table;
 
 
@@ -89,13 +88,32 @@
      */
     public abstract boolean contains(String className);
 
+    abstract Table getTable(Class<? extends RealmModel> clazz);
+
+    abstract Table getTable(String className);
+
+    abstract RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz);
+
+    abstract RealmObjectSchema getSchemaForClass(String className);
+
+    /**
+     * Set the column index cache for this schema.
+     *
+     * @param columnIndices the column index cache
+     */
     final void setInitialColumnIndices(ColumnIndices columnIndices) {
         if (this.columnIndices != null) {
             throw new IllegalStateException("An instance of ColumnIndices is already set.");
         }
-        this.columnIndices = columnIndices.clone();
+        this.columnIndices = new ColumnIndices(columnIndices, true);
     }
 
+    /**
+     * Set the column index cache for this schema.
+     *
+     * @param version the schema version
+     * @param columnInfoMap the column info map
+     */
     final void setInitialColumnIndices(long version, Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap) {
         if (this.columnIndices != null) {
             throw new IllegalStateException("An instance of ColumnIndices is already set.");
@@ -105,49 +123,54 @@ final void setInitialColumnIndices(long version, Map<Class<? extends RealmModel>
 
     /**
      * Updates all {@link ColumnInfo} elements in {@code columnIndices}.
-     *
      * <p>
      * The ColumnInfo elements are shared between all {@link RealmObject}s created by the Realm instance
      * which owns this RealmSchema. Updating them also means updating indices information in those {@link RealmObject}s.
      *
      * @param schemaVersion new schema version.
-     * @param mediator mediator for the Realm.
      */
-    void updateColumnIndices(ColumnIndices schemaVersion, RealmProxyMediator mediator) {
-        columnIndices.copyFrom(schemaVersion, mediator);
+    void updateColumnIndices(ColumnIndices schemaVersion) {
+        columnIndices.copyFrom(schemaVersion);
     }
 
-    final ColumnIndices cloneColumnIndices() {
-        checkIndices();
-        return columnIndices.clone();
+    final boolean isProxyClass(Class<? extends RealmModel> modelClass, Class<? extends RealmModel> testee) {
+        return modelClass.equals(testee);
     }
 
-    final ColumnInfo getColumnInfo(Class<? extends RealmModel> clazz) {
+    /**
+     * Sometimes you need ColumnIndicies that can be passed between threads.
+     * Setting the mutable flag false creates an instance that is effectively final.
+     *
+     * @return a new, thread-safe copy of this Schema's ColumnIndices.
+     * @see ColumnIndices for the effectively final contract.
+     */
+    final ColumnIndices getImmutableColumnIndicies() {
         checkIndices();
-        return columnIndices.getColumnInfo(clazz);
+        return new ColumnIndices(columnIndices, false);
+    }
+
+    final boolean haveColumnInfo() {
+        return columnIndices != null;
     }
 
     final long getSchemaVersion() {
         checkIndices();
-        return this.columnIndices.getSchemaVersion();
+        return columnIndices.getSchemaVersion();
     }
 
-    final boolean isProxyClass(Class<? extends RealmModel> modelClass, Class<? extends RealmModel> testee) {
-        return modelClass.equals(testee);
+    final ColumnInfo getColumnInfo(Class<? extends RealmModel> clazz) {
+        checkIndices();
+        return columnIndices.getColumnInfo(clazz);
     }
 
-    static String getSchemaForTable(Table table) {
-        return table.getName().substring(Table.TABLE_PREFIX.length());
+    protected final ColumnInfo getColumnInfo(String className) {
+        checkIndices();
+        return columnIndices.getColumnInfo(className);
     }
 
     private void checkIndices() {
-        if (this.columnIndices == null) {
+        if (!haveColumnInfo()) {
             throw new IllegalStateException("Attempt to use column index before set.");
         }
     }
-
-    abstract Table getTable(Class<? extends RealmModel> clazz);
-    abstract Table getTable(String className);
-    abstract RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz);
-    abstract RealmObjectSchema getSchemaForClass(String className);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/SchemaConnector.java b/realm/realm-library/src/main/java/io/realm/SchemaConnector.java
new file mode 100644
index 0000000000..5a695e474c
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/SchemaConnector.java
@@ -0,0 +1,55 @@
+package io.realm;
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.fields.FieldDescriptor;
+
+
+/**
+ * This is a proxy, whose sole reason for existence, is to make package protected
+ * methods on Schema, visible outside the io.realm package.
+ *
+ * The class is in the package, so it has access to package protected methods.
+ * The class is <b>not</b> outside the package.
+ * The class implements one or more interfaces visible to package-external clients, that need them.
+ *
+ * I suggest creating instances of this through a factory method in the service class.
+ * That will make it easy to lazily instantiate a singleton should that become advisable.
+ */
+class SchemaConnector implements FieldDescriptor.SchemaProxy {
+    private final RealmSchema schema;
+
+    public SchemaConnector(RealmSchema schema) {
+        this.schema = schema;
+    }
+
+    @Override
+    public boolean hasCache() {
+        return schema.haveColumnInfo();
+    }
+
+    @Override
+    public ColumnInfo getColumnInfo(String tableName) {
+        return schema.getColumnInfo(tableName);
+    }
+
+    @Override
+    public long getNativeTablePtr(String targetTable) {
+        return schema.getTable(targetTable).getNativePtr();
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java
index 3591817aed..e09cc80a7d 100644
--- a/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java
@@ -16,7 +16,6 @@
 
 package io.realm;
 
-import java.util.Collection;
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
@@ -25,7 +24,7 @@
 import java.util.Set;
 
 import io.realm.annotations.Required;
-import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.ColumnInfo;
 import io.realm.internal.Table;
 
 
@@ -65,25 +64,31 @@
     }
 
     private final BaseRealm realm;
-    private final Map<String, Long> columnIndices;
+    private final ColumnInfo columnInfo;
     private final Table table;
 
+    /**
+     * Creates a dynamic schema object for a given Realm class.
+     *
+     * @param realm Realm holding the objects.
+     * @param table table representation of the Realm class
+     */
+    StandardRealmObjectSchema(BaseRealm realm, StandardRealmSchema schema, Table table) {
+        this(realm, schema, table, new StandardRealmObjectSchema.DynamicColumnIndices(table));
+    }
+
     /**
      * Creates a schema object for a given Realm class.
      *
      * @param realm Realm holding the objects.
      * @param table table representation of the Realm class
-     * @param columnIndices mapping between field names and column indexes for the given table
+     * @param columnInfo mapping between field names and column indexes for the given table
      */
-    StandardRealmObjectSchema(BaseRealm realm, Table table, Map<String, Long> columnIndices) {
+    StandardRealmObjectSchema(BaseRealm realm, StandardRealmSchema schema, Table table, ColumnInfo columnInfo) {
+        super(schema);
         this.realm = realm;
         this.table = table;
-        this.columnIndices = columnIndices;
-    }
-
-    @Override
-    Table getTable() {
-        return table;
+        this.columnInfo = columnInfo;
     }
 
     /**
@@ -104,7 +109,7 @@ public void close() { }
      */
     @Override
     public String getClassName() {
-        return table.getName().substring(Table.TABLE_PREFIX.length());
+        return table.getClassName();
     }
 
     /**
@@ -120,7 +125,7 @@ public String getClassName() {
     public StandardRealmObjectSchema setClassName(String className) {
         realm.checkNotInSync(); // renaming a table is not permitted
         checkEmpty(className);
-        String internalTableName = Table.TABLE_PREFIX + className;
+        String internalTableName = Table.getTableNameForClass(className);
         if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
             throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: \'" + className + "\' (" + Integer.toString(className.length()) + ")");
         }
@@ -205,7 +210,7 @@ public StandardRealmObjectSchema addField(String fieldName, Class<?> fieldType,
     public StandardRealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
         checkLegalName(fieldName);
         checkFieldNameIsAvailable(fieldName);
-        table.addColumnLink(RealmFieldType.OBJECT, fieldName, realm.sharedRealm.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
+        table.addColumnLink(RealmFieldType.OBJECT, fieldName, realm.sharedRealm.getTable(Table.getTableNameForClass(objectSchema.getClassName())));
         return this;
     }
 
@@ -221,7 +226,7 @@ public StandardRealmObjectSchema addRealmObjectField(String fieldName, RealmObje
     public StandardRealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
         checkLegalName(fieldName);
         checkFieldNameIsAvailable(fieldName);
-        table.addColumnLink(RealmFieldType.LIST, fieldName, realm.sharedRealm.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
+        table.addColumnLink(RealmFieldType.LIST, fieldName, realm.sharedRealm.getTable(Table.getTableNameForClass(objectSchema.getClassName())));
         return this;
     }
 
@@ -550,6 +555,11 @@ public RealmFieldType getFieldType(String fieldName) {
         return table.getColumnType(columnIndex);
     }
 
+    @Override
+    Table getTable() {
+        return table;
+    }
+
     @Override
     StandardRealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
         long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);
@@ -566,86 +576,10 @@ StandardRealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchem
         table.addColumnLink(
                 type,
                 name,
-                realm.getSharedRealm().getTable(StandardRealmSchema.TABLE_PREFIX + linkedTo.getClassName()));
+                realm.getSharedRealm().getTable(Table.getTableNameForClass(linkedTo.getClassName())));
         return this;
     }
 
-    /**
-     * Returns the column indices for the given field name. If a linked field is defined, the column index for
-     * each field is returned.
-     *
-     * @param fieldDescription fieldName or link path to a field name.
-     * @param validColumnTypes valid field type for the last field in a linked field
-     * @return list of column indices.
-     */
-    // TODO: consider another caching strategy so linked classes are included in the cache.
-    @Override
-    long[] getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
-        if (fieldDescription == null || fieldDescription.equals("")) {
-            throw new IllegalArgumentException("Invalid query: field name is empty");
-        }
-        if (fieldDescription.endsWith(".")) {
-            throw new IllegalArgumentException("Invalid query: field name must not end with a period ('.')");
-        }
-        String[] names = fieldDescription.split("\\.");
-
-        //final RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
-
-        long[] columnIndices = new long[names.length];
-        Table currentTable = table;
-        RealmFieldType columnType;
-        String columnName;
-        String tableName;
-        for (int i = 0; /* loop exits in the middle */ ; i++) {
-            columnName = names[i];
-            if (columnName.length() <= 0) {
-                throw new IllegalArgumentException(String.format(
-                        "Invalid query: empty column name in field '%s'.  " +
-                                "A field name must not begin with, end with, or contain adjacent periods ('.').",
-                                fieldDescription));
-            }
-
-            tableName = getTableName(currentTable);
-            long index = currentTable.getColumnIndex(columnName);
-            if (index < 0) {
-                throw new IllegalArgumentException(
-                        String.format("Invalid query: field '%s' does not exist in table '%s'.",
-                                columnName, tableName));
-            }
-            columnIndices[i] = index;
-
-            columnType = currentTable.getColumnType(index);
-
-            if (i >= names.length - 1) { break; }
-
-            if ((columnType != RealmFieldType.OBJECT) && (columnType != RealmFieldType.LIST)) {
-                throw new IllegalArgumentException(
-                        String.format("Invalid query: field '%s' in table '%s' is of type '%s'.  It must be a LIST or OBJECT type.",
-                                columnName, tableName, columnType.toString()));
-            }
-
-            currentTable = currentTable.getLinkTarget(index);
-        }
-
-        if ((validColumnTypes != null) && (validColumnTypes.length > 0) && !isValidType(columnType, validColumnTypes)) {
-            throw new IllegalArgumentException(
-                    String.format("Invalid query: field '%s' in table '%s' is of invalid type '%s'.",
-                            columnName, tableName, columnType.toString()));
-        }
-
-        return columnIndices;
-    }
-
-    /**
-     * Returns the column index in the underlying table for the given field name.
-     *
-     * @param fieldName field name to find index for.
-     * @return column index or null if it doesn't exists.
-     */
-    Long getFieldIndex(String fieldName) {
-        return columnIndices.get(fieldName);
-    }
-
     /**
      * Returns the column index in the underlying table for the given field name.
      *
@@ -655,15 +589,23 @@ Long getFieldIndex(String fieldName) {
      */
     @Override
     long getAndCheckFieldIndex(String fieldName) {
-        Long index = columnIndices.get(fieldName);
-        if (index == null) {
+        long index = columnInfo.getColumnIndex(fieldName);
+        if (index < 0) {
             throw new IllegalArgumentException("Field does not exist: " + fieldName);
         }
         return index;
     }
 
-    private String getTableName(Table table) {
-        return table.getName().substring(StandardRealmSchema.TABLE_PREFIX.length());
+    /**
+     * Returns the column index in the underlying table for the given field name.
+     * <b>FOR TESTING USE ONLY!</b>
+     *
+     * @param fieldName field name to find index for.
+     * @return column index or -1 if it doesn't exists.
+     */
+    //@VisibleForTesting(otherwise = VisibleForTesting.NONE)
+    long getFieldIndex(String fieldName) {
+        return columnInfo.getColumnIndex(fieldName);
     }
 
     // Invariant: Field was just added. This method is responsible for cleaning up attributes if it fails.
@@ -749,81 +691,54 @@ private void checkEmpty(String str) {
         }
     }
 
-    private boolean isValidType(RealmFieldType columnType, RealmFieldType[] validColumnTypes) {
-        for (int i = 0; i < validColumnTypes.length; i++) {
-            if (validColumnTypes[i] == columnType) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    public static final class DynamicColumnMap implements Map<String, Long> {
+    private static final class DynamicColumnIndices extends ColumnInfo {
         private final Table table;
 
-        DynamicColumnMap(Table table) {
+        DynamicColumnIndices(Table table) {
+            super(null, false);
             this.table = table;
         }
 
         @Override
-        public Long get(Object key) {
-            long ret = table.getColumnIndex((String) key);
-            return ret < 0 ? null : ret;
+        public long getColumnIndex(String columnName) {
+            return table.getColumnIndex(columnName);
         }
 
         @Override
-        public void clear() {
-            throw new UnsupportedOperationException();
+        public RealmFieldType getColumnType(String columnName) {
+            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getColumnType'");
         }
 
         @Override
-        public boolean containsKey(Object key) {
-            throw new UnsupportedOperationException();
+        public String getLinkedTable(String columnName) {
+            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getLinkedTable'");
         }
 
         @Override
-        public boolean containsValue(Object value) {
-            throw new UnsupportedOperationException();
+        public void copyFrom(ColumnInfo src) {
+            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
         }
 
         @Override
-        public Set<Entry<String, Long>> entrySet() {
-            throw new UnsupportedOperationException();
+        protected ColumnInfo copy(boolean immutable) {
+            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
         }
 
-        @Override
-        public boolean isEmpty() {
-            throw new UnsupportedOperationException();
-        }
 
         @Override
-        public Set<String> keySet() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Long put(String key, Long value) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public void putAll(Map<? extends String, ? extends Long> map) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Long remove(Object key) {
-            throw new UnsupportedOperationException();
+        protected void copy(ColumnInfo src, ColumnInfo dst) {
+            throw new UnsupportedOperationException("DynamicColumnIndices cannot copy");
         }
+    }
 
-        @Override
-        public int size() {
-            throw new UnsupportedOperationException();
-        }
+    // Tuple containing data about each supported Java type.
+    private static final class FieldMetaData {
+        final RealmFieldType realmType;
+        final boolean defaultNullable;
 
-        @Override
-        public Collection<Long> values() {
-            throw new UnsupportedOperationException();
+        FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
+            this.realmType = realmType;
+            this.defaultNullable = defaultNullable;
         }
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java b/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
index 280309bb0d..63bee2608c 100644
--- a/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
@@ -34,9 +34,7 @@
  * @see io.realm.RealmMigration
  */
 class StandardRealmSchema extends RealmSchema {
-
-    static final String TABLE_PREFIX = Table.TABLE_PREFIX;
-    static final String EMPTY_STRING_MSG = "Null or empty class names are not allowed";
+    public static final String EMPTY_STRING_MSG = "Null or empty class names are not allowed";
 
     // Caches Dynamic Class objects given as Strings to Realm Tables
     private final Map<String, Table> dynamicClassToTable = new HashMap<>();
@@ -69,12 +67,10 @@ public void close() { }
     public RealmObjectSchema get(String className) {
         checkEmpty(className, EMPTY_STRING_MSG);
 
-        String internalClassName = TABLE_PREFIX + className;
+        String internalClassName = Table.getTableNameForClass(className);
         if (!realm.getSharedRealm().hasTable(internalClassName)) { return null; }
-
         Table table = realm.getSharedRealm().getTable(internalClassName);
-        StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
-        return new StandardRealmObjectSchema(realm, table, columnIndices);
+        return new StandardRealmObjectSchema(realm, this, table);
     }
 
     /**
@@ -91,9 +87,7 @@ public RealmObjectSchema get(String className) {
             if (!Table.isModelTable(tableName)) {
                 continue;
             }
-            Table table = realm.getSharedRealm().getTable(tableName);
-            StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
-            schemas.add(new StandardRealmObjectSchema(realm, table, columnIndices));
+            schemas.add(new StandardRealmObjectSchema(realm, this, realm.getSharedRealm().getTable(tableName)));
         }
         return schemas;
     }
@@ -109,16 +103,14 @@ public RealmObjectSchema create(String className) {
         // Adding a class is always permitted.
         checkEmpty(className, EMPTY_STRING_MSG);
 
-        String internalTableName = TABLE_PREFIX + className;
+        String internalTableName = Table.getTableNameForClass(className);
         if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
             throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: " + className.length());
         }
         if (realm.getSharedRealm().hasTable(internalTableName)) {
             throw new IllegalArgumentException("Class already exists: " + className);
         }
-        Table table = realm.getSharedRealm().getTable(internalTableName);
-        StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
-        return new StandardRealmObjectSchema(realm, table, columnIndices);
+        return new StandardRealmObjectSchema(realm, this, realm.getSharedRealm().getTable(internalTableName));
     }
 
     /**
@@ -129,7 +121,7 @@ public RealmObjectSchema create(String className) {
      */
     @Override
     public boolean contains(String className) {
-        return realm.getSharedRealm().hasTable(Table.TABLE_PREFIX + className);
+        return realm.getSharedRealm().hasTable(Table.getTableNameForClass(className));
     }
 
     /**
@@ -142,7 +134,7 @@ public boolean contains(String className) {
     public void remove(String className) {
         realm.checkNotInSync(); // Destructive modifications are not permitted.
         checkEmpty(className, EMPTY_STRING_MSG);
-        String internalTableName = TABLE_PREFIX + className;
+        String internalTableName = Table.getTableNameForClass(className);
         checkHasTable(className, "Cannot remove class because it is not in this Realm: " + className);
         Table table = getTable(className);
         if (table.hasPrimaryKey()) {
@@ -163,8 +155,8 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
         realm.checkNotInSync(); // Destructive modifications are not permitted.
         checkEmpty(oldClassName, "Class names cannot be empty or null");
         checkEmpty(newClassName, "Class names cannot be empty or null");
-        String oldInternalName = TABLE_PREFIX + oldClassName;
-        String newInternalName = TABLE_PREFIX + newClassName;
+        String oldInternalName = Table.getTableNameForClass(oldClassName);
+        String newInternalName = Table.getTableNameForClass(newClassName);
         checkHasTable(oldClassName, "Cannot rename class because it doesn't exist in this Realm: " + oldClassName);
         if (realm.getSharedRealm().hasTable(newInternalName)) {
             throw new IllegalArgumentException(oldClassName + " cannot be renamed because the new class already exists: " + newClassName);
@@ -186,8 +178,7 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
             table.setPrimaryKey(pkField);
         }
 
-        StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
-        return new StandardRealmObjectSchema(realm, table, columnIndices);
+        return new StandardRealmObjectSchema(realm, this, table);
     }
 
     private void checkEmpty(String str, String error) {
@@ -197,7 +188,7 @@ private void checkEmpty(String str, String error) {
     }
 
     private void checkHasTable(String className, String errorMsg) {
-        String internalTableName = TABLE_PREFIX + className;
+        String internalTableName = Table.getTableNameForClass(className);
         if (!realm.getSharedRealm().hasTable(internalTableName)) {
             throw new IllegalArgumentException(errorMsg);
         }
@@ -205,15 +196,15 @@ private void checkHasTable(String className, String errorMsg) {
 
     @Override
     Table getTable(String className) {
-        className = Table.TABLE_PREFIX + className;
-        Table table = dynamicClassToTable.get(className);
+        String tableName = Table.getTableNameForClass(className);
+        Table table = dynamicClassToTable.get(tableName);
         if (table != null) { return table; }
 
-        if (!realm.getSharedRealm().hasTable(className)) {
+        if (!realm.getSharedRealm().hasTable(tableName)) {
             throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
         }
-        table = realm.getSharedRealm().getTable(className);
-        dynamicClassToTable.put(className, table);
+        table = realm.getSharedRealm().getTable(tableName);
+        dynamicClassToTable.put(tableName, table);
 
         return table;
     }
@@ -252,28 +243,27 @@ StandardRealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
         }
         if (classSchema == null) {
             Table table = getTable(clazz);
-            classSchema = new StandardRealmObjectSchema(realm, table, getColumnInfo(originalClass).getIndicesMap());
+            classSchema = new StandardRealmObjectSchema(realm, this, table, getColumnInfo(originalClass));
             classToSchema.put(originalClass, classSchema);
         }
         if (isProxyClass(originalClass, clazz)) {
             // 'clazz' is the proxy class for 'originalClass'.
             classToSchema.put(clazz, classSchema);
         }
+
         return classSchema;
     }
 
     @Override
     StandardRealmObjectSchema getSchemaForClass(String className) {
-        className = Table.TABLE_PREFIX + className;
-        StandardRealmObjectSchema dynamicSchema = dynamicClassToSchema.get(className);
+        String tableName = Table.getTableNameForClass(className);
+        StandardRealmObjectSchema dynamicSchema = dynamicClassToSchema.get(tableName);
         if (dynamicSchema == null) {
-            if (!realm.getSharedRealm().hasTable(className)) {
+            if (!realm.getSharedRealm().hasTable(tableName)) {
                 throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
             }
-            Table table = realm.getSharedRealm().getTable(className);
-            StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
-            dynamicSchema = new StandardRealmObjectSchema(realm, table, columnIndices);
-            dynamicClassToSchema.put(className, dynamicSchema);
+            dynamicSchema = new StandardRealmObjectSchema(realm, this, realm.getSharedRealm().getTable(tableName));
+            dynamicClassToSchema.put(tableName, dynamicSchema);
         }
         return dynamicSchema;
     }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
index 069e5b0004..78bbdb0f18 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
@@ -24,68 +24,152 @@
 
 /**
  * Utility class used to cache the mapping between object field names and their column indices.
+ * <p>
+ * This class can be mutated, after construction, in two ways:
+ * <ul>
+ * <li>the {@code copyFrom} method</li>
+ * <li>mutating one of the ColumnInfo object to which this instance holds a reference</li>
+ * </ul>
+ * Immutable instances of this class protect against the first possiblity by throwing on calls
+ * to {@code copyFrom}.  {@see ColumnInfo} for its mutability contract.
+ *
+ * There are two, redundant, lookup methods, for schema members: by Class and by String.
+ * Query lookups must be done by the name of the class and use the String-keyed lookup table.
+ * Although it would be possible to use the same table to look up ColumnInfo by Class, the
+ * class lookup is very fast and on a hot path, so we maintain the redundant table.
  */
-public final class ColumnIndices implements Cloneable {
+public final class ColumnIndices {
+    private final Map<Class<? extends RealmModel>, ColumnInfo> classes;
+    private final Map<String, ColumnInfo> classesByName;
+    private final boolean mutable;
     private long schemaVersion;
-    private Map<Class<? extends RealmModel>, ColumnInfo> classes;
 
+    /**
+     * Create a mutable ColumnIndices initialized with the ColumnInfo objects in the passed map.
+     *
+     * @param schemaVersion the schema version
+     * @param classes a map of table classes to their column info
+     * @throws IllegalArgumentException if any of the ColumnInfo object is immutable.
+     */
     public ColumnIndices(long schemaVersion, Map<Class<? extends RealmModel>, ColumnInfo> classes) {
+        this(schemaVersion, new HashMap<>(classes), true);
+        for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classes.entrySet()) {
+            ColumnInfo columnInfo = entry.getValue();
+            if (mutable != columnInfo.isMutable()) {
+                throw new IllegalArgumentException("ColumnInfo mutability does not match ColumnIndices");
+            }
+            this.classesByName.put(entry.getKey().getSimpleName(), entry.getValue());
+        }
+    }
+
+    /**
+     * Create a copy of the passed ColumnIndices with the specified mutablity.
+     *
+     * @param other the ColumnIndices object to copy
+     * @param mutable if false the object is effectively final.
+     */
+    public ColumnIndices(ColumnIndices other, boolean mutable) {
+        this(other.schemaVersion, new HashMap<Class<? extends RealmModel>, ColumnInfo>(other.classes.size()), mutable);
+        for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : other.classes.entrySet()) {
+            ColumnInfo columnInfo = entry.getValue().copy(mutable);
+            this.classes.put(entry.getKey(), columnInfo);
+            this.classesByName.put(entry.getKey().getSimpleName(), columnInfo);
+        }
+    }
+
+    private ColumnIndices(long schemaVersion, Map<Class<? extends RealmModel>, ColumnInfo> classes, boolean mutable) {
         this.schemaVersion = schemaVersion;
         this.classes = classes;
+        this.mutable = mutable;
+        this.classesByName = new HashMap<>(classes.size());
     }
 
+    /**
+     * Get the schema version.
+     *
+     * @return the schema version.
+     */
     public long getSchemaVersion() {
         return schemaVersion;
     }
 
     /**
-     * Returns {@link ColumnInfo} for the given class or {@code null} if no mapping exists.
+     * Returns the {@link ColumnInfo} for the passed class or ({@code null} if there is no such class).
+     *
+     * @param clazz the class for which to get the ColumnInfo.
+     * @return the corresponding {@link ColumnInfo} object, or {@code null} if not found.
      */
     public ColumnInfo getColumnInfo(Class<? extends RealmModel> clazz) {
         return classes.get(clazz);
     }
 
     /**
-     * Returns the column index for a given field on a clazz or {@code -1} if no such field exists.
+     * Returns the {@link ColumnInfo} for the passed class ({@code null} if there is no such class).
+     *
+     * @param className the simple name of the class for which to get the ColumnInfo.
+     * @return the corresponding {@link ColumnInfo} object, or {@code null} if not found.
      */
+    public ColumnInfo getColumnInfo(String className) {
+        return classesByName.get(className);
+    }
+
+    /**
+     * Convenience method to return the column index for a given field on a class
+     * or {@code -1} if no such field exists.
+     *
+     * @param clazz the class to search.
+     * @param fieldName the name of the field whose index is needed.
+     * @return the index in clazz of the field fieldName.
+     * @deprecated Use {@code getColumnInfo().getColumnIndex()} instead.
+     */
+    @Deprecated
     public long getColumnIndex(Class<? extends RealmModel> clazz, String fieldName) {
-        final ColumnInfo columnInfo = classes.get(clazz);
-        if (columnInfo != null) {
-            Long index = columnInfo.getIndicesMap().get(fieldName);
-            return (index != null) ? index : -1;
-        } else {
+        final ColumnInfo columnInfo = getColumnInfo(clazz);
+        if (columnInfo == null) {
             return -1;
         }
+        return columnInfo.getColumnIndex(fieldName);
     }
 
-    @Override
-    public ColumnIndices clone() {
-        try {
-            final ColumnIndices clone = (ColumnIndices) super.clone();
-            clone.classes = duplicateColumnInfoMap();
-            return clone;
-        } catch (CloneNotSupportedException e) {
-            throw new RuntimeException(e);
+    /**
+     * Make this instance contain a (non-strict) subset of the data in the passed ColumnIndices.
+     * The schemaVersion and every ColumnInfo object held by this instance will be updated to be
+     * the same the corresponding data in the passed instance or IllegalStateException will be thrown.
+     * It is allowable for the passed ColumnIndices to contain information this instance does not.
+     * <p>
+     * NOTE: copying does not change this instance's mutablity state.
+     *
+     * @param src the instance to copy.
+     * @throws UnsupportedOperationException if this instance is immutable.
+     * @throws IllegalStateException if this object contains information for a table that the source does not.
+     */
+    public void copyFrom(ColumnIndices src) {
+        if (!mutable) {
+            throw new UnsupportedOperationException("Attempt to modify immutable cache");
         }
-    }
-
-    private Map<Class<? extends RealmModel>, ColumnInfo> duplicateColumnInfoMap() {
-        final Map<Class<? extends RealmModel>, ColumnInfo> copy = new HashMap<Class<? extends RealmModel>, ColumnInfo>();
-        for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classes.entrySet()) {
-            copy.put(entry.getKey(), entry.getValue().clone());
+        for (Map.Entry<String, ColumnInfo> entry : classesByName.entrySet()) {
+            final ColumnInfo otherColumnInfo = src.classesByName.get(entry.getKey());
+            if (otherColumnInfo == null) {
+                throw new IllegalStateException("Failed to copy ColumnIndices cache for class: " + entry.getKey());
+            }
+            entry.getValue().copyFrom(otherColumnInfo);
         }
-        return copy;
+        this.schemaVersion = src.schemaVersion;
     }
 
-    public void copyFrom(ColumnIndices other, RealmProxyMediator mediator) {
-        for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classes.entrySet()) {
-            final ColumnInfo otherColumnInfo = other.getColumnInfo(entry.getKey());
-            if (otherColumnInfo == null) {
-                throw new IllegalStateException("Failed to copy ColumnIndices cache: "
-                        + Table.tableNameToClassName(mediator.getTableName(entry.getKey())));
+    @Override
+    public String toString() {
+        StringBuilder buf = new StringBuilder("ColumnIndices[");
+        buf.append(schemaVersion).append(",");
+        buf.append(mutable).append(",");
+        if (classes != null) {
+            boolean commaNeeded = false;
+            for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classes.entrySet()) {
+                if (commaNeeded) { buf.append(","); }
+                buf.append(entry.getKey().getSimpleName()).append("->").append(entry.getValue());
+                commaNeeded = true;
             }
-            entry.getValue().copyColumnInfoFrom(otherColumnInfo);
         }
-        this.schemaVersion = other.schemaVersion;
+        return buf.append("]").toString();
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
index fe39118f01..c612bb6744 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
@@ -16,60 +16,249 @@
 
 package io.realm.internal;
 
+import java.util.HashMap;
 import java.util.Map;
 
-import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.RealmFieldType;
 
 
-public abstract class ColumnInfo implements Cloneable {
-    private Map<String, Long> indicesMap;
+/**
+ * Objects of this class play two roles:
+ * <ul>
+ * <li>Subclasses are a fast cache of column indices, for proxy object</li>
+ * <li>They cache table (schema) information used by for StandardRealmObjectSchema and StandardRealmSchema</li>
+ * </ul>
+ * The fast cache functionality is implemented in the Proxy classes generated by {@code RealmProxyClassGenerator}.
+ * Be sure to understand what is going on there, before changing things here.
+ * <p>
+ * While the use of the fields in {@code ColumnDetails} is consistent, there are three subtly different cases:
+ * <ul>
+ * <li>If the column type is a simple type, the link table field is empty (0L / NULLPTR)</li>
+ * <li>If the column type is OBJECT or LINK, the link table field is the class name of the OBJECT/LINK type</li>
+ * <li>If the column type is LINKING_OBJECT, the link table field is the class name of the backlink source table
+ * and the column index field is the index of the backlink source field, in the source table</li>
+ * </ul>
+ *
+ * <p>
+ * Some instances of this class must be thread-safe.  The class support effectively-final semantics.
+ * An instance can be mutated, after construction, in four ways:
+ * <ul>
+ * <li>the {@code copyFrom} method</li>
+ * <li>as the dst parameter of the two-argument copy method</li>
+ * <li>using the {@code addColumnDetails} method</li>
+ * <li>using the {@code addBacklinkDetails} method</li>
+ * </ul>
+ * Immutable instances of this class protect against the first possibility by throwing on calls
+ * to {@code copyFrom}.  There are no checks against the other three mutations.  In order to comply
+ * with the effectively-final contract:
+ * <ul>
+ * <li>the methods {@code addColumnDetails} and {@code addBacklinkDetails} must be called
+ * only from within instance constructors</li>
+ * <li>an immutable instance must never be the dst parameter of the two-argument copy method</li>
+ * </ul>
+ */
+public abstract class ColumnInfo {
+
+    // Immutable column information
+    private static final class ColumnDetails {
+        public final long columnIndex;
+        public final RealmFieldType columnType;
+        public final String linkTable;
 
-    protected final long getValidColumnIndex(String realmPath, Table table,
-            String className, String columnName) {
-        final long columnIndex = table.getColumnIndex(columnName);
-        if (columnIndex == -1) {
-            throw new RealmMigrationNeededException(realmPath,
-                    "Field '" + columnName + "' not found for type " + className);
+        ColumnDetails(long columnIndex, RealmFieldType columnType, String srcTable) {
+            this.columnIndex = columnIndex;
+            this.columnType = columnType;
+            this.linkTable = srcTable;
+        }
+
+        @Override
+        public String toString() {
+            StringBuilder buf = new StringBuilder("ColumnDetails[");
+            buf.append(columnIndex);
+            buf.append(", ").append(columnType);
+            buf.append(", ").append(linkTable);
+            return buf.append("]").toString();
         }
-        return columnIndex;
     }
 
+
+    private final Map<String, ColumnDetails> indicesMap;
+    private final boolean mutable;
+
     /**
-     * Returns a map from column name to column index.
+     * Create a new, empty instance
      *
-     * @return a map from column name to column index. Do not modify returned map because it may be
-     * shared among other {@link ColumnInfo} instances.
+     * @param mapSize the expected number of columns in the map.
      */
-    public Map<String, Long> getIndicesMap() {
-        return indicesMap;
+    protected ColumnInfo(int mapSize) {
+        this(mapSize, true);
     }
 
-    protected final void setIndicesMap(Map<String, Long> indicesMap) {
-        this.indicesMap = indicesMap;
+    /**
+     * Create an exact copy of the passed instance.
+     *
+     * @param src the instance to copy
+     * @param mutable false to make this instance effectively final
+     */
+    protected ColumnInfo(ColumnInfo src, boolean mutable) {
+        this((src == null) ? 0 : src.indicesMap.size(), mutable);
+        // ColumnDetails are immutable and may be re-used.
+        if (src != null) {
+            indicesMap.putAll(src.indicesMap);
+        }
+    }
+
+    private ColumnInfo(int mapSize, boolean mutable) {
+        this.indicesMap = new HashMap<>(mapSize);
+        this.mutable = mutable;
     }
 
     /**
-     * Copies the column index value from other {@link ColumnInfo} object.
+     * Get the mutability state of the instance.
      *
-     * @param other the class of {@code other} must be exactly the same as this instance.
-     * It must not be {@code null}.
-     * @throws IllegalArgumentException if {@code other} has different class than this.
+     * @return true if the instance is mutable
      */
-    public abstract void copyColumnInfoFrom(ColumnInfo other);
+    public final boolean isMutable() {
+        return mutable;
+    }
 
     /**
-     * Returns a shallow copy of this instance.
+     * Returns the index, in the described table, for the named column.
      *
-     * @return shallow copy.
+     * @return column index.
+     */
+    public long getColumnIndex(String columnName) {
+        ColumnDetails details = indicesMap.get(columnName);
+        return (details == null) ? -1 : details.columnIndex;
+    }
+
+    /**
+     * Returns the Realm Type, in the described table, of the named column.
+     *
+     * @return column Realm Type.
+     */
+    public RealmFieldType getColumnType(String columnName) {
+        ColumnDetails details = indicesMap.get(columnName);
+        return (details == null) ? RealmFieldType.UNSUPPORTED_TABLE : details.columnType;
+    }
+
+    /**
+     * Returns the table linked in the described table, to the named column.
+     *
+     * @return the class name of the linked table, or null if the column is a primitive type.
+     */
+    public String getLinkedTable(String columnName) {
+        ColumnDetails details = indicesMap.get(columnName);
+        return (details == null) ? null : details.linkTable;
+    }
+
+    /**
+     * Makes this ColumnInfo an exact copy of {@code src}.
+     *
+     * @param src The source for the copy.  This instance will be an exact copy of {@code src} after return.
+     * {@code src} must not be {@code null}.
+     * @throws IllegalArgumentException if {@code other} has different class than this.
      */
+    public void copyFrom(ColumnInfo src) {
+        if (!mutable) {
+            throw new UnsupportedOperationException("Attempt to modify an immutable ColumnInfo");
+        }
+        if (null == src) {
+            throw new NullPointerException("Attempt to copy null ColumnInfo");
+        }
+
+        indicesMap.clear();
+        indicesMap.putAll(src.indicesMap);
+        copy(src, this);
+    }
+
     @Override
-    public ColumnInfo clone() {
-        try {
-            return (ColumnInfo) super.clone();
-        } catch (CloneNotSupportedException e) {
-            throw new RuntimeException(e);
+    public String toString() {
+        StringBuilder buf = new StringBuilder("ColumnInfo[");
+        buf.append(mutable).append(",");
+        if (indicesMap != null) {
+            boolean commaNeeded = false;
+            for (Map.Entry<String, ColumnDetails> entry : indicesMap.entrySet()) {
+                if (commaNeeded) { buf.append(","); }
+                buf.append(entry.getKey()).append("->").append(entry.getValue());
+                commaNeeded = true;
+            }
+        }
+        return buf.append("]").toString();
+    }
+
+    /**
+     * Create a new object that is an exact copy of {@code src}.
+     * This is the generic factory for ColumnInfo objects.
+     * Subclasses are expected to override it with a proxy to a copy constructor.
+     *
+     * @param mutable false to make an immutable copy.
+     */
+    protected abstract ColumnInfo copy(boolean mutable);
+
+    /**
+     * Make {@code dst} into an exact copy of {@code src}.
+     * Intended for use only by subclasses.
+     * NOTE: there is no protection against calling this method with an "immutable" instance as dst!
+     *
+     * @param src The source for the copy
+     * @param dst The destination of the copy.  Will be an exact copy of src after return.
+     */
+    protected abstract void copy(ColumnInfo src, ColumnInfo dst);
+
+    /**
+     * Add a new column to the indexMap.
+     * <p>
+     * <b>For use only in subclass constructors!</b>.
+     * Must be called from within the subclass constructor, to maintain the effectively-final contract.
+     * <p>
+     * No validation done here.  Presuming that all necessary validation takes place in {@code Proxy.validateTable}.
+     *
+     * @param table The table to search for the column.
+     * @param columnName The name of the column whose index is sought.
+     * @param columnType Type RealmType of the column.
+     * @return the index of the column in the table
+     */
+    @SuppressWarnings("unused")
+    protected final long addColumnDetails(Table table, String columnName, RealmFieldType columnType) {
+        long columnIndex = table.getColumnIndex(columnName);
+        if (columnIndex >= 0) {
+            String linkedTableName = ((columnType != RealmFieldType.OBJECT) && (columnType != RealmFieldType.LIST))
+                    ? null
+                    : table.getLinkTarget(columnIndex).getClassName();
+
+            indicesMap.put(columnName, new ColumnDetails(columnIndex, columnType, linkedTableName));
         }
+
+        return columnIndex;
+    }
+
+    /**
+     * Add a new backlink to the indexMap.
+     * <b>For use only by subclasses!</b>.
+     * Must be called from within the subclass constructor, to maintain the effectively-final contract.
+     *
+     * @param realm The shared realm.
+     * @param columnName The name of the backlink column.
+     * @param sourceTableName The name of the backlink source class.
+     * @param sourceColumnName The name of the backlink source field.
+     */
+    @SuppressWarnings("unused")
+    protected final void addBacklinkDetails(SharedRealm realm, String columnName, String sourceTableName, String sourceColumnName) {
+//        Table sourceTable = realm.getTable(Table.getTableNameForClass(sourceTableName));
+//        long columnIndex = sourceTable.getColumnIndex(sourceColumnName);
+//        indicesMap.put(columnName, new ColumnDetails(columnIndex, RealmFieldType.LINKING_OBJECTS, sourceTableName));
     }
 
-    ;
+    /**
+     * Returns the {@link Map} that is the implementation for this object.
+     * <b>FOR TESTING USE ONLY!</b>
+     *
+     * @return the column details map.
+     */
+    @SuppressWarnings("ReturnOfCollectionOrArrayField")
+    //@VisibleForTesting(otherwise = VisibleForTesting.NONE)
+    public Map<String, ColumnDetails> getIndicesMap() {
+        return indicesMap;
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/FieldDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/FieldDescriptor.java
deleted file mode 100644
index 13d815aa42..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/FieldDescriptor.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.internal;
-
-import java.util.Arrays;
-
-import io.realm.RealmFieldType;
-
-
-/**
- * Class describing a single field possible several links away.
- */
-public class FieldDescriptor {
-
-    private long[] columnIndices;
-    private RealmFieldType fieldType;
-    private String fieldName;
-    private boolean searchIndex;
-
-    public FieldDescriptor(Table table, String fieldDescription, boolean allowLink, boolean allowList) {
-        if (fieldDescription == null || fieldDescription.isEmpty()) {
-            throw new IllegalArgumentException("Non-empty field name must be provided");
-        }
-        if (fieldDescription.startsWith(".") || fieldDescription.endsWith(".")) {
-            throw new IllegalArgumentException("Illegal field name. It cannot start or end with a '.': " + fieldDescription);
-        }
-        if (fieldDescription.contains(".")) {
-            // Resolves field description down to last field name
-            String[] names = fieldDescription.split("\\.");
-            long[] columnIndices = new long[names.length];
-            for (int i = 0; i < names.length - 1; i++) {
-                long index = table.getColumnIndex(names[i]);
-                if (index == Table.NO_MATCH) {
-                    throw new IllegalArgumentException(
-                            String.format("Invalid field name: '%s' does not refer to a class.", names[i]));
-                }
-                RealmFieldType type = table.getColumnType(index);
-                if (!allowLink && type == RealmFieldType.OBJECT) {
-                    throw new IllegalArgumentException(
-                            String.format("'RealmObject' field '%s' is not a supported link field here.", names[i]));
-                } else if (!allowList && type == RealmFieldType.LIST) {
-                    throw new IllegalArgumentException(
-                            String.format("'RealmList' field '%s' is not a supported link field here.", names[i]));
-                } else if (type == RealmFieldType.OBJECT || type == RealmFieldType.LIST) {
-                    table = table.getLinkTarget(index);
-                    columnIndices[i] = index;
-                } else {
-                    throw new IllegalArgumentException(
-                            String.format("Invalid field name: '%s' does not refer to a class.", names[i]));
-                }
-            }
-
-            // Check if last field name is a valid field
-            String columnName = names[names.length - 1];
-            long columnIndex = table.getColumnIndex(columnName);
-            columnIndices[names.length - 1] = columnIndex;
-            if (columnIndex == Table.NO_MATCH) {
-                throw new IllegalArgumentException(
-                        String.format("'%s' is not a field name in class '%s'.", columnName, table.getName()));
-            }
-
-            this.fieldType = table.getColumnType(columnIndex);
-            this.fieldName = columnName;
-            this.columnIndices = columnIndices;
-            this.searchIndex = table.hasSearchIndex(columnIndex);
-        } else {
-            long fieldIndex = table.getColumnIndex(fieldDescription);
-            if (fieldIndex == Table.NO_MATCH) {
-                throw new IllegalArgumentException(String.format("Field '%s' does not exist.", fieldDescription));
-            }
-            this.fieldType = table.getColumnType(fieldIndex);
-            this.fieldName = fieldDescription;
-            this.columnIndices = new long[] {fieldIndex};
-            this.searchIndex = table.hasSearchIndex(fieldIndex);
-        }
-    }
-
-    public long[] getColumnIndices() {
-        return Arrays.copyOf(columnIndices, columnIndices.length);
-    }
-
-    public RealmFieldType getFieldType() {
-        return fieldType;
-    }
-
-    public String getFieldName() {
-        return fieldName;
-    }
-
-    public boolean hasSearchIndex() {
-        return searchIndex;
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/NativeContext.java b/realm/realm-library/src/main/java/io/realm/internal/NativeContext.java
index f559678b76..be40d7ac3f 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/NativeContext.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/NativeContext.java
@@ -27,10 +27,10 @@
 // test_destructor_thread_safety.cpp. Explicit call of SharedGroup::close() or Table::detach() is also not thread-safe
 // with respect to destruction of other accessors.
 public class NativeContext {
-    private final static ReferenceQueue<NativeObject> referenceQueue = new ReferenceQueue<NativeObject>();
-    private final static Thread finalizingThread = new Thread(new FinalizerRunnable(referenceQueue));
+    private static final ReferenceQueue<NativeObject> referenceQueue = new ReferenceQueue<NativeObject>();
+    private static final Thread finalizingThread = new Thread(new FinalizerRunnable(referenceQueue));
     // Dummy context which will be used by native objects which's destructors are always thread safe.
-    final static NativeContext dummyContext = new NativeContext();
+    static final NativeContext dummyContext = new NativeContext();
 
     static {
         finalizingThread.setName("RealmFinalizingDaemon");
diff --git a/realm/realm-library/src/main/java/io/realm/internal/NativeObject.java b/realm/realm-library/src/main/java/io/realm/internal/NativeObject.java
index ce326dbf9b..ac8f32d2c4 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/NativeObject.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/NativeObject.java
@@ -21,7 +21,9 @@
  * It specifies the operations common to all such objects.
  * All Java classes wrapping a core class should implement NativeObject.
  */
-interface NativeObject {
+public interface NativeObject {
+    long NULLPTR = 0L;
+
     /**
      * Gets the pointer of a native object.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 70acf9617e..a5aab3136a 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -65,7 +65,7 @@ public static File getTemporaryDirectory() {
         return temporaryDirectory;
     }
 
-    private volatile static File temporaryDirectory;
+    private static volatile File temporaryDirectory;
 
     public enum Durability {
         FULL(0),
@@ -175,12 +175,13 @@ public int hashCode() {
         void onSchemaVersionChanged(long currentVersion);
     }
 
+    private final SchemaVersionListener schemaChangeListener;
     private final RealmConfiguration configuration;
+    private final long nativePtr;
 
-    final private long nativePtr;
-    final NativeContext context;
     private long lastSchemaVersion;
-    private final SchemaVersionListener schemaChangeListener;
+
+    final NativeContext context;
 
     private SharedRealm(long nativeConfigPtr,
             RealmConfiguration configuration,
@@ -342,9 +343,17 @@ public boolean compact() {
     /**
      * Updates the underlying schema based on the schema description.
      * Calling this method must be done from inside a write transaction.
+     * <p>
+     * TODO: This method should not require the caller to get the native pointer.
+     * Instead, the signature should be something like:
+     * public <T extends RealmSchema & NativeObject> </T>void updateSchema(T schema, long version)
+     * ... that is: something that is a schema and that wraps a native object.
+     *
+     * @param schemaNativePtr the pointer to a native schema object.
+     * @param version the target version.
      */
-    public void updateSchema(long schemaNativePointer, long version) {
-        nativeUpdateSchema(nativePtr, schemaNativePointer, version);
+    public void updateSchema(long schemaNativePtr, long version) {
+        nativeUpdateSchema(nativePtr, schemaNativePtr, version);
     }
 
     public void setAutoRefresh(boolean enabled) {
@@ -356,8 +365,19 @@ public boolean isAutoRefresh() {
         return nativeIsAutoRefresh(nativePtr);
     }
 
-    public boolean requiresMigration(long schemaNativePointer) {
-        return nativeRequiresMigration(nativePtr, schemaNativePointer);
+    /**
+     * Determine whether the passed schema needs to be updated.
+     * <p>
+     * TODO: This method should not require the caller to get the native pointer.
+     * Instead, the signature should be something like:
+     * public <T extends RealmSchema & NativeObject> </T>void updateSchema(T schema, long version)
+     * ... that is, something that is a schema and that wraps a native object.
+     *
+     * @param schemaNativePtr the pointer to a native schema object.
+     * @return true if it will be necessary to call {@code updateSchema}
+     */
+    public boolean requiresMigration(long schemaNativePtr) {
+        return nativeRequiresMigration(nativePtr, schemaNativePtr);
     }
 
     @Override
@@ -433,7 +453,7 @@ void invalidateIterators() {
     // calling the Object Store begin_transaction to avoid the problem.
     // Add pending row to the list when it is created. It should be called in the PendingRow constructor.
     void addPendingRow(PendingRow pendingRow) {
-       pendingRows.add(new WeakReference<PendingRow>(pendingRow));
+        pendingRows.add(new WeakReference<PendingRow>(pendingRow));
     }
 
     // Remove pending row from the list. It should be called when pending row's query finished.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
index 3df785ef92..273d3ef411 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
@@ -17,10 +17,13 @@
 package io.realm.internal;
 
 import java.util.Arrays;
-import java.util.List;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
 
 import io.realm.RealmFieldType;
 import io.realm.Sort;
+import io.realm.internal.fields.FieldDescriptor;
 
 
 /**
@@ -30,107 +33,109 @@
  * NOTE: Since the column indices are determined when constructing the object with the given table's status, the indices
  * could be wrong when schema changes. Always create and consume the instance when needed, DON'T store a SortDescriptor
  * and use it whenever the ShareGroup can be in different versions.
+ * <p>
+ * Sort descriptors do not support Linking Objects, either internally or as terminal types.
  */
 @KeepMember
 public class SortDescriptor {
-
-    private final long[][] columnIndices;
-    private final boolean[] ascendings;
-    private final Table table;
-
-    final static List<RealmFieldType> validFieldTypesForSort = Arrays.asList(
+    //@VisibleForTesting
+    final static Set<RealmFieldType> SORT_VALID_FIELD_TYPES = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
             RealmFieldType.BOOLEAN, RealmFieldType.INTEGER, RealmFieldType.FLOAT, RealmFieldType.DOUBLE,
-            RealmFieldType.STRING, RealmFieldType.DATE);
-    final static List<RealmFieldType> validFieldTypesForDistinct = Arrays.asList(
-            RealmFieldType.BOOLEAN, RealmFieldType.INTEGER, RealmFieldType.STRING, RealmFieldType.DATE);
-
-    // Internal use only. For JNI testing.
-    SortDescriptor(Table table, long[] columnIndices) {
-        this(table, new long[][] {columnIndices}, null);
-    }
-
-    private SortDescriptor(Table table, long[][] columnIndices, Sort[] sortOrders) {
-        if (sortOrders != null) {
-            ascendings = new boolean[sortOrders.length];
-            for (int i = 0; i < sortOrders.length; i++) {
-                ascendings[i] = sortOrders[i].getValue();
-            }
-        } else {
-            ascendings = null;
-        }
+            RealmFieldType.STRING, RealmFieldType.DATE)));
 
-        this.columnIndices = columnIndices;
-        this.table = table;
-    }
+    //@VisibleForTesting
+    final static Set<RealmFieldType> DISTINCT_VALID_FIELD_TYPES = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
+            RealmFieldType.BOOLEAN, RealmFieldType.INTEGER, RealmFieldType.STRING, RealmFieldType.DATE)));
 
-    public static SortDescriptor getInstanceForSort(Table table, String fieldDescription, Sort sortOrder) {
-        return getInstanceForSort(table, new String[] {fieldDescription}, new Sort[] {sortOrder});
+    public static SortDescriptor getInstanceForSort(FieldDescriptor.SchemaProxy proxy, Table table, String fieldDescription, Sort sortOrder) {
+        return getInstanceForSort(proxy, table, new String[] {fieldDescription}, new Sort[] {sortOrder});
     }
 
-    public static SortDescriptor getInstanceForSort(Table table, String[] fieldDescriptions, Sort[] sortOrders) {
-        if (fieldDescriptions == null || fieldDescriptions.length == 0) {
-            throw new IllegalArgumentException("You must provide at least one field name.");
-        }
+    public static SortDescriptor getInstanceForSort(FieldDescriptor.SchemaProxy proxy, Table table, String[] fieldDescriptions, Sort[] sortOrders) {
         if (sortOrders == null || sortOrders.length == 0) {
             throw new IllegalArgumentException("You must provide at least one sort order.");
         }
         if (fieldDescriptions.length != sortOrders.length) {
             throw new IllegalArgumentException("Number of fields and sort orders do not match.");
         }
+        return getInstance(proxy, table, fieldDescriptions, sortOrders, FieldDescriptor.OBJECT_LINK_FIELD_TYPE, SORT_VALID_FIELD_TYPES, "Sort is not supported");
+    }
 
-        long[][] columnIndices = new long[fieldDescriptions.length][];
-        for (int i = 0; i < fieldDescriptions.length; i++) {
-            FieldDescriptor descriptor = new FieldDescriptor(table, fieldDescriptions[i], true, false);
-            checkFieldTypeForSort(descriptor, fieldDescriptions[i]);
-            columnIndices[i] = descriptor.getColumnIndices();
-        }
-
-        return new SortDescriptor(table, columnIndices, sortOrders);
+    public static SortDescriptor getInstanceForDistinct(FieldDescriptor.SchemaProxy proxy, Table table, String fieldDescription) {
+        return getInstanceForDistinct(proxy, table, new String[] {fieldDescription});
     }
 
-    public static SortDescriptor getInstanceForDistinct(Table table, String fieldDescription) {
-        return getInstanceForDistinct(table, new String[] {fieldDescription});
+    public static SortDescriptor getInstanceForDistinct(FieldDescriptor.SchemaProxy proxy, Table table, String[] fieldDescriptions) {
+        return getInstance(proxy, table, fieldDescriptions, null, FieldDescriptor.NO_LINK_FIELD_TYPE, DISTINCT_VALID_FIELD_TYPES, "Distinct is not supported");
     }
 
-    public static SortDescriptor getInstanceForDistinct(Table table, String[] fieldDescriptions) {
+    static SortDescriptor getInstance(
+            FieldDescriptor.SchemaProxy proxy,
+            Table table,
+            String[] fieldDescriptions,
+            Sort[] sortOrders,
+            Set<RealmFieldType> legalInternalTypes,
+            Set<RealmFieldType> legalTerminalTypes,
+            String message) {
+
         if (fieldDescriptions == null || fieldDescriptions.length == 0) {
             throw new IllegalArgumentException("You must provide at least one field name.");
         }
 
         long[][] columnIndices = new long[fieldDescriptions.length][];
+
+        // Force aggressive parsing of the FieldDescriptors, so that only valid SortDescriptor objects are created.
         for (int i = 0; i < fieldDescriptions.length; i++) {
-            FieldDescriptor descriptor = new FieldDescriptor(table, fieldDescriptions[i], false, false);
-            checkFieldTypeForDistinct(descriptor, fieldDescriptions[i]);
+            FieldDescriptor descriptor = FieldDescriptor.createFieldDescriptor(proxy, table, fieldDescriptions[i], legalInternalTypes, null);
+            checkFieldType(descriptor, legalTerminalTypes, message, fieldDescriptions[i]);
             columnIndices[i] = descriptor.getColumnIndices();
         }
 
-        return new SortDescriptor(table, columnIndices, null);
+        return new SortDescriptor(table, columnIndices, sortOrders);
+    }
+
+    // Internal use only. For JNI testing.
+    //@VisibleForTesting
+    static SortDescriptor getTestInstance(Table table, long[] columnIndices) {
+        return new SortDescriptor(table, new long[][] {columnIndices}, null);
     }
 
-    private static void checkFieldTypeForSort(FieldDescriptor descriptor, String fieldDescriptions) {
-        if (!validFieldTypesForSort.contains(descriptor.getFieldType())) {
+    // could do this in the field descriptor, but this provides a better error message
+    private static void checkFieldType(FieldDescriptor descriptor, Set<RealmFieldType> legalTerminalTypes, String message, String fieldDescriptions) {
+        if (!legalTerminalTypes.contains(descriptor.getFinalColumnType())) {
             throw new IllegalArgumentException(String.format(
-                    "Sort is not supported on '%s' field '%s' in '%s'.", descriptor.toString(), descriptor.getFieldName(),
-                    fieldDescriptions));
+                    "%s on '%s' field '%s' in '%s'.", message, descriptor.getFinalColumnType(), descriptor.getFinalColumnName(), fieldDescriptions));
         }
     }
 
-    private static void checkFieldTypeForDistinct(FieldDescriptor descriptor, String fieldDescriptions) {
-        if (!validFieldTypesForDistinct.contains(descriptor.getFieldType())) {
-            throw new IllegalArgumentException(String.format(
-                    "Distinct is not supported on '%s' field '%s' in '%s'.",
-                    descriptor.getFieldType().toString(), descriptor.getFieldName(), fieldDescriptions));
+
+    private final Table table;
+    private final long[][] columnIndices;
+    private final boolean[] ascendings;
+
+    private SortDescriptor(Table table, long[][] columnIndices, Sort[] sortOrders) {
+        this.table = table;
+        this.columnIndices = columnIndices;
+        if (sortOrders != null) {
+            ascendings = new boolean[sortOrders.length];
+            for (int i = 0; i < sortOrders.length; i++) {
+                ascendings[i] = sortOrders[i].getValue();
+            }
+        } else {
+            ascendings = null;
         }
     }
 
     // Called by JNI.
     @KeepMember
+    @SuppressWarnings("unused")
     long[][] getColumnIndices() {
         return columnIndices;
     }
 
     // Called by JNI.
     @KeepMember
+    @SuppressWarnings("unused")
     boolean[] getAscendings() {
         return ascendings;
     }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index 67e744ca3e..53bde14879 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -45,12 +45,12 @@
     }
 
     public static final int TABLE_MAX_LENGTH = 56; // Max length of class names without prefix
-    public static final String TABLE_PREFIX = Util.getTablePrefix();
     public static final long INFINITE = -1;
     public static final boolean NULLABLE = true;
     public static final boolean NOT_NULLABLE = false;
     public static final int NO_MATCH = -1;
 
+    private static final String TABLE_PREFIX = Util.getTablePrefix();
     private static final String PRIMARY_KEY_TABLE_NAME = "pk";
     private static final String PRIMARY_KEY_CLASS_COLUMN_NAME = "pk_table";
     private static final long PRIMARY_KEY_CLASS_COLUMN_INDEX = 0;
@@ -58,9 +58,11 @@
     private static final long PRIMARY_KEY_FIELD_COLUMN_INDEX = 1;
     private static final long NO_PRIMARY_KEY = -2;
 
-    private long nativePtr;
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
-    final NativeContext context;
+
+    private final long nativePtr;
+    private final NativeContext context;
+
     private final SharedRealm sharedRealm;
     private long cachedPrimaryKeyColumnIndex = NO_MATCH;
 
@@ -102,8 +104,8 @@ public long getNativeFinalizerPtr() {
         return nativeFinalizerPtr;
     }
 
-    public long getNativeTablePointer() {
-        return nativePtr;
+    public Table getTable() {
+        return this;
     }
 
     /*
@@ -217,13 +219,12 @@ public void renameColumn(long columnIndex, String newName) {
         // Renames a primary key. At this point, renaming the column name should have been fine.
         if (oldPkColumnIndex == columnIndex) {
             try {
-                String className = tableNameToClassName(getName());
                 Table pkTable = getPrimaryKeyTable();
                 if (pkTable == null) {
                     throw new IllegalStateException(
                             "Table is not created from a SharedRealm, primary key is not available");
                 }
-                long pkRowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, className);
+                long pkRowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, getClassName());
                 if (pkRowIndex != NO_MATCH) {
                     nativeSetString(pkTable.nativePtr, PRIMARY_KEY_FIELD_COLUMN_INDEX, pkRowIndex, newName, false);
                 } else {
@@ -483,7 +484,7 @@ protected long add(Object... values) {
                     ") does not match the number of columns in the table (" +
                     String.valueOf(columns) + ").");
         }
-        RealmFieldType colTypes[] = new RealmFieldType[columns];
+        RealmFieldType[] colTypes = new RealmFieldType[columns];
         for (int columnIndex = 0; columnIndex < columns; columnIndex++) {
             Object value = values[columnIndex];
             RealmFieldType colType = getColumnType(columnIndex);
@@ -570,8 +571,7 @@ public long getPrimaryKey() {
                 return NO_PRIMARY_KEY; // Free table = No primary key.
             }
 
-            String className = tableNameToClassName(getName());
-            long rowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, className);
+            long rowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, getClassName());
             if (rowIndex != NO_MATCH) {
                 String pkColumnName = pkTable.getUncheckedRow(rowIndex).getString(PRIMARY_KEY_FIELD_COLUMN_INDEX);
                 cachedPrimaryKeyColumnIndex = getColumnIndex(pkColumnName);
@@ -1013,6 +1013,15 @@ public String getName() {
         return nativeGetName(nativePtr);
     }
 
+    /**
+     * Returns the class name for the table.
+     *
+     * @return Name of the the table or null if it not part of a group.
+     */
+    public String getClassName() {
+        return getClassNameForTable(getName());
+    }
+
     public String toJson() {
         return nativeToJson(nativePtr);
     }
@@ -1084,11 +1093,20 @@ public long getVersion() {
         return nativeVersion(nativePtr);
     }
 
-    public static String tableNameToClassName(String tableName) {
-        if (!tableName.startsWith(Table.TABLE_PREFIX)) {
-            return tableName;
+    public static String getClassNameForTable(String name) {
+        if (name == null) { return null; }
+        if (!name.startsWith(TABLE_PREFIX)) {
+            return name;
+        }
+        return name.substring(TABLE_PREFIX.length());
+    }
+
+    public static String getTableNameForClass(String name) {
+        if (name == null) { return null; }
+        if (name.startsWith(TABLE_PREFIX)) {
+            return name;
         }
-        return tableName.substring(Table.TABLE_PREFIX.length());
+        return TABLE_PREFIX + name;
     }
 
     protected native long createNative();
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
index 8d0be81e47..f29688f891 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
@@ -20,16 +20,21 @@
 
 import io.realm.Case;
 import io.realm.Sort;
+import io.realm.log.RealmLog;
 
 
 public class TableQuery implements NativeObject {
-    protected boolean DEBUG = false;
+    private static final boolean DEBUG = false;
 
-    protected long nativePtr;
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
-    protected final Table table;
+
+    // See documentation in that NativeContext for an explanation of how this is used
+    @SuppressWarnings("unused")
     private final NativeContext context;
 
+    private final Table table;
+    private final long nativePtr;
+
     // All actions (find(), findAll(), sum(), etc.) must call validateQuery() before performing
     // the actual action. The other methods must set queryValidated to false in order to enforce
     // the first action to validate the syntax of the query.
@@ -38,7 +43,7 @@
     // TODO: Can we protect this?
     public TableQuery(NativeContext context, Table table, long nativeQueryPtr) {
         if (DEBUG) {
-            System.err.println("++++++ new TableQuery, ptr= " + nativeQueryPtr);
+            RealmLog.debug("New TableQuery: ptr=%x", nativeQueryPtr);
         }
         this.context = context;
         this.table = table;
@@ -100,38 +105,38 @@ public TableQuery not() {
 
     // Queries for integer values.
 
-    public TableQuery equalTo(long[] columnIndexes, long value) {
-        nativeEqual(nativePtr, columnIndexes, value);
+    public TableQuery equalTo(long[] columnIndexes, long[] tablePtrs, long value) {
+        nativeEqual(nativePtr, columnIndexes, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long[] columnIndex, long value) {
-        nativeNotEqual(nativePtr, columnIndex, value);
+    public TableQuery notEqualTo(long[] columnIndex, long[] tablePtrs, long value) {
+        nativeNotEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThan(long[] columnIndex, long value) {
-        nativeGreater(nativePtr, columnIndex, value);
+    public TableQuery greaterThan(long[] columnIndex, long[] tablePtrs, long value) {
+        nativeGreater(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThanOrEqual(long[] columnIndex, long value) {
-        nativeGreaterEqual(nativePtr, columnIndex, value);
+    public TableQuery greaterThanOrEqual(long[] columnIndex, long[] tablePtrs, long value) {
+        nativeGreaterEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThan(long[] columnIndex, long value) {
-        nativeLess(nativePtr, columnIndex, value);
+    public TableQuery lessThan(long[] columnIndex, long[] tablePtrs, long value) {
+        nativeLess(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThanOrEqual(long[] columnIndex, long value) {
-        nativeLessEqual(nativePtr, columnIndex, value);
+    public TableQuery lessThanOrEqual(long[] columnIndex, long[] tablePtrs, long value) {
+        nativeLessEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
@@ -144,38 +149,38 @@ public TableQuery between(long[] columnIndex, long value1, long value2) {
 
     // Queries for float values.
 
-    public TableQuery equalTo(long[] columnIndex, float value) {
-        nativeEqual(nativePtr, columnIndex, value);
+    public TableQuery equalTo(long[] columnIndex, long[] tablePtrs, float value) {
+        nativeEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long[] columnIndex, float value) {
-        nativeNotEqual(nativePtr, columnIndex, value);
+    public TableQuery notEqualTo(long[] columnIndex, long[] tablePtrs, float value) {
+        nativeNotEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThan(long[] columnIndex, float value) {
-        nativeGreater(nativePtr, columnIndex, value);
+    public TableQuery greaterThan(long[] columnIndex, long[] tablePtrs, float value) {
+        nativeGreater(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThanOrEqual(long[] columnIndex, float value) {
-        nativeGreaterEqual(nativePtr, columnIndex, value);
+    public TableQuery greaterThanOrEqual(long[] columnIndex, long[] tablePtrs, float value) {
+        nativeGreaterEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThan(long[] columnIndex, float value) {
-        nativeLess(nativePtr, columnIndex, value);
+    public TableQuery lessThan(long[] columnIndex, long[] tablePtrs, float value) {
+        nativeLess(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThanOrEqual(long[] columnIndex, float value) {
-        nativeLessEqual(nativePtr, columnIndex, value);
+    public TableQuery lessThanOrEqual(long[] columnIndex, long[] tablePtrs, float value) {
+        nativeLessEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
@@ -188,38 +193,38 @@ public TableQuery between(long[] columnIndex, float value1, float value2) {
 
     // Queries for double values.
 
-    public TableQuery equalTo(long[] columnIndex, double value) {
-        nativeEqual(nativePtr, columnIndex, value);
+    public TableQuery equalTo(long[] columnIndex, long[] tablePtrs, double value) {
+        nativeEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long[] columnIndex, double value) {
-        nativeNotEqual(nativePtr, columnIndex, value);
+    public TableQuery notEqualTo(long[] columnIndex, long[] tablePtrs, double value) {
+        nativeNotEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThan(long[] columnIndex, double value) {
-        nativeGreater(nativePtr, columnIndex, value);
+    public TableQuery greaterThan(long[] columnIndex, long[] tablePtrs, double value) {
+        nativeGreater(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThanOrEqual(long[] columnIndex, double value) {
-        nativeGreaterEqual(nativePtr, columnIndex, value);
+    public TableQuery greaterThanOrEqual(long[] columnIndex, long[] tablePtrs, double value) {
+        nativeGreaterEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThan(long[] columnIndex, double value) {
-        nativeLess(nativePtr, columnIndex, value);
+    public TableQuery lessThan(long[] columnIndex, long[] tablePtrs, double value) {
+        nativeLess(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThanOrEqual(long[] columnIndex, double value) {
-        nativeLessEqual(nativePtr, columnIndex, value);
+    public TableQuery lessThanOrEqual(long[] columnIndex, long[] tablePtrs, double value) {
+        nativeLessEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
@@ -232,8 +237,8 @@ public TableQuery between(long[] columnIndex, double value1, double value2) {
 
     // Query for boolean values.
 
-    public TableQuery equalTo(long[] columnIndex, boolean value) {
-        nativeEqual(nativePtr, columnIndex, value);
+    public TableQuery equalTo(long[] columnIndex, long[] tablePtrs, boolean value) {
+        nativeEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
@@ -242,47 +247,47 @@ public TableQuery equalTo(long[] columnIndex, boolean value) {
 
     private static final String DATE_NULL_ERROR_MESSAGE = "Date value in query criteria must not be null.";
 
-    public TableQuery equalTo(long[] columnIndex, Date value) {
+    public TableQuery equalTo(long[] columnIndex, long[] tablePtrs, Date value) {
         if (value == null) {
-            nativeIsNull(nativePtr, columnIndex);
+            nativeIsNull(nativePtr, columnIndex, tablePtrs);
         } else {
-            nativeEqualTimestamp(nativePtr, columnIndex, value.getTime());
+            nativeEqualTimestamp(nativePtr, columnIndex, tablePtrs, value.getTime());
         }
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long[] columnIndex, Date value) {
+    public TableQuery notEqualTo(long[] columnIndex, long[] tablePtrs, Date value) {
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
-        nativeNotEqualTimestamp(nativePtr, columnIndex, value.getTime());
+        nativeNotEqualTimestamp(nativePtr, columnIndex, tablePtrs, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThan(long[] columnIndex, Date value) {
+    public TableQuery greaterThan(long[] columnIndex, long[] tablePtrs, Date value) {
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
-        nativeGreaterTimestamp(nativePtr, columnIndex, value.getTime());
+        nativeGreaterTimestamp(nativePtr, columnIndex, tablePtrs, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThanOrEqual(long[] columnIndex, Date value) {
+    public TableQuery greaterThanOrEqual(long[] columnIndex, long[] tablePtrs, Date value) {
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
-        nativeGreaterEqualTimestamp(nativePtr, columnIndex, value.getTime());
+        nativeGreaterEqualTimestamp(nativePtr, columnIndex, tablePtrs, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThan(long[] columnIndex, Date value) {
+    public TableQuery lessThan(long[] columnIndex, long[] tablePtrs, Date value) {
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
-        nativeLessTimestamp(nativePtr, columnIndex, value.getTime());
+        nativeLessTimestamp(nativePtr, columnIndex, tablePtrs, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThanOrEqual(long[] columnIndex, Date value) {
+    public TableQuery lessThanOrEqual(long[] columnIndex, long[] tablePtrs, Date value) {
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
-        nativeLessEqualTimestamp(nativePtr, columnIndex, value.getTime());
+        nativeLessEqualTimestamp(nativePtr, columnIndex, tablePtrs, value.getTime());
         queryValidated = false;
         return this;
     }
@@ -298,104 +303,100 @@ public TableQuery between(long[] columnIndex, Date value1, Date value2) {
 
     // Queries for Binary values.
 
-    public TableQuery equalTo(long[] columnIndices, byte[] value) {
-        nativeEqual(nativePtr, columnIndices, value);
+    public TableQuery equalTo(long[] columnIndices, long[] tablePtrs, byte[] value) {
+        nativeEqual(nativePtr, columnIndices, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long[] columnIndices, byte[] value) {
-        nativeNotEqual(nativePtr, columnIndices, value);
+    public TableQuery notEqualTo(long[] columnIndices, long[] tablePtrs, byte[] value) {
+        nativeNotEqual(nativePtr, columnIndices, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    // Query for String values.
-
-    private static final String STRING_NULL_ERROR_MESSAGE = "String value in query criteria must not be null.";
-
     // Equals
-    public TableQuery equalTo(long[] columnIndexes, String value, Case caseSensitive) {
-        nativeEqual(nativePtr, columnIndexes, value, caseSensitive.getValue());
+    public TableQuery equalTo(long[] columnIndexes, long[] tablePtrs, String value, Case caseSensitive) {
+        nativeEqual(nativePtr, columnIndexes, tablePtrs, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery equalTo(long[] columnIndexes, String value) {
-        nativeEqual(nativePtr, columnIndexes, value, true);
+    public TableQuery equalTo(long[] columnIndexes, long[] tablePtrs, String value) {
+        nativeEqual(nativePtr, columnIndexes, tablePtrs, value, true);
         queryValidated = false;
         return this;
     }
 
     // Not Equals
-    public TableQuery notEqualTo(long[] columnIndex, String value, Case caseSensitive) {
-        nativeNotEqual(nativePtr, columnIndex, value, caseSensitive.getValue());
+    public TableQuery notEqualTo(long[] columnIndex, long[] tablePtrs, String value, Case caseSensitive) {
+        nativeNotEqual(nativePtr, columnIndex, tablePtrs, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long[] columnIndex, String value) {
-        nativeNotEqual(nativePtr, columnIndex, value, true);
+    public TableQuery notEqualTo(long[] columnIndex, long[] tablePtrs, String value) {
+        nativeNotEqual(nativePtr, columnIndex, tablePtrs, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery beginsWith(long[] columnIndices, String value, Case caseSensitive) {
-        nativeBeginsWith(nativePtr, columnIndices, value, caseSensitive.getValue());
+    public TableQuery beginsWith(long[] columnIndices, long[] tablePtrs, String value, Case caseSensitive) {
+        nativeBeginsWith(nativePtr, columnIndices, tablePtrs, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery beginsWith(long[] columnIndices, String value) {
-        nativeBeginsWith(nativePtr, columnIndices, value, true);
+    public TableQuery beginsWith(long[] columnIndices, long[] tablePtrs, String value) {
+        nativeBeginsWith(nativePtr, columnIndices, tablePtrs, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery endsWith(long[] columnIndices, String value, Case caseSensitive) {
-        nativeEndsWith(nativePtr, columnIndices, value, caseSensitive.getValue());
+    public TableQuery endsWith(long[] columnIndices, long[] tablePtrs, String value, Case caseSensitive) {
+        nativeEndsWith(nativePtr, columnIndices, tablePtrs, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery endsWith(long[] columnIndices, String value) {
-        nativeEndsWith(nativePtr, columnIndices, value, true);
+    public TableQuery endsWith(long[] columnIndices, long[] tablePtrs, String value) {
+        nativeEndsWith(nativePtr, columnIndices, tablePtrs, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery like(long[] columnIndices, String value, Case caseSensitive) {
-        nativeLike(nativePtr, columnIndices, value, caseSensitive.getValue());
+    public TableQuery like(long[] columnIndices, long[] tablePtrs, String value, Case caseSensitive) {
+        nativeLike(nativePtr, columnIndices, tablePtrs, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery like(long[] columnIndices, String value) {
-        nativeLike(nativePtr, columnIndices, value, true);
+    public TableQuery like(long[] columnIndices, long[] tablePtrs, String value) {
+        nativeLike(nativePtr, columnIndices, tablePtrs, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery contains(long[] columnIndices, String value, Case caseSensitive) {
-        nativeContains(nativePtr, columnIndices, value, caseSensitive.getValue());
+    public TableQuery contains(long[] columnIndices, long[] tablePtrs, String value, Case caseSensitive) {
+        nativeContains(nativePtr, columnIndices, tablePtrs, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery contains(long[] columnIndices, String value) {
-        nativeContains(nativePtr, columnIndices, value, true);
+    public TableQuery contains(long[] columnIndices, long[] tablePtrs, String value) {
+        nativeContains(nativePtr, columnIndices, tablePtrs, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery isEmpty(long[] columnIndices) {
-        nativeIsEmpty(nativePtr, columnIndices);
+    public TableQuery isEmpty(long[] columnIndices, long[] tablePtrs) {
+        nativeIsEmpty(nativePtr, columnIndices, tablePtrs);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery isNotEmpty(long[] columnIndices) {
-        return not().isEmpty(columnIndices);
+    public TableQuery isNotEmpty(long[] columnIndices, long[] tablePtrs) {
+        return not().isEmpty(columnIndices, tablePtrs);
     }
 
     // Searching methods.
@@ -604,14 +605,14 @@ public Date minimumDate(long columnIndex) {
     }
 
     // isNull and isNotNull
-    public TableQuery isNull(long[] columnIndices) {
-        nativeIsNull(nativePtr, columnIndices);
+    public TableQuery isNull(long[] columnIndices, long[] tablePtrs) {
+        nativeIsNull(nativePtr, columnIndices, tablePtrs);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery isNotNull(long[] columnIndices) {
-        nativeIsNotNull(nativePtr, columnIndices);
+    public TableQuery isNotNull(long[] columnIndices, long[] tablePtrs) {
+        nativeIsNotNull(nativePtr, columnIndices, tablePtrs);
         queryValidated = false;
         return this;
     }
@@ -660,81 +661,81 @@ private void throwImmutable() {
 
     private native void nativeNot(long nativeQueryPtr);
 
-    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
     private native void nativeBetween(long nativeQueryPtr, long[] columnIndex, long value1, long value2);
 
-    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, float value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, float value);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, float value);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, float value);
 
-    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, float value);
+    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, float value);
 
-    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, float value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, float value);
 
-    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, float value);
+    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, float value);
 
-    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, float value);
+    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, float value);
 
     private native void nativeBetween(long nativeQueryPtr, long[] columnIndex, float value1, float value2);
 
-    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, double value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, double value);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, double value);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, double value);
 
-    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, double value);
+    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, double value);
 
-    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, double value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, double value);
 
-    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, double value);
+    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, double value);
 
-    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, double value);
+    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, double value);
 
     private native void nativeBetween(long nativeQueryPtr, long[] columnIndex, double value1, double value2);
 
-    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, boolean value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, boolean value);
 
-    private native void nativeEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeNotEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeNotEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeGreaterTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeGreaterTimestamp(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeGreaterEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeGreaterEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeLessTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeLessTimestamp(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeLessEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeLessEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
     private native void nativeBetweenTimestamp(long nativeQueryPtr, long[] columnIndex, long value1, long value2);
 
-    private native void nativeEqual(long nativeQueryPtr, long[] columnIndices, byte[] value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndices, long[] tablePtrs, byte[] value);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndices, byte[] value);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndices, long[] tablePtrs, byte[] value);
 
-    private native void nativeEqual(long nativeQueryPtr, long[] columnIndexes, String value, boolean caseSensitive);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndexes, long[] tablePtrs, String value, boolean caseSensitive);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, String value, boolean caseSensitive);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, String value, boolean caseSensitive);
 
-    private native void nativeBeginsWith(long nativeQueryPtr, long[] columnIndices, String value, boolean caseSensitive);
+    private native void nativeBeginsWith(long nativeQueryPtr, long[] columnIndices, long[] tablePtrs, String value, boolean caseSensitive);
 
-    private native void nativeEndsWith(long nativeQueryPtr, long[] columnIndices, String value, boolean caseSensitive);
+    private native void nativeEndsWith(long nativeQueryPtr, long[] columnIndices, long[] tablePtrs, String value, boolean caseSensitive);
 
-    private native void nativeLike(long nativeQueryPtr, long[] columnIndices, String value, boolean caseSensitive);
+    private native void nativeLike(long nativeQueryPtr, long[] columnIndices, long[] tablePtrs, String value, boolean caseSensitive);
 
-    private native void nativeContains(long nativeQueryPtr, long[] columnIndices, String value, boolean caseSensitive);
+    private native void nativeContains(long nativeQueryPtr, long[] columnIndices, long[] tablePtrs, String value, boolean caseSensitive);
 
-    private native void nativeIsEmpty(long nativePtr, long[] columnIndices);
+    private native void nativeIsEmpty(long nativePtr, long[] columnIndices, long[] tablePtrs);
 
     private native long nativeFind(long nativeQueryPtr, long fromTableRow);
 
@@ -768,9 +769,9 @@ private void throwImmutable() {
 
     private native Long nativeMinimumTimestamp(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
-    private native void nativeIsNull(long nativePtr, long[] columnIndices);
+    private native void nativeIsNull(long nativePtr, long[] columnIndices, long[] tablePtrs);
 
-    private native void nativeIsNotNull(long nativePtr, long[] columnIndices);
+    private native void nativeIsNotNull(long nativePtr, long[] columnIndice, long[] tablePtr);
 
     private native long nativeCount(long nativeQueryPtr, long start, long end, long limit);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/fields/CachedFieldDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/fields/CachedFieldDescriptor.java
new file mode 100644
index 0000000000..a5b7f6cc70
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/fields/CachedFieldDescriptor.java
@@ -0,0 +1,94 @@
+package io.realm.internal.fields;
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+import java.util.Set;
+
+import io.realm.RealmFieldType;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.NativeObject;
+
+
+/**
+ * Parses the passed field description (@see parseFieldDescription(String) and returns the information
+ * necessary for RealmQuery predicates to select the specified records.
+ * Because the values returned by this method will, immediately, be handed to native code, they are
+ * in coordinated arrays, not a List&lt;ColumnDeatils&gt;
+ * There are two kinds of records.  If return[1][i] is NativeObject.NULLPTR, return[0][i] contains
+ * the column index for the i-th element in the dotted field description path.
+ * If return[1][i] is *not* NativeObject.NULLPTR, it is a pointer to the source table for a backlink
+ * and return[0][i] is the column index of the source column in that table.
+ */
+class CachedFieldDescriptor extends FieldDescriptor {
+    private final SchemaProxy schema;
+    private final String className;
+
+    /**
+     * @param schema the associated Realm Schema
+     * @param className the starting Table: where(Table.class)
+     * @param fieldDescription fieldName or link path to a field name.
+     */
+    CachedFieldDescriptor(SchemaProxy schema, String className, String fieldDescription, Set<RealmFieldType> validInternalColumnTypes, Set<RealmFieldType> validFinalColumnTypes) {
+        super(fieldDescription, validInternalColumnTypes, validFinalColumnTypes);
+        this.className = className;
+        this.schema = schema;
+    }
+
+    @Override
+    protected void compileFieldDescription(List<String> fields) {
+        final int nFields = fields.size();
+        long[] columnIndices = new long[nFields];
+        long[] tableNativePointers = new long[nFields];
+        String currentTable = className;
+
+        ColumnInfo tableInfo;
+        String columnName = null;
+        RealmFieldType columnType = null;
+        long columnIndex;
+        for (int i = 0; i < nFields; i++) {
+            columnName = fields.get(i);
+            if ((columnName == null) || (columnName.length() <= 0)) {
+                throw new IllegalArgumentException(
+                        "Invalid query: Field descriptor contains an empty field.  A field description may not begin with or contain adjacent periods ('.').");
+            }
+
+            tableInfo = schema.getColumnInfo(currentTable);
+            if (tableInfo == null) {
+                throw new IllegalArgumentException(
+                        String.format("Invalid query: table '%s' not found in this schema.", currentTable));
+            }
+
+            columnIndex = tableInfo.getColumnIndex(columnName);
+            if (columnIndex < 0) {
+                throw new IllegalArgumentException(
+                        String.format("Invalid query: field '%s' not found in table '%s'.", columnName, currentTable));
+            }
+
+            columnType = tableInfo.getColumnType(columnName);
+            if (i < nFields - 1) {
+                verifyInternalColumnType(currentTable, columnName, columnType);
+                currentTable = tableInfo.getLinkedTable(columnName);
+            }
+            columnIndices[i] = columnIndex;
+            tableNativePointers[i] = (columnType != RealmFieldType.LINKING_OBJECTS)
+                    ? NativeObject.NULLPTR
+                    : schema.getNativeTablePtr(currentTable);
+        }
+
+        setCompilationResults(className, columnName, columnType, columnIndices, tableNativePointers);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/fields/DynamicFieldDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/fields/DynamicFieldDescriptor.java
new file mode 100644
index 0000000000..55995f9355
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/fields/DynamicFieldDescriptor.java
@@ -0,0 +1,81 @@
+package io.realm.internal.fields;
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+import java.util.Set;
+
+import io.realm.RealmFieldType;
+import io.realm.internal.Table;
+
+
+/**
+ * A field descriptor that uses dynamic table lookup.
+ * Use when cache cannot be trusted...
+ */
+class DynamicFieldDescriptor extends FieldDescriptor {
+    private final Table table;
+
+    /**
+     * Build a dynamic field descriptor for the passed field description string.
+     *
+     * @param table the start table.
+     * @param fieldDescription the field description.
+     * @param validInternalColumnTypes valid types for the last field in the field description.
+     * @param validFinalColumnTypes valid types for the last field in the field description.
+     */
+    DynamicFieldDescriptor(Table table, String fieldDescription, Set<RealmFieldType> validInternalColumnTypes, Set<RealmFieldType> validFinalColumnTypes) {
+        super(fieldDescription, validInternalColumnTypes, validFinalColumnTypes);
+        this.table = table;
+    }
+
+    @Override
+    protected void compileFieldDescription(List<String> fields) {
+        final int nFields = fields.size();
+        long[] columnIndices = new long[nFields];
+        Table currentTable = table;
+
+        long columnIndex;
+        String tableName = null;
+        String columnName = null;
+        RealmFieldType columnType = null;
+        for (int i = 0; i < nFields; i++) {
+            columnName = fields.get(i);
+            if ((columnName == null) || (columnName.length() <= 0)) {
+                throw new IllegalArgumentException(
+                        "Invalid query: Field descriptor contains an empty field.  A field description may not begin with or contain adjacent periods ('.').");
+            }
+
+            tableName = currentTable.getClassName();
+
+            columnIndex = currentTable.getColumnIndex(columnName);
+            if (columnIndex < 0) {
+                throw new IllegalArgumentException(
+                        String.format("Invalid query: field '%s' not found in table '%s'.", columnName, tableName));
+            }
+
+            columnType = currentTable.getColumnType(columnIndex);
+            if (i < nFields - 1) {
+                verifyInternalColumnType(tableName, columnName, columnType);
+                currentTable = currentTable.getLinkTarget(columnIndex);
+            }
+
+            columnIndices[i] = columnIndex;
+        }
+
+        setCompilationResults(tableName, columnName, columnType, columnIndices, new long[nFields]);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java
new file mode 100644
index 0000000000..6a17af9445
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java
@@ -0,0 +1,287 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.fields;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import io.realm.RealmFieldType;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.Table;
+
+
+/**
+ * Class describing a single field, possibly several links away, e.g.:
+ * <ul>
+ * </li> "someField"
+ * </li> "someRealmObjectField.someField"
+ * </li> "someRealmListField.someField"
+ * </li> "someLinkingObjectField.someField"
+ * </li> "someRealmObjectField.someRealmListField.someLinkingObjectField.someField"
+ * </ul>
+ */
+public abstract class FieldDescriptor {
+    public interface SchemaProxy {
+        boolean hasCache();
+
+        ColumnInfo getColumnInfo(String tableName);
+
+        long getNativeTablePtr(String targetTable);
+    }
+
+    public static final Set<RealmFieldType> ALL_LINK_FIELD_TYPES;
+
+    static {
+        Set<RealmFieldType> s = new HashSet<>(3);
+        s.add(RealmFieldType.OBJECT);
+        s.add(RealmFieldType.LIST);
+        s.add(RealmFieldType.LINKING_OBJECTS);
+        ALL_LINK_FIELD_TYPES = Collections.unmodifiableSet(s);
+    }
+
+    public static final Set<RealmFieldType> SIMPLE_LINK_FIELD_TYPES;
+
+    static {
+        Set<RealmFieldType> s = new HashSet<>(2);
+        s.add(RealmFieldType.OBJECT);
+        s.add(RealmFieldType.LIST);
+        SIMPLE_LINK_FIELD_TYPES = Collections.unmodifiableSet(s);
+    }
+
+    public static final Set<RealmFieldType> LIST_LINK_FIELD_TYPE;
+
+    static {
+        Set<RealmFieldType> s = new HashSet<>(1);
+        s.add(RealmFieldType.LIST);
+        LIST_LINK_FIELD_TYPE = Collections.unmodifiableSet(s);
+    }
+
+    public static final Set<RealmFieldType> OBJECT_LINK_FIELD_TYPE;
+
+    static {
+        Set<RealmFieldType> s = new HashSet<>(1);
+        s.add(RealmFieldType.OBJECT);
+        OBJECT_LINK_FIELD_TYPE = Collections.unmodifiableSet(s);
+    }
+
+    public static final Set<RealmFieldType> NO_LINK_FIELD_TYPE = Collections.emptySet();
+
+    /**
+     * Convenience method to allow var-arg specification of valid final column types
+     *
+     * @param schema Proxy to schema info
+     * @param table the start table
+     * @param fieldDescription dot-separated column names
+     * @param validFinalColumnTypes legal types for the last column
+     * @return the Field descriptor
+     */
+    public static FieldDescriptor createStandardFieldDescriptor(
+            SchemaProxy schema,
+            Table table,
+            String fieldDescription,
+            RealmFieldType... validFinalColumnTypes) {
+        return createFieldDescriptor(schema, table, fieldDescription, null, new HashSet<>(Arrays.asList(validFinalColumnTypes)));
+    }
+
+    /**
+     * Factory method for field descriptors.
+     *
+     * @param schema Proxy to schema info
+     * @param table the start table
+     * @param fieldDescription dot-separated column names
+     * @param validFinalColumnTypes legal types for the last column
+     * @return the Field descriptor
+     * <p>
+     * TODO:
+     * I suspect that choosing the parsing strategy based on whether there is a ref to a ColumnIndices
+     * around or not, is bad architecture.  Almost certainly, there should be a schema that has
+     * ColumnIndices and one that does not and the strategies below should belong to the first
+     * and second, respectively.  --gbm
+     */
+    public static FieldDescriptor createFieldDescriptor(
+            SchemaProxy schema,
+            Table table,
+            String fieldDescription,
+            Set<RealmFieldType> validInternalColumnTypes,
+            Set<RealmFieldType> validFinalColumnTypes) {
+        return ((schema == null) || !schema.hasCache())
+                ? new DynamicFieldDescriptor(table, fieldDescription, (null != validInternalColumnTypes) ? validInternalColumnTypes : SIMPLE_LINK_FIELD_TYPES, validFinalColumnTypes)
+                : new CachedFieldDescriptor(schema, table.getClassName(), fieldDescription, (null != validInternalColumnTypes) ? validInternalColumnTypes : ALL_LINK_FIELD_TYPES, validFinalColumnTypes);
+    }
+
+
+    private final List<String> fields;
+    private final Set<RealmFieldType> validInternalColumnTypes;
+    private final Set<RealmFieldType> validFinalColumnTypes;
+
+    private String finalColumnName;
+    private RealmFieldType finalColumnType;
+    private long[] columnIndices;
+    private long[] nativeTablePointers;
+
+    /**
+     * @param fieldDescription fieldName or link path to a field name.
+     * @param validInternalColumnTypes valid internal link types.
+     * @param validFinalColumnTypes valid field types for the last field in a linked field
+     */
+    protected FieldDescriptor(
+            String fieldDescription, Set<RealmFieldType>
+            validInternalColumnTypes,
+            Set<RealmFieldType> validFinalColumnTypes) {
+        this.fields = parseFieldDescription(fieldDescription);
+        int nFields = fields.size();
+        if (nFields <= 0) {
+            throw new IllegalArgumentException("Invalid query: Empty field descriptor");
+        }
+        this.validInternalColumnTypes = validInternalColumnTypes;
+        this.validFinalColumnTypes = validFinalColumnTypes;
+    }
+
+    /**
+     * The number of columnNames in the field description.
+     * The returned number is the size of the array returned by
+     * {@code getColumnIndices} and {@code getNativeTablePointers}
+     *
+     * @return the number of fields.
+     */
+    public final int length() {
+        return fields.size();
+    }
+
+    /**
+     * Return a java array of column indices for the columns named in the description.
+     * If the column at ret[i] is a LinkingObjects column, ret[i] (the column index)
+     * is the index for the <b>source</b> column in the <b>source</b> table.
+     *
+     * The return is an array because it will be, immediately, passed to native code
+     *
+     * @return an array of column indices.
+     */
+    public final long[] getColumnIndices() {
+        compileIfNecessary();
+        return Arrays.copyOf(columnIndices, columnIndices.length);
+    }
+
+    /**
+     * Return a java array of native table pointers.  For most columns the table will be identified by
+     * the type of the column: no further information is needed.  In that case, this array will contain
+     * NativeObject.NULLPTR.  If, however, a column is a LinkingObjects column the <b>source</b> table
+     * cannot be inferred, so the returned array contains the native pointer to it.
+     *
+     * The return is an array because it will be, immediately, passed to native code
+     *
+     * @return an array of native table pointers.
+     */
+    public final long[] getNativeTablePointers() {
+        compileIfNecessary();
+        return Arrays.copyOf(nativeTablePointers, nativeTablePointers.length);
+    }
+
+    /**
+     * Getter for the name of the final column in the descriptor.
+     *
+     * @return the name of the final column
+     */
+    public final String getFinalColumnName() {
+        compileIfNecessary();
+        return finalColumnName;
+    }
+
+    /**
+     * Getter for the type of the final column in the descriptor.
+     *
+     * @return the type of the final column
+     */
+    public final RealmFieldType getFinalColumnType() {
+        compileIfNecessary();
+        return finalColumnType;
+    }
+
+    /**
+     * Subclasses implement this method with a compilation strategy.
+     */
+    protected abstract void compileFieldDescription(List<String> fields);
+
+    /**
+     * Verify that the named link column, in the named table, of the specified type, is one of the legal internal column types.
+     *
+     * @param tableName Name of the table containing the column: used in error messages
+     * @param columnName Name of the column whose type is being tested: used in error messages
+     * @param columnType The type of the column: examined for validity.
+     */
+    protected final void verifyInternalColumnType(String tableName, String columnName, RealmFieldType columnType) {
+        verifyColumnType(tableName, columnName, columnType, validInternalColumnTypes);
+    }
+
+    /**
+     * Store the results of compiling the field description.
+     * Subclasses call this as the last action in
+     *
+     * @param finalClassName the name of the final table in the field description.
+     * @param finalColumnName the name of the final column in the field description.
+     * @param finalColumnType the type of the final column in the field description: MAY NOT BE {@code null}!
+     * @param columnIndices the array of columnIndices.
+     * @param nativeTablePointers the array of table pointers
+     */
+    protected final void setCompilationResults(
+            String finalClassName,
+            String finalColumnName,
+            RealmFieldType finalColumnType,
+            long[] columnIndices,
+            long[] nativeTablePointers) {
+        if ((validFinalColumnTypes != null) && (validFinalColumnTypes.size() > 0)) {
+            verifyColumnType(finalClassName, finalColumnName, finalColumnType, validFinalColumnTypes);
+        }
+        this.finalColumnName = finalColumnName;
+        this.finalColumnType = finalColumnType;
+        this.columnIndices = columnIndices;
+        this.nativeTablePointers = nativeTablePointers;
+    }
+
+    /**
+     * Parse the passed field description into its components.
+     * This must be standard across implementations and is, therefore, implemented in the base class.
+     *
+     * @param fieldDescription a field description.
+     * @return the parse tree: a list of column names
+     */
+    private List<String> parseFieldDescription(String fieldDescription) {
+        if (fieldDescription == null || fieldDescription.equals("")) {
+            throw new IllegalArgumentException("Invalid query: field name is empty");
+        }
+        if (fieldDescription.endsWith(".")) {
+            throw new IllegalArgumentException("Invalid query: field name must not end with a period ('.')");
+        }
+        return Arrays.asList(fieldDescription.split("\\."));
+    }
+
+    private void verifyColumnType(String tableName, String columnName, RealmFieldType columnType, Set<RealmFieldType> validTypes) {
+        if (!validTypes.contains(columnType)) {
+            throw new IllegalArgumentException(String.format(
+                    "Invalid query: field '%s' in table '%s' is of invalid type '%s'.",
+                    columnName, tableName, columnType.toString()));
+        }
+    }
+
+    private void compileIfNecessary() {
+        if (finalColumnType == null) {
+            compileFieldDescription(fields);
+        }
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
index dfd7b31859..b1469a6a1f 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
@@ -49,13 +49,12 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
+
 @RunWith(AndroidJUnit4.class)
 public class ProcessCommitTests extends BaseIntegrationTest {
 
-    // FIXME: Ignore for now. They do still not work. It might be caused by two processes each creating
-    // a Sync Client, but it needs to be investigated.
     @Test
-    @Ignore
+    @Ignore("Failure might be caused by two processes each creating a Sync Client: needs investigation")
     public void expectServerCommit() throws Throwable {
         final Throwable[] exception = new Throwable[1];
         final CountDownLatch testFinished = new CountDownLatch(1);
@@ -109,14 +108,12 @@ public void onChange(RealmResults<ProcessInfo> element) {
         }
     }
 
-    // FIXME: Ignore for now. They do still not work. It might be caused by two processes each creating
-    // a Sync Client, but it needs to be investigated.
-    //TODO send string from service and match
-    //     replicate integration tests from Cocoa
-    //     add gradle task to start the sh script automatically (create pid file, ==> run or kill existing process
-    //     check the requirement for the issue again
+    // TODO:
+    // - send string from service and match replicate integration tests from Cocoa
+    // - add gradle task to start the sh script automatically (create pid file, ==> run or kill existing process)
+    // - check the requirement for the issue again
     @Test
-    @Ignore
+    @Ignore("Failure might be caused by two processes each creating a Sync Client: needs investigation")
     public void expectALot() throws Throwable {
         final Throwable[] exception = new Throwable[1];
         final CountDownLatch testFinished = new CountDownLatch(1);
