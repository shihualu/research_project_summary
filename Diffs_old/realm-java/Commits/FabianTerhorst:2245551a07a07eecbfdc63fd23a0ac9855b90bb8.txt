diff --git a/changelog.txt b/changelog.txt
index ae3091b59e..a77eda2796 100644
--- a/changelog.txt
+++ b/changelog.txt
@@ -17,10 +17,12 @@
  * Fixed a bug when calling System.exit(0), the process might hang.
 
 0.82
+ * Support async queries & transactions.
  * RealmConfiguration.setModules() now accept ignore null values which Realm.getDefaultModule() might return.
+>>>>>>> master
  * Trying to access a deleted Realm object throw throws a proper IllegalStateException.
  * Added in-memory Realm support.
- * Closing realm on another thread different from where it was created now throws an exception.
+ * Closing Realm on another thread different from where it was created now throws an exception.
  * Realm will now throw a RealmError when Realm's underlying storage engine encounters an unrecoverable error.
  * @Index annotation can also be applied to byte/short/int/long/boolean/Date now.
  * BREAKING CHANGE: Fields with annotation @PrimaryKey are indexed automatically now. Older schemas require a migration.
diff --git a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java
index fc8ab339c3..c86fc65170 100644
--- a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java
+++ b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java
@@ -85,7 +85,7 @@ public long execute(Realm realm, long version) {
 
             for (int i = 0; i < personTable.size(); i++) {
                 if (personTable.getString(fullNameIndex, i).equals("JP McDonald")) {
-                    personTable.getUncheckedRow(i).getLinkList(petsIndex).add(petTable.add("Jimbo", "dog"));
+                    personTable.getUncheckedRowByIndex(i).getLinkList(petsIndex).add(petTable.add("Jimbo", "dog"));
                 }
             }
             version++;
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
new file mode 100644
index 0000000000..3657e4638d
--- /dev/null
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.threads;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.BaseAdapter;
+import android.widget.ListView;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import java.util.Collections;
+import java.util.List;
+
+import io.realm.Realm;
+import io.realm.RealmQuery;
+import io.realm.RealmResults;
+import io.realm.examples.threads.model.Dot;
+
+/**
+ * This fragment demonstrates how you can perform asynchronous queries with Realm
+ */
+public class AsyncQueryFragment extends Fragment implements View.OnClickListener {
+    private Realm realm;
+    private DotAdapter mAdapter;
+    private RealmQuery.Request mAsyncRequest;
+    private RealmQuery.Request mAsyncTransaction;
+
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        View rootView = inflater.inflate(R.layout.fragment_async_query, container, false);
+        rootView.findViewById(R.id.start_button).setOnClickListener(this);
+        rootView.findViewById(R.id.translate_button).setOnClickListener(this);
+
+        ListView listView = (ListView) rootView.findViewById(android.R.id.list);
+        mAdapter = new DotAdapter(getActivity());
+        listView.setAdapter(mAdapter);
+        return rootView;
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        // Create Realm instance for the UI thread
+        realm = Realm.getDefaultInstance();
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+        // Remember to close the Realm instance when done with it.
+        cancelRequest();
+        cancelTransaction();
+        realm.close();
+    }
+
+    @Override
+    public void onClick(View view) {
+        switch (view.getId()) {
+            case R.id.start_button: {
+                // cancel any previously running request
+                cancelRequest();
+
+                mAsyncRequest = realm.where(Dot.class)
+                        .between("x", 25, 75)
+                        .between("y", 0, 50)
+                        .findAllSorted(
+                                "x", RealmResults.SORT_ORDER_ASCENDING,
+                                "y", RealmResults.SORT_ORDER_ASCENDING,
+                                new RealmResults.QueryCallback<Dot>() {
+                                    @Override
+                                    public void onSuccess(RealmResults<Dot> results) {
+                                        mAdapter.updateList(results);
+                                    }
+
+                                    @Override
+                                    public void onError(Exception t) {
+                                        t.printStackTrace();
+                                    }
+                                });
+                break;
+            }
+            case R.id.translate_button: {
+                cancelTransaction();
+                // translate all points coordinates using an async transaction
+                mAsyncTransaction = realm.executeTransaction(new Realm.Transaction() {
+                                            @Override
+                                            public void execute(Realm realm) {
+                                                // query for all points
+                                                RealmResults<Dot> dots = realm.where(Dot.class).findAll();
+
+                                                // Iterating backwards to avoid https://github.com/realm/realm-java/issues/640
+                                                for (int i = dots.size()-1; i>=0; i--) {
+                                                    Dot dot = dots.get(i);
+                                                    if (dot.isValid()) {
+                                                        int x = dot.getX();
+                                                        int y = dot.getY();
+                                                        dot.setX(y);
+                                                        dot.setY(x);
+                                                    }
+                                                }
+                                            }
+                                        }, new Realm.Transaction.Callback() {
+                                            @Override
+                                            public void onSuccess() {
+                                                if (isAdded()) {
+                                                    Toast.makeText(getActivity(), "Translation completed", Toast.LENGTH_SHORT).show();
+                                                }
+                                            }
+
+                                            @Override
+                                            public void onError(Throwable e) {
+                                                if (isAdded()) {
+                                                    Toast.makeText(getActivity(), "Error while translating dots", Toast.LENGTH_SHORT).show();
+                                                    e.printStackTrace();
+                                                }
+                                            }
+                                        });
+                break;
+            }
+        }
+    }
+
+    private void cancelRequest() {
+        if (mAsyncRequest != null && !mAsyncRequest.isCancelled()) {
+            mAsyncRequest.cancel();
+            mAsyncRequest = null;
+        }
+    }
+
+    private void cancelTransaction() {
+        if (mAsyncTransaction != null && !mAsyncTransaction.isCancelled()) {
+            mAsyncTransaction.cancel();
+            mAsyncTransaction = null;
+        }
+    }
+
+    private class DotAdapter extends BaseAdapter {
+        private List<Dot> dots = Collections.emptyList();
+        private final LayoutInflater inflater;
+
+        DotAdapter(Context context) {
+            this.inflater = LayoutInflater.from(context);
+        }
+
+        void updateList(List<Dot> dots) {
+            this.dots = dots;
+            notifyDataSetChanged();
+        }
+
+        @Override
+        public int getCount() {
+            return dots.size();
+        }
+
+        @Override
+        public Dot getItem(int i) {
+            return dots.get(i);
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return i;
+        }
+
+        @Override
+        public View getView(int i, View view, ViewGroup viewGroup) {
+            if (view == null) {
+                view = inflater.inflate(android.R.layout.simple_list_item_1, viewGroup, false);
+                ViewHolder viewHolder = new ViewHolder(view);
+                view.setTag(viewHolder);
+            }
+            ViewHolder vh = (ViewHolder) view.getTag();
+            vh.text.setText("[X= " + getItem(i).getX() + " Y= " + getItem(i).getY() + "]");
+
+            return view;
+        }
+
+        private class ViewHolder {
+            TextView text;
+
+            ViewHolder(View view) {
+                text = (TextView) view.findViewById(android.R.id.text1);
+            }
+        }
+    }
+}
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadExampleActivity.java b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadExampleActivity.java
index 6c085cfcdf..775a697504 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadExampleActivity.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadExampleActivity.java
@@ -30,7 +30,6 @@
 
 public class ThreadExampleActivity extends ActionBarActivity implements android.support.v7.app.ActionBar.TabListener {
 
-    private SectionsPagerAdapter pageAdapter;
     private ViewPager viewPager;
 
     @Override
@@ -42,7 +41,7 @@ protected void onCreate(Bundle savedInstanceState) {
         final android.support.v7.app.ActionBar actionBar = getSupportActionBar();
         actionBar.setNavigationMode(android.support.v7.app.ActionBar.NAVIGATION_MODE_TABS);
 
-        pageAdapter = new SectionsPagerAdapter(getSupportFragmentManager());
+        SectionsPagerAdapter pageAdapter = new SectionsPagerAdapter(getSupportFragmentManager());
         viewPager = (ViewPager) findViewById(R.id.pager);
         viewPager.setAdapter(pageAdapter);
 
@@ -87,13 +86,14 @@ public Fragment getItem(int position) {
             switch(position) {
                 case 0: return new ThreadFragment();
                 case 1: return new AsyncTaskFragment();
+                case 2: return new AsyncQueryFragment();
                 default: return null;
             }
         }
 
         @Override
         public int getCount() {
-            return 2;
+            return 3;
         }
 
         @Override
@@ -102,6 +102,7 @@ public CharSequence getPageTitle(int position) {
             switch (position) {
                 case 0: return getString(R.string.title_section1).toUpperCase(l);
                 case 1: return getString(R.string.title_section2).toUpperCase(l);
+                case 2: return getString(R.string.title_section3).toUpperCase(l);
                 default: return null;
             }
         }
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
index ab20e28764..ec3c536f2d 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
@@ -16,7 +16,6 @@
 
 package io.realm.examples.threads;
 
-import android.app.Activity;
 import android.os.Bundle;
 import android.os.SystemClock;
 import android.support.v4.app.Fragment;
@@ -58,28 +57,10 @@ public void onCreate(Bundle savedInstanceState) {
         setHasOptionsMenu(true);
     }
 
-    @Override
-    public void onAttach(Activity activity) {
-        super.onAttach(activity);
-
-        // Create Realm instance for the UI thread
-        realm = Realm.getDefaultInstance();
-    }
-
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
         View rootView = inflater.inflate(R.layout.fragment_thread, container, false);
         dotsView = (DotsView) rootView.findViewById(R.id.dots);
-
-        // Create a RealmQuery on the UI thread and send the results to the custom view. The
-        // RealmResults will automatically be updated whenever the Realm data is changed.
-        // We still need to invalidate the UI to show the changes however. See the RealmChangeListener.
-        //
-        // Note that the query gets updated by rerunning it on the thread it was
-        // created. This can negatively effect frame rates if it is a complicated query or a very
-        // large data set.
-        dotsView.setRealmResults(realm.allObjects(Dot.class));
-
         return rootView;
     }
 
@@ -114,6 +95,22 @@ public boolean onOptionsItemSelected(MenuItem item) {
         }
     }
 
+    @Override
+    public void onStart() {
+        super.onStart();
+        // Create Realm instance for the UI thread
+        realm = Realm.getDefaultInstance();
+
+        // Create a RealmQuery on the UI thread and send the results to the custom view. The
+        // RealmResults will automatically be updated whenever the Realm data is changed.
+        // We still need to invalidate the UI to show the changes however. See the RealmChangeListener.
+        //
+        // Note that the query gets updated by rerunning it on the thread it was
+        // created. This can negatively effect frame rates if it is a complicated query or a very
+        // large data set.
+        dotsView.setRealmResults(realm.allObjects(Dot.class));
+    }
+
     @Override
     public void onResume() {
         super.onResume();
@@ -161,8 +158,8 @@ public void onPause() {
     }
 
     @Override
-    public void onDestroy() {
-        super.onDestroy();
+    public void onStop() {
+        super.onStop();
         // Remember to close the Realm instance when done with it.
         realm.close();
     }
diff --git a/examples/threadExample/src/main/res/layout/fragment_async_query.xml b/examples/threadExample/src/main/res/layout/fragment_async_query.xml
new file mode 100644
index 0000000000..eb87cbd471
--- /dev/null
+++ b/examples/threadExample/src/main/res/layout/fragment_async_query.xml
@@ -0,0 +1,49 @@
+<!--
+  ~ Copyright 2015 Realm Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~ http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+                xmlns:tools="http://schemas.android.com/tools"
+                android:layout_width="match_parent"
+                android:layout_height="match_parent"
+                android:background="@color/fragment_background"
+                android:orientation="vertical"
+                android:paddingBottom="@dimen/activity_vertical_margin"
+                android:paddingLeft="@dimen/activity_horizontal_margin"
+                android:paddingRight="@dimen/activity_horizontal_margin"
+                android:paddingTop="@dimen/activity_vertical_margin"
+                tools:context=".MainActivity$PlaceholderFragment">
+
+    <Button
+        android:id="@+id/start_button"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="@string/query"/>
+
+    <Button
+        android:id="@+id/translate_button"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="@string/translate"/>
+
+    <ListView
+        android:id="@android:id/list"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="16dp">
+    </ListView>
+
+
+</LinearLayout>
diff --git a/examples/threadExample/src/main/res/values/strings.xml b/examples/threadExample/src/main/res/values/strings.xml
index 8c5fcdd4e4..20ca5ca73c 100644
--- a/examples/threadExample/src/main/res/values/strings.xml
+++ b/examples/threadExample/src/main/res/values/strings.xml
@@ -5,7 +5,10 @@
     <string name="action_settings">Settings</string>
     <string name="title_section1">Threads</string>
     <string name="title_section2">AsyncTask</string>
+    <string name="title_section3">Async Query</string>
     <string name="add_dot">Add blue dot</string>
     <string name="clear_dots">Clear dots</string>
+    <string name="query">Query</string>
+    <string name="translate">Translate Dots</string>
 
 </resources>
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index bd1e6c9f01..b990c5f1f2 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -201,7 +201,7 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                 writer.emitStatement("return null");
                 writer.endControlFlow();
                 writer.emitStatement(
-                        "return realm.get(%s.class, row.getLink(%s))",
+                        "return realm.getByIndex(%s.class, row.getLink(%s))",
                         fieldTypeCanonicalName, staticFieldIndexVarName(field));
                 writer.endMethod();
                 writer.emitEmptyLine();
@@ -484,7 +484,7 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                 .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
                     .emitStatement("realmObject = new %s()", Utils.getProxyClassName(className))
                     .emitStatement("realmObject.realm = realm")
-                    .emitStatement("realmObject.row = table.getUncheckedRow(rowIndex)")
+                    .emitStatement("realmObject.row = table.getUncheckedRowByIndex(rowIndex)")
                     .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
                 .nextControlFlow("else")
                     .emitStatement("canUpdate = false")
@@ -744,7 +744,7 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
                         .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
                             .emitStatement("obj = new %s()", Utils.getProxyClassName(className))
                             .emitStatement("obj.realm = realm")
-                            .emitStatement("obj.row = table.getUncheckedRow(rowIndex)")
+                            .emitStatement("obj.row = table.getUncheckedRowByIndex(rowIndex)")
                         .endControlFlow()
                     .endControlFlow()
                 .endControlFlow()
diff --git a/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 69309dc3c1..c9a8957552 100644
--- a/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -143,7 +143,7 @@ public AllTypes getColumnObject() {
         if (row.isNullLink(INDEX_COLUMNOBJECT)) {
             return null;
         }
-        return realm.get(some.test.AllTypes.class, row.getLink(INDEX_COLUMNOBJECT));
+        return realm.getByIndex(some.test.AllTypes.class, row.getLink(INDEX_COLUMNOBJECT));
     }
 
     @Override
@@ -328,7 +328,7 @@ public static AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject jso
                 if (rowIndex != TableOrView.NO_MATCH) {
                     obj = new AllTypesRealmProxy();
                     obj.realm = realm;
-                    obj.row = table.getUncheckedRow(rowIndex);
+                    obj.row = table.getUncheckedRowByIndex(rowIndex);
                 }
             }
         }
@@ -446,7 +446,7 @@ public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update
             if (rowIndex != TableOrView.NO_MATCH) {
                 realmObject = new AllTypesRealmProxy();
                 realmObject.realm = realm;
-                realmObject.row = table.getUncheckedRow(rowIndex);
+                realmObject.row = table.getUncheckedRowByIndex(rowIndex);
                 cache.put(object, (RealmObjectProxy) realmObject);
             } else {
                 canUpdate = false;
diff --git a/realm-jni/build.gradle b/realm-jni/build.gradle
index 3e1827b065..33f3fe4ea4 100644
--- a/realm-jni/build.gradle
+++ b/realm-jni/build.gradle
@@ -1,4 +1,4 @@
-ext.coreVersion = '0.89.9'
+ext.coreVersion = '0.91.0'
 ext.clang = false // gcc is default for the NDK. It also produces smaller binaries
 
 def commonCflags = [ '-std=c++11', '-ffunction-sections', '-fdata-sections', '-flto' ]
diff --git a/realm-jni/src/io_realm_internal_LinkView.cpp b/realm-jni/src/io_realm_internal_LinkView.cpp
index 9fd98b44b9..864ca24f19 100644
--- a/realm-jni/src/io_realm_internal_LinkView.cpp
+++ b/realm-jni/src/io_realm_internal_LinkView.cpp
@@ -158,8 +158,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeWhere
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        LinkView *lv = LV(nativeLinkViewPtr); 
-        Query query = lv->get_target_table().where(lv);
+        LinkView *lv = LV(nativeLinkViewPtr);
+        Query query = lv->get_target_table().where(LinkViewRef(lv));
         TableQuery* queryPtr = new TableQuery(query);
         return reinterpret_cast<jlong>(queryPtr);
     } CATCH_STD()
diff --git a/realm-jni/src/io_realm_internal_SharedGroup.cpp b/realm-jni/src/io_realm_internal_SharedGroup.cpp
index e154ccf95f..65ff91ec90 100644
--- a/realm-jni/src/io_realm_internal_SharedGroup.cpp
+++ b/realm-jni/src/io_realm_internal_SharedGroup.cpp
@@ -19,7 +19,6 @@
 #include "util.hpp"
 
 #include <realm/group_shared.hpp>
-#include <realm/replication.hpp>
 #include <realm/commit_log.hpp>
 
 #include "util.hpp"
@@ -28,8 +27,6 @@
 using namespace std;
 using namespace realm;
 
-#define SG(ptr) reinterpret_cast<SharedGroup*>(ptr)
-
 inline static bool jint_to_durability_level(JNIEnv* env, jint durability, SharedGroup::DurabilityLevel &level) {
     if (durability == 0)
         level = SharedGroup::durability_Full;
@@ -105,9 +102,9 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_createNativeWithImpli
     try {
         KeyBuffer key(env, keyArray);
 #ifdef REALM_ENABLE_ENCRYPTION
-        SharedGroup* db = new SharedGroup(*reinterpret_cast<realm::Replication*>(native_replication_ptr), level, key.data());
+        SharedGroup* db = new SharedGroup(*CH(native_replication_ptr), level, key.data());
 #else
-        SharedGroup* db = new SharedGroup(*reinterpret_cast<realm::Replication*>(native_replication_ptr), level);
+        SharedGroup* db = new SharedGroup(*CH(native_replication_ptr), level);
 #endif
         return reinterpret_cast<jlong>(db);
     }
@@ -126,11 +123,11 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreateReplicati
         file_name = StringData(file_name_tmp);
         KeyBuffer key(env, keyArray);
 #ifdef REALM_ENABLE_ENCRYPTION
-        std::unique_ptr<Replication> repl = makeWriteLogCollector(file_name, false, key.data());
+        std::unique_ptr<ClientHistory> hist = make_client_history(file_name, key.data());
 #else
-        std::unique_ptr<Replication> repl = makeWriteLogCollector(file_name);
+        std::unique_ptr<ClientHistory> hist = make_client_history(file_name);
 #endif
-        return reinterpret_cast<jlong>(repl.release());
+        return reinterpret_cast<jlong>(hist.release());
     }
     CATCH_FILE(file_name)
     CATCH_STD()
@@ -150,21 +147,21 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginImplicit
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceRead
-(JNIEnv *env, jobject, jlong native_ptr)
+(JNIEnv *env, jobject, jlong native_ptr, jlong native_replication_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
-        LangBindHelper::advance_read( *SG(native_ptr) );
+        LangBindHelper::advance_read( *SG(native_ptr), *CH(native_replication_ptr) );
     }
     CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativePromoteToWrite
-  (JNIEnv *env, jobject, jlong native_ptr)
+  (JNIEnv *env, jobject, jlong native_ptr, jlong native_replication_ptr)
 {
     TR_ENTER_PTR(native_ptr) 
     try {
-        LangBindHelper::promote_to_write( *SG(native_ptr) );
+        LangBindHelper::promote_to_write( *SG(native_ptr), *CH(native_replication_ptr) );
     }
     CATCH_STD()
 }
@@ -183,7 +180,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCloseReplication
   (JNIEnv *, jobject, jlong native_replication_ptr)
 {
     TR_ENTER_PTR(native_replication_ptr)
-    delete reinterpret_cast<Replication*>(native_replication_ptr);
+    delete CH(native_replication_ptr);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeClose(
@@ -254,10 +251,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollback(
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollbackAndContinueAsRead(
-    JNIEnv *, jobject, jlong native_ptr)
+    JNIEnv *, jobject, jlong native_ptr, jlong native_replication_ptr)
 {
     TR_ENTER_PTR(native_ptr)
-    LangBindHelper::rollback_and_continue_as_read(*SG(native_ptr));
+    LangBindHelper::rollback_and_continue_as_read(*SG(native_ptr), *CH(native_replication_ptr));
 }
 
 
diff --git a/realm-jni/src/io_realm_internal_SharedGroup.h b/realm-jni/src/io_realm_internal_SharedGroup.h
index 6fd7623fe6..621133ea06 100644
--- a/realm-jni/src/io_realm_internal_SharedGroup.h
+++ b/realm-jni/src/io_realm_internal_SharedGroup.h
@@ -10,7 +10,7 @@ extern "C" {
 /*
  * Class:     io_realm_internal_SharedGroup
  * Method:    createNativeWithImplicitTransactions
- * Signature: (J[B)J
+ * Signature: (JI[B)J
  */
 JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_createNativeWithImplicitTransactions
   (JNIEnv *, jobject, jlong, jint, jbyteArray);
@@ -26,18 +26,18 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreateReplicati
 /*
  * Class:     io_realm_internal_SharedGroup
  * Method:    nativeAdvanceRead
- * Signature: (J)V
+ * Signature: (JJ)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceRead
-  (JNIEnv *, jobject, jlong);
+  (JNIEnv *, jobject, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_SharedGroup
  * Method:    nativePromoteToWrite
- * Signature: (J)V
+ * Signature: (JJ)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativePromoteToWrite
-  (JNIEnv *, jobject, jlong);
+  (JNIEnv *, jobject, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_SharedGroup
@@ -50,10 +50,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCommitAndContinu
 /*
  * Class:     io_realm_internal_SharedGroup
  * Method:    nativeRollbackAndContinueAsRead
- * Signature: (J)V
+ * Signature: (JJ)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollbackAndContinueAsRead
-  (JNIEnv *, jobject, jlong);
+  (JNIEnv *, jobject, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_SharedGroup
diff --git a/realm-jni/src/io_realm_internal_TableQuery.cpp b/realm-jni/src/io_realm_internal_TableQuery.cpp
index 5554e0c8c1..8eb9c63f77 100644
--- a/realm-jni/src/io_realm_internal_TableQuery.cpp
+++ b/realm-jni/src/io_realm_internal_TableQuery.cpp
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#include <realm/group_shared.hpp>
 #include "util.hpp"
 #include "io_realm_internal_TableQuery.h"
 #include "tablequery.hpp"
@@ -864,6 +865,51 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind(
     return -1;
 }
 
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover(
+    JNIEnv* env, jobject, jlong bgSharedGroupPtr, jlong handoverQueryPtr, jlong fromTableRow)
+{
+    try {
+      // cast the pointer
+      SharedGroup::Handover<Query>* hQuery = reinterpret_cast<SharedGroup::Handover<Query>* > (handoverQueryPtr);
+      std::unique_ptr<SharedGroup::Handover<Query> > handoverQuery (hQuery);
+
+      // when opening a Realm, we start implicitly a read transaction
+      // we need to close it before calling begin_read
+      SG(bgSharedGroupPtr)->end_read();
+
+      // set the background Realm to the same version as the caller Realm
+      SG(bgSharedGroupPtr)->begin_read(handoverQuery->version); // throws
+
+      // import the handover query pointer using the background SharedGroup
+      std::unique_ptr<Query> pQuery = SG(bgSharedGroupPtr)->import_from_handover(std::move(handoverQuery));
+      Table* pTable = pQuery->get_table().get();
+
+      if (!QUERY_VALID(env, pQuery.get()))
+           return -1;
+
+       // It's valid to go 1 past the end index
+      if ((fromTableRow < 0) || (S(fromTableRow) > pTable->size())) {
+        // below check will fail with appropriate exception
+        (void) ROW_INDEX_VALID(env, pTable, fromTableRow);
+        return -1;
+      }
+
+      size_t r = pQuery->find( S(fromTableRow) );
+      if (r == not_found) {
+        return -1;
+      } else {
+         // handover the result
+         Row row = (*pTable)[r];
+         std::unique_ptr<SharedGroup::Handover<Row> > handover = SG(bgSharedGroupPtr)->export_for_handover(row);
+         return reinterpret_cast<jlong>(handover.release());
+      }
+
+  } CATCH_STD()
+  return -1;
+
+}
+
+
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlong start, jlong end, jlong limit)
 {
@@ -879,6 +925,179 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll(
     return -1;
 }
 
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllWithHandover
+  (JNIEnv *env, jobject, jlong bgSharedGroupPtr, jlong handoverQueryPtr, jlong start, jlong end, jlong limit)
+  {
+
+          // cast the pointer
+          SharedGroup::Handover<Query>* hQuery = reinterpret_cast<SharedGroup::Handover<Query>* >(handoverQueryPtr);
+          try {
+              std::unique_ptr<SharedGroup::Handover<Query> > handoverQuery (hQuery);
+
+              // when opening a Realm, we start implicitly a read transaction
+              // we need to close it before calling begin_read
+              SG(bgSharedGroupPtr)->end_read();
+
+              // set the background Realm to the same version as the caller Realm
+              SG(bgSharedGroupPtr)->begin_read(handoverQuery->version); // throws
+
+              // import the handover query pointer using the background SharedGroup
+              std::unique_ptr<Query> pQuery = SG(bgSharedGroupPtr)->import_from_handover(std::move(handoverQuery));
+              Table* pTable = pQuery->get_table().get();
+
+              if (!QUERY_VALID(env, pQuery.get()) || !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+                  return -1;
+
+                // run the query
+                TableView* pResultView = new TableView( pQuery->find_all(S(start), S(end), S(limit)) );
+
+                // handover the result
+                std::unique_ptr<SharedGroup::Handover<TableView> > handover = SG(bgSharedGroupPtr)->export_for_handover(*pResultView, MutableSourcePayload::Move);
+
+                return reinterpret_cast<jlong>(handover.release());
+
+          } catch (SharedGroup::BadVersion& e) {
+              delete hQuery;
+              ThrowException(env, BadVersion, " begin_read failed");
+          } CATCH_STD()
+      return -1;
+  }
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllSortedWithHandover
+  (JNIEnv *env, jobject, jlong bgSharedGroupPtr, jlong handoverQueryPtr, jlong start, jlong end, jlong limit, jlong columnIndex, jboolean ascending)
+  {
+      try {
+          // cast the pointer
+          SharedGroup::Handover<Query>* hQuery = reinterpret_cast<SharedGroup::Handover<Query>*>(handoverQueryPtr);
+          std::unique_ptr<SharedGroup::Handover<Query> > handoverQuery (hQuery);
+
+          // when opening a Realm, we start implicitly a read transaction
+          // we need to close it before calling begin_read
+          SG(bgSharedGroupPtr)->end_read();
+
+          // set the background Realm to the same version as the caller Realm
+          SG(bgSharedGroupPtr)->begin_read(handoverQuery->version); // throws
+
+          // import the handover query pointer using the background SharedGroup
+          std::unique_ptr<Query> pQuery (SG(bgSharedGroupPtr)->import_from_handover(std::move(handoverQuery)));
+          Table* pTable = pQuery->get_table().get();
+
+          if (!QUERY_VALID(env, pQuery.get()) || !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+              return -1;
+
+            // run the query
+            TableView* pResultView = new TableView( pQuery->find_all(S(start), S(end), S(limit)) );
+
+            // sorting the results
+            if (!COL_INDEX_VALID(env, pResultView, columnIndex))
+                      return -1;
+              int colType = pResultView->get_column_type( S(columnIndex) );
+
+              switch (colType) {
+                  case type_Bool:
+                  case type_Int:
+                  case type_DateTime:
+                  case type_Float:
+                  case type_Double:
+                  case type_String:
+                      pResultView->sort( S(columnIndex), ascending != 0 ? true : false);
+                      break;
+                  default:
+                      ThrowException(env, IllegalArgument, "Sort is currently only supported on integer, float, double, boolean, Date, and String columns.");
+                      return -1;
+              }
+
+            // handover the result
+            std::unique_ptr<SharedGroup::Handover<TableView> > handover = SG(bgSharedGroupPtr)->export_for_handover(*pResultView, MutableSourcePayload::Move);
+
+            return reinterpret_cast<jlong>(handover.release());
+
+      } CATCH_STD()
+      return -1;
+  }
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllMultiSortedWithHandover
+  (JNIEnv *env, jobject, jlong bgSharedGroupPtr, jlong handoverQueryPtr, jlong start, jlong end, jlong limit, jlongArray columnIndices, jbooleanArray ascending)
+  {
+      try {
+          // cast the pointer
+          SharedGroup::Handover<Query>* hQuery = reinterpret_cast<SharedGroup::Handover<Query>*>(handoverQueryPtr);
+          std::unique_ptr<SharedGroup::Handover<Query> > handoverQuery (hQuery);
+
+          // when opening a Realm, we start implicitly a read transaction
+          // we need to close it before calling begin_read
+          SG(bgSharedGroupPtr)->end_read();
+
+          // set the background Realm to the same version as the caller Realm
+          SG(bgSharedGroupPtr)->begin_read(handoverQuery->version); // throws
+
+          jsize arr_len = env->GetArrayLength(columnIndices);
+          jsize asc_len = env->GetArrayLength(ascending);
+
+          jlong *long_arr = env->GetLongArrayElements(columnIndices, NULL);
+          jboolean *bool_arr = env->GetBooleanArrayElements(ascending, NULL);
+
+          if (arr_len == 0) {
+              ThrowException(env, IllegalArgument, "You must provide at least one field name.");
+              return -1;
+          }
+          if (asc_len == 0) {
+              ThrowException(env, IllegalArgument, "You must provide at least one sort order.");
+              return -1;
+          }
+          if (arr_len != asc_len) {
+              ThrowException(env, IllegalArgument, "Number of column indices and sort orders do not match.");
+              return -1;
+          }
+
+          // import the handover query pointer using the background SharedGroup
+          std::unique_ptr<Query> pQuery = SG(bgSharedGroupPtr)->import_from_handover(std::move(handoverQuery));
+          Table* pTable = pQuery->get_table().get();
+
+          if (!QUERY_VALID(env, pQuery.get()) || !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+              return -1;
+
+            // run the query
+            TableView* pResultView = new TableView( pQuery->find_all(S(start), S(end), S(limit)) );
+
+            // sorting the results
+            std::vector<size_t> indices;
+            std::vector<bool> ascendings;
+
+            for (int i = 0; i < arr_len; ++i) {
+                if (!COL_INDEX_VALID(env, pResultView, long_arr[i]))
+                    return -1;
+                int colType = pResultView->get_column_type( S(long_arr[i]) );
+                switch (colType) {
+                    case type_Bool:
+                    case type_Int:
+                    case type_DateTime:
+                    case type_Float:
+                    case type_Double:
+                    case type_String:
+                        indices.push_back( S(long_arr[i]) );
+                        ascendings.push_back( B(bool_arr[i]) );
+                        break;
+                    default:
+                        ThrowException(env, IllegalArgument, "Sort is currently only supported on integer, float, double, boolean, Date, and String columns.");
+                        return -1;
+                }
+            }
+
+            pResultView->sort(indices, ascendings);
+            env->ReleaseLongArrayElements(columnIndices, long_arr, 0);
+            env->ReleaseBooleanArrayElements(ascending, bool_arr, 0);
+
+            // handover the result
+            std::unique_ptr<SharedGroup::Handover<TableView> > handover = SG(bgSharedGroupPtr)->export_for_handover(*pResultView, MutableSourcePayload::Move);
+
+            return reinterpret_cast<jlong>(handover.release());
+
+      } CATCH_STD()
+      return -1;
+  }
+
+
 
 // Integer Aggregates
 
@@ -1169,3 +1388,83 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(
         pQuery->and_query(query);
     } CATCH_STD()
 }
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverTableViewIntoSharedGroup
+  (JNIEnv *env, jobject, jlong handoverPtr, jlong callerSharedGrpPtr)
+  {
+    SharedGroup::Handover<TableView>* hTableView = reinterpret_cast<SharedGroup::Handover<TableView>*>(handoverPtr);
+    std::unique_ptr<SharedGroup::Handover<TableView> > handoverTV (hTableView);
+
+    try {
+        // import_from_handover will free (delete) the handover
+        if (SG(callerSharedGrpPtr)->is_attached()) {
+            std::unique_ptr<TableView> tv = SG(callerSharedGrpPtr)->import_from_handover(std::move(handoverTV));
+            return reinterpret_cast<jlong>(tv.release());
+
+        } else {
+            ThrowException(env, RuntimeError, " Can not import results from a closed Realm");
+        }
+
+    } catch (SharedGroup::BadVersion& e) {
+        ThrowException(env, BadVersion, " import handover failed");
+
+    } CATCH_STD()
+    return -1;
+  }
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRowIntoSharedGroup
+  (JNIEnv *env, jobject, jlong handoverPtr, jlong callerSharedGrpPtr)
+  {
+    SharedGroup::Handover<Row>* hRow = reinterpret_cast<SharedGroup::Handover<Row>*>(handoverPtr);
+    std::unique_ptr<SharedGroup::Handover<Row> > handoverRow (hRow);
+
+    try {
+        // import_from_handover will free (delete) the handover
+        if (SG(callerSharedGrpPtr)->is_attached()) {
+            std::unique_ptr<Row> row = SG(callerSharedGrpPtr)->import_from_handover(std::move(handoverRow));
+            return reinterpret_cast<jlong>(row.release());
+
+        } else {
+            ThrowException(env, RuntimeError, " Can not import results from a closed Realm");
+        }
+
+    } catch (SharedGroup::BadVersion& e) {
+        ThrowException(env, BadVersion, " import handover failed");
+
+    } CATCH_STD()
+    return -1;
+  }
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery
+   (JNIEnv* env, jobject, jlong bgSharedGroupPtr, jlong nativeQueryPtr)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    if (!QUERY_VALID(env, pQuery))
+        return -1;
+    try {
+        std::unique_ptr<SharedGroup::Handover<Query> > handover = SG(bgSharedGroupPtr)->export_for_handover(*pQuery, MutableSourcePayload::Move);
+        return reinterpret_cast<jlong>(handover.release());
+    } CATCH_STD()
+    return -1;
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseRowHandover
+  (JNIEnv *env, jobject, jlong nativeHandoverRowPtr)
+  {
+     TR_ENTER_PTR(nativeHandoverRowPtr)
+     delete reinterpret_cast<SharedGroup::Handover<Row>* > (nativeHandoverRowPtr);
+  }
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseQueryHandover
+  (JNIEnv *env, jobject, jlong nativeHandoverQuery)
+  {
+    TR_ENTER_PTR(nativeHandoverQuery)
+    delete reinterpret_cast<SharedGroup::Handover<Query>*>(nativeHandoverQuery);
+  }
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseTableHandover
+  (JNIEnv *env, jobject, jlong nativeHandoverTable)
+  {
+     TR_ENTER_PTR(nativeHandoverTable)
+    delete reinterpret_cast<SharedGroup::Handover<TableView>*>(nativeHandoverTable);
+  }
diff --git a/realm-jni/src/io_realm_internal_TableQuery.h b/realm-jni/src/io_realm_internal_TableQuery.h
index 5ccb9eeb7e..4c4e4a6fb1 100644
--- a/realm-jni/src/io_realm_internal_TableQuery.h
+++ b/realm-jni/src/io_realm_internal_TableQuery.h
@@ -359,6 +359,14 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeContains
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind
   (JNIEnv *, jobject, jlong, jlong);
 
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeFindWithHandover
+ * Signature: (JJJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover
+  (JNIEnv *, jobject, jlong, jlong, jlong);
+
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeFindAll
@@ -367,6 +375,54 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
 
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeFindAllWithHandover
+ * Signature: (JJJJJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllWithHandover
+  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeFindAllSortedWithHandover
+ * Signature: (JJJJJJZ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllSortedWithHandover
+  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong, jlong, jboolean);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeFindAllMultiSortedWithHandover
+ * Signature: (JJJJJ[J[Z)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllMultiSortedWithHandover
+  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong, jlongArray, jbooleanArray);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeImportHandoverTableViewIntoSharedGroup
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverTableViewIntoSharedGroup
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeImportHandoverRowIntoSharedGroup
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRowIntoSharedGroup
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeHandoverQuery
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery
+  (JNIEnv *, jobject, jlong, jlong);
+
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeSumInt
@@ -503,6 +559,30 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeCount
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeRemove
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
 
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeCloseRowHandover
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseRowHandover
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeCloseQueryHandover
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseQueryHandover
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeCloseTableHandover
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseTableHandover
+  (JNIEnv *, jobject, jlong);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/realm-jni/src/util.cpp b/realm-jni/src/util.cpp
index 3028e5729e..59d9993056 100644
--- a/realm-jni/src/util.cpp
+++ b/realm-jni/src/util.cpp
@@ -126,12 +126,14 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
             jExceptionClass = env->FindClass("java/lang/RuntimeException");
             message = classStr;
             break;
-
         case RowInvalid:
             jExceptionClass = env->FindClass("java/lang/IllegalStateException");
             message = "Illegal State: " + classStr;
             break;
-
+        case BadVersion:
+            jExceptionClass = env->FindClass("io/realm/internal/async/BadVersionException");
+            message = "Handover failed due to version mismatch: " + classStr;
+            break;
         case EncryptionNotSupported:
             jExceptionClass = env->FindClass("io/realm/exceptions/RealmEncryptionNotSupportedException");
             message = classStr;
diff --git a/realm-jni/src/util.hpp b/realm-jni/src/util.hpp
index 22dfb3fbde..aac1f0428e 100644
--- a/realm-jni/src/util.hpp
+++ b/realm-jni/src/util.hpp
@@ -48,6 +48,8 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved);
 }
 #endif
 
+using namespace realm;
+
 // Use this macro when logging a pointer using '%p'
 #define VOID_PTR(ptr) reinterpret_cast<void*>(ptr)
 
@@ -94,12 +96,14 @@ std::string num_to_string(T pNumber)
 #define S(x)    static_cast<size_t>(x)
 #define B(x)    static_cast<bool>(x)
 #define S64(x)  static_cast<int64_t>(x)
-#define TBL(x)  reinterpret_cast<realm::Table*>(x)
-#define TV(x)   reinterpret_cast<realm::TableView*>(x)
-#define LV(x)   reinterpret_cast<realm::LinkView*>(x)
-#define Q(x)    reinterpret_cast<realm::Query*>(x)
-#define G(x)    reinterpret_cast<realm::Group*>(x)
-#define ROW(x)  reinterpret_cast<realm::Row*>(x)
+#define TBL(x)  reinterpret_cast<Table*>(x)
+#define TV(x)   reinterpret_cast<TableView*>(x)
+#define LV(x)   reinterpret_cast<LinkView*>(x)
+#define Q(x)    reinterpret_cast<Query*>(x)
+#define G(x)    reinterpret_cast<Group*>(x)
+#define ROW(x)  reinterpret_cast<Row*>(x)
+#define SG(ptr) reinterpret_cast<SharedGroup*>(ptr)
+#define CH(ptr) reinterpret_cast<ClientHistory*>(ptr)
 
 // Exception handling
 enum ExceptionKind {
@@ -118,8 +122,10 @@ enum ExceptionKind {
     FatalError = 11,
     RuntimeError = 12,
     RowInvalid = 13,
+    BadVersion = 15
     EncryptionNotSupported = 14
 // NOTE!!!!: Please also add test cases to Util.java when introducing a new exception kind.
+>>>>>>> master
 };
 
 void ConvertException(JNIEnv* env, const char *file, int line);
@@ -215,7 +221,7 @@ extern const char *log_tag;
 
 
 inline jlong to_jlong_or_not_found(size_t res) {
-    return (res == realm::not_found) ? jlong(-1) : jlong(res);
+    return (res == not_found) ? jlong(-1) : jlong(res);
 }
 
 template <class T>
@@ -224,7 +230,7 @@ inline bool TableIsValid(JNIEnv* env, T* objPtr)
     bool valid = (objPtr != NULL);
     if (valid) {
         // Check if Table is valid
-        if (realm::util::SameType<realm::Table, T>::value) {
+        if (std::is_same<Table, T>::value) {
             valid = TBL(objPtr)->is_attached();
         }
         // TODO: Add check for TableView
@@ -259,13 +265,13 @@ bool RowIndexesValid(JNIEnv* env, T* pTable, jlong startIndex, jlong endIndex, j
         ThrowException(env, IndexOutOfBounds, "startIndex < 0.");
         return false;
     }
-    if (realm::util::int_greater_than(startIndex, maxIndex)) {
+    if (util::int_greater_than(startIndex, maxIndex)) {
         TR_ERR("startIndex %" PRId64 " > %" PRId64 " - invalid!", S64(startIndex), S64(maxIndex))
         ThrowException(env, IndexOutOfBounds, "startIndex > available rows.");
         return false;
     }
 
-    if (realm::util::int_greater_than(endIndex, maxIndex)) {
+    if (util::int_greater_than(endIndex, maxIndex)) {
         TR_ERR("endIndex %" PRId64 " > %" PRId64 " - invalid!", S64(endIndex), S64(maxIndex))
         ThrowException(env, IndexOutOfBounds, "endIndex > available rows.");
         return false;
@@ -295,7 +301,7 @@ inline bool RowIndexValid(JNIEnv* env, T* pTable, jlong rowIndex, bool offset=fa
     size_t size = pTable->size();
     if (size > 0 && offset)
         size -= 1;
-    bool rowErr = realm::util::int_greater_than_or_equal(rowIndex, size);
+    bool rowErr = util::int_greater_than_or_equal(rowIndex, size);
     if (rowErr) {
         TR_ERR("rowIndex %" PRId64 " > %" PRId64 " - invalid!", S64(rowIndex), S64(size))
         ThrowException(env, IndexOutOfBounds,
@@ -308,7 +314,7 @@ inline bool RowIndexValid(JNIEnv* env, T* pTable, jlong rowIndex, bool offset=fa
 template <class T>
 inline bool TblRowIndexValid(JNIEnv* env, T* pTable, jlong rowIndex, bool offset=false)
 {
-    if (realm::util::SameType<realm::Table, T>::value) {
+    if (std::is_same<Table, T>::value) {
         if (!TableIsValid(env, TBL(pTable)))
             return false;
     }
@@ -322,7 +328,7 @@ inline bool ColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
         ThrowException(env, IndexOutOfBounds, "columnIndex is less than 0.");
         return false;
     }
-    bool colErr = realm::util::int_greater_than_or_equal(columnIndex, pTable->get_column_count());
+    bool colErr = util::int_greater_than_or_equal(columnIndex, pTable->get_column_count());
     if (colErr) {
         TR_ERR("columnIndex %" PRId64 " > %" PRId64 " - invalid!", S64(columnIndex), S64(pTable->get_column_count()))
         ThrowException(env, IndexOutOfBounds, "columnIndex > available columns.");
@@ -333,7 +339,7 @@ inline bool ColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
 template <class T>
 inline bool TblColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
 {
-    if (realm::util::SameType<realm::Table, T>::value) {
+    if (std::is_same<Table, T>::value) {
         if (!TableIsValid(env, TBL(pTable)))
             return false;
     }
@@ -364,7 +370,7 @@ inline bool TblIndexInsertValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong
 {
     if (!TblColIndexValid(env, pTable, columnIndex))
         return false;
-    bool rowErr = realm::util::int_greater_than(rowIndex, pTable->size()+1);
+    bool rowErr = util::int_greater_than(rowIndex, pTable->size()+1);
     if (rowErr) {
         TR_ERR("rowIndex %" PRId64 " > %" PRId64 " - invalid!", S64(rowIndex), S64(pTable->size()))
         ThrowException(env, IndexOutOfBounds,
@@ -380,7 +386,7 @@ inline bool TypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex,
     size_t col = static_cast<size_t>(columnIndex);
     int colType = pTable->get_column_type(col);
     if (allowMixed) {
-        if (colType == realm::type_Mixed) {
+        if (colType == type_Mixed) {
             size_t row = static_cast<size_t>(rowIndex);
             colType = pTable->get_mixed_type(col, row);
         }
@@ -451,7 +457,7 @@ inline bool TblIndexAndTypeInsertValid(JNIEnv* env, T* pTable, jlong columnIndex
         && TypeValid(env, pTable, columnIndex, rowIndex, expectColType, false);
 }
 
-bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, realm::BinaryData& data);
+bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, BinaryData& data);
 
 
 // Utility function for appending StringData, which is returned
@@ -469,15 +475,15 @@ std::string concat_stringdata(const char *message, StringData data);
 //
 // See also http://en.wikipedia.org/wiki/UTF-8#Modified_UTF-8
 
-jstring to_jstring(JNIEnv*, realm::StringData);
+jstring to_jstring(JNIEnv*, StringData);
 
 class JStringAccessor {
 public:
     JStringAccessor(JNIEnv*, jstring);  // throws
 
-    operator realm::StringData() const REALM_NOEXCEPT
+    operator StringData() const REALM_NOEXCEPT
     {
-        return realm::StringData(m_data.get(), m_size);
+        return StringData(m_data.get(), m_size);
     }
 
 private:
diff --git a/realm/build.gradle b/realm/build.gradle
index 954fc6c5bb..5ab7ebfd00 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -47,6 +47,7 @@ android.libraryVariants.all { variant ->
         ext.androidJar = files(project.android.getBootClasspath())
         classpath = files(variant.javaCompile.classpath.files) + ext.androidJar
         options.memberLevel = JavadocMemberLevel.PUBLIC
+        options.addStringOption('Xdoclint:none', '-quiet')
         exclude '**/internal/**'
         exclude '**/BuildConfig.java'
         exclude '**/R.java'
diff --git a/realm/config/checkstyle/checkstyle.xml b/realm/config/checkstyle/checkstyle.xml
index d0977e2e72..39663eb51a 100644
--- a/realm/config/checkstyle/checkstyle.xml
+++ b/realm/config/checkstyle/checkstyle.xml
@@ -14,7 +14,7 @@
     <module name="NewlineAtEndOfFile">
         <property name="lineSeparator" value="lf"/>
     </module>
-    <module name="FileLength"/>
+    <!--<module name="FileLength"/>-->
     <module name="FileTabCharacter"/>
 
     <!-- Trailing spaces -->
diff --git a/realm/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
new file mode 100644
index 0000000000..43525da9dd
--- /dev/null
+++ b/realm/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -0,0 +1,1591 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.Looper;
+import android.os.SystemClock;
+import android.test.InstrumentationTestCase;
+
+import junit.framework.AssertionFailedError;
+
+import java.lang.reflect.Field;
+import java.util.Date;
+import java.util.Random;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.Dog;
+import io.realm.entities.NonLatinFieldNames;
+import io.realm.entities.Owner;
+import io.realm.exceptions.RealmException;
+import io.realm.internal.async.RetryPolicy;
+
+public class RealmAsyncQueryTests extends InstrumentationTestCase {
+    private final static int NO_RETRY = 0;
+    private static final int RETRY_ONCE = 1;
+    private static final int RETRY_TWICE = 2;
+    private static final int RETRY_NUMBER_NOT_APPLICABLE = Integer.MAX_VALUE;
+
+    private final static int NO_ADVANCED_READ = 0;
+    private static final int ADVANCE_ONE_READ = 1;
+    private static final int ADVANCE_THREE_READ = 3;
+    private static final int ADVANCE_HUNDRED_READ = 100;
+
+    // async query without any conflicts strategy
+    public void testFindAll() throws Throwable {
+        setDebugModeForAsyncRealmQuery(NO_ADVANCED_READ, RetryPolicy.MODE_NO_RETRY, NO_RETRY);
+        // we need to control precisely which Looper/Thread our Realm
+        // will operate on. This is unfortunately not possible when using the
+        // current Instrumentation#InstrumentationThread, because InstrumentationTestRunner#onStart
+        // Call Looper.prepare() for us and surprisingly doesn't call Looper#loop(), this is problematic
+        // as the async query callback will not run (because the Handler is sending Runnables to a Looper
+        // that didn't loop.
+        //
+        // On the other hand, using a dedicated 'ExecutorService' will allow us to fine grain control the
+        // desired behaviour
+        final CountDownLatch signalCallbackFinished = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                Realm realm = null;
+                try {
+                    realm = openRealmInstance("test_find_all");
+                    populateTestRealm(realm, 10);
+
+                    // async query (will run on different thread)
+                    realm.where(AllTypes.class)
+                            .between("columnLong", 0, 9)
+                            .findAll(new RealmResults.QueryCallback<AllTypes>() {
+                                @Override
+                                public void onSuccess(RealmResults<AllTypes> results) {
+                                    try {
+                                        assertEquals(10, results.size());
+
+                                        // make sure access to RealmObject will not throw an Exception
+                                        for (int i = 0, size = results.size(); i < size; i++) {
+                                            assertEquals(i, results.get(i).getColumnLong());
+                                        }
+
+                                    } catch (AssertionFailedError e) {
+                                        threadAssertionError[0] = e;
+
+                                    } finally {
+                                        // whatever happened, make sure to notify the waiting TestCase Thread
+                                        signalCallbackFinished.countDown();
+                                    }
+                                }
+
+                                @Override
+                                public void onError(Exception t) {
+                                    try {
+                                        threadAssertionError[0] = t;
+                                        t.printStackTrace();
+                                    } finally {
+                                        signalCallbackFinished.countDown();
+                                    }
+                                }
+                            });
+
+                    Looper.loop();// ready to receive callback
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+
+                } finally {
+                    if (signalCallbackFinished.getCount() > 0) {
+                        signalCallbackFinished.countDown();
+                    }
+                    if (realm != null) {
+                        realm.close();
+                    }
+                }
+            }
+        });
+
+        // wait until the callback of our async query proceed
+        signalCallbackFinished.await();
+        looper[0].quit();
+        executorService.shutdownNow();
+        if (null != threadAssertionError[0]) {
+            // throw any assertion errors happened in the background thread
+            throw threadAssertionError[0];
+        }
+    }
+
+    // async query on closed Realm
+    public void testFindAllOnClosedRealm() throws Throwable {
+        setDebugModeForAsyncRealmQuery(ADVANCE_ONE_READ, RetryPolicy.MODE_INDEFINITELY, RETRY_NUMBER_NOT_APPLICABLE);
+        final CountDownLatch signalCallbackFinished = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                Realm realm = null;
+                try {
+                    realm = openRealmInstance("test_find_all_closed_realm");
+                    populateTestRealm(realm, 10);
+
+                    // async query (will run on different thread)
+                    realm.where(AllTypes.class)
+                            .between("columnLong", 0, 9)
+                            .findAll(new RealmResults.DebugRealmResultsQueryCallback<AllTypes>() {
+                                @Override
+                                public void onSuccess(RealmResults<AllTypes> results) {
+                                    signalCallbackFinished.countDown();
+                                }
+
+                                @Override
+                                public void onError(Exception t) {
+                                    t.printStackTrace();
+                                    threadAssertionError[0] = t;
+                                    signalCallbackFinished.countDown();
+                                }
+
+                                @Override
+                                public void onBackgroundQueryCompleted(Realm realm) {
+                                    realm.close();
+                                }
+                            });
+
+                    Looper.loop();// ready to receive callback
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+
+                } finally {
+                    if (signalCallbackFinished.getCount() > 0) {
+                        signalCallbackFinished.countDown();
+                    }
+                }
+            }
+        });
+
+        // wait until the callback of our async query proceed
+        signalCallbackFinished.await();
+        looper[0].quit();
+        executorService.shutdownNow();
+        if (null == threadAssertionError[0] || !(threadAssertionError[0] instanceof RuntimeException)) {
+            fail("Expecting RuntimeException: Unspecified exception. Detached accessor in io_realm_internal_TableQuery.cpp");
+        }
+    }
+
+    // async query that should fail, because the caller thread has advanced
+    // the version of the Realm, which is different from the one used by
+    // the background thread. Since no retry policy was defined, we should fail.
+    public void testMismatchedRealmVersion_should_fail_no_retry() throws Throwable {
+        // simulate one advanced read just after the worker thread has finished querying the Realm
+        // without any retry we should crash, because the background Realm used to perform the query
+        // return a TableView using a different version of the caller Realm (now more advanced)
+        setDebugModeForAsyncRealmQuery(ADVANCE_ONE_READ, RetryPolicy.MODE_NO_RETRY, NO_RETRY);
+
+        final CountDownLatch signalCallbackFinished = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                Realm realm = null;
+                try {
+                    realm = openRealmInstance("test_should_fail_no_retry");
+                    populateTestRealm(realm, 10);
+
+                    realm.where(AllTypes.class)
+                            .between("columnLong", 0, 9)
+                            .findAll(new RealmResults.DebugRealmResultsQueryCallback<AllTypes>() {
+                                @Override
+                                public void onSuccess(RealmResults<AllTypes> results) {
+                                    signalCallbackFinished.countDown();
+                                }
+
+                                @Override
+                                public void onError(Exception t) {
+                                    threadAssertionError[0] = t;
+                                    signalCallbackFinished.countDown();
+                                }
+
+                                @Override
+                                public void onBackgroundQueryCompleted(Realm realm) {
+                                    // triggered on the background thread to alter the caller's Realm state
+                                    realm.executeTransaction(new Realm.Transaction() {
+                                        @Override
+                                        public void execute(Realm realm) {
+                                            realm.clear(AllTypes.class);
+                                        }
+                                    });
+                                }
+                            });
+
+                    Looper.loop();
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+                } finally {
+                    if (signalCallbackFinished.getCount() > 0) {
+                        // opening Realm crashed, not even callbacks get the chance to be called
+                        signalCallbackFinished.countDown();
+                    }
+                    if (realm != null) {
+                        realm.close();
+                    }
+                }
+            }
+        });
+
+        signalCallbackFinished.await();
+        looper[0].quit();
+        executorService.shutdownNow();
+        if (null == threadAssertionError[0] || !(threadAssertionError[0] instanceof RealmException)) {
+            fail("Expecting RuntimeException: Unspecified exception." +
+                    " Handover failed due to version mismatch in io_realm_internal_TableQuery.cpp");
+        }
+    }
+
+    // async query that converge after 1 retry
+    public void testMismatchedRealmVersion_should_converge_after_1_retry() throws Throwable {
+        // simulate one advanced read just after the worker thread has finished querying the Realm
+        setDebugModeForAsyncRealmQuery(ADVANCE_ONE_READ, RetryPolicy.MODE_MAX_RETRY, RETRY_ONCE);
+
+        final CountDownLatch signalCallbackFinishedLatch = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                Realm realm = null;
+                try {
+                    realm = openRealmInstance("should_converge_after_1_retry");
+                    populateTestRealm(realm, 10);
+                    realm.where(AllTypes.class)
+                            .between("columnLong", 0, 9)
+                            .findAll(new RealmResults.DebugRealmResultsQueryCallback<AllTypes>() {
+                                @Override
+                                public void onSuccess(RealmResults<AllTypes> results) {
+                                    try {
+                                        assertEquals(3, results.size());
+
+                                        for (int i = 0, size = results.size(); i < size; i++) {
+                                            assertEquals(i, results.get(i).getColumnLong());
+                                        }
+
+                                    } catch (AssertionFailedError e) {
+                                        threadAssertionError[0] = e;
+
+                                    } finally {
+                                        signalCallbackFinishedLatch.countDown();
+                                    }
+                                }
+
+                                @Override
+                                public void onError(Exception t) {
+                                    try {
+                                        threadAssertionError[0] = t;
+                                    } finally {
+                                        signalCallbackFinishedLatch.countDown();
+                                    }
+                                }
+
+                                @Override
+                                public void onBackgroundQueryCompleted(Realm realm) {
+                                    populateTestRealm(realm, 3);// this is already inside a transaction
+                                }
+                            });
+
+                    Looper.loop();//ready to receive callback
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+                } finally {
+                    if (signalCallbackFinishedLatch.getCount() > 0) {
+                        signalCallbackFinishedLatch.countDown();
+                    }
+                    if (realm != null) {
+                        realm.close();
+                    }
+                }
+            }
+        });
+
+        signalCallbackFinishedLatch.await();
+        looper[0].quit();
+        executorService.shutdownNow();
+        if (null != threadAssertionError[0]) {
+            throw threadAssertionError[0];
+        }
+    }
+
+    // this should crash because the number of retries is less than the number of modifications
+    public void testMismatchedRealmVersion_should_fail_after_2_retries() throws Throwable {
+        // simulate 3 modification to the caller's Realm for each result coming from the background thread
+        setDebugModeForAsyncRealmQuery(ADVANCE_THREE_READ, RetryPolicy.MODE_MAX_RETRY, RETRY_TWICE);
+
+        final CountDownLatch signalCallbackFinishedLatch = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                Realm realm = null;
+                try {
+                    realm = openRealmInstance("test_should_crash_after_2_retries");
+                    populateTestRealm(realm, 10);
+                    realm.where(AllTypes.class)
+                            .between("columnLong", 0, 9)
+                            .findAll(new RealmResults.DebugRealmResultsQueryCallback<AllTypes>() {
+                                @Override
+                                public void onSuccess(RealmResults<AllTypes> results) {
+                                    try {
+                                        signalCallbackFinishedLatch.countDown();
+
+                                    } catch (AssertionFailedError e) {
+                                        threadAssertionError[0] = e;
+
+                                    } finally {
+                                        // whatever happened, make sure to notify the waiting TestCase Thread
+                                        signalCallbackFinishedLatch.countDown();
+                                    }
+                                }
+
+                                @Override
+                                public void onError(Exception t) {
+                                    try {
+                                        threadAssertionError[0] = t;
+                                    } finally {
+                                        signalCallbackFinishedLatch.countDown();
+                                    }
+                                }
+
+                                @Override
+                                public void onBackgroundQueryCompleted(Realm realm) {
+                                    populateTestRealm(realm, 3);
+                                }
+                            });
+
+                    Looper.loop();
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+                } finally {
+                    if (signalCallbackFinishedLatch.getCount() > 0) {
+                        signalCallbackFinishedLatch.countDown();
+                    }
+                    if (realm != null) {
+                        realm.close();
+                    }
+                }
+            }
+        });
+
+        signalCallbackFinishedLatch.await();
+        looper[0].quit();
+        executorService.shutdownNow();
+        if (null == threadAssertionError[0] || !(threadAssertionError[0] instanceof RealmException)) {
+            fail("Expecting RuntimeException: Unspecified exception." +
+                    " Handover failed due to version mismatch in io_realm_internal_TableQuery.cpp");
+        }
+    }
+
+    // keep retrying until the caller thread & the background results converge
+    public void testMismatchedRealmVersion_should_converge_after_100_retries() throws Throwable {
+        setDebugModeForAsyncRealmQuery(ADVANCE_HUNDRED_READ, RetryPolicy.MODE_INDEFINITELY, RETRY_NUMBER_NOT_APPLICABLE);
+
+        final CountDownLatch signalCallbackFinishedLatch = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final AtomicInteger numberOfEntries = new AtomicInteger(10);
+        final Random random = new Random(System.currentTimeMillis());
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                Realm realm = null;
+                try {
+                    realm = openRealmInstance("test_should_converge_after_100_retries");
+                    populateTestRealm(realm, numberOfEntries.get());
+                    realm.where(AllTypes.class)
+                            .between("columnLong", 0, 9)
+                            .findAll(new RealmResults.DebugRealmResultsQueryCallback<AllTypes>() {
+                                @Override
+                                public void onSuccess(RealmResults<AllTypes> results) {
+                                    try {
+                                        if (numberOfEntries.get() > 10) {
+                                            assertEquals(10, results.size());
+                                        } else {
+                                            assertEquals(numberOfEntries.get(), results.size());
+                                        }
+
+                                        for (int i = 0, size = results.size(); i < size; i++) {
+                                            assertEquals(i, results.get(i).getColumnLong());
+                                        }
+
+                                    } catch (AssertionFailedError e) {
+                                        threadAssertionError[0] = e;
+
+                                    } finally {
+                                        signalCallbackFinishedLatch.countDown();
+                                    }
+                                }
+
+                                @Override
+                                public void onError(Exception t) {
+                                    try {
+                                        threadAssertionError[0] = t;
+                                    } finally {
+                                        signalCallbackFinishedLatch.countDown();
+                                    }
+                                }
+
+                                @Override
+                                public void onBackgroundQueryCompleted(Realm realm) {
+                                    numberOfEntries.set(random.nextInt(100));
+                                    populateTestRealm(realm, numberOfEntries.get());
+                                }
+
+                            });
+
+                    Looper.loop();
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+                } finally {
+                    if (signalCallbackFinishedLatch.getCount() > 0) {
+                        signalCallbackFinishedLatch.countDown();
+                    }
+                    if (realm != null) {
+                        realm.close();
+                    }
+                }
+            }
+        });
+
+        signalCallbackFinishedLatch.await();
+        looper[0].quit();
+        executorService.shutdownNow();
+        if (null != threadAssertionError[0]) {
+            throw threadAssertionError[0];
+        }
+    }
+
+    // cancel a pending query
+    public void testCancelQuery() throws Throwable {
+        setDebugModeForAsyncRealmQuery(ADVANCE_THREE_READ, RetryPolicy.MODE_INDEFINITELY, RETRY_NUMBER_NOT_APPLICABLE);
+
+        final AtomicInteger retryNumber = new AtomicInteger(0);
+        final CountDownLatch signalQueryRunning = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        final RealmQuery.Request[] asyncRequest = new RealmQuery.Request[1];
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                Realm realm = null;
+                try {
+                    realm = openRealmInstance("test_cancel_query");
+                    populateTestRealm(realm, 10);
+
+                    asyncRequest[0] = realm.where(AllTypes.class)
+                            .between("columnLong", 0, 9)
+                            .findAll(new RealmResults.DebugRealmResultsQueryCallback<AllTypes>() {
+                                @Override
+                                public void onSuccess(RealmResults<AllTypes> results) {
+                                    threadAssertionError[0] = new AssertionFailedError("onSuccess called on a cancelled query");
+                                }
+
+                                @Override
+                                public void onError(Exception t) {
+                                    threadAssertionError[0] = new AssertionFailedError("onError called on a cancelled query");
+                                }
+
+                                @Override
+                                public void onBackgroundQueryCompleted(Realm realm) {
+                                    populateTestRealm(realm, 1);
+                                    // after 2 retries we cancel the query
+                                    if (retryNumber.incrementAndGet() == 2) {
+                                        asyncRequest[0].cancel();
+                                        signalQueryRunning.countDown();
+                                    }
+                                }
+                            });
+
+                    Looper.loop();
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+
+                } finally {
+                    if (signalQueryRunning.getCount() > 0) {
+                        signalQueryRunning.countDown();
+                    }
+                    if (realm != null) {
+                        realm.close();
+                    }
+                }
+            }
+        });
+
+        signalQueryRunning.await();
+        executorService.shutdown();
+        executorService.awaitTermination(5, TimeUnit.SECONDS);
+
+        assertTrue(asyncRequest[0].isCancelled());
+
+        looper[0].quit();
+        executorService.shutdownNow();
+
+        if (null != threadAssertionError[0]) {
+            throw threadAssertionError[0];
+        }
+    }
+
+    // *** findFirst *** //
+
+    // Async query to find one RealmObject without any conflicts strategy
+    public void testFindFirst() throws Throwable {
+        setDebugModeForAsyncRealmQuery(NO_ADVANCED_READ, RetryPolicy.MODE_NO_RETRY, NO_RETRY);
+
+        final CountDownLatch signalCallbackFinished = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                Realm realm = null;
+                try {
+                    realm = openRealmInstance("test_find_first");
+                    realm.beginTransaction();
+                    final Owner owner1 = realm.createObject(Owner.class);
+                    owner1.setName("Owner 1");
+                    final Dog dog1 = realm.createObject(Dog.class);
+                    dog1.setName("Dog 1");
+                    dog1.setWeight(1);
+                    final Dog dog2 = realm.createObject(Dog.class);
+                    dog2.setName("Dog 2");
+                    dog2.setWeight(2);
+                    owner1.getDogs().add(dog1);
+                    owner1.getDogs().add(dog2);
+
+                    final Owner owner2 = realm.createObject(Owner.class);
+                    owner2.setName("Owner 2");
+                    final Dog dog3 = realm.createObject(Dog.class);
+                    dog3.setName("Dog 3");
+                    dog3.setWeight(1);
+                    final Dog dog4 = realm.createObject(Dog.class);
+                    dog4.setName("Dog 4");
+                    dog4.setWeight(2);
+                    owner2.getDogs().add(dog3);
+                    owner2.getDogs().add(dog4);
+                    realm.commitTransaction();
+
+                    realm.where(Owner.class)
+                            .equalTo("name", "Owner 2")
+                            .findFirst(new RealmObject.QueryCallback<Owner>() {
+                                @Override
+                                public void onSuccess(Owner result) {
+                                    try {
+                                        RealmList<Dog> dogs = result.getDogs();
+                                        Dog dog = dogs.where().equalTo("name", "Dog 4").findFirst();
+                                        assertEquals(dog4, dog);
+
+                                    } catch (AssertionFailedError e) {
+                                        threadAssertionError[0] = e;
+
+                                    } finally {
+                                        // whatever happened, make sure to notify the waiting TestCase Thread
+                                        signalCallbackFinished.countDown();
+                                    }
+                                }
+
+                                @Override
+                                public void onError(Exception t) {
+                                    try {
+                                        threadAssertionError[0] = t;
+                                        t.printStackTrace();
+                                    } finally {
+                                        signalCallbackFinished.countDown();
+                                    }
+                                }
+                            });
+
+                    Looper.loop();
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+                } finally {
+                    if (signalCallbackFinished.getCount() > 0) {
+                        signalCallbackFinished.countDown();
+                    }
+                    if (realm != null) {
+                        realm.close();
+                    }
+                }
+            }
+        });
+
+        // wait until the callback of our async query proceed
+        signalCallbackFinished.await();
+        looper[0].quit();
+        executorService.shutdownNow();
+        if (null != threadAssertionError[0]) {
+            // throw any assertion errors happened in the background thread
+            throw threadAssertionError[0];
+        }
+    }
+
+    // async query to find one RealmObject without any conflicts strategy.
+    // since no retry policy was defined it should crash
+    public void testFindFirst_should_fail_no_retry() throws Throwable {
+        setDebugModeForAsyncRealmQuery(1, RetryPolicy.MODE_NO_RETRY, NO_RETRY);
+
+        final CountDownLatch signalCallbackFinished = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                Realm realm = null;
+                try {
+                    realm = openRealmInstance("test_find_first_fail_no_retry");
+                    realm.beginTransaction();
+                    final Owner owner1 = realm.createObject(Owner.class);
+                    owner1.setName("Owner 1");
+                    final Dog dog1 = realm.createObject(Dog.class);
+                    dog1.setName("Dog 1");
+                    dog1.setWeight(1);
+                    final Dog dog2 = realm.createObject(Dog.class);
+                    dog2.setName("Dog 2");
+                    dog2.setWeight(2);
+                    owner1.getDogs().add(dog1);
+                    owner1.getDogs().add(dog2);
+
+                    final Owner owner2 = realm.createObject(Owner.class);
+                    owner2.setName("Owner 2");
+                    final Dog dog3 = realm.createObject(Dog.class);
+                    dog3.setName("Dog 3");
+                    dog3.setWeight(1);
+                    final Dog dog4 = realm.createObject(Dog.class);
+                    dog4.setName("Dog 4");
+                    dog4.setWeight(2);
+                    owner2.getDogs().add(dog3);
+                    owner2.getDogs().add(dog4);
+                    realm.commitTransaction();
+
+                    realm.where(Owner.class)
+                            .equalTo("name", "Owner 2")
+                            .findFirst(new RealmObject.DebugRealmObjectQueryCallback<Owner>() {
+                                @Override
+                                public void onSuccess(Owner result) {
+                                    signalCallbackFinished.countDown();
+                                }
+
+                                @Override
+                                public void onError(Exception t) {
+                                    try {
+                                        threadAssertionError[0] = t;
+                                        t.printStackTrace();
+                                    } finally {
+                                        signalCallbackFinished.countDown();
+                                    }
+                                }
+
+                                @Override
+                                public void onBackgroundQueryCompleted(Realm realm) {
+                                    // triggered on the background thread to alter the caller's Realm state
+                                    realm.executeTransaction(new Realm.Transaction() {
+                                        @Override
+                                        public void execute(Realm realm) {
+                                            realm.createObject(Owner.class);
+                                            realm.createObject(Dog.class);
+                                        }
+                                    });
+                                }
+                            });
+
+                    Looper.loop();// ready to receive callback
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+
+                } finally {
+                    if (signalCallbackFinished.getCount() > 0) {
+                        signalCallbackFinished.countDown();
+                    }
+                    if (realm != null) {
+                        realm.close();
+                    }
+                }
+            }
+        });
+
+        // wait until the callback of our async query proceed
+        signalCallbackFinished.await();
+        looper[0].quit();
+        executorService.shutdownNow();
+        if (null == threadAssertionError[0] || !(threadAssertionError[0] instanceof RealmException)) {
+            fail("Expecting RuntimeException: Unspecified exception." +
+                    " Handover failed due to version mismatch in io_realm_internal_TableQuery.cpp");
+        }
+    }
+
+    // async query to find one RealmObject converge after 1 retry
+    public void testFindFirst_should_converge_after_1_retry() throws Throwable {
+        setDebugModeForAsyncRealmQuery(NO_ADVANCED_READ, RetryPolicy.MODE_NO_RETRY, NO_RETRY);
+
+        final CountDownLatch signalCallbackFinished = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                Realm realm = null;
+                try {
+                    realm = openRealmInstance("test_find_first_converge_after_1_retry");
+                    realm.beginTransaction();
+                    final Owner owner1 = realm.createObject(Owner.class);
+                    owner1.setName("Owner 1");
+                    final Dog dog1 = realm.createObject(Dog.class);
+                    dog1.setName("Dog 1");
+                    dog1.setWeight(1);
+                    final Dog dog2 = realm.createObject(Dog.class);
+                    dog2.setName("Dog 2");
+                    dog2.setWeight(2);
+                    owner1.getDogs().add(dog1);
+                    owner1.getDogs().add(dog2);
+
+                    final Owner owner2 = realm.createObject(Owner.class);
+                    owner2.setName("Owner 2");
+                    final Dog dog3 = realm.createObject(Dog.class);
+                    dog3.setName("Dog 3");
+                    dog3.setWeight(1);
+                    final Dog dog4 = realm.createObject(Dog.class);
+                    dog4.setName("Dog 4");
+                    dog4.setWeight(2);
+                    owner2.getDogs().add(dog3);
+                    owner2.getDogs().add(dog4);
+                    realm.commitTransaction();
+
+                    realm.where(Owner.class)
+                            .equalTo("name", "Owner 2")
+                            .findFirst(new RealmObject.DebugRealmObjectQueryCallback<Owner>() {
+                                @Override
+                                public void onSuccess(Owner result) {
+                                    try {
+                                        RealmList<Dog> dogs = result.getDogs();
+                                        Dog dog = dogs.where().equalTo("name", "Dog 4").findFirst();
+                                        assertEquals(dog4, dog);
+
+                                    } catch (AssertionFailedError e) {
+                                        threadAssertionError[0] = e;
+
+                                    } finally {
+                                        // whatever happened, make sure to notify the waiting TestCase Thread
+                                        signalCallbackFinished.countDown();
+                                    }
+                                }
+
+                                @Override
+                                public void onError(Exception t) {
+                                    try {
+                                        threadAssertionError[0] = t;
+                                        t.printStackTrace();
+                                    } finally {
+                                        signalCallbackFinished.countDown();
+                                    }
+                                }
+
+                                @Override
+                                public void onBackgroundQueryCompleted(Realm realm) {
+                                    // triggered on the background thread to alter the caller's Realm state
+                                    realm.executeTransaction(new Realm.Transaction() {
+                                        @Override
+                                        public void execute(Realm realm) {
+                                            realm.createObject(Owner.class);
+                                            realm.createObject(Dog.class);
+                                        }
+                                    });
+                                }
+
+                            });
+
+                    Looper.loop();// ready to receive callback
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+                } finally {
+                    if (signalCallbackFinished.getCount() > 0) {
+                        signalCallbackFinished.countDown();
+                    }
+                    if (realm != null) {
+                        realm.close();
+                    }
+                }
+            }
+        });
+
+        // wait until the callback of our async query proceed
+        signalCallbackFinished.await();
+        looper[0].quit();
+        executorService.shutdownNow();
+        if (null != threadAssertionError[0]) {
+            // throw any assertion errors happened in the background thread
+            throw threadAssertionError[0];
+        }
+    }
+
+    // *** findAllSorted *** //
+
+    public void testFindAllSorted() throws Throwable {
+        setDebugModeForAsyncRealmQuery(NO_ADVANCED_READ, RetryPolicy.MODE_NO_RETRY, NO_RETRY);
+        final CountDownLatch signalCallbackFinished = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                Realm realm = null;
+                try {
+                    realm = openRealmInstance("test_find_all_sorted");
+                    realm.beginTransaction();
+                    for (int i = 0; i < 10; i++) {
+                        AllTypes allTypes = realm.createObject(AllTypes.class);
+                        allTypes.setColumnLong(i);
+                        allTypes.setColumnString("data " + i % 3);
+                    }
+                    realm.commitTransaction();
+
+                    realm.where(AllTypes.class)
+                            .findAllSorted("columnLong",
+                                    RealmResults.SORT_ORDER_DESCENDING,
+                                    new RealmResults.QueryCallback<AllTypes>() {
+
+                                        @Override
+                                        public void onSuccess(RealmResults<AllTypes> sortedList) {
+                                            try {
+                                                assertEquals(10, sortedList.size());
+                                                assertEquals(9, sortedList.first().getColumnLong());
+                                                assertEquals(0, sortedList.last().getColumnLong());
+
+
+                                            } catch (AssertionFailedError e) {
+                                                threadAssertionError[0] = e;
+
+                                            } finally {
+                                                // whatever happened, make sure to notify the waiting TestCase Thread
+                                                signalCallbackFinished.countDown();
+                                            }
+                                        }
+
+                                        @Override
+                                        public void onError(Exception t) {
+                                            try {
+                                                threadAssertionError[0] = t;
+                                                t.printStackTrace();
+                                            } finally {
+                                                signalCallbackFinished.countDown();
+                                            }
+                                        }
+                                    });
+
+                    Looper.loop();
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+                } finally {
+                    if (signalCallbackFinished.getCount() > 0) {
+                        signalCallbackFinished.countDown();
+                    }
+                    if (realm != null) {
+                        realm.close();
+                    }
+                }
+            }
+        });
+
+        // wait until the callback of our async query proceed
+        signalCallbackFinished.await();
+        looper[0].quit();
+        executorService.shutdownNow();
+        if (null != threadAssertionError[0]) {
+            // throw any assertion errors happened in the background thread
+            throw threadAssertionError[0];
+        }
+    }
+
+    public void testFindAllSorted_converge_3_retries() throws Throwable {
+        setDebugModeForAsyncRealmQuery(ADVANCE_THREE_READ, RetryPolicy.MODE_MAX_RETRY, ADVANCE_THREE_READ);
+        final CountDownLatch signalCallbackFinished = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                Realm realm = null;
+                try {
+                    realm = openRealmInstance("test_find_all_sorted_converge_3_retries");
+                    realm.beginTransaction();
+                    for (int i = 0; i < 10; i++) {
+                        AllTypes allTypes = realm.createObject(AllTypes.class);
+                        allTypes.setColumnLong(i);
+                        allTypes.setColumnString("data " + i % 3);
+                    }
+                    realm.commitTransaction();
+
+                    realm.where(AllTypes.class)
+                            .findAllSorted("columnLong",
+                                    RealmResults.SORT_ORDER_ASCENDING,
+                                    new RealmResults.DebugRealmResultsQueryCallback<AllTypes>() {
+
+                                        @Override
+                                        public void onSuccess(RealmResults<AllTypes> sortedList) {
+                                            try {
+                                                assertEquals(10, sortedList.size());
+                                                assertEquals(0, sortedList.first().getColumnLong());
+                                                assertEquals(9, sortedList.last().getColumnLong());
+
+
+                                            } catch (AssertionFailedError e) {
+                                                threadAssertionError[0] = e;
+
+                                            } finally {
+                                                // whatever happened, make sure to notify the waiting TestCase Thread
+                                                signalCallbackFinished.countDown();
+                                            }
+                                        }
+
+                                        @Override
+                                        public void onError(Exception t) {
+                                            try {
+                                                threadAssertionError[0] = t;
+                                                t.printStackTrace();
+                                            } finally {
+                                                signalCallbackFinished.countDown();
+                                            }
+                                        }
+
+                                        @Override
+                                        public void onBackgroundQueryCompleted(Realm realm) {
+                                            // triggered on the background thread to alter the caller's Realm state
+                                            realm.executeTransaction(new Realm.Transaction() {
+                                                @Override
+                                                public void execute(Realm realm) {
+                                                    realm.createObject(Owner.class);
+                                                    realm.createObject(Dog.class);
+                                                }
+                                            });
+                                        }
+
+                                    });
+
+                    Looper.loop();// ready to receive callback
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+                } finally {
+                    if (signalCallbackFinished.getCount() > 0) {
+                        signalCallbackFinished.countDown();
+                    }
+                    if (realm != null) {
+                        realm.close();
+                    }
+                }
+            }
+        });
+
+        // wait until the callback of our async query proceed
+        signalCallbackFinished.await();
+        looper[0].quit();
+        executorService.shutdownNow();
+        if (null != threadAssertionError[0]) {
+            // throw any assertion errors happened in the background thread
+            throw threadAssertionError[0];
+        }
+    }
+
+
+    public void testFindAllSorted_fail_no_retry() throws Throwable {
+        setDebugModeForAsyncRealmQuery(ADVANCE_ONE_READ, RetryPolicy.MODE_NO_RETRY, NO_RETRY);
+        final CountDownLatch signalCallbackFinished = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                Realm realm = null;
+                try {
+                    realm = openRealmInstance("test_find_all_sorted_no_retry");
+                    realm.beginTransaction();
+                    for (int i = 0; i < 10; i++) {
+                        AllTypes allTypes = realm.createObject(AllTypes.class);
+                        allTypes.setColumnLong(i);
+                        allTypes.setColumnString("data " + i % 3);
+                    }
+                    realm.commitTransaction();
+
+                    realm.where(AllTypes.class)
+                            .findAllSorted("columnLong",
+                                    RealmResults.SORT_ORDER_DESCENDING,
+                                    new RealmResults.DebugRealmResultsQueryCallback<AllTypes>() {
+                                        @Override
+                                        public void onSuccess(RealmResults<AllTypes> result) {
+                                            signalCallbackFinished.countDown();
+                                        }
+
+                                        @Override
+                                        public void onError(Exception t) {
+                                            try {
+                                                threadAssertionError[0] = t;
+                                                t.printStackTrace();
+                                            } finally {
+                                                signalCallbackFinished.countDown();
+                                            }
+                                        }
+
+                                        @Override
+                                        public void onBackgroundQueryCompleted(Realm realm) {
+                                            // triggered on the background thread to alter the caller's Realm state
+                                            realm.executeTransaction(new Realm.Transaction() {
+                                                @Override
+                                                public void execute(Realm realm) {
+                                                    realm.createObject(Owner.class);
+                                                    realm.createObject(Dog.class);
+                                                }
+                                            });
+                                        }
+                                    });
+
+                    Looper.loop();
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+                } finally {
+                    if (signalCallbackFinished.getCount() > 0) {
+                        signalCallbackFinished.countDown();
+                    }
+                    if (realm != null) {
+                        realm.close();
+                    }
+                }
+            }
+        });
+
+        // wait until the callback of our async query proceed
+        signalCallbackFinished.await();
+        looper[0].quit();
+        executorService.shutdownNow();
+        if (null == threadAssertionError[0] || !(threadAssertionError[0] instanceof RealmException)) {
+            fail("Expecting RuntimeException: Unspecified exception." +
+                    " Handover failed due to version mismatch in io_realm_internal_TableQuery.cpp");
+        }
+    }
+
+
+    public void testFindAllSortedMulti_converge_after_100_retries() throws Throwable {
+        setDebugModeForAsyncRealmQuery(ADVANCE_HUNDRED_READ, RetryPolicy.MODE_INDEFINITELY, RETRY_NUMBER_NOT_APPLICABLE);
+        final CountDownLatch signalCallbackFinished = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                Realm realm = null;
+                try {
+                    realm = openRealmInstance("test_find_all_sorted_multi_100_retries");
+                    realm.beginTransaction();
+                    for (int i = 0; i < 5;) {
+                        AllTypes allTypes = realm.createObject(AllTypes.class);
+                        allTypes.setColumnLong(i);
+                        allTypes.setColumnString("data " + i % 3);
+
+                        allTypes = realm.createObject(AllTypes.class);
+                        allTypes.setColumnLong(i);
+                        allTypes.setColumnString("data " + (++i  % 3));
+                    }
+                    realm.commitTransaction();
+
+                    realm.where(AllTypes.class)
+                            .findAllSorted(new String[]{"columnLong", "columnString"},
+                                    new boolean[]{RealmResults.SORT_ORDER_DESCENDING, RealmResults.SORT_ORDER_ASCENDING},
+                                    new RealmResults.DebugRealmResultsQueryCallback<AllTypes>() {
+                                        @Override
+                                        public void onSuccess(RealmResults<AllTypes> sortedList) {
+                                            try {
+                                                assertEquals(10, sortedList.size());
+                                                assertEquals(4, sortedList.first().getColumnLong());
+                                                assertEquals(0, sortedList.last().getColumnLong());
+
+                                                assertEquals(4, sortedList.get(0).getColumnLong());
+                                                assertEquals("data 1", sortedList.get(0).getColumnString());
+                                                assertEquals(4, sortedList.get(1).getColumnLong());
+                                                assertEquals("data 2", sortedList.get(1).getColumnString());
+
+                                                assertEquals(3, sortedList.get(2).getColumnLong());
+                                                assertEquals("data 0", sortedList.get(2).getColumnString());
+                                                assertEquals(3, sortedList.get(3).getColumnLong());
+                                                assertEquals("data 1", sortedList.get(3).getColumnString());
+
+                                                assertEquals(2, sortedList.get(4).getColumnLong());
+                                                assertEquals("data 0", sortedList.get(4).getColumnString());
+                                                assertEquals(2, sortedList.get(5).getColumnLong());
+                                                assertEquals("data 2", sortedList.get(5).getColumnString());
+
+                                                assertEquals(1, sortedList.get(6).getColumnLong());
+                                                assertEquals("data 1", sortedList.get(6).getColumnString());
+                                                assertEquals(1, sortedList.get(7).getColumnLong());
+                                                assertEquals("data 2", sortedList.get(7).getColumnString());
+
+                                                assertEquals(0, sortedList.get(8).getColumnLong());
+                                                assertEquals("data 0", sortedList.get(8).getColumnString());
+                                                assertEquals(0, sortedList.get(9).getColumnLong());
+                                                assertEquals("data 1", sortedList.get(9).getColumnString());
+
+                                            } catch (AssertionFailedError e) {
+                                                threadAssertionError[0] = e;
+
+                                            } finally {
+                                                // whatever happened, make sure to notify the waiting TestCase Thread
+                                                signalCallbackFinished.countDown();
+                                            }
+                                        }
+
+                                        @Override
+                                        public void onError(Exception t) {
+                                            try {
+                                                threadAssertionError[0] = t;
+                                                t.printStackTrace();
+                                            } finally {
+                                                signalCallbackFinished.countDown();
+                                            }
+                                        }
+
+                                        @Override
+                                        public void onBackgroundQueryCompleted(Realm realm) {
+                                            // triggered on the background thread to alter the caller's Realm state
+                                            realm.executeTransaction(new Realm.Transaction() {
+                                                @Override
+                                                public void execute(Realm realm) {
+                                                    realm.createObject(Owner.class);
+                                                    realm.createObject(Dog.class);
+                                                }
+                                            });
+                                        }
+                                    });
+
+                    Looper.loop();
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+                } finally {
+                    if (signalCallbackFinished.getCount() > 0) {
+                        signalCallbackFinished.countDown();
+                    }
+                    if (realm != null) {
+                        realm.close();
+                    }
+                }
+            }
+        });
+
+        // wait until the callback of our async query proceed
+        signalCallbackFinished.await();
+        looper[0].quit();
+        executorService.shutdownNow();
+        if (null != threadAssertionError[0]) {
+            throw threadAssertionError[0];
+        }
+    }
+
+    public void testFindAllMultiSorted() throws Throwable {
+        setDebugModeForAsyncRealmQuery(NO_ADVANCED_READ, RetryPolicy.MODE_NO_RETRY, NO_RETRY);
+        final CountDownLatch signalCallbackFinished = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                Realm realm = null;
+                try {
+                    realm = openRealmInstance("test_find_all_sorted_multi");
+                    realm.beginTransaction();
+                    for (int i = 0; i < 5;) {
+                        AllTypes allTypes = realm.createObject(AllTypes.class);
+                        allTypes.setColumnLong(i);
+                        allTypes.setColumnString("data " + i % 3);
+
+                        allTypes = realm.createObject(AllTypes.class);
+                        allTypes.setColumnLong(i);
+                        allTypes.setColumnString("data " + (++i  % 3));
+                    }
+                    realm.commitTransaction();
+
+                    realm.where(AllTypes.class)
+                            .findAllSorted(new String[]{"columnLong", "columnString"},
+                                    new boolean[]{RealmResults.SORT_ORDER_DESCENDING, RealmResults.SORT_ORDER_ASCENDING},
+                    new RealmResults.QueryCallback<AllTypes>() {
+
+                        @Override
+                        public void onSuccess(RealmResults<AllTypes> sortedList) {
+                            try {
+                                assertEquals(10, sortedList.size());
+                                assertEquals(4, sortedList.first().getColumnLong());
+                                assertEquals(0, sortedList.last().getColumnLong());
+
+                                assertEquals(4, sortedList.get(0).getColumnLong());
+                                assertEquals("data 1", sortedList.get(0).getColumnString());
+                                assertEquals(4, sortedList.get(1).getColumnLong());
+                                assertEquals("data 2", sortedList.get(1).getColumnString());
+
+                                assertEquals(3, sortedList.get(2).getColumnLong());
+                                assertEquals("data 0", sortedList.get(2).getColumnString());
+                                assertEquals(3, sortedList.get(3).getColumnLong());
+                                assertEquals("data 1", sortedList.get(3).getColumnString());
+
+                                assertEquals(2, sortedList.get(4).getColumnLong());
+                                assertEquals("data 0", sortedList.get(4).getColumnString());
+                                assertEquals(2, sortedList.get(5).getColumnLong());
+                                assertEquals("data 2", sortedList.get(5).getColumnString());
+
+                                assertEquals(1, sortedList.get(6).getColumnLong());
+                                assertEquals("data 1", sortedList.get(6).getColumnString());
+                                assertEquals(1, sortedList.get(7).getColumnLong());
+                                assertEquals("data 2", sortedList.get(7).getColumnString());
+
+                                assertEquals(0, sortedList.get(8).getColumnLong());
+                                assertEquals("data 0", sortedList.get(8).getColumnString());
+                                assertEquals(0, sortedList.get(9).getColumnLong());
+                                assertEquals("data 1", sortedList.get(9).getColumnString());
+
+                            } catch (AssertionFailedError e) {
+                                threadAssertionError[0] = e;
+
+                            } finally {
+                                // whatever happened, make sure to notify the waiting TestCase Thread
+                                signalCallbackFinished.countDown();
+                            }
+                        }
+
+                        @Override
+                        public void onError(Exception t) {
+                            try {
+                                threadAssertionError[0] = t;
+                                t.printStackTrace();
+                            } finally {
+                                signalCallbackFinished.countDown();
+                            }
+                        }
+                    });
+
+                    Looper.loop();// ready to receive callback
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+                } finally {
+                    if (signalCallbackFinished.getCount() > 0) {
+                        signalCallbackFinished.countDown();
+                    }
+                    if (realm != null) {
+                        realm.close();
+                    }
+                }
+            }
+        });
+
+        // wait until the callback of our async query proceed
+        signalCallbackFinished.await();
+        looper[0].quit();
+        executorService.shutdownNow();
+        if (null != threadAssertionError[0]) {
+            // throw any assertion errors happened in the background thread
+            throw threadAssertionError[0];
+        }
+    }
+
+    // *** Async write transaction *** //
+
+    public void testAsyncWriteTransaction() throws Throwable {
+        final CountDownLatch signalCallbackFinished = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final Realm[] realm = new Realm[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                try {
+                    realm[0] = openRealmInstance("test_async_write_transaction");
+                    realm[0].executeTransaction(new Realm.Transaction() {
+                        @Override
+                        public void execute(Realm realm) {
+                            Owner owner = realm.createObject(Owner.class);
+                            owner.setName("Owner");
+                        }
+                    }, new Realm.Transaction.Callback() {
+                        @Override
+                        public void onSuccess() {
+                            try {
+                                assertEquals(1, realm[0].allObjects(Owner.class).size());
+                                assertEquals("Owner", realm[0].where(Owner.class).findFirst().getName());
+                            } catch (AssertionFailedError e) {
+                                threadAssertionError[0] = e;
+
+                            } finally {
+                                signalCallbackFinished.countDown();
+                            }
+                        }
+
+                        @Override
+                        public void onError(Throwable e) {
+                            signalCallbackFinished.countDown();
+                        }
+                    });
+
+                    Looper.loop();
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+
+                } finally {
+                    if (signalCallbackFinished.getCount() > 0) {
+                        signalCallbackFinished.countDown();
+                    }
+                    if (realm.length > 0 && realm[0] != null) {
+                        realm[0].close();
+                    }
+                }
+            }
+        });
+
+        // wait until the callback of our async query proceed
+        signalCallbackFinished.await();
+        looper[0].quit();
+        executorService.shutdownNow();
+        if (null != threadAssertionError[0]) {
+            // throw any assertion errors happened in the background thread
+            throw threadAssertionError[0];
+        }
+    }
+
+    public void testCancelAsyncWriteTransaction() throws Throwable {
+        final CountDownLatch signalTransactionStarted = new CountDownLatch(1);
+        final Looper[] looper = new Looper[1];
+        final Realm[] realm = new Realm[1];
+        final RealmQuery.Request[] request = new RealmQuery.Request[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                try {
+                    realm[0] = openRealmInstance("test_cancel_async_write_transaction");
+                    request[0] = realm[0].executeTransaction(new Realm.Transaction() {
+                        @Override
+                        public void execute(Realm realm) {
+                            signalTransactionStarted.countDown();
+                            for (int i = 0; i < 10000; i++) {
+                                Owner owner = realm.createObject(Owner.class);
+                                owner.setName("Owner " + i);
+                            }
+                            SystemClock.sleep(100);
+
+                        }
+                    }, new Realm.Transaction.Callback() {
+                        @Override
+                        public void onSuccess() {
+                            threadAssertionError[0] = new AssertionFailedError("Transaction should not be completed");
+                        }
+
+                        @Override
+                        public void onError(Throwable e) {
+                            threadAssertionError[0] = new AssertionFailedError("Transaction should not call onError");
+                            e.printStackTrace();
+                        }
+                    });
+
+                    Looper.loop();
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+
+                } finally {
+                    if (signalTransactionStarted.getCount() > 0) {
+                        signalTransactionStarted.countDown();
+                    }
+                    if (realm.length > 0 && realm[0] != null) {
+                        realm[0].close();
+                    }
+                }
+            }
+        });
+
+        // wait until the async transaction starts
+        signalTransactionStarted.await();
+        request[0].cancel();
+        executorService.shutdown();
+        executorService.awaitTermination(5, TimeUnit.SECONDS);
+
+        assertTrue(request[0].isCancelled());
+        // nothing was committed
+        Realm ownerRealm = Realm.getInstance(realm[0].getConfiguration());
+        assertEquals(0, ownerRealm.allObjects(Owner.class).size());
+        ownerRealm.close();
+
+        looper[0].quit();
+        executorService.shutdownNow();
+        if (null != threadAssertionError[0]) {
+            // throw any assertion errors happened in the background thread
+            throw threadAssertionError[0];
+        }
+    }
+
+    // *** Helper methods ***
+
+    // This could be done from #setUp but then we can't control
+    // which Looper we want to associate this Realm instance with
+    private Realm openRealmInstance(String name) {
+        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder(getInstrumentation().getTargetContext())
+                .name(name)
+                .deleteRealmIfMigrationNeeded()
+                .build();
+        Realm.deleteRealm(realmConfiguration);
+        return Realm.getInstance(realmConfiguration);
+    }
+
+    private void populateTestRealm(final Realm testRealm, int objects) {
+        testRealm.beginTransaction();
+        testRealm.allObjects(AllTypes.class).clear();
+        testRealm.allObjects(NonLatinFieldNames.class).clear();
+        for (int i = 0; i < objects; ++i) {
+            AllTypes allTypes = testRealm.createObject(AllTypes.class);
+            allTypes.setColumnBoolean((i % 3) == 0);
+            allTypes.setColumnBinary(new byte[]{1, 2, 3});
+            allTypes.setColumnDate(new Date());
+            allTypes.setColumnDouble(3.1415);
+            allTypes.setColumnFloat(1.234567f + i);
+            allTypes.setColumnString("test data " + i);
+            allTypes.setColumnLong(i);
+            NonLatinFieldNames nonLatinFieldNames = testRealm.createObject(NonLatinFieldNames.class);
+            nonLatinFieldNames.set(i);
+            nonLatinFieldNames.set(i);
+            nonLatinFieldNames.set(1.234567f + i);
+            nonLatinFieldNames.set(1.234567f + i);
+        }
+        testRealm.commitTransaction();
+        testRealm.refresh();
+    }
+
+    // we could have avoided using reflection to inject this behaviour if we were using a DI
+    private void setDebugModeForAsyncRealmQuery(int numberOfAdvancedReadSimulation, int retryPolicyMode, int maxNumberOfRetries) {
+        try {
+            Field debugFlagField = RealmQuery.class.getDeclaredField("IS_DEBUG");
+            Field nbAdvancedReadSimulationField = RealmQuery.class.getDeclaredField("NB_ADVANCE_READ_SIMULATION");
+            Field nbNumberRetriesPolicyField = RealmQuery.class.getDeclaredField("MAX_NUMBER_RETRIES_POLICY");
+            Field retryPolicyModeField = RealmQuery.class.getDeclaredField("RETRY_POLICY_MODE");
+
+            debugFlagField.setAccessible(true);
+            nbAdvancedReadSimulationField.setAccessible(true);
+            nbNumberRetriesPolicyField.setAccessible(true);
+            retryPolicyModeField.setAccessible(true);
+
+            if (numberOfAdvancedReadSimulation > 0) {
+                debugFlagField.set(null, true);
+                nbAdvancedReadSimulationField.set(null, numberOfAdvancedReadSimulation);
+                nbNumberRetriesPolicyField.set(null, maxNumberOfRetries);
+                retryPolicyModeField.set(null, retryPolicyMode);
+
+            } else {// reset to defaults
+                debugFlagField.set(null, false);
+                nbAdvancedReadSimulationField.set(null, 0);
+                nbNumberRetriesPolicyField.set(null, 0);
+                retryPolicyModeField.set(null, RetryPolicy.MODE_INDEFINITELY);
+            }
+
+        } catch (NoSuchFieldException e) {
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/RealmQueryTest.java b/realm/src/androidTest/java/io/realm/RealmQueryTest.java
index 4c96b96e33..bcda937de8 100644
--- a/realm/src/androidTest/java/io/realm/RealmQueryTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmQueryTest.java
@@ -351,7 +351,6 @@ public void testRealmQueryLink() {
         assertEquals(dog1, dog);
     }
 
-
     public void testSortMultiFailures() {
         // zero fields specified
         try {
@@ -370,7 +369,7 @@ public void testSortMultiFailures() {
 
         // null is not allowed
         try {
-            RealmResults<AllTypes> results = testRealm.where(AllTypes.class).findAllSorted(null, null);
+            RealmResults<AllTypes> results = testRealm.where(AllTypes.class).findAllSorted((String[]) null, null);
             fail();
         } catch (IllegalArgumentException ignored) {}
         try {
diff --git a/realm/src/androidTest/java/io/realm/RealmTest.java b/realm/src/androidTest/java/io/realm/RealmTest.java
index c6c174c3a9..ff0405a397 100644
--- a/realm/src/androidTest/java/io/realm/RealmTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmTest.java
@@ -254,10 +254,10 @@ public void testShouldRemoveRow() {
         assertEquals(TEST_DATA_SIZE - 1, resultList.size());
     }
 
-    // <E extends RealmObject> E get(Class<E> clazz, long rowIndex)
+    // <E extends RealmObject> E getByIndex(Class<E> clazz, long rowIndex)
     public void testShouldGetObject() {
         populateTestRealm();
-        AllTypes allTypes = testRealm.get(AllTypes.class, 0);
+        AllTypes allTypes = testRealm.getByIndex(AllTypes.class, 0);
         assertNotNull(allTypes);
         assertEquals("test data 0", allTypes.getColumnString());
     }
@@ -396,7 +396,7 @@ public void testQueriesFailWithNullQueryValue() throws IOException {
     public void testShouldReturnTableOrViewList() {
         populateTestRealm();
         RealmResults<AllTypes> resultList = testRealm.allObjects(AllTypes.class);
-        assertEquals("Realm.get is returning wrong result set", TEST_DATA_SIZE, resultList.size());
+        assertEquals("Realm.getByIndex is returning wrong result set", TEST_DATA_SIZE, resultList.size());
     }
 
     public void testAllObjectsSorted() {
@@ -611,7 +611,10 @@ public void testCancelTransaction() {
 
 
     public void testExecuteTransactionNull() {
-        testRealm.executeTransaction(null); // Nothing happens
+        try {
+            testRealm.executeTransaction(null);
+            fail("null transaction should throw");
+        } catch (IllegalArgumentException ignore) {}
         assertFalse(testRealm.hasChanged());
     }
 
diff --git a/realm/src/androidTest/java/io/realm/internal/JNILinkTest.java b/realm/src/androidTest/java/io/realm/internal/JNILinkTest.java
index 74b4c85a2d..573111b118 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNILinkTest.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNILinkTest.java
@@ -59,7 +59,7 @@ public void testLinkList() {
 
         table2.insertLinkList(0,0);
 
-        LinkView links = table2.getUncheckedRow(0).getLinkList(0);
+        LinkView links = table2.getUncheckedRowByIndex(0).getLinkList(0);
 
         assertEquals(links.isEmpty(), true);
         assertEquals(links.size(), 0);
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIRowTest.java b/realm/src/androidTest/java/io/realm/internal/JNIRowTest.java
index 7fac06aff1..bab5cd0514 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIRowTest.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNIRowTest.java
@@ -26,7 +26,7 @@ public void testRow() {
         table.add("abc", 3, (float) 1.2, 1.3, true, new Date(0), data);
 
 
-        UncheckedRow row = table.getUncheckedRow(0);
+        UncheckedRow row = table.getUncheckedRowByIndex(0);
 
         assertEquals("abc", row.getString(0));
         assertEquals(3, row.getLong(1));
@@ -63,12 +63,12 @@ public void testMixed() {
 
         table.addEmptyRows(2);
 
-        UncheckedRow row = table.getUncheckedRow(0);
+        UncheckedRow row = table.getUncheckedRowByIndex(0);
         row.setMixed(0, new Mixed(1.5));
 
         assertEquals(1.5, row.getMixed(0).getDoubleValue());
 
-        UncheckedRow row2 = table.getUncheckedRow(1);
+        UncheckedRow row2 = table.getUncheckedRowByIndex(1);
         row2.setMixed(0, new Mixed("test"));
 
         assertEquals("test", row2.getMixed(0).getStringValue());
diff --git a/realm/src/androidTest/java/io/realm/internal/JNITransactions.java b/realm/src/androidTest/java/io/realm/internal/JNITransactions.java
index a406446225..8ccf50b926 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNITransactions.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNITransactions.java
@@ -369,14 +369,14 @@ public void testAddEmptyRowWithPrimaryKeyString() {
         Table t = getTableWithStringPrimaryKey();
         long rowIndex = t.addEmptyRowWithPrimaryKey("Foo");
         assertEquals(1, t.size());
-        assertEquals("Foo", t.getUncheckedRow(rowIndex).getString(0));
+        assertEquals("Foo", t.getUncheckedRowByIndex(rowIndex).getString(0));
     }
 
     public void testAddEmptyRowWithPrimaryKeyLong() {
         Table t = getTableWithIntegerPrimaryKey();
         long rowIndex = t.addEmptyRowWithPrimaryKey(42);
         assertEquals(1, t.size());
-        assertEquals(42, t.getUncheckedRow(rowIndex).getLong(0));
+        assertEquals(42, t.getUncheckedRowByIndex(rowIndex).getLong(0));
     }
 
     public void testPrimaryKeyTableMigration() throws IOException {
diff --git a/realm/src/main/java/io/realm/Realm.java b/realm/src/main/java/io/realm/Realm.java
index 9797e52229..df0dd8ca60 100644
--- a/realm/src/main/java/io/realm/Realm.java
+++ b/realm/src/main/java/io/realm/Realm.java
@@ -24,6 +24,7 @@
 import android.os.Message;
 import android.util.JsonReader;
 
+import org.jetbrains.annotations.Nullable;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -45,6 +46,9 @@
 import java.util.Scanner;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.exceptions.RealmException;
@@ -146,6 +150,9 @@
     private static final Map<String, AtomicInteger> globalOpenInstanceCounter =
             new ConcurrentHashMap<String, AtomicInteger>();
 
+    // Thread Pool for all async operations (Query & Write transaction)
+    public static final ExecutorService asyncQueryExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2 + 1);
+
     protected static final Map<Handler, String> handlers = new ConcurrentHashMap<Handler, String>();
     private static final int REALM_CHANGED = 14930352; // Hopefully it won't clash with other message IDs.
 
@@ -935,7 +942,7 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
     public <E extends RealmObject> E createObject(Class<E> clazz) {
         Table table = getTable(clazz);
         long rowIndex = table.addEmptyRow();
-        return get(clazz, rowIndex);
+        return getByIndex(clazz, rowIndex);
     }
 
     /**
@@ -951,16 +958,25 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
     <E extends RealmObject> E createObject(Class<E> clazz, Object primaryKeyValue) {
         Table table = getTable(clazz);
         long rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
-        return get(clazz, rowIndex);
+        return getByIndex(clazz, rowIndex);
     }
 
     void remove(Class<? extends RealmObject> clazz, long objectIndex) {
         getTable(clazz).moveLastOver(objectIndex);
     }
 
-    <E extends RealmObject> E get(Class<E> clazz, long rowIndex) {
+    <E extends RealmObject> E getByIndex(Class<E> clazz, long rowIndex) {
         Table table = getTable(clazz);
-        UncheckedRow row = table.getUncheckedRow(rowIndex);
+        UncheckedRow row = table.getUncheckedRowByIndex(rowIndex);
+        E result = configuration.getSchemaMediator().newInstance(clazz);
+        result.row = row;
+        result.realm = this;
+        return result;
+    }
+
+    <E extends RealmObject> E getByPointer(Class<E> clazz, long nativeRowPointer) {
+        Table table = getTable(clazz);
+        UncheckedRow row = table.getUncheckedRowByPointer(nativeRowPointer);
         E result = configuration.getSchemaMediator().newInstance(clazz);
         result.row = row;
         result.realm = this;
@@ -1370,7 +1386,8 @@ public void cancelTransaction() {
      */
     public void executeTransaction(Transaction transaction) {
         if (transaction == null)
-            return;
+            throw new IllegalArgumentException("transaction should not be null");
+
         beginTransaction();
         try {
             transaction.execute(this);
@@ -1384,6 +1401,78 @@ public void executeTransaction(Transaction transaction) {
         }
     }
 
+    /**
+     * Similar to {@link #executeTransaction(Transaction)} but runs asynchronously from a worker thread
+     * @param transaction {@link io.realm.Realm.Transaction} to execute.
+     * @param callback optional, to receive the result of this query
+     * @return A {@link io.realm.RealmQuery.Request} representing a cancellable task
+     */
+    public RealmQuery.Request executeTransaction(final Transaction transaction, @Nullable final Transaction.Callback callback) {
+        if (transaction == null)
+            throw new IllegalArgumentException("transaction should not be null");
+
+        // will use the Looper of the caller thread to post the result
+        final Handler handler = new Handler();
+
+        // We need to use the same configuration to open a background SharedGroup (i.e Realm)
+        // to perform the transaction
+        final RealmConfiguration realmConfiguration = getConfiguration();
+
+        final Future<?> pendingQuery = asyncQueryExecutor.submit(new Runnable() {
+            @Override
+            public void run() {
+                android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+
+                if (!Thread.currentThread().isInterrupted()) {
+                    Realm bgRealm = Realm.getInstance(realmConfiguration);
+                    bgRealm.beginTransaction();
+                    try {
+                        transaction.execute(bgRealm);
+
+                        if (!Thread.currentThread().isInterrupted()) {
+                            bgRealm.commitTransaction();
+                            if (callback != null) {
+                                handler.post(new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        callback.onSuccess();
+                                    }
+                                });
+                            }
+                        } else {
+                            bgRealm.cancelTransaction();
+                        }
+
+                    } catch (final RuntimeException e) {
+                        bgRealm.cancelTransaction();
+                        if (callback != null && !Thread.currentThread().isInterrupted()) {
+                            handler.post(new Runnable() {
+                                @Override
+                                public void run() {
+                                    callback.onError(e);
+                                }
+                            });
+                        }
+                    } catch (final Error e) {
+                        bgRealm.cancelTransaction();
+                        if (callback != null && !Thread.currentThread().isInterrupted()) {
+                            handler.post(new Runnable() {
+                                @Override
+                                public void run() {
+                                    callback.onError(e);
+                                }
+                            });
+                        }
+                    } finally {
+                        bgRealm.close();
+                    }
+                }
+            }
+        });
+
+        return new RealmQuery.Request(pendingQuery);
+    }
+
     /**
      * Remove all objects of the specified class.
      *
@@ -1636,6 +1725,23 @@ public static Object getDefaultModule() {
      */
     public interface Transaction {
         void execute(Realm realm);
+
+        /**
+         * Callback invoked after a {#Transaction} call, to notify the caller thread
+         */
+        class Callback {
+            public void onSuccess() {}
+            public void onError(Throwable e) {}
+        }
     }
+    //FIXME Realm.java being the public API and the implementation.
+    //      we need a Realm interface to be able to separate this kind of call
+    //      (mostly from internal API/tests that need to access private field/method).
+    //      RealmImpl will be accessible to other internal packages
+    //      but not to the user (avoid compromising our exposed public API)
+    //
 
+    public long getSharedGroupPointer() {
+        return sharedGroup.getNativePointer();
+    }
 }
diff --git a/realm/src/main/java/io/realm/RealmList.java b/realm/src/main/java/io/realm/RealmList.java
index 0e6dfc400e..0ea70627b1 100644
--- a/realm/src/main/java/io/realm/RealmList.java
+++ b/realm/src/main/java/io/realm/RealmList.java
@@ -262,7 +262,7 @@ public E remove(int location) {
     @Override
     public E get(int location) {
         if (managedMode) {
-            return realm.get(clazz, view.getTargetRowIndex(location));
+            return realm.getByIndex(clazz, view.getTargetRowIndex(location));
         } else {
             return nonManagedList.get(location);
         }
diff --git a/realm/src/main/java/io/realm/RealmObject.java b/realm/src/main/java/io/realm/RealmObject.java
index 3753f8cd82..a274a169d5 100644
--- a/realm/src/main/java/io/realm/RealmObject.java
+++ b/realm/src/main/java/io/realm/RealmObject.java
@@ -124,4 +124,25 @@ protected static Realm getRealm(RealmObject obj) {
     protected static Row getRow(RealmObject obj) {
         return obj.row;
     }
+
+    /**
+     * Encapsulates an async {@link RealmQuery}.
+     * <p>
+     * This will run the {@link RealmQuery} on a worker thread, then invoke this callback on the caller thread
+     */
+    public interface QueryCallback<E extends RealmObject> {
+        void onSuccess (E result);
+        void onError (Exception t);
+    }
+
+    /**
+     * Used for debugging/testing purpose to add any logic (within the caller's thread)
+     * before we return the results
+     */
+    interface DebugRealmObjectQueryCallback<E extends RealmObject> extends RealmObject.QueryCallback<E> {
+        /**
+         * Runs on the caller's thread just before we hand over the result to {@link #onSuccess(RealmObject)}
+         */
+        void onBackgroundQueryCompleted(Realm realm);
+    }
 }
diff --git a/realm/src/main/java/io/realm/RealmQuery.java b/realm/src/main/java/io/realm/RealmQuery.java
index df847f5e69..e3703ef086 100644
--- a/realm/src/main/java/io/realm/RealmQuery.java
+++ b/realm/src/main/java/io/realm/RealmQuery.java
@@ -17,30 +17,43 @@
 package io.realm;
 
 
+import android.annotation.SuppressLint;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Future;
 
+import io.realm.exceptions.RealmException;
 import io.realm.internal.ColumnType;
 import io.realm.internal.LinkView;
 import io.realm.internal.Table;
 import io.realm.internal.TableQuery;
 import io.realm.internal.TableView;
+import io.realm.internal.async.BadVersionException;
+import io.realm.internal.async.RetryPolicy;
+import io.realm.internal.async.RetryPolicyFactory;
+
+import static io.realm.Realm.asyncQueryExecutor;
+
 
 /**
  * A RealmQuery encapsulates a query on a {@link io.realm.Realm} or a {@link io.realm.RealmResults}
  * using the Builder pattern. The query is executed using either {@link #findAll()} or
  * {@link #findFirst()}
- * <p>
+ * <p/>
  * The input to many of the query functions take a field name as String. Note that this is not
  * type safe. If a model class is refactored care has to be taken to not break any queries.
- * <p>
+ * <p/>
  * A {@link io.realm.Realm} is unordered, which means that there is no guarantee that querying a
  * Realm will return the objects in the order they where inserted. Use
  * {@link #findAllSorted(String)} and similar methods if a specific order is required.
- * <p>
+ * <p/>
  * A RealmQuery cannot be passed between different threads.
  *
  * @param <E> The class of the objects to be queried.
@@ -57,16 +70,31 @@
     private Map<String, Long> columns = new HashMap<String, Long>();
     private Class<E> clazz;
 
-    private static final String LINK_NOT_SUPPORTED_METHOD = "'%s' is not supported for link queries";
-
     public static final boolean CASE_SENSITIVE = true;
     public static final boolean CASE_INSENSITIVE = false;
 
+    private Request asyncRequest;
+    private final RetryPolicy retryPolicy;
+    private static int RETRY_POLICY_MODE = RetryPolicy.MODE_INDEFINITELY;
+    private static int MAX_NUMBER_RETRIES_POLICY = 0;
+
+    // sorting properties
+    private String fieldName;
+    private boolean sortAscending;
+    private String[] fieldNames;
+    private boolean[] sortAscendings;
+
+    // native pointers to be released
+    private long handoverQueryPtr = -1;
+    private long handoverRowPtr = -1;
+    private long handoverTableViewPtr = -1;
+
+
     /**
      * Creating a RealmQuery instance.
      *
-     * @param realm  The realm to query within.
-     * @param clazz  The class to query.
+     * @param realm The realm to query within.
+     * @param clazz The class to query.
      * @throws java.lang.RuntimeException Any other error.
      */
     public RealmQuery(Realm realm, Class<E> clazz) {
@@ -75,13 +103,14 @@ public RealmQuery(Realm realm, Class<E> clazz) {
         this.table = realm.getTable(clazz);
         this.query = table.where();
         this.columns = realm.columnIndices.getClassFields(clazz);
+        this.retryPolicy = RetryPolicyFactory.get(RETRY_POLICY_MODE, MAX_NUMBER_RETRIES_POLICY);
     }
 
     /**
      * Create a RealmQuery instance from a @{link io.realm.RealmResults}.
      *
-     * @param realmList   The @{link io.realm.RealmResults} to query
-     * @param clazz       The class to query
+     * @param realmList The @{link io.realm.RealmResults} to query
+     * @param clazz     The class to query
      * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery(RealmResults realmList, Class<E> clazz) {
@@ -90,6 +119,7 @@ public RealmQuery(RealmResults realmList, Class<E> clazz) {
         this.table = realm.getTable(clazz);
         this.query = realmList.getTable().where();
         this.columns = realm.columnIndices.getClassFields(clazz);
+        this.retryPolicy = RetryPolicyFactory.get(RETRY_POLICY_MODE, MAX_NUMBER_RETRIES_POLICY);
     }
 
     RealmQuery(Realm realm, LinkView view, Class<E> clazz) {
@@ -99,6 +129,7 @@ public RealmQuery(RealmResults realmList, Class<E> clazz) {
         this.view = view;
         this.table = realm.getTable(clazz);
         this.columns = realm.columnIndices.getClassFields(clazz);
+        this.retryPolicy = RetryPolicyFactory.get(RETRY_POLICY_MODE, MAX_NUMBER_RETRIES_POLICY);
     }
 
     private boolean containsDot(String s) {
@@ -115,17 +146,17 @@ private boolean containsDot(String s) {
                 n++;
 
         // split at .
-        String[] arr = new String[n+1];
+        String[] arr = new String[n + 1];
         i = 0;
         n = 0;
         j = s.indexOf('.');
         while (j != -1) {
             arr[n] = s.substring(i, j);
-            i = j+1;
+            i = j + 1;
             j = s.indexOf('.', i);
             n++;
         }
-        arr[n] = s.substring(s.lastIndexOf('.')+1);
+        arr[n] = s.substring(s.lastIndexOf('.') + 1);
 
         return arr;
     }
@@ -136,7 +167,7 @@ private boolean containsDot(String s) {
         if (containsDot(fieldName)) {
             String[] names = splitString(fieldName); //fieldName.split("\\.");
             long[] columnIndices = new long[names.length];
-            for (int i = 0; i < names.length-1; i++) {
+            for (int i = 0; i < names.length - 1; i++) {
                 long index = table.getColumnIndex(names[i]);
                 if (index < 0) {
                     throw new IllegalArgumentException("Invalid query: " + names[i] + " does not refer to a class.");
@@ -149,9 +180,9 @@ private boolean containsDot(String s) {
                     throw new IllegalArgumentException("Invalid query: " + names[i] + " does not refer to a class.");
                 }
             }
-            columnIndices[names.length-1] = table.getColumnIndex(names[names.length-1]);
-            if (fieldType != table.getColumnType(columnIndices[names.length-1])) {
-                throw new IllegalArgumentException(String.format("Field '%s': type mismatch.", names[names.length-1]));
+            columnIndices[names.length - 1] = table.getColumnIndex(names[names.length - 1]);
+            if (fieldType != table.getColumnType(columnIndices[names.length - 1])) {
+                throw new IllegalArgumentException(String.format("Field '%s': type mismatch.", names[names.length - 1]));
             }
             return columnIndices;
         } else {
@@ -165,7 +196,7 @@ private boolean containsDot(String s) {
                         fieldName, fieldType, tableColumnType
                 ));
             }
-            return new long[] {columns.get(fieldName)};
+            return new long[]{columns.get(fieldName)};
         }
     }
 
@@ -202,12 +233,13 @@ private boolean containsDot(String s) {
 
     /**
      * Equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> equalTo(String fieldName, String value) {
         return this.equalTo(fieldName, value, CASE_SENSITIVE);
@@ -215,15 +247,15 @@ private boolean containsDot(String s) {
 
     /**
      * Equal-to comparison
-     * @param fieldName   The field to compare
-     * @param value       The value to compare with
+     *
+     * @param fieldName     The field to compare
+     * @param value         The value to compare with
      * @param caseSensitive if true, substring matching is case sensitive. Setting this to false only works for English
      *                      locale characters.
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> equalTo(String fieldName, String value, boolean caseSensitive) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.STRING);
@@ -233,12 +265,13 @@ private boolean containsDot(String s) {
 
     /**
      * Equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> equalTo(String fieldName, int value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
@@ -248,12 +281,13 @@ private boolean containsDot(String s) {
 
     /**
      * Equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> equalTo(String fieldName, long value) {
         long[] columnIndices = getColumnIndices(fieldName, ColumnType.INTEGER);
@@ -263,12 +297,13 @@ private boolean containsDot(String s) {
 
     /**
      * Equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> equalTo(String fieldName, double value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.DOUBLE);
@@ -278,12 +313,13 @@ private boolean containsDot(String s) {
 
     /**
      * Equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> equalTo(String fieldName, float value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.FLOAT);
@@ -293,12 +329,13 @@ private boolean containsDot(String s) {
 
     /**
      * Equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> equalTo(String fieldName, boolean value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.BOOLEAN);
@@ -308,12 +345,13 @@ private boolean containsDot(String s) {
 
     /**
      * Equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> equalTo(String fieldName, Date value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.DATE);
@@ -325,12 +363,13 @@ private boolean containsDot(String s) {
 
     /**
      * Not-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> notEqualTo(String fieldName, String value) {
         return this.notEqualTo(fieldName, value, RealmQuery.CASE_SENSITIVE);
@@ -338,14 +377,15 @@ private boolean containsDot(String s) {
 
     /**
      * Not-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName     The field to compare
+     * @param value         The value to compare with
      * @param caseSensitive if true, substring matching is case sensitive. Setting this to false only works for English
      *                      locale characters.
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> notEqualTo(String fieldName, String value, boolean caseSensitive) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.STRING);
@@ -358,12 +398,13 @@ private boolean containsDot(String s) {
 
     /**
      * Not-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> notEqualTo(String fieldName, int value) {
         long[] columnIndices = getColumnIndices(fieldName, ColumnType.INTEGER);
@@ -373,12 +414,13 @@ private boolean containsDot(String s) {
 
     /**
      * Not-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> notEqualTo(String fieldName, long value) {
         long[] columnIndices = getColumnIndices(fieldName, ColumnType.INTEGER);
@@ -388,12 +430,13 @@ private boolean containsDot(String s) {
 
     /**
      * Not-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> notEqualTo(String fieldName, double value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.DOUBLE);
@@ -403,12 +446,13 @@ private boolean containsDot(String s) {
 
     /**
      * Not-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> notEqualTo(String fieldName, float value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.FLOAT);
@@ -418,12 +462,13 @@ private boolean containsDot(String s) {
 
     /**
      * Not-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> notEqualTo(String fieldName, boolean value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.BOOLEAN);
@@ -433,12 +478,13 @@ private boolean containsDot(String s) {
 
     /**
      * Not-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> notEqualTo(String fieldName, Date value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.DATE);
@@ -450,12 +496,13 @@ private boolean containsDot(String s) {
 
     /**
      * Greater-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> greaterThan(String fieldName, int value) {
         long[] columnIndices = getColumnIndices(fieldName, ColumnType.INTEGER);
@@ -465,12 +512,13 @@ private boolean containsDot(String s) {
 
     /**
      * Greater-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> greaterThan(String fieldName, long value) {
         long[] columnIndices = getColumnIndices(fieldName, ColumnType.INTEGER);
@@ -480,12 +528,13 @@ private boolean containsDot(String s) {
 
     /**
      * Greater-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> greaterThan(String fieldName, double value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.DOUBLE);
@@ -495,12 +544,13 @@ private boolean containsDot(String s) {
 
     /**
      * Greater-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> greaterThan(String fieldName, float value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.FLOAT);
@@ -510,12 +560,13 @@ private boolean containsDot(String s) {
 
     /**
      * Greater-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> greaterThan(String fieldName, Date value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.DATE);
@@ -525,12 +576,13 @@ private boolean containsDot(String s) {
 
     /**
      * Greater-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, int value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
@@ -540,12 +592,13 @@ private boolean containsDot(String s) {
 
     /**
      * Greater-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, long value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
@@ -555,12 +608,13 @@ private boolean containsDot(String s) {
 
     /**
      * Greater-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, double value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.DOUBLE);
@@ -570,12 +624,13 @@ private boolean containsDot(String s) {
 
     /**
      * Greater-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, float value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.FLOAT);
@@ -585,12 +640,13 @@ private boolean containsDot(String s) {
 
     /**
      * Greater-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, Date value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.DATE);
@@ -602,12 +658,13 @@ private boolean containsDot(String s) {
 
     /**
      * Less-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> lessThan(String fieldName, int value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
@@ -617,12 +674,13 @@ private boolean containsDot(String s) {
 
     /**
      * Less-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> lessThan(String fieldName, long value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
@@ -632,12 +690,13 @@ private boolean containsDot(String s) {
 
     /**
      * Less-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> lessThan(String fieldName, double value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.DOUBLE);
@@ -647,12 +706,13 @@ private boolean containsDot(String s) {
 
     /**
      * Less-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> lessThan(String fieldName, float value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.FLOAT);
@@ -662,12 +722,13 @@ private boolean containsDot(String s) {
 
     /**
      * Less-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> lessThan(String fieldName, Date value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.DATE);
@@ -677,12 +738,13 @@ private boolean containsDot(String s) {
 
     /**
      * Less-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, int value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
@@ -692,12 +754,13 @@ private boolean containsDot(String s) {
 
     /**
      * Less-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, long value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
@@ -707,12 +770,13 @@ private boolean containsDot(String s) {
 
     /**
      * Less-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, double value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.DOUBLE);
@@ -722,12 +786,13 @@ private boolean containsDot(String s) {
 
     /**
      * Less-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, float value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.FLOAT);
@@ -737,12 +802,13 @@ private boolean containsDot(String s) {
 
     /**
      * Less-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
+     *
+     * @param fieldName The field to compare
+     * @param value     The value to compare with
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, Date value) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.DATE);
@@ -754,13 +820,14 @@ private boolean containsDot(String s) {
 
     /**
      * Between condition
-     * @param fieldName  The field to compare
-     * @param from       Lowest value (inclusive)
-     * @param to         Highest value (inclusive)
+     *
+     * @param fieldName The field to compare
+     * @param from      Lowest value (inclusive)
+     * @param to        Highest value (inclusive)
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> between(String fieldName, int from, int to) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
@@ -770,13 +837,14 @@ private boolean containsDot(String s) {
 
     /**
      * Between condition
-     * @param fieldName  The field to compare
-     * @param from       Lowest value (inclusive)
-     * @param to         Highest value (inclusive)
+     *
+     * @param fieldName The field to compare
+     * @param from      Lowest value (inclusive)
+     * @param to        Highest value (inclusive)
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> between(String fieldName, long from, long to) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
@@ -786,13 +854,14 @@ private boolean containsDot(String s) {
 
     /**
      * Between condition
-     * @param fieldName  The field to compare
-     * @param from       Lowest value (inclusive)
-     * @param to         Highest value (inclusive)
+     *
+     * @param fieldName The field to compare
+     * @param from      Lowest value (inclusive)
+     * @param to        Highest value (inclusive)
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> between(String fieldName, double from, double to) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.DOUBLE);
@@ -802,13 +871,14 @@ private boolean containsDot(String s) {
 
     /**
      * Between condition
-     * @param fieldName  The field to compare
-     * @param from       Lowest value (inclusive)
-     * @param to         Highest value (inclusive)
+     *
+     * @param fieldName The field to compare
+     * @param from      Lowest value (inclusive)
+     * @param to        Highest value (inclusive)
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> between(String fieldName, float from, float to) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.FLOAT);
@@ -818,13 +888,14 @@ private boolean containsDot(String s) {
 
     /**
      * Between condition
-     * @param fieldName  The field to compare
-     * @param from       Lowest value (inclusive)
-     * @param to         Highest value (inclusive)
+     *
+     * @param fieldName The field to compare
+     * @param from      Lowest value (inclusive)
+     * @param to        Highest value (inclusive)
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> between(String fieldName, Date from, Date to) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.DATE);
@@ -837,12 +908,13 @@ private boolean containsDot(String s) {
 
     /**
      * Condition that value of field contains the specified substring
-     * @param fieldName  The field to compare
-     * @param value      The substring
+     *
+     * @param fieldName The field to compare
+     * @param value     The substring
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> contains(String fieldName, String value) {
         return contains(fieldName, value, CASE_SENSITIVE);
@@ -850,14 +922,15 @@ private boolean containsDot(String s) {
 
     /**
      * Condition that value of field contains the specified substring
-     * @param fieldName  The field to compare
-     * @param value      The substring
+     *
+     * @param fieldName     The field to compare
+     * @param value         The substring
      * @param caseSensitive if true, substring matching is case sensitive. Setting this to false only works for English
      *                      locale characters.
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> contains(String fieldName, String value, boolean caseSensitive) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.STRING);
@@ -867,12 +940,13 @@ private boolean containsDot(String s) {
 
     /**
      * Condition that the value of field begins with the specified string
+     *
      * @param fieldName The field to compare
      * @param value     The string
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> beginsWith(String fieldName, String value) {
         return beginsWith(fieldName, value, CASE_SENSITIVE);
@@ -880,14 +954,15 @@ private boolean containsDot(String s) {
 
     /**
      * Condition that the value of field begins with the specified substring
-     * @param fieldName The field to compare
-     * @param value     The substring
+     *
+     * @param fieldName     The field to compare
+     * @param value         The substring
      * @param caseSensitive if true, substring matching is case sensitive. Setting this to false only works for English
      *                      locale characters.
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> beginsWith(String fieldName, String value, boolean caseSensitive) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.STRING);
@@ -897,12 +972,13 @@ private boolean containsDot(String s) {
 
     /**
      * Condition that the value of field ends with the specified string
+     *
      * @param fieldName The field to compare
      * @param value     The string
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> endsWith(String fieldName, String value) {
         return endsWith(fieldName, value, CASE_SENSITIVE);
@@ -910,14 +986,15 @@ private boolean containsDot(String s) {
 
     /**
      * Condition that the value of field ends with the specified substring
-     * @param fieldName The field to compare
-     * @param value     The substring
+     *
+     * @param fieldName     The field to compare
+     * @param value         The substring
      * @param caseSensitive if true, substring matching is case sensitive. Setting this to false only works for English
      *                      locale characters.
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
+     *                                            field type
+     * @throws java.lang.RuntimeException         Any other error
      */
     public RealmQuery<E> endsWith(String fieldName, String value, boolean caseSensitive) {
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.STRING);
@@ -930,6 +1007,7 @@ private boolean containsDot(String s) {
     /**
      * Begin grouping of conditions ("left parenthesis"). A group must be closed with a
      * call to <code>endGroup()</code>.
+     *
      * @return The query object
      * @see #endGroup()
      */
@@ -941,6 +1019,7 @@ private boolean containsDot(String s) {
     /**
      * End grouping of conditions ("right parenthesis") which was opened by a call to
      * <code>beginGroup()</code>.
+     *
      * @return The query object
      * @see #beginGroup()
      */
@@ -951,6 +1030,7 @@ private boolean containsDot(String s) {
 
     /**
      * Logical-or two conditions
+     *
      * @return The query object
      */
     public RealmQuery<E> or() {
@@ -960,6 +1040,7 @@ private boolean containsDot(String s) {
 
     /**
      * Negate condition.
+     *
      * @return The query object
      */
     public RealmQuery<E> not() {
@@ -973,6 +1054,7 @@ private boolean containsDot(String s) {
 
     /**
      * Calculate the sum of a field
+     *
      * @param fieldName The field name
      * @return The sum
      * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
@@ -984,6 +1066,7 @@ public long sumInt(String fieldName) {
 
     /**
      * Calculate the sum of a field
+     *
      * @param fieldName The field name
      * @return The sum
      * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
@@ -995,6 +1078,7 @@ public double sumDouble(String fieldName) {
 
     /**
      * Calculate the sum of a field
+     *
      * @param fieldName The field name
      * @return The sum
      * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
@@ -1008,6 +1092,7 @@ public double sumFloat(String fieldName) {
 
     /**
      * Calculate the average of a field
+     *
      * @param fieldName The field name
      * @return The average
      * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
@@ -1019,6 +1104,7 @@ public double averageInt(String fieldName) {
 
     /**
      * Calculate the average of a field
+     *
      * @param fieldName The field name
      * @return The average
      * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
@@ -1030,6 +1116,7 @@ public double averageDouble(String fieldName) {
 
     /**
      * Calculate the average of a field
+     *
      * @param fieldName The field name
      * @return The average
      * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
@@ -1043,7 +1130,8 @@ public double averageFloat(String fieldName) {
 
     /**
      * Find the minimum value of a field
-     * @param fieldName  The field name
+     *
+     * @param fieldName The field name
      * @return The minimum value
      * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
@@ -1054,7 +1142,8 @@ public long minimumInt(String fieldName) {
 
     /**
      * Find the minimum value of a field
-     * @param fieldName  The field name
+     *
+     * @param fieldName The field name
      * @return The minimum value
      * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
@@ -1065,7 +1154,8 @@ public double minimumDouble(String fieldName) {
 
     /**
      * Find the minimum value of a field
-     * @param fieldName  The field name
+     *
+     * @param fieldName The field name
      * @return The minimum value
      * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
@@ -1076,7 +1166,8 @@ public float minimumFloat(String fieldName) {
 
     /**
      * Find the minimum value of a field
-     * @param fieldName  The field name
+     *
+     * @param fieldName The field name
      * @return The minimum value
      * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
@@ -1089,7 +1180,8 @@ public Date minimumDate(String fieldName) {
 
     /**
      * Find the maximum value of a field
-     * @param fieldName  The field name
+     *
+     * @param fieldName The field name
      * @return The maximum value
      * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
@@ -1100,7 +1192,8 @@ public long maximumInt(String fieldName) {
 
     /**
      * Find the maximum value of a field
-     * @param fieldName  The field name
+     *
+     * @param fieldName The field name
      * @return The maximum value
      * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
@@ -1111,7 +1204,8 @@ public double maximumDouble(String fieldName) {
 
     /**
      * Find the maximum value of a field
-     * @param fieldName  The field name
+     *
+     * @param fieldName The field name
      * @return The maximum value
      * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
@@ -1122,7 +1216,8 @@ public float maximumFloat(String fieldName) {
 
     /**
      * Find the maximum value of a field
-     * @param fieldName  The field name
+     *
+     * @param fieldName The field name
      * @return The maximum value
      * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
@@ -1148,20 +1243,111 @@ public long count() {
      *
      * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
      * a list with zero objects is returned.
-     * @see io.realm.RealmResults
      * @throws java.lang.RuntimeException Any other error
+     * @see io.realm.RealmResults
      */
     public RealmResults<E> findAll() {
         return new RealmResults<E>(realm, query.findAll(), clazz);
     }
 
     /**
-     * Find all objects that fulfill the query conditions and sorted by specific field name.
+     * Find all objects that fulfill the query conditions.
+     * Results will be posted to the callback instance {@link RealmResults.QueryCallback} asynchronously
      *
+     * @param callback to receive the result of this query
+     * @return A {@link Request} representing a cancellable, pending asynchronous query
+     * @throws java.lang.RuntimeException Any other error
+     * @see io.realm.RealmResults
+     */
+    public Request findAll(final RealmResults.QueryCallback<E> callback) {
+        // will use the Looper of the caller thread to post the result
+        final Handler handler = new EventHandler(callback);
+
+        // We need a pointer to the caller Realm, to be able to handover the result to it
+        final long callerSharedGroupNativePtr = realm.getSharedGroupPointer();
+
+        // Handover the query (to be used by a worker thread)
+        handoverQueryPtr = query.handoverQuery(callerSharedGroupNativePtr);
+
+        // We need to use the same configuration to open a background SharedGroup (i.e Realm)
+        // to perform the query
+        final RealmConfiguration realmConfiguration = realm.getConfiguration();
+
+        Future<?> pendingQuery = asyncQueryExecutor.submit(new Runnable() {
+            @Override
+            public void run() {
+                android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+                if (!Thread.currentThread().isInterrupted() && (asyncRequest == null || !asyncRequest.isCancelled())) {
+                    Realm bgRealm = null;
+
+                    try {
+                        //TODO Once SharedGroup is thread safe, start reusing a cached instance
+                        //     of a worker Realm to avoid the cost of opening/closing a SharedGroup
+                        //     for each query
+                        bgRealm = Realm.getInstance(realmConfiguration);
+
+                        // Run the query & handover the table view for the caller thread
+                        handoverTableViewPtr = query.findAllWithHandover(bgRealm.getSharedGroupPointer(), handoverQueryPtr);
+                        handoverQueryPtr = -1;
+
+                        if (IS_DEBUG && NB_ADVANCE_READ_SIMULATION-- > 0) {
+                            // notify caller thread that we're about to post result to Handler
+                            // (this is relevant in Unit Testing, as we can advance read to simulate
+                            // a mismatch between the query result, and the current version of the Realm
+                            handler.sendMessage(handler.obtainMessage(
+                                    EventHandler.MSG_ADVANCE_READ,
+                                    EventHandler.FIND_ALL_QUERY, 0));
+                        }
+
+                        // send results to the caller thread's callback
+                        Bundle bundle = new Bundle(2);
+                        bundle.putLong(EventHandler.QUERY_RESULT_POINTER_ARG, handoverTableViewPtr);
+                        bundle.putLong(EventHandler.CALLER_SHARED_GROUP_POINTER_ARG, callerSharedGroupNativePtr);
+
+                        Message message = handler.obtainMessage(EventHandler.MSG_SUCCESS);
+                        message.arg1 = EventHandler.FIND_ALL_QUERY;
+                        message.setData(bundle);
+                        handler.sendMessage(message);
+
+                    } catch (BadVersionException e) {
+                        handler.sendMessage(handler.obtainMessage(
+                                EventHandler.MSG_UNREACHABLE_VERSION,
+                                EventHandler.FIND_ALL_QUERY));
+
+                    } catch (Exception e) {
+                        handler.sendMessage(handler.obtainMessage(
+                                EventHandler.MSG_ERROR,
+                                EventHandler.FIND_ALL_QUERY, 0, e));
+
+                    } finally {
+                        if (null != bgRealm) {
+                            bgRealm.close();
+                        }
+                    }
+                } else {
+                    releaseHandoverResources();
+                }
+            }
+        });
+        if (null != asyncRequest) {
+            // update current reference, since retrying the query will
+            // submit a new Runnable, hence the need to update the user
+            // with the new Future<?> reference.
+            asyncRequest.setPendingQuery(pendingQuery);
+
+        } else { //First run
+            asyncRequest = new Request(pendingQuery);
+        }
+        return asyncRequest;
+    }
+
+    /**
+     * Find all objects that fulfill the query conditions and sorted by specific field name.
+     * <p/>
      * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
      * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
      *
-     * @param fieldName the field name to sort by.
+     * @param fieldName     the field name to sort by.
      * @param sortAscending sort ascending if <code>SORT_ORDER_ASCENDING</code>, sort descending
      *                      if <code>SORT_ORDER_DESCENDING</code>
      * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
@@ -1179,11 +1365,113 @@ public long count() {
         return new RealmResults<E>(realm, tableView, clazz);
     }
 
+    /**
+     * Similar to {@link #findAllSorted(String, boolean)} but runs asynchronously from a worker thread
+     *
+     * @param fieldName     the field name to sort by.
+     * @param sortAscending sort ascending if <code>SORT_ORDER_ASCENDING</code>, sort descending
+     *                      if <code>SORT_ORDER_DESCENDING</code>
+     * @param callback      to receive the result of this query
+     * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
+     * a list with zero objects is returned.
+     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     */
+    public Request findAllSorted(String fieldName, boolean sortAscending, RealmResults.QueryCallback<E> callback) {
+        // capture the sorting properties in case we want to retry the query
+        this.fieldName = fieldName;
+        this.sortAscending = sortAscending;
+
+        // will use the Looper of the caller thread to post the result
+        final Handler handler = new EventHandler(callback);
+
+        // We need a pointer to the caller Realm, to be able to handover the result to it
+        final long callerSharedGroupNativePtr = realm.getSharedGroupPointer();
+
+        // Handover the query (to be used by a worker thread)
+        handoverQueryPtr = query.handoverQuery(callerSharedGroupNativePtr);
+
+        // We need to use the same configuration to open a background SharedGroup (i.e Realm)
+        // to perform the query
+        final RealmConfiguration realmConfiguration = realm.getConfiguration();
+
+        final TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
+        final Long columnIndex = columns.get(fieldName);
+        if (columnIndex == null || columnIndex < 0) {
+            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
+        }
+
+        Future<?> pendingQuery = asyncQueryExecutor.submit(new Runnable() {
+            @Override
+            public void run() {
+                android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+                if (!Thread.currentThread().isInterrupted() && (asyncRequest == null || !asyncRequest.isCancelled())) {
+                    Realm bgRealm = null;
+
+                    try {
+                        //TODO Once SharedGroup is thread safe, start reusing a cached instance
+                        //     of a worker Realm to avoid the cost of opening/closing a SharedGroup
+                        //     for each query
+                        bgRealm = Realm.getInstance(realmConfiguration);
+
+                        // Run the query & handover the table view for the caller thread
+                        handoverTableViewPtr = query.findAllSortedWithHandover(bgRealm.getSharedGroupPointer(), handoverQueryPtr, columnIndex, (order == TableView.Order.ascending));
+                        handoverQueryPtr = -1;
+                        if (IS_DEBUG && NB_ADVANCE_READ_SIMULATION-- > 0) {
+                            // notify caller thread that we're about to post result to Handler
+                            // (this is relevant in Unit Testing, as we can advance read to simulate
+                            // a mismatch between the query result, and the current version of the Realm
+                            handler.sendMessage(handler.obtainMessage(
+                                    EventHandler.MSG_ADVANCE_READ,
+                                    EventHandler.FIND_ALL_SORTED_QUERY, 0));
+
+                        }
+
+                        // send results to the caller thread's callback
+                        Bundle bundle = new Bundle(2);
+                        bundle.putLong(EventHandler.QUERY_RESULT_POINTER_ARG, handoverTableViewPtr);
+                        bundle.putLong(EventHandler.CALLER_SHARED_GROUP_POINTER_ARG, callerSharedGroupNativePtr);
+
+                        Message message = handler.obtainMessage(EventHandler.MSG_SUCCESS);
+                        message.arg1 = EventHandler.FIND_ALL_SORTED_QUERY;
+                        message.setData(bundle);
+                        handler.sendMessage(message);
+
+                    } catch (BadVersionException e) {
+                        handler.sendMessage(handler.obtainMessage(
+                                EventHandler.MSG_UNREACHABLE_VERSION,
+                                EventHandler.FIND_ALL_SORTED_QUERY, 0));
+
+                    } catch (Exception e) {
+                        handler.sendMessage(handler.obtainMessage(
+                                EventHandler.MSG_ERROR,
+                                EventHandler.FIND_ALL_SORTED_QUERY, 0, e));
+
+                    } finally {
+                        if (null != bgRealm) {
+                            bgRealm.close();
+                        }
+                    }
+                } else {
+                    releaseHandoverResources();
+                }
+            }
+        });
+        if (null != asyncRequest) {
+            // update current reference, since retrying the query will
+            // submit a new Runnable, hence the need to update the user
+            // with the new Future<?> reference.
+            asyncRequest.setPendingQuery(pendingQuery);
+
+        } else { //First run
+            asyncRequest = new Request(pendingQuery);
+        }
+        return asyncRequest;
+    }
 
     /**
      * Find all objects that fulfill the query conditions and sorted by specific field name in
      * ascending order.
-     *
+     * <p/>
      * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
      * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
      *
@@ -1197,12 +1485,29 @@ public long count() {
     }
 
     /**
-     * Find all objects that fulfill the query conditions and sorted by specific field names.
+     * Similar to {@link #findAllSorted(String)} but runs asynchronously from a worker thread
+     * ascending order.
+     * <p/>
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
      *
+     * @param fieldName the field name to sort by.
+     * @param callback  to receive the result of this query
+     * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
+     * a list with zero objects is returned.
+     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     */
+    public Request findAllSorted(String fieldName, RealmResults.QueryCallback<E> callback) {
+        return findAllSorted(fieldName, true, callback);
+    }
+
+    /**
+     * Find all objects that fulfill the query conditions and sorted by specific field names.
+     * <p/>
      * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
      * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
      *
-     * @param fieldNames an array of field names to sort by.
+     * @param fieldNames    an array of field names to sort by.
      * @param sortAscending sort ascending if <code>SORT_ORDER_ASCENDING</code>, sort descending
      *                      if <code>SORT_ORDER_DESCENDING</code>.
      * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
@@ -1242,64 +1547,539 @@ public long count() {
         }
     }
 
+
+    public Request findAllSorted(String fieldNames[], final boolean sortAscendings[], RealmResults.QueryCallback<E> callback) {
+        // capture the sorting properties in case we want to retry the query
+        this.fieldNames = fieldNames;
+        this.sortAscendings = sortAscendings;
+
+        if (fieldNames == null) {
+            throw new IllegalArgumentException("fieldNames cannot be 'null'.");
+        } else if (sortAscendings == null) {
+            throw new IllegalArgumentException("sortAscending cannot be 'null'.");
+        } else if (fieldNames.length == 0) {
+            throw new IllegalArgumentException("At least one field name must be specified.");
+        } else if (fieldNames.length != sortAscendings.length) {
+            throw new IllegalArgumentException(String.format("Number of field names (%d) and sort orders (%d) does not match.", fieldNames.length, sortAscendings.length));
+        }
+
+        if (fieldNames.length == 1 && sortAscendings.length == 1) {
+            return findAllSorted(fieldNames[0], sortAscendings[0], callback);
+        } else {
+
+            // will use the Looper of the caller thread to post the result
+            final Handler handler = new EventHandler(callback);
+
+            // We need a pointer to the caller Realm, to be able to handover the result to it
+            final long callerSharedGroupNativePtr = realm.getSharedGroupPointer();
+
+            // Handover the query (to be used by a worker thread)
+            handoverQueryPtr = query.handoverQuery(callerSharedGroupNativePtr);
+
+            // We need to use the same configuration to open a background SharedGroup (i.e Realm)
+            // to perform the query
+            final RealmConfiguration realmConfiguration = realm.getConfiguration();
+
+            final long indices[] = new long[fieldNames.length];
+
+            for (int i = 0; i < fieldNames.length; i++) {
+                String fieldName = fieldNames[i];
+                Long columnIndex = columns.get(fieldName);
+                if (columnIndex == null || columnIndex < 0) {
+                    throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
+                }
+                indices[i] = columnIndex;
+            }
+
+            Future<?> pendingQuery = asyncQueryExecutor.submit(new Runnable() {
+                @Override
+                public void run() {
+                    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+                    if (!Thread.currentThread().isInterrupted() && (asyncRequest == null || !asyncRequest.isCancelled())) {
+                        Realm bgRealm = null;
+
+                        try {
+                            //TODO Once SharedGroup is thread safe, start reusing a cached instance
+                            //     of a worker Realm to avoid the cost of opening/closing a SharedGroup
+                            //     for each query
+                            bgRealm = Realm.getInstance(realmConfiguration);
+
+                            // Run the query & handover the table view for the caller thread
+                            handoverTableViewPtr = query.findAllMultiSortedWithHandover(bgRealm.getSharedGroupPointer(), handoverQueryPtr, indices, sortAscendings);
+                            handoverQueryPtr = -1;
+                            if (IS_DEBUG && NB_ADVANCE_READ_SIMULATION-- > 0) {
+                                // notify caller thread that we're about to post result to Handler
+                                // (this is relevant in Unit Testing, as we can advance read to simulate
+                                // a mismatch between the query result, and the current version of the Realm
+                                handler.sendMessage(handler.obtainMessage(
+                                        EventHandler.MSG_ADVANCE_READ,
+                                        EventHandler.FIND_ALL_SORTED_MULTI_QUERY, 0));
+                            }
+
+                            // send results to the caller thread's callback
+                            Bundle bundle = new Bundle(2);
+                            bundle.putLong(EventHandler.QUERY_RESULT_POINTER_ARG, handoverTableViewPtr);
+                            bundle.putLong(EventHandler.CALLER_SHARED_GROUP_POINTER_ARG, callerSharedGroupNativePtr);
+
+                            Message message = handler.obtainMessage(EventHandler.MSG_SUCCESS);
+                            message.arg1 = EventHandler.FIND_ALL_SORTED_MULTI_QUERY;
+                            message.setData(bundle);
+                            handler.sendMessage(message);
+
+                        } catch (BadVersionException e) {
+                            handler.sendMessage(handler.obtainMessage(
+                                    EventHandler.MSG_UNREACHABLE_VERSION,
+                                    EventHandler.FIND_ALL_SORTED_MULTI_QUERY, 0));
+
+                        } catch (Exception e) {
+                            handler.sendMessage(handler.obtainMessage(
+                                    EventHandler.MSG_ERROR,
+                                    EventHandler.FIND_ALL_SORTED_MULTI_QUERY, 0, e));
+
+                        } finally {
+                            if (null != bgRealm) {
+                                bgRealm.close();
+                            }
+                        }
+                    } else {
+                        releaseHandoverResources();
+                    }
+                }
+            });
+            if (null != asyncRequest) {
+                // update current reference, since retrying the query will
+                // submit a new Runnable, hence the need to update the user
+                // with the new Future<?> reference.
+                asyncRequest.setPendingQuery(pendingQuery);
+
+            } else { //First run
+                asyncRequest = new Request(pendingQuery);
+            }
+            return asyncRequest;
+        }
+    }
+
     /**
      * Find all objects that fulfill the query conditions and sorted by specific field names in
      * ascending order.
-     *
+     * <p/>
      * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
      * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
      *
-     * @param fieldName1 first field name
+     * @param fieldName1     first field name
      * @param sortAscending1 sort order for first field
-     * @param fieldName2 second field name
+     * @param fieldName2     second field name
      * @param sortAscending2 sort order for second field
      * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
      * a list with zero objects is returned.
      * @throws java.lang.IllegalArgumentException if a field name does not exist.
      */
     public RealmResults<E> findAllSorted(String fieldName1, boolean sortAscending1,
-                                   String fieldName2, boolean sortAscending2) {
-        return findAllSorted(new String[] {fieldName1, fieldName2}, new boolean[] {sortAscending1, sortAscending2});
+                                         String fieldName2, boolean sortAscending2) {
+        return findAllSorted(new String[]{fieldName1, fieldName2}, new boolean[]{sortAscending1, sortAscending2});
     }
 
+    /**
+     * Similar to {@link #findAllSorted(String, boolean, String, boolean)} but runs asynchronously from a worker thread
+     *
+     * @param fieldName1     first field name
+     * @param sortAscending1 sort order for first field
+     * @param fieldName2     second field name
+     * @param sortAscending2 sort order for second field
+     * @param callback       to receive the result of this query
+     * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
+     * a list with zero objects is returned.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     */
+    public Request findAllSorted(String fieldName1, boolean sortAscending1,
+                                 String fieldName2, boolean sortAscending2,
+                                 RealmResults.QueryCallback<E> callback) {
+        return findAllSorted(new String[]{fieldName1, fieldName2},
+                new boolean[]{sortAscending1, sortAscending2},
+                callback);
+    }
 
     /**
      * Find all objects that fulfill the query conditions and sorted by specific field names in
      * ascending order.
-     *
+     * <p/>
      * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
      * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
      *
-     * @param fieldName1 first field name
+     * @param fieldName1     first field name
      * @param sortAscending1 sort order for first field
-     * @param fieldName2 second field name
+     * @param fieldName2     second field name
      * @param sortAscending2 sort order for second field
-     * @param fieldName3 third field name
+     * @param fieldName3     third field name
      * @param sortAscending3 sort order for third field
      * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
      * a list with zero objects is returned.
      * @throws java.lang.IllegalArgumentException if a field name does not exist.
      */
     public RealmResults<E> findAllSorted(String fieldName1, boolean sortAscending1,
-                                   String fieldName2, boolean sortAscending2,
-                                   String fieldName3, boolean sortAscending3) {
-        return findAllSorted(new String[] {fieldName1, fieldName2, fieldName3},
-                new boolean[] {sortAscending1, sortAscending2, sortAscending3});
+                                         String fieldName2, boolean sortAscending2,
+                                         String fieldName3, boolean sortAscending3) {
+        return findAllSorted(new String[]{fieldName1, fieldName2, fieldName3},
+                new boolean[]{sortAscending1, sortAscending2, sortAscending3});
+    }
+
+    /**
+     * Similar to {@link #findAllSorted(String, boolean, String, boolean, String, boolean)} but runs asynchronously from a worker thread
+     *
+     * @param fieldName1     first field name
+     * @param sortAscending1 sort order for first field
+     * @param fieldName2     second field name
+     * @param sortAscending2 sort order for second field
+     * @param fieldName3     third field name
+     * @param sortAscending3 sort order for third field
+     * @param callback       to receive the result of this query
+     * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
+     * a list with zero objects is returned.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     */
+    public Request findAllSorted(String fieldName1, boolean sortAscending1,
+                                 String fieldName2, boolean sortAscending2,
+                                 String fieldName3, boolean sortAscending3,
+                                 RealmResults.QueryCallback<E> callback) {
+        return findAllSorted(new String[]{fieldName1, fieldName2, fieldName3},
+                new boolean[]{sortAscending1, sortAscending2, sortAscending3}, callback);
     }
 
     /**
      * Find the first object that fulfills the query conditions.
      *
      * @return The object found or null if no object matches the query conditions.
-     * @see io.realm.RealmObject
      * @throws java.lang.RuntimeException Any other error.
+     * @see io.realm.RealmObject
      */
     public E findFirst() {
         long rowIndex = this.query.find();
         if (rowIndex >= 0) {
-            return realm.get(clazz, (view != null) ? view.getTargetRowIndex(rowIndex) : rowIndex);
+            return realm.getByIndex(clazz, (view != null) ? view.getTargetRowIndex(rowIndex) : rowIndex);
         } else {
             return null;
         }
     }
+
+    /**
+     * Similar to {@link #findFirst()} but runs asynchronously from a worker thread
+     *
+     * @param callback to receive the result of this query
+     * @return A {@link Request} representing a cancellable, pending asynchronous query
+     */
+    public Request findFirst(RealmObject.QueryCallback<E> callback) {
+        // will use the Looper of the caller thread to post the result
+        final Handler handler = new EventHandler(callback);
+
+        // We need a pointer to the caller Realm, to be able to handover the result to it
+        final long callerSharedGroupNativePtr = realm.getSharedGroupPointer();
+
+        // Handover the query (to be used by a worker thread)
+        handoverQueryPtr = query.handoverQuery(callerSharedGroupNativePtr);
+
+        // We need to use the same configuration to open a background SharedGroup (i.e Realm)
+        // to perform the query
+        final RealmConfiguration realmConfiguration = realm.getConfiguration();
+
+        Future<?> pendingQuery = asyncQueryExecutor.submit(new Runnable() {
+            @Override
+            public void run() {
+                android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+                if (!Thread.currentThread().isInterrupted() && (asyncRequest == null || !asyncRequest.isCancelled())) {
+                    Realm bgRealm = null;
+
+                    try {
+                        //TODO Once SharedGroup is thread safe, start reusing a cached instance
+                        //     of a worker Realm to avoid the cost of opening/closing a SharedGroup
+                        //     for each query
+                        bgRealm = Realm.getInstance(realmConfiguration);
+
+                        // Run the query & handover the table view for the caller thread
+                        handoverRowPtr = query.findWithHandover(bgRealm.getSharedGroupPointer(), handoverQueryPtr);
+                        handoverQueryPtr = -1;
+                        if (IS_DEBUG && NB_ADVANCE_READ_SIMULATION-- > 0) {
+                            // notify caller thread that we're about to post result to Handler
+                            // (this is relevant in Unit Testing, as we can advance read to simulate
+                            // a mismatch between the query result, and the current version of the Realm
+                            handler.sendMessage(handler.obtainMessage(
+                                    EventHandler.MSG_ADVANCE_READ,
+                                    EventHandler.FIND_FIRST_QUERY, 0));
+                        }
+
+                        // send results to the caller thread's callback
+                        Bundle bundle = new Bundle(2);
+                        bundle.putLong(EventHandler.QUERY_RESULT_POINTER_ARG, handoverRowPtr);
+                        bundle.putLong(EventHandler.CALLER_SHARED_GROUP_POINTER_ARG, callerSharedGroupNativePtr);
+
+                        Message message = handler.obtainMessage(EventHandler.MSG_SUCCESS);
+                        message.arg1 = EventHandler.FIND_FIRST_QUERY;
+                        message.setData(bundle);
+                        handler.sendMessage(message);
+
+                    } catch (BadVersionException e) {
+                        handler.sendMessage(handler.obtainMessage(
+                                EventHandler.MSG_UNREACHABLE_VERSION,
+                                EventHandler.FIND_FIRST_QUERY, 0));
+
+                    } catch (Exception e) {
+                        handler.sendMessage(handler.obtainMessage(
+                                EventHandler.MSG_ERROR,
+                                EventHandler.FIND_FIRST_QUERY, 0, e));
+
+                    } finally {
+                        if (null != bgRealm) {
+                            bgRealm.close();
+                        }
+                    }
+                } else {
+                    releaseHandoverResources();
+                }
+            }
+        });
+        if (null != asyncRequest) {
+            // update current reference, since retrying the query will
+            // submit a new Runnable, hence the need to update the user
+            // with the new Future<?> reference.
+            asyncRequest.setPendingQuery(pendingQuery);
+
+        } else { //First run
+            asyncRequest = new Request(pendingQuery);
+        }
+        return asyncRequest;
+    }
+
+    /**
+     * Represents a pending asynchronous Realm query.
+     * <p/>
+     * Users are responsible of maintaining a reference to {@code Request} in order
+     * to call #cancel in case of a configuration change for example (to avoid memory leak, as the
+     * query will post the result to the caller's thread callback)
+     */
+    public static class Request {
+        private Future<?> pendingQuery;
+        private volatile boolean isCancelled = false;
+
+        public Request(Future<?> pendingQuery) {
+            this.pendingQuery = pendingQuery;
+        }
+
+        /**
+         * Attempts to cancel execution of this query (if it hasn't already completed or previously cancelled)
+         */
+        public void cancel() {
+            pendingQuery.cancel(true);
+            isCancelled = true;
+        }
+
+        private void setPendingQuery(Future<?> pendingQuery) {
+            this.pendingQuery = pendingQuery;
+        }
+
+        /**
+         * Whether an attempt to cancel the query was performed
+         *
+         * @return {@code true} if {@link #cancel()} has already been called, {@code false} otherwise
+         */
+        public boolean isCancelled() {
+            return isCancelled;
+        }
+    }
+
+    /**
+     * Custom {@link android.os.Handler} using the caller {@link android.os.Looper}
+     * to deliver result or error to a {@link io.realm.RealmResults.QueryCallback} or
+     * a {@link io.realm.RealmObject.QueryCallback}
+     */
+    // this handler is private & lives within the scope of the retained RealmQuery instance only
+    @SuppressLint("HandlerLeak")
+    private class EventHandler extends Handler {
+        private final static int FIND_FIRST_QUERY = 1;
+        private final static int FIND_ALL_QUERY = 2;
+        private final static int FIND_ALL_SORTED_QUERY = 3;
+        private final static int FIND_ALL_SORTED_MULTI_QUERY = 4;
+
+        private final static String QUERY_RESULT_POINTER_ARG = "queryResultPtr";
+        private final static String CALLER_SHARED_GROUP_POINTER_ARG = "callerSgPtr";
+
+        private static final int MSG_SUCCESS = 1;
+        private static final int MSG_ERROR = 2;
+        // Used when begin_read fails to position the background Realm at a specific version
+        // most likely the caller thread has advanced_read or the provided version of Realm
+        // is no longer available
+        private static final int MSG_UNREACHABLE_VERSION = 3;
+        // This is only used for testing scenarios, when we want to simulate a change in the
+        // caller Realm before delivering the result. Thus, this will trigger 'Handover failed due to version mismatch'
+        // that helps testing the retry process
+        private static final int MSG_ADVANCE_READ = 4;
+
+        private RealmResults.QueryCallback<E> callbackRealmResults;
+        private RealmObject.QueryCallback<E> callbackRealmObject;
+
+        EventHandler(RealmResults.QueryCallback<E> callbackRealmResults) {
+            super();
+            this.callbackRealmResults = callbackRealmResults;
+            this.callbackRealmObject = null;
+        }
+
+        EventHandler(RealmObject.QueryCallback<E> callbackRealmObject) {
+            super();
+            this.callbackRealmObject = callbackRealmObject;
+            this.callbackRealmResults = null;
+        }
+
+
+        @Override
+        public void handleMessage(Message msg) {
+            if (!asyncRequest.isCancelled()) {
+                switch (msg.what) {
+                    case MSG_SUCCESS:
+                        handleSuccess(msg);
+                        break;
+                    case MSG_ERROR:
+                        handleError(msg);
+                        break;
+                    case MSG_UNREACHABLE_VERSION: {
+                        handleUnreachableVersion(msg);
+                        break;
+                    }
+                    case MSG_ADVANCE_READ: {
+                        handleAdvanceRead(msg);
+                        break;
+                    }
+                }
+
+            } else {
+                // in case we didn't have the chance to import the different handovers(because the query was cancelled/crash)
+                // we need to manually free those resources to avoid memory leak
+                releaseHandoverResources();
+            }
+        }
+
+        private void handleSuccess(final Message message) {
+            Bundle bundle = message.getData();
+            try {
+                switch (message.arg1) {
+                    case FIND_FIRST_QUERY: {
+                        E realmObject = realm.getByPointer(clazz,
+                                query.importHandoverRow(bundle.getLong(QUERY_RESULT_POINTER_ARG),
+                                        bundle.getLong(CALLER_SHARED_GROUP_POINTER_ARG)));
+
+                        callbackRealmObject.onSuccess(realmObject);
+                        callbackRealmObject = null;
+                        break;
+                    }
+                    case FIND_ALL_QUERY: {
+                        RealmResults<E> resultList = new RealmResults<E>(realm,
+                                query.importHandoverTableView(bundle.getLong(QUERY_RESULT_POINTER_ARG),
+                                        bundle.getLong(CALLER_SHARED_GROUP_POINTER_ARG)),
+                                clazz);
+
+                        callbackRealmResults.onSuccess(resultList);
+                        callbackRealmResults = null;
+                        break;
+                    }
+                    case FIND_ALL_SORTED_QUERY: {
+                        RealmResults<E> resultList = new RealmResults<E>(realm,
+                                query.importHandoverTableView(bundle.getLong(QUERY_RESULT_POINTER_ARG),
+                                        bundle.getLong(CALLER_SHARED_GROUP_POINTER_ARG)),
+                                clazz);
+
+                        callbackRealmResults.onSuccess(resultList);
+                        callbackRealmResults = null;
+                        break;
+                    }
+                    case FIND_ALL_SORTED_MULTI_QUERY: {
+                        RealmResults<E> resultList = new RealmResults<E>(realm,
+                                query.importHandoverTableView(bundle.getLong(QUERY_RESULT_POINTER_ARG),
+                                        bundle.getLong(CALLER_SHARED_GROUP_POINTER_ARG)),
+                                clazz);
+
+                        callbackRealmResults.onSuccess(resultList);
+                        callbackRealmResults = null;
+                        break;
+                    }
+                }
+
+            } catch (BadVersionException e) {
+                handleUnreachableVersion(message);
+
+            } catch (Exception e) {
+                handoverQueryPtr = -1;
+                handoverTableViewPtr = -1;
+                handoverRowPtr = -1;
+                message.obj = e;
+                handleError(message);
+            }
+        }
+
+        private void handleError(Message message) {
+            releaseHandoverResources();
+
+            switch (message.arg1) {
+                case FIND_FIRST_QUERY:
+                    callbackRealmObject.onError((Exception) message.obj);
+                    callbackRealmObject = null;
+                    break;
+                case FIND_ALL_QUERY:
+                case FIND_ALL_SORTED_QUERY:
+                case FIND_ALL_SORTED_MULTI_QUERY:
+                    callbackRealmResults.onError((Exception) message.obj);
+                    callbackRealmResults = null;
+                    break;
+            }
+        }
+
+        private void handleUnreachableVersion(Message message) {
+            if (retryPolicy.shouldRetry()) {
+                switch (message.arg1) {
+                    case FIND_FIRST_QUERY:
+                        findFirst(callbackRealmObject);
+                        break;
+                    case FIND_ALL_QUERY:
+                        findAll(callbackRealmResults);
+                        break;
+                    case FIND_ALL_SORTED_QUERY:
+                        findAllSorted(fieldName, sortAscending, callbackRealmResults);
+                        break;
+                    case FIND_ALL_SORTED_MULTI_QUERY:
+                        findAllSorted(fieldNames, sortAscendings, callbackRealmResults);
+                        break;
+                }
+            } else {
+                // pointers were already freed/consumed by 'import_from_handover'
+                // calling delete again will crash core
+                handoverQueryPtr = -1;
+                handoverTableViewPtr = -1;
+                handoverRowPtr = -1;
+                message.obj = new RealmException("Query failed due to concurrent modification of the Realm");
+                handleError(message);
+            }
+        }
+
+        private void handleAdvanceRead(Message message) {
+            switch (message.arg1) {
+                case FIND_FIRST_QUERY:
+                    ((RealmObject.DebugRealmObjectQueryCallback<E>) callbackRealmObject).onBackgroundQueryCompleted(realm);
+                    break;
+                case FIND_ALL_QUERY:
+                case FIND_ALL_SORTED_QUERY:
+                case FIND_ALL_SORTED_MULTI_QUERY:
+                    ((RealmResults.DebugRealmResultsQueryCallback<E>) callbackRealmResults).onBackgroundQueryCompleted(realm);
+                    break;
+            }
+        }
+    }
+
+    private void releaseHandoverResources() {
+        query.closeRowHandover(handoverRowPtr);
+        handoverRowPtr = -1;
+        query.closeQueryHandover(handoverQueryPtr);
+        handoverQueryPtr = -1;
+        query.closeTableViewHandover(handoverTableViewPtr);
+        handoverTableViewPtr = -1;
+    }
+
+    // Unit Test Helper
+    private static boolean IS_DEBUG = false;
+    private static int NB_ADVANCE_READ_SIMULATION = 0;
 }
diff --git a/realm/src/main/java/io/realm/RealmResults.java b/realm/src/main/java/io/realm/RealmResults.java
index 3e8b55937d..3c3108ba78 100644
--- a/realm/src/main/java/io/realm/RealmResults.java
+++ b/realm/src/main/java/io/realm/RealmResults.java
@@ -69,7 +69,7 @@
         this.classSpec = classSpec;
     }
 
-    RealmResults(Realm realm, TableOrView table, Class<E> classSpec) {
+    public RealmResults(Realm realm, TableOrView table, Class<E> classSpec) {
         this(realm, classSpec);
         this.table = table;
     }
@@ -624,4 +624,25 @@ public void set(E object) {
         @Override
         public void remove() { throw new RealmException("Removing elements not supported."); }
     }
+
+    /**
+     * Encapsulates an async {@link RealmQuery}.
+     * <p>
+     * This will run the {@link RealmQuery} on a worker thread, then invoke this callback on the caller thread
+     */
+    public interface QueryCallback<E extends RealmObject> {
+        void onSuccess (RealmResults<E>  results);
+        void onError (Exception e);
+    }
+
+    /**
+     * Used for debugging/testing purpose to add any logic (within the caller's thread)
+     * before we return the results
+     */
+    interface DebugRealmResultsQueryCallback<E extends RealmObject> extends RealmResults.QueryCallback<E> {
+        /**
+         * Runs on the caller's thread just before we hand over the result to {@link #onSuccess(RealmResults)}
+         */
+        void onBackgroundQueryCompleted(Realm realm);
+    }
 }
diff --git a/realm/src/main/java/io/realm/internal/LinkView.java b/realm/src/main/java/io/realm/internal/LinkView.java
index f7375d246d..3e82917448 100644
--- a/realm/src/main/java/io/realm/internal/LinkView.java
+++ b/realm/src/main/java/io/realm/internal/LinkView.java
@@ -42,7 +42,7 @@ public LinkView(Context context, Table parent, long columnIndexInParent, long na
      * @return Unsafe row wrapper object.
      */
     public UncheckedRow getUncheckedRow(long index) {
-        return UncheckedRow.get(context, this, index);
+        return UncheckedRow.getByRowIndex(context, this, index);
     }
 
     /**
diff --git a/realm/src/main/java/io/realm/internal/SharedGroup.java b/realm/src/main/java/io/realm/internal/SharedGroup.java
index 5a9fb6995c..340af6e6ea 100644
--- a/realm/src/main/java/io/realm/internal/SharedGroup.java
+++ b/realm/src/main/java/io/realm/internal/SharedGroup.java
@@ -81,22 +81,36 @@ public SharedGroup(String databaseFile, Durability durability, boolean fileMustE
         checkNativePtrNotZero();
     }
 
+    private native long createNativeWithImplicitTransactions(long nativeReplicationPtr, int durability, byte[] key);
+    
+    public long getNativePointer () {
+        return nativePtr;
+    }
+
+    private native long nativeCreateReplication(String databaseFile, byte[] key);
+
     void advanceRead() {
-        nativeAdvanceRead(nativePtr);
+        nativeAdvanceRead(nativePtr, nativeReplicationPtr);
     }
 
+    private native void nativeAdvanceRead(long nativePtr, long nativeReplicationPtr);
+
     void promoteToWrite() {
-        nativePromoteToWrite(nativePtr);
+        nativePromoteToWrite(nativePtr, nativeReplicationPtr);
     }
 
+    private native void nativePromoteToWrite(long nativePtr, long nativeReplicationPtr);
+
     void commitAndContinueAsRead() {
         nativeCommitAndContinueAsRead(nativePtr);
     }
 
     void rollbackAndContinueAsRead() {
-        nativeRollbackAndContinueAsRead(nativePtr);
+        nativeRollbackAndContinueAsRead(nativePtr, nativeReplicationPtr);
     }
 
+    private native void nativeRollbackAndContinueAsRead(long nativePtr, long nativeReplicationPtr);
+
     public ImplicitTransaction beginImplicitTransaction() {
         if (activeTransaction) {
             throw new IllegalStateException(
diff --git a/realm/src/main/java/io/realm/internal/Table.java b/realm/src/main/java/io/realm/internal/Table.java
index 20946434fb..77871a1223 100644
--- a/realm/src/main/java/io/realm/internal/Table.java
+++ b/realm/src/main/java/io/realm/internal/Table.java
@@ -390,7 +390,7 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
                     throwDuplicatePrimaryKeyException(primaryKeyValue);
                 }
                 rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                row = getUncheckedRow(rowIndex);
+                row = getUncheckedRowByIndex(rowIndex);
                 row.setString(primaryKeyColumnIndex, (String) primaryKeyValue);
                 break;
 
@@ -405,7 +405,7 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
                     throwDuplicatePrimaryKeyException(pkValue);
                 }
                 rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                row = getUncheckedRow(rowIndex);
+                row = getUncheckedRowByIndex(rowIndex);
                 row.setLong(primaryKeyColumnIndex, pkValue);
                 break;
 
@@ -660,7 +660,7 @@ public long getPrimaryKey() {
             }
             long rowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, getName());
             if (rowIndex != NO_MATCH) {
-                String pkColumnName = pkTable.getUncheckedRow(rowIndex).getString(PRIMARY_KEY_FIELD_COLUMN_INDEX);
+                String pkColumnName = pkTable.getUncheckedRowByIndex(rowIndex).getString(PRIMARY_KEY_FIELD_COLUMN_INDEX);
                 cachedPrimaryKeyColumnIndex = getColumnIndex(pkColumnName);
             } else {
                 cachedPrimaryKeyColumnIndex = NO_PRIMARY_KEY;
@@ -997,15 +997,26 @@ public void clearSubtable(long columnIndex, long rowIndex) {
      * @param index Index of row to fetch.
      * @return Unsafe row wrapper object.
      */
-    public UncheckedRow getUncheckedRow(long index) {
-        return UncheckedRow.get(context, this, index);
+    public UncheckedRow getUncheckedRowByIndex(long index) {
+        return UncheckedRow.getByRowIndex(context, this, index);
+    }
+
+    /**
+     * Returns a non-checking Row. Incorrect use of this Row will cause a hard core crash.
+     * If error checking is required, use {@link #getCheckedRow(long)} instead.
+     *
+     * @param nativeRowPointer Pointer to the row to fetch.
+     * @return Unsafe row wrapper object.
+     */
+    public UncheckedRow getUncheckedRowByPointer(long nativeRowPointer) {
+        return UncheckedRow.getByRowPointer(context, this, nativeRowPointer);
     }
 
     /**
      * Returns a wrapper around Row access. All access will be error checked in JNI and will throw an
      * appropriate {@link RuntimeException} if used incorrectly.
      *
-     * If error checking is done elsewhere, consider using {@link #getUncheckedRow(long)} for better performance.
+     * If error checking is done elsewhere, consider using {@link #getUncheckedRowByIndex(long)} for better performance.
      *
      * @param index Index of row to fetch./
      * @return Safe row wrapper object.
diff --git a/realm/src/main/java/io/realm/internal/TableQuery.java b/realm/src/main/java/io/realm/internal/TableQuery.java
index b68bb2038f..3af88aa641 100644
--- a/realm/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/src/main/java/io/realm/internal/TableQuery.java
@@ -91,14 +91,14 @@ private void validateQuery() {
         }
     }
 
-    protected native String nativeValidateQuery(long nativeQueryPtr);
+    private native String nativeValidateQuery(long nativeQueryPtr);
 
     // Query TableView
     public TableQuery tableview(TableView tv) {
         nativeTableview(nativePtr, tv.nativePtr);
         return this;
     }
-    protected native void nativeTableview(long nativeQueryPtr, long nativeTableViewPtr);
+    private native void nativeTableview(long nativeQueryPtr, long nativeTableViewPtr);
 
     // Grouping
 
@@ -106,42 +106,42 @@ public TableQuery group() {
         nativeGroup(nativePtr);
         return this;
     }
-    protected native void nativeGroup(long nativeQueryPtr);
+    private native void nativeGroup(long nativeQueryPtr);
 
     public TableQuery endGroup() {
         nativeEndGroup(nativePtr);
         queryValidated = false;
         return this;
     }
-    protected native void nativeEndGroup(long nativeQueryPtr);
+    private native void nativeEndGroup(long nativeQueryPtr);
 
     public TableQuery subtable(long columnIndex) {
         nativeSubtable(nativePtr, columnIndex);
         queryValidated = false;
         return this;
     }
-    protected native void nativeSubtable(long nativeQueryPtr, long columnIndex);
+    private native void nativeSubtable(long nativeQueryPtr, long columnIndex);
 
     public TableQuery endSubtable() {
         nativeParent(nativePtr);
         queryValidated = false;
         return this;
     }
-    protected native void nativeParent(long nativeQueryPtr);
+    private native void nativeParent(long nativeQueryPtr);
 
     public TableQuery or() {
         nativeOr(nativePtr);
         queryValidated = false;
         return this;
     }
-    protected native void nativeOr(long nativeQueryPtr);
+    private native void nativeOr(long nativeQueryPtr);
 
     public TableQuery not() {
         nativeNot(nativePtr);
         queryValidated = false;
         return this;
     }
-    protected native void nativeNot(long nativeQueryPtr);
+    private native void nativeNot(long nativeQueryPtr);
 
     // Query for integer values.
 
@@ -150,49 +150,49 @@ public TableQuery equalTo(long columnIndexes[], long value) {
         queryValidated = false;
         return this;
     }
-    protected native void nativeEqual(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeEqual(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery notEqualTo(long columnIndex[], long value) {
         nativeNotEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery greaterThan(long columnIndex[], long value) {
         nativeGreater(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeGreater(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreater(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery greaterThanOrEqual(long columnIndex[], long value) {
         nativeGreaterEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery lessThan(long columnIndex[], long value) {
         nativeLess(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeLess(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLess(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery lessThanOrEqual(long columnIndex[], long value) {
         nativeLessEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery between(long columnIndex[], long value1, long value2) {
         nativeBetween(nativePtr, columnIndex, value1, value2);
         queryValidated = false;
         return this;
     }
-    protected native void nativeBetween(long nativeQueryPtr, long columnIndex[], long value1, long value2);
+    private native void nativeBetween(long nativeQueryPtr, long columnIndex[], long value1, long value2);
 
 
     // Query for float values.
@@ -202,49 +202,49 @@ public TableQuery equalTo(long columnIndex[], float value) {
         queryValidated = false;
         return this;
     }
-    protected native void nativeEqual(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeEqual(long nativeQueryPtr, long columnIndex[], float value);
 
     public TableQuery notEqualTo(long columnIndex[], float value) {
         nativeNotEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], float value);
 
     public TableQuery greaterThan(long columnIndex[], float value) {
         nativeGreater(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeGreater(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeGreater(long nativeQueryPtr, long columnIndex[], float value);
 
     public TableQuery greaterThanOrEqual(long columnIndex[], float value) {
         nativeGreaterEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], float value);
 
     public TableQuery lessThan(long columnIndex[], float value) {
         nativeLess(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeLess(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeLess(long nativeQueryPtr, long columnIndex[], float value);
 
     public TableQuery lessThanOrEqual(long columnIndex[], float value) {
         nativeLessEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], float value);
 
     public TableQuery between(long columnIndex[], float value1, float value2) {
         nativeBetween(nativePtr, columnIndex, value1, value2);
         queryValidated = false;
         return this;
     }
-    protected native void nativeBetween(long nativeQueryPtr, long columnIndex[], float value1, float value2);
+    private native void nativeBetween(long nativeQueryPtr, long columnIndex[], float value1, float value2);
 
 
     // Query for double values.
@@ -254,49 +254,49 @@ public TableQuery equalTo(long columnIndex[], double value) {
         queryValidated = false;
         return this;
     }
-    protected native void nativeEqual(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeEqual(long nativeQueryPtr, long columnIndex[], double value);
 
     public TableQuery notEqualTo(long columnIndex[], double value) {
         nativeNotEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], double value);
 
     public TableQuery greaterThan(long columnIndex[], double value) {
         nativeGreater(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeGreater(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeGreater(long nativeQueryPtr, long columnIndex[], double value);
 
     public TableQuery greaterThanOrEqual(long columnIndex[], double value) {
         nativeGreaterEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], double value);
 
     public TableQuery lessThan(long columnIndex[], double value) {
         nativeLess(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeLess(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeLess(long nativeQueryPtr, long columnIndex[], double value);
 
     public TableQuery lessThanOrEqual(long columnIndex[], double value) {
         nativeLessEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], double value);
 
     public TableQuery between(long columnIndex[], double value1, double value2) {
         nativeBetween(nativePtr, columnIndex, value1, value2);
         queryValidated = false;
         return this;
     }
-    protected native void nativeBetween(long nativeQueryPtr, long columnIndex[], double value1, double value2);
+    private native void nativeBetween(long nativeQueryPtr, long columnIndex[], double value1, double value2);
 
 
     // Query for boolean values.
@@ -306,7 +306,7 @@ public TableQuery equalTo(long columnIndex[], boolean value){
         queryValidated = false;
         return this;
     }
-    protected native void nativeEqual(long nativeQueryPtr, long columnIndex[], boolean value);
+    private native void nativeEqual(long nativeQueryPtr, long columnIndex[], boolean value);
 
     // Query for Date values
 
@@ -319,7 +319,7 @@ public TableQuery equalTo(long columnIndex[], Date value){
         queryValidated = false;
         return this;
     }
-    protected native void nativeEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery notEqualTo(long columnIndex[], Date value){
         if (value == null)
@@ -328,7 +328,7 @@ public TableQuery notEqualTo(long columnIndex[], Date value){
         queryValidated = false;
         return this;
     }
-    protected native void nativeNotEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeNotEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery greaterThan(long columnIndex[], Date value){
         if (value == null)
@@ -338,7 +338,7 @@ public TableQuery greaterThan(long columnIndex[], Date value){
         return this;
     }
 
-    protected native void nativeGreaterDateTime(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreaterDateTime(long nativeQueryPtr, long columnIndex[], long value);
 
 
     public TableQuery greaterThanOrEqual(long columnIndex[], Date value){
@@ -349,7 +349,7 @@ public TableQuery greaterThanOrEqual(long columnIndex[], Date value){
         return this;
     }
 
-    protected native void nativeGreaterEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreaterEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery lessThan(long columnIndex[], Date value){
         if (value == null)
@@ -359,7 +359,7 @@ public TableQuery lessThan(long columnIndex[], Date value){
         return this;
     }
 
-    protected native void nativeLessDateTime(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLessDateTime(long nativeQueryPtr, long columnIndex[], long value);
 
 
     public TableQuery lessThanOrEqual(long columnIndex[], Date value){
@@ -370,7 +370,7 @@ public TableQuery lessThanOrEqual(long columnIndex[], Date value){
         return this;
     }
 
-    protected native void nativeLessEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLessEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery between(long columnIndex[], Date value1, Date value2){
         if (value1 == null || value2 == null)
@@ -379,7 +379,7 @@ public TableQuery between(long columnIndex[], Date value1, Date value2){
         queryValidated = false;
         return this;
     }
-    protected native void nativeBetweenDateTime(long nativeQueryPtr, long columnIndex[], long value1, long value2);
+    private native void nativeBetweenDateTime(long nativeQueryPtr, long columnIndex[], long value1, long value2);
 
     // Query for String values.
     
@@ -400,7 +400,7 @@ public TableQuery equalTo(long[] columnIndexes, String value) {
         queryValidated = false;
         return this;
     }
-    protected native void nativeEqual(long nativeQueryPtr, long[] columnIndexes, String value, boolean caseSensitive);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndexes, String value, boolean caseSensitive);
 
     // Not Equal
     public TableQuery notEqualTo(long columnIndex[], String value, boolean caseSensitive) {
@@ -417,7 +417,7 @@ public TableQuery notEqualTo(long columnIndex[], String value) {
         queryValidated = false;
         return this;
     }
-    protected native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], String value, boolean caseSensitive);
+    private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], String value, boolean caseSensitive);
 
     public TableQuery beginsWith(long columnIndices[], String value, boolean caseSensitive) {
         if (value == null)
@@ -433,7 +433,7 @@ public TableQuery beginsWith(long columnIndices[], String value) {
         queryValidated = false;
         return this;
     }
-    protected native void nativeBeginsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
+    private native void nativeBeginsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
 
     public TableQuery endsWith(long columnIndices[], String value, boolean caseSensitive) {
         if (value == null)
@@ -449,7 +449,7 @@ public TableQuery endsWith(long columnIndices[], String value) {
         queryValidated = false;
         return this;
     }
-    protected native void nativeEndsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
+    private native void nativeEndsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
 
     public TableQuery contains(long columnIndices[], String value, boolean caseSensitive) {
         if (value == null)
@@ -465,7 +465,7 @@ public TableQuery contains(long columnIndices[], String value) {
         queryValidated = false;
         return this;
     }
-    protected native void nativeContains(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
+    private native void nativeContains(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
 
 
     // Searching methods.
@@ -480,7 +480,16 @@ public long find() {
         return nativeFind(nativePtr, 0);
     }
 
-    protected native long nativeFind(long nativeQueryPtr, long fromTableRow);
+    public long findWithHandover(long bgSharedGroupPtr, long ptrQuery) {
+        validateQuery();
+
+        // Execute the disposal of abandoned realm objects each time a new realm object is created
+        context.executeDelayedDisposal();
+        return nativeFindWithHandover(bgSharedGroupPtr, ptrQuery, 0);
+    }
+
+    private native long nativeFind(long nativeQueryPtr, long fromTableRow);
+    private native long nativeFindWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long fromTableRow);
 
     public TableView findAll(long start, long end, long limit) {
         validateQuery();
@@ -510,8 +519,69 @@ public TableView findAll() {
         }
     }
 
-    protected native long nativeFindAll(long nativeQueryPtr, long start, long end, long limit);
+    /**
+     * This will use the background SharedGroup to import the query (using the handover object)
+     * run the query, and return the table view to the caller SharedGroup using the handover object.
+     * @param bgSharedGroupPtr Background shared group native pointer
+     * @param ptrQuery handover pointer to the query (coming from the caller SharedGroup)
+     * @return handover pointer to the table view results
+     */
+    public long findAllWithHandover(long bgSharedGroupPtr, long ptrQuery) {
+        validateQuery();
+
+        // Execute the disposal of abandoned realm objects each time a new realm object is created
+        context.executeDelayedDisposal();// TODO bottleneck. when freeing tables become thread safe in core use FinalizerRunnable
+        return nativeFindAllWithHandover(bgSharedGroupPtr, ptrQuery, 0, Table.INFINITE, Table.INFINITE);
+    }
 
+    public long findAllSortedWithHandover(long bgSharedGroupPtr, long ptrQuery, long columnIndex, boolean ascending) {
+        validateQuery();
+        // Execute the disposal of abandoned realm objects each time a new realm object is created
+        context.executeDelayedDisposal();
+        return nativeFindAllSortedWithHandover(bgSharedGroupPtr, ptrQuery, 0, Table.INFINITE, Table.INFINITE, columnIndex, ascending);
+    }
+
+    public long findAllMultiSortedWithHandover(long bgSharedGroupPtr, long ptrQuery, long[] columnIndices, boolean[] ascending) {
+        validateQuery();
+        // Execute the disposal of abandoned realm objects each time a new realm object is created
+        context.executeDelayedDisposal();
+        return nativeFindAllMultiSortedWithHandover(bgSharedGroupPtr, ptrQuery, 0, Table.INFINITE, Table.INFINITE, columnIndices, ascending);
+    }
+
+    // Suppose to be called from the caller SharedGroup thread
+    public TableView importHandoverTableView(long handoverPtr, long callerSharedGroupPtr) {
+        long nativeTvPtr = 0;
+        try {
+            nativeTvPtr = nativeImportHandoverTableViewIntoSharedGroup(handoverPtr, callerSharedGroupPtr);
+            return new TableView(this.context, this.parent, nativeTvPtr);
+        } catch (RuntimeException e) {
+            if (nativeTvPtr != 0) {
+                TableView.nativeClose(nativeTvPtr);
+            }
+            throw e;
+        }
+    }
+
+    public long importHandoverRow(long handoverPtr, long callerSharedGroupPtr) {
+      return nativeImportHandoverRowIntoSharedGroup(handoverPtr, callerSharedGroupPtr);
+    }
+
+    /**
+     * Handover the query, so it can be used by other SharedGroup (in different thread)
+     * @param callerSharedGroupPtr native pointer to the SharedGroup holding the query
+     * @return native pointer to the handover query
+     */
+    public long handoverQuery(long callerSharedGroupPtr) {
+        return nativeHandoverQuery(callerSharedGroupPtr, nativePtr);
+    }
+
+    private native long nativeFindAll(long nativeQueryPtr, long start, long end, long limit);
+    private native long nativeFindAllWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit);
+    private native long nativeFindAllSortedWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit, long columnIndex, boolean ascending);
+    private native long nativeFindAllMultiSortedWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit, long[] columnIndices, boolean[] ascending);
+    private native long nativeImportHandoverTableViewIntoSharedGroup(long handoverTableViewPtr, long callerSharedGroupPtr);
+    private native long nativeImportHandoverRowIntoSharedGroup(long handoverRowPtr, long callerSharedGroupPtr);
+    private native long nativeHandoverQuery(long callerSharedGroupPtr, long nativeQueryPtr);
     //
     // Aggregation methods
     //
@@ -526,7 +596,7 @@ public long sumInt(long columnIndex) {
         validateQuery();
         return nativeSumInt(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native long nativeSumInt(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native long nativeSumInt(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
 
     public long maximumInt(long columnIndex, long start, long end, long limit) {
@@ -537,7 +607,7 @@ public long maximumInt(long columnIndex) {
         validateQuery();
         return nativeMaximumInt(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native long nativeMaximumInt(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native long nativeMaximumInt(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
 
     public long minimumInt(long columnIndex, long start, long end, long limit) {
@@ -548,7 +618,7 @@ public long minimumInt(long columnIndex) {
         validateQuery();
         return nativeMinimumInt(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native long nativeMinimumInt(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native long nativeMinimumInt(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
 
     public double averageInt(long columnIndex, long start, long end, long limit) {
@@ -559,7 +629,7 @@ public double averageInt(long columnIndex) {
         validateQuery();
         return nativeAverageInt(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native double nativeAverageInt(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native double nativeAverageInt(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
 
     // float aggregation
@@ -572,7 +642,7 @@ public double sumFloat(long columnIndex) {
         validateQuery();
         return nativeSumFloat(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native double nativeSumFloat(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native double nativeSumFloat(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
 
     public float maximumFloat(long columnIndex, long start, long end, long limit) {
@@ -583,7 +653,7 @@ public float maximumFloat(long columnIndex) {
         validateQuery();
         return nativeMaximumFloat(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native float nativeMaximumFloat(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native float nativeMaximumFloat(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
 
     public float minimumFloat(long columnIndex, long start, long end, long limit) {
@@ -594,7 +664,7 @@ public float minimumFloat(long columnIndex) {
         validateQuery();
         return nativeMinimumFloat(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native float nativeMinimumFloat(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native float nativeMinimumFloat(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
 
     public double averageFloat(long columnIndex, long start, long end, long limit) {
@@ -605,7 +675,7 @@ public double averageFloat(long columnIndex) {
         validateQuery();
         return nativeAverageFloat(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native double nativeAverageFloat(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native double nativeAverageFloat(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
 
     // double aggregation
@@ -618,7 +688,7 @@ public double sumDouble(long columnIndex) {
         validateQuery();
         return nativeSumDouble(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native double nativeSumDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native double nativeSumDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
 
     public double maximumDouble(long columnIndex, long start, long end, long limit) {
@@ -629,7 +699,7 @@ public double maximumDouble(long columnIndex) {
         validateQuery();
         return nativeMaximumDouble(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native double nativeMaximumDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native double nativeMaximumDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
 
     public double minimumDouble(long columnIndex, long start, long end, long limit) {
@@ -640,7 +710,7 @@ public double minimumDouble(long columnIndex) {
         validateQuery();
         return nativeMinimumDouble(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native double nativeMinimumDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native double nativeMinimumDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
 
     public double averageDouble(long columnIndex, long start, long end, long limit) {
@@ -651,7 +721,7 @@ public double averageDouble(long columnIndex) {
         validateQuery();
         return nativeAverageDouble(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native double nativeAverageDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native double nativeAverageDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
     // date aggregation
 
@@ -663,7 +733,7 @@ public Date maximumDate(long columnIndex) {
         validateQuery();
         return new Date(nativeMaximumDate(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE) * 1000);
     }
-    protected native long nativeMaximumDate(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native long nativeMaximumDate(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
 
     public Date minimumDate(long columnIndex, long start, long end, long limit) {
@@ -674,7 +744,7 @@ public Date minimumDate(long columnIndex) {
         validateQuery();
         return new Date(nativeMinimumDate(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE) * 1000);
     }
-    protected native long nativeMinimumDate(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native long nativeMinimumDate(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
 
     // isNull and isNotNull
@@ -683,7 +753,7 @@ public TableQuery isNull(long columnIndex) {
         return this;
     }
 
-    protected native void nativeIsNull(long nativePtr, long columnIndex);
+    private native void nativeIsNull(long nativePtr, long columnIndex);
 
     // count
 
@@ -698,7 +768,7 @@ public long count() {
         return nativeCount(nativePtr, 0, Table.INFINITE, Table.INFINITE);
     }
 
-    protected native long nativeCount(long nativeQueryPtr, long start, long end, long limit);
+    private native long nativeCount(long nativeQueryPtr, long start, long end, long limit);
 
 
     // Deletion.
@@ -714,9 +784,32 @@ public long remove() {
         return nativeRemove(nativePtr, 0, Table.INFINITE, Table.INFINITE);
     }
 
-    protected native long nativeRemove(long nativeQueryPtr, long start, long end, long limit);
+    private native long nativeRemove(long nativeQueryPtr, long start, long end, long limit);
 
     private void throwImmutable() {
         throw new IllegalStateException("Mutable method call during read transaction.");
     }
+
+    // Handover
+    public void closeRowHandover (long nativePtr) {
+        if (nativePtr != -1) {
+            nativeCloseRowHandover(nativePtr);
+        }
+    }
+    private native void nativeCloseRowHandover (long nativePtr);// closed from bg realm
+
+    public void closeQueryHandover (long nativePtr) {
+        if (nativePtr != -1) {
+            nativeCloseQueryHandover (nativePtr);
+        }
+    }
+    private native void nativeCloseQueryHandover (long nativePtr);
+
+    public void closeTableViewHandover (long nativePtr) {
+        if (nativePtr != -1) {
+            nativeCloseTableHandover (nativePtr);
+        }
+    }
+    private native void nativeCloseTableHandover (long nativePtr);
+
 }
diff --git a/realm/src/main/java/io/realm/internal/UncheckedRow.java b/realm/src/main/java/io/realm/internal/UncheckedRow.java
index 5d67683589..8a6a285129 100644
--- a/realm/src/main/java/io/realm/internal/UncheckedRow.java
+++ b/realm/src/main/java/io/realm/internal/UncheckedRow.java
@@ -47,13 +47,26 @@ protected UncheckedRow(Context context, Table parent, long nativePtr) {
      * @param index the index of the row
      * @return an instance of Row for the table and index specified
      */
-    public static UncheckedRow get(Context context, Table table, long index) {
+    public static UncheckedRow getByRowIndex(Context context, Table table, long index) {
         long nativeRowPointer = table.nativeGetRowPtr(table.nativePtr, index);
         UncheckedRow row = new UncheckedRow(context, table, nativeRowPointer);
         context.rowReferences.put(new NativeObjectReference(row, context.referenceQueue), context.ROW_REFERENCES_VALUE);
         return row;
     }
 
+    /**
+     * Get the row object from a row pointer
+     * @param context the Realm context
+     * @param table the Table that holds the row
+     * @param nativeRowPointer pointer of a row
+     * @return an instance of Row for the table and row specified
+     */
+    public static UncheckedRow getByRowPointer(Context context, Table table, long nativeRowPointer) {
+        UncheckedRow row = new UncheckedRow(context, table, nativeRowPointer);
+        FinalizerRunnable.references.put(new NativeObjectReference(row, FinalizerRunnable.referenceQueue), Boolean.TRUE);
+        return row;
+    }
+
     /**
      * Get the row object associated to an index in a LinkView
      * @param context the Realm context
@@ -61,7 +74,7 @@ public static UncheckedRow get(Context context, Table table, long index) {
      * @param index the index of the row
      * @return an instance of Row for the LinkView and index specified
      */
-    public static UncheckedRow get(Context context, LinkView linkView, long index) {
+    public static UncheckedRow getByRowIndex(Context context, LinkView linkView, long index) {
         long nativeRowPointer = linkView.nativeGetRow(linkView.nativeLinkViewPtr, index);
         UncheckedRow row = new UncheckedRow(context, linkView.parent.getLinkTarget(linkView.columnIndexInParent), nativeRowPointer);
         context.rowReferences.put(new NativeObjectReference(row, context.referenceQueue), context.ROW_REFERENCES_VALUE);
diff --git a/realm/src/main/java/io/realm/internal/async/BadVersionException.java b/realm/src/main/java/io/realm/internal/async/BadVersionException.java
new file mode 100644
index 0000000000..777e68624e
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/async/BadVersionException.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.async;
+
+import io.realm.exceptions.RealmException;
+
+/**
+ * Triggered when the result of a query could not be used against the current state of the Realm
+ * which might be more up-to-date than the provided results
+ */
+// Triggered from JNI level to indicate a failing Handover due to version mismatch
+public class BadVersionException extends RealmException {
+
+    public BadVersionException(String detailMessage) {
+        super(detailMessage);
+    }
+
+    public BadVersionException(String detailMessage, Throwable exception) {
+        super(detailMessage, exception);
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/async/IndefinitelyRetryPolicy.java b/realm/src/main/java/io/realm/internal/async/IndefinitelyRetryPolicy.java
new file mode 100644
index 0000000000..e5081bdece
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/async/IndefinitelyRetryPolicy.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.async;
+
+/**
+ * Keep retrying the query until both background Realm & caller's Realm converge (i.e have the
+ * same {@code VersionID})
+ * this corresponds to the mode {@link RetryPolicy#MODE_INDEFINITELY}
+ */
+class IndefinitelyRetryPolicy implements RetryPolicy {
+    @Override
+    public boolean shouldRetry() {
+        return true;
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/async/MaxRetryPolicy.java b/realm/src/main/java/io/realm/internal/async/MaxRetryPolicy.java
new file mode 100644
index 0000000000..4a4b67b796
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/async/MaxRetryPolicy.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.async;
+
+/**
+ * Retry the query a number of times (at most #maxNumberOfRetries times)
+ * this corresponds to {@link RetryPolicy#MODE_MAX_RETRY} mode
+ */
+class MaxRetryPolicy implements RetryPolicy {
+    int maxNumberOfRetries;
+
+    MaxRetryPolicy(int maxNbrOfRetries) {
+        this.maxNumberOfRetries = maxNbrOfRetries;
+    }
+
+    @Override
+    public boolean shouldRetry() {
+        return this.maxNumberOfRetries-- > 0;
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/async/NoRetryPolicy.java b/realm/src/main/java/io/realm/internal/async/NoRetryPolicy.java
new file mode 100644
index 0000000000..c92840667c
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/async/NoRetryPolicy.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.async;
+
+/**
+ * Doesn't perform any retry, this corresponds to {@link RetryPolicy#MODE_NO_RETRY} mode
+ */
+class NoRetryPolicy implements RetryPolicy {
+
+    @Override
+    public boolean shouldRetry() {
+        return false;
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/async/RetryPolicy.java b/realm/src/main/java/io/realm/internal/async/RetryPolicy.java
new file mode 100644
index 0000000000..77a530d8f3
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/async/RetryPolicy.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.async;
+
+/**
+ * Define a retry policy in case an {@link io.realm.RealmQuery} fails to
+ * import the result to the caller Realm. (usually because in the meantime, the caller
+ * Realm has advanced the transaction) failing to retry will throw an exception
+ */
+public interface RetryPolicy {
+    /**
+     * No retry this will probably propagate the exception thrown by Core 'Handover failed due to version mismatch'
+     */
+    int MODE_NO_RETRY = 0;
+    /**
+     * Retry the query a number of times
+     */
+    int MODE_MAX_RETRY = 1;
+    /**
+     * Retry indefinitely
+     */
+    int MODE_INDEFINITELY = 2;
+
+    /**
+     * Given the selected mode, this return {@code true} or {@code false} indicating
+     * whether the {@link io.realm.RealmQuery} should keep retrying or not
+     * @return {@code true} if query should be retried, {@code false} otherwise.
+     */
+    boolean shouldRetry ();
+}
diff --git a/realm/src/main/java/io/realm/internal/async/RetryPolicyFactory.java b/realm/src/main/java/io/realm/internal/async/RetryPolicyFactory.java
new file mode 100644
index 0000000000..bf54281cf6
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/async/RetryPolicyFactory.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.async;
+
+/**
+ * Build a {@link RetryPolicy}
+ */
+public class RetryPolicyFactory {
+    /**
+     * Return the appropriate {@link RetryPolicy}
+     * @param mode one of the supported mode in {@link RetryPolicy}
+     * @param maxNumberOfRetries how many times we should retry before giving up
+     *                           (not applicable for {@link RetryPolicy#MODE_INDEFINITELY})
+     * @return new instance of {@code RetryPolicy}
+     */
+    public static RetryPolicy get(int mode, int maxNumberOfRetries) {
+        switch (mode) {
+            case RetryPolicy.MODE_NO_RETRY: {
+                return new NoRetryPolicy();
+            }
+            case RetryPolicy.MODE_MAX_RETRY: {
+                return new MaxRetryPolicy(maxNumberOfRetries);
+            }
+            case RetryPolicy.MODE_INDEFINITELY: {
+                return new IndefinitelyRetryPolicy();
+            }
+            default:
+                throw new IllegalArgumentException("Unsupported retry policy " + mode);
+        }
+    }
+}
