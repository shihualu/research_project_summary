diff --git a/.gitignore b/.gitignore
index d2b71f4..abc5f0c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -33,4 +33,7 @@ local.properties
 #Command line
 proguard-project.txt
 .DS_Store
-.tmp
\ No newline at end of file
+.tmp
+
+# Emacs
+.meghanada/
diff --git a/library/src/main/java/com/evernote/android/job/AbstractJobOpenHelper.java b/library/src/main/java/com/evernote/android/job/AbstractJobOpenHelper.java
new file mode 100644
index 0000000..fb8955b
--- /dev/null
+++ b/library/src/main/java/com/evernote/android/job/AbstractJobOpenHelper.java
@@ -0,0 +1,284 @@
+package com.evernote.android.job;
+
+import android.content.Context;
+import android.database.DatabaseErrorHandler;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.os.Build;
+
+/**
+ * Created by eggcaker on 26/07/2017
+ */
+public abstract class AbstractJobOpenHelper {
+
+    private static final String TAG = SQLiteOpenHelper.class.getSimpleName();
+
+
+    private final Context mContext;
+    private final String mName;
+    private final SQLiteDatabase.CursorFactory mFactory;
+    private final int mNewVersion;
+
+    private SQLiteDatabase mDatabase;
+    private boolean mIsInitializing;
+    private boolean mEnableWriteAheadLogging;
+    private final DatabaseErrorHandler mErrorHandler;
+
+    /**
+     * Create a helper object to create, open, and/or manage a database.
+     * This method always returns very quickly.  The database is not actually
+     * created or opened until one of {@link #getWritableDatabase} or
+     *  is called.
+     *
+     * @param context to use to open or create the database
+     * @param name of the database file, or null for an in-memory database
+     * @param factory to use for creating cursor objects, or null for the default
+     * @param version number of the database (starting at 1); if the database is older,
+     *     {@link #onUpgrade} will be used to upgrade the database; if the database is
+     *     newer, {@link #onDowngrade} will be used to downgrade the database
+     */
+    public AbstractJobOpenHelper (Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
+        this(context, name, factory, version, null);
+    }
+
+    /**
+     * Create a helper object to create, open, and/or manage a database.
+     * The database is not actually created or opened until one of
+     * {@link #getWritableDatabase} or  is called.
+     *
+     * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
+     * used to handle corruption when sqlite reports database corruption.</p>
+     *
+     * @param context to use to open or create the database
+     * @param name of the database file, or null for an in-memory database
+     * @param factory to use for creating cursor objects, or null for the default
+     * @param version number of the database (starting at 1); if the database is older,
+     *     {@link #onUpgrade} will be used to upgrade the database; if the database is
+     *     newer, {@link #onDowngrade} will be used to downgrade the database
+     * @param errorHandler the {@link DatabaseErrorHandler} to be used when sqlite reports database
+     * corruption, or null to use the default error handler.
+     */
+    public AbstractJobOpenHelper (Context context, String name, SQLiteDatabase.CursorFactory factory, int version,
+            DatabaseErrorHandler errorHandler) {
+        if (version < 1) throw new IllegalArgumentException("Version must be >= 1, was " + version);
+
+        mContext = context;
+        mName = name;
+        mFactory = factory;
+        mNewVersion = version;
+        mErrorHandler = errorHandler;
+    }
+
+    /**
+     * Return the name of the SQLite database being opened, as given to
+     * the constructor.
+     */
+    public String getDatabaseName() {
+        return mName;
+    }
+
+    /**
+     * Enables or disables the use of write-ahead logging for the database.
+     *
+     * Write-ahead logging cannot be used with read-only databases so the value of
+     * this flag is ignored if the database is opened read-only.
+     *
+     * @param enabled True if write-ahead logging should be enabled, false if it
+     * should be disabled.
+     *
+     * @see SQLiteDatabase#enableWriteAheadLogging()
+     */
+    public void setWriteAheadLoggingEnabled(boolean enabled) {
+        synchronized (this) {
+            if (mEnableWriteAheadLogging != enabled) {
+                if (mDatabase != null && mDatabase.isOpen() && !mDatabase.isReadOnly()) {
+                    if (enabled) {
+                        mDatabase.enableWriteAheadLogging();
+                    } else {
+                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+                            mDatabase.disableWriteAheadLogging();
+                        }
+                    }
+                }
+                mEnableWriteAheadLogging = enabled;
+            }
+        }
+    }
+
+    /**
+       Simplified getWritableDatabase from SDK source
+     */
+    public SQLiteDatabase getWritableDatabase() {
+        synchronized (this) {
+            return getDatabaseLocked();
+        }
+    }
+
+    private SQLiteDatabase getDatabaseLocked() {
+        // always get writable database
+        if (mDatabase != null) {
+            if (!mDatabase.isOpen()) {
+                // Darn!  The user closed the database by calling mDatabase.close().
+                mDatabase = null;
+            } else if (!mDatabase.isReadOnly()) {
+                // The database is already open for business.
+                return mDatabase;
+            }
+        }
+
+        if (mIsInitializing) {
+            throw new IllegalStateException("getDatabase called recursively");
+        }
+
+        SQLiteDatabase db = mDatabase;
+        try {
+            mIsInitializing = true;
+
+            if (db == null && mName == null) {
+                db = SQLiteDatabase.create(null);
+            } else if (db == null) {
+                try {
+                    final String path = mContext.getDatabasePath(mName).getPath();
+                    db = SQLiteDatabase.openDatabase(path, mFactory,
+                            (SQLiteDatabase.CREATE_IF_NECESSARY | SQLiteDatabase.NO_LOCALIZED_COLLATORS),
+                            mErrorHandler);
+                } catch (SQLiteException ex) {
+                    throw ex;
+                }
+            }
+
+            onConfigure(db);
+
+            final int version = db.getVersion();
+            if (version != mNewVersion) {
+
+                db.beginTransaction();
+                try {
+                    if (version == 0) {
+                        onCreate(db);
+                    } else {
+                        if (version > mNewVersion) {
+                            onDowngrade(db, version, mNewVersion);
+                        } else {
+                            onUpgrade(db, version, mNewVersion);
+                        }
+                    }
+                    db.setVersion(mNewVersion);
+                    db.setTransactionSuccessful();
+                } finally {
+                    db.endTransaction();
+                }
+            }
+
+            onOpen(db);
+
+            mDatabase = db;
+            return db;
+        } finally {
+            mIsInitializing = false;
+            if (db != null && db != mDatabase) {
+                db.close();
+            }
+        }
+    }
+
+    /**
+     * Close any open database object.
+     */
+    public synchronized void close() {
+        if (mIsInitializing) throw new IllegalStateException("Closed during initialization");
+
+        if (mDatabase != null && mDatabase.isOpen()) {
+            mDatabase.close();
+            mDatabase = null;
+        }
+    }
+
+    /**
+     * Called when the database connection is being configured, to enable features
+     * such as write-ahead logging or foreign key support.
+     * <p>
+     * This method is called before {@link #onCreate}, {@link #onUpgrade},
+     * {@link #onDowngrade}, or {@link #onOpen} are called.  It should not modify
+     * the database except to configure the database connection as required.
+     * </p><p>
+     * This method should only call methods that configure the parameters of the
+     * database connection, such as {@link SQLiteDatabase#enableWriteAheadLogging}
+     * {@link SQLiteDatabase#setForeignKeyConstraintsEnabled},
+     * {@link SQLiteDatabase#setLocale}, {@link SQLiteDatabase#setMaximumSize},
+     * or executing PRAGMA statements.
+     * </p>
+     *
+     * @param db The database.
+     */
+    public void onConfigure(SQLiteDatabase db) {}
+
+    /**
+     * Called when the database is created for the first time. This is where the
+     * creation of tables and the initial population of the tables should happen.
+     *
+     * @param db The database.
+     */
+    public abstract void onCreate(SQLiteDatabase db);
+
+    /**
+     * Called when the database needs to be upgraded. The implementation
+     * should use this method to drop tables, add tables, or do anything else it
+     * needs to upgrade to the new schema version.
+     *
+     * <p>
+     * The SQLite ALTER TABLE documentation can be found
+     * <a href="http://sqlite.org/lang_altertable.html">here</a>. If you add new columns
+     * you can use ALTER TABLE to insert them into a live table. If you rename or remove columns
+     * you can use ALTER TABLE to rename the old table, then create the new table and then
+     * populate the new table with the contents of the old table.
+     * </p><p>
+     * This method executes within a transaction.  If an exception is thrown, all changes
+     * will automatically be rolled back.
+     * </p>
+     *
+     * @param db The database.
+     * @param oldVersion The old database version.
+     * @param newVersion The new database version.
+     */
+    public abstract void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion);
+
+    /**
+     * Called when the database needs to be downgraded. This is strictly similar to
+     * {@link #onUpgrade} method, but is called whenever current version is newer
+     * than requested one.
+     * However, this method is not abstract, so it is not mandatory for a customer to
+     * implement it. If not overridden, default implementation will reject downgrade and
+     * throws SQLiteException
+     *
+     * <p>
+     * This method executes within a transaction.  If an exception is thrown, all changes
+     * will automatically be rolled back.
+     * </p>
+     *
+     * @param db The database.
+     * @param oldVersion The old database version.
+     * @param newVersion The new database version.
+     */
+    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        throw new SQLiteException("Can't downgrade database from version "
+                + oldVersion + " to " + newVersion);
+    }
+
+    /**
+     * Called when the database has been opened.  The implementation
+     * should check {@link SQLiteDatabase#isReadOnly} before updating the
+     * database.
+     * <p>
+     * This method is called after the database connection has been configured
+     * and after the database schema has been created, upgraded or downgraded as necessary.
+     * If the database connection must be configured in some way before the schema
+     * is created, upgraded, or downgraded, do it in {@link #onConfigure} instead.
+     * </p>
+     *
+     * @param db The database.
+     */
+    public void onOpen(SQLiteDatabase db) {}
+}
+
diff --git a/library/src/main/java/com/evernote/android/job/JobStorage.java b/library/src/main/java/com/evernote/android/job/JobStorage.java
index e6d7059..2031466 100644
--- a/library/src/main/java/com/evernote/android/job/JobStorage.java
+++ b/library/src/main/java/com/evernote/android/job/JobStorage.java
@@ -23,15 +23,12 @@
 import android.database.SQLException;
 import android.database.sqlite.SQLiteCantOpenDatabaseException;
 import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.annotation.VisibleForTesting;
 import android.text.TextUtils;
 import android.util.LruCache;
-
 import com.evernote.android.job.util.JobCat;
-
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -39,6 +36,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
+import net.vrallev.android.cat.CatLog;
 
 /**
  * @author rwondratschek
@@ -319,7 +317,6 @@ private JobRequest load(int id, boolean includeStarted) {
         } else {
             try {
                 return mDbHelper.getWritableDatabase();
-
             } catch (SQLiteCantOpenDatabaseException e) {
                 CAT.e(e);
 
@@ -435,7 +432,7 @@ protected JobRequest create(Integer id) {
         }
     }
 
-    private static final class JobOpenHelper extends SQLiteOpenHelper {
+    private static final class JobOpenHelper extends AbstractJobOpenHelper {
 
         private JobOpenHelper(Context context, String databasePath) {
             super(context, databasePath, null, DATABASE_VERSION, new JobStorageDatabaseErrorHandler());
