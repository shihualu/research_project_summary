diff --git a/README.md b/README.md
index f219bd83..c8672ae3 100644
--- a/README.md
+++ b/README.md
@@ -1,8 +1,8 @@
 ## Tinker
 [![license](http://img.shields.io/badge/license-BSD3-brightgreen.svg?style=flat)](https://github.com/Tencent/tinker/blob/master/LICENSE)
-[![Release Version](https://img.shields.io/badge/release-1.9.5-red.svg)](https://github.com/Tencent/tinker/releases)
+[![Release Version](https://img.shields.io/badge/release-1.9.9-red.svg)](https://github.com/Tencent/tinker/releases)
 [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/Tencent/tinker/pulls)
-[![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.9.5-red.svg)](https://github.com/Tencent/tinker/wiki)
+[![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.9.9-red.svg)](https://github.com/Tencent/tinker/wiki)
 
 Tinker is a hot-fix solution library for Android, it supports dex, library and resources update without reinstalling apk.
 
diff --git a/build.gradle b/build.gradle
index 1edf14f1..4a70a310 100644
--- a/build.gradle
+++ b/build.gradle
@@ -2,18 +2,22 @@
 buildscript {
     repositories {
         mavenLocal()
+        mavenCentral()
+        google()
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.2.0'
+        classpath 'com.android.tools.build:gradle:3.2.1'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
-        classpath "com.github.dcendents:android-maven-gradle-plugin:1.4.1"
+        classpath "com.github.dcendents:android-maven-gradle-plugin:2.1"
     }
 }
 
 allprojects {
     repositories {
         mavenLocal()
+        mavenCentral()
+        google()
         jcenter()
     }
 
@@ -25,10 +29,10 @@ allprojects {
 
 ext {
     minSdkVersion = 10
-    compileSdkVersion = 23
-    targetSdkVersion = compileSdkVersion
-    buildToolsVersion = '23.0.2'
-    supportLibVersion = '25.1.0'
+    compileSdkVersion = 26
+    targetSdkVersion = 23
+    buildToolsVersion = '28.0.3'
+    supportLibVersion = '28.0.0'
     javaVersion = JavaVersion.VERSION_1_7
 
     GROUP = 'com.tencent.tinker'
diff --git a/gradle.properties b/gradle.properties
index 24c09552..bc5983db 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,5 +16,5 @@
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
-VERSION_NAME_PREFIX=1.9.8
+VERSION_NAME_PREFIX=1.9.12
 VERSION_NAME_SUFFIX=
\ No newline at end of file
diff --git a/gradle/android-artifacts.gradle b/gradle/android-artifacts.gradle
index 584ca11a..9c90fcb2 100644
--- a/gradle/android-artifacts.gradle
+++ b/gradle/android-artifacts.gradle
@@ -84,24 +84,51 @@ publishing {
             artifact("$buildDir/outputs/aar/${project.getName()}-release.aar")
             artifact androidJavadocsJar
             pom.withXml {
-                def dependenciesNode = asNode().appendNode('dependencies')
-                configurations.compile.allDependencies.each {
-                    if (it.group != null && it.name != null) {
-                        def dependencyNode = dependenciesNode.appendNode('dependency')
-                        dependencyNode.appendNode('groupId', it.group)
-                        dependencyNode.appendNode('artifactId', it.name)
-                        dependencyNode.appendNode('version', it.version)
-
-                        if (it.excludeRules.size() > 0) {
-                            def exclusionsNode = dependencyNode.appendNode('exclusions')
-                            it.excludeRules.each { rule ->
-                                def exclusionNode = exclusionsNode.appendNode('exclusion')
-                                exclusionNode.appendNode('groupId', rule.group)
-                                exclusionNode.appendNode('artifactId', rule.module)
-                            }
+                // Resolve dependencies
+                final depsNode = asNode().appendNode('dependencies')
+                final addDep = { Dependency dep, String scope ->
+                    if (dep.group == null || dep.version == null || dep.name == null
+                            || dep.name == "unspecified")
+                        return // ignore invalid dependencies
+
+                    // Determine actual artifactId for the dependency
+                    def artifactId = dep.name
+                    if (dep instanceof ProjectDependency) {
+                        def p = (dep as ProjectDependency).dependencyProject
+                        if (p.hasProperty('artifactId'))
+                            artifactId = p.property('artifactId')
+                    }
+
+                    def node = depsNode.appendNode('dependency')
+                    node.appendNode('groupId', dep.group)
+                    node.appendNode('artifactId', artifactId)
+                    node.appendNode('version', dep.version)
+                    node.appendNode('scope', scope)
+
+                    if (!dep.transitive) {
+                        // If this dependency is transitive, we should force exclude all its dependencies them from the POM
+                        final exclusionNode = node.appendNode('exclusions').appendNode('exclusion')
+                        exclusionNode.appendNode('groupId', '*')
+                        exclusionNode.appendNode('artifactId', '*')
+                    } else if (!dep.properties.excludeRules.empty) {
+                        // Otherwise add specified exclude rules
+                        final exclusionNode = node.appendNode('exclusions').appendNode('exclusion')
+                        dep.properties.excludeRules.each { ExcludeRule rule ->
+                            exclusionNode.appendNode('groupId', rule.group ?: '*')
+                            exclusionNode.appendNode('artifactId', rule.module ?: '*')
                         }
                     }
                 }
+
+                [
+                        'compile':          'compile',
+                        'api':              'compile',
+                        'implementation':   'runtime',
+                        'compileOnly':      'compile',
+                        'runtimeOnly':      'runtime'
+                ].each { conf, scope ->
+                    project.configurations[conf].allDependencies.each { addDep(it, scope) }
+                }
             }
         }
     }
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index dbdc05d2..3f0f9be6 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-all.zip
diff --git a/third-party/aosp-dexutils/build.gradle b/third-party/aosp-dexutils/build.gradle
index 1844d317..fff52903 100644
--- a/third-party/aosp-dexutils/build.gradle
+++ b/third-party/aosp-dexutils/build.gradle
@@ -1,4 +1,4 @@
-apply plugin: 'java'
+apply plugin: 'java-library'
 
 [compileJava, compileTestJava, javadoc]*.options*.encoding = 'UTF-8'
 
diff --git a/third-party/bsdiff-util/build.gradle b/third-party/bsdiff-util/build.gradle
index 1844d317..fff52903 100644
--- a/third-party/bsdiff-util/build.gradle
+++ b/third-party/bsdiff-util/build.gradle
@@ -1,4 +1,4 @@
-apply plugin: 'java'
+apply plugin: 'java-library'
 
 [compileJava, compileTestJava, javadoc]*.options*.encoding = 'UTF-8'
 
diff --git a/third-party/tinker-ziputils/build.gradle b/third-party/tinker-ziputils/build.gradle
index 1844d317..fff52903 100644
--- a/third-party/tinker-ziputils/build.gradle
+++ b/third-party/tinker-ziputils/build.gradle
@@ -1,4 +1,4 @@
-apply plugin: 'java'
+apply plugin: 'java-library'
 
 [compileJava, compileTestJava, javadoc]*.options*.encoding = 'UTF-8'
 
diff --git a/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipUtil.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipUtil.java
index 24f61d28..17b2c7e5 100644
--- a/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipUtil.java
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipUtil.java
@@ -79,4 +79,17 @@ public static void extractLargeModifyFile(TinkerZipEntry sourceArscEntry, File n
             }
         }
     }
+
+    public static boolean validateZipEntryName(File destDir, String entryName) {
+        if (entryName == null || entryName.isEmpty()) {
+            return false;
+        }
+        try {
+            final String canonicalDestinationDir = destDir.getCanonicalPath();
+            final File destEntryFile = destDir.toPath().resolve(entryName).toFile();
+            return destEntryFile.getCanonicalPath().startsWith(canonicalDestinationDir + File.separator);
+        } catch (Throwable ignored) {
+            return false;
+        }
+    }
 }
diff --git a/tinker-android/tinker-android-anno/build.gradle b/tinker-android/tinker-android-anno/build.gradle
index 263ca599..24306a3c 100644
--- a/tinker-android/tinker-android-anno/build.gradle
+++ b/tinker-android/tinker-android-anno/build.gradle
@@ -1,4 +1,4 @@
-apply plugin: 'java'
+apply plugin: 'java-library'
 
 version rootProject.ext.VERSION_NAME
 group rootProject.ext.GROUP
@@ -6,7 +6,7 @@ group rootProject.ext.GROUP
 [compileJava, compileTestJava, javadoc]*.options*.encoding = 'UTF-8'
 
 dependencies {
-    compile fileTree(dir: 'libs', include: ['*.jar'])
+    implementation fileTree(dir: 'libs', include: ['*.jar'])
 }
 
 sourceSets {
diff --git a/tinker-android/tinker-android-lib/build.gradle b/tinker-android/tinker-android-lib/build.gradle
index bcc8b83f..c91a8205 100644
--- a/tinker-android/tinker-android-lib/build.gradle
+++ b/tinker-android/tinker-android-lib/build.gradle
@@ -14,10 +14,11 @@ android {
 }
 
 dependencies {
-    compile fileTree(dir: 'libs', include: ['*.jar'])
-    testCompile 'junit:junit:4.12'
-    compile project(':tinker-commons')
-    compile project(':tinker-android:tinker-android-loader')
+    implementation fileTree(dir: 'libs', include: ['*.jar'])
+    testImplementation 'junit:junit:4.12'
+    implementation "com.android.support:support-annotations:${rootProject.ext.supportLibVersion}"
+    implementation project(':tinker-android:tinker-android-loader')
+    api project(':tinker-commons')
 }
 
 task buildTinkerSdk(type: Copy, dependsOn: [build]) {
diff --git a/tinker-android/tinker-android-lib/src/main/AndroidManifest.xml b/tinker-android/tinker-android-lib/src/main/AndroidManifest.xml
index fbcfdc79..9a1bf2b6 100644
--- a/tinker-android/tinker-android-lib/src/main/AndroidManifest.xml
+++ b/tinker-android/tinker-android-lib/src/main/AndroidManifest.xml
@@ -6,28 +6,24 @@
         <!--
             Notice:
             Following service must run in the same process.
-              TinkerPatchService$IntentServiceRunner
-              TinkerPatchService$IntentServiceRunner$InnerService
-              TinkerPatchService$JobServiceRunner
+              TinkerPatchService
+              TinkerPatchService$InnerService
         -->
         <!-- ########################################################################### -->
         <service
-            android:name=".service.TinkerPatchService$IntentServiceRunner"
-            android:exported="false"
-            android:process=":patch"/>
-        <service
-            android:name=".service.TinkerPatchService$IntentServiceRunner$InnerService"
+            android:name=".service.TinkerPatchService"
+            android:permission="android.permission.BIND_JOB_SERVICE"
             android:exported="false"
             android:process=":patch"/>
         <service
-            android:name=".service.TinkerPatchService$JobServiceRunner"
-            android:permission="android.permission.BIND_JOB_SERVICE"
+            android:name=".service.TinkerPatchService$InnerService"
             android:exported="false"
             android:process=":patch"/>
         <!-- ########################################################################### -->
 
         <service
             android:name=".service.DefaultTinkerResultService"
+            android:permission="android.permission.BIND_JOB_SERVICE"
             android:exported="false"/>
 
     </application>
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLifeCycle.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/entry/ApplicationLifeCycle.java
similarity index 97%
rename from tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLifeCycle.java
rename to tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/entry/ApplicationLifeCycle.java
index 3b67094d..3e26f479 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLifeCycle.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/entry/ApplicationLifeCycle.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.tencent.tinker.loader.app;
+package com.tencent.tinker.entry;
 
 /**
  * Created by zhangshaowen on 16/3/8.
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/entry/ApplicationLike.java
similarity index 96%
rename from tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java
rename to tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/entry/ApplicationLike.java
index 4278e3f1..68201d0a 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/entry/ApplicationLike.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.tencent.tinker.loader.app;
+package com.tencent.tinker.entry;
 
 import android.app.Application;
 import android.content.Context;
@@ -22,10 +22,12 @@
 import android.content.res.AssetManager;
 import android.content.res.Configuration;
 import android.content.res.Resources;
+import android.support.annotation.Keep;
 
 /**
  * Created by zhangshaowen on 16/7/28.
  */
+@Keep
 public abstract class ApplicationLike implements ApplicationLifeCycle {
     private final Application application;
     private final Intent      tinkerResultIntent;
@@ -99,22 +101,27 @@ public void onBaseContextAttached(Context base) {
 
     }
     //some get methods that may be overwrite
+    @Keep
     public Resources getResources(Resources resources) {
         return resources;
     }
 
+    @Keep
     public ClassLoader getClassLoader(ClassLoader classLoader) {
         return classLoader;
     }
 
+    @Keep
     public AssetManager getAssets(AssetManager assetManager) {
        return assetManager;
     }
 
+    @Keep
     public Object getSystemService(String name, Object service) {
         return service;
     }
 
+    @Keep
     public Context getBaseContext(Context base) {
         return base;
     }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/DefaultApplicationLike.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/entry/DefaultApplicationLike.java
similarity index 96%
rename from tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/DefaultApplicationLike.java
rename to tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/entry/DefaultApplicationLike.java
index eabf146e..af0f37b7 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/DefaultApplicationLike.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/entry/DefaultApplicationLike.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.tencent.tinker.loader.app;
+package com.tencent.tinker.entry;
 
 /**
  * Created by zhangshaowen on 16/3/8.
@@ -24,11 +24,13 @@
 import android.content.Context;
 import android.content.Intent;
 import android.content.res.Configuration;
+import android.support.annotation.Keep;
 import android.util.Log;
 
 /**
  * Empty implementation of {@link ApplicationLike}.
  */
+@Keep
 public class DefaultApplicationLike extends ApplicationLike {
     private static final String TAG = "Tinker.DefaultAppLike";
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
index 029d49be..d2e86620 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
@@ -19,13 +19,13 @@
 import android.content.Context;
 import android.os.Build;
 
+import com.tencent.tinker.entry.ApplicationLike;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerApplicationHelper;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
 import com.tencent.tinker.lib.tinker.TinkerLoadResult;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.TinkerRuntimeException;
-import com.tencent.tinker.loader.app.ApplicationLike;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
index 2ae8a1d3..f60425de 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
@@ -101,9 +101,9 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
             // if it is interpret now, use changing flag to wait main process
             final String finalOatDir = oldInfo.oatDir.equals(ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH)
                 ? ShareConstants.CHANING_DEX_OPTIMIZE_PATH : oldInfo.oatDir;
-            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5, Build.FINGERPRINT, finalOatDir);
+            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5, false, Build.FINGERPRINT, finalOatDir);
         } else {
-            newInfo = new SharePatchInfo("", patchMd5, Build.FINGERPRINT, ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH);
+            newInfo = new SharePatchInfo("", patchMd5, false, Build.FINGERPRINT, ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH);
         }
 
         //it is a new patch, we first delete if there is any files
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
index cc43ae28..b1421c48 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
@@ -87,7 +87,7 @@ public void onPatchPackageCheckFail(File patchFile, int errorCode) {
             || errorCode == ShareConstants.ERROR_PACKAGE_CHECK_LIB_META_CORRUPTED
             || errorCode == ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED) {
             //delete temp files
-            Tinker.with(context).cleanPatchByVersion(patchFile);
+            Tinker.with(context).cleanPatchByPatchApk(patchFile);
         }
     }
 
@@ -124,7 +124,7 @@ public void onPatchTypeExtractFail(File patchFile, File extractTo, String filena
         TinkerLog.i(TAG, "patchReporter onPatchTypeExtractFail: file extract fail type: %s, path: %s, extractTo: %s, filename: %s",
             ShareTinkerInternals.getTypeString(fileType), patchFile.getPath(), extractTo.getPath(), filename);
         //delete temp files
-        Tinker.with(context).cleanPatchByVersion(patchFile);
+        Tinker.with(context).cleanPatchByPatchApk(patchFile);
     }
 
     /**
@@ -147,7 +147,7 @@ public void onPatchDexOptFail(File patchFile, List<File> dexFiles, Throwable t)
             shouldRetry = true;
             deleteOptFiles(dexFiles);
         } else {
-            Tinker.with(context).cleanPatchByVersion(patchFile);
+            Tinker.with(context).cleanPatchByPatchApk(patchFile);
         }
     }
 
@@ -205,7 +205,7 @@ public void onPatchException(File patchFile, Throwable e) {
         //don't accept request any more!
         Tinker.with(context).setTinkerDisable();
         ////delete temp files, I think we don't have to clean all patch
-        Tinker.with(context).cleanPatchByVersion(patchFile);
+        Tinker.with(context).cleanPatchByPatchApk(patchFile);
     }
 
     private void deleteOptFiles(List<File> dexFiles) {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
index 95429503..f3b0d073 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
@@ -16,46 +16,52 @@
 
 package com.tencent.tinker.lib.service;
 
-import android.app.IntentService;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
+import android.support.annotation.NonNull;
+import com.tencent.tinker.lib.util.TinkerJobIntentService;
 
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.loader.BuildConfig;
 import com.tencent.tinker.loader.TinkerRuntimeException;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
 
 /**
  * Created by zhangshaowen on 16/3/14.
  */
-public abstract class AbstractResultService extends IntentService {
+public abstract class AbstractResultService extends TinkerJobIntentService {
     private static final String TAG = "Tinker.AbstractResultService";
+    private static final int JOB_ID = 0xf3f4f5f6;
 
     private static final String RESULT_EXTRA = "result_extra";
 
-
-    /**
-     * Creates an IntentService.  Invoked by your subclass's constructor.
-     */
-    public AbstractResultService() {
-        super(AbstractResultService.class.getSimpleName());
-    }
-
     public static void runResultService(Context context, PatchResult result, String resultServiceClass) {
         if (resultServiceClass == null) {
             throw new TinkerRuntimeException("resultServiceClass is null.");
         }
+        try {
+            if (!TinkerJobIntentService.class.isAssignableFrom(Class.forName(resultServiceClass))) {
+                throw new TinkerRuntimeException("on tinker version " + BuildConfig.TINKER_VERSION + " result service class must inherit from TinkerJobIntentService.");
+            }
+        } catch (ClassNotFoundException e) {
+            throw new TinkerRuntimeException("cannot find result service class: " + resultServiceClass, e);
+        }
         try {
             Intent intent = new Intent();
             intent.setClassName(context, resultServiceClass);
             intent.putExtra(RESULT_EXTRA, result);
-
-            context.startService(intent);
+            enqueueWork(context, new ComponentName(context, resultServiceClass), JOB_ID, intent);
         } catch (Throwable throwable) {
             TinkerLog.e(TAG, "run result service fail, exception:" + throwable);
         }
     }
 
     @Override
+    protected void onHandleWork(@NonNull Intent intent) {
+        onHandleIntent(intent);
+    }
+
     protected void onHandleIntent(Intent intent) {
         if (intent == null) {
             TinkerLog.e(TAG, "AbstractResultService received a null intent, ignoring.");
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
index 020a486e..d07c3143 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
@@ -16,110 +16,50 @@
 
 package com.tencent.tinker.lib.service;
 
-import android.annotation.TargetApi;
-import android.app.IntentService;
 import android.app.Notification;
 import android.app.Service;
-import android.app.job.JobInfo;
-import android.app.job.JobParameters;
-import android.app.job.JobScheduler;
-import android.app.job.JobService;
-import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
-import android.os.AsyncTask;
 import android.os.Build;
-import android.os.Handler;
 import android.os.IBinder;
-import android.os.Looper;
-import android.os.PersistableBundle;
 import android.os.SystemClock;
-import android.support.annotation.Nullable;
 
 import com.tencent.tinker.lib.patch.AbstractPatch;
 import com.tencent.tinker.lib.tinker.Tinker;
+import com.tencent.tinker.lib.util.TinkerJobIntentService;
 import com.tencent.tinker.lib.util.TinkerLog;
-import com.tencent.tinker.lib.util.TinkerServiceInternals;
 import com.tencent.tinker.loader.TinkerRuntimeException;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
 
 import java.io.File;
-import java.lang.ref.WeakReference;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * Created by zhangshaowen on 16/3/14.
  */
-public class TinkerPatchService {
+public class TinkerPatchService extends TinkerJobIntentService {
     private static final String TAG = "Tinker.TinkerPatchService";
 
+    private static final int JOB_ID = 0xf0f1f2f3;
+
     private static final String PATCH_PATH_EXTRA = "patch_path_extra";
     private static final String RESULT_CLASS_EXTRA = "patch_result_class";
-    private static final int MIN_SDKVER_TO_USE_JOBSCHEDULER = 26;
 
     private static AbstractPatch upgradePatchProcessor = null;
     private static int notificationId = ShareConstants.TINKER_PATCH_SERVICE_NOTIFICATION;
     private static Class<? extends AbstractResultService> resultServiceClass = null;
-    private static Handler mHandler = new Handler(Looper.getMainLooper());
 
     public static void runPatchService(final Context context, final String path) {
-        try {
-            if (Build.VERSION.SDK_INT < MIN_SDKVER_TO_USE_JOBSCHEDULER) {
-                runPatchServiceByIntentService(context, path);
-            } else {
-                try {
-                    runPatchServiceByJobScheduler(context, path);
-                } catch (Throwable ignored) {
-                    // ignored.
-                }
-                mHandler.postDelayed(new Runnable() {
-                    @Override
-                    public void run() {
-                        TinkerLog.i(TAG, "check if patch service is running.");
-                        if (!TinkerServiceInternals.isTinkerPatchServiceRunning(context)) {
-                            TinkerLog.w(TAG, "patch service is not running, retry with IntentService.");
-                            try {
-                                runPatchServiceByIntentService(context, path);
-                                TinkerLog.i(TAG, "successfully start patch service with IntentService.");
-                            } catch (Throwable thr) {
-                                TinkerLog.e(TAG, "failure to start patch service with IntentService. osver: %s, manu: %s, msg: %s", Build.VERSION.SDK_INT, Build.MANUFACTURER, thr.toString());
-                            }
-                        }
-                    }
-                }, TimeUnit.SECONDS.toMillis(5));
-            }
-        } catch (Throwable throwable) {
-            TinkerLog.e(TAG, "start patch service fail, exception:" + throwable);
-        }
-    }
-
-    private static void runPatchServiceByIntentService(Context context, String path) {
-        TinkerLog.i(TAG, "run patch service by intent service.");
-        Intent intent = new Intent(context, IntentServiceRunner.class);
+        TinkerLog.i(TAG, "run patch service...");
+        Intent intent = new Intent(context, TinkerPatchService.class);
         intent.putExtra(PATCH_PATH_EXTRA, path);
         intent.putExtra(RESULT_CLASS_EXTRA, resultServiceClass.getName());
-        context.startService(intent);
-    }
-
-    @TargetApi(21)
-    private static boolean runPatchServiceByJobScheduler(Context context, String path) {
-        TinkerLog.i(TAG, "run patch service by job scheduler.");
-        final JobInfo.Builder jobInfoBuilder = new JobInfo.Builder(
-                1, new ComponentName(context, JobServiceRunner.class)
-        );
-        final PersistableBundle extras = new PersistableBundle();
-        extras.putString(PATCH_PATH_EXTRA, path);
-        extras.putString(RESULT_CLASS_EXTRA, resultServiceClass.getName());
-        jobInfoBuilder.setExtras(extras);
-        jobInfoBuilder.setOverrideDeadline(5);
-        final JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
-        if (jobScheduler == null) {
-            TinkerLog.e(TAG, "jobScheduler is null.");
-            return false;
+        try {
+            enqueueWork(context, TinkerPatchService.class, JOB_ID, intent);
+        } catch (Throwable thr) {
+            TinkerLog.e(TAG, "run patch service fail, exception:" + thr);
         }
-        return (jobScheduler.schedule(jobInfoBuilder.build()) == JobScheduler.RESULT_SUCCESS);
     }
 
     public static void setPatchProcessor(AbstractPatch upgradePatch, Class<? extends AbstractResultService> serviceClass) {
@@ -147,14 +87,6 @@ public static String getPatchResultExtra(Intent intent) {
         return ShareIntentUtil.getStringExtra(intent, RESULT_CLASS_EXTRA);
     }
 
-    public static Class<? extends Service> getExpectedRealRunnerClass() {
-        if (Build.VERSION.SDK_INT < MIN_SDKVER_TO_USE_JOBSCHEDULER) {
-            return IntentServiceRunner.class;
-        } else {
-            return JobServiceRunner.class;
-        }
-    }
-
     /**
      * set the tinker notification id you want
      * @param id
@@ -218,131 +150,64 @@ private static void doApplyPatch(Context context, Intent intent) {
         sIsPatchApplying.set(false);
     }
 
-    public static class IntentServiceRunner extends IntentService {
+    @Override
+    protected void onHandleWork(Intent intent) {
+        increasingPriority();
+        doApplyPatch(this, intent);
+    }
 
-        public IntentServiceRunner() {
-            super("TinkerPatchService");
+    private void increasingPriority() {
+        if (Build.VERSION.SDK_INT >= 26) {
+            TinkerLog.i(TAG, "for system version >= Android O, we just ignore increasingPriority "
+                    + "job to avoid crash or toasts.");
+            return;
         }
 
-        @Override
-        protected void onHandleIntent(@Nullable Intent intent) {
-            increasingPriority();
-            doApplyPatch(getApplicationContext(), intent);
+        if ("ZUK".equals(Build.MANUFACTURER)) {
+            TinkerLog.i(TAG, "for ZUK device, we just ignore increasingPriority "
+                    + "job to avoid crash.");
+            return;
         }
 
-        private void increasingPriority() {
-//        if (Build.VERSION.SDK_INT > 24) {
-//            TinkerLog.i(TAG, "for Android 7.1, we just ignore increasingPriority job");
-//            return;
-//        }
-            if (Build.VERSION.SDK_INT >= 26) {
-                TinkerLog.i(TAG, "for system version >= Android O, we just ignore increasingPriority "
-                        + "job to avoid crash or toasts.");
-                return;
-            }
-
-            if ("ZUK".equals(Build.MANUFACTURER)) {
-                TinkerLog.i(TAG, "for ZUK device, we just ignore increasingPriority "
-                        + "job to avoid crash.");
-                return;
+        TinkerLog.i(TAG, "try to increase patch process priority");
+        try {
+            Notification notification = new Notification();
+            if (Build.VERSION.SDK_INT < 18) {
+                startForeground(notificationId, notification);
+            } else {
+                startForeground(notificationId, notification);
+                // start InnerService
+                startService(new Intent(this, InnerService.class));
             }
+        } catch (Throwable e) {
+            TinkerLog.i(TAG, "try to increase patch process priority error:" + e);
+        }
+    }
 
-            TinkerLog.i(TAG, "try to increase patch process priority");
+    /**
+     * I don't want to do this, believe me
+     */
+    public static class InnerService extends Service {
+        @Override
+        public void onCreate() {
+            super.onCreate();
             try {
-                Notification notification = new Notification();
-                if (Build.VERSION.SDK_INT < 18) {
-                    startForeground(notificationId, notification);
-                } else {
-                    startForeground(notificationId, notification);
-                    // start InnerService
-                    startService(new Intent(this, InnerService.class));
-                }
+                startForeground(notificationId, new Notification());
             } catch (Throwable e) {
-                TinkerLog.i(TAG, "try to increase patch process priority error:" + e);
-            }
-        }
-
-        /**
-         * I don't want to do this, believe me
-         */
-        //InnerService
-        public static class InnerService extends Service {
-            @Override
-            public void onCreate() {
-                super.onCreate();
-                try {
-                    startForeground(notificationId, new Notification());
-                } catch (Throwable e) {
-                    TinkerLog.e(TAG, "InnerService set service for push exception:%s.", e);
-                }
-                // kill
-                stopSelf();
-            }
-
-            @Override
-            public void onDestroy() {
-                stopForeground(true);
-                super.onDestroy();
-            }
-
-            @Override
-            public IBinder onBind(Intent intent) {
-                return null;
+                TinkerLog.e(TAG, "InnerService set service for push exception:%s.", e);
             }
+            stopSelf();
         }
-    }
-
-    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
-    public static class JobServiceRunner extends JobService {
-        private JobAsyncTask mTask = null;
 
         @Override
-        public boolean onStartJob(JobParameters params) {
-            mTask = new JobAsyncTask(this);
-            mTask.execute(params);
-            return true;
+        public void onDestroy() {
+            stopForeground(true);
+            super.onDestroy();
         }
 
         @Override
-        public boolean onStopJob(JobParameters params) {
-            TinkerLog.w(TAG, "Stopping TinkerPatchJob service.");
-            if (mTask != null) {
-                mTask.cancel(true);
-                mTask = null;
-            }
-            return false;
-        }
-
-        private static class JobAsyncTask extends AsyncTask<JobParameters, Void, Void> {
-            private final WeakReference<JobService> mHolderRef;
-
-            JobAsyncTask(JobService holder) {
-                mHolderRef = new WeakReference<>(holder);
-            }
-
-            @Override
-            protected Void doInBackground(JobParameters... paramsList) {
-                final JobParameters params = paramsList[0];
-                final PersistableBundle extras = params.getExtras();
-                final Intent paramIntent = new Intent();
-                paramIntent.putExtra(PATCH_PATH_EXTRA, extras.getString(PATCH_PATH_EXTRA));
-                paramIntent.putExtra(RESULT_CLASS_EXTRA, extras.getString(RESULT_CLASS_EXTRA));
-                final JobService holder = mHolderRef.get();
-                if (holder == null) {
-                    TinkerLog.e(TAG, "unexpected case: holder job service is null.");
-                    return null;
-                }
-                doApplyPatch(holder.getApplicationContext(), paramIntent);
-                notifyFinished(params);
-                return null;
-            }
-
-            private void notifyFinished(JobParameters params) {
-                final JobService holder = mHolderRef.get();
-                if (holder != null) {
-                    holder.jobFinished(params, false);
-                }
-            }
+        public IBinder onBind(Intent intent) {
+            return null;
         }
     }
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
index 570558ae..bbba1b51 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
@@ -35,6 +35,7 @@
 import com.tencent.tinker.loader.TinkerRuntimeException;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.SharePatchInfo;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.io.File;
@@ -258,10 +259,17 @@ public void cleanPatch() {
         if (patchDirectory == null) {
             return;
         }
-        if (isTinkerLoaded()) {
-            TinkerLog.e(TAG, "it is not safety to clean patch when tinker is loaded, you should kill all your process after clean!");
+        final File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectory.getAbsolutePath());
+        if (!patchInfoFile.exists()) {
+            TinkerLog.w(TAG, "try to clean patch while patch info file does not exist.");
+            return;
+        }
+        final File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectory.getAbsolutePath());
+        final SharePatchInfo patchInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);
+        if (patchInfo != null) {
+            patchInfo.isRemoveNewVersion = true;
+            SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile);
         }
-        SharePatchFileUtil.deleteDir(patchDirectory);
     }
 
     /**
@@ -308,13 +316,13 @@ public long getTinkerRomSpace() {
     /**
      * try delete the temp version files
      *
-     * @param patchFile
+     * @param patchApk
      */
-    public void cleanPatchByVersion(File patchFile) {
-        if (patchDirectory == null || patchFile == null || !patchFile.exists()) {
+    public void cleanPatchByPatchApk(File patchApk) {
+        if (patchDirectory == null || patchApk == null || !patchApk.exists()) {
             return;
         }
-        String versionName = SharePatchFileUtil.getPatchVersionDirectory(SharePatchFileUtil.getMD5(patchFile));
+        String versionName = SharePatchFileUtil.getPatchVersionDirectory(SharePatchFileUtil.getMD5(patchApk));
         cleanPatchByVersion(versionName);
     }
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerApplicationHelper.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerApplicationHelper.java
index f00941ef..e2a4314e 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerApplicationHelper.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerApplicationHelper.java
@@ -18,12 +18,13 @@
 
 import android.content.Intent;
 
+import com.tencent.tinker.entry.ApplicationLike;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.TinkerRuntimeException;
-import com.tencent.tinker.loader.app.ApplicationLike;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.SharePatchInfo;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.io.File;
@@ -241,10 +242,22 @@ public static void cleanPatch(ApplicationLike applicationLike) {
         if (applicationLike == null || applicationLike.getApplication() == null) {
             throw new TinkerRuntimeException("tinkerApplication is null");
         }
-        if (TinkerApplicationHelper.isTinkerLoadSuccess(applicationLike)) {
-            TinkerLog.e(TAG, "it is not safety to clean patch when tinker is loaded, you should kill all your process after clean!");
+        final File tinkerDir = SharePatchFileUtil.getPatchDirectory(applicationLike.getApplication());
+        if (!tinkerDir.exists()) {
+            TinkerLog.w(TAG, "try to clean patch while there're not any applied patches.");
+            return;
+        }
+        final File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(tinkerDir.getAbsolutePath());
+        if (!patchInfoFile.exists()) {
+            TinkerLog.w(TAG, "try to clean patch while patch info file does not exist.");
+            return;
+        }
+        final File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(tinkerDir.getAbsolutePath());
+        final SharePatchInfo patchInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);
+        if (patchInfo != null) {
+            patchInfo.isRemoveNewVersion = true;
+            SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile);
         }
-        SharePatchFileUtil.deleteDir(SharePatchFileUtil.getPatchDirectory(applicationLike.getApplication()));
     }
 
     /**
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerInstaller.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerInstaller.java
index 9cb71ac0..34c2bb44 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerInstaller.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerInstaller.java
@@ -18,13 +18,13 @@
 
 import android.content.Context;
 
+import com.tencent.tinker.entry.ApplicationLike;
 import com.tencent.tinker.lib.listener.PatchListener;
 import com.tencent.tinker.lib.patch.AbstractPatch;
 import com.tencent.tinker.lib.reporter.LoadReporter;
 import com.tencent.tinker.lib.reporter.PatchReporter;
 import com.tencent.tinker.lib.service.AbstractResultService;
 import com.tencent.tinker.lib.util.TinkerLog;
-import com.tencent.tinker.loader.app.ApplicationLike;
 
 /**
  * Created by zhangshaowen on 16/3/19.
@@ -57,8 +57,8 @@ public static Tinker install(ApplicationLike applicationLike) {
      * @param upgradePatchProcessor
      */
     public static Tinker install(ApplicationLike applicationLike, LoadReporter loadReporter, PatchReporter patchReporter,
-                               PatchListener listener, Class<? extends AbstractResultService> resultServiceClass,
-                               AbstractPatch upgradePatchProcessor) {
+                                 PatchListener listener, Class<? extends AbstractResultService> resultServiceClass,
+                                 AbstractPatch upgradePatchProcessor) {
 
         Tinker tinker = new Tinker.Builder(applicationLike.getApplication())
             .tinkerFlags(applicationLike.getTinkerFlags())
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
index e50fa87a..5828798b 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
@@ -113,7 +113,7 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 resourceDirectory = new File(patchVersionDirectory, ShareConstants.RES_PATH);
                 resourceFile = new File(resourceDirectory, ShareConstants.RES_NAME);
             }
-            patchInfo = new SharePatchInfo(oldVersion, newVersion, Build.FINGERPRINT, oatDir);
+            patchInfo = new SharePatchInfo(oldVersion, newVersion, false, Build.FINGERPRINT, oatDir);
             versionChanged = !(oldVersion.equals(newVersion));
         }
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerJobIntentService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerJobIntentService.java
new file mode 100644
index 00000000..63d0303b
--- /dev/null
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerJobIntentService.java
@@ -0,0 +1,677 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.lib.util;
+
+import android.Manifest;
+import android.annotation.TargetApi;
+import android.app.Service;
+import android.app.job.JobInfo;
+import android.app.job.JobParameters;
+import android.app.job.JobScheduler;
+import android.app.job.JobServiceEngine;
+import android.app.job.JobWorkItem;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.os.IBinder;
+import android.os.PowerManager;
+import android.os.Process;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+/**
+ * This class is copied and renamed from JobIntentService in android support compat
+ * library 28.0.0-alpha1. Some changes was made for adapting Tinker's specific usage.
+ *
+ * Since We can't get rid of the resources dependencies that android support compat library
+ * has to include with, instead of hacking into the gradle dependency mechanism We choose to
+ * copy what we need directly. Copy with renaming is to avoid conflicting when developers
+ * happen to include android support compat library which has the same class in their App.
+ *
+ * Helper for processing work that has been enqueued for a job/service.  When running on
+ * {@link android.os.Build.VERSION_CODES#O Android O} or later, the work will be dispatched
+ * as a job via {@link android.app.job.JobScheduler#enqueue JobScheduler.enqueue}.  When running
+ * on older versions of the platform, it will use
+ * {@link android.content.Context#startService Context.startService}.
+ *
+ * <p>You must publish your subclass in your manifest for the system to interact with.  This
+ * should be published as a {@link android.app.job.JobService}, as described for that class,
+ * since on O and later platforms it will be executed that way.</p>
+ *
+ * <p>Use {@link #enqueueWork(Context, Class, int, Intent)} to enqueue new work to be
+ * dispatched to and handled by your service.  It will be executed in
+ * {@link #onHandleWork(Intent)}.</p>
+ *
+ * <p>You do not need to use {@link android.support.v4.content.WakefulBroadcastReceiver}
+ * when using this class.  When running on {@link android.os.Build.VERSION_CODES#O Android O},
+ * the JobScheduler will take care of wake locks for you (holding a wake lock from the time
+ * you enqueue work until the job has been dispatched and while it is running).  When running
+ * on previous versions of the platform, this wake lock handling is emulated in the class here
+ * by directly calling the PowerManager; this means the application must request the
+ * {@link android.Manifest.permission#WAKE_LOCK} permission.</p>
+ *
+ * <p>There are a few important differences in behavior when running on
+ * {@link android.os.Build.VERSION_CODES#O Android O} or later as a Job vs. pre-O:</p>
+ *
+ * <ul>
+ *     <li><p>When running as a pre-O service, the act of enqueueing work will generally start
+ *     the service immediately, regardless of whether the device is dozing or in other
+ *     conditions.  When running as a Job, it will be subject to standard JobScheduler
+ *     policies for a Job with a {@link android.app.job.JobInfo.Builder#setOverrideDeadline(long)}
+ *     of 0: the job will not run while the device is dozing, it may get delayed more than
+ *     a service if the device is under strong memory pressure with lots of demand to run
+ *     jobs.</p></li>
+ *     <li><p>When running as a pre-O service, the normal service execution semantics apply:
+ *     the service can run indefinitely, though the longer it runs the more likely the system
+ *     will be to outright kill its process, and under memory pressure one should expect
+ *     the process to be killed even of recently started services.  When running as a Job,
+ *     the typical {@link android.app.job.JobService} execution time limit will apply, after
+ *     which the job will be stopped (cleanly, not by killing the process) and rescheduled
+ *     to continue its execution later.  Job are generally not killed when the system is
+ *     under memory pressure, since the number of concurrent jobs is adjusted based on the
+ *     memory state of the device.</p></li>
+ * </ul>
+ *
+ * <p>Here is an example implementation of this class:</p>
+ *
+ * {@sample frameworks/support/samples/Support4Demos/src/main/java/com/example/android/supportv4/app/SimpleJobIntentService.java
+ *      complete}
+ */
+public abstract class TinkerJobIntentService extends Service {
+    static final String TAG = "TinkerJobIntentService";
+
+    static final boolean DEBUG = false;
+
+    CompatJobEngine mJobImpl;
+    WorkEnqueuer mCompatWorkEnqueuer;
+    CommandProcessor mCurProcessor;
+    boolean mInterruptIfStopped = false;
+    boolean mStopped = false;
+    boolean mDestroyed = false;
+
+    final ArrayList<CompatWorkItem> mCompatQueue;
+
+    static final Object sLock = new Object();
+    static final HashMap<ComponentName, WorkEnqueuer> sClassWorkEnqueuer = new HashMap<>();
+
+    /**
+     * Base class for the target service we can deliver work to and the implementation of
+     * how to deliver that work.
+     */
+    abstract static class WorkEnqueuer {
+        final ComponentName mComponentName;
+
+        boolean mHasJobId;
+        int mJobId;
+
+        WorkEnqueuer(Context context, ComponentName cn) {
+            mComponentName = cn;
+        }
+
+        void ensureJobId(int jobId) {
+            if (!mHasJobId) {
+                mHasJobId = true;
+                mJobId = jobId;
+            } else if (mJobId != jobId) {
+                throw new IllegalArgumentException("Given job ID " + jobId
+                        + " is different than previous " + mJobId);
+            }
+        }
+
+        abstract void enqueueWork(Intent work);
+
+        public void serviceStartReceived() {
+        }
+
+        public void serviceProcessingStarted() {
+        }
+
+        public void serviceProcessingFinished() {
+        }
+    }
+
+    /**
+     * Get rid of lint warnings about API levels.
+     */
+    interface CompatJobEngine {
+        IBinder compatGetBinder();
+        GenericWorkItem dequeueWork();
+    }
+
+    /**
+     * An implementation of WorkEnqueuer that works for pre-O (raw Service-based).
+     */
+    static final class CompatWorkEnqueuer extends WorkEnqueuer {
+        private final Context mContext;
+        private final PowerManager.WakeLock mLaunchWakeLock;
+        private final PowerManager.WakeLock mRunWakeLock;
+        boolean mLaunchingService;
+        boolean mServiceProcessing;
+
+        CompatWorkEnqueuer(Context context, ComponentName cn) {
+            super(context, cn);
+            mContext = context.getApplicationContext();
+            if (mContext.checkPermission(Manifest.permission.WAKE_LOCK, Process.myPid(), Process.myUid()) == PackageManager.PERMISSION_GRANTED) {
+                // Make wake locks.  We need two, because the launch wake lock wants to have
+                // a timeout, and the system does not do the right thing if you mix timeout and
+                // non timeout (or even changing the timeout duration) in one wake lock.
+                PowerManager pm = ((PowerManager) context.getSystemService(Context.POWER_SERVICE));
+                mLaunchWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, cn.getClassName() + ":launch");
+                mLaunchWakeLock.setReferenceCounted(false);
+                mRunWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, cn.getClassName() + ":run");
+                mRunWakeLock.setReferenceCounted(false);
+            } else {
+                TinkerLog.w(TAG, "it would be better to grant WAKE_LOCK permission to your app so that tinker can use WakeLock to keep system awake.");
+                mLaunchWakeLock = mRunWakeLock = null;
+            }
+        }
+
+        @Override
+        void enqueueWork(Intent work) {
+            Intent intent = new Intent(work);
+            intent.setComponent(mComponentName);
+            if (DEBUG) Log.d(TAG, "Starting service for work: " + work);
+            if (mContext.startService(intent) != null) {
+                synchronized (this) {
+                    if (!mLaunchingService) {
+                        mLaunchingService = true;
+                        if (!mServiceProcessing && mLaunchWakeLock != null) {
+                            // If the service is not already holding the wake lock for
+                            // itself, acquire it now to keep the system running until
+                            // we get this work dispatched.  We use a timeout here to
+                            // protect against whatever problem may cause it to not get
+                            // the work.
+                            mLaunchWakeLock.acquire(60 * 1000);
+                        }
+                    }
+                }
+            }
+        }
+
+        @Override
+        public void serviceStartReceived() {
+            synchronized (this) {
+                // Once we have started processing work, we can count whatever last
+                // enqueueWork() that happened as handled.
+                mLaunchingService = false;
+            }
+        }
+
+        @Override
+        public void serviceProcessingStarted() {
+            synchronized (this) {
+                // We hold the wake lock as long as the service is processing commands.
+                if (!mServiceProcessing) {
+                    mServiceProcessing = true;
+                    // Keep the device awake, but only for at most 10 minutes at a time
+                    // (Similar to JobScheduler.)
+                    if (mRunWakeLock != null) {
+                        mRunWakeLock.acquire(10 * 60 * 1000L);
+                    }
+                    if (mLaunchWakeLock != null) {
+                        mLaunchWakeLock.release();
+                    }
+                }
+            }
+        }
+
+        @Override
+        public void serviceProcessingFinished() {
+            synchronized (this) {
+                if (mServiceProcessing) {
+                    // If we are transitioning back to a wakelock with a timeout, do the same
+                    // as if we had enqueued work without the service running.
+                    if (mLaunchingService && mLaunchWakeLock != null) {
+                        mLaunchWakeLock.acquire(60 * 1000);
+                    }
+                    mServiceProcessing = false;
+                    if (mRunWakeLock != null) {
+                        mRunWakeLock.release();
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Implementation of a JobServiceEngine for interaction with TinkerJobIntentService.
+     */
+    @RequiresApi(26)
+    static final class JobServiceEngineImpl extends JobServiceEngine
+            implements TinkerJobIntentService.CompatJobEngine {
+        static final String TAG = "JobServiceEngineImpl";
+
+        static final boolean DEBUG = false;
+
+        final TinkerJobIntentService mService;
+        final Object mLock = new Object();
+        JobParameters mParams;
+
+        final class WrapperWorkItem implements TinkerJobIntentService.GenericWorkItem {
+            final JobWorkItem mJobWork;
+
+            WrapperWorkItem(JobWorkItem jobWork) {
+                mJobWork = jobWork;
+            }
+
+            @Override
+            public Intent getIntent() {
+                return mJobWork.getIntent();
+            }
+
+            @Override
+            public void complete() {
+                synchronized (mLock) {
+                    if (mParams != null) {
+                        mParams.completeWork(mJobWork);
+                    }
+                }
+            }
+        }
+
+        JobServiceEngineImpl(TinkerJobIntentService service) {
+            super(service);
+            mService = service;
+        }
+
+        @Override
+        public IBinder compatGetBinder() {
+            return getBinder();
+        }
+
+        @Override
+        public boolean onStartJob(JobParameters params) {
+            if (DEBUG) Log.d(TAG, "onStartJob: " + params);
+            mParams = params;
+            // We can now start dequeuing work!
+            mService.ensureProcessorRunningLocked(false);
+            return true;
+        }
+
+        @Override
+        public boolean onStopJob(JobParameters params) {
+            if (DEBUG) Log.d(TAG, "onStartJob: " + params);
+            boolean result = mService.doStopCurrentWork();
+            synchronized (mLock) {
+                // Once we return, the job is stopped, so its JobParameters are no
+                // longer valid and we should not be doing anything with them.
+                mParams = null;
+            }
+            return result;
+        }
+
+        /**
+         * Dequeue some work.
+         */
+        @Override
+        public TinkerJobIntentService.GenericWorkItem dequeueWork() {
+            JobWorkItem work;
+            synchronized (mLock) {
+                if (mParams == null) {
+                    return null;
+                }
+                try {
+                    work = mParams.dequeueWork();
+                } catch (Throwable thr) {
+                    Log.w(TAG, "exception occurred.", thr);
+                    work = null;
+                }
+            }
+            if (work != null) {
+                work.getIntent().setExtrasClassLoader(mService.getClassLoader());
+                return new WrapperWorkItem(work);
+            } else {
+                return null;
+            }
+        }
+    }
+
+    @RequiresApi(26)
+    static final class JobWorkEnqueuer extends TinkerJobIntentService.WorkEnqueuer {
+        private final JobInfo mJobInfo;
+        private final JobScheduler mJobScheduler;
+
+        JobWorkEnqueuer(Context context, ComponentName cn, int jobId) {
+            super(context, cn);
+            ensureJobId(jobId);
+            JobInfo.Builder b = new JobInfo.Builder(jobId, mComponentName);
+            mJobInfo = b.setOverrideDeadline(0).build();
+            mJobScheduler = (JobScheduler) context.getApplicationContext().getSystemService(
+                    Context.JOB_SCHEDULER_SERVICE);
+        }
+
+        @Override
+        void enqueueWork(Intent work) {
+            if (DEBUG) Log.d(TAG, "Enqueueing work: " + work);
+            mJobScheduler.enqueue(mJobInfo, new JobWorkItem(work));
+        }
+    }
+
+    /**
+     * Abstract definition of an item of work that is being dispatched.
+     */
+    interface GenericWorkItem {
+        Intent getIntent();
+        void complete();
+    }
+
+    /**
+     * An implementation of GenericWorkItem that dispatches work for pre-O platforms: intents
+     * received through a raw service's onStartCommand.
+     */
+    final class CompatWorkItem implements GenericWorkItem {
+        final Intent mIntent;
+        final int mStartId;
+
+        CompatWorkItem(Intent intent, int startId) {
+            mIntent = intent;
+            mStartId = startId;
+        }
+
+        @Override
+        public Intent getIntent() {
+            return mIntent;
+        }
+
+        @Override
+        public void complete() {
+            if (DEBUG) Log.d(TAG, "Stopping self: #" + mStartId);
+            stopSelf(mStartId);
+        }
+    }
+
+    /**
+     * This is a task to dequeue and process work in the background.
+     */
+    final class CommandProcessor extends AsyncTask<Void, Void, Void> {
+        @Override
+        protected Void doInBackground(Void... params) {
+            GenericWorkItem work;
+
+            if (DEBUG) Log.d(TAG, "Starting to dequeue work...");
+
+            while ((work = dequeueWork()) != null) {
+                if (DEBUG) Log.d(TAG, "Processing next work: " + work);
+                onHandleWork(work.getIntent());
+                if (DEBUG) Log.d(TAG, "Completing work: " + work);
+                work.complete();
+            }
+
+            if (DEBUG) Log.d(TAG, "Done processing work!");
+
+            return null;
+        }
+
+        @Override
+        protected void onCancelled(Void aVoid) {
+            processorFinished();
+        }
+
+        @Override
+        protected void onPostExecute(Void aVoid) {
+            processorFinished();
+        }
+    }
+
+    /**
+     * Default empty constructor.
+     */
+    public TinkerJobIntentService() {
+        if (Build.VERSION.SDK_INT >= 26) {
+            mCompatQueue = null;
+        } else {
+            mCompatQueue = new ArrayList<>();
+        }
+    }
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        if (DEBUG) Log.d(TAG, "CREATING: " + this);
+        if (Build.VERSION.SDK_INT >= 26) {
+            mJobImpl = new JobServiceEngineImpl(this);
+            mCompatWorkEnqueuer = null;
+        } else {
+            mJobImpl = null;
+            ComponentName cn = new ComponentName(this, this.getClass());
+            mCompatWorkEnqueuer = getWorkEnqueuer(this, cn, false, 0);
+        }
+    }
+
+    /**
+     * Processes start commands when running as a pre-O service, enqueueing them to be
+     * later dispatched in {@link #onHandleWork(Intent)}.
+     */
+    @Override
+    public int onStartCommand(@Nullable Intent intent, int flags, int startId) {
+        if (mCompatQueue != null) {
+            mCompatWorkEnqueuer.serviceStartReceived();
+            if (DEBUG) Log.d(TAG, "Received compat start command #" + startId + ": " + intent);
+            synchronized (mCompatQueue) {
+                mCompatQueue.add(new CompatWorkItem(intent != null ? intent : new Intent(),
+                        startId));
+                ensureProcessorRunningLocked(true);
+            }
+            return START_REDELIVER_INTENT;
+        } else {
+            if (DEBUG) Log.d(TAG, "Ignoring start command: " + intent);
+            return START_NOT_STICKY;
+        }
+    }
+
+    /**
+     * Returns the IBinder for the {@link android.app.job.JobServiceEngine} when
+     * running as a JobService on O and later platforms.
+     */
+    @Override
+    public IBinder onBind(@NonNull Intent intent) {
+        if (mJobImpl != null) {
+            IBinder engine = mJobImpl.compatGetBinder();
+            if (DEBUG) Log.d(TAG, "Returning engine: " + engine);
+            return engine;
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        if (mCompatQueue != null) {
+            synchronized (mCompatQueue) {
+                mDestroyed = true;
+                mCompatWorkEnqueuer.serviceProcessingFinished();
+            }
+        }
+    }
+
+    /**
+     * Call this to enqueue work for your subclass of {@link TinkerJobIntentService}.  This will
+     * either directly start the service (when running on pre-O platforms) or enqueue work
+     * for it as a job (when running on O and later).  In either case, a wake lock will be
+     * held for you to ensure you continue running.  The work you enqueue will ultimately
+     * appear at {@link #onHandleWork(Intent)}.
+     *
+     * @param context Context this is being called from.
+     * @param cls The concrete class the work should be dispatched to (this is the class that
+     * is published in your manifest).
+     * @param jobId A unique job ID for scheduling; must be the same value for all work
+     * enqueued for the same class.
+     * @param work The Intent of work to enqueue.
+     */
+    public static void enqueueWork(@NonNull Context context, @NonNull Class cls, int jobId,
+                                   @NonNull Intent work) {
+        enqueueWork(context, new ComponentName(context, cls), jobId, work);
+    }
+
+    /**
+     * Like {@link #enqueueWork(Context, Class, int, Intent)}, but supplies a ComponentName
+     * for the service to interact with instead of its class.
+     *
+     * @param context Context this is being called from.
+     * @param component The published ComponentName of the class this work should be
+     * dispatched to.
+     * @param jobId A unique job ID for scheduling; must be the same value for all work
+     * enqueued for the same class.
+     * @param work The Intent of work to enqueue.
+     */
+    public static void enqueueWork(@NonNull Context context, @NonNull ComponentName component,
+                                   int jobId, @NonNull Intent work) {
+        if (work == null) {
+            throw new IllegalArgumentException("work must not be null");
+        }
+        synchronized (sLock) {
+            WorkEnqueuer we = getWorkEnqueuer(context, component, true, jobId);
+            we.ensureJobId(jobId);
+            we.enqueueWork(work);
+        }
+    }
+
+    static WorkEnqueuer getWorkEnqueuer(Context context, ComponentName cn, boolean hasJobId,
+                                        int jobId) {
+        WorkEnqueuer we = sClassWorkEnqueuer.get(cn);
+        if (we == null) {
+            if (Build.VERSION.SDK_INT >= 26) {
+                if (!hasJobId) {
+                    throw new IllegalArgumentException("Can't be here without a job id");
+                }
+                we = new JobWorkEnqueuer(context, cn, jobId);
+            } else {
+                we = new CompatWorkEnqueuer(context, cn);
+            }
+            sClassWorkEnqueuer.put(cn, we);
+        }
+        return we;
+    }
+
+    /**
+     * Called serially for each work dispatched to and processed by the service.  This
+     * method is called on a background thread, so you can do long blocking operations
+     * here.  Upon returning, that work will be considered complete and either the next
+     * pending work dispatched here or the overall service destroyed now that it has
+     * nothing else to do.
+     *
+     * <p>Be aware that when running as a job, you are limited by the maximum job execution
+     * time and any single or total sequential items of work that exceeds that limit will
+     * cause the service to be stopped while in progress and later restarted with the
+     * last unfinished work.  (There is currently no limit on execution duration when
+     * running as a pre-O plain Service.)</p>
+     *
+     * @param intent The intent describing the work to now be processed.
+     */
+    protected abstract void onHandleWork(@NonNull Intent intent);
+
+    /**
+     * Control whether code executing in {@link #onHandleWork(Intent)} will be interrupted
+     * if the job is stopped.  By default this is false.  If called and set to true, any
+     * time {@link #onStopCurrentWork()} is called, the class will first call
+     * {@link AsyncTask#cancel(boolean) AsyncTask.cancel(true)} to interrupt the running
+     * task.
+     *
+     * @param interruptIfStopped Set to true to allow the system to interrupt actively
+     * running work.
+     */
+    public void setInterruptIfStopped(boolean interruptIfStopped) {
+        mInterruptIfStopped = interruptIfStopped;
+    }
+
+    /**
+     * Returns true if {@link #onStopCurrentWork()} has been called.  You can use this,
+     * while executing your work, to see if it should be stopped.
+     */
+    public boolean isStopped() {
+        return mStopped;
+    }
+
+    /**
+     * This will be called if the JobScheduler has decided to stop this job.  The job for
+     * this service does not have any constraints specified, so this will only generally happen
+     * if the service exceeds the job's maximum execution time.
+     *
+     * @return True to indicate to the JobManager whether you'd like to reschedule this work,
+     * false to drop this and all following work. Regardless of the value returned, your service
+     * must stop executing or the system will ultimately kill it.  The default implementation
+     * returns true, and that is most likely what you want to return as well (so no work gets
+     * lost).
+     */
+    public boolean onStopCurrentWork() {
+        return true;
+    }
+
+    boolean doStopCurrentWork() {
+        if (mCurProcessor != null) {
+            mCurProcessor.cancel(mInterruptIfStopped);
+        }
+        mStopped = true;
+        return onStopCurrentWork();
+    }
+
+    @TargetApi(11)
+    void ensureProcessorRunningLocked(boolean reportStarted) {
+        if (mCurProcessor == null) {
+            mCurProcessor = new CommandProcessor();
+            if (mCompatWorkEnqueuer != null && reportStarted) {
+                mCompatWorkEnqueuer.serviceProcessingStarted();
+            }
+            if (DEBUG) Log.d(TAG, "Starting processor: " + mCurProcessor);
+            mCurProcessor.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
+        }
+    }
+
+    void processorFinished() {
+        if (mCompatQueue != null) {
+            synchronized (mCompatQueue) {
+                mCurProcessor = null;
+                // The async task has finished, but we may have gotten more work scheduled in the
+                // meantime.  If so, we need to restart the new processor to execute it.  If there
+                // is no more work at this point, either the service is in the process of being
+                // destroyed (because we called stopSelf on the last intent started for it), or
+                // someone has already called startService with a new Intent that will be
+                // arriving shortly.  In either case, we want to just leave the service
+                // waiting -- either to get destroyed, or get a new onStartCommand() callback
+                // which will then kick off a new processor.
+                if (mCompatQueue != null && mCompatQueue.size() > 0) {
+                    ensureProcessorRunningLocked(false);
+                } else if (!mDestroyed) {
+                    mCompatWorkEnqueuer.serviceProcessingFinished();
+                }
+            }
+        }
+    }
+
+    GenericWorkItem dequeueWork() {
+        if (mJobImpl != null) {
+            return mJobImpl.dequeueWork();
+        } else {
+            synchronized (mCompatQueue) {
+                if (mCompatQueue.size() > 0) {
+                    return mCompatQueue.remove(0);
+                } else {
+                    return null;
+                }
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
index b98ee128..0db959ee 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
@@ -98,7 +98,7 @@ public static String getTinkerPatchServiceName(final Context context) {
             return patchServiceProcessName;
         }
         //may be null, and you may like to hardcode instead
-        String serviceName = TinkerServiceInternals.getServiceProcessName(context, TinkerPatchService.getExpectedRealRunnerClass());
+        String serviceName = TinkerServiceInternals.getServiceProcessName(context, TinkerPatchService.class);
         if (serviceName == null) {
             return null;
         }
diff --git a/tinker-android/tinker-android-loader/build.gradle b/tinker-android/tinker-android-loader/build.gradle
index 971a76e0..6e6f0c77 100644
--- a/tinker-android/tinker-android-loader/build.gradle
+++ b/tinker-android/tinker-android-loader/build.gradle
@@ -19,9 +19,9 @@ android {
 }
 
 dependencies {
-    compile fileTree(dir: 'libs', include: ['*.jar'])
-    testCompile 'junit:junit:4.12'
-    compile "com.android.support:support-annotations:${rootProject.ext.supportLibVersion}"
+    implementation fileTree(dir: 'libs', include: ['*.jar'])
+    testImplementation 'junit:junit:4.12'
+    compileOnly "com.android.support:support-annotations:${rootProject.ext.supportLibVersion}"
 }
 
 task buildTinkerSdk(type: Copy, dependsOn: [build]) {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
index a283600a..565c7f9a 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
@@ -40,6 +40,7 @@
     private static final String TAG = "Tinker.NClassLoader";
 
     private static Object oldDexPathListHolder = null;
+    private static String baseApkFullPath = null;
 
     private final PathClassLoader originClassLoader;
     private String applicationClassName;
@@ -51,6 +52,7 @@ private AndroidNClassLoader(String dexPath, PathClassLoader parent, Application
         if (name != null && !name.equals("android.app.Application")) {
             applicationClassName = name;
         }
+        baseApkFullPath = application.getPackageCodePath();
     }
 
     @SuppressWarnings("unchecked")
@@ -70,7 +72,10 @@ private static Object recreateDexPathList(Object originalDexPathList, ClassLoade
         boolean isFirstItem = true;
         for (Object dexElement : dexElements) {
             final DexFile dexFile = (DexFile) dexFileField.get(dexElement);
-            if (dexFile == null) {
+            if (dexFile == null || dexFile.getName() == null) {
+                continue;
+            }
+            if (!dexFile.getName().equals(baseApkFullPath)) {
                 continue;
             }
             if (isFirstItem) {
@@ -153,25 +158,45 @@ public static AndroidNClassLoader inject(PathClassLoader originClassLoader, Appl
         return classLoader;
     }
 
-//    public static String getLdLibraryPath(ClassLoader loader) throws Exception {
-//        String nativeLibraryPath;
-//
-//        nativeLibraryPath = (String) loader.getClass()
-//            .getMethod("getLdLibraryPath", new Class[0])
-//            .invoke(loader, new Object[0]);
-//
-//        return nativeLibraryPath;
-//    }
-
     public Class<?> findClass(String name) throws ClassNotFoundException {
-        // loader class use default pathClassloader to load
-        if ((name != null
-                && name.startsWith("com.tencent.tinker.loader.")
-                && !name.equals(SystemClassLoaderAdder.CHECK_DEX_CLASS))
-                || (applicationClassName != null && applicationClassName.equals(name))) {
+        // app class use default pathClassloader to load
+        if (applicationClassName != null && applicationClassName.equals(name)) {
+            return originClassLoader.loadClass(name);
+        } else if (name != null && name.startsWith("com.tencent.tinker.loader.")
+                && !name.equals(SystemClassLoaderAdder.CHECK_DEX_CLASS)) {
+            return originClassLoader.loadClass(name);
+        } else if (name != null && name.startsWith("org.apache.http.")) {
+            // Here's the whole story:
+            //   Some app use apache wrapper library to access Apache utilities. Classes in apache wrapper
+            //   library may be conflict with those preloaded in BootClassLoader.
+            //   So with the build option:
+            //       useLibrary 'org.apache.http.legacy'
+            //   appears, the Android Framework will inject a jar called 'org.apache.http.legacy.boot.jar'
+            //   in front of the path of user's apk. After that, PathList in app's PathClassLoader should
+            //   look like this:
+            //       ["/system/framework/org.apache.http.legacy.boot.jar", "path-to-user-apk", "path-to-other-preload-jar"]
+            //   When app runs to the code refer to Apache classes, the referred classes in the first
+            //   jar override those in user's app, which avoids any conflicts and crashes.
+            //
+            //   When it comes to Tinker, to block the cached instances in class table of app's
+            //   PathClassLoader we use this AndroidNClassLoader to replace the original PathClassLoader.
+            //   At the beginning it's fine to imitate system's behavior and construct the PathList in AndroidNClassLoader
+            //   like below:
+            //       ["/system/framework/org.apache.http.legacy.boot.jar", "path-to-new-dexes", "path-to-other-preload-jar"]
+            //   However, the ART VM of Android P adds a new feature that checks whether the inlined class is loaded by the same
+            //   ClassLoader that loads the callsite's class. If any Apache classes is inlined in old dex(oat), after we replacing
+            //   the App's ClassLoader we will receive an assert since the Apache classes is loaded by another ClassLoader now.
+            return originClassLoader.loadClass(name);
+        }
+        try {
+            return super.findClass(name);
+        } catch (ClassNotFoundException e) {
+            // Some jars/apks other than base.apk was removed from AndroidNClassloader's dex path list.
+            // So if target class cannot be found in AndroidNClassloader, we should fallback to try
+            // original PathClassLoader for compatibility.
+            // Obviously this behavior violates the Parent Delegate Model, but it doesn't matter.
             return originClassLoader.loadClass(name);
         }
-        return super.findClass(name);
     }
 
     @Override
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
index 47566786..17293f95 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
@@ -34,10 +34,12 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Map;
+import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
 import dalvik.system.DexFile;
@@ -119,8 +121,27 @@ private static boolean checkIsProtectedApp(List<File> files) {
                 if (file == null) {
                     continue;
                 }
-                if (file.getName().startsWith(ShareConstants.CHANGED_CLASSES_DEX_NAME)) {
+                final String fileName = file.getName();
+                if (fileName.startsWith(ShareConstants.CHANGED_CLASSES_DEX_PREFIX)) {
                     return true;
+                } else if (fileName.endsWith(ShareConstants.APK_SUFFIX) || file.getName().endsWith(ShareConstants.JAR_SUFFIX)) {
+                    ZipFile zf = null;
+                    try {
+                        zf = new ZipFile(file);
+                        final Enumeration<? extends ZipEntry> entries = zf.entries();
+                        while (entries.hasMoreElements()) {
+                            final ZipEntry entry = entries.nextElement();
+                            if (entry.getName().startsWith(ShareConstants.CHANGED_CLASSES_DEX_PREFIX)) {
+                                return true;
+                            }
+                        }
+                        return false;
+                    } catch (IOException e) {
+                        // Usually we shouldn't reach here.
+                        return false;
+                    } finally {
+                        SharePatchFileUtil.closeZip(zf);
+                    }
                 }
             }
         }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
index 5e98084f..1473ae2f 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
@@ -16,9 +16,7 @@
 
 package com.tencent.tinker.loader;
 
-import android.content.Context;
 import android.content.Intent;
-import android.content.SharedPreferences;
 import android.os.Build;
 import android.os.SystemClock;
 import android.util.Log;
@@ -73,7 +71,6 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultInten
             Log.w(TAG, "tryLoadPatchFiles: we don't load patch with :patch process itself, just return");
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);
             return;
-
         }
         //tinker
         File patchDirectoryFile = SharePatchFileUtil.getPatchDirectory(app);
@@ -122,17 +119,39 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultInten
             return;
         }
 
+        boolean mainProcess = ShareTinkerInternals.isInMainProcess(app);
+        boolean isRemoveNewVersion = patchInfo.isRemoveNewVersion;
+
+        // So far new version is not loaded in main process and other processes.
+        // We can remove new version directory safely.
+        if (mainProcess && isRemoveNewVersion) {
+            Log.w(TAG, "found clean patch mark and we are in main process, delete patch file now.");
+            String patchName = SharePatchFileUtil.getPatchVersionDirectory(newVersion);
+            if (patchName != null) {
+                String patchVersionDirFullPath = patchDirectoryPath + "/" + patchName;
+                SharePatchFileUtil.deleteDir(patchVersionDirFullPath);
+                if (oldVersion.equals(newVersion)) {
+                    // !oldVersion.equals(newVersion) means new patch is applied, just fall back to old one in that case.
+                    // Or we will set oldVersion and newVersion to empty string to clean patch.
+                    oldVersion = "";
+                }
+                newVersion = oldVersion;
+                patchInfo.oldVersion = oldVersion;
+                patchInfo.newVersion = newVersion;
+                SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile);
+                ShareTinkerInternals.killProcessExceptMain(app);
+            }
+        }
+
         resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OLD_VERSION, oldVersion);
         resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_NEW_VERSION, newVersion);
 
-        boolean mainProcess = ShareTinkerInternals.isInMainProcess(app);
         boolean versionChanged = !(oldVersion.equals(newVersion));
-        boolean oatModeChanged = oatDex.equals(ShareConstants.CHANING_DEX_OPTIMIZE_PATH) && mainProcess;
+        boolean oatModeChanged = oatDex.equals(ShareConstants.CHANING_DEX_OPTIMIZE_PATH);
         oatDex = ShareTinkerInternals.getCurrentOatMode(app, oatDex);
         resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR, oatDex);
 
         String version = oldVersion;
-
         if (versionChanged && mainProcess) {
             version = newVersion;
         }
@@ -229,8 +248,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultInten
         resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, isSystemOTA);
 
         //we should first try rewrite patch info file, if there is a error, we can't load jar
-        if ((mainProcess && versionChanged)
-             || oatModeChanged) {
+        if (mainProcess && (versionChanged || oatModeChanged)) {
             patchInfo.oldVersion = version;
             patchInfo.oatDir = oatDex;
 
@@ -304,18 +322,13 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultInten
     }
 
     private boolean checkSafeModeCount(TinkerApplication application) {
-        String processName = ShareTinkerInternals.getProcessName(application);
-        String preferName = ShareConstants.TINKER_OWN_PREFERENCE_CONFIG + processName;
-        //each process have its own SharedPreferences file
-        SharedPreferences sp = application.getSharedPreferences(preferName, Context.MODE_PRIVATE);
-        int count = sp.getInt(ShareConstants.TINKER_SAFE_MODE_COUNT, 0) + 1;
-        Log.w(TAG, "tinker safe mode preferName:" + preferName + " count:" + count);
-        if (count >= ShareConstants.TINKER_SAFE_MODE_MAX_COUNT) {
-            sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, 0).commit();
+        int count = ShareTinkerInternals.getSafeModeCount(application);
+        if (count >= ShareConstants.TINKER_SAFE_MODE_MAX_COUNT - 1) {
+            ShareTinkerInternals.setSafeModeCount(application, 0);
             return false;
         }
         application.setUseSafeMode(true);
-        sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, count).commit();
+        ShareTinkerInternals.setSafeModeCount(application, count + 1);
         return true;
     }
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerTestDexLoad.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerTestDexLoad.java
index 82b8f1c8..1c2c7ee6 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerTestDexLoad.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerTestDexLoad.java
@@ -16,9 +16,12 @@
 
 package com.tencent.tinker.loader;
 
+import android.support.annotation.Keep;
+
 /**
  * Created by zhangshaowen on 16/9/18.
  */
+@Keep
 public class TinkerTestDexLoad {
     public static boolean isPatch = false;
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
index f3f32bae..fb1b1d06 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
@@ -20,7 +20,6 @@
 import android.app.Application;
 import android.content.Context;
 import android.content.Intent;
-import android.content.SharedPreferences;
 import android.content.res.AssetManager;
 import android.content.res.Configuration;
 import android.content.res.Resources;
@@ -33,6 +32,7 @@
 import com.tencent.tinker.loader.hotplug.UnsupportedEnvironmentException;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.lang.reflect.Constructor;
@@ -73,7 +73,7 @@
     private       boolean useSafeMode;
     private       Intent  tinkerResultIntent;
 
-    private ApplicationLike applicationLike = null;
+    private Object applicationLike = null;
 
     private long applicationStartElapsedTime;
     private long applicationStartMillisTime;
@@ -82,7 +82,7 @@
      * current build.
      */
     protected TinkerApplication(int tinkerFlags) {
-        this(tinkerFlags, "com.tencent.tinker.loader.app.DefaultApplicationLike", TinkerLoader.class.getName(), false);
+        this(tinkerFlags, "com.tencent.tinker.entry.DefaultApplicationLike", TinkerLoader.class.getName(), false);
     }
 
     /**
@@ -101,14 +101,14 @@ protected TinkerApplication(int tinkerFlags, String delegateClassName) {
         this(tinkerFlags, delegateClassName, TinkerLoader.class.getName(), false);
     }
 
-    private ApplicationLike createDelegate() {
+    private Object createDelegate() {
         try {
             // Use reflection to create the delegate so it doesn't need to go into the primary dex.
             // And we can also patch it
             Class<?> delegateClass = Class.forName(delegateClassName, false, getClassLoader());
             Constructor<?> constructor = delegateClass.getConstructor(Application.class, int.class, boolean.class,
                 long.class, long.class, Intent.class);
-            return (ApplicationLike) constructor.newInstance(this, tinkerFlags, tinkerLoadVerifyFlag,
+            return constructor.newInstance(this, tinkerFlags, tinkerLoadVerifyFlag,
                 applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);
         } catch (Throwable e) {
             throw new TinkerRuntimeException("createDelegate failed", e);
@@ -121,23 +121,39 @@ private synchronized void ensureDelegate() {
         }
     }
 
+    private Method appLikeOnBaseContextAttached = null;
+
+    private void invokeAppLikeOnBaseContextAttached(Object appLike, Context base) throws TinkerRuntimeException {
+        try {
+            if (appLikeOnBaseContextAttached == null) {
+                appLikeOnBaseContextAttached = ShareReflectUtil.findMethod(applicationLike, "onBaseContextAttached", Context.class);
+            }
+            appLikeOnBaseContextAttached.invoke(appLike, base);
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException("fail to invoke onBaseContextAttached of appLike.", thr);
+        }
+    }
+
     /**
      * Hook for sub-classes to run logic after the {@link Application#attachBaseContext} has been
      * called but before the delegate is created. Implementors should be very careful what they do
      * here since {@link android.app.Application#onCreate} will not have yet been called.
      */
     private void onBaseContextAttached(Context base) {
-        applicationStartElapsedTime = SystemClock.elapsedRealtime();
-        applicationStartMillisTime = System.currentTimeMillis();
-        loadTinker();
-        ensureDelegate();
-        applicationLike.onBaseContextAttached(base);
-        //reset save mode
-        if (useSafeMode) {
-            String processName = ShareTinkerInternals.getProcessName(this);
-            String preferName = ShareConstants.TINKER_OWN_PREFERENCE_CONFIG + processName;
-            SharedPreferences sp = getSharedPreferences(preferName, Context.MODE_PRIVATE);
-            sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, 0).commit();
+        try {
+            applicationStartElapsedTime = SystemClock.elapsedRealtime();
+            applicationStartMillisTime = System.currentTimeMillis();
+            loadTinker();
+            ensureDelegate();
+            invokeAppLikeOnBaseContextAttached(applicationLike, base);
+            //reset save mode
+            if (useSafeMode) {
+                ShareTinkerInternals.setSafeModeCount(this, 0);
+            }
+        } catch (TinkerRuntimeException e) {
+            throw e;
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException(thr.getMessage(), thr);
         }
     }
 
@@ -163,23 +179,68 @@ private void loadTinker() {
         }
     }
 
+    private Method appLikeOnCreate = null;
+
+    private void invokeAppLikeOnCreate(Object appLike) throws TinkerRuntimeException {
+        try {
+            if (appLikeOnCreate == null) {
+                appLikeOnCreate = ShareReflectUtil.findMethod(applicationLike, "onCreate");
+            }
+            appLikeOnCreate.invoke(appLike);
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException("fail to invoke onCreate of appLike.", thr);
+        }
+    }
+
     @Override
     public void onCreate() {
         super.onCreate();
-        ensureDelegate();
         try {
-            ComponentHotplug.ensureComponentHotplugInstalled(this);
-        } catch (UnsupportedEnvironmentException e) {
-            throw new TinkerRuntimeException("failed to make sure that ComponentHotplug logic is fine.", e);
+            ensureDelegate();
+            try {
+                ComponentHotplug.ensureComponentHotplugInstalled(this);
+            } catch (UnsupportedEnvironmentException e) {
+                throw new TinkerRuntimeException("failed to make sure that ComponentHotplug logic is fine.", e);
+            }
+            invokeAppLikeOnCreate(applicationLike);
+        } catch (TinkerRuntimeException e) {
+            throw e;
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException(thr.getMessage(), thr);
+        }
+    }
+
+    private Method appLikeOnTerminate = null;
+
+    private void invokeAppLikeOnTerminate(Object appLike) throws TinkerRuntimeException {
+        try {
+            if (appLikeOnTerminate == null) {
+                appLikeOnTerminate = ShareReflectUtil.findMethod(applicationLike, "onTerminate");
+            }
+            appLikeOnTerminate.invoke(appLike);
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException("fail to invoke onTerminate of appLike.", thr);
         }
-        applicationLike.onCreate();
     }
 
     @Override
     public void onTerminate() {
         super.onTerminate();
         if (applicationLike != null) {
-            applicationLike.onTerminate();
+            invokeAppLikeOnTerminate(applicationLike);
+        }
+    }
+
+    private Method appLikeOnLowMemory = null;
+
+    private void invokeAppLikeOnLowMemory(Object appLike) throws TinkerRuntimeException {
+        try {
+            if (appLikeOnLowMemory == null) {
+                appLikeOnLowMemory = ShareReflectUtil.findMethod(applicationLike, "onLowMemory");
+            }
+            appLikeOnLowMemory.invoke(appLike);
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException("fail to invoke onLowMemory of appLike.", thr);
         }
     }
 
@@ -187,7 +248,20 @@ public void onTerminate() {
     public void onLowMemory() {
         super.onLowMemory();
         if (applicationLike != null) {
-            applicationLike.onLowMemory();
+            invokeAppLikeOnLowMemory(applicationLike);
+        }
+    }
+
+    private Method appLikeOnTrimMemory = null;
+
+    private void invokeAppLikeOnTrimMemory(Object appLike, int level) throws TinkerRuntimeException {
+        try {
+            if (appLikeOnTrimMemory == null) {
+                appLikeOnTrimMemory = ShareReflectUtil.findMethod(applicationLike, "onTrimMemory", int.class);
+            }
+            appLikeOnTrimMemory.invoke(appLike, level);
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException("fail to invoke onTrimMemory of appLike.", thr);
         }
     }
 
@@ -196,7 +270,20 @@ public void onLowMemory() {
     public void onTrimMemory(int level) {
         super.onTrimMemory(level);
         if (applicationLike != null) {
-            applicationLike.onTrimMemory(level);
+            invokeAppLikeOnTrimMemory(applicationLike, level);
+        }
+    }
+
+    private Method appLikeOnConfigurationChanged = null;
+
+    private void invokeAppLikeOnConfigurationChanged(Object appLike, Configuration newConfig) throws TinkerRuntimeException {
+        try {
+            if (appLikeOnConfigurationChanged == null) {
+                appLikeOnConfigurationChanged = ShareReflectUtil.findMethod(applicationLike, "onConfigurationChanged", Configuration.class);
+            }
+            appLikeOnConfigurationChanged.invoke(appLike, newConfig);
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException("fail to invoke onConfigurationChanged of appLike.", thr);
         }
     }
 
@@ -204,7 +291,20 @@ public void onTrimMemory(int level) {
     public void onConfigurationChanged(Configuration newConfig) {
         super.onConfigurationChanged(newConfig);
         if (applicationLike != null) {
-            applicationLike.onConfigurationChanged(newConfig);
+            invokeAppLikeOnConfigurationChanged(applicationLike, newConfig);
+        }
+    }
+
+    private Method appLikeGetResources = null;
+
+    private Resources invokeAppLikeGetResources(Object appLike, Resources resources) throws TinkerRuntimeException {
+        try {
+            if (appLikeGetResources == null) {
+                appLikeGetResources = ShareReflectUtil.findMethod(applicationLike, "getResources", Resources.class);
+            }
+            return (Resources) appLikeGetResources.invoke(appLike, resources);
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException("fail to invoke getResources of appLike.", thr);
         }
     }
 
@@ -212,43 +312,95 @@ public void onConfigurationChanged(Configuration newConfig) {
     public Resources getResources() {
         Resources resources = super.getResources();
         if (applicationLike != null) {
-            return applicationLike.getResources(resources);
+            return invokeAppLikeGetResources(applicationLike, resources);
         }
         return resources;
     }
 
+    private Method appLikeGetClassLoader = null;
+
+    private ClassLoader invokeAppLikeGetClassLoader(Object appLike, ClassLoader classLoader) throws TinkerRuntimeException {
+        try {
+            if (appLikeGetClassLoader == null) {
+                appLikeGetClassLoader = ShareReflectUtil.findMethod(applicationLike, "getClassLoader", ClassLoader.class);
+            }
+            return (ClassLoader) appLikeGetClassLoader.invoke(appLike, classLoader);
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException("fail to invoke getClassLoader of appLike.", thr);
+        }
+    }
+
     @Override
     public ClassLoader getClassLoader() {
         ClassLoader classLoader = super.getClassLoader();
         if (applicationLike != null) {
-            return applicationLike.getClassLoader(classLoader);
+            return invokeAppLikeGetClassLoader(applicationLike, classLoader);
         }
         return classLoader;
     }
 
+    private Method appLikeGetAssets = null;
+
+    private AssetManager invokeAppLikeGetAssets(Object appLike, AssetManager assetManager) throws TinkerRuntimeException {
+        try {
+            if (appLikeGetAssets == null) {
+                appLikeGetAssets = ShareReflectUtil.findMethod(applicationLike, "getAssets", AssetManager.class);
+            }
+            return (AssetManager) appLikeGetAssets.invoke(appLike, assetManager);
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException("fail to invoke getAssets of appLike.", thr);
+        }
+    }
+
     @Override
     public AssetManager getAssets() {
         AssetManager assetManager = super.getAssets();
         if (applicationLike != null) {
-            return applicationLike.getAssets(assetManager);
+            return invokeAppLikeGetAssets(applicationLike, assetManager);
         }
         return assetManager;
     }
 
+    private Method appLikeGetSystemService = null;
+
+    private Object invokeAppLikeGetSystemService(Object appLike, String name, Object service) throws TinkerRuntimeException {
+        try {
+            if (appLikeGetSystemService == null) {
+                appLikeGetSystemService = ShareReflectUtil.findMethod(applicationLike, "getSystemService", String.class, Object.class);
+            }
+            return appLikeGetSystemService.invoke(appLike, name, service);
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException("fail to invoke getSystemService of appLike.", thr);
+        }
+    }
+
     @Override
     public Object getSystemService(String name) {
         Object service = super.getSystemService(name);
         if (applicationLike != null) {
-            return applicationLike.getSystemService(name, service);
+            return invokeAppLikeGetSystemService(applicationLike, name, service);
         }
         return service;
     }
 
+    private Method appLikeGetBaseContext = null;
+
+    private Object invokeAppLikeGetBaseContext(Object appLike, Context base) throws TinkerRuntimeException {
+        try {
+            if (appLikeGetBaseContext == null) {
+                appLikeGetBaseContext = ShareReflectUtil.findMethod(applicationLike, "getBaseContext", Context.class);
+            }
+            return appLikeGetBaseContext.invoke(appLike, base);
+        } catch (Throwable thr) {
+            throw new TinkerRuntimeException("fail to invoke getBaseContext of appLike.", thr);
+        }
+    }
+
     @Override
     public Context getBaseContext() {
         Context base = super.getBaseContext();
         if (applicationLike != null) {
-            return applicationLike.getBaseContext(base);
+            return (Context) invokeAppLikeGetBaseContext(applicationLike, base);
         }
         return base;
     }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
index a7d2b324..ca92cf3b 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
@@ -59,10 +59,11 @@
 
     public static final String DEX_SUFFIX  = ".dex";
     public static final String JAR_SUFFIX  = ".jar";
+    public static final String APK_SUFFIX  = ".apk";
     public static final String ODEX_SUFFIX = ".odex";
 
     public static final String TEST_DEX_NAME            = "test.dex";
-    public static final String CHANGED_CLASSES_DEX_NAME = "changed_classes.dex";
+    public static final String CHANGED_CLASSES_DEX_PREFIX = "changed_classes";
     public static final String CLASS_N_APK_NAME         = "tinker_classN.apk";
 
     public static final String CHECK_DEX_INSTALL_FAIL = "checkDexInstall failed";
@@ -105,14 +106,14 @@
      * multi process share
      */
     public static final String TINKER_SHARE_PREFERENCE_CONFIG = "tinker_share_config";
-    public static final String TINKER_ENABLE_CONFIG           = "tinker_enable_";
+    public static final String TINKER_ENABLE_CONFIG_PREFIX    = "tinker_enable_";
 
     /**
      * only for each process
      */
-    public static final String TINKER_OWN_PREFERENCE_CONFIG = "tinker_own_config_";
-    public static final String TINKER_SAFE_MODE_COUNT       = "safe_mode_count";
-    public static final int    TINKER_SAFE_MODE_MAX_COUNT   = 3;
+    public static final String TINKER_OWN_PREFERENCE_CONFIG_PREFIX = "tinker_own_config_";
+    public static final String TINKER_SAFE_MODE_COUNT_PREFIX       = "safe_mode_count_";
+    public static final int    TINKER_SAFE_MODE_MAX_COUNT          = 3;
 
 
     /**
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
index 98a056f4..f3f97074 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
@@ -33,21 +33,24 @@
 public class SharePatchInfo {
     private static final String TAG = "Tinker.PatchInfo";
 
-    public static final int    MAX_EXTRACT_ATTEMPTS = ShareConstants.MAX_EXTRACT_ATTEMPTS;
-    public static final String OLD_VERSION          = ShareConstants.OLD_VERSION;
-    public static final String NEW_VERSION          = ShareConstants.NEW_VERSION;
-    public static final String FINGER_PRINT         = "print";
-    public static final String OAT_DIR              = "dir";
+    public static final int    MAX_EXTRACT_ATTEMPTS  = ShareConstants.MAX_EXTRACT_ATTEMPTS;
+    public static final String OLD_VERSION           = ShareConstants.OLD_VERSION;
+    public static final String NEW_VERSION           = ShareConstants.NEW_VERSION;
+    public static final String IS_REMOVE_NEW_VERSION = "is_remove_new_version";
+    public static final String FINGER_PRINT          = "print";
+    public static final String OAT_DIR               = "dir";
     public static final String DEFAULT_DIR   = ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
     public String oldVersion;
     public String newVersion;
+    public boolean isRemoveNewVersion;
     public String fingerPrint;
     public String oatDir;
 
-    public SharePatchInfo(String oldVer, String newVew, String finger, String oatDir) {
+    public SharePatchInfo(String oldVer, String newVew, boolean isRemoveNewVersion, String finger, String oatDir) {
         // TODO Auto-generated constructor stub
         this.oldVersion = oldVer;
         this.newVersion = newVew;
+        this.isRemoveNewVersion = isRemoveNewVersion;
         this.fingerPrint = finger;
         this.oatDir = oatDir;
     }
@@ -115,7 +118,8 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
         String oldVer = null;
         String newVer = null;
         String lastFingerPrint = null;
-        String oatDIr = null;
+        boolean isRemoveNewVersion = false;
+        String oatDir = null;
 
         while (numAttempts < MAX_EXTRACT_ATTEMPTS && !isReadPatchSuccessful) {
             numAttempts++;
@@ -126,8 +130,9 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
                 properties.load(inputStream);
                 oldVer = properties.getProperty(OLD_VERSION);
                 newVer = properties.getProperty(NEW_VERSION);
+                isRemoveNewVersion = !"0".equals(properties.getProperty(IS_REMOVE_NEW_VERSION));
                 lastFingerPrint = properties.getProperty(FINGER_PRINT);
-                oatDIr = properties.getProperty(OAT_DIR);
+                oatDir = properties.getProperty(OAT_DIR);
             } catch (IOException e) {
 //                e.printStackTrace();
                 Log.w(TAG, "read property failed, e:" + e);
@@ -149,7 +154,7 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
         }
 
         if (isReadPatchSuccessful) {
-            return new SharePatchInfo(oldVer, newVer, lastFingerPrint, oatDIr);
+            return new SharePatchInfo(oldVer, newVer, isRemoveNewVersion, lastFingerPrint, oatDir);
         }
 
         return null;
@@ -172,6 +177,8 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
             + info.oldVersion
             + ", newVer:"
             + info.newVersion
+            + ", isRemoveNewVersion:"
+            + (info.isRemoveNewVersion ? 1 : 0)
             + ", fingerprint:"
             + info.fingerPrint
             + ", oatDir:"
@@ -191,6 +198,7 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
             Properties newProperties = new Properties();
             newProperties.put(OLD_VERSION, info.oldVersion);
             newProperties.put(NEW_VERSION, info.newVersion);
+            newProperties.put(IS_REMOVE_NEW_VERSION, (info.isRemoveNewVersion ? "1" : "0"));
             newProperties.put(FINGER_PRINT, info.fingerPrint);
             newProperties.put(OAT_DIR, info.oatDir);
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
index 517c6dab..594e79b0 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
@@ -296,7 +296,8 @@ public static String getTypeString(int type) {
      */
     public static void setTinkerDisableWithSharedPreferences(Context context) {
         SharedPreferences sp = context.getSharedPreferences(ShareConstants.TINKER_SHARE_PREFERENCE_CONFIG, Context.MODE_MULTI_PROCESS);
-        sp.edit().putBoolean(getTinkerSharedPreferencesName(), false).commit();
+        String keyName = ShareConstants.TINKER_ENABLE_CONFIG_PREFIX + ShareConstants.TINKER_VERSION;
+        sp.edit().putBoolean(keyName, false).commit();
     }
 
     /**
@@ -310,11 +311,25 @@ public static boolean isTinkerEnableWithSharedPreferences(Context context) {
             return false;
         }
         SharedPreferences sp = context.getSharedPreferences(ShareConstants.TINKER_SHARE_PREFERENCE_CONFIG, Context.MODE_MULTI_PROCESS);
-        return sp.getBoolean(getTinkerSharedPreferencesName(), true);
+        String keyName = ShareConstants.TINKER_ENABLE_CONFIG_PREFIX + ShareConstants.TINKER_VERSION;
+        return sp.getBoolean(keyName, true);
     }
 
-    private static String getTinkerSharedPreferencesName() {
-        return ShareConstants.TINKER_ENABLE_CONFIG + ShareConstants.TINKER_VERSION;
+    public static int getSafeModeCount(Context context) {
+        String processName = ShareTinkerInternals.getProcessName(context);
+        String preferName = ShareConstants.TINKER_OWN_PREFERENCE_CONFIG_PREFIX + processName;
+        SharedPreferences sp = context.getSharedPreferences(preferName, Context.MODE_PRIVATE);
+        int count = sp.getInt(ShareConstants.TINKER_SAFE_MODE_COUNT_PREFIX + ShareConstants.TINKER_VERSION, 0);
+        Log.w(TAG, "getSafeModeCount: preferName:" + preferName + " count:" + count);
+        return count;
+    }
+
+    public static void setSafeModeCount(Context context, int count) {
+        String processName = ShareTinkerInternals.getProcessName(context);
+        String preferName = ShareConstants.TINKER_OWN_PREFERENCE_CONFIG_PREFIX + processName;
+        SharedPreferences sp = context.getSharedPreferences(preferName, Context.MODE_PRIVATE);
+        sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT_PREFIX + ShareConstants.TINKER_VERSION, count).commit();
+        Log.w(TAG, "setSafeModeCount: preferName:" + preferName + " count:" + count);
     }
 
     public static boolean isTinkerEnabled(int flag) {
diff --git a/tinker-build/tinker-patch-cli/build.gradle b/tinker-build/tinker-patch-cli/build.gradle
index c1bd4e62..f3fdb305 100644
--- a/tinker-build/tinker-patch-cli/build.gradle
+++ b/tinker-build/tinker-patch-cli/build.gradle
@@ -1,4 +1,4 @@
-apply plugin: 'java'
+apply plugin: 'java-library'
 
 version rootProject.ext.VERSION_NAME
 group rootProject.ext.GROUP
@@ -6,8 +6,8 @@ group rootProject.ext.GROUP
 [compileJava, compileTestJava, javadoc]*.options*.encoding = 'UTF-8'
 
 dependencies {
-    compile fileTree(dir: 'libs', include: ['*.jar'])
-    compile project(':tinker-build:tinker-patch-lib')
+    implementation fileTree(dir: 'libs', include: ['*.jar'])
+    implementation project(':tinker-build:tinker-patch-lib')
 }
 
 jar {
@@ -16,7 +16,11 @@ jar {
         attributes 'Manifest-Version': version
     }
     from {
-        configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }
+        configurations.compileClasspath.collect { it.isDirectory() ? it : zipTree(it) }
+    } {
+        exclude "META-INF/*.SF"
+        exclude "META-INF/*.DSA"
+        exclude "META-INF/*.RSA"
     }
 }
 
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro b/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro
index 5c9f4c5b..c394459f 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro
@@ -1,5 +1,5 @@
 #tinker multidex keep patterns:
--keep public class * implements com.tencent.tinker.loader.app.ApplicationLifeCycle {
+-keep public class * implements com.tencent.tinker.entry.ApplicationLifeCycle {
     <init>();
     void onBaseContextAttached(android.content.Context);
 }
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro b/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
index 85e96b50..4de5fc9a 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
@@ -7,10 +7,10 @@
     *;
 }
 
--keep public class com.tencent.tinker.loader.app.ApplicationLifeCycle {
+-keep public class com.tencent.tinker.entry.ApplicationLifeCycle {
     *;
 }
--keep public class * implements com.tencent.tinker.loader.app.ApplicationLifeCycle {
+-keep public class * implements com.tencent.tinker.entry.ApplicationLifeCycle {
     *;
 }
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/build.gradle b/tinker-build/tinker-patch-gradle-plugin/build.gradle
index fa4fb4e2..0f646ed2 100644
--- a/tinker-build/tinker-patch-gradle-plugin/build.gradle
+++ b/tinker-build/tinker-patch-gradle-plugin/build.gradle
@@ -5,12 +5,12 @@ version rootProject.ext.VERSION_NAME
 group rootProject.ext.GROUP
 
 dependencies {
-    compile gradleApi()
-    compile localGroovy()
-//    compile fileTree(dir: 'libs', include: ['*.jar'])
-    compile project(':tinker-build:tinker-patch-lib')
-    compile 'com.google.gradle:osdetector-gradle-plugin:1.2.1'
-    compile 'com.android.tools.build:gradle:2.1.0'
+    implementation gradleApi()
+    implementation localGroovy()
+//    implementation fileTree(dir: 'libs', include: ['*.jar'])
+    implementation project(':tinker-build:tinker-patch-lib')
+    implementation 'com.google.gradle:osdetector-gradle-plugin:1.6.0'
+    implementation 'com.android.tools.build:gradle:3.2.1'
 }
 
 repositories {
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
index 80825350..ee61556b 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
@@ -67,11 +67,10 @@ class TinkerPatchPlugin implements Plugin<Project> {
             //open jumboMode
             android.dexOptions.jumboMode = true
 
-            //disable aapt2
-            reflectAapt2Flag()
-
             //disable dex archive mode
             disableArchiveDex()
+            //dex
+            android.dexOptions.keepRuntimeAnnotatedClasses = false
         } catch (Throwable e) {
             //no preDexLibraries field, just continue
         }
@@ -89,7 +88,6 @@ class TinkerPatchPlugin implements Plugin<Project> {
             project.logger.error("excluding annotation processor and source template from app packaging. Enable dx jumboMode to reduce package size.")
             project.logger.error("enable dx jumboMode to reduce package size.")
             project.logger.error("disable preDexLibraries to prevent ClassDefNotFoundException when your app is booting.")
-            project.logger.error("disable aapt2 so far for resource id keeping.")
             project.logger.error("disable archive dex mode so far for keeping dex apply.")
             project.logger.error("")
             project.logger.error("tinker will change your build configs:")
@@ -160,6 +158,8 @@ class TinkerPatchPlugin implements Plugin<Project> {
 
                 //resource id
                 TinkerResourceIdTask applyResourceTask = project.tasks.create("tinkerProcess${variantName}ResourceId", TinkerResourceIdTask)
+                applyResourceTask.applicationId = variantData.getApplicationId()
+                applyResourceTask.variantName = variant.name
 
                 if (variantOutput.processResources.properties['resDir'] != null) {
                     applyResourceTask.resDir = variantOutput.processResources.resDir
@@ -170,6 +170,11 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 applyResourceTask.mustRunAfter manifestTask
 
                 variantOutput.processResources.dependsOn applyResourceTask
+                // Fix issue-866.
+                // We found some case that applyResourceTask run after mergeResourcesTask, it caused 'applyResourceMapping' config not work.
+                // The task need merged resources to calculate ids.xml, it must depends on merge resources task.
+                def mergeResourcesTask = project.tasks.findByName("merge${variantName.capitalize()}Resources")
+                applyResourceTask.dependsOn mergeResourcesTask
 
                 if (manifestTask.manifestPath == null || applyResourceTask.resDir == null) {
                     throw new RuntimeException("manifestTask.manifestPath or applyResourceTask.resDir is null.")
@@ -240,24 +245,6 @@ class TinkerPatchPlugin implements Plugin<Project> {
         tinkerPatchBuildTask.outputFolder = outputFolder
     }
 
-    void reflectAapt2Flag() {
-        try {
-            def booleanOptClazz = Class.forName('com.android.build.gradle.options.BooleanOption')
-            def enableAAPT2Field = booleanOptClazz.getDeclaredField('ENABLE_AAPT2')
-            enableAAPT2Field.setAccessible(true)
-            def enableAAPT2EnumObj = enableAAPT2Field.get(null)
-            def defValField = enableAAPT2EnumObj.getClass().getDeclaredField('defaultValue')
-            defValField.setAccessible(true)
-            defValField.set(enableAAPT2EnumObj, false)
-        } catch (Throwable thr) {
-            // To some extends, class not found means we are in lower version of android gradle
-            // plugin, so just ignore that exception.
-            if (!(thr instanceof ClassNotFoundException)) {
-                project.logger.error("reflectAapt2Flag error: ${thr.getMessage()}.")
-            }
-        }
-    }
-
     void disableArchiveDex() {
         try {
             def booleanOptClazz = Class.forName('com.android.build.gradle.options.BooleanOption')
@@ -319,4 +306,4 @@ class TinkerPatchPlugin implements Plugin<Project> {
         return project.tasks.findByName(collectMultiDexComponents)
     }
 
-}
\ No newline at end of file
+}
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
index 2b148947..73ef23fe 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
@@ -28,11 +28,15 @@ import org.gradle.api.tasks.TaskAction
 public class TinkerMultidexConfigTask extends DefaultTask {
     static final String MULTIDEX_CONFIG_PATH = TinkerPatchPlugin.TINKER_INTERMEDIATES + "tinker_multidexkeep.pro"
     static final String MULTIDEX_CONFIG_SETTINGS =
-            "-keep public class * implements com.tencent.tinker.loader.app.ApplicationLifeCycle {\n" +
+            "-keep public class * implements com.tencent.tinker.entry.ApplicationLifeCycle {\n" +
                     "    <init>(...);\n" +
                     "    void onBaseContextAttached(android.content.Context);\n" +
                     "}\n" +
                     "\n" +
+                    "-keep public class com.tencent.tinker.entry.ApplicationLifeCycle {\n" +
+                    "    *;\n" +
+                    "}\n" +
+                    "\n" +
                     "-keep public class * extends com.tencent.tinker.loader.TinkerLoader {\n" +
                     "    <init>(...);\n" +
                     "}\n" +
@@ -102,9 +106,23 @@ public class TinkerMultidexConfigTask extends DefaultTask {
             multiDexKeepProguard = applicationVariant.getVariantData().getScope().getManifestKeepListProguardFile()
         } catch (Throwable ignore) {
             try {
-                multiDexKeepProguard = applicationVariant.getVariantData().getScope().getManifestKeepListFile()
+                def buildableArtifact = applicationVariant.getVariantData().getScope().getArtifacts().getFinalArtifactFiles(
+                        Class.forName("com.android.build.gradle.internal.scope.InternalArtifactType")
+                                .getDeclaredField("LEGACY_MULTIDEX_AAPT_DERIVED_PROGUARD_RULES")
+                                .get(null)
+                )
+
+                //noinspection GroovyUncheckedAssignmentOfMemberOfRawType,UnnecessaryQualifiedReference
+                multiDexKeepProguard = com.google.common.collect.Iterators.getOnlyElement(buildableArtifact.iterator())
             } catch (Throwable e) {
-                project.logger.error("can't find getManifestKeepListFile method, exception:${e}")
+
+            }
+            if (multiDexKeepProguard == null) {
+                try {
+                    multiDexKeepProguard = applicationVariant.getVariantData().getScope().getManifestKeepListFile()
+                } catch (Throwable e) {
+                    project.logger.error("can't find getManifestKeepListFile method, exception:${e}")
+                }
             }
         }
         if (multiDexKeepProguard == null) {
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
index 23230b52..940a8707 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
@@ -36,10 +36,10 @@ public class TinkerProguardConfigTask extends DefaultTask {
                     "    *;\n" +
                     "}\n" +
                     "\n" +
-                    "-keep public class com.tencent.tinker.loader.app.ApplicationLifeCycle {\n" +
+                    "-keep public class com.tencent.tinker.entry.ApplicationLifeCycle {\n" +
                     "    *;\n" +
                     "}\n" +
-                    "-keep public class * implements com.tencent.tinker.loader.app.ApplicationLifeCycle {\n" +
+                    "-keep public class * implements com.tencent.tinker.entry.ApplicationLifeCycle {\n" +
                     "    *;\n" +
                     "}\n" +
                     "\n" +
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
index ba6c2c75..b119b357 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
@@ -22,8 +22,15 @@ import com.tencent.tinker.build.aapt.PatchUtil
 import com.tencent.tinker.build.aapt.RDotTxtEntry
 import com.tencent.tinker.build.gradle.TinkerPatchPlugin
 import com.tencent.tinker.build.util.FileOperation
+import groovy.io.FileType
 import org.gradle.api.DefaultTask
+import org.gradle.api.GradleException
+import org.gradle.api.Project
 import org.gradle.api.tasks.TaskAction
+import org.gradle.util.GFileUtils
+
+import java.util.regex.Matcher
+import java.util.regex.Pattern
 
 /**
  * The configuration properties.
@@ -33,13 +40,266 @@ import org.gradle.api.tasks.TaskAction
 public class TinkerResourceIdTask extends DefaultTask {
     static final String RESOURCE_PUBLIC_XML = TinkerPatchPlugin.TINKER_INTERMEDIATES + "public.xml"
     static final String RESOURCE_IDX_XML = TinkerPatchPlugin.TINKER_INTERMEDIATES + "idx.xml"
+    static final String RESOURCE_VALUES_BACKUP = TinkerPatchPlugin.TINKER_INTERMEDIATES + "values_backup"
+    static final String RESOURCE_PUBLIC_TXT = TinkerPatchPlugin.TINKER_INTERMEDIATES + "public.txt"
+
+    //it's parent dir must start with values
+    static final String RESOURCE_TO_COMPILE_PUBLIC_XML = TinkerPatchPlugin.TINKER_INTERMEDIATES + "aapt2/res/values/tinker_public.xml"
 
     String resDir
+    String variantName
+    String applicationId
+
+    //if you need add public flag, set tinker.aapt2.public = true in gradle.properties
+    boolean addPublicFlagForAapt2 = false
 
     TinkerResourceIdTask() {
         group = 'tinker'
     }
 
+    /**
+     * get android gradle plugin version by reflect
+     */
+    static String getAndroidGradlePluginVersionCompat() {
+        String version = null
+        try {
+            Class versionModel = Class.forName("com.android.builder.model.Version")
+            def versionFiled = versionModel.getDeclaredField("ANDROID_GRADLE_PLUGIN_VERSION")
+            versionFiled.setAccessible(true)
+            version = versionFiled.get(null)
+        } catch (Exception e) {
+
+        }
+        return version
+    }
+
+    /**
+     * get enum obj by reflect
+     */
+    static <T> T resolveEnumValue(String value, Class<T> type) {
+        for (T constant : type.getEnumConstants()) {
+            if (constant.toString().equalsIgnoreCase(value)) {
+                return constant
+            }
+        }
+        return null
+    }
+
+    /**
+     * get com.android.build.gradle.options.ProjectOptions obj by reflect
+     */
+    static def getProjectOptions(Project project) {
+        try {
+            def basePlugin = project.getPlugins().hasPlugin('com.android.application') ? project.getPlugins().findPlugin('com.android.application') : project.getPlugins().findPlugin('com.android.library')
+            return Class.forName("com.android.build.gradle.BasePlugin").getMetaClass().getProperty(basePlugin, 'projectOptions')
+        } catch (Exception e) {
+        }
+        return null
+    }
+
+    /**
+     * get whether aapt2 is enabled
+     */
+    static boolean isAapt2EnabledCompat(Project project) {
+        if (getAndroidGradlePluginVersionCompat() >= '3.3.0') {
+            //when agp' version >= 3.3.0, use aapt2 default and no way to switch to aapt.
+            return true
+        }
+        boolean aapt2Enabled = false
+        try {
+            def projectOptions = getProjectOptions(project)
+            Object enumValue = resolveEnumValue("ENABLE_AAPT2", Class.forName("com.android.build.gradle.options.BooleanOption"))
+            aapt2Enabled = projectOptions.get(enumValue)
+        } catch (Exception e) {
+            try {
+                //retry for agp <= 2.3.3
+                //when agp <= 2.3.3, the field is store in com.android.build.gradle.AndroidGradleOptions
+                Class classAndroidGradleOptions = Class.forName("com.android.build.gradle.AndroidGradleOptions")
+                def isAapt2Enabled = classAndroidGradleOptions.getDeclaredMethod("isAapt2Enabled", Project.class)
+                isAapt2Enabled.setAccessible(true)
+                aapt2Enabled = isAapt2Enabled.invoke(null, project)
+            } catch (Exception e1) {
+                //if we can't get it, it means aapt2 is not support current.
+                aapt2Enabled = false
+            }
+        }
+        return aapt2Enabled
+    }
+
+    /**
+     * add --stable-ids param to aaptOptions's additionalParameters
+     */
+    List<String> addStableIdsFileToAdditionalParameters(def processAndroidResourceTask) {
+        def aaptOptions = processAndroidResourceTask.getAaptOptions()
+        List<String> additionalParameters = new ArrayList<>()
+        List<String> originalAdditionalParameters = aaptOptions.getAdditionalParameters()
+        if (originalAdditionalParameters != null) {
+            additionalParameters.addAll(originalAdditionalParameters)
+        }
+        aaptOptions.setAdditionalParameters(additionalParameters)
+        additionalParameters.add("--stable-ids")
+        additionalParameters.add(project.file(RESOURCE_PUBLIC_TXT).getAbsolutePath())
+        project.logger.error("tinker add additionalParameters --stable-ids ${project.file(RESOURCE_PUBLIC_TXT).getAbsolutePath()}")
+        return additionalParameters
+    }
+
+    /**
+     * get real name for style type resources in R.txt by values files
+     */
+    Map<String, String> getStyles() {
+        Map<String, String> styles = new HashMap<>()
+        def mergeResourcesTask = project.tasks.findByName("merge${variantName.capitalize()}Resources")
+        List<File> resDirCandidateList = new ArrayList<>()
+        resDirCandidateList.add(mergeResourcesTask.outputDir)
+        resDirCandidateList.add(new File(mergeResourcesTask.getIncrementalFolder(), "merged.dir"))
+        resDirCandidateList.each {
+            it.eachFileRecurse(FileType.FILES) {
+                if (it.getParentFile().getName().startsWith("values") && it.getName().startsWith("values") && it.getName().endsWith(".xml")) {
+                    File destFile = new File(project.file(RESOURCE_VALUES_BACKUP), "${it.getParentFile().getName()}/${it.getName()}")
+                    GFileUtils.deleteQuietly(destFile)
+                    GFileUtils.mkdirs(destFile.getParentFile())
+                    GFileUtils.copyFile(it, destFile)
+                }
+            }
+        }
+        project.file(RESOURCE_VALUES_BACKUP).eachFileRecurse(FileType.FILES) {
+            new XmlParser().parse(it).each {
+                if ("style".equalsIgnoreCase("${it.name()}")) {
+                    String originalStyle = "${it.@name}".toString()
+                    //replace . to _
+                    String sanitizeName = originalStyle.replaceAll("[.:]", "_");
+                    styles.put(sanitizeName, originalStyle)
+                }
+            }
+        }
+        return styles
+    }
+
+    /**
+     * get the sorted stable id lines
+     */
+    ArrayList<String> getSortedStableIds(Map<RDotTxtEntry.RType, Set<RDotTxtEntry>> rTypeResourceMap) {
+        List<String> sortedLines = new ArrayList<>()
+        Map<String, String> styles = getStyles()
+        rTypeResourceMap?.each { key, entries ->
+            entries.each {
+                if (it.type == RDotTxtEntry.RType.STYLEABLE) {
+                    //ignore styleable type, also public.xml ignore it.
+                    return
+                } else if (it.type == RDotTxtEntry.RType.STYLE) {
+                    //the name in R.txt for style type which has replaced . to _
+                    //so we should get the original name for it
+                    sortedLines.add("${applicationId}:${it.type}/${styles.get(it.name)} = ${it.idValue}")
+                } else if (it.type == RDotTxtEntry.RType.DRAWABLE) {
+                    //there is a special resource type for drawable which called nested resource.
+                    //such as avd_hide_password and avd_show_password resource in support design sdk.
+                    //the nested resource is start with $, such as $avd_hide_password__0 and $avd_hide_password__1
+                    //but there is none nested resource in R.txt, so ignore it just now.
+                    sortedLines.add("${applicationId}:${it.type}/${it.name} = ${it.idValue}")
+                } else {
+                    //other resource type which format is packageName:resType/resName = resId
+                    sortedLines.add("${applicationId}:${it.type}/${it.name} = ${it.idValue}")
+                }
+            }
+        }
+        //sort it and see the diff content conveniently
+        Collections.sort(sortedLines)
+        return sortedLines
+    }
+
+    /**
+     * convert public.txt to public.xml
+     */
+    @SuppressWarnings("GrMethodMayBeStatic")
+    void convertPublicTxtToPublicXml(File publicTxtFile, File publicXmlFile, boolean withId) {
+        if (publicTxtFile == null) {
+            return
+        }
+        GFileUtils.deleteQuietly(publicXmlFile)
+        GFileUtils.mkdirs(publicXmlFile.getParentFile())
+        GFileUtils.touch(publicXmlFile)
+
+        publicXmlFile.append("<!-- AUTO-GENERATED FILE.  DO NOT MODIFY -->")
+        publicXmlFile.append("\n")
+        publicXmlFile.append("<resources>")
+        publicXmlFile.append("\n")
+        Pattern linePattern = Pattern.compile(".*?:(.*?)/(.*?)\\s+=\\s+(.*?)")
+
+        publicTxtFile?.eachLine { def line ->
+            Matcher matcher = linePattern.matcher(line)
+            if (matcher.matches() && matcher.groupCount() == 3) {
+                String resType = matcher.group(1)
+                String resName = matcher.group(2)
+                if (resName.startsWith('$')) {
+                    project.logger.error("ignore convert to public res ${resName} because it's a nested resource")
+                } else if (resType.equalsIgnoreCase("styleable")) {
+                    project.logger.error("ignore convert to public res ${resName} because it's a styleable resource")
+                } else {
+                    if (withId) {
+                        publicXmlFile.append("\t<public type=\"${resType}\" name=\"${resName}\" id=\"${matcher.group(3)}\" />\n")
+                    } else {
+                        publicXmlFile.append("\t<public type=\"${resType}\" name=\"${resName}\" />\n")
+                    }
+                }
+            }
+        }
+        publicXmlFile.append("</resources>")
+    }
+
+    /**
+     * compile xml file to flat file
+     */
+    void compileXmlForAapt2(File xmlFile) {
+        if (xmlFile == null || !xmlFile.exists()) {
+            return
+        }
+
+        def foundVariant = null
+        project.android.applicationVariants.all { def variant ->
+            if (variant.getName() == variantName) {
+                foundVariant = variant
+            }
+        }
+
+        if (foundVariant == null) {
+            throw new GradleException("variant ${variantName} not found")
+        }
+
+        def variantData = foundVariant.getMetaClass().getProperty(foundVariant, 'variantData')
+        def variantScope = variantData.getScope()
+        def globalScope = variantScope.getGlobalScope()
+        def androidBuilder = globalScope.getAndroidBuilder()
+        def targetInfo = androidBuilder.getTargetInfo()
+        def buildTools = targetInfo.getBuildTools()
+        Map paths = buildTools.getMetaClass().getProperty(buildTools, "mPaths")
+        String aapt2Path = paths.get(resolveEnumValue("AAPT2", Class.forName('com.android.sdklib.BuildToolInfo$PathId')))
+
+        try {
+            //may be from maven, the flat magic number don't match. so we should also use the aapt2 from maven.
+            Class aapt2MavenUtilsClass = Class.forName("com.android.build.gradle.internal.res.Aapt2MavenUtils")
+            def getAapt2FromMavenMethod = aapt2MavenUtilsClass.getDeclaredMethod("getAapt2FromMaven", Class.forName("com.android.build.gradle.internal.scope.GlobalScope"))
+            getAapt2FromMavenMethod.setAccessible(true)
+            def aapt2FromMaven = getAapt2FromMavenMethod.invoke(null, globalScope)
+            //noinspection UnnecessaryQualifiedReference
+            aapt2Path = aapt2FromMaven.singleFile.toPath().resolve(com.android.SdkConstants.FN_AAPT2)
+        } catch (Exception e) {
+            //ignore
+        }
+
+        project.logger.error("tinker get aapt2 path ${aapt2Path}")
+        def mergeResourcesTask = project.tasks.findByName("merge${variantName.capitalize()}Resources")
+        if (xmlFile.exists()) {
+            project.exec { def execSpec ->
+                execSpec.executable "${aapt2Path}"
+                execSpec.args("compile")
+                execSpec.args("--legacy")
+                execSpec.args("-o")
+                execSpec.args("${mergeResourcesTask.outputDir}")
+                execSpec.args("${xmlFile}")
+            }
+        }
+    }
+
     @TaskAction
     def applyResourceId() {
         String resourceMappingFile = project.extensions.tinkerPatch.buildConfig.applyResourceMapping
@@ -49,28 +309,58 @@ public class TinkerResourceIdTask extends DefaultTask {
             project.logger.error("apply resource mapping file ${resourceMappingFile} is illegal, just ignore")
             return
         }
-        String idsXml = resDir + "/values/ids.xml";
-        String publicXml = resDir + "/values/public.xml";
-        FileOperation.deleteFile(idsXml);
-        FileOperation.deleteFile(publicXml);
-        List<String> resourceDirectoryList = new ArrayList<String>()
-        resourceDirectoryList.add(resDir)
-
         project.logger.error("we build ${project.getName()} apk with apply resource mapping file ${resourceMappingFile}")
         project.extensions.tinkerPatch.buildConfig.usingResourceMapping = true
         Map<RDotTxtEntry.RType, Set<RDotTxtEntry>> rTypeResourceMap = PatchUtil.readRTxt(resourceMappingFile)
 
-        AaptResourceCollector aaptResourceCollector = AaptUtil.collectResource(resourceDirectoryList, rTypeResourceMap)
-        PatchUtil.generatePublicResourceXml(aaptResourceCollector, idsXml, publicXml)
-        File publicFile = new File(publicXml)
-        if (publicFile.exists()) {
-            FileOperation.copyFileUsingStream(publicFile, project.file(RESOURCE_PUBLIC_XML))
-            project.logger.error("tinker gen resource public.xml in ${RESOURCE_PUBLIC_XML}")
-        }
-        File idxFile = new File(idsXml)
-        if (idxFile.exists()) {
-            FileOperation.copyFileUsingStream(idxFile, project.file(RESOURCE_IDX_XML))
-            project.logger.error("tinker gen resource idx.xml in ${RESOURCE_IDX_XML}")
+
+        if (!isAapt2EnabledCompat(project)) {
+            String idsXml = resDir + "/values/ids.xml";
+            String publicXml = resDir + "/values/public.xml";
+            FileOperation.deleteFile(idsXml);
+            FileOperation.deleteFile(publicXml);
+            List<String> resourceDirectoryList = new ArrayList<String>()
+            resourceDirectoryList.add(resDir)
+
+            AaptResourceCollector aaptResourceCollector = AaptUtil.collectResource(resourceDirectoryList, rTypeResourceMap)
+            PatchUtil.generatePublicResourceXml(aaptResourceCollector, idsXml, publicXml)
+            File publicFile = new File(publicXml)
+            if (publicFile.exists()) {
+                FileOperation.copyFileUsingStream(publicFile, project.file(RESOURCE_PUBLIC_XML))
+                project.logger.error("tinker gen resource public.xml in ${RESOURCE_PUBLIC_XML}")
+            }
+            File idxFile = new File(idsXml)
+            if (idxFile.exists()) {
+                FileOperation.copyFileUsingStream(idxFile, project.file(RESOURCE_IDX_XML))
+                project.logger.error("tinker gen resource idx.xml in ${RESOURCE_IDX_XML}")
+            }
+        } else {
+            File stableIdsFile = project.file(RESOURCE_PUBLIC_TXT)
+            FileOperation.deleteFile(stableIdsFile);
+            ArrayList<String> sortedLines = getSortedStableIds(rTypeResourceMap)
+
+            sortedLines?.each {
+                stableIdsFile.append("${it}\n")
+            }
+
+            def processResourcesTask = project.tasks.findByName("process${variantName.capitalize()}Resources")
+            processResourcesTask.doFirst {
+                addStableIdsFileToAdditionalParameters(processResourcesTask)
+
+                if (project.hasProperty("tinker.aapt2.public")) {
+                    addPublicFlagForAapt2 = project.ext["tinker.aapt2.public"]?.toString()?.toBoolean()
+                }
+
+                if (addPublicFlagForAapt2) {
+                    //if we need add public flag for resource, we need to compile public.xml to .flat file
+                    //it's parent dir must start with values
+                    File publicXmlFile = project.file(RESOURCE_TO_COMPILE_PUBLIC_XML)
+                    //convert public.txt to public.xml
+                    convertPublicTxtToPublicXml(stableIdsFile, publicXmlFile, false)
+                    //dest file is mergeResourceTask output dir
+                    compileXmlForAapt2(publicXmlFile)
+                }
+            }
         }
     }
 }
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
index 25f5fff1..92a35eaf 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
@@ -371,6 +371,9 @@ public class ImmutableDexTransform extends Transform {
             @Override
             public void graphPopulated(TaskExecutionGraph taskGraph) {
                 for (Task task : taskGraph.getAllTasks()) {
+                    if (task.project != project) {
+                        continue
+                    }
                     if (task instanceof TransformTask && task.name.toLowerCase().contains(variant.name.toLowerCase())) {
 
                         if (((TransformTask) task).getTransform() instanceof DexTransform && !(((TransformTask) task).getTransform() instanceof ImmutableDexTransform)) {
diff --git a/tinker-build/tinker-patch-lib/build.gradle b/tinker-build/tinker-patch-lib/build.gradle
index 239c258c..37b874b4 100644
--- a/tinker-build/tinker-patch-lib/build.gradle
+++ b/tinker-build/tinker-patch-lib/build.gradle
@@ -1,4 +1,4 @@
-apply plugin: 'java'
+apply plugin: 'java-library'
 
 version rootProject.ext.VERSION_NAME
 group rootProject.ext.GROUP
@@ -7,14 +7,13 @@ group rootProject.ext.GROUP
 
 
 dependencies {
-    compile fileTree(dir: 'libs', include: ['*.jar'])
-    compile project(':tinker-commons')
-    compile group: 'com.tencent.mm', name: 'apk-parser-lib', version: '1.2.3'
-    compile group: 'com.google.guava', name: 'guava', version: '11.0.2'
-    compile group: 'org.ow2.asm', name: 'asm', version: '5.0.3'
-    compile group: 'org.smali', name: 'dexlib2', version: '2.1.3'
-
-    compile (group: 'dom4j', name: 'dom4j', version: '1.6.1')
+    implementation fileTree(dir: 'libs', include: ['*.jar'])
+    api project(':tinker-commons')
+    api group: 'com.tencent.mm', name: 'apk-parser-lib', version: '1.2.3'
+    implementation group: 'com.google.guava', name: 'guava', version: '11.0.2'
+    implementation group: 'org.ow2.asm', name: 'asm', version: '5.0.3'
+    implementation group: 'org.smali', name: 'dexlib2', version: '2.1.3'
+    implementation group: 'dom4j', name: 'dom4j', version: '1.6.1'
 }
 
 sourceSets {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
index 56675bcb..20f6b1ac 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
@@ -277,6 +277,11 @@ public static void processXmlFile(String xmlFullFilename, List<RDotTxtEntry> ref
             if (name.startsWith("android:")) {
                 continue;
             }
+
+            if (rawRType.startsWith("tools:")) {
+                continue;
+            }
+
             if (!RESOURCE_TYPES.containsKey(rawRType)) {
                 throw new AaptUtilException("Invalid reference '" + resourceName + "' in '" + xmlFullFilename + "'");
             }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/DefaultFileCopyProcessor.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/DefaultFileCopyProcessor.java
deleted file mode 100644
index 83bd529e..00000000
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/DefaultFileCopyProcessor.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright 2014-present Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may
- * not use this file except in compliance with the License. You may obtain
- * a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-package com.tencent.tinker.build.aapt;
-
-import com.tencent.tinker.commons.util.StreamUtil;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-public class DefaultFileCopyProcessor implements FileUtil.FileCopyProcessor {
-
-    /**
-     * copyFileToFileProcess
-     *
-     * @param from,maybe   directory
-     * @param to,maybe     directory
-     * @param isFile,maybe directory or file
-     * @return boolean, if true keep going copy,only active in directory so far
-     */
-    public boolean copyFileToFileProcess(final String from, final String to, final boolean isFile) {
-        try {
-            if (isFile) {
-                String fromFile = new File(from).getAbsolutePath();
-                String toFile = new File(to).getAbsolutePath();
-                if (fromFile.equals(toFile)) {
-                    toFile = toFile + "_copy";
-                }
-                FileUtil.createFile(toFile);
-                InputStream inputStream = null;
-                OutputStream outputStream = null;
-                try {
-                    inputStream = new FileInputStream(fromFile);
-                    outputStream = new FileOutputStream(toFile);
-                    byte[] buffer = new byte[Constant.Capacity.BYTES_PER_KB];
-                    int length = -1;
-                    while ((length = inputStream.read(buffer, 0, buffer.length)) != -1) {
-                        outputStream.write(buffer, 0, length);
-                    }
-                } finally {
-                    StreamUtil.closeQuietly(outputStream);
-                    StreamUtil.closeQuietly(inputStream);
-                }
-            } else {
-                FileUtil.createDirectory(to);
-            }
-        } catch (Exception e) {
-            throw new FileCopyException(e);
-        }
-        return true;
-    }
-}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/FileUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/FileUtil.java
index 1a3db2d6..97e1cb4c 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/FileUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/FileUtil.java
@@ -16,40 +16,15 @@
 
 package com.tencent.tinker.build.aapt;
 
-import com.tencent.tinker.commons.util.StreamUtil;
-
-import java.io.BufferedReader;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
 import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Enumeration;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Properties;
 import java.util.Queue;
-import java.util.Set;
 import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.CopyOnWriteArrayList;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipException;
-import java.util.zip.ZipFile;
-import java.util.zip.ZipOutputStream;
 
 public final class FileUtil {
 
-    private static final FileCopyProcessor DEFAULT_FILE_COPY_PROCESSOR = new DefaultFileCopyProcessor();
-
     private FileUtil() {
     }
 
@@ -64,35 +39,6 @@ public static boolean isExist(String path) {
         return file.exists();
     }
 
-    /**
-     * is has file from directory
-     *
-     * @param directory
-     * @param fileSuffix
-     * @return boolean
-     */
-    public static boolean isHasFile(String directory, String fileSuffix) {
-        boolean result = false;
-        File directoryFile = new File(directory);
-        Queue<File> queue = new ConcurrentLinkedQueue<File>();
-        queue.add(directoryFile);
-        while (!queue.isEmpty()) {
-            File file = queue.poll();
-            if (file.isDirectory()) {
-                File[] fileArray = file.listFiles();
-                if (fileArray != null) {
-                    queue.addAll(Arrays.asList(fileArray));
-                }
-            } else if (file.isFile()) {
-                if (file.getName().toLowerCase().endsWith(fileSuffix.toLowerCase())) {
-                    result = true;
-                    break;
-                }
-            }
-        }
-        return result;
-    }
-
     /**
      * create directory
      *
@@ -127,531 +73,6 @@ public static boolean createFile(final String fullFilename) {
         return result;
     }
 
-    /**
-     * delete all file
-     *
-     * @param directory
-     */
-    public static void deleteAllFile(String directory) {
-        List<File> fileList = new ArrayList<File>();
-        File directoryFile = new File(directory);
-        Queue<File> queue = new ConcurrentLinkedQueue<File>();
-        queue.add(directoryFile);
-        while (!queue.isEmpty()) {
-            File file = queue.poll();
-            if (file.isDirectory()) {
-                File[] fileArray = file.listFiles();
-                if (fileArray != null) {
-                    queue.addAll(Arrays.asList(fileArray));
-                }
-            }
-            fileList.add(file);
-        }
-        for (int i = fileList.size() - 1; i >= 0; i--) {
-            fileList.get(i).delete();
-        }
-    }
-
-    /**
-     * copy file,default path to path
-     *
-     * @param from
-     * @param to
-     */
-    public static void copyFile(final String from, final String to) {
-        copyFile(from, to, FileCopyType.PATH_TO_PATH, DEFAULT_FILE_COPY_PROCESSOR);
-    }
-
-    /**
-     * copy file
-     *
-     * @param from
-     * @param to
-     * @param fileCopyType
-     */
-    public static void copyFile(final String from, final String to, final FileCopyType fileCopyType) {
-        copyFile(from, to, fileCopyType, DEFAULT_FILE_COPY_PROCESSOR);
-    }
-
-    /**
-     * copy file
-     *
-     * @param from
-     * @param to
-     * @param fileCopyType
-     * @param fileCopyProcessor
-     */
-    public static void copyFile(final String from, final String to, final FileCopyType fileCopyType, FileCopyProcessor fileCopyProcessor) {
-        switch (fileCopyType) {
-            case FILE_TO_PATH:
-                copyFileToPath(from, to, fileCopyProcessor);
-                break;
-            case FILE_TO_FILE:
-                copyFileToFile(from, to, fileCopyProcessor);
-                break;
-            case PATH_TO_PATH:
-            default:
-                copyPathToPath(from, to, fileCopyProcessor);
-                break;
-        }
-    }
-
-    /**
-     * copy path to path,copy process include directory copy
-     *
-     * @param fromPath
-     * @param toPath
-     * @param fileCopyProcessor
-     */
-    public static void copyPathToPath(final String fromPath, final String toPath, FileCopyProcessor fileCopyProcessor) {
-        File fromDirectoryFile = new File(fromPath);
-        File toDirectoryFile = new File(toPath);
-        String fromDirectoryPath = fromDirectoryFile.getAbsolutePath();
-        String toDirectoryPath = toDirectoryFile.getAbsolutePath();
-        if (fromDirectoryPath.equals(toDirectoryPath)) {
-            toDirectoryPath = toDirectoryPath + "_copy";
-        }
-        Queue<File> queue = new ConcurrentLinkedQueue<File>();
-        queue.add(fromDirectoryFile);
-        while (!queue.isEmpty()) {
-            File file = queue.poll();
-            String fromFilePath = file.getAbsolutePath();
-            String toFilePath = toDirectoryPath + fromFilePath.substring(fromDirectoryPath.length());
-            if (file.isDirectory()) {
-                boolean result = true;
-                if (fileCopyProcessor != null) {
-                    result = fileCopyProcessor.copyFileToFileProcess(fromFilePath, toFilePath, false);
-                }
-                if (result) {
-                    File[] fileArray = file.listFiles();
-                    if (fileArray != null) {
-                        queue.addAll(Arrays.asList(fileArray));
-                    }
-                }
-            } else if (file.isFile()) {
-                if (fileCopyProcessor != null) {
-                    fileCopyProcessor.copyFileToFileProcess(fromFilePath, toFilePath, true);
-                }
-            }
-        }
-    }
-
-    /**
-     * @param fromFile
-     * @param toPath
-     * @param fileCopyProcessor
-     */
-    private static void copyFileToPath(final String fromFile, final String toPath, final FileCopyProcessor fileCopyProcessor) {
-        File from = new File(fromFile);
-        File to = new File(toPath);
-        if (from.exists() && from.isFile()) {
-            createDirectory(toPath);
-            String tempFromFile = from.getAbsolutePath();
-            String tempToFile = to.getAbsolutePath() + File.separator + from.getName();
-            copyFileToFile(tempFromFile, tempToFile, fileCopyProcessor);
-        }
-    }
-
-    /**
-     * unzip
-     *
-     * @param zipFullFilename
-     * @param outputDirectory
-     * @return List<String>
-     */
-    public static List<String> unzip(String zipFullFilename, String outputDirectory) {
-        return unzip(zipFullFilename, outputDirectory, null);
-    }
-
-    /**
-     * unzip
-     *
-     * @param zipFullFilename
-     * @param outputDirectory
-     * @param zipEntryNameList,if it is null or empty,will unzip all
-     * @return List<String>
-     */
-    public static List<String> unzip(String zipFullFilename, String outputDirectory, List<String> zipEntryNameList) {
-        if (outputDirectory == null) {
-            throw new NullPointerException("out put directory can not be null.");
-        }
-        List<String> storeFileList = null;
-        ZipFile zipFile = null;
-        try {
-            storeFileList = new ArrayList<String>();
-            zipFile = new ZipFile(zipFullFilename);
-            String outputDirectoryAbsolutePath = new File(outputDirectory).getAbsolutePath();
-            Enumeration<? extends ZipEntry> enumeration = zipFile.entries();
-            while (enumeration.hasMoreElements()) {
-                ZipEntry zipEntry = enumeration.nextElement();
-                String zipEntryName = zipEntry.getName();
-                boolean contains = false;
-                if (zipEntryNameList == null || zipEntryNameList.isEmpty()) {
-                    contains = true;
-                } else {
-                    if (zipEntryNameList.contains(zipEntryName)) {
-                        contains = true;
-                    }
-                }
-                if (contains) {
-                    String outputFullFilename = outputDirectoryAbsolutePath + Constant.Symbol.SLASH_LEFT + zipEntryName;
-                    if (zipEntry.isDirectory()) {
-                        createDirectory(outputFullFilename);
-                    } else {
-                        InputStream inputStream = null;
-                        createFile(outputFullFilename);
-                        OutputStream outputStream = null;
-                        try {
-                            inputStream = zipFile.getInputStream(zipEntry);
-                            outputStream = new FileOutputStream(outputFullFilename);
-                            byte[] buffer = new byte[Constant.Capacity.BYTES_PER_KB];
-                            int length = -1;
-                            while ((length = inputStream.read(buffer, 0, buffer.length)) != -1) {
-                                outputStream.write(buffer, 0, length);
-                                outputStream.flush();
-                            }
-                        } finally {
-                            StreamUtil.closeQuietly(outputStream);
-                            StreamUtil.closeQuietly(inputStream);
-                        }
-                        storeFileList.add(outputFullFilename);
-                    }
-                }
-            }
-        } catch (Exception e) {
-            throw new FileUtilException(e);
-        } finally {
-            StreamUtil.closeQuietly(zipFile);
-        }
-        return storeFileList;
-    }
-
-    /**
-     * zip
-     *
-     * @param outputZipFullFilename
-     * @param directory
-     */
-    public static void zip(String outputZipFullFilename, String directory) {
-        zip(outputZipFullFilename, directory, StringUtil.BLANK);
-    }
-
-    /**
-     * zip
-     *
-     * @param outputZipFullFilename
-     * @param directory
-     * @param fileSuffix
-     */
-    public static void zip(String outputZipFullFilename, String directory, String fileSuffix) {
-        List<String> classFileList = FileUtil.findMatchFile(directory, fileSuffix);
-        if (classFileList != null && !classFileList.isEmpty()) {
-            List<ZipEntryPath> zipEntryPathList = new ArrayList<ZipEntryPath>();
-            int classOutputFullFilenameLength = new File(directory).getAbsolutePath().length() + 1;
-            for (String classFile : classFileList) {
-                String zipEntryName = classFile.substring(classOutputFullFilenameLength, classFile.length());
-                zipEntryName = zipEntryName.replace(Constant.Symbol.SLASH_RIGHT, Constant.Symbol.SLASH_LEFT);
-                zipEntryPathList.add(new ZipEntryPath(classFile, new ZipEntry(zipEntryName), true));
-            }
-            zip(outputZipFullFilename, zipEntryPathList);
-        }
-    }
-
-    /**
-     * zip
-     *
-     * @param outputZipFullFilename
-     * @param zipEntryPathList
-     */
-    public static void zip(String outputZipFullFilename, List<ZipEntryPath> zipEntryPathList) {
-        zip(outputZipFullFilename, null, zipEntryPathList);
-    }
-
-    /**
-     * zip
-     *
-     * @param outputZipFullFilename
-     * @param inputZipFullFilename,can null,the entry will not from the input file
-     * @param zipEntryPathList
-     */
-    public static void zip(String outputZipFullFilename, String inputZipFullFilename, List<ZipEntryPath> zipEntryPathList) {
-        zip(outputZipFullFilename, inputZipFullFilename, zipEntryPathList, null);
-    }
-
-    /**
-     * zip
-     *
-     * @param outputZipFullFilename
-     * @param inputZipFullFilename,can null,the entry will not from the input file
-     * @param zipProcessor
-     */
-    public static void zip(String outputZipFullFilename, String inputZipFullFilename, ZipProcessor zipProcessor) {
-        zip(outputZipFullFilename, inputZipFullFilename, null, zipProcessor);
-    }
-
-    /**
-     * zip
-     *
-     * @param outputZipFullFilename
-     * @param inputZipFullFilename,can null,the entry will not from the input file
-     * @param zipEntryPathList
-     * @param zipProcessor
-     */
-    public static void zip(String outputZipFullFilename, String inputZipFullFilename, List<ZipEntryPath> zipEntryPathList, ZipProcessor zipProcessor) {
-        ZipOutputStream zipOutputStream = null;
-        ZipFile zipFile = null;
-        Map<String, ZipEntryPath> zipEntryPathMap = new HashMap<String, ZipEntryPath>();
-        List<String> needToAddEntryNameList = new CopyOnWriteArrayList<String>();
-        if (zipEntryPathList != null) {
-            for (ZipEntryPath zipEntryPath : zipEntryPathList) {
-                zipEntryPathMap.put(zipEntryPath.zipEntry.getName(), zipEntryPath);
-                needToAddEntryNameList.add(zipEntryPath.zipEntry.getName());
-            }
-        }
-        try {
-            createFile(outputZipFullFilename);
-            zipOutputStream = new ZipOutputStream(new FileOutputStream(outputZipFullFilename));
-            if (inputZipFullFilename != null) {
-                zipFile = new ZipFile(inputZipFullFilename);
-                Enumeration<? extends ZipEntry> enumeration = zipFile.entries();
-                while (enumeration.hasMoreElements()) {
-                    ZipEntry zipEntry = enumeration.nextElement();
-                    String zipEntryName = zipEntry.getName();
-                    InputStream inputStream = null;
-                    if (zipEntryPathMap.containsKey(zipEntryName)) {
-                        ZipEntryPath zipEntryPath = zipEntryPathMap.get(zipEntryName);
-                        needToAddEntryNameList.remove(zipEntryName);
-                        if (zipEntryPath.replace) {
-                            zipEntry = zipEntryPath.zipEntry;
-                            inputStream = new FileInputStream(zipEntryPath.fullFilename);
-                        }
-                    }
-                    if (inputStream == null) {
-                        inputStream = zipFile.getInputStream(zipEntry);
-                        if (zipProcessor != null) {
-                            inputStream = zipProcessor.zipEntryProcess(zipEntryName, inputStream);
-                        }
-                    }
-                    ZipEntry newZipEntry = new ZipEntry(zipEntryName);
-                    addZipEntry(zipOutputStream, newZipEntry, inputStream);
-                }
-            }
-            for (String zipEntryName : needToAddEntryNameList) {
-                ZipEntryPath zipEntryPath = zipEntryPathMap.get(zipEntryName);
-                ZipEntry zipEntry = zipEntryPath.zipEntry;
-                InputStream inputStream = new FileInputStream(zipEntryPath.fullFilename);
-                if (zipProcessor != null) {
-                    inputStream = zipProcessor.zipEntryProcess(zipEntry.getName(), inputStream);
-                }
-                addZipEntry(zipOutputStream, zipEntry, inputStream);
-            }
-        } catch (Exception e) {
-            throw new FileUtilException(e);
-        } finally {
-            StreamUtil.closeQuietly(zipOutputStream);
-            StreamUtil.closeQuietly(zipFile);
-        }
-    }
-
-    /**
-     * merge zip file
-     *
-     * @param zipOutputFullFilename
-     * @param mergeZipFullFilenameList
-     */
-    public static void mergeZip(String zipOutputFullFilename, List<String> mergeZipFullFilenameList) {
-        FileUtil.createFile(zipOutputFullFilename);
-        ZipOutputStream zipOutputStream = null;
-        try {
-            zipOutputStream = new ZipOutputStream(new FileOutputStream(zipOutputFullFilename));
-            if (mergeZipFullFilenameList != null) {
-                for (String zipFullFilename : mergeZipFullFilenameList) {
-                    if (isExist(zipFullFilename)) {
-                        ZipFile zipFile = new ZipFile(zipFullFilename);
-                        Enumeration<? extends ZipEntry> enumeration = zipFile.entries();
-                        while (enumeration.hasMoreElements()) {
-                            ZipEntry zipEntry = enumeration.nextElement();
-                            InputStream inputStream = zipFile.getInputStream(zipEntry);
-                            addZipEntry(zipOutputStream, zipEntry, inputStream);
-                        }
-                        zipFile.close();
-                    }
-                }
-            }
-        } catch (Exception e) {
-            throw new FileUtilException(e);
-        } finally {
-            StreamUtil.closeQuietly(zipOutputStream);
-        }
-    }
-
-    /**
-     * add zip entry
-     *
-     * @param zipOutputStream
-     * @param zipEntry
-     * @param inputStream
-     * @throws Exception
-     */
-    public static void addZipEntry(ZipOutputStream zipOutputStream, ZipEntry zipEntry, InputStream inputStream) throws Exception {
-        try {
-            zipOutputStream.putNextEntry(zipEntry);
-            byte[] buffer = new byte[Constant.Capacity.BYTES_PER_KB];
-            int length = -1;
-            while ((length = inputStream.read(buffer, 0, buffer.length)) != -1) {
-                zipOutputStream.write(buffer, 0, length);
-                zipOutputStream.flush();
-            }
-        } catch (ZipException e) {
-            // do nothing
-        } finally {
-            StreamUtil.closeQuietly(inputStream);
-            zipOutputStream.closeEntry();
-        }
-    }
-
-    /**
-     * read file
-     *
-     * @param fullFilename
-     * @return byte[]
-     */
-    public static byte[] readFile(String fullFilename) {
-        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
-        InputStream inputStream = null;
-        try {
-            inputStream = new FileInputStream(fullFilename);
-            copyStream(inputStream, byteArrayOutputStream);
-        } catch (FileNotFoundException e) {
-            throw new FileUtilException(e);
-        } finally {
-            StreamUtil.closeQuietly(byteArrayOutputStream);
-            StreamUtil.closeQuietly(inputStream);
-        }
-        return byteArrayOutputStream.toByteArray();
-    }
-
-    /**
-     * write file
-     *
-     * @param outputFullFilename
-     * @param byteArray
-     */
-    public static void writeFile(String outputFullFilename, byte[] byteArray) {
-        InputStream inputStream = null;
-        FileUtil.createFile(outputFullFilename);
-        OutputStream outputStream = null;
-        try {
-            inputStream = new ByteArrayInputStream(byteArray);
-            outputStream = new FileOutputStream(outputFullFilename);
-            copyStream(inputStream, outputStream);
-        } catch (FileNotFoundException e) {
-            throw new FileUtilException(e);
-        } finally {
-            StreamUtil.closeQuietly(outputStream);
-            StreamUtil.closeQuietly(inputStream);
-        }
-    }
-
-    /**
-     * copy stream , from input to output,it don't close
-     *
-     * @param inputStream
-     * @param outputStream
-     */
-    public static void copyStream(InputStream inputStream, OutputStream outputStream) {
-        if (inputStream != null && outputStream != null) {
-            try {
-                int length = -1;
-                byte[] buffer = new byte[Constant.Capacity.BYTES_PER_MB];
-                while ((length = inputStream.read(buffer, 0, buffer.length)) != -1) {
-                    outputStream.write(buffer, 0, length);
-                    outputStream.flush();
-                }
-            } catch (Exception e) {
-                throw new FileUtilException(e);
-            }
-        }
-    }
-
-    /**
-     * merge file
-     *
-     * @param outputFullFilename
-     * @param fullFilenameList
-     */
-    public static void mergeFile(String outputFullFilename, List<String> fullFilenameList) {
-        if (fullFilenameList != null && outputFullFilename != null) {
-            OutputStream outputStream = null;
-            try {
-                outputStream = new FileOutputStream(outputFullFilename);
-                for (String fullFilename : fullFilenameList) {
-                    InputStream inputStream = null;
-                    try {
-                        inputStream = new FileInputStream(fullFilename);
-                        copyStream(inputStream, outputStream);
-                    } catch (Exception e) {
-                        throw new FileUtilException(e);
-                    } finally {
-                        StreamUtil.closeQuietly(inputStream);
-                    }
-                }
-            } catch (Exception e) {
-                throw new FileUtilException(e);
-            } finally {
-                StreamUtil.closeQuietly(outputStream);
-            }
-        }
-    }
-
-    /**
-     * find match file directory
-     *
-     * @param sourceDirectory
-     * @param fileSuffix
-     * @return List<String>
-     */
-    public static List<String> findMatchFileDirectory(String sourceDirectory, String fileSuffix) {
-        return findMatchFileOrMatchFileDirectory(sourceDirectory, fileSuffix, null, false, true);
-    }
-
-    /**
-     * find match file directory
-     *
-     * @param sourceDirectory
-     * @param fileSuffix
-     * @param includeHidden
-     * @return List<String>
-     */
-    public static List<String> findMatchFileDirectory(String sourceDirectory, String fileSuffix, boolean includeHidden) {
-        return findMatchFileOrMatchFileDirectory(sourceDirectory, fileSuffix, null, false, includeHidden);
-    }
-
-    /**
-     * find match file directory and append some string to rear
-     *
-     * @param sourceDirectory
-     * @param fileSuffix
-     * @param somethingAppendToRear
-     * @return List<String>
-     */
-    public static List<String> findMatchFileDirectory(String sourceDirectory, String fileSuffix, String somethingAppendToRear) {
-        return findMatchFileOrMatchFileDirectory(sourceDirectory, fileSuffix, somethingAppendToRear, false, true);
-    }
-
-    /**
-     * find match file directory and append some string to rear
-     *
-     * @param sourceDirectory
-     * @param fileSuffix
-     * @param somethingAppendToRear
-     * @param includeHidden
-     * @return List<String>
-     */
-    public static List<String> findMatchFileDirectory(String sourceDirectory, String fileSuffix, String somethingAppendToRear, boolean includeHidden) {
-        return findMatchFileOrMatchFileDirectory(sourceDirectory, fileSuffix, somethingAppendToRear, false, includeHidden);
-    }
-
     /**
      * find match file
      *
@@ -663,43 +84,6 @@ public static void mergeFile(String outputFullFilename, List<String> fullFilenam
         return findMatchFileOrMatchFileDirectory(sourceDirectory, fileSuffix, null, true, true);
     }
 
-    /**
-     * find match file
-     *
-     * @param sourceDirectory
-     * @param fileSuffix
-     * @param includeHidden
-     * @return List<String>
-     */
-    public static List<String> findMatchFile(String sourceDirectory, String fileSuffix, boolean includeHidden) {
-        return findMatchFileOrMatchFileDirectory(sourceDirectory, fileSuffix, null, true, includeHidden);
-    }
-
-    /**
-     * find match file and append some string to rear
-     *
-     * @param sourceDirectory
-     * @param fileSuffix
-     * @param somethingAppendToRear
-     * @return List<String>
-     */
-    public static List<String> findMatchFile(String sourceDirectory, String fileSuffix, String somethingAppendToRear) {
-        return findMatchFileOrMatchFileDirectory(sourceDirectory, fileSuffix, somethingAppendToRear, true, false);
-    }
-
-    /**
-     * find match file and append some string to rear
-     *
-     * @param sourceDirectory
-     * @param fileSuffix
-     * @param somethingAppendToRear
-     * @param includeHidden
-     * @return List<String>
-     */
-    public static List<String> findMatchFile(String sourceDirectory, String fileSuffix, String somethingAppendToRear, boolean includeHidden) {
-        return findMatchFileOrMatchFileDirectory(sourceDirectory, fileSuffix, somethingAppendToRear, true, includeHidden);
-    }
-
     /**
      * find match file or match file directory
      *
@@ -747,432 +131,6 @@ public static void mergeFile(String outputFullFilename, List<String> fullFilenam
         return list;
     }
 
-    /**
-     * get zip entry hash map
-     *
-     * @param zipFile
-     * @return Map<String, String>
-     */
-    private static Map<String, String> getZipEntryHashMap(String zipFullFilename) {
-        ZipFile zipFile = null;
-        Map<String, String> map = new HashMap<String, String>();
-        try {
-            zipFile = new ZipFile(zipFullFilename);
-            Enumeration<? extends ZipEntry> entries = zipFile.entries();
-            while (entries.hasMoreElements()) {
-                ZipEntry zipEntry = (ZipEntry) entries.nextElement();
-                if (!zipEntry.isDirectory()) {
-                    String key = zipEntry.getName();
-                    String value = zipEntry.getCrc() + Constant.Symbol.DOT + zipEntry.getSize();
-                    map.put(key, value);
-                }
-            }
-        } catch (Exception e) {
-            throw new FileUtilException(e);
-        } finally {
-            if (zipFile != null) {
-                try {
-                    zipFile.close();
-                } catch (IOException e) {
-                    throw new FileUtilException(e);
-                }
-            }
-        }
-        return map;
-    }
-
-    /**
-     * differ zip
-     *
-     * @param differentOutputFullFilename
-     * @param oldZipFullFilename
-     * @param newZipFullFilename
-     */
-    public static void differZip(String differentOutputFullFilename, String oldZipFullFilename, String newZipFullFilename) {
-        Map<String, String> map = getZipEntryHashMap(oldZipFullFilename);
-        ZipFile newZipFile = null;
-        ZipOutputStream zipOutputStream = null;
-        try {
-            newZipFile = new ZipFile(newZipFullFilename);
-            Enumeration<? extends ZipEntry> entries = newZipFile.entries();
-            FileUtil.createFile(differentOutputFullFilename);
-            zipOutputStream = new ZipOutputStream(new FileOutputStream(differentOutputFullFilename));
-            while (entries.hasMoreElements()) {
-                ZipEntry zipEntry = entries.nextElement();
-                if (!zipEntry.isDirectory()) {
-                    String zipEntryName = zipEntry.getName();
-                    String oldZipEntryHash = map.get(zipEntryName);
-                    String newZipEntryHash = zipEntry.getCrc() + Constant.Symbol.DOT + zipEntry.getSize();
-                    // old zip entry hash not exist is a new zip entry,if exist
-                    // is a modified zip entry
-                    if (oldZipEntryHash == null || (!newZipEntryHash.equals(oldZipEntryHash))) {
-                        System.out.println(String.format("found modified entry, key=%s(%s/%s)", new Object[]{zipEntryName, oldZipEntryHash, newZipEntryHash}));
-                        addZipEntry(zipOutputStream, zipEntry, newZipFile.getInputStream(zipEntry));
-                    }
-                }
-            }
-        } catch (Exception e) {
-            throw new FileUtilException(e);
-        } finally {
-            StreamUtil.closeQuietly(zipOutputStream);
-            StreamUtil.closeQuietly(newZipFile);
-        }
-    }
-
-    /**
-     * generate simple file
-     *
-     * @param templateFullFilename
-     * @param outputFullFilename
-     * @param valueMap
-     */
-    public static void generateSimpleFile(String templateFullFilename, String outputFullFilename, Map<String, String> valueMap) {
-        InputStream inputStream = null;
-        try {
-            inputStream = new FileInputStream(templateFullFilename);
-            generateSimpleFile(inputStream, outputFullFilename, valueMap);
-        } catch (Exception e) {
-            throw new FileUtilException(e);
-        } finally {
-            StreamUtil.closeQuietly(inputStream);
-        }
-    }
-
-    /**
-     * generate simple file
-     *
-     * @param templateInputStream
-     * @param outputFullFilename
-     * @param valueMap
-     */
-    public static void generateSimpleFile(InputStream templateInputStream, String outputFullFilename, Map<String, String> valueMap) {
-        BufferedReader bufferedReader = null;
-        OutputStream outputStream = null;
-        try {
-            bufferedReader = new BufferedReader(new InputStreamReader(templateInputStream, Constant.Encoding.UTF8));
-            StringBuilder content = new StringBuilder();
-            String line = null;
-            Set<Entry<String, String>> entrySet = valueMap.entrySet();
-            while ((line = bufferedReader.readLine()) != null) {
-                for (Entry<String, String> entry : entrySet) {
-                    String key = entry.getKey();
-                    String value = entry.getValue();
-                    line = line.replace(key, value);
-                }
-                content.append(line);
-                content.append(StringUtil.CRLF_STRING);
-            }
-            createFile(outputFullFilename);
-            outputStream = new FileOutputStream(outputFullFilename);
-            outputStream.write(content.toString().getBytes(Constant.Encoding.UTF8));
-            outputStream.flush();
-        } catch (Exception e) {
-            throw new FileUtilException(e);
-        } finally {
-            StreamUtil.closeQuietly(outputStream);
-            StreamUtil.closeQuietly(bufferedReader);
-        }
-    }
-
-    /**
-     * find file list with cache
-     *
-     * @param sourceDirectoryList
-     * @param cacheProperties
-     * @param fileSuffix            suffix it will search file in source directory list
-     * @param somethingAppendToRear
-     * @param isFile                if true the return list is source file else is the source directory
-     * @return List<String>
-     */
-    public static List<String> findFileListWithCache(List<String> sourceDirectoryList, Properties cacheProperties, String fileSuffix, String somethingAppendToRear, boolean isFile) {
-        return findFileListWithCache(sourceDirectoryList, cacheProperties, fileSuffix, somethingAppendToRear, isFile, null);
-    }
-
-    /**
-     * find file list with cache
-     *
-     * @param sourceDirectoryList
-     * @param cacheProperties
-     * @param fileSuffix
-     * @param somethingAppendToRear
-     * @param isFile
-     * @param cacheProcessor
-     * @return List<String>
-     */
-    public static List<String> findFileListWithCache(List<String> sourceDirectoryList, Properties cacheProperties, String fileSuffix, String somethingAppendToRear, boolean isFile, CacheProcessor cacheProcessor) {
-        return findFileListWithCache(sourceDirectoryList, cacheProperties, fileSuffix, somethingAppendToRear, isFile, false, cacheProcessor);
-    }
-
-    /**
-     * find file list with cache
-     *
-     * @param sourceDirectoryList
-     * @param cacheProperties
-     * @param fileSuffix            suffix it will search file in source directory list
-     * @param somethingAppendToRear
-     * @param isFile                if true the return list is source file else is the source directory
-     * @param includeHidden
-     * @return List<String>
-     */
-    public static List<String> findFileListWithCache(List<String> sourceDirectoryList, Properties cacheProperties, String fileSuffix, String somethingAppendToRear, boolean isFile, boolean includeHidden, CacheProcessor cacheProcessor) {
-        List<String> sourceList = new ArrayList<String>();
-        //no cache
-        if (cacheProperties == null) {
-            if (sourceDirectoryList != null && !sourceDirectoryList.isEmpty()) {
-                for (String sourceDirectory : sourceDirectoryList) {
-                    if (isFile) {
-                        sourceList.addAll(FileUtil.findMatchFile(sourceDirectory, fileSuffix, includeHidden));
-                    } else {
-                        sourceList.addAll(FileUtil.findMatchFileDirectory(sourceDirectory, fileSuffix, somethingAppendToRear, includeHidden));
-                    }
-                }
-            }
-        } else if (cacheProperties.isEmpty()) {
-            List<String> fileList = new ArrayList<String>();
-            if (sourceDirectoryList != null && !sourceDirectoryList.isEmpty()) {
-                for (String sourceDirectory : sourceDirectoryList) {
-                    fileList.addAll(FileUtil.findMatchFile(sourceDirectory, fileSuffix, includeHidden));
-                }
-            }
-            for (String fullFilename : fileList) {
-                String cacheKey = fullFilename;
-                if (cacheProcessor != null) {
-                    cacheKey = cacheProcessor.keyProcess(cacheKey);
-                }
-                cacheProperties.setProperty(cacheKey, Generator.md5File(fullFilename));
-            }
-            if (isFile) {
-                sourceList.addAll(fileList);
-            } else {
-                if (sourceDirectoryList != null && !sourceDirectoryList.isEmpty()) {
-                    for (String sourceDirectory : sourceDirectoryList) {
-                        sourceList.addAll(FileUtil.findMatchFileDirectory(sourceDirectory, fileSuffix, somethingAppendToRear, includeHidden));
-                    }
-                }
-            }
-        } else {
-            List<String> fileList = new ArrayList<String>();
-            if (sourceDirectoryList != null && !sourceDirectoryList.isEmpty()) {
-                for (String sourceDirectory : sourceDirectoryList) {
-                    fileList.addAll(FileUtil.findMatchFile(sourceDirectory, fileSuffix, includeHidden));
-                }
-            }
-            for (String fullFilename : fileList) {
-                String cacheKey = fullFilename;
-                if (cacheProcessor != null) {
-                    cacheKey = cacheProcessor.keyProcess(cacheKey);
-                }
-                String sourceFileMd5 = Generator.md5File(fullFilename);
-                if (cacheProperties.containsKey(cacheKey)) {
-                    String md5 = cacheProperties.getProperty(cacheKey);
-                    if (!sourceFileMd5.equals(md5)) {
-                        sourceList.add(fullFilename);
-                        cacheProperties.setProperty(cacheKey, sourceFileMd5);
-                    }
-                } else {
-                    sourceList.add(fullFilename);
-                    cacheProperties.setProperty(cacheKey, sourceFileMd5);
-                }
-            }
-        }
-        return sourceList;
-    }
-
-    /**
-     * deal with file cache
-     *
-     * @param propertiesFileMappingFullFilename
-     * @param noCacheFileFinder
-     * @param noCacheFileProcessor
-     * @return List<String>
-     */
-    public static List<String> dealWithFileCache(String propertiesFileMappingFullFilename, NoCacheFileFinder noCacheFileFinder, NoCacheFileProcessor noCacheFileProcessor) {
-        Properties propertiesFileMapping = getPropertiesAutoCreate(propertiesFileMappingFullFilename);
-        List<String> noCacheFileList = null;
-        if (noCacheFileFinder == null) {
-            throw new NullPointerException("noCacheFileFinder can not be null.");
-        }
-        noCacheFileList = noCacheFileFinder.findNoCacheFileList(propertiesFileMapping);
-        boolean saveCache = false;
-        if (noCacheFileProcessor != null) {
-            saveCache = noCacheFileProcessor.process(noCacheFileList);
-        }
-        if (saveCache) {
-            saveProperties(propertiesFileMapping, propertiesFileMappingFullFilename);
-        }
-        return noCacheFileList;
-    }
-
-    /**
-     * get properties will auto create
-     *
-     * @param propertiesFullFilename
-     * @return Properties
-     */
-    public static Properties getPropertiesAutoCreate(String propertiesFullFilename) {
-        if (!FileUtil.isExist(propertiesFullFilename)) {
-            FileUtil.createFile(propertiesFullFilename);
-        }
-        return getProperties(propertiesFullFilename);
-    }
-
-    /**
-     * get properties
-     *
-     * @param propertiesFullFilename
-     * @return Properties
-     */
-    public static Properties getProperties(String propertiesFullFilename) {
-        Properties properties = null;
-        if (propertiesFullFilename != null) {
-            InputStream inputStream = null;
-            try {
-                inputStream = new FileInputStream(propertiesFullFilename);
-                properties = new Properties();
-                properties.load(inputStream);
-            } catch (Exception e) {
-                throw new FileUtilException(e);
-            } finally {
-                StreamUtil.closeQuietly(inputStream);
-            }
-        }
-        return properties;
-    }
-
-    /**
-     * get properties from properties file,will auto create
-     *
-     * @param file
-     * @return Properties
-     * @throws IOException
-     */
-    public static Properties getProperties(File file) {
-        Properties properties = null;
-        if (file != null) {
-            properties = getProperties(file.getAbsolutePath());
-        }
-        return properties;
-    }
-
-    /**
-     * save properties
-     *
-     * @param properties
-     * @param outputFullFilename
-     */
-    public static void saveProperties(Properties properties, String outputFullFilename) {
-        if (properties != null && outputFullFilename != null) {
-            OutputStream outputStream = null;
-            try {
-                outputStream = new FileOutputStream(outputFullFilename);
-                properties.store(outputStream, null);
-            } catch (Exception e) {
-                throw new FileUtilException(e);
-            } finally {
-                StreamUtil.closeQuietly(outputStream);
-            }
-        }
-    }
-
-    /**
-     * @param fromFile
-     * @param toFile
-     * @param fileCopyProcessor
-     */
-    private static void copyFileToFile(final String fromFile, final String toFile, FileCopyProcessor fileCopyProcessor) {
-        if (fileCopyProcessor != null) {
-            createFile(toFile);
-            fileCopyProcessor.copyFileToFileProcess(fromFile, toFile, true);
-        }
-    }
-
-    /**
-     * @param args
-     */
-    public static void main(String[] args) {
-        String outputZipFullFilename = "/D:/a/b.zip";
-        mergeZip(outputZipFullFilename, Arrays.asList("/D:/a.zip", "/D:/b.zip"));
-    }
-
-    public enum FileCopyType {
-        PATH_TO_PATH, FILE_TO_PATH, FILE_TO_FILE
-    }
-
-    public interface FileCopyProcessor {
-
-        /**
-         * copyFileToFileProcess
-         *
-         * @param from,maybe   directory
-         * @param to,maybe     directory
-         * @param isFile,maybe directory or file
-         * @return boolean, if true keep going copy,only active in directory so
-         * far
-         */
-        boolean copyFileToFileProcess(final String from, final String to, final boolean isFile);
-
-    }
-
-    public interface ZipProcessor {
-
-        /**
-         * zip entry process
-         *
-         * @param zipEntryName
-         * @param inputStream
-         * @return InputStream
-         */
-        InputStream zipEntryProcess(final String zipEntryName, InputStream inputStream);
-    }
-
-    public interface CacheProcessor {
-        /**
-         * key process,can change key to save cache
-         *
-         * @param cacheKey
-         * @return String
-         */
-        String keyProcess(final String key);
-    }
-
-    public interface NoCacheFileProcessor {
-        /**
-         * process
-         *
-         * @param uncachedFileList
-         * @return boolean, true is save cache else false
-         */
-        boolean process(List<String> uncachedFileList);
-    }
-
-
-    public interface NoCacheFileFinder {
-
-        /**
-         * find no cache file list
-         *
-         * @param cacheFileMapping
-         * @return List<String>
-         */
-        List<String> findNoCacheFileList(Properties cacheFileMapping);
-    }
-
-    public static class ZipEntryPath {
-        private String   fullFilename = null;
-        private ZipEntry zipEntry     = null;
-        private boolean  replace      = false;
-
-        public ZipEntryPath(String fullFilename, ZipEntry zipEntry) {
-            this(fullFilename, zipEntry, false);
-        }
-
-        public ZipEntryPath(String fullFilename, ZipEntry zipEntry, boolean replace) {
-            this.fullFilename = fullFilename;
-            this.zipEntry = zipEntry;
-            this.replace = replace;
-        }
-    }
-
     public static class FileUtilException extends RuntimeException {
         private static final long serialVersionUID = 3884649425767533205L;
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/RDotTxtEntry.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/RDotTxtEntry.java
index ee5faefa..99cd9cee 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/RDotTxtEntry.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/RDotTxtEntry.java
@@ -116,7 +116,7 @@ public String toString() {
     // Taken from http://developer.android.com/reference/android/R.html
     // TRANSITION for api level 19
     public enum RType {
-        ANIM, ANIMATOR, ARRAY, ATTR, BOOL, COLOR, DIMEN, DRAWABLE, FONT, FRACTION, ID, INTEGER, INTERPOLATOR, LAYOUT, MENU, MIPMAP, PLURALS, RAW, STRING, STYLE, STYLEABLE, TRANSITION, XML;
+        ANIM, ANIMATOR, ARRAY, ATTR, BOOL, COLOR, DIMEN, DRAWABLE, FONT, FRACTION, ID, INTEGER, INTERPOLATOR, LAYOUT, MENU, MIPMAP, PLURALS, RAW, STRING, STYLE, STYLEABLE, TRANSITION, XML, NAVIGATION;
 
         @Override
         public String toString() {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
index 712876d6..013a14f5 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
@@ -66,7 +66,7 @@
  */
 public class DexDiffDecoder extends BaseDecoder {
     private static final String TEST_DEX_NAME = "test.dex";
-    private static final String CHANGED_CLASSES_DEX_NAME = "changed_classes.dex";
+    private static final String CHANGED_CLASSES_DEX_NAME_PREFIX = "changed_classes";
 
     private final InfoWriter logWriter;
     private final InfoWriter metaWriter;
@@ -204,9 +204,6 @@ public void onAllPatchesEnd() throws Exception {
     @SuppressWarnings("NewApi")
     private void generateChangedClassesDexFile() throws IOException {
         final String dexMode = config.mDexRaw ? "raw" : "jar";
-        final File dest = new File(config.mTempResultDir + "/" + CHANGED_CLASSES_DEX_NAME);
-
-        Logger.d("\nBuilding changed classes dex: %s, size: %d\n", dest.getAbsolutePath(), dest.length());
 
         List<File> oldDexList = new ArrayList<>();
         List<File> newDexList = new ArrayList<>();
@@ -243,10 +240,22 @@ private void generateChangedClassesDexFile() throws IOException {
             descOfChangedClasses.add(classInfo.classDesc);
         }
 
-        DexBuilder dexBuilder = DexBuilder.makeDexBuilder();
+        StringBuilder metaBuilder = new StringBuilder();
+        int changedDexId = 1;
         for (Dex dex : owners) {
             Set<String> descOfChangedClassesInCurrDex = ownerToDescOfChangedClassesMap.get(dex);
             DexFile dexFile = new DexBackedDexFile(org.jf.dexlib2.Opcodes.forApi(20), dex.getBytes());
+            boolean isCurrentDexHasChangedClass = false;
+            for (org.jf.dexlib2.iface.ClassDef classDef : dexFile.getClasses()) {
+                if (descOfChangedClassesInCurrDex.contains(classDef.getType())) {
+                    isCurrentDexHasChangedClass = true;
+                    break;
+                }
+            }
+            if (!isCurrentDexHasChangedClass) {
+                continue;
+            }
+            DexBuilder dexBuilder = DexBuilder.makeDexBuilder();
             for (org.jf.dexlib2.iface.ClassDef classDef : dexFile.getClasses()) {
                 if (!descOfChangedClassesInCurrDex.contains(classDef.getType())) {
                     continue;
@@ -295,22 +304,38 @@ private void generateChangedClassesDexFile() throws IOException {
                         builderMethods
                 );
             }
-        }
-
-        // Write constructed changed classes dex to file and record it in meta file.
-        FileDataStore fileDataStore = new FileDataStore(dest);
-        dexBuilder.writeTo(fileDataStore);
-
-        final String md5 = MD5.getMD5(dest);
-
-        String meta = CHANGED_CLASSES_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0
-                + "," + 0 + "," + 0 + "," + dexMode;
 
-        Logger.d("\nDexDecoder:write changed classes dex meta file data: %s", meta);
+            // Write constructed changed classes dex to file and record it in meta file.
+            final String changedDexName = CHANGED_CLASSES_DEX_NAME_PREFIX + changedDexId + ".dex";
+            final File dest = new File(config.mTempResultDir + "/" + changedDexName);
+            final FileDataStore fileDataStore = new FileDataStore(dest);
+            dexBuilder.writeTo(fileDataStore);
+            final String md5 = MD5.getMD5(dest);
+            appendMetaLine(metaBuilder, changedDexName, "", md5, md5, 0, 0, 0, dexMode);
+            ++changedDexId;
+        }
 
+        final String meta = metaBuilder.toString();
+        Logger.d("\nDexDecoder:write changed classes dex meta file data:\n%s", meta);
         metaWriter.writeLineToInfoFile(meta);
     }
 
+    private void appendMetaLine(StringBuilder sb, Object... vals) {
+        if (vals == null || vals.length == 0) {
+            return;
+        }
+        boolean isFirstItem = true;
+        for (Object val : vals) {
+            if (isFirstItem) {
+                isFirstItem = false;
+            } else {
+                sb.append(',');
+            }
+            sb.append(val);
+        }
+        sb.append('\n');
+    }
+
     @SuppressWarnings("NewApi")
     private void generatePatchInfoFile() throws IOException {
         generatePatchedDexInfoFile();
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java
index 5df99138..30f4b083 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java
@@ -39,18 +39,6 @@
 import java.util.zip.ZipOutputStream;
 
 public class FileOperation {
-    public static final boolean fileExists(String filePath) {
-        if (filePath == null) {
-            return false;
-        }
-
-        File file = new File(filePath);
-        if (file.exists()) {
-            return true;
-        }
-        return false;
-    }
-
     public static final boolean deleteFile(String filePath) {
         if (filePath == null) {
             return true;
@@ -187,6 +175,9 @@ public static void unZipAPk(String fileName, String filePath) throws IOException
         try {
             while (enumeration.hasMoreElements()) {
                 ZipEntry entry = (ZipEntry) enumeration.nextElement();
+                if (!validateZipEntryName(new File(filePath), entry.getName())) {
+                    throw new IOException("Bad ZipEntry name: " + entry.getName());
+                }
                 if (entry.isDirectory()) {
                     new File(filePath, entry.getName()).mkdirs();
                     continue;
@@ -404,4 +395,17 @@ public static boolean sevenZipInputDir(File inputDir, File outputFile, Configura
         }
         return true;
     }
+
+    private static boolean validateZipEntryName(File destDir, String entryName) {
+        if (entryName == null || entryName.isEmpty()) {
+            return false;
+        }
+        try {
+            final String canonicalDestinationDir = destDir.getCanonicalPath();
+            final File destEntryFile = destDir.toPath().resolve(entryName).toFile();
+            return destEntryFile.getCanonicalPath().startsWith(canonicalDestinationDir + File.separator);
+        } catch (Throwable ignored) {
+            return false;
+        }
+    }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
index e0bad90a..924e60cc 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
@@ -19,10 +19,10 @@
 import com.tencent.tinker.build.decoder.ResDiffDecoder;
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.commons.util.StreamUtil;
-import com.tencent.tinker.ziputils.ziputil.TinkerZipUtil;
 import com.tencent.tinker.ziputils.ziputil.TinkerZipEntry;
 import com.tencent.tinker.ziputils.ziputil.TinkerZipFile;
 import com.tencent.tinker.ziputils.ziputil.TinkerZipOutputStream;
+import com.tencent.tinker.ziputils.ziputil.TinkerZipUtil;
 
 import java.io.BufferedOutputStream;
 import java.io.BufferedReader;
@@ -141,8 +141,8 @@ public static String genResOutputFile(File output, File newZipFile, Configuratio
                     );
                 }
                 String name = zipEntry.getName();
-                if (name.contains("../")) {
-                    continue;
+                if (!TinkerZipUtil.validateZipEntryName(output.getParentFile(), name)) {
+                    throw new IOException("Bad ZipEntry name: " + name);
                 }
                 if (Utils.checkFileInPattern(config.mResFilePattern, name)) {
                     //won't contain in add set.
diff --git a/tinker-commons/build.gradle b/tinker-commons/build.gradle
index 9b52ca65..a886028c 100644
--- a/tinker-commons/build.gradle
+++ b/tinker-commons/build.gradle
@@ -1,4 +1,4 @@
-apply plugin: 'java'
+apply plugin: 'java-library'
 
 version rootProject.ext.VERSION_NAME
 group rootProject.ext.GROUP
@@ -7,10 +7,10 @@ group rootProject.ext.GROUP
 
 
 dependencies {
-    compile fileTree(dir: 'libs', include: ['*.jar'])
-    compile project(':third-party:aosp-dexutils')
-    compile project(':third-party:bsdiff-util')
-    compile project(':third-party:tinker-ziputils')
+    implementation fileTree(dir: 'libs', include: ['*.jar'])
+    api project(':third-party:aosp-dexutils')
+    api project(':third-party:bsdiff-util')
+    api project(':third-party:tinker-ziputils')
 }
 
 task buildTinkerSdk(type: Copy, dependsOn: [build]) {
diff --git a/tinker-sample-android/app/build.gradle b/tinker-sample-android/app/build.gradle
index 9b662d29..ceac928a 100644
--- a/tinker-sample-android/app/build.gradle
+++ b/tinker-sample-android/app/build.gradle
@@ -5,7 +5,11 @@ dependencies {
         implementation fileTree(dir: 'libs', include: ['*.jar'])
         testImplementation 'junit:junit:4.12'
         implementation "com.android.support:appcompat-v7:23.1.1"
-        implementation("com.tencent.tinker:tinker-android-lib:${TINKER_VERSION}") { changing = true }
+        api("com.tencent.tinker:tinker-android-lib:${TINKER_VERSION}") { changing = true }
+
+        // Maven local cannot handle transist dependencies.
+        implementation("com.tencent.tinker:tinker-android-loader:${TINKER_VERSION}") { changing = true }
+
         annotationProcessor("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
         compileOnly("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
 
@@ -75,7 +79,7 @@ android {
     defaultConfig {
         applicationId "tinker.sample.android"
         minSdkVersion 14
-        targetSdkVersion 22
+        targetSdkVersion 26
         versionCode 1
         versionName "1.0.0"
         /**
@@ -97,6 +101,7 @@ android {
     }
 
 //    aaptOptions{
+//        additionalParameters "--emit-ids", "${project.file('public.txt')}"
 //        cruncherEnabled false
 //    }
 
@@ -471,3 +476,21 @@ if (buildWithTinker()) {
         }
     }
 }
+
+
+
+task sortPublicTxt() {
+    doLast {
+        File originalFile = project.file("public.txt")
+        File sortedFile = project.file("public_sort.txt")
+        List<String> sortedLines = new ArrayList<>()
+        originalFile.eachLine {
+            sortedLines.add(it)
+        }
+        Collections.sort(sortedLines)
+        sortedFile.delete()
+        sortedLines.each {
+            sortedFile.append("${it}\n")
+        }
+    }
+}
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
index 5aef75a3..ba9d01bd 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
@@ -24,15 +24,12 @@
 import android.support.multidex.MultiDex;
 
 import com.tencent.tinker.anno.DefaultLifeCycle;
+import com.tencent.tinker.entry.ApplicationLifeCycle;
+import com.tencent.tinker.entry.DefaultApplicationLike;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
-import com.tencent.tinker.lib.util.TinkerLog;
-import com.tencent.tinker.loader.app.ApplicationLifeCycle;
-import com.tencent.tinker.loader.app.DefaultApplicationLike;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 
-import java.util.regex.Pattern;
-
 import tinker.sample.android.Log.MyLogImp;
 import tinker.sample.android.util.SampleApplicationContext;
 import tinker.sample.android.util.TinkerManager;
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
index 90dcd767..6656c088 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
@@ -22,7 +22,7 @@
 
 import com.tencent.tinker.lib.tinker.TinkerApplicationHelper;
 import com.tencent.tinker.lib.util.TinkerLog;
-import com.tencent.tinker.loader.app.ApplicationLike;
+import com.tencent.tinker.entry.ApplicationLike;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
index e3af535f..42364476 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
@@ -24,7 +24,7 @@
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.lib.util.UpgradePatchRetry;
-import com.tencent.tinker.loader.app.ApplicationLike;
+import com.tencent.tinker.entry.ApplicationLike;
 
 import tinker.sample.android.crash.SampleUncaughtExceptionHandler;
 import tinker.sample.android.reporter.SampleLoadReporter;
diff --git a/tinker-sample-android/build.gradle b/tinker-sample-android/build.gradle
index ed57cac0..c424ee6a 100644
--- a/tinker-sample-android/build.gradle
+++ b/tinker-sample-android/build.gradle
@@ -2,24 +2,37 @@
 buildscript {
     repositories {
         mavenLocal()
-        google()
         jcenter()
+        maven {
+            url 'https://maven.google.com/'
+            name 'Google'
+        }
     }
     dependencies {
         if (project.hasProperty('GRADLE_3') && GRADLE_3.equalsIgnoreCase('TRUE')) {
-            classpath 'com.android.tools.build:gradle:3.2.0-alpha02'
+            classpath 'com.android.tools.build:gradle:3.2.1'
         } else {
             classpath 'com.android.tools.build:gradle:2.3.3'
         }
-        classpath "com.tencent.tinker:tinker-patch-gradle-plugin:${TINKER_VERSION}"
+        classpath("com.tencent.tinker:tinker-patch-gradle-plugin:${TINKER_VERSION}") {
+            changing = TINKER_VERSION?.endsWith("-SNAPSHOT")
+            exclude group: 'com.android.tools.build', module: 'gradle'
+        }
+    }
+    configurations.all {
+        it.resolutionStrategy.cacheDynamicVersionsFor(5, 'minutes')
+        it.resolutionStrategy.cacheChangingModulesFor(0, 'seconds')
     }
 }
 
 allprojects {
     repositories {
         mavenLocal()
-        google()
         jcenter()
+        maven {
+            url 'https://maven.google.com/'
+            name 'Google'
+        }
     }
 }
 
diff --git a/tinker-sample-android/gradle.properties b/tinker-sample-android/gradle.properties
index 2a7b1269..0da4d094 100644
--- a/tinker-sample-android/gradle.properties
+++ b/tinker-sample-android/gradle.properties
@@ -17,5 +17,8 @@
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
 
-TINKER_VERSION=1.9.8
-GRADLE_3=true
\ No newline at end of file
+TINKER_VERSION=1.9.11
+GRADLE_3=true
+
+#android.enableAapt2=false
+#tinker.aapt2.public=false
diff --git a/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties b/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
index 860d32cb..7e69b017 100644
--- a/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
+++ b/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.5-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-all.zip
