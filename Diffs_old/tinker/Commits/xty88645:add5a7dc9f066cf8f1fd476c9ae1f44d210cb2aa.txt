diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
index 936b50a6..03ba6974 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
@@ -149,21 +149,20 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
             if (ShareTinkerInternals.isVmArt()) {
                 File extractedFile = new File(dir + ShareConstants.DEX_SMALLPATCH_INFO_FILE);
                 ZipEntry smallPatchInfoEntry = patch.getEntry(ShareConstants.DEX_SMALLPATCH_INFO_FILE);
-                if (smallPatchInfoEntry == null) {
-                    TinkerLog.w(TAG, "small patch info is not exists, bad patch package?");
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, ShareConstants.DEX_SMALLPATCH_INFO_FILE, type, isUpgradePatch);
-                    return false;
-                }
-                InputStream smallPatchInfoIs = null;
-                try {
-                    smallPatchInfoIs = patch.getInputStream(smallPatchInfoEntry);
-                    smallPatchInfoFile = new SmallPatchedDexItemFile(smallPatchInfoIs);
-                } catch (Throwable e) {
-                    TinkerLog.w(TAG, "failed to read small patched info. reason: " + e.getMessage());
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, ShareConstants.DEX_SMALLPATCH_INFO_FILE, type, isUpgradePatch);
-                    return false;
-                } finally {
-                    SharePatchFileUtil.closeQuietly(smallPatchInfoIs);
+                if (smallPatchInfoEntry != null) {
+                    InputStream smallPatchInfoIs = null;
+                    try {
+                        smallPatchInfoIs = patch.getInputStream(smallPatchInfoEntry);
+                        smallPatchInfoFile = new SmallPatchedDexItemFile(smallPatchInfoIs);
+                    } catch (Throwable e) {
+                        TinkerLog.w(TAG, "failed to read small patched info. reason: " + e.getMessage());
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, ShareConstants.DEX_SMALLPATCH_INFO_FILE, type, isUpgradePatch);
+                        return false;
+                    } finally {
+                        SharePatchFileUtil.closeQuietly(smallPatchInfoIs);
+                    }
+                } else {
+                    TinkerLog.w(TAG, "small patch info is not exists, it's ok now.");
                 }
             }
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/build.gradle b/tinker-build/tinker-patch-gradle-plugin/build.gradle
index d07a0497..c027fdaa 100644
--- a/tinker-build/tinker-patch-gradle-plugin/build.gradle
+++ b/tinker-build/tinker-patch-gradle-plugin/build.gradle
@@ -10,6 +10,7 @@ dependencies {
 //    compile fileTree(dir: 'libs', include: ['*.jar'])
     compile project(':tinker-build:tinker-patch-lib')
     compile 'com.google.gradle:osdetector-gradle-plugin:1.2.1'
+    compile 'com.android.tools.build:gradle-api:2.2.0'
 }
 
 repositories {
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
index 463e2993..0b18f8f5 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
@@ -16,24 +16,14 @@
 
 package com.tencent.tinker.build.gradle
 
-import com.tencent.tinker.build.gradle.extension.TinkerBuildConfigExtension
-import com.tencent.tinker.build.gradle.extension.TinkerDexExtension
-import com.tencent.tinker.build.gradle.extension.TinkerLibExtension
-import com.tencent.tinker.build.gradle.extension.TinkerPackageConfigExtension
-import com.tencent.tinker.build.gradle.extension.TinkerPatchExtension
-import com.tencent.tinker.build.gradle.extension.TinkerResourceExtension
-import com.tencent.tinker.build.gradle.extension.TinkerSevenZipExtension
-import com.tencent.tinker.build.gradle.task.TinkerManifestTask
-import com.tencent.tinker.build.gradle.task.TinkerMultidexConfigTask
-import com.tencent.tinker.build.gradle.task.TinkerPatchSchemaTask
-import com.tencent.tinker.build.gradle.task.TinkerProguardConfigTask
-import com.tencent.tinker.build.gradle.task.TinkerResourceIdTask
+import com.tencent.tinker.build.gradle.extension.*
+import com.tencent.tinker.build.gradle.task.*
+import com.tencent.tinker.build.gradle.transform.AuxiliaryInjectTransform
 import com.tencent.tinker.build.util.FileOperation
 import com.tencent.tinker.build.util.TypedValue
 import org.gradle.api.GradleException
 import org.gradle.api.Plugin
 import org.gradle.api.Project
-
 /**
  * Registers the plugin's tasks.
  *
@@ -59,6 +49,8 @@ class TinkerPatchPlugin implements Plugin<Project> {
 
         def configuration = project.tinkerPatch
 
+        project.android.registerTransform(new AuxiliaryInjectTransform(project))
+
         project.afterEvaluate {
             if (!project.plugins.hasPlugin('com.android.application')) {
                 throw new GradleException('generateTinkerApk: Android Application plugin required')
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
index 81210332..0893beec 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
@@ -31,7 +31,7 @@ public class TinkerPatchExtension {
     String oldApk
 
     /**
-     * if there is loader class changes,
+     * If there is loader class changes,
      * or Activity, Service, Receiver, Provider change, it will terminal
      * if ignoreWarning is false
      * default: false
@@ -39,7 +39,19 @@ public class TinkerPatchExtension {
     boolean ignoreWarning
 
     /**
-     * if sign the patch file with the android signConfig
+     * If mUsePreGeneratedPatchDex was enabled, tinker framework would generate
+     * a dex file including all added and changed classes instead of patch info file.
+     *
+     * You can make this mode enabled if you're using any dex encrypting solutions or
+     * maintaining patches that suitable for multi-channel base packages.
+     *
+     * Notice that although you use this mode, proguard mappings should still be applied
+     * to base package and all patched packages.
+     */
+    boolean usePreGeneratedPatchDex
+
+    /**
+     * If sign the patch file with the android signConfig
      * default: true
      */
     boolean useSign
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
index 4b7cc559..5a6ba306 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
@@ -68,6 +68,7 @@ public class TinkerPatchSchemaTask extends DefaultTask {
                .setNewApk(buildApkPath)
                .setOutBuilder(outputFolder)
                .setIgnoreWarning(configuration.ignoreWarning)
+               .setUsePreGeneratedPatchDex(configuration.usePreGeneratedPatchDex)
                .setDexFilePattern(configuration.dex.pattern)
                .setDexLoaderPattern(configuration.dex.loader)
                .setDexMode(configuration.dex.dexMode)
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
index c0f9e0d0..971a46bd 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
@@ -16,6 +16,7 @@
 
 package com.tencent.tinker.build.gradle.task
 
+import com.tencent.tinker.build.auxiliaryinject.AuxiliaryInjector
 import com.tencent.tinker.build.gradle.TinkerPatchPlugin
 import com.tencent.tinker.build.util.FileOperation
 import org.gradle.api.DefaultTask
@@ -86,6 +87,18 @@ public class TinkerProguardConfigTask extends DefaultTask {
         }
 
         fr.write(PROGUARD_CONFIG_SETTINGS)
+
+        // write additional rules to keep <init> and <clinit>
+        if (project.tinkerPatch.usePreGeneratedPatchDex) {
+            def additionalKeptRules =
+                    "-dontwarn ${AuxiliaryInjector.AUXILIARY_CLASSNAME} \n" +
+                            '-keepclassmembers class * { \n' +
+                            '    <init>(...); \n' +
+                            '    static void <clinit>(...); \n' +
+                            '}\n\n'
+            fr.write(additionalKeptRules)
+        }
+
         fr.write("#your dex.loader patterns here\n")
         //they will removed when apply
         Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy
new file mode 100644
index 00000000..6753aab2
--- /dev/null
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy
@@ -0,0 +1,332 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.gradle.transform
+
+import com.android.build.api.transform.*
+import com.google.common.collect.Sets
+import com.google.common.io.Files
+import com.tencent.tinker.build.auxiliaryinject.AuxiliaryInjector
+import com.tencent.tinker.build.util.MD5
+import com.tencent.tinker.commons.ziputil.Streams
+import groovy.io.FileType
+import org.gradle.api.Project
+
+import java.util.zip.ZipEntry
+import java.util.zip.ZipInputStream
+import java.util.zip.ZipOutputStream
+
+/**
+ * Transform for calling AuxiliaryInjector.
+ *
+ * @author tangyinsheng
+ */
+public class AuxiliaryInjectTransform extends Transform {
+    private static final String TRANSFORM_NAME = 'AuxiliaryInject'
+
+    private final Project project
+
+    private AuxiliaryInjector auxiliaryInjector
+    private boolean isEnabled = false
+
+    def applicationVariants
+
+    /* ****** Variant related parameters start ****** */
+
+    boolean isInitialized = false
+    def manifestFile
+    def appClassName
+    def appClassPathName
+
+    /* ******  Variant related parameters end  ****** */
+
+    public AuxiliaryInjectTransform(Project project) {
+        this.project = project
+        project.afterEvaluate {
+            this.isEnabled = project.tinkerPatch.usePreGeneratedPatchDex
+            this.applicationVariants = project.android.applicationVariants
+        }
+    }
+
+    @Override
+    String getName() {
+        return TRANSFORM_NAME
+    }
+
+    @Override
+    Set<QualifiedContent.ContentType> getInputTypes() {
+        return Sets.immutableEnumSet(QualifiedContent.DefaultContentType.CLASSES)
+    }
+
+    @Override
+    Set<QualifiedContent.Scope> getScopes() {
+        return Sets.immutableEnumSet(
+                QualifiedContent.Scope.PROJECT,
+                QualifiedContent.Scope.PROJECT_LOCAL_DEPS,
+                QualifiedContent.Scope.SUB_PROJECTS,
+                QualifiedContent.Scope.SUB_PROJECTS_LOCAL_DEPS,
+                QualifiedContent.Scope.EXTERNAL_LIBRARIES
+        )
+    }
+
+    @Override
+    boolean isIncremental() {
+        return true
+    }
+
+    private String getTaskNamePrefix(Transform transform) {
+        StringBuilder sb = new StringBuilder(100);
+        sb.append("transform");
+
+        Iterator<QualifiedContent.ContentType> iterator = transform.getInputTypes().iterator();
+        // there's always at least one
+        sb.append(iterator.next().name().toLowerCase(Locale.getDefault()).capitalize());
+        while (iterator.hasNext()) {
+            sb.append("And").append(
+                    iterator.next().name().toLowerCase(Locale.getDefault()).capitalize());
+        }
+
+        sb.append("With").append(transform.getName().capitalize()).append("For");
+
+        return sb.toString();
+    }
+
+    private String decapitalize(String src) {
+        char[] chars = src.toCharArray()
+        chars[0] += (char) 32
+        return new String(chars)
+    }
+
+    private void initVariantRelatedParamsIfNeeded(String variantName) {
+        if (this.isInitialized) {
+            return
+        }
+
+        // Get manifest file path.
+        def manifestTask = this.project.tasks.findByName("process${variantName.capitalize()}Manifest")
+        this.manifestFile = manifestTask.outputs.files.files[0]
+
+        // Get application classname from manifest file.
+        def parsedManifest = new XmlParser().parse(this.manifestFile)
+        def androidTag = new groovy.xml.Namespace(
+                "http://schemas.android.com/apk/res/android", 'android')
+        this.appClassName = parsedManifest.application[0].attribute(androidTag.name)
+        this.appClassPathName = this.appClassName.replace('.', '/') + '.class'
+
+        this.isInitialized = true
+    }
+
+    @Override
+    public void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
+        if (!this.isEnabled) {
+            return
+        }
+
+        String variantName = decapitalize(transformInvocation.context.path.split(getTaskNamePrefix(this))[1])
+        initVariantRelatedParamsIfNeeded(variantName)
+
+        File dirOutput = transformInvocation.outputProvider.getContentLocation(
+                "classes", getOutputTypes(), getScopes(), Format.DIRECTORY)
+        if (!dirOutput.exists()) {
+            dirOutput.mkdirs()
+        }
+
+        File jarOutput = transformInvocation.outputProvider.getContentLocation(
+                "combined", getOutputTypes(), getScopes(), Format.JAR
+        )
+        if (!jarOutput.exists()) {
+            jarOutput.getParentFile().mkdirs()
+        }
+
+        File tempJarOutputDir = new File(transformInvocation.context.temporaryDir, "combined-jars")
+        if (!tempJarOutputDir.exists()) {
+            tempJarOutputDir.mkdirs()
+        }
+
+        transformInvocation.inputs.each { input ->
+            input.directoryInputs.each { dirInput ->
+                if (transformInvocation.incremental) {
+                    dirInput.changedFiles.each { entry ->
+                        File fileInput = entry.getKey()
+                        File fileOutput = new File(fileInput.getAbsolutePath().replace(
+                                dirInput.file.getAbsolutePath(), dirOutput.getAbsolutePath()))
+                        if (!fileOutput.exists()) {
+                            fileOutput.getParentFile().mkdirs()
+                        }
+
+                        Status fileStatus = entry.getValue()
+                        switch(fileStatus) {
+                            case Status.ADDED:
+                            case Status.CHANGED:
+                                // Skip application class.
+                                if (dirInput.file.toPath().relativize(fileInput.toPath())
+                                        .toString().replace('\\', '/').endsWith(this.appClassPathName)) {
+                                    printWarnLog('Skipping Application class: %s',
+                                            dirInput.file.toPath().relativize(fileInput.toPath()).toString())
+                                    Files.copy(fileInput, fileOutput)
+                                } else {
+                                    printMsgLog('Processing %s file %s',
+                                            fileStatus,
+                                            dirInput.file.toPath().relativize(fileInput.toPath()).toString())
+                                    AuxiliaryInjector.processClass(fileInput, fileOutput)
+                                }
+                                break
+                            case Status.REMOVED:
+                                printMsgLog('Removing %s file %s from result.', fileStatus,
+                                        dirOutput.toPath().relativize(fileOutput.toPath()).toString())
+                                if (fileOutput.exists()) {
+                                    fileOutput.delete()
+                                }
+                                break
+                        }
+                    }
+                } else {
+                    if (dirOutput.exists()) {
+                        dirOutput.deleteDir()
+                    }
+
+                    dirInput.file.traverse(type: FileType.FILES, nameFilter: ~/.*\.class$/) { fileInput ->
+                        File fileOutput = new File(fileInput.getAbsolutePath().replace(dirInput.file.getAbsolutePath(), dirOutput.getAbsolutePath()))
+                        if (!fileOutput.exists()) {
+                            fileOutput.getParentFile().mkdirs()
+                        }
+
+                        // Skip application class.
+                        if (dirInput.file.toPath().relativize(fileInput.toPath())
+                                .toString().replace('\\', '/').endsWith(this.appClassPathName)) {
+                            printWarnLog('Skipping Application class: %s',
+                                    dirInput.file.toPath().relativize(fileInput.toPath()).toString())
+                            Files.copy(fileInput, fileOutput)
+                        } else {
+                            printMsgLog('Processing %s file %s',
+                                    Status.ADDED,
+                                    dirInput.file.toPath().relativize(fileInput.toPath()).toString())
+                            AuxiliaryInjector.processClass(fileInput, fileOutput)
+                        }
+                    }
+                }
+            }
+
+            List<File> jarsToMerge = new ArrayList<>()
+
+            input.jarInputs.each { jarInput ->
+                File fileInput = jarInput.file
+                File fileOutput = new File(tempJarOutputDir,
+                        getUniqueHashName(fileInput))
+                if (!fileOutput.exists()) {
+                    fileOutput.getParentFile().mkdirs()
+                }
+
+                switch (jarInput.status) {
+                    case Status.NOTCHANGED:
+                        if (transformInvocation.incremental) {
+                            break
+                        }
+                    case Status.ADDED:
+                    case Status.CHANGED:
+                        printMsgLog('Processing %s file %s',
+                                transformInvocation.incremental ? jarInput.status : Status.ADDED,
+                                tempJarOutputDir.toPath().relativize(fileOutput.toPath()).toString())
+                        AuxiliaryInjector.processJar(fileInput, fileOutput)
+                        jarsToMerge.add(fileOutput)
+                        break
+                    case Status.REMOVED:
+                        printMsgLog('Removing %s file %s from result.', fileStatus,
+                                tempJarOutputDir.toPath().relativize(fileOutput.toPath()).toString())
+                        if (fileOutput.exists()) {
+                            fileOutput.delete()
+                        }
+                        break
+                }
+            }
+
+            mergeJars(jarsToMerge, jarOutput)
+        }
+    }
+
+    private String getUniqueHashName(File fileInput) {
+        final String fileInputName = fileInput.getName()
+        if (fileInput.isDirectory()) {
+            return fileInputName
+        }
+        final String parentDirPath = fileInput.getParentFile().getAbsolutePath()
+        final String pathMD5 = MD5.getMessageDigest(parentDirPath.getBytes())
+        final int extSepPos = fileInputName.lastIndexOf('.')
+        final String fileInputNamePrefix =
+                (extSepPos >= 0 ? fileInputName.substring(0, extSepPos) : fileInputName)
+        final String fileInputNameSurfix =
+                (extSepPos >= 0 ? fileInputName.substring(extSepPos) : '')
+        return fileInputNamePrefix + '_' + pathMD5 + fileInputNameSurfix
+    }
+
+    private void mergeJars(Collection<File> jarsToMerge, File jarOutput) {
+        if (jarsToMerge == null || jarsToMerge.size() == 0) {
+            return
+        }
+
+        Set<String> addedEntries = new HashSet<>()
+        ZipOutputStream zos = null
+        try {
+            zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(jarOutput)))
+            jarsToMerge.each { jarInput ->
+                ZipInputStream zis = null
+                try {
+                    zis = new ZipInputStream(new BufferedInputStream(new FileInputStream(jarInput)))
+                    ZipEntry entryIn = null
+                    while ((entryIn = zis.getNextEntry()) != null) {
+                        final String entryName = entryIn.getName()
+                        if (!addedEntries.contains(entryName)) {
+                            addedEntries.add(entryName)
+                            ZipEntry entryOut = new ZipEntry(entryIn.getName())
+                            zos.putNextEntry(entryOut)
+                            if (!entryIn.isDirectory()) {
+                                Streams.copy(zis, zos)
+                            }
+                            zos.closeEntry()
+                        }
+                    }
+                } finally {
+                    closeQuietly(zis)
+                }
+            }
+        } finally {
+            closeQuietly(zos)
+        }
+    }
+
+    private void printMsgLog(String fmt, Object... vals) {
+        final String title = TRANSFORM_NAME.capitalize()
+        this.project.logger.lifecycle("[{}] {}", title,
+                (vals == null || vals.length == 0 ? fmt : String.format(fmt, vals)))
+    }
+
+    private void printWarnLog(String fmt, Object... vals) {
+        final String title = TRANSFORM_NAME.capitalize()
+        this.project.logger.warn("[{}] {}", title,
+                (vals == null || vals.length == 0 ? fmt : String.format(fmt, vals)))
+    }
+
+    private void closeQuietly(Closeable target) {
+        if (target != null) {
+            try {
+                target.close()
+            } catch (Exception e) {
+                // Ignored.
+            }
+        }
+    }
+}
+
diff --git a/tinker-build/tinker-patch-lib/build.gradle b/tinker-build/tinker-patch-lib/build.gradle
index 9b48db6e..adcdbf4e 100644
--- a/tinker-build/tinker-patch-lib/build.gradle
+++ b/tinker-build/tinker-patch-lib/build.gradle
@@ -11,6 +11,8 @@ dependencies {
     compile project(':tinker-commons')
     compile group: 'net.dongliu', name: 'apk-parser', version: '2.1.6'
     compile group: 'com.google.guava', name: 'guava', version: '11.0.2'
+    compile group: 'org.smali', name: 'dexlib2', version: '2.1.3'
+    compile group: 'org.ow2.asm', name: 'asm-all', version: '5.0.4'
 }
 
 sourceSets {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryinject/AuxiliaryInjectAdapter.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryinject/AuxiliaryInjectAdapter.java
new file mode 100644
index 00000000..e5950ba5
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryinject/AuxiliaryInjectAdapter.java
@@ -0,0 +1,141 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.auxiliaryinject;
+
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
+
+/**
+ * Created by tangyinsheng on 2016/10/10.
+ */
+
+public final class AuxiliaryInjectAdapter extends ClassVisitor {
+    private final String auxiliaryClassDesc;
+    private boolean isClInitExists;
+    private boolean isInitExists;
+    private boolean isTargetClass;
+    private boolean isInjected;
+
+    public AuxiliaryInjectAdapter(String auxiliaryClassName, ClassWriter cw) {
+        super(Opcodes.ASM5, cw);
+        this.auxiliaryClassDesc = fastClassNameToDesc(auxiliaryClassName);
+    }
+
+    private String fastClassNameToDesc(String className) {
+        if (className.startsWith("L") && className.endsWith(";")) {
+            return className;
+        }
+        if ("boolean".equals(className)) {
+            return "Z";
+        } else
+        if ("byte".equals(className)) {
+            return "B";
+        } else
+        if ("char".equals(className)) {
+            return "C";
+        } else
+        if ("short".equals(className)) {
+            return "S";
+        } else
+        if ("int".equals(className)) {
+            return "I";
+        } else
+        if ("long".equals(className)) {
+            return "J";
+        } else
+        if ("float".equals(className)) {
+            return "F";
+        } else
+        if ("double".equals(className)) {
+            return "D";
+        } else {
+            className = className.replace('.', '/');
+            return "L" + className + ";";
+        }
+    }
+
+    @Override
+    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
+        super.visit(version, access, name, signature, superName, interfaces);
+        this.isClInitExists = false;
+        this.isInitExists = false;
+        this.isTargetClass = ((access & Opcodes.ACC_INTERFACE) == 0);
+        this.isInjected = false;
+    }
+
+    @Override
+    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);
+        if (mv != null && this.isTargetClass && !this.isInjected) {
+            if ("<clinit>".equals(name)) {
+                this.isClInitExists = true;
+                this.isInjected = true;
+                mv = new InjectImplMethodVisitor(mv);
+            } else
+            if ("<init>".equals(name)){
+                this.isInitExists = true;
+                this.isInjected = true;
+                mv = new InjectImplMethodVisitor(mv);
+            }
+        }
+        return mv;
+    }
+
+    @Override
+    public void visitEnd() {
+        // If method <clinit> and <init> are not found, we should generate a <clinit>.
+        if (!this.isClInitExists && !this.isInitExists) {
+            MethodVisitor mv = super.visitMethod(Opcodes.ACC_STATIC, "<clinit>", "()V", null, null);
+            mv.visitCode();
+            mv.visitLdcInsn(Type.getType(AuxiliaryInjectAdapter.this.auxiliaryClassDesc));
+            mv.visitVarInsn(Opcodes.ASTORE, 0);
+            mv.visitInsn(Opcodes.RETURN);
+            mv.visitMaxs(1, 1);
+            mv.visitEnd();
+        }
+        super.visitEnd();
+    }
+
+    private class InjectImplMethodVisitor extends MethodVisitor {
+        public InjectImplMethodVisitor(MethodVisitor mv) {
+            super(Opcodes.ASM5, mv);
+        }
+
+        @Override
+        public void visitInsn(int opcode) {
+            if (opcode == Opcodes.RETURN) {
+                super.visitLdcInsn(Type.getType(AuxiliaryInjectAdapter.this.auxiliaryClassDesc));
+                super.visitVarInsn(Opcodes.ASTORE, 0);
+            }
+            super.visitInsn(opcode);
+        }
+
+        @Override
+        public void visitMaxs(int maxStack, int maxLocals) {
+            if (maxStack < 1) {
+                maxStack = 1;
+            }
+            if (maxLocals < 1) {
+                maxLocals = 1;
+            }
+            super.visitMaxs(maxStack, maxLocals);
+        }
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryinject/AuxiliaryInjector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryinject/AuxiliaryInjector.java
new file mode 100644
index 00000000..574f98f1
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryinject/AuxiliaryInjector.java
@@ -0,0 +1,115 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.auxiliaryinject;
+
+import com.tencent.tinker.commons.ziputil.Streams;
+
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassWriter;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.charset.Charset;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+import java.util.zip.ZipOutputStream;
+
+/**
+ * Created by tangyinsheng on 2016/10/9.
+ */
+
+public final class AuxiliaryInjector {
+    public static final String AUXILIARY_CLASSNAME = "dalvik.system.PathClassLoader";
+
+    public static void processClass(File classIn, File classOut) throws IOException {
+        InputStream is = null;
+        OutputStream os = null;
+        try {
+            is = new BufferedInputStream(new FileInputStream(classIn));
+            os = new BufferedOutputStream(new FileOutputStream(classOut));
+            processClass(is, os);
+        } finally {
+            closeQuietly(os);
+            closeQuietly(is);
+        }
+    }
+
+    public static void processJar(File jarIn, File jarOut) throws IOException {
+        try {
+            processJarHelper(jarIn, jarOut, Charset.forName("UTF-8"), Charset.forName("UTF-8"));
+        } catch (IllegalArgumentException e) {
+            if ("MALFORMED".equals(e.getMessage())) {
+                processJarHelper(jarIn, jarOut, Charset.forName("GBK"), Charset.forName("UTF-8"));
+            } else {
+                throw e;
+            }
+        }
+    }
+
+    @SuppressWarnings("NewApi")
+    private static void processJarHelper(File jarIn, File jarOut, Charset charsetIn, Charset charsetOut) throws IOException {
+        ZipInputStream zis = null;
+        ZipOutputStream zos = null;
+        try {
+            zis = new ZipInputStream(new BufferedInputStream(new FileInputStream(jarIn)), charsetIn);
+            zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(jarOut)), charsetOut);
+            ZipEntry entryIn = null;
+            while ((entryIn = zis.getNextEntry()) != null) {
+                final String entryName = entryIn.getName();
+                ZipEntry entryOut = new ZipEntry(entryName);
+                zos.putNextEntry(entryOut);
+                if (!entryIn.isDirectory()) {
+                    if (entryName.endsWith(".class")) {
+                        processClass(zis, zos);
+                    } else {
+                        Streams.copy(zis, zos);
+                    }
+                }
+                zos.closeEntry();
+            }
+        } finally {
+            closeQuietly(zos);
+            closeQuietly(zis);
+        }
+    }
+
+    private static void processClass(InputStream classIn, OutputStream classOut) throws IOException {
+        ClassReader cr = new ClassReader(classIn);
+        ClassWriter cw = new ClassWriter(0);
+        AuxiliaryInjectAdapter aia = new AuxiliaryInjectAdapter(AUXILIARY_CLASSNAME, cw);
+        cr.accept(aia, 0);
+        classOut.write(cw.toByteArray());
+        classOut.flush();
+    }
+
+    private static void closeQuietly(Closeable target) {
+        if (target != null) {
+            try {
+                target.close();
+            } catch (Exception e) {
+                // Ignored.
+            }
+        }
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
index 6c366f00..b674579a 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
@@ -22,6 +22,7 @@
 import com.tencent.tinker.android.dex.DexFormat;
 import com.tencent.tinker.android.dx.util.Hex;
 import com.tencent.tinker.build.dexpatcher.DexPatchGenerator;
+import com.tencent.tinker.build.dexpatcher.util.SmallDexClassInfoCollector;
 import com.tencent.tinker.build.dexpatcher.util.SmallDexPatchGenerator;
 import com.tencent.tinker.build.info.InfoWriter;
 import com.tencent.tinker.build.patch.Configuration;
@@ -39,6 +40,17 @@
 import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger.IDexPatcherLogger;
 import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
 
+import org.jf.dexlib2.Opcodes;
+import org.jf.dexlib2.builder.BuilderMutableMethodImplementation;
+import org.jf.dexlib2.dexbacked.DexBackedDexFile;
+import org.jf.dexlib2.iface.DexFile;
+import org.jf.dexlib2.iface.Field;
+import org.jf.dexlib2.iface.Method;
+import org.jf.dexlib2.writer.builder.BuilderField;
+import org.jf.dexlib2.writer.builder.BuilderMethod;
+import org.jf.dexlib2.writer.builder.DexBuilder;
+import org.jf.dexlib2.writer.io.FileDataStore;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -56,7 +68,9 @@
  * Created by zhangshaowen on 2016/3/23.
  */
 public class DexDiffDecoder extends BaseDecoder {
-    private static final String TEST_DEX_PATH = "test.dex";
+    private static final String TEST_DEX_NAME = "test.dex";
+    private static final String STUBMODE_PATCH_DEX_NAME = "changed_classes.dex";
+
     private final InfoWriter logWriter;
     private final InfoWriter metaWriter;
 
@@ -141,15 +155,19 @@ public boolean patch(final File oldFile, final File newFile) throws IOException,
         //new add file
         if (oldFile == null || !oldFile.exists() || oldFile.length() == 0) {
             hasDexChanged = true;
-            copyNewDexAndMarkInMeta(newFile, newMd5, dexDiffOut);
-            return true;
+            if (!config.mUsePreGeneratedPatchDex) {
+                copyNewDexAndMarkInMeta(newFile, newMd5, dexDiffOut);
+                return true;
+            }
         }
 
         final String oldMd5 = MD5.getMD5(oldFile);
 
-        if (!oldMd5.equals(newMd5)) {
+        if ((oldMd5 != null && !oldMd5.equals(newMd5)) || (oldMd5 == null && newMd5 != null)) {
             hasDexChanged = true;
-            checkAddedOrDeletedClasses(oldFile, newFile);
+            if (oldMd5 != null) {
+                checkAddedOrDeletedClasses(oldFile, newFile);
+            }
         }
 
         RelatedInfo relatedInfo = new RelatedInfo();
@@ -159,13 +177,12 @@ public boolean patch(final File oldFile, final File newFile) throws IOException,
         // collect current old dex file and corresponding new dex file for further processing.
         oldAndNewDexFilePairList.add(new AbstractMap.SimpleEntry<>(oldFile, newFile));
 
-        final String dexName = oldFile.getName();
+        final String dexName = (oldFile != null ? oldFile.getName() : newFile.getName());
         dexNameToRelatedInfoMap.put(dexName, relatedInfo);
 
         return true;
     }
 
-    @SuppressWarnings("NewApi")
     @Override
     public void onAllPatchesEnd() throws Exception {
         if (!hasDexChanged) {
@@ -173,6 +190,118 @@ public void onAllPatchesEnd() throws Exception {
             return;
         }
 
+        if (config.mUsePreGeneratedPatchDex) {
+            generateStubModePatchDex();
+        } else {
+            generatePatchInfoFile();
+        }
+    }
+
+    @SuppressWarnings("NewApi")
+    private void generateStubModePatchDex() throws IOException {
+        List<File> oldDexList = new ArrayList<>();
+        List<File> newDexList = new ArrayList<>();
+        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
+            File oldDexFile = oldAndNewDexFilePair.getKey();
+            File newDexFile = oldAndNewDexFilePair.getValue();
+            if (oldDexFile != null) {
+                oldDexList.add(oldDexFile);
+            }
+            if (newDexFile != null) {
+                newDexList.add(newDexFile);
+            }
+        }
+
+        DexGroup oldDexGroup = DexGroup.wrap(oldDexList);
+        DexGroup newDexGroup = DexGroup.wrap(newDexList);
+
+        SmallDexClassInfoCollector smallDexClassInfoCollector = new SmallDexClassInfoCollector();
+        smallDexClassInfoCollector.setLoaderClassPatterns(config.mDexLoaderPattern);
+        smallDexClassInfoCollector.setLogger(this.dexPatcherLoggerBridge);
+
+        Set<DexClassInfo> classInfosInPatchedDex =
+                smallDexClassInfoCollector.doCollect(oldDexGroup, newDexGroup);
+
+        // So far we have got all infos of classes we need to include in stub mode patch dex.
+        // Now construct the stub mode patch dex.
+        final Set<String> classDescsInPatchedDex = new HashSet<>();
+        Set<Dex> newDexes = new HashSet<>();
+
+        DexBuilder dexBuilder = DexBuilder.makeDexBuilder(Opcodes.forApi(15));
+
+        for (DexClassInfo classInfo : classInfosInPatchedDex) {
+            classDescsInPatchedDex.add(classInfo.classDesc);
+            newDexes.add(classInfo.owner);
+        }
+
+        for (Dex newDex : newDexes) {
+            DexFile dexFile = new DexBackedDexFile(Opcodes.forApi(15), newDex.getBytes());
+            for (org.jf.dexlib2.iface.ClassDef parsedClassDef : dexFile.getClasses()) {
+                if (classDescsInPatchedDex.contains(parsedClassDef.getType())) {
+                    List<BuilderField> builderFields = new ArrayList<>();
+                    for (Field parsedField : parsedClassDef.getFields()) {
+                        BuilderField builderField = dexBuilder.internField(
+                                parsedField.getDefiningClass(),
+                                parsedField.getName(),
+                                parsedField.getType(),
+                                parsedField.getAccessFlags(),
+                                parsedField.getInitialValue(),
+                                parsedField.getAnnotations()
+                        );
+                        builderFields.add(builderField);
+                    }
+                    List<BuilderMethod> builderMethods = new ArrayList<>();
+                    for (Method parsedMethod : parsedClassDef.getMethods()) {
+                        BuilderMethod builderMethod = dexBuilder.internMethod(
+                                parsedMethod.getDefiningClass(),
+                                parsedMethod.getName(),
+                                parsedMethod.getParameters(),
+                                parsedMethod.getReturnType(),
+                                parsedMethod.getAccessFlags(),
+                                parsedMethod.getAnnotations(),
+                                new BuilderMutableMethodImplementation(
+                                        dexBuilder, parsedMethod.getImplementation()
+                                )
+                        );
+                        builderMethods.add(builderMethod);
+                    }
+
+                    dexBuilder.internClassDef(
+                            parsedClassDef.getType(),
+                            parsedClassDef.getAccessFlags(),
+                            parsedClassDef.getSuperclass(),
+                            parsedClassDef.getInterfaces(),
+                            parsedClassDef.getSourceFile(),
+                            parsedClassDef.getAnnotations(),
+                            builderFields,
+                            builderMethods
+                    );
+                }
+            }
+        }
+
+        // Write constructed stub mode patch dex to file and record it in meta file.
+        final String dexMode = config.mDexRaw ? "raw" : "jar";
+        final File dest = new File(config.mTempResultDir + "/" + STUBMODE_PATCH_DEX_NAME);
+
+        FileDataStore fileDataStore = new FileDataStore(dest);
+        dexBuilder.writeTo(fileDataStore);
+
+        final String md5 = MD5.getMD5(dest);
+
+        String meta = STUBMODE_PATCH_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0
+                        + "," + 0 + "," + dexMode;
+
+        Logger.d("\nPre-generated patch dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
+        Logger.d("DexDecoder:write pre-generated patch dex meta file data: %s", meta);
+
+        metaWriter.writeLineToInfoFile(meta);
+
+        addTestDex();
+    }
+
+    @SuppressWarnings("NewApi")
+    private void generatePatchInfoFile() throws IOException {
         File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "full");
         ensureDirectoryExist(tempFullPatchDexPath);
         File tempSmallPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "small");
@@ -386,7 +515,7 @@ public void onAllPatchesEnd() throws Exception {
         Set<String> movedCrossFilesClassDescs = deletedClassDescs;
         if (!movedCrossFilesClassDescs.isEmpty()) {
             Logger.e("Warning:Class Moved. Some classes are just moved from one dex to another. "
-                + "This behavior may leads to unnecessary enlargement of patch file. you should try to check them:");
+                    + "This behavior may leads to unnecessary enlargement of patch file. you should try to check them:");
 
             for (String classDesc : movedCrossFilesClassDescs) {
                 StringBuilder sb = new StringBuilder();
@@ -524,14 +653,14 @@ private void addTestDex() throws IOException {
             dexMode = "raw";
         }
 
-        final InputStream is = DexDiffDecoder.class.getResourceAsStream("/" + TEST_DEX_PATH);
+        final InputStream is = DexDiffDecoder.class.getResourceAsStream("/" + TEST_DEX_NAME);
         String md5 = MD5.getMD5(is, 1024);
         is.close();
 
-        String meta = TEST_DEX_PATH + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + dexMode;
+        String meta = TEST_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + dexMode;
 
-        File dest = new File(config.mTempResultDir + "/" + TEST_DEX_PATH);
-        FileOperation.copyResourceUsingStream(TEST_DEX_PATH, dest);
+        File dest = new File(config.mTempResultDir + "/" + TEST_DEX_NAME);
+        FileOperation.copyResourceUsingStream(TEST_DEX_NAME, dest);
         Logger.d("\nAdd test install result dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
         Logger.d("DexDecoder:write test dex meta file data: %s", meta);
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/RefToRefAffectedClassInsnVisitor.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/RefToRefAffectedClassInsnVisitor.java
new file mode 100644
index 00000000..8158746a
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/RefToRefAffectedClassInsnVisitor.java
@@ -0,0 +1,136 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.dexpatcher.util;
+
+import com.tencent.tinker.android.dex.ClassData;
+import com.tencent.tinker.android.dex.Dex;
+import com.tencent.tinker.android.dex.FieldId;
+import com.tencent.tinker.android.dex.MethodId;
+import com.tencent.tinker.android.dex.ProtoId;
+import com.tencent.tinker.android.dx.instruction.InstructionCodec;
+import com.tencent.tinker.android.dx.instruction.InstructionVisitor;
+import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
+
+import java.util.Collection;
+
+/**
+ * Created by tangyinsheng on 2016/10/8.
+ */
+
+public class RefToRefAffectedClassInsnVisitor extends InstructionVisitor {
+    private static final String TAG = "RefToRefAffectedClassInsnVisitor";
+
+    private final Dex methodOwner;
+    private final ClassData.Method method;
+    private final Collection<String> refAffectedClassDefs;
+    private final DexPatcherLogger logger;
+
+    public boolean isMethodReferencedToRefAffectedClass;
+
+    RefToRefAffectedClassInsnVisitor(Dex methodOwner, ClassData.Method method, Collection<String> refAffectedClassDefs, DexPatcherLogger logger) {
+        super(null);
+        this.methodOwner = methodOwner;
+        this.method = method;
+        this.refAffectedClassDefs = refAffectedClassDefs;
+        this.logger = logger;
+        this.isMethodReferencedToRefAffectedClass = false;
+    }
+
+    @Override
+    public void visitZeroRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitOneRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitTwoRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitThreeRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitFourRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitFiveRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d, int e) {
+        processIndexByType(index, indexType);
+    }
+
+    @Override
+    public void visitRegisterRangeInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int registerCount) {
+        processIndexByType(index, indexType);
+    }
+
+    private void processIndexByType(int index, int indexType) {
+        String typeName = null;
+        String refInfoInLog = null;
+        switch (indexType) {
+            case InstructionCodec.INDEX_TYPE_TYPE_REF: {
+                typeName = methodOwner.typeNames().get(index);
+                refInfoInLog = "init ref-changed class";
+                break;
+            }
+            case InstructionCodec.INDEX_TYPE_FIELD_REF: {
+                final FieldId fieldId = methodOwner.fieldIds().get(index);
+                typeName = methodOwner.typeNames().get(fieldId.declaringClassIndex);
+                refInfoInLog = "referencing to field: " + methodOwner.strings().get(fieldId.nameIndex);
+                break;
+            }
+            case InstructionCodec.INDEX_TYPE_METHOD_REF: {
+                final MethodId methodId = methodOwner.methodIds().get(index);
+                typeName = methodOwner.typeNames().get(methodId.declaringClassIndex);
+                refInfoInLog = "invoking method: " + getMethodProtoTypeStr(methodId);
+                break;
+            }
+        }
+        if (typeName != null && refAffectedClassDefs.contains(typeName)) {
+            MethodId methodId = methodOwner.methodIds().get(method.methodIndex);
+            logger.i(
+                    TAG,
+                    "Method %s in class %s referenced ref-changed class %s by %s",
+                    getMethodProtoTypeStr(methodId),
+                    methodOwner.typeNames().get(methodId.declaringClassIndex),
+                    typeName,
+                    refInfoInLog
+            );
+            isMethodReferencedToRefAffectedClass = true;
+        }
+    }
+
+    private String getMethodProtoTypeStr(MethodId methodId) {
+        StringBuilder strBuilder = new StringBuilder();
+        strBuilder.append(methodOwner.strings().get(methodId.nameIndex));
+        ProtoId protoId = methodOwner.protoIds().get(methodId.protoIndex);
+        strBuilder.append('(');
+        short[] paramTypeIds = methodOwner.parameterTypeIndicesFromMethodId(methodId);
+        for (short typeId : paramTypeIds) {
+            strBuilder.append(methodOwner.typeNames().get(typeId));
+        }
+        strBuilder.append(')').append(methodOwner.typeNames().get(protoId.returnTypeIndex));
+        return strBuilder.toString();
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexClassInfoCollector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexClassInfoCollector.java
new file mode 100644
index 00000000..f9be6337
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexClassInfoCollector.java
@@ -0,0 +1,162 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.dexpatcher.util;
+
+import com.tencent.tinker.android.dex.ClassData;
+import com.tencent.tinker.android.dex.Code;
+import com.tencent.tinker.android.dex.Dex;
+import com.tencent.tinker.android.dx.instruction.InstructionReader;
+import com.tencent.tinker.android.dx.instruction.ShortArrayCodeInput;
+import com.tencent.tinker.build.util.DexClassesComparator;
+import com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
+import com.tencent.tinker.build.util.DexClassesComparator.DexGroup;
+import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
+
+import java.io.EOFException;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Created by tangyinsheng on 2016/10/8.
+ */
+
+public final class SmallDexClassInfoCollector {
+    private static final String TAG = "SmallDexClassInfoCollector";
+
+    private static final DexPatcherLogger logger = new DexPatcherLogger();
+    private final Set<String> loaderClassPatterns = new HashSet<>();
+
+    public SmallDexClassInfoCollector setLoaderClassPatterns(Collection<String> loaderClassPatterns) {
+        this.loaderClassPatterns.clear();
+        this.loaderClassPatterns.addAll(loaderClassPatterns);
+        return this;
+    }
+
+    public SmallDexClassInfoCollector addLoaderClassPattern(String loaderClassPattern) {
+        this.loaderClassPatterns.add(loaderClassPattern);
+        return this;
+    }
+
+    public SmallDexClassInfoCollector clearLoaderClassPattern() {
+        this.loaderClassPatterns.clear();
+        return this;
+    }
+
+    public SmallDexClassInfoCollector setLogger(DexPatcherLogger.IDexPatcherLogger loggerImpl) {
+        this.logger.setLoggerImpl(loggerImpl);
+        return this;
+    }
+
+    public Set<DexClassInfo> doCollect(DexGroup oldDexGroup, DexGroup newDexGroup) {
+        DexClassesComparator dexClassesCmp = new DexClassesComparator("*");
+        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_CAUSE_REF_CHANGE_ONLY);
+        dexClassesCmp.setIgnoredRemovedClassDescPattern(this.loaderClassPatterns);
+        dexClassesCmp.startCheck(oldDexGroup, newDexGroup);
+
+        Set<String> refAffectedClassDescs
+                = dexClassesCmp.getChangedClassDescToInfosMap().keySet();
+
+        Set<DexClassInfo> classInfosInNewDexGroup
+                = newDexGroup.getClassInfosInDexesWithDuplicateCheck();
+
+        Set<DexClassInfo> classInfosOfSmallDex = new HashSet<>();
+
+        for (DexClassInfo patchedClassInfo : classInfosInNewDexGroup) {
+            if (patchedClassInfo.classDef.classDataOffset == 0) {
+                continue;
+            }
+
+            ClassData patchedClassData
+                    = patchedClassInfo.owner.readClassData(patchedClassInfo.classDef);
+
+            boolean shouldAdd = isClassMethodReferenceToRefAffectedClass(
+                    patchedClassInfo.owner,
+                    patchedClassData.directMethods,
+                    refAffectedClassDescs
+            );
+
+            if (!shouldAdd) {
+                shouldAdd = isClassMethodReferenceToRefAffectedClass(
+                        patchedClassInfo.owner,
+                        patchedClassData.virtualMethods,
+                        refAffectedClassDescs
+                );
+            }
+
+            if (shouldAdd) {
+                logger.i(TAG, "Add class %s to small dex.", patchedClassInfo.classDesc);
+                classInfosOfSmallDex.add(patchedClassInfo);
+            }
+        }
+
+        // So far we get descriptors of classes we need to add additionally,
+        // while we still need to do a fully compare to collect added classes
+        // and replaced classes since they may use items in their owner dex which
+        // is not modified.
+        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_NORMAL);
+        dexClassesCmp.startCheck(oldDexGroup, newDexGroup);
+
+        Collection<DexClassInfo> addedClassInfos = dexClassesCmp.getAddedClassInfos();
+        for (DexClassInfo addClassInfo : addedClassInfos) {
+            logger.i(TAG, "Add class %s to small dex.", addClassInfo.classDesc);
+            classInfosOfSmallDex.add(addClassInfo);
+        }
+
+        Collection<DexClassInfo[]> changedOldPatchedClassInfos =
+                dexClassesCmp.getChangedClassDescToInfosMap().values();
+
+        // changedOldPatchedClassInfo[1] means changedPatchedClassInfo
+        for (DexClassInfo[] changedOldPatchedClassInfo : changedOldPatchedClassInfos) {
+            logger.i(TAG, "Add class %s to small dex.", changedOldPatchedClassInfo[1].classDesc);
+            classInfosOfSmallDex.add(changedOldPatchedClassInfo[1]);
+        }
+
+        return classInfosOfSmallDex;
+    }
+
+    private boolean isClassMethodReferenceToRefAffectedClass(
+            Dex owner,
+            ClassData.Method[] methods,
+            Collection<String> affectedClassDescs
+    ) {
+        if (affectedClassDescs.isEmpty() || methods == null || methods.length == 0) {
+            return false;
+        }
+
+        for (ClassData.Method method : methods) {
+            if (method.codeOffset == 0) {
+                continue;
+            }
+            Code code = owner.readCode(method);
+            RefToRefAffectedClassInsnVisitor refInsnVisitor =
+                    new RefToRefAffectedClassInsnVisitor(owner, method, affectedClassDescs, logger);
+            InstructionReader insnReader =
+                    new InstructionReader(new ShortArrayCodeInput(code.instructions));
+            try {
+                insnReader.accept(refInsnVisitor);
+                if (refInsnVisitor.isMethodReferencedToRefAffectedClass) {
+                    return true;
+                }
+            } catch (EOFException e) {
+                throw new IllegalStateException(e);
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java
index dd805303..d56b2a1e 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java
@@ -44,7 +44,6 @@
 import com.tencent.tinker.android.dx.instruction.ShortArrayCodeInput;
 import com.tencent.tinker.android.dx.util.Hex;
 import com.tencent.tinker.android.dx.util.IndexMap;
-import com.tencent.tinker.build.util.DexClassesComparator;
 import com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
 import com.tencent.tinker.build.util.DexClassesComparator.DexGroup;
 import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
@@ -737,104 +736,17 @@ private void writeDataChunk(
         }
     }
 
-    private boolean isClassMethodReferenceToRefAffectedClass(
-            Dex owner,
-            ClassData.Method[] methods,
-            Collection<String> affectedClassDescs
-    ) {
-        if (affectedClassDescs.isEmpty() || methods == null || methods.length == 0) {
-            return false;
-        }
-
-        for (ClassData.Method method : methods) {
-            if (method.codeOffset == 0) {
-                continue;
-            }
-            Code code = owner.readCode(method);
-            RefToRefAffectedClassInsnVisitor refInsnVisitor =
-                    new RefToRefAffectedClassInsnVisitor(owner, method, affectedClassDescs);
-            InstructionReader insnReader =
-                    new InstructionReader(new ShortArrayCodeInput(code.instructions));
-            try {
-                insnReader.accept(refInsnVisitor);
-                if (refInsnVisitor.isMethodReferencedToRefAffectedClass) {
-                    return true;
-                }
-            } catch (EOFException e) {
-                throw new IllegalStateException(e);
-            }
-        }
-
-        return false;
-    }
-
     private void collectItemIndicesFromDexGroup(
             DexGroup oldDexGroup,
             DexGroup patchedDexGroup
     ) {
-        DexClassesComparator dexClassesCmp = new DexClassesComparator("*");
-        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_CAUSE_REF_CHANGE_ONLY);
-        dexClassesCmp.setIgnoredRemovedClassDescPattern(this.loaderClassPatterns);
-        dexClassesCmp.startCheck(oldDexGroup, patchedDexGroup);
-
-        Set<String> refAffectedClassDescs
-                = dexClassesCmp.getChangedClassDescToInfosMap().keySet();
-
-        Set<DexClassInfo> classInfosInPatchedDexGroup
-                = patchedDexGroup.getClassInfosInDexesWithDuplicateCheck();
-
-        Set<DexClassInfo> patchedClassInfosForItemIndexCollecting = new HashSet<>();
-
-        for (DexClassInfo patchedClassInfo : classInfosInPatchedDexGroup) {
-            if (patchedClassInfo.classDef.classDataOffset == 0) {
-                continue;
-            }
-            ClassData patchedClassData
-                    = patchedClassInfo.owner.readClassData(patchedClassInfo.classDef);
-
-            boolean shouldAdd = isClassMethodReferenceToRefAffectedClass(
-                    patchedClassInfo.owner,
-                    patchedClassData.directMethods,
-                    refAffectedClassDescs
-            );
-
-            if (!shouldAdd) {
-                shouldAdd = isClassMethodReferenceToRefAffectedClass(
-                        patchedClassInfo.owner,
-                        patchedClassData.virtualMethods,
-                        refAffectedClassDescs
-                );
-            }
-
-            if (shouldAdd) {
-                logger.i(TAG, "Add class %s to small patched dex.", patchedClassInfo.classDesc);
-                patchedClassInfosForItemIndexCollecting.add(patchedClassInfo);
-            }
-        }
-
-        // So far we get descriptors of classes we need to add additionally,
-        // while we still need to do a fully compare to collect added classes
-        // and replaced classes since they may use items in their owner dex which
-        // is not modified.
-        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_NORMAL);
-        dexClassesCmp.startCheck(oldDexGroup, patchedDexGroup);
-
-        Collection<DexClassInfo> addedClassInfos = dexClassesCmp.getAddedClassInfos();
-        for (DexClassInfo addClassInfo : addedClassInfos) {
-            logger.i(TAG, "Add class %s to small patched dex.", addClassInfo.classDesc);
-            patchedClassInfosForItemIndexCollecting.add(addClassInfo);
-        }
-
-        Collection<DexClassInfo[]> changedOldPatchedClassInfos =
-                dexClassesCmp.getChangedClassDescToInfosMap().values();
+        SmallDexClassInfoCollector smallDexClassInfoCollector = new SmallDexClassInfoCollector();
+        smallDexClassInfoCollector.setLoaderClassPatterns(this.loaderClassPatterns);
+        smallDexClassInfoCollector.setLogger(this.logger.getLoggerImpl());
+        Set<DexClassInfo> patchedClassInfosForItemIndexCollecting =
+                smallDexClassInfoCollector.doCollect(oldDexGroup, patchedDexGroup);
 
-        // changedOldPatchedClassInfo[1] means changedPatchedClassInfo
-        for (DexClassInfo[] changedOldPatchedClassInfo : changedOldPatchedClassInfos) {
-            logger.i(TAG, "Add class %s to small patched dex.", changedOldPatchedClassInfo[1].classDesc);
-            patchedClassInfosForItemIndexCollecting.add(changedOldPatchedClassInfo[1]);
-        }
-
-        // Finally we collect all elements' indices of collected class.
+        // Collect all elements' indices of collected class.
 
         Map<Dex, OffsetToIndexConverter> dexToOffsetToIndexConverterMap = new HashMap<>();
 
@@ -1787,105 +1699,6 @@ public int simulate(int smallPatchBaseOffset) {
         }
     }
 
-    private class RefToRefAffectedClassInsnVisitor extends InstructionVisitor {
-        private final Dex methodOwner;
-        private final ClassData.Method method;
-        private final Collection<String> refAffectedClassDefs;
-        private boolean isMethodReferencedToRefAffectedClass;
-
-        RefToRefAffectedClassInsnVisitor(Dex methodOwner, ClassData.Method method, Collection<String> refAffectedClassDefs) {
-            super(null);
-            this.methodOwner = methodOwner;
-            this.method = method;
-            this.refAffectedClassDefs = refAffectedClassDefs;
-            this.isMethodReferencedToRefAffectedClass = false;
-        }
-
-        @Override
-        public void visitZeroRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitOneRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitTwoRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitThreeRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitFourRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitFiveRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d, int e) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitRegisterRangeInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int registerCount) {
-            processIndexByType(index, indexType);
-        }
-
-        private void processIndexByType(int index, int indexType) {
-            String typeName = null;
-            String refInfoInLog = null;
-            switch (indexType) {
-                case InstructionCodec.INDEX_TYPE_TYPE_REF: {
-                    typeName = methodOwner.typeNames().get(index);
-                    refInfoInLog = "init ref-changed class";
-                    break;
-                }
-                case InstructionCodec.INDEX_TYPE_FIELD_REF: {
-                    final FieldId fieldId = methodOwner.fieldIds().get(index);
-                    typeName = methodOwner.typeNames().get(fieldId.declaringClassIndex);
-                    refInfoInLog = "referencing to field: " + methodOwner.strings().get(fieldId.nameIndex);
-                    break;
-                }
-                case InstructionCodec.INDEX_TYPE_METHOD_REF: {
-                    final MethodId methodId = methodOwner.methodIds().get(index);
-                    typeName = methodOwner.typeNames().get(methodId.declaringClassIndex);
-                    refInfoInLog = "invoking method: " + getMethodProtoTypeStr(methodId);
-                    break;
-                }
-            }
-            if (typeName != null && refAffectedClassDefs.contains(typeName)) {
-                MethodId methodId = methodOwner.methodIds().get(method.methodIndex);
-                logger.i(
-                        TAG,
-                        "Method %s in class %s referenced ref-changed class %s by %s",
-                        getMethodProtoTypeStr(methodId),
-                        methodOwner.typeNames().get(methodId.declaringClassIndex),
-                        typeName,
-                        refInfoInLog
-                );
-                isMethodReferencedToRefAffectedClass = true;
-            }
-        }
-
-        private String getMethodProtoTypeStr(MethodId methodId) {
-            StringBuilder strBuilder = new StringBuilder();
-            strBuilder.append(methodOwner.strings().get(methodId.nameIndex));
-            ProtoId protoId = methodOwner.protoIds().get(methodId.protoIndex);
-            strBuilder.append('(');
-            short[] paramTypeIds = methodOwner.parameterTypeIndicesFromMethodId(methodId);
-            for (short typeId : paramTypeIds) {
-                strBuilder.append(methodOwner.typeNames().get(typeId));
-            }
-            strBuilder.append(')').append(methodOwner.typeNames().get(protoId.returnTypeIndex));
-            return strBuilder.toString();
-        }
-    }
-
     private class IndicesCollectorInsnVisitor extends InstructionVisitor {
         private final Dex ownerDex;
         private final OffsetToIndexConverter offsetToIndexConverter;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
index 9b359eb5..fd663191 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
@@ -60,6 +60,7 @@
     protected static final String ATTR_NAME  = "name";
 
     protected static final String ATTR_IGNORE_WARNING    = "ignoreWarning";
+    protected static final String ATTR_NO_DIFFPATCH_MODE = "mUsePreGeneratedPatchDex";
     protected static final String ATTR_USE_SIGN          = "useSign";
     protected static final String ATTR_SEVEN_ZIP_PATH    = "sevenZipPath";
     protected static final String ATTR_DEX_MODE          = "dexMode";
@@ -83,6 +84,7 @@
     public File             mOldApkFile;
     public File             mNewApkFile;
     public boolean          mIgnoreWarning;
+    public boolean          mUsePreGeneratedPatchDex;
     /**
      * lib config
      */
@@ -213,6 +215,8 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
         mOutFolder = param.outFolder;
 
         mIgnoreWarning = param.ignoreWarning;
+        mUsePreGeneratedPatchDex = param.usePreGeneratedPatchDex;
+
         mSevenZipPath = param.sevenZipPath;
         mPackageFields = param.configFields;
 
@@ -234,6 +238,7 @@ public String toString() {
         sb.append("newApk:" + mNewApkPath + "\n");
         sb.append("outputFolder:" + mOutFolder + "\n");
         sb.append("isIgnoreWarning:" + mIgnoreWarning + "\n");
+        sb.append("isInsertStubMode:" + mUsePreGeneratedPatchDex + "\n");
         sb.append("7-ZipPath:" + mSevenZipPath + "\n");
         sb.append("useSignAPk:" + mUseSignAPk + "\n");
 
@@ -406,6 +411,9 @@ private void readPropertyFromXml(Node node) throws IOException {
                     }
                     if (tagName.equals(ATTR_IGNORE_WARNING)) {
                         mIgnoreWarning = value.equals("true");
+                    } else
+                    if (tagName.equals(ATTR_NO_DIFFPATCH_MODE)) {
+                        mUsePreGeneratedPatchDex = value.equals("true");
                     } else if (tagName.equals(ATTR_USE_SIGN)) {
                         mUseSignAPk = value.equals("true");
                     } else if (tagName.equals(ATTR_SEVEN_ZIP_PATH)) {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
index 6a217f47..348f431a 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
@@ -35,6 +35,7 @@
     public final String  storealias;
     public final String  storepass;
     public final boolean ignoreWarning;
+    public final boolean usePreGeneratedPatchDex;
     public final boolean useSign;
 
     /**
@@ -81,6 +82,7 @@ private InputParam(
         String storealias,
         String storepass,
         boolean ignoreWarning,
+        boolean usePreGeneratedPatchDex,
         boolean useSign,
 
         ArrayList<String> dexFilePattern,
@@ -103,6 +105,7 @@ private InputParam(
         this.storealias = storealias;
         this.storepass = storepass;
         this.ignoreWarning = ignoreWarning;
+        this.usePreGeneratedPatchDex = usePreGeneratedPatchDex;
         this.useSign = useSign;
 
         this.dexFilePattern = dexFilePattern;
@@ -132,6 +135,7 @@ private InputParam(
         private String  storealias;
         private String  storepass;
         private boolean ignoreWarning;
+        private boolean usePreGeneratedPatchDex;
         private boolean useSign;
 
         /**
@@ -243,6 +247,11 @@ public Builder setIgnoreWarning(boolean ignoreWarning) {
             return this;
         }
 
+        public Builder setUsePreGeneratedPatchDex(boolean usePreGeneratedPatchDex) {
+            this.usePreGeneratedPatchDex = usePreGeneratedPatchDex;
+            return this;
+        }
+
         public Builder setDexLoaderPattern(ArrayList<String> dexLoaderPattern) {
             this.dexLoaderPattern = dexLoaderPattern;
             return this;
@@ -270,25 +279,26 @@ public Builder setUseSign(boolean useSign) {
 
         public InputParam create() {
             return new InputParam(
-                oldApk,
-                newApk,
-                outFolder,
-                signFile,
-                keypass,
-                storealias,
-                storepass,
-                ignoreWarning,
-                useSign,
-                dexFilePattern,
-                dexLoaderPattern,
-                dexMode,
-                soFilePattern,
-                resourceFilePattern,
-                resourceIgnoreChangePattern,
-                largeModSize,
-                useApplyResource,
-                configFields,
-                sevenZipPath
+                    oldApk,
+                    newApk,
+                    outFolder,
+                    signFile,
+                    keypass,
+                    storealias,
+                    storepass,
+                    ignoreWarning,
+                    usePreGeneratedPatchDex,
+                    useSign,
+                    dexFilePattern,
+                    dexLoaderPattern,
+                    dexMode,
+                    soFilePattern,
+                    resourceFilePattern,
+                    resourceIgnoreChangePattern,
+                    largeModSize,
+                    useApplyResource,
+                    configFields,
+                    sevenZipPath
             );
         }
     }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
new file mode 100644
index 00000000..b77a7868
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
@@ -0,0 +1,1142 @@
+/*
+ * Copyright 2013, Google Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * *** This file is NOT a part of DexLib2 project. ***
+ *
+ * Tricky ways for converting MethodImplementation in DexFile into the corresponding
+ * one in DexBuilder.
+ *
+ * If you pass null as DexBuilder, this class behavior the same as
+ * what {@link org.jf.dexlib2.builder.MutableMethodImplementation} would do.
+ */
+
+package org.jf.dexlib2.builder;
+
+import com.google.common.base.Function;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+
+import org.jf.dexlib2.DebugItemType;
+import org.jf.dexlib2.Opcode;
+import org.jf.dexlib2.builder.debug.BuilderEndLocal;
+import org.jf.dexlib2.builder.debug.BuilderEpilogueBegin;
+import org.jf.dexlib2.builder.debug.BuilderLineNumber;
+import org.jf.dexlib2.builder.debug.BuilderPrologueEnd;
+import org.jf.dexlib2.builder.debug.BuilderRestartLocal;
+import org.jf.dexlib2.builder.debug.BuilderSetSourceFile;
+import org.jf.dexlib2.builder.debug.BuilderStartLocal;
+import org.jf.dexlib2.builder.instruction.BuilderArrayPayload;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction10t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction10x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction11n;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction11x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction12x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction20bc;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction20t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21ih;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21lh;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21s;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22b;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22s;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction23x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction25x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction30t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction31c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction31i;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction31t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction32x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction35c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction3rc;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction51l;
+import org.jf.dexlib2.builder.instruction.BuilderPackedSwitchPayload;
+import org.jf.dexlib2.builder.instruction.BuilderSparseSwitchPayload;
+import org.jf.dexlib2.iface.ExceptionHandler;
+import org.jf.dexlib2.iface.MethodImplementation;
+import org.jf.dexlib2.iface.TryBlock;
+import org.jf.dexlib2.iface.debug.DebugItem;
+import org.jf.dexlib2.iface.debug.EndLocal;
+import org.jf.dexlib2.iface.debug.LineNumber;
+import org.jf.dexlib2.iface.debug.RestartLocal;
+import org.jf.dexlib2.iface.debug.SetSourceFile;
+import org.jf.dexlib2.iface.debug.StartLocal;
+import org.jf.dexlib2.iface.instruction.Instruction;
+import org.jf.dexlib2.iface.instruction.SwitchElement;
+import org.jf.dexlib2.iface.instruction.formats.ArrayPayload;
+import org.jf.dexlib2.iface.instruction.formats.Instruction10t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction10x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction11n;
+import org.jf.dexlib2.iface.instruction.formats.Instruction11x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction12x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction20bc;
+import org.jf.dexlib2.iface.instruction.formats.Instruction20t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21ih;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21lh;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21s;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22b;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22s;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction23x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction25x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction30t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction31c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction31i;
+import org.jf.dexlib2.iface.instruction.formats.Instruction31t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction32x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction35c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction3rc;
+import org.jf.dexlib2.iface.instruction.formats.Instruction51l;
+import org.jf.dexlib2.iface.instruction.formats.PackedSwitchPayload;
+import org.jf.dexlib2.iface.instruction.formats.SparseSwitchPayload;
+import org.jf.dexlib2.iface.reference.Reference;
+import org.jf.dexlib2.iface.reference.StringReference;
+import org.jf.dexlib2.iface.reference.TypeReference;
+import org.jf.dexlib2.writer.builder.DexBuilder;
+import org.jf.util.ExceptionWithContext;
+
+import java.util.AbstractList;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+/**
+ * Created by tangyinsheng on 2016/10/9.
+ */
+public class BuilderMutableMethodImplementation implements MethodImplementation {
+    private final DexBuilder dexBuilder;
+    private final int registerCount;
+    private final ArrayList<MethodLocation> instructionList = Lists.newArrayList(new MethodLocation(null, 0, 0));
+    private final ArrayList<BuilderTryBlock> tryBlocks = Lists.newArrayList();
+    private boolean fixInstructions = true;
+
+    public BuilderMutableMethodImplementation(DexBuilder dexBuilder, @Nonnull MethodImplementation methodImplementation) {
+        this.dexBuilder = dexBuilder;
+
+        this.registerCount = methodImplementation.getRegisterCount();
+
+        int codeAddress = 0;
+        int index = 0;
+
+        for (Instruction instruction : methodImplementation.getInstructions()) {
+            codeAddress += instruction.getCodeUnits();
+            index++;
+
+            instructionList.add(new MethodLocation(null, codeAddress, index));
+        }
+
+        final int[] codeAddressToIndex = new int[codeAddress + 1];
+        Arrays.fill(codeAddressToIndex, -1);
+
+        for (int i = 0; i < instructionList.size(); i++) {
+            codeAddressToIndex[instructionList.get(i).codeAddress] = i;
+        }
+
+        List<Task> switchPayloadTasks = Lists.newArrayList();
+        index = 0;
+        for (final Instruction instruction : methodImplementation.getInstructions()) {
+            final MethodLocation location = instructionList.get(index);
+            final Opcode opcode = instruction.getOpcode();
+            if (opcode == Opcode.PACKED_SWITCH_PAYLOAD || opcode == Opcode.SPARSE_SWITCH_PAYLOAD) {
+                switchPayloadTasks.add(new Task() {
+                    @Override
+                    public void perform() {
+                        convertAndSetInstruction(location, codeAddressToIndex, instruction);
+                    }
+                });
+            } else {
+                convertAndSetInstruction(location, codeAddressToIndex, instruction);
+            }
+            index++;
+        }
+
+        // the switch payload instructions must be converted last, so that any switch statements that refer to them
+        // have created the referring labels that we look for
+        for (Task switchPayloadTask : switchPayloadTasks) {
+            switchPayloadTask.perform();
+        }
+
+        for (DebugItem debugItem : methodImplementation.getDebugItems()) {
+            int debugCodeAddress = debugItem.getCodeAddress();
+            int locationIndex = mapCodeAddressToIndex(codeAddressToIndex, debugCodeAddress);
+            MethodLocation debugLocation = instructionList.get(locationIndex);
+            BuilderDebugItem builderDebugItem = convertDebugItem(debugItem);
+            debugLocation.getDebugItems().add(builderDebugItem);
+            builderDebugItem.location = debugLocation;
+        }
+
+        for (TryBlock<? extends ExceptionHandler> tryBlock : methodImplementation.getTryBlocks()) {
+            Label startLabel = newLabel(codeAddressToIndex, tryBlock.getStartCodeAddress());
+            Label endLabel = newLabel(codeAddressToIndex, tryBlock.getStartCodeAddress() + tryBlock.getCodeUnitCount());
+
+            for (ExceptionHandler exceptionHandler : tryBlock.getExceptionHandlers()) {
+                tryBlocks.add(new BuilderTryBlock(startLabel, endLabel,
+                        exceptionHandler.getExceptionTypeReference(),
+                        newLabel(codeAddressToIndex, exceptionHandler.getHandlerCodeAddress())));
+            }
+        }
+    }
+
+    private interface Task {
+        void perform();
+    }
+
+    public BuilderMutableMethodImplementation(int registerCount) {
+        this.dexBuilder = null;
+        this.registerCount = registerCount;
+    }
+
+    @Override
+    public int getRegisterCount() {
+        return registerCount;
+    }
+
+    @Nonnull
+    public List<BuilderInstruction> getInstructions() {
+        if (fixInstructions) {
+            fixInstructions();
+        }
+
+        return new AbstractList<BuilderInstruction>() {
+            @Override
+            public BuilderInstruction get(int i) {
+                if (i >= size()) {
+                    throw new IndexOutOfBoundsException();
+                }
+                if (fixInstructions) {
+                    fixInstructions();
+                }
+                return instructionList.get(i).instruction;
+            }
+
+            @Override
+            public int size() {
+                if (fixInstructions) {
+                    fixInstructions();
+                }
+                // don't include the last MethodLocation, which always has a null instruction
+                return instructionList.size() - 1;
+            }
+        };
+    }
+
+    @Nonnull
+    @Override
+    public List<BuilderTryBlock> getTryBlocks() {
+        if (fixInstructions) {
+            fixInstructions();
+        }
+        return Collections.unmodifiableList(tryBlocks);
+    }
+
+    @Nonnull
+    @Override
+    public Iterable<? extends DebugItem> getDebugItems() {
+        if (fixInstructions) {
+            fixInstructions();
+        }
+        return Iterables.concat(
+                Iterables.transform(instructionList, new Function<MethodLocation, Iterable<? extends DebugItem>>() {
+                    @Nullable
+                    @Override
+                    public Iterable<? extends DebugItem> apply(@Nullable MethodLocation input) {
+                        assert input != null;
+                        if (fixInstructions) {
+                            throw new IllegalStateException("This iterator was invalidated by a change to" +
+                                    " this MutableMethodImplementation.");
+                        }
+                        return input.getDebugItems();
+                    }
+                }));
+    }
+
+    public void addCatch(@Nullable TypeReference type, @Nonnull Label from,
+                         @Nonnull Label to, @Nonnull Label handler) {
+        tryBlocks.add(new BuilderTryBlock(from, to, type, handler));
+    }
+
+    public void addCatch(@Nullable String type, @Nonnull Label from, @Nonnull Label to,
+                         @Nonnull Label handler) {
+        tryBlocks.add(new BuilderTryBlock(from, to, type, handler));
+    }
+
+    public void addCatch(@Nonnull Label from, @Nonnull Label to, @Nonnull Label handler) {
+        tryBlocks.add(new BuilderTryBlock(from, to, handler));
+    }
+
+    public void addInstruction(int index, BuilderInstruction instruction) {
+        // the end check here is intentially >= rather than >, because the list always includes an "empty"
+        // (null instruction) MethodLocation at the end. To add an instruction to the end of the list, the user would
+        // provide the index of this empty item, which would be size() - 1.
+        if (index >= instructionList.size()) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        if (index == instructionList.size() - 1) {
+            addInstruction(instruction);
+            return;
+        }
+        int codeAddress = instructionList.get(index).getCodeAddress();
+        MethodLocation newLoc = new MethodLocation(instruction, codeAddress, index);
+        instructionList.add(index, newLoc);
+        instruction.location = newLoc;
+
+        codeAddress += instruction.getCodeUnits();
+
+        for (int i = index + 1; i < instructionList.size(); i++) {
+            MethodLocation location = instructionList.get(i);
+            location.index++;
+            location.codeAddress = codeAddress;
+            if (location.instruction != null) {
+                codeAddress += location.instruction.getCodeUnits();
+            } else {
+                // only the last MethodLocation should have a null instruction
+                assert i == instructionList.size() - 1;
+            }
+        }
+
+        this.fixInstructions = true;
+    }
+
+    public void addInstruction(@Nonnull BuilderInstruction instruction) {
+        MethodLocation last = instructionList.get(instructionList.size() - 1);
+        last.instruction = instruction;
+        instruction.location = last;
+
+        int nextCodeAddress = last.codeAddress + instruction.getCodeUnits();
+        instructionList.add(new MethodLocation(null, nextCodeAddress, instructionList.size()));
+
+        this.fixInstructions = true;
+    }
+
+    public void replaceInstruction(int index, @Nonnull BuilderInstruction replacementInstruction) {
+        if (index >= instructionList.size() - 1) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        MethodLocation replaceLocation = instructionList.get(index);
+        replacementInstruction.location = replaceLocation;
+        BuilderInstruction old = replaceLocation.instruction;
+        assert old != null;
+        old.location = null;
+        replaceLocation.instruction = replacementInstruction;
+
+        // TODO: factor out index/address fix up loop
+        int codeAddress = replaceLocation.codeAddress + replaceLocation.instruction.getCodeUnits();
+        for (int i = index + 1; i < instructionList.size(); i++) {
+            MethodLocation location = instructionList.get(i);
+            location.codeAddress = codeAddress;
+
+            Instruction instruction = location.getInstruction();
+            if (instruction != null) {
+                codeAddress += instruction.getCodeUnits();
+            } else {
+                assert i == instructionList.size() - 1;
+            }
+        }
+
+        this.fixInstructions = true;
+    }
+
+    public void removeInstruction(int index) {
+        if (index >= instructionList.size() - 1) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        MethodLocation toRemove = instructionList.get(index);
+        toRemove.instruction = null;
+        MethodLocation next = instructionList.get(index + 1);
+        toRemove.mergeInto(next);
+
+        instructionList.remove(index);
+        int codeAddress = toRemove.codeAddress;
+        for (int i = index; i < instructionList.size(); i++) {
+            MethodLocation location = instructionList.get(i);
+            location.index = i;
+            location.codeAddress = codeAddress;
+
+            Instruction instruction = location.getInstruction();
+            if (instruction != null) {
+                codeAddress += instruction.getCodeUnits();
+            } else {
+                assert i == instructionList.size() - 1;
+            }
+        }
+
+        this.fixInstructions = true;
+    }
+
+    public void swapInstructions(int index1, int index2) {
+        if (index1 >= instructionList.size() - 1 || index2 >= instructionList.size() - 1) {
+            throw new IndexOutOfBoundsException();
+        }
+        MethodLocation first = instructionList.get(index1);
+        MethodLocation second = instructionList.get(index2);
+
+        // only the last MethodLocation may have a null instruction
+        assert first.instruction != null;
+        assert second.instruction != null;
+
+        first.instruction.location = second;
+        second.instruction.location = first;
+
+        {
+            BuilderInstruction tmp = second.instruction;
+            second.instruction = first.instruction;
+            first.instruction = tmp;
+        }
+
+        if (index2 < index1) {
+            int tmp = index2;
+            index2 = index1;
+            index1 = tmp;
+        }
+
+        int codeAddress = first.codeAddress + first.instruction.getCodeUnits();
+        for (int i = index1 + 1; i <= index2; i++) {
+            MethodLocation location = instructionList.get(i);
+            location.codeAddress = codeAddress;
+
+            Instruction instruction = location.instruction;
+            assert instruction != null;
+            codeAddress += location.instruction.getCodeUnits();
+        }
+
+        this.fixInstructions = true;
+    }
+
+    @Nullable
+    private BuilderInstruction getFirstNonNop(int startIndex) {
+
+        for (int i = startIndex; i < instructionList.size() - 1; i++) {
+            BuilderInstruction instruction = instructionList.get(i).instruction;
+            assert instruction != null;
+            if (instruction.getOpcode() != Opcode.NOP) {
+                return instruction;
+            }
+        }
+        return null;
+    }
+
+    private void fixInstructions() {
+        HashSet<MethodLocation> payloadLocations = Sets.newHashSet();
+
+        for (MethodLocation location : instructionList) {
+            BuilderInstruction instruction = location.instruction;
+            if (instruction != null) {
+                switch (instruction.getOpcode()) {
+                    case SPARSE_SWITCH:
+                    case PACKED_SWITCH: {
+                        MethodLocation targetLocation =
+                                ((BuilderOffsetInstruction) instruction).getTarget().getLocation();
+                        BuilderInstruction targetInstruction = targetLocation.instruction;
+                        if (targetInstruction == null) {
+                            throw new IllegalStateException(String.format("Switch instruction at address/index " +
+                                    "0x%x/%d points to the end of the method.", location.codeAddress, location.index));
+                        }
+
+                        if (targetInstruction.getOpcode() == Opcode.NOP) {
+                            targetInstruction = getFirstNonNop(targetLocation.index + 1);
+                        }
+                        if (targetInstruction == null || !(targetInstruction instanceof BuilderSwitchPayload)) {
+                            throw new IllegalStateException(String.format("Switch instruction at address/index " +
+                                            "0x%x/%d does not refer to a payload instruction.",
+                                    location.codeAddress, location.index));
+                        }
+                        if ((instruction.opcode == Opcode.PACKED_SWITCH &&
+                                targetInstruction.getOpcode() != Opcode.PACKED_SWITCH_PAYLOAD) ||
+                                (instruction.opcode == Opcode.SPARSE_SWITCH &&
+                                        targetInstruction.getOpcode() != Opcode.SPARSE_SWITCH_PAYLOAD)) {
+                            throw new IllegalStateException(String.format("Switch instruction at address/index " +
+                                            "0x%x/%d refers to the wrong type of payload instruction.",
+                                    location.codeAddress, location.index));
+                        }
+
+                        if (!payloadLocations.add(targetLocation)) {
+                            throw new IllegalStateException("Multiple switch instructions refer to the same payload. " +
+                                    "This is not currently supported. Please file a bug :)");
+                        }
+
+                        ((BuilderSwitchPayload) targetInstruction).referrer = location;
+                        break;
+                    }
+                }
+            }
+        }
+
+        boolean madeChanges;
+        do {
+            madeChanges = false;
+
+            for (int index = 0; index < instructionList.size(); index++) {
+                MethodLocation location = instructionList.get(index);
+                BuilderInstruction instruction = location.instruction;
+                if (instruction != null) {
+                    switch (instruction.getOpcode()) {
+                        case GOTO: {
+                            int offset = ((BuilderOffsetInstruction) instruction).internalGetCodeOffset();
+                            if (offset < Byte.MIN_VALUE || offset > Byte.MAX_VALUE) {
+                                BuilderOffsetInstruction replacement;
+                                if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {
+                                    replacement = new BuilderInstruction30t(Opcode.GOTO_32,
+                                            ((BuilderOffsetInstruction) instruction).getTarget());
+                                } else {
+                                    replacement = new BuilderInstruction20t(Opcode.GOTO_16,
+                                            ((BuilderOffsetInstruction) instruction).getTarget());
+                                }
+                                replaceInstruction(location.index, replacement);
+                                madeChanges = true;
+                            }
+                            break;
+                        }
+                        case GOTO_16: {
+                            int offset = ((BuilderOffsetInstruction) instruction).internalGetCodeOffset();
+                            if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {
+                                BuilderOffsetInstruction replacement = new BuilderInstruction30t(Opcode.GOTO_32,
+                                        ((BuilderOffsetInstruction) instruction).getTarget());
+                                replaceInstruction(location.index, replacement);
+                                madeChanges = true;
+                            }
+                            break;
+                        }
+                        case SPARSE_SWITCH_PAYLOAD:
+                        case PACKED_SWITCH_PAYLOAD:
+                            if (((BuilderSwitchPayload) instruction).referrer == null) {
+                                // if the switch payload isn't referenced, just remove it
+                                removeInstruction(index);
+                                index--;
+                                madeChanges = true;
+                                break;
+                            }
+                            // intentional fall-through
+                        case ARRAY_PAYLOAD: {
+                            if ((location.codeAddress & 0x01) != 0) {
+                                int previousIndex = location.index - 1;
+                                MethodLocation previousLocation = instructionList.get(previousIndex);
+                                Instruction previousInstruction = previousLocation.instruction;
+                                assert previousInstruction != null;
+                                if (previousInstruction.getOpcode() == Opcode.NOP) {
+                                    removeInstruction(previousIndex);
+                                    index--;
+                                } else {
+                                    addInstruction(location.index, new BuilderInstruction10x(Opcode.NOP));
+                                    index++;
+                                }
+                                madeChanges = true;
+                            }
+                            break;
+                        }
+                    }
+                }
+            }
+        } while (madeChanges);
+
+        fixInstructions = false;
+    }
+
+    private int mapCodeAddressToIndex(@Nonnull int[] codeAddressToIndex, int codeAddress) {
+        int index;
+        do {
+            index = codeAddressToIndex[codeAddress];
+            if (index < 0) {
+                codeAddress--;
+            } else {
+                return index;
+            }
+        } while (true);
+    }
+
+    private int mapCodeAddressToIndex(int codeAddress) {
+        float avgCodeUnitsPerInstruction = 1.9f;
+
+        int index = (int) (codeAddress / avgCodeUnitsPerInstruction);
+        if (index >= instructionList.size()) {
+            index = instructionList.size() - 1;
+        }
+
+        MethodLocation guessedLocation = instructionList.get(index);
+
+        if (guessedLocation.codeAddress == codeAddress) {
+            return index;
+        } else if (guessedLocation.codeAddress > codeAddress) {
+            do {
+                index--;
+            } while (instructionList.get(index).codeAddress > codeAddress);
+            return index;
+        } else {
+            do {
+                index++;
+            }
+            while (index < instructionList.size() && instructionList.get(index).codeAddress <= codeAddress);
+            return index - 1;
+        }
+    }
+
+    @Nonnull
+    public Label newLabelForAddress(int codeAddress) {
+        if (codeAddress < 0 || codeAddress > instructionList.get(instructionList.size() - 1).codeAddress) {
+            throw new IndexOutOfBoundsException(String.format("codeAddress %d out of bounds", codeAddress));
+        }
+        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddress));
+        return referent.addNewLabel();
+    }
+
+    @Nonnull
+    public Label newLabelForIndex(int instructionIndex) {
+        if (instructionIndex < 0 || instructionIndex >= instructionList.size()) {
+            throw new IndexOutOfBoundsException(String.format("instruction index %d out of bounds", instructionIndex));
+        }
+        MethodLocation referent = instructionList.get(instructionIndex);
+        return referent.addNewLabel();
+    }
+
+    @Nonnull
+    private Label newLabel(@Nonnull int[] codeAddressToIndex, int codeAddress) {
+        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddressToIndex, codeAddress));
+        return referent.addNewLabel();
+    }
+
+    private static class SwitchPayloadReferenceLabel extends Label {
+        @Nonnull
+        public MethodLocation switchLocation;
+    }
+
+    @Nonnull
+    public Label newSwitchPayloadReferenceLabel(@Nonnull MethodLocation switchLocation,
+                                                @Nonnull int[] codeAddressToIndex, int codeAddress) {
+        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddressToIndex, codeAddress));
+        SwitchPayloadReferenceLabel label = new SwitchPayloadReferenceLabel();
+        label.switchLocation = switchLocation;
+        referent.getLabels().add(label);
+        return label;
+    }
+
+    private void setInstruction(@Nonnull MethodLocation location, @Nonnull BuilderInstruction instruction) {
+        location.instruction = instruction;
+        instruction.location = location;
+    }
+
+    private void convertAndSetInstruction(@Nonnull MethodLocation location, int[] codeAddressToIndex,
+                                          @Nonnull Instruction instruction) {
+        switch (instruction.getOpcode().format) {
+            case Format10t:
+                setInstruction(location, newBuilderInstruction10t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction10t) instruction));
+                return;
+            case Format10x:
+                setInstruction(location, newBuilderInstruction10x((Instruction10x) instruction));
+                return;
+            case Format11n:
+                setInstruction(location, newBuilderInstruction11n((Instruction11n) instruction));
+                return;
+            case Format11x:
+                setInstruction(location, newBuilderInstruction11x((Instruction11x) instruction));
+                return;
+            case Format12x:
+                setInstruction(location, newBuilderInstruction12x((Instruction12x) instruction));
+                return;
+            case Format20bc:
+                setInstruction(location, newBuilderInstruction20bc((Instruction20bc) instruction));
+                return;
+            case Format20t:
+                setInstruction(location, newBuilderInstruction20t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction20t) instruction));
+                return;
+            case Format21c:
+                setInstruction(location, newBuilderInstruction21c((Instruction21c) instruction));
+                return;
+            case Format21ih:
+                setInstruction(location, newBuilderInstruction21ih((Instruction21ih) instruction));
+                return;
+            case Format21lh:
+                setInstruction(location, newBuilderInstruction21lh((Instruction21lh) instruction));
+                return;
+            case Format21s:
+                setInstruction(location, newBuilderInstruction21s((Instruction21s) instruction));
+                return;
+            case Format21t:
+                setInstruction(location, newBuilderInstruction21t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction21t) instruction));
+                return;
+            case Format22b:
+                setInstruction(location, newBuilderInstruction22b((Instruction22b) instruction));
+                return;
+            case Format22c:
+                setInstruction(location, newBuilderInstruction22c((Instruction22c) instruction));
+                return;
+            case Format22s:
+                setInstruction(location, newBuilderInstruction22s((Instruction22s) instruction));
+                return;
+            case Format22t:
+                setInstruction(location, newBuilderInstruction22t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction22t) instruction));
+                return;
+            case Format22x:
+                setInstruction(location, newBuilderInstruction22x((Instruction22x) instruction));
+                return;
+            case Format23x:
+                setInstruction(location, newBuilderInstruction23x((Instruction23x) instruction));
+                return;
+            case Format25x:
+                setInstruction(location, newBuilderInstruction25x((Instruction25x) instruction));
+                return;
+            case Format30t:
+                setInstruction(location, newBuilderInstruction30t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction30t) instruction));
+                return;
+            case Format31c:
+                setInstruction(location, newBuilderInstruction31c((Instruction31c) instruction));
+                return;
+            case Format31i:
+                setInstruction(location, newBuilderInstruction31i((Instruction31i) instruction));
+                return;
+            case Format31t:
+                setInstruction(location, newBuilderInstruction31t(location, codeAddressToIndex,
+                        (Instruction31t) instruction));
+                return;
+            case Format32x:
+                setInstruction(location, newBuilderInstruction32x((Instruction32x) instruction));
+                return;
+            case Format35c:
+                setInstruction(location, newBuilderInstruction35c((Instruction35c) instruction));
+                return;
+            case Format3rc:
+                setInstruction(location, newBuilderInstruction3rc((Instruction3rc) instruction));
+                return;
+            case Format51l:
+                setInstruction(location, newBuilderInstruction51l((Instruction51l) instruction));
+                return;
+            case PackedSwitchPayload:
+                setInstruction(location,
+                        newBuilderPackedSwitchPayload(location, codeAddressToIndex, (PackedSwitchPayload) instruction));
+                return;
+            case SparseSwitchPayload:
+                setInstruction(location,
+                        newBuilderSparseSwitchPayload(location, codeAddressToIndex, (SparseSwitchPayload) instruction));
+                return;
+            case ArrayPayload:
+                setInstruction(location, newBuilderArrayPayload((ArrayPayload) instruction));
+                return;
+            default:
+                throw new ExceptionWithContext("Instruction format %s not supported", instruction.getOpcode().format);
+        }
+    }
+
+    @Nonnull
+    private BuilderInstruction10t newBuilderInstruction10t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction10t instruction) {
+        return new BuilderInstruction10t(
+                instruction.getOpcode(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction10x newBuilderInstruction10x(@Nonnull Instruction10x instruction) {
+        return new BuilderInstruction10x(
+                instruction.getOpcode());
+    }
+
+    @Nonnull
+    private BuilderInstruction11n newBuilderInstruction11n(@Nonnull Instruction11n instruction) {
+        return new BuilderInstruction11n(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction11x newBuilderInstruction11x(@Nonnull Instruction11x instruction) {
+        return new BuilderInstruction11x(
+                instruction.getOpcode(),
+                instruction.getRegisterA());
+    }
+
+    @Nonnull
+    private BuilderInstruction12x newBuilderInstruction12x(@Nonnull Instruction12x instruction) {
+        return new BuilderInstruction12x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB());
+    }
+
+    @Nonnull
+    private BuilderInstruction20bc newBuilderInstruction20bc(@Nonnull Instruction20bc instruction) {
+        return new BuilderInstruction20bc(
+                instruction.getOpcode(),
+                instruction.getVerificationError(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction20t newBuilderInstruction20t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction20t instruction) {
+        return new BuilderInstruction20t(
+                instruction.getOpcode(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction21c newBuilderInstruction21c(@Nonnull Instruction21c instruction) {
+        return new BuilderInstruction21c(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction21ih newBuilderInstruction21ih(@Nonnull Instruction21ih instruction) {
+        return new BuilderInstruction21ih(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction21lh newBuilderInstruction21lh(@Nonnull Instruction21lh instruction) {
+        return new BuilderInstruction21lh(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getWideLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction21s newBuilderInstruction21s(@Nonnull Instruction21s instruction) {
+        return new BuilderInstruction21s(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction21t newBuilderInstruction21t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction21t instruction) {
+        return new BuilderInstruction21t(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction22b newBuilderInstruction22b(@Nonnull Instruction22b instruction) {
+        return new BuilderInstruction22b(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction22c newBuilderInstruction22c(@Nonnull Instruction22c instruction) {
+        return new BuilderInstruction22c(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction22s newBuilderInstruction22s(@Nonnull Instruction22s instruction) {
+        return new BuilderInstruction22s(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction22t newBuilderInstruction22t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction22t instruction) {
+        return new BuilderInstruction22t(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction22x newBuilderInstruction22x(@Nonnull Instruction22x instruction) {
+        return new BuilderInstruction22x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB());
+    }
+
+    @Nonnull
+    private BuilderInstruction23x newBuilderInstruction23x(@Nonnull Instruction23x instruction) {
+        return new BuilderInstruction23x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                instruction.getRegisterC());
+    }
+
+    @Nonnull
+    private BuilderInstruction30t newBuilderInstruction30t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction30t instruction) {
+        return new BuilderInstruction30t(
+                instruction.getOpcode(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction31c newBuilderInstruction31c(@Nonnull Instruction31c instruction) {
+        return new BuilderInstruction31c(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction31i newBuilderInstruction31i(@Nonnull Instruction31i instruction) {
+        return new BuilderInstruction31i(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction31t newBuilderInstruction31t(@Nonnull MethodLocation location, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction31t instruction) {
+        int codeAddress = location.getCodeAddress();
+        Label newLabel;
+        if (instruction.getOpcode() != Opcode.FILL_ARRAY_DATA) {
+            // if it's a sparse switch or packed switch
+            newLabel = newSwitchPayloadReferenceLabel(location, codeAddressToIndex, codeAddress + instruction.getCodeOffset());
+        } else {
+            newLabel = newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset());
+        }
+        return new BuilderInstruction31t(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                newLabel);
+    }
+
+    @Nonnull
+    private BuilderInstruction32x newBuilderInstruction32x(@Nonnull Instruction32x instruction) {
+        return new BuilderInstruction32x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB());
+    }
+
+    @Nonnull
+    private BuilderInstruction35c newBuilderInstruction35c(@Nonnull Instruction35c instruction) {
+        return new BuilderInstruction35c(
+                instruction.getOpcode(),
+                instruction.getRegisterCount(),
+                instruction.getRegisterC(),
+                instruction.getRegisterD(),
+                instruction.getRegisterE(),
+                instruction.getRegisterF(),
+                instruction.getRegisterG(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction25x newBuilderInstruction25x(@Nonnull Instruction25x instruction) {
+        return new BuilderInstruction25x(
+                instruction.getOpcode(),
+                instruction.getParameterRegisterCount(),
+                instruction.getRegisterFixedC(),
+                instruction.getRegisterParameterD(),
+                instruction.getRegisterParameterE(),
+                instruction.getRegisterParameterF(),
+                instruction.getRegisterParameterG());
+    }
+
+    @Nonnull
+    private BuilderInstruction3rc newBuilderInstruction3rc(@Nonnull Instruction3rc instruction) {
+        return new BuilderInstruction3rc(
+                instruction.getOpcode(),
+                instruction.getStartRegister(),
+                instruction.getRegisterCount(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction51l newBuilderInstruction51l(@Nonnull Instruction51l instruction) {
+        return new BuilderInstruction51l(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getWideLiteral());
+    }
+
+    @Nullable
+    private MethodLocation findSwitchForPayload(@Nonnull MethodLocation payloadLocation) {
+        MethodLocation location = payloadLocation;
+        MethodLocation switchLocation = null;
+        do {
+            for (Label label : location.getLabels()) {
+                if (label instanceof SwitchPayloadReferenceLabel) {
+                    if (switchLocation != null) {
+                        throw new IllegalStateException("Multiple switch instructions refer to the same payload. " +
+                                "This is not currently supported. Please file a bug :)");
+                    }
+                    switchLocation = ((SwitchPayloadReferenceLabel) label).switchLocation;
+                }
+            }
+
+            // A switch instruction can refer to the payload instruction itself, or to a nop before the payload
+            // instruction.
+            // We need to search for all occurrences of a switch reference, so we can detect when multiple switch
+            // statements refer to the same payload
+            // TODO: confirm that it could refer to the first NOP in a series of NOPs preceding the payload
+            if (location.index == 0) {
+                return switchLocation;
+            }
+            location = instructionList.get(location.index - 1);
+            if (location.instruction == null || location.instruction.getOpcode() != Opcode.NOP) {
+                return switchLocation;
+            }
+        } while (true);
+    }
+
+    @Nonnull
+    private BuilderPackedSwitchPayload newBuilderPackedSwitchPayload(@Nonnull MethodLocation location,
+                                                                     @Nonnull int[] codeAddressToIndex,
+                                                                     @Nonnull PackedSwitchPayload instruction) {
+        List<? extends SwitchElement> switchElements = instruction.getSwitchElements();
+        if (switchElements.size() == 0) {
+            return new BuilderPackedSwitchPayload(0, null);
+        }
+
+        MethodLocation switchLocation = findSwitchForPayload(location);
+        int baseAddress;
+        if (switchLocation == null) {
+            baseAddress = 0;
+        } else {
+            baseAddress = switchLocation.codeAddress;
+        }
+
+        List<Label> labels = Lists.newArrayList();
+        for (SwitchElement element : switchElements) {
+            labels.add(newLabel(codeAddressToIndex, element.getOffset() + baseAddress));
+        }
+
+        return new BuilderPackedSwitchPayload(switchElements.get(0).getKey(), labels);
+    }
+
+    @Nonnull
+    private BuilderSparseSwitchPayload newBuilderSparseSwitchPayload(@Nonnull MethodLocation location,
+                                                                     @Nonnull int[] codeAddressToIndex,
+                                                                     @Nonnull SparseSwitchPayload instruction) {
+        List<? extends SwitchElement> switchElements = instruction.getSwitchElements();
+        if (switchElements.size() == 0) {
+            return new BuilderSparseSwitchPayload(null);
+        }
+
+        MethodLocation switchLocation = findSwitchForPayload(location);
+        int baseAddress;
+        if (switchLocation == null) {
+            baseAddress = 0;
+        } else {
+            baseAddress = switchLocation.codeAddress;
+        }
+
+        List<SwitchLabelElement> labelElements = Lists.newArrayList();
+        for (SwitchElement element : switchElements) {
+            labelElements.add(new SwitchLabelElement(element.getKey(),
+                    newLabel(codeAddressToIndex, element.getOffset() + baseAddress)));
+        }
+
+        return new BuilderSparseSwitchPayload(labelElements);
+    }
+
+    @Nonnull
+    private BuilderArrayPayload newBuilderArrayPayload(@Nonnull ArrayPayload instruction) {
+        return new BuilderArrayPayload(instruction.getElementWidth(), instruction.getArrayElements());
+    }
+
+    private Reference convertReference(@Nonnull Reference reference) {
+        if (reference != null && this.dexBuilder != null) {
+            return this.dexBuilder.internReference(reference);
+        } else {
+            return reference;
+        }
+    }
+
+    @Nonnull
+    private BuilderDebugItem convertDebugItem(@Nonnull DebugItem debugItem) {
+        switch (debugItem.getDebugItemType()) {
+            case DebugItemType.START_LOCAL: {
+                StartLocal startLocal = (StartLocal) debugItem;
+                return new BuilderStartLocal(startLocal.getRegister(),
+                        (StringReference) convertReference(startLocal.getNameReference()),
+                        (TypeReference) convertReference(startLocal.getTypeReference()),
+                        (StringReference) convertReference(startLocal.getSignatureReference()));
+            }
+            case DebugItemType.END_LOCAL: {
+                EndLocal endLocal = (EndLocal) debugItem;
+                return new BuilderEndLocal(endLocal.getRegister());
+            }
+            case DebugItemType.RESTART_LOCAL: {
+                RestartLocal restartLocal = (RestartLocal) debugItem;
+                return new BuilderRestartLocal(restartLocal.getRegister());
+            }
+            case DebugItemType.PROLOGUE_END:
+                return new BuilderPrologueEnd();
+            case DebugItemType.EPILOGUE_BEGIN:
+                return new BuilderEpilogueBegin();
+            case DebugItemType.LINE_NUMBER: {
+                LineNumber lineNumber = (LineNumber) debugItem;
+                return new BuilderLineNumber(lineNumber.getLineNumber());
+            }
+            case DebugItemType.SET_SOURCE_FILE: {
+                SetSourceFile setSourceFile = (SetSourceFile) debugItem;
+                return new BuilderSetSourceFile(
+                        (StringReference) convertReference(setSourceFile.getSourceFileReference())
+                );
+            }
+            default:
+                throw new ExceptionWithContext("Invalid debug item type: " + debugItem.getDebugItemType());
+        }
+    }
+}
+
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatcherLogger.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatcherLogger.java
index 3ee24910..76b4ae65 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatcherLogger.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatcherLogger.java
@@ -7,6 +7,10 @@
 public final class DexPatcherLogger {
     private IDexPatcherLogger loggerImpl = null;
 
+    public IDexPatcherLogger getLoggerImpl() {
+        return this.loggerImpl;
+    }
+
     public void setLoggerImpl(IDexPatcherLogger dexPatcherLogger) {
         this.loggerImpl = dexPatcherLogger;
     }
diff --git a/tinker-sample-android/app/build.gradle b/tinker-sample-android/app/build.gradle
index e55ca463..27540c8c 100644
--- a/tinker-sample-android/app/build.gradle
+++ b/tinker-sample-android/app/build.gradle
@@ -244,6 +244,18 @@ if (buildWithTinker()) {
          * case 5: resources.arsc has changed, but we don't use applyResourceMapping to build
          */
         ignoreWarning = false
+
+        /**
+         * optionaldefault 'false'
+         * if usePreGeneratedPatchDex is true, tinker framework will insert auxiliary instruction
+         * when compiling base package using assemble{Debug/Release} task to prevent class
+         * pre-verified issue in dvm. Besides, a real dex file contains necessary class
+         * will be generated and packed into patch package instead of any patch info files.
+         *
+         * Use this mode if you have to use any dex encryption solutions.
+         */
+        usePreGeneratedPatchDex = true
+
         /**
          * optionaldefault 'true'
          * whether sign the patch file
