diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 13bc8569..29ace9c5 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,8 +1,8 @@
 # Contributing to Tinker
 Welcome to [report Issues](https://github.com/Tencent/tinker/issues) or [pull requests](https://github.com/Tencent/tinker/pulls). It's recommended to read the following Contributing Guide first before contributing. 
 
-## issues
-We use Git Issues to track public bugs and feature requests.
+## Issues
+We use Github Issues to track public bugs and feature requests.
 
 ### Search Known Issues First
 Please search the existing issues to see if any similar issue or feature request has already been filed. You should make sure your issue isn't redundant.
@@ -11,24 +11,24 @@ Please search the existing issues to see if any similar issue or feature request
 If you open an issue, the more information the better. Such as detailed description, screenshot or video of your problem, logcat or code blocks for your crash.
 
 ## Pull Requests
-We strongly welcome your pull request to make tinker better. 
+We strongly welcome your pull request to make Tinker better. 
 
 ### Branch Management
-There are three main branch here:
+There are three main branches here:
 
 1. `master` branch.
-	1. It is the latest (pre-)release branch. We use `master` for tag, with version number `1.1.0`, `1.2.0`, `1.3.0`...
+	1. It is the latest (pre-)release branch. We use `master` for tags, with version number `1.1.0`, `1.2.0`, `1.3.0`...
 	2. **Don't submit any PR on `master` branch.**
 2. `dev` branch. 
-	1. It is our stable developing branch. After full testing, `dev` will publish to `master` branch for the next release.
+	1. It is our stable developing branch. After full testing, `dev` will be merged to `master` branch for the next release.
 	2. **You are recommended to submit bugfix or feature PR on `dev` branch.**
 3. `hotfix` branch. 
 	1. It is the latest tag version for hot fix. If we accept your pull request, we may just tag with version number `1.1.1`, `1.2.3`.
 	2. **Only submit urgent PR on `hotfix` branch for next specific release.**
 
-Normal bugfix or feature request should submit on `dev` branch. After full testing, we will merge them on `master` branch for the next release. 
+Normal bugfix or feature request should be submitted to `dev` branch. After full testing, we will merge them to `master` branch for the next release. 
 
-If you have some urgent bugfix on a published version, but the `master` branch have already far away with the latest tag version, you can submit a PR on hotfix. And it will be cherry picked to `dev` branch if it is possible.
+If you have some urgent bugfixes on a published version, but the `master` branch have already far away with the latest tag version, you can submit a PR on hotfix. And it will be cherry picked to `dev` branch if it is possible.
 
 ```
 master
diff --git a/README.md b/README.md
index d73604f0..27a8f89d 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,8 @@
 ## Tinker
 [![license](http://img.shields.io/badge/license-BSD3-brightgreen.svg?style=flat)](https://github.com/Tencent/tinker/blob/master/LICENSE)
+[![Release Version](https://img.shields.io/badge/release-1.7.7-red.svg)](https://github.com/Tencent/tinker/releases) 
+[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/Tencent/tinker/pulls)
+[![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.7.7-red.svg)](https://github.com/Tencent/tinker/wiki)
 
 Tinker is a hot-fix solution library for Android, it supports dex, library and resources update without reinstalling apk.
 
@@ -11,7 +14,7 @@ Add tinker-gradle-plugin as a dependency in your main `build.gradle` in the root
 ```gradle
 buildscript {
     dependencies {
-        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.6.0')
+        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.7')
     }
 }
 ```
@@ -21,9 +24,9 @@ Then you need to "apply" the plugin and add dependencies by adding the following
 ```gradle
 dependencies {
     //optional, help to generate the final application 
-    compile('com.tencent.tinker:tinker-android-anno:1.6.0')
+    provided('com.tencent.tinker:tinker-android-anno:1.7.7')
     //tinker's main Android lib
-    compile('com.tencent.tinker:tinker-android-lib:1.6.0') 
+    compile('com.tencent.tinker:tinker-android-lib:1.7.7') 
 }
 ...
 ...
@@ -34,7 +37,7 @@ If your app has a class that subclasses android.app.Application, then you need t
 
 ```java
 -public class YourApplication extends Application {
-+public class SampleApplicationLike extends DefaultApplicationLike
++public class SampleApplicationLike extends DefaultApplicationLike {
 ```
 
 Now you should change your `Application` class, make it a subclass of [TinkerApplication](https://github.com/Tencent/tinker/blob/master/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java). As you can see from its API, it is an abstract class that does not have a default constructor, so you must define a no-arg constructor:
@@ -48,7 +51,7 @@ public class SampleApplication extends TinkerApplication {
         ShareConstants.TINKER_ENABLE_ALL,
         // This is passed as a string so the shell application does not
         // have a binary dependency on your ApplicationLifeCycle class. 
-        "tinker.sample.android.SampleApplicationLike");
+        "tinker.sample.android.app.SampleApplicationLike");
     }  
 }
 ```
@@ -68,6 +71,13 @@ For proguard, we have already made the proguard config automatic, and tinker wil
 
 For more tinker configurations, learn more at the sample [app/build.gradle](https://github.com/Tencent/tinker/blob/master/tinker-sample-android/app/build.gradle).
 
+## Known Issues
+There are some issues which Tinker can't dynamic update.
+
+1. Can't update AndroidManifest.xml, such as add Android Component.
+2. Do not support some Samsung models with os version android-21.
+3. Due to Google Play Developer Distribution Agreement, we can't dynamic update our apk.
+
 ## Support
 Any problem?
 
diff --git a/build.gradle b/build.gradle
index c0041cfa..41297d17 100644
--- a/build.gradle
+++ b/build.gradle
@@ -5,8 +5,9 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.1.0'
+        classpath 'com.android.tools.build:gradle:2.2.0'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
+        classpath "com.github.dcendents:android-maven-gradle-plugin:1.4.1"
     }
 }
 
@@ -20,21 +21,6 @@ allprojects {
         enabled = false
         options.setEncoding('UTF-8')
     }
-
-    apply plugin: 'checkstyle'
-
-    checkstyle {
-        configFile rootProject.file('checkstyle.xml')
-        toolVersion '6.19'
-        ignoreFailures false
-        showViolations true
-    }
-
-    task('checkstyle', type: Checkstyle) {
-        source 'src/main/java'
-        include '**/*.java'
-        classpath = files()
-    }
 }
 
 ext {
diff --git a/findbugs-exclude.xml b/findbugs-exclude.xml
new file mode 100644
index 00000000..e3c7c348
--- /dev/null
+++ b/findbugs-exclude.xml
@@ -0,0 +1,9 @@
+<FindBugsFilter>
+
+    <Match>
+        <Class name="~.*R\$.*" />
+    </Match>
+    <Match>
+        <Class name="~.*Manifest\$.*" />
+    </Match>
+</FindBugsFilter>
\ No newline at end of file
diff --git a/gradle.properties b/gradle.properties
index 457f9684..2691a69d 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,5 +16,5 @@
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
-VERSION_NAME_PREFIX=1.6.0
+VERSION_NAME_PREFIX=1.7.7
 VERSION_NAME_SUFFIX=
\ No newline at end of file
diff --git a/gradle/android-artifacts.gradle b/gradle/android-artifacts.gradle
index f240c22f..cd4ded81 100644
--- a/gradle/android-artifacts.gradle
+++ b/gradle/android-artifacts.gradle
@@ -1,4 +1,47 @@
 apply plugin: 'maven-publish'
+apply plugin: 'com.github.dcendents.android-maven'
+
+android {
+    compileOptions {
+        sourceCompatibility rootProject.ext.javaVersion
+        targetCompatibility rootProject.ext.javaVersion
+    }
+}
+version = version
+group = GROUP
+
+install {
+    repositories.mavenInstaller {
+        // This generates POM.xml with proper parameters
+        pom.project {
+            name POM_NAME
+            artifactId POM_ARTIFACT_ID
+            packaging POM_PACKAGING
+            description POM_DESCRIPTION
+            url POM_URL
+
+            scm {
+                url POM_SCM_URL
+            }
+
+            licenses {
+                license {
+                    name POM_LICENCE_NAME
+                    url POM_LICENCE_URL
+                    Distribution POM_LICENCE_DIST
+                }
+            }
+
+            developers {
+                developer {
+                    id POM_DEVELOPER_ID
+                    name POM_DEVELOPER_NAME
+                }
+            }
+        }
+    }
+}
+
 
 task androidJavadocs(type: Javadoc) {
     source = android.sourceSets.main.java.srcDirs
@@ -44,6 +87,8 @@ publishing {
     }
 }
 
-task buildAndPublishLocalMaven(dependsOn: ['build', 'publishTinkerPatchPublicationToMavenLocal']) {}
-//depend checkstyle
-project.tasks.getByName("check").dependsOn tasks.getByName("checkstyle")
+task buildAndPublishTinkerToLocalMaven(dependsOn: ['build', 'publishTinkerPatchPublicationToMavenLocal']) {
+    group = 'tinker'
+}
+
+apply from: rootProject.file('gradle/check.gradle')
\ No newline at end of file
diff --git a/gradle/check.gradle b/gradle/check.gradle
new file mode 100644
index 00000000..4205d8b1
--- /dev/null
+++ b/gradle/check.gradle
@@ -0,0 +1,74 @@
+apply plugin: 'checkstyle'
+
+
+checkstyle {
+    configFile rootProject.file('checkstyle.xml')
+    toolVersion '6.19'
+    ignoreFailures false
+    showViolations true
+}
+
+task('checkstyle', type: Checkstyle) {
+    source 'src/main/java'
+    include '**/*.java'
+    classpath = files()
+}
+
+check.dependsOn('checkstyle')
+
+
+//apply plugin: 'pmd'
+//
+//pmd {
+//    toolVersion '5.4.0'
+//}
+//
+//task pmd(type: Pmd) {
+//    targetJdk = TargetJdk.VERSION_1_7
+//
+//    description 'Run pmd'
+//    group 'verification'
+//
+//    // If ruleSets is not empty, it seems to contain some
+//    // defaults which override rules in the ruleset file...
+//    ruleSets = []
+//    ruleSetFiles = rootProject.files('pmd-ruleset.xml')
+//    source = fileTree('src/main/java')
+//    ignoreFailures = false
+//
+//    reports {
+//        xml.enabled = false
+//        html.enabled = true
+//    }
+//}
+//
+//check.dependsOn('pmd')
+
+//apply plugin: 'findbugs'
+//
+//def classTree = 'build/intermediates/classes/debug'
+//
+//if (project.plugins.hasPlugin('java')) {
+//    classTree = 'build/classes'
+//}
+//task findbugs(type: FindBugs) {
+//
+//    description 'Run findbugs'
+//    group 'verification'
+//
+//    classes = fileTree(classTree)
+//    source = fileTree('src/main/java/')
+//    classpath = files()
+//
+//    effort = 'default'
+//
+//    excludeFilter = rootProject.file("findbugs-exclude.xml")
+//
+//    reports {
+//        xml.enabled = false
+//        html.enabled = true
+//    }
+//    ignoreFailures = true
+//}
+
+//check.dependsOn('findbugs')
\ No newline at end of file
diff --git a/gradle/gradle-mvn-push.gradle b/gradle/gradle-mvn-push.gradle
index 9e795143..66196e32 100644
--- a/gradle/gradle-mvn-push.gradle
+++ b/gradle/gradle-mvn-push.gradle
@@ -125,14 +125,10 @@ task buildAndPublishRepo(dependsOn: ['build', 'uploadArchives']) {
     }
 }
 
-//depend checkstyle
-tasks.getByName("uploadArchives").dependsOn tasks.getByName("checkstyle")
-tasks.getByName("bintrayUpload").dependsOn tasks.getByName("checkstyle")
-
 tasks.getByName("bintrayUpload") {
     it.doFirst {
         if (!isReleaseBuild()) {
             throw new GradleException("bintrayUpload only support release version")
         }
     }
-}
\ No newline at end of file
+}
diff --git a/gradle/java-artifacts.gradle b/gradle/java-artifacts.gradle
index 0bbd9769..9b204192 100644
--- a/gradle/java-artifacts.gradle
+++ b/gradle/java-artifacts.gradle
@@ -1,5 +1,8 @@
 apply plugin: 'maven-publish'
 
+sourceCompatibility = rootProject.ext.javaVersion
+targetCompatibility = rootProject.ext.javaVersion
+
 task sourcesJar(type: Jar) {
     from sourceSets.main.java.srcDirs
     classifier = 'sources'
@@ -36,7 +39,8 @@ publishing {
     }
 }
 
-task buildAndPublishLocalMaven(dependsOn: ['build', 'publishTinkerPatchPublicationToMavenLocal']) {}
+task buildAndPublishTinkerToLocalMaven(dependsOn: ['build', 'publishTinkerPatchPublicationToMavenLocal']) {
+    group = 'tinker'
+}
 
-//depend checkstyle
-project.tasks.getByName("check").dependsOn tasks.getByName("checkstyle")
\ No newline at end of file
+apply from: rootProject.file('gradle/check.gradle')
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 7d05de32..dbdc05d2 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.11-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
diff --git a/pmd-ruleset.xml b/pmd-ruleset.xml
new file mode 100644
index 00000000..ca65331c
--- /dev/null
+++ b/pmd-ruleset.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<ruleset name="PMD.rul" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">
+
+    <description>This ruleset was created from PMD.rul</description>
+
+    <rule ref="rulesets/java/basic.xml">
+        <exclude name="AvoidBranchingStatementAsLastInLoop"/>
+    </rule>
+    <rule ref="rulesets/java/braces.xml"/>
+    <rule ref="rulesets/java/strings.xml">
+        <!-- TODO: This warns about annotations, apparently fixed in a later version. -->
+        <exclude name="AvoidDuplicateLiterals"/>
+    </rule>
+    <rule ref="rulesets/java/unusedcode.xml"/>
+
+    <rule ref="rulesets/java/design.xml">
+        <exclude name="ConfusingTernary"/>
+        <exclude name="EmptyMethodInAbstractClassShouldBeAbstract"/>
+        <exclude name="AvoidSynchronizedAtMethodLevel"/>
+
+        <!-- This check breaks on double checked locking which is safe in Java 6/7 -->
+        <exclude name="NonThreadSafeSingleton"/>
+        <!-- This check breaks the builder pattern, I didn't find the solution-->
+        <exclude name="AccessorClassGeneration"/>
+        <!-- TODO: Fix these -->
+        <exclude name="AvoidReassigningParameters"/>
+        <exclude name="GodClass"/>
+
+    </rule>
+
+    <rule ref="rulesets/java/design.xml/AvoidDeeplyNestedIfStmts">
+        <properties>
+            <property name="problemDepth" value="5"/>
+        </properties>
+    </rule>
+
+    <rule message="Commented blocks are ok" ref="rulesets/java/empty.xml/EmptyCatchBlock">
+        <properties>
+            <property name="allowCommentedBlocks" value="true"/>
+        </properties>
+    </rule>
+</ruleset>
\ No newline at end of file
diff --git a/settings.gradle b/settings.gradle
index 1ed082f9..ed01852c 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -5,6 +5,5 @@ include ':tinker-android:tinker-android-anno'
 include ':tinker-build:tinker-patch-cli'
 include ':tinker-build:tinker-patch-lib'
 include ':tinker-build:tinker-patch-gradle-plugin'
-include ':third-party:seven-zip'
 include ':third-party:aosp-dexutils'
 include ':third-party:bsdiff-util'
diff --git a/third-party/aosp-dexutils/build.gradle b/third-party/aosp-dexutils/build.gradle
index 4153cea7..1844d317 100644
--- a/third-party/aosp-dexutils/build.gradle
+++ b/third-party/aosp-dexutils/build.gradle
@@ -5,7 +5,8 @@ apply plugin: 'java'
 version rootProject.ext.VERSION_NAME
 group rootProject.ext.GROUP
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from('build/libs') {
         include '*.jar'
         exclude '*javadoc.jar'
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/io/DexDataBuffer.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/io/DexDataBuffer.java
index f2e16ed6..93c9da09 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/io/DexDataBuffer.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dex/io/DexDataBuffer.java
@@ -51,6 +51,8 @@
     public static final int DEFAULT_BUFFER_SIZE = 512;
 
     private static final short[] EMPTY_SHORT_ARRAY = new short[0];
+    private static final Code.Try[] EMPTY_TRY_ARRAY = new Code.Try[0];
+    private static final Code.CatchHandler[] EMPTY_CATCHHANDLER_ARRAY = new Code.CatchHandler[0];
 
     private ByteBuffer data;
     private int dataBound;
@@ -235,8 +237,8 @@ public Code readCode() {
         Code.Try[] tries;
         Code.CatchHandler[] catchHandlers;
         if (triesSize > 0) {
-            if (instructions.length % 2 == 1) {
-                readShort(); // padding
+            if ((instructions.length & 1) == 1) {
+                skip(2); // padding
             }
 
             /*
@@ -252,8 +254,8 @@ public Code readCode() {
             tries = readTries(triesSize, catchHandlers);
             data.position(posAfterCatchHandlers);
         } else {
-            tries = new Code.Try[0];
-            catchHandlers = new Code.CatchHandler[0];
+            tries = EMPTY_TRY_ARRAY;
+            catchHandlers = EMPTY_CATCHHANDLER_ARRAY;
         }
         return new Code(off, registersSize, insSize, outsSize, debugInfoOffset, instructions,
                 tries, catchHandlers);
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionComparator.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionComparator.java
index b90bac22..a2651b9d 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionComparator.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionComparator.java
@@ -21,6 +21,8 @@
 import com.tencent.tinker.android.dx.util.Hex;
 
 import java.io.EOFException;
+import java.util.HashSet;
+import java.util.Set;
 
 /**
  * *** This file is NOT a part of AOSP. ***
@@ -30,8 +32,14 @@
 public abstract class InstructionComparator {
     private final InstructionHolder[] insnHolders1;
     private final InstructionHolder[] insnHolders2;
+    private final Set<String> visitedInsnAddrPairs;
+    private final short[] insns1;
+    private final short[] insns2;
 
     public InstructionComparator(short[] insns1, short[] insns2) {
+        this.insns1 = insns1;
+        this.insns2 = insns2;
+
         if (insns1 != null) {
             ShortArrayCodeInput codeIn1 = new ShortArrayCodeInput(insns1);
             this.insnHolders1 = readInstructionsIntoHolders(codeIn1, insns1.length);
@@ -44,6 +52,7 @@ public InstructionComparator(short[] insns1, short[] insns2) {
         } else {
             this.insnHolders2 = null;
         }
+        visitedInsnAddrPairs = new HashSet<>();
     }
 
     private InstructionHolder[] readInstructionsIntoHolders(ShortArrayCodeInput in, int length) {
@@ -189,6 +198,8 @@ public void visitFillArrayDataPayloadInsn(int currentAddress, int opcode, Object
     }
 
     public final boolean compare() {
+        this.visitedInsnAddrPairs.clear();
+
         if (this.insnHolders1 == null && this.insnHolders2 == null) {
             return true;
         }
@@ -275,7 +286,16 @@ public boolean isSameInstruction(int insnAddress1, int insnAddress2) {
             case InstructionCodec.INSN_FORMAT_22T:
             case InstructionCodec.INSN_FORMAT_30T:
             case InstructionCodec.INSN_FORMAT_31T: {
-                return isSameInstruction(insnHolder1.target, insnHolder2.target);
+                final String addrPairStr = insnAddress1 + "-" + insnAddress2;
+                if (this.visitedInsnAddrPairs.add(addrPairStr)) {
+                    // If we haven't compared target insns, following the control flow
+                    // and do further compare.
+                    return isSameInstruction(insnHolder1.target, insnHolder2.target);
+                } else {
+                    // If we have already compared target insns, here we can return
+                    // true directly.
+                    return true;
+                }
             }
             case InstructionCodec.INSN_FORMAT_21C:
             case InstructionCodec.INSN_FORMAT_22C:
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/utils/SparseBoolArray.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/utils/SparseBoolArray.java
new file mode 100644
index 00000000..1e43ce9b
--- /dev/null
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/utils/SparseBoolArray.java
@@ -0,0 +1,355 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.android.utils;
+
+/**
+ * SparseBoolArrays map integers to booleans.  Unlike a normal array of booleans,
+ * there can be gaps in the indices.  It is intended to be more memory efficient
+ * than using a HashMap to map Integers to Booleans, both because it avoids
+ * auto-boxing keys and values and its data structure doesn't rely on an extra entry object
+ * for each mapping.
+ *
+ * <p>Note that this container keeps its mappings in an array data structure,
+ * using a binary search to find keys.  The implementation is not intended to be appropriate for
+ * data structures
+ * that may contain large numbers of items.  It is generally slower than a traditional
+ * HashMap, since lookups require a binary search and adds and removes require inserting
+ * and deleting entries in the array.  For containers holding up to hundreds of items,
+ * the performance difference is not significant, less than 50%.</p>
+ *
+ * <p>It is possible to iterate over the items in this container using
+ * {@link #keyAt(int)} and {@link #valueAt(int)}. Iterating over the keys using
+ * <code>keyAt(int)</code> with ascending values of the index will return the
+ * keys in ascending order, or the values corresponding to the keys in ascending
+ * order in the case of <code>valueAt(int)</code>.</p>
+ */
+public class SparseBoolArray implements Cloneable {
+    private static final int[] EMPTY_INT_ARRAY = new int[0];
+    private static final boolean[] EMPTY_BOOL_ARRAY = new boolean[0];
+    private int[] mKeys;
+    private boolean[] mValues;
+    private int   mSize;
+
+    public static class KeyNotFoundException extends Exception {
+        public KeyNotFoundException() {
+            super();
+        }
+
+        public KeyNotFoundException(String msg) {
+            super(msg);
+        }
+    }
+
+    /**
+     * Creates a new SparseIntArray containing no mappings.
+     */
+    public SparseBoolArray() {
+        this(10);
+    }
+
+    /**
+     * Creates a new SparseIntArray containing no mappings that will not
+     * require any additional memory allocation to store the specified
+     * number of mappings.  If you supply an initial capacity of 0, the
+     * sparse array will be initialized with a light-weight representation
+     * not requiring any additional array allocations.
+     */
+    public SparseBoolArray(int initialCapacity) {
+        if (initialCapacity == 0) {
+            mKeys = SparseBoolArray.EMPTY_INT_ARRAY;
+            mValues = SparseBoolArray.EMPTY_BOOL_ARRAY;
+        } else {
+            mKeys = new int[initialCapacity];
+            mValues = new boolean[initialCapacity];
+        }
+        mSize = 0;
+    }
+
+    /**
+     * Given the current size of an array, returns an ideal size to which the array should grow.
+     * This is typically double the given size, but should not be relied upon to do so in the
+     * future.
+     */
+    private static int growSize(int currentSize) {
+        return currentSize <= 4 ? 8 : currentSize + (currentSize >> 1);
+    }
+
+    @Override
+    public SparseBoolArray clone() {
+        SparseBoolArray clone = null;
+        try {
+            clone = (SparseBoolArray) super.clone();
+            clone.mKeys = mKeys.clone();
+            clone.mValues = mValues.clone();
+        } catch (CloneNotSupportedException cnse) {
+            /* ignore */
+        }
+        return clone;
+    }
+
+    /**
+     * Gets the int mapped from the specified key, or a {@code KeyNotFoundException} is thrown
+     * if no such mapping has been made.
+     */
+    public boolean get(int key) throws KeyNotFoundException {
+        int i = binarySearch(mKeys, mSize, key);
+
+        if (i < 0) {
+            throw new KeyNotFoundException("" + key);
+        } else {
+            return mValues[i];
+        }
+    }
+
+    /**
+     * Removes the mapping from the specified key, if there was any.
+     */
+    public void delete(int key) {
+        int i = binarySearch(mKeys, mSize, key);
+
+        if (i >= 0) {
+            removeAt(i);
+        }
+    }
+
+    /**
+     * Removes the mapping at the given index.
+     */
+    public void removeAt(int index) {
+        System.arraycopy(mKeys, index + 1, mKeys, index, mSize - (index + 1));
+        System.arraycopy(mValues, index + 1, mValues, index, mSize - (index + 1));
+        --mSize;
+    }
+
+    /**
+     * Adds a mapping from the specified key to the specified value,
+     * replacing the previous mapping from the specified key if there
+     * was one.
+     */
+    public void put(int key, boolean value) {
+        int i = binarySearch(mKeys, mSize, key);
+
+        if (i >= 0) {
+            mValues[i] = value;
+        } else {
+            i = ~i;
+            mKeys = insertElementIntoIntArray(mKeys, mSize, i, key);
+            mValues = insertElementIntoBoolArray(mValues, mSize, i, value);
+            ++mSize;
+        }
+    }
+
+    /**
+     * Returns the number of key-value mappings that this SparseIntArray
+     * currently stores.
+     */
+    public int size() {
+        return mSize;
+    }
+
+    /**
+     * Given an index in the range <code>0...size()-1</code>, returns
+     * the key from the <code>index</code>th key-value mapping that this
+     * SparseIntArray stores.
+     *
+     * <p>The keys corresponding to indices in ascending order are guaranteed to
+     * be in ascending order, e.g., <code>keyAt(0)</code> will return the
+     * smallest key and <code>keyAt(size()-1)</code> will return the largest
+     * key.</p>
+     */
+    public int keyAt(int index) {
+        return mKeys[index];
+    }
+
+    /**
+     * Given an index in the range <code>0...size()-1</code>, returns
+     * the value from the <code>index</code>th key-value mapping that this
+     * SparseIntArray stores.
+     *
+     * <p>The values corresponding to indices in ascending order are guaranteed
+     * to be associated with keys in ascending order, e.g.,
+     * <code>valueAt(0)</code> will return the value associated with the
+     * smallest key and <code>valueAt(size()-1)</code> will return the value
+     * associated with the largest key.</p>
+     */
+    public boolean valueAt(int index) {
+        return mValues[index];
+    }
+
+    /**
+     * Returns the index for which {@link #keyAt} would return the
+     * specified key, or a negative number if the specified
+     * key is not mapped.
+     */
+    public int indexOfKey(int key) {
+        return binarySearch(mKeys, mSize, key);
+    }
+
+    /**
+     * Returns whether the {@code key} is exists.
+     */
+    public boolean containsKey(int key) {
+        return indexOfKey(key) >= 0;
+    }
+
+    /**
+     * Returns an index for which {@link #valueAt} would return the
+     * specified key, or a negative number if no keys map to the
+     * specified value.
+     * Beware that this is a linear search, unlike lookups by key,
+     * and that multiple keys can map to the same value and this will
+     * find only one of them.
+     */
+    public int indexOfValue(boolean value) {
+        for (int i = 0; i < mSize; ++i) {
+            if (mValues[i] == value) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * Removes all key-value mappings from this SparseIntArray.
+     */
+    public void clear() {
+        mSize = 0;
+    }
+
+    /**
+     * Puts a key/value pair into the array, optimizing for the case where
+     * the key is greater than all existing keys in the array.
+     */
+    public void append(int key, boolean value) {
+        if (mSize != 0 && key <= mKeys[mSize - 1]) {
+            put(key, value);
+            return;
+        }
+
+        mKeys = appendElementIntoIntArray(mKeys, mSize, key);
+        mValues = appendElementIntoBoolArray(mValues, mSize, value);
+        mSize++;
+    }
+
+    private int binarySearch(int[] array, int size, int value) {
+        int lo = 0;
+        int hi = size - 1;
+
+        while (lo <= hi) {
+            int mid = (lo + hi) >>> 1;
+            int midVal = array[mid];
+
+            if (midVal < value) {
+                lo = mid + 1;
+            } else if (midVal > value) {
+                hi = mid - 1;
+            } else {
+                return mid;  // value found
+            }
+        }
+        return ~lo;  // value not present
+    }
+
+    private int[] appendElementIntoIntArray(int[] array, int currentSize, int element) {
+        if (currentSize > array.length) {
+            throw new IllegalArgumentException("Bad currentSize, originalSize: " + array.length + " currentSize: " + currentSize);
+        }
+        if (currentSize + 1 > array.length) {
+            int[] newArray = new int[SparseBoolArray.growSize(currentSize)];
+            System.arraycopy(array, 0, newArray, 0, currentSize);
+            array = newArray;
+        }
+        array[currentSize] = element;
+        return array;
+    }
+
+    private boolean[] appendElementIntoBoolArray(boolean[] array, int currentSize, boolean element) {
+        if (currentSize > array.length) {
+            throw new IllegalArgumentException("Bad currentSize, originalSize: " + array.length + " currentSize: " + currentSize);
+        }
+        if (currentSize + 1 > array.length) {
+            boolean[] newArray = new boolean[SparseBoolArray.growSize(currentSize)];
+            System.arraycopy(array, 0, newArray, 0, currentSize);
+            array = newArray;
+        }
+        array[currentSize] = element;
+        return array;
+    }
+
+    private int[] insertElementIntoIntArray(int[] array, int currentSize, int index, int element) {
+        if (currentSize > array.length) {
+            throw new IllegalArgumentException("Bad currentSize, originalSize: " + array.length + " currentSize: " + currentSize);
+        }
+
+        if (currentSize + 1 <= array.length) {
+            System.arraycopy(array, index, array, index + 1, currentSize - index);
+            array[index] = element;
+            return array;
+        }
+
+        int[] newArray = new int[SparseBoolArray.growSize(currentSize)];
+        System.arraycopy(array, 0, newArray, 0, index);
+        newArray[index] = element;
+        System.arraycopy(array, index, newArray, index + 1, array.length - index);
+        return newArray;
+    }
+
+    private boolean[] insertElementIntoBoolArray(boolean[] array, int currentSize, int index, boolean element) {
+        if (currentSize > array.length) {
+            throw new IllegalArgumentException("Bad currentSize, originalSize: " + array.length + " currentSize: " + currentSize);
+        }
+
+        if (currentSize + 1 <= array.length) {
+            System.arraycopy(array, index, array, index + 1, currentSize - index);
+            array[index] = element;
+            return array;
+        }
+
+        boolean[] newArray = new boolean[SparseBoolArray.growSize(currentSize)];
+        System.arraycopy(array, 0, newArray, 0, index);
+        newArray[index] = element;
+        System.arraycopy(array, index, newArray, index + 1, array.length - index);
+        return newArray;
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * <p>This implementation composes a string by iterating over its mappings.
+     */
+    @Override
+    public String toString() {
+        if (size() <= 0) {
+            return "{}";
+        }
+
+        StringBuilder buffer = new StringBuilder(mSize * 28);
+        buffer.append('{');
+        for (int i = 0; i < mSize; i++) {
+            if (i > 0) {
+                buffer.append(", ");
+            }
+            int key = keyAt(i);
+            buffer.append(key);
+            buffer.append('=');
+            boolean value = valueAt(i);
+            buffer.append(value);
+        }
+        buffer.append('}');
+        return buffer.toString();
+    }
+}
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/utils/SparseIntArray.java b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/utils/SparseIntArray.java
index 20bfbf4e..8634a6ac 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/utils/SparseIntArray.java
+++ b/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/utils/SparseIntArray.java
@@ -196,6 +196,13 @@ public int indexOfKey(int key) {
         return binarySearch(mKeys, mSize, key);
     }
 
+    /**
+     * Returns whether the {@code key} is exists.
+     */
+    public boolean containsKey(int key) {
+        return indexOfKey(key) >= 0;
+    }
+
     /**
      * Returns an index for which {@link #valueAt} would return the
      * specified key, or a negative number if no keys map to the
diff --git a/third-party/bsdiff-util/build.gradle b/third-party/bsdiff-util/build.gradle
index 4153cea7..1844d317 100644
--- a/third-party/bsdiff-util/build.gradle
+++ b/third-party/bsdiff-util/build.gradle
@@ -5,7 +5,8 @@ apply plugin: 'java'
 version rootProject.ext.VERSION_NAME
 group rootProject.ext.GROUP
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from('build/libs') {
         include '*.jar'
         exclude '*javadoc.jar'
diff --git a/third-party/seven-zip/.gitignore b/third-party/seven-zip/.gitignore
deleted file mode 100644
index 796b96d1..00000000
--- a/third-party/seven-zip/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/build
diff --git a/third-party/seven-zip/License.txt b/third-party/seven-zip/License.txt
deleted file mode 100644
index 2c6b3074..00000000
--- a/third-party/seven-zip/License.txt
+++ /dev/null
@@ -1,52 +0,0 @@
-  7-Zip source code
-  ~~~~~~~~~~~~~~~~~
-  License for use and distribution
-  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-  7-Zip Copyright (C) 1999-2016 Igor Pavlov.
-
-  Licenses for files are:
-
-    1) CPP/7zip/Compress/Rar* files:  GNU LGPL + unRAR restriction
-    2) All other files:  GNU LGPL
-
-  The GNU LGPL + unRAR restriction means that you must follow both 
-  GNU LGPL rules and unRAR restriction rules.
-
-
-  GNU LGPL information
-  --------------------
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-
-  unRAR restriction
-  -----------------
-
-    The decompression engine for RAR archives was developed using source 
-    code of unRAR program.
-    All copyrights to original unRAR code are owned by Alexander Roshal.
-
-    The license for original unRAR code has the following restriction:
-
-    The unRAR sources cannot be used to re-create the RAR compression algorithm, 
-    which is proprietary. Distribution of modified unRAR sources in separate form 
-    or as a part of other software is permitted, provided that it is clearly
-    stated in the documentation and source comments that the code may
-    not be used to develop a RAR (WinRAR) compatible archiver.
-
-
-  --
-  Igor Pavlov
diff --git a/third-party/seven-zip/build.gradle b/third-party/seven-zip/build.gradle
deleted file mode 100644
index f1352e49..00000000
--- a/third-party/seven-zip/build.gradle
+++ /dev/null
@@ -1,49 +0,0 @@
-apply plugin: 'maven'
-apply plugin: 'maven-publish'
-apply plugin: 'com.jfrog.bintray'
-
-//hardcode 1.0.0
-version "1.0.0"
-group rootProject.ext.GROUP
-
-bintray {
-    publications = ['SevenZipPub']
-}
-
-publishing {
-    publications {
-        SevenZipPub(MavenPublication) {
-            artifactId project.getName()
-            groupId group
-            artifact("executable/SevenZip-linux-x86_32.exe") {
-                classifier "linux-x86_32"
-                extension "exe"
-            }
-            artifact("executable/SevenZip-linux-x86_64.exe") {
-                classifier "linux-x86_64"
-                extension "exe"
-            }
-            artifact("executable/SevenZip-windows-x86_32.exe") {
-                classifier "windows-x86_32"
-                extension "exe"
-            }
-            artifact("executable/SevenZip-windows-x86_64.exe") {
-                classifier "windows-x86_64"
-                extension "exe"
-            }
-            artifact("executable/SevenZip-osx-x86_64.exe") {
-                classifier "osx-x86_64"
-                extension "exe"
-            }
-        }
-    }
-}
-
-task buildAndPublishLocalMaven(dependsOn: 'publishSevenZipPubPublicationToMavenLocal') {
-
-}
-
-//don't upload sevenZip default
-if (hasProperty('UPLOAD_SEVEN_ZIP')) {
-    apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
-}
diff --git a/third-party/seven-zip/executable/SevenZip-linux-x86_32.exe b/third-party/seven-zip/executable/SevenZip-linux-x86_32.exe
deleted file mode 100755
index f1c18e4b..00000000
Binary files a/third-party/seven-zip/executable/SevenZip-linux-x86_32.exe and /dev/null differ
diff --git a/third-party/seven-zip/executable/SevenZip-linux-x86_64.exe b/third-party/seven-zip/executable/SevenZip-linux-x86_64.exe
deleted file mode 100644
index 927cc1ad..00000000
Binary files a/third-party/seven-zip/executable/SevenZip-linux-x86_64.exe and /dev/null differ
diff --git a/third-party/seven-zip/executable/SevenZip-osx-x86_64.exe b/third-party/seven-zip/executable/SevenZip-osx-x86_64.exe
deleted file mode 100644
index c40e062b..00000000
Binary files a/third-party/seven-zip/executable/SevenZip-osx-x86_64.exe and /dev/null differ
diff --git a/third-party/seven-zip/executable/SevenZip-windows-x86_32.exe b/third-party/seven-zip/executable/SevenZip-windows-x86_32.exe
deleted file mode 100644
index 710bda2f..00000000
Binary files a/third-party/seven-zip/executable/SevenZip-windows-x86_32.exe and /dev/null differ
diff --git a/third-party/seven-zip/executable/SevenZip-windows-x86_64.exe b/third-party/seven-zip/executable/SevenZip-windows-x86_64.exe
deleted file mode 100644
index 881b7dd9..00000000
Binary files a/third-party/seven-zip/executable/SevenZip-windows-x86_64.exe and /dev/null differ
diff --git a/third-party/seven-zip/gradle.properties b/third-party/seven-zip/gradle.properties
deleted file mode 100644
index 6c1444d4..00000000
--- a/third-party/seven-zip/gradle.properties
+++ /dev/null
@@ -1,2 +0,0 @@
-POM_ARTIFACT_ID=seven-zip
-POM_NAME=seven-zip
diff --git a/tinker-android/tinker-android-anno/build.gradle b/tinker-android/tinker-android-anno/build.gradle
index d74f33c2..263ca599 100644
--- a/tinker-android/tinker-android-anno/build.gradle
+++ b/tinker-android/tinker-android-anno/build.gradle
@@ -21,7 +21,8 @@ sourceSets {
     }
 }
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from('build/libs') {
         include '*.jar'
         exclude '*javadoc.jar'
diff --git a/tinker-android/tinker-android-lib/build.gradle b/tinker-android/tinker-android-lib/build.gradle
index 7f9c60b2..bcc8b83f 100644
--- a/tinker-android/tinker-android-lib/build.gradle
+++ b/tinker-android/tinker-android-lib/build.gradle
@@ -20,7 +20,8 @@ dependencies {
     compile project(':tinker-android:tinker-android-loader')
 }
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from("$buildDir/outputs/aar/") {
         include "${project.getName()}-release.aar"
     }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
new file mode 100644
index 00000000..5fa176b2
--- /dev/null
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
@@ -0,0 +1,238 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.lib.library;
+
+import android.content.Context;
+import android.os.Build;
+
+import com.tencent.tinker.lib.tinker.Tinker;
+import com.tencent.tinker.lib.tinker.TinkerLoadResult;
+import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.loader.TinkerRuntimeException;
+import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by zhangshaowen on 17/1/5.
+ * Thanks for Android Fragmentation
+ */
+
+public class TinkerLoadLibrary {
+    private static final String TAG = "Tinker.LoadLibrary";
+
+    /**
+     * you can use TinkerInstaller.loadLibrary replace your System.loadLibrary for auto update library!
+     * only support auto load lib/armeabi library from patch.
+     * for other library in lib/* or assets,
+     * you can load through {@code TinkerInstaller#loadLibraryFromTinker}
+     */
+    public static void loadArmLibrary(Context context, String libName) {
+        if (libName == null || libName.isEmpty() || context == null) {
+            throw new TinkerRuntimeException("libName or context is null!");
+        }
+
+        Tinker tinker = Tinker.with(context);
+        if (tinker.isEnabledForNativeLib()) {
+            if (TinkerLoadLibrary.loadLibraryFromTinker(context, "lib/armeabi", libName)) {
+                return;
+            }
+
+        }
+        System.loadLibrary(libName);
+    }
+
+    /**
+     * you can use TinkerInstaller.loadArmV7Library replace your System.loadLibrary for auto update library!
+     * only support auto load lib/armeabi-v7a library from patch.
+     * for other library in lib/* or assets,
+     * you can load through {@code TinkerInstaller#loadLibraryFromTinker}
+     */
+    public static void loadArmV7Library(Context context, String libName) {
+        if (libName == null || libName.isEmpty() || context == null) {
+            throw new TinkerRuntimeException("libName or context is null!");
+        }
+
+        Tinker tinker = Tinker.with(context);
+        if (tinker.isEnabledForNativeLib()) {
+            if (TinkerLoadLibrary.loadLibraryFromTinker(context, "lib/armeabi-v7a", libName)) {
+                return;
+            }
+
+        }
+        System.loadLibrary(libName);
+    }
+
+    /**
+     * sample usage for native library
+     *
+     * @param context
+     * @param relativePath such as lib/armeabi
+     * @param libName      for the lib libTest.so, you can pass Test or libTest, or libTest.so
+     * @return boolean
+     * @throws UnsatisfiedLinkError
+     */
+    public static boolean loadLibraryFromTinker(Context context, String relativePath, String libName) throws UnsatisfiedLinkError {
+        final Tinker tinker = Tinker.with(context);
+
+        libName = libName.startsWith("lib") ? libName : "lib" + libName;
+        libName = libName.endsWith(".so") ? libName : libName + ".so";
+        String relativeLibPath = relativePath + "/" + libName;
+
+        //TODO we should add cpu abi, and the real path later
+        if (tinker.isEnabledForNativeLib() && tinker.isTinkerLoaded()) {
+            TinkerLoadResult loadResult = tinker.getTinkerLoadResultIfPresent();
+            if (loadResult.libs != null) {
+                for (String name : loadResult.libs.keySet()) {
+                    if (name.equals(relativeLibPath)) {
+                        String patchLibraryPath = loadResult.libraryDirectory + "/" + name;
+                        File library = new File(patchLibraryPath);
+                        if (library.exists()) {
+                            //whether we check md5 when load
+                            boolean verifyMd5 = tinker.isTinkerLoadVerify();
+                            if (verifyMd5 && !SharePatchFileUtil.verifyFileMd5(library, loadResult.libs.get(name))) {
+                                tinker.getLoadReporter().onLoadFileMd5Mismatch(library, ShareConstants.TYPE_LIBRARY);
+                            } else {
+                                System.load(patchLibraryPath);
+                                TinkerLog.i(TAG, "loadLibraryFromTinker success:" + patchLibraryPath);
+                                return true;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * you can reflect your current abi to classloader library path
+     * as you don't need to use load*Library method above
+     * @param context
+     * @param currentABI
+     */
+    public static void installNavitveLibraryABI(Context context, String currentABI) {
+        Tinker tinker = Tinker.with(context);
+        if (!tinker.isTinkerLoaded()) {
+            TinkerLog.i(TAG, "tinker is not loaded, just return");
+            return;
+        }
+        TinkerLoadResult loadResult = tinker.getTinkerLoadResultIfPresent();
+        if (loadResult.libs == null) {
+            TinkerLog.i(TAG, "tinker libs is null, just return");
+            return;
+        }
+        File soDir = new File(loadResult.libraryDirectory, "lib/" + currentABI);
+        if (!soDir.exists()) {
+            TinkerLog.e(TAG, "current libraryABI folder is not exist, path: %s", soDir.getPath());
+            return;
+        }
+        ClassLoader classLoader = context.getClassLoader();
+        if (classLoader == null) {
+            TinkerLog.e(TAG, "classloader is null");
+            return;
+        }
+        TinkerLog.i(TAG, "before hack classloader:" + classLoader.toString());
+
+        try {
+            installNativeLibraryPath(classLoader, soDir);
+        } catch (Throwable throwable) {
+            TinkerLog.e(TAG, "installNativeLibraryPath fail:" + throwable);
+        }
+        TinkerLog.i(TAG, "after hack classloader:" + classLoader.toString());
+    }
+
+    private static void installNativeLibraryPath(ClassLoader classLoader, File folder)
+        throws Throwable {
+        if (folder == null || !folder.exists()) {
+            TinkerLog.e(TAG, "installNativeLibraryPath, folder %s is illegal", folder);
+            return;
+        }
+        if (Build.VERSION.SDK_INT >= 23) {
+            try {
+                V23.install(classLoader, folder);
+            } catch (Throwable throwable) {
+                // install fail, try to treat it as v14
+                TinkerLog.e(TAG, "installNativeLibraryPath, v23 fail, sdk: %d, error: %s",
+                    Build.VERSION.SDK_INT, throwable.getMessage());
+
+                V14.install(classLoader, folder);
+            }
+        } else if (Build.VERSION.SDK_INT >= 14) {
+            V14.install(classLoader, folder);
+        } else {
+            V4.install(classLoader, folder);
+        }
+    }
+
+    private static final class V4 {
+        private static void install(ClassLoader classLoader, File folder)  throws Throwable {
+            String addPath = folder.getPath();
+            Field pathField = ShareReflectUtil.findField(classLoader, "libPath");
+            StringBuilder libPath = new StringBuilder((String) pathField.get(classLoader));
+            libPath.append(':').append(addPath);
+            pathField.set(classLoader, libPath.toString());
+
+            Field libraryPathElementsFiled = ShareReflectUtil.findField(classLoader, "libraryPathElements");
+            List<String> libraryPathElements = (List<String>) libraryPathElementsFiled.get(classLoader);
+            libraryPathElements.add(0, addPath);
+            libraryPathElementsFiled.set(classLoader, libraryPathElements);
+        }
+    }
+
+    private static final class V14 {
+        private static void install(ClassLoader classLoader, File folder)  throws Throwable {
+            Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
+            Object dexPathList = pathListField.get(classLoader);
+
+            ShareReflectUtil.expandFieldArray(dexPathList, "nativeLibraryDirectories", new File[]{folder});
+        }
+    }
+
+    private static final class V23 {
+        private static void install(ClassLoader classLoader, File folder)  throws Throwable {
+            Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
+            Object dexPathList = pathListField.get(classLoader);
+
+            Field nativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, "nativeLibraryDirectories");
+
+            List<File> libDirs = (List<File>) nativeLibraryDirectories.get(dexPathList);
+            libDirs.add(0, folder);
+            Field systemNativeLibraryDirectories =
+                ShareReflectUtil.findField(dexPathList, "systemNativeLibraryDirectories");
+            List<File> systemLibDirs = (List<File>) systemNativeLibraryDirectories.get(dexPathList);
+            Method makePathElements =
+                ShareReflectUtil.findMethod(dexPathList, "makePathElements", List.class, File.class, List.class);
+            ArrayList<IOException> suppressedExceptions = new ArrayList<>();
+            libDirs.addAll(systemLibDirs);
+            Object[] elements = (Object[]) makePathElements.
+                invoke(dexPathList, libDirs, null, suppressedExceptions);
+            Field nativeLibraryPathElements = ShareReflectUtil.findField(dexPathList, "nativeLibraryPathElements");
+            nativeLibraryPathElements.setAccessible(true);
+            nativeLibraryPathElements.set(dexPathList, elements);
+        }
+    }
+
+}
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
index f0f3055f..52651e30 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
@@ -22,6 +22,7 @@
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerServiceInternals;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.io.File;
@@ -41,32 +42,31 @@ public DefaultPatchListener(Context context) {
      * you can overwrite it
      *
      * @param path
-     * @param isUpgrade
      * @return
      */
     @Override
-    public int onPatchReceived(String path, boolean isUpgrade) {
+    public int onPatchReceived(String path) {
 
-        int returnCode = patchCheck(path, isUpgrade);
+        int returnCode = patchCheck(path);
 
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
-            TinkerPatchService.runPatchService(context, path, isUpgrade);
+            TinkerPatchService.runPatchService(context, path);
         } else {
-            Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(new File(path), returnCode, isUpgrade);
+            Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(new File(path), returnCode);
         }
         return returnCode;
 
     }
 
-    protected int patchCheck(String path, boolean isUpgrade) {
+    protected int patchCheck(String path) {
         Tinker manager = Tinker.with(context);
-        //check SharePrefenences also
+        //check SharePreferences also
         if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) {
             return ShareConstants.ERROR_PATCH_DISABLE;
         }
         File file = new File(path);
 
-        if (!file.isFile() || !file.exists() || file.length() == 0) {
+        if (!SharePatchFileUtil.isLegalFile(file)) {
             return ShareConstants.ERROR_PATCH_NOTEXIST;
         }
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/PatchListener.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/PatchListener.java
index 7d65c555..1f18c491 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/PatchListener.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/PatchListener.java
@@ -20,5 +20,5 @@
  * Created by zhangshaowen on 16/3/14.
  */
 public interface PatchListener {
-    int onPatchReceived(String path, boolean isUpgrade);
+    int onPatchReceived(String path);
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
index 5ef3d88d..732166f2 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
@@ -43,7 +43,6 @@
     protected static final String RES_META_FILE        = ShareConstants.RES_META_FILE;
 
     protected static final int TYPE_DEX         = ShareConstants.TYPE_DEX;
-    protected static final int TYPE_DEX_FOR_ART = ShareConstants.TYPE_DEX_FOR_ART;
     protected static final int TYPE_Library     = ShareConstants.TYPE_LIBRARY;
     protected static final int TYPE_RESOURCE    = ShareConstants.TYPE_RESOURCE;
 
@@ -89,7 +88,7 @@ public static boolean extract(ZipFile zipFile, ZipEntry entryFile, File extractT
     }
 
     public static int getMetaCorruptedCode(int type) {
-        if (type == TYPE_DEX || type == TYPE_DEX_FOR_ART) {
+        if (type == TYPE_DEX) {
             return ShareConstants.ERROR_PACKAGE_CHECK_DEX_META_CORRUPTED;
         } else if (type == TYPE_Library) {
             return ShareConstants.ERROR_PACKAGE_CHECK_LIB_META_CORRUPTED;
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
index 45e241b2..7414b007 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
@@ -42,7 +42,7 @@
     private static final String TAG = "Tinker.BsDiffPatchInternal";
 
     protected static boolean tryRecoverLibraryFiles(Tinker manager, ShareSecurityCheck checker, Context context,
-                                                    String patchVersionDirectory, File patchFile, boolean isUpgradePatch) {
+                                                    String patchVersionDirectory, File patchFile) {
 
         if (!manager.isEnabledForNativeLib()) {
             TinkerLog.w(TAG, "patch recover, library is not enabled");
@@ -55,19 +55,19 @@ protected static boolean tryRecoverLibraryFiles(Tinker manager, ShareSecurityChe
             return true;
         }
         long begin = SystemClock.elapsedRealtime();
-        boolean result = patchLibraryExtractViaBsDiff(context, patchVersionDirectory, libMeta, patchFile, isUpgradePatch);
+        boolean result = patchLibraryExtractViaBsDiff(context, patchVersionDirectory, libMeta, patchFile);
         long cost = SystemClock.elapsedRealtime() - begin;
-        TinkerLog.i(TAG, "recover lib result:%b, cost:%d, isUpgradePatch:%b", result, cost, isUpgradePatch);
+        TinkerLog.i(TAG, "recover lib result:%b, cost:%d", result, cost);
         return result;
     }
 
 
-    private static boolean patchLibraryExtractViaBsDiff(Context context, String patchVersionDirectory, String meta, File patchFile, boolean isUpgradePatch) {
+    private static boolean patchLibraryExtractViaBsDiff(Context context, String patchVersionDirectory, String meta, File patchFile) {
         String dir = patchVersionDirectory + "/" + SO_PATH + "/";
-        return extractBsDiffInternals(context, dir, meta, patchFile, TYPE_Library, isUpgradePatch);
+        return extractBsDiffInternals(context, dir, meta, patchFile, TYPE_Library);
     }
 
-    private static boolean extractBsDiffInternals(Context context, String dir, String meta, File patchFile, int type, boolean isUpgradePatch) {
+    private static boolean extractBsDiffInternals(Context context, String dir, String meta, File patchFile, int type) {
         //parse
         ArrayList<ShareBsDiffPatchInfo> patchList = new ArrayList<>();
 
@@ -110,7 +110,7 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
                 final String fileMd5 = info.md5;
                 if (!SharePatchFileUtil.checkIfMd5Valid(fileMd5)) {
                     TinkerLog.w(TAG, "meta file md5 mismatch, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), info.name, info.md5);
-                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                     return false;
                 }
                 String middle;
@@ -140,21 +140,21 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
 
                 if (patchFileEntry == null) {
                     TinkerLog.w(TAG, "patch entry is null. path:" + patchRealPath);
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type, isUpgradePatch);
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type);
                     return false;
                 }
 
                 if (patchFileMd5.equals("0")) {
                     if (!extract(patch, patchFileEntry, extractedFile, fileMd5, false)) {
                         TinkerLog.w(TAG, "Failed to extract file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type);
                         return false;
                     }
                 } else {
                     //we do not check the intermediate files' md5 to save time, use check whether it is 32 length
                     if (!SharePatchFileUtil.checkIfMd5Valid(patchFileMd5)) {
                         TinkerLog.w(TAG, "meta file md5 mismatch, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), info.name, patchFileMd5);
-                        manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                        manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                         return false;
                     }
 
@@ -162,7 +162,7 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
 
                     if (rawApkFileEntry == null) {
                         TinkerLog.w(TAG, "apk entry is null. path:" + patchRealPath);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type);
                         return false;
                     }
 
@@ -172,7 +172,7 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
                     String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());
                     if (!rawEntryCrc.equals(rawApkCrc)) {
                         TinkerLog.e(TAG, "apk entry %s crc is not equal, expect crc: %s, got crc: %s", patchRealPath, rawApkCrc, rawEntryCrc);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type);
                         return false;
                     }
                     InputStream oldStream = null;
@@ -189,7 +189,7 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
                     //go go go bsdiff get the
                     if (!SharePatchFileUtil.verifyFileMd5(extractedFile, fileMd5)) {
                         TinkerLog.w(TAG, "Failed to recover diff file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.name, type);
                         SharePatchFileUtil.safeDeleteFile(extractedFile);
                         return false;
                     }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
index 936b50a6..fa72d59b 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
@@ -21,9 +21,9 @@
 import android.os.SystemClock;
 
 import com.tencent.tinker.commons.dexpatcher.DexPatchApplier;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.loader.TinkerParallelDexOptimizer;
 import com.tencent.tinker.loader.TinkerRuntimeException;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareDexDiffPatchInfo;
@@ -31,8 +31,6 @@
 import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
-import dalvik.system.DexFile;
-
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.File;
@@ -40,20 +38,30 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
+import java.util.List;
+import java.util.Vector;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 import java.util.zip.ZipInputStream;
 import java.util.zip.ZipOutputStream;
 
+import dalvik.system.DexFile;
+
 /**
  * Created by zhangshaowen on 16/4/12.
  */
 public class DexDiffPatchInternal extends BasePatchInternal {
     protected static final String TAG = "Tinker.DexDiffPatchInternal";
 
-    protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck checker, Context context,
-                                                String patchVersionDirectory, File patchFile, boolean isUpgradePatch) {
+    protected static final int WAIT_ASYN_OAT_TIME = 8 * 1000;
+    protected static final int MAX_WAIT_COUNT     = 30;
+
+    private static ArrayList<File> optFiles = new ArrayList<>();
+    private static List<File> failOptDexFile = new Vector<>();
+
 
+    protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck checker, Context context,
+                                                String patchVersionDirectory, File patchFile) {
         if (!manager.isEnabledForDex()) {
             TinkerLog.w(TAG, "patch recover, dex is not enabled");
             return true;
@@ -66,55 +74,170 @@ protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck c
         }
 
         long begin = SystemClock.elapsedRealtime();
-        boolean result = patchDexExtractViaDexDiff(context, patchVersionDirectory, dexMeta, patchFile, isUpgradePatch);
+        boolean result = patchDexExtractViaDexDiff(context, patchVersionDirectory, dexMeta, patchFile);
         long cost = SystemClock.elapsedRealtime() - begin;
-        TinkerLog.i(TAG, "recover dex result:%b, cost:%d, isUpgradePatch:%b", result, cost, isUpgradePatch);
+        TinkerLog.i(TAG, "recover dex result:%b, cost:%d", result, cost);
         return result;
     }
 
-    private static boolean patchDexExtractViaDexDiff(Context context, String patchVersionDirectory, String meta, File patchFile, boolean isUpgradePatch) {
+    protected static boolean waitDexOptFile() {
+        if (optFiles.isEmpty()) {
+            return true;
+        }
+
+        int size = optFiles.size() * 6;
+        if (size > MAX_WAIT_COUNT) {
+            size = MAX_WAIT_COUNT;
+        }
+        TinkerLog.i(TAG, "dex count: %d, final wait time: %d", optFiles.size(), size);
+
+        for (int i = 0; i < size; i++) {
+            if (!checkAllDexOptFile(optFiles, i + 1)) {
+                try {
+                    Thread.sleep(WAIT_ASYN_OAT_TIME);
+                } catch (InterruptedException e) {
+                    TinkerLog.e(TAG, "thread sleep InterruptedException e:" + e);
+                }
+            }
+        }
+
+        // check again, if still can be found, just return
+        for (File file : optFiles) {
+            TinkerLog.i(TAG, "check dex optimizer file %s, size %d", file.getName(), file.length());
+
+            if (!SharePatchFileUtil.isLegalFile(file)) {
+                TinkerLog.e(TAG, "final parallel dex optimizer file %s is not exist, return false", file.getName());
+                // don't report fail
+//                manager.getPatchReporter()
+//                    .onPatchDexOptFail(patchFile, file, file.getParentFile().getPath(),
+//                        file.getName(), new TinkerRuntimeException("dexOpt file:" + file.getName() + " is not exist"));
+                return false;
+
+            }
+        }
+        return true;
+    }
+
+    private static boolean patchDexExtractViaDexDiff(Context context, String patchVersionDirectory, String meta, final File patchFile) {
         String dir = patchVersionDirectory + "/" + DEX_PATH + "/";
 
-        int dexType = ShareTinkerInternals.isVmArt() ? TYPE_DEX_FOR_ART : TYPE_DEX;
-        if (!extractDexDiffInternals(context, dir, meta, patchFile, dexType, isUpgradePatch)) {
+        if (!extractDexDiffInternals(context, dir, meta, patchFile, TYPE_DEX)) {
             TinkerLog.w(TAG, "patch recover, extractDiffInternals fail");
             return false;
         }
 
-        Tinker manager = Tinker.with(context);
+        final Tinker manager = Tinker.with(context);
 
         File dexFiles = new File(dir);
         File[] files = dexFiles.listFiles();
+        optFiles.clear();
 
         if (files != null) {
-            String optimizeDexDirectory = patchVersionDirectory + "/" + DEX_OPTIMIZE_PATH + "/";
+            final String optimizeDexDirectory = patchVersionDirectory + "/" + DEX_OPTIMIZE_PATH + "/";
             File optimizeDexDirectoryFile = new File(optimizeDexDirectory);
 
-            if (!optimizeDexDirectoryFile.exists()) {
-                optimizeDexDirectoryFile.mkdirs();
+            if (!optimizeDexDirectoryFile.exists() && !optimizeDexDirectoryFile.mkdirs()) {
+                TinkerLog.w(TAG, "patch recover, make optimizeDexDirectoryFile fail");
+                return false;
             }
-
+            // add opt files
             for (File file : files) {
-                try {
-                    String outputPathName = SharePatchFileUtil.optimizedPathFor(file, optimizeDexDirectoryFile);
-                    long start = System.currentTimeMillis();
-                    DexFile.loadDex(file.getAbsolutePath(), outputPathName, 0);
-                    TinkerLog.i(TAG, "success dex optimize file, path: %s, use time: %d", file.getPath(), (System.currentTimeMillis() - start));
-                } catch (Throwable e) {
-                    TinkerLog.e(TAG, "dex optimize or load failed, path:" + file.getPath());
-                    //delete file
-                    SharePatchFileUtil.safeDeleteFile(file);
-                    manager.getPatchReporter().onPatchDexOptFail(patchFile, file, optimizeDexDirectory, file.getName(), e, isUpgradePatch);
-                    return false;
+                String outputPathName = SharePatchFileUtil.optimizedPathFor(file, optimizeDexDirectoryFile);
+                optFiles.add(new File(outputPathName));
+            }
+
+            TinkerLog.w(TAG, "patch recover, try to optimize dex file count:%d", files.length);
+
+            // only use parallel dex optimizer for art
+            if (ShareTinkerInternals.isVmArt()) {
+                failOptDexFile.clear();
+                // try parallel dex optimizer
+                TinkerParallelDexOptimizer.optimizeAll(
+                    files, optimizeDexDirectoryFile,
+                    new TinkerParallelDexOptimizer.ResultCallback() {
+                        long startTime;
+
+                        @Override
+                        public void onStart(File dexFile, File optimizedDir) {
+                            startTime = System.currentTimeMillis();
+                            TinkerLog.i(TAG, "start to parallel optimize dex %s, size: %d", dexFile.getPath(), dexFile.length());
+                        }
+
+                        @Override
+                        public void onSuccess(File dexFile, File optimizedDir, File optimizedFile) {
+                            // Do nothing.
+                            TinkerLog.i(TAG, "success to parallel optimize dex %s, opt file size: %d, use time %d",
+                                dexFile.getPath(), optimizedFile.length(), (System.currentTimeMillis() - startTime));
+                        }
+
+                        @Override
+                        public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
+                            TinkerLog.i(TAG, "fail to parallel optimize dex %s use time %d",
+                                dexFile.getPath(), (System.currentTimeMillis() - startTime));
+                            failOptDexFile.add(dexFile);
+                        }
+                    }
+                );
+                // try again
+                for (File retryDexFile : failOptDexFile) {
+                    try {
+                        String outputPathName = SharePatchFileUtil.optimizedPathFor(retryDexFile, optimizeDexDirectoryFile);
+
+                        if (!SharePatchFileUtil.isLegalFile(retryDexFile)) {
+                            manager.getPatchReporter().onPatchDexOptFail(patchFile, retryDexFile,
+                                optimizeDexDirectory, retryDexFile.getName(), new TinkerRuntimeException("retry dex optimize file is not exist, name: " + retryDexFile.getName()));
+                            return false;
+                        }
+                        TinkerLog.i(TAG, "try to retry dex optimize file, path: %s, size: %d", retryDexFile.getPath(), retryDexFile.length());
+                        long start = System.currentTimeMillis();
+                        DexFile.loadDex(retryDexFile.getAbsolutePath(), outputPathName, 0);
+
+                        TinkerLog.i(TAG, "success retry dex optimize file, path: %s, opt file size: %d, use time: %d",
+                            retryDexFile.getPath(), new File(outputPathName).length(), (System.currentTimeMillis() - start));
+                    } catch (Throwable e) {
+                        TinkerLog.e(TAG, "retry dex optimize or load failed, path:" + retryDexFile.getPath());
+                        manager.getPatchReporter().onPatchDexOptFail(patchFile, retryDexFile, optimizeDexDirectory, retryDexFile.getName(), e);
+                        return false;
+                    }
+                }
+            // for dalvik, machine hardware performance is much worse than art machine
+            } else {
+                for (File file : files) {
+                    try {
+                        String outputPathName = SharePatchFileUtil.optimizedPathFor(file, optimizeDexDirectoryFile);
+                        long start = System.currentTimeMillis();
+                        DexFile.loadDex(file.getAbsolutePath(), outputPathName, 0);
+                        TinkerLog.i(TAG, "success single dex optimize file, path: %s, opt file size: %d, use time: %d", file.getPath(), new File(outputPathName).length(),
+                            (System.currentTimeMillis() - start));
+                    } catch (Throwable e) {
+                        TinkerLog.e(TAG, "single dex optimize or load failed, path:" + file.getPath());
+                        manager.getPatchReporter().onPatchDexOptFail(patchFile, file, optimizeDexDirectory, file.getName(), e);
+                        return false;
+                    }
                 }
             }
         }
-
         return true;
     }
 
+    /**
+     * for ViVo or some other rom, they would make dex2oat asynchronous
+     * so we need to check whether oat file is actually generated.
+     * @param files
+     * @param count
+     * @return
+     */
+    private static boolean checkAllDexOptFile(ArrayList<File> files, int count) {
+        for (File file : files) {
+            if (!SharePatchFileUtil.isLegalFile(file)) {
+                TinkerLog.e(TAG, "parallel dex optimizer file %s is not exist, just wait %d times", file.getName(), count);
+                return false;
+            }
+        }
+        return true;
+    }
 
-    private static boolean extractDexDiffInternals(Context context, String dir, String meta, File patchFile, int type, boolean isUpgradePatch) {
+    private static boolean extractDexDiffInternals(Context context, String dir, String meta, File patchFile, int type) {
         //parse
         ArrayList<ShareDexDiffPatchInfo> patchList = new ArrayList<>();
 
@@ -144,29 +267,6 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
             apk = new ZipFile(apkPath);
             patch = new ZipFile(patchFile);
 
-            SmallPatchedDexItemFile smallPatchInfoFile = null;
-
-            if (ShareTinkerInternals.isVmArt()) {
-                File extractedFile = new File(dir + ShareConstants.DEX_SMALLPATCH_INFO_FILE);
-                ZipEntry smallPatchInfoEntry = patch.getEntry(ShareConstants.DEX_SMALLPATCH_INFO_FILE);
-                if (smallPatchInfoEntry == null) {
-                    TinkerLog.w(TAG, "small patch info is not exists, bad patch package?");
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, ShareConstants.DEX_SMALLPATCH_INFO_FILE, type, isUpgradePatch);
-                    return false;
-                }
-                InputStream smallPatchInfoIs = null;
-                try {
-                    smallPatchInfoIs = patch.getInputStream(smallPatchInfoEntry);
-                    smallPatchInfoFile = new SmallPatchedDexItemFile(smallPatchInfoIs);
-                } catch (Throwable e) {
-                    TinkerLog.w(TAG, "failed to read small patched info. reason: " + e.getMessage());
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, ShareConstants.DEX_SMALLPATCH_INFO_FILE, type, isUpgradePatch);
-                    return false;
-                } finally {
-                    SharePatchFileUtil.closeQuietly(smallPatchInfoIs);
-                }
-            }
-
             for (ShareDexDiffPatchInfo info : patchList) {
                 long start = System.currentTimeMillis();
 
@@ -181,11 +281,15 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                 String dexDiffMd5 = info.dexDiffMd5;
                 String oldDexCrc = info.oldDexCrC;
 
+                if (!ShareTinkerInternals.isVmArt() && info.destMd5InDvm.equals("0")) {
+                    TinkerLog.w(TAG, "patch dex %s is only for art, just continue", patchRealPath);
+                    continue;
+                }
                 String extractedFileMd5 = ShareTinkerInternals.isVmArt() ? info.destMd5InArt : info.destMd5InDvm;
 
                 if (!SharePatchFileUtil.checkIfMd5Valid(extractedFileMd5)) {
                     TinkerLog.w(TAG, "meta file md5 invalid, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), info.rawName, extractedFileMd5);
-                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                     return false;
                 }
 
@@ -211,25 +315,25 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                 if (oldDexCrc.equals("0")) {
                     if (patchFileEntry == null) {
                         TinkerLog.w(TAG, "patch entry is null. path:" + patchRealPath);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
 
                     //it is a new file, but maybe we need to repack the dex file
                     if (!extractDexFile(patch, patchFileEntry, extractedFile, info)) {
                         TinkerLog.w(TAG, "Failed to extract raw patch file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
                 } else if (dexDiffMd5.equals("0")) {
-                    // skip process old dex for dalvik vm
+                    // skip process old dex for real dalvik vm
                     if (!ShareTinkerInternals.isVmArt()) {
                         continue;
                     }
 
                     if (rawApkFileEntry == null) {
                         TinkerLog.w(TAG, "apk entry is null. path:" + patchRealPath);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
 
@@ -237,110 +341,60 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                     String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());
                     if (!rawEntryCrc.equals(oldDexCrc)) {
                         TinkerLog.e(TAG, "apk entry %s crc is not equal, expect crc: %s, got crc: %s", patchRealPath, oldDexCrc, rawEntryCrc);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
 
-                    InputStream oldDexIs = null;
-                    try {
-                        oldDexIs = apk.getInputStream(rawApkFileEntry);
-                        new DexPatchApplier(oldDexIs, (int) rawApkFileEntry.getSize(), null, smallPatchInfoFile).executeAndSaveTo(extractedFile);
-                    } catch (Throwable e) {
-                        TinkerLog.w(TAG, "Failed to recover dex file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
-                        SharePatchFileUtil.safeDeleteFile(extractedFile);
-                        return false;
-                    } finally {
-                        SharePatchFileUtil.closeQuietly(oldDexIs);
-                    }
+                    // Small patched dex generating strategy was disabled, we copy full original dex directly now.
+                    //patchDexFile(apk, patch, rawApkFileEntry, null, info, smallPatchInfoFile, extractedFile);
+                    extractDexFile(apk, rawApkFileEntry, extractedFile, info);
 
                     if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) {
-                        TinkerLog.w(TAG, "Failed to recover dex file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        TinkerLog.w(TAG, "Failed to recover dex file when verify patched dex: " + extractedFile.getPath());
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         SharePatchFileUtil.safeDeleteFile(extractedFile);
                         return false;
                     }
                 } else {
                     if (patchFileEntry == null) {
                         TinkerLog.w(TAG, "patch entry is null. path:" + patchRealPath);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
 
                     if (!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)) {
                         TinkerLog.w(TAG, "meta file md5 invalid, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), info.rawName, dexDiffMd5);
-                        manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                        manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                         return false;
                     }
 
                     if (rawApkFileEntry == null) {
                         TinkerLog.w(TAG, "apk entry is null. path:" + patchRealPath);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
                     //check source crc instead of md5 for faster
                     String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());
                     if (!rawEntryCrc.equals(oldDexCrc)) {
                         TinkerLog.e(TAG, "apk entry %s crc is not equal, expect crc: %s, got crc: %s", patchRealPath, oldDexCrc, rawEntryCrc);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         return false;
                     }
 
-                    final boolean isRawDexFile = SharePatchFileUtil.isRawDexFile(info.rawName);
-                    InputStream oldInputStream = apk.getInputStream(rawApkFileEntry);
-                    InputStream newInputStream = patch.getInputStream(patchFileEntry);
-                    //if it is not the dex file or we are using jar mode, we should repack the output dex to jar
-                    try {
-                        if (!isRawDexFile || info.isJarMode) {
-                            FileOutputStream fos = new FileOutputStream(extractedFile);
-                            ZipOutputStream zos = new ZipOutputStream(new
-                                BufferedOutputStream(fos));
-
-                            try {
-                                zos.putNextEntry(new ZipEntry(ShareConstants.DEX_IN_JAR));
-                                //it is not a raw dex file, we do not want to any temp files
-                                int oldDexSize;
-                                if (!isRawDexFile) {
-                                    ZipEntry entry;
-                                    ZipInputStream zis = new ZipInputStream(oldInputStream);
-                                    while ((entry = zis.getNextEntry()) != null) {
-                                        if (ShareConstants.DEX_IN_JAR.equals(entry.getName())) break;
-                                    }
-                                    if (entry == null) {
-                                        throw new TinkerRuntimeException("can't recognize zip dex format file:" + extractedFile.getAbsolutePath());
-                                    }
-                                    oldInputStream = zis;
-                                    oldDexSize = (int) entry.getSize();
-                                } else {
-                                    oldDexSize = (int) rawApkFileEntry.getSize();
-                                }
-                                new DexPatchApplier(oldInputStream, oldDexSize, newInputStream, smallPatchInfoFile).executeAndSaveTo(zos);
-                                zos.closeEntry();
-                            } finally {
-                                SharePatchFileUtil.closeQuietly(zos);
-                            }
-
-                        } else {
-                            new DexPatchApplier(oldInputStream, (int) rawApkFileEntry.getSize(), newInputStream, smallPatchInfoFile).executeAndSaveTo(extractedFile);
-                        }
-                    } finally {
-                        SharePatchFileUtil.closeQuietly(oldInputStream);
-                        SharePatchFileUtil.closeQuietly(newInputStream);
-                    }
+                    patchDexFile(apk, patch, rawApkFileEntry, patchFileEntry, info, extractedFile);
 
                     if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) {
-                        TinkerLog.w(TAG, "Failed to recover dex file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
+                        TinkerLog.w(TAG, "Failed to recover dex file when verify patched dex: " + extractedFile.getPath());
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);
                         SharePatchFileUtil.safeDeleteFile(extractedFile);
                         return false;
                     }
-                    TinkerLog.w(TAG, "success recover dex file: %s, use time: %d",
-                        extractedFile.getPath(), (System.currentTimeMillis() - start));
+
+                    TinkerLog.w(TAG, "success recover dex file: %s, size: %d, use time: %d",
+                            extractedFile.getPath(), extractedFile.length(), (System.currentTimeMillis() - start));
                 }
             }
-
         } catch (Throwable e) {
-//            e.printStackTrace();
             throw new TinkerRuntimeException("patch " + ShareTinkerInternals.getTypeString(type) + " extract failed (" + e.getMessage() + ").", e);
         } finally {
             SharePatchFileUtil.closeZip(apk);
@@ -374,7 +428,7 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
             TinkerLog.i(TAG, "try Extracting " + extractTo.getPath());
             try {
                 zos = new ZipOutputStream(new
-                    BufferedOutputStream(fos));
+                        BufferedOutputStream(fos));
                 bis = new BufferedInputStream(in);
 
                 byte[] buffer = new byte[ShareConstants.BUFFER_SIZE];
@@ -404,6 +458,16 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
         return isExtractionSuccessful;
     }
 
+//    /**
+//     * reject dalvik vm, but sdk version is larger than 21
+//     */
+//    private static void checkVmArtProperty() {
+//        boolean art = ShareTinkerInternals.isVmArt();
+//        if (!art && Build.VERSION.SDK_INT >= 21) {
+//            throw new TinkerRuntimeException(ShareConstants.CHECK_VM_PROPERTY_FAIL + ", it is dalvik vm, but sdk version " + Build.VERSION.SDK_INT + " is larger than 21!");
+//        }
+//    }
+
     private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File extractTo, ShareDexDiffPatchInfo dexInfo) throws IOException {
         final String fileMd5 = ShareTinkerInternals.isVmArt() ? dexInfo.destMd5InArt : dexInfo.destMd5InDvm;
         final String rawName = dexInfo.rawName;
@@ -415,4 +479,70 @@ private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File
         return extract(zipFile, entryFile, extractTo, fileMd5, true);
     }
 
+    /**
+     * Generate patched dex file (May wrapped it by a jar if needed.)
+     * @param baseApk
+     *   OldApk.
+     * @param patchPkg
+     *   Patch package, it is also a zip file.
+     * @param oldDexEntry
+     *   ZipEntry of old dex.
+     * @param patchFileEntry
+     *   ZipEntry of patch file. (also ends with .dex) This could be null.
+     * @param patchInfo
+     *   Parsed patch info from package-meta.txt
+     * @param patchedDexFile
+     *   Patched dex file, may be a jar.
+     *
+     * <b>Notice: patchFileEntry and smallPatchInfoFile cannot both be null.</b>
+     *
+     * @throws IOException
+     */
+    private static void patchDexFile(
+            ZipFile baseApk, ZipFile patchPkg, ZipEntry oldDexEntry, ZipEntry patchFileEntry,
+            ShareDexDiffPatchInfo patchInfo,  File patchedDexFile) throws IOException {
+        InputStream oldDexStream = null;
+        InputStream patchFileStream = null;
+        try {
+            oldDexStream = new BufferedInputStream(baseApk.getInputStream(oldDexEntry));
+            patchFileStream = (patchFileEntry != null ? new BufferedInputStream(patchPkg.getInputStream(patchFileEntry)) : null);
+
+            final boolean isRawDexFile = SharePatchFileUtil.isRawDexFile(patchInfo.rawName);
+            if (!isRawDexFile || patchInfo.isJarMode) {
+                ZipOutputStream zos = null;
+                try {
+                    zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(patchedDexFile)));
+                    zos.putNextEntry(new ZipEntry(ShareConstants.DEX_IN_JAR));
+                    // Old dex is not a raw dex file.
+                    if (!isRawDexFile) {
+                        ZipInputStream zis = null;
+                        try {
+                            zis = new ZipInputStream(oldDexStream);
+                            ZipEntry entry;
+                            while ((entry = zis.getNextEntry()) != null) {
+                                if (ShareConstants.DEX_IN_JAR.equals(entry.getName())) break;
+                            }
+                            if (entry == null) {
+                                throw new TinkerRuntimeException("can't recognize zip dex format file:" + patchedDexFile.getAbsolutePath());
+                            }
+                            new DexPatchApplier(zis, patchFileStream).executeAndSaveTo(zos);
+                        } finally {
+                            SharePatchFileUtil.closeQuietly(zis);
+                        }
+                    } else {
+                        new DexPatchApplier(oldDexStream, patchFileStream).executeAndSaveTo(zos);
+                    }
+                    zos.closeEntry();
+                } finally {
+                    SharePatchFileUtil.closeQuietly(zos);
+                }
+            } else {
+                new DexPatchApplier(oldDexStream, patchFileStream).executeAndSaveTo(patchedDexFile);
+            }
+        } finally {
+            SharePatchFileUtil.closeQuietly(oldDexStream);
+            SharePatchFileUtil.closeQuietly(patchFileStream);
+        }
+    }
+
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
deleted file mode 100644
index f9910f82..00000000
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.lib.patch;
-
-import android.content.Context;
-
-import com.tencent.tinker.lib.service.PatchResult;
-import com.tencent.tinker.lib.tinker.Tinker;
-import com.tencent.tinker.lib.util.TinkerLog;
-import com.tencent.tinker.loader.shareutil.ShareConstants;
-import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
-import com.tencent.tinker.loader.shareutil.SharePatchInfo;
-import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
-import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
-
-import java.io.File;
-
-/**
- * Created by zhangshaowen on 16/3/18.
- *
- * if some of a patch data(such as so, dex) is deleted,
- * we will try to repair them via RepairPatch
- * you can implement your own patch processor class
- */
-public class RepairPatch extends AbstractPatch {
-    private static final String TAG = "Tinker.RepairPatch";
-
-    @Override
-    public boolean tryPatch(Context context, String tempPatchPath, PatchResult patchResult) {
-
-        Tinker manager = Tinker.with(context);
-
-        final File patchFile = new File(tempPatchPath);
-
-        if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:patch is disabled, just return");
-            return false;
-        }
-
-        if (!patchFile.isFile() || !patchFile.exists()) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:patch file is not found, just return");
-            return false;
-        }
-        //check the signature, we should create a new checker
-        ShareSecurityCheck signatureCheck = new ShareSecurityCheck(context);
-
-
-        int returnCode = ShareTinkerInternals.checkSignatureAndTinkerID(context, patchFile, signatureCheck);
-        if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:onPatchPackageCheckFail");
-            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, false, returnCode);
-            return false;
-        }
-
-        patchResult.patchTinkerID = signatureCheck.getNewTinkerID();
-        patchResult.baseTinkerID = signatureCheck.getTinkerID();
-
-        //it is a old patch, so we should find a exist
-        SharePatchInfo oldInfo = manager.getTinkerLoadResultIfPresent().patchInfo;
-        String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
-
-        //use md5 as version
-        patchResult.patchVersion = patchMd5;
-
-        if (oldInfo == null) {
-            TinkerLog.e(TAG, "OldPatchProcessor tryPatch:onPatchVersionCheckFail, oldInfo is null");
-            manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5, false);
-            return false;
-        } else {
-            if (oldInfo.oldVersion == null || oldInfo.newVersion == null) {
-                TinkerLog.e(TAG, "RepairPatch tryPatch:onPatchInfoCorrupted");
-                manager.getPatchReporter().onPatchInfoCorrupted(patchFile, oldInfo.oldVersion, oldInfo.newVersion, false);
-                return false;
-            }
-            //already have patch
-            if (!oldInfo.oldVersion.equals(patchMd5) || !oldInfo.newVersion.equals(patchMd5)) {
-                TinkerLog.e(TAG, "RepairPatch tryPatch:onPatchVersionCheckFail");
-                manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5, false);
-                return false;
-            }
-        }
-
-        //check ok
-        final String patchDirectory = manager.getPatchDirectory().getAbsolutePath();
-
-        final String patchName = SharePatchFileUtil.getPatchVersionDirectory(patchMd5);
-
-        final String patchVersionDirectory = patchDirectory + "/" + patchName;
-
-        if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, patchFile, false)) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:try patch dex failed");
-            return false;
-        }
-
-        if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, patchFile, false)) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:try patch library failed");
-            return false;
-        }
-
-        if (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, patchFile, false)) {
-            TinkerLog.e(TAG, "RepairPatch tryPatch:try patch resource failed");
-            return false;
-        }
-        return true;
-    }
-
-}
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
index 21ac8d85..5bdbf310 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
@@ -50,7 +50,7 @@
     protected static final String TAG = "Tinker.ResDiffPatchInternal";
 
     protected static boolean tryRecoverResourceFiles(Tinker manager, ShareSecurityCheck checker, Context context,
-                                                String patchVersionDirectory, File patchFile, boolean isUpgradePatch) {
+                                                String patchVersionDirectory, File patchFile) {
 
         if (!manager.isEnabledForResource()) {
             TinkerLog.w(TAG, "patch recover, resource is not enabled");
@@ -64,23 +64,24 @@ protected static boolean tryRecoverResourceFiles(Tinker manager, ShareSecurityCh
         }
 
         long begin = SystemClock.elapsedRealtime();
-        boolean result = patchResourceExtractViaResourceDiff(context, patchVersionDirectory, resourceMeta, patchFile, isUpgradePatch);
+        boolean result = patchResourceExtractViaResourceDiff(context, patchVersionDirectory, resourceMeta, patchFile);
         long cost = SystemClock.elapsedRealtime() - begin;
-        TinkerLog.i(TAG, "recover resource result:%b, cost:%d, isNewPatch:%b", result, cost, isUpgradePatch);
+        TinkerLog.i(TAG, "recover resource result:%b, cost:%d", result, cost);
         return result;
     }
 
-    private static boolean patchResourceExtractViaResourceDiff(Context context, String patchVersionDirectory, String meta, File patchFile, boolean isUpgradePatch) {
+    private static boolean patchResourceExtractViaResourceDiff(Context context, String patchVersionDirectory,
+                                                               String meta, File patchFile) {
         String dir = patchVersionDirectory + "/" + ShareConstants.RES_PATH + "/";
 
-        if (!extractResourceDiffInternals(context, dir, meta, patchFile, TYPE_RESOURCE, isUpgradePatch)) {
+        if (!extractResourceDiffInternals(context, dir, meta, patchFile, TYPE_RESOURCE)) {
             TinkerLog.w(TAG, "patch recover, extractDiffInternals fail");
             return false;
         }
         return true;
     }
 
-    private static boolean extractResourceDiffInternals(Context context, String dir, String meta, File patchFile, int type, boolean isUpgradePatch) {
+    private static boolean extractResourceDiffInternals(Context context, String dir, String meta, File patchFile, int type) {
         ShareResPatchInfo resPatchInfo = new ShareResPatchInfo();
         ShareResPatchInfo.parseAllResPatchInfo(meta, resPatchInfo);
         TinkerLog.i(TAG, "res dir: %s, meta: %s", dir, resPatchInfo.toString());
@@ -88,7 +89,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
 
         if (!SharePatchFileUtil.checkIfMd5Valid(resPatchInfo.resArscMd5)) {
             TinkerLog.w(TAG, "resource meta file md5 mismatch, type:%s, md5: %s", ShareTinkerInternals.getTypeString(type), resPatchInfo.resArscMd5);
-            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
             return false;
         }
         File directory = new File(dir);
@@ -117,7 +118,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
             }
             String apkPath = applicationInfo.sourceDir;
 
-            if (!checkAndExtractResourceLargeFile(context, apkPath, directory, patchFile, resPatchInfo, type, isUpgradePatch)) {
+            if (!checkAndExtractResourceLargeFile(context, apkPath, directory, patchFile, resPatchInfo, type)) {
                 return false;
             }
 
@@ -136,6 +137,9 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                         throw new TinkerRuntimeException("zipEntry is null when get from oldApk");
                     }
                     String name = zipEntry.getName();
+                    if (name.contains("../")) {
+                        continue;
+                    }
                     if (ShareResPatchInfo.checkFileInPattern(resPatchInfo.patterns, name)) {
                         //won't contain in add set.
                         if (!resPatchInfo.deleteRes.contains(name)
@@ -152,7 +156,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                 TinkerZipEntry manifestZipEntry = oldApk.getEntry(ShareConstants.RES_MANIFEST);
                 if (manifestZipEntry == null) {
                     TinkerLog.w(TAG, "manifest patch entry is null. path:" + ShareConstants.RES_MANIFEST);
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, ShareConstants.RES_MANIFEST, type, isUpgradePatch);
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, ShareConstants.RES_MANIFEST, type);
                     return false;
                 }
                 ResUtil.extractTinkerEntry(oldApk, manifestZipEntry, out);
@@ -162,7 +166,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                     TinkerZipEntry largeZipEntry = oldApk.getEntry(name);
                     if (largeZipEntry == null) {
                         TinkerLog.w(TAG, "large patch entry is null. path:" + name);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type);
                         return false;
                     }
                     ShareResPatchInfo.LargeModeInfo largeModeInfo = resPatchInfo.largeModMap.get(name);
@@ -174,7 +178,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                     TinkerZipEntry addZipEntry = newApk.getEntry(name);
                     if (addZipEntry == null) {
                         TinkerLog.w(TAG, "add patch entry is null. path:" + name);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type);
                         return false;
                     }
                     ResUtil.extractTinkerEntry(newApk, addZipEntry, out);
@@ -185,7 +189,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                     TinkerZipEntry modZipEntry = newApk.getEntry(name);
                     if (modZipEntry == null) {
                         TinkerLog.w(TAG, "mod patch entry is null. path:" + name);
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type, isUpgradePatch);
+                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type);
                         return false;
                     }
                     ResUtil.extractTinkerEntry(newApk, modZipEntry, out);
@@ -211,7 +215,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
             if (!result) {
                 TinkerLog.i(TAG, "check final new resource file fail path:%s, entry count:%d, size:%d", resOutput.getAbsolutePath(), totalEntryCount, resOutput.length());
                 SharePatchFileUtil.safeDeleteFile(resOutput);
-                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, ShareConstants.RES_NAME, type, isUpgradePatch);
+                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, ShareConstants.RES_NAME, type);
                 return false;
             }
 
@@ -224,7 +228,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
     }
 
     private static boolean checkAndExtractResourceLargeFile(Context context, String apkPath, File directory,
-                                                            File patchFile, ShareResPatchInfo resPatchInfo, int type, boolean isUpgradePatch) {
+                                                            File patchFile, ShareResPatchInfo resPatchInfo, int type) {
         long start = System.currentTimeMillis();
         Tinker manager = Tinker.with(context);
         ZipFile apkFile = null;
@@ -236,14 +240,14 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
             File arscFile = new File(directory, ShareConstants.RES_ARSC);
             if (arscEntry == null) {
                 TinkerLog.w(TAG, "resources apk entry is null. path:" + ShareConstants.RES_ARSC);
-                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, arscFile, ShareConstants.RES_ARSC, type, isUpgradePatch);
+                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, arscFile, ShareConstants.RES_ARSC, type);
                 return false;
             }
             //use base resources.arsc crc to identify base.apk
             String baseArscCrc = String.valueOf(arscEntry.getCrc());
             if (!baseArscCrc.equals(resPatchInfo.arscBaseCrc)) {
                 TinkerLog.e(TAG, "resources.arsc's crc is not equal, expect crc: %s, got crc: %s", resPatchInfo.arscBaseCrc, baseArscCrc);
-                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, arscFile, ShareConstants.RES_ARSC, type, isUpgradePatch);
+                manager.getPatchReporter().onPatchTypeExtractFail(patchFile, arscFile, ShareConstants.RES_ARSC, type);
                 return false;
             }
 
@@ -258,7 +262,7 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
 
                 if (largeModeInfo == null) {
                     TinkerLog.w(TAG, "resource not found largeModeInfo, type:%s, name: %s", ShareTinkerInternals.getTypeString(type), name);
-                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                     return false;
                 }
 
@@ -268,21 +272,21 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
                 //we do not check the intermediate files' md5 to save time, use check whether it is 32 length
                 if (!SharePatchFileUtil.checkIfMd5Valid(largeModeInfo.md5)) {
                     TinkerLog.w(TAG, "resource meta file md5 mismatch, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), name, largeModeInfo.md5);
-                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, isUpgradePatch, BasePatchInternal.getMetaCorruptedCode(type));
+                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                     return false;
                 }
                 patchZipFile = new ZipFile(patchFile);
                 ZipEntry patchEntry = patchZipFile.getEntry(name);
                 if (patchEntry == null) {
                     TinkerLog.w(TAG, "large mod patch entry is null. path:" + name);
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type, isUpgradePatch);
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type);
                     return false;
                 }
 
                 ZipEntry baseEntry = apkFile.getEntry(name);
                 if (baseEntry == null) {
                     TinkerLog.w(TAG, "resources apk entry is null. path:" + name);
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type, isUpgradePatch);
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type);
                     return false;
                 }
                 InputStream oldStream = null;
@@ -299,10 +303,10 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
                 if (!SharePatchFileUtil.verifyFileMd5(largeModeInfo.file, largeModeInfo.md5)) {
                     TinkerLog.w(TAG, "Failed to recover large modify file:%s", largeModeInfo.file.getPath());
                     SharePatchFileUtil.safeDeleteFile(largeModeInfo.file);
-                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type, isUpgradePatch);
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, largeModeInfo.file, name, type);
                     return false;
                 }
-                TinkerLog.w(TAG, "success recover large modify file:%s , file size:%d, use time:%d", largeModeInfo.file.getPath(), largeModeInfo.file.length(), (System.currentTimeMillis() - largeStart));
+                TinkerLog.w(TAG, "success recover large modify file:%s, file size:%d, use time:%d", largeModeInfo.file.getPath(), largeModeInfo.file.length(), (System.currentTimeMillis() - largeStart));
             }
             TinkerLog.w(TAG, "success recover all large modify use time:%d", (System.currentTimeMillis() - start));
         } catch (Throwable e) {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
index 3a91e09f..72257dac 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
@@ -17,6 +17,7 @@
 package com.tencent.tinker.lib.patch;
 
 import android.content.Context;
+import android.os.Build;
 
 import com.tencent.tinker.lib.service.PatchResult;
 import com.tencent.tinker.lib.tinker.Tinker;
@@ -49,23 +50,20 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
             return false;
         }
 
-        if (!patchFile.isFile() || !patchFile.exists()) {
+        if (!SharePatchFileUtil.isLegalFile(patchFile)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:patch file is not found, just return");
             return false;
         }
         //check the signature, we should create a new checker
         ShareSecurityCheck signatureCheck = new ShareSecurityCheck(context);
 
-        int returnCode = ShareTinkerInternals.checkSignatureAndTinkerID(context, patchFile, signatureCheck);
+        int returnCode = ShareTinkerInternals.checkTinkerPackage(context, manager.getTinkerFlags(), patchFile, signatureCheck);
         if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchPackageCheckFail");
-            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, true, returnCode);
+            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, returnCode);
             return false;
         }
 
-        patchResult.patchTinkerID = signatureCheck.getNewTinkerID();
-        patchResult.baseTinkerID = signatureCheck.getTinkerID();
-
         //it is a new patch, so we should not find a exist
         SharePatchInfo oldInfo = manager.getTinkerLoadResultIfPresent().patchInfo;
         String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
@@ -84,24 +82,24 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         if (oldInfo != null) {
             if (oldInfo.oldVersion == null || oldInfo.newVersion == null) {
                 TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchInfoCorrupted");
-                manager.getPatchReporter().onPatchInfoCorrupted(patchFile, oldInfo.oldVersion, oldInfo.newVersion, true);
+                manager.getPatchReporter().onPatchInfoCorrupted(patchFile, oldInfo.oldVersion, oldInfo.newVersion);
                 return false;
             }
 
-            if (oldInfo.oldVersion.equals(patchMd5) || oldInfo.newVersion.equals(patchMd5)) {
-                TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchVersionCheckFail");
-                manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5, true);
+            if (!SharePatchFileUtil.checkIfMd5Valid(patchMd5)) {
+                TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchVersionCheckFail md5 %s is valid", patchMd5);
+                manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5);
                 return false;
             }
-            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5);
+            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5, Build.FINGERPRINT);
         } else {
-            newInfo = new SharePatchInfo("", patchMd5);
+            newInfo = new SharePatchInfo("", patchMd5, Build.FINGERPRINT);
         }
 
         //check ok, we can real recover a new patch
         final String patchDirectory = manager.getPatchDirectory().getAbsolutePath();
 
-        TinkerLog.i(TAG, "UpgradePatch tryPatch:dexDiffMd5:%s", patchMd5);
+        TinkerLog.i(TAG, "UpgradePatch tryPatch:patchMd5:%s", patchMd5);
 
         final String patchName = SharePatchFileUtil.getPatchVersionDirectory(patchMd5);
 
@@ -115,42 +113,51 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
 
         //copy file
         File destPatchFile = new File(patchVersionDirectory + "/" + SharePatchFileUtil.getPatchVersionFile(patchMd5));
+
         try {
-            SharePatchFileUtil.copyFileUsingStream(patchFile, destPatchFile);
-            TinkerLog.w(TAG, "UpgradePatch after %s size:%d, %s size:%d", patchFile.getAbsolutePath(), patchFile.length(),
-                destPatchFile.getAbsolutePath(), destPatchFile.length());
+            // check md5 first
+            if (!patchMd5.equals(SharePatchFileUtil.getMD5(destPatchFile))) {
+                SharePatchFileUtil.copyFileUsingStream(patchFile, destPatchFile);
+                TinkerLog.w(TAG, "UpgradePatch copy patch file, src file: %s size: %d, dest file: %s size:%d", patchFile.getAbsolutePath(), patchFile.length(),
+                    destPatchFile.getAbsolutePath(), destPatchFile.length());
+            }
         } catch (IOException e) {
 //            e.printStackTrace();
             TinkerLog.e(TAG, "UpgradePatch tryPatch:copy patch file fail from %s to %s", patchFile.getPath(), destPatchFile.getPath());
-            manager.getPatchReporter().onPatchTypeExtractFail(patchFile, destPatchFile, patchFile.getName(), ShareConstants.TYPE_PATCH_FILE, true);
+            manager.getPatchReporter().onPatchTypeExtractFail(patchFile, destPatchFile, patchFile.getName(), ShareConstants.TYPE_PATCH_FILE);
             return false;
         }
 
         //we use destPatchFile instead of patchFile, because patchFile may be deleted during the patch process
-        if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile, true)) {
+        if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, try patch dex failed");
             return false;
         }
 
-        if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile, true)) {
+        if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, try patch library failed");
             return false;
         }
 
-        if (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile, true)) {
+        if (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, try patch resource failed");
             return false;
         }
 
+        // check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted
+        // just warn
+        if (!DexDiffPatchInternal.waitDexOptFile()) {
+            TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, check dex opt file failed");
+        }
+
         final File patchInfoFile = manager.getPatchInfoFile();
 
         if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, newInfo, SharePatchFileUtil.getPatchInfoLockFile(patchDirectory))) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, rewrite patch info failed");
-            manager.getPatchReporter().onPatchInfoCorrupted(patchFile, newInfo.oldVersion, newInfo.newVersion, true);
+            manager.getPatchReporter().onPatchInfoCorrupted(patchFile, newInfo.oldVersion, newInfo.newVersion);
             return false;
         }
 
-
         TinkerLog.w(TAG, "UpgradePatch tryPatch: done, it is ok");
         return true;
     }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
index f955477d..a45555e9 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
@@ -21,10 +21,11 @@
 
 import com.tencent.tinker.lib.service.TinkerPatchService;
 import com.tencent.tinker.lib.tinker.Tinker;
-import com.tencent.tinker.lib.tinker.TinkerInstaller;
+import com.tencent.tinker.lib.tinker.TinkerLoadResult;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.SharePatchInfo;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.io.File;
@@ -54,12 +55,11 @@ public DefaultLoadReporter(Context context) {
      *                  {@code ShareConstants.ERROR_PATCH_NOTEXIST}            the file of tempPatchPatch file is not exist
      *                  {@code ShareConstants.ERROR_PATCH_RUNNING}             the recover service is running now, try later
      *                  {@code ShareConstants.ERROR_PATCH_INSERVICE}           the recover service can't send patch request
-     *
-     * @param isUpgrade whether is a new patch, or just recover the old patch
      */
     @Override
-    public void onLoadPatchListenerReceiveFail(File patchFile, int errorCode, boolean isUpgrade) {
-        TinkerLog.i(TAG, "patch load Reporter: patch receive fail:%s, code:%d, isUpgrade:%b", patchFile.getAbsolutePath(), errorCode, isUpgrade);
+    public void onLoadPatchListenerReceiveFail(File patchFile, int errorCode) {
+        TinkerLog.i(TAG, "patch loadReporter onLoadPatchListenerReceiveFail: patch receive fail:%s, code:%d",
+            patchFile.getAbsolutePath(), errorCode);
     }
 
 
@@ -76,7 +76,7 @@ public void onLoadPatchListenerReceiveFail(File patchFile, int errorCode, boolea
      */
     @Override
     public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File patchDirectoryFile, String currentPatchName) {
-        TinkerLog.i(TAG, "patch version change from " + oldVersion + " to " + newVersion);
+        TinkerLog.i(TAG, "patch loadReporter onLoadPatchVersionChanged: patch version change from " + oldVersion + " to " + newVersion);
 
         if (oldVersion == null || newVersion == null) {
             return;
@@ -89,7 +89,7 @@ public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File
         if (!Tinker.with(context).isMainProcess()) {
             return;
         }
-        TinkerLog.i(TAG, "try kill all other process");
+        TinkerLog.i(TAG, "onLoadPatchVersionChanged, try kill all other process");
         //kill all other process to ensure that all process's code is the same.
         ShareTinkerInternals.killAllOtherProcess(context);
 
@@ -122,21 +122,10 @@ public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File
      */
     @Override
     public void onLoadFileNotFound(File file, int fileType, boolean isDirectory) {
-        TinkerLog.i(TAG, "patch file not found: %s, fileType:%d, isDirectory:%b", file.getAbsolutePath(), fileType, isDirectory);
-        if (fileType == ShareConstants.TYPE_DEX || fileType == ShareConstants.TYPE_DEX_OPT
-            || fileType == ShareConstants.TYPE_LIBRARY || fileType == ShareConstants.TYPE_RESOURCE) {
-            Tinker tinker = Tinker.with(context);
-
-            //we can recover at any process except recover process
-            if (!tinker.isPatchProcess()) {
-                File patchVersionFile = tinker.getTinkerLoadResultIfPresent().patchVersionFile;
-                if (patchVersionFile != null) {
-                    TinkerInstaller.onReceiveRepairPatch(context, patchVersionFile.getAbsolutePath());
-                }
-            }
-        } else if (fileType == ShareConstants.TYPE_PATCH_FILE || fileType == ShareConstants.TYPE_PATCH_INFO) {
-            Tinker.with(context).cleanPatch();
-        }
+        TinkerLog.i(TAG, "patch loadReporter onLoadFileNotFound: patch file not found: %s, fileType:%d, isDirectory:%b",
+            file.getAbsolutePath(), fileType, isDirectory);
+
+        checkAndCleanPatch();
     }
 
     /**
@@ -153,9 +142,9 @@ public void onLoadFileNotFound(File file, int fileType, boolean isDirectory) {
      */
     @Override
     public void onLoadFileMd5Mismatch(File file, int fileType) {
-        TinkerLog.i(TAG, "patch file md5 mismatch file: %s, fileType:%d", file.getAbsolutePath(), fileType);
+        TinkerLog.i(TAG, "patch load Reporter onLoadFileMd5Mismatch: patch file md5 mismatch file: %s, fileType:%d", file.getAbsolutePath(), fileType);
         //clean patch for safety
-        Tinker.with(context).cleanPatch();
+        checkAndCleanPatch();
     }
 
     /**
@@ -169,10 +158,10 @@ public void onLoadFileMd5Mismatch(File file, int fileType) {
      */
     @Override
     public void onLoadPatchInfoCorrupted(String oldVersion, String newVersion, File patchInfoFile) {
-        TinkerLog.i(TAG, "patch info file damage: %s", patchInfoFile.getAbsolutePath());
-        TinkerLog.i(TAG, "patch info file damage from version: %s to version: %s", oldVersion, newVersion);
+        TinkerLog.i(TAG, "patch loadReporter onLoadPatchInfoCorrupted: patch info file damage: %s, from version: %s to version: %s",
+            patchInfoFile.getAbsolutePath(), oldVersion, newVersion);
 
-        Tinker.with(context).cleanPatch();
+        checkAndCleanPatch();
     }
 
     /**
@@ -185,7 +174,7 @@ public void onLoadPatchInfoCorrupted(String oldVersion, String newVersion, File
      */
     @Override
     public void onLoadResult(File patchDirectory, int loadCode, long cost) {
-        TinkerLog.i(TAG, "patch load result, path:%s, code:%d, cost:%d", patchDirectory.getAbsolutePath(), loadCode, cost);
+        TinkerLog.i(TAG, "patch loadReporter onLoadResult: patch load result, path:%s, code:%d, cost:%d", patchDirectory.getAbsolutePath(), loadCode, cost);
         //you can just report the result here
     }
 
@@ -208,29 +197,40 @@ public void onLoadException(Throwable e, int errorCode) {
         switch (errorCode) {
             case ShareConstants.ERROR_LOAD_EXCEPTION_DEX:
                 if (e.getMessage().contains(ShareConstants.CHECK_DEX_INSTALL_FAIL)) {
-                    TinkerLog.e(TAG, "tinker dex check fail:" + e.getMessage());
+                    TinkerLog.e(TAG, "patch loadReporter onLoadException: tinker dex check fail:" + e.getMessage());
                 } else {
-                    TinkerLog.i(TAG, "patch load dex exception: %s", e);
+                    TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load dex exception: %s", e);
                 }
                 ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
                 TinkerLog.i(TAG, "dex exception disable tinker forever with sp");
                 break;
+            case ShareConstants.ERROR_LOAD_EXCEPTION_DEX_OPT:
+                TinkerLog.i(TAG, "patch load parallel dex opt exception: %s", e);
+                break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE:
-                TinkerLog.i(TAG, "patch load resource exception: %s", e);
+                if (e.getMessage().contains(ShareConstants.CHECK_RES_INSTALL_FAIL)) {
+                    TinkerLog.e(TAG, "patch loadReporter onLoadException: tinker res check fail:" + e.getMessage());
+                } else {
+                    TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load resource exception: %s", e);
+                }
+                ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
+                TinkerLog.i(TAG, "res exception disable tinker forever with sp");
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT:
-                TinkerLog.i(TAG, "patch load unCatch exception: %s", e);
+                TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load unCatch exception: %s", e);
                 ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
                 TinkerLog.i(TAG, "unCaught exception disable tinker forever with sp");
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_UNKNOWN:
-                TinkerLog.i(TAG, "patch load unknown exception: %s", e);
+                TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load unknown exception: %s", e);
+                //exception can be caught, it is no need to disable Tinker with sharedPreference
                 break;
         }
+        TinkerLog.e(TAG, "tinker load exception, welcome to submit issue to us: https://github.com/Tencent/tinker/issues");
         TinkerLog.printErrStackTrace(TAG, e, "tinker load exception");
 
         Tinker.with(context).setTinkerDisable();
-        Tinker.with(context).cleanPatch();
+        checkAndCleanPatch();
     }
     /**
      * check patch signature, TINKER_ID and meta files
@@ -246,10 +246,37 @@ public void onLoadException(Throwable e, int errorCode) {
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND}       can't find TINKER_PATCH in patch meta file
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL}             apk and patch's TINKER_PATCH value is not equal
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
+     *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     @Override
     public void onLoadPackageCheckFail(File patchFile, int errorCode) {
-        TinkerLog.i(TAG, "load patch package check fail file path:%s, errorCode:%d", patchFile.getAbsolutePath(), errorCode);
-        Tinker.with(context).cleanPatch();
+        TinkerLog.i(TAG, "patch loadReporter onLoadPackageCheckFail: "
+            + "load patch package check fail file path:%s, errorCode:%d", patchFile.getAbsolutePath(), errorCode);
+        checkAndCleanPatch();
+    }
+
+    /**
+     * other process may have installed old patch version,
+     * if we try to clean patch, we should kill other process first
+     */
+    public void checkAndCleanPatch() {
+        Tinker tinker = Tinker.with(context);
+        //only main process can load a new patch
+        if (tinker.isMainProcess()) {
+            TinkerLoadResult tinkerLoadResult = tinker.getTinkerLoadResultIfPresent();
+            //if versionChange and the old patch version is not ""
+            if (tinkerLoadResult.versionChanged) {
+                SharePatchInfo sharePatchInfo = tinkerLoadResult.patchInfo;
+                if (sharePatchInfo != null && !ShareTinkerInternals.isNullOrNil(sharePatchInfo.oldVersion)) {
+                    TinkerLog.w(TAG, "checkAndCleanPatch, oldVersion %s is not null, try kill all other process",
+                        sharePatchInfo.oldVersion);
+
+                    ShareTinkerInternals.killAllOtherProcess(context);
+                }
+            }
+
+        }
+        tinker.cleanPatch();
+
     }
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
index c1717c41..9d1dca7e 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
@@ -52,7 +52,7 @@ public DefaultPatchReporter(Context context) {
      */
     @Override
     public void onPatchServiceStart(Intent intent) {
-        TinkerLog.i(TAG, "patchReporter: patch service start");
+        TinkerLog.i(TAG, "patchReporter onPatchServiceStart: patch service start");
     }
 
     /**
@@ -69,10 +69,12 @@ public void onPatchServiceStart(Intent intent) {
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND}       can't find TINKER_PATCH in patch meta file
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL}             apk and patch's TINKER_PATCH value is not equal
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
+     *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     @Override
-    public void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int errorCode) {
-        TinkerLog.i(TAG, "patchReporter: package check failed. path:%s, isUpgrade:%b, code:%d", patchFile.getAbsolutePath(), isUpgradePatch, errorCode);
+    public void onPatchPackageCheckFail(File patchFile, int errorCode) {
+        TinkerLog.i(TAG, "patchReporter onPatchPackageCheckFail: package check failed. path:%s, code:%d",
+            patchFile.getAbsolutePath(), errorCode);
         //only meta corrupted, need to delete temp files. others is just in the check time!
         if (errorCode == ShareConstants.ERROR_PACKAGE_CHECK_DEX_META_CORRUPTED
             || errorCode == ShareConstants.ERROR_PACKAGE_CHECK_LIB_META_CORRUPTED
@@ -89,11 +91,11 @@ public void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int
      * @param patchFile        the input patch file to recover
      * @param oldPatchInfo     the current patch info
      * @param patchFileVersion it is the md5 of the input patchFile
-     * @param isUpgradePatch   whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: patch version exist. path:%s, version:%s, isUpgrade:%b", patchFile.getAbsolutePath(), patchFileVersion, isUpgradePatch);
+    public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion) {
+        TinkerLog.i(TAG, "patchReporter onPatchVersionCheckFail: patch version exist. path:%s, version:%s",
+            patchFile.getAbsolutePath(), patchFileVersion);
         //no need to delete temp files, because it is only in the check time!
     }
 
@@ -109,12 +111,11 @@ public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo,
      *                       {@code ShareConstants.TYPE_LIBRARY}     extract patch library fail
      *                       {@code ShareConstants.TYPE_PATCH_FILE}  copy patch file fail
      *                       {@code ShareConstants.TYPE_RESOURCE}    extract patch resource fail
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: file extract fail type:%s, path:%s, extractTo:%s, filename:%s, isUpgrade:%b",
-            ShareTinkerInternals.getTypeString(fileType), patchFile.getPath(), extractTo.getPath(), filename, isUpgradePatch);
+    public void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType) {
+        TinkerLog.i(TAG, "patchReporter onPatchTypeExtractFail: file extract fail type:%s, path:%s, extractTo:%s, filename:%s",
+            ShareTinkerInternals.getTypeString(fileType), patchFile.getPath(), extractTo.getPath(), filename);
         //delete temp files
         Tinker.with(context).cleanPatchByVersion(patchFile);
     }
@@ -126,12 +127,11 @@ public void onPatchTypeExtractFail(File patchFile, File extractTo, String filena
      * @param dexFile        the dex file
      * @param optDirectory
      * @param dexName        dexName try to dexOpt
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: dex opt fail path:%s, dexPath:%s, optDir:%s, dexName:%s, isUpgrade:%b",
-            patchFile.getAbsolutePath(), dexFile.getPath(), optDirectory, dexName, isUpgradePatch);
+    public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t) {
+        TinkerLog.i(TAG, "patchReporter onPatchDexOptFail: dex opt fail path:%s, dexPath:%s, optDir:%s, dexName:%s",
+            patchFile.getAbsolutePath(), dexFile.getPath(), optDirectory, dexName);
         TinkerLog.printErrStackTrace(TAG, t, "onPatchDexOptFail:");
         //delete temp files
         Tinker.with(context).cleanPatchByVersion(patchFile);
@@ -143,11 +143,11 @@ public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory,
      * @param patchFile      the input patch file to recover
      * @param success        if it is success
      * @param cost           cost time in ms
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchResult(File patchFile, boolean success, long cost, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: patch all result path:%s, success:%b, cost:%d, isUpgrade:%b", patchFile.getAbsolutePath(), success, cost, isUpgradePatch);
+    public void onPatchResult(File patchFile, boolean success, long cost) {
+        TinkerLog.i(TAG, "patchReporter onPatchResult: patch all result path:%s, success:%b, cost:%d",
+            patchFile.getAbsolutePath(), success, cost);
         //you can just report the result here
     }
 
@@ -158,11 +158,11 @@ public void onPatchResult(File patchFile, boolean success, long cost, boolean is
      * @param patchFile      the input patch file to recover
      * @param oldVersion     old patch version
      * @param newVersion     new patch version
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: patch info is corrupted. old:%s, new:%s, isUpgradeP:%b", oldVersion, newVersion, isUpgradePatch);
+    public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion) {
+        TinkerLog.i(TAG, "patchReporter onPatchInfoCorrupted: patch info is corrupted. old:%s, new:%s",
+            oldVersion, newVersion);
         //patch.info is corrupted, just clean all patch
         Tinker.with(context).cleanPatch();
     }
@@ -174,11 +174,16 @@ public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVe
      *
      * @param patchFile      the input file to patch
      * @param e
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
     @Override
-    public void onPatchException(File patchFile, Throwable e, boolean isUpgradePatch) {
-        TinkerLog.i(TAG, "patchReporter: patch exception path:%s, throwable:%s, isUpgrade:%b", patchFile.getAbsolutePath(), e.getMessage(), isUpgradePatch);
+    public void onPatchException(File patchFile, Throwable e) {
+        TinkerLog.i(TAG, "patchReporter onPatchException: patch exception path:%s, throwable:%s",
+            patchFile.getAbsolutePath(), e.getMessage());
+        TinkerLog.e(TAG, "tinker patch exception, welcome to submit issue to us: https://github.com/Tencent/tinker/issues");
+//        if (e.getMessage().contains(ShareConstants.CHECK_VM_PROPERTY_FAIL)) {
+//            ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
+//            TinkerLog.i(TAG, "check vm property exception disable tinker forever with sp");
+//        }
         TinkerLog.printErrStackTrace(TAG, e, "tinker patch exception");
         //don't accept request any more!
         Tinker.with(context).setTinkerDisable();
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
index 67f4c7aa..6ff69254 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
@@ -36,9 +36,8 @@
      *                  {@code ShareConstants.ERROR_PATCH_NOTEXIST}            the file of tempPatchPatch file is not exist
      *                  {@code ShareConstants.ERROR_PATCH_RUNNING}             the recover service is running now, try later
      *                  {@code ShareConstants.ERROR_PATCH_INSERVICE}           the recover service can't send patch request
-     * @param isUpgrade whether is a new patch, or just recover the old patch
      */
-    void onLoadPatchListenerReceiveFail(File patchFile, int errorCode, boolean isUpgrade);
+    void onLoadPatchListenerReceiveFail(File patchFile, int errorCode);
 
     /**
      * we can only handle patch version change in the main process,
@@ -134,6 +133,7 @@
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND}       can't find TINKER_PATCH in patch meta file
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL}             apk and patch's TINKER_PATCH value is not equal
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
+     *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
     void onLoadPackageCheckFail(File patchFile, int errorCode);
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
index dbc5860c..7ba65da4 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
@@ -19,7 +19,6 @@
 
 import android.content.Intent;
 
-import com.tencent.tinker.lib.patch.RepairPatch;
 import com.tencent.tinker.lib.patch.UpgradePatch;
 import com.tencent.tinker.lib.service.DefaultTinkerResultService;
 import com.tencent.tinker.loader.shareutil.SharePatchInfo;
@@ -29,12 +28,8 @@
 /**
  * Created by zhangshaowen on 16/3/14.
  *
- * isUpgradePatch:
- * true: means that it is a newly patch, we would default use {@link UpgradePatch}
+ * means that it is a newly patch, we would default use {@link UpgradePatch}
  * to do the job
- *
- * false: means that there are some files missing in current patch, we want to repair them,
- * we would default use {@link RepairPatch} to do the recover patch job
  */
 public interface PatchReporter {
 
@@ -59,8 +54,9 @@
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND}       can't find TINKER_PATCH in patch meta file
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL}             apk and patch's TINKER_PATCH value is not equal
      *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED}         resource meta file's format check fail
+     *                  {@code ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT}          some patch file type is not supported for current tinkerFlag
      */
-    void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int errorCode);
+    void onPatchPackageCheckFail(File patchFile, int errorCode);
 
     /**
      * for upgrade patch, patchFileVersion can't equal oldVersion or newVersion in oldPatchInfo
@@ -69,9 +65,8 @@
      * @param patchFile        the input patch file to recover
      * @param oldPatchInfo     the current patch info
      * @param patchFileVersion it is the md5 of the input patchFile
-     * @param isUpgradePatch   whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion, boolean isUpgradePatch);
+    void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion);
 
 
     /**
@@ -86,9 +81,8 @@
      *                       {@code ShareConstants.TYPE_LIBRARY}     extract patch library fail
      *                       {@code ShareConstants.TYPE_PATCH_FILE}  copy patch file fail
      *                       {@code ShareConstants.TYPE_RESOURCE}    extract patch resource fail
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType, boolean isUpgradePatch);
+    void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType);
 
 
     /**
@@ -99,9 +93,8 @@
      * @param optDirectory
      * @param dexName        dexName try to dexOpt
      * @param t              throwable
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t, boolean isUpgradePatch);
+    void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t);
 
 
     /**
@@ -110,9 +103,8 @@
      * @param patchFile      the input patch file to recover
      * @param success        if it is success
      * @param cost           cost time in ms
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchResult(File patchFile, boolean success, long cost, boolean isUpgradePatch);
+    void onPatchResult(File patchFile, boolean success, long cost);
 
     /**
      * recover patch occur unknown exception that we have wrap try catch for you!
@@ -121,9 +113,8 @@
      *
      * @param patchFile      the input file to patch
      * @param e
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchException(File patchFile, Throwable e, boolean isUpgradePatch);
+    void onPatchException(File patchFile, Throwable e);
 
     /**
      * when we load a new patch, we need to rewrite the patch.info file.
@@ -132,8 +123,7 @@
      * @param patchFile      the input patch file to recover
      * @param oldVersion     old patch version
      * @param newVersion     new patch version
-     * @param isUpgradePatch whether it is a new patch file, or just recover some of the current patch files
      */
-    void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion, boolean isUpgradePatch);
+    void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion);
 
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
index 0ecb1bca..95429503 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
@@ -32,7 +32,6 @@
 
     private static final String RESULT_EXTRA = "result_extra";
 
-    private static Class<? extends AbstractResultService> resultServiceClass = null;
 
     /**
      * Creates an IntentService.  Invoked by your subclass's constructor.
@@ -41,25 +40,19 @@ public AbstractResultService() {
         super(AbstractResultService.class.getSimpleName());
     }
 
-    public static void runResultService(Context context, PatchResult result) {
+    public static void runResultService(Context context, PatchResult result, String resultServiceClass) {
         if (resultServiceClass == null) {
             throw new TinkerRuntimeException("resultServiceClass is null.");
         }
-        Intent intent = new Intent(context, resultServiceClass);
-        intent.putExtra(RESULT_EXTRA, result);
-
-        context.startService(intent);
-    }
-
-    public static void setResultServiceClass(Class<? extends AbstractResultService> serviceClass) {
-        resultServiceClass = serviceClass;
-        //try to load
         try {
-            Class.forName(serviceClass.getName());
-        } catch (ClassNotFoundException e) {
-//            e.printStackTrace();
-        }
+            Intent intent = new Intent();
+            intent.setClassName(context, resultServiceClass);
+            intent.putExtra(RESULT_EXTRA, result);
 
+            context.startService(intent);
+        } catch (Throwable throwable) {
+            TinkerLog.e(TAG, "run result service fail, exception:" + throwable);
+        }
     }
 
     @Override
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/DefaultTinkerResultService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/DefaultTinkerResultService.java
index 078fb5ad..6291a457 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/DefaultTinkerResultService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/DefaultTinkerResultService.java
@@ -21,6 +21,7 @@
 import com.tencent.tinker.lib.tinker.TinkerLoadResult;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.lib.util.TinkerServiceInternals;
+import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 
 import java.io.File;
@@ -49,23 +50,41 @@ public void onPatchResult(PatchResult result) {
 
         // if success and newPatch, it is nice to delete the raw file, and restart at once
         // only main process can load an upgrade patch!
-        if (result.isSuccess && result.isUpgradePatch) {
-            File rawFile = new File(result.rawPatchFilePath);
-            if (rawFile.exists()) {
-                TinkerLog.i(TAG, "save delete raw patch file");
-                SharePatchFileUtil.safeDeleteFile(rawFile);
-            }
+        if (result.isSuccess) {
+            deleteRawPatchFile(new File(result.rawPatchFilePath));
             if (checkIfNeedKill(result)) {
                 android.os.Process.killProcess(android.os.Process.myPid());
             } else {
                 TinkerLog.i(TAG, "I have already install the newly patch version!");
             }
         }
+    }
 
-        //repair current patch fail, just clean!
-        if (!result.isSuccess && !result.isUpgradePatch) {
-            Tinker.with(getApplicationContext()).cleanPatch();
+    /**
+     * don't delete tinker version file
+     * @param rawFile
+     */
+    public void deleteRawPatchFile(File rawFile) {
+        if (!SharePatchFileUtil.isLegalFile(rawFile)) {
+            return;
         }
+        TinkerLog.w(TAG, "deleteRawPatchFile rawFile path: %s", rawFile.getPath());
+        String fileName = rawFile.getName();
+        if (!fileName.startsWith(ShareConstants.PATCH_BASE_NAME)
+            || !fileName.endsWith(ShareConstants.PATCH_SUFFIX)) {
+            SharePatchFileUtil.safeDeleteFile(rawFile);
+            return;
+        }
+        File parentFile = rawFile.getParentFile();
+        if (!parentFile.getName().startsWith(ShareConstants.PATCH_BASE_NAME)) {
+            SharePatchFileUtil.safeDeleteFile(rawFile);
+        } else {
+            File grandFile = parentFile.getParentFile();
+            if (!grandFile.getName().equals(ShareConstants.PATCH_DIRECTORY_NAME)) {
+                SharePatchFileUtil.safeDeleteFile(rawFile);
+            }
+        }
+
     }
 
     public boolean checkIfNeedKill(PatchResult result) {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/PatchResult.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/PatchResult.java
index 7de1e3d9..268a4dd8 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/PatchResult.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/PatchResult.java
@@ -22,8 +22,6 @@
  * Created by zhangshaowen on 16/3/19.
  */
 public class PatchResult implements Serializable {
-    public boolean isUpgradePatch;
-
     public boolean isSuccess;
 
     public String rawPatchFilePath;
@@ -35,28 +33,19 @@
     //@Nullable
     public String patchVersion;
 
-    //@Nullable
-    public String patchTinkerID;
-
-    //@Nullable
-    public String baseTinkerID;
-
     @Override
     public String toString() {
         StringBuffer sb = new StringBuffer();
         sb.append("\nPatchResult: \n");
-        sb.append("isUpgradePatch:" + isUpgradePatch + "\n");
         sb.append("isSuccess:" + isSuccess + "\n");
         sb.append("rawPatchFilePath:" + rawPatchFilePath + "\n");
         sb.append("costTime:" + costTime + "\n");
-        sb.append("patchVersion:" + patchVersion + "\n");
-        sb.append("patchTinkerID:" + patchTinkerID + "\n");
-        sb.append("baseTinkerID:" + baseTinkerID + "\n");
+        if (patchVersion != null) {
+            sb.append("patchVersion:" + patchVersion + "\n");
+        }
 
         if (e != null) {
             sb.append("Throwable:" + e.getMessage() + "\n");
-        } else {
-            sb.append("Throwable: null" + "\n");
         }
         return sb.toString();
     }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
index 75f254af..db7d4526 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
@@ -41,10 +41,11 @@
     private static final String TAG = "Tinker.TinkerPatchService";
 
     private static final String        PATCH_PATH_EXTRA      = "patch_path_extra";
-    private static final String        PATCH_NEW_EXTRA       = "patch_new_extra";
+    private static final String        RESULT_CLASS_EXTRA    = "patch_result_class";
+
     private static       AbstractPatch upgradePatchProcessor = null;
-    private static       AbstractPatch repairPatchProcessor  = null;
-    private static       int           notificationId        = ShareConstants.TINKER_PATCH_SERVICE_NOTIFICATION;
+    private static       int                                    notificationId       = ShareConstants.TINKER_PATCH_SERVICE_NOTIFICATION;
+    private static       Class<? extends AbstractResultService> resultServiceClass   = null;
 
     /**
      * Creates an IntentService.  Invoked by your subclass's constructor.
@@ -53,17 +54,26 @@ public TinkerPatchService() {
         super(TinkerPatchService.class.getSimpleName());
     }
 
-    public static void runPatchService(Context context, String path, boolean isUpgradePatch) {
-        Intent intent = new Intent(context, TinkerPatchService.class);
-        intent.putExtra(PATCH_PATH_EXTRA, path);
-        intent.putExtra(PATCH_NEW_EXTRA, isUpgradePatch);
-
-        context.startService(intent);
+    public static void runPatchService(Context context, String path) {
+        try {
+            Intent intent = new Intent(context, TinkerPatchService.class);
+            intent.putExtra(PATCH_PATH_EXTRA, path);
+            intent.putExtra(RESULT_CLASS_EXTRA, resultServiceClass.getName());
+            context.startService(intent);
+        } catch (Throwable throwable) {
+            TinkerLog.e(TAG, "start patch service fail, exception:" + throwable);
+        }
     }
 
-    public static void setPatchProcessor(AbstractPatch upgradePatch, AbstractPatch repairPatch) {
+    public static void setPatchProcessor(AbstractPatch upgradePatch, Class<? extends AbstractResultService> serviceClass) {
         upgradePatchProcessor = upgradePatch;
-        repairPatchProcessor = repairPatch;
+        resultServiceClass = serviceClass;
+        //try to load
+        try {
+            Class.forName(serviceClass.getName());
+        } catch (ClassNotFoundException e) {
+//            e.printStackTrace();
+        }
     }
 
     public static String getPatchPathExtra(Intent intent) {
@@ -73,11 +83,11 @@ public static String getPatchPathExtra(Intent intent) {
         return ShareIntentUtil.getStringExtra(intent, PATCH_PATH_EXTRA);
     }
 
-    public static boolean getPatchUpgradeExtra(Intent intent) {
+    public static String getPatchResultExtra(Intent intent) {
         if (intent == null) {
-            throw new TinkerRuntimeException("getPatchUpgradeExtra, but intent is null");
+            throw new TinkerRuntimeException("getPatchResultExtra, but intent is null");
         }
-        return ShareIntentUtil.getBooleanExtra(intent, PATCH_NEW_EXTRA, false);
+        return ShareIntentUtil.getStringExtra(intent, RESULT_CLASS_EXTRA);
     }
 
     /**
@@ -105,8 +115,6 @@ protected void onHandleIntent(Intent intent) {
         }
         File patchFile = new File(path);
 
-        boolean isUpgradePatch = getPatchUpgradeExtra(intent);
-
         long begin = SystemClock.elapsedRealtime();
         boolean result;
         long cost;
@@ -115,48 +123,46 @@ protected void onHandleIntent(Intent intent) {
         increasingPriority();
         PatchResult patchResult = new PatchResult();
         try {
-            if (isUpgradePatch) {
-                if (upgradePatchProcessor == null) {
-                    throw new TinkerRuntimeException("upgradePatchProcessor is null.");
-                }
-                result = upgradePatchProcessor.tryPatch(context, path, patchResult);
-
-            } else {
-                //just recover from exist patch
-                if (repairPatchProcessor == null) {
-                    throw new TinkerRuntimeException("upgradePatchProcessor is null.");
-                }
-                result = repairPatchProcessor.tryPatch(context, path, patchResult);
+            if (upgradePatchProcessor == null) {
+                throw new TinkerRuntimeException("upgradePatchProcessor is null.");
             }
+            result = upgradePatchProcessor.tryPatch(context, path, patchResult);
         } catch (Throwable throwable) {
             e = throwable;
             result = false;
-            tinker.getPatchReporter().onPatchException(patchFile, e, isUpgradePatch);
+            tinker.getPatchReporter().onPatchException(patchFile, e);
         }
 
         cost = SystemClock.elapsedRealtime() - begin;
         tinker.getPatchReporter().
-            onPatchResult(patchFile, result, cost, isUpgradePatch);
+            onPatchResult(patchFile, result, cost);
 
         patchResult.isSuccess = result;
-        patchResult.isUpgradePatch = isUpgradePatch;
         patchResult.rawPatchFilePath = path;
         patchResult.costTime = cost;
         patchResult.e = e;
 
-        AbstractResultService.runResultService(context, patchResult);
+        AbstractResultService.runResultService(context, patchResult, getPatchResultExtra(intent));
 
     }
 
     private void increasingPriority() {
+//        if (Build.VERSION.SDK_INT > 24) {
+//            TinkerLog.i(TAG, "for Android 7.1, we just ignore increasingPriority job");
+//            return;
+//        }
         TinkerLog.i(TAG, "try to increase patch process priority");
-        Notification notification = new Notification();
-        if (Build.VERSION.SDK_INT < 18) {
-            startForeground(notificationId, notification);
-        } else {
-            startForeground(notificationId, notification);
-            // start InnerService
-            startService(new Intent(this, InnerService.class));
+        try {
+            Notification notification = new Notification();
+            if (Build.VERSION.SDK_INT < 18) {
+                startForeground(notificationId, notification);
+            } else {
+                startForeground(notificationId, notification);
+                // start InnerService
+                startService(new Intent(this, InnerService.class));
+            }
+        } catch (Throwable e) {
+            TinkerLog.i(TAG, "try to increase patch process priority error:" + e);
         }
     }
 
@@ -170,7 +176,7 @@ public void onCreate() {
             super.onCreate();
             try {
                 startForeground(notificationId, new Notification());
-            } catch (NullPointerException e) {
+            } catch (Throwable e) {
                 TinkerLog.e(TAG, "InnerService set service for push exception:%s.", e);
             }
             // kill
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
index 4d5be29c..3cc8aa01 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
@@ -22,7 +22,6 @@
 import com.tencent.tinker.lib.listener.DefaultPatchListener;
 import com.tencent.tinker.lib.listener.PatchListener;
 import com.tencent.tinker.lib.patch.AbstractPatch;
-import com.tencent.tinker.lib.patch.RepairPatch;
 import com.tencent.tinker.lib.patch.UpgradePatch;
 import com.tencent.tinker.lib.reporter.DefaultLoadReporter;
 import com.tencent.tinker.lib.reporter.DefaultPatchReporter;
@@ -46,23 +45,26 @@
 public class Tinker {
     private static final String TAG = "Tinker.Tinker";
 
-    private static Tinker        sInstance;
-    private static boolean installed = false;
-    final          Context       context;
+    private static Tinker sInstance;
+    private static boolean sInstalled = false;
+
+    final Context       context;
     /**
      * data dir, such as /data/data/tinker.sample.android/tinker
      */
-    final          File          patchDirectory;
-    final          PatchListener listener;
-    final          LoadReporter  loadReporter;
-    final          PatchReporter patchReporter;
-    final          File          patchInfoFile;
-    final          boolean       isMainProcess;
-    final          boolean       isPatchProcess;
+    final File          patchDirectory;
+    final PatchListener listener;
+    final LoadReporter  loadReporter;
+    final PatchReporter patchReporter;
+    final File          patchInfoFile;
+    final File          patchInfoLockFile;
+    final boolean       isMainProcess;
+    final boolean       isPatchProcess;
     /**
      * same with {@code TinkerApplication.tinkerLoadVerifyFlag}
      */
-    final boolean tinkerLoadVerifyFlag;
+    final boolean       tinkerLoadVerifyFlag;
+
     /**
      * same with {@code TinkerApplication.tinkerFlags}
      */
@@ -71,10 +73,10 @@
     /**
      * whether load patch success
      */
-    private        boolean loaded    = false;
+    private boolean loaded = false;
 
     private Tinker(Context context, int tinkerFlags, LoadReporter loadReporter, PatchReporter patchReporter,
-                   PatchListener listener, File patchDirectory, File patchInfoFile,
+                   PatchListener listener, File patchDirectory, File patchInfoFile, File patchInfoLockFile,
                    boolean isInMainProc, boolean isPatchProcess, boolean tinkerLoadVerifyFlag) {
         this.context = context;
         this.listener = listener;
@@ -83,6 +85,7 @@ private Tinker(Context context, int tinkerFlags, LoadReporter loadReporter, Patc
         this.tinkerFlags = tinkerFlags;
         this.patchDirectory = patchDirectory;
         this.patchInfoFile = patchInfoFile;
+        this.patchInfoLockFile = patchInfoLockFile;
         this.isMainProcess = isInMainProc;
         this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;
         this.isPatchProcess = isPatchProcess;
@@ -96,7 +99,7 @@ private Tinker(Context context, int tinkerFlags, LoadReporter loadReporter, Patc
      * @return the Tinker object
      */
     public static Tinker with(Context context) {
-        if (!installed) {
+        if (!sInstalled) {
             throw new TinkerRuntimeException("you must install tinker before get tinker sInstance");
         }
         if (sInstance == null) {
@@ -122,20 +125,23 @@ public static void create(Tinker tinker) {
         sInstance = tinker;
     }
 
+    public static boolean isTinkerInstalled() {
+        return sInstalled;
+    }
+
     /**
      * you must install tinker first!!
      *
      * @param intentResult
      * @param serviceClass
      * @param upgradePatch
-     * @param repairPatch
      */
     public void install(Intent intentResult, Class<? extends AbstractResultService> serviceClass,
-                        AbstractPatch upgradePatch, AbstractPatch repairPatch
-    ) {
-        installed = true;
-        AbstractResultService.setResultServiceClass(serviceClass);
-        TinkerPatchService.setPatchProcessor(upgradePatch, repairPatch);
+                        AbstractPatch upgradePatch) {
+        sInstalled = true;
+        TinkerPatchService.setPatchProcessor(upgradePatch, serviceClass);
+
+        TinkerLog.i(TAG, "try to install tinker, isEnable: %b, version: %s", isTinkerEnabled(), ShareConstants.TINKER_VERSION);
 
         if (!isTinkerEnabled()) {
             TinkerLog.e(TAG, "tinker is disabled");
@@ -156,13 +162,13 @@ public void install(Intent intentResult, Class<? extends AbstractResultService>
 
     /**
      * set tinkerPatchServiceNotificationId
+     *
      * @param id
      */
     public void setPatchServiceNotificationId(int id) {
         TinkerPatchService.setTinkerNotificationId(id);
     }
 
-
     /**
      * Nullable, should check the loaded flag first
      */
@@ -171,7 +177,7 @@ public TinkerLoadResult getTinkerLoadResultIfPresent() {
     }
 
     public void install(Intent intentResult) {
-        install(intentResult, DefaultTinkerResultService.class, new UpgradePatch(), new RepairPatch());
+        install(intentResult, DefaultTinkerResultService.class, new UpgradePatch());
     }
 
     public Context getContext() {
@@ -198,7 +204,6 @@ public PatchReporter getPatchReporter() {
         return patchReporter;
     }
 
-
     public boolean isTinkerEnabled() {
         return ShareTinkerInternals.isTinkerEnabled(tinkerFlags);
     }
@@ -211,10 +216,6 @@ public void setTinkerLoaded(boolean isLoaded) {
         loaded = isLoaded;
     }
 
-    public boolean isTinkerInstalled() {
-        return installed;
-    }
-
     public boolean isTinkerLoadVerify() {
         return tinkerLoadVerifyFlag;
     }
@@ -239,10 +240,19 @@ public File getPatchInfoFile() {
         return patchInfoFile;
     }
 
+    public File getPatchInfoLockFile() {
+        return patchInfoLockFile;
+    }
+
     public PatchListener getPatchListener() {
         return listener;
     }
 
+
+    public int getTinkerFlags() {
+        return tinkerFlags;
+    }
+
     /**
      * clean all patch files
      */
@@ -307,6 +317,7 @@ public void cleanPatchByVersion(File patchFile) {
         private PatchListener listener;
         private File          patchDirectory;
         private File          patchInfoFile;
+        private File          patchInfoLockFile;
         private Boolean       tinkerLoadVerifyFlag;
 
         /**
@@ -325,6 +336,7 @@ public Builder(Context context) {
                 return;
             }
             this.patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectory.getAbsolutePath());
+            this.patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectory.getAbsolutePath());
             TinkerLog.w(TAG, "tinker patch directory: %s", patchDirectory);
         }
 
@@ -402,7 +414,7 @@ public Tinker build() {
             }
 
             return new Tinker(context, status, loadReporter, patchReporter, listener, patchDirectory,
-                patchInfoFile, mainProcess, patchProcess, tinkerLoadVerifyFlag);
+                patchInfoFile, patchInfoLockFile, mainProcess, patchProcess, tinkerLoadVerifyFlag);
         }
     }
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerInstaller.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerInstaller.java
index f0b52b0a..9cb71ac0 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerInstaller.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerInstaller.java
@@ -24,12 +24,7 @@
 import com.tencent.tinker.lib.reporter.PatchReporter;
 import com.tencent.tinker.lib.service.AbstractResultService;
 import com.tencent.tinker.lib.util.TinkerLog;
-import com.tencent.tinker.loader.TinkerRuntimeException;
 import com.tencent.tinker.loader.app.ApplicationLike;
-import com.tencent.tinker.loader.shareutil.ShareConstants;
-import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
-
-import java.io.File;
 
 /**
  * Created by zhangshaowen on 16/3/19.
@@ -43,9 +38,11 @@
      *
      * @param applicationLike
      */
-    public static void install(ApplicationLike applicationLike) {
+    public static Tinker install(ApplicationLike applicationLike) {
         Tinker tinker = new Tinker.Builder(applicationLike.getApplication()).build();
+        Tinker.create(tinker);
         tinker.install(applicationLike.getTinkerResultIntent());
+        return tinker;
     }
 
     /**
@@ -58,11 +55,10 @@ public static void install(ApplicationLike applicationLike) {
      * @param listener
      * @param resultServiceClass
      * @param upgradePatchProcessor
-     * @param repairPatchProcessor
      */
-    public static void install(ApplicationLike applicationLike, LoadReporter loadReporter, PatchReporter patchReporter,
+    public static Tinker install(ApplicationLike applicationLike, LoadReporter loadReporter, PatchReporter patchReporter,
                                PatchListener listener, Class<? extends AbstractResultService> resultServiceClass,
-                               AbstractPatch upgradePatchProcessor, AbstractPatch repairPatchProcessor) {
+                               AbstractPatch upgradePatchProcessor) {
 
         Tinker tinker = new Tinker.Builder(applicationLike.getApplication())
             .tinkerFlags(applicationLike.getTinkerFlags())
@@ -72,9 +68,8 @@ public static void install(ApplicationLike applicationLike, LoadReporter loadRep
             .tinkerLoadVerifyFlag(applicationLike.getTinkerLoadVerifyFlag()).build();
 
         Tinker.create(tinker);
-        tinker.install(applicationLike.getTinkerResultIntent(), resultServiceClass, upgradePatchProcessor, repairPatchProcessor);
-
-
+        tinker.install(applicationLike.getTinkerResultIntent(), resultServiceClass, upgradePatchProcessor);
+        return tinker;
     }
 
     /**
@@ -93,18 +88,7 @@ public static void cleanPatch(Context context) {
      * @param patchLocation
      */
     public static void onReceiveUpgradePatch(Context context, String patchLocation) {
-        Tinker.with(context).getPatchListener().onPatchReceived(patchLocation, true);
-    }
-
-    /**
-     * some file does not exist, repair them with :patch process
-     * Generally you will not use it
-     *
-     * @param context
-     * @param patchLocation
-     */
-    public static void onReceiveRepairPatch(Context context, String patchLocation) {
-        Tinker.with(context).getPatchListener().onPatchReceived(patchLocation, false);
+        Tinker.with(context).getPatchListener().onPatchReceived(patchLocation);
     }
 
     /**
@@ -115,91 +99,4 @@ public static void onReceiveRepairPatch(Context context, String patchLocation) {
     public static void setLogIml(TinkerLog.TinkerLogImp imp) {
         TinkerLog.setTinkerLogImp(imp);
     }
-
-    /**
-     * sample usage for native library
-     *
-     * @param context
-     * @param relativePath such as lib/armeabi
-     * @param libname      for the lib libTest.so, you can pass Test or libTest, or libTest.so
-     * @return boolean
-     * @throws UnsatisfiedLinkError
-     */
-    public static boolean loadLibraryFromTinker(Context context, String relativePath, String libname) throws UnsatisfiedLinkError {
-        final Tinker tinker = Tinker.with(context);
-
-        libname = libname.startsWith("lib") ? libname : "lib" + libname;
-        libname = libname.endsWith(".so") ? libname : libname + ".so";
-        String relativeLibPath = relativePath + "/" + libname;
-
-        //TODO we should add cpu abi, and the real path later
-        if (tinker.isEnabledForNativeLib() && tinker.isTinkerLoaded()) {
-            TinkerLoadResult loadResult = tinker.getTinkerLoadResultIfPresent();
-            if (loadResult.libs != null) {
-                for (String name : loadResult.libs.keySet()) {
-                    if (name.equals(relativeLibPath)) {
-                        String patchLibraryPath = loadResult.libraryDirectory + "/" + name;
-                        File library = new File(patchLibraryPath);
-                        if (library.exists()) {
-                            //whether we check md5 when load
-                            boolean verifyMd5 = tinker.isTinkerLoadVerify();
-                            if (verifyMd5 && !SharePatchFileUtil.verifyFileMd5(library, loadResult.libs.get(name))) {
-                                tinker.getLoadReporter().onLoadFileMd5Mismatch(library, ShareConstants.TYPE_LIBRARY);
-                            } else {
-                                System.load(patchLibraryPath);
-                                TinkerLog.i(TAG, "loadLibraryFromTinker success:" + patchLibraryPath);
-                                return true;
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        return false;
-    }
-
-    /**
-     * you can use TinkerInstaller.loadLibrary replace your System.loadLibrary for auto update library!
-     * only support auto load lib/armeabi library from patch.
-     * for other library in lib/* or assets,
-     * you can load through {@code TinkerInstaller#loadLibraryFromTinker}
-     */
-    public static void loadArmLibrary(Context context, String libName) {
-        if (libName == null || libName.isEmpty() || context == null) {
-            throw new TinkerRuntimeException("libName or context is null!");
-        }
-
-        Tinker tinker = Tinker.with(context);
-        if (tinker.isEnabledForNativeLib()) {
-            if (TinkerInstaller.loadLibraryFromTinker(context, "lib/armeabi", libName)) {
-                return;
-            }
-
-        }
-        System.loadLibrary(libName);
-    }
-
-    /**
-     * you can use TinkerInstaller.loadArmV7Library replace your System.loadLibrary for auto update library!
-     * only support auto load lib/armeabi-v7a library from patch.
-     * for other library in lib/* or assets,
-     * you can load through {@code TinkerInstaller#loadLibraryFromTinker}
-     */
-    public static void loadArmV7Library(Context context, String libName) {
-        if (libName == null || libName.isEmpty() || context == null) {
-            throw new TinkerRuntimeException("libName or context is null!");
-        }
-
-        Tinker tinker = Tinker.with(context);
-        if (tinker.isEnabledForNativeLib()) {
-            if (TinkerInstaller.loadLibraryFromTinker(context, "lib/armeabi-v7a", libName)) {
-                return;
-            }
-
-        }
-        System.loadLibrary(libName);
-    }
-
-
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
index 46316274..3b5b06f2 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
@@ -18,6 +18,7 @@
 
 import android.content.Context;
 import android.content.Intent;
+import android.os.Build;
 
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.TinkerRuntimeException;
@@ -41,6 +42,9 @@
     public String         currentVersion;
 
     public boolean                 versionChanged;
+
+    public boolean                 systemOTA;
+
     //@Nullable
     public File                    patchVersionDirectory;
     //@Nullable
@@ -67,9 +71,11 @@
     public boolean parseTinkerResult(Context context, Intent intentResult) {
         Tinker tinker = Tinker.with(context);
         loadCode = ShareIntentUtil.getIntentReturnCode(intentResult);
-        TinkerLog.i(TAG, "parseTinkerResult loadCode:%d", loadCode);
 
         costTime = ShareIntentUtil.getIntentPatchCostTime(intentResult);
+        systemOTA = ShareIntentUtil.getBooleanExtra(intentResult, ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, false);
+
+        TinkerLog.i(TAG, "parseTinkerResult loadCode:%d, systemOTA:%b", loadCode, systemOTA);
         //@Nullable
         final String oldVersion = ShareIntentUtil.getStringExtra(intentResult, ShareIntentUtil.INTENT_PATCH_OLD_VERSION);
         //@Nullable
@@ -100,7 +106,7 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 resourceDirectory = new File(patchVersionDirectory, ShareConstants.RES_PATH);
                 resourceFile = new File(resourceDirectory, ShareConstants.RES_NAME);
             }
-            patchInfo = new SharePatchInfo(oldVersion, newVersion);
+            patchInfo = new SharePatchInfo(oldVersion, newVersion, Build.FINGERPRINT);
             versionChanged = !(oldVersion.equals(newVersion));
         }
 
@@ -116,6 +122,9 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 case ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION:
                     errorCode = ShareConstants.ERROR_LOAD_EXCEPTION_DEX;
                     break;
+                case ShareConstants.ERROR_LOAD_PATCH_VERSION_PARALLEL_DEX_OPT_EXCEPTION:
+                    errorCode = ShareConstants.ERROR_LOAD_EXCEPTION_DEX_OPT;
+                    break;
                 case ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION:
                     errorCode = ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE;
                     break;
@@ -309,9 +318,7 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
 
                 if (isMainProcess && versionChanged) {
                     //change the old version to new
-                    patchInfo.oldVersion = currentVersion;
                     tinker.getLoadReporter().onLoadPatchVersionChanged(oldVersion, newVersion, patchDirectory, patchVersionDirectory.getName());
-
                 }
                 return true;
         }
@@ -319,33 +326,6 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
 
     }
 
-    /**
-     * get the base tinkerId
-     *
-     * @return
-     */
-    public String getTinkerID() {
-        if (packageConfig != null) {
-            String tinkerId = packageConfig.get(ShareConstants.TINKER_ID);
-            return tinkerId;
-        }
-        return null;
-    }
-
-    /**
-     * get the new tinkerId
-     *
-     * @return
-     */
-    public String getNewTinkerID() {
-        if (packageConfig != null) {
-            String tinkerId = packageConfig.get(ShareConstants.NEW_TINKER_ID);
-
-            return tinkerId;
-        }
-        return null;
-    }
-
     /**
      * get package configs
      *
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
index 2118e23b..0db959ee 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerServiceInternals.java
@@ -47,8 +47,13 @@ public static void killTinkerPatchServiceProcess(Context context) {
         }
 
         final ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
-
-        for (ActivityManager.RunningAppProcessInfo appProcess : am.getRunningAppProcesses()) {
+        // ActivityManager getRunningAppProcesses()
+        List<ActivityManager.RunningAppProcessInfo> appProcessList = am
+            .getRunningAppProcesses();
+        if (appProcessList == null) {
+            return;
+        }
+        for (ActivityManager.RunningAppProcessInfo appProcess : appProcessList) {
             String processName = appProcess.processName;
             if (processName.equals(serverProcessName)) {
                 android.os.Process.killProcess(appProcess.pid);
@@ -64,10 +69,12 @@ public static boolean isTinkerPatchServiceRunning(Context context) {
             return false;
         }
         try {
-            // ActivityManagergetRunningAppProcesses()
+            // ActivityManager getRunningAppProcesses()
             List<ActivityManager.RunningAppProcessInfo> appProcessList = am
                 .getRunningAppProcesses();
-
+            if (appProcessList == null) {
+                return false;
+            }
             for (ActivityManager.RunningAppProcessInfo appProcess : appProcessList) {
                 String processName = appProcess.processName;
                 if (processName.equals(serverName)) {
@@ -122,7 +129,7 @@ private static String getServiceProcessName(Context context, Class<? extends Ser
         ServiceInfo serviceInfo;
         try {
             serviceInfo = packageManager.getServiceInfo(component, 0);
-        } catch (PackageManager.NameNotFoundException ignored) {
+        } catch (Throwable ignored) {
             // Service is disabled.
             return null;
         }
diff --git a/tinker-android/tinker-android-loader/build.gradle b/tinker-android/tinker-android-loader/build.gradle
index cb3264ad..b65288cc 100644
--- a/tinker-android/tinker-android-loader/build.gradle
+++ b/tinker-android/tinker-android-loader/build.gradle
@@ -19,7 +19,8 @@ dependencies {
     testCompile 'junit:junit:4.12'
 }
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from("$buildDir/outputs/aar/") {
         include "${project.getName()}-release.aar"
     }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
index 683ba2c0..3fa21b51 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
@@ -21,8 +21,16 @@
 import android.content.Context;
 import android.os.Build;
 
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
+
+import java.io.File;
+import java.io.IOException;
 import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.List;
 
+import dalvik.system.DexFile;
 import dalvik.system.PathClassLoader;
 
 /**
@@ -30,6 +38,7 @@
  */
 @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 class AndroidNClassLoader extends PathClassLoader {
+    static ArrayList<DexFile> oldDexFiles = new ArrayList<>();
     PathClassLoader originClassLoader;
 
     private AndroidNClassLoader(String dexPath, PathClassLoader parent) {
@@ -40,28 +49,32 @@ private AndroidNClassLoader(String dexPath, PathClassLoader parent) {
     private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader original) throws Exception {
         //let all element ""
         AndroidNClassLoader androidNClassLoader = new AndroidNClassLoader("",  original);
-        Object originPathList = findField(original, "pathList").get(original);
-        Field pathListField = findField(androidNClassLoader, "pathList");
-        //just use PathClassloader's pathlist
-        pathListField.set(androidNClassLoader, originPathList);
-        return androidNClassLoader;
-    }
-
-    private static Field findField(Object instance, String name) throws NoSuchFieldException {
-        for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) {
-            try {
-                Field field = clazz.getDeclaredField(name);
-
-                if (!field.isAccessible()) {
-                    field.setAccessible(true);
-                }
-
-                return field;
-            } catch (NoSuchFieldException e) {
-                // ignore and search next
-            }
+        Field originPathList = ShareReflectUtil.findField(original, "pathList");
+        Object originPathListObject = originPathList.get(original);
+        //should reflect definingContext also
+        Field originClassloader = ShareReflectUtil.findField(originPathListObject, "definingContext");
+        originClassloader.set(originPathListObject, androidNClassLoader);
+        //copy pathList
+        Field pathListField = ShareReflectUtil.findField(androidNClassLoader, "pathList");
+        //just use PathClassloader's pathList
+        pathListField.set(androidNClassLoader, originPathListObject);
+
+        //we must recreate dexFile due to dexCache
+        List<File> additionalClassPathEntries = new ArrayList<>();
+        Field dexElement = ShareReflectUtil.findField(originPathListObject, "dexElements");
+        Object[] originDexElements = (Object[]) dexElement.get(originPathListObject);
+        for (Object element : originDexElements) {
+            DexFile dexFile = (DexFile) ShareReflectUtil.findField(element, "dexFile").get(element);
+            additionalClassPathEntries.add(new File(dexFile.getName()));
+            //protect for java.lang.AssertionError: Failed to close dex file in finalizer.
+            oldDexFiles.add(dexFile);
         }
-        throw new NoSuchFieldException("Field " + name + " not found in " + instance.getClass());
+        Method makePathElements = ShareReflectUtil.findMethod(originPathListObject, "makePathElements", List.class, File.class,
+            List.class);
+        ArrayList<IOException> suppressedExceptions = new ArrayList<>();
+        Object[] newDexElements = (Object[]) makePathElements.invoke(originPathListObject, additionalClassPathEntries, null, suppressedExceptions);
+        dexElement.set(originPathListObject, newDexElements);
+        return androidNClassLoader;
     }
 
     private static void reflectPackageInfoClassloader(Application application, ClassLoader reflectClassLoader) throws Exception {
@@ -69,9 +82,9 @@ private static void reflectPackageInfoClassloader(Application application, Class
         String defPackageInfo = "mPackageInfo";
         String defClassLoader = "mClassLoader";
 
-        Context baseContext = (Context) findField(application, defBase).get(application);
-        Object basePackageInfo = findField(baseContext, defPackageInfo).get(baseContext);
-        Field classLoaderField = findField(basePackageInfo, defClassLoader);
+        Context baseContext = (Context) ShareReflectUtil.findField(application, defBase).get(application);
+        Object basePackageInfo = ShareReflectUtil.findField(baseContext, defPackageInfo).get(baseContext);
+        Field classLoaderField = ShareReflectUtil.findField(basePackageInfo, defClassLoader);
         Thread.currentThread().setContextClassLoader(reflectClassLoader);
         classLoaderField.set(basePackageInfo, reflectClassLoader);
     }
@@ -93,6 +106,10 @@ public static AndroidNClassLoader inject(PathClassLoader originClassLoader, Appl
 //    }
 
     public Class<?> findClass(String name) throws ClassNotFoundException {
+        // loader class use default pathClassloader to load
+        if (name != null && name.startsWith("com.tencent.tinker.loader.") && !name.equals("com.tencent.tinker.loader.TinkerTestDexLoad")) {
+            return originClassLoader.loadClass(name);
+        }
         return super.findClass(name);
     }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
index 88b67135..6c8199fa 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
@@ -48,6 +48,7 @@
     private static final String CHECK_DEX_CLASS = "com.tencent.tinker.loader.TinkerTestDexLoad";
     private static final String CHECK_DEX_FIELD = "isPatch";
 
+    private static int sPatchDexCount = 0;
 
     @SuppressLint("NewApi")
     public static void installDexes(Application application, PathClassLoader loader, File dexOptDir, List<File> files)
@@ -69,15 +70,39 @@ public static void installDexes(Application application, PathClassLoader loader,
             } else {
                 V4.install(classLoader, files, dexOptDir);
             }
+            //install done
+            sPatchDexCount = files.size();
+            Log.i(TAG, "after loaded classloader: " + classLoader + ", dex size:" + sPatchDexCount);
 
-            if (!checkDexInstall()) {
+            if (!checkDexInstall(classLoader)) {
+                //reset patch dex
+                SystemClassLoaderAdder.uninstallPatchDex(classLoader);
                 throw new TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);
             }
         }
     }
 
-    private static boolean checkDexInstall() throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
-        Class<?> clazz = Class.forName(CHECK_DEX_CLASS);
+    public static void uninstallPatchDex(ClassLoader classLoader) throws Throwable {
+        if (sPatchDexCount <= 0) {
+            return;
+        }
+        if (Build.VERSION.SDK_INT >= 14) {
+            Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
+            Object dexPathList = pathListField.get(classLoader);
+            ShareReflectUtil.reduceFieldArray(dexPathList, "dexElements", sPatchDexCount);
+        } else {
+            ShareReflectUtil.reduceFieldArray(classLoader, "mPaths", sPatchDexCount);
+            ShareReflectUtil.reduceFieldArray(classLoader, "mFiles", sPatchDexCount);
+            ShareReflectUtil.reduceFieldArray(classLoader, "mZips", sPatchDexCount);
+            try {
+                ShareReflectUtil.reduceFieldArray(classLoader, "mDexs", sPatchDexCount);
+            } catch (Exception e) {
+            }
+        }
+    }
+
+    private static boolean checkDexInstall(ClassLoader classLoader) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
+        Class<?> clazz = Class.forName(CHECK_DEX_CLASS, true, classLoader);
         Field filed = ShareReflectUtil.findField(clazz, CHECK_DEX_FIELD);
         boolean isPatch = (boolean) filed.get(null);
         Log.w(TAG, "checkDexInstall result:" + isPatch);
@@ -85,7 +110,7 @@ private static boolean checkDexInstall() throws ClassNotFoundException, NoSuchFi
     }
 
     /**
-     * Installer for platform versions 19.
+     * Installer for platform versions 23.
      */
     private static final class V23 {
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
index b700a1b8..90ebc589 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
@@ -29,12 +29,12 @@
 import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
-import dalvik.system.PathClassLoader;
-
 import java.io.File;
 import java.util.ArrayList;
 import java.util.HashMap;
 
+import dalvik.system.PathClassLoader;
+
 /**
  * Created by zhangshaowen on 16/3/8.
  * check the complete of the dex files
@@ -49,6 +49,9 @@
     private static final String                           DEX_OPTIMIZE_PATH = ShareConstants.DEX_OPTIMIZE_PATH;
     private static final ArrayList<ShareDexDiffPatchInfo> dexList           = new ArrayList<>();
 
+    private static boolean   parallelOTAResult;
+    private static Throwable parallelOTAThrowable;
+
     private TinkerDexLoader() {
     }
 
@@ -59,7 +62,7 @@ private TinkerDexLoader() {
      * @param application The application.
      */
     @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-    public static boolean loadTinkerJars(Application application, boolean tinkerLoadVerifyFlag, String directory, Intent intentResult) {
+    public static boolean loadTinkerJars(Application application, boolean tinkerLoadVerifyFlag, String directory, Intent intentResult, boolean isSystemOTA) {
         if (dexList.isEmpty()) {
             Log.w(TAG, "there is no dex to load");
             return true;
@@ -99,10 +102,47 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
                         file.getAbsolutePath());
                     return false;
                 }
-                Log.i(TAG, "verify dex file:" + file.getPath() + ", md5 use time: " + (System.currentTimeMillis() - start));
+                Log.i(TAG, "verify dex file:" + file.getPath() + " md5, use time: " + (System.currentTimeMillis() - start));
             }
             legalFiles.add(file);
         }
+
+        if (isSystemOTA) {
+            parallelOTAResult = true;
+            parallelOTAThrowable = null;
+            Log.w(TAG, "systemOTA, try parallel oat dexes!!!!!");
+
+            TinkerParallelDexOptimizer.optimizeAll(
+                legalFiles, optimizeDir,
+                new TinkerParallelDexOptimizer.ResultCallback() {
+                    long start;
+
+                    @Override
+                    public void onStart(File dexFile, File optimizedDir) {
+                        start = System.currentTimeMillis();
+                        Log.i(TAG, "start to optimize dex:" + dexFile.getPath());
+                    }
+
+                    @Override
+                    public void onSuccess(File dexFile, File optimizedDir, File optimizedFile) {
+                        // Do nothing.
+                        Log.i(TAG, "success to optimize dex " + dexFile.getPath() + "use time " + (System.currentTimeMillis() - start));
+                    }
+                    @Override
+                    public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
+                        parallelOTAResult = false;
+                        parallelOTAThrowable = thr;
+                        Log.i(TAG, "fail to optimize dex " + dexFile.getPath() + "use time " + (System.currentTimeMillis() - start));
+                    }
+                }
+            );
+            if (!parallelOTAResult) {
+                Log.e(TAG, "parallel oat dexes failed");
+                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, parallelOTAThrowable);
+                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_PARALLEL_DEX_OPT_EXCEPTION);
+                return false;
+            }
+        }
         try {
             SystemClassLoaderAdder.installDexes(application, classLoader, optimizeDir, legalFiles);
         } catch (Throwable e) {
@@ -112,7 +152,6 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
             ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION);
             return false;
         }
-        Log.i(TAG, "after loaded classloader: " + application.getClassLoader().toString());
 
         return true;
     }
@@ -160,21 +199,20 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
             ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST);
             return false;
         }
-
         String optimizeDexDirectory = directory + "/" + DEX_OPTIMIZE_PATH + "/";
         File optimizeDexDirectoryFile = new File(optimizeDexDirectory);
 
         //fast check whether there is any dex files missing
         for (String name : dexes.keySet()) {
             File dexFile = new File(dexDirectory + name);
-            if (!dexFile.exists()) {
+            if (!SharePatchFileUtil.isLegalFile(dexFile)) {
                 intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISSING_DEX_PATH, dexFile.getAbsolutePath());
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST);
                 return false;
             }
             //check dex opt whether complete also
             File dexOptFile = new File(SharePatchFileUtil.optimizedPathFor(dexFile, optimizeDexDirectoryFile));
-            if (!dexOptFile.exists()) {
+            if (!SharePatchFileUtil.isLegalFile(dexOptFile)) {
                 intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISSING_DEX_PATH, dexOptFile.getAbsolutePath());
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST);
                 return false;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
index 7b1853f3..2c517745 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
@@ -128,7 +128,12 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         //patch-641e634c
         String patchName = SharePatchFileUtil.getPatchVersionDirectory(version);
-
+        if (patchName == null) {
+            Log.w(TAG, "tryLoadPatchFiles:patchName is null");
+            //we may delete patch info file
+            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);
+            return;
+        }
         //tinker/patch.info/patch-641e634c
         String patchVersionDirectory = patchDirectoryPath + "/" + patchName;
         File patchVersionDirectoryFile = new File(patchVersionDirectory);
@@ -143,7 +148,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
         //tinker/patch.info/patch-641e634c/patch-641e634c.apk
         File patchVersionFile = new File(patchVersionDirectoryFile.getAbsolutePath(), SharePatchFileUtil.getPatchVersionFile(version));
 
-        if (!patchVersionFile.exists()) {
+        if (!SharePatchFileUtil.isLegalFile(patchVersionFile)) {
             Log.w(TAG, "tryLoadPatchFiles:onPatchVersionFileNotFound");
             //we may delete patch info file
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST);
@@ -152,9 +157,9 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         ShareSecurityCheck securityCheck = new ShareSecurityCheck(app);
 
-        int returnCode = ShareTinkerInternals.checkSignatureAndTinkerID(app, patchVersionFile, securityCheck);
-        if (returnCode != 0) {
-            Log.w(TAG, "tryLoadPatchFiles:checkSignatureAndTinkerID");
+        int returnCode = ShareTinkerInternals.checkTinkerPackage(app, tinkerFlag, patchVersionFile, securityCheck);
+        if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {
+            Log.w(TAG, "tryLoadPatchFiles:checkTinkerPackage");
             resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, returnCode);
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);
             return;
@@ -197,8 +202,13 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
                 return;
             }
         }
+        //only work for art platform oat
+        boolean isSystemOTA = ShareTinkerInternals.isVmArt() && ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint);
+        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, isSystemOTA);
+
         //we should first try rewrite patch info file, if there is a error, we can't load jar
-        if (mainProcess && versionChanged) {
+        if (isSystemOTA
+            || (mainProcess && versionChanged)) {
             patchInfo.oldVersion = version;
             //update old version to new
             if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) {
@@ -215,7 +225,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
         }
         //now we can load patch jar
         if (isEnabledForDex) {
-            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);
+            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent, isSystemOTA);
             if (!loadTinkerJars) {
                 Log.w(TAG, "tryLoadPatchFiles:onPatchLoadDexesFail");
                 return;
@@ -224,7 +234,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         //now we can load patch resource
         if (isEnabledForResource) {
-            boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);
+            boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);
             if (!loadTinkerResources) {
                 Log.w(TAG, "tryLoadPatchFiles:onPatchLoadResourcesFail");
                 return;
@@ -241,16 +251,14 @@ private boolean checkSafeModeCount(TinkerApplication application) {
         String preferName = ShareConstants.TINKER_OWN_PREFERENCE_CONFIG + processName;
         //each process have its own SharedPreferences file
         SharedPreferences sp = application.getSharedPreferences(preferName, Context.MODE_PRIVATE);
-        int count = sp.getInt(ShareConstants.TINKER_SAFE_MODE_COUNT, 0);
+        int count = sp.getInt(ShareConstants.TINKER_SAFE_MODE_COUNT, 0) + 1;
         Log.w(TAG, "tinker safe mode preferName:" + preferName + " count:" + count);
         if (count >= ShareConstants.TINKER_SAFE_MODE_MAX_COUNT) {
             sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, 0).commit();
             return false;
         }
         application.setUseSafeMode(true);
-        count++;
         sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, count).commit();
-        Log.w(TAG, "after tinker safe mode count:" + count);
         return true;
     }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java
new file mode 100644
index 00000000..e2481a05
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java
@@ -0,0 +1,146 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader;
+
+import android.util.Log;
+
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+
+import dalvik.system.DexFile;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Created by tangyinsheng on 2016/11/15.
+ */
+
+public final class TinkerParallelDexOptimizer {
+    private static final String TAG = "Tinker.ParallelDex";
+
+    /**
+     * Optimize (trigger dexopt or dex2oat) dexes.
+     *
+     * @param dexFiles
+     * @param optimizedDir
+     * @param cb
+     *
+     * @return
+     *  If all dexes are optimized successfully, return true. Otherwise return false.
+     */
+    public synchronized static boolean optimizeAll(File[] dexFiles, File optimizedDir, ResultCallback cb) {
+        final AtomicInteger successCount = new AtomicInteger(0);
+        return optimizeAllLocked(Arrays.asList(dexFiles), optimizedDir, successCount, cb);
+    }
+
+    /**
+     * Optimize (trigger dexopt or dex2oat) dexes.
+     *
+     * @param dexFiles
+     * @param optimizedDir
+     * @param cb
+     *
+     * @return
+     *  If all dexes are optimized successfully, return true. Otherwise return false.
+     */
+    public synchronized static boolean optimizeAll(Collection<File> dexFiles, File optimizedDir, ResultCallback cb) {
+        final AtomicInteger successCount = new AtomicInteger(0);
+        return optimizeAllLocked(dexFiles, optimizedDir, successCount, cb);
+    }
+
+    private static boolean optimizeAllLocked(Collection<File> dexFiles, File optimizedDir, AtomicInteger successCount, ResultCallback cb) {
+        final CountDownLatch lauch = new CountDownLatch(dexFiles.size());
+        final ExecutorService threadPool = Executors.newCachedThreadPool();
+        long startTick = System.nanoTime();
+        for (File dexFile : dexFiles) {
+            OptimizeWorker worker = new OptimizeWorker(dexFile, optimizedDir, successCount, lauch, cb);
+            threadPool.submit(worker);
+        }
+        try {
+            lauch.await();
+            long timeCost = (System.nanoTime() - startTick) / 1000000;
+            if (successCount.get() == dexFiles.size()) {
+                Log.i(TAG, "All dexes are optimized successfully, cost: " + timeCost + " ms.");
+                return true;
+            } else {
+                Log.e(TAG, "Dexes optimizing failed, some dexes are not optimized.");
+                return false;
+            }
+        } catch (InterruptedException e) {
+            Log.w(TAG, "Dex optimizing was interrupted.", e);
+            return false;
+        } finally {
+            threadPool.shutdown();
+        }
+    }
+
+    public interface ResultCallback {
+        void onStart(File dexFile, File optimizedDir);
+        void onSuccess(File dexFile, File optimizedDir, File optimizedFile);
+        void onFailed(File dexFile, File optimizedDir, Throwable thr);
+    }
+
+    private static class OptimizeWorker implements Runnable {
+        private final File dexFile;
+        private final File optimizedDir;
+        private final AtomicInteger successCount;
+        private final CountDownLatch waitingLauch;
+        private final ResultCallback callback;
+
+        OptimizeWorker(File dexFile, File optimizedDir, AtomicInteger successCount, CountDownLatch lauch, ResultCallback cb) {
+            this.dexFile = dexFile;
+            this.optimizedDir = optimizedDir;
+            this.successCount = successCount;
+            this.waitingLauch = lauch;
+            this.callback = cb;
+        }
+
+        @Override
+        public void run() {
+            try {
+                if (!SharePatchFileUtil.isLegalFile(dexFile)) {
+                    if (callback != null) {
+                        callback.onFailed(dexFile, optimizedDir,
+                            new IOException("dex file " + dexFile.getAbsolutePath() + " is not exist!"));
+                    }
+                }
+                if (callback != null) {
+                    callback.onStart(dexFile, optimizedDir);
+                }
+                String optimizedPath = SharePatchFileUtil.optimizedPathFor(this.dexFile, this.optimizedDir);
+                DexFile.loadDex(dexFile.getAbsolutePath(), optimizedPath, 0);
+                successCount.incrementAndGet();
+                if (callback != null) {
+                    callback.onSuccess(dexFile, optimizedDir, new File(optimizedPath));
+                }
+            } catch (final Throwable e) {
+                Log.e(TAG, "Failed to optimize dex: " + dexFile.getAbsolutePath(), e);
+                if (callback != null) {
+                    callback.onFailed(dexFile, optimizedDir, e);
+                }
+            } finally {
+                this.waitingLauch.countDown();
+            }
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
index 3976ffe5..167231b3 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
@@ -32,44 +32,50 @@
  * Created by liangwenxiang on 2016/4/14.
  */
 public class TinkerResourceLoader {
-
     protected static final String RESOURCE_META_FILE = ShareConstants.RES_META_FILE;
     protected static final String RESOURCE_FILE      = ShareConstants.RES_NAME;
     protected static final String RESOURCE_PATH      = ShareConstants.RES_PATH;
     private static final String TAG = "Tinker.ResourceLoader";
     private static ShareResPatchInfo resPatchInfo = new ShareResPatchInfo();
 
-
     private TinkerResourceLoader() {
     }
 
     /**
      * Load tinker resources
      */
-    public static boolean loadTinkerResources(boolean tinkerLoadVerifyFlag, String directory, Intent intentResult) {
+    public static boolean loadTinkerResources(Context context, boolean tinkerLoadVerifyFlag, String directory, Intent intentResult) {
         if (resPatchInfo == null || resPatchInfo.resArscMd5 == null) {
             return true;
         }
         String resourceString = directory + "/" + RESOURCE_PATH +  "/" + RESOURCE_FILE;
         File resourceFile = new File(resourceString);
+        long start = System.currentTimeMillis();
 
         if (tinkerLoadVerifyFlag) {
-            long start = System.currentTimeMillis();
             if (!SharePatchFileUtil.checkResourceArscMd5(resourceFile, resPatchInfo.resArscMd5)) {
                 Log.e(TAG, "Failed to load resource file, path: " + resourceFile.getPath() + ", expect md5: " + resPatchInfo.resArscMd5);
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH);
                 return false;
             }
-            Log.i(TAG, "verify resource file:" + resourceFile.getPath() + ", md5 use time: " + (System.currentTimeMillis() - start));
+            Log.i(TAG, "verify resource file:" + resourceFile.getPath() + " md5, use time: " + (System.currentTimeMillis() - start));
         }
         try {
-            TinkerResourcePatcher.monkeyPatchExistingResources(resourceString);
+            TinkerResourcePatcher.monkeyPatchExistingResources(context, resourceString);
+            Log.i(TAG, "monkeyPatchExistingResources resource file:" + resourceString + ", use time: " + (System.currentTimeMillis() - start));
         } catch (Throwable e) {
-            Log.e(TAG, "install resources failed", e);
+            Log.e(TAG, "install resources failed");
+            //remove patch dex if resource is installed failed
+            try {
+                SystemClassLoaderAdder.uninstallPatchDex(context.getClassLoader());
+            } catch (Throwable throwable) {
+                Log.e(TAG, "uninstallPatchDex failed", e);
+            }
             intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, e);
             ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION);
             return false;
         }
+
         return true;
     }
 
@@ -107,7 +113,7 @@ public static boolean checkComplete(Context context, String directory, ShareSecu
         }
 
         File resourceFile = new File(resourcePath + RESOURCE_FILE);
-        if (!resourceFile.exists()) {
+        if (!SharePatchFileUtil.isLegalFile(resourceFile)) {
             ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_FILE_NOT_EXIST);
             return false;
         }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
index 81aaa4e0..975c4e17 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
@@ -20,61 +20,87 @@
 import android.content.res.AssetManager;
 import android.content.res.Resources;
 import android.util.ArrayMap;
+import android.util.Log;
+
+import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
 
 import java.lang.ref.WeakReference;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.Map;
 
 import static android.os.Build.VERSION.SDK_INT;
 import static android.os.Build.VERSION_CODES.KITKAT;
 
+/**
+ * Created by zhangshaowen on 16/9/21.
+ * Thanks for Android Fragmentation
+ */
 class TinkerResourcePatcher {
-    // original value
-    private static Collection<WeakReference<Resources>> references;
+    private static final String TAG                     = "Tinker.ResourcePatcher";
+    private static final String TEST_ASSETS_VALUE       = "only_use_to_test_tinker_resource.txt";
+//    private static final String MIUI_RESOURCE_CLASSNAME = "android.content.res.MiuiResources";
 
-    private static AssetManager newAssetManager          = null;
-    private static Method       addAssetPathMethod       = null;
-    private static Method       ensureStringBlocksMethod = null;
-    private static Field        assetsFiled              = null;
-    private static Field        resourcesImplFiled      = null;
+    // original object
+    private static Collection<WeakReference<Resources>>  references               = null;
+    private static Object                                currentActivityThread    = null;
+    private static AssetManager                          newAssetManager          = null;
+    //    private static ArrayMap<?, WeakReference<?>>         resourceImpls            = null;
 
-    public static void isResourceCanPatch(Context context) throws Throwable {
-        /*
-        (Note: the resource directory is *also* inserted into the loadedApk in
-        monkeyPatchApplication)
-        The code seems to perform this:
-        File externalResourceFile = <path to resources.ap_ or extracted directory>
+    // method
+    private static Method                                addAssetPathMethod       = null;
+    private static Method                                ensureStringBlocksMethod = null;
 
-        AssetManager newAssetManager = new AssetManager();
-        newAssetManager.addAssetPath(externalResourceFile)
+    // field
+    private static Field assetsFiled           = null;
+    private static Field resourcesImplFiled    = null;
+    private static Field resDir                = null;
+    private static Field packagesFiled         = null;
+    private static Field resourcePackagesFiled = null;
+//    private static Field        publicSourceDirField     = null;
 
-        // Kitkat needs this method call, Lollipop doesn't. However, it doesn't seem to cause any harm
-        // in L, so we do it unconditionally.
-        newAssetManager.ensureStringBlocks();
+//    private static boolean isMiuiSystem = false;
 
-        // Find the singleton instance of ResourcesManager
-        ResourcesManager resourcesManager = ResourcesManager.getInstance();
+    public static void isResourceCanPatch(Context context) throws Throwable {
+        //   - Replace mResDir to point to the external resource file instead of the .apk. This is
+        //     used as the asset path for new Resources objects.
+        //   - Set Application#mLoadedApk to the found LoadedApk instance
 
-        // Iterate over all known Resources objects
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-            for (WeakReference<Resources> wr : resourcesManager.mActiveResources.values()) {
-                Resources resources = wr.get();
-                // Set the AssetManager of the Resources instance to our brand new one
-                resources.mAssets = newAssetManager;
-                resources.updateConfiguration(resources.getConfiguration(), resources.getDisplayMetrics());
-            }
+        // Find the ActivityThread instance for the current thread
+        Class<?> activityThread = Class.forName("android.app.ActivityThread");
+        currentActivityThread = ShareReflectUtil.getActivityThread(context, activityThread);
+
+        // API version 8 has PackageInfo, 10 has LoadedApk. 9, I don't know.
+        Class<?> loadedApkClass;
+        try {
+            loadedApkClass = Class.forName("android.app.LoadedApk");
+        } catch (ClassNotFoundException e) {
+            loadedApkClass = Class.forName("android.app.ActivityThread$PackageInfo");
         }
 
-        // Also, for each context, call getTheme() to get the current theme; null out its
-        // mTheme field, then invoke initializeTheme() to force it to be recreated (with the
-        // new asset manager!)
 
-        */
-        // Create a new AssetManager instance and point it to the resources installed under
-        // /sdcard
-        newAssetManager = AssetManager.class.getConstructor().newInstance();
+        resDir = loadedApkClass.getDeclaredField("mResDir");
+        resDir.setAccessible(true);
+        packagesFiled = activityThread.getDeclaredField("mPackages");
+        packagesFiled.setAccessible(true);
+
+        resourcePackagesFiled = activityThread.getDeclaredField("mResourcePackages");
+        resourcePackagesFiled.setAccessible(true);
+
+        // Create a new AssetManager instance and point it to the resources
+        AssetManager assets = context.getAssets();
+        // Baidu os
+        if (assets.getClass().getName().equals("android.content.res.BaiduAssetManager")) {
+            Class baiduAssetManager = Class.forName("android.content.res.BaiduAssetManager");
+            newAssetManager = (AssetManager) baiduAssetManager.getConstructor().newInstance();
+        } else {
+            newAssetManager = AssetManager.class.getConstructor().newInstance();
+        }
+
         addAssetPathMethod = AssetManager.class.getDeclaredMethod("addAssetPath", String.class);
         addAssetPathMethod.setAccessible(true);
 
@@ -94,29 +120,27 @@ public static void isResourceCanPatch(Context context) throws Throwable {
             try {
                 Field fMActiveResources = resourcesManagerClass.getDeclaredField("mActiveResources");
                 fMActiveResources.setAccessible(true);
-                ArrayMap<?, WeakReference<Resources>> arrayMap =
+                ArrayMap<?, WeakReference<Resources>> activeResources19 =
                     (ArrayMap<?, WeakReference<Resources>>) fMActiveResources.get(resourcesManager);
-                references = arrayMap.values();
+                references = activeResources19.values();
             } catch (NoSuchFieldException ignore) {
                 // N moved the resources to mResourceReferences
                 Field mResourceReferences = resourcesManagerClass.getDeclaredField("mResourceReferences");
                 mResourceReferences.setAccessible(true);
-                //noinspection unchecked
+//                resourceImpls = (ArrayMap<?, WeakReference<?>>) mResourceReferences.get("mResourceImpls");
+
                 references = (Collection<WeakReference<Resources>>) mResourceReferences.get(resourcesManager);
             }
         } else {
-            Class<?> activityThread = Class.forName("android.app.ActivityThread");
             Field fMActiveResources = activityThread.getDeclaredField("mActiveResources");
             fMActiveResources.setAccessible(true);
-            Object thread = getActivityThread(context, activityThread);
-            @SuppressWarnings("unchecked")
-            HashMap<?, WeakReference<Resources>> map =
-                (HashMap<?, WeakReference<Resources>>) fMActiveResources.get(thread);
-            references = map.values();
+            HashMap<?, WeakReference<Resources>> activeResources7 =
+                (HashMap<?, WeakReference<Resources>>) fMActiveResources.get(currentActivityThread);
+            references = activeResources7.values();
         }
         // check resource
-        if (references == null || references.isEmpty()) {
-            throw new IllegalStateException("resource references is null or empty");
+        if (references == null) {
+            throw new IllegalStateException("resource references is null");
         }
         try {
             assetsFiled = Resources.class.getDeclaredField("mAssets");
@@ -126,16 +150,42 @@ public static void isResourceCanPatch(Context context) throws Throwable {
             resourcesImplFiled = Resources.class.getDeclaredField("mResourcesImpl");
             resourcesImplFiled.setAccessible(true);
         }
+
+//        final Resources resources = context.getResources();
+//        isMiuiSystem = resources != null && MIUI_RESOURCE_CLASSNAME.equals(resources.getClass().getName());
+
+//        try {
+//            publicSourceDirField = ShareReflectUtil.findField(ApplicationInfo.class, "publicSourceDir");
+//        } catch (NoSuchFieldException e) {
+//            throw new IllegalStateException("cannot find 'mInstrumentation' field");
+//        }
     }
 
-    public static void monkeyPatchExistingResources(String externalResourceFile) throws Throwable {
+    /**
+     * @param context
+     * @param externalResourceFile
+     * @throws Throwable
+     */
+    public static void monkeyPatchExistingResources(Context context, String externalResourceFile) throws Throwable {
         if (externalResourceFile == null) {
             return;
         }
 
-        // Create a new AssetManager instance and point it to the resources installed under
-        // /sdcard
+        for (Field field : new Field[]{packagesFiled, resourcePackagesFiled}) {
+            Object value = field.get(currentActivityThread);
 
+            for (Map.Entry<String, WeakReference<?>> entry
+                : ((Map<String, WeakReference<?>>) value).entrySet()) {
+                Object loadedApk = entry.getValue().get();
+                if (loadedApk == null) {
+                    continue;
+                }
+                if (externalResourceFile != null) {
+                    resDir.set(loadedApk, externalResourceFile);
+                }
+            }
+        }
+        // Create a new AssetManager instance and point it to the resources installed under
         if (((Integer) addAssetPathMethod.invoke(newAssetManager, externalResourceFile)) == 0) {
             throw new IllegalStateException("Could not create new AssetManager");
         }
@@ -152,41 +202,69 @@ public static void monkeyPatchExistingResources(String externalResourceFile) thr
                 try {
                     assetsFiled.set(resources, newAssetManager);
                 } catch (Throwable ignore) {
-                    //N
+                    // N
                     Object resourceImpl = resourcesImplFiled.get(resources);
-                    Field implAssets = resourceImpl.getClass().getDeclaredField("mAssets");
+                    // for Huawei HwResourcesImpl
+                    Field implAssets = ShareReflectUtil.findField(resourceImpl, "mAssets");
                     implAssets.setAccessible(true);
                     implAssets.set(resourceImpl, newAssetManager);
                 }
 
+                clearPreloadTypedArrayIssue(resources);
+
                 resources.updateConfiguration(resources.getConfiguration(), resources.getDisplayMetrics());
             }
         }
+
+        // Handle issues caused by WebView on Android N.
+        // Issue: On Android N, if an activity contains a webview, when screen rotates
+        // our resource patch may lost effects.
+//        publicSourceDirField.set(context.getApplicationInfo(), externalResourceFile);
+
+        if (!checkResUpdate(context)) {
+            throw new TinkerRuntimeException(ShareConstants.CHECK_RES_INSTALL_FAIL);
+        }
     }
 
-    private static Object getActivityThread(Context context,
-                                            Class<?> activityThread) {
+    /**
+     * Why must I do these?
+     * Resource has mTypedArrayPool field, which just like Message Poll to reduce gc
+     * MiuiResource change TypedArray to MiuiTypedArray, but it get string block from offset instead of assetManager
+     */
+    private static void clearPreloadTypedArrayIssue(Resources resources) {
+        // Perform this trick not only in Miui system since we can't predict if any other
+        // manufacturer would do the same modification to Android.
+//        if (!isMiuiSystem) {
+//            return;
+//        }
+
+        Log.w(TAG, "try to clear typedArray cache!");
+        // Clear typedArray cache.
         try {
-            if (activityThread == null) {
-                activityThread = Class.forName("android.app.ActivityThread");
-            }
-            Method m = activityThread.getMethod("currentActivityThread");
-            m.setAccessible(true);
-            Object currentActivityThread = m.invoke(null);
-            if (currentActivityThread == null && context != null) {
-                // In older versions of Android (prior to frameworks/base 66a017b63461a22842)
-                // the currentActivityThread was built on thread locals, so we'll need to try
-                // even harder
-                Field mLoadedApk = context.getClass().getField("mLoadedApk");
-                mLoadedApk.setAccessible(true);
-                Object apk = mLoadedApk.get(context);
-                Field mActivityThreadField = apk.getClass().getDeclaredField("mActivityThread");
-                mActivityThreadField.setAccessible(true);
-                currentActivityThread = mActivityThreadField.get(apk);
-            }
-            return currentActivityThread;
-        } catch (Throwable ignore) {
-            return null;
+            Field typedArrayPoolField = ShareReflectUtil.findField(Resources.class, "mTypedArrayPool");
+
+            final Object origTypedArrayPool = typedArrayPoolField.get(resources);
+
+            Field poolField = ShareReflectUtil.findField(origTypedArrayPool, "mPool");
+
+            final Constructor<?> typedArrayConstructor = origTypedArrayPool.getClass().getConstructor(int.class);
+            typedArrayConstructor.setAccessible(true);
+            final int poolSize = ((Object[]) poolField.get(origTypedArrayPool)).length;
+            final Object newTypedArrayPool = typedArrayConstructor.newInstance(poolSize);
+            typedArrayPoolField.set(resources, newTypedArrayPool);
+        } catch (Throwable ignored) {
+            Log.e(TAG, "clearPreloadTypedArrayIssue failed, ignore error: " + ignored);
+        }
+    }
+
+    private static boolean checkResUpdate(Context context) {
+        try {
+            Log.e(TAG, "checkResUpdate success, found test resource assets file " + TEST_ASSETS_VALUE);
+            context.getAssets().open(TEST_ASSETS_VALUE);
+        } catch (Throwable e) {
+            Log.e(TAG, "checkResUpdate failed, can't find test resource assets file " + TEST_ASSETS_VALUE + " e:" + e.getMessage());
+            return false;
         }
+        return true;
     }
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcesKey.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcesKey.java
new file mode 100644
index 00000000..d235bdb8
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcesKey.java
@@ -0,0 +1,44 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader;
+
+/**
+ * Created by zhangshaowen on 17/1/12.
+ *
+ * TODO:
+ * Thanks for Android Fragmentation
+ * hold the issue https://github.com/Tencent/tinker/issues/302
+ */
+public class TinkerResourcesKey {
+
+    private static final class V24 {
+
+
+    }
+
+    private static final class V19 {
+
+    }
+
+    private static final class V17 {
+
+    }
+
+    private static final class V7 {
+
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerSoLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerSoLoader.java
index c495465b..5f97e388 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerSoLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerSoLoader.java
@@ -21,6 +21,7 @@
 import com.tencent.tinker.loader.shareutil.ShareBsDiffPatchInfo;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
 
 import java.io.File;
@@ -89,7 +90,7 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
         //fast check whether there is any dex files missing
         for (String relative : libs.keySet()) {
             File libFile = new File(libraryPath + relative);
-            if (!libFile.exists()) {
+            if (!SharePatchFileUtil.isLegalFile(libFile)) {
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_LIB_FILE_NOT_EXIST);
                 intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISSING_LIB_PATH, libFile.getAbsolutePath());
                 return false;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java
new file mode 100644
index 00000000..8471914c
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java
@@ -0,0 +1,78 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader;
+
+import android.content.Context;
+import android.util.Log;
+
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+
+/**
+ * Created by zhangshaowen on 16/12/1.
+ */
+
+public class TinkerUncaughtHandler implements Thread.UncaughtExceptionHandler {
+    private static final String TAG = "Tinker.UncaughtHandler";
+
+
+    private final File crashFile;
+    private final Context context;
+    private final Thread.UncaughtExceptionHandler ueh;
+
+    public TinkerUncaughtHandler(Context context) {
+        this.context = context;
+        ueh = Thread.getDefaultUncaughtExceptionHandler();
+        crashFile = SharePatchFileUtil.getPatchLastCrashFile(context);
+    }
+
+    @Override
+    public void uncaughtException(Thread thread, Throwable ex) {
+        Log.e(TAG, "catch exception when loading tinker:" + Log.getStackTraceString(ex));
+        ueh.uncaughtException(thread, ex);
+
+        if (crashFile != null) {
+            Thread.UncaughtExceptionHandler handler = Thread.getDefaultUncaughtExceptionHandler();
+
+            //only catch real uncaught Exception
+            if (handler instanceof TinkerUncaughtHandler) {
+                File parentFile = crashFile.getParentFile();
+                if (!parentFile.exists() && !parentFile.mkdirs()) {
+                    Log.e(TAG, "print crash file error: create directory fail!");
+                    return;
+                }
+                PrintWriter pw = null;
+                try {
+                    pw = new PrintWriter(new FileWriter(crashFile, false));
+                    pw.println("process:" + ShareTinkerInternals.getProcessName(this.context));
+                    pw.println(ShareTinkerInternals.getExceptionCauseString(ex));
+                } catch (IOException e) {
+                    //ignore
+                    Log.e(TAG, "print crash file error:" + Log.getStackTraceString(e));
+                } finally {
+                    SharePatchFileUtil.closeQuietly(pw);
+                }
+                android.os.Process.killProcess(android.os.Process.myPid());
+            }
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java
index df3d558f..ca0a9059 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java
@@ -33,34 +33,16 @@
     private final long        applicationStartMillisTime;
     private final int         tinkerFlags;
     private final boolean     tinkerLoadVerifyFlag;
-    private Resources[]    resources;
-    private ClassLoader[]  classLoader;
-    private AssetManager[] assetManager;
+
 
     public ApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,
-                           long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent,
-                           Resources[] resources, ClassLoader[] classLoader, AssetManager[] assetManager) {
+                           long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) {
         this.application = application;
         this.tinkerFlags = tinkerFlags;
         this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;
         this.applicationStartElapsedTime = applicationStartElapsedTime;
         this.applicationStartMillisTime = applicationStartMillisTime;
         this.tinkerResultIntent = tinkerResultIntent;
-        this.resources = resources;
-        this.classLoader = classLoader;
-        this.assetManager = assetManager;
-    }
-
-    public void setResources(Resources resources) {
-        this.resources[0] = resources;
-    }
-
-    public void setAssetManager(AssetManager assetManager) {
-        this.assetManager[0] = assetManager;
-    }
-
-    public void setClassLoader(ClassLoader classLoader) {
-        this.classLoader[0] = classLoader;
     }
 
     public Application getApplication() {
@@ -116,4 +98,21 @@ public void onConfigurationChanged(Configuration newConfig) {
     public void onBaseContextAttached(Context base) {
 
     }
+    //some get methods that may be overwrite
+    public Resources getResources(Resources resources) {
+        return resources;
+    }
+
+    public ClassLoader getClassLoader(ClassLoader classLoader) {
+        return classLoader;
+    }
+
+    public AssetManager getAssets(AssetManager assetManager) {
+       return assetManager;
+    }
+
+    public Object getSystemService(String name, Object service) {
+        return service;
+    }
 }
+
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/DefaultApplicationLike.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/DefaultApplicationLike.java
index f0367db2..eabf146e 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/DefaultApplicationLike.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/DefaultApplicationLike.java
@@ -23,9 +23,7 @@
 import android.app.Application;
 import android.content.Context;
 import android.content.Intent;
-import android.content.res.AssetManager;
 import android.content.res.Configuration;
-import android.content.res.Resources;
 import android.util.Log;
 
 /**
@@ -35,9 +33,8 @@
     private static final String TAG = "Tinker.DefaultAppLike";
 
     public DefaultApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,
-                                  long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent,
-                                  Resources[] resources, ClassLoader[] classLoader, AssetManager[] assetManager) {
-        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent, resources, classLoader, assetManager);
+                                  long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) {
+        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);
     }
 
     @Override
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
index eb908b86..bcdab701 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
@@ -28,9 +28,9 @@
 
 import com.tencent.tinker.loader.TinkerLoader;
 import com.tencent.tinker.loader.TinkerRuntimeException;
+import com.tencent.tinker.loader.TinkerUncaughtHandler;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
-import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.lang.reflect.Constructor;
@@ -54,7 +54,7 @@
      * dex only, library only, all support
      * default: TINKER_ENABLE_ALL
      */
-    private final int tinkerFlags;
+    private final int     tinkerFlags;
     /**
      * whether verify md5 when we load dex or lib
      * they store at data/data/package, and we had verity them at the :patch process.
@@ -67,13 +67,10 @@
     /**
      * if we have load patch, we should use safe mode
      */
-    private boolean useSafeMode;
+    private       boolean useSafeMode;
     private       Intent  tinkerResultIntent;
 
-    private Object         delegate      = null;
-    private Resources[]    resources     = new Resources[1];
-    private ClassLoader[]  classLoader   = new ClassLoader[1];
-    private AssetManager[] assetManager  = new AssetManager[1];
+    private ApplicationLike applicationLike = null;
 
     private long applicationStartElapsedTime;
     private long applicationStartMillisTime;
@@ -102,24 +99,23 @@ protected TinkerApplication(int tinkerFlags, String delegateClassName) {
         this(tinkerFlags, delegateClassName, TinkerLoader.class.getName(), false);
     }
 
-    private Object createDelegate() {
+    private ApplicationLike createDelegate() {
         try {
             // Use reflection to create the delegate so it doesn't need to go into the primary dex.
             // And we can also patch it
             Class<?> delegateClass = Class.forName(delegateClassName, false, getClassLoader());
-            Constructor<?> constructor = delegateClass.getConstructor(Application.class, int.class, boolean.class, long.class, long.class,
-                Intent.class, Resources[].class, ClassLoader[].class, AssetManager[].class);
-            return constructor.newInstance(this, tinkerFlags, tinkerLoadVerifyFlag,
-                applicationStartElapsedTime, applicationStartMillisTime,
-                tinkerResultIntent, resources, classLoader, assetManager);
+            Constructor<?> constructor = delegateClass.getConstructor(Application.class, int.class, boolean.class,
+                long.class, long.class, Intent.class);
+            return (ApplicationLike) constructor.newInstance(this, tinkerFlags, tinkerLoadVerifyFlag,
+                applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);
         } catch (Throwable e) {
             throw new TinkerRuntimeException("createDelegate failed", e);
         }
     }
 
     private synchronized void ensureDelegate() {
-        if (delegate == null) {
-            delegate = createDelegate();
+        if (applicationLike == null) {
+            applicationLike = createDelegate();
         }
     }
 
@@ -133,12 +129,7 @@ private void onBaseContextAttached(Context base) {
         applicationStartMillisTime = System.currentTimeMillis();
         loadTinker();
         ensureDelegate();
-        try {
-            Method method = ShareReflectUtil.findMethod(delegate, "onBaseContextAttached", Context.class);
-            method.invoke(delegate, base);
-        } catch (Throwable t) {
-            throw new TinkerRuntimeException("onBaseContextAttached method not found", t);
-        }
+        applicationLike.onBaseContextAttached(base);
         //reset save mode
         if (useSafeMode) {
             String processName = ShareTinkerInternals.getProcessName(this);
@@ -149,8 +140,9 @@ private void onBaseContextAttached(Context base) {
     }
 
     @Override
-    protected final void attachBaseContext(Context base) {
+    protected void attachBaseContext(Context base) {
         super.attachBaseContext(base);
+        Thread.setDefaultUncaughtExceptionHandler(new TinkerUncaughtHandler(this));
         onBaseContextAttached(base);
     }
 
@@ -174,93 +166,80 @@ private void loadTinker() {
         }
     }
 
-    private void delegateMethod(String methodName) {
-        if (delegate != null) {
-            try {
-                Method method = ShareReflectUtil.findMethod(delegate, methodName, new Class[0]);
-                method.invoke(delegate, new Object[0]);
-            } catch (Throwable t) {
-                throw new TinkerRuntimeException(String.format("%s method not found", methodName), t);
-            }
-        }
-    }
-
     @Override
-    public final void onCreate() {
+    public void onCreate() {
         super.onCreate();
         ensureDelegate();
-        delegateMethod("onCreate");
+        applicationLike.onCreate();
     }
 
     @Override
-    public final void onTerminate() {
+    public void onTerminate() {
         super.onTerminate();
-        delegateMethod("onTerminate");
+        if (applicationLike != null) {
+            applicationLike.onTerminate();
+        }
     }
 
     @Override
-    public final void onLowMemory() {
+    public void onLowMemory() {
         super.onLowMemory();
-        delegateMethod("onLowMemory");
-    }
-
-    private void delegateTrimMemory(int level) {
-        if (delegate != null) {
-            try {
-                Method method = ShareReflectUtil.findMethod(delegate, "onTrimMemory", int.class);
-                method.invoke(delegate, level);
-            } catch (Throwable t) {
-                throw new TinkerRuntimeException("onTrimMemory method not found", t);
-            }
+        if (applicationLike != null) {
+            applicationLike.onLowMemory();
         }
     }
 
     @TargetApi(14)
     @Override
-    public final void onTrimMemory(int level) {
+    public void onTrimMemory(int level) {
         super.onTrimMemory(level);
-        delegateTrimMemory(level);
-    }
-
-    private void delegateConfigurationChanged(Configuration newConfig) {
-        if (delegate != null) {
-            try {
-                Method method = ShareReflectUtil.findMethod(delegate, "onConfigurationChanged", Configuration.class);
-                method.invoke(delegate, newConfig);
-            } catch (Throwable t) {
-                throw new TinkerRuntimeException("onConfigurationChanged method not found", t);
-            }
+        if (applicationLike != null) {
+            applicationLike.onTrimMemory(level);
         }
     }
 
     @Override
     public void onConfigurationChanged(Configuration newConfig) {
         super.onConfigurationChanged(newConfig);
-        delegateConfigurationChanged(newConfig);
+        if (applicationLike != null) {
+            applicationLike.onConfigurationChanged(newConfig);
+        }
     }
 
     @Override
     public Resources getResources() {
-        if (resources[0] != null) {
-            return resources[0];
+        Resources resources = super.getResources();
+        if (applicationLike != null) {
+            return applicationLike.getResources(resources);
         }
-        return super.getResources();
+        return resources;
     }
 
     @Override
     public ClassLoader getClassLoader() {
-        if (classLoader[0] != null) {
-            return classLoader[0];
+        ClassLoader classLoader = super.getClassLoader();
+        if (applicationLike != null) {
+            return applicationLike.getClassLoader(classLoader);
         }
-        return super.getClassLoader();
+        return classLoader;
     }
 
     @Override
     public AssetManager getAssets() {
-        if (assetManager[0] != null) {
-            return assetManager[0];
+        AssetManager assetManager = super.getAssets();
+        if (applicationLike != null) {
+            return applicationLike.getAssets(assetManager);
+        }
+        return assetManager;
+    }
+
+    @Override
+    public Object getSystemService(String name) {
+        Object service = super.getSystemService(name);
+        if (applicationLike != null) {
+            return applicationLike.getSystemService(name, service);
         }
-        return super.getAssets();
+        return service;
     }
 
     public void setUseSafeMode(boolean useSafeMode) {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
index 8f53fcb6..9d485d78 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
@@ -20,6 +20,8 @@
  * Created by zhangshaowen on 16/3/24.
  */
 public class ShareConstants {
+    public static final String TINKER_VERSION = "1.7.7";
+
     public static final int BUFFER_SIZE         = 16384;
     public static final int MD5_LENGTH          = 32;
     public static final int MD5_FILE_BUF_LENGTH = 1024 * 100;
@@ -39,15 +41,17 @@
     public static final String SO_META_FILE = "assets/so_meta.txt";
     public static final String SO_PATH      = "lib";
 
-    // If you changed this value, please change the same value in TypedValue, too.
-    public static final String DEX_SMALLPATCH_INFO_FILE = "smallpatch_info.ddextra";
 
-    public static final String DEX_META_FILE            = "assets/dex_meta.txt";
-    public static final String DEX_PATH                 = "dex";
-    public static final String DEX_OPTIMIZE_PATH        = "odex";
-    public static final String DEX_SUFFIX               = ".dex";
-    public static final String JAR_SUFFIX               = ".jar";
+    public static final String DEX_META_FILE     = "assets/dex_meta.txt";
+    public static final String DEX_PATH          = "dex";
+    public static final String DEX_OPTIMIZE_PATH = "odex";
+    public static final String DEX_SUFFIX        = ".dex";
+    public static final String JAR_SUFFIX        = ".jar";
+
     public static final String CHECK_DEX_INSTALL_FAIL = "checkDexInstall failed";
+    public static final String CHECK_RES_INSTALL_FAIL = "checkResInstall failed";
+//    public static final String CHECK_VM_PROPERTY_FAIL = "checkVmArtProperty failed";
+
 
     public static final String RES_META_FILE       = "assets/res_meta.txt";
     public static final String RES_ARSC            = "resources.arsc";
@@ -65,7 +69,10 @@
     public static final String DEXMODE_JAR = "jar";
     public static final String DEX_IN_JAR  = "classes.dex";
 
-    public static final String PATCH_DIRECTORY_NAME = "tinker";
+    public static final String PATCH_DIRECTORY_NAME       = "tinker";
+    public static final String PATCH_TEMP_DIRECTORY_NAME  = "tinker_temp";
+    public static final String PATCH_TEMP_LAST_CRASH_NAME = "tinker_last_crash";
+
     public static final String PATCH_INFO_NAME      = "patch.info";
     public static final String PATCH_INFO_LOCK_NAME = "info.lock";
 
@@ -75,7 +82,7 @@
      * multi process share
      */
     public static final String TINKER_SHARE_PREFERENCE_CONFIG = "tinker_share_config";
-    public static final String TINKER_ENABLE_CONFIG           = "tinker_enable";
+    public static final String TINKER_ENABLE_CONFIG           = "tinker_enable_";
 
     /**
      * only for each process
@@ -93,16 +100,13 @@
     public static final int TINKER_PATCH_SERVICE_NOTIFICATION = -1119860829;
 
     //resource type
-    public static final int TYPE_PATCH_FILE  = 1;
-    public static final int TYPE_PATCH_INFO  = 2;
-    public static final int TYPE_DEX         = 3;
-    /**
-     * for art small dex
-     */
-    public static final int TYPE_DEX_FOR_ART = 4;
-    public static final int TYPE_DEX_OPT     = 5;
-    public static final int TYPE_LIBRARY     = 6;
-    public static final int TYPE_RESOURCE    = 7;
+    public static final int TYPE_PATCH_FILE = 1;
+    public static final int TYPE_PATCH_INFO = 2;
+    public static final int TYPE_DEX        = 3;
+
+    public static final int TYPE_DEX_OPT  = 4;
+    public static final int TYPE_LIBRARY  = 5;
+    public static final int TYPE_RESOURCE = 6;
 
 
     public static final int TINKER_DISABLE             = 0x00;
@@ -113,31 +117,33 @@
     public static final int TINKER_ENABLE_ALL          = TINKER_DEX_MASK | TINKER_NATIVE_LIBRARY_MASK | TINKER_RESOURCE_MASK;
 
     //load error code
-    public static final int ERROR_LOAD_OK                                         = 0;
-    public static final int ERROR_LOAD_DISABLE                                    = -1;
-    public static final int ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST                  = -2;
-    public static final int ERROR_LOAD_PATCH_INFO_NOT_EXIST                       = -3;
-    public static final int ERROR_LOAD_PATCH_INFO_CORRUPTED                       = -4;
-    public static final int ERROR_LOAD_PATCH_INFO_BLANK                           = -5;
-    public static final int ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST          = -6;
-    public static final int ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST               = -7;
-    public static final int ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL                   = -9;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST      = -10;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST           = -11;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST       = -12;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL         = -13;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH             = -14;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION           = -15;
+    public static final int ERROR_LOAD_OK                                       = 0;
+    public static final int ERROR_LOAD_DISABLE                                  = -1;
+    public static final int ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST                = -2;
+    public static final int ERROR_LOAD_PATCH_INFO_NOT_EXIST                     = -3;
+    public static final int ERROR_LOAD_PATCH_INFO_CORRUPTED                     = -4;
+    public static final int ERROR_LOAD_PATCH_INFO_BLANK                         = -5;
+    public static final int ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST        = -6;
+    public static final int ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST             = -7;
+    public static final int ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL                 = -8;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST    = -9;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST         = -10;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST     = -11;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL       = -12;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH           = -13;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION         = -14;
+    public static final int ERROR_LOAD_PATCH_VERSION_PARALLEL_DEX_OPT_EXCEPTION = -15;
+
     public static final int ERROR_LOAD_PATCH_VERSION_LIB_DIRECTORY_NOT_EXIST      = -16;
     public static final int ERROR_LOAD_PATCH_VERSION_LIB_FILE_NOT_EXIST           = -17;
     public static final int ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL              = -18;
     public static final int ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION                    = -19;
     //resource
-    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_DIRECTORY_NOT_EXIST = -21;
-    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_FILE_NOT_EXIST      = -22;
-    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION      = -23;
-    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH        = -24;
-    public static final int ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION                   = -25;
+    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_DIRECTORY_NOT_EXIST = -20;
+    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_FILE_NOT_EXIST      = -21;
+    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION      = -22;
+    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH        = -23;
+    public static final int ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION                   = -24;
 
     public static final int ERROR_LOAD_GET_INTENT_FAIL = -10000;
 
@@ -147,9 +153,10 @@
     public static final int ERROR_LOAD_EXCEPTION_DEX      = -2;
     public static final int ERROR_LOAD_EXCEPTION_RESOURCE = -3;
     public static final int ERROR_LOAD_EXCEPTION_UNCAUGHT = -4;
+    public static final int ERROR_LOAD_EXCEPTION_DEX_OPT  = -5;
 
 
-    //recover error code
+    //patch listener error code
     public static final int ERROR_PATCH_OK        = 0;
     public static final int ERROR_PATCH_DISABLE   = -1;
     public static final int ERROR_PATCH_NOTEXIST  = -2;
@@ -166,5 +173,5 @@
     public static final int ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND = -6;
     public static final int ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = -7;
     public static final int ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED   = -8;
-
+    public static final int ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = -9;
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
index 965fb4cd..7cf48852 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
@@ -41,6 +41,8 @@
     public static final  String INTENT_PATCH_EXCEPTION           = "intent_patch_exception";
     public static final  String INTENT_PATCH_PACKAGE_PATCH_CHECK = "intent_patch_package_patch_check";
     public static final  String INTENT_PATCH_PACKAGE_CONFIG      = "intent_patch_package_config";
+    public static final  String INTENT_PATCH_SYSTEM_OTA          = "intent_patch_system_ota";
+
     private static final String TAG                              = "ShareIntentUtil";
 
     public static void setIntentReturnCode(Intent intent, int code) {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
index ddfee922..419efd88 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
@@ -21,12 +21,14 @@
 import android.util.Log;
 
 import java.io.BufferedInputStream;
+import java.io.BufferedReader;
 import java.io.Closeable;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.security.MessageDigest;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
@@ -52,6 +54,24 @@ public static File getPatchDirectory(Context context) {
         return new File(applicationInfo.dataDir, ShareConstants.PATCH_DIRECTORY_NAME);
     }
 
+    public static File getPatchTempDirectory(Context context) {
+        ApplicationInfo applicationInfo = context.getApplicationInfo();
+        if (applicationInfo == null) {
+            // Looks like running on a test Context, so just return without patching.
+            return null;
+        }
+
+        return new File(applicationInfo.dataDir, ShareConstants.PATCH_TEMP_DIRECTORY_NAME);
+    }
+
+    public static File getPatchLastCrashFile(Context context) {
+        File tempFile = getPatchTempDirectory(context);
+        if (tempFile == null) {
+            return null;
+        }
+        return new File(tempFile, ShareConstants.PATCH_TEMP_LAST_CRASH_NAME);
+    }
+
     public static File getPatchInfoFile(String patchDirectory) {
         return new File(patchDirectory + "/" + ShareConstants.PATCH_INFO_NAME);
     }
@@ -83,16 +103,33 @@ public static boolean checkIfMd5Valid(final String object) {
         return true;
     }
 
-    public static final boolean fileExists(String filePath) {
-        if (filePath == null) {
-            return false;
+    public static String checkTinkerLastUncaughtCrash(Context context) {
+        File crashFile = SharePatchFileUtil.getPatchLastCrashFile(context);
+        if (!SharePatchFileUtil.isLegalFile(crashFile)) {
+            return null;
         }
-
-        File file = new File(filePath);
-        if (file.exists()) {
-            return true;
+        StringBuffer buffer = new StringBuffer();
+        BufferedReader in = null;
+        try {
+            in = new BufferedReader(new InputStreamReader(new FileInputStream(crashFile)));
+            String line;
+            while ((line = in.readLine()) != null) {
+                buffer.append(line);
+                buffer.append("\n");
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "checkTinkerLastUncaughtCrash exception: " + e);
+            return null;
+        } finally {
+            closeQuietly(in);
         }
-        return false;
+
+        return buffer.toString();
+
+    }
+
+    public static final boolean isLegalFile(File file) {
+        return file != null && file.exists() && file.isFile() && file.length() > 0;
     }
 
     /**
@@ -208,17 +245,25 @@ public static boolean verifyDexFileMd5(File file, String md5) {
             try {
                 dexJar = new ZipFile(file);
                 ZipEntry classesDex = dexJar.getEntry(ShareConstants.DEX_IN_JAR);
-
                 // no code
                 if (null == classesDex) {
+                    Log.e(TAG, "There's no entry named: " + ShareConstants.DEX_IN_JAR + " in " + file.getAbsolutePath());
                     return false;
                 }
                 fileMd5 = getMD5(dexJar.getInputStream(classesDex));
-            } catch (IOException e) {
-//                e.printStackTrace();
+            } catch (Throwable e) {
+                Log.e(TAG, "Bad dex jar file: " + file.getAbsolutePath(), e);
                 return false;
             } finally {
-                SharePatchFileUtil.closeZip(dexJar);
+                // Bugfix: some device redefined ZipFile, which is not implemented closeable.
+                // SharePatchFileUtil.closeZip(dexJar);
+                if (dexJar != null) {
+                    try {
+                        dexJar.close();
+                    } catch (Throwable thr) {
+                        // Ignored.
+                    }
+                }
             }
         }
 
@@ -226,6 +271,12 @@ public static boolean verifyDexFileMd5(File file, String md5) {
     }
 
     public static void copyFileUsingStream(File source, File dest) throws IOException {
+        if (!SharePatchFileUtil.isLegalFile(source) || dest == null) {
+            return;
+        }
+        if (source.getAbsolutePath().equals(dest.getAbsolutePath())) {
+            return;
+        }
         FileInputStream is = null;
         FileOutputStream os = null;
         File parent = dest.getParentFile();
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
index f787fb38..71a96450 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
@@ -16,6 +16,7 @@
 
 package com.tencent.tinker.loader.shareutil;
 
+import android.os.Build;
 import android.util.Log;
 
 import com.tencent.tinker.loader.TinkerRuntimeException;
@@ -33,17 +34,23 @@
     public static final int    MAX_EXTRACT_ATTEMPTS = ShareConstants.MAX_EXTRACT_ATTEMPTS;
     public static final String OLD_VERSION          = ShareConstants.OLD_VERSION;
     public static final String NEW_VERSION          = ShareConstants.NEW_VERSION;
+    public static final String FINGER_PRINT         = "print";
     private static final String TAG = "PatchInfo";
     public String oldVersion;
     public String newVersion;
+    public String fingerPrint;
 
-    public SharePatchInfo(String oldVer, String newVew) {
+    public SharePatchInfo(String oldVer, String newVew, String finger) {
         // TODO Auto-generated constructor stub
         this.oldVersion = oldVer;
         this.newVersion = newVew;
+        this.fingerPrint = finger;
     }
 
     public static SharePatchInfo readAndCheckPropertyWithLock(File pathInfoFile, File lockFile) {
+        if (pathInfoFile == null || lockFile == null) {
+            return null;
+        }
         File lockParentFile = lockFile.getParentFile();
         if (!lockParentFile.exists()) {
             lockParentFile.mkdirs();
@@ -70,6 +77,9 @@ public static SharePatchInfo readAndCheckPropertyWithLock(File pathInfoFile, Fil
     }
 
     public static boolean rewritePatchInfoFileWithLock(File pathInfoFile, SharePatchInfo info, File lockFile) {
+        if (pathInfoFile == null || info == null || lockFile == null) {
+            return false;
+        }
         File lockParentFile = lockFile.getParentFile();
         if (!lockParentFile.exists()) {
             lockParentFile.mkdirs();
@@ -99,6 +109,7 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
         int numAttempts = 0;
         String oldVer = null;
         String newVer = null;
+        String lastFingerPrint = null;
 
         while (numAttempts < MAX_EXTRACT_ATTEMPTS && !isReadPatchSuccessful) {
             numAttempts++;
@@ -109,8 +120,10 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
                 properties.load(inputStream);
                 oldVer = properties.getProperty(OLD_VERSION);
                 newVer = properties.getProperty(NEW_VERSION);
+                lastFingerPrint = properties.getProperty(FINGER_PRINT);
             } catch (IOException e) {
-                e.printStackTrace();
+//                e.printStackTrace();
+                Log.e(TAG, "read property failed, e:" + e);
             } finally {
                 SharePatchFileUtil.closeQuietly(inputStream);
             }
@@ -118,8 +131,9 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
             if (oldVer == null || newVer == null) {
                 continue;
             }
-            //oldver may be "" or 32 md5
-            if ((!oldVer.equals("") && !SharePatchFileUtil.checkIfMd5Valid(oldVer)) || !SharePatchFileUtil.checkIfMd5Valid(newVer)) {
+            //oldVer may be "" or 32 md5
+            if ((!oldVer.equals("") && !SharePatchFileUtil.checkIfMd5Valid(oldVer))
+                || !SharePatchFileUtil.checkIfMd5Valid(newVer)) {
                 Log.w(TAG, "path info file  corrupted:" + pathInfoFile.getAbsolutePath());
                 continue;
             } else {
@@ -128,7 +142,7 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
         }
 
         if (isReadPatchSuccessful) {
-            return new SharePatchInfo(oldVer, newVer);
+            return new SharePatchInfo(oldVer, newVer, lastFingerPrint);
         }
 
         return null;
@@ -159,6 +173,8 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
             Properties newProperties = new Properties();
             newProperties.put(OLD_VERSION, info.oldVersion);
             newProperties.put(NEW_VERSION, info.newVersion);
+            newProperties.put(FINGER_PRINT, Build.FINGERPRINT);
+
             FileOutputStream outputStream = null;
             try {
                 outputStream = new FileOutputStream(pathInfoFile, false);
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
index 28f0295a..7ebc1dbd 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
@@ -16,6 +16,8 @@
 
 package com.tencent.tinker.loader.shareutil;
 
+import android.content.Context;
+
 import java.lang.reflect.Array;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
@@ -125,4 +127,59 @@ public static void expandFieldArray(Object instance, String fieldName, Object[]
         jlrField.set(instance, combined);
     }
 
+    /**
+     * Replace the value of a field containing a non null array, by a new array containing the
+     * elements of the original array plus the elements of extraElements.
+     *
+     * @param instance      the instance whose field is to be modified.
+     * @param fieldName     the field to modify.
+     */
+    public static void reduceFieldArray(Object instance, String fieldName, int reduceSize)
+        throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException {
+        if (reduceSize <= 0) {
+            return;
+        }
+
+        Field jlrField = findField(instance, fieldName);
+
+        Object[] original = (Object[]) jlrField.get(instance);
+        int finalLength = original.length - reduceSize;
+
+        if (finalLength <= 0) {
+            return;
+        }
+
+        Object[] combined = (Object[]) Array.newInstance(original.getClass().getComponentType(), finalLength);
+
+        System.arraycopy(original, reduceSize, combined, 0, finalLength);
+
+        jlrField.set(instance, combined);
+    }
+
+    public static Object getActivityThread(Context context,
+                                            Class<?> activityThread) {
+        try {
+            if (activityThread == null) {
+                activityThread = Class.forName("android.app.ActivityThread");
+            }
+            Method m = activityThread.getMethod("currentActivityThread");
+            m.setAccessible(true);
+            Object currentActivityThread = m.invoke(null);
+            if (currentActivityThread == null && context != null) {
+                // In older versions of Android (prior to frameworks/base 66a017b63461a22842)
+                // the currentActivityThread was built on thread locals, so we'll need to try
+                // even harder
+                Field mLoadedApk = context.getClass().getField("mLoadedApk");
+                mLoadedApk.setAccessible(true);
+                Object apk = mLoadedApk.get(context);
+                Field mActivityThreadField = apk.getClass().getDeclaredField("mActivityThread");
+                mActivityThreadField.setAccessible(true);
+                currentActivityThread = mActivityThreadField.get(apk);
+            }
+            return currentActivityThread;
+        } catch (Throwable ignore) {
+            return null;
+        }
+    }
+
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
index d62e4693..921984cb 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
@@ -64,32 +64,6 @@ public ShareSecurityCheck(Context context) {
         return metaContentMap;
     }
 
-    /**
-     * get the base tinkerId
-     *
-     * @return
-     */
-    public String getTinkerID() {
-        if (packageProperties != null) {
-            String tinkerId = packageProperties.get(ShareConstants.TINKER_ID);
-            return tinkerId;
-        }
-        return null;
-    }
-
-    /**
-     * get the new tinkerId
-     *
-     * @return
-     */
-    public String getNewTinkerID() {
-        if (packageProperties != null) {
-            String tinkerId = packageProperties.get(ShareConstants.NEW_TINKER_ID);
-
-            return tinkerId;
-        }
-        return null;
-    }
     /**
      * Nullable
      *
@@ -128,7 +102,7 @@ public String getNewTinkerID() {
     }
 
     public boolean verifyPatchMetaSignature(File path) {
-        if (path == null || !path.isFile() || !path.exists() || path.length() == 0) {
+        if (!SharePatchFileUtil.isLegalFile(path)) {
             return false;
         }
         JarFile jarFile = null;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
index 404bbdcd..6024ba9c 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
@@ -21,12 +21,15 @@
 import android.content.SharedPreferences;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
+import android.os.Build;
 import android.util.Log;
 
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.PrintStream;
 import java.util.HashMap;
 import java.util.Properties;
 import java.util.regex.Matcher;
@@ -47,7 +50,26 @@
     private static String tinkerID = null;
 
     public static boolean isVmArt() {
-        return VM_IS_ART;
+        return VM_IS_ART || Build.VERSION.SDK_INT >= 21;
+    }
+
+    public static boolean isSystemOTA(String lastFingerPrint) {
+        String currentFingerprint = Build.FINGERPRINT;
+        if (lastFingerPrint == null
+            || lastFingerPrint.equals("")
+            || currentFingerprint == null
+            || currentFingerprint.equals("")) {
+            Log.d(TAG, "fingerprint empty:" + lastFingerPrint + ",current:" + currentFingerprint);
+            return false;
+        } else {
+            if (lastFingerPrint.equals(currentFingerprint)) {
+                Log.d(TAG, "same fingerprint:" + currentFingerprint);
+                return false;
+            } else {
+                Log.d(TAG, "system OTA,fingerprint not equal:" + lastFingerPrint + "," + currentFingerprint);
+                return true;
+            }
+        }
     }
 
     public static boolean isNullOrNil(final String object) {
@@ -57,6 +79,21 @@ public static boolean isNullOrNil(final String object) {
         return false;
     }
 
+    /**
+     * thinker package check
+     * @param context
+     * @param tinkerFlag
+     * @param patchFile
+     * @param securityCheck
+     * @return
+     */
+    public static int checkTinkerPackage(Context context, int tinkerFlag, File patchFile, ShareSecurityCheck securityCheck) {
+        int returnCode = checkSignatureAndTinkerID(context, patchFile, securityCheck);
+        if (returnCode == ShareConstants.ERROR_PACKAGE_CHECK_OK) {
+            returnCode = checkPackageAndTinkerFlag(securityCheck, tinkerFlag);
+        }
+        return returnCode;
+    }
     /**
      * check patch file signature and TINKER_ID
      *
@@ -86,11 +123,37 @@ public static int checkSignatureAndTinkerID(Context context, File patchFile, Sha
             return ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND;
         }
         if (!oldTinkerId.equals(patchTinkerId)) {
+            Log.e(TAG, "tinkerId is not equal, base is " + oldTinkerId + ", but patch is " + patchTinkerId);
             return ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL;
         }
         return ShareConstants.ERROR_PACKAGE_CHECK_OK;
     }
 
+
+    public static int checkPackageAndTinkerFlag(ShareSecurityCheck securityCheck, int tinkerFlag) {
+        if (isTinkerEnabledAll(tinkerFlag)) {
+            return ShareConstants.ERROR_PACKAGE_CHECK_OK;
+        }
+        HashMap<String, String> metaContentMap = securityCheck.getMetaContentMap();
+        //check dex
+        boolean dexEnable = isTinkerEnabledForDex(tinkerFlag);
+        if (!dexEnable && metaContentMap.containsKey(ShareConstants.DEX_META_FILE)) {
+            return ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT;
+        }
+        //check native library
+        boolean nativeEnable = isTinkerEnabledForNativeLib(tinkerFlag);
+        if (!nativeEnable && metaContentMap.containsKey(ShareConstants.SO_META_FILE)) {
+            return ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT;
+        }
+        //check resource
+        boolean resEnable = isTinkerEnabledForResource(tinkerFlag);
+        if (!resEnable && metaContentMap.containsKey(ShareConstants.RES_META_FILE)) {
+            return ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT;
+        }
+
+        return ShareConstants.ERROR_PACKAGE_CHECK_OK;
+    }
+
     /**
      * not like {@cod ShareSecurityCheck.getPackagePropertiesIfPresent}
      * we don't check Signatures or other files, we just get the package meta's properties directly
@@ -126,6 +189,7 @@ public static Properties fastGetPatchPackageMeta(File patchFile) {
             SharePatchFileUtil.closeZip(zipFile);
         }
     }
+
     public static String getManifestTinkerID(Context context) {
         if (tinkerID != null) {
             return tinkerID;
@@ -165,8 +229,6 @@ public static String getTypeString(int type) {
         switch (type) {
             case ShareConstants.TYPE_DEX:
                 return "dex";
-            case ShareConstants.TYPE_DEX_FOR_ART:
-                return "dex_art";
             case ShareConstants.TYPE_DEX_OPT:
                 return "dex_opt";
             case ShareConstants.TYPE_LIBRARY:
@@ -188,7 +250,7 @@ public static String getTypeString(int type) {
      */
     public static void setTinkerDisableWithSharedPreferences(Context context) {
         SharedPreferences sp = context.getSharedPreferences(ShareConstants.TINKER_SHARE_PREFERENCE_CONFIG, Context.MODE_MULTI_PROCESS);
-        sp.edit().putBoolean(ShareConstants.TINKER_ENABLE_CONFIG, false).commit();
+        sp.edit().putBoolean(getTinkerSharedPreferencesName(), false).commit();
     }
 
     /**
@@ -197,8 +259,15 @@ public static void setTinkerDisableWithSharedPreferences(Context context) {
      * @return
      */
     public static boolean isTinkerEnableWithSharedPreferences(Context context) {
+        if (context == null) {
+            return false;
+        }
         SharedPreferences sp = context.getSharedPreferences(ShareConstants.TINKER_SHARE_PREFERENCE_CONFIG, Context.MODE_MULTI_PROCESS);
-        return sp.getBoolean(ShareConstants.TINKER_ENABLE_CONFIG, true);
+        return sp.getBoolean(getTinkerSharedPreferencesName(), true);
+    }
+
+    private static String getTinkerSharedPreferencesName() {
+        return ShareConstants.TINKER_ENABLE_CONFIG + ShareConstants.TINKER_VERSION;
     }
 
     public static boolean isTinkerEnabled(int flag) {
@@ -221,6 +290,9 @@ public static boolean isInMainProcess(Context context) {
 
     public static void killAllOtherProcess(Context context) {
         final ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+        if (am == null) {
+            return;
+        }
         // NOTE: getRunningAppProcess() ONLY GIVE YOU THE PROCESS OF YOUR OWN PACKAGE IN ANDROID M
         // BUT THAT'S ENOUGH HERE
         for (ActivityManager.RunningAppProcessInfo ai : am.getRunningAppProcesses()) {
@@ -325,4 +397,50 @@ private static boolean isVmArt(String versionString) {
         }
         return isArt;
     }
+
+    public static String getExceptionCauseString(final Throwable ex) {
+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        final PrintStream ps = new PrintStream(bos);
+
+        try {
+            // print directly
+            Throwable t = ex;
+            while (t.getCause() != null) {
+                t = t.getCause();
+            }
+            t.printStackTrace(ps);
+            return toVisualString(bos.toString());
+        } finally {
+            try {
+                bos.close();
+            } catch (IOException e) {
+            }
+        }
+    }
+
+    public static String toVisualString(String src) {
+        boolean cutFlg = false;
+        if (null == src) {
+            return null;
+        }
+        char[] chr = src.toCharArray();
+        if (null == chr) {
+            return null;
+        }
+        int i = 0;
+        for (; i < chr.length; i++) {
+            if (chr[i] > 127) {
+                chr[i] = 0;
+                cutFlg = true;
+                break;
+            }
+        }
+
+        if (cutFlg) {
+            return new String(chr, 0, i);
+        } else {
+            return src;
+        }
+    }
+
 }
diff --git a/tinker-build/tinker-patch-cli/build.gradle b/tinker-build/tinker-patch-cli/build.gradle
index 9b48cc3a..c1bd4e62 100644
--- a/tinker-build/tinker-patch-cli/build.gradle
+++ b/tinker-build/tinker-patch-cli/build.gradle
@@ -21,7 +21,8 @@ jar {
 }
 
 // copy the jar to work directory
-task buildSdk(type: Copy, dependsOn: [build, jar]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build, jar]) {
+    group = "tinker"
     from('build/libs') {
         include '*.jar'
         exclude '*-javadoc.jar'
@@ -33,4 +34,4 @@ task buildSdk(type: Copy, dependsOn: [build, jar]) {
     into(rootProject.file("buildSdk/build"))
 }
 
-defaultTasks 'buildSdk'
+defaultTasks 'buildTinkerSdk'
diff --git a/tinker-build/tinker-patch-cli/src/main/java/com/tencent/tinker/patch/CliMain.java b/tinker-build/tinker-patch-cli/src/main/java/com/tencent/tinker/patch/CliMain.java
index 37dbf0b1..8df97a5e 100644
--- a/tinker-build/tinker-patch-cli/src/main/java/com/tencent/tinker/patch/CliMain.java
+++ b/tinker-build/tinker-patch-cli/src/main/java/com/tencent/tinker/patch/CliMain.java
@@ -92,6 +92,9 @@ private void run(String[] args) {
             if (oldApkFile == null || newApkFile == null) {
                 Logger.e("Missing old apk or new apk file argument");
                 goToError();
+            } else if (!oldApkFile.exists() || !newApkFile.exists()) {
+                Logger.e("Old apk or new apk file does not exist");
+                goToError();
             }
 
             if (outputFile == null) {
diff --git a/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py b/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py
new file mode 100644
index 00000000..3dc8577a
--- /dev/null
+++ b/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py
@@ -0,0 +1,165 @@
+#!/usr/bin/python
+# coding: utf-8
+"""
+aplymapping
+    1.keepkeep
+    2.keepkeep
+proguardwarning
+(http://proguard.sourceforge.net/manual/troubleshooting.html#mappingconflict1)
+mapping
+
+
+mappingmapping1mappingmapping2
+mapping2mapping
+mapping2mapping1mapping3mapping3
+mapping3mappingmapping3
+
+mappingmapping
+keepmappingproguard
+so  mappingmapping
+
+mappingapplymappingmappingmapping 
+"""
+import os
+import sys
+
+
+def print_usage():
+    print >>sys.stderr, \
+        """usage: python merge_mapping.py old_mapping.txt current_mapping.txt
+           the output mapping file is 'new_mapping.txt' in the cwd directory
+        """
+    sys.exit(1)
+
+
+class MappingData:
+    def __init__(self):
+        self.raw_line = ""
+        self.key = ""
+        self.field_methods = []
+
+
+class DealWithProguardWarning:
+    def __init__(self):
+        self.classes = {}
+        self.class_list = []
+        self.current_classes = {}
+        self.current_class_list = []
+
+    @staticmethod
+    def read_mapping_file(classes, class_list, mapping):
+        current_mapping_data = None
+        with open(mapping, 'r') as fd:
+            # 
+            for line in fd.xreadlines():
+                # 
+                if not line.startswith(' '):
+                    # 
+                    if current_mapping_data is not None:
+                        classes[current_mapping_data.key] = current_mapping_data
+                        class_list.append(current_mapping_data.key)
+                    # 
+                    current_mapping_data = MappingData()
+                    current_mapping_data.raw_line = line
+                    current_mapping_data.key = line.split('->')[0].strip()
+                else:
+                    # 
+                    current_mapping_data.field_methods.append(line)
+            classes[current_mapping_data.key] = current_mapping_data
+            class_list.append(current_mapping_data.key)
+        print "size: ", len(classes)
+
+    def remove_warning_mapping(self, old_mapping, current_mapping):
+        self.read_mapping_file(self.classes, self.class_list, old_mapping)
+        self.read_mapping_file(self.current_classes, self.current_class_list, current_mapping)
+        self.do_merge()
+        self.print_new_mapping()
+
+    def exe(self, args):
+        if len(args) < 2:
+            print_usage()
+
+        old_mapping_path = args[0]
+        if not os.path.exists(old_mapping_path):
+            raise Exception("mapping file is not exist, path=%s", old_mapping_path)
+
+        current_mapping_path = args[1]
+        if not os.path.exists(current_mapping_path):
+            raise Exception("proguard warning file is not exist, path=%s", current_mapping_path)
+
+        self.remove_warning_mapping(old_mapping_path, current_mapping_path)
+
+    def do_merge(self):
+        # mapping class_key
+        for key in self.current_class_list:
+            if key in self.classes:
+                data = self.classes[key]
+                current_data = self.current_classes[key]
+                # mapping
+                # ___.___ -> ___.___:
+                if current_data.raw_line.split("->")[0] == current_data.raw_line.split("->")[1][:-1]:
+                    current_data.raw_line = data.raw_line
+                new_method_list = []
+                # 
+                for line in current_data.filed_methods:
+                    result, new_line = self.find_same_methods(line, data)
+                    # 
+                    if result:
+                        new_method_list.append(new_line)
+                current_data.filed_methods = new_method_list
+            # 
+            else:
+                del self.current_classes[key]
+
+    def find_same_methods(self, line, data):
+        search_name, search_complete_name, search_new_name = self.get_name_and_complete_name_and_new_name(line)
+        # mappingmapping
+        if search_name == search_new_name:
+            return False, ""
+        for method_line in data.filed_methods:
+            target_name, target_complete_name, target_new_name = self.get_name_and_complete_name_and_new_name(method_line)
+            # 
+            if search_complete_name == target_complete_name:
+                print "1"
+                return True, method_line
+            print "0"
+        return False, ""
+
+    #    
+    @staticmethod
+    def get_name_and_complete_name_and_new_name(line):
+        """ ___ ___ -> ___
+            ___:___:___ ___(___) -> ___
+            ___:___:___ ___(___):___ -> ___
+            ___:___:___ ___(___):___:___ -> ___
+        """
+        no_space_line = line.strip()
+        colonIndex1 = no_space_line.find(":")
+        colonIndex2 = no_space_line.find(":", colonIndex1+1) if colonIndex1 != -1 else -1
+        spaceIndex = no_space_line.find(" ", colonIndex2+2)
+        argumentIndex1 = no_space_line.find("(", spaceIndex+1)
+        argumentIndex2 = no_space_line.find(")", argumentIndex1+1) if argumentIndex1 != -1 else -1
+        colonIndex3 = no_space_line.find(":", argumentIndex2+1) if argumentIndex2 != -1 else -1
+        colonIndex4 = no_space_line.find(":", colonIndex3+1) if colonIndex3 != -1 else -1
+        arrowIndex = no_space_line.find("->")
+
+        if spaceIndex < 0 or arrowIndex < 0:
+            raise Exception("can not parse line %s", no_space_line)
+        name = no_space_line[spaceIndex + 1: argumentIndex1 if argumentIndex1 >= 0 else arrowIndex].strip()
+        new_name = no_space_line[arrowIndex + 2:].strip()
+        complete_name = no_space_line[colonIndex2 + 1:arrowIndex].strip()
+        return name, complete_name,  new_name
+
+    def print_new_mapping(self):
+        output_path = os.path.join(os.getcwd(), "new_mapping.txt")
+        with open(output_path, "w") as fw:
+            for key in self.current_class_list:
+                if key in self.current_classes:
+                    data = self.current_classes[key]
+                    fw.write(data.raw_line)
+                    for line in data.filed_methods:
+                        fw.write(line)
+
+
+if __name__ == '__main__':
+    DealWithProguardWarning().exe(sys.argv[1:])
diff --git a/tinker-build/tinker-patch-cli/tool_output/proguard_warning.py b/tinker-build/tinker-patch-cli/tool_output/proguard_warning.py
new file mode 100755
index 00000000..a9cb7681
--- /dev/null
+++ b/tinker-build/tinker-patch-cli/tool_output/proguard_warning.py
@@ -0,0 +1,109 @@
+#!/usr/bin/python
+# coding: utf8
+
+import os
+import sys
+
+
+def print_usage():
+    print >>sys.stderr, \
+        """usage: python proguard_warning.py mapping.txt warning.txt
+
+           the output mapping file is 'mapping_edit.txt' in the cwd directory
+        """
+    sys.exit(1)
+
+class MappingData:
+    raw_line = ""
+    key = ""
+    filed_methods = []
+
+    def __init__(self):
+        self.raw_line = ""
+        self.key = ""
+        self.filed_methods = []
+
+class RemoveProguardWarning:
+    def __init__(self):
+        self.classes = {}
+        self.class_list = []
+
+    def read_mapping_file(self, mapping):
+        current_mapping_data = None
+        with open(mapping) as fd:
+            for line in fd.readlines():
+                if not line.startswith(' '):
+                    if current_mapping_data is not None:
+                        self.classes[current_mapping_data.key] = current_mapping_data
+                        self.class_list.append(current_mapping_data.key)
+
+                    current_mapping_data = MappingData()
+                    current_mapping_data.raw_line = line
+                    current_mapping_data.key = line.split('->')[0].strip()
+                else:
+                    current_mapping_data.filed_methods.append(line)
+
+            self.classes[current_mapping_data.key] = current_mapping_data
+            self.class_list.append(current_mapping_data.key)
+
+        # print "size: ", len(self.classes)
+
+    def remove_warning(self, warning):
+        with open(warning) as fd:
+            for line in fd.readlines():
+                if not line.startswith("Warning:"):
+                    raise Exception("proguard warning must begin with 'Warning:', line=", line)
+                splits = line.split(':')
+                class_key = splits[1].strip()
+                # print "class_key", class_key
+                if class_key not in self.classes:
+                    print "Warning:can't find warning class in the mapping file, class=", class_key
+                    continue
+                warning_value = splits[2].split("'")[1] + " -> " + splits[2].split("'")[5]
+                mapping_data = self.classes[class_key]
+                # print "warning_value", warning_value
+
+                find = False
+                for mappings in mapping_data.filed_methods:
+                    if mappings.find(warning_value) != -1:
+                        mapping_data.filed_methods.remove(mappings)
+                        find = True
+                        break
+
+                if not find:
+                    print "Warning: can't find warning field or method in the mapping file:', value=", warning_value
+
+                if len(mapping_data.filed_methods) == 0:
+                    del self.classes[class_key]
+
+        output_path = os.path.join(os.getcwd(), "mapping_edit.txt")
+        with open(output_path, "w") as fw:
+            for key in self.class_list:
+                if key in self.classes:
+                    data = self.classes[key]
+                    fw.write(data.raw_line)
+                    for line in data.filed_methods:
+                        fw.write(line)
+
+    def remove_warning_mapping(self, mapping, warning):
+        self.read_mapping_file(mapping)
+        self.remove_warning(warning)
+
+    def do_command(self, args):
+        if (len(args) < 2):
+            print_usage()
+
+        mapping_path = args[0]
+        if not os.path.exists(mapping_path):
+            raise Exception("mapping file is not exist, path=%s", mapping_path)
+
+        warning_patch = args[1]
+        if not os.path.exists(warning_patch):
+            raise Exception("proguard warning file is not exist, path=%s", warning_patch)
+
+        self.remove_warning_mapping(mapping_path, warning_patch)
+
+
+
+if __name__ == '__main__':
+    RemoveProguardWarning().do_command(sys.argv[1:])
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
index f62489f0..de0c6c99 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
@@ -82,6 +82,12 @@
         <!--or TinkerLoadResult.getPackageConfigByName-->
         <!--you must add TINKER_ID with the old apk manifest's meta TINKER_ID value-->
         <!--other config files (such as patchMessage below)is not necessary-->
+
+        <!--For sample project or any projects that copy SamplePatchListener directory,-->
+        <!--platform config field is necessary, or an error code ERROR_PATCH_CONDITION_NOT_SATISFIED(-10)-->
+        <!--will be thrown.-->
+        <configField name="platform" value="all"/>
+
         <configField name="patchMessage" value="classes.dex"/>
     </issue>
 
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro b/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro
index af70fdb0..263db733 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro
@@ -6,7 +6,7 @@
     *;
 }
 
--keep public class * extends com.tencent.tinker.loader.app.TinkerApplication {
+-keep public class * extends android.app.Application {
     *;
 }
 
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro b/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
index 23c74455..e4ef8030 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
@@ -26,6 +26,6 @@
 }
 
 #your dex.loader pattern here
--keep class com.tencent.tinker.loader.*
+-keep class com.tencent.tinker.loader.**
 -keep class tinker.sample.android.app.SampleApplication
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/build.gradle b/tinker-build/tinker-patch-gradle-plugin/build.gradle
index d07a0497..fa4fb4e2 100644
--- a/tinker-build/tinker-patch-gradle-plugin/build.gradle
+++ b/tinker-build/tinker-patch-gradle-plugin/build.gradle
@@ -10,6 +10,7 @@ dependencies {
 //    compile fileTree(dir: 'libs', include: ['*.jar'])
     compile project(':tinker-build:tinker-patch-lib')
     compile 'com.google.gradle:osdetector-gradle-plugin:1.2.1'
+    compile 'com.android.tools.build:gradle:2.1.0'
 }
 
 repositories {
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
index fe44cea2..9fe162e9 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
@@ -16,23 +16,14 @@
 
 package com.tencent.tinker.build.gradle
 
-import com.tencent.tinker.build.gradle.extension.TinkerBuildConfigExtension
-import com.tencent.tinker.build.gradle.extension.TinkerDexExtension
-import com.tencent.tinker.build.gradle.extension.TinkerLibExtension
-import com.tencent.tinker.build.gradle.extension.TinkerPackageConfigExtension
-import com.tencent.tinker.build.gradle.extension.TinkerPatchExtension
-import com.tencent.tinker.build.gradle.extension.TinkerResourceExtension
-import com.tencent.tinker.build.gradle.extension.TinkerSevenZipExtension
-import com.tencent.tinker.build.gradle.task.TinkerManifestTask
-import com.tencent.tinker.build.gradle.task.TinkerMultidexConfigTask
-import com.tencent.tinker.build.gradle.task.TinkerPatchSchemaTask
-import com.tencent.tinker.build.gradle.task.TinkerProguardConfigTask
-import com.tencent.tinker.build.gradle.task.TinkerResourceIdTask
+import com.tencent.tinker.build.gradle.extension.*
+import com.tencent.tinker.build.gradle.task.*
 import com.tencent.tinker.build.util.FileOperation
 import com.tencent.tinker.build.util.TypedValue
 import org.gradle.api.GradleException
 import org.gradle.api.Plugin
 import org.gradle.api.Project
+import org.gradle.api.Task
 
 /**
  * Registers the plugin's tasks.
@@ -45,7 +36,12 @@ class TinkerPatchPlugin implements Plugin<Project> {
 
     @Override
     public void apply(Project project) {
-        project.apply plugin: 'osdetector'
+        //osdetector change its plugin name in 1.4.0
+        try {
+            project.apply plugin: 'osdetector'
+        } catch (Throwable e) {
+            project.apply plugin: 'com.google.osdetector'
+        }
 
         project.extensions.create('tinkerPatch', TinkerPatchExtension)
 
@@ -57,23 +53,38 @@ class TinkerPatchPlugin implements Plugin<Project> {
         project.tinkerPatch.extensions.create('packageConfig', TinkerPackageConfigExtension, project)
         project.tinkerPatch.extensions.create('sevenZip', TinkerSevenZipExtension, project)
 
-        def configuration = project.tinkerPatch
+        if (!project.plugins.hasPlugin('com.android.application')) {
+            throw new GradleException('generateTinkerApk: Android Application plugin required')
+        }
 
         project.afterEvaluate {
-            if (!project.plugins.hasPlugin('com.android.application')) {
-                throw new GradleException('generateTinkerApk: Android Application plugin required')
+            def configuration = project.tinkerPatch
+
+            if (!configuration.tinkerEnable) {
+                project.logger.error("tinker tasks are disabled.")
+                return
             }
 
             def android = project.extensions.android
-            //add the tinker anno resource to the package exclude option
-            android.packagingOptions.exclude("META-INF/services/javax.annotation.processing.Processor")
-            android.packagingOptions.exclude("TinkerAnnoApplication.tmpl")
+
             //open jumboMode
             android.dexOptions.jumboMode = true
 
+            //close preDexLibraries
+            try {
+                android.dexOptions.preDexLibraries = false
+            } catch (Throwable e) {
+                //no preDexLibraries field, just continue
+            }
+
             project.logger.error("----------------------tinker build warning ------------------------------------")
+            project.logger.error("tinker auto operation: ")
+            project.logger.error("excluding annotation processor and source template from app packaging. Enable dx jumboMode to reduce package size.")
+            project.logger.error("enable dx jumboMode to reduce package size.")
+            project.logger.error("disable preDexLibraries to prevent ClassDefNotFoundException when your app is booting.")
+            project.logger.error("")
             project.logger.error("tinker will change your build configs:")
-            project.logger.error("we will add TINDER_ID=${configuration.buildConfig.tinkerId} in your build output manifest file build/intermediates/manifests/full/*")
+            project.logger.error("we will add TINKER_ID=${configuration.buildConfig.tinkerId} in your build output manifest file build/intermediates/manifests/full/*")
             project.logger.error("")
             project.logger.error("if minifyEnabled is true")
 
@@ -88,7 +99,7 @@ class TinkerPatchPlugin implements Plugin<Project> {
             project.logger.error("")
             project.logger.error("if multiDexEnabled is true")
             project.logger.error("you will find the gen multiDexKeepProguard file at ${TinkerMultidexConfigTask.MULTIDEX_CONFIG_PATH}")
-            project.logger.error("and you should copy it to your own multiDex keep proguard file yourself.")
+            project.logger.error("and we will help you to put it in the MultiDexKeepProguardFile.")
             project.logger.error("")
             project.logger.error("if applyResourceMapping file is exist")
             String tempResourceMappingPath = configuration.buildConfig.applyResourceMapping
@@ -105,10 +116,19 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 def variantOutput = variant.outputs.first()
                 def variantName = variant.name.capitalize()
 
+                def instantRunTask = getInstantRunTask(project, variantName)
+                if (instantRunTask != null) {
+                    throw new GradleException(
+                            "Tinker does not support instant run mode, please trigger build"
+                                    + " by assemble${variantName} or disable instant run"
+                                    + " in 'File->Settings...'."
+                    )
+                }
+
                 TinkerPatchSchemaTask tinkerPatchBuildTask = project.tasks.create("tinkerPatch${variantName}", TinkerPatchSchemaTask)
                 tinkerPatchBuildTask.dependsOn variant.assemble
 
-                tinkerPatchBuildTask.signconfig = variant.apkVariantData.variantConfiguration.signingConfig
+                tinkerPatchBuildTask.signConfig = variant.apkVariantData.variantConfiguration.signingConfig
 
                 variant.outputs.each { output ->
                     tinkerPatchBuildTask.buildApkPath = output.outputFile
@@ -125,13 +145,27 @@ class TinkerPatchPlugin implements Plugin<Project> {
 
                 variantOutput.processResources.dependsOn manifestTask
 
+                //resource id
+                TinkerResourceIdTask applyResourceTask = project.tasks.create("tinkerProcess${variantName}ResourceId", TinkerResourceIdTask)
+                applyResourceTask.resDir = variantOutput.processResources.resDir
+                //let applyResourceTask run after manifestTask
+                applyResourceTask.mustRunAfter manifestTask
+
+                variantOutput.processResources.dependsOn applyResourceTask
+
                 // Add this proguard settings file to the list
                 boolean proguardEnable = variant.getBuildType().buildType.minifyEnabled
 
                 if (proguardEnable) {
                     TinkerProguardConfigTask proguardConfigTask = project.tasks.create("tinkerProcess${variantName}Proguard", TinkerProguardConfigTask)
                     proguardConfigTask.applicationVariant = variant
-                    variantOutput.packageApplication.dependsOn proguardConfigTask
+                    proguardConfigTask.mustRunAfter manifestTask
+
+                    def proguardTask = getProguardTask(project, variantName)
+                    if (proguardTask != null) {
+                        proguardTask.dependsOn proguardConfigTask
+                    }
+
                 }
 
                 // Add this multidex proguard settings file to the list
@@ -140,19 +174,44 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 if (multiDexEnabled) {
                     TinkerMultidexConfigTask multidexConfigTask = project.tasks.create("tinkerProcess${variantName}MultidexKeep", TinkerMultidexConfigTask)
                     multidexConfigTask.applicationVariant = variant
-                    variantOutput.packageApplication.dependsOn multidexConfigTask
+                    multidexConfigTask.mustRunAfter manifestTask
+
+                    def multidexTask = getMultiDexTask(project, variantName)
+                    if (multidexTask != null) {
+                        multidexTask.dependsOn multidexConfigTask
+                    }
+                    def collectMultiDexComponentsTask = getCollectMultiDexComponentsTask(project, variantName)
+                    if (collectMultiDexComponentsTask != null) {
+                        multidexConfigTask.mustRunAfter collectMultiDexComponentsTask
+                    }
+                }
+
+                if (configuration.buildConfig.keepDexApply
+                    && FileOperation.isLegalFile(project.tinkerPatch.oldApk)) {
+                    com.tencent.tinker.build.gradle.transform.ImmutableDexTransform.inject(project, variant)
                 }
-//                if (tempResourceFile != null && tempResourceFile.exists() && tempResourceFile.isFile()) {
-                    TinkerResourceIdTask applyResourceTask = project.tasks.create("tinkerProcess${variantName}ResourceId", TinkerResourceIdTask)
-                    applyResourceTask.resDir = variantOutput.processResources.resDir
-                    variantOutput.processResources.dependsOn applyResourceTask
-//                }
-//                else {
-//                    project.logger.error("apply resource mapping file ${resourceMappingFile} is not exist, just ignore")
-//                }
             }
         }
+    }
+
+    Task getMultiDexTask(Project project, String variantName) {
+        String multiDexTaskName = "transformClassesWithMultidexlistFor${variantName}"
+        return project.tasks.findByName(multiDexTaskName)
+    }
+
+    Task getProguardTask(Project project, String variantName) {
+        String proguardTaskName = "transformClassesAndResourcesWithProguardFor${variantName}"
+        return project.tasks.findByName(proguardTaskName)
+    }
+
+    Task getInstantRunTask(Project project, String variantName) {
+        String instantRunTask = "transformClassesWithInstantRunFor${variantName}"
+        return project.tasks.findByName(instantRunTask)
+    }
 
+    Task getCollectMultiDexComponentsTask(Project project, String variantName) {
+        String collectMultiDexComponents = "collect${variantName}MultiDexComponents"
+        return project.tasks.findByName(collectMultiDexComponents)
     }
 
 }
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy
index 4ad1b62e..7d109793 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy
@@ -49,12 +49,19 @@ public class TinkerBuildConfigExtension {
 
     boolean usingResourceMapping
 
+    /**
+     * if keepDexApply is true,class in which dex refer to the old apk.
+     * open this can reduce the dex diff file size.
+     */
+    boolean keepDexApply;
+
     public TinkerBuildConfigExtension(Project project) {
         this.project = project
         applyMapping = ""
         applyResourceMapping = ""
         tinkerId = null
         usingResourceMapping = false
+        keepDexApply = false
     }
 
     void checkParameter() {
@@ -68,6 +75,7 @@ public class TinkerBuildConfigExtension {
     public String toString() {
         """| applyMapping = ${applyMapping}
            | applyResourceMapping = ${applyResourceMapping}
+           | keepDexApply = ${keepDexApply}
            | tinkerId = ${tinkerId}
         """.stripMargin()
     }
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
index 2add6dc0..f600b499 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
@@ -31,6 +31,7 @@ public class TinkerDexExtension {
      * default: raw, keep the orginal file type
      */
     String dexMode;
+
     /**
      * the dex file patterns, which dex or jar files will be deal to gen patch
      * such as [classes.dex, classes-*.dex, assets/multiDex/*.jar]
@@ -42,6 +43,8 @@ public class TinkerDexExtension {
      * such as [com.tencent.tinker.loader.*, com.tinker.sample.MyApplication]
      */
     Iterable<String> loader;
+
+
     private Project project;
 
     public TinkerDexExtension(Project project) {
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPackageConfigExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPackageConfigExtension.groovy
index fbf9221a..4ed81b94 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPackageConfigExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPackageConfigExtension.groovy
@@ -16,7 +16,7 @@
 
 package com.tencent.tinker.build.gradle.extension
 
-import com.tencent.tinker.build.apkparser.AndroidManifest
+import com.tencent.tinker.build.apkparser.AndroidParser
 import org.gradle.api.GradleException
 import org.gradle.api.Project
 
@@ -32,7 +32,7 @@ public class TinkerPackageConfigExtension {
      */
     private Map<String, String> fields
     private Project project;
-    private AndroidManifest androidManifest;
+    private AndroidParser androidManifest;
 
 
     public TinkerPackageConfigExtension(project) {
@@ -57,7 +57,7 @@ public class TinkerPackageConfigExtension {
                         String.format("old apk file %s is not exist, you can set the value directly!", oldPakFile)
                 )
             }
-            androidManifest = AndroidManifest.getAndroidManifest(oldPakFile);
+            androidManifest = AndroidParser.getAndroidManifest(oldPakFile);
         }
     }
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
index 81210332..c3b86141 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
@@ -31,7 +31,7 @@ public class TinkerPatchExtension {
     String oldApk
 
     /**
-     * if there is loader class changes,
+     * If there is loader class changes,
      * or Activity, Service, Receiver, Provider change, it will terminal
      * if ignoreWarning is false
      * default: false
@@ -39,29 +39,42 @@ public class TinkerPatchExtension {
     boolean ignoreWarning
 
     /**
-     * if sign the patch file with the android signConfig
+     * If sign the patch file with the android signConfig
      * default: true
      */
     boolean useSign
 
+    /**
+     * whether use tinker
+     * default: true
+     */
+    boolean tinkerEnable
+
     public TinkerPatchExtension() {
         oldApk = ""
         ignoreWarning = false
         useSign = true
+        tinkerEnable = true
     }
 
     void checkParameter() {
         if (oldApk == null) {
             throw new GradleException("old apk is null, you must set the correct old apk value!")
-        } else if (!new File(oldApk).exists()) {
+        }
+        File apk = new File(oldApk)
+        if (!apk.exists()) {
             throw new GradleException("old apk ${oldApk} is not exist, you must set the correct old apk value!")
+        } else if (!apk.isFile()) {
+            throw new GradleException("old apk ${oldApk} is a directory, you must set the correct old apk value!")
         }
+
     }
 
     @Override
     public String toString() {
         """| oldApk = ${oldApk}
            | ignoreWarning = ${ignoreWarning}
+           | tinkerEnable = ${tinkerEnable}
            | useSign = ${useSign}
         """.stripMargin()
     }
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
index 0b60c831..2c4b19d1 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
@@ -31,6 +31,8 @@ import org.gradle.api.tasks.TaskAction
 public class TinkerManifestTask extends DefaultTask {
     static final String MANIFEST_XML = TinkerPatchPlugin.TINKER_INTERMEDIATES + "AndroidManifest.xml"
     static final String TINKER_ID = "TINKER_ID"
+    static final String TINKER_ID_PREFIX = "tinker_id_"
+
     String manifestPath
     TinkerManifestTask() {
         group = 'tinker'
@@ -43,10 +45,25 @@ public class TinkerManifestTask extends DefaultTask {
         if (tinkerValue == null || tinkerValue.isEmpty()) {
             throw new GradleException('tinkerId is not set!!!')
         }
+
+        tinkerValue = TINKER_ID_PREFIX + tinkerValue
+
         project.logger.error("tinker add ${tinkerValue} to your AndroidManifest.xml ${manifestPath}")
 
+        writeManifestMeta(manifestPath, TINKER_ID, tinkerValue)
+        addApplicationToLoaderPattern()
+        File manifestFile = new File(manifestPath)
+        if (manifestFile.exists()) {
+            FileOperation.copyFileUsingStream(manifestFile, project.file(MANIFEST_XML))
+            project.logger.error("tinker gen AndroidManifest.xml in ${MANIFEST_XML}")
+        }
+
+    }
+
+    void writeManifestMeta(String path, String name, String value) {
         def ns = new Namespace("http://schemas.android.com/apk/res/android", "android")
-        def xml = new XmlParser().parse(manifestPath)
+
+        def xml = new XmlParser().parse(new InputStreamReader(new FileInputStream(path), "utf-8"))
 
         def application = xml.application[0]
         if (application) {
@@ -54,26 +71,46 @@ public class TinkerManifestTask extends DefaultTask {
 
             // remove any old TINKER_ID elements
             def tinkerId = metaDataTags.findAll {
-                it.attributes()[ns.name].equals(TINKER_ID)
+                it.attributes()[ns.name].equals(name)
             }.each {
                 it.parent().remove(it)
             }
 
             // Add the new TINKER_ID element
-            application.appendNode('meta-data', [(ns.name): TINKER_ID, (ns.value): tinkerValue])
+            application.appendNode('meta-data', [(ns.name): name, (ns.value): value])
 
             // Write the manifest file
-            def writer = new FileWriter(manifestPath)
-            def printer = new XmlNodePrinter(new PrintWriter(writer))
+            def printer = new XmlNodePrinter(new PrintWriter(path, "utf-8"))
             printer.preserveWhitespace = true
             printer.print(xml)
         }
-        File manifestFile = new File(manifestPath)
-        if (manifestFile.exists()) {
-            FileOperation.copyFileUsingStream(manifestFile, project.file(MANIFEST_XML))
-            project.logger.error("tinker gen AndroidManifest.xml in ${MANIFEST_XML}")
+    }
+
+    void addApplicationToLoaderPattern() {
+        Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
+        String applicationName = readManifestApplicationName(manifestPath)
+
+        if (applicationName != null && !loader.contains(applicationName)) {
+            loader.add(applicationName)
+            project.logger.error("tinker add ${applicationName} to dex loader pattern")
+        }
+        String loaderClass = "com.tencent.tinker.loader.*"
+        if (!loader.contains(loaderClass)) {
+            loader.add(loaderClass)
+            project.logger.error("tinker add ${loaderClass} to dex loader pattern")
         }
 
     }
+
+    String readManifestApplicationName(String path) {
+        def xml = new XmlParser().parse(new InputStreamReader(new FileInputStream(path), "utf-8"))
+        def ns = new Namespace("http://schemas.android.com/apk/res/android", "android")
+
+        def application = xml.application[0]
+        if (application) {
+            return application.attributes()[ns.name]
+        }
+        return null
+    }
 }
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
index a7384fa7..0476e862 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
@@ -20,7 +20,6 @@ import com.tencent.tinker.build.gradle.TinkerPatchPlugin
 import org.gradle.api.DefaultTask
 import org.gradle.api.tasks.TaskAction
 
-
 /**
  * The configuration properties.
  *
@@ -37,9 +36,9 @@ public class TinkerMultidexConfigTask extends DefaultTask {
                     "    *;\n" +
                     "}\n" +
                     "\n" +
-                    "-keep public class * extends com.tencent.tinker.loader.app.TinkerApplication {\n" +
+                    "-keep public class * extends android.app.Application {\n" +
                     "    *;\n" +
-                    "}"
+                    "}\n"
 
 
     def applicationVariant
@@ -50,19 +49,19 @@ public class TinkerMultidexConfigTask extends DefaultTask {
 
     @TaskAction
     def updateTinkerProguardConfig() {
-        def file = project.file(MULTIDEX_CONFIG_PATH)
+        File file = project.file(MULTIDEX_CONFIG_PATH)
         project.logger.error("try update tinker multidex keep proguard file with ${file}")
 
         // Create the directory if it doesn't exist already
         file.getParentFile().mkdirs()
 
-        // Write our recommended proguard settings to this file
-        FileWriter fr = new FileWriter(file.path)
+        StringBuffer lines = new StringBuffer()
+        lines.append("\n")
+             .append("#tinker multidex keep patterns:\n")
+             .append(MULTIDEX_CONFIG_SETTINGS)
+             .append("\n")
+             .append("#your dex.loader patterns here\n")
 
-        fr.write(MULTIDEX_CONFIG_SETTINGS)
-        fr.write("\n")
-        //unlike proguard, if loader endwith *, we must change to **
-        fr.write("#your dex.loader patterns here\n")
         Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
         for (String pattern : loader) {
             if (pattern.endsWith("*")) {
@@ -70,12 +69,44 @@ public class TinkerMultidexConfigTask extends DefaultTask {
                     pattern += "*"
                 }
             }
-            fr.write("-keep class " + pattern + " {\n" +
+            lines.append("-keep class " + pattern + " {\n" +
                     "    *;\n" +
                     "}\n")
-            fr.write("\n")
+                    .append("\n")
+        }
+
+        // Write our recommended proguard settings to this file
+        FileWriter fr = new FileWriter(file.path)
+        try {
+            for (String line : lines) {
+                fr.write(line)
+            }
+        } finally {
+            fr.close()
+        }
+
+        File multiDexKeepProguard = null
+        try {
+            multiDexKeepProguard = applicationVariant.getVariantData().getScope().getManifestKeepListProguardFile()
+        } catch (Throwable ignore) {
+            try {
+                multiDexKeepProguard = applicationVariant.getVariantData().getScope().getManifestKeepListFile()
+            } catch (Throwable e) {
+                project.logger.error("can't find getManifestKeepListFile method, exception:${e}")
+            }
+        }
+        if (multiDexKeepProguard == null) {
+            project.logger.error("auto add multidex keep pattern fail, you can only copy ${file} to your own multiDex keep proguard file yourself.")
+            return
+        }
+        FileWriter manifestWriter = new FileWriter(multiDexKeepProguard, true)
+        try {
+            for (String line : lines) {
+                manifestWriter.write(line)
+            }
+        } finally {
+            manifestWriter.close()
         }
-        fr.close()
     }
 
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
index 4b7cc559..87d674ad 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
@@ -30,7 +30,7 @@ public class TinkerPatchSchemaTask extends DefaultTask {
     def android
     String buildApkPath
     String outputFolder
-    def signconfig
+    def signConfig
 
     public TinkerPatchSchemaTask() {
         description = 'Assemble Tinker Patch'
@@ -44,8 +44,6 @@ public class TinkerPatchSchemaTask extends DefaultTask {
 
     @TaskAction
     def tinkerPatch() {
-//        println configuration.toString()
-
         configuration.checkParameter()
         configuration.buildConfig.checkParameter()
         configuration.res.checkParameter()
@@ -54,13 +52,13 @@ public class TinkerPatchSchemaTask extends DefaultTask {
 
         InputParam.Builder builder = new InputParam.Builder()
         if (configuration.useSign) {
-            if (signconfig == null) {
-                throw new GradleException("can't the get signconfig for ${taskName} build")
+            if (signConfig == null) {
+                throw new GradleException("can't the get signConfig for this build")
             }
-            builder.setSignFile(signconfig.storeFile)
-                    .setKeypass(signconfig.keyPassword)
-                    .setStorealias(signconfig.keyAlias)
-                    .setStorepass(signconfig.storePassword)
+            builder.setSignFile(signConfig.storeFile)
+                    .setKeypass(signConfig.keyPassword)
+                    .setStorealias(signConfig.keyAlias)
+                    .setStorepass(signConfig.storePassword)
 
         }
 
@@ -68,15 +66,15 @@ public class TinkerPatchSchemaTask extends DefaultTask {
                .setNewApk(buildApkPath)
                .setOutBuilder(outputFolder)
                .setIgnoreWarning(configuration.ignoreWarning)
-               .setDexFilePattern(configuration.dex.pattern)
-               .setDexLoaderPattern(configuration.dex.loader)
+               .setDexFilePattern(new ArrayList<String>(configuration.dex.pattern))
+               .setDexLoaderPattern(new ArrayList<String>(configuration.dex.loader))
                .setDexMode(configuration.dex.dexMode)
-               .setSoFilePattern(configuration.lib.pattern)
-               .setResourceFilePattern(configuration.res.pattern)
-               .setResourceIgnoreChangePattern(configuration.res.ignoreChange)
+               .setSoFilePattern(new ArrayList<String>(configuration.lib.pattern))
+               .setResourceFilePattern(new ArrayList<String>(configuration.res.pattern))
+               .setResourceIgnoreChangePattern(new ArrayList<String>(configuration.res.ignoreChange))
                .setResourceLargeModSize(configuration.res.largeModSize)
                .setUseApplyResource(configuration.buildConfig.usingResourceMapping)
-               .setConfigFields(configuration.packageConfig.getFields())
+               .setConfigFields(new HashMap<String, String>(configuration.packageConfig.getFields()))
                .setSevenZipPath(configuration.sevenZip.path)
                .setUseSign(configuration.useSign)
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
index c0f9e0d0..e98a0935 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
@@ -86,10 +86,14 @@ public class TinkerProguardConfigTask extends DefaultTask {
         }
 
         fr.write(PROGUARD_CONFIG_SETTINGS)
+
         fr.write("#your dex.loader patterns here\n")
         //they will removed when apply
         Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
         for (String pattern : loader) {
+            if (pattern.endsWith("*") && !pattern.endsWith("**")) {
+                pattern += "*"
+            }
             fr.write("-keep class " + pattern)
             fr.write("\n")
         }
@@ -97,6 +101,7 @@ public class TinkerProguardConfigTask extends DefaultTask {
         // Add this proguard settings file to the list
         applicationVariant.getBuildType().buildType.proguardFiles(file)
         def files = applicationVariant.getBuildType().buildType.getProguardFiles()
+
         project.logger.error("now proguard files is ${files}")
     }
 }
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
index 4e51c6a0..ba6c2c75 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerResourceIdTask.groovy
@@ -23,7 +23,6 @@ import com.tencent.tinker.build.aapt.RDotTxtEntry
 import com.tencent.tinker.build.gradle.TinkerPatchPlugin
 import com.tencent.tinker.build.util.FileOperation
 import org.gradle.api.DefaultTask
-import org.gradle.api.Project
 import org.gradle.api.tasks.TaskAction
 
 /**
@@ -43,24 +42,24 @@ public class TinkerResourceIdTask extends DefaultTask {
 
     @TaskAction
     def applyResourceId() {
+        String resourceMappingFile = project.extensions.tinkerPatch.buildConfig.applyResourceMapping
+
         // Parse the public.xml and ids.xml
+        if (!FileOperation.isLegalFile(resourceMappingFile)) {
+            project.logger.error("apply resource mapping file ${resourceMappingFile} is illegal, just ignore")
+            return
+        }
         String idsXml = resDir + "/values/ids.xml";
         String publicXml = resDir + "/values/public.xml";
         FileOperation.deleteFile(idsXml);
         FileOperation.deleteFile(publicXml);
         List<String> resourceDirectoryList = new ArrayList<String>()
         resourceDirectoryList.add(resDir)
-        Map<RDotTxtEntry.RType, Set<RDotTxtEntry>> rTypeResourceMap = null
 
-        String resourceMappingFile = project.extensions.tinkerPatch.buildConfig.applyResourceMapping
+        project.logger.error("we build ${project.getName()} apk with apply resource mapping file ${resourceMappingFile}")
+        project.extensions.tinkerPatch.buildConfig.usingResourceMapping = true
+        Map<RDotTxtEntry.RType, Set<RDotTxtEntry>> rTypeResourceMap = PatchUtil.readRTxt(resourceMappingFile)
 
-        if (FileOperation.isLegalFile(resourceMappingFile)) {
-            project.logger.error("we build ${project.getName()} apk with apply resource mapping file ${resourceMappingFile}")
-            project.extensions.tinkerPatch.buildConfig.usingResourceMapping = true
-            rTypeResourceMap = PatchUtil.readRTxt(resourceMappingFile);
-        } else {
-            project.logger.error("apply resource mapping file ${resourceMappingFile} is illegal, just ignore")
-        }
         AaptResourceCollector aaptResourceCollector = AaptUtil.collectResource(resourceDirectoryList, rTypeResourceMap)
         PatchUtil.generatePublicResourceXml(aaptResourceCollector, idsXml, publicXml)
         File publicFile = new File(publicXml)
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
new file mode 100644
index 00000000..92a80fcf
--- /dev/null
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
@@ -0,0 +1,510 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.gradle.transform
+
+import com.android.annotations.NonNull
+import com.android.build.api.transform.Format
+import com.android.build.api.transform.JarInput;
+import com.android.build.api.transform.QualifiedContent
+import com.android.build.api.transform.Transform;
+import com.android.build.api.transform.TransformException
+import com.android.build.api.transform.TransformInput
+import com.android.build.api.transform.TransformInvocation
+import com.android.build.api.transform.TransformOutputProvider
+import com.android.build.gradle.internal.pipeline.TransformTask
+import com.android.build.gradle.internal.transforms.DexTransform
+import com.google.common.base.Joiner
+import com.google.common.collect.Lists
+import com.tencent.tinker.android.dex.ClassDef
+import com.tencent.tinker.android.dex.Dex
+import com.tencent.tinker.build.gradle.TinkerPatchPlugin
+import com.tencent.tinker.build.immutable.ClassSimDef
+import com.tencent.tinker.build.immutable.DexRefData
+import com.tencent.tinker.build.util.FileOperation
+import com.tencent.tinker.build.util.Utils
+import org.gradle.api.GradleException
+import org.gradle.api.Project
+import org.gradle.api.Task
+import org.gradle.api.execution.TaskExecutionGraph
+import org.gradle.api.execution.TaskExecutionGraphListener
+import org.gradle.api.logging.Logging
+
+
+import java.lang.reflect.Field;
+import java.util.zip.ZipEntry
+import java.util.zip.ZipFile
+import java.util.zip.ZipOutputStream
+
+/**
+ * Created by wangzhi on 16/11/24.
+ */
+public class ImmutableDexTransform extends Transform {
+
+    public static final String TASK_WORK_DIR = "keep_dex"
+
+    private static final Joiner PATH_JOINER = Joiner.on(File.separatorChar);
+
+    Project project
+
+    String oldApkPath
+
+    File classPreDir
+
+    File baseDexDir
+
+    File dxOutDir
+
+    File mainDexListFile
+
+    String varName
+
+    String varDirName
+
+    def variant
+
+    DexTransform dexTransform
+
+
+    ImmutableDexTransform(Project project, def variant, DexTransform dexTransform) {
+        this.dexTransform = dexTransform
+        this.project = project
+        this.variant = variant
+        this.varName = variant.name.capitalize()
+        this.varDirName = variant.getDirName()
+        this.oldApkPath = project.tinkerPatch.oldApk
+        this.mainDexListFile = dexTransform.mainDexListFile
+    }
+
+    public void initFileEnv(TransformOutputProvider outputProvider) {
+        classPreDir = getDirInWorkDir("class_pre")
+        baseDexDir = getDirInWorkDir("base_dex")
+        dxOutDir = outputProvider.getContentLocation("main",
+                getOutputTypes(), getScopes(),
+                Format.DIRECTORY);
+
+        classPreDir.mkdirs()
+        baseDexDir.mkdirs()
+        dxOutDir.mkdirs()
+
+        FileOperation.cleanDir(classPreDir)
+        FileOperation.cleanDir(baseDexDir)
+        FileOperation.cleanDir(dxOutDir)
+    }
+
+    private File getDirInWorkDir(String name) {
+        return new File(PATH_JOINER.join(project.projectDir,
+                TinkerPatchPlugin.TINKER_INTERMEDIATES,
+                TASK_WORK_DIR,
+                name,
+                varDirName)
+        )
+    }
+
+
+    @NonNull
+    @Override
+    public Set<QualifiedContent.ContentType> getOutputTypes() {
+        return dexTransform.getOutputTypes();
+    }
+
+    @NonNull
+    @Override
+    public Collection<File> getSecondaryFileInputs() {
+        return dexTransform.getSecondaryFileInputs()
+    }
+
+    @NonNull
+    @Override
+    public Collection<File> getSecondaryDirectoryOutputs() {
+        return dexTransform.getSecondaryDirectoryOutputs()
+    }
+
+    @NonNull
+    @Override
+    public Map<String, Object> getParameterInputs() {
+       return dexTransform.getParameterInputs()
+    }
+
+    @Override
+    String getName() {
+        return dexTransform.getName()
+    }
+
+    @Override
+    Set<QualifiedContent.ContentType> getInputTypes() {
+        return dexTransform.getInputTypes()
+    }
+
+    @Override
+    Set<QualifiedContent.Scope> getScopes() {
+        return dexTransform.getScopes()
+    }
+
+    @Override
+    boolean isIncremental() {
+        return dexTransform.isIncremental()
+    }
+
+    @Override
+    void transform(TransformInvocation transformInvocation) throws TransformException, IOException, InterruptedException {
+
+        // because multi dex is enable,we only process jar file.
+        List<JarInput> jarInputs = Lists.newArrayList();
+        for (TransformInput input : transformInvocation.getInputs()) {
+            jarInputs.addAll(input.getJarInputs());
+        }
+        //because the multi-dex is turned on,so the jarInput.size()==1 in theory.
+        if (jarInputs.size() != 1) {
+            project.logger.error("jar input size is ${jarInputs.size()}, expected is 1. we will skip immutable dex!")
+            dexTransform.transform(transformInvocation)
+            return
+        }
+
+        //init
+        initFileEnv(transformInvocation.getOutputProvider());
+        //get all old dex
+        ArrayList<File> oldDexList = new ArrayList<>()
+        traversal(new ZipFile(oldApkPath), { ZipEntry zipEntry, byte[] bytes ->
+            if (zipEntry.name.startsWith("classes") && zipEntry.name.endsWith(".dex")) {
+                project.logger.info("find dex: ${zipEntry.name} in old apk. ")
+                File classDxFile = new File(baseDexDir, zipEntry.name)
+                classDxFile.withDataOutputStream { output ->
+                    output.write(bytes, 0, bytes.length)
+                    output.close()
+                }
+                oldDexList.add(classDxFile)
+            }
+        })
+
+        //hashmap:classPath <==> dexName
+        HashMap<String, String> pathDexMap = new HashMap<>()
+        project.logger.info("old dex list is : ${oldDexList}.")
+
+        //hashmap:classPath<=>dexName
+        oldDexList.each { dexFile ->
+            Dex dex = new Dex(dexFile)
+            dex.classDefs().each { ClassDef classDef ->
+                String classPath = dex.typeNames().get(classDef.typeIndex)
+                if (pathDexMap.get(classPath)) {
+                    throw new GradleException("double class: ${classPath} in dex: ${dexFile.name} ")
+                }
+                pathDexMap.put(classPath, dexFile.name - ".dex")
+            }
+        }
+        //the dex start index for orphan class
+        int newDexIndex = oldDexList.size()
+        //a hashset for maindexlist
+        HashSet<String> mainDexSets = initMainDexSet(mainDexListFile)
+        project.logger.info("mainDexSets is ${mainDexSets}.")
+        //zip file name <==> ZipOutputStream
+        HashMap<String, ZipOutputStream> osMap = new HashMap<>()
+        //zip file name <==> mtd count and filed count in the zip
+        HashMap<String, DexRefData> methodAndFieldsNum = new HashMap<>()
+        //orphan class's entry <==> orphan class's bytes
+        HashMap<ZipEntry, ByteArrayOutputStream> orphanMap = new HashMap()
+
+        //all class  in allClass.jar
+        HashSet<String> allClassSet = new HashSet<>()
+        //process all-classes.jar
+        processJar(jarInputs.get(0).file, allClassSet, pathDexMap, mainDexSets, methodAndFieldsNum, osMap, orphanMap)
+
+        Iterator<Map.Entry<ZipEntry, ByteArrayOutputStream>> iterator = orphanMap.entrySet().iterator()
+        Map.Entry<ZipEntry, ByteArrayOutputStream> leaveEntry = null
+        while (iterator.hasNext()) {
+            boolean writeResult = true
+            while (writeResult && iterator.hasNext()) {
+                if (leaveEntry != null) {
+                    String newDexName = dexIndexToName(newDexIndex, "")
+                    project.logger.info("write level orphan class: ${leaveEntry.key.name} to zip: ${newDexName}")
+                    writeResult = writeClassToZip(methodAndFieldsNum, osMap, newDexName, leaveEntry.value.toByteArray(), leaveEntry.key)
+                    if (!writeResult) {
+                        throw new GradleException("add one class to a new zip failed!\n" +
+                                "\t class:" + leaveEntry.key.name + "  zip: " + newDexName)
+                    }
+                }
+                Map.Entry<ZipEntry, ByteArrayOutputStream> entry = iterator.next()
+                leaveEntry = entry
+                String newDexName = dexIndexToName(newDexIndex, "")
+                project.logger.info("write orphan class: ${entry.key.name} to zip: ${newDexName}")
+                writeResult = writeClassToZip(methodAndFieldsNum, osMap, newDexName, entry.value.toByteArray(), entry.key)
+                if (writeResult) {
+                    leaveEntry = null
+                }
+            }
+            newDexIndex++
+        }
+
+        osMap.each { key, value ->
+            value.close()
+        }
+
+        //a list for all dex's path,use for checkClassConsistence mtd
+        ArrayList<String> dexPathList = new ArrayList<>()
+        classPreDir.eachFile { classZip ->
+            String classIndexName = classZip.name - ".jar"
+            String dexPath = "${dxOutDir.absolutePath}/${classIndexName}.dex"
+            dexPathList.add(dexPath)
+            doDex(classIndexName, classZip, project.android.getDexOptions())
+        }
+
+        checkClassConsistence(dexPathList, allClassSet)
+
+    }
+
+    private void processJar(File jarFile,
+                            HashSet<String> allClassSet, HashMap<String, String> pathDexMap, HashSet<String> mainDexSets, HashMap<String, DexRefData> methodAndFieldsNum, HashMap<String, ZipOutputStream> osMap, HashMap<ZipEntry, ByteArrayOutputStream> orphanMap) {
+
+
+        ZipFile zipFile = new ZipFile(jarFile)
+        //process class in maindexlist in first
+        traversal(zipFile, { ZipEntry zipEntry, byte[] bytes ->
+            if (zipEntry.name.endsWith(".class")) {
+                if (mainDexSets.contains(zipEntry.name)) {
+                    String classPath = rePathToClassPath(zipEntry.name)
+                    allClassSet.add(classPath)
+                    project.logger.info("process main dex list's class " + classPath)
+                    if (!writeClassToZip(methodAndFieldsNum, osMap, "classes", bytes, zipEntry)) {
+                        throw new GradleException("main dex is exceed the limit! reduce the class number on your main dex keep please.")
+                    }
+                }
+            }
+        })
+
+        traversal(zipFile, {
+            ZipEntry zipEntry,
+            byte[] bytes ->
+                if (zipEntry.name.endsWith(".class")) {
+                    String classPath = rePathToClassPath(zipEntry.name)
+                    if (!Utils.isBlank(classPath) && !allClassSet.contains(classPath)) {
+                        allClassSet.add(classPath)
+                        //get the old dex name which class be located
+                        String belongDex = belongTo(pathDexMap, classPath)
+                        //the class is new or method|fields exceeds limit
+                        if (Utils.isBlank(belongDex) ||
+                                !writeClassToZip(methodAndFieldsNum, osMap, belongDex, bytes, zipEntry)) {
+                            if (Utils.isBlank(belongDex)) {
+                                project.logger.warn("find new class: " + classPath)
+                            }
+                            saveOrphan(orphanMap, zipEntry, bytes)
+                        }
+                    } else {
+                        if (Utils.isBlank(classPath)) {
+                            project.logger.error("illegal zip entry: " + zipEntry.name)
+                        }
+                    }
+
+                }
+        })
+    }
+
+    public HashSet<String> initMainDexSet(File mainDexList) {
+        HashSet<String> mainDexSets = new HashSet<>()
+        BufferedReader reader = mainDexList.newReader()
+        List<String> lines = reader.readLines()
+        lines.each {
+            mainDexSets.add(it)
+        }
+        return mainDexSets
+    }
+
+    private String rePathToClassPath(String rePath) {
+        int eIndex = rePath.lastIndexOf(".class")
+        if (eIndex >= 0) {
+            return "L${rePath.substring(0, eIndex)};"
+        } else {
+            return ""
+        }
+    }
+
+
+    private void doDex(String classIndexName, File classZip, def dexOptions) {
+        ArrayList<String> execArgs = new ArrayList()
+        def dex = "${project.android.getSdkDirectory()}/build-tools/${project.android.buildToolsVersion}/dx"
+        execArgs.add(dex.toString())
+        execArgs.add("--dex")
+        if (dexOptions.getJumboMode()) {
+            execArgs.add("--force-jumbo");
+        }
+        if (dexOptions.getIncremental()) {
+            execArgs.add("--incremental");
+            execArgs.add("--no-strict");
+        }
+        execArgs.add("--output=${dxOutDir.absolutePath}/${classIndexName}.dex".toString())
+        execArgs.add(classZip.absolutePath)
+        project.logger.info(execArgs.toString())
+        Utils.exec(execArgs, null)
+    }
+
+    public static void inject(Project project, def variant) {
+        project.logger.info("prepare inject dex transform ")
+        if (!variant.apkVariantData.variantConfiguration.isMultiDexEnabled()) {
+            project.logger.warn("multidex is diable. we will not replace the dex transform.")
+            return
+        }
+        if (!FileOperation.isLegalFile(project.tinkerPatch.oldApk)) {
+            project.logger.warn("oldApk is illegal. we will not replace the dex transform.")
+            return
+        }
+
+        project.getGradle().getTaskGraph().addTaskExecutionGraphListener(new TaskExecutionGraphListener() {
+            @Override
+            public void graphPopulated(TaskExecutionGraph taskGraph) {
+                for (Task task : taskGraph.getAllTasks()) {
+                    if (task instanceof TransformTask && task.name.toLowerCase().contains(variant.name.toLowerCase())) {
+
+                        if (((TransformTask) task).getTransform() instanceof DexTransform && !(((TransformTask) task).getTransform() instanceof ImmutableDexTransform)) {
+                            project.logger.warn("find dex transform. transform class: " + task.transform.getClass() + " . task name: " + task.name)
+
+                            DexTransform dexTransform = task.transform
+                            ImmutableDexTransform hookDexTransform = new ImmutableDexTransform(project,
+                                    variant, dexTransform)
+                            project.logger.info("variant name: " + variant.name)
+
+                            Field field = TransformTask.class.getDeclaredField("transform")
+                            field.setAccessible(true)
+                            field.set(task, hookDexTransform)
+                            project.logger.warn("transform class after hook: " + task.transform.getClass())
+                            break;
+                        }
+                    }
+                }
+            }
+        });
+
+    }
+
+
+    void checkClassConsistence(ArrayList<String> dexPathList, HashSet<String> allClassSet) {
+        project.logger.info("start check class's consistence ..")
+        if (dexPathList == null || dexPathList.size() == 0) {
+            throw new GradleException("immutable dex list is null! ")
+        }
+        project.logger.info("check dex list: " + dexPathList)
+        HashSet<String> dexClassSet = new HashSet<>()
+        int classSize = 0
+        dexPathList.each { path ->
+            File dexFile = new File(path)
+            if (dexFile.isFile()) {
+                Dex dex = new Dex(dexFile)
+                classSize += dex.classDefs().size()
+                for (ClassDef item : dex.classDefs()) {
+                    int index = item.typeIndex
+                    dexClassSet.add(dex.typeNames().get(index))
+                }
+            } else {
+                throw new GradleException("dex: ${dexFile} is illegal!")
+            }
+        }
+
+        HashSet<String> hashSet1 = new HashSet<>(dexClassSet)
+        HashSet<String> hashSet2 = new HashSet<>(allClassSet)
+
+        hashSet1.removeAll(allClassSet)
+        hashSet2.removeAll(dexClassSet)
+
+        if (hashSet1.size() != 0 || hashSet2.size() != 0) {
+            throw new GradleException("class is inconsistent! " + "\n\t"
+                    + "allClassSet size is " + allClassSet.size()
+                    + ",dexClassSet size is " + dexClassSet.size() + "\n"
+                    + "allClassSet has extra class: " + hashSet2 + ",\n"
+                    + "dexClassSet has extra class: " + hashSet1 + ".\n"
+            )
+        } else {
+            project.logger.info("check class consistence successful! ")
+        }
+
+    }
+
+    boolean writeClassToZip(HashMap<String, DexRefData> methodAndFieldsNum,
+                            HashMap<String, ZipOutputStream> osMap,
+                            String belongDex,
+                            byte[] bytes,
+                            ZipEntry zipEntry) {
+        File jarFile = new File(classPreDir, belongDex + ".jar")
+        DexRefData mfData = methodAndFieldsNum.get(jarFile.name)
+        if (mfData == null) {
+            mfData = new DexRefData()
+            methodAndFieldsNum.put(jarFile.name, mfData)
+        }
+        ClassSimDef cf = new ClassSimDef(bytes, mfData.refFields, mfData.refMtds)
+        ZipOutputStream zos = osMap.get(belongDex)
+        if (zos == null) {
+            project.logger.info("jarFile is  ${jarFile}.")
+            zos = new ZipOutputStream(new FileOutputStream(jarFile))
+            osMap.put(belongDex, zos)
+        }
+        if (!writeClassToZipNoCheck(mfData, cf, zos, zipEntry, bytes)) {
+            project.logger.error("except limit! \n \tfind class ${zipEntry.name} method num: ${mfData.methodNum},field num: ${mfData.fieldNum},belong dex: ${belongDex} ")
+            return false
+        } else {
+            return true
+        }
+    }
+
+    boolean writeClassToZipNoCheck(DexRefData mfData, ClassSimDef cf, ZipOutputStream zos, ZipEntry zipEntry, byte[] bytes) {
+        /**
+         * In ClassSimDef, only the fields  which  methods referenced or in the class definition are scanned.
+         * But in fact, some fields may be referenced in annotation. So the statistics in ClassSimDef is not complete.
+         * The threshold is adjusted lower in order to avoid the troubles to calculate the fields referred by annotations.
+         */
+        if (mfData.methodNum + cf.methodCount >= 65536 || mfData.fieldNum + cf.fieldCount >= 64536) {
+            return false
+        } else {
+            mfData.methodNum += cf.methodCount
+            mfData.fieldNum += cf.fieldCount
+            zos.putNextEntry(zipEntry)
+            zos.write(bytes)
+            zos.closeEntry()
+            return true
+        }
+    }
+
+    void saveOrphan(HashMap<ZipEntry, ByteArrayOutputStream> orphanMap, ZipEntry zipEntry, byte[] bytes) {
+        ByteArrayOutputStream bos = new ByteArrayOutputStream(bytes.length)
+        bos.write(bytes, 0, bytes.length)
+        bos.flush()
+        orphanMap.put(zipEntry, bos)
+    }
+
+    public static String getNextClassName(int index) {
+        return "classes${index + 1}.dex"
+    }
+
+    public String dexIndexToName(int index, String suffix) {
+        return "classes" + (index == 1 ? "" : index) + suffix
+    }
+
+    public String belongTo(HashMap<String, String> pathDexMap, String classPath) {
+        return pathDexMap.get(classPath)
+    }
+
+    public static void traversal(ZipFile zipFile, Closure callback) {
+        try {
+            Enumeration<? extends ZipEntry> enumeration = zipFile.entries();
+            while (enumeration.hasMoreElements()) {
+                ZipEntry entry = enumeration.nextElement();
+                callback.call(entry, zipFile.getInputStream(entry).bytes)
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            Utils.closeQuietly(zipFile);
+        }
+    }
+}
+
+
+
diff --git a/tinker-build/tinker-patch-lib/build.gradle b/tinker-build/tinker-patch-lib/build.gradle
index f0443dce..669e3811 100644
--- a/tinker-build/tinker-patch-lib/build.gradle
+++ b/tinker-build/tinker-patch-lib/build.gradle
@@ -9,8 +9,9 @@ group rootProject.ext.GROUP
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
     compile project(':tinker-commons')
-    compile group: 'net.dongliu', name: 'apk-parser', version: '2.1.2'
+    compile group: 'com.tencent.mm', name: 'apk-parser-lib', version: '1.0.0'
     compile group: 'com.google.guava', name: 'guava', version: '11.0.2'
+    compile group: 'org.ow2.asm', name: 'asm', version: '5.0.3'
 }
 
 sourceSets {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
index 97bc68c4..f4735892 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptResourceCollector.java
@@ -38,7 +38,7 @@
     private final Map<RType, Set<RDotTxtEntry>>                   rTypeResourceMap;
     private final Map<RType, Set<RDotTxtEntry>>                   rTypeIncreaseResourceMap;
     private final Map<String, Set<String>>                        duplicateResourceMap;
-    private final Map<String, String>                             sanitizeNameMap;
+    private final Map<RType, HashMap<String, String>>             sanitizeTypeMap;
     private final Set<String>                                     ignoreIdSet;
     private       int                                             currentTypeId;
 
@@ -50,7 +50,7 @@ public AaptResourceCollector() {
         this.rTypeResourceMap = new HashMap<RType, Set<RDotTxtEntry>>();
         this.rTypeIncreaseResourceMap = new HashMap<RType, Set<RDotTxtEntry>>();
         this.duplicateResourceMap = new HashMap<String, Set<String>>();
-        this.sanitizeNameMap = new HashMap<String, String>();
+        this.sanitizeTypeMap = new HashMap<RType, HashMap<String, String>>();
         this.originalResourceMap = new HashMap<RDotTxtEntry, RDotTxtEntry>();
         this.ignoreIdSet = new HashSet<String>();
         //attr type must 1
@@ -70,7 +70,7 @@ public AaptResourceCollector(Map<RType, Set<RDotTxtEntry>> rTypeResourceMap) {
                     originalResourceMap.put(rDotTxtEntry, rDotTxtEntry);
                     ResourceIdEnumerator resourceIdEnumerator = null;
                     if (!rDotTxtEntry.idType.equals(IdType.INT_ARRAY)) {
-                        int resourceId = Integer.decode(rDotTxtEntry.idValue).intValue();
+                        int resourceId = Integer.decode(rDotTxtEntry.idValue.trim()).intValue();
                         int typeId = ((resourceId & 0x00FF0000) / 0x00010000);
                         if (typeId >= currentTypeId) {
                             currentTypeId = typeId + 1;
@@ -260,9 +260,16 @@ void addRTypeResourceName(RType rType, String resourceName, String resourceValue
         }
     }
 
-    void putSanitizeName(String sanitizeName, String rawName) {
-        if (!this.sanitizeNameMap.containsKey(sanitizeName)) {
-            this.sanitizeNameMap.put(sanitizeName, rawName);
+    void putSanitizeName(RType rType, String sanitizeName, String rawName) {
+        HashMap<String, String> sanitizeNameMap;
+        if (!sanitizeTypeMap.containsKey(rType)) {
+            sanitizeNameMap = new HashMap<>();
+            sanitizeTypeMap.put(rType, sanitizeNameMap);
+        } else {
+            sanitizeNameMap = sanitizeTypeMap.get(rType);
+        }
+        if (!sanitizeNameMap.containsKey(sanitizeName)) {
+            sanitizeNameMap.put(sanitizeName, rawName);
         }
     }
 
@@ -272,8 +279,11 @@ void putSanitizeName(String sanitizeName, String rawName) {
      * @param sanitizeName
      * @return String
      */
-    public String getRawName(String sanitizeName) {
-        return this.sanitizeNameMap.get(sanitizeName);
+    public String getRawName(RType rType, String sanitizeName) {
+        if (!sanitizeTypeMap.containsKey(rType)) {
+            return null;
+        }
+        return this.sanitizeTypeMap.get(rType).get(sanitizeName);
     }
 
     /**
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
index e7172f4f..29de1521 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
@@ -78,7 +78,7 @@ public static AaptResourceCollector collectResource(List<String> resourceDirecto
         return collectResource(resourceDirectoryList, null);
     }
 
-    public static AaptResourceCollector collectResource(List<String> resourceDirectoryList, Map<RType, Set<com.tencent.tinker.build.aapt.RDotTxtEntry>> rTypeResourceMap) {
+    public static AaptResourceCollector collectResource(List<String> resourceDirectoryList, Map<RType, Set<RDotTxtEntry>> rTypeResourceMap) {
         AaptResourceCollector resourceCollector = new AaptResourceCollector(rTypeResourceMap);
         List<com.tencent.tinker.build.aapt.RDotTxtEntry> references = new ArrayList<com.tencent.tinker.build.aapt.RDotTxtEntry>();
         for (String resourceDirectory : resourceDirectoryList) {
@@ -98,15 +98,15 @@ public static AaptResourceCollector collectResource(List<String> resourceDirecto
         return resourceCollector;
     }
 
-    public static void processXmlFilesForIds(String resourceDirectory, List<com.tencent.tinker.build.aapt.RDotTxtEntry> references, AaptResourceCollector resourceCollector) throws Exception {
+    public static void processXmlFilesForIds(String resourceDirectory, List<RDotTxtEntry> references, AaptResourceCollector resourceCollector) throws Exception {
         List<String> xmlFullFilenameList = FileUtil.findMatchFile(resourceDirectory, Constant.Symbol.DOT + Constant.File.XML);
         if (xmlFullFilenameList != null) {
             for (String xmlFullFilename : xmlFullFilenameList) {
                 File xmlFile = new File(xmlFullFilename);
                 String parentFullFilename = xmlFile.getParent();
                 File parentFile = new File(parentFullFilename);
-                if (isAValuesDirectory(parentFile.getName())) {
-                    // Ignore files under values* directories.
+                if (isAValuesDirectory(parentFile.getName()) || parentFile.getName().startsWith("raw")) {
+                    // Ignore files under values* directories and raw*.
                     continue;
                 }
                 processXmlFile(xmlFullFilename, references, resourceCollector);
@@ -170,7 +170,7 @@ public static void processFileNamesInDirectory(String resourceDirectory, AaptRes
 
                 RType rType = RESOURCE_TYPES.get(directoryName);
                 resourceCollector.addIntResourceIfNotPresent(rType, resourceName);
-                com.tencent.tinker.build.aapt.ResourceDirectory resourceDirectoryBean = new com.tencent.tinker.build.aapt.ResourceDirectory(file.getParentFile().getName(), file.getAbsolutePath());
+                ResourceDirectory resourceDirectoryBean = new ResourceDirectory(file.getParentFile().getName(), file.getAbsolutePath());
                 resourceCollector.addRTypeResourceName(rType, resourceName, null, resourceDirectoryBean);
             }
         }
@@ -227,6 +227,7 @@ public static void processValuesFile(String valuesFullFilename, AaptResourceColl
                 case DIMEN:
                 case DRAWABLE:
                 case BOOL:
+                case INTEGER:
                     resourceValue = node.getTextContent().trim();
                     break;
                 case ARRAY://has sub item
@@ -243,14 +244,14 @@ public static void processValuesFile(String valuesFullFilename, AaptResourceColl
                     break;
             }
             try {
-                addToResourceCollector(resourceCollector, new com.tencent.tinker.build.aapt.ResourceDirectory(directoryName, valuesFullFilename), node, rType, resourceValue);
+                addToResourceCollector(resourceCollector, new ResourceDirectory(directoryName, valuesFullFilename), node, rType, resourceValue);
             } catch (Exception e) {
                 throw new AaptUtilException(e.getMessage() + ",Process file error:" + valuesFullFilename, e);
             }
         }
     }
 
-    public static void processXmlFile(String xmlFullFilename, List<com.tencent.tinker.build.aapt.RDotTxtEntry> references, AaptResourceCollector resourceCollector) throws IOException, XPathExpressionException {
+    public static void processXmlFile(String xmlFullFilename, List<RDotTxtEntry> references, AaptResourceCollector resourceCollector) throws IOException, XPathExpressionException {
         Document document = JavaXmlUtil.parse(xmlFullFilename);
         NodeList nodesWithIds = (NodeList) ANDROID_ID_DEFINITION.evaluate(document, XPathConstants.NODESET);
         for (int i = 0; i < nodesWithIds.getLength(); i++) {
@@ -266,7 +267,9 @@ public static void processXmlFile(String xmlFullFilename, List<com.tencent.tinke
         for (int i = 0; i < nodesUsingIds.getLength(); i++) {
             String resourceName = nodesUsingIds.item(i).getNodeValue();
             int slashPosition = resourceName.indexOf('/');
-
+            if (slashPosition < 0) {
+                continue;
+            }
             String rawRType = resourceName.substring(1, slashPosition);
             String name = resourceName.substring(slashPosition + 1);
 
@@ -281,12 +284,12 @@ public static void processXmlFile(String xmlFullFilename, List<com.tencent.tinke
 //if(!resourceCollector.isContainResource(rType, IdType.INT, sanitizeName(resourceCollector, name))){
 //throw new AaptUtilException("Not found reference '" + resourceName + "' in '" + xmlFullFilename + "'");
 //}
-            references.add(new com.tencent.tinker.build.aapt.FakeRDotTxtEntry(IdType.INT, rType, sanitizeName(resourceCollector, name)));
+            references.add(new FakeRDotTxtEntry(IdType.INT, rType, sanitizeName(rType, resourceCollector, name)));
         }
     }
 
-    private static void addToResourceCollector(AaptResourceCollector resourceCollector, com.tencent.tinker.build.aapt.ResourceDirectory resourceDirectory, Node node, RType rType, String resourceValue) {
-        String resourceName = sanitizeName(resourceCollector, extractNameAttribute(node));
+    private static void addToResourceCollector(AaptResourceCollector resourceCollector, ResourceDirectory resourceDirectory, Node node, RType rType, String resourceValue) {
+        String resourceName = sanitizeName(rType, resourceCollector, extractNameAttribute(node));
         resourceCollector.addRTypeResourceName(rType, resourceName, resourceValue, resourceDirectory);
         if (rType.equals(RType.STYLEABLE)) {
 
@@ -297,7 +300,7 @@ private static void addToResourceCollector(AaptResourceCollector resourceCollect
                 }
 
                 String rawAttrName = extractNameAttribute(attrNode);
-                String attrName = sanitizeName(resourceCollector, rawAttrName);
+                String attrName = sanitizeName(rType, resourceCollector, rawAttrName);
                 resourceCollector.addResource(RType.STYLEABLE, IdType.INT, String.format("%s_%s", resourceName, attrName), Integer.toString(count++));
 
                 if (!rawAttrName.startsWith("android:")) {
@@ -312,9 +315,9 @@ private static void addToResourceCollector(AaptResourceCollector resourceCollect
         }
     }
 
-    private static String sanitizeName(AaptResourceCollector resourceCollector, String rawName) {
+    private static String sanitizeName(RType rType, AaptResourceCollector resourceCollector, String rawName) {
         String sanitizeName = rawName.replaceAll("[.:]", "_");
-        resourceCollector.putSanitizeName(sanitizeName, rawName);
+        resourceCollector.putSanitizeName(rType, sanitizeName, rawName);
         return sanitizeName;
     }
 
@@ -350,7 +353,7 @@ private static String extractNameAttribute(Node node) {
                     if (rDotTxtEntry.idType.equals(IdType.INT)) {
                         aaptResourceCollector.addIntResourceIfNotPresent(rType, rDotTxtEntry.name);
                     } else if (rDotTxtEntry.idType.equals(IdType.INT_ARRAY)) {
-                        aaptResourceCollector.addResource(rType, rDotTxtEntry.idType, rDotTxtEntry.name, rDotTxtEntry.idValue);
+                        aaptResourceCollector.addResource(rType, rDotTxtEntry.idType, rDotTxtEntry.name, rDotTxtEntry.idValue.trim());
                     }
                 }
             }
@@ -385,7 +388,7 @@ public static void writeRJava(String outputDirectory, String packageName, Map<RT
                 for (com.tencent.tinker.build.aapt.RDotTxtEntry rDotTxtEntry : rTypeResourceMap.get(rType)) {
                     // Write out the resource.
                     // Write as an int.
-                    writer.format("    public static%s%s %s=%s;\n", isFinal ? " final " : " ", rDotTxtEntry.idType, rDotTxtEntry.name, rDotTxtEntry.idValue);
+                    writer.format("    public static%s%s %s=%s;\n", isFinal ? " final " : " ", rDotTxtEntry.idType, rDotTxtEntry.name, rDotTxtEntry.idValue.trim());
                 }
                 writer.println("  }\n");
             }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
index 87f829f2..9cd3e3af 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
@@ -20,8 +20,8 @@
 import com.tencent.tinker.build.aapt.RDotTxtEntry.RType;
 
 import java.io.BufferedReader;
+import java.io.File;
 import java.io.FileInputStream;
-import java.io.FileOutputStream;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.Arrays;
@@ -102,8 +102,8 @@ public static void generatePublicResourceXml(AaptResourceCollector aaptResourceC
         try {
             FileUtil.createFile(outputIdsXmlFullFilename);
             FileUtil.createFile(outputPublicXmlFullFilename);
-            idsWriter = new PrintWriter(new FileOutputStream(outputIdsXmlFullFilename));
-            publicWriter = new PrintWriter(new FileOutputStream(outputPublicXmlFullFilename));
+            idsWriter = new PrintWriter(new File(outputIdsXmlFullFilename), "UTF-8");
+            publicWriter = new PrintWriter(new File(outputPublicXmlFullFilename), "UTF-8");
             idsWriter.println("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
             publicWriter.println("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
             idsWriter.println("<resources>");
@@ -116,16 +116,16 @@ public static void generatePublicResourceXml(AaptResourceCollector aaptResourceC
                 if (!rType.equals(RType.STYLEABLE)) {
                     Set<RDotTxtEntry> set = entry.getValue();
                     for (RDotTxtEntry rDotTxtEntry : set) {
-                        if (rType.equals(RType.STYLE)) {
-                            String rawName = aaptResourceCollector.getRawName(rDotTxtEntry.name);
+//                        if (rType.equals(RType.STYLE)) {
+                            String rawName = aaptResourceCollector.getRawName(rType, rDotTxtEntry.name);
                             if (StringUtil.isBlank(rawName)) {
-                                System.err.println("Blank?" + rDotTxtEntry.name);
+//                                System.err.println("Blank?" + rDotTxtEntry.name);
                                 rawName = rDotTxtEntry.name;
                             }
-                            publicWriter.println("<public type=\"" + rType + "\" name=\"" + rawName + "\" id=\"" + rDotTxtEntry.idValue + "\" />");
-                        } else {
-                            publicWriter.println("<public type=\"" + rType + "\" name=\"" + rDotTxtEntry.name + "\" id=\"" + rDotTxtEntry.idValue + "\" />");
-                        }
+                            publicWriter.println("<public type=\"" + rType + "\" name=\"" + rawName + "\" id=\"" + rDotTxtEntry.idValue.trim() + "\" />");
+//                        } else {
+//                            publicWriter.println("<public type=\"" + rType + "\" name=\"" + rDotTxtEntry.name + "\" id=\"" + rDotTxtEntry.idValue + "\" />");
+//                        }
                     }
                     Set<String> ignoreIdSet = aaptResourceCollector.getIgnoreIdSet();
                     for (RDotTxtEntry rDotTxtEntry : set) {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/RDotTxtEntry.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/RDotTxtEntry.java
index 11e43aa8..e78e01b7 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/RDotTxtEntry.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/RDotTxtEntry.java
@@ -110,7 +110,7 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return Objects.toStringHelper(RDotTxtEntry.class).add("idType", idType).add("type", type).add("name", name).add("idValue", idValue).toString();
+        return Objects.toStringHelper(RDotTxtEntry.class).add("idType", idType).add("type", type).add("name", name).add("idValue", idValue.trim()).toString();
     }
 
     // Taken from http://developer.android.com/reference/android/R.html
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidManifest.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
similarity index 60%
rename from tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidManifest.java
rename to tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
index ea63940f..b417847d 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidManifest.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
@@ -16,9 +16,14 @@
 
 package com.tencent.tinker.build.apkparser;
 
+import com.tencent.tinker.build.patch.Configuration;
+
 import net.dongliu.apk.parser.ApkParser;
 import net.dongliu.apk.parser.bean.ApkMeta;
 import net.dongliu.apk.parser.exception.ParserException;
+import net.dongliu.apk.parser.struct.StringPool;
+import net.dongliu.apk.parser.struct.resource.ResourceTable;
+import net.dongliu.apk.parser.utils.ParseUtils;
 
 import org.w3c.dom.Document;
 import org.w3c.dom.NamedNodeMap;
@@ -27,7 +32,9 @@
 
 import java.io.ByteArrayInputStream;
 import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
+import java.nio.ByteBuffer;
 import java.text.ParseException;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -39,7 +46,7 @@
 /**
  * Created by zhangshaowen on 16/5/5.
  */
-public class AndroidManifest {
+public class AndroidParser {
     public static final int TYPE_SERVICE            = 1;
     public static final int TYPE_ACTIVITY           = 2;
     public static final int TYPE_BROADCAST_RECEIVER = 3;
@@ -55,15 +62,79 @@
     public final HashMap<String, String> metaDatas = new HashMap<>();
 
 
-    public AndroidManifest(ApkMeta apkMeta, String xml) throws ParserException {
+    public AndroidParser(ApkMeta apkMeta, String xml) throws ParserException {
         this.apkMeta = apkMeta;
         this.xml = xml;
         parse();
     }
 
-    public static AndroidManifest getAndroidManifest(File file) throws IOException, ParseException {
+    public static boolean resourceTableLogicalChange(Configuration config) throws IOException {
+        ApkParser parser = new ApkParser(config.mOldApkFile);
+        ApkParser newParser = new ApkParser(config.mNewApkFile);
+        parser.parseResourceTable();
+        newParser.parseResourceTable();
+        return parser.getResourceTable().equals(newParser.getResourceTable());
+    }
+
+    public static void editResourceTableString(String from, String to, File originFile, File destFile) throws IOException {
+        if (from == null || to == null) {
+            return;
+        }
+        if (!originFile.exists()) {
+            throw new RuntimeException("origin resources.arsc is not exist, path:" + originFile.getPath());
+        }
+
+        if (from.length() != to.length()) {
+            throw new RuntimeException("only support the same string length now!");
+        }
+        ApkParser parser = new ApkParser();
+        parser.parseResourceTable(originFile);
+        ResourceTable resourceTable = parser.getResourceTable();
+        StringPool stringPool = resourceTable.getStringPool();
+        ByteBuffer buffer = resourceTable.getBuffers();
+        byte[] array = buffer.array();
+        int length = stringPool.getPool().length;
+        boolean found = false;
+        for (int i = 0; i < length; i++) {
+            String value = stringPool.get(i);
+            if (value.equals(from)) {
+                found = true;
+                long offset = stringPool.getPoolOffsets().get(i);
+                //length
+                offset += 2;
+                byte[] tempByte;
+                if (stringPool.isUtf8()) {
+                    tempByte = to.getBytes(ParseUtils.charsetUTF8);
+                    if (to.length() != tempByte.length) {
+                        throw new RuntimeException(String.format(
+                            "editResourceTableString length is different, name %d, tempByte %d\n", to.length(), tempByte.length));
+                    }
+                } else {
+                    tempByte = to.getBytes(ParseUtils.charsetUTF16);
+                    if ((to.length() * 2) != tempByte.length) {
+                        throw new RuntimeException(String.format(
+                            "editResourceTableString length is different, name %d, tempByte %d\n", to.length(), tempByte.length));
+                    }
+                }
+                System.arraycopy(tempByte, 0, array, (int) offset, tempByte.length);
+            }
+        }
+        if (!found) {
+            throw new RuntimeException("can't found string:" + from + " in the resources.arsc file's string pool!");
+        }
+
+        //write array to file
+        FileOutputStream fileOutputStream = new FileOutputStream(destFile);
+        try {
+            fileOutputStream.write(array);
+        } finally {
+            fileOutputStream.close();
+        }
+    }
+
+    public static AndroidParser getAndroidManifest(File file) throws IOException, ParseException {
         ApkParser apkParser = new ApkParser(file);
-        AndroidManifest androidManifest = new AndroidManifest(apkParser.getApkMeta(), apkParser.getManifestXml());
+        AndroidParser androidManifest = new AndroidParser(apkParser.getApkMeta(), apkParser.getManifestXml());
         return androidManifest;
     }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
index df530e96..7b2e0d3e 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
@@ -23,7 +23,11 @@
 import com.tencent.tinker.build.util.TypedValue;
 
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.IOException;
+import java.security.Key;
+import java.security.KeyStore;
+import java.util.ArrayList;
 
 /**
  * @author zhangshaowen
@@ -44,7 +48,7 @@ public PatchBuilder(Configuration config) {
         this.sevenZipOutPutDir = new File(config.mOutFolder, TypedValue.OUT_7ZIP_FILE_PATH);
     }
 
-    public void buildPatch() throws IOException, InterruptedException {
+    public void buildPatch() throws Exception {
         final File resultDir = config.mTempResultDir;
         if (!resultDir.exists()) {
             throw new IOException(String.format(
@@ -54,7 +58,7 @@ public void buildPatch() throws IOException, InterruptedException {
         if (resultDir.listFiles().length == 0) {
             return;
         }
-        generalUnsignedApk(unSignedApk);
+        generateUnsignedApk(unSignedApk);
         signApk(unSignedApk, signedApk);
 
         use7zApk(signedApk, signedWith7ZipApk, sevenZipOutPutDir);
@@ -79,32 +83,65 @@ public void buildPatch() throws IOException, InterruptedException {
 
     }
 
+    private String getSignatureAlgorithm() throws Exception {
+        FileInputStream fileIn = new FileInputStream(config.mSignatureFile);
+        KeyStore keyStore = KeyStore.getInstance("JKS");
+        keyStore.load(fileIn, config.mStorePass.toCharArray());
+        Key key = keyStore.getKey(config.mStoreAlias, config.mKeyPass.toCharArray());
+        String keyAlgorithm = key.getAlgorithm();
+        String signatureAlgorithm;
+        if (keyAlgorithm.equalsIgnoreCase("DSA")) {
+            signatureAlgorithm = "SHA1withDSA";
+        } else if (keyAlgorithm.equalsIgnoreCase("RSA")) {
+            signatureAlgorithm = "SHA1withRSA";
+        } else if (keyAlgorithm.equalsIgnoreCase("EC")) {
+            signatureAlgorithm = "SHA1withECDSA";
+        } else {
+            throw new RuntimeException("private key is not a DSA or "
+                    + "RSA key");
+        }
+        return signatureAlgorithm;
+    }
+
     /**
      * @param input  unsigned file input
      * @param output signed file output
      * @throws IOException
      * @throws InterruptedException
      */
-    private void signApk(File input, File output) throws IOException, InterruptedException {
+    private void signApk(File input, File output) throws Exception {
         //sign apk
         if (config.mUseSignAPk) {
             Logger.d("Signing apk: %s", output.getName());
+            String signatureAlgorithm = getSignatureAlgorithm();
+            Logger.d("Signing key algorithm is %s", signatureAlgorithm);
+
             if (output.exists()) {
                 output.delete();
             }
-            String cmd = "jarsigner -sigalg MD5withRSA -digestalg SHA1 -keystore " + config.mSignatureFile
-                + " -storepass " + config.mStorePass
-                + " -keypass " + config.mKeyPass
-                + " -signedjar " + output.getAbsolutePath()
-                + " " + input.getAbsolutePath()
-                + " " + config.mStoreAlias;
-            Process pro = Runtime.getRuntime().exec(cmd);
-            //destroy the stream
-            pro.waitFor();
-            pro.destroy();
-
+            ArrayList<String> command = new ArrayList<>();
+            command.add("jarsigner");
+            // issue https://github.com/Tencent/tinker/issues/118
+            command.add("-sigalg");
+            command.add(signatureAlgorithm);
+            command.add("-digestalg");
+            command.add("SHA1");
+            command.add("-keystore");
+            command.add(config.mSignatureFile.getAbsolutePath());
+            command.add("-storepass");
+            command.add(config.mStorePass);
+            command.add("-keypass");
+            command.add(config.mKeyPass);
+            command.add("-signedjar");
+            command.add(output.getAbsolutePath());
+            command.add(input.getAbsolutePath());
+            command.add(config.mStoreAlias);
+
+            Process process = new ProcessBuilder(command).start();
+            process.waitFor();
+            process.destroy();
             if (!output.exists()) {
-                throw new IOException("Can't Generate signed APK. Please check your sign info is correct.");
+                throw new IOException("Can't Generate signed APK. Please check if your sign info is correct.");
             }
         }
     }
@@ -113,8 +150,8 @@ private void signApk(File input, File output) throws IOException, InterruptedExc
      * @param output unsigned apk file output
      * @throws IOException
      */
-    private void generalUnsignedApk(File output) throws IOException {
-        Logger.d("General unsigned apk: %s", output.getName());
+    private void generateUnsignedApk(File output) throws IOException {
+        Logger.d("Generate unsigned apk: %s", output.getName());
         final File tempOutDir = config.mTempResultDir;
         if (!tempOutDir.exists()) {
             throw new IOException(String.format(
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java
index 679f3e2f..d099a697 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java
@@ -116,7 +116,7 @@ public boolean patch(File oldFile, File newFile) throws Exception {
         for (File duplicateRes : resDuplicateFiles) {
 //            resPatchDecoder.patch(duplicateRes, null);
             Logger.e("Warning: res file %s is also match at dex or library pattern, "
-                + "we treat it as unchanged in the new resource_out.zip", getRelativeStringByOldDir(duplicateRes));
+                + "we treat it as unchanged in the new resource_out.zip", getRelativePathStringToOldFile(duplicateRes));
         }
 
         soPatchDecoder.onAllPatchesEnd();
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BaseDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BaseDecoder.java
index d6550847..8ea4eb5e 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BaseDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BaseDecoder.java
@@ -58,20 +58,16 @@ public Path getOutputPath(File file) {
         return config.mTempResultDir.toPath().resolve(getRelativePath(file));
     }
 
-    public String getRelativeString(File file) {
-        return config.mTempUnzipNewDir.toPath().relativize(file.toPath()).toString().replace("\\", "/");
+    public String getRelativePathStringToOldFile(File oldFile) {
+        return config.mTempUnzipOldDir.toPath().relativize(oldFile.toPath()).toString().replace("\\", "/");
     }
 
-    public String getParentRelativeString(File file) {
-        return config.mTempUnzipNewDir.toPath().relativize(file.getParentFile().toPath()).toString().replace("\\", "/");
+    public String getRelativePathStringToNewFile(File newFile) {
+        return config.mTempUnzipNewDir.toPath().relativize(newFile.toPath()).toString().replace("\\", "/");
     }
 
-    public String getRelativeStringByOldDir(File file) {
-        return config.mTempUnzipOldDir.toPath().relativize(file.toPath()).toString().replace("\\", "/");
-    }
-
-    public String getParentRelativeStringByOldDir(File file) {
-        return config.mTempUnzipOldDir.toPath().relativize(file.getParentFile().toPath()).toString().replace("\\", "/");
+    public String getParentRelativePathStringToNewFile(File newFile) {
+        return config.mTempUnzipNewDir.toPath().relativize(newFile.getParentFile().toPath()).toString().replace("\\", "/");
     }
 
     /**
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BsDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BsDiffDecoder.java
index 48e27930..a46b0d8b 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BsDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BsDiffDecoder.java
@@ -118,8 +118,8 @@ protected void writeLogFiles(File newFile, File oldFile, File bsDiff, String new
         if (metaWriter == null && logWriter == null) {
             return;
         }
-        String parentRelative = getParentRelativeString(newFile);
-        String relative = getRelativeString(newFile);
+        String parentRelative = getParentRelativePathStringToNewFile(newFile);
+        String relative = getRelativePathStringToNewFile(newFile);
 
         if (metaWriter != null) {
             String fileName = newFile.getName();
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
index c96a4830..77d4e980 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
@@ -20,14 +20,11 @@
 import com.tencent.tinker.android.dex.ClassDef;
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.DexFormat;
-import com.tencent.tinker.android.dx.util.Hex;
 import com.tencent.tinker.build.dexpatcher.DexPatchGenerator;
-import com.tencent.tinker.build.dexpatcher.util.SmallDexPatchGenerator;
 import com.tencent.tinker.build.info.InfoWriter;
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.build.util.DexClassesComparator;
 import com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
-import com.tencent.tinker.build.util.DexClassesComparator.DexGroup;
 import com.tencent.tinker.build.util.ExcludedClassModifiedChecker;
 import com.tencent.tinker.build.util.FileOperation;
 import com.tencent.tinker.build.util.Logger;
@@ -37,7 +34,6 @@
 import com.tencent.tinker.build.util.Utils;
 import com.tencent.tinker.commons.dexpatcher.DexPatchApplier;
 import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger.IDexPatcherLogger;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
 
 import java.io.File;
 import java.io.IOException;
@@ -56,7 +52,8 @@
  * Created by zhangshaowen on 2016/3/23.
  */
 public class DexDiffDecoder extends BaseDecoder {
-    private static final String TEST_DEX_PATH = "test.dex";
+    private static final String TEST_DEX_NAME = "test.dex";
+
     private final InfoWriter logWriter;
     private final InfoWriter metaWriter;
 
@@ -105,13 +102,21 @@ public void onAllPatchesStart() throws IOException, TinkerPatchException {
 
     }
 
+    /**
+     * Provide /oldFileRoot/dir/to/oldDex, /newFileRoot/dir/to/newDex,
+     * return dir/to/oldDex or dir/to/newDex if any one is not null.
+     */
+    protected String getRelativeDexName(File oldDexFile, File newDexFile) {
+        return oldDexFile != null ? getRelativePathStringToOldFile(oldDexFile) : getRelativePathStringToNewFile(newDexFile);
+    }
+
     @SuppressWarnings("NewApi")
     @Override
     public boolean patch(final File oldFile, final File newFile) throws IOException, TinkerPatchException {
+        final String dexName = getRelativeDexName(oldFile, newFile);
+
         // first of all, we should check input files if excluded classes were modified.
-        Logger.d("Check for loader classes in dex: %s",
-            (oldFile == null ? getRelativeString(newFile) : getRelativeString(oldFile))
-        );
+        Logger.d("Check for loader classes in dex: %s", dexName);
 
         try {
             excludedClassModifiedChecker.checkIfExcludedClassWasModifiedInNewDex(oldFile, newFile);
@@ -136,20 +141,22 @@ public boolean patch(final File oldFile, final File newFile) throws IOException,
 
         File dexDiffOut = getOutputPath(newFile).toFile();
 
-        final String newMd5 = MD5.getMD5(newFile);
+        final String newMd5 = getRawOrWrappedDexMD5(newFile);
 
         //new add file
         if (oldFile == null || !oldFile.exists() || oldFile.length() == 0) {
             hasDexChanged = true;
-            copyNewDexAndMarkInMeta(newFile, newMd5, dexDiffOut);
+            copyNewDexAndLogToDexMeta(newFile, newMd5, dexDiffOut);
             return true;
         }
 
-        final String oldMd5 = MD5.getMD5(oldFile);
+        final String oldMd5 = getRawOrWrappedDexMD5(oldFile);
 
-        if (!oldMd5.equals(newMd5)) {
+        if ((oldMd5 != null && !oldMd5.equals(newMd5)) || (oldMd5 == null && newMd5 != null)) {
             hasDexChanged = true;
-            checkAddedOrDeletedClasses(oldFile, newFile);
+            if (oldMd5 != null) {
+                collectAddedOrDeletedClasses(oldFile, newFile);
+            }
         }
 
         RelatedInfo relatedInfo = new RelatedInfo();
@@ -159,13 +166,11 @@ public boolean patch(final File oldFile, final File newFile) throws IOException,
         // collect current old dex file and corresponding new dex file for further processing.
         oldAndNewDexFilePairList.add(new AbstractMap.SimpleEntry<>(oldFile, newFile));
 
-        final String dexName = oldFile.getName();
         dexNameToRelatedInfoMap.put(dexName, relatedInfo);
 
         return true;
     }
 
-    @SuppressWarnings("NewApi")
     @Override
     public void onAllPatchesEnd() throws Exception {
         if (!hasDexChanged) {
@@ -173,89 +178,39 @@ public void onAllPatchesEnd() throws Exception {
             return;
         }
 
-        File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "full");
-        ensureDirectoryExist(tempFullPatchDexPath);
-        File tempSmallPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "small");
-        ensureDirectoryExist(tempSmallPatchDexPath);
-
-        // Generate dex diff out and full patched dex if a pair of dex is different.
-        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
-            File oldFile = oldAndNewDexFilePair.getKey();
-            File newFile = oldAndNewDexFilePair.getValue();
-            final String dexName = oldFile.getName();
-            RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
-
-            if (!relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
-                File dexDiffOut = getOutputPath(newFile).toFile();
-                ensureDirectoryExist(dexDiffOut.getParentFile());
-
-                try {
-                    DexPatchGenerator dexPatchGen = new DexPatchGenerator(oldFile, newFile);
-                    dexPatchGen.setAdditionalRemovingClassPatterns(config.mDexLoaderPattern);
-
-                    logWriter.writeLineToInfoFile(
-                            String.format(
-                                    "Start diff between [%s] as old and [%s] as new:",
-                                    getRelativeStringBy(oldFile, config.mTempUnzipOldDir),
-                                    getRelativeStringBy(newFile, config.mTempUnzipNewDir)
-                            )
-                    );
-
-                    dexPatchGen.executeAndSaveTo(dexDiffOut);
-                } catch (Exception e) {
-                    throw new TinkerPatchException(e);
-                }
-
-                if (!dexDiffOut.exists()) {
-                    throw new TinkerPatchException("can not find the diff file:" + dexDiffOut.getAbsolutePath());
-                }
+        generatePatchInfoFile();
 
-                relatedInfo.dexDiffFile = dexDiffOut;
-                relatedInfo.dexDiffMd5 = MD5.getMD5(dexDiffOut);
+        addTestDex();
+    }
 
-                File tempFullPatchedDexFile = new File(tempFullPatchDexPath, dexName);
+    @SuppressWarnings("NewApi")
+    private void generatePatchInfoFile() throws IOException {
+        generatePatchedDexInfoFile();
 
-                try {
-                    new DexPatchApplier(oldFile, dexDiffOut).executeAndSaveTo(tempFullPatchedDexFile);
+        // generateSmallPatchedDexInfoFile is blocked by issue we found in ART environment
+        // which indicates that if inline optimization is done on patched class, some error
+        // such as crash, ClassCastException, mistaken string fetching, etc. would happen.
+        //
+        // Instead, we will log all classN dexes as 'copy directly' in dex-meta, so that
+        // tinker patch applying procedure will copy them out and load them in ART environment.
 
-                    Logger.d(
-                            String.format("Verifying if patched new dex is logically the same as original new dex: %s ...", getRelativeStringBy(newFile, config.mTempUnzipNewDir))
-                    );
+        //generateSmallPatchedDexInfoFile();
 
-                    Dex origNewDex = new Dex(newFile);
-                    Dex patchedNewDex = new Dex(tempFullPatchedDexFile);
-                    checkDexChange(origNewDex, patchedNewDex);
+        logDexesToDexMeta();
 
-                    relatedInfo.newOrFullPatchedFile = tempFullPatchedDexFile;
-                    relatedInfo.newOrFullPatchedMd5 = MD5.getMD5(tempFullPatchedDexFile);
-                } catch (Exception e) {
-                    e.printStackTrace();
-                    throw new TinkerPatchException(
-                            "Failed to generate temporary patched dex, which makes MD5 generating procedure of new dex failed, either.", e
-                    );
-                }
-
-                if (!tempFullPatchedDexFile.exists()) {
-                    throw new TinkerPatchException("can not find the temporary full patched dex file:" + tempFullPatchedDexFile.getAbsolutePath());
-                }
-                Logger.e("Gen %s for dalvik full dex file:%s, size:%d, md5:%s", dexName, tempFullPatchedDexFile.getAbsolutePath(), tempFullPatchedDexFile.length(), relatedInfo.newOrFullPatchedMd5);
-            } else {
-                // In this case newDexFile is the same as oldDexFile, but we still
-                // need to treat it as patched dex file so that the SmallPatchGenerator
-                // can analyze which class of this dex should be kept in small patch.
-                relatedInfo.newOrFullPatchedFile = newFile;
-                relatedInfo.newOrFullPatchedMd5 = relatedInfo.newMd5;
-            }
-        }
+        checkCrossDexMovingClasses();
+    }
 
-        Set<File> classNOldDexFiles = new HashSet<>();
+    @SuppressWarnings("NewApi")
+    private void logDexesToDexMeta() throws IOException {
+        Map<String, File> dexNameToClassNOldDexFileMap = new HashMap<>();
+        Set<File> realClassNDexFiles = new HashSet<>();
 
         for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
             File oldFile = oldAndNewDexFilePair.getKey();
-            final String dexName = oldFile.getName();
-
+            final String dexName = getRelativeDexName(oldFile, null);
             if (isDexNameMatchesClassNPattern(dexName)) {
-                classNOldDexFiles.add(oldFile);
+                dexNameToClassNOldDexFileMap.put(dexName, oldFile);
             }
         }
 
@@ -263,113 +218,151 @@ public void onAllPatchesEnd() throws Exception {
         // classes.dex, classes2.dex, classes4.dex, classes5.dex
         // Since classes3.dex is missing, according to the logic in AOSP, we should not treat
         // rest dexes as part of class N dexes.
-        Map<String, File> dexNameToClassNOldDexFileMap = new HashMap<>();
-        for (File classNOldDex : classNOldDexFiles) {
-            dexNameToClassNOldDexFileMap.put(classNOldDex.getName(), classNOldDex);
+        for (int i = 0; i < dexNameToClassNOldDexFileMap.size(); ++i) {
+            final String expectedDexName = (i == 0 ? DexFormat.DEX_IN_JAR_NAME : "classes" + (i + 1) + ".dex");
+            if (dexNameToClassNOldDexFileMap.containsKey(expectedDexName)) {
+                File oldDexFile = dexNameToClassNOldDexFileMap.get(expectedDexName);
+                realClassNDexFiles.add(oldDexFile);
+            } else {
+                break;
+            }
         }
 
-        boolean isRestDexNotInClassN = false;
-        for (int i = 0; i < classNOldDexFiles.size(); ++i) {
-            final String expectedDexName = (i == 0 ? DexFormat.DEX_IN_JAR_NAME : "classes" + (i + 1) + ".dex");
-            if (!dexNameToClassNOldDexFileMap.containsKey(expectedDexName)) {
-                isRestDexNotInClassN = true;
+        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
+            final File oldDexFile = oldAndNewDexFilePair.getKey();
+            final File newDexFile = oldAndNewDexFilePair.getValue();
+            final String dexName = getRelativeDexName(oldDexFile, newDexFile);
+            final RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
+            if (!relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
+                //logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.smallPatchedMd5, relatedInfo.dexDiffMd5);
+                logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.newOrFullPatchedMd5, relatedInfo.dexDiffMd5);
             } else {
-                if (isRestDexNotInClassN) {
-                    File mistakenClassNOldDexFile = dexNameToClassNOldDexFileMap.get(expectedDexName);
-                    classNOldDexFiles.remove(mistakenClassNOldDexFile);
+                // For class N dexes, if new dex is the same as old dex, we should log it as 'copy directly'
+                // in dex meta to fix problems in Art environment.
+                if (realClassNDexFiles.contains(oldDexFile)) {
+                    //if (!"0".equals(relatedInfo.smallPatchedMd5)) {
+                    //    logToDexMeta(newDexFile, oldDexFile, null, "0", relatedInfo.smallPatchedMd5, "0");
+                    //}
+
+                    // Bugfix: However, if what we would copy directly is main dex, we should do an additional diff operation
+                    // so that patch applier would help us remove all loader classes of it in runtime.
+                    if (dexName.equals(DexFormat.DEX_IN_JAR_NAME)) {
+                        Logger.d("\nDo additional diff on main dex to remove loader classes in it.");
+                        diffDexPairAndFillRelatedInfo(oldDexFile, newDexFile, relatedInfo);
+                        logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.newOrFullPatchedMd5, relatedInfo.dexDiffMd5);
+                    } else {
+                        logToDexMeta(newDexFile, oldDexFile, null, "0", relatedInfo.oldMd5, "0");
+                    }
                 }
             }
         }
+    }
 
-        File tempSmallPatchInfoFile = new File(config.mTempResultDir, TypedValue.DEX_SMALLPATCH_INFO_FILE);
-        ensureDirectoryExist(tempSmallPatchInfoFile.getParentFile());
-
-        // So far we know whether a pair of dex is belong to class N dexes or other dexes.
-        // Then we collect class N dex pairs and other dex pairs by separate their old dex
-        // and full patched dex into different list.
-        SmallDexPatchGenerator smallDexPatchGenerator = new SmallDexPatchGenerator();
-        smallDexPatchGenerator.setLoaderClassPatterns(config.mDexLoaderPattern);
-        smallDexPatchGenerator.setLogger(dexPatcherLoggerBridge);
-
-        logWriter.writeLineToInfoFile("\nStart collecting old dex and full patched dex...");
-
-        List<File> classNOldDexFileList = new ArrayList<>();
-        List<File> classNFullPatchedDexFileList = new ArrayList<>();
-        List<File> otherOldDexFileList = new ArrayList<>();
-        List<File> otherFullPatchedDexFileList = new ArrayList<>();
+    @SuppressWarnings("NewApi")
+    private void generatePatchedDexInfoFile() {
+        // Generate dex diff out and full patched dex if a pair of dex is different.
         for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
             File oldFile = oldAndNewDexFilePair.getKey();
-            final String dexName = oldFile.getName();
-            File fullPatchedFile = dexNameToRelatedInfoMap.get(dexName).newOrFullPatchedFile;
-            if (classNOldDexFiles.contains(oldFile)) {
-                classNOldDexFileList.add(oldFile);
-                classNFullPatchedDexFileList.add(fullPatchedFile);
+            File newFile = oldAndNewDexFilePair.getValue();
+            final String dexName = getRelativeDexName(oldFile, newFile);
+            RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
+            if (!relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
+                diffDexPairAndFillRelatedInfo(oldFile, newFile, relatedInfo);
             } else {
-                otherOldDexFileList.add(oldFile);
-                otherFullPatchedDexFileList.add(fullPatchedFile);
+                // In this case newDexFile is the same as oldDexFile, but we still
+                // need to treat it as patched dex file so that the SmallPatchGenerator
+                // can analyze which class of this dex should be kept in small patch.
+                relatedInfo.newOrFullPatchedFile = newFile;
+                relatedInfo.newOrFullPatchedMd5 = relatedInfo.newMd5;
             }
         }
+    }
 
-        logWriter.writeLineToInfoFile(String.format("\nCollected class N old dexes: %s", classNOldDexFileList));
-        logWriter.writeLineToInfoFile(String.format("Collected class N full patched dexes: %s", classNFullPatchedDexFileList));
-        logWriter.writeLineToInfoFile(String.format("\nCollected other old dexes: %s", otherOldDexFileList));
-        logWriter.writeLineToInfoFile(String.format("Collected other full patched dexes: %s", otherFullPatchedDexFileList));
+    private void diffDexPairAndFillRelatedInfo(File oldDexFile, File newDexFile, RelatedInfo relatedInfo) {
+        File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR);
+        final String dexName = getRelativeDexName(oldDexFile, newDexFile);
 
-        smallDexPatchGenerator.appendDexGroup(DexGroup.wrap(classNOldDexFileList), DexGroup.wrap(classNFullPatchedDexFileList));
+        File dexDiffOut = getOutputPath(newDexFile).toFile();
+        ensureDirectoryExist(dexDiffOut.getParentFile());
 
-        if (!otherOldDexFileList.isEmpty()) {
-            smallDexPatchGenerator.appendDexGroup(DexGroup.wrap(otherOldDexFileList), DexGroup.wrap(otherFullPatchedDexFileList));
+        try {
+            DexPatchGenerator dexPatchGen = new DexPatchGenerator(oldDexFile, newDexFile);
+            dexPatchGen.setAdditionalRemovingClassPatterns(config.mDexLoaderPattern);
+
+            logWriter.writeLineToInfoFile(
+                    String.format(
+                            "Start diff between [%s] as old and [%s] as new:",
+                            getRelativeStringBy(oldDexFile, config.mTempUnzipOldDir),
+                            getRelativeStringBy(newDexFile, config.mTempUnzipNewDir)
+                    )
+            );
+
+            dexPatchGen.executeAndSaveTo(dexDiffOut);
+        } catch (Exception e) {
+            throw new TinkerPatchException(e);
+        }
+
+        if (!dexDiffOut.exists()) {
+            throw new TinkerPatchException("can not find the diff file:" + dexDiffOut.getAbsolutePath());
+        }
+
+        relatedInfo.dexDiffFile = dexDiffOut;
+        relatedInfo.dexDiffMd5 = MD5.getMD5(dexDiffOut);
+        Logger.d("\nGen %s patch file:%s, size:%d, md5:%s", dexName, relatedInfo.dexDiffFile.getAbsolutePath(), relatedInfo.dexDiffFile.length(), relatedInfo.dexDiffMd5);
+
+        File tempFullPatchedDexFile = new File(tempFullPatchDexPath, dexName);
+        if (!tempFullPatchedDexFile.exists()) {
+            ensureDirectoryExist(tempFullPatchedDexFile.getParentFile());
         }
 
         try {
-            Logger.d("Start generating small patch info file...");
-            smallDexPatchGenerator.executeAndSaveTo(tempSmallPatchInfoFile);
+            new DexPatchApplier(oldDexFile, dexDiffOut).executeAndSaveTo(tempFullPatchedDexFile);
+
+            Logger.d(
+                    String.format("Verifying if patched new dex is logically the same as original new dex: %s ...", getRelativeStringBy(newDexFile, config.mTempUnzipNewDir))
+            );
+
+            Dex origNewDex = new Dex(newDexFile);
+            Dex patchedNewDex = new Dex(tempFullPatchedDexFile);
+            checkDexChange(origNewDex, patchedNewDex);
+
+            relatedInfo.newOrFullPatchedFile = tempFullPatchedDexFile;
+            relatedInfo.newOrFullPatchedMd5 = MD5.getMD5(tempFullPatchedDexFile);
         } catch (Exception e) {
-            throw new TinkerPatchException("\nFailed to generate small patch info file.", e);
+            e.printStackTrace();
+            throw new TinkerPatchException(
+                    "Failed to generate temporary patched dex, which makes MD5 generating procedure of new dex failed, either.", e
+            );
+        }
+
+        if (!tempFullPatchedDexFile.exists()) {
+            throw new TinkerPatchException("can not find the temporary full patched dex file:" + tempFullPatchedDexFile.getAbsolutePath());
         }
-        if (!tempSmallPatchInfoFile.exists()) {
-            throw new TinkerPatchException("can not find the small patch info file:" + tempSmallPatchInfoFile.getAbsolutePath());
+        Logger.d("\nGen %s for dalvik full dex file:%s, size:%d, md5:%s", dexName, tempFullPatchedDexFile.getAbsolutePath(), tempFullPatchedDexFile.length(), relatedInfo.newOrFullPatchedMd5);
+    }
+
+    private void addTestDex() throws IOException {
+        //write test dex
+        String dexMode = "jar";
+        if (config.mDexRaw) {
+            dexMode = "raw";
         }
 
-        SmallPatchedDexItemFile smallPatchedDexItemFile = new SmallPatchedDexItemFile(tempSmallPatchInfoFile);
+        final InputStream is = DexDiffDecoder.class.getResourceAsStream("/" + TEST_DEX_NAME);
+        String md5 = MD5.getMD5(is, 1024);
+        is.close();
 
-        // Generate small patched dex and write meta.
-        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
-            File oldFile = oldAndNewDexFilePair.getKey();
-            File newFile = oldAndNewDexFilePair.getValue();
-            final String dexName = oldFile.getName();
-            final String oldDexSignStr = Hex.toHexString(new Dex(oldFile).computeSignature(false));
-            File tempSmallPatchedFile = new File(tempSmallPatchDexPath, dexName);
-            RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
-            File dexDiffFile = relatedInfo.dexDiffFile;
+        String meta = TEST_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + dexMode;
 
-            if (!smallPatchedDexItemFile.isSmallPatchedDexEmpty(oldDexSignStr)) {
-                try {
-                    new DexPatchApplier(oldFile, dexDiffFile, smallPatchedDexItemFile).executeAndSaveTo(tempSmallPatchedFile);
-                } catch (Exception e) {
-                    e.printStackTrace();
-                    throw new TinkerPatchException(
-                            "Failed to generate temporary small patched dex, which makes MD5 generating procedure of small patched dex failed, either.", e
-                    );
-                }
-                if (!tempSmallPatchedFile.exists()) {
-                    throw new TinkerPatchException("can not find the temporary small patched dex file:" + tempSmallPatchInfoFile.getAbsolutePath());
-                }
-                relatedInfo.smallPatchedMd5 = MD5.getMD5(tempSmallPatchedFile);
-                Logger.e("Gen %s for art small dex file:%s, size:%d, md5:%s", dexName, tempSmallPatchedFile.getAbsolutePath(), tempSmallPatchedFile.length(), relatedInfo.smallPatchedMd5);
-
-                if (relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
-                    // Unmodified dex, which has no dexDiffFile, and is ignored in dvm environment.
-                    // So we pass zero string to destMd5InDvm and dexDiffMd5.
-                    writeLogFiles(newFile, oldFile, relatedInfo.dexDiffFile, "0", relatedInfo.smallPatchedMd5, "0");
-                } else {
-                    writeLogFiles(newFile, oldFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.smallPatchedMd5, relatedInfo.dexDiffMd5);
-                }
-            }
-        }
+        File dest = new File(config.mTempResultDir + "/" + TEST_DEX_NAME);
+        FileOperation.copyResourceUsingStream(TEST_DEX_NAME, dest);
+        Logger.d("\nAdd test install result dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
+        Logger.d("DexDecoder:write test dex meta file data: %s", meta);
 
-        addTestDex();
+        metaWriter.writeLineToInfoFile(meta);
+    }
 
+    private void checkCrossDexMovingClasses() {
         // Here we will check if any classes that were deleted in one dex
         // would be added to another dex. e.g. classA is deleted in dex0 and
         // added in dex1.
@@ -385,7 +378,7 @@ public void onAllPatchesEnd() throws Exception {
         Set<String> movedCrossFilesClassDescs = deletedClassDescs;
         if (!movedCrossFilesClassDescs.isEmpty()) {
             Logger.e("Warning:Class Moved. Some classes are just moved from one dex to another. "
-                + "This behavior may leads to unnecessary enlargement of patch file. you should try to check them:");
+                    + "This behavior may leads to unnecessary enlargement of patch file. you should try to check them:");
 
             for (String classDesc : movedCrossFilesClassDescs) {
                 StringBuilder sb = new StringBuilder();
@@ -399,33 +392,11 @@ public void onAllPatchesEnd() throws Exception {
         }
     }
 
-    @Override
-    public void clean() {
-        metaWriter.close();
-        logWriter.close();
-    }
-
-    private void ensureDirectoryExist(File dir) {
-        if (!dir.exists()) {
-            if (!dir.mkdirs()) {
-                throw new TinkerPatchException("failed to create directory: " + dir);
-            }
-        }
-    }
-
-    private boolean isDexNameMatchesClassNPattern(String dexName) {
-        return (dexName.matches("^classes[0-9]*\\.dex$"));
-    }
-
-    private void copyNewDexAndMarkInMeta(File newFile, String newMd5, File output) throws IOException {
-        newMd5 = checkNewDexAndMd5(newMd5, newFile);
-        FileOperation.copyFileUsingStream(newFile, output);
-        writeLogFiles(newFile, null, null, newMd5, newMd5, "0");
-    }
-
-    private void checkAddedOrDeletedClasses(File oldFile, File newFile) throws IOException {
-        // Before starting real diff works, we collect added class descriptor
-        // and deleted class descriptor for further analysing.
+    /**
+     * Before starting real diff works, we collect added class descriptor
+     * and deleted class descriptor for further analysing in {@code checkCrossDexMovingClasses}.
+     */
+    private void collectAddedOrDeletedClasses(File oldFile, File newFile) throws IOException {
         Dex oldDex = new Dex(oldFile);
         Dex newDex = new Dex(newFile);
 
@@ -476,6 +447,15 @@ private void checkAddedOrDeletedClasses(File oldFile, File newFile) throws IOExc
         }
     }
 
+    private boolean isDexNameMatchesClassNPattern(String dexName) {
+        return (dexName.matches("^classes[0-9]*\\.dex$"));
+    }
+
+    private void copyNewDexAndLogToDexMeta(File newFile, String newMd5, File output) throws IOException {
+        FileOperation.copyFileUsingStream(newFile, output);
+        logToDexMeta(newFile, null, null, newMd5, newMd5, "0");
+    }
+
     private void checkDexChange(Dex originDex, Dex newDex) {
         DexClassesComparator classesCmptor = new DexClassesComparator("*");
         classesCmptor.setIgnoredRemovedClassDescPattern(config.mDexLoaderPattern);
@@ -516,59 +496,6 @@ private void checkDexChange(Dex originDex, Dex newDex) {
         }
     }
 
-    private void addTestDex() throws IOException {
-        //write test dex
-        String dexMode = "jar";
-        if (config.mDexRaw) {
-            dexMode = "raw";
-        }
-
-        final InputStream is = DexDiffDecoder.class.getResourceAsStream("/" + TEST_DEX_PATH);
-        String md5 = MD5.getMD5(is, 1024);
-        is.close();
-
-        String meta = TEST_DEX_PATH + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + dexMode;
-
-        File dest = new File(config.mTempResultDir + "/" + TEST_DEX_PATH);
-        FileOperation.copyResourceUsingStream(TEST_DEX_PATH, dest);
-        Logger.d("Add test install result dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
-        Logger.d("DexDecoder:write test dex meta file data: %s", meta);
-
-        metaWriter.writeLineToInfoFile(meta);
-    }
-
-    private String checkNewDexAndMd5(String md5, File dexFile) {
-        String name = dexFile.getName();
-        if (name.endsWith(".dex")) {
-            return md5;
-        } else {
-            try {
-                final JarFile dexJar = new JarFile(dexFile);
-                ZipEntry classesDex = dexJar.getEntry(DexFormat.DEX_IN_JAR_NAME);
-                // no code
-                if (null == classesDex) {
-                    throw new TinkerPatchException(
-                        String.format("dex jar file %s do not contain 'classes.dex', it is not a correct dex jar file!", dexFile.getAbsolutePath())
-                    );
-                }
-
-                return MD5.getMD5(dexJar.getInputStream(classesDex), 1024 * 100);
-            } catch (IOException e) {
-                throw new TinkerPatchException(
-                    String.format("dex file %s is not end with '.dex', but it is not a correct dex jar file also!", dexFile.getAbsolutePath()), e
-                );
-            }
-        }
-    }
-
-    private String getRelativeStringBy(File file, File reference) {
-        File actualReference = reference.getParentFile();
-        if (actualReference == null) {
-            actualReference = reference;
-        }
-        return actualReference.toPath().relativize(file.toPath()).toString().replace("\\", "/");
-    }
-
     /**
      * Construct dex meta-info and write it to meta file and log.
      *
@@ -587,12 +514,12 @@ private String getRelativeStringBy(File file, File reference) {
      *
      * @throws IOException
      */
-    protected void writeLogFiles(File newOrFullPatchedFile, File oldFile, File dexDiffFile, String destMd5InDvm, String destMd5InArt, String dexDiffMd5) throws IOException {
+    protected void logToDexMeta(File newOrFullPatchedFile, File oldFile, File dexDiffFile, String destMd5InDvm, String destMd5InArt, String dexDiffMd5) throws IOException {
         if (metaWriter == null && logWriter == null) {
             return;
         }
-        String parentRelative = getParentRelativeString(newOrFullPatchedFile);
-        String relative = getRelativeString(newOrFullPatchedFile);
+        String parentRelative = getParentRelativePathStringToNewFile(newOrFullPatchedFile);
+        String relative = getRelativePathStringToNewFile(newOrFullPatchedFile);
 
         if (metaWriter != null) {
             String fileName = newOrFullPatchedFile.getName();
@@ -629,6 +556,60 @@ protected void writeLogFiles(File newOrFullPatchedFile, File oldFile, File dexDi
         }
     }
 
+    @Override
+    public void clean() {
+        metaWriter.close();
+        logWriter.close();
+    }
+
+    private String getRawOrWrappedDexMD5(File dexOrJarFile) {
+        final String name = dexOrJarFile.getName();
+        if (name.endsWith(".dex")) {
+            return MD5.getMD5(dexOrJarFile);
+        } else {
+            JarFile dexJar = null;
+            try {
+                dexJar = new JarFile(dexOrJarFile);
+                ZipEntry classesDex = dexJar.getEntry(DexFormat.DEX_IN_JAR_NAME);
+                // no code
+                if (classesDex == null) {
+                    throw new TinkerPatchException(
+                            String.format("Jar file %s do not contain 'classes.dex', it is not a correct dex jar file!", dexOrJarFile.getAbsolutePath())
+                    );
+                }
+                return MD5.getMD5(dexJar.getInputStream(classesDex), 1024 * 100);
+            } catch (IOException e) {
+                throw new TinkerPatchException(
+                        String.format("File %s is not end with '.dex', but it is not a correct dex jar file !", dexOrJarFile.getAbsolutePath()), e
+                );
+            } finally {
+                if (dexJar != null) {
+                    try {
+                        dexJar.close();
+                    } catch (Exception e) {
+                        // Ignored.
+                    }
+                }
+            }
+        }
+    }
+
+    private String getRelativeStringBy(File file, File reference) {
+        File actualReference = reference.getParentFile();
+        if (actualReference == null) {
+            actualReference = reference;
+        }
+        return actualReference.toPath().relativize(file.toPath()).toString().replace("\\", "/");
+    }
+
+    private void ensureDirectoryExist(File dir) {
+        if (!dir.exists()) {
+            if (!dir.mkdirs()) {
+                throw new TinkerPatchException("failed to create directory: " + dir);
+            }
+        }
+    }
+
     private final class RelatedInfo {
         File newOrFullPatchedFile = null;
         /**
@@ -645,39 +626,38 @@ protected void writeLogFiles(File newOrFullPatchedFile, File oldFile, File dexDi
          *  newDex md5, if new dex is marked to be copied directly;
          */
         String newOrFullPatchedMd5 = "0";
-        String smallPatchedMd5 = "0";
     }
 
     private final class DexPatcherLoggerBridge implements IDexPatcherLogger {
-        private final InfoWriter logWritter;
+        private final InfoWriter logWriter;
 
         DexPatcherLoggerBridge(InfoWriter logWritter) {
-            this.logWritter = logWritter;
+            this.logWriter = logWritter;
         }
 
         @Override
         public void v(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
 
         @Override
         public void d(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
 
         @Override
         public void i(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
 
         @Override
         public void w(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
 
         @Override
         public void e(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
index d21414ee..642b4482 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
@@ -17,7 +17,7 @@
 package com.tencent.tinker.build.decoder;
 
 
-import com.tencent.tinker.build.apkparser.AndroidManifest;
+import com.tencent.tinker.build.apkparser.AndroidParser;
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.build.util.Logger;
 import com.tencent.tinker.build.util.TinkerPatchException;
@@ -42,8 +42,8 @@ public ManifestDecoder(Configuration config) throws IOException {
     public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatchException {
         final boolean ignoreWarning = config.mIgnoreWarning;
         try {
-            AndroidManifest oldAndroidManifest = AndroidManifest.getAndroidManifest(oldFile);
-            AndroidManifest newAndroidManifest = AndroidManifest.getAndroidManifest(newFile);
+            AndroidParser oldAndroidManifest = AndroidParser.getAndroidManifest(oldFile);
+            AndroidParser newAndroidManifest = AndroidParser.getAndroidManifest(newFile);
             //check minSdkVersion
             int minSdkVersion = Integer.parseInt(oldAndroidManifest.apkMeta.getMinSdkVersion());
 
@@ -51,12 +51,12 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
                 if (config.mDexRaw) {
                     if (ignoreWarning) {
                         //ignoreWarning, just log
-                        Logger.e("Warning:ignoreWarning is true, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will be crash at some times", minSdkVersion);
+                        Logger.e("Warning:ignoreWarning is true, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will crash at some time", minSdkVersion);
                     } else {
-                        Logger.e("Warning:ignoreWarning is false, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will be crash at some times", minSdkVersion);
+                        Logger.e("Warning:ignoreWarning is false, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will crash at some time", minSdkVersion);
 
                         throw new TinkerPatchException(
-                            String.format("ignoreWarning is false, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will be crash at some times", minSdkVersion)
+                            String.format("ignoreWarning is false, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will crash at some time", minSdkVersion)
                         );
                     }
                 }
@@ -76,11 +76,11 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
                 }
                 if (!found) {
                     if (ignoreWarning) {
-                        Logger.e("Warning:ignoreWarning is true, but we found a new AndroidComponent %s, it will be crash at some times", newComponentName);
+                        Logger.e("Warning:ignoreWarning is true, but we found a new AndroidComponent %s, it will crash at some time", newComponentName);
                     } else {
-                        Logger.e("Warning:ignoreWarning is false, but we found a new AndroidComponent %s, it will be crash at some times", newComponentName);
+                        Logger.e("Warning:ignoreWarning is false, but we found a new AndroidComponent %s, it will crash at some time", newComponentName);
                         throw new TinkerPatchException(
-                            String.format("ignoreWarning is false, but we found a new AndroidComponent %s, it will be crash at some times", newComponentName)
+                            String.format("ignoreWarning is false, but we found a new AndroidComponent %s, it will crash at some time", newComponentName)
                         );
                     }
                 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
index 193b41c1..d5c82b75 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
@@ -17,6 +17,7 @@
 package com.tencent.tinker.build.decoder;
 
 import com.tencent.tinker.bsdiff.BSDiff;
+import com.tencent.tinker.build.apkparser.AndroidParser;
 import com.tencent.tinker.build.info.InfoWriter;
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.build.util.FileOperation;
@@ -41,6 +42,8 @@
  * Created by zhangshaowen on 16/8/8.
  */
 public class ResDiffDecoder extends BaseDecoder {
+    private static final String TEST_RESOURCE_NAME        = "only_use_to_test_tinker_resource.txt";
+    private static final String TEST_RESOURCE_ASSETS_PATH = "assets/" + TEST_RESOURCE_NAME;
 
     private static final String TEMP_RES_ZIP  = "temp_res.zip";
     private static final String TEMP_RES_7ZIP = "temp_res_7ZIP.zip";
@@ -80,8 +83,8 @@ public void clean() {
     }
 
     private boolean checkLargeModFile(File file) {
-        long lenght = file.length();
-        if (lenght > config.mLargeModSize * TypedValue.K_BYTES) {
+        long length = file.length();
+        if (length > config.mLargeModSize * TypedValue.K_BYTES) {
             return true;
         }
         return false;
@@ -89,14 +92,16 @@ private boolean checkLargeModFile(File file) {
 
     @Override
     public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatchException {
+        String name = getRelativePathStringToNewFile(newFile);
+
         //actually, it won't go below
         if (newFile == null || !newFile.exists()) {
-            String name = getRelativeStringByOldDir(oldFile);
-            if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, name)) {
-                Logger.e("found delete resource: " + name + " ,but it match ignore change pattern, just ignore!");
+            String relativeStringByOldDir = getRelativePathStringToOldFile(oldFile);
+            if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, relativeStringByOldDir)) {
+                Logger.e("found delete resource: " + relativeStringByOldDir + " ,but it match ignore change pattern, just ignore!");
                 return false;
             }
-            deletedSet.add(name);
+            deletedSet.add(relativeStringByOldDir);
             writeResLog(newFile, oldFile, TypedValue.DEL);
             return true;
         }
@@ -104,7 +109,6 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
         File outputFile = getOutputPath(newFile).toFile();
 
         if (oldFile == null || !oldFile.exists()) {
-            String name = getRelativeString(newFile);
             if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, name)) {
                 Logger.e("found add resource: " + name + " ,but it match ignore change pattern, just ignore!");
                 return false;
@@ -126,15 +130,25 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
         if (oldMd5 != null && oldMd5.equals(newMd5)) {
             return false;
         }
-        String name = getRelativeString(newFile);
         if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, name)) {
-            Logger.e("found modify resource: " + name + " ,but it match ignore change pattern, just ignore!");
+            Logger.d("found modify resource: " + name + ", but it match ignore change pattern, just ignore!");
             return false;
         }
         if (name.equals(TypedValue.RES_MANIFEST)) {
-            Logger.e("found modify resource: " + name + " ,but it is AndroidManifest.xml, just ignore!");
+            Logger.d("found modify resource: " + name + ", but it is AndroidManifest.xml, just ignore!");
             return false;
         }
+        if (name.equals(TypedValue.RES_ARSC)) {
+            if (AndroidParser.resourceTableLogicalChange(config)) {
+                Logger.d("found modify resource: " + name + ", but it is logically the same as original new resources.arsc, just ignore!");
+                return false;
+            }
+        }
+        dealWithModeFile(name, newMd5, oldFile, newFile, outputFile);
+        return true;
+    }
+
+    private boolean dealWithModeFile(String name, String newMd5, File oldFile, File newFile, File outputFile) throws IOException {
         if (checkLargeModFile(newFile)) {
             if (!outputFile.getParentFile().exists()) {
                 outputFile.getParentFile().mkdirs();
@@ -155,7 +169,7 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
         modifiedSet.add(name);
         FileOperation.copyFileUsingStream(newFile, outputFile);
         writeResLog(newFile, oldFile, TypedValue.MOD);
-        return true;
+        return false;
     }
 
     private void writeResLog(File newFile, File oldFile, int mode) throws IOException {
@@ -164,25 +178,25 @@ private void writeResLog(File newFile, File oldFile, int mode) throws IOExceptio
             String relative;
             switch (mode) {
                 case TypedValue.ADD:
-                    relative = getRelativeString(newFile);
+                    relative = getRelativePathStringToNewFile(newFile);
                     Logger.d("Found add resource: " + relative);
                     log = "add resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
                     break;
                 case TypedValue.MOD:
-                    relative = getRelativeString(newFile);
+                    relative = getRelativePathStringToNewFile(newFile);
                     Logger.d("Found modify resource: " + relative);
                     log = "modify resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
                     break;
                 case TypedValue.DEL:
-                    relative = getRelativeStringByOldDir(oldFile);
+                    relative = getRelativePathStringToOldFile(oldFile);
                     Logger.d("Found deleted resource: " + relative);
                     log = "deleted resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
                     break;
                 case TypedValue.LARGE_MOD:
-                    relative = getRelativeString(newFile);
+                    relative = getRelativePathStringToNewFile(newFile);
                     Logger.d("Found large modify resource: " + relative + " size:" + newFile.length());
                     log = "large modify resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
@@ -197,6 +211,16 @@ public void onAllPatchesStart() throws IOException, TinkerPatchException {
 
     }
 
+    private void addAssetsFileForTestResource() throws IOException {
+        File dest = new File(config.mTempResultDir + "/" + TEST_RESOURCE_ASSETS_PATH);
+        FileOperation.copyResourceUsingStream(TEST_RESOURCE_NAME, dest);
+        addedSet.add(TEST_RESOURCE_ASSETS_PATH);
+        Logger.d("Add Test resource file: " + TEST_RESOURCE_ASSETS_PATH);
+        String log = "add test resource: " + TEST_RESOURCE_ASSETS_PATH + ", oldSize=" + 0 + ", newSize="
+            + FileOperation.getFileSizes(dest);
+        logWriter.writeLineToInfoFile(log);
+    }
+
     @Override
     public void onAllPatchesEnd() throws IOException, TinkerPatchException {
         //only there is only deleted set, we just ignore
@@ -213,10 +237,9 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
 
         //check gradle build
         if (config.mUsingGradle) {
+            final boolean ignoreWarning = config.mIgnoreWarning;
             final boolean resourceArscChanged = modifiedSet.contains(TypedValue.RES_ARSC)
                 || largeModifiedSet.contains(TypedValue.RES_ARSC);
-            final boolean ignoreWarning = config.mIgnoreWarning;
-
             if (resourceArscChanged && !config.mUseApplyResource) {
                 if (ignoreWarning) {
                     //ignoreWarning, just log
@@ -249,6 +272,9 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
         removeIgnoreChangeFile(addedSet);
         removeIgnoreChangeFile(largeModifiedSet);
 
+        // last add test res in assets for user cannot ignore it;
+        addAssetsFileForTestResource();
+
         File tempResZip = new File(config.mOutFolder + File.separator + TEMP_RES_ZIP);
         final File tempResFiles = config.mTempResultDir;
 
@@ -259,9 +285,9 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
         String resZipMd5 = Utils.genResOutputFile(extractToZip, tempResZip, config,
             addedSet, modifiedSet, deletedSet, largeModifiedSet, largeModifiedMap);
 
-        Logger.e("final normal zip resource: %s, size=%d, md5=%s", extractToZip.getName(), extractToZip.length(), resZipMd5);
+        Logger.e("Final normal zip resource: %s, size=%d, md5=%s", extractToZip.getName(), extractToZip.length(), resZipMd5);
         logWriter.writeLineToInfoFile(
-            String.format("final normal zip resource: %s, size=%d, md5=%s", extractToZip.getName(), extractToZip.length(), resZipMd5)
+            String.format("Final normal zip resource: %s, size=%d, md5=%s", extractToZip.getName(), extractToZip.length(), resZipMd5)
         );
         //delete temp file
         FileOperation.deleteFile(tempResZip);
@@ -279,9 +305,9 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
                     addedSet, modifiedSet, deletedSet, largeModifiedSet, largeModifiedMap);
                 //delete temp file
                 FileOperation.deleteFile(tempRes7Zip);
-                Logger.e("final 7zip resource: %s, size=%d, md5=%s", extractTo7Zip.getName(), extractTo7Zip.length(), res7zipMd5);
+                Logger.e("Final 7zip resource: %s, size=%d, md5=%s", extractTo7Zip.getName(), extractTo7Zip.length(), res7zipMd5);
                 logWriter.writeLineToInfoFile(
-                    String.format("final 7zip resource: %s, size=%d, md5=%s", extractTo7Zip.getName(), extractTo7Zip.length(), res7zipMd5)
+                    String.format("Final 7zip resource: %s, size=%d, md5=%s", extractTo7Zip.getName(), extractTo7Zip.length(), res7zipMd5)
                 );
             }
         }
@@ -396,7 +422,7 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IO
             if (Utils.checkFileInPattern(config.mResFilePattern, patternKey)) {
                 //not contain in new path, is deleted
                 if (!newPath.toFile().exists()) {
-                    deletedFiles.add(relativePath.toString());
+                    deletedFiles.add(patternKey);
                     writeResLog(newPath.toFile(), file.toFile(), TypedValue.DEL);
                 }
                 return FileVisitResult.CONTINUE;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/UniqueDexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/UniqueDexDiffDecoder.java
index 46a61f7c..88258320 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/UniqueDexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/UniqueDexDiffDecoder.java
@@ -48,4 +48,4 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
         return added;
     }
 
-}
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
index 8bbe973b..ce25e7e4 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
@@ -33,7 +33,7 @@
 import com.tencent.tinker.android.dex.StringData;
 import com.tencent.tinker.android.dex.TypeList;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 import com.tencent.tinker.build.dexpatcher.algorithms.diff.AnnotationSectionDiffAlgorithm;
 import com.tencent.tinker.build.dexpatcher.algorithms.diff.AnnotationSetRefListSectionDiffAlgorithm;
 import com.tencent.tinker.build.dexpatcher.algorithms.diff.AnnotationSetSectionDiffAlgorithm;
@@ -136,10 +136,10 @@ public DexPatchGenerator(Dex oldDex, Dex newDex) {
         this.oldDex = oldDex;
         this.newDex = newDex;
 
-        IndexMap oldToNewIndexMap = new IndexMap();
-        IndexMap oldToPatchedIndexMap = new IndexMap();
-        IndexMap newToPatchedIndexMap = new IndexMap();
-        IndexMap selfIndexMapForSkip = new IndexMap();
+        SparseIndexMap oldToNewIndexMap = new SparseIndexMap();
+        SparseIndexMap oldToPatchedIndexMap = new SparseIndexMap();
+        SparseIndexMap newToPatchedIndexMap = new SparseIndexMap();
+        SparseIndexMap selfIndexMapForSkip = new SparseIndexMap();
 
         additionalRemovingClassPatternSet = new HashSet<>();
 
@@ -547,173 +547,129 @@ private void writeResultToStream(OutputStream os) throws IOException {
         buffer.writeInt(firstChunkOffset);
         buffer.position(firstChunkOffset);
 
-        new PatchOperationsWriter<StringData>(this.stringDataSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, StringData item) {
-                buffer.writeStringData(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<Integer>(this.typeIdSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, Integer item) {
-                buffer.writeInt(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<TypeList>(this.typeListSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, TypeList item) {
-                buffer.writeTypeList(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<ProtoId>(this.protoIdSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, ProtoId item) {
-                buffer.writeProtoId(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<FieldId>(this.fieldIdSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, FieldId item) {
-                buffer.writeFieldId(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<MethodId>(this.methodIdSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, MethodId item) {
-                buffer.writeMethodId(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<Annotation>(this.annotationSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, Annotation item) {
-                buffer.writeAnnotation(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<AnnotationSet>(this.annotationSetSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, AnnotationSet item) {
-                buffer.writeAnnotationSet(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<AnnotationSetRefList>(this.annotationSetRefListSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, AnnotationSetRefList item) {
-                buffer.writeAnnotationSetRefList(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<AnnotationsDirectory>(this.annotationsDirectorySectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, AnnotationsDirectory item) {
-                buffer.writeAnnotationsDirectory(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<DebugInfoItem>(this.debugInfoSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, DebugInfoItem item) {
-                buffer.writeDebugInfoItem(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<Code>(this.codeSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, Code item) {
-                buffer.writeCode(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<ClassData>(this.classDataSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, ClassData item) {
-                buffer.writeClassData(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<EncodedValue>(this.encodedArraySectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, EncodedValue item) {
-                buffer.writeEncodedArray(item);
-            }
-        }.writeToBuffer(buffer);
-
-        new PatchOperationsWriter<ClassDef>(this.classDefSectionDiffAlg.getPatchOperationList()) {
-            @Override
-            protected void writeItem(DexDataBuffer buffer, ClassDef item) {
-                buffer.writeClassDef(item);
-            }
-        }.writeToBuffer(buffer);
+        writePatchOperations(buffer, this.stringDataSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.typeIdSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.typeListSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.protoIdSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.fieldIdSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.methodIdSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.annotationSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.annotationSetSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.annotationSetRefListSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.annotationsDirectorySectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.debugInfoSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.codeSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.classDataSectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.encodedArraySectionDiffAlg.getPatchOperationList());
+        writePatchOperations(buffer, this.classDefSectionDiffAlg.getPatchOperationList());
 
         byte[] bufferData = buffer.array();
         os.write(bufferData);
         os.flush();
     }
 
-    private abstract class PatchOperationsWriter<T> {
-        private final List<PatchOperation<T>> patchOperationList;
-
-        PatchOperationsWriter(List<PatchOperation<T>> patchOperationList) {
-            this.patchOperationList = patchOperationList;
-        }
-
-        protected abstract void writeItem(DexDataBuffer buffer, T item);
-
-        public final void writeToBuffer(DexDataBuffer buffer) {
-            List<Integer> delOpIndexList = new ArrayList<>(patchOperationList.size());
-            List<Integer> addOpIndexList = new ArrayList<>(patchOperationList.size());
-            List<Integer> replaceOpIndexList = new ArrayList<>(patchOperationList.size());
-            List<T> newItemList = new ArrayList<>(patchOperationList.size());
-
-            for (PatchOperation<T> patchOperation : patchOperationList) {
-                switch (patchOperation.op) {
-                    case PatchOperation.OP_DEL: {
-                        delOpIndexList.add(patchOperation.index);
-                        break;
-                    }
-                    case PatchOperation.OP_ADD: {
-                        addOpIndexList.add(patchOperation.index);
-                        newItemList.add(patchOperation.newItem);
-                        break;
-                    }
-                    case PatchOperation.OP_REPLACE: {
-                        replaceOpIndexList.add(patchOperation.index);
-                        newItemList.add(patchOperation.newItem);
-                        break;
-                    }
+    private <T extends Comparable<T>> void writePatchOperations(
+            DexDataBuffer buffer, List<PatchOperation<T>> patchOperationList
+    ) {
+        List<Integer> delOpIndexList = new ArrayList<>(patchOperationList.size());
+        List<Integer> addOpIndexList = new ArrayList<>(patchOperationList.size());
+        List<Integer> replaceOpIndexList = new ArrayList<>(patchOperationList.size());
+        List<T> newItemList = new ArrayList<>(patchOperationList.size());
+
+        for (PatchOperation<T> patchOperation : patchOperationList) {
+            switch (patchOperation.op) {
+                case PatchOperation.OP_DEL: {
+                    delOpIndexList.add(patchOperation.index);
+                    break;
+                }
+                case PatchOperation.OP_ADD: {
+                    addOpIndexList.add(patchOperation.index);
+                    newItemList.add(patchOperation.newItem);
+                    break;
+                }
+                case PatchOperation.OP_REPLACE: {
+                    replaceOpIndexList.add(patchOperation.index);
+                    newItemList.add(patchOperation.newItem);
+                    break;
                 }
             }
+        }
 
-            buffer.writeUleb128(delOpIndexList.size());
-            int lastIndex = 0;
-            for (Integer index : delOpIndexList) {
-                buffer.writeSleb128(index - lastIndex);
-                lastIndex = index;
-            }
+        buffer.writeUleb128(delOpIndexList.size());
+        int lastIndex = 0;
+        for (Integer index : delOpIndexList) {
+            buffer.writeSleb128(index - lastIndex);
+            lastIndex = index;
+        }
 
-            buffer.writeUleb128(addOpIndexList.size());
-            lastIndex = 0;
-            for (Integer index : addOpIndexList) {
-                buffer.writeSleb128(index - lastIndex);
-                lastIndex = index;
-            }
+        buffer.writeUleb128(addOpIndexList.size());
+        lastIndex = 0;
+        for (Integer index : addOpIndexList) {
+            buffer.writeSleb128(index - lastIndex);
+            lastIndex = index;
+        }
 
-            buffer.writeUleb128(replaceOpIndexList.size());
-            lastIndex = 0;
-            for (Integer index : replaceOpIndexList) {
-                buffer.writeSleb128(index - lastIndex);
-                lastIndex = index;
-            }
+        buffer.writeUleb128(replaceOpIndexList.size());
+        lastIndex = 0;
+        for (Integer index : replaceOpIndexList) {
+            buffer.writeSleb128(index - lastIndex);
+            lastIndex = index;
+        }
 
-            for (T newItem : newItemList) {
-                writeItem(buffer, newItem);
+        for (T newItem : newItemList) {
+            if (newItem instanceof StringData) {
+                buffer.writeStringData((StringData) newItem);
+            } else
+            if (newItem instanceof Integer) {
+                // TypeId item.
+                buffer.writeInt((Integer) newItem);
+            } else
+            if (newItem instanceof TypeList) {
+                buffer.writeTypeList((TypeList) newItem);
+            } else
+            if (newItem instanceof ProtoId) {
+                buffer.writeProtoId((ProtoId) newItem);
+            } else
+            if (newItem instanceof FieldId) {
+                buffer.writeFieldId((FieldId) newItem);
+            } else
+            if (newItem instanceof MethodId) {
+                buffer.writeMethodId((MethodId) newItem);
+            } else
+            if (newItem instanceof Annotation) {
+                buffer.writeAnnotation((Annotation) newItem);
+            } else
+            if (newItem instanceof AnnotationSet) {
+                buffer.writeAnnotationSet((AnnotationSet) newItem);
+            } else
+            if (newItem instanceof AnnotationSetRefList) {
+                buffer.writeAnnotationSetRefList(
+                        (AnnotationSetRefList) newItem
+                );
+            } else
+            if (newItem instanceof AnnotationsDirectory) {
+                buffer.writeAnnotationsDirectory(
+                        (AnnotationsDirectory) newItem
+                );
+            } else
+            if (newItem instanceof DebugInfoItem) {
+                buffer.writeDebugInfoItem((DebugInfoItem) newItem);
+            } else
+            if (newItem instanceof Code) {
+                buffer.writeCode((Code) newItem);
+            } else
+            if (newItem instanceof ClassData) {
+                buffer.writeClassData((ClassData) newItem);
+            } else
+            if (newItem instanceof EncodedValue) {
+                buffer.writeEncodedArray((EncodedValue) newItem);
+            } else
+            if (newItem instanceof ClassDef) {
+                buffer.writeClassDef((ClassDef) newItem);
+            } else {
+                throw new IllegalStateException(
+                        "Unknown item type: " + newItem.getClass()
+                );
             }
         }
     }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSectionDiffAlgorithm.java
index 3d07d29e..d9979724 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class AnnotationSectionDiffAlgorithm extends DexSectionDiffAlgorithm<Annotation> {
-    public AnnotationSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public AnnotationSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(Annotation item) {
     }
 
     @Override
-    protected Annotation adjustItem(IndexMap indexMap, Annotation item) {
+    protected Annotation adjustItem(AbstractIndexMap indexMap, Annotation item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapAnnotationOffset(oldOffset, newOffset);
+            sparseIndexMap.mapAnnotationOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markAnnotationDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markAnnotationDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSetRefListSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSetRefListSectionDiffAlgorithm.java
index b8561637..27971231 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSetRefListSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSetRefListSectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class AnnotationSetRefListSectionDiffAlgorithm extends DexSectionDiffAlgorithm<AnnotationSetRefList> {
-    public AnnotationSetRefListSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public AnnotationSetRefListSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(AnnotationSetRefList item) {
     }
 
     @Override
-    protected AnnotationSetRefList adjustItem(IndexMap indexMap, AnnotationSetRefList item) {
+    protected AnnotationSetRefList adjustItem(AbstractIndexMap indexMap, AnnotationSetRefList item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapAnnotationSetRefListOffset(oldOffset, newOffset);
+            sparseIndexMap.mapAnnotationSetRefListOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markAnnotationSetRefListDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markAnnotationSetRefListDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSetSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSetSectionDiffAlgorithm.java
index 98f02533..557713d4 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSetSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationSetSectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class AnnotationSetSectionDiffAlgorithm extends DexSectionDiffAlgorithm<AnnotationSet> {
-    public AnnotationSetSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public AnnotationSetSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(AnnotationSet item) {
     }
 
     @Override
-    protected AnnotationSet adjustItem(IndexMap indexMap, AnnotationSet item) {
+    protected AnnotationSet adjustItem(AbstractIndexMap indexMap, AnnotationSet item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapAnnotationSetOffset(oldOffset, newOffset);
+            sparseIndexMap.mapAnnotationSetOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markAnnotationSetDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markAnnotationSetDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationsDirectorySectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationsDirectorySectionDiffAlgorithm.java
index a72a15ca..5c4f9ffb 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationsDirectorySectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/AnnotationsDirectorySectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class AnnotationsDirectorySectionDiffAlgorithm extends DexSectionDiffAlgorithm<AnnotationsDirectory> {
-    public AnnotationsDirectorySectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public AnnotationsDirectorySectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(AnnotationsDirectory item) {
     }
 
     @Override
-    protected AnnotationsDirectory adjustItem(IndexMap indexMap, AnnotationsDirectory item) {
+    protected AnnotationsDirectory adjustItem(AbstractIndexMap indexMap, AnnotationsDirectory item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapAnnotationsDirectoryOffset(oldOffset, newOffset);
+            sparseIndexMap.mapAnnotationsDirectoryOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markAnnotationsDirectoryDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markAnnotationsDirectoryDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ClassDataSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ClassDataSectionDiffAlgorithm.java
index addf7b0d..e835b6b9 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ClassDataSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ClassDataSectionDiffAlgorithm.java
@@ -21,7 +21,8 @@
 import com.tencent.tinker.android.dex.SizeOf;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 import java.util.Collection;
 import java.util.HashSet;
@@ -33,7 +34,7 @@
 public class ClassDataSectionDiffAlgorithm extends DexSectionDiffAlgorithm<ClassData> {
     private Set<Integer> offsetOfClassDataToRemoveSet = new HashSet<>();
 
-    public ClassDataSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public ClassDataSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -62,7 +63,7 @@ protected int getItemSize(ClassData item) {
     }
 
     @Override
-    protected ClassData adjustItem(IndexMap indexMap, ClassData item) {
+    protected ClassData adjustItem(AbstractIndexMap indexMap, ClassData item) {
         return indexMap.adjust(item);
     }
 
@@ -78,14 +79,14 @@ protected boolean shouldSkipInNewDex(ClassData newItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapClassDataOffset(oldOffset, newOffset);
+            sparseIndexMap.mapClassDataOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markClassDataDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markClassDataDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ClassDefSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ClassDefSectionDiffAlgorithm.java
index ebb558c7..8d8c8867 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ClassDefSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ClassDefSectionDiffAlgorithm.java
@@ -21,7 +21,8 @@
 import com.tencent.tinker.android.dex.SizeOf;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 import java.util.Collection;
 import java.util.HashSet;
@@ -33,7 +34,7 @@
 public class ClassDefSectionDiffAlgorithm extends DexSectionDiffAlgorithm<ClassDef> {
     private Set<Integer> typeIdOfClassDefToRemoveSet = new HashSet<>();
 
-    public ClassDefSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public ClassDefSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -67,7 +68,7 @@ protected int getItemSize(ClassDef item) {
     }
 
     @Override
-    protected ClassDef adjustItem(IndexMap indexMap, ClassDef item) {
+    protected ClassDef adjustItem(AbstractIndexMap indexMap, ClassDef item) {
         return indexMap.adjust(item);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/CodeSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/CodeSectionDiffAlgorithm.java
index 2672f9ca..7a4e24c2 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/CodeSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/CodeSectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class CodeSectionDiffAlgorithm extends DexSectionDiffAlgorithm<Code> {
-    public CodeSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public CodeSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(Code item) {
     }
 
     @Override
-    protected Code adjustItem(IndexMap indexMap, Code item) {
+    protected Code adjustItem(AbstractIndexMap indexMap, Code item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapCodeOffset(oldOffset, newOffset);
+            sparseIndexMap.mapCodeOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markCodeDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markCodeDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DebugInfoItemSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DebugInfoItemSectionDiffAlgorithm.java
index 5c329203..c5135ba7 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DebugInfoItemSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DebugInfoItemSectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class DebugInfoItemSectionDiffAlgorithm extends DexSectionDiffAlgorithm<DebugInfoItem> {
-    public DebugInfoItemSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public DebugInfoItemSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(DebugInfoItem item) {
     }
 
     @Override
-    protected DebugInfoItem adjustItem(IndexMap indexMap, DebugInfoItem item) {
+    protected DebugInfoItem adjustItem(AbstractIndexMap indexMap, DebugInfoItem item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapDebugInfoItemOffset(oldOffset, newOffset);
+            sparseIndexMap.mapDebugInfoItemOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markDebugInfoItemDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markDebugInfoItemDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java
index 9bf57a8e..75cd2e7f 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/DexSectionDiffAlgorithm.java
@@ -22,8 +22,9 @@
 import com.tencent.tinker.android.dex.TableOfContents.Section.Item;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
 import com.tencent.tinker.android.dex.util.CompareUtils;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.PatchOperation;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 import java.util.AbstractMap;
 import java.util.ArrayList;
@@ -43,24 +44,24 @@
     protected final Dex oldDex;
     protected final Dex newDex;
     /**
-     * IndexMap for mapping items between old dex and new dex.
+     * SparseIndexMap for mapping items between old dex and new dex.
      * e.g. item.oldIndex => item.newIndex
      */
-    private final IndexMap oldToNewIndexMap;
+    private final SparseIndexMap oldToNewIndexMap;
     /**
-     * IndexMap for mapping items between old dex and patched dex.
+     * SparseIndexMap for mapping items between old dex and patched dex.
      * e.g. item.oldIndex => item.patchedIndex
      */
-    private final IndexMap oldToPatchedIndexMap;
+    private final SparseIndexMap oldToPatchedIndexMap;
     /**
-     * IndexMap for mapping items between new dex and patched dex.
+     * SparseIndexMap for mapping items between new dex and patched dex.
      * e.g. item.newIndex => item.newIndexInPatchedDex
      */
-    private final IndexMap newToPatchedIndexMap;
+    private final SparseIndexMap newToPatchedIndexMap;
     /**
-     * IndexMap for mapping items in new dex when skip items.
+     * SparseIndexMap for mapping items in new dex when skip items.
      */
-    private final IndexMap selfIndexMapForSkip;
+    private final SparseIndexMap selfIndexMapForSkip;
     private final List<PatchOperation<T>> patchOperationList;
     private final Map<Integer, PatchOperation<T>> indexToDelOperationMap = new HashMap<>();
     private final Map<Integer, PatchOperation<T>> indexToAddOperationMap = new HashMap<>();
@@ -118,10 +119,10 @@ public int compare(PatchOperation<T> o1, PatchOperation<T> o2) {
     public DexSectionDiffAlgorithm(
             Dex oldDex,
             Dex newDex,
-            IndexMap oldToNewIndexMap,
-            IndexMap oldToPatchedIndexMap,
-            IndexMap newToPatchedIndexMap,
-            IndexMap selfIndexMapForSkip
+            SparseIndexMap oldToNewIndexMap,
+            SparseIndexMap oldToPatchedIndexMap,
+            SparseIndexMap newToPatchedIndexMap,
+            SparseIndexMap selfIndexMapForSkip
     ) {
         this.oldDex = oldDex;
         this.newDex = newDex;
@@ -157,9 +158,9 @@ public int getPatchedSectionSize() {
     protected abstract int getItemSize(T item);
 
     /**
-     * Adjust {@code item} using specific {@code indexMap}
+     * Adjust {@code item} using specific {@code sparseIndexMap}
      */
-    protected T adjustItem(IndexMap indexMap, T item) {
+    protected T adjustItem(AbstractIndexMap indexMap, T item) {
         return item;
     }
 
@@ -171,16 +172,26 @@ protected boolean shouldSkipInNewDex(T newItem) {
     }
 
     /**
-     * Update index or offset mapping in {@code indexMap}.
+     * Update index or offset mapping in {@code sparseIndexMap}.
      */
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         // Should override by subclass if needed.
     }
 
     /**
-     * Mark deleted index or offset in {@code indexMap}.
+     * Mark deleted index or offset in {@code sparseIndexMap}.
+     *
+     * Here we mark deleted item for such a case like this:
+     *   Item in DebugInfo section reference a string in StringData section
+     *   by index X, while in patched dex, the referenced string is removed.
+     *
+     * The {@code sparseIndexMap} must be aware of this case and return -1
+     * instead of the original value X.
+     *
+     * Further more, the special value -1 is not chosen by our inspiration but
+     * the definition of NO_INDEX in document of dex file format.
      */
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
         // Should override by subclass if needed.
     }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/FieldIdSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/FieldIdSectionDiffAlgorithm.java
index f1751361..5511e264 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/FieldIdSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/FieldIdSectionDiffAlgorithm.java
@@ -21,13 +21,14 @@
 import com.tencent.tinker.android.dex.SizeOf;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class FieldIdSectionDiffAlgorithm extends DexSectionDiffAlgorithm<FieldId> {
-    public FieldIdSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public FieldIdSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -47,19 +48,19 @@ protected int getItemSize(FieldId item) {
     }
 
     @Override
-    protected FieldId adjustItem(IndexMap indexMap, FieldId item) {
+    protected FieldId adjustItem(AbstractIndexMap indexMap, FieldId item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapFieldIds(oldIndex, newIndex);
+            sparseIndexMap.mapFieldIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markFieldIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markFieldIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/MethodIdSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/MethodIdSectionDiffAlgorithm.java
index 4456dacb..2320bed2 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/MethodIdSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/MethodIdSectionDiffAlgorithm.java
@@ -21,13 +21,14 @@
 import com.tencent.tinker.android.dex.SizeOf;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class MethodIdSectionDiffAlgorithm extends DexSectionDiffAlgorithm<MethodId> {
-    public MethodIdSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public MethodIdSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -47,19 +48,19 @@ protected int getItemSize(MethodId item) {
     }
 
     @Override
-    protected MethodId adjustItem(IndexMap indexMap, MethodId item) {
+    protected MethodId adjustItem(AbstractIndexMap indexMap, MethodId item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapMethodIds(oldIndex, newIndex);
+            sparseIndexMap.mapMethodIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markMethodIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markMethodIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ProtoIdSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ProtoIdSectionDiffAlgorithm.java
index fcec419b..aa495b5f 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ProtoIdSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/ProtoIdSectionDiffAlgorithm.java
@@ -21,13 +21,14 @@
 import com.tencent.tinker.android.dex.SizeOf;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class ProtoIdSectionDiffAlgorithm extends DexSectionDiffAlgorithm<ProtoId> {
-    public ProtoIdSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public ProtoIdSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -47,19 +48,19 @@ protected int getItemSize(ProtoId item) {
     }
 
     @Override
-    protected ProtoId adjustItem(IndexMap indexMap, ProtoId item) {
+    protected ProtoId adjustItem(AbstractIndexMap indexMap, ProtoId item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapProtoIds(oldIndex, newIndex);
+            sparseIndexMap.mapProtoIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markProtoIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markProtoIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/StaticValueSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/StaticValueSectionDiffAlgorithm.java
index 51e7a223..974eadb8 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/StaticValueSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/StaticValueSectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.EncodedValue;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class StaticValueSectionDiffAlgorithm extends DexSectionDiffAlgorithm<EncodedValue> {
-    public StaticValueSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public StaticValueSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(EncodedValue item) {
     }
 
     @Override
-    protected EncodedValue adjustItem(IndexMap indexMap, EncodedValue item) {
+    protected EncodedValue adjustItem(AbstractIndexMap indexMap, EncodedValue item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapStaticValuesOffset(oldOffset, newOffset);
+            sparseIndexMap.mapStaticValuesOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markStaticValuesDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markStaticValuesDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/StringDataSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/StringDataSectionDiffAlgorithm.java
index e75a9c37..aed29a38 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/StringDataSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/StringDataSectionDiffAlgorithm.java
@@ -20,13 +20,13 @@
 import com.tencent.tinker.android.dex.StringData;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class StringDataSectionDiffAlgorithm extends DexSectionDiffAlgorithm<StringData> {
-    public StringDataSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public StringDataSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,14 +46,14 @@ protected int getItemSize(StringData item) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapStringIds(oldIndex, newIndex);
+            sparseIndexMap.mapStringIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markStringIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markStringIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/TypeIdSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/TypeIdSectionDiffAlgorithm.java
index e9b3dd75..cdfe82bb 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/TypeIdSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/TypeIdSectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.SizeOf;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class TypeIdSectionDiffAlgorithm extends DexSectionDiffAlgorithm<Integer> {
-    public TypeIdSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public TypeIdSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(Integer item) {
     }
 
     @Override
-    protected Integer adjustItem(IndexMap indexMap, Integer item) {
+    protected Integer adjustItem(AbstractIndexMap indexMap, Integer item) {
         return indexMap.adjustStringIndex(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapTypeIds(oldIndex, newIndex);
+            sparseIndexMap.mapTypeIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markTypeIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markTypeIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/TypeListSectionDiffAlgorithm.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/TypeListSectionDiffAlgorithm.java
index 2562600e..3ce0061e 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/TypeListSectionDiffAlgorithm.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/algorithms/diff/TypeListSectionDiffAlgorithm.java
@@ -20,13 +20,14 @@
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.TypeList;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/6/30.
  */
 public class TypeListSectionDiffAlgorithm extends DexSectionDiffAlgorithm<TypeList> {
-    public TypeListSectionDiffAlgorithm(Dex oldDex, Dex newDex, IndexMap oldToNewIndexMap, IndexMap oldToPatchedIndexMap, IndexMap newToPatchedIndexMap, IndexMap selfIndexMapForSkip) {
+    public TypeListSectionDiffAlgorithm(Dex oldDex, Dex newDex, SparseIndexMap oldToNewIndexMap, SparseIndexMap oldToPatchedIndexMap, SparseIndexMap newToPatchedIndexMap, SparseIndexMap selfIndexMapForSkip) {
         super(oldDex, newDex, oldToNewIndexMap, oldToPatchedIndexMap, newToPatchedIndexMap, selfIndexMapForSkip);
     }
 
@@ -46,19 +47,19 @@ protected int getItemSize(TypeList item) {
     }
 
     @Override
-    protected TypeList adjustItem(IndexMap indexMap, TypeList item) {
+    protected TypeList adjustItem(AbstractIndexMap indexMap, TypeList item) {
         return indexMap.adjust(item);
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapTypeListOffset(oldOffset, newOffset);
+            sparseIndexMap.mapTypeListOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markTypeListDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markTypeListDeleted(deletedOffset);
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/OffsetToIndexConverter.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/OffsetToIndexConverter.java
deleted file mode 100644
index 80673a8a..00000000
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/OffsetToIndexConverter.java
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.build.dexpatcher.util;
-
-import com.tencent.tinker.android.dex.Dex;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Created by tangyinsheng on 2016/9/11.
- */
-public final class OffsetToIndexConverter {
-    private final Map<Integer, Integer> typeListOffsetToIndexMap = new HashMap<>();
-    private final Map<Integer, Integer> classDataOffsetToIndexMap = new HashMap<>();
-    private final Map<Integer, Integer> encodedArrayOffsetToIndexMap = new HashMap<>();
-    private final Map<Integer, Integer> annotationOffsetToIndexMap = new HashMap<>();
-    private final Map<Integer, Integer> annotationSetOffsetToIndexMap = new HashMap<>();
-    private final Map<Integer, Integer> annotationSetRefListOffsetToIndexMap = new HashMap<>();
-    private final Map<Integer, Integer> annotationsDirectoryOffsetToIndexMap = new HashMap<>();
-    private final Map<Integer, Integer> codeOffsetToIndexMap = new HashMap<>();
-    private final Map<Integer, Integer> debugInfoItemOffsetToIndexMap = new HashMap<>();
-
-    public OffsetToIndexConverter(Dex dex) {
-        if (dex == null) {
-            throw new IllegalArgumentException("dex is null.");
-        }
-
-        if (dex.getTableOfContents().typeLists.exists()) {
-            Dex.Section typeListSec = dex.openSection(dex.getTableOfContents().typeLists);
-            int typeListCount = dex.getTableOfContents().typeLists.size;
-            for (int i = 0; i < typeListCount; ++i) {
-                typeListOffsetToIndexMap.put(typeListSec.readTypeList().off, i);
-            }
-        }
-
-        if (dex.getTableOfContents().classDatas.exists()) {
-            Dex.Section classDataSec = dex.openSection(dex.getTableOfContents().classDatas);
-            int classDataCount = dex.getTableOfContents().classDatas.size;
-            for (int i = 0; i < classDataCount; ++i) {
-                classDataOffsetToIndexMap.put(classDataSec.readClassData().off, i);
-            }
-        }
-
-        if (dex.getTableOfContents().encodedArrays.exists()) {
-            Dex.Section encodedArraySec = dex.openSection(dex.getTableOfContents().encodedArrays);
-            int encodedArrayCount = dex.getTableOfContents().encodedArrays.size;
-            for (int i = 0; i < encodedArrayCount; ++i) {
-                encodedArrayOffsetToIndexMap.put(encodedArraySec.readEncodedArray().off, i);
-            }
-        }
-
-        if (dex.getTableOfContents().annotations.exists()) {
-            Dex.Section annotationSec = dex.openSection(dex.getTableOfContents().annotations);
-            int annotationCount = dex.getTableOfContents().annotations.size;
-            for (int i = 0; i < annotationCount; ++i) {
-                annotationOffsetToIndexMap.put(annotationSec.readAnnotation().off, i);
-            }
-        }
-
-        if (dex.getTableOfContents().annotationSets.exists()) {
-            Dex.Section annotationSetSec = dex.openSection(dex.getTableOfContents().annotationSets);
-            int annotationSetCount = dex.getTableOfContents().annotationSets.size;
-            for (int i = 0; i < annotationSetCount; ++i) {
-                annotationSetOffsetToIndexMap.put(annotationSetSec.readAnnotationSet().off, i);
-            }
-        }
-
-        if (dex.getTableOfContents().annotationSetRefLists.exists()) {
-            Dex.Section annotationSetRefListSec = dex.openSection(dex.getTableOfContents().annotationSetRefLists);
-            int annotationSetRefListCount = dex.getTableOfContents().annotationSetRefLists.size;
-            for (int i = 0; i < annotationSetRefListCount; ++i) {
-                annotationSetRefListOffsetToIndexMap.put(annotationSetRefListSec.readAnnotationSetRefList().off, i);
-            }
-        }
-
-        if (dex.getTableOfContents().annotationsDirectories.exists()) {
-            Dex.Section annotationsDirectorySec = dex.openSection(dex.getTableOfContents().annotationsDirectories);
-            int annotationsDirectoryCount = dex.getTableOfContents().annotationsDirectories.size;
-            for (int i = 0; i < annotationsDirectoryCount; ++i) {
-                annotationsDirectoryOffsetToIndexMap.put(annotationsDirectorySec.readAnnotationsDirectory().off, i);
-            }
-        }
-
-        if (dex.getTableOfContents().codes.exists()) {
-            Dex.Section codeSec = dex.openSection(dex.getTableOfContents().codes);
-            int codeCount = dex.getTableOfContents().codes.size;
-            for (int i = 0; i < codeCount; ++i) {
-                codeOffsetToIndexMap.put(codeSec.readCode().off, i);
-            }
-        }
-
-        if (dex.getTableOfContents().debugInfos.exists()) {
-            Dex.Section debugInfoItemSec = dex.openSection(dex.getTableOfContents().debugInfos);
-            int debugInfoItemCount = dex.getTableOfContents().debugInfos.size;
-            for (int i = 0; i < debugInfoItemCount; ++i) {
-                debugInfoItemOffsetToIndexMap.put(debugInfoItemSec.readDebugInfoItem().off, i);
-            }
-        }
-    }
-
-    public int getTypeListIndexByOffset(int offset) {
-        if (typeListOffsetToIndexMap.containsKey(offset)) {
-            return typeListOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-
-    public int getClassDataIndexByOffset(int offset) {
-        if (classDataOffsetToIndexMap.containsKey(offset)) {
-            return classDataOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-
-    public int getEncodedArrayIndexByOffset(int offset) {
-        if (encodedArrayOffsetToIndexMap.containsKey(offset)) {
-            return encodedArrayOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-
-    public int getAnnotationIndexByOffset(int offset) {
-        if (annotationOffsetToIndexMap.containsKey(offset)) {
-            return annotationOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-
-    public int getAnnotationSetIndexByOffset(int offset) {
-        if (annotationSetOffsetToIndexMap.containsKey(offset)) {
-            return annotationSetOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-
-    public int getAnnotationSetRefListIndexByOffset(int offset) {
-        if (annotationSetRefListOffsetToIndexMap.containsKey(offset)) {
-            return annotationSetRefListOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-
-    public int getAnnotationsDirectoryIndexByOffset(int offset) {
-        if (annotationsDirectoryOffsetToIndexMap.containsKey(offset)) {
-            return annotationsDirectoryOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-
-    public int getCodeIndexByOffset(int offset) {
-        if (codeOffsetToIndexMap.containsKey(offset)) {
-            return codeOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-
-    public int getDebugInfoItemIndexByOffset(int offset) {
-        if (debugInfoItemOffsetToIndexMap.containsKey(offset)) {
-            return debugInfoItemOffsetToIndexMap.get(offset);
-        } else {
-            throw new IllegalArgumentException("cannot find corresponding index of offset: " + offset);
-        }
-    }
-}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java
deleted file mode 100644
index dd805303..00000000
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/SmallDexPatchGenerator.java
+++ /dev/null
@@ -1,1965 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.build.dexpatcher.util;
-
-import com.tencent.tinker.android.dex.Annotation;
-import com.tencent.tinker.android.dex.AnnotationSet;
-import com.tencent.tinker.android.dex.AnnotationSetRefList;
-import com.tencent.tinker.android.dex.AnnotationsDirectory;
-import com.tencent.tinker.android.dex.ClassData;
-import com.tencent.tinker.android.dex.ClassDef;
-import com.tencent.tinker.android.dex.Code;
-import com.tencent.tinker.android.dex.DebugInfoItem;
-import com.tencent.tinker.android.dex.Dex;
-import com.tencent.tinker.android.dex.DexException;
-import com.tencent.tinker.android.dex.EncodedValue;
-import com.tencent.tinker.android.dex.EncodedValueReader;
-import com.tencent.tinker.android.dex.FieldId;
-import com.tencent.tinker.android.dex.Leb128;
-import com.tencent.tinker.android.dex.MethodId;
-import com.tencent.tinker.android.dex.ProtoId;
-import com.tencent.tinker.android.dex.SizeOf;
-import com.tencent.tinker.android.dex.StringData;
-import com.tencent.tinker.android.dex.TableOfContents;
-import com.tencent.tinker.android.dex.TypeList;
-import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dex.util.ByteInput;
-import com.tencent.tinker.android.dx.instruction.InstructionCodec;
-import com.tencent.tinker.android.dx.instruction.InstructionReader;
-import com.tencent.tinker.android.dx.instruction.InstructionVisitor;
-import com.tencent.tinker.android.dx.instruction.ShortArrayCodeInput;
-import com.tencent.tinker.android.dx.util.Hex;
-import com.tencent.tinker.android.dx.util.IndexMap;
-import com.tencent.tinker.build.util.DexClassesComparator;
-import com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
-import com.tencent.tinker.build.util.DexClassesComparator.DexGroup;
-import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
-import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger.IDexPatcherLogger;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
-
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayInputStream;
-import java.io.EOFException;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * Created by tangyinsheng on 2016/8/8.
- */
-public final class SmallDexPatchGenerator {
-    private static final String TAG = "SmallDexPatchGenerator";
-
-    private final List<DexGroup> oldDexGroups = new ArrayList<>();
-    private final List<DexGroup> patchedDexGroups = new ArrayList<>();
-
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedStringIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedTypeIdIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedTypeListIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedProtoIdIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedFieldIdIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedMethodIdIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedAnnotationIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedAnnotationSetIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedAnnotationSetRefListIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedAnnotationsDirectoryIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedEncodedArrayIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedDebugInfoIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedCodeIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedClassDataIndicesMap = new HashMap<>();
-    private final Map<Dex, Set<Integer>>
-            patchedDexToCollectedClassDefIndicesMap = new HashMap<>();
-
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedStringIdOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedTypeIdOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedProtoIdOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedFieldIdOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedMethodIdOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedClassDefOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedMapListOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedTypeListOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedAnnotationSetRefListOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedAnnotationSetOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedClassDataOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedCodeOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedStringDataOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedDebugInfoOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedAnnotationOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedEncodedArrayOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedAnnotationsDirectoryOffsetMap = new HashMap<>();
-    private final Map<Dex, Integer>
-            patchedDexToSmallPatchedDexSizeMap = new HashMap<>();
-
-    private final Set<String> loaderClassPatterns = new HashSet<>();
-
-    private final DexPatcherLogger logger = new DexPatcherLogger();
-
-    public void addLoaderClassPattern(String pattern) {
-        this.loaderClassPatterns.add(pattern);
-    }
-
-    public void setLoaderClassPatterns(Collection<String> patterns) {
-        this.loaderClassPatterns.clear();
-        this.loaderClassPatterns.addAll(patterns);
-    }
-
-    public void clearLoaderClassPatterns() {
-        this.loaderClassPatterns.clear();
-    }
-
-    public void setLogger(IDexPatcherLogger logger) {
-        this.logger.setLoggerImpl(logger);
-    }
-
-    public SmallDexPatchGenerator appendDexGroup(DexGroup oldDexGroup, DexGroup patchedDexGroup) {
-        if (oldDexGroup == null) {
-            throw new IllegalArgumentException("oldDexGroup is null.");
-        }
-        if (patchedDexGroup == null) {
-            throw new IllegalArgumentException("patchedDexGroup is null.");
-        }
-
-        this.oldDexGroups.add(oldDexGroup);
-        this.patchedDexGroups.add(patchedDexGroup);
-
-        // Build map between patched dex and old dex, which is used in next logic.
-        if (oldDexGroup.dexes.length != patchedDexGroup.dexes.length) {
-            throw new IllegalArgumentException(
-                    "dex count in oldDexGroup is not matched to dex count in patchedDexGroup."
-            );
-        }
-
-        return this;
-    }
-
-    public void executeAndSaveTo(File out) throws IOException {
-        OutputStream os = null;
-        try {
-            os = new BufferedOutputStream(new FileOutputStream(out));
-            executeAndSaveTo(os);
-        } finally {
-            if (os != null) {
-                try {
-                    os.close();
-                } catch (Exception e) {
-                    // ignored.
-                }
-            }
-        }
-    }
-
-    public void executeAndSaveTo(OutputStream os) throws IOException {
-        int dexGroupCount = this.oldDexGroups.size();
-
-        // Collect all items that should be exist in small patched dex.
-        for (int i = 0; i < dexGroupCount; ++i) {
-            DexGroup oldDexGroup = oldDexGroups.get(i);
-            DexGroup patchedDexGroup = patchedDexGroups.get(i);
-
-            collectItemIndicesFromDexGroup(oldDexGroup, patchedDexGroup);
-            calculateSmallPatchedSectionOffsets(oldDexGroup, patchedDexGroup);
-        }
-
-        saveToStream(os);
-    }
-
-    private void calculateSmallPatchedSectionOffsets(
-            DexGroup oldDexGroup, DexGroup patchedDexGroup
-    ) {
-        if (oldDexGroup.dexes.length != patchedDexGroup.dexes.length) {
-            throw new IllegalStateException("dex group contains different amount of dexes.");
-        }
-        int dexCount = oldDexGroup.dexes.length;
-        for (int dexId = 0; dexId < dexCount; ++dexId) {
-            Dex oldDex = oldDexGroup.dexes[dexId];
-            Dex patchedDex = patchedDexGroup.dexes[dexId];
-
-            final String currOldDexSignStr = Hex.toHexString(oldDex.computeSignature(false));
-
-            IndexMap fullToSmallPatchIndexMap = new IndexMap();
-
-            // For calculating size of mapList soon.
-            // Initialize it to 2 means a dex must contains two sections: header
-            // and mapList.
-            int smallPatchedSectionCount = 2;
-
-            // In next steps we do a bunch of simulations to calculate actual sizes of
-            // each section in small patched dex.
-
-            // First, calculate header and id sections size, so that we can work out
-            // base offsets of data sections soon.
-            int smallPatchedHeaderSize = SizeOf.HEADER_ITEM;
-            int collectedStringIndicesCount = getCollectedIndicesCountSafely(
-                    patchedDexToCollectedStringIndicesMap, patchedDex
-            );
-            int smallPatchedStringIdsSize = collectedStringIndicesCount * SizeOf.STRING_ID_ITEM;
-            if (smallPatchedHeaderSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-            int collectedTypeIndicesCount = getCollectedIndicesCountSafely(
-                    patchedDexToCollectedTypeIdIndicesMap, patchedDex
-            );
-            int smallPatchedTypeIdsSize = collectedTypeIndicesCount * SizeOf.TYPE_ID_ITEM;
-            if (smallPatchedTypeIdsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            // Although simulatePatchOperation can calculate this value, since protoIds section
-            // depends on typeLists section, we can't run protoIds Section's simulatePatchOperation
-            // method so far. Instead we calculate protoIds section's size using information we known
-            // directly.
-            int collectedProtoIdsIndicesCount = getCollectedIndicesCountSafely(
-                    patchedDexToCollectedProtoIdIndicesMap, patchedDex
-            );
-            int smallPatchedProtoIdsSize = collectedProtoIdsIndicesCount * SizeOf.PROTO_ID_ITEM;
-            if (smallPatchedProtoIdsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int collectedFieldIdsIndicesCount = getCollectedIndicesCountSafely(
-                    patchedDexToCollectedFieldIdIndicesMap, patchedDex
-            );
-            int smallPatchedFieldIdsSize = collectedFieldIdsIndicesCount * SizeOf.MEMBER_ID_ITEM;
-            if (smallPatchedFieldIdsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-            int collectedMethodIdsIndicesCount = getCollectedIndicesCountSafely(
-                    patchedDexToCollectedMethodIdIndicesMap, patchedDex
-            );
-            int smallPatchedMethodIdsSize = collectedMethodIdsIndicesCount * SizeOf.MEMBER_ID_ITEM;
-            if (smallPatchedMethodIdsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-            int collectedClassDefsIndicesCount = getCollectedIndicesCountSafely(
-                    patchedDexToCollectedClassDefIndicesMap, patchedDex
-            );
-            int smallPatchedClassDefsSize = collectedClassDefsIndicesCount * SizeOf.CLASS_DEF_ITEM;
-            if (smallPatchedClassDefsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedIdSectionSize =
-                    smallPatchedStringIdsSize
-                            + smallPatchedTypeIdsSize
-                            + smallPatchedProtoIdsSize
-                            + smallPatchedFieldIdsSize
-                            + smallPatchedMethodIdsSize
-                            + smallPatchedClassDefsSize;
-
-            int smallPatchedHeaderOffset = 0;
-
-            int smallPatchedStringIdsOffset = smallPatchedHeaderOffset + smallPatchedHeaderSize;
-            if (oldDex.getTableOfContents().stringIds.isElementFourByteAligned) {
-                smallPatchedStringIdsOffset = SizeOf.roundToTimesOfFour(smallPatchedStringIdsOffset);
-            }
-            patchedDexToSmallPatchedStringIdOffsetMap.put(patchedDex, smallPatchedStringIdsOffset);
-
-            int smallPatchedStringDatasOffset = smallPatchedHeaderSize + smallPatchedIdSectionSize;
-            if (oldDex.getTableOfContents().stringDatas.isElementFourByteAligned) {
-                smallPatchedStringDatasOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedStringDatasOffset);
-            }
-            patchedDexToSmallPatchedStringDataOffsetMap.put(patchedDex, smallPatchedStringDatasOffset);
-            int smallPatchedStringDataItemsSize = new SmallPatchSimulator<StringData>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().stringDatas,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedStringIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedStringDatasOffset);
-            if (smallPatchedStringDataItemsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedTypeIdsOffset
-                    = smallPatchedStringIdsOffset + smallPatchedStringIdsSize;
-            if (oldDex.getTableOfContents().typeIds.isElementFourByteAligned) {
-                smallPatchedTypeIdsOffset = SizeOf.roundToTimesOfFour(smallPatchedTypeIdsOffset);
-            }
-            patchedDexToSmallPatchedTypeIdOffsetMap.put(patchedDex, smallPatchedTypeIdsOffset);
-
-            int smallPatchedTypeListsOffset
-                    = smallPatchedHeaderSize
-                    + smallPatchedIdSectionSize
-                    + smallPatchedStringDataItemsSize;
-            if (oldDex.getTableOfContents().typeLists.isElementFourByteAligned) {
-                smallPatchedTypeListsOffset = SizeOf.roundToTimesOfFour(smallPatchedTypeListsOffset);
-            }
-            patchedDexToSmallPatchedTypeListOffsetMap.put(
-                    patchedDex, smallPatchedTypeListsOffset
-            );
-            int smallPatchedTypeListsSize = new SmallPatchSimulator<TypeList>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().typeLists,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedTypeListIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedTypeListsOffset);
-            if (smallPatchedTypeListsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedProtoIdsOffset
-                    = smallPatchedTypeIdsOffset + smallPatchedTypeIdsSize;
-            if (oldDex.getTableOfContents().protoIds.isElementFourByteAligned) {
-                smallPatchedProtoIdsOffset = SizeOf.roundToTimesOfFour(smallPatchedProtoIdsOffset);
-            }
-            patchedDexToSmallPatchedProtoIdOffsetMap.put(
-                    patchedDex, smallPatchedProtoIdsOffset
-            );
-
-            int smallPatchedFieldIdsOffset
-                    = smallPatchedProtoIdsOffset + smallPatchedProtoIdsSize;
-            if (oldDex.getTableOfContents().fieldIds.isElementFourByteAligned) {
-                smallPatchedFieldIdsOffset = SizeOf.roundToTimesOfFour(smallPatchedFieldIdsOffset);
-            }
-            patchedDexToSmallPatchedFieldIdOffsetMap.put(
-                    patchedDex, smallPatchedFieldIdsOffset
-            );
-
-            int smallPatchedMethodIdsOffset
-                    = smallPatchedFieldIdsOffset + smallPatchedFieldIdsSize;
-            if (oldDex.getTableOfContents().methodIds.isElementFourByteAligned) {
-                smallPatchedMethodIdsOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedMethodIdsOffset);
-            }
-            patchedDexToSmallPatchedMethodIdOffsetMap.put(
-                    patchedDex, smallPatchedMethodIdsOffset
-            );
-
-            int smallPatchedAnnotationsOffset
-                    = smallPatchedTypeListsOffset + smallPatchedTypeListsSize;
-            if (oldDex.getTableOfContents().annotations.isElementFourByteAligned) {
-                smallPatchedAnnotationsOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedAnnotationsOffset);
-            }
-            patchedDexToSmallPatchedAnnotationOffsetMap.put(
-                    patchedDex, smallPatchedAnnotationsOffset
-            );
-            int smallPatchedAnnotationsSize = new SmallPatchSimulator<Annotation>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().annotations,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedAnnotationIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedAnnotationsOffset);
-            if (smallPatchedAnnotationsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedAnnotationSetsOffset
-                    = smallPatchedAnnotationsOffset + smallPatchedAnnotationsSize;
-            if (oldDex.getTableOfContents().annotationSets.isElementFourByteAligned) {
-                smallPatchedAnnotationSetsOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedAnnotationSetsOffset);
-            }
-            patchedDexToSmallPatchedAnnotationSetOffsetMap.put(
-                    patchedDex, smallPatchedAnnotationSetsOffset
-            );
-            int smallPatchedAnnotationSetsSize = new SmallPatchSimulator<AnnotationSet>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().annotationSets,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedAnnotationSetIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedAnnotationSetsOffset);
-            if (smallPatchedAnnotationSetsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedAnnotationSetRefListsOffset
-                    = smallPatchedAnnotationSetsOffset
-                    + smallPatchedAnnotationSetsSize;
-            if (oldDex.getTableOfContents().annotationSetRefLists.isElementFourByteAligned) {
-                smallPatchedAnnotationSetRefListsOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedAnnotationSetRefListsOffset);
-            }
-            patchedDexToSmallPatchedAnnotationSetRefListOffsetMap.put(
-                    patchedDex, smallPatchedAnnotationSetRefListsOffset
-            );
-            int smallPatchedAnnotationSetRefListsSize
-                    = new SmallPatchSimulator<AnnotationSetRefList>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().annotationSetRefLists,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedAnnotationSetRefListIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedAnnotationSetRefListsOffset);
-            if (smallPatchedAnnotationSetRefListsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedAnnotationsDirectoriesOffset
-                    = smallPatchedAnnotationSetRefListsOffset
-                    + smallPatchedAnnotationSetRefListsSize;
-            if (oldDex.getTableOfContents().annotationsDirectories.isElementFourByteAligned) {
-                smallPatchedAnnotationsDirectoriesOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedAnnotationsDirectoriesOffset);
-            }
-            patchedDexToSmallPatchedAnnotationsDirectoryOffsetMap.put(
-                    patchedDex, smallPatchedAnnotationsDirectoriesOffset
-            );
-            int smallPatchedAnnotationsDirectoriesSize
-                    = new SmallPatchSimulator<AnnotationsDirectory>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().annotationsDirectories,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedAnnotationsDirectoryIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedAnnotationsDirectoriesOffset);
-            if (smallPatchedAnnotationsDirectoriesSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedDebugInfoItemsOffset
-                    = smallPatchedAnnotationsDirectoriesOffset
-                    + smallPatchedAnnotationsDirectoriesSize;
-            if (oldDex.getTableOfContents().debugInfos.isElementFourByteAligned) {
-                smallPatchedDebugInfoItemsOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedDebugInfoItemsOffset);
-            }
-            patchedDexToSmallPatchedDebugInfoOffsetMap.put(
-                    patchedDex, smallPatchedDebugInfoItemsOffset
-            );
-            int smallPatchedDebugInfoItemsSize = new SmallPatchSimulator<DebugInfoItem>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().debugInfos,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedDebugInfoIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedDebugInfoItemsOffset);
-            if (smallPatchedDebugInfoItemsSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedCodesOffset
-                    = smallPatchedDebugInfoItemsOffset
-                    + smallPatchedDebugInfoItemsSize;
-            if (oldDex.getTableOfContents().codes.isElementFourByteAligned) {
-                smallPatchedCodesOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedCodesOffset);
-            }
-            patchedDexToSmallPatchedCodeOffsetMap.put(
-                    patchedDex, smallPatchedCodesOffset
-            );
-            int smallPatchedCodesSize = new SmallPatchSimulator<Code>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().codes,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedCodeIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedCodesOffset);
-            if (smallPatchedCodesSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedClassDatasOffset
-                    = smallPatchedCodesOffset
-                    + smallPatchedCodesSize;
-            if (oldDex.getTableOfContents().classDatas.isElementFourByteAligned) {
-                smallPatchedClassDatasOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedClassDatasOffset);
-            }
-            patchedDexToSmallPatchedClassDataOffsetMap.put(
-                    patchedDex, smallPatchedClassDatasOffset
-            );
-            int smallPatchedClassDatasSize = new SmallPatchSimulator<ClassData>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().classDatas,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedClassDataIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedClassDatasOffset);
-            if (smallPatchedClassDatasSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedEncodedArraysOffset
-                    = smallPatchedClassDatasOffset
-                    + smallPatchedClassDatasSize;
-            if (oldDex.getTableOfContents().encodedArrays.isElementFourByteAligned) {
-                smallPatchedEncodedArraysOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedEncodedArraysOffset);
-            }
-            patchedDexToSmallPatchedEncodedArrayOffsetMap.put(
-                    patchedDex, smallPatchedEncodedArraysOffset
-            );
-            int smallPatchedEncodedArraysSize = new SmallPatchSimulator<EncodedValue>(
-                    patchedDex,
-                    patchedDex.getTableOfContents().encodedArrays,
-                    fullToSmallPatchIndexMap,
-                    patchedDexToCollectedEncodedArrayIndicesMap.get(patchedDex)
-            ).simulate(smallPatchedEncodedArraysOffset);
-            if (smallPatchedEncodedArraysSize > 0) {
-                ++smallPatchedSectionCount;
-            }
-
-            int smallPatchedClassDefsOffset
-                    = smallPatchedMethodIdsOffset
-                    + smallPatchedMethodIdsSize;
-            if (oldDex.getTableOfContents().classDefs.isElementFourByteAligned) {
-                smallPatchedClassDefsOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedClassDefsOffset);
-            }
-            patchedDexToSmallPatchedClassDefOffsetMap.put(
-                    patchedDex, smallPatchedClassDefsOffset
-            );
-
-            // Calculate any values we still know nothing about them.
-            int smallPatchedMapListOffset
-                    = smallPatchedEncodedArraysOffset
-                    + smallPatchedEncodedArraysSize;
-            if (oldDex.getTableOfContents().mapList.isElementFourByteAligned) {
-                smallPatchedMapListOffset
-                        = SizeOf.roundToTimesOfFour(smallPatchedMapListOffset);
-            }
-            patchedDexToSmallPatchedMapListOffsetMap.put(
-                    patchedDex, smallPatchedMapListOffset
-            );
-            int smallPatchedMapListSize
-                    = SizeOf.UINT + SizeOf.MAP_ITEM * smallPatchedSectionCount;
-
-            int smallPatchedDexSize
-                    = smallPatchedMapListOffset
-                    + smallPatchedMapListSize;
-            patchedDexToSmallPatchedDexSizeMap.put(patchedDex, smallPatchedDexSize);
-        }
-    }
-
-    private int getCollectedIndicesCountSafely(
-            Map<Dex, Set<Integer>> collectedIndicesMap, Dex patchedDex
-    ) {
-        Set<Integer> indices = collectedIndicesMap.get(patchedDex);
-        if (indices == null) {
-            return 0;
-        } else {
-            return indices.size();
-        }
-    }
-
-    private void saveToStream(OutputStream os) throws IOException {
-        DexDataBuffer buffer = new DexDataBuffer();
-
-        // Write header
-        buffer.write(SmallPatchedDexItemFile.MAGIC);
-        buffer.writeShort(SmallPatchedDexItemFile.CURRENT_VERSION);
-        // Take the field 'firstChunkOffset' into header's size account.
-        buffer.writeInt(buffer.position() + SizeOf.UINT);
-
-        // Gather old dexes
-        List<Dex> oldDexes = new ArrayList<>();
-        int oldDexGroupCount = this.oldDexGroups.size();
-        for (int i = 0; i < oldDexGroupCount; ++i) {
-            DexGroup oldDexGroup = oldDexGroups.get(i);
-            for (Dex oldDex : oldDexGroup.dexes) {
-                oldDexes.add(oldDex);
-            }
-        }
-
-        // Gather patched dexes
-        List<Dex> patchedDexes = new ArrayList<>();
-        int patchedDexGroupCount = this.patchedDexGroups.size();
-        for (int i = 0; i < patchedDexGroupCount; ++i) {
-            DexGroup patchedDexGroup = patchedDexGroups.get(i);
-            for (Dex patchedDex : patchedDexGroup.dexes) {
-                patchedDexes.add(patchedDex);
-            }
-        }
-
-        // Dex sign chunk
-        int oldDexSignCount = oldDexes.size();
-        buffer.writeUleb128(oldDexSignCount);
-
-        Map<String, Integer> oldDexSignToIdxInSignList = new HashMap<>();
-        for (int i = 0; i < oldDexSignCount; ++i) {
-            final byte[] signBytes = oldDexes.get(i).computeSignature(false);
-            final String signStr = Hex.toHexString(signBytes);
-            buffer.write(signBytes);
-            oldDexSignToIdxInSignList.put(signStr, i);
-        }
-
-        for (Dex patchedDex : patchedDexes) {
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedStringIdOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedTypeIdOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedProtoIdOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedFieldIdOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedMethodIdOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedClassDefOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedStringDataOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedTypeListOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedAnnotationOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedAnnotationSetOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedAnnotationSetRefListOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedAnnotationsDirectoryOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedDebugInfoOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedCodeOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedClassDataOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedEncodedArrayOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedMapListOffsetMap
-            );
-            writeSmallPatchedSectionOffset(
-                    buffer, patchedDex, patchedDexToSmallPatchedDexSizeMap
-            );
-        }
-
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedStringIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedTypeIdIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedTypeListIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedProtoIdIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedFieldIdIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedMethodIdIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedAnnotationIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedAnnotationSetIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedAnnotationSetRefListIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedAnnotationsDirectoryIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedEncodedArrayIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedDebugInfoIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedCodeIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedClassDataIndicesMap);
-        writeDataChunk(buffer, patchedDexes, patchedDexToCollectedClassDefIndicesMap);
-
-        os.write(buffer.array());
-        os.flush();
-    }
-
-    private void writeSmallPatchedSectionOffset(
-            DexDataBuffer buffer,
-            Dex patchedDex,
-            Map<Dex, Integer> patchedDexToSmallPatchedSectionOffsetMap
-    ) {
-        Integer offset = patchedDexToSmallPatchedSectionOffsetMap.get(patchedDex);
-        if (offset != null) {
-            buffer.writeInt(offset);
-        } else {
-            throw new IllegalStateException("section offset is missing.");
-        }
-    }
-
-    private void writeDataChunk(
-            DexDataBuffer buffer,
-            List<Dex> patchedDexList,
-            Map<Dex, Set<Integer>> patchedDexToCollectedItemIndicesMap
-    ) {
-        for (Dex patchedDex : patchedDexList) {
-            Set<Integer> itemIndices = patchedDexToCollectedItemIndicesMap.get(patchedDex);
-            if (itemIndices == null) {
-                buffer.writeUleb128(0);
-            } else {
-                int indexCount = itemIndices.size();
-                Integer[] itemIndexArr = new Integer[indexCount];
-                itemIndices.toArray(itemIndexArr);
-                Arrays.sort(itemIndexArr);
-                buffer.writeUleb128(indexCount);
-                int prevIndex = 0;
-                for (int j = 0; j < indexCount; ++j) {
-                    buffer.writeSleb128(itemIndexArr[j] - prevIndex);
-                    prevIndex = itemIndexArr[j];
-                }
-            }
-        }
-    }
-
-    private boolean isClassMethodReferenceToRefAffectedClass(
-            Dex owner,
-            ClassData.Method[] methods,
-            Collection<String> affectedClassDescs
-    ) {
-        if (affectedClassDescs.isEmpty() || methods == null || methods.length == 0) {
-            return false;
-        }
-
-        for (ClassData.Method method : methods) {
-            if (method.codeOffset == 0) {
-                continue;
-            }
-            Code code = owner.readCode(method);
-            RefToRefAffectedClassInsnVisitor refInsnVisitor =
-                    new RefToRefAffectedClassInsnVisitor(owner, method, affectedClassDescs);
-            InstructionReader insnReader =
-                    new InstructionReader(new ShortArrayCodeInput(code.instructions));
-            try {
-                insnReader.accept(refInsnVisitor);
-                if (refInsnVisitor.isMethodReferencedToRefAffectedClass) {
-                    return true;
-                }
-            } catch (EOFException e) {
-                throw new IllegalStateException(e);
-            }
-        }
-
-        return false;
-    }
-
-    private void collectItemIndicesFromDexGroup(
-            DexGroup oldDexGroup,
-            DexGroup patchedDexGroup
-    ) {
-        DexClassesComparator dexClassesCmp = new DexClassesComparator("*");
-        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_CAUSE_REF_CHANGE_ONLY);
-        dexClassesCmp.setIgnoredRemovedClassDescPattern(this.loaderClassPatterns);
-        dexClassesCmp.startCheck(oldDexGroup, patchedDexGroup);
-
-        Set<String> refAffectedClassDescs
-                = dexClassesCmp.getChangedClassDescToInfosMap().keySet();
-
-        Set<DexClassInfo> classInfosInPatchedDexGroup
-                = patchedDexGroup.getClassInfosInDexesWithDuplicateCheck();
-
-        Set<DexClassInfo> patchedClassInfosForItemIndexCollecting = new HashSet<>();
-
-        for (DexClassInfo patchedClassInfo : classInfosInPatchedDexGroup) {
-            if (patchedClassInfo.classDef.classDataOffset == 0) {
-                continue;
-            }
-            ClassData patchedClassData
-                    = patchedClassInfo.owner.readClassData(patchedClassInfo.classDef);
-
-            boolean shouldAdd = isClassMethodReferenceToRefAffectedClass(
-                    patchedClassInfo.owner,
-                    patchedClassData.directMethods,
-                    refAffectedClassDescs
-            );
-
-            if (!shouldAdd) {
-                shouldAdd = isClassMethodReferenceToRefAffectedClass(
-                        patchedClassInfo.owner,
-                        patchedClassData.virtualMethods,
-                        refAffectedClassDescs
-                );
-            }
-
-            if (shouldAdd) {
-                logger.i(TAG, "Add class %s to small patched dex.", patchedClassInfo.classDesc);
-                patchedClassInfosForItemIndexCollecting.add(patchedClassInfo);
-            }
-        }
-
-        // So far we get descriptors of classes we need to add additionally,
-        // while we still need to do a fully compare to collect added classes
-        // and replaced classes since they may use items in their owner dex which
-        // is not modified.
-        dexClassesCmp.setCompareMode(DexClassesComparator.COMPARE_MODE_NORMAL);
-        dexClassesCmp.startCheck(oldDexGroup, patchedDexGroup);
-
-        Collection<DexClassInfo> addedClassInfos = dexClassesCmp.getAddedClassInfos();
-        for (DexClassInfo addClassInfo : addedClassInfos) {
-            logger.i(TAG, "Add class %s to small patched dex.", addClassInfo.classDesc);
-            patchedClassInfosForItemIndexCollecting.add(addClassInfo);
-        }
-
-        Collection<DexClassInfo[]> changedOldPatchedClassInfos =
-                dexClassesCmp.getChangedClassDescToInfosMap().values();
-
-        // changedOldPatchedClassInfo[1] means changedPatchedClassInfo
-        for (DexClassInfo[] changedOldPatchedClassInfo : changedOldPatchedClassInfos) {
-            logger.i(TAG, "Add class %s to small patched dex.", changedOldPatchedClassInfo[1].classDesc);
-            patchedClassInfosForItemIndexCollecting.add(changedOldPatchedClassInfo[1]);
-        }
-
-        // Finally we collect all elements' indices of collected class.
-
-        Map<Dex, OffsetToIndexConverter> dexToOffsetToIndexConverterMap = new HashMap<>();
-
-        for (DexClassInfo classInfo : patchedClassInfosForItemIndexCollecting) {
-            Dex owner = classInfo.owner;
-            OffsetToIndexConverter offsetToIndexConverter =
-                    dexToOffsetToIndexConverterMap.get(owner);
-
-            if (offsetToIndexConverter == null) {
-                offsetToIndexConverter = new OffsetToIndexConverter(owner);
-                dexToOffsetToIndexConverterMap.put(owner, offsetToIndexConverter);
-            }
-
-            collectItemIndicesFromClassInfo(classInfo, offsetToIndexConverter);
-        }
-    }
-
-    private void collectItemIndicesFromClassInfo(
-            DexClassInfo classInfo,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        Dex owner = classInfo.owner;
-
-        putValueIntoSetMap(
-                patchedDexToCollectedClassDefIndicesMap,
-                owner,
-                classInfo.classDefIndex
-        );
-
-        collectItemIndicesFromTypeIndex(
-                owner, classInfo.classDef.typeIndex, offsetToIndexConverter
-        );
-
-        collectItemIndicesFromTypeIndex(
-                owner, classInfo.classDef.supertypeIndex, offsetToIndexConverter
-        );
-
-        collectItemIndicesFromTypeList(
-                owner, classInfo.classDef.interfacesOffset, offsetToIndexConverter
-        );
-
-        collectItemIndicesFromStringIndex(
-                owner, classInfo.classDef.sourceFileIndex, offsetToIndexConverter
-        );
-
-        collectItemIndicesFromAnnotationsDirectory(
-                owner, classInfo.classDef.annotationsOffset, offsetToIndexConverter
-        );
-
-        collectItemIndicesFromClassData(
-                owner, classInfo.classDef.classDataOffset, offsetToIndexConverter
-        );
-
-        collectItemIndicesFromEncodedArray(
-                owner, classInfo.classDef.staticValuesOffset, offsetToIndexConverter
-        );
-    }
-
-    private void collectItemIndicesFromStringIndex(
-            Dex owner,
-            int stringIndex,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (stringIndex == ClassDef.NO_INDEX) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedStringIndicesMap,
-                owner,
-                stringIndex
-        );
-    }
-
-    private void collectItemIndicesFromTypeList(
-            Dex owner,
-            int typeListOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (typeListOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedTypeListIndicesMap,
-                owner,
-                offsetToIndexConverter.getTypeListIndexByOffset(typeListOffset)
-        );
-
-        TypeList typeList = owner.openSection(typeListOffset).readTypeList();
-        for (int typeIndex : typeList.types) {
-            collectItemIndicesFromTypeIndex(
-                    owner, typeIndex, offsetToIndexConverter
-            );
-        }
-    }
-
-    private void collectItemIndicesFromTypeIndex(
-            Dex owner,
-            int typeIndex,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (typeIndex == ClassDef.NO_INDEX) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedTypeIdIndicesMap,
-                owner,
-                typeIndex
-        );
-
-        collectItemIndicesFromStringIndex(
-                owner, owner.typeIds().get(typeIndex), offsetToIndexConverter
-        );
-    }
-
-    private void collectItemIndicesFromFieldIndex(
-            Dex owner,
-            int fieldIndex,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (fieldIndex == ClassDef.NO_INDEX) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedFieldIdIndicesMap,
-                owner,
-                fieldIndex
-        );
-
-        FieldId fieldId = owner.fieldIds().get(fieldIndex);
-        collectItemIndicesFromStringIndex(owner, fieldId.nameIndex, offsetToIndexConverter);
-        collectItemIndicesFromTypeIndex(
-                owner, fieldId.declaringClassIndex, offsetToIndexConverter
-        );
-        collectItemIndicesFromTypeIndex(owner, fieldId.typeIndex, offsetToIndexConverter);
-    }
-
-    private void collectItemIndicesFromMethodIndex(
-            Dex owner,
-            int methodIndex,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (methodIndex == ClassDef.NO_INDEX) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedMethodIdIndicesMap,
-                owner,
-                methodIndex
-        );
-
-        MethodId methodId = owner.methodIds().get(methodIndex);
-        collectItemIndicesFromStringIndex(
-                owner, methodId.nameIndex, offsetToIndexConverter
-        );
-        collectItemIndicesFromTypeIndex(
-                owner, methodId.declaringClassIndex, offsetToIndexConverter
-        );
-        collectItemIndicesFromProtoIndex(
-                owner, methodId.protoIndex, offsetToIndexConverter
-        );
-    }
-
-    private void collectItemIndicesFromProtoIndex(
-            Dex owner,
-            int protoIndex,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (protoIndex == ClassDef.NO_INDEX) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedProtoIdIndicesMap,
-                owner,
-                protoIndex
-        );
-
-        ProtoId protoId = owner.protoIds().get(protoIndex);
-
-        collectItemIndicesFromStringIndex(
-                owner, protoId.shortyIndex, offsetToIndexConverter
-        );
-        collectItemIndicesFromTypeIndex(
-                owner, protoId.returnTypeIndex, offsetToIndexConverter
-        );
-        collectItemIndicesFromTypeList(
-                owner, protoId.parametersOffset, offsetToIndexConverter
-        );
-    }
-
-    private void collectItemIndicesFromAnnotationsDirectory(
-            Dex owner,
-            int annotationsDirectoryOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (annotationsDirectoryOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedAnnotationsDirectoryIndicesMap,
-                owner,
-                offsetToIndexConverter.getAnnotationsDirectoryIndexByOffset(
-                        annotationsDirectoryOffset
-                )
-        );
-
-        AnnotationsDirectory annotationsDirectory =
-                owner.openSection(annotationsDirectoryOffset).readAnnotationsDirectory();
-
-        collectItemIndicesFromAnnotationSet(
-                owner,
-                annotationsDirectory.classAnnotationsOffset,
-                offsetToIndexConverter
-        );
-
-        for (int[] fieldAnnoPair : annotationsDirectory.fieldAnnotations) {
-            collectItemIndicesFromFieldIndex(
-                    owner, fieldAnnoPair[0], offsetToIndexConverter
-            );
-            collectItemIndicesFromAnnotationSet(
-                    owner, fieldAnnoPair[1], offsetToIndexConverter
-            );
-        }
-        for (int[] methodAnnoPair : annotationsDirectory.methodAnnotations) {
-            collectItemIndicesFromMethodIndex(
-                    owner, methodAnnoPair[0], offsetToIndexConverter
-            );
-            collectItemIndicesFromAnnotationSet(
-                    owner, methodAnnoPair[1], offsetToIndexConverter
-            );
-        }
-        for (int[] paramAnnoPair : annotationsDirectory.parameterAnnotations) {
-            collectItemIndicesFromMethodIndex(
-                    owner, paramAnnoPair[0], offsetToIndexConverter
-            );
-            collectItemIndicesFromAnnotationSetRefList(
-                    owner, paramAnnoPair[1], offsetToIndexConverter
-            );
-        }
-    }
-
-    private void collectItemIndicesFromAnnotationSetRefList(
-            Dex owner,
-            int annotationSetRefListOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (annotationSetRefListOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedAnnotationSetRefListIndicesMap,
-                owner,
-                offsetToIndexConverter.getAnnotationSetRefListIndexByOffset(
-                        annotationSetRefListOffset
-                )
-        );
-
-        AnnotationSetRefList annotationSetRefList =
-                owner.openSection(annotationSetRefListOffset).readAnnotationSetRefList();
-
-        for (int annotationSetOffset : annotationSetRefList.annotationSetRefItems) {
-            collectItemIndicesFromAnnotationSet(
-                    owner, annotationSetOffset, offsetToIndexConverter
-            );
-        }
-    }
-
-    private void collectItemIndicesFromAnnotationSet(
-            Dex owner,
-            int annotationSetOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (annotationSetOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedAnnotationSetIndicesMap,
-                owner,
-                offsetToIndexConverter.getAnnotationSetIndexByOffset(
-                        annotationSetOffset
-                )
-        );
-
-        AnnotationSet annotationSet = owner.openSection(annotationSetOffset).readAnnotationSet();
-
-        for (int annotationOffset : annotationSet.annotationOffsets) {
-            collectItemIndicesFromAnnotation(
-                    owner, annotationOffset, offsetToIndexConverter
-            );
-        }
-    }
-
-    private void collectItemIndicesFromAnnotation(
-            Dex owner,
-            int annotationOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (annotationOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedAnnotationIndicesMap,
-                owner,
-                offsetToIndexConverter.getAnnotationIndexByOffset(
-                        annotationOffset
-                )
-        );
-
-        Annotation annotation =
-                owner.openSection(annotationOffset).readAnnotation();
-
-        EncodedValueReader annotationReader = annotation.getReader();
-
-        collectItemIndicesFromAnnotationReader(
-                owner,
-                annotationReader,
-                offsetToIndexConverter
-        );
-    }
-
-    private void collectItemIndicesFromAnnotationReader(
-            Dex owner,
-            EncodedValueReader annotationReader,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        int fieldCount = annotationReader.readAnnotation();
-
-        collectItemIndicesFromTypeIndex(
-                owner, annotationReader.getAnnotationType(), offsetToIndexConverter
-        );
-
-        for (int i = 0; i < fieldCount; ++i) {
-            int annotationNameIndex = annotationReader.readAnnotationName();
-            collectItemIndicesFromStringIndex(
-                    owner, annotationNameIndex, offsetToIndexConverter
-            );
-            collectItemIndicesFromEncodedValueReader(
-                    owner, annotationReader, offsetToIndexConverter
-            );
-        }
-    }
-
-    private void collectItemIndicesFromEncodedArrayReader(
-            Dex owner,
-            EncodedValueReader arrayReader,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        int size = arrayReader.readArray();
-        for (int i = 0; i < size; ++i) {
-            collectItemIndicesFromEncodedValueReader(
-                    owner, arrayReader, offsetToIndexConverter
-            );
-        }
-    }
-
-    private void collectItemIndicesFromEncodedValueReader(
-            Dex owner,
-            EncodedValueReader encodedValueReader,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        switch (encodedValueReader.peek()) {
-            case EncodedValueReader.ENCODED_BYTE:
-                // Skip value.
-                encodedValueReader.readByte();
-                break;
-            case EncodedValueReader.ENCODED_SHORT:
-                // Skip value.
-                encodedValueReader.readShort();
-                break;
-            case EncodedValueReader.ENCODED_INT:
-                // Skip value.
-                encodedValueReader.readInt();
-                break;
-            case EncodedValueReader.ENCODED_LONG:
-                // Skip value.
-                encodedValueReader.readLong();
-                break;
-            case EncodedValueReader.ENCODED_CHAR:
-                // Skip value.
-                encodedValueReader.readChar();
-                break;
-            case EncodedValueReader.ENCODED_FLOAT:
-                // Skip value.
-                encodedValueReader.readFloat();
-                break;
-            case EncodedValueReader.ENCODED_DOUBLE:
-                // Skip value.
-                encodedValueReader.readDouble();
-                break;
-            case EncodedValueReader.ENCODED_STRING:
-                collectItemIndicesFromStringIndex(
-                        owner,
-                        encodedValueReader.readString(),
-                        offsetToIndexConverter
-                );
-                break;
-            case EncodedValueReader.ENCODED_TYPE:
-                collectItemIndicesFromTypeIndex(
-                        owner,
-                        encodedValueReader.readType(),
-                        offsetToIndexConverter
-                );
-                break;
-            case EncodedValueReader.ENCODED_FIELD:
-                collectItemIndicesFromFieldIndex(
-                        owner,
-                        encodedValueReader.readField(),
-                        offsetToIndexConverter
-                );
-                break;
-            case EncodedValueReader.ENCODED_ENUM:
-                collectItemIndicesFromFieldIndex(
-                        owner,
-                        encodedValueReader.readEnum(),
-                        offsetToIndexConverter
-                );
-                break;
-            case EncodedValueReader.ENCODED_METHOD:
-                collectItemIndicesFromMethodIndex(
-                        owner,
-                        encodedValueReader.readMethod(),
-                        offsetToIndexConverter
-                );
-                break;
-            case EncodedValueReader.ENCODED_ARRAY:
-                collectItemIndicesFromEncodedArrayReader(
-                        owner,
-                        encodedValueReader,
-                        offsetToIndexConverter
-                );
-                break;
-            case EncodedValueReader.ENCODED_ANNOTATION:
-                collectItemIndicesFromAnnotationReader(
-                        owner,
-                        encodedValueReader,
-                        offsetToIndexConverter
-
-                );
-                break;
-            case EncodedValueReader.ENCODED_NULL:
-                // Skip value.
-                encodedValueReader.readNull();
-                break;
-            case EncodedValueReader.ENCODED_BOOLEAN:
-                // Skip value.
-                encodedValueReader.readBoolean();
-                break;
-            default:
-                throw new DexException(
-                        "Unexpected type: " + Integer.toHexString(encodedValueReader.peek())
-                );
-        }
-    }
-
-    private void collectItemIndicesFromClassData(
-            Dex owner,
-            int classDataOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (classDataOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedClassDataIndicesMap,
-                owner,
-                offsetToIndexConverter.getClassDataIndexByOffset(classDataOffset)
-        );
-
-        ClassData classData = owner.openSection(classDataOffset).readClassData();
-
-        for (ClassData.Field field : classData.instanceFields) {
-            collectItemIndicesFromFieldIndex(
-                    owner, field.fieldIndex, offsetToIndexConverter
-            );
-        }
-
-        for (ClassData.Field field : classData.staticFields) {
-            collectItemIndicesFromFieldIndex(
-                    owner, field.fieldIndex, offsetToIndexConverter
-            );
-        }
-
-        for (ClassData.Method method : classData.directMethods) {
-            collectItemIndicesFromMethodIndex(
-                    owner, method.methodIndex, offsetToIndexConverter
-            );
-            collectItemIndicesFromCode(
-                    owner, method.codeOffset, offsetToIndexConverter
-            );
-        }
-
-        for (ClassData.Method method : classData.virtualMethods) {
-            collectItemIndicesFromMethodIndex(
-                    owner, method.methodIndex, offsetToIndexConverter
-            );
-            collectItemIndicesFromCode(
-                    owner, method.codeOffset, offsetToIndexConverter
-            );
-        }
-    }
-
-    private void collectItemIndicesFromCode(
-            Dex owner,
-            int codeOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (codeOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-
-        putValueIntoSetMap(
-                patchedDexToCollectedCodeIndicesMap,
-                owner,
-                offsetToIndexConverter.getCodeIndexByOffset(codeOffset)
-        );
-
-        Code code = owner.openSection(codeOffset).readCode();
-
-        collectItemIndicesFromDebugInfoItem(
-                owner,
-                code.debugInfoOffset,
-                offsetToIndexConverter
-        );
-
-        InstructionReader ir = new InstructionReader(new ShortArrayCodeInput(code.instructions));
-        try {
-            ir.accept(new IndicesCollectorInsnVisitor(
-                    owner, offsetToIndexConverter
-            ));
-        } catch (EOFException e) {
-            throw new IllegalStateException(e);
-        }
-
-        for (Code.CatchHandler catchHandler : code.catchHandlers) {
-            for (int typeIndex : catchHandler.typeIndexes) {
-                collectItemIndicesFromTypeIndex(
-                        owner,
-                        typeIndex,
-                        offsetToIndexConverter
-                );
-            }
-        }
-    }
-
-    private void collectItemIndicesFromDebugInfoItem(
-            Dex owner,
-            int debugInfoItemOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (debugInfoItemOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedDebugInfoIndicesMap,
-                owner,
-                offsetToIndexConverter.getDebugInfoItemIndexByOffset(debugInfoItemOffset)
-        );
-
-        DebugInfoItem debugInfoItem = owner.openSection(debugInfoItemOffset).readDebugInfoItem();
-
-        for (int stringIndex : debugInfoItem.parameterNames) {
-            collectItemIndicesFromStringIndex(
-                    owner, stringIndex, offsetToIndexConverter
-            );
-        }
-
-        final ByteArrayInputStream bais = new ByteArrayInputStream(debugInfoItem.infoSTM);
-        ByteInput inAdapter = new ByteInput() {
-            @Override
-            public byte readByte() {
-                return (byte) (bais.read() & 0xFF);
-            }
-        };
-
-        outside_whileloop:
-        while (true) {
-            int opcode = bais.read() & 0xFF;
-            switch (opcode) {
-                case DebugInfoItem.DBG_END_SEQUENCE: {
-                    break outside_whileloop;
-                }
-                case DebugInfoItem.DBG_ADVANCE_PC: {
-                    // Skip addrDiff.
-                    int addrDiff = Leb128.readUnsignedLeb128(inAdapter);
-                    break;
-                }
-                case DebugInfoItem.DBG_ADVANCE_LINE: {
-                    // Skip lineDiff.
-                    int lineDiff = Leb128.readSignedLeb128(inAdapter);
-                    break;
-                }
-                case DebugInfoItem.DBG_START_LOCAL:
-                case DebugInfoItem.DBG_START_LOCAL_EXTENDED: {
-                    // Skip registerNum.
-                    int registerNum = Leb128.readUnsignedLeb128(inAdapter);
-
-                    int nameIndex = Leb128.readUnsignedLeb128p1(inAdapter);
-                    collectItemIndicesFromStringIndex(
-                            owner, nameIndex, offsetToIndexConverter
-                    );
-
-                    int typeIndex = Leb128.readUnsignedLeb128p1(inAdapter);
-                    collectItemIndicesFromTypeIndex(
-                            owner, typeIndex, offsetToIndexConverter
-                    );
-
-                    if (opcode == DebugInfoItem.DBG_START_LOCAL_EXTENDED) {
-                        int sigIndex = Leb128.readUnsignedLeb128p1(inAdapter);
-                        collectItemIndicesFromStringIndex(
-                                owner, sigIndex, offsetToIndexConverter
-                        );
-                    }
-                    break;
-                }
-                case DebugInfoItem.DBG_END_LOCAL:
-                case DebugInfoItem.DBG_RESTART_LOCAL: {
-                    // Skip registerNum.
-                    int registerNum = Leb128.readUnsignedLeb128(inAdapter);
-                    break;
-                }
-                case DebugInfoItem.DBG_SET_FILE: {
-                    int nameIndex = Leb128.readUnsignedLeb128p1(inAdapter);
-                    collectItemIndicesFromStringIndex(
-                            owner, nameIndex, offsetToIndexConverter
-                    );
-                    break;
-                }
-                case DebugInfoItem.DBG_SET_PROLOGUE_END:
-                case DebugInfoItem.DBG_SET_EPILOGUE_BEGIN:
-                default: {
-                    break;
-                }
-            }
-        }
-    }
-
-    private void collectItemIndicesFromEncodedArray(
-            Dex owner,
-            int encodedArrayOffset,
-            OffsetToIndexConverter offsetToIndexConverter
-    ) {
-        if (encodedArrayOffset == ClassDef.NO_OFFSET) {
-            return;
-        }
-
-        putValueIntoSetMap(
-                patchedDexToCollectedEncodedArrayIndicesMap,
-                owner,
-                offsetToIndexConverter.getEncodedArrayIndexByOffset(encodedArrayOffset)
-        );
-
-        EncodedValue arrayVal = owner.openSection(encodedArrayOffset).readEncodedArray();
-        EncodedValueReader arrayReader =
-                new EncodedValueReader(arrayVal, EncodedValueReader.ENCODED_ARRAY);
-
-        collectItemIndicesFromEncodedArrayReader(
-                owner, arrayReader, offsetToIndexConverter
-        );
-    }
-
-    private <K, V> void putValueIntoSetMap(Map<K, Set<V>> map, K key, V value) {
-        Set<V> valueSet = map.get(key);
-        if (valueSet == null) {
-            valueSet = new HashSet<>();
-            map.put(key, valueSet);
-        }
-        valueSet.add(value);
-    }
-
-    private class SmallPatchSimulator<T extends Comparable<T>> {
-        private final TableOfContents.Section tocSec;
-        private final Dex.Section patchedSection;
-        private final int patchedItemCount;
-        private final IndexMap fullToSmallPatchMap;
-        private final Set<Integer> collectedIndices;
-
-        SmallPatchSimulator(
-                Dex patchedDex,
-                TableOfContents.Section tocSec,
-                IndexMap fullToSmallPatchMap,
-                Set<Integer> collectedIndices
-        ) {
-            if (tocSec.exists()) {
-                this.tocSec = tocSec;
-                this.patchedSection = patchedDex.openSection(tocSec);
-                this.patchedItemCount = tocSec.size;
-                this.fullToSmallPatchMap = fullToSmallPatchMap;
-                this.collectedIndices = collectedIndices;
-            } else {
-                this.tocSec = null;
-                this.patchedSection = null;
-                this.patchedItemCount = 0;
-                this.fullToSmallPatchMap = null;
-                this.collectedIndices = null;
-            }
-        }
-
-        private int getItemIndexOrOffset(T item, int index) {
-            if (item instanceof TableOfContents.Section.Item) {
-                return ((TableOfContents.Section.Item) item).off;
-            } else {
-                return index;
-            }
-        }
-
-        @SuppressWarnings("unchecked")
-        private T nextItem(DexDataBuffer buffer) {
-            switch (this.tocSec.type) {
-                case TableOfContents.SECTION_TYPE_TYPEIDS: {
-                    return (T) (Integer) buffer.readInt();
-                }
-                case TableOfContents.SECTION_TYPE_PROTOIDS: {
-                    return (T) buffer.readProtoId();
-                }
-                case TableOfContents.SECTION_TYPE_FIELDIDS: {
-                    return (T) buffer.readFieldId();
-                }
-                case TableOfContents.SECTION_TYPE_METHODIDS: {
-                    return (T) buffer.readMethodId();
-                }
-                case TableOfContents.SECTION_TYPE_CLASSDEFS: {
-                    return (T) buffer.readClassDef();
-                }
-                case TableOfContents.SECTION_TYPE_STRINGDATAS: {
-                    return (T) buffer.readStringData();
-                }
-                case TableOfContents.SECTION_TYPE_TYPELISTS: {
-                    return (T) buffer.readTypeList();
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONS: {
-                    return (T) buffer.readAnnotation();
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSETS: {
-                    return (T) buffer.readAnnotationSet();
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSETREFLISTS: {
-                    return (T) buffer.readAnnotationSetRefList();
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSDIRECTORIES: {
-                    return (T) buffer.readAnnotationsDirectory();
-                }
-                case TableOfContents.SECTION_TYPE_DEBUGINFOS: {
-                    return (T) buffer.readDebugInfoItem();
-                }
-                case TableOfContents.SECTION_TYPE_CODES: {
-                    return (T) buffer.readCode();
-                }
-                case TableOfContents.SECTION_TYPE_ENCODEDARRAYS: {
-                    return (T) buffer.readEncodedArray();
-                }
-                case TableOfContents.SECTION_TYPE_CLASSDATA: {
-                    return (T) buffer.readClassData();
-                }
-                default:
-                    throw new IllegalStateException("unknown section type: " + this.tocSec.type);
-            }
-        }
-
-        private int getItemSize(T item) {
-            if (item instanceof TableOfContents.Section.Item) {
-                return ((TableOfContents.Section.Item) item).byteCountInDex();
-            } else {
-                if (item instanceof Integer) {
-                    return SizeOf.UINT;
-                } else {
-                    throw new IllegalStateException(
-                            "unexpected item type: " + item.getClass().getName()
-                    );
-                }
-            }
-        }
-
-        @SuppressWarnings("unchecked")
-        private T adjustItem(IndexMap indexMap, T item) {
-            switch (this.tocSec.type) {
-                case TableOfContents.SECTION_TYPE_TYPEIDS: {
-                    return (T) (Integer) indexMap.adjustStringIndex((Integer) item);
-                }
-                case TableOfContents.SECTION_TYPE_PROTOIDS: {
-                    return (T) indexMap.adjust((ProtoId) item);
-                }
-                case TableOfContents.SECTION_TYPE_FIELDIDS: {
-                    return (T) indexMap.adjust((FieldId) item);
-                }
-                case TableOfContents.SECTION_TYPE_METHODIDS: {
-                    return (T) indexMap.adjust((MethodId) item);
-                }
-                case TableOfContents.SECTION_TYPE_CLASSDEFS: {
-                    return (T) indexMap.adjust((ClassDef) item);
-                }
-                case TableOfContents.SECTION_TYPE_STRINGDATAS: {
-                    // nothing to do.
-                    return item;
-                }
-                case TableOfContents.SECTION_TYPE_TYPELISTS: {
-                    return (T) indexMap.adjust((TypeList) item);
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONS: {
-                    return (T) indexMap.adjust((Annotation) item);
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSETS: {
-                    return (T) indexMap.adjust((AnnotationSet) item);
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSETREFLISTS: {
-                    return (T) indexMap.adjust((AnnotationSetRefList) item);
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSDIRECTORIES: {
-                    return (T) indexMap.adjust((AnnotationsDirectory) item);
-                }
-                case TableOfContents.SECTION_TYPE_DEBUGINFOS: {
-                    return (T) indexMap.adjust((DebugInfoItem) item);
-                }
-                case TableOfContents.SECTION_TYPE_CODES: {
-                    return (T) indexMap.adjust((Code) item);
-                }
-                case TableOfContents.SECTION_TYPE_ENCODEDARRAYS: {
-                    return (T) indexMap.adjust((EncodedValue) item);
-                }
-                case TableOfContents.SECTION_TYPE_CLASSDATA: {
-                    return (T) indexMap.adjust((ClassData) item);
-                }
-                default:
-                    throw new IllegalStateException("unknown section type: " + this.tocSec.type);
-            }
-        }
-
-        @SuppressWarnings("unchecked")
-        private void updateIndexOrOffset(
-                IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset
-        ) {
-            switch (this.tocSec.type) {
-                case TableOfContents.SECTION_TYPE_TYPEIDS: {
-                    indexMap.mapTypeIds(oldIndex, newIndex);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_PROTOIDS: {
-                    indexMap.mapProtoIds(oldIndex, newIndex);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_FIELDIDS: {
-                    indexMap.mapFieldIds(oldIndex, newIndex);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_METHODIDS: {
-                    indexMap.mapMethodIds(oldIndex, newIndex);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_CLASSDEFS: {
-                    // nothing to do.
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_STRINGDATAS: {
-                    indexMap.mapStringIds(oldIndex, newIndex);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_TYPELISTS: {
-                    indexMap.mapTypeListOffset(oldOffset, newOffset);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONS: {
-                    indexMap.mapAnnotationOffset(oldOffset, newOffset);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSETS: {
-                    indexMap.mapAnnotationSetOffset(oldOffset, newOffset);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSETREFLISTS: {
-                    indexMap.mapAnnotationSetRefListOffset(oldOffset, newOffset);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_ANNOTATIONSDIRECTORIES: {
-                    indexMap.mapAnnotationsDirectoryOffset(oldOffset, newOffset);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_DEBUGINFOS: {
-                    indexMap.mapDebugInfoItemOffset(oldOffset, newOffset);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_CODES: {
-                    indexMap.mapCodeOffset(oldOffset, newOffset);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_ENCODEDARRAYS: {
-                    indexMap.mapStaticValuesOffset(oldOffset, newOffset);
-                    break;
-                }
-                case TableOfContents.SECTION_TYPE_CLASSDATA: {
-                    indexMap.mapClassDataOffset(oldOffset, newOffset);
-                    break;
-                }
-                default:
-                    throw new IllegalStateException("unknown section type: " + this.tocSec.type);
-            }
-        }
-
-        public int simulate(int smallPatchBaseOffset) {
-            if (patchedSection == null) {
-                return 0;
-            }
-            if (collectedIndices == null || collectedIndices.isEmpty()) {
-                return 0;
-            }
-            int smallPatchedIndex = 0;
-            int smallPatchOffset = smallPatchBaseOffset;
-            for (int fullPatchedItemIndex = 0;
-                 fullPatchedItemIndex < this.patchedItemCount;
-                 ++fullPatchedItemIndex
-            ) {
-                T fullPatchedItemInSmallPatch = adjustItem(
-                        this.fullToSmallPatchMap, nextItem(this.patchedSection)
-                );
-                if (collectedIndices.contains(fullPatchedItemIndex)) {
-                    if (this.tocSec.isElementFourByteAligned) {
-                        smallPatchOffset = SizeOf.roundToTimesOfFour(smallPatchOffset);
-                    }
-
-                    int fullPatchedOffset = getItemIndexOrOffset(
-                            fullPatchedItemInSmallPatch, fullPatchedItemIndex
-                    );
-
-                    if (fullPatchedItemIndex != smallPatchedIndex
-                            || fullPatchedOffset != smallPatchOffset) {
-                        updateIndexOrOffset(
-                                this.fullToSmallPatchMap,
-                                fullPatchedItemIndex,
-                                fullPatchedOffset,
-                                smallPatchedIndex,
-                                smallPatchOffset
-                        );
-                    }
-
-                    ++smallPatchedIndex;
-                    smallPatchOffset += getItemSize(fullPatchedItemInSmallPatch);
-                }
-            }
-            return smallPatchOffset - smallPatchBaseOffset;
-        }
-    }
-
-    private class RefToRefAffectedClassInsnVisitor extends InstructionVisitor {
-        private final Dex methodOwner;
-        private final ClassData.Method method;
-        private final Collection<String> refAffectedClassDefs;
-        private boolean isMethodReferencedToRefAffectedClass;
-
-        RefToRefAffectedClassInsnVisitor(Dex methodOwner, ClassData.Method method, Collection<String> refAffectedClassDefs) {
-            super(null);
-            this.methodOwner = methodOwner;
-            this.method = method;
-            this.refAffectedClassDefs = refAffectedClassDefs;
-            this.isMethodReferencedToRefAffectedClass = false;
-        }
-
-        @Override
-        public void visitZeroRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitOneRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitTwoRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitThreeRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitFourRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitFiveRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d, int e) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitRegisterRangeInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int registerCount) {
-            processIndexByType(index, indexType);
-        }
-
-        private void processIndexByType(int index, int indexType) {
-            String typeName = null;
-            String refInfoInLog = null;
-            switch (indexType) {
-                case InstructionCodec.INDEX_TYPE_TYPE_REF: {
-                    typeName = methodOwner.typeNames().get(index);
-                    refInfoInLog = "init ref-changed class";
-                    break;
-                }
-                case InstructionCodec.INDEX_TYPE_FIELD_REF: {
-                    final FieldId fieldId = methodOwner.fieldIds().get(index);
-                    typeName = methodOwner.typeNames().get(fieldId.declaringClassIndex);
-                    refInfoInLog = "referencing to field: " + methodOwner.strings().get(fieldId.nameIndex);
-                    break;
-                }
-                case InstructionCodec.INDEX_TYPE_METHOD_REF: {
-                    final MethodId methodId = methodOwner.methodIds().get(index);
-                    typeName = methodOwner.typeNames().get(methodId.declaringClassIndex);
-                    refInfoInLog = "invoking method: " + getMethodProtoTypeStr(methodId);
-                    break;
-                }
-            }
-            if (typeName != null && refAffectedClassDefs.contains(typeName)) {
-                MethodId methodId = methodOwner.methodIds().get(method.methodIndex);
-                logger.i(
-                        TAG,
-                        "Method %s in class %s referenced ref-changed class %s by %s",
-                        getMethodProtoTypeStr(methodId),
-                        methodOwner.typeNames().get(methodId.declaringClassIndex),
-                        typeName,
-                        refInfoInLog
-                );
-                isMethodReferencedToRefAffectedClass = true;
-            }
-        }
-
-        private String getMethodProtoTypeStr(MethodId methodId) {
-            StringBuilder strBuilder = new StringBuilder();
-            strBuilder.append(methodOwner.strings().get(methodId.nameIndex));
-            ProtoId protoId = methodOwner.protoIds().get(methodId.protoIndex);
-            strBuilder.append('(');
-            short[] paramTypeIds = methodOwner.parameterTypeIndicesFromMethodId(methodId);
-            for (short typeId : paramTypeIds) {
-                strBuilder.append(methodOwner.typeNames().get(typeId));
-            }
-            strBuilder.append(')').append(methodOwner.typeNames().get(protoId.returnTypeIndex));
-            return strBuilder.toString();
-        }
-    }
-
-    private class IndicesCollectorInsnVisitor extends InstructionVisitor {
-        private final Dex ownerDex;
-        private final OffsetToIndexConverter offsetToIndexConverter;
-
-        IndicesCollectorInsnVisitor(
-                Dex ownerDex, OffsetToIndexConverter offsetToIndexConverter
-        ) {
-            super(null);
-            this.ownerDex = ownerDex;
-            this.offsetToIndexConverter = offsetToIndexConverter;
-        }
-
-        @Override
-        public void visitZeroRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitOneRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitTwoRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitThreeRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitFourRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitFiveRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d, int e) {
-            processIndexByType(index, indexType);
-        }
-
-        @Override
-        public void visitRegisterRangeInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int registerCount) {
-            processIndexByType(index, indexType);
-        }
-
-        private void processIndexByType(int index, int indexType) {
-            switch (indexType) {
-                case InstructionCodec.INDEX_TYPE_STRING_REF: {
-                    collectItemIndicesFromStringIndex(
-                            ownerDex, index, offsetToIndexConverter
-                    );
-                    break;
-                }
-                case InstructionCodec.INDEX_TYPE_TYPE_REF: {
-                    collectItemIndicesFromTypeIndex(
-                            ownerDex, index, offsetToIndexConverter
-                    );
-                    break;
-                }
-                case InstructionCodec.INDEX_TYPE_FIELD_REF: {
-                    collectItemIndicesFromFieldIndex(
-                            ownerDex, index, offsetToIndexConverter
-                    );
-                    break;
-                }
-                case InstructionCodec.INDEX_TYPE_METHOD_REF: {
-                    collectItemIndicesFromMethodIndex(
-                            ownerDex, index, offsetToIndexConverter
-                    );
-                    break;
-                }
-            }
-        }
-    }
-}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/ClassSimDef.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/ClassSimDef.java
new file mode 100644
index 00000000..7d968672
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/ClassSimDef.java
@@ -0,0 +1,103 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.immutable;
+
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.FieldVisitor;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+
+import java.util.HashSet;
+
+
+public class ClassSimDef {
+
+    int methodCount;
+    int fieldCount;
+    byte[] bytes;
+    HashSet<String> refFieldSet;
+    HashSet<String> refMtdSet;
+
+    public ClassSimDef(byte[] bytes, HashSet<String> refFieldSet, HashSet<String> refMtdSet) {
+        this.bytes = bytes;
+        this.refFieldSet = refFieldSet;
+        this.refMtdSet = refMtdSet;
+        init();
+    }
+
+    public void init() {
+        methodCount = 0;
+        fieldCount = 0;
+
+        ClassReader cr = new ClassReader(bytes);
+        ClassVisitor cv = new ClassVisitor(Opcodes.ASM4) {
+            String className;
+
+            @Override
+            public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
+                className = name;
+                super.visit(version, access, name, signature, superName, interfaces);
+            }
+
+            @Override
+            public MethodVisitor visitMethod(int access, String mtdName, String mtdDesc, String mtdSig, String[] exceptions) {
+
+                String defMtd = className + ":" + mtdName + ":" + mtdDesc;
+                if (!refMtdSet.contains(defMtd)) {
+                    refMtdSet.add(defMtd);
+                    methodCount++;
+                }
+
+                MethodVisitor mv = super.visitMethod(access, mtdName, mtdDesc, mtdSig, exceptions);
+                mv = new MethodVisitor(Opcodes.ASM4, mv) {
+                    @Override
+                    public void visitFieldInsn(int opcode, String owner, String fName, String fDesc) {
+                        String invokeField = owner + ":" + fName + ":" + fDesc;
+                        if (!refFieldSet.contains(invokeField)) {
+                            refFieldSet.add(invokeField);
+                            fieldCount++;
+                        }
+                        super.visitFieldInsn(opcode, owner, fName, fDesc);
+                    }
+
+                    @Override
+                    public void visitMethodInsn(int opcode, String owner, String mName, String mDesc) {
+                        String invokeMtd = owner + ":" + mName + ":" + mDesc;
+                        if (!refMtdSet.contains(invokeMtd)) {
+                            refMtdSet.add(invokeMtd);
+                            methodCount++;
+                        }
+                        super.visitMethodInsn(opcode, owner, mName, mDesc);
+                    }
+                };
+                return mv;
+            }
+
+            @Override
+            public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) {
+                String fieldDesc = className + ":" + name + ":" + desc;
+                if (!refFieldSet.contains(fieldDesc)) {
+                    refFieldSet.add(fieldDesc);
+                    fieldCount++;
+                }
+                return super.visitField(access, name, desc, signature, value);
+            }
+        };
+        cr.accept(cv, 0);
+    }
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/DexRefData.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/DexRefData.java
new file mode 100644
index 00000000..a1e342eb
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/immutable/DexRefData.java
@@ -0,0 +1,38 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.immutable;
+
+import java.util.HashSet;
+import java.util.Set;
+
+public class DexRefData {
+    int methodNum;
+    int fieldNum;
+    public Set<String> refFields;
+    public Set<String> refMtds;
+
+    DexRefData() {
+        this(0, 0);
+    }
+
+    DexRefData(int methodNum, int fieldNum) {
+        this.methodNum = methodNum;
+        this.fieldNum = fieldNum;
+        refFields = new HashSet<>();
+        refMtds = new HashSet<>();
+    }
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfo.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfo.java
index 2adf51a4..1ac70a60 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfo.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfo.java
@@ -23,13 +23,10 @@
  */
 public class PatchInfo {
 
-    private final Configuration config;
-
     private final PatchInfoGen infoGen;
 
 
     public PatchInfo(Configuration config) {
-        this.config = config;
         infoGen = new PatchInfoGen(config);
     }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java
index a097f658..39ad80ef 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java
@@ -16,7 +16,7 @@
 
 package com.tencent.tinker.build.info;
 
-import com.tencent.tinker.build.apkparser.AndroidManifest;
+import com.tencent.tinker.build.apkparser.AndroidParser;
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.build.util.TinkerPatchException;
 import com.tencent.tinker.build.util.TypedValue;
@@ -41,7 +41,7 @@ public PatchInfoGen(Configuration config) {
 
     private void addTinkerID() throws IOException, ParseException {
         if (!config.mPackageFields.containsKey(TypedValue.TINKER_ID)) {
-            AndroidManifest oldAndroidManifest = AndroidManifest.getAndroidManifest(config.mOldApkFile);
+            AndroidParser oldAndroidManifest = AndroidParser.getAndroidManifest(config.mOldApkFile);
             String tinkerID = oldAndroidManifest.metaDatas.get(TypedValue.TINKER_ID);
 
             if (tinkerID == null) {
@@ -51,7 +51,7 @@ private void addTinkerID() throws IOException, ParseException {
         }
 
         if (!config.mPackageFields.containsKey(TypedValue.NEW_TINKER_ID)) {
-            AndroidManifest newAndroidManifest = AndroidManifest.getAndroidManifest(config.mNewApkFile);
+            AndroidParser newAndroidManifest = AndroidParser.getAndroidManifest(config.mNewApkFile);
             String tinkerID = newAndroidManifest.metaDatas.get(TypedValue.TINKER_ID);
 
             if (tinkerID == null) {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
index 9b359eb5..e61122ff 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
@@ -83,6 +83,7 @@
     public File             mOldApkFile;
     public File             mNewApkFile;
     public boolean          mIgnoreWarning;
+
     /**
      * lib config
      */
@@ -213,6 +214,7 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
         mOutFolder = param.outFolder;
 
         mIgnoreWarning = param.ignoreWarning;
+
         mSevenZipPath = param.sevenZipPath;
         mPackageFields = param.configFields;
 
@@ -299,7 +301,8 @@ private void createTempDirectory() throws TinkerPatchException {
 
         String tempNewName = newApkName.substring(0, newApkName.indexOf(TypedValue.FILE_APK));
 
-        if (tempNewName.equals(tempOldName)) {
+        // Bugfix: For windows user, filename is case-insensitive.
+        if (tempNewName.equalsIgnoreCase(tempOldName)) {
             tempOldName += "-old";
             tempNewName += "-new";
         }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
index 6a217f47..e56d4eac 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
@@ -270,25 +270,25 @@ public Builder setUseSign(boolean useSign) {
 
         public InputParam create() {
             return new InputParam(
-                oldApk,
-                newApk,
-                outFolder,
-                signFile,
-                keypass,
-                storealias,
-                storepass,
-                ignoreWarning,
-                useSign,
-                dexFilePattern,
-                dexLoaderPattern,
-                dexMode,
-                soFilePattern,
-                resourceFilePattern,
-                resourceIgnoreChangePattern,
-                largeModSize,
-                useApplyResource,
-                configFields,
-                sevenZipPath
+                    oldApk,
+                    newApk,
+                    outFolder,
+                    signFile,
+                    keypass,
+                    storealias,
+                    storepass,
+                    ignoreWarning,
+                    useSign,
+                    dexFilePattern,
+                    dexLoaderPattern,
+                    dexMode,
+                    soFilePattern,
+                    resourceFilePattern,
+                    resourceIgnoreChangePattern,
+                    largeModSize,
+                    useApplyResource,
+                    configFields,
+                    sevenZipPath
             );
         }
     }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
index fe55d9a9..d0c99383 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
@@ -972,12 +972,12 @@ private boolean isSameEncodedValue(
             case EncodedValueReader.ENCODED_FLOAT: {
                 float oldFloat = oldAnnoReader.readFloat();
                 float newFloat = newAnnoReader.readFloat();
-                return oldFloat == newFloat;
+                return Float.compare(oldFloat, newFloat) == 0;
             }
             case EncodedValueReader.ENCODED_DOUBLE: {
                 double oldDouble = oldAnnoReader.readDouble();
                 double newDouble = newAnnoReader.readDouble();
-                return oldDouble == newDouble;
+                return Double.compare(oldDouble, newDouble) == 0;
             }
             case EncodedValueReader.ENCODED_STRING: {
                 int oldStringIdx = oldAnnoReader.readString();
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
index 965b87c8..93115188 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
@@ -34,7 +34,9 @@ public static void initLogger(Configuration config) throws IOException {
     }
 
     public static void closeLogger() {
-        logWriter.close();
+        if (logWriter != null) {
+            logWriter.close();
+        }
     }
 
     public static void d(final String msg) {
@@ -49,6 +51,7 @@ public static void d(final String format, final Object... obj) {
         }
         //add \n
         System.out.printf(log + "\n");
+        System.out.flush();
 
         logWriter.writeLineToInfoFile(log);
     }
@@ -64,8 +67,9 @@ public static void e(final String format, final Object... obj) {
         }
         //add \n
         System.err.printf(log + "\n");
-        logWriter.writeLineToInfoFile(log);
+        System.err.flush();
 
+        logWriter.writeLineToInfoFile(log);
     }
 
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
index 8d815700..13120a8d 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
@@ -59,7 +59,6 @@
     public static final String RES_MANIFEST    = "AndroidManifest.xml";
     public static final String RES_OUT         = "resources_out.zip";
     public static final String RES_OUT_7ZIP    = "resources_out_7z.zip";
-    public static final String RES_OUT_MD5_TAG = "%RES_OUT_MD5_TAG%";
 
     public static final int ADD       = 1;
     public static final int MOD       = 2;
@@ -71,4 +70,8 @@
     public static final String LARGE_MOD_TITLE = "large modify:";
     public static final String DEL_TITLE       = "delete:";
     public static final String PATTERN_TITLE   = "pattern:";
+
+    public static final String TEST_STRING_VALUE_A = "only use for test tinker resource: a";
+    public static final String TEST_STRING_VALUE_B = "only use for test tinker resource: b";
+
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
index bcc20917..fabadf31 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
@@ -24,9 +24,12 @@
 import com.tencent.tinker.commons.ziputil.TinkerZipOutputStream;
 
 import java.io.BufferedOutputStream;
+import java.io.BufferedReader;
+import java.io.Closeable;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Enumeration;
@@ -125,6 +128,9 @@ public static String genResOutputFile(File output, File newZipFile, Configuratio
                     );
                 }
                 String name = zipEntry.getName();
+                if (name.contains("../")) {
+                    continue;
+                }
                 if (Utils.checkFileInPattern(config.mResFilePattern, name)) {
                     //won't contain in add set.
                     if (!deletedSet.contains(name)
@@ -210,4 +216,33 @@ public static boolean checkBsDiffFileSize(File bsDiffFile, File newFile) {
         }
         return true;
     }
+
+    public static void closeQuietly(Closeable closeable) {
+        try {
+            if (closeable != null) {
+                closeable.close();
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void exec(ArrayList<String> args, File path) throws RuntimeException, IOException, InterruptedException {
+        ProcessBuilder ps = new ProcessBuilder(args);
+        ps.redirectErrorStream(true);
+        if (path != null) {
+            ps.directory(path);
+        }
+        Process pr = ps.start();
+        BufferedReader ins = new BufferedReader(new InputStreamReader(pr.getInputStream()));
+        String line;
+        while ((line = ins.readLine()) != null) {
+            System.out.println(line);
+        }
+        if (pr.waitFor() != 0) {
+            throw new RuntimeException("exec cmd failed! args: " + args);
+        }
+        ins.close();
+    }
+
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/resources/only_use_to_test_tinker_resource.txt b/tinker-build/tinker-patch-lib/src/main/resources/only_use_to_test_tinker_resource.txt
new file mode 100644
index 00000000..dc9c715f
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/resources/only_use_to_test_tinker_resource.txt
@@ -0,0 +1 @@
+#tinker resource changed
\ No newline at end of file
diff --git a/tinker-commons/build.gradle b/tinker-commons/build.gradle
index eb94594d..b7de68c6 100644
--- a/tinker-commons/build.gradle
+++ b/tinker-commons/build.gradle
@@ -5,13 +5,15 @@ group rootProject.ext.GROUP
 
 [compileJava, compileTestJava, javadoc]*.options*.encoding = 'UTF-8'
 
+
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
     compile project(':third-party:aosp-dexutils')
     compile project(':third-party:bsdiff-util')
 }
 
-task buildSdk(type: Copy, dependsOn: [build]) {
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
     from('build/libs') {
         include '*.jar'
         exclude '*javadoc.jar'
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatchApplier.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatchApplier.java
index 42d8c19b..1d9f7fef 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatchApplier.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatchApplier.java
@@ -33,8 +33,7 @@
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.TypeList;
 import com.tencent.tinker.android.dex.util.CompareUtils;
-import com.tencent.tinker.android.dx.util.Hex;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 import com.tencent.tinker.commons.dexpatcher.algorithms.patch.AnnotationSectionPatchAlgorithm;
 import com.tencent.tinker.commons.dexpatcher.algorithms.patch.AnnotationSetRefListSectionPatchAlgorithm;
 import com.tencent.tinker.commons.dexpatcher.algorithms.patch.AnnotationSetSectionPatchAlgorithm;
@@ -52,7 +51,6 @@
 import com.tencent.tinker.commons.dexpatcher.algorithms.patch.TypeIdSectionPatchAlgorithm;
 import com.tencent.tinker.commons.dexpatcher.algorithms.patch.TypeListSectionPatchAlgorithm;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
 
 import java.io.BufferedOutputStream;
 import java.io.File;
@@ -69,14 +67,9 @@
     private final Dex oldDex;
     private final Dex patchedDex;
 
-    /** May be null if we need to generate small patch. **/
     private final DexPatchFile patchFile;
 
-    private final SmallPatchedDexItemFile extraInfoFile;
-    private final IndexMap oldToFullPatchedIndexMap;
-    private final IndexMap patchedToSmallPatchedIndexMap;
-
-    private final String oldDexSignStr;
+    private final SparseIndexMap oldToPatchedIndexMap;
 
     private DexSectionPatchAlgorithm<StringData> stringDataSectionPatchAlg;
     private DexSectionPatchAlgorithm<Integer> typeIdSectionPatchAlg;
@@ -95,93 +88,21 @@
     private DexSectionPatchAlgorithm<AnnotationsDirectory> annotationsDirectorySectionPatchAlg;
 
     public DexPatchApplier(File oldDexIn, File patchFileIn) throws IOException {
-        this(
-                new Dex(oldDexIn),
-                (patchFileIn != null ? new DexPatchFile(patchFileIn) : null),
-                null
-        );
+        this(new Dex(oldDexIn), new DexPatchFile(patchFileIn));
     }
 
     public DexPatchApplier(InputStream oldDexIn, InputStream patchFileIn) throws IOException {
-        this(
-                new Dex(oldDexIn),
-                (patchFileIn != null ? new DexPatchFile(patchFileIn) : null),
-                null
-        );
-    }
-
-    public DexPatchApplier(InputStream oldDexIn, int initDexSize, InputStream patchFileIn) throws IOException {
-        this(
-                new Dex(oldDexIn, initDexSize),
-                (patchFileIn != null ? new DexPatchFile(patchFileIn) : null),
-                null
-        );
-    }
-
-    public DexPatchApplier(
-            File oldDexIn,
-            File patchFileIn,
-            SmallPatchedDexItemFile extraInfoFile
-    ) throws IOException {
-        this(
-                new Dex(oldDexIn),
-                (patchFileIn != null ? new DexPatchFile(patchFileIn) : null),
-                extraInfoFile
-        );
-    }
-
-    public DexPatchApplier(
-            InputStream oldDexIn,
-            InputStream patchFileIn,
-            SmallPatchedDexItemFile extraInfoFile
-    ) throws IOException {
-        this(
-                new Dex(oldDexIn),
-                (patchFileIn != null ? new DexPatchFile(patchFileIn) : null),
-                extraInfoFile
-        );
-    }
-
-    public DexPatchApplier(
-            InputStream oldDexIn,
-            int initDexSize,
-            InputStream patchFileIn,
-            SmallPatchedDexItemFile extraInfoFile
-    ) throws IOException {
-        this(
-                new Dex(oldDexIn, initDexSize),
-                (patchFileIn != null ? new DexPatchFile(patchFileIn) : null),
-                extraInfoFile
-        );
+        this(new Dex(oldDexIn), new DexPatchFile(patchFileIn));
     }
 
     public DexPatchApplier(
             Dex oldDexIn,
-            DexPatchFile patchFileIn,
-            SmallPatchedDexItemFile extraAddedDexElementsFile
+            DexPatchFile patchFileIn
     ) {
         this.oldDex = oldDexIn;
-        this.oldDexSignStr = Hex.toHexString(oldDexIn.computeSignature(false));
         this.patchFile = patchFileIn;
-        if (extraAddedDexElementsFile == null) {
-            this.patchedDex = new Dex(patchFileIn.getPatchedDexSize());
-        } else {
-            this.patchedDex = new Dex(
-                    extraAddedDexElementsFile.getPatchedDexSizeByOldDexSign(this.oldDexSignStr)
-            );
-        }
-        this.oldToFullPatchedIndexMap = new IndexMap();
-        this.patchedToSmallPatchedIndexMap = (extraAddedDexElementsFile != null ? new IndexMap() : null);
-        this.extraInfoFile = extraAddedDexElementsFile;
-
-        if ((patchFileIn == null) && (extraAddedDexElementsFile == null
-                || !extraAddedDexElementsFile.isAffectedOldDex(this.oldDexSignStr))) {
-            throw new UnsupportedOperationException(
-                    "patchFileIn is null, and extraAddedDexElementFile"
-                            + "(smallPatchInfo) is null or does not mention "
-                            + "oldDexIn."
-            );
-        }
+        this.patchedDex = new Dex(patchFileIn.getPatchedDexSize());
+        this.oldToPatchedIndexMap = new SparseIndexMap();
     }
 
     public void executeAndSaveTo(OutputStream out) throws IOException {
@@ -191,21 +112,19 @@ public void executeAndSaveTo(OutputStream out) throws IOException {
         if (oldDexSign == null) {
             throw new IOException("failed to compute old dex's signature.");
         }
-
-        if (this.patchFile != null) {
-            byte[] oldDexSignInPatchFile = this.patchFile.getOldDexSignature();
-            if (CompareUtils.uArrCompare(oldDexSign, oldDexSignInPatchFile) != 0) {
-                throw new IOException(
-                        String.format(
-                                "old dex signature mismatch! expected: %s, actual: %s",
-                                Arrays.toString(oldDexSign),
-                                Arrays.toString(oldDexSignInPatchFile)
-                        )
-                );
-            }
+        if (this.patchFile == null) {
+            throw new IllegalArgumentException("patch file is null.");
+        }
+        byte[] oldDexSignInPatchFile = this.patchFile.getOldDexSignature();
+        if (CompareUtils.uArrCompare(oldDexSign, oldDexSignInPatchFile) != 0) {
+            throw new IOException(
+                    String.format(
+                            "old dex signature mismatch! expected: %s, actual: %s",
+                            Arrays.toString(oldDexSign),
+                            Arrays.toString(oldDexSignInPatchFile)
+                    )
+            );
         }
-
-        String oldDexSignStr = Hex.toHexString(oldDexSign);
 
         // Firstly, set sections' offset after patched, sort according to their offset so that
         // the dex lib of aosp can calculate section size.
@@ -215,81 +134,42 @@ public void executeAndSaveTo(OutputStream out) throws IOException {
         patchedToc.header.size = 1;
         patchedToc.mapList.size = 1;
 
-        if (extraInfoFile == null || !extraInfoFile.isAffectedOldDex(this.oldDexSignStr)) {
-            patchedToc.stringIds.off
-                    = this.patchFile.getPatchedStringIdSectionOffset();
-            patchedToc.typeIds.off
-                    = this.patchFile.getPatchedTypeIdSectionOffset();
-            patchedToc.typeLists.off
-                    = this.patchFile.getPatchedTypeListSectionOffset();
-            patchedToc.protoIds.off
-                    = this.patchFile.getPatchedProtoIdSectionOffset();
-            patchedToc.fieldIds.off
-                    = this.patchFile.getPatchedFieldIdSectionOffset();
-            patchedToc.methodIds.off
-                    = this.patchFile.getPatchedMethodIdSectionOffset();
-            patchedToc.classDefs.off
-                    = this.patchFile.getPatchedClassDefSectionOffset();
-            patchedToc.mapList.off
-                    = this.patchFile.getPatchedMapListSectionOffset();
-            patchedToc.stringDatas.off
-                    = this.patchFile.getPatchedStringDataSectionOffset();
-            patchedToc.annotations.off
-                    = this.patchFile.getPatchedAnnotationSectionOffset();
-            patchedToc.annotationSets.off
-                    = this.patchFile.getPatchedAnnotationSetSectionOffset();
-            patchedToc.annotationSetRefLists.off
-                    = this.patchFile.getPatchedAnnotationSetRefListSectionOffset();
-            patchedToc.annotationsDirectories.off
-                    = this.patchFile.getPatchedAnnotationsDirectorySectionOffset();
-            patchedToc.encodedArrays.off
-                    = this.patchFile.getPatchedEncodedArraySectionOffset();
-            patchedToc.debugInfos.off
-                    = this.patchFile.getPatchedDebugInfoSectionOffset();
-            patchedToc.codes.off
-                    = this.patchFile.getPatchedCodeSectionOffset();
-            patchedToc.classDatas.off
-                    = this.patchFile.getPatchedClassDataSectionOffset();
-            patchedToc.fileSize
-                    = this.patchFile.getPatchedDexSize();
-        } else {
-            patchedToc.stringIds.off
-                    = this.extraInfoFile.getPatchedStringIdOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.typeIds.off
-                    = this.extraInfoFile.getPatchedTypeIdOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.typeLists.off
-                    = this.extraInfoFile.getPatchedTypeListOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.protoIds.off
-                    = this.extraInfoFile.getPatchedProtoIdOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.fieldIds.off
-                    = this.extraInfoFile.getPatchedFieldIdOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.methodIds.off
-                    = this.extraInfoFile.getPatchedMethodIdOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.classDefs.off
-                    = this.extraInfoFile.getPatchedClassDefOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.mapList.off
-                    = this.extraInfoFile.getPatchedMapListOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.stringDatas.off
-                    = this.extraInfoFile.getPatchedStringDataOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.annotations.off
-                    = this.extraInfoFile.getPatchedAnnotationOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.annotationSets.off
-                    = this.extraInfoFile.getPatchedAnnotationSetOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.annotationSetRefLists.off
-                    = this.extraInfoFile.getPatchedAnnotationSetRefListOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.annotationsDirectories.off
-                    = this.extraInfoFile.getPatchedAnnotationsDirectoryOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.encodedArrays.off
-                    = this.extraInfoFile.getPatchedEncodedArrayOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.debugInfos.off
-                    = this.extraInfoFile.getPatchedDebugInfoOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.codes.off
-                    = this.extraInfoFile.getPatchedCodeOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.classDatas.off
-                    = this.extraInfoFile.getPatchedClassDataOffsetByOldDexSign(oldDexSignStr);
-            patchedToc.fileSize
-                    = this.extraInfoFile.getPatchedDexSizeByOldDexSign(oldDexSignStr);
-        }
+        patchedToc.stringIds.off
+                = this.patchFile.getPatchedStringIdSectionOffset();
+        patchedToc.typeIds.off
+                = this.patchFile.getPatchedTypeIdSectionOffset();
+        patchedToc.typeLists.off
+                = this.patchFile.getPatchedTypeListSectionOffset();
+        patchedToc.protoIds.off
+                = this.patchFile.getPatchedProtoIdSectionOffset();
+        patchedToc.fieldIds.off
+                = this.patchFile.getPatchedFieldIdSectionOffset();
+        patchedToc.methodIds.off
+                = this.patchFile.getPatchedMethodIdSectionOffset();
+        patchedToc.classDefs.off
+                = this.patchFile.getPatchedClassDefSectionOffset();
+        patchedToc.mapList.off
+                = this.patchFile.getPatchedMapListSectionOffset();
+        patchedToc.stringDatas.off
+                = this.patchFile.getPatchedStringDataSectionOffset();
+        patchedToc.annotations.off
+                = this.patchFile.getPatchedAnnotationSectionOffset();
+        patchedToc.annotationSets.off
+                = this.patchFile.getPatchedAnnotationSetSectionOffset();
+        patchedToc.annotationSetRefLists.off
+                = this.patchFile.getPatchedAnnotationSetRefListSectionOffset();
+        patchedToc.annotationsDirectories.off
+                = this.patchFile.getPatchedAnnotationsDirectorySectionOffset();
+        patchedToc.encodedArrays.off
+                = this.patchFile.getPatchedEncodedArraySectionOffset();
+        patchedToc.debugInfos.off
+                = this.patchFile.getPatchedDebugInfoSectionOffset();
+        patchedToc.codes.off
+                = this.patchFile.getPatchedCodeSectionOffset();
+        patchedToc.classDatas.off
+                = this.patchFile.getPatchedClassDataSectionOffset();
+        patchedToc.fileSize
+                = this.patchFile.getPatchedDexSize();
 
         Arrays.sort(patchedToc.sections);
 
@@ -297,64 +177,49 @@ public void executeAndSaveTo(OutputStream out) throws IOException {
 
         // Secondly, run patch algorithms according to sections' dependencies.
         this.stringDataSectionPatchAlg = new StringDataSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.typeIdSectionPatchAlg = new TypeIdSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.protoIdSectionPatchAlg = new ProtoIdSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.fieldIdSectionPatchAlg = new FieldIdSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.methodIdSectionPatchAlg = new MethodIdSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.classDefSectionPatchAlg = new ClassDefSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.typeListSectionPatchAlg = new TypeListSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.annotationSetRefListSectionPatchAlg = new AnnotationSetRefListSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.annotationSetSectionPatchAlg = new AnnotationSetSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.classDataSectionPatchAlg = new ClassDataSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.codeSectionPatchAlg = new CodeSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.debugInfoSectionPatchAlg = new DebugInfoItemSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.annotationSectionPatchAlg = new AnnotationSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.encodedArraySectionPatchAlg = new StaticValueSectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
         this.annotationsDirectorySectionPatchAlg = new AnnotationsDirectorySectionPatchAlgorithm(
-                patchFile, oldDex, patchedDex, oldToFullPatchedIndexMap,
-                patchedToSmallPatchedIndexMap, extraInfoFile
+                patchFile, oldDex, patchedDex, oldToPatchedIndexMap
         );
 
         this.stringDataSectionPatchAlg.execute();
@@ -363,19 +228,15 @@ public void executeAndSaveTo(OutputStream out) throws IOException {
         this.protoIdSectionPatchAlg.execute();
         this.fieldIdSectionPatchAlg.execute();
         this.methodIdSectionPatchAlg.execute();
-        Runtime.getRuntime().gc();
         this.annotationSectionPatchAlg.execute();
         this.annotationSetSectionPatchAlg.execute();
         this.annotationSetRefListSectionPatchAlg.execute();
         this.annotationsDirectorySectionPatchAlg.execute();
-        Runtime.getRuntime().gc();
         this.debugInfoSectionPatchAlg.execute();
         this.codeSectionPatchAlg.execute();
-        Runtime.getRuntime().gc();
         this.classDataSectionPatchAlg.execute();
         this.encodedArraySectionPatchAlg.execute();
         this.classDefSectionPatchAlg.execute();
-        Runtime.getRuntime().gc();
 
         // Thirdly, write header, mapList. Calculate and write patched dex's sign and checksum.
         Dex.Section headerOut = this.patchedDex.openSection(patchedToc.header.off);
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatcherLogger.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatcherLogger.java
index 3ee24910..76b4ae65 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatcherLogger.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatcherLogger.java
@@ -7,6 +7,10 @@
 public final class DexPatcherLogger {
     private IDexPatcherLogger loggerImpl = null;
 
+    public IDexPatcherLogger getLoggerImpl() {
+        return this.loggerImpl;
+    }
+
     public void setLoggerImpl(IDexPatcherLogger dexPatcherLogger) {
         this.loggerImpl = dexPatcherLogger;
     }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSectionPatchAlgorithm.java
index 6d97bc26..66acfce3 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public AnnotationSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isAnnotationInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public AnnotationSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedAnnotationTocSec = patchedDex.getTableOfContents().annotations;
@@ -96,16 +61,7 @@ protected int getItemSize(Annotation item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedAnnotationSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected Annotation adjustItem(IndexMap indexMap, Annotation item) {
+    protected Annotation adjustItem(AbstractIndexMap indexMap, Annotation item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(Annotation patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapAnnotationOffset(oldOffset, newOffset);
+            sparseIndexMap.mapAnnotationOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markAnnotationDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markAnnotationDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSetRefListSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSetRefListSectionPatchAlgorithm.java
index e23ad8d2..5253c41c 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSetRefListSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSetRefListSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public AnnotationSetRefListSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isAnnotationSetRefListInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public AnnotationSetRefListSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedAnnotationSetRefListTocSec
@@ -98,16 +63,7 @@ protected int getItemSize(AnnotationSetRefList item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedAnnotationSetRefListSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected AnnotationSetRefList adjustItem(IndexMap indexMap, AnnotationSetRefList item) {
+    protected AnnotationSetRefList adjustItem(AbstractIndexMap indexMap, AnnotationSetRefList item) {
         return indexMap.adjust(item);
     }
 
@@ -118,14 +74,14 @@ protected int writePatchedItem(AnnotationSetRefList patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapAnnotationSetRefListOffset(oldOffset, newOffset);
+            sparseIndexMap.mapAnnotationSetRefListOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markAnnotationSetRefListDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markAnnotationSetRefListDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSetSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSetSectionPatchAlgorithm.java
index 738229c1..33a053ee 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSetSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationSetSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,45 +35,9 @@ public AnnotationSetSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isAnnotationSetInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public AnnotationSetSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
-
+        super(patchFile, oldDex, oldToPatchedIndexMap);
         if (patchedDex != null) {
             this.patchedAnnotationSetTocSec = patchedDex.getTableOfContents().annotationSets;
             this.patchedAnnotationSetSec = patchedDex.openSection(this.patchedAnnotationSetTocSec);
@@ -96,16 +60,7 @@ protected int getItemSize(AnnotationSet item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedAnnotationSetSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected AnnotationSet adjustItem(IndexMap indexMap, AnnotationSet item) {
+    protected AnnotationSet adjustItem(AbstractIndexMap indexMap, AnnotationSet item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +71,14 @@ protected int writePatchedItem(AnnotationSet patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapAnnotationSetOffset(oldOffset, newOffset);
+            sparseIndexMap.mapAnnotationSetOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markAnnotationSetDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markAnnotationSetDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationsDirectorySectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationsDirectorySectionPatchAlgorithm.java
index 508d4336..c0402270 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationsDirectorySectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/AnnotationsDirectorySectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public AnnotationsDirectorySectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isAnnotationsDirectoryInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public AnnotationsDirectorySectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedAnnotationsDirectoryTocSec = patchedDex.getTableOfContents().annotationsDirectories;
@@ -96,16 +61,7 @@ protected int getItemSize(AnnotationsDirectory item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedAnnotationsDirectorySectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected AnnotationsDirectory adjustItem(IndexMap indexMap, AnnotationsDirectory item) {
+    protected AnnotationsDirectory adjustItem(AbstractIndexMap indexMap, AnnotationsDirectory item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(AnnotationsDirectory patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapAnnotationsDirectoryOffset(oldOffset, newOffset);
+            sparseIndexMap.mapAnnotationsDirectoryOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markAnnotationsDirectoryDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markAnnotationsDirectoryDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ClassDataSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ClassDataSectionPatchAlgorithm.java
index 5881c215..570e8162 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ClassDataSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ClassDataSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public ClassDataSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isClassDataInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public ClassDataSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedClassDataTocSec = patchedDex.getTableOfContents().classDatas;
@@ -96,16 +61,7 @@ protected int getItemSize(ClassData item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedClassDataSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected ClassData adjustItem(IndexMap indexMap, ClassData item) {
+    protected ClassData adjustItem(AbstractIndexMap indexMap, ClassData item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(ClassData patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapClassDataOffset(oldOffset, newOffset);
+            sparseIndexMap.mapClassDataOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markClassDataDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markClassDataDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ClassDefSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ClassDefSectionPatchAlgorithm.java
index 86f25fbb..9af801ed 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ClassDefSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ClassDefSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public ClassDefSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isClassDefInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public ClassDefSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedClassDefTocSec = patchedDex.getTableOfContents().classDefs;
@@ -97,16 +62,7 @@ protected int getItemSize(ClassDef item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedClassDefSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected ClassDef adjustItem(IndexMap indexMap, ClassDef item) {
+    protected ClassDef adjustItem(AbstractIndexMap indexMap, ClassDef item) {
         return indexMap.adjust(item);
     }
 
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/CodeSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/CodeSectionPatchAlgorithm.java
index d12abd74..023a4afd 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/CodeSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/CodeSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public CodeSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isCodeInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public CodeSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedCodeTocSec = patchedDex.getTableOfContents().codes;
@@ -96,16 +61,7 @@ protected int getItemSize(Code item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedCodeSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected Code adjustItem(IndexMap indexMap, Code item) {
+    protected Code adjustItem(AbstractIndexMap indexMap, Code item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(Code patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapCodeOffset(oldOffset, newOffset);
+            sparseIndexMap.mapCodeOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markCodeDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markCodeDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DebugInfoItemSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DebugInfoItemSectionPatchAlgorithm.java
index 955f1771..86295e07 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DebugInfoItemSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DebugInfoItemSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public DebugInfoItemSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isDebugInfoInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public DebugInfoItemSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedDebugInfoItemTocSec = patchedDex.getTableOfContents().debugInfos;
@@ -96,16 +61,7 @@ protected int getItemSize(DebugInfoItem item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedDebugInfoSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected DebugInfoItem adjustItem(IndexMap indexMap, DebugInfoItem item) {
+    protected DebugInfoItem adjustItem(AbstractIndexMap indexMap, DebugInfoItem item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(DebugInfoItem patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapDebugInfoItemOffset(oldOffset, newOffset);
+            sparseIndexMap.mapDebugInfoItemOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markDebugInfoItemDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markDebugInfoItemDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DexSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DexSectionPatchAlgorithm.java
index 62b746f0..be68c43d 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DexSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/DexSectionPatchAlgorithm.java
@@ -17,12 +17,11 @@
 package com.tencent.tinker.commons.dexpatcher.algorithms.patch;
 
 import com.tencent.tinker.android.dex.Dex;
-import com.tencent.tinker.android.dex.SizeOf;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.Hex;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 import java.util.Arrays;
 
@@ -35,47 +34,18 @@
     protected final Dex oldDex;
 
     /**
-     * IndexMap for mapping old item to corresponding one in full patch.
+     * SparseIndexMap for mapping old item to corresponding one in patched item.
      */
-    private final IndexMap oldToFullPatchedIndexMap;
+    private final SparseIndexMap oldToPatchedIndexMap;
 
-    /**
-     * IndexMap for mapping item in full patch to corresponding one in small patch.
-     */
-    private final IndexMap fullPatchedToSmallPatchedIndexMap;
-
-    /**
-     * Signature string of dex we're processing. For extra info file usage.
-     */
-    private final String oldDexSignStr;
-    private SmallPatchedDexItemChooser smallPatchedDexItemChooser = null;
-
-    public DexSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap
-    ) {
-        this(patchFile, oldDex, oldToFullPatchedIndexMap, fullPatchedToSmallPatchedIndexMap, null);
-    }
-
-    public DexSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser smallPatchedDexItemChooser
-    ) {
+    public DexSectionPatchAlgorithm(DexPatchFile patchFile, Dex oldDex, SparseIndexMap oldToPatchedIndexMap) {
         this.patchFile = patchFile;
         this.oldDex = oldDex;
-        this.oldToFullPatchedIndexMap = oldToFullPatchedIndexMap;
-        this.fullPatchedToSmallPatchedIndexMap = fullPatchedToSmallPatchedIndexMap;
-        this.oldDexSignStr = Hex.toHexString(oldDex.computeSignature(false));
-        this.smallPatchedDexItemChooser = smallPatchedDexItemChooser;
+        this.oldToPatchedIndexMap = oldToPatchedIndexMap;
     }
 
     /**
-     * Get {@code Section} in {@code TableOfContents}.
+     * Get {@link TableOfContents.Section} from {@code dex}.
      */
     protected abstract TableOfContents.Section getTocSection(Dex dex);
 
@@ -90,43 +60,36 @@ public DexSectionPatchAlgorithm(
     protected abstract int getItemSize(T item);
 
     /**
-     * Adjust {@code item} using specific {@code indexMap}
+     * Adjust {@code item} using specific {@code sparseIndexMap}
      */
-    protected T adjustItem(IndexMap indexMap, T item) {
+    protected T adjustItem(AbstractIndexMap indexMap, T item) {
         return item;
     }
 
     /**
-     * Update index or offset mapping in {@code indexMap}.
+     * Update index or offset mapping in {@code sparseIndexMap}.
      */
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         // Should override by subclass if needed.
     }
 
     /**
-     * Mark deleted index or offset in {@code indexMap}.
+     * Mark deleted index or offset in {@code sparseIndexMap}.
+     *
+     * Here we mark deleted item for such a case like this:
+     *   Item in DebugInfo section reference a string in StringData section
+     *   by index X, while in patched dex, the referenced string is removed.
+     *
+     * The {@code sparseIndexMap} must be aware of this case and return -1
+     * instead of the original value X.
+     *
+     * Further more, the special value -1 is not chosen by our inspiration but
+     * the definition of NO_INDEX in document of dex file format.
      */
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
         // Should override by subclass if needed.
     }
 
-    /**
-     * Judge if item on index {@code patchedIndex} should be kept in small dex.
-     */
-    protected final boolean isPatchedItemInSmallPatchedDex(String oldDexSignStr, int patchedIndex) {
-        if (this.smallPatchedDexItemChooser != null) {
-            return this.smallPatchedDexItemChooser
-                    .isPatchedItemInSmallPatchedDex(oldDexSignStr, patchedIndex);
-        } else {
-            return true;
-        }
-    }
-
-    /**
-     * Return base offset of current section in full patched dex.
-     */
-    protected abstract int getFullPatchSectionBase();
-
     /**
      * Output patched item. This method should be overrided by subclass
      * so that patched item can be written to right place.
@@ -148,7 +111,7 @@ protected final boolean isPatchedItemInSmallPatchedDex(String oldDexSignStr, int
 
     /**
      * Adapter method for item's offset fetching, if an item is not
-     * inherited from {@code Item} (which means it is a simple item in dex section
+     * inherited from {@link TableOfContents.Section.Item} (which means it is a simple item in dex section
      * that doesn't need multiple members to describe), this method
      * return {@code index} instead.
      */
@@ -161,36 +124,16 @@ private int getItemOffsetOrIndex(int index, T item) {
     }
 
     public void execute() {
-        int deletedItemCount;
-        int[] deletedIndices;
-
-        int addedItemCount;
-        int[] addedIndices;
-
-        int replacedItemCount;
-        int[] replacedIndices;
+        final int deletedItemCount = patchFile.getBuffer().readUleb128();
+        final int[] deletedIndices = readDeltaIndiciesOrOffsets(deletedItemCount);
 
-        if (patchFile != null) {
-            deletedItemCount = patchFile.getBuffer().readUleb128();
-            deletedIndices = readDeltaIndiciesOrOffsets(deletedItemCount);
+        final int addedItemCount = patchFile.getBuffer().readUleb128();
+        final int[] addedIndices = readDeltaIndiciesOrOffsets(addedItemCount);
 
-            addedItemCount = patchFile.getBuffer().readUleb128();
-            addedIndices = readDeltaIndiciesOrOffsets(addedItemCount);
+        final int replacedItemCount = patchFile.getBuffer().readUleb128();
+        final int[] replacedIndices = readDeltaIndiciesOrOffsets(replacedItemCount);
 
-            replacedItemCount = patchFile.getBuffer().readUleb128();
-            replacedIndices = readDeltaIndiciesOrOffsets(replacedItemCount);
-        } else {
-            deletedItemCount = 0;
-            deletedIndices = new int[deletedItemCount];
-
-            addedItemCount = 0;
-            addedIndices = new int[addedItemCount];
-
-            replacedItemCount = 0;
-            replacedIndices = new int[replacedItemCount];
-        }
-
-        TableOfContents.Section tocSec = getTocSection(this.oldDex);
+        final TableOfContents.Section tocSec = getTocSection(this.oldDex);
         Dex.Section oldSection = null;
 
         int oldItemCount = 0;
@@ -201,17 +144,9 @@ public void execute() {
 
         // Now rest data are added and replaced items arranged in the order of
         // added indices and replaced indices.
-        boolean genFullPatchDex = (fullPatchedToSmallPatchedIndexMap == null);
-
-        if (genFullPatchDex) {
-            doFullPatch(
-                    oldSection, oldItemCount, deletedIndices, addedIndices, replacedIndices
-            );
-        } else {
-            doSmallPatch(
-                    oldSection, oldItemCount, deletedIndices, addedIndices, replacedIndices
-            );
-        }
+        doFullPatch(
+                oldSection, oldItemCount, deletedIndices, addedIndices, replacedIndices
+        );
     }
 
     private void doFullPatch(
@@ -247,20 +182,30 @@ private void doFullPatch(
             } else
             if (Arrays.binarySearch(deletedIndices, oldIndex) >= 0) {
                 T skippedOldItem = nextItem(oldSection); // skip old item.
+                markDeletedIndexOrOffset(
+                        oldToPatchedIndexMap,
+                        oldIndex,
+                        getItemOffsetOrIndex(oldIndex, skippedOldItem)
+                );
                 ++oldIndex;
                 ++deletedItemCounter;
             } else
             if (Arrays.binarySearch(replacedIndices, oldIndex) >= 0) {
                 T skippedOldItem = nextItem(oldSection); // skip old item.
+                markDeletedIndexOrOffset(
+                        oldToPatchedIndexMap,
+                        oldIndex,
+                        getItemOffsetOrIndex(oldIndex, skippedOldItem)
+                );
                 ++oldIndex;
             } else
             if (oldIndex < oldItemCount) {
-                T oldItem = adjustItem(this.oldToFullPatchedIndexMap, nextItem(oldSection));
+                T oldItem = adjustItem(this.oldToPatchedIndexMap, nextItem(oldSection));
 
                 int patchedOffset = writePatchedItem(oldItem);
 
                 updateIndexOrOffset(
-                        this.oldToFullPatchedIndexMap,
+                        this.oldToPatchedIndexMap,
                         oldIndex,
                         getItemOffsetOrIndex(oldIndex, oldItem),
                         patchedIndex,
@@ -290,147 +235,4 @@ private void doFullPatch(
             );
         }
     }
-
-    private void doSmallPatch(
-            Dex.Section oldSection,
-            int oldItemCount,
-            int[] deletedIndices,
-            int[] addedIndices,
-            int[] replacedIndices
-    ) {
-        int deletedItemCount = deletedIndices.length;
-        int addedItemCount = addedIndices.length;
-        int replacedItemCount = replacedIndices.length;
-        int newItemCount = oldItemCount + addedItemCount - deletedItemCount;
-
-        int deletedItemCounter = 0;
-        int addActionCursor = 0;
-        int replaceActionCursor = 0;
-
-        int oldIndex = 0;
-        int fullPatchedIndex = 0;
-        int fullPatchedOffset = getFullPatchSectionBase();
-        int smallPatchedIndex = 0;
-        while (oldIndex < oldItemCount || fullPatchedIndex < newItemCount) {
-            if (addActionCursor < addedItemCount && addedIndices[addActionCursor] == fullPatchedIndex) {
-                T addedItem = nextItem(patchFile.getBuffer());
-                ++addActionCursor;
-
-                if (getTocSection(oldDex).isElementFourByteAligned) {
-                    fullPatchedOffset = SizeOf.roundToTimesOfFour(fullPatchedOffset);
-                }
-
-                if (isPatchedItemInSmallPatchedDex(this.oldDexSignStr, fullPatchedIndex)) {
-                    T adjustedItem = adjustItem(fullPatchedToSmallPatchedIndexMap, addedItem);
-                    int smallPatchedOffset = writePatchedItem(adjustedItem);
-                    updateIndexOrOffset(
-                            fullPatchedToSmallPatchedIndexMap,
-                            fullPatchedIndex,
-                            fullPatchedOffset,
-                            smallPatchedIndex,
-                            smallPatchedOffset
-                    );
-                    ++smallPatchedIndex;
-                }
-
-                ++fullPatchedIndex;
-                fullPatchedOffset += getItemSize(addedItem);
-            } else
-            if (replaceActionCursor < replacedItemCount && replacedIndices[replaceActionCursor] == fullPatchedIndex) {
-                T replacedItem = nextItem(patchFile.getBuffer());
-                ++replaceActionCursor;
-
-                if (getTocSection(oldDex).isElementFourByteAligned) {
-                    fullPatchedOffset = SizeOf.roundToTimesOfFour(fullPatchedOffset);
-                }
-
-                if (isPatchedItemInSmallPatchedDex(this.oldDexSignStr, fullPatchedIndex)) {
-                    T adjustedItem = adjustItem(fullPatchedToSmallPatchedIndexMap, replacedItem);
-                    int smallPatchedOffset = writePatchedItem(adjustedItem);
-                    updateIndexOrOffset(
-                            fullPatchedToSmallPatchedIndexMap,
-                            fullPatchedIndex,
-                            fullPatchedOffset,
-                            smallPatchedIndex,
-                            smallPatchedOffset
-                    );
-                    ++smallPatchedIndex;
-                }
-
-                ++fullPatchedIndex;
-                fullPatchedOffset += getItemSize(replacedItem);
-            } else
-            if (Arrays.binarySearch(deletedIndices, oldIndex) >= 0) {
-                T skippedOldItem = nextItem(oldSection); // skip old item.
-                ++oldIndex;
-                ++deletedItemCounter;
-            } else
-            if (Arrays.binarySearch(replacedIndices, oldIndex) >= 0) {
-                T skippedOldItem = nextItem(oldSection); // skip old item.
-                ++oldIndex;
-            } else
-            if (oldIndex < oldItemCount) {
-                T oldItem = nextItem(oldSection);
-                T oldItemInFullPatch = adjustItem(this.oldToFullPatchedIndexMap, oldItem);
-
-                if (getTocSection(oldDex).isElementFourByteAligned) {
-                    fullPatchedOffset = SizeOf.roundToTimesOfFour(fullPatchedOffset);
-                }
-
-                if (isPatchedItemInSmallPatchedDex(this.oldDexSignStr, fullPatchedIndex)) {
-                    T patchedItemInSmallPatch = adjustItem(
-                            this.fullPatchedToSmallPatchedIndexMap, oldItemInFullPatch
-                    );
-                    int smallPatchedOffset = writePatchedItem(patchedItemInSmallPatch);
-                    updateIndexOrOffset(
-                            fullPatchedToSmallPatchedIndexMap,
-                            fullPatchedIndex,
-                            fullPatchedOffset,
-                            smallPatchedIndex,
-                            smallPatchedOffset
-                    );
-                    ++smallPatchedIndex;
-                }
-
-                updateIndexOrOffset(
-                        oldToFullPatchedIndexMap,
-                        oldIndex,
-                        getItemOffsetOrIndex(oldIndex, oldItem),
-                        fullPatchedIndex,
-                        fullPatchedOffset
-                );
-
-                ++fullPatchedIndex;
-                fullPatchedOffset += getItemSize(oldItemInFullPatch);
-
-                ++oldIndex;
-            }
-        }
-
-        if (addActionCursor != addedItemCount || deletedItemCounter != deletedItemCount
-                || replaceActionCursor != replacedItemCount
-        ) {
-            throw new IllegalStateException(
-                    String.format(
-                            "bad patch operation sequence. addCounter: %d, addCount: %d, "
-                                    + "delCounter: %d, delCount: %d, "
-                                    + "replaceCounter: %d, replaceCount:%d",
-                            addActionCursor,
-                            addedItemCount,
-                            deletedItemCounter,
-                            deletedItemCount,
-                            replaceActionCursor,
-                            replacedItemCount
-                    )
-            );
-        }
-    }
-
-    /**
-     * Indicates if an item in full patched dex with specific index
-     * should be kept in small patched dex of current old dex.
-     */
-    public interface SmallPatchedDexItemChooser {
-        boolean isPatchedItemInSmallPatchedDex(String oldDexSign, int patchedItemIndex);
-    }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/FieldIdSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/FieldIdSectionPatchAlgorithm.java
index f8cbd1da..9f6100ef 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/FieldIdSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/FieldIdSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.FieldId;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public FieldIdSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isFieldIdInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public FieldIdSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedFieldIdTocSec = patchedDex.getTableOfContents().fieldIds;
@@ -96,16 +61,7 @@ protected int getItemSize(FieldId item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedFieldIdSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected FieldId adjustItem(IndexMap indexMap, FieldId item) {
+    protected FieldId adjustItem(AbstractIndexMap indexMap, FieldId item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(FieldId patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapFieldIds(oldIndex, newIndex);
+            sparseIndexMap.mapFieldIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markFieldIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markFieldIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/MethodIdSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/MethodIdSectionPatchAlgorithm.java
index 5dcef75d..56e87630 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/MethodIdSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/MethodIdSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.MethodId;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public MethodIdSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isMethodIdInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public MethodIdSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedMethodIdTocSec = patchedDex.getTableOfContents().methodIds;
@@ -96,16 +61,7 @@ protected int getItemSize(MethodId item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedMethodIdSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected MethodId adjustItem(IndexMap indexMap, MethodId item) {
+    protected MethodId adjustItem(AbstractIndexMap indexMap, MethodId item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(MethodId patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapMethodIds(oldIndex, newIndex);
+            sparseIndexMap.mapMethodIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markMethodIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markMethodIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ProtoIdSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ProtoIdSectionPatchAlgorithm.java
index f427cfd9..e59beb69 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ProtoIdSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/ProtoIdSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.ProtoId;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public ProtoIdSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isProtoIdInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public ProtoIdSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedProtoIdTocSec = patchedDex.getTableOfContents().protoIds;
@@ -96,16 +61,7 @@ protected int getItemSize(ProtoId item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedProtoIdSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected ProtoId adjustItem(IndexMap indexMap, ProtoId item) {
+    protected ProtoId adjustItem(AbstractIndexMap indexMap, ProtoId item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(ProtoId patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapProtoIds(oldIndex, newIndex);
+            sparseIndexMap.mapProtoIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markProtoIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markProtoIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/StaticValueSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/StaticValueSectionPatchAlgorithm.java
index dd8f4bc9..c16dcc33 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/StaticValueSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/StaticValueSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.EncodedValue;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public StaticValueSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isEncodedArrayInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public StaticValueSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedEncodedValueTocSec = patchedDex.getTableOfContents().encodedArrays;
@@ -96,16 +61,7 @@ protected int getItemSize(EncodedValue item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedEncodedArraySectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected EncodedValue adjustItem(IndexMap indexMap, EncodedValue item) {
+    protected EncodedValue adjustItem(AbstractIndexMap indexMap, EncodedValue item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(EncodedValue patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapStaticValuesOffset(oldOffset, newOffset);
+            sparseIndexMap.mapStaticValuesOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markStaticValuesDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markStaticValuesDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/StringDataSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/StringDataSectionPatchAlgorithm.java
index 66df249e..959261bd 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/StringDataSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/StringDataSectionPatchAlgorithm.java
@@ -20,9 +20,8 @@
 import com.tencent.tinker.android.dex.StringData;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -33,48 +32,14 @@
     private Dex.Section patchedStringDataSec = null;
     private Dex.Section patchedStringIdSec = null;
 
-    public StringDataSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
-    ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isStringInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
 
     public StringDataSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedStringDataTocSec = patchedDex.getTableOfContents().stringDatas;
@@ -99,15 +64,6 @@ protected int getItemSize(StringData item) {
         return item.byteCountInDex();
     }
 
-    @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedStringDataSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
     @Override
     protected int writePatchedItem(StringData patchedItem) {
         int off = this.patchedStringDataSec.writeStringData(patchedItem);
@@ -118,14 +74,14 @@ protected int writePatchedItem(StringData patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapStringIds(oldIndex, newIndex);
+            sparseIndexMap.mapStringIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markStringIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markStringIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/TypeIdSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/TypeIdSectionPatchAlgorithm.java
index 4296ab4e..76c4b648 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/TypeIdSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/TypeIdSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.SizeOf;
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public TypeIdSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isTypeIdInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public TypeIdSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedTypeIdTocSec = patchedDex.getTableOfContents().typeIds;
@@ -96,16 +61,7 @@ protected int getItemSize(Integer item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedTypeIdSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected Integer adjustItem(IndexMap indexMap, Integer item) {
+    protected Integer adjustItem(AbstractIndexMap indexMap, Integer item) {
         return indexMap.adjustStringIndex(item);
     }
 
@@ -118,14 +74,14 @@ protected int writePatchedItem(Integer patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldIndex != newIndex) {
-            indexMap.mapTypeIds(oldIndex, newIndex);
+            sparseIndexMap.mapTypeIds(oldIndex, newIndex);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markTypeIdDeleted(deletedIndex);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markTypeIdDeleted(deletedIndex);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/TypeListSectionPatchAlgorithm.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/TypeListSectionPatchAlgorithm.java
index 2267a1ee..5b40c6f1 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/TypeListSectionPatchAlgorithm.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/algorithms/patch/TypeListSectionPatchAlgorithm.java
@@ -20,9 +20,9 @@
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.TypeList;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dx.util.IndexMap;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
+import com.tencent.tinker.commons.dexpatcher.util.AbstractIndexMap;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 
 /**
  * Created by tangyinsheng on 2016/7/4.
@@ -35,44 +35,9 @@ public TypeListSectionPatchAlgorithm(
             DexPatchFile patchFile,
             Dex oldDex,
             Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            final SmallPatchedDexItemFile extraInfoFile
+            SparseIndexMap oldToPatchedIndexMap
     ) {
-        this(
-                patchFile,
-                oldDex,
-                patchedDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                new SmallPatchedDexItemChooser() {
-                    @Override
-                    public boolean isPatchedItemInSmallPatchedDex(
-                            String oldDexSign, int patchedItemIndex
-                    ) {
-                        return extraInfoFile.isTypeListInSmallPatchedDex(
-                                oldDexSign, patchedItemIndex
-                        );
-                    }
-                }
-        );
-    }
-
-    public TypeListSectionPatchAlgorithm(
-            DexPatchFile patchFile,
-            Dex oldDex,
-            Dex patchedDex,
-            IndexMap oldToFullPatchedIndexMap,
-            IndexMap fullPatchedToSmallPatchedIndexMap,
-            SmallPatchedDexItemChooser spdItemChooser
-    ) {
-        super(
-                patchFile,
-                oldDex,
-                oldToFullPatchedIndexMap,
-                fullPatchedToSmallPatchedIndexMap,
-                spdItemChooser
-        );
+        super(patchFile, oldDex, oldToPatchedIndexMap);
 
         if (patchedDex != null) {
             this.patchedTypeListTocSec = patchedDex.getTableOfContents().typeLists;
@@ -96,16 +61,7 @@ protected int getItemSize(TypeList item) {
     }
 
     @Override
-    protected int getFullPatchSectionBase() {
-        if (this.patchFile != null) {
-            return this.patchFile.getPatchedTypeListSectionOffset();
-        } else {
-            return getTocSection(this.oldDex).off;
-        }
-    }
-
-    @Override
-    protected TypeList adjustItem(IndexMap indexMap, TypeList item) {
+    protected TypeList adjustItem(AbstractIndexMap indexMap, TypeList item) {
         return indexMap.adjust(item);
     }
 
@@ -116,14 +72,14 @@ protected int writePatchedItem(TypeList patchedItem) {
     }
 
     @Override
-    protected void updateIndexOrOffset(IndexMap indexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
+    protected void updateIndexOrOffset(SparseIndexMap sparseIndexMap, int oldIndex, int oldOffset, int newIndex, int newOffset) {
         if (oldOffset != newOffset) {
-            indexMap.mapTypeListOffset(oldOffset, newOffset);
+            sparseIndexMap.mapTypeListOffset(oldOffset, newOffset);
         }
     }
 
     @Override
-    protected void markDeletedIndexOrOffset(IndexMap indexMap, int deletedIndex, int deletedOffset) {
-        indexMap.markTypeListDeleted(deletedOffset);
+    protected void markDeletedIndexOrOffset(SparseIndexMap sparseIndexMap, int deletedIndex, int deletedOffset) {
+        sparseIndexMap.markTypeListDeleted(deletedOffset);
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/struct/DexPatchFile.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/struct/DexPatchFile.java
index 1cb356f4..edbbc9ee 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/struct/DexPatchFile.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/struct/DexPatchFile.java
@@ -17,7 +17,6 @@
 package com.tencent.tinker.commons.dexpatcher.struct;
 
 import com.tencent.tinker.android.dex.SizeOf;
-import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
 import com.tencent.tinker.android.dex.util.CompareUtils;
 import com.tencent.tinker.android.dex.util.FileUtils;
@@ -26,11 +25,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
 
 /**
  * Created by tangyinsheng on 2016/7/1.
@@ -106,116 +101,6 @@ private void init() {
         this.buffer.position(firstChunkOffset);
     }
 
-    private List<Integer> readDeltaIndiciesOrOffsets(int count) {
-        List<Integer> result = new ArrayList<>(count);
-        int lastVal = 0;
-        for (int i = 0; i < count; ++i) {
-            int delta = this.buffer.readSleb128();
-            lastVal = lastVal + delta;
-            result.add(lastVal);
-        }
-        return result;
-    }
-
-    private <T extends Comparable<T>> void readChunkData(
-            int sectionType, Set<Integer> deletedItemIndices, Map<Integer, T> indexToNewItemMap
-    ) {
-        int deletedItemCount = this.buffer.readUleb128();
-        List<Integer> deletedIndices = readDeltaIndiciesOrOffsets(deletedItemCount);
-        deletedItemIndices.addAll(deletedIndices);
-
-        int addedItemCount = this.buffer.readUleb128();
-        List<Integer> addedIndices = readDeltaIndiciesOrOffsets(addedItemCount);
-
-        int replacedItemCount = this.buffer.readUleb128();
-        List<Integer> replacedIndices = readDeltaIndiciesOrOffsets(replacedItemCount);
-
-        int addedIndexCursor = 0;
-        int replacedIndexCursor = 0;
-
-        while (addedIndexCursor < addedItemCount || replacedIndexCursor < replacedItemCount) {
-            if (addedIndexCursor >= addedItemCount) {
-                // rest items are all replaced item.
-                while (replacedIndexCursor < replacedItemCount) {
-                    T newItem = readItemBySectionType(sectionType);
-                    indexToNewItemMap.put(replacedIndexCursor, newItem);
-                    ++replacedIndexCursor;
-                }
-            } else
-            if (replacedIndexCursor >= replacedItemCount) {
-                // rest items are all added item.
-                while (addedIndexCursor < addedItemCount) {
-                    T newItem = readItemBySectionType(sectionType);
-                    indexToNewItemMap.put(addedIndexCursor, newItem);
-                    ++addedIndexCursor;
-                }
-            } else {
-                T newItem = readItemBySectionType(sectionType);
-                if (addedIndexCursor <= replacedIndexCursor) {
-                    indexToNewItemMap.put(addedIndexCursor, newItem);
-                    ++addedIndexCursor;
-                } else {
-                    indexToNewItemMap.put(replacedIndexCursor, newItem);
-                    ++replacedIndexCursor;
-                }
-            }
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    private <T extends Comparable<T>> T readItemBySectionType(int sectionType) {
-        switch (sectionType) {
-            case TableOfContents.SECTION_TYPE_TYPEIDS: {
-                return (T) (Integer) this.buffer.readInt();
-            }
-            case TableOfContents.SECTION_TYPE_PROTOIDS: {
-                return (T) this.buffer.readProtoId();
-            }
-            case TableOfContents.SECTION_TYPE_FIELDIDS: {
-                return (T) this.buffer.readFieldId();
-            }
-            case TableOfContents.SECTION_TYPE_METHODIDS: {
-                return (T) this.buffer.readMethodId();
-            }
-            case TableOfContents.SECTION_TYPE_CLASSDEFS: {
-                return (T) this.buffer.readClassDef();
-            }
-            case TableOfContents.SECTION_TYPE_STRINGDATAS: {
-                return (T) this.buffer.readStringData();
-            }
-            case TableOfContents.SECTION_TYPE_TYPELISTS: {
-                return (T) this.buffer.readTypeList();
-            }
-            case TableOfContents.SECTION_TYPE_ANNOTATIONS: {
-                return (T) this.buffer.readAnnotation();
-            }
-            case TableOfContents.SECTION_TYPE_ANNOTATIONSETS: {
-                return (T) this.buffer.readAnnotationSet();
-            }
-            case TableOfContents.SECTION_TYPE_ANNOTATIONSETREFLISTS: {
-                return (T) this.buffer.readAnnotationSetRefList();
-            }
-            case TableOfContents.SECTION_TYPE_ANNOTATIONSDIRECTORIES: {
-                return (T) this.buffer.readAnnotationsDirectory();
-            }
-            case TableOfContents.SECTION_TYPE_DEBUGINFOS: {
-                return (T) this.buffer.readDebugInfoItem();
-            }
-            case TableOfContents.SECTION_TYPE_CODES: {
-                return (T) this.buffer.readCode();
-            }
-            case TableOfContents.SECTION_TYPE_CLASSDATA: {
-                return (T) this.buffer.readClassData();
-            }
-            case TableOfContents.SECTION_TYPE_ENCODEDARRAYS: {
-                return (T) this.buffer.readEncodedArray();
-            }
-            default: {
-                return null;
-            }
-        }
-    }
-
     public short getVersion() {
         return version;
     }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/struct/SmallPatchedDexItemFile.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/struct/SmallPatchedDexItemFile.java
deleted file mode 100644
index 2fc9dd71..00000000
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/struct/SmallPatchedDexItemFile.java
+++ /dev/null
@@ -1,419 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.commons.dexpatcher.struct;
-
-import com.tencent.tinker.android.dex.SizeOf;
-import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.android.dex.util.CompareUtils;
-import com.tencent.tinker.android.dex.util.FileUtils;
-import com.tencent.tinker.android.dx.util.Hex;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.BitSet;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Created by tangyinsheng on 2016/8/10.
- */
-public final class SmallPatchedDexItemFile {
-    public static final byte[] MAGIC = {0x44, 0x44, 0x45, 0x58, 0x54, 0x52, 0x41}; // DDEXTRA
-    public static final short CURRENT_VERSION = 0x0001;
-    private final List<String> oldDexSigns = new ArrayList<>();
-
-    private final Map<String, DexOffsets> oldDexSignToOffsetInfoMap = new HashMap<>();
-
-    private final Map<String, BitSet>
-            oldDexSignToStringIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToTypeIdIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToTypeListIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToProtoIdIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToFieldIdIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToMethodIdIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToAnnotationIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToAnnotationSetIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToAnnotationSetRefListIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToAnnotationsDirectoryIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToEncodedArrayIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToDebugInfoIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToCodeIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToClassDataIndicesInSmallPatch = new HashMap<>();
-    private final Map<String, BitSet>
-            oldDexSignToClassDefIndicesInSmallPatch = new HashMap<>();
-    private int version;
-    private int firstChunkOffset;
-
-    private static final class DexOffsets {
-        int stringIdsOffset = -1;
-        int typeIdsOffset = -1;
-        int protoIdsOffset = -1;
-        int fieldIdsOffset = -1;
-        int methodIdsOffset = -1;
-        int classDefsOffset = -1;
-        int mapListOffset = -1;
-        int typeListsOffset = -1;
-        int annotationsOffset = -1;
-        int annotationSetsOffset = -1;
-        int annotationSetRefListsOffset = -1;
-        int annotationsDirectoriesOffset = -1;
-        int classDataItemsOffset = -1;
-        int codeItemsOffset = -1;
-        int stringDataItemsOffset = -1;
-        int debugInfoItemsOffset = -1;
-        int encodedArraysOffset = -1;
-        int dexSize = -1;
-    }
-
-    public SmallPatchedDexItemFile(File input) throws IOException {
-        DexDataBuffer buffer = new DexDataBuffer(ByteBuffer.wrap(FileUtils.readFile(input)));
-        init(buffer);
-    }
-
-    public SmallPatchedDexItemFile(InputStream is) throws IOException {
-        DexDataBuffer buffer = new DexDataBuffer(ByteBuffer.wrap(FileUtils.readStream(is)));
-        init(buffer);
-    }
-
-    private void init(DexDataBuffer buffer) throws IOException {
-        byte[] magic = buffer.readByteArray(MAGIC.length);
-        if (CompareUtils.uArrCompare(magic, MAGIC) != 0) {
-            throw new IllegalStateException(
-                    "bad dexdiff extra file magic: " + Arrays.toString(magic)
-            );
-        }
-        this.version = buffer.readShort();
-        if (this.version != CURRENT_VERSION) {
-            throw new IllegalStateException(
-                    "bad dexdiff extra file version: " + this.version + ", expected: " + CURRENT_VERSION
-            );
-        }
-
-        this.firstChunkOffset = buffer.readInt();
-        buffer.position(this.firstChunkOffset);
-
-        int oldDexSignCount = buffer.readUleb128();
-        for (int i = 0; i < oldDexSignCount; ++i) {
-            byte[] oldDexSign = buffer.readByteArray(SizeOf.SIGNATURE);
-            oldDexSigns.add(Hex.toHexString(oldDexSign));
-        }
-
-        for (int i = 0; i < oldDexSignCount; ++i) {
-            final String oldDexSign = oldDexSigns.get(i);
-            final DexOffsets dexOffsets = new DexOffsets();
-            dexOffsets.stringIdsOffset = buffer.readInt();
-            dexOffsets.typeIdsOffset = buffer.readInt();
-            dexOffsets.protoIdsOffset = buffer.readInt();
-            dexOffsets.fieldIdsOffset = buffer.readInt();
-            dexOffsets.methodIdsOffset = buffer.readInt();
-            dexOffsets.classDefsOffset = buffer.readInt();
-            dexOffsets.stringDataItemsOffset = buffer.readInt();
-            dexOffsets.typeListsOffset = buffer.readInt();
-            dexOffsets.annotationsOffset = buffer.readInt();
-            dexOffsets.annotationSetsOffset = buffer.readInt();
-            dexOffsets.annotationSetRefListsOffset = buffer.readInt();
-            dexOffsets.annotationsDirectoriesOffset = buffer.readInt();
-            dexOffsets.debugInfoItemsOffset = buffer.readInt();
-            dexOffsets.codeItemsOffset = buffer.readInt();
-            dexOffsets.classDataItemsOffset = buffer.readInt();
-            dexOffsets.encodedArraysOffset = buffer.readInt();
-            dexOffsets.mapListOffset = buffer.readInt();
-            dexOffsets.dexSize = buffer.readInt();
-            oldDexSignToOffsetInfoMap.put(oldDexSign, dexOffsets);
-        }
-
-        readDataChunk(buffer, oldDexSignToStringIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToTypeIdIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToTypeListIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToProtoIdIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToFieldIdIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToMethodIdIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToAnnotationIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToAnnotationSetIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToAnnotationSetRefListIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToAnnotationsDirectoryIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToEncodedArrayIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToDebugInfoIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToCodeIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToClassDataIndicesInSmallPatch);
-        readDataChunk(buffer, oldDexSignToClassDefIndicesInSmallPatch);
-    }
-
-    private void readDataChunk(
-            DexDataBuffer buffer, Map<String, BitSet> oldDexSignToIndicesInSmallPatchMap
-    ) {
-        int oldDexSignCount = oldDexSigns.size();
-        for (int i = 0; i < oldDexSignCount; ++i) {
-            int itemCount = buffer.readUleb128();
-            int prevIndex = 0;
-            for (int j = 0; j < itemCount; ++j) {
-                int indexDelta = buffer.readSleb128();
-                prevIndex += indexDelta;
-
-                final String oldDexSign = oldDexSigns.get(i);
-                BitSet indices = oldDexSignToIndicesInSmallPatchMap.get(oldDexSign);
-                if (indices == null) {
-                    indices = new BitSet();
-                    oldDexSignToIndicesInSmallPatchMap.put(oldDexSign, indices);
-                }
-
-                indices.set(prevIndex);
-            }
-        }
-    }
-
-    public boolean isAffectedOldDex(String oldDexSign) {
-        return this.oldDexSigns.contains(oldDexSign);
-    }
-
-    public boolean isSmallPatchedDexEmpty(String oldDexSign) {
-        BitSet indices = this.oldDexSignToClassDefIndicesInSmallPatch.get(oldDexSign);
-        return (indices == null || indices.isEmpty());
-    }
-
-    public int getPatchedStringIdOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.stringIdsOffset : -1;
-    }
-
-    public int getPatchedTypeIdOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.typeIdsOffset : -1;
-    }
-
-    public int getPatchedProtoIdOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.protoIdsOffset : -1;
-    }
-
-    public int getPatchedFieldIdOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.fieldIdsOffset : -1;
-    }
-
-    public int getPatchedMethodIdOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.methodIdsOffset : -1;
-    }
-
-    public int getPatchedClassDefOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.classDefsOffset : -1;
-    }
-
-    public int getPatchedMapListOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.mapListOffset : -1;
-    }
-
-    public int getPatchedTypeListOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.typeListsOffset : -1;
-    }
-
-    public int getPatchedAnnotationSetRefListOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.annotationSetRefListsOffset : -1;
-    }
-
-    public int getPatchedAnnotationSetOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.annotationSetsOffset : -1;
-    }
-
-    public int getPatchedClassDataOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.classDataItemsOffset : -1;
-    }
-
-    public int getPatchedCodeOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.codeItemsOffset : -1;
-    }
-
-    public int getPatchedStringDataOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.stringDataItemsOffset : -1;
-    }
-
-    public int getPatchedDebugInfoOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.debugInfoItemsOffset : -1;
-    }
-
-    public int getPatchedAnnotationOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.annotationsOffset : -1;
-    }
-
-    public int getPatchedEncodedArrayOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.encodedArraysOffset : -1;
-    }
-
-    public int getPatchedAnnotationsDirectoryOffsetByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.annotationsDirectoriesOffset : -1;
-    }
-
-    public int getPatchedDexSizeByOldDexSign(String oldDexSign) {
-        DexOffsets dexOffsets = this.oldDexSignToOffsetInfoMap.get(oldDexSign);
-        return dexOffsets != null ? dexOffsets.dexSize : -1;
-    }
-
-    public boolean isStringInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToStringIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isTypeIdInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToTypeIdIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isTypeListInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToTypeListIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isProtoIdInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToProtoIdIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isFieldIdInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToFieldIdIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isMethodIdInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToMethodIdIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isAnnotationInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToAnnotationIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isAnnotationSetInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToAnnotationSetIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isAnnotationSetRefListInSmallPatchedDex(
-            String oldDexSign, int indexInPatchedDex
-    ) {
-        BitSet indices = oldDexSignToAnnotationSetRefListIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isAnnotationsDirectoryInSmallPatchedDex(
-            String oldDexSign, int indexInPatchedDex
-    ) {
-        BitSet indices = oldDexSignToAnnotationsDirectoryIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isEncodedArrayInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToEncodedArrayIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isDebugInfoInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToDebugInfoIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isCodeInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToCodeIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isClassDataInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToClassDataIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-
-    public boolean isClassDefInSmallPatchedDex(String oldDexSign, int indexInPatchedDex) {
-        BitSet indices = oldDexSignToClassDefIndicesInSmallPatch.get(oldDexSign);
-        if (indices == null) {
-            return false;
-        }
-        return indices.get(indexInPatchedDex);
-    }
-}
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/util/IndexMap.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/AbstractIndexMap.java
similarity index 66%
rename from third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/util/IndexMap.java
rename to tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/AbstractIndexMap.java
index a9e46362..870320f0 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/util/IndexMap.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/AbstractIndexMap.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.tencent.tinker.android.dx.util;
+package com.tencent.tinker.commons.dexpatcher.util;
 
 import com.tencent.tinker.android.dex.Annotation;
 import com.tencent.tinker.android.dex.AnnotationSet;
@@ -35,297 +35,45 @@
 import com.tencent.tinker.android.dex.TypeList;
 import com.tencent.tinker.android.dex.util.ByteInput;
 import com.tencent.tinker.android.dex.util.ByteOutput;
-import com.tencent.tinker.android.utils.SparseIntArray;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
-import java.util.BitSet;
 
 /**
  * Created by tangyinsheng on 2016/6/29.
+ *
+ * *** This file is renamed from IndexMap in dx project. ***
  */
-public class IndexMap {
-    private final SparseIntArray stringIdsMap = new SparseIntArray();
-    private final SparseIntArray typeIdsMap = new SparseIntArray();
-    private final SparseIntArray protoIdsMap = new SparseIntArray();
-    private final SparseIntArray fieldIdsMap = new SparseIntArray();
-    private final SparseIntArray methodIdsMap = new SparseIntArray();
-    private final SparseIntArray typeListOffsetsMap = new SparseIntArray();
-    private final SparseIntArray annotationOffsetsMap = new SparseIntArray();
-    private final SparseIntArray annotationSetOffsetsMap = new SparseIntArray();
-    private final SparseIntArray annotationSetRefListOffsetsMap = new SparseIntArray();
-    private final SparseIntArray annotationsDirectoryOffsetsMap = new SparseIntArray();
-    private final SparseIntArray staticValuesOffsetsMap = new SparseIntArray();
-    private final SparseIntArray classDataOffsetsMap = new SparseIntArray();
-    private final SparseIntArray debugInfoItemOffsetsMap = new SparseIntArray();
-    private final SparseIntArray codeOffsetsMap = new SparseIntArray();
-
-    private final BitSet deletedStringIds = new BitSet();
-    private final BitSet deletedTypeIds = new BitSet();
-    private final BitSet deletedProtoIds = new BitSet();
-    private final BitSet deletedFieldIds = new BitSet();
-    private final BitSet deletedMethodIds = new BitSet();
-    private final BitSet deletedTypeListOffsets = new BitSet();
-    private final BitSet deletedAnnotationOffsets = new BitSet();
-    private final BitSet deletedAnnotationSetOffsets = new BitSet();
-    private final BitSet deletedAnnotationSetRefListOffsets = new BitSet();
-    private final BitSet deletedAnnotationsDirectoryOffsets = new BitSet();
-    private final BitSet deletedStaticValuesOffsets = new BitSet();
-    private final BitSet deletedClassDataOffsets = new BitSet();
-    private final BitSet deletedDebugInfoItemOffsets = new BitSet();
-    private final BitSet deletedCodeOffsets = new BitSet();
-
-    public void mapStringIds(int oldIndex, int newIndex) {
-        stringIdsMap.put(oldIndex, newIndex);
-    }
-
-    public void markStringIdDeleted(int index) {
-        if (index < 0) return;
-        deletedStringIds.set(index);
-    }
-
-    public void mapTypeIds(int oldIndex, int newIndex) {
-        typeIdsMap.put(oldIndex, newIndex);
-    }
-
-    public void markTypeIdDeleted(int index) {
-        if (index < 0) return;
-        deletedTypeIds.set(index);
-    }
-
-    public void mapProtoIds(int oldIndex, int newIndex) {
-        protoIdsMap.put(oldIndex, newIndex);
-    }
-
-    public void markProtoIdDeleted(int index) {
-        if (index < 0) return;
-        deletedProtoIds.set(index);
-    }
-
-    public void mapFieldIds(int oldIndex, int newIndex) {
-        fieldIdsMap.put(oldIndex, newIndex);
-    }
-
-    public void markFieldIdDeleted(int index) {
-        if (index < 0) return;
-        deletedFieldIds.set(index);
-    }
-
-    public void mapMethodIds(int oldIndex, int newIndex) {
-        methodIdsMap.put(oldIndex, newIndex);
-    }
-
-    public void markMethodIdDeleted(int index) {
-        if (index < 0) return;
-        deletedMethodIds.set(index);
-    }
-
-    public void mapTypeListOffset(int oldOffset, int newOffset) {
-        typeListOffsetsMap.put(oldOffset, newOffset);
-    }
 
-    public void markTypeListDeleted(int offset) {
-        if (offset < 0) return;
-        deletedTypeListOffsets.set(offset);
-    }
+public abstract class AbstractIndexMap {
 
-    public void mapAnnotationOffset(int oldOffset, int newOffset) {
-        annotationOffsetsMap.put(oldOffset, newOffset);
-    }
+    public abstract int adjustStringIndex(int stringIndex);
 
-    public void markAnnotationDeleted(int offset) {
-        if (offset < 0) return;
-        deletedAnnotationOffsets.set(offset);
-    }
+    public abstract int adjustTypeIdIndex(int typeIdIndex);
 
-    public void mapAnnotationSetOffset(int oldOffset, int newOffset) {
-        annotationSetOffsetsMap.put(oldOffset, newOffset);
-    }
+    public abstract int adjustProtoIdIndex(int protoIndex);
 
-    public void markAnnotationSetDeleted(int offset) {
-        if (offset < 0) return;
-        deletedAnnotationSetOffsets.set(offset);
-    }
+    public abstract int adjustFieldIdIndex(int fieldIndex);
 
-    public void mapAnnotationSetRefListOffset(int oldOffset, int newOffset) {
-        annotationSetRefListOffsetsMap.put(oldOffset, newOffset);
-    }
+    public abstract int adjustMethodIdIndex(int methodIndex);
 
-    public void markAnnotationSetRefListDeleted(int offset) {
-        if (offset < 0) return;
-        deletedAnnotationSetRefListOffsets.set(offset);
-    }
+    public abstract int adjustTypeListOffset(int typeListOffset);
 
-    public void mapAnnotationsDirectoryOffset(int oldOffset, int newOffset) {
-        annotationsDirectoryOffsetsMap.put(oldOffset, newOffset);
-    }
+    public abstract int adjustAnnotationOffset(int annotationOffset);
 
-    public void markAnnotationsDirectoryDeleted(int offset) {
-        if (offset < 0) return;
-        deletedAnnotationsDirectoryOffsets.set(offset);
-    }
+    public abstract int adjustAnnotationSetOffset(int annotationSetOffset);
 
-    public void mapStaticValuesOffset(int oldOffset, int newOffset) {
-        staticValuesOffsetsMap.put(oldOffset, newOffset);
-    }
+    public abstract int adjustAnnotationSetRefListOffset(int annotationSetRefListOffset);
 
-    public void markStaticValuesDeleted(int offset) {
-        if (offset < 0) return;
-        deletedStaticValuesOffsets.set(offset);
-    }
-
-    public void mapClassDataOffset(int oldOffset, int newOffset) {
-        classDataOffsetsMap.put(oldOffset, newOffset);
-    }
-
-    public void markClassDataDeleted(int offset) {
-        if (offset < 0) return;
-        deletedClassDataOffsets.set(offset);
-    }
+    public abstract int adjustAnnotationsDirectoryOffset(int annotationsDirectoryOffset);
 
-    public void mapDebugInfoItemOffset(int oldOffset, int newOffset) {
-        debugInfoItemOffsetsMap.put(oldOffset, newOffset);
-    }
+    public abstract int adjustStaticValuesOffset(int staticValuesOffset);
 
-    public void markDebugInfoItemDeleted(int offset) {
-        if (offset < 0) return;
-        deletedDebugInfoItemOffsets.set(offset);
-    }
+    public abstract int adjustClassDataOffset(int classDataOffset);
 
-    public void mapCodeOffset(int oldOffset, int newOffset) {
-        codeOffsetsMap.put(oldOffset, newOffset);
-    }
-
-    public void markCodeDeleted(int offset) {
-        if (offset < 0) return;
-        deletedCodeOffsets.set(offset);
-    }
+    public abstract int adjustDebugInfoItemOffset(int debugInfoItemOffset);
 
-    public int adjustStringIndex(int stringIndex) {
-        int index = stringIdsMap.indexOfKey(stringIndex);
-        if (index < 0) {
-            return (stringIndex >= 0 && deletedStringIds.get(stringIndex) ? -1 : stringIndex);
-        } else {
-            return stringIdsMap.valueAt(index);
-        }
-    }
-
-    public int adjustTypeIdIndex(int typeIdIndex) {
-        int index = typeIdsMap.indexOfKey(typeIdIndex);
-        if (index < 0) {
-            return (typeIdIndex >= 0 && deletedTypeIds.get(typeIdIndex) ? -1 : typeIdIndex);
-        } else {
-            return typeIdsMap.valueAt(index);
-        }
-    }
-
-    public int adjustProtoIdIndex(int protoIndex) {
-        int index = protoIdsMap.indexOfKey(protoIndex);
-        if (index < 0) {
-            return (protoIndex >= 0 && deletedProtoIds.get(protoIndex) ? -1 : protoIndex);
-        } else {
-            return protoIdsMap.valueAt(index);
-        }
-    }
-
-    public int adjustFieldIdIndex(int fieldIndex) {
-        int index = fieldIdsMap.indexOfKey(fieldIndex);
-        if (index < 0) {
-            return (fieldIndex >= 0 && deletedFieldIds.get(fieldIndex) ? -1 : fieldIndex);
-        } else {
-            return fieldIdsMap.valueAt(index);
-        }
-    }
-
-    public int adjustMethodIdIndex(int methodIndex) {
-        int index = methodIdsMap.indexOfKey(methodIndex);
-        if (index < 0) {
-            return (methodIndex >= 0 && deletedMethodIds.get(methodIndex) ? -1 : methodIndex);
-        } else {
-            return methodIdsMap.valueAt(index);
-        }
-    }
-
-    public int adjustTypeListOffset(int typeListOffset) {
-        int index = typeListOffsetsMap.indexOfKey(typeListOffset);
-        if (index < 0) {
-            return (typeListOffset >= 0 && deletedTypeListOffsets.get(typeListOffset) ? -1 : typeListOffset);
-        } else {
-            return typeListOffsetsMap.valueAt(index);
-        }
-    }
-
-    public int adjustAnnotationOffset(int annotationOffset) {
-        int index = annotationOffsetsMap.indexOfKey(annotationOffset);
-        if (index < 0) {
-            return (annotationOffset >= 0 && deletedAnnotationOffsets.get(annotationOffset) ? -1 : annotationOffset);
-        } else {
-            return annotationOffsetsMap.valueAt(index);
-        }
-    }
-
-    public int adjustAnnotationSetOffset(int annotationSetOffset) {
-        int index = annotationSetOffsetsMap.indexOfKey(annotationSetOffset);
-        if (index < 0) {
-            return (annotationSetOffset >= 0 && deletedAnnotationSetOffsets.get(annotationSetOffset) ? -1 : annotationSetOffset);
-        } else {
-            return annotationSetOffsetsMap.valueAt(index);
-        }
-    }
-
-    public int adjustAnnotationSetRefListOffset(int annotationSetRefListOffset) {
-        int index = annotationSetRefListOffsetsMap.indexOfKey(annotationSetRefListOffset);
-        if (index < 0) {
-            return (annotationSetRefListOffset >= 0 && deletedAnnotationSetRefListOffsets.get(annotationSetRefListOffset) ? -1 : annotationSetRefListOffset);
-        } else {
-            return annotationSetRefListOffsetsMap.valueAt(index);
-        }
-    }
-
-    public int adjustAnnotationsDirectoryOffset(int annotationsDirectoryOffset) {
-        int index = annotationsDirectoryOffsetsMap.indexOfKey(annotationsDirectoryOffset);
-        if (index < 0) {
-            return (annotationsDirectoryOffset >= 0 && deletedAnnotationsDirectoryOffsets.get(annotationsDirectoryOffset) ? -1 : annotationsDirectoryOffset);
-        } else {
-            return annotationsDirectoryOffsetsMap.valueAt(index);
-        }
-    }
-
-    public int adjustStaticValuesOffset(int staticValuesOffset) {
-        int index = staticValuesOffsetsMap.indexOfKey(staticValuesOffset);
-        if (index < 0) {
-            return (staticValuesOffset >= 0 && deletedStaticValuesOffsets.get(staticValuesOffset) ? -1 : staticValuesOffset);
-        } else {
-            return staticValuesOffsetsMap.valueAt(index);
-        }
-    }
-
-    public int adjustClassDataOffset(int classDataOffset) {
-        int index = classDataOffsetsMap.indexOfKey(classDataOffset);
-        if (index < 0) {
-            return (classDataOffset >= 0 && deletedClassDataOffsets.get(classDataOffset) ? -1 : classDataOffset);
-        } else {
-            return classDataOffsetsMap.valueAt(index);
-        }
-    }
-
-    public int adjustDebugInfoItemOffset(int debugInfoItemOffset) {
-        int index = debugInfoItemOffsetsMap.indexOfKey(debugInfoItemOffset);
-        if (index < 0) {
-            return (debugInfoItemOffset >= 0 && deletedDebugInfoItemOffsets.get(debugInfoItemOffset) ? -1 : debugInfoItemOffset);
-        } else {
-            return debugInfoItemOffsetsMap.valueAt(index);
-        }
-    }
-
-    public int adjustCodeOffset(int codeOffset) {
-        int index = codeOffsetsMap.indexOfKey(codeOffset);
-        if (index < 0) {
-            return (codeOffset >= 0 && deletedCodeOffsets.get(codeOffset) ? -1 : codeOffset);
-        } else {
-            return codeOffsetsMap.valueAt(index);
-        }
-    }
+    public abstract int adjustCodeOffset(int codeOffset);
 
     public TypeList adjust(TypeList typeList) {
         if (typeList == TypeList.EMPTY) {
diff --git a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/util/InstructionTransformer.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/InstructionTransformer.java
similarity index 96%
rename from third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/util/InstructionTransformer.java
rename to tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/InstructionTransformer.java
index cc6562d2..3a1b590b 100644
--- a/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/util/InstructionTransformer.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/InstructionTransformer.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.tencent.tinker.android.dx.util;
+package com.tencent.tinker.commons.dexpatcher.util;
 
 import com.tencent.tinker.android.dex.DexException;
 import com.tencent.tinker.android.dx.instruction.InstructionCodec;
@@ -31,9 +31,9 @@
  * Created by tangyinsheng on 2016/6/29.
  */
 public final class InstructionTransformer {
-    private final com.tencent.tinker.android.dx.util.IndexMap indexMap;
+    private final AbstractIndexMap indexMap;
 
-    public InstructionTransformer(com.tencent.tinker.android.dx.util.IndexMap indexMap) {
+    public InstructionTransformer(AbstractIndexMap indexMap) {
         this.indexMap = indexMap;
     }
 
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/SparseIndexMap.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/SparseIndexMap.java
new file mode 100644
index 00000000..f922079a
--- /dev/null
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/util/SparseIndexMap.java
@@ -0,0 +1,324 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.commons.dexpatcher.util;
+
+import com.tencent.tinker.android.utils.SparseBoolArray;
+import com.tencent.tinker.android.utils.SparseIntArray;
+
+/**
+ * Created by tangyinsheng on 2016/6/29.
+ *
+ * *** This file is renamed from IndexMap in dx project. ***
+ */
+
+public class SparseIndexMap extends AbstractIndexMap {
+    private final SparseIntArray stringIdsMap = new SparseIntArray();
+    private final SparseIntArray typeIdsMap = new SparseIntArray();
+    private final SparseIntArray protoIdsMap = new SparseIntArray();
+    private final SparseIntArray fieldIdsMap = new SparseIntArray();
+    private final SparseIntArray methodIdsMap = new SparseIntArray();
+    private final SparseIntArray typeListOffsetsMap = new SparseIntArray();
+    private final SparseIntArray annotationOffsetsMap = new SparseIntArray();
+    private final SparseIntArray annotationSetOffsetsMap = new SparseIntArray();
+    private final SparseIntArray annotationSetRefListOffsetsMap = new SparseIntArray();
+    private final SparseIntArray annotationsDirectoryOffsetsMap = new SparseIntArray();
+    private final SparseIntArray staticValuesOffsetsMap = new SparseIntArray();
+    private final SparseIntArray classDataOffsetsMap = new SparseIntArray();
+    private final SparseIntArray debugInfoItemOffsetsMap = new SparseIntArray();
+    private final SparseIntArray codeOffsetsMap = new SparseIntArray();
+
+    private final SparseBoolArray deletedStringIds = new SparseBoolArray();
+    private final SparseBoolArray deletedTypeIds = new SparseBoolArray();
+    private final SparseBoolArray deletedProtoIds = new SparseBoolArray();
+    private final SparseBoolArray deletedFieldIds = new SparseBoolArray();
+    private final SparseBoolArray deletedMethodIds = new SparseBoolArray();
+    private final SparseBoolArray deletedTypeListOffsets = new SparseBoolArray();
+    private final SparseBoolArray deletedAnnotationOffsets = new SparseBoolArray();
+    private final SparseBoolArray deletedAnnotationSetOffsets = new SparseBoolArray();
+    private final SparseBoolArray deletedAnnotationSetRefListOffsets = new SparseBoolArray();
+    private final SparseBoolArray deletedAnnotationsDirectoryOffsets = new SparseBoolArray();
+    private final SparseBoolArray deletedStaticValuesOffsets = new SparseBoolArray();
+    private final SparseBoolArray deletedClassDataOffsets = new SparseBoolArray();
+    private final SparseBoolArray deletedDebugInfoItemOffsets = new SparseBoolArray();
+    private final SparseBoolArray deletedCodeOffsets = new SparseBoolArray();
+
+    public void mapStringIds(int oldIndex, int newIndex) {
+        stringIdsMap.put(oldIndex, newIndex);
+    }
+
+    public void markStringIdDeleted(int index) {
+        if (index < 0) return;
+        deletedStringIds.put(index, true);
+    }
+
+    public void mapTypeIds(int oldIndex, int newIndex) {
+        typeIdsMap.put(oldIndex, newIndex);
+    }
+
+    public void markTypeIdDeleted(int index) {
+        if (index < 0) return;
+        deletedTypeIds.put(index, true);
+    }
+
+    public void mapProtoIds(int oldIndex, int newIndex) {
+        protoIdsMap.put(oldIndex, newIndex);
+    }
+
+    public void markProtoIdDeleted(int index) {
+        if (index < 0) return;
+        deletedProtoIds.put(index, true);
+    }
+
+    public void mapFieldIds(int oldIndex, int newIndex) {
+        fieldIdsMap.put(oldIndex, newIndex);
+    }
+
+    public void markFieldIdDeleted(int index) {
+        if (index < 0) return;
+        deletedFieldIds.put(index, true);
+    }
+
+    public void mapMethodIds(int oldIndex, int newIndex) {
+        methodIdsMap.put(oldIndex, newIndex);
+    }
+
+    public void markMethodIdDeleted(int index) {
+        if (index < 0) return;
+        deletedMethodIds.put(index, true);
+    }
+
+    public void mapTypeListOffset(int oldOffset, int newOffset) {
+        typeListOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markTypeListDeleted(int offset) {
+        if (offset < 0) return;
+        deletedTypeListOffsets.put(offset, true);
+    }
+
+    public void mapAnnotationOffset(int oldOffset, int newOffset) {
+        annotationOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markAnnotationDeleted(int offset) {
+        if (offset < 0) return;
+        deletedAnnotationOffsets.put(offset, true);
+    }
+
+    public void mapAnnotationSetOffset(int oldOffset, int newOffset) {
+        annotationSetOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markAnnotationSetDeleted(int offset) {
+        if (offset < 0) return;
+        deletedAnnotationSetOffsets.put(offset, true);
+    }
+
+    public void mapAnnotationSetRefListOffset(int oldOffset, int newOffset) {
+        annotationSetRefListOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markAnnotationSetRefListDeleted(int offset) {
+        if (offset < 0) return;
+        deletedAnnotationSetRefListOffsets.put(offset, true);
+    }
+
+    public void mapAnnotationsDirectoryOffset(int oldOffset, int newOffset) {
+        annotationsDirectoryOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markAnnotationsDirectoryDeleted(int offset) {
+        if (offset < 0) return;
+        deletedAnnotationsDirectoryOffsets.put(offset, true);
+    }
+
+    public void mapStaticValuesOffset(int oldOffset, int newOffset) {
+        staticValuesOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markStaticValuesDeleted(int offset) {
+        if (offset < 0) return;
+        deletedStaticValuesOffsets.put(offset, true);
+    }
+
+    public void mapClassDataOffset(int oldOffset, int newOffset) {
+        classDataOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markClassDataDeleted(int offset) {
+        if (offset < 0) return;
+        deletedClassDataOffsets.put(offset, true);
+    }
+
+    public void mapDebugInfoItemOffset(int oldOffset, int newOffset) {
+        debugInfoItemOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markDebugInfoItemDeleted(int offset) {
+        if (offset < 0) return;
+        deletedDebugInfoItemOffsets.put(offset, true);
+    }
+
+    public void mapCodeOffset(int oldOffset, int newOffset) {
+        codeOffsetsMap.put(oldOffset, newOffset);
+    }
+
+    public void markCodeDeleted(int offset) {
+        if (offset < 0) return;
+        deletedCodeOffsets.put(offset, true);
+    }
+
+    @Override
+    public int adjustStringIndex(int stringIndex) {
+        int index = stringIdsMap.indexOfKey(stringIndex);
+        if (index < 0) {
+            return (stringIndex >= 0 && deletedStringIds.containsKey(stringIndex) ? -1 : stringIndex);
+        } else {
+            return stringIdsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustTypeIdIndex(int typeIdIndex) {
+        int index = typeIdsMap.indexOfKey(typeIdIndex);
+        if (index < 0) {
+            return (typeIdIndex >= 0 && deletedTypeIds.containsKey(typeIdIndex) ? -1 : typeIdIndex);
+        } else {
+            return typeIdsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustProtoIdIndex(int protoIndex) {
+        int index = protoIdsMap.indexOfKey(protoIndex);
+        if (index < 0) {
+            return (protoIndex >= 0 && deletedProtoIds.containsKey(protoIndex) ? -1 : protoIndex);
+        } else {
+            return protoIdsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustFieldIdIndex(int fieldIndex) {
+        int index = fieldIdsMap.indexOfKey(fieldIndex);
+        if (index < 0) {
+            return (fieldIndex >= 0 && deletedFieldIds.containsKey(fieldIndex) ? -1 : fieldIndex);
+        } else {
+            return fieldIdsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustMethodIdIndex(int methodIndex) {
+        int index = methodIdsMap.indexOfKey(methodIndex);
+        if (index < 0) {
+            return (methodIndex >= 0 && deletedMethodIds.containsKey(methodIndex) ? -1 : methodIndex);
+        } else {
+            return methodIdsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustTypeListOffset(int typeListOffset) {
+        int index = typeListOffsetsMap.indexOfKey(typeListOffset);
+        if (index < 0) {
+            return (typeListOffset >= 0 && deletedTypeListOffsets.containsKey(typeListOffset) ? -1 : typeListOffset);
+        } else {
+            return typeListOffsetsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustAnnotationOffset(int annotationOffset) {
+        int index = annotationOffsetsMap.indexOfKey(annotationOffset);
+        if (index < 0) {
+            return (annotationOffset >= 0 && deletedAnnotationOffsets.containsKey(annotationOffset) ? -1 : annotationOffset);
+        } else {
+            return annotationOffsetsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustAnnotationSetOffset(int annotationSetOffset) {
+        int index = annotationSetOffsetsMap.indexOfKey(annotationSetOffset);
+        if (index < 0) {
+            return (annotationSetOffset >= 0 && deletedAnnotationSetOffsets.containsKey(annotationSetOffset) ? -1 : annotationSetOffset);
+        } else {
+            return annotationSetOffsetsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustAnnotationSetRefListOffset(int annotationSetRefListOffset) {
+        int index = annotationSetRefListOffsetsMap.indexOfKey(annotationSetRefListOffset);
+        if (index < 0) {
+            return (annotationSetRefListOffset >= 0 && deletedAnnotationSetRefListOffsets.containsKey(annotationSetRefListOffset) ? -1 : annotationSetRefListOffset);
+        } else {
+            return annotationSetRefListOffsetsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustAnnotationsDirectoryOffset(int annotationsDirectoryOffset) {
+        int index = annotationsDirectoryOffsetsMap.indexOfKey(annotationsDirectoryOffset);
+        if (index < 0) {
+            return (annotationsDirectoryOffset >= 0 && deletedAnnotationsDirectoryOffsets.containsKey(annotationsDirectoryOffset) ? -1 : annotationsDirectoryOffset);
+        } else {
+            return annotationsDirectoryOffsetsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustStaticValuesOffset(int staticValuesOffset) {
+        int index = staticValuesOffsetsMap.indexOfKey(staticValuesOffset);
+        if (index < 0) {
+            return (staticValuesOffset >= 0 && deletedStaticValuesOffsets.containsKey(staticValuesOffset) ? -1 : staticValuesOffset);
+        } else {
+            return staticValuesOffsetsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustClassDataOffset(int classDataOffset) {
+        int index = classDataOffsetsMap.indexOfKey(classDataOffset);
+        if (index < 0) {
+            return (classDataOffset >= 0 && deletedClassDataOffsets.containsKey(classDataOffset) ? -1 : classDataOffset);
+        } else {
+            return classDataOffsetsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustDebugInfoItemOffset(int debugInfoItemOffset) {
+        int index = debugInfoItemOffsetsMap.indexOfKey(debugInfoItemOffset);
+        if (index < 0) {
+            return (debugInfoItemOffset >= 0 && deletedDebugInfoItemOffsets.containsKey(debugInfoItemOffset) ? -1 : debugInfoItemOffset);
+        } else {
+            return debugInfoItemOffsetsMap.valueAt(index);
+        }
+    }
+
+    @Override
+    public int adjustCodeOffset(int codeOffset) {
+        int index = codeOffsetsMap.indexOfKey(codeOffset);
+        if (index < 0) {
+            return (codeOffset >= 0 && deletedCodeOffsets.containsKey(codeOffset) ? -1 : codeOffset);
+        } else {
+            return codeOffsetsMap.valueAt(index);
+        }
+    }
+}
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipEntry.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipEntry.java
index a1f03235..54510611 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipEntry.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipEntry.java
@@ -418,7 +418,7 @@ public String toString() {
         sb.append("\ncrc:" + crc);
         sb.append("\ncompressionMethod:" + compressionMethod);
         sb.append("\nmodDate:" + modDate);
-        sb.append("\nextra:" + extra);
+        sb.append("\nextra length:" + extra.length);
         sb.append("\nlocalHeaderRelOffset:" + localHeaderRelOffset);
         sb.append("\ndataOffset:" + dataOffset);
         return sb.toString();
diff --git a/tinker-sample-android/app/build.gradle b/tinker-sample-android/app/build.gradle
index b93277be..269372f3 100644
--- a/tinker-sample-android/app/build.gradle
+++ b/tinker-sample-android/app/build.gradle
@@ -6,17 +6,33 @@ dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
     testCompile 'junit:junit:4.12'
     compile "com.android.support:appcompat-v7:23.1.1"
-    compile("com.tencent.tinker:tinker-android-lib:${TINKER_VERSION}")
-    compile("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}")
+    compile("com.tencent.tinker:tinker-android-lib:${TINKER_VERSION}") { changing = true }
+    provided("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
+
     compile "com.android.support:multidex:1.0.1"
 
     //use to test multiDex
 //    compile group: 'com.google.guava', name: 'guava', version: '19.0'
 //    compile "org.scala-lang:scala-library:2.11.7"
+
+    //use for local maven test
+//    compile("com.tencent.tinker:tinker-android-loader:${TINKER_VERSION}") { changing = true }
+//    compile("com.tencent.tinker:aosp-dexutils:${TINKER_VERSION}") { changing = true }
+//    compile("com.tencent.tinker:bsdiff-util:${TINKER_VERSION}") { changing = true }
+//    compile("com.tencent.tinker:tinker-commons:${TINKER_VERSION}") { changing = true }
+
 }
 
 def gitSha() {
-    return 'git rev-parse --short HEAD'.execute().text.trim()
+    try {
+        String gitRev = 'git rev-parse --short HEAD'.execute(null, project.rootDir).text.trim()
+        if (gitRev == null) {
+            throw new GradleException("can't get git rev, you should add git to system path or just input test value, such as 'testTinkerId'")
+        }
+        return gitRev
+    } catch (Exception e) {
+        throw new GradleException("can't get git rev, you should add git to system path or just input test value, such as 'testTinkerId'")
+    }
 }
 
 def javaVersion = JavaVersion.VERSION_1_7
@@ -61,12 +77,6 @@ android {
          * you can use multiDex and install it in your ApplicationLifeCycle implement
          */
         multiDexEnabled true
-        /**
-         * not like proguard, multiDexKeepProguard is not a list, so we can't just
-         * add for you in our task. you can copy tinker keep rules at
-         * build/intermediates/tinker_intermediates/tinker_multidexkeep.pro
-         */
-        multiDexKeepProguard file("keep_in_main_dex.txt")
         /**
          * buildConfig can change during patch!
          * we can use the newly value when patch
@@ -77,9 +87,14 @@ android {
          * client version would update with patch
          * so we can get the newly git version easily!
          */
-        buildConfigField "String", "CLIENTVERSION", "\"${gitSha()}\""
+        buildConfigField "String", "TINKER_ID", "\"${getTinkerIdValue()}\""
         buildConfigField "String", "PLATFORM",  "\"all\""
     }
+
+//    aaptOptions{
+//        cruncherEnabled false
+//    }
+
 //    //use to test flavors support
 //    productFlavors {
 //        flavor1 {
@@ -120,13 +135,17 @@ def bakPath = file("${buildDir}/bakApk/")
 ext {
     //for some reason, you may want to ignore tinkerBuild, such as instant run debug build?
     tinkerEnabled = true
-    //you should bak the following files
+
+    //for normal build
     //old apk file to build patch apk
-    tinkerOldApkPath = "${bakPath}/app-debug-0919-20-32-57.apk"
+    tinkerOldApkPath = "${bakPath}/app-debug-1018-17-32-47.apk"
     //proguard mapping file to build patch apk
-    tinkerApplyMappingPath = "${bakPath}/"
+    tinkerApplyMappingPath = "${bakPath}/app-debug-1018-17-32-47-mapping.txt"
     //resource R.txt to build patch apk, must input if there is resource changed
-    tinkerApplyResourcePath = "${bakPath}/"
+    tinkerApplyResourcePath = "${bakPath}/app-debug-1018-17-32-47-R.txt"
+
+    //only use for build all flavor, if not, just ignore this field
+    tinkerBuildFlavorDirectory = "${bakPath}/app-1018-17-32-47"
 }
 
 
@@ -150,6 +169,10 @@ def buildWithTinker() {
     return hasProperty("TINKER_ENABLE") ? TINKER_ENABLE : ext.tinkerEnabled
 }
 
+def getTinkerBuildFlavorDirectory() {
+    return ext.tinkerBuildFlavorDirectory
+}
+
 if (buildWithTinker()) {
     apply plugin: 'com.tencent.tinker.patch'
 
@@ -176,6 +199,7 @@ if (buildWithTinker()) {
          * case 5: resources.arsc has changed, but we don't use applyResourceMapping to build
          */
         ignoreWarning = false
+
         /**
          * optionaldefault 'true'
          * whether sign the patch file
@@ -184,6 +208,12 @@ if (buildWithTinker()) {
          */
         useSign = true
 
+        /**
+         * optionaldefault 'true'
+         * whether use tinker to build
+         */
+        tinkerEnable = buildWithTinker()
+
         /**
          * Warning, applyMapping will affect the normal android build!
          */
@@ -210,6 +240,12 @@ if (buildWithTinker()) {
              * we will gen the tinkerId in your manifest automatic
              */
             tinkerId = getTinkerIdValue()
+
+            /**
+             * if keepDexApply is true, class in which dex refer to the old apk.
+             * open this can reduce the dex diff file size.
+             */
+            keepDexApply = false
         }
 
         dex {
@@ -221,6 +257,7 @@ if (buildWithTinker()) {
              * or you want to save rom or check quicker, you can use raw mode also
              */
             dexMode = "jar"
+
             /**
              * necessarydefault '[]'
              * what dexes in apk are expected to deal with tinkerPatch
@@ -237,8 +274,7 @@ if (buildWithTinker()) {
              * own tinkerLoader, and the classes you use in them
              *
              */
-            loader = ["com.tencent.tinker.loader.*",
-                      "tinker.sample.android.SampleApplication",
+            loader = [
                       //use sample, let BaseBuildInfo unchangeable with tinker
                       "tinker.sample.android.app.BaseBuildInfo"
             ]
@@ -252,7 +288,7 @@ if (buildWithTinker()) {
              * for library in assets, we would just recover them in the patch directory
              * you can get them in TinkerLoadResult with Tinker
              */
-            pattern = ["lib/armeabi/*.so"]
+            pattern = ["lib/*/*.so"]
         }
 
         res {
@@ -297,7 +333,10 @@ if (buildWithTinker()) {
              * Then you can use patch conditional!
              */
             configField("platform", "all")
-
+            /**
+             * patch version via packageConfig
+             */
+            configField("patchVersion", "1.0")
         }
         //or you can add config filed outside, or get meta value from old apk
         //project.tinkerPatch.packageConfig.configField("test1", project.tinkerPatch.packageConfig.getMetaDataFromOldApk("Test"))
@@ -311,7 +350,7 @@ if (buildWithTinker()) {
              * optionaldefault '7za'
              * the 7zip artifact path, it will use the right 7za with your platform
              */
-            zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
+           zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
             /**
              * optionaldefault '7za'
              * you can specify the 7za path yourself, it will overwrite the zipArtifact value
@@ -320,33 +359,87 @@ if (buildWithTinker()) {
         }
     }
 
-/**
- * task type, you want to bak
- */
-    def taskName = "debug"
-/**
- * bak apk and mapping
- */
-    tasks.getByName("assemble${taskName.capitalize()}") {
-        it.doLast {
-            copy {
-                def date = new Date().format("MMdd-HH-mm-ss")
-                from "${buildDir}/outputs/apk/${project.getName()}-${taskName}.apk"
-                into bakPath
-                rename { String fileName ->
-                    fileName.replace("${project.getName()}-${taskName}.apk", "${project.getName()}-${taskName}-${date}.apk")
+    List<String> flavors = new ArrayList<>();
+    project.android.productFlavors.each {flavor ->
+        flavors.add(flavor.name)
+    }
+    boolean hasFlavors = flavors.size() > 0
+    /**
+    * bak apk and mapping
+    */
+    android.applicationVariants.all { variant ->
+        /**
+         * task type, you want to bak
+         */
+        def taskName = variant.name
+        def date = new Date().format("MMdd-HH-mm-ss")
+
+        tasks.all {
+            if ("assemble${taskName.capitalize()}".equalsIgnoreCase(it.name)) {
+
+                it.doLast {
+                    copy {
+                        def fileNamePrefix = "${project.name}-${variant.baseName}"
+                        def newFileNamePrefix = hasFlavors ? "${fileNamePrefix}" : "${fileNamePrefix}-${date}"
+
+                        def destPath = hasFlavors ? file("${bakPath}/${project.name}-${date}/${variant.flavorName}") : bakPath
+                        from variant.outputs.outputFile
+                        into destPath
+                        rename { String fileName ->
+                            fileName.replace("${fileNamePrefix}.apk", "${newFileNamePrefix}.apk")
+                        }
+
+                        from "${buildDir}/outputs/mapping/${variant.dirName}/mapping.txt"
+                        into destPath
+                        rename { String fileName ->
+                            fileName.replace("mapping.txt", "${newFileNamePrefix}-mapping.txt")
+                        }
+
+                        from "${buildDir}/intermediates/symbols/${variant.dirName}/R.txt"
+                        into destPath
+                        rename { String fileName ->
+                            fileName.replace("R.txt", "${newFileNamePrefix}-R.txt")
+                        }
+                    }
                 }
+            }
+        }
+    }
+    project.afterEvaluate {
+        //sample use for build all flavor for one time
+        if (hasFlavors) {
+            task(tinkerPatchAllFlavorRelease) {
+                group = 'tinker'
+                def originOldPath = getTinkerBuildFlavorDirectory()
+                for (String flavor : flavors) {
+                    def tinkerTask = tasks.getByName("tinkerPatch${flavor.capitalize()}Release")
+                    dependsOn tinkerTask
+                    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}ReleaseManifest")
+                    preAssembleTask.doFirst {
+                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 15)
+                        project.tinkerPatch.oldApk = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release.apk"
+                        project.tinkerPatch.buildConfig.applyMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-mapping.txt"
+                        project.tinkerPatch.buildConfig.applyResourceMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-R.txt"
+
+                    }
 
-                from "${buildDir}/outputs/mapping/${taskName}/mapping.txt"
-                into bakPath
-                rename { String fileName ->
-                    fileName.replace("mapping.txt", "${project.getName()}-${taskName}-${date}-mapping.txt")
                 }
+            }
+
+            task(tinkerPatchAllFlavorDebug) {
+                group = 'tinker'
+                def originOldPath = getTinkerBuildFlavorDirectory()
+                for (String flavor : flavors) {
+                    def tinkerTask = tasks.getByName("tinkerPatch${flavor.capitalize()}Debug")
+                    dependsOn tinkerTask
+                    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}DebugManifest")
+                    preAssembleTask.doFirst {
+                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 13)
+                        project.tinkerPatch.oldApk = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug.apk"
+                        project.tinkerPatch.buildConfig.applyMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-mapping.txt"
+                        project.tinkerPatch.buildConfig.applyResourceMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-R.txt"
+                    }
 
-                from "${buildDir}/intermediates/symbols/${taskName}/R.txt"
-                into bakPath
-                rename { String fileName ->
-                    fileName.replace("R.txt", "${project.getName()}-${taskName}-${date}-R.txt")
                 }
             }
         }
diff --git a/tinker-sample-android/app/keep_in_main_dex.txt b/tinker-sample-android/app/keep_in_main_dex.txt
deleted file mode 100644
index 12c1dcf5..00000000
--- a/tinker-sample-android/app/keep_in_main_dex.txt
+++ /dev/null
@@ -1,26 +0,0 @@
-# you can copy the tinker keep rule at
-# build/intermediates/tinker_intermediates/tinker_multidexkeep.pro
-
--keep class com.tencent.tinker.loader.** {
-    *;
-}
-
--keep class tinker.sample.android.app.SampleApplication {
-    *;
-}
-
--keep public class * implements com.tencent.tinker.loader.app.ApplicationLifeCycle {
-    *;
-}
-
--keep public class * extends com.tencent.tinker.loader.TinkerLoader {
-    *;
-}
-
--keep public class * extends com.tencent.tinker.loader.app.TinkerApplication {
-    *;
-}
-
-# here, it is your own keep rules.
-# you must be careful that the class name you write won't be proguard
-# but the tinker class above is OK, we have already keep for you!
diff --git a/tinker-sample-android/app/libs/armeabi/libstlport_shared.so b/tinker-sample-android/app/libs/armeabi/libstlport_shared.so
deleted file mode 100755
index 050818bb..00000000
Binary files a/tinker-sample-android/app/libs/armeabi/libstlport_shared.so and /dev/null differ
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BaseBuildInfo.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BaseBuildInfo.java
index 4ffa7d4d..eca15927 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BaseBuildInfo.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BaseBuildInfo.java
@@ -16,10 +16,13 @@
 
 package tinker.sample.android.app;
 
+import tinker.sample.android.BuildConfig;
+
 /**
  * Created by zhangshaowen on 16/6/30.
  * we add BaseBuildInfo to loader pattern, so it won't change with patch!
  */
 public class BaseBuildInfo {
     public static String TEST_MESSAGE = "I won't change with tinker patch!";
+    public static String BASE_TINKER_ID = BuildConfig.TINKER_ID;
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BuildInfo.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BuildInfo.java
index 58ea3527..e1d73f52 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BuildInfo.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BuildInfo.java
@@ -31,7 +31,7 @@
     public static int     VERSION_CODE = BuildConfig.VERSION_CODE;
 
     public static String MESSAGE       = BuildConfig.MESSAGE;
-    public static String CLIENTVERSION = BuildConfig.CLIENTVERSION;
+    public static String TINKER_ID     = BuildConfig.TINKER_ID;
     public static String PLATFORM      = BuildConfig.PLATFORM;
 
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
index bc55dc62..6bc8122b 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
@@ -30,6 +30,7 @@
 import android.widget.Button;
 import android.widget.TextView;
 
+import com.tencent.tinker.lib.library.TinkerLoadLibrary;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
@@ -64,9 +65,16 @@ public void onClick(View v) {
         loadLibraryButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
-                //for lib/armeabi, just use TinkerInstaller.loadLibrary
-                TinkerInstaller.loadArmLibrary(getApplicationContext(), "stlport_shared");
+                // #method 1, hack classloader library path
+                TinkerLoadLibrary.installNavitveLibraryABI(getApplicationContext(), "armeabi");
+                System.loadLibrary("stlport_shared");
+
+                // #method 2, for lib/armeabi, just use TinkerInstaller.loadLibrary
+//                TinkerLoadLibrary.loadArmLibrary(getApplicationContext(), "stlport_shared");
+
+                // #method 3, load tinker patch library directly
 //                TinkerInstaller.loadLibraryFromTinker(getApplicationContext(), "assets/x86", "stlport_shared");
+
             }
         });
 
@@ -84,6 +92,7 @@ public void onClick(View v) {
         killSelfButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
+                ShareTinkerInternals.killAllOtherProcess(getApplicationContext());
                 android.os.Process.killProcess(android.os.Process.myPid());
             }
         });
@@ -104,16 +113,19 @@ public boolean showInfo(Context context) {
         Tinker tinker = Tinker.with(getApplicationContext());
         if (tinker.isTinkerLoaded()) {
             sb.append(String.format("[patch is loaded] \n"));
-            sb.append(String.format("[buildConfig CLIENTVERSION] %s \n", BuildInfo.CLIENTVERSION));
+            sb.append(String.format("[buildConfig TINKER_ID] %s \n", BuildInfo.TINKER_ID));
+            sb.append(String.format("[buildConfig BASE_TINKER_ID] %s \n", BaseBuildInfo.BASE_TINKER_ID));
+
             sb.append(String.format("[buildConfig MESSSAGE] %s \n", BuildInfo.MESSAGE));
             sb.append(String.format("[TINKER_ID] %s \n", tinker.getTinkerLoadResultIfPresent().getPackageConfigByName(ShareConstants.TINKER_ID)));
-            sb.append(String.format("[REAL TINKER_ID] %s \n", tinker.getTinkerLoadResultIfPresent().getTinkerID()));
             sb.append(String.format("[packageConfig patchMessage] %s \n", tinker.getTinkerLoadResultIfPresent().getPackageConfigByName("patchMessage")));
             sb.append(String.format("[TINKER_ID Rom Space] %d k \n", tinker.getTinkerRomSpace()));
 
         } else {
             sb.append(String.format("[patch is not loaded] \n"));
-            sb.append(String.format("[buildConfig CLIENTVERSION] %s \n", BuildInfo.CLIENTVERSION));
+            sb.append(String.format("[buildConfig TINKER_ID] %s \n", BuildInfo.TINKER_ID));
+            sb.append(String.format("[buildConfig BASE_TINKER_ID] %s \n", BaseBuildInfo.BASE_TINKER_ID));
+
             sb.append(String.format("[buildConfig MESSSAGE] %s \n", BuildInfo.MESSAGE));
             sb.append(String.format("[TINKER_ID] %s \n", ShareTinkerInternals.getManifestTinkerID(getApplicationContext())));
         }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
index 48ddaf4e..9233951e 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
@@ -20,12 +20,11 @@
 import android.app.Application;
 import android.content.Context;
 import android.content.Intent;
-import android.content.res.AssetManager;
-import android.content.res.Resources;
 import android.os.Build;
 import android.support.multidex.MultiDex;
 
 import com.tencent.tinker.anno.DefaultLifeCycle;
+import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
 import com.tencent.tinker.loader.app.ApplicationLifeCycle;
 import com.tencent.tinker.loader.app.DefaultApplicationLike;
@@ -64,9 +63,8 @@
     private static final String TAG = "Tinker.SampleApplicationLike";
 
     public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,
-                                 long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent,
-                                 Resources[] resources, ClassLoader[] classLoader, AssetManager[] assetManager) {
-        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent, resources, classLoader, assetManager);
+                                 long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) {
+        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);
     }
 
     /**
@@ -83,8 +81,9 @@ public void onBaseContextAttached(Context base) {
         MultiDex.install(base);
 
         SampleApplicationContext.application = getApplication();
-        SampleApplicationContext.context = getApplication().getApplicationContext();
+        SampleApplicationContext.context = getApplication();
         TinkerManager.setTinkerApplicationLike(this);
+
         TinkerManager.initFastCrashProtect();
         //should set before tinker is installed
         TinkerManager.setUpgradeRetryEnable(true);
@@ -95,6 +94,7 @@ public void onBaseContextAttached(Context base) {
         //installTinker after load multiDex
         //or you can put com.tencent.tinker.** to main dex
         TinkerManager.installTinker(this);
+        Tinker tinker = Tinker.with(getApplication());
     }
 
     @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
index b98bbb4d..a4c6c184 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
@@ -19,7 +19,6 @@
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.os.SystemClock;
-import android.widget.Toast;
 
 import com.tencent.tinker.lib.tinker.TinkerApplicationHelper;
 import com.tencent.tinker.lib.util.TinkerLog;
@@ -66,38 +65,42 @@ public void uncaughtException(Thread thread, Throwable ex) {
      * If it use Xposed, we can just clean patch or mention user to uninstall it.
      */
     private void tinkerPreVerifiedCrashHandler(Throwable ex) {
-        if (Utils.isXposedExists(ex)) {
-            //method 1
-            ApplicationLike applicationLike = TinkerManager.getTinkerApplicationLike();
-            if (applicationLike == null || applicationLike.getApplication() == null) {
-                return;
+        Throwable throwable = ex;
+        boolean isXposed = false;
+        while (throwable != null) {
+            if (!isXposed) {
+                isXposed = Utils.isXposedExists(throwable);
             }
-
-            if (!TinkerApplicationHelper.isTinkerLoadSuccess(applicationLike)) {
-                return;
-            }
-            boolean isCausedByXposed = false;
-            //for art, we can't know the actually crash type
-            //art's xposed has not much people
-            if (ShareTinkerInternals.isVmArt()) {
-                isCausedByXposed = true;
-            } else if (ex instanceof IllegalAccessError && ex.getMessage().contains(DALVIK_XPOSED_CRASH)) {
-                //for dalvik, we know the actual crash type
-                isCausedByXposed = true;
-            }
-
-            if (isCausedByXposed) {
-                SampleTinkerReport.onXposedCrash();
-                TinkerLog.e(TAG, "have xposed: just clean tinker");
-                //kill all other process to ensure that all process's code is the same.
-                ShareTinkerInternals.killAllOtherProcess(applicationLike.getApplication());
-
-                TinkerApplicationHelper.cleanPatch(applicationLike);
-                ShareTinkerInternals.setTinkerDisableWithSharedPreferences(applicationLike.getApplication());
-                //method 2
-                //or you can mention user to uninstall Xposed!
-                Toast.makeText(applicationLike.getApplication(), "please uninstall Xposed, illegal modify the app", Toast.LENGTH_LONG).show();
+            if (isXposed) {
+                //method 1
+                ApplicationLike applicationLike = TinkerManager.getTinkerApplicationLike();
+                if (applicationLike == null || applicationLike.getApplication() == null) {
+                    return;
+                }
+
+                if (!TinkerApplicationHelper.isTinkerLoadSuccess(applicationLike)) {
+                    return;
+                }
+                boolean isCausedByXposed = false;
+                //for art, we can't know the actually crash type
+                //just ignore art
+                if (throwable instanceof IllegalAccessError && throwable.getMessage().contains(DALVIK_XPOSED_CRASH)) {
+                    //for dalvik, we know the actual crash type
+                    isCausedByXposed = true;
+                }
+
+                if (isCausedByXposed) {
+                    SampleTinkerReport.onXposedCrash();
+                    TinkerLog.e(TAG, "have xposed: just clean tinker");
+                    //kill all other process to ensure that all process's code is the same.
+                    ShareTinkerInternals.killAllOtherProcess(applicationLike.getApplication());
+
+                    TinkerApplicationHelper.cleanPatch(applicationLike);
+                    ShareTinkerInternals.setTinkerDisableWithSharedPreferences(applicationLike.getApplication());
+                    return;
+                }
             }
+            throwable = throwable.getCause();
         }
     }
 
@@ -123,14 +126,14 @@ private boolean tinkerFastCrashProtect() {
             }
 
             SharedPreferences sp = applicationLike.getApplication().getSharedPreferences(ShareConstants.TINKER_SHARE_PREFERENCE_CONFIG, Context.MODE_MULTI_PROCESS);
-            int fastCrashCount = sp.getInt(currentVersion, 0);
+            int fastCrashCount = sp.getInt(currentVersion, 0) + 1;
             if (fastCrashCount >= MAX_CRASH_COUNT) {
                 SampleTinkerReport.onFastCrashProtect();
                 TinkerApplicationHelper.cleanPatch(applicationLike);
                 TinkerLog.e(TAG, "tinker has fast crash more than %d, we just clean patch!", fastCrashCount);
                 return true;
             } else {
-                sp.edit().putInt(currentVersion, ++fastCrashCount).commit();
+                sp.edit().putInt(currentVersion, fastCrashCount).commit();
                 TinkerLog.e(TAG, "tinker has fast crash %d times", fastCrashCount);
             }
         }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java
index 138f7725..bc2acd22 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java
@@ -17,55 +17,35 @@
 package tinker.sample.android.reporter;
 
 import android.content.Context;
-import android.os.Handler;
 import android.os.Looper;
 import android.os.MessageQueue;
-import android.widget.Toast;
 
 import com.tencent.tinker.lib.reporter.DefaultLoadReporter;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
+import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.io.File;
 
 import tinker.sample.android.util.UpgradePatchRetry;
-import tinker.sample.android.util.Utils;
 
 /**
  * optional, you can just use DefaultLoadReporter
  * Created by zhangshaowen on 16/4/13.
  */
 public class SampleLoadReporter extends DefaultLoadReporter {
-    private Handler handler = new Handler();
+    private final static String TAG = "Tinker.SampleLoadReporter";
 
     public SampleLoadReporter(Context context) {
         super(context);
     }
 
     @Override
-    public void onLoadPatchListenerReceiveFail(final File patchFile, int errorCode, final boolean isUpgrade) {
-        super.onLoadPatchListenerReceiveFail(patchFile, errorCode, isUpgrade);
-        switch (errorCode) {
-            case ShareConstants.ERROR_PATCH_NOTEXIST:
-                Toast.makeText(context, "patch file is not exist", Toast.LENGTH_LONG).show();
-                break;
-            case ShareConstants.ERROR_PATCH_RUNNING:
-                // try later
-                // only retry for upgrade patch
-                if (isUpgrade) {
-                    handler.postDelayed(new Runnable() {
-                        @Override
-                        public void run() {
-                            TinkerInstaller.onReceiveUpgradePatch(context, patchFile.getAbsolutePath());
-                        }
-                    }, 60 * 1000);
-                }
-                break;
-            case Utils.ERROR_PATCH_ROM_SPACE:
-                Toast.makeText(context, "rom space is not enough", Toast.LENGTH_LONG).show();
-                break;
-        }
+    public void onLoadPatchListenerReceiveFail(final File patchFile, int errorCode) {
+        super.onLoadPatchListenerReceiveFail(patchFile, errorCode);
         SampleTinkerReport.onTryApplyFail(errorCode);
     }
 
@@ -87,6 +67,17 @@ public void onLoadResult(File patchDirectory, int loadCode, long cost) {
     @Override
     public void onLoadException(Throwable e, int errorCode) {
         super.onLoadException(e, errorCode);
+        switch (errorCode) {
+            case ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT:
+                String uncaughtString = SharePatchFileUtil.checkTinkerLastUncaughtCrash(context);
+                if (!ShareTinkerInternals.isNullOrNil(uncaughtString)) {
+                    File laseCrashFile = SharePatchFileUtil.getPatchLastCrashFile(context);
+                    SharePatchFileUtil.safeDeleteFile(laseCrashFile);
+                    // found really crash reason
+                    TinkerLog.e(TAG, "tinker uncaught real exception:" + uncaughtString);
+                }
+                break;
+        }
         SampleTinkerReport.onLoadException(e, errorCode);
     }
 
@@ -96,9 +87,37 @@ public void onLoadFileMd5Mismatch(File file, int fileType) {
         SampleTinkerReport.onLoadFileMisMatch(fileType);
     }
 
+    /**
+     * try to recover patch oat file
+     * @param file
+     * @param fileType
+     * @param isDirectory
+     */
     @Override
     public void onLoadFileNotFound(File file, int fileType, boolean isDirectory) {
-        super.onLoadFileNotFound(file, fileType, isDirectory);
+        TinkerLog.i(TAG, "patch loadReporter onLoadFileNotFound: patch file not found: %s, fileType:%d, isDirectory:%b",
+            file.getAbsolutePath(), fileType, isDirectory);
+
+        // only try to recover opt file
+        // check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted
+        if (fileType == ShareConstants.TYPE_DEX_OPT) {
+            Tinker tinker = Tinker.with(context);
+            //we can recover at any process except recover process
+            if (tinker.isMainProcess()) {
+                File patchVersionFile = tinker.getTinkerLoadResultIfPresent().patchVersionFile;
+                if (patchVersionFile != null) {
+                    if (UpgradePatchRetry.getInstance(context).onPatchListenerCheck(SharePatchFileUtil.getMD5(patchVersionFile))) {
+                        TinkerLog.i(TAG, "try to repair oat file on patch process");
+                        TinkerInstaller.onReceiveUpgradePatch(context, patchVersionFile.getAbsolutePath());
+                    } else {
+                        TinkerLog.i(TAG, "repair retry exceed must max time, just clean");
+                        checkAndCleanPatch();
+                    }
+                }
+            }
+        } else {
+            checkAndCleanPatch();
+        }
         SampleTinkerReport.onLoadFileNotFound(fileType);
     }
 
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java
index 852ef447..17a63497 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java
@@ -33,6 +33,7 @@
 
 import tinker.sample.android.app.BuildInfo;
 import tinker.sample.android.crash.SampleUncaughtExceptionHandler;
+import tinker.sample.android.util.UpgradePatchRetry;
 import tinker.sample.android.util.Utils;
 
 /**
@@ -45,7 +46,6 @@
     private static final String TAG = "Tinker.SamplePatchListener";
 
     protected static final long NEW_PATCH_RESTRICTION_SPACE_SIZE_MIN = 60 * 1024 * 1024;
-    protected static final long OLD_PATCH_RESTRICTION_SPACE_SIZE_MIN = 30 * 1024 * 1024;
 
     private final int maxMemory;
 
@@ -64,17 +64,13 @@ public SamplePatchListener(Context context) {
      * @return
      */
     @Override
-    public int patchCheck(String path, boolean isUpgrade) {
+    public int patchCheck(String path) {
         File patchFile = new File(path);
-        TinkerLog.i(TAG, "receive a patch file: %s, isUpgrade:%b, file size:%d", path, isUpgrade, SharePatchFileUtil.getFileOrDirectorySize(patchFile));
-        int returnCode = super.patchCheck(path, isUpgrade);
+        TinkerLog.i(TAG, "receive a patch file: %s, file size:%d", path, SharePatchFileUtil.getFileOrDirectorySize(patchFile));
+        int returnCode = super.patchCheck(path);
 
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
-            if (isUpgrade) {
-                returnCode = Utils.checkForPatchRecover(NEW_PATCH_RESTRICTION_SPACE_SIZE_MIN, maxMemory);
-            } else {
-                returnCode = Utils.checkForPatchRecover(OLD_PATCH_RESTRICTION_SPACE_SIZE_MIN, maxMemory);
-            }
+            returnCode = Utils.checkForPatchRecover(NEW_PATCH_RESTRICTION_SPACE_SIZE_MIN, maxMemory);
         }
 
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
@@ -99,6 +95,11 @@ public int patchCheck(String path, boolean isUpgrade) {
                     }
                 }
             }
+            //check whether retry so many times
+            if (returnCode == ShareConstants.ERROR_PATCH_OK) {
+                returnCode = UpgradePatchRetry.getInstance(context).onPatchListenerCheck(patchMd5)
+                    ? ShareConstants.ERROR_PATCH_OK : Utils.ERROR_PATCH_RETRY_COUNT_LIMIT;
+            }
         }
         // Warning, it is just a sample case, you don't need to copy all of these
         // Interception some of the request
@@ -116,7 +117,7 @@ public int patchCheck(String path, boolean isUpgrade) {
             }
         }
 
-        SampleTinkerReport.onTryApply(isUpgrade, returnCode == ShareConstants.ERROR_PATCH_OK);
+        SampleTinkerReport.onTryApply(returnCode == ShareConstants.ERROR_PATCH_OK);
         return returnCode;
     }
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java
index a3566d68..af0753f0 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java
@@ -43,45 +43,45 @@ public void onPatchServiceStart(Intent intent) {
     }
 
     @Override
-    public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t, boolean isUpgradePatch) {
-        super.onPatchDexOptFail(patchFile, dexFile, optDirectory, dexName, t, isUpgradePatch);
+    public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t) {
+        super.onPatchDexOptFail(patchFile, dexFile, optDirectory, dexName, t);
         SampleTinkerReport.onApplyDexOptFail(t);
     }
 
     @Override
-    public void onPatchException(File patchFile, Throwable e, boolean isUpgradePatch) {
-        super.onPatchException(patchFile, e, isUpgradePatch);
+    public void onPatchException(File patchFile, Throwable e) {
+        super.onPatchException(patchFile, e);
         SampleTinkerReport.onApplyCrash(e);
     }
 
     @Override
-    public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion, boolean isUpgradePatch) {
-        super.onPatchInfoCorrupted(patchFile, oldVersion, newVersion, isUpgradePatch);
+    public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion) {
+        super.onPatchInfoCorrupted(patchFile, oldVersion, newVersion);
         SampleTinkerReport.onApplyInfoCorrupted();
     }
 
     @Override
-    public void onPatchPackageCheckFail(File patchFile, boolean isUpgradePatch, int errorCode) {
-        super.onPatchPackageCheckFail(patchFile, isUpgradePatch, errorCode);
+    public void onPatchPackageCheckFail(File patchFile, int errorCode) {
+        super.onPatchPackageCheckFail(patchFile, errorCode);
         SampleTinkerReport.onApplyPackageCheckFail(errorCode);
     }
 
     @Override
-    public void onPatchResult(File patchFile, boolean success, long cost, boolean isUpgradePatch) {
-        super.onPatchResult(patchFile, success, cost, isUpgradePatch);
-        SampleTinkerReport.onApplied(isUpgradePatch, cost, success);
-        UpgradePatchRetry.getInstance(context).onPatchServiceResult(isUpgradePatch);
+    public void onPatchResult(File patchFile, boolean success, long cost) {
+        super.onPatchResult(patchFile, success, cost);
+        SampleTinkerReport.onApplied(cost, success);
+        UpgradePatchRetry.getInstance(context).onPatchServiceResult();
     }
 
     @Override
-    public void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType, boolean isUpgradePatch) {
-        super.onPatchTypeExtractFail(patchFile, extractTo, filename, fileType, isUpgradePatch);
+    public void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType) {
+        super.onPatchTypeExtractFail(patchFile, extractTo, filename, fileType);
         SampleTinkerReport.onApplyExtractFail(fileType);
     }
 
     @Override
-    public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion, boolean isUpgradePatch) {
-        super.onPatchVersionCheckFail(patchFile, oldPatchInfo, patchFileVersion, isUpgradePatch);
+    public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion) {
+        super.onPatchVersionCheckFail(patchFile, oldPatchInfo, patchFileVersion);
         SampleTinkerReport.onApplyVersionCheckFail();
     }
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
index 269f1066..a2d5a74e 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
@@ -43,24 +43,21 @@
     public static final int KEY_APPLY_WITH_RETRY          = 10;
 
     //Key -- try apply detail
-    public static final int KEY_TRY_APPLY_REPAIR                  = 70;
-    public static final int KEY_TRY_APPLY_UPGRADE                 = 71;
-    public static final int KEY_TRY_APPLY_DISABLE                 = 72;
-    public static final int KEY_TRY_APPLY_RUNNING                 = 73;
-    public static final int KEY_TRY_APPLY_INSERVICE               = 74;
-    public static final int KEY_TRY_APPLY_NOT_EXIST               = 75;
-    public static final int KEY_TRY_APPLY_GOOGLEPLAY              = 76;
-    public static final int KEY_TRY_APPLY_ROM_SPACE               = 77;
-    public static final int KEY_TRY_APPLY_ALREADY_APPLY           = 78;
-    public static final int KEY_TRY_APPLY_MEMORY_LIMIT            = 79;
-    public static final int KEY_TRY_APPLY_CRASH_LIMIT             = 80;
-    public static final int KEY_TRY_APPLY_CONDITION_NOT_SATISFIED = 81;
+    public static final int KEY_TRY_APPLY_UPGRADE                 = 70;
+    public static final int KEY_TRY_APPLY_DISABLE                 = 71;
+    public static final int KEY_TRY_APPLY_RUNNING                 = 72;
+    public static final int KEY_TRY_APPLY_INSERVICE               = 73;
+    public static final int KEY_TRY_APPLY_NOT_EXIST               = 74;
+    public static final int KEY_TRY_APPLY_GOOGLEPLAY              = 75;
+    public static final int KEY_TRY_APPLY_ROM_SPACE               = 76;
+    public static final int KEY_TRY_APPLY_ALREADY_APPLY           = 77;
+    public static final int KEY_TRY_APPLY_MEMORY_LIMIT            = 78;
+    public static final int KEY_TRY_APPLY_CRASH_LIMIT             = 79;
+    public static final int KEY_TRY_APPLY_CONDITION_NOT_SATISFIED = 80;
 
     //Key -- apply detail
-    public static final int KEY_APPLIED_REPAIR       = 100;
-    public static final int KEY_APPLIED_UPGRADE      = 101;
-    public static final int KEY_APPLIED_REPAIR_FAIL  = 102;
-    public static final int KEY_APPLIED_UPGRADE_FAIL = 103;
+    public static final int KEY_APPLIED_UPGRADE      = 100;
+    public static final int KEY_APPLIED_UPGRADE_FAIL = 101;
 
     public static final int KEY_APPLIED_EXCEPTION                               = 120;
     public static final int KEY_APPLIED_DEXOPT                                  = 121;
@@ -74,17 +71,15 @@
     public static final int KEY_APPLIED_PACKAGE_CHECK_META_NOT_FOUND            = 155;
     public static final int KEY_APPLIED_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = 156;
     public static final int KEY_APPLIED_PACKAGE_CHECK_RES_META                  = 157;
+    public static final int KEY_APPLIED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = 158;
+
     //version check
     public static final int KEY_APPLIED_VERSION_CHECK                           = 180;
     //extract error
     public static final int KEY_APPLIED_PATCH_FILE_EXTRACT                      = 181;
     public static final int KEY_APPLIED_DEX_EXTRACT                             = 182;
-    /**
-     * for art small dex
-     */
-    public static final int KEY_APPLIED_DEX_ART_EXTRACT                         = 183;
-    public static final int KEY_APPLIED_LIB_EXTRACT                             = 184;
-    public static final int KEY_APPLIED_RESOURCE_EXTRACT                        = 185;
+    public static final int KEY_APPLIED_LIB_EXTRACT                             = 183;
+    public static final int KEY_APPLIED_RESOURCE_EXTRACT                        = 184;
     //cost time
     public static final int KEY_APPLIED_SUCC_COST_5S_LESS                       = 200;
     public static final int KEY_APPLIED_SUCC_COST_10S_LESS                      = 201;
@@ -100,11 +95,13 @@
 
 
     // KEY -- load detail
-    public static final int KEY_LOADED_UNKNOWN_EXCEPTION   = 250;
-    public static final int KEY_LOADED_UNCAUGHT_EXCEPTION  = 251;
-    public static final int KEY_LOADED_EXCEPTION_DEX       = 252;
-    public static final int KEY_LOADED_EXCEPTION_DEX_CHECK = 253;
-    public static final int KEY_LOADED_EXCEPTION_RESOURCE  = 254;
+    public static final int KEY_LOADED_UNKNOWN_EXCEPTION        = 250;
+    public static final int KEY_LOADED_UNCAUGHT_EXCEPTION       = 251;
+    public static final int KEY_LOADED_EXCEPTION_DEX            = 252;
+    public static final int KEY_LOADED_EXCEPTION_DEX_CHECK      = 253;
+    public static final int KEY_LOADED_EXCEPTION_RESOURCE       = 254;
+    public static final int KEY_LOADED_EXCEPTION_RESOURCE_CHECK = 255;
+
 
     public static final int KEY_LOADED_MISMATCH_DEX       = 300;
     public static final int KEY_LOADED_MISMATCH_LIB       = 301;
@@ -126,6 +123,8 @@
     public static final int KEY_LOADED_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = 355;
     public static final int KEY_LOADED_PACKAGE_CHECK_PACKAGE_META_NOT_FOUND    = 356;
     public static final int KEY_LOADED_PACKAGE_CHECK_RES_META                  = 357;
+    public static final int KEY_LOADED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = 358;
+
 
     public static final int KEY_LOADED_SUCC_COST_500_LESS  = 400;
     public static final int KEY_LOADED_SUCC_COST_1000_LESS = 401;
@@ -145,16 +144,14 @@ public void setReporter(Reporter reporter) {
         this.reporter = reporter;
     }
 
-    public static void onTryApply(boolean upgrade, boolean success) {
+    public static void onTryApply(boolean success) {
         if (reporter == null) {
             return;
         }
         reporter.onReport(KEY_TRY_APPLY);
-        if (upgrade) {
-            reporter.onReport(KEY_TRY_APPLY_UPGRADE);
-        } else {
-            reporter.onReport(KEY_TRY_APPLY_REPAIR);
-        }
+
+        reporter.onReport(KEY_TRY_APPLY_UPGRADE);
+
         if (success) {
             reporter.onReport(KEY_TRY_APPLY_SUCCESS);
         }
@@ -228,6 +225,9 @@ public static void onLoadPackageCheckFail(int errorCode) {
             case ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED:
                 reporter.onReport(KEY_LOADED_PACKAGE_CHECK_RES_META);
                 break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT:
+                reporter.onReport(KEY_LOADED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT);
+                break;
         }
     }
 
@@ -309,12 +309,12 @@ public static void onLoadException(Throwable throwable, int errorCode) {
         if (reporter == null) {
             return;
         }
-        boolean isDexCheckFail = false;
+        boolean isCheckFail = false;
         switch (errorCode) {
             case ShareConstants.ERROR_LOAD_EXCEPTION_DEX:
                 if (throwable.getMessage().contains(ShareConstants.CHECK_DEX_INSTALL_FAIL)) {
                     reporter.onReport(KEY_LOADED_EXCEPTION_DEX_CHECK);
-                    isDexCheckFail = true;
+                    isCheckFail = true;
                     TinkerLog.e(TAG, "tinker dex check fail:" + throwable.getMessage());
                 } else {
                     reporter.onReport(KEY_LOADED_EXCEPTION_DEX);
@@ -322,7 +322,14 @@ public static void onLoadException(Throwable throwable, int errorCode) {
                 }
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE:
-                reporter.onReport(KEY_LOADED_EXCEPTION_RESOURCE);
+                if (throwable.getMessage().contains(ShareConstants.CHECK_RES_INSTALL_FAIL)) {
+                    reporter.onReport(KEY_LOADED_EXCEPTION_RESOURCE_CHECK);
+                    isCheckFail = true;
+                    TinkerLog.e(TAG, "tinker res check fail:" + throwable.getMessage());
+                } else {
+                    reporter.onReport(KEY_LOADED_EXCEPTION_RESOURCE);
+                    TinkerLog.e(TAG, "tinker res reflect fail:" + throwable.getMessage());
+                }
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT:
                 reporter.onReport(KEY_LOADED_UNCAUGHT_EXCEPTION);
@@ -332,7 +339,7 @@ public static void onLoadException(Throwable throwable, int errorCode) {
                 break;
         }
         //reporter exception, for dex check fail, we don't need to report stacktrace
-        if (!isDexCheckFail) {
+        if (!isCheckFail) {
             reporter.onReport("Tinker Exception:load tinker occur exception " + Utils.getExceptionCauseString(throwable));
         }
     }
@@ -374,9 +381,6 @@ public static void onApplyExtractFail(int fileType) {
             case ShareConstants.TYPE_DEX:
                 reporter.onReport(KEY_APPLIED_DEX_EXTRACT);
                 break;
-            case ShareConstants.TYPE_DEX_FOR_ART:
-                reporter.onReport(KEY_APPLIED_DEX_ART_EXTRACT);
-                break;
             case ShareConstants.TYPE_LIBRARY:
                 reporter.onReport(KEY_APPLIED_LIB_EXTRACT);
                 break;
@@ -389,7 +393,7 @@ public static void onApplyExtractFail(int fileType) {
         }
     }
 
-    public static void onApplied(boolean isUpgrade, long cost, boolean success) {
+    public static void onApplied(long cost, boolean success) {
         if (reporter == null) {
             return;
         }
@@ -397,19 +401,10 @@ public static void onApplied(boolean isUpgrade, long cost, boolean success) {
             reporter.onReport(KEY_APPLIED);
         }
 
-        if (isUpgrade) {
-            if (success) {
-                reporter.onReport(KEY_APPLIED_UPGRADE);
-            } else {
-                reporter.onReport(KEY_APPLIED_UPGRADE_FAIL);
-            }
-
+        if (success) {
+            reporter.onReport(KEY_APPLIED_UPGRADE);
         } else {
-            if (success) {
-                reporter.onReport(KEY_APPLIED_REPAIR);
-            } else {
-                reporter.onReport(KEY_APPLIED_REPAIR_FAIL);
-            }
+            reporter.onReport(KEY_APPLIED_UPGRADE_FAIL);
         }
 
         TinkerLog.i(TAG, "hp_report report apply cost = %d", cost);
@@ -483,6 +478,9 @@ public static void onApplyPackageCheckFail(int errorCode) {
             case ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED:
                 reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_RES_META);
                 break;
+            case ShareConstants.ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT:
+                reporter.onReport(KEY_APPLIED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT);
+                break;
         }
     }
 
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java
index d98c3a50..3b62551f 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java
@@ -26,13 +26,11 @@
 
 import com.tencent.tinker.lib.service.DefaultTinkerResultService;
 import com.tencent.tinker.lib.service.PatchResult;
-import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.lib.util.TinkerServiceInternals;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 
 import java.io.File;
-import java.util.zip.ZipFile;
 
 import tinker.sample.android.util.Utils;
 
@@ -69,12 +67,9 @@ public void run() {
         });
         // is success and newPatch, it is nice to delete the raw file, and restart at once
         // for old patch, you can't delete the patch file
-        if (result.isSuccess && result.isUpgradePatch) {
-            File rawFile = new File(result.rawPatchFilePath);
-            if (rawFile.exists()) {
-                TinkerLog.i(TAG, "save delete raw patch file");
-                SharePatchFileUtil.safeDeleteFile(rawFile);
-            }
+        if (result.isSuccess) {
+            deleteRawPatchFile(new File(result.rawPatchFilePath));
+
             //not like TinkerResultService, I want to restart just when I am at background!
             //if you have not install tinker this moment, you can use TinkerApplicationHelper api
             if (checkIfNeedKill(result)) {
@@ -96,12 +91,6 @@ public void onScreenOff() {
                 TinkerLog.i(TAG, "I have already install the newly patch version!");
             }
         }
-
-        //repair current patch fail, just clean!
-        if (!result.isSuccess && !result.isUpgradePatch) {
-            //if you have not install tinker this moment, you can use TinkerApplicationHelper api
-            Tinker.with(getApplicationContext()).cleanPatch();
-        }
     }
 
     /**
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
index 4106eceb..d22e30f5 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
@@ -18,7 +18,6 @@
 
 import com.tencent.tinker.lib.listener.PatchListener;
 import com.tencent.tinker.lib.patch.AbstractPatch;
-import com.tencent.tinker.lib.patch.RepairPatch;
 import com.tencent.tinker.lib.patch.UpgradePatch;
 import com.tencent.tinker.lib.reporter.LoadReporter;
 import com.tencent.tinker.lib.reporter.PatchReporter;
@@ -94,12 +93,10 @@ public static void installTinker(ApplicationLike appLike) {
         PatchListener patchListener = new SamplePatchListener(appLike.getApplication());
         //you can set your own upgrade patch if you need
         AbstractPatch upgradePatchProcessor = new UpgradePatch();
-        //you can set your own repair patch if you need
-        AbstractPatch repairPatchProcessor = new RepairPatch();
 
         TinkerInstaller.install(appLike,
             loadReporter, patchReporter, patchListener,
-            SampleResultService.class, upgradePatchProcessor, repairPatchProcessor);
+            SampleResultService.class, upgradePatchProcessor);
 
         isInstalled = true;
     }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
index e3f8eefa..a714b94f 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
@@ -49,7 +49,8 @@
 
     private static final String RETRY_FILE_MD5_PROPERTY = "md5";
     private static final String RETRY_COUNT_PROPERTY    = "times";
-    private static final int    RETRY_MAX_COUNT         = 2;
+    private static final int    RETRY_MAX_COUNT         = 4;
+
 
     private boolean isRetryEnable = false;
     private File    retryInfoFile = null;
@@ -65,8 +66,8 @@
      */
     public UpgradePatchRetry(Context context) {
         this.context = context;
-        retryInfoFile = new File(SharePatchFileUtil.getPatchDirectory(context), RETRY_INFO_NAME);
-        tempPatchFile = new File(SharePatchFileUtil.getPatchDirectory(context), TEMP_PATCH_NAME);
+        retryInfoFile = new File(SharePatchFileUtil.getPatchTempDirectory(context), RETRY_INFO_NAME);
+        tempPatchFile = new File(SharePatchFileUtil.getPatchTempDirectory(context), TEMP_PATCH_NAME);
     }
 
     public static UpgradePatchRetry getInstance(Context context) {
@@ -108,18 +109,6 @@ public void onPatchRetryLoad() {
         SampleTinkerReport.onReportRetryPatch();
     }
 
-    private void copyToTempFile(File patchFile) {
-        if (patchFile.getAbsolutePath().equals(tempPatchFile.getAbsolutePath())) {
-            return;
-        }
-        TinkerLog.w(TAG, "try copy file: %s to %s", patchFile.getAbsolutePath(), tempPatchFile.getAbsolutePath());
-
-        try {
-            SharePatchFileUtil.copyFileUsingStream(patchFile, tempPatchFile);
-        } catch (IOException e) {
-        }
-    }
-
     public void onPatchServiceStart(Intent intent) {
         if (!isRetryEnable) {
             TinkerLog.w(TAG, "onPatchServiceStart retry disabled, just return");
@@ -131,13 +120,6 @@ public void onPatchServiceStart(Intent intent) {
             return;
         }
 
-        boolean isUpgrade = TinkerPatchService.getPatchUpgradeExtra(intent);
-
-        if (!isUpgrade) {
-            TinkerLog.w(TAG, "onPatchServiceStart is not upgrade patch, just return");
-            return;
-        }
-
         String path = TinkerPatchService.getPatchPathExtra(intent);
 
         if (path == null) {
@@ -149,6 +131,10 @@ public void onPatchServiceStart(Intent intent) {
         File patchFile = new File(path);
 
         String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
+        if (patchMd5 == null) {
+            TinkerLog.w(TAG, "onPatchServiceStart patch md5 is null, just return");
+            return;
+        }
 
         if (retryInfoFile.exists()) {
             retryInfo = RetryInfo.readRetryProperty(retryInfoFile);
@@ -159,7 +145,6 @@ public void onPatchServiceStart(Intent intent) {
             } else {
                 int nowTimes = Integer.parseInt(retryInfo.times);
                 if (nowTimes >= RETRY_MAX_COUNT) {
-                    SharePatchFileUtil.safeDeleteFile(retryInfoFile);
                     SharePatchFileUtil.safeDeleteFile(tempPatchFile);
                     TinkerLog.w(TAG, "onPatchServiceStart retry more than max count, delete retry info file!");
                     return;
@@ -174,29 +159,41 @@ public void onPatchServiceStart(Intent intent) {
         }
 
         RetryInfo.writeRetryProperty(retryInfoFile, retryInfo);
-
     }
 
+    public boolean onPatchListenerCheck(String md5) {
+        if (!isRetryEnable) {
+            TinkerLog.w(TAG, "onPatchListenerCheck retry disabled, just return");
+            return true;
+        }
+        if (!retryInfoFile.exists()) {
+            TinkerLog.w(TAG, "onPatchListenerCheck retry file is not exist, just return");
+            return true;
+        }
+        if (md5 == null) {
+            TinkerLog.w(TAG, "onPatchListenerCheck md5 is null, just return");
+            return true;
+        }
+        RetryInfo retryInfo = RetryInfo.readRetryProperty(retryInfoFile);
+        if (md5.equals(retryInfo.md5)) {
+            int nowTimes = Integer.parseInt(retryInfo.times);
+            if (nowTimes >= RETRY_MAX_COUNT) {
+                TinkerLog.w(TAG, "onPatchListenerCheck, retry count %d must exceed than max retry count", nowTimes);
+                SharePatchFileUtil.safeDeleteFile(tempPatchFile);
+                return false;
+            }
+        }
+        return true;
+    }
     /**
      * if we receive any result, we can delete the temp retry info file
-     *
-     * @param isUpgradePatch
      */
-    public void onPatchServiceResult(boolean isUpgradePatch) {
+    public void onPatchServiceResult() {
         if (!isRetryEnable) {
             TinkerLog.w(TAG, "onPatchServiceResult retry disabled, just return");
             return;
         }
 
-        if (!isUpgradePatch) {
-            TinkerLog.w(TAG, "onPatchServiceResult is not upgrade patch, just return");
-            return;
-        }
-
-        //delete info file
-        if (retryInfoFile.exists()) {
-            SharePatchFileUtil.safeDeleteFile(retryInfoFile);
-        }
         //delete temp patch file
         if (tempPatchFile.exists()) {
             SharePatchFileUtil.safeDeleteFile(tempPatchFile);
@@ -207,6 +204,20 @@ public void setRetryEnable(boolean enable) {
         isRetryEnable = enable;
     }
 
+
+    private void copyToTempFile(File patchFile) {
+        if (patchFile.getAbsolutePath().equals(tempPatchFile.getAbsolutePath())) {
+            return;
+        }
+        TinkerLog.w(TAG, "try copy file: %s to %s", patchFile.getAbsolutePath(), tempPatchFile.getAbsolutePath());
+
+        try {
+            SharePatchFileUtil.copyFileUsingStream(patchFile, tempPatchFile);
+        } catch (IOException e) {
+            TinkerLog.e(TAG, "fail to copy file: %s to %s", patchFile.getAbsolutePath(), tempPatchFile.getAbsolutePath());
+        }
+    }
+
     static class RetryInfo {
         String md5;
         String times;
@@ -228,7 +239,7 @@ static RetryInfo readRetryProperty(File infoFile) {
                 md5 = properties.getProperty(RETRY_FILE_MD5_PROPERTY);
                 times = properties.getProperty(RETRY_COUNT_PROPERTY);
             } catch (IOException e) {
-                e.printStackTrace();
+                TinkerLog.e(TAG, "fail to readRetryProperty:" + e);
             } finally {
                 SharePatchFileUtil.closeQuietly(inputStream);
             }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java
index d6f2b993..8767307d 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java
@@ -40,7 +40,8 @@
     public static final int ERROR_PATCH_MEMORY_LIMIT            = -7;
     public static final int ERROR_PATCH_ALREADY_APPLY           = -8;
     public static final int ERROR_PATCH_CRASH_LIMIT             = -9;
-    public static final int ERROR_PATCH_CONDITION_NOT_SATISFIED = -10;
+    public static final int ERROR_PATCH_RETRY_COUNT_LIMIT       = -10;
+    public static final int ERROR_PATCH_CONDITION_NOT_SATISFIED = -11;
 
     public static final String PLATFORM = "platform";
 
diff --git a/tinker-sample-android/app/src/test/java/tinker/sample/android/ExampleUnitTest.java b/tinker-sample-android/app/src/test/java/tinker/sample/android/ExampleUnitTest.java
index 8bbca8ab..4f1c077c 100644
--- a/tinker-sample-android/app/src/test/java/tinker/sample/android/ExampleUnitTest.java
+++ b/tinker-sample-android/app/src/test/java/tinker/sample/android/ExampleUnitTest.java
@@ -18,7 +18,7 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * To work on unit tests, switch the Test Artifact in the Build Variants view.
diff --git a/tinker-sample-android/build.gradle b/tinker-sample-android/build.gradle
index 7f8c6830..08af2ebf 100644
--- a/tinker-sample-android/build.gradle
+++ b/tinker-sample-android/build.gradle
@@ -5,7 +5,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.1.0'
+        classpath 'com.android.tools.build:gradle:2.2.0'
         classpath "com.tencent.tinker:tinker-patch-gradle-plugin:${TINKER_VERSION}"
     }
 }
diff --git a/tinker-sample-android/gradle.properties b/tinker-sample-android/gradle.properties
index 20504014..25a8de5a 100644
--- a/tinker-sample-android/gradle.properties
+++ b/tinker-sample-android/gradle.properties
@@ -17,5 +17,4 @@
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
 
-TINKER_VERSION=1.6.0
-
+TINKER_VERSION=1.7.7
diff --git a/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties b/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
index c25cec52..86d6158a 100644
--- a/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
+++ b/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
diff --git a/tinker-sample-android/updateTinkerLib.sh b/tinker-sample-android/updateTinkerLib.sh
index 154d2c3c..30ae62b1 100755
--- a/tinker-sample-android/updateTinkerLib.sh
+++ b/tinker-sample-android/updateTinkerLib.sh
@@ -1,4 +1,5 @@
 #!/usr/bin/env bash
 rm -rf ~/.gradle/caches/modules-2/metadata-2.16/descriptors/com.tencent.tinker
 
+#rm -rf ~/.m2/repository/com/tencent/tinker
 #adb push ./app/build/outputs/tinkerPatch/debug/patch_signed_7zip.apk /storage/sdcard0/
\ No newline at end of file
