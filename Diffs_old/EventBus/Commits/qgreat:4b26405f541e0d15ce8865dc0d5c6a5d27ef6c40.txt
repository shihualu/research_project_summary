diff --git a/EventBus/src/org/greenrobot/eventbus/EventBus.java b/EventBus/src/org/greenrobot/eventbus/EventBus.java
index ae671e52..5b073351 100644
--- a/EventBus/src/org/greenrobot/eventbus/EventBus.java
+++ b/EventBus/src/org/greenrobot/eventbus/EventBus.java
@@ -38,540 +38,561 @@
  */
 public class EventBus {
 
-    /** Log tag, apps may override it. */
-    public static String TAG = "EventBus";
-
-    static volatile EventBus defaultInstance;
-
-    private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
-    //eventType 就是ModelBean，key为subscriber，订阅者，value为eventType的集合
-    private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
-    //subscription  里面封装了subscriber和SubscriberMethod：event，method，threadMode sticky等方法
-    private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
-    //
-    private final Map<Object, List<Class<?>>> typesBySubscriber;
-    private final Map<Class<?>, Object> stickyEvents;
-
-    private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
-        @Override
-        protected PostingThreadState initialValue() {
-            return new PostingThreadState();
-        }
-    };
-
-    // @Nullable
-    private final MainThreadSupport mainThreadSupport;
-    // @Nullable
-    private final Poster mainThreadPoster;
-    private final BackgroundPoster backgroundPoster;
-    private final AsyncPoster asyncPoster;
-    private final SubscriberMethodFinder subscriberMethodFinder;
-    private final ExecutorService executorService;
-
-    private final boolean throwSubscriberException;
-    private final boolean logSubscriberExceptions;
-    private final boolean logNoSubscriberMessages;
-    private final boolean sendSubscriberExceptionEvent;
-    private final boolean sendNoSubscriberEvent;
-    private final boolean eventInheritance;
-
-    private final int indexCount;
-    private final Logger logger;
-
-    /** Convenience singleton for apps using a process-wide EventBus instance. */
-    public static EventBus getDefault() {
-        // XXX: 换成局部变量
-        EventBus instance = defaultInstance;
-        if (instance == null) {
-            synchronized (EventBus.class) {
-                instance = EventBus.defaultInstance;
-                if (instance == null) {
-                    instance = EventBus.defaultInstance = new EventBus();
-                }
-            }
-        }
-        return instance;
-    }
-
-    public static EventBusBuilder builder() {
-        return new EventBusBuilder();
-    }
-
-    /** For unit test primarily. */
-    public static void clearCaches() {
-        SubscriberMethodFinder.clearCaches();
-        eventTypesCache.clear();
-    }
-
-    /**
-     * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a
-     * central bus, consider {@link #getDefault()}.
-     */
-    public EventBus() {
-        this(DEFAULT_BUILDER);
-    }
-
-    EventBus(EventBusBuilder builder) {
-        logger = builder.getLogger();
-        subscriptionsByEventType = new HashMap<>();
-        typesBySubscriber = new HashMap<>();
-        stickyEvents = new ConcurrentHashMap<>();
-        mainThreadSupport = builder.getMainThreadSupport();
-        //通过 Looper.getMainLooper() 获取主线程的Looper
-        mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;
-        backgroundPoster = new BackgroundPoster(this);
-        asyncPoster = new AsyncPoster(this);
-        indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;
-        subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,
-                builder.strictMethodVerification, builder.ignoreGeneratedIndex);
-        logSubscriberExceptions = builder.logSubscriberExceptions;
-        logNoSubscriberMessages = builder.logNoSubscriberMessages;
-        sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
-        sendNoSubscriberEvent = builder.sendNoSubscriberEvent;
-        throwSubscriberException = builder.throwSubscriberException;
-        eventInheritance = builder.eventInheritance;
-        executorService = builder.executorService;
-    }
-
-    /**
-     * Registers the given subscriber to receive events. Subscribers must call {@link #unregister(Object)} once they
-     * are no longer interested in receiving events.
-     * <p/>
-     * Subscribers have event handling methods that must be annotated by {@link Subscribe}.
-     * The {@link Subscribe} annotation also allows configuration like {@link
-     * ThreadMode} and priority.
-     */
-    public void register(Object subscriber) {
-        Class<?> subscriberClass = subscriber.getClass();
-        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
-        synchronized (this) {
-            for (SubscriberMethod subscriberMethod : subscriberMethods) {
-                subscribe(subscriber, subscriberMethod);
-            }
-        }
-    }
-
-    // Must be called in synchronized block
-    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
-        Class<?> eventType = subscriberMethod.eventType;
-        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
-        CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
-        if (subscriptions == null) {
-            subscriptions = new CopyOnWriteArrayList<>();
-            subscriptionsByEventType.put(eventType, subscriptions);
-        } else {
-            if (subscriptions.contains(newSubscription)) {
-                throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
-                        + eventType);
-            }
-        }
-
-        int size = subscriptions.size();
-        for (int i = 0; i <= size; i++) {
-            if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
-                subscriptions.add(i, newSubscription);
-                break;
-            }
-        }
-
-        List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
-        if (subscribedEvents == null) {
-            subscribedEvents = new ArrayList<>();
-            typesBySubscriber.put(subscriber, subscribedEvents);
-        }
-        subscribedEvents.add(eventType);
-
-        if (subscriberMethod.sticky) {
-            if (eventInheritance) {
-                // Existing sticky events of all subclasses of eventType have to be considered.
-                // Note: Iterating over all events may be inefficient with lots of sticky events,
-                // thus data structure should be changed to allow a more efficient lookup
-                // (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).
-                Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();
-                for (Map.Entry<Class<?>, Object> entry : entries) {
-                    Class<?> candidateEventType = entry.getKey();
-                    if (eventType.isAssignableFrom(candidateEventType)) {
-                        Object stickyEvent = entry.getValue();
-                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);
-                    }
-                }
-            } else {
-                Object stickyEvent = stickyEvents.get(eventType);
-                checkPostStickyEventToSubscription(newSubscription, stickyEvent);
-            }
-        }
-    }
-
-    private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {
-        if (stickyEvent != null) {
-            // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
-            // --> Strange corner case, which we don't take care of here.
-            postToSubscription(newSubscription, stickyEvent, isMainThread());
-        }
-    }
-
-    /**
-     * Checks if the current thread is running in the main thread.
-     * If there is no main thread support (e.g. non-Android), "true" is always returned. In that case MAIN thread
-     * subscribers are always called in posting thread, and BACKGROUND subscribers are always called from a background
-     * poster.
-     */
-    private boolean isMainThread() {
-        return mainThreadSupport != null ? mainThreadSupport.isMainThread() : true;
-    }
-
-    public synchronized boolean isRegistered(Object subscriber) {
-        return typesBySubscriber.containsKey(subscriber);
-    }
-
-    /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
-    private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
-        List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
-        if (subscriptions != null) {
-            int size = subscriptions.size();
-            for (int i = 0; i < size; i++) {
-                Subscription subscription = subscriptions.get(i);
-                if (subscription.subscriber == subscriber) {
-                    subscription.active = false;
-                    subscriptions.remove(i);
-                    i--;
-                    size--;
-                }
-            }
-        }
-    }
-
-    /** Unregisters the given subscriber from all event classes. */
-    public synchronized void unregister(Object subscriber) {
-        List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
-        if (subscribedTypes != null) {
-            for (Class<?> eventType : subscribedTypes) {
-                unsubscribeByEventType(subscriber, eventType);
-            }
-            typesBySubscriber.remove(subscriber);
-        } else {
-            logger.log(Level.WARNING, "Subscriber to unregister was not registered before: " + subscriber.getClass());
-        }
-    }
-
-    /** Posts the given event to the event bus. */
-    public void post(Object event) {
-        PostingThreadState postingState = currentPostingThreadState.get();
-        List<Object> eventQueue = postingState.eventQueue;
-        eventQueue.add(event);
-
-        if (!postingState.isPosting) {
-            postingState.isMainThread = isMainThread();
-            postingState.isPosting = true;
-            if (postingState.canceled) {
-                throw new EventBusException("Internal error. Abort state was not reset");
-            }
-            try {
-                while (!eventQueue.isEmpty()) {
-                    postSingleEvent(eventQueue.remove(0), postingState);
-                }
-            } finally {
-                postingState.isPosting = false;
-                postingState.isMainThread = false;
-            }
-        }
-    }
-
-    /**
-     * Called from a subscriber's event handling method, further event delivery will be canceled. Subsequent
-     * subscribers
-     * won't receive the event. Events are usually canceled by higher priority subscribers (see
-     * {@link Subscribe#priority()}). Canceling is restricted to event handling methods running in posting thread
-     * {@link ThreadMode#POSTING}.
-     */
-    public void cancelEventDelivery(Object event) {
-        PostingThreadState postingState = currentPostingThreadState.get();
-        if (!postingState.isPosting) {
-            throw new EventBusException(
-                    "This method may only be called from inside event handling methods on the posting thread");
-        } else if (event == null) {
-            throw new EventBusException("Event may not be null");
-        } else if (postingState.event != event) {
-            throw new EventBusException("Only the currently handled event may be aborted");
-        } else if (postingState.subscription.subscriberMethod.threadMode != ThreadMode.POSTING) {
-            throw new EventBusException(" event handlers may only abort the incoming event");
-        }
-
-        postingState.canceled = true;
-    }
-
-    /**
-     * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky
-     * event of an event's type is kept in memory for future access by subscribers using {@link Subscribe#sticky()}.
-     */
-    public void postSticky(Object event) {
-        synchronized (stickyEvents) {
-            stickyEvents.put(event.getClass(), event);
-        }
-        // Should be posted after it is putted, in case the subscriber wants to remove immediately
-        post(event);
-    }
-
-    /**
-     * Gets the most recent sticky event for the given type.
-     *
-     * @see #postSticky(Object)
-     */
-    public <T> T getStickyEvent(Class<T> eventType) {
-        synchronized (stickyEvents) {
-            return eventType.cast(stickyEvents.get(eventType));
-        }
-    }
-
-    /**
-     * Remove and gets the recent sticky event for the given event type.
-     *
-     * @see #postSticky(Object)
-     */
-    public <T> T removeStickyEvent(Class<T> eventType) {
-        synchronized (stickyEvents) {
-            return eventType.cast(stickyEvents.remove(eventType));
-        }
-    }
-
-    /**
-     * Removes the sticky event if it equals to the given event.
-     *
-     * @return true if the events matched and the sticky event was removed.
-     */
-    public boolean removeStickyEvent(Object event) {
-        synchronized (stickyEvents) {
-            Class<?> eventType = event.getClass();
-            Object existingEvent = stickyEvents.get(eventType);
-            if (event.equals(existingEvent)) {
-                stickyEvents.remove(eventType);
-                return true;
-            } else {
-                return false;
-            }
-        }
-    }
-
-    /**
-     * Removes all sticky events.
-     */
-    public void removeAllStickyEvents() {
-        synchronized (stickyEvents) {
-            stickyEvents.clear();
-        }
-    }
-
-    public boolean hasSubscriberForEvent(Class<?> eventClass) {
-        List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
-        if (eventTypes != null) {
-            int countTypes = eventTypes.size();
-            for (int h = 0; h < countTypes; h++) {
-                Class<?> clazz = eventTypes.get(h);
-                CopyOnWriteArrayList<Subscription> subscriptions;
-                synchronized (this) {
-                    subscriptions = subscriptionsByEventType.get(clazz);
-                }
-                if (subscriptions != null && !subscriptions.isEmpty()) {
-                    return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
-        Class<?> eventClass = event.getClass();
-        boolean subscriptionFound = false;
-        if (eventInheritance) {
-            List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
-            int countTypes = eventTypes.size();
-            for (int h = 0; h < countTypes; h++) {
-                Class<?> clazz = eventTypes.get(h);
-                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
-            }
-        } else {
-            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
-        }
-        if (!subscriptionFound) {
-            if (logNoSubscriberMessages) {
-                logger.log(Level.FINE, "No subscribers registered for event " + eventClass);
-            }
-            if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&
-                    eventClass != SubscriberExceptionEvent.class) {
-                post(new NoSubscriberEvent(this, event));
-            }
-        }
-    }
-
-    private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
-        CopyOnWriteArrayList<Subscription> subscriptions;
-        synchronized (this) {
-            subscriptions = subscriptionsByEventType.get(eventClass);
-        }
-        if (subscriptions != null && !subscriptions.isEmpty()) {
-            for (Subscription subscription : subscriptions) {
-                postingState.event = event;
-                postingState.subscription = subscription;
-                boolean aborted = false;
-                try {
-                    postToSubscription(subscription, event, postingState.isMainThread);
-                    aborted = postingState.canceled;
-                } finally {
-                    postingState.event = null;
-                    postingState.subscription = null;
-                    postingState.canceled = false;
-                }
-                if (aborted) {
-                    break;
-                }
-            }
-            return true;
-        }
-        return false;
-    }
-
-    private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
-        switch (subscription.subscriberMethod.threadMode) {
-            case POSTING:
-                invokeSubscriber(subscription, event);
-                break;
-            case MAIN:
-                if (isMainThread) {
-                    invokeSubscriber(subscription, event);
-                } else {
-                    mainThreadPoster.enqueue(subscription, event);
-                }
-                break;
-            case MAIN_ORDERED:
-                if (mainThreadPoster != null) {
-                    mainThreadPoster.enqueue(subscription, event);
-                } else {
-                    // temporary: technically not correct as poster not decoupled from subscriber
-                    invokeSubscriber(subscription, event);
-                }
-                break;
-            case BACKGROUND:
-                if (isMainThread) {
-                    backgroundPoster.enqueue(subscription, event);
-                } else {
-                    invokeSubscriber(subscription, event);
-                }
-                break;
-            case ASYNC:
-                asyncPoster.enqueue(subscription, event);
-                break;
-            default:
-                throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode);
-        }
-    }
-
-    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
-    private static List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
-        synchronized (eventTypesCache) {
-            List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
-            if (eventTypes == null) {
-                eventTypes = new ArrayList<>();
-                Class<?> clazz = eventClass;
-                while (clazz != null) {
-                    eventTypes.add(clazz);
-                    addInterfaces(eventTypes, clazz.getInterfaces());
-                    clazz = clazz.getSuperclass();
-                }
-                eventTypesCache.put(eventClass, eventTypes);
-            }
-            return eventTypes;
-        }
-    }
-
-    /** Recurses through super interfaces. */
-    static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
-        for (Class<?> interfaceClass : interfaces) {
-            if (!eventTypes.contains(interfaceClass)) {
-                eventTypes.add(interfaceClass);
-                addInterfaces(eventTypes, interfaceClass.getInterfaces());
-            }
-        }
-    }
-
-    /**
-     * Invokes the subscriber if the subscriptions is still active. Skipping subscriptions prevents race conditions
-     * between {@link #unregister(Object)} and event delivery. Otherwise the event might be delivered after the
-     * subscriber unregistered. This is particularly important for main thread delivery and registrations bound to the
-     * live cycle of an Activity or Fragment.
-     */
-    void invokeSubscriber(PendingPost pendingPost) {
-        Object event = pendingPost.event;
-        Subscription subscription = pendingPost.subscription;
-        PendingPost.releasePendingPost(pendingPost);
-        if (subscription.active) {
-            invokeSubscriber(subscription, event);
-        }
-    }
-
-    void invokeSubscriber(Subscription subscription, Object event) {
-        try {
-            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
-        } catch (InvocationTargetException e) {
-            handleSubscriberException(subscription, event, e.getCause());
-        } catch (IllegalAccessException e) {
-            throw new IllegalStateException("Unexpected exception", e);
-        }
-    }
-
-    private void handleSubscriberException(Subscription subscription, Object event, Throwable cause) {
-        if (event instanceof SubscriberExceptionEvent) {
-            if (logSubscriberExceptions) {
-                // Don't send another SubscriberExceptionEvent to avoid infinite event recursion, just log
-                logger.log(Level.SEVERE, "SubscriberExceptionEvent subscriber " + subscription.subscriber.getClass()
-                        + " threw an exception", cause);
-                SubscriberExceptionEvent exEvent = (SubscriberExceptionEvent) event;
-                logger.log(Level.SEVERE, "Initial event " + exEvent.causingEvent + " caused exception in "
-                        + exEvent.causingSubscriber, exEvent.throwable);
-            }
-        } else {
-            if (throwSubscriberException) {
-                throw new EventBusException("Invoking subscriber failed", cause);
-            }
-            if (logSubscriberExceptions) {
-                logger.log(Level.SEVERE, "Could not dispatch event: " + event.getClass() + " to subscribing class "
-                        + subscription.subscriber.getClass(), cause);
-            }
-            if (sendSubscriberExceptionEvent) {
-                SubscriberExceptionEvent exEvent = new SubscriberExceptionEvent(this, cause, event,
-                        subscription.subscriber);
-                post(exEvent);
-            }
-        }
-    }
-
-    /** For ThreadLocal, much faster to set (and get multiple values). */
-    final static class PostingThreadState {
-        final List<Object> eventQueue = new ArrayList<>();
-        boolean isPosting;
-        boolean isMainThread;
-        Subscription subscription;
-        Object event;
-        boolean canceled;
-    }
-
-    ExecutorService getExecutorService() {
-        return executorService;
-    }
-
-    /**
-     * For internal use only.
-     */
-    public Logger getLogger() {
-        return logger;
-    }
-
-    // Just an idea: we could provide a callback to post() to be notified, an alternative would be events, of course...
-    /* public */interface PostCallback {
-        void onPostCompleted(List<SubscriberExceptionEvent> exceptionEvents);
-    }
-
-    @Override
-    public String toString() {
-        return "EventBus[indexCount=" + indexCount + ", eventInheritance=" + eventInheritance + "]";
-    }
+	/**
+	 * Log tag, apps may override it.
+	 */
+	public static String TAG = "EventBus";
+
+	static volatile EventBus defaultInstance;
+
+	private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
+	//eventType 就是ModelBean，key为subscriber，订阅者，value为eventType的集合
+	private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<>();
+	//subscription  里面封装了subscriber和SubscriberMethod：event，method，threadMode sticky等方法
+	private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
+	//
+	private final Map<Object, List<Class<?>>> typesBySubscriber;
+	private final Map<Class<?>, Object> stickyEvents;
+
+	private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
+		@Override
+		protected PostingThreadState initialValue() {
+			return new PostingThreadState();
+		}
+	};
+
+	// @Nullable
+	private final MainThreadSupport mainThreadSupport;
+	// @Nullable
+	private final Poster mainThreadPoster;
+	private final BackgroundPoster backgroundPoster;
+	private final AsyncPoster asyncPoster;
+	private final SubscriberMethodFinder subscriberMethodFinder;
+	private final ExecutorService executorService;
+
+	private final boolean throwSubscriberException;
+	private final boolean logSubscriberExceptions;
+	private final boolean logNoSubscriberMessages;
+	private final boolean sendSubscriberExceptionEvent;
+	private final boolean sendNoSubscriberEvent;
+	private final boolean eventInheritance;
+
+	private final int indexCount;
+	private final Logger logger;
+
+	/**
+	 * Convenience singleton for apps using a process-wide EventBus instance.
+	 */
+	public static EventBus getDefault() {
+		// XXX: 换成局部变量
+		EventBus instance = defaultInstance;
+		if (instance == null) {
+			synchronized (EventBus.class) {
+				instance = EventBus.defaultInstance;
+				if (instance == null) {
+					instance = EventBus.defaultInstance = new EventBus();
+				}
+			}
+		}
+		return instance;
+	}
+
+	public static EventBusBuilder builder() {
+		return new EventBusBuilder();
+	}
+
+	/**
+	 * For unit test primarily.
+	 */
+	public static void clearCaches() {
+		SubscriberMethodFinder.clearCaches();
+		eventTypesCache.clear();
+	}
+
+	/**
+	 * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a
+	 * central bus, consider {@link #getDefault()}.
+	 */
+	public EventBus() {
+		this(DEFAULT_BUILDER);
+	}
+
+	EventBus(EventBusBuilder builder) {
+		logger = builder.getLogger();
+		subscriptionsByEventType = new HashMap<>();
+		typesBySubscriber = new HashMap<>();
+		stickyEvents = new ConcurrentHashMap<>();
+		mainThreadSupport = builder.getMainThreadSupport();
+		//通过 Looper.getMainLooper() 获取主线程的Looper
+		mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;
+		backgroundPoster = new BackgroundPoster(this);
+		asyncPoster = new AsyncPoster(this);
+		indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;
+		subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,
+				builder.strictMethodVerification, builder.ignoreGeneratedIndex);
+		logSubscriberExceptions = builder.logSubscriberExceptions;
+		logNoSubscriberMessages = builder.logNoSubscriberMessages;
+		sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
+		sendNoSubscriberEvent = builder.sendNoSubscriberEvent;
+		throwSubscriberException = builder.throwSubscriberException;
+		eventInheritance = builder.eventInheritance;
+		executorService = builder.executorService;
+	}
+
+	/**
+	 * Registers the given subscriber to receive events. Subscribers must call {@link #unregister(Object)} once they
+	 * are no longer interested in receiving events.
+	 * <p/>
+	 * Subscribers have event handling methods that must be annotated by {@link Subscribe}.
+	 * The {@link Subscribe} annotation also allows configuration like {@link
+	 * ThreadMode} and priority.
+	 */
+	public void register(Object subscriber) {
+		Class<?> subscriberClass = subscriber.getClass();
+		List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
+		synchronized (this) {
+			for (SubscriberMethod subscriberMethod : subscriberMethods) {
+				subscribe(subscriber, subscriberMethod);
+			}
+		}
+	}
+
+	// Must be called in synchronized block
+	private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
+		Class<?> eventType = subscriberMethod.eventType;
+		Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
+		CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
+		if (subscriptions == null) {
+			subscriptions = new CopyOnWriteArrayList<>();
+			subscriptionsByEventType.put(eventType, subscriptions);
+		} else {
+			if (subscriptions.contains(newSubscription)) {
+				throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
+						+ eventType);
+			}
+		}
+
+		int size = subscriptions.size();
+		for (int i = 0; i <= size; i++) {//优先级高的话，排在前面
+			if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
+				subscriptions.add(i, newSubscription);
+				break;
+			}
+		}
+		//types也根据subscriber保存一份
+		List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
+		if (subscribedEvents == null) {
+			subscribedEvents = new ArrayList<>();
+			typesBySubscriber.put(subscriber, subscribedEvents);
+		}
+		subscribedEvents.add(eventType);
+//粘性事件，就算post时，没有收到，之后也会收到的
+		if (subscriberMethod.sticky) {
+			if (eventInheritance) {
+				// Existing sticky events of all subclasses of eventType have to be considered.
+				// Note: Iterating over all events may be inefficient with lots of sticky events,
+				// thus data structure should be changed to allow a more efficient lookup
+				// (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).
+				Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();
+				for (Map.Entry<Class<?>, Object> entry : entries) {
+					Class<?> candidateEventType = entry.getKey();
+					if (eventType.isAssignableFrom(candidateEventType)) {
+						Object stickyEvent = entry.getValue();
+						checkPostStickyEventToSubscription(newSubscription, stickyEvent);
+					}
+				}
+			} else {
+				Object stickyEvent = stickyEvents.get(eventType);
+				checkPostStickyEventToSubscription(newSubscription, stickyEvent);
+			}
+		}
+	}
+
+	private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {
+		if (stickyEvent != null) {
+			// If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
+			// --> Strange corner case, which we don't take care of here.
+			postToSubscription(newSubscription, stickyEvent, isMainThread());
+		}
+	}
+
+	/**
+	 * Checks if the current thread is running in the main thread.
+	 * If there is no main thread support (e.g. non-Android), "true" is always returned. In that case MAIN thread
+	 * subscribers are always called in posting thread, and BACKGROUND subscribers are always called from a background
+	 * poster.
+	 */
+	private boolean isMainThread() {
+		return mainThreadSupport != null ? mainThreadSupport.isMainThread() : true;
+	}
+
+	public synchronized boolean isRegistered(Object subscriber) {
+		return typesBySubscriber.containsKey(subscriber);
+	}
+
+	/**
+	 * Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber.
+	 */
+	private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
+		//获取所有的
+		List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
+		if (subscriptions != null) {
+			int size = subscriptions.size();
+			for (int i = 0; i < size; i++) {
+				Subscription subscription = subscriptions.get(i);
+				if (subscription.subscriber == subscriber) {
+					subscription.active = false;
+					subscriptions.remove(i);
+					i--;
+					size--;
+				}
+			}
+		}
+	}
+
+	/**
+	 * Unregisters the given subscriber from all event classes.
+	 */
+	public synchronized void unregister(Object subscriber) {
+		List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);//获取所有types（定义的BEAN）
+		if (subscribedTypes != null) {
+			for (Class<?> eventType : subscribedTypes) {
+				unsubscribeByEventType(subscriber, eventType);
+			}
+			typesBySubscriber.remove(subscriber);
+		} else {
+			logger.log(Level.WARNING, "Subscriber to unregister was not registered before: " + subscriber.getClass());
+		}
+	}
+
+	/**
+	 * Posts the given event to the event bus.
+	 */
+	public void post(Object event) {
+		//ThreadLocal，线程隔离
+		PostingThreadState postingState = currentPostingThreadState.get();
+		List<Object> eventQueue = postingState.eventQueue;
+		eventQueue.add(event);
+
+		if (!postingState.isPosting) {
+			postingState.isMainThread = isMainThread();//是否主线程
+			postingState.isPosting = true;
+			if (postingState.canceled) {
+				throw new EventBusException("Internal error. Abort state was not reset");
+			}
+			try {
+				//循环从queue里面取event去执行
+				while (!eventQueue.isEmpty()) {
+					postSingleEvent(eventQueue.remove(0), postingState);
+				}
+			} finally {
+				postingState.isPosting = false;
+				postingState.isMainThread = false;
+			}
+		}
+	}
+
+	/**
+	 * Called from a subscriber's event handling method, further event delivery will be canceled. Subsequent
+	 * subscribers
+	 * won't receive the event. Events are usually canceled by higher priority subscribers (see
+	 * {@link Subscribe#priority()}). Canceling is restricted to event handling methods running in posting thread
+	 * {@link ThreadMode#POSTING}.
+	 */
+	public void cancelEventDelivery(Object event) {
+		PostingThreadState postingState = currentPostingThreadState.get();
+		if (!postingState.isPosting) {
+			throw new EventBusException(
+					"This method may only be called from inside event handling methods on the posting thread");
+		} else if (event == null) {
+			throw new EventBusException("Event may not be null");
+		} else if (postingState.event != event) {
+			throw new EventBusException("Only the currently handled event may be aborted");
+		} else if (postingState.subscription.subscriberMethod.threadMode != ThreadMode.POSTING) {
+			throw new EventBusException(" event handlers may only abort the incoming event");
+		}
+
+		postingState.canceled = true;
+	}
+
+	/**
+	 * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky
+	 * event of an event's type is kept in memory for future access by subscribers using {@link Subscribe#sticky()}.
+	 */
+	public void postSticky(Object event) {
+		synchronized (stickyEvents) {// XXX: 2019/8/15 stickEvents 为ConcurrentHashMap 是线程安全的，还需要synchronized吗
+			stickyEvents.put(event.getClass(), event);
+		}
+		// Should be posted after it is putted, in case the subscriber wants to remove immediately
+		post(event);
+	}
+
+	/**
+	 * Gets the most recent sticky event for the given type.
+	 *
+	 * @see #postSticky(Object)
+	 */
+	public <T> T getStickyEvent(Class<T> eventType) {
+		synchronized (stickyEvents) {
+			return eventType.cast(stickyEvents.get(eventType));
+		}
+	}
+
+	/**
+	 * Remove and gets the recent sticky event for the given event type.
+	 *
+	 * @see #postSticky(Object)
+	 */
+	public <T> T removeStickyEvent(Class<T> eventType) {
+		synchronized (stickyEvents) {
+			return eventType.cast(stickyEvents.remove(eventType));
+		}
+	}
+
+	/**
+	 * Removes the sticky event if it equals to the given event.
+	 *
+	 * @return true if the events matched and the sticky event was removed.
+	 */
+	public boolean removeStickyEvent(Object event) {
+		synchronized (stickyEvents) {
+			Class<?> eventType = event.getClass();
+			Object existingEvent = stickyEvents.get(eventType);
+			if (event.equals(existingEvent)) {
+				stickyEvents.remove(eventType);
+				return true;
+			} else {
+				return false;
+			}
+		}
+	}
+
+	/**
+	 * Removes all sticky events.
+	 */
+	public void removeAllStickyEvents() {
+		synchronized (stickyEvents) {
+			stickyEvents.clear();
+		}
+	}
+
+	public boolean hasSubscriberForEvent(Class<?> eventClass) {
+		List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
+		if (eventTypes != null) {
+			int countTypes = eventTypes.size();
+			for (int h = 0; h < countTypes; h++) {
+				Class<?> clazz = eventTypes.get(h);
+				CopyOnWriteArrayList<Subscription> subscriptions;
+				synchronized (this) {
+					subscriptions = subscriptionsByEventType.get(clazz);
+				}
+				if (subscriptions != null && !subscriptions.isEmpty()) {
+					return true;
+				}
+			}
+		}
+		return false;
+	}
+
+	private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
+		Class<?> eventClass = event.getClass();
+		boolean subscriptionFound = false;
+		if (eventInheritance) {
+			List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);//getAllTypes include parent
+			int countTypes = eventTypes.size();
+			for (int h = 0; h < countTypes; h++) {
+				Class<?> clazz = eventTypes.get(h);
+				subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
+			}
+		} else {
+			subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
+		}
+		if (!subscriptionFound) {
+			if (logNoSubscriberMessages) {
+				logger.log(Level.FINE, "No subscribers registered for event " + eventClass);
+			}
+			if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&
+					eventClass != SubscriberExceptionEvent.class) {
+				post(new NoSubscriberEvent(this, event));
+			}
+		}
+	}
+
+	private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
+		CopyOnWriteArrayList<Subscription> subscriptions;
+		synchronized (this) {
+			subscriptions = subscriptionsByEventType.get(eventClass);//根据eventClass获取subscriptions
+		}
+		if (subscriptions != null && !subscriptions.isEmpty()) {
+			for (Subscription subscription : subscriptions) {
+				postingState.event = event;
+				postingState.subscription = subscription;
+				boolean aborted = false;
+				try {//
+					postToSubscription(subscription, event, postingState.isMainThread);
+					aborted = postingState.canceled;
+				} finally {
+					postingState.event = null;
+					postingState.subscription = null;
+					postingState.canceled = false;
+				}
+				if (aborted) {
+					break;
+				}
+			}
+			return true;
+		}
+		return false;
+	}
+
+	private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
+		switch (subscription.subscriberMethod.threadMode) {
+			case POSTING:
+				invokeSubscriber(subscription, event);
+				break;
+			case MAIN:
+				if (isMainThread) {
+					invokeSubscriber(subscription, event);//通过方法的反射去执行
+				} else {//如果当前非主线程，需要在主线程执行，通过mainThreadPoster去执行，传入了Looper的MainLooper
+					mainThreadPoster.enqueue(subscription, event);
+				}
+				break;
+			case MAIN_ORDERED:
+				if (mainThreadPoster != null) {
+					mainThreadPoster.enqueue(subscription, event);
+				} else {
+					// temporary: technically not correct as poster not decoupled from subscriber
+					invokeSubscriber(subscription, event);
+				}
+				break;
+			case BACKGROUND:
+				if (isMainThread) {
+					backgroundPoster.enqueue(subscription, event);
+				} else {
+					invokeSubscriber(subscription, event);
+				}
+				break;
+			case ASYNC:
+				asyncPoster.enqueue(subscription, event);
+				break;
+			default:
+				throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode);
+		}
+	}
+
+	/**
+	 * Looks up all Class objects including super classes and interfaces. Should also work for interfaces.
+	 */
+	private static List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {
+		synchronized (eventTypesCache) {
+			List<Class<?>> eventTypes = eventTypesCache.get(eventClass);
+			if (eventTypes == null) {
+				eventTypes = new ArrayList<>();
+				Class<?> clazz = eventClass;
+				while (clazz != null) {
+					eventTypes.add(clazz);
+					addInterfaces(eventTypes, clazz.getInterfaces());
+					clazz = clazz.getSuperclass();
+				}
+				eventTypesCache.put(eventClass, eventTypes);
+			}
+			return eventTypes;
+		}
+	}
+
+	/**
+	 * Recurses through super interfaces.
+	 */
+	static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {
+		for (Class<?> interfaceClass : interfaces) {
+			if (!eventTypes.contains(interfaceClass)) {
+				eventTypes.add(interfaceClass);
+				addInterfaces(eventTypes, interfaceClass.getInterfaces());
+			}
+		}
+	}
+
+	/**
+	 * Invokes the subscriber if the subscriptions is still active. Skipping subscriptions prevents race conditions
+	 * between {@link #unregister(Object)} and event delivery. Otherwise the event might be delivered after the
+	 * subscriber unregistered. This is particularly important for main thread delivery and registrations bound to the
+	 * live cycle of an Activity or Fragment.
+	 */
+	void invokeSubscriber(PendingPost pendingPost) {
+		Object event = pendingPost.event;
+		Subscription subscription = pendingPost.subscription;
+		PendingPost.releasePendingPost(pendingPost);
+		if (subscription.active) {
+			invokeSubscriber(subscription, event);
+		}
+	}
+
+	void invokeSubscriber(Subscription subscription, Object event) {
+		try {
+			subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
+		} catch (InvocationTargetException e) {
+			handleSubscriberException(subscription, event, e.getCause());
+		} catch (IllegalAccessException e) {
+			throw new IllegalStateException("Unexpected exception", e);
+		}
+	}
+
+	private void handleSubscriberException(Subscription subscription, Object event, Throwable cause) {
+		if (event instanceof SubscriberExceptionEvent) {
+			if (logSubscriberExceptions) {
+				// Don't send another SubscriberExceptionEvent to avoid infinite event recursion, just log
+				logger.log(Level.SEVERE, "SubscriberExceptionEvent subscriber " + subscription.subscriber.getClass()
+						+ " threw an exception", cause);
+				SubscriberExceptionEvent exEvent = (SubscriberExceptionEvent) event;
+				logger.log(Level.SEVERE, "Initial event " + exEvent.causingEvent + " caused exception in "
+						+ exEvent.causingSubscriber, exEvent.throwable);
+			}
+		} else {
+			if (throwSubscriberException) {
+				throw new EventBusException("Invoking subscriber failed", cause);
+			}
+			if (logSubscriberExceptions) {
+				logger.log(Level.SEVERE, "Could not dispatch event: " + event.getClass() + " to subscribing class "
+						+ subscription.subscriber.getClass(), cause);
+			}
+			if (sendSubscriberExceptionEvent) {
+				SubscriberExceptionEvent exEvent = new SubscriberExceptionEvent(this, cause, event,
+						subscription.subscriber);
+				post(exEvent);
+			}
+		}
+	}
+
+	/**
+	 * For ThreadLocal, much faster to set (and get multiple values).
+	 */
+	final static class PostingThreadState {
+		final List<Object> eventQueue = new ArrayList<>();
+		boolean isPosting;
+		boolean isMainThread;
+		Subscription subscription;
+		Object event;
+		boolean canceled;
+	}
+
+	ExecutorService getExecutorService() {
+		return executorService;
+	}
+
+	/**
+	 * For internal use only.
+	 */
+	public Logger getLogger() {
+		return logger;
+	}
+
+	// Just an idea: we could provide a callback to post() to be notified, an alternative would be events, of course...
+	/* public */interface PostCallback {
+		void onPostCompleted(List<SubscriberExceptionEvent> exceptionEvents);
+	}
+
+	@Override
+	public String toString() {
+		return "EventBus[indexCount=" + indexCount + ", eventInheritance=" + eventInheritance + "]";
+	}
 }
diff --git a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
index 29b75008..160f713e 100644
--- a/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
+++ b/EventBus/src/org/greenrobot/eventbus/SubscriberMethodFinder.java
@@ -79,7 +79,7 @@
         while (findState.clazz != null) {//subscriberClass
             findState.subscriberInfo = getSubscriberInfo(findState);
             if (findState.subscriberInfo != null) {
-                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();//获取Subscriber里的方法
+                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();//通过反射获取Subscriber里的方法
                 for (SubscriberMethod subscriberMethod : array) {
                     if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {
                         findState.subscriberMethods.add(subscriberMethod);
@@ -99,6 +99,7 @@
         synchronized (FIND_STATE_POOL) {
             for (int i = 0; i < POOL_SIZE; i++) {
                 if (FIND_STATE_POOL[i] == null) {
+                    //将findState保存
                     FIND_STATE_POOL[i] = findState;
                     break;
                 }
@@ -163,6 +164,8 @@ private void findUsingReflectionInSingleClass(FindState findState) {
             findState.skipSuperClasses = true;
         }
         for (Method method : methods) {
+            // XXX: 反射方法，  int modifiers = method.getModifiers(); method.getParameterTypes();
+            // method.getAnnotation(Subscribe.class);findState.clazz.getDeclaredMethods();
             int modifiers = method.getModifiers();
             if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
                 Class<?>[] parameterTypes = method.getParameterTypes();
