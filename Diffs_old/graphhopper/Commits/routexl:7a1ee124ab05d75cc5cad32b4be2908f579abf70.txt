diff --git a/.travis.yml b/.travis.yml
index 3bf2a5c51a..f1e53db4fa 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -12,9 +12,9 @@ env:
 matrix:
   include:
     - jdk: openjdk8
-    - env: JDK='OpenJDK 12'
+    - env: JDK='OpenJDK 11'
       install: . ./install-jdk.sh -F 11 -C
-    - env: JDK='OpenJDK 13'
+    - env: JDK='OpenJDK 12'
       install: . ./install-jdk.sh -F 12 -C
     
 # avoid default dependency command for maven, 'true' means 'return true' and continue
diff --git a/android/app/build.gradle b/android/app/build.gradle
index fc4d4ea6ba..84be98bc17 100644
--- a/android/app/build.gradle
+++ b/android/app/build.gradle
@@ -42,14 +42,14 @@ dependencies {
        exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
     }
 
-    implementation 'org.mapsforge:vtm:0.11.0'
-    implementation 'org.mapsforge:vtm-android:0.11.0'
-    implementation 'org.mapsforge:vtm-android:0.11.0:natives-armeabi-v7a'
-    implementation 'org.mapsforge:vtm-android:0.11.0:natives-arm64-v8a'
-    implementation 'org.mapsforge:vtm-android:0.11.0:natives-x86'
-    implementation 'org.mapsforge:vtm-android:0.11.0:natives-x86_64'
-    implementation 'org.mapsforge:vtm-jts:0.11.0'
-    implementation 'org.mapsforge:vtm-themes:0.11.0'
+    implementation 'org.mapsforge:vtm:0.11.1'
+    implementation 'org.mapsforge:vtm-android:0.11.1'
+    implementation 'org.mapsforge:vtm-android:0.11.1:natives-armeabi-v7a'
+    implementation 'org.mapsforge:vtm-android:0.11.1:natives-arm64-v8a'
+    implementation 'org.mapsforge:vtm-android:0.11.1:natives-x86'
+    implementation 'org.mapsforge:vtm-android:0.11.1:natives-x86_64'
+    implementation 'org.mapsforge:vtm-jts:0.11.1'
+    implementation 'org.mapsforge:vtm-themes:0.11.1'
     implementation 'com.caverock:androidsvg:1.3'
 
     implementation 'org.slf4j:slf4j-api:1.7.25'
diff --git a/android/app/pom.xml b/android/app/pom.xml
index ade25517b7..de30b700e4 100644
--- a/android/app/pom.xml
+++ b/android/app/pom.xml
@@ -19,7 +19,7 @@
         <version>0.13-SNAPSHOT</version>
     </parent>
     <properties>
-        <vtm.version>0.11.0</vtm.version>
+        <vtm.version>0.11.1</vtm.version>
         <!-- do not put the properties here as it differs from dev to dev <android.sdk.path>/home/peterk/Programme/android-sdk-linux_x86</android.sdk.path>
         instead use your IDE to set it up or specify android sdk via command line
         using -Dandroid.sdk.path=... or by setting environment variable ANDROID_HOME
diff --git a/android/app/src/main/java/com/graphhopper/android/MainActivity.java b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
index 8dc3e82782..0c50791cba 100644
--- a/android/app/src/main/java/com/graphhopper/android/MainActivity.java
+++ b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
@@ -184,7 +184,7 @@ boolean isReady() {
             logUser("Preparation still in progress");
             return false;
         }
-        logUser("Prepare finished but hopper not ready. This happens when there was an error while loading the files");
+        logUser("Prepare finished but GraphHopper not ready. This happens when there was an error while loading the files");
         return false;
     }
 
diff --git a/android/build.gradle b/android/build.gradle
index ca48f6921f..6b199027f8 100644
--- a/android/build.gradle
+++ b/android/build.gradle
@@ -5,7 +5,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.3.2'
+        classpath 'com.android.tools.build:gradle:3.4.0'
     }
 }
 
diff --git a/android/gradle/wrapper/gradle-wrapper.properties b/android/gradle/wrapper/gradle-wrapper.properties
index 4e974715fd..c4486d47dc 100644
--- a/android/gradle/wrapper/gradle-wrapper.properties
+++ b/android/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
diff --git a/api/src/main/java/com/graphhopper/util/Helper.java b/api/src/main/java/com/graphhopper/util/Helper.java
index de08e73101..e7ed1df51e 100644
--- a/api/src/main/java/com/graphhopper/util/Helper.java
+++ b/api/src/main/java/com/graphhopper/util/Helper.java
@@ -20,6 +20,8 @@
 import com.graphhopper.util.shapes.BBox;
 
 import java.io.*;
+import java.lang.management.GarbageCollectorMXBean;
+import java.lang.management.ManagementFactory;
 import java.nio.ByteBuffer;
 import java.nio.MappedByteBuffer;
 import java.nio.charset.Charset;
@@ -30,7 +32,6 @@
 import java.util.Map.Entry;
 
 /**
- *
  * @author Peter Karich
  */
 public class Helper {
@@ -62,11 +63,11 @@ public static Locale getLocale(String param) {
         return new Locale(param.substring(0, index), param.substring(index + 1));
     }
 
-    public static String toLowerCase(String string){
+    public static String toLowerCase(String string) {
         return string.toLowerCase(Locale.ROOT);
     }
 
-    public static String toUpperCase(String string){
+    public static String toUpperCase(String string) {
         return string.toUpperCase(Locale.ROOT);
     }
 
@@ -174,6 +175,29 @@ public static String getMemInfo() {
         return "totalMB:" + getTotalMB() + ", usedMB:" + getUsedMB();
     }
 
+    public static int getUsedMBAfterGC() {
+        long before = getTotalGcCount();
+        // trigger gc
+        System.gc();
+        while (getTotalGcCount() == before) {
+            // wait for the gc to have completed
+        }
+        long result = (ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed() +
+                ManagementFactory.getMemoryMXBean().getNonHeapMemoryUsage().getUsed()) / (1024 * 1024);
+        return (int) result;
+    }
+
+    private static long getTotalGcCount() {
+        long sum = 0;
+        for (GarbageCollectorMXBean b : ManagementFactory.getGarbageCollectorMXBeans()) {
+            long count = b.getCollectionCount();
+            if (count != -1) {
+                sum += count;
+            }
+        }
+        return sum;
+    }
+
     public static int getSizeOfObjectRef(int factor) {
         // pointer to class, flags, lock
         return factor * (4 + 4 + 4);
@@ -433,4 +457,18 @@ public static final String underScoreToCamelCase(String key) {
 
         return sb.toString();
     }
+
+    /**
+     * Equivalent to java 8 String#join
+     */
+    public static String join(String delimiter, List<String> strings) {
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < strings.size(); i++) {
+            if (i > 0) {
+                sb.append(delimiter);
+            }
+            sb.append(strings.get(i));
+        }
+        return sb.toString();
+    }
 }
diff --git a/api/src/main/java/com/graphhopper/util/Instruction.java b/api/src/main/java/com/graphhopper/util/Instruction.java
index 921d2e3383..8e7612b951 100644
--- a/api/src/main/java/com/graphhopper/util/Instruction.java
+++ b/api/src/main/java/com/graphhopper/util/Instruction.java
@@ -18,7 +18,6 @@
 package com.graphhopper.util;
 
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 
 public class Instruction {
@@ -127,24 +126,6 @@ public Instruction setTime(long time) {
         return this;
     }
 
-    /**
-     * Latitude of the location where this instruction should take place.
-     */
-    double getFirstLat() {
-        return points.getLatitude(0);
-    }
-
-    /**
-     * Longitude of the location where this instruction should take place.
-     */
-    double getFirstLon() {
-        return points.getLongitude(0);
-    }
-
-    double getFirstEle() {
-        return points.getElevation(0);
-    }
-
     /* This method returns the points associated to this instruction. Please note that it will not include the last point,
      * i.e. the first point of the next instruction object.
      */
@@ -156,43 +137,6 @@ public void setPoints(PointList points) {
         this.points = points;
     }
 
-    /**
-     * This method returns a list of gpx entries where the time (in time) is relative to the first
-     * which is 0. It does NOT contain the last point which is the first of the next instruction.
-     *
-     * @return the time offset to add for the next instruction
-     */
-    long fillGPXList(List<GPXEntry> list, long time,
-                     Instruction prevInstr, Instruction nextInstr, boolean firstInstr) {
-        checkOne();
-        int len = points.size();
-        long prevTime = time;
-        double lat = points.getLatitude(0);
-        double lon = points.getLongitude(0);
-        double ele = Double.NaN;
-        boolean is3D = points.is3D();
-        if (is3D)
-            ele = points.getElevation(0);
-
-        for (int i = 0; i < len; i++) {
-            list.add(new GPXEntry(lat, lon, ele, prevTime));
-
-            boolean last = i + 1 == len;
-            double nextLat = last ? nextInstr.getFirstLat() : points.getLatitude(i + 1);
-            double nextLon = last ? nextInstr.getFirstLon() : points.getLongitude(i + 1);
-            double nextEle = is3D ? (last ? nextInstr.getFirstEle() : points.getElevation(i + 1)) : Double.NaN;
-            if (is3D)
-                prevTime = Math.round(prevTime + this.time * Helper.DIST_3D.calcDist(nextLat, nextLon, nextEle, lat, lon, ele) / distance);
-            else
-                prevTime = Math.round(prevTime + this.time * Helper.DIST_3D.calcDist(nextLat, nextLon, lat, lon) / distance);
-
-            lat = nextLat;
-            lon = nextLon;
-            ele = nextEle;
-        }
-        return time + this.time;
-    }
-
     @Override
     public String toString() {
         StringBuilder sb = new StringBuilder();
@@ -209,7 +153,7 @@ public String toString() {
      * Return the direction like 'NE' based on the first tracksegment of the instruction. If
      * Instruction does not contain enough coordinate points, an empty string will be returned.
      */
-    String calcDirection(Instruction nextI) {
+    public String calcDirection(Instruction nextI) {
         double azimuth = calcAzimuth(nextI);
         if (Double.isNaN(azimuth))
             return "";
@@ -241,11 +185,6 @@ public double calcAzimuth(Instruction nextI) {
         return AC.calcAzimuth(lat, lon, nextLat, nextLon);
     }
 
-    void checkOne() {
-        if (points.size() < 1)
-            throw new IllegalStateException("Instruction must contain at least one point " + toString());
-    }
-
     /**
      * This method returns the length of an Instruction. The length of an instruction is defined by [the
      * index of the first point of the next instruction] - [the index of the first point of this instruction].
diff --git a/api/src/main/java/com/graphhopper/util/InstructionList.java b/api/src/main/java/com/graphhopper/util/InstructionList.java
index 5d9192e6be..69aafcad97 100644
--- a/api/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/api/src/main/java/com/graphhopper/util/InstructionList.java
@@ -17,9 +17,6 @@
  */
 package com.graphhopper.util;
 
-import java.text.DateFormat;
-import java.text.DecimalFormat;
-import java.text.DecimalFormatSymbols;
 import java.util.*;
 
 /**
@@ -27,13 +24,6 @@
  */
 public class InstructionList extends AbstractList<Instruction> {
 
-    static String simpleXMLEscape(String str) {
-        // We could even use the 'more flexible' CDATA section but for now do the following. The 'and' could be important sometimes:
-        return str.replaceAll("&", "&amp;").
-                // but do not care for:
-                        replaceAll("[\\<\\>]", "_");
-    }
-
     private final List<Instruction> instructions;
     private final Translation tr;
 
@@ -71,211 +61,6 @@ public Instruction remove(int index) {
         return instructions.remove(index);
     }
 
-    public void replaceLast(Instruction instr) {
-        if (instructions.isEmpty())
-            throw new IllegalStateException("Cannot replace last instruction as list is empty");
-
-        instructions.set(instructions.size() - 1, instr);
-    }
-
-    public List<Map<String, Object>> createJson() {
-        List<Map<String, Object>> instrList = new ArrayList<>(instructions.size());
-        int pointsIndex = 0;
-        int counter = 0;
-        for (Instruction instruction : instructions) {
-            Map<String, Object> instrJson = new HashMap<>();
-            instrList.add(instrJson);
-
-            InstructionAnnotation ia = instruction.getAnnotation();
-            String text = instruction.getTurnDescription(tr);
-            if (Helper.isEmpty(text))
-                text = ia.getMessage();
-            instrJson.put("text", Helper.firstBig(text));
-            if (!ia.isEmpty()) {
-                instrJson.put("annotation_text", ia.getMessage());
-                instrJson.put("annotation_importance", ia.getImportance());
-            }
-
-            instrJson.put("street_name", instruction.getName());
-            instrJson.put("time", instruction.getTime());
-            instrJson.put("distance", Helper.round(instruction.getDistance(), 3));
-            instrJson.put("sign", instruction.getSign());
-            instrJson.putAll(instruction.getExtraInfoJSON());
-
-            int tmpIndex = pointsIndex + instruction.getLength();
-            instrJson.put("interval", Arrays.asList(pointsIndex, tmpIndex));
-            pointsIndex = tmpIndex;
-
-            counter++;
-        }
-        return instrList;
-    }
-
-    /**
-     * @return This method returns a list of gpx entries where the time (in millis) is relative to
-     * the first which is 0.
-     */
-    public List<GPXEntry> createGPXList() {
-        if (isEmpty())
-            return Collections.emptyList();
-
-        List<GPXEntry> gpxList = new ArrayList<>();
-        long timeOffset = 0;
-        for (int i = 0; i < size() - 1; i++) {
-            Instruction prevInstr = (i > 0) ? get(i - 1) : null;
-            boolean instrIsFirst = prevInstr == null;
-            Instruction nextInstr = get(i + 1);
-            nextInstr.checkOne();
-            // current instruction does not contain last point which is equals to first point of next instruction:
-            timeOffset = get(i).fillGPXList(gpxList, timeOffset, prevInstr, nextInstr, instrIsFirst);
-        }
-        Instruction lastI = get(size() - 1);
-        if (lastI.points.size() != 1)
-            throw new IllegalStateException("Last instruction must have exactly one point but was " + lastI.points.size());
-        double lastLat = lastI.getFirstLat(), lastLon = lastI.getFirstLon(),
-                lastEle = lastI.getPoints().is3D() ? lastI.getFirstEle() : Double.NaN;
-        gpxList.add(new GPXEntry(lastLat, lastLon, lastEle, timeOffset));
-        return gpxList;
-    }
-
-    /**
-     * Creates the standard GPX string out of the points according to the schema found here:
-     * https://graphhopper.com/public/schema/gpx-1.1.xsd
-     * <p>
-     *
-     * @return string to be stored as gpx file
-     */
-    public String createGPX(String version) {
-        return createGPX("GraphHopper", new Date().getTime(), version);
-    }
-
-    public String createGPX(String trackName, long startTimeMillis, String version) {
-        boolean includeElevation = size() > 0 && get(0).getPoints().is3D();
-        return createGPX(trackName, startTimeMillis, includeElevation, true, true, true, version);
-    }
-
-    private void createWayPointBlock(StringBuilder output, Instruction instruction, DecimalFormat decimalFormat) {
-        output.append("\n<wpt ");
-        output.append("lat=\"").append(decimalFormat.format(instruction.getFirstLat()));
-        output.append("\" lon=\"").append(decimalFormat.format(instruction.getFirstLon())).append("\">");
-        String name;
-        if (instruction.getName().isEmpty())
-            name = instruction.getTurnDescription(tr);
-        else
-            name = instruction.getName();
-
-        output.append(" <name>").append(simpleXMLEscape(name)).append("</name>");
-        output.append("</wpt>");
-    }
-
-    public String createGPX(String trackName, long startTimeMillis, boolean includeElevation, boolean withRoute, boolean withTrack, boolean withWayPoints, String version) {
-        DateFormat formatter = Helper.createFormatter();
-
-        DecimalFormat decimalFormat = new DecimalFormat("#", DecimalFormatSymbols.getInstance(Locale.ROOT));
-        decimalFormat.setMinimumFractionDigits(1);
-        decimalFormat.setMaximumFractionDigits(6);
-        decimalFormat.setMinimumIntegerDigits(1);
-
-        String header = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>"
-                + "<gpx xmlns=\"http://www.topografix.com/GPX/1/1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""
-                + " creator=\"Graphhopper version " + version + "\" version=\"1.1\""
-                // This xmlns:gh acts only as ID, no valid URL necessary.
-                // Use a separate namespace for custom extensions to make basecamp happy.
-                + " xmlns:gh=\"https://graphhopper.com/public/schema/gpx/1.1\">"
-                + "\n<metadata>"
-                + "<copyright author=\"OpenStreetMap contributors\"/>"
-                + "<link href=\"http://graphhopper.com\">"
-                + "<text>GraphHopper GPX</text>"
-                + "</link>"
-                + "<time>" + formatter.format(startTimeMillis) + "</time>"
-                + "</metadata>";
-        StringBuilder gpxOutput = new StringBuilder(header);
-        if (!isEmpty()) {
-            if (withWayPoints) {
-                createWayPointBlock(gpxOutput, instructions.get(0), decimalFormat);   // Start
-                for (Instruction currInstr : instructions) {
-                    if ((currInstr.getSign() == Instruction.REACHED_VIA) // Via
-                            || (currInstr.getSign() == Instruction.FINISH)) // End
-                    {
-                        createWayPointBlock(gpxOutput, currInstr, decimalFormat);
-                    }
-                }
-            }
-            if (withRoute) {
-                gpxOutput.append("\n<rte>");
-                Instruction nextInstr = null;
-                for (Instruction currInstr : instructions) {
-                    if (null != nextInstr)
-                        createRteptBlock(gpxOutput, nextInstr, currInstr, decimalFormat);
-
-                    nextInstr = currInstr;
-                }
-                createRteptBlock(gpxOutput, nextInstr, null, decimalFormat);
-                gpxOutput.append("\n</rte>");
-            }
-        }
-        if (withTrack) {
-            gpxOutput.append("\n<trk><name>").append(trackName).append("</name>");
-
-            gpxOutput.append("<trkseg>");
-            for (GPXEntry entry : createGPXList()) {
-                gpxOutput.append("\n<trkpt lat=\"").append(decimalFormat.format(entry.getLat()));
-                gpxOutput.append("\" lon=\"").append(decimalFormat.format(entry.getLon())).append("\">");
-                if (includeElevation)
-                    gpxOutput.append("<ele>").append(Helper.round2(entry.getEle())).append("</ele>");
-                gpxOutput.append("<time>").append(formatter.format(startTimeMillis + entry.getTime())).append("</time>");
-                gpxOutput.append("</trkpt>");
-            }
-            gpxOutput.append("\n</trkseg>");
-            gpxOutput.append("\n</trk>");
-        }
-
-        // we could now use 'wpt' for via points
-        gpxOutput.append("\n</gpx>");
-        return gpxOutput.toString();
-    }
-
-    public void createRteptBlock(StringBuilder output, Instruction instruction, Instruction nextI, DecimalFormat decimalFormat) {
-        output.append("\n<rtept lat=\"").append(decimalFormat.format(instruction.getFirstLat())).
-                append("\" lon=\"").append(decimalFormat.format(instruction.getFirstLon())).append("\">");
-
-        if (!instruction.getName().isEmpty())
-            output.append("<desc>").append(simpleXMLEscape(instruction.getTurnDescription(tr))).append("</desc>");
-
-        output.append("<extensions>");
-        output.append("<gh:distance>").append(Helper.round(instruction.getDistance(), 1)).append("</gh:distance>");
-        output.append("<gh:time>").append(instruction.getTime()).append("</gh:time>");
-
-        String direction = instruction.calcDirection(nextI);
-        if (!direction.isEmpty())
-            output.append("<gh:direction>").append(direction).append("</gh:direction>");
-
-        double azimuth = instruction.calcAzimuth(nextI);
-        if (!Double.isNaN(azimuth))
-            output.append("<gh:azimuth>").append(Helper.round2(azimuth)).append("</gh:azimuth>");
-
-        if (instruction instanceof RoundaboutInstruction) {
-            RoundaboutInstruction ri = (RoundaboutInstruction) instruction;
-
-            output.append("<gh:exit_number>").append(ri.getExitNumber()).append("</gh:exit_number>");
-        }
-
-        output.append("<gh:sign>").append(instruction.getSign()).append("</gh:sign>");
-        output.append("</extensions>");
-        output.append("</rtept>");
-    }
-
-    /**
-     * @return list of lat lon
-     */
-    List<List<Double>> createStartPoints() {
-        List<List<Double>> res = new ArrayList<>(instructions.size());
-        for (Instruction instruction : instructions) {
-            res.add(Arrays.asList(instruction.getFirstLat(), instruction.getFirstLon()));
-        }
-        return res;
-    }
-
     /**
      * This method is useful for navigation devices to find the next instruction for the specified
      * coordinate (e.g. the current position).
@@ -339,4 +124,8 @@ public Instruction find(double lat, double lon, double maxDistance) {
         return get(foundInstruction);
     }
 
+    public Translation getTr() {
+        return tr;
+    }
+
 }
diff --git a/api/src/main/java/com/graphhopper/util/PointList.java b/api/src/main/java/com/graphhopper/util/PointList.java
index 11ae6f155e..92b347dd2d 100644
--- a/api/src/main/java/com/graphhopper/util/PointList.java
+++ b/api/src/main/java/com/graphhopper/util/PointList.java
@@ -136,7 +136,7 @@ public int size() {
         }
 
         @Override
-        public GHPoint3D toGHPoint(int index) {
+        public GHPoint3D get(int index) {
             throw new UnsupportedOperationException("cannot access EMPTY PointList");
         }
 
@@ -571,7 +571,7 @@ public void parse2DJSON(String str) {
         }
     }
 
-    public GHPoint3D toGHPoint(int index) {
+    public GHPoint3D get(int index) {
         return new GHPoint3D(getLatitude(index), getLongitude(index), getElevation(index));
     }
 
@@ -594,7 +594,7 @@ public GHPoint3D next() {
                 if (counter >= getSize())
                     throw new NoSuchElementException();
 
-                GHPoint3D point = PointList.this.toGHPoint(counter);
+                GHPoint3D point = PointList.this.get(counter);
                 counter++;
                 return point;
             }
diff --git a/api/src/main/java/com/graphhopper/util/shapes/BBox.java b/api/src/main/java/com/graphhopper/util/shapes/BBox.java
index ed716f56d1..9a73055f9c 100644
--- a/api/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.NumHelper;
+import org.locationtech.jts.geom.Envelope;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -46,7 +47,7 @@
     public double maxEle;
 
     public BBox(double[] coords) {
-        this(coords[0],coords[2],coords[1],coords[3]);
+        this(coords[0], coords[2], coords[1], coords[3]);
     }
 
     public BBox(double minLon, double maxLon, double minLat, double maxLat) {
@@ -122,7 +123,7 @@ public void update(double lat, double lon, double elev) {
      * @return the intersecting BBox or null if not intersecting
      */
     public BBox calculateIntersection(BBox bBox) {
-        if (!this.intersect(bBox))
+        if (!this.intersects(bBox))
             return null;
 
         double minLon = Math.max(this.minLon, bBox.minLon);
@@ -139,11 +140,11 @@ public BBox clone() {
     }
 
     @Override
-    public boolean intersect(Shape s) {
+    public boolean intersects(Shape s) {
         if (s instanceof BBox) {
-            return intersect((BBox) s);
+            return intersects((BBox) s);
         } else if (s instanceof Circle) {
-            return ((Circle) s).intersect(this);
+            return ((Circle) s).intersects(this);
         }
 
         throw new UnsupportedOperationException("unsupported shape");
@@ -160,14 +161,24 @@ public boolean contains(Shape s) {
         throw new UnsupportedOperationException("unsupported shape");
     }
 
-    public boolean intersect(Circle s) {
-        return ((Circle) s).intersect(this);
+    public boolean intersects(Circle s) {
+        return s.intersects(this);
     }
 
-    public boolean intersect(BBox o) {
+    /**
+     * This method calculates if this BBox intersects with the specified BBox
+     */
+    public boolean intersects(double minLon, double maxLon, double minLat, double maxLat) {
+        return this.minLon < maxLon && this.minLat < maxLat && minLon < this.maxLon && minLat < this.maxLat;
+    }
+
+    /**
+     * This method calculates if this BBox intersects with the specified BBox
+     */
+    public boolean intersects(BBox o) {
         // return (o.minLon < minLon && o.maxLon > minLon || o.minLon < maxLon && o.minLon >= minLon)
         //  && (o.maxLat < maxLat && o.maxLat >= minLat || o.maxLat >= maxLat && o.minLat < maxLat);
-        return minLon < o.maxLon && minLat < o.maxLat && o.minLon < maxLon && o.minLat < maxLat;
+        return this.minLon < o.maxLon && this.minLat < o.maxLat && o.minLon < this.maxLon && o.minLat < this.maxLat;
     }
 
     @Override
@@ -272,6 +283,10 @@ public boolean isValid() {
         return list;
     }
 
+    public static BBox fromEnvelope(Envelope envelope) {
+        return new BBox(envelope.getMinX(), envelope.getMaxX(), envelope.getMinY(), envelope.getMaxY());
+    }
+
     /**
      * @return an estimated area in m^2 using the mean value of latitudes for longitude distance
      */
diff --git a/api/src/main/java/com/graphhopper/util/shapes/Circle.java b/api/src/main/java/com/graphhopper/util/shapes/Circle.java
index 0bf6a57b80..bbb38ee334 100644
--- a/api/src/main/java/com/graphhopper/util/shapes/Circle.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/Circle.java
@@ -73,14 +73,14 @@ private double normDist(double lat1, double lon1) {
     }
 
     @Override
-    public boolean intersect(Shape o) {
+    public boolean intersects(Shape o) {
         if (o instanceof Circle) {
-            return intersect((Circle) o);
+            return intersects((Circle) o);
         } else if (o instanceof BBox) {
-            return intersect((BBox) o);
+            return intersects((BBox) o);
         }
 
-        return o.intersect(this);
+        return o.intersects(this);
     }
 
     @Override
@@ -94,8 +94,8 @@ public boolean contains(Shape o) {
         throw new UnsupportedOperationException("unsupported shape");
     }
 
-    public boolean intersect(BBox b) {
-        // test top intersect
+    public boolean intersects(BBox b) {
+        // test top intersects
         if (lat > b.maxLat) {
             if (lon < b.minLon) {
                 return normDist(b.maxLat, b.minLon) <= normedDist;
@@ -106,7 +106,7 @@ public boolean intersect(BBox b) {
             return b.maxLat - bbox.minLat > 0;
         }
 
-        // test bottom intersect
+        // test bottom intersects
         if (lat < b.minLat) {
             if (lon < b.minLon) {
                 return normDist(b.minLat, b.minLon) <= normedDist;
@@ -117,7 +117,7 @@ public boolean intersect(BBox b) {
             return bbox.maxLat - b.minLat > 0;
         }
 
-        // test middle intersect
+        // test middle intersects
         if (lon < b.minLon) {
             return bbox.maxLon - b.minLon > 0;
         }
@@ -127,9 +127,9 @@ public boolean intersect(BBox b) {
         return true;
     }
 
-    public boolean intersect(Circle c) {
+    public boolean intersects(Circle c) {
         // necessary to improve speed?
-        if (!getBounds().intersect(c.getBounds())) {
+        if (!getBounds().intersects(c.getBounds())) {
             return false;
         }
 
diff --git a/api/src/main/java/com/graphhopper/util/shapes/Polygon.java b/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
index 52d94115e0..abf7c731cb 100644
--- a/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
@@ -100,7 +100,7 @@ public boolean contains(GHPoint point) {
     }
 
     @Override
-    public boolean intersect(Shape o) {
+    public boolean intersects(Shape o) {
         throw new UnsupportedOperationException("Not supported yet.");
     }
 
diff --git a/api/src/main/java/com/graphhopper/util/shapes/Shape.java b/api/src/main/java/com/graphhopper/util/shapes/Shape.java
index dd0f71e5f3..7962c67610 100644
--- a/api/src/main/java/com/graphhopper/util/shapes/Shape.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/Shape.java
@@ -27,7 +27,7 @@
     /**
      * @return true if edges or areas of this and the specified shapes overlap
      */
-    boolean intersect(Shape o);
+    boolean intersects(Shape o);
 
     /**
      * @return true only if lat and lon are inside (or on the edge) of this shape
diff --git a/api/src/test/java/com/graphhopper/util/shapes/BBoxTest.java b/api/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
index dc77fb80d1..321e473b5f 100644
--- a/api/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
+++ b/api/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
@@ -71,18 +71,18 @@ public void testIntersect() {
         //
 
         // use ISO 19115 standard (minLon, maxLon followed by minLat(south!),maxLat)
-        assertTrue(new BBox(12, 15, 12, 15).intersect(new BBox(13, 14, 11, 16)));
-        // assertFalse(new BBox(15, 12, 12, 15).intersect(new BBox(16, 15, 11, 14)));
+        assertTrue(new BBox(12, 15, 12, 15).intersects(new BBox(13, 14, 11, 16)));
+        // assertFalse(new BBox(15, 12, 12, 15).intersects(new BBox(16, 15, 11, 14)));
 
         // DOES NOT WORK: use bottom to top coord for lat
-        // assertFalse(new BBox(6, 2, 11, 6).intersect(new BBox(5, 3, 12, 5)));
+        // assertFalse(new BBox(6, 2, 11, 6).intersects(new BBox(5, 3, 12, 5)));
         // so, use bottom-left and top-right corner!
-        assertTrue(new BBox(2, 6, 6, 11).intersect(new BBox(3, 5, 5, 12)));
+        assertTrue(new BBox(2, 6, 6, 11).intersects(new BBox(3, 5, 5, 12)));
 
         // DOES NOT WORK: use bottom to top coord for lat and right to left for lon
-        // assertFalse(new BBox(6, 11, 11, 6).intersect(new BBox(5, 10, 12, 7)));
+        // assertFalse(new BBox(6, 11, 11, 6).intersects(new BBox(5, 10, 12, 7)));
         // so, use bottom-right and top-left corner
-        assertTrue(new BBox(6, 11, 6, 11).intersect(new BBox(7, 10, 5, 12)));
+        assertTrue(new BBox(6, 11, 6, 11).intersects(new BBox(7, 10, 5, 12)));
     }
 
     @Test
@@ -109,37 +109,37 @@ public void testCalculateIntersection() {
     public void testBasicJavaOverload() {
         new BBox(2, 4, 0, 1) {
             @Override
-            public boolean intersect(Circle c) {
+            public boolean intersects(Circle c) {
                 assertTrue(true);
-                return super.intersect(c);
+                return super.intersects(c);
             }
 
             @Override
-            public boolean intersect(Shape c) {
+            public boolean intersects(Shape c) {
                 assertTrue(false);
                 return true;
             }
 
             @Override
-            public boolean intersect(BBox c) {
+            public boolean intersects(BBox c) {
                 assertTrue(false);
                 return true;
             }
-        }.intersect(new Circle(1, 2, 3) {
+        }.intersects(new Circle(1, 2, 3) {
             @Override
-            public boolean intersect(Circle c) {
+            public boolean intersects(Circle c) {
                 assertTrue(false);
                 return true;
             }
 
             @Override
-            public boolean intersect(Shape b) {
+            public boolean intersects(Shape b) {
                 assertTrue(false);
                 return true;
             }
 
             @Override
-            public boolean intersect(BBox b) {
+            public boolean intersects(BBox b) {
                 assertTrue(true);
                 return true;
             }
diff --git a/api/src/test/java/com/graphhopper/util/shapes/CircleTest.java b/api/src/test/java/com/graphhopper/util/shapes/CircleTest.java
index 819a944be4..eaf6e18092 100644
--- a/api/src/test/java/com/graphhopper/util/shapes/CircleTest.java
+++ b/api/src/test/java/com/graphhopper/util/shapes/CircleTest.java
@@ -29,17 +29,17 @@
 public class CircleTest {
     @Test
     public void testIntersectCircleCircle() {
-        assertTrue(new Circle(0, 0, 80000).intersect(new Circle(1, 1, 80000)));
-        assertFalse(new Circle(0, 0, 75000).intersect(new Circle(1, 1, 80000)));
+        assertTrue(new Circle(0, 0, 80000).intersects(new Circle(1, 1, 80000)));
+        assertFalse(new Circle(0, 0, 75000).intersects(new Circle(1, 1, 80000)));
     }
 
     @Test
     public void testIntersectCircleBBox() {
-        assertTrue(new Circle(10, 10, 120000).intersect(new BBox(9, 11, 8, 9)));
-        assertTrue(new BBox(9, 11, 8, 9).intersect(new Circle(10, 10, 120000)));
+        assertTrue(new Circle(10, 10, 120000).intersects(new BBox(9, 11, 8, 9)));
+        assertTrue(new BBox(9, 11, 8, 9).intersects(new Circle(10, 10, 120000)));
 
-        assertFalse(new Circle(10, 10, 110000).intersect(new BBox(9, 11, 8, 9)));
-        assertFalse(new BBox(9, 11, 8, 9).intersect(new Circle(10, 10, 110000)));
+        assertFalse(new Circle(10, 10, 110000).intersects(new BBox(9, 11, 8, 9)));
+        assertFalse(new BBox(9, 11, 8, 9).intersects(new Circle(10, 10, 110000)));
     }
 
     @Test
diff --git a/client-hc/pom.xml b/client-hc/pom.xml
index e19c4d9f08..8bbc4b30d9 100644
--- a/client-hc/pom.xml
+++ b/client-hc/pom.xml
@@ -42,7 +42,7 @@
         <dependency>
             <groupId>com.squareup.okhttp3</groupId>
             <artifactId>okhttp</artifactId>
-            <version>3.8.0</version>
+            <version>3.14.2</version>
         </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
index e88385a674..b6983df46e 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
@@ -225,7 +225,4 @@ protected static String encode(String str) {
         }
     }
 
-    public List<Throwable> readErrors(JsonNode json) {
-        return web.readErrors(json);
-    }
 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
index 43a219b736..d13d61a27b 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
@@ -4,6 +4,7 @@
 import com.fasterxml.jackson.databind.node.ArrayNode;
 import com.fasterxml.jackson.databind.node.JsonNodeFactory;
 import com.fasterxml.jackson.databind.node.ObjectNode;
+import com.graphhopper.jackson.PathWrapperDeserializer;
 import com.graphhopper.util.shapes.GHPoint;
 import okhttp3.OkHttpClient;
 import org.slf4j.Logger;
@@ -110,7 +111,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
 
             JsonNode responseJson = toJSON(postUrl, postResponseStr);
             if (responseJson.has("message")) {
-                matrixResponse.addErrors(readErrors(responseJson));
+                matrixResponse.addErrors(PathWrapperDeserializer.readErrors(objectMapper, responseJson));
                 return matrixResponse;
             }
             if (!responseJson.has("job_id")) {
@@ -139,7 +140,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
                 if (debug) {
                     logger.info(i + " GET URL:" + getUrl + ", response: " + getResponseStr);
                 }
-                matrixResponse.addErrors(readErrors(getResponseJson));
+                matrixResponse.addErrors(PathWrapperDeserializer.readErrors(objectMapper, getResponseJson));
                 if (matrixResponse.hasErrors()) {
                     break;
                 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
index 1761f05c59..38d56eaa72 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
@@ -1,6 +1,7 @@
 package com.graphhopper.api;
 
 import com.fasterxml.jackson.databind.JsonNode;
+import com.graphhopper.jackson.PathWrapperDeserializer;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
 import okhttp3.OkHttpClient;
@@ -99,7 +100,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
             String str = getJson(url);
             JsonNode getResponseJson = objectMapper.reader().readTree(str);
 
-            matrixResponse.addErrors(readErrors(getResponseJson));
+            matrixResponse.addErrors(PathWrapperDeserializer.readErrors(objectMapper, getResponseJson));
             if (!matrixResponse.hasErrors()) {
                 matrixResponse.addErrors(readUsableEntityError(outArraysList, getResponseJson));
             }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
index 485da03c52..ec3b26430a 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.api;
 
-import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.JsonNode;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.graphhopper.GHRequest;
@@ -26,15 +25,17 @@
 import com.graphhopper.PathWrapper;
 import com.graphhopper.http.WebHelper;
 import com.graphhopper.jackson.Jackson;
-import com.graphhopper.util.*;
-import com.graphhopper.util.details.PathDetail;
-import com.graphhopper.util.exceptions.*;
+import com.graphhopper.jackson.PathWrapperDeserializer;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.Parameters;
 import com.graphhopper.util.shapes.GHPoint;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
 
-import java.util.*;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
 import static com.graphhopper.util.Helper.round6;
@@ -103,197 +104,6 @@ public OkHttpClient getDownloader() {
         return downloader;
     }
 
-    PathWrapper createPathWrapper(JsonNode path, boolean tmpElevation, boolean turnDescription) {
-        PathWrapper pathWrapper = new PathWrapper();
-        pathWrapper.addErrors(readErrors(path));
-        if (pathWrapper.hasErrors())
-            return pathWrapper;
-
-        if (path.has("snapped_waypoints")) {
-            String snappedPointStr = path.get("snapped_waypoints").asText();
-            PointList snappedPoints = WebHelper.decodePolyline(snappedPointStr, 5, tmpElevation);
-            pathWrapper.setWaypoints(snappedPoints);
-        }
-
-        if (path.has("ascend")) {
-            pathWrapper.setAscend(path.get("ascend").asDouble());
-        }
-        if (path.has("descend")) {
-            pathWrapper.setDescend(path.get("descend").asDouble());
-        }
-        if (path.has("weight")) {
-            pathWrapper.setRouteWeight(path.get("weight").asDouble());
-        }
-        if (path.has("description")) {
-            JsonNode descriptionNode = path.get("description");
-            if (descriptionNode.isArray()) {
-                List<String> description = new ArrayList<>(descriptionNode.size());
-                for (JsonNode descNode : descriptionNode) {
-                    description.add(descNode.asText());
-                }
-                pathWrapper.setDescription(description);
-            } else {
-                throw new IllegalStateException("Description has to be an array");
-            }
-        }
-
-        if (path.has("points")) {
-            String pointStr = path.get("points").asText();
-            PointList pointList = WebHelper.decodePolyline(pointStr, 100, tmpElevation);
-            pathWrapper.setPoints(pointList);
-
-            if (path.has("instructions")) {
-                JsonNode instrArr = path.get("instructions");
-
-                InstructionList il = new InstructionList(null);
-                int viaCount = 1;
-                for (JsonNode jsonObj : instrArr) {
-                    double instDist = jsonObj.get("distance").asDouble();
-                    String text = turnDescription ? jsonObj.get("text").asText() : jsonObj.get("street_name").asText();
-                    long instTime = jsonObj.get("time").asLong();
-                    int sign = jsonObj.get("sign").asInt();
-                    JsonNode iv = jsonObj.get("interval");
-                    int from = iv.get(0).asInt();
-                    int to = iv.get(1).asInt();
-                    PointList instPL = new PointList(to - from, tmpElevation);
-                    for (int j = from; j <= to; j++) {
-                        instPL.add(pointList, j);
-                    }
-
-                    InstructionAnnotation ia = InstructionAnnotation.EMPTY;
-                    if (jsonObj.has("annotation_importance") && jsonObj.has("annotation_text")) {
-                        ia = new InstructionAnnotation(jsonObj.get("annotation_importance").asInt(), jsonObj.get("annotation_text").asText());
-                    }
-
-                    Instruction instr;
-                    if (sign == Instruction.USE_ROUNDABOUT || sign == Instruction.LEAVE_ROUNDABOUT) {
-                        RoundaboutInstruction ri = new RoundaboutInstruction(sign, text, ia, instPL);
-
-                        if (jsonObj.has("exit_number")) {
-                            ri.setExitNumber(jsonObj.get("exit_number").asInt());
-                        }
-
-                        if (jsonObj.has("exited")) {
-                            if (jsonObj.get("exited").asBoolean())
-                                ri.setExited();
-                        }
-
-                        if (jsonObj.has("turn_angle")) {
-                            // TODO provide setTurnAngle setter
-                            double angle = jsonObj.get("turn_angle").asDouble();
-                            ri.setDirOfRotation(angle);
-                            ri.setRadian((angle < 0 ? -Math.PI : Math.PI) - angle);
-                        }
-
-                        instr = ri;
-                    } else if (sign == Instruction.REACHED_VIA) {
-                        ViaInstruction tmpInstr = new ViaInstruction(text, ia, instPL);
-                        tmpInstr.setViaCount(viaCount);
-                        viaCount++;
-                        instr = tmpInstr;
-                    } else if (sign == Instruction.FINISH) {
-                        instr = new FinishInstruction(text, instPL, 0);
-                    } else {
-                        instr = new Instruction(sign, text, ia, instPL);
-                        if (sign == Instruction.CONTINUE_ON_STREET) {
-                            if (jsonObj.has("heading")) {
-                                instr.setExtraInfo("heading", jsonObj.get("heading").asDouble());
-                            }
-                        }
-                    }
-
-                    // Usually, the translation is done from the routing service so just use the provided string
-                    // instead of creating a combination with sign and name etc.
-                    // This is called the turn description.
-                    // This can be changed by passing <code>turn_description=false</code>.
-                    if (turnDescription)
-                        instr.setUseRawName();
-
-                    instr.setDistance(instDist).setTime(instTime);
-                    il.add(instr);
-                }
-                pathWrapper.setInstructions(il);
-            }
-
-            if (path.has("details")) {
-                JsonNode details = path.get("details");
-                Map<String, List<PathDetail>> pathDetails = new HashMap<>(details.size());
-                Iterator<Map.Entry<String, JsonNode>> detailIterator = details.fields();
-                while (detailIterator.hasNext()) {
-                    Map.Entry<String, JsonNode> detailEntry = detailIterator.next();
-                    List<PathDetail> pathDetailList = new ArrayList<>();
-                    for (JsonNode pathDetail : detailEntry.getValue()) {
-                        PathDetail pd = objectMapper.convertValue(pathDetail, PathDetail.class);
-                        pathDetailList.add(pd);
-                    }
-                    pathDetails.put(detailEntry.getKey(), pathDetailList);
-                }
-                pathWrapper.addPathDetails(pathDetails);
-            }
-        }
-
-        double distance = path.get("distance").asDouble();
-        long time = path.get("time").asLong();
-        pathWrapper.setDistance(distance).setTime(time);
-        return pathWrapper;
-    }
-
-    // Credits to: http://stackoverflow.com/a/24012023/194609
-    private Map<String, Object> toMap(JsonNode object) {
-        return objectMapper.convertValue(object, new TypeReference<Map<String, Object>>() {
-        });
-    }
-
-    public List<Throwable> readErrors(JsonNode json) {
-        List<Throwable> errors = new ArrayList<>();
-        JsonNode errorJson;
-
-        if (json.has("message")) {
-            if (json.has("hints")) {
-                errorJson = json.get("hints");
-            } else {
-                // should not happen
-                errors.add(new RuntimeException(json.get("message").asText()));
-                return errors;
-            }
-        } else
-            return errors;
-
-        for (JsonNode error : errorJson) {
-            String exClass = "";
-            if (error.has("details"))
-                exClass = error.get("details").asText();
-
-            String exMessage = error.get("message").asText();
-
-            if (exClass.equals(UnsupportedOperationException.class.getName()))
-                errors.add(new UnsupportedOperationException(exMessage));
-            else if (exClass.equals(IllegalStateException.class.getName()))
-                errors.add(new IllegalStateException(exMessage));
-            else if (exClass.equals(RuntimeException.class.getName()))
-                errors.add(new DetailedRuntimeException(exMessage, toMap(error)));
-            else if (exClass.equals(IllegalArgumentException.class.getName()))
-                errors.add(new DetailedIllegalArgumentException(exMessage, toMap(error)));
-            else if (exClass.equals(ConnectionNotFoundException.class.getName())) {
-                errors.add(new ConnectionNotFoundException(exMessage, toMap(error)));
-            } else if (exClass.equals(PointNotFoundException.class.getName())) {
-                int pointIndex = error.get("point_index").asInt();
-                errors.add(new PointNotFoundException(exMessage, pointIndex));
-            } else if (exClass.equals(PointOutOfBoundsException.class.getName())) {
-                int pointIndex = error.get("point_index").asInt();
-                errors.add(new PointOutOfBoundsException(exMessage, pointIndex));
-            } else if (exClass.isEmpty())
-                errors.add(new DetailedRuntimeException(exMessage, toMap(error)));
-            else
-                errors.add(new DetailedRuntimeException(exClass + " " + exMessage, toMap(error)));
-        }
-
-        if (json.has("message") && errors.isEmpty())
-            errors.add(new RuntimeException(json.get("message").asText()));
-
-        return errors;
-    }
-
     @Override
     public boolean load(String serviceUrl) {
         this.routeServiceUrl = serviceUrl;
@@ -358,7 +168,7 @@ public GHResponse route(GHRequest request) {
             JsonNode json = objectMapper.reader().readTree(rspBody.byteStream());
 
             GHResponse res = new GHResponse();
-            res.addErrors(readErrors(json));
+            res.addErrors(PathWrapperDeserializer.readErrors(objectMapper, json));
             if (res.hasErrors())
                 return res;
 
@@ -368,7 +178,7 @@ public GHResponse route(GHRequest request) {
             boolean tmpTurnDescription = request.getHints().getBool("turn_description", true);
 
             for (JsonNode path : paths) {
-                PathWrapper altRsp = createPathWrapper(path, tmpElevation, tmpTurnDescription);
+                PathWrapper altRsp = PathWrapperDeserializer.createPathWrapper(objectMapper, path, tmpElevation, tmpTurnDescription);
                 res.add(altRsp);
             }
 
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
index 26b881e74c..8dad531807 100644
--- a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
@@ -5,6 +5,8 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.PathWrapper;
+import com.graphhopper.jackson.Jackson;
+import com.graphhopper.jackson.PathWrapperDeserializer;
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.RoundaboutInstruction;
@@ -87,7 +89,7 @@ public void testAlternativeRoute() {
         path = paths.get(0);
         isBetween(20, 30, path.getPoints().size());
         isBetween(800, 900, path.getDistance());
-        assertTrue("expected: " + path.getDescription().get(0), Arrays.asList("Jacobistrae", "Ludwig-Gercke-Strae", "Eichendorffplatz").contains(path.getDescription().get(0)));
+        assertTrue("expected: " + path.getDescription().get(0), Arrays.asList("Jacobistrae", "Bismarckstrae", "Ludwig-Gercke-Strae", "Eichendorffplatz").contains(path.getDescription().get(0)));
     }
 
     @Test
@@ -235,22 +237,6 @@ public void testExportWithoutTrack() {
         assertTrue(res.endsWith("</gpx>"));
     }
 
-    @Test
-    public void testCreateGPXFromInstructionList() {
-        GHRequest req = new GHRequest().
-                addPoint(new GHPoint(49.6724, 11.3494)).
-                addPoint(new GHPoint(49.6550, 11.4180));
-        req.getHints().put("elevation", false);
-        req.getHints().put("instructions", true);
-        req.getHints().put("calc_points", true);
-        GHResponse ghResponse = gh.route(req);
-        String gpx = ghResponse.getBest().getInstructions().createGPX("wurst");
-        assertTrue(gpx.contains("<gpx"));
-        assertTrue(gpx.contains("<rtept lat="));
-        assertTrue(gpx.contains("<trk><name>"));
-        assertTrue(gpx.endsWith("</gpx>"));
-    }
-
     void isBetween(double from, double to, double expected) {
         assertTrue("expected value " + expected + " was smaller than limit " + from, expected >= from);
         assertTrue("expected value " + expected + " was bigger than limit " + to, expected <= to);
@@ -307,8 +293,9 @@ protected String postJson(String url, JsonNode data) throws IOException {
     public void testUnknownInstructionSign() throws IOException {
         // Actual path for the request: point=48.354413%2C8.676335&point=48.35442%2C8.676345
         // Modified the sign though
-        JsonNode json = new ObjectMapper().readTree("{\"instructions\":[{\"distance\":1.073,\"sign\":741,\"interval\":[0,1],\"text\":\"Continue onto A 81\",\"time\":32,\"street_name\":\"A 81\"},{\"distance\":0,\"sign\":4,\"interval\":[1,1],\"text\":\"Finish!\",\"time\":0,\"street_name\":\"\"}],\"descend\":0,\"ascend\":0,\"distance\":1.073,\"bbox\":[8.676286,48.354446,8.676297,48.354453],\"weight\":0.032179,\"time\":32,\"points_encoded\":true,\"points\":\"gfcfHwq}s@}c~AAA?\",\"snapped_waypoints\":\"gfcfHwq}s@}c~AAA?\"}");
-        PathWrapper wrapper = new GraphHopperWeb().createPathWrapper(json, true, true);
+        ObjectMapper objectMapper = Jackson.newObjectMapper();
+        JsonNode json = objectMapper.readTree("{\"instructions\":[{\"distance\":1.073,\"sign\":741,\"interval\":[0,1],\"text\":\"Continue onto A 81\",\"time\":32,\"street_name\":\"A 81\"},{\"distance\":0,\"sign\":4,\"interval\":[1,1],\"text\":\"Finish!\",\"time\":0,\"street_name\":\"\"}],\"descend\":0,\"ascend\":0,\"distance\":1.073,\"bbox\":[8.676286,48.354446,8.676297,48.354453],\"weight\":0.032179,\"time\":32,\"points_encoded\":true,\"points\":\"gfcfHwq}s@}c~AAA?\",\"snapped_waypoints\":\"gfcfHwq}s@}c~AAA?\"}");
+        PathWrapper wrapper = PathWrapperDeserializer.createPathWrapper(objectMapper, json, true, true);
 
         assertEquals(741, wrapper.getInstructions().get(0).getSign());
         assertEquals("Continue onto A 81", wrapper.getInstructions().get(0).getName());
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index 659e0cdfce..4ac9737fc9 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,3 +1,5 @@
+0.13
+    removed TraversalMode.EDGE_BASED_1DIR
 0.12
     renamed VirtualEdgeIteratorState.getOriginalEdgeKey to more precise getOriginalEdgeKey #1549
     access refactoring #1436 that moves AccessValue into SpatialRule.Access
diff --git a/core/files/update-translations.sh b/core/files/update-translations.sh
index 24496ac1b3..13663f9e64 100755
--- a/core/files/update-translations.sh
+++ b/core/files/update-translations.sh
@@ -3,7 +3,7 @@ cd $HOME/..
 
 destination=src/main/resources/com/graphhopper/util/
 
-translations="en_US SKIP SKIP ar ast bg ca cs_CZ da_DK de_DE el eo es fa fil fi fr_FR fr_CH gl he hr_HR hsb hu_HU it ja ko lt_LT ne nl pl_PL pt_BR pt_PT ro ru sk sl_SI sr_RS sv_SE tr uk vi_VI zh_CN zh_HK"
+translations="en_US SKIP SKIP ar ast bg ca cs_CZ da_DK de_DE el eo es fa fil fi fr_FR fr_CH gl he hr_HR hsb hu_HU it ja ko lt_LT ne nl pl_PL pt_BR pt_PT ro ru sk sl_SI sr_RS sv_SE tr uk vi_VI zh_CN zh_HK zh_TW"
 file=$1
 
 # You can execute the following
diff --git a/core/pom.xml b/core/pom.xml
index 91615bda51..97201d6b5b 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -98,7 +98,7 @@
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-jar-plugin</artifactId>
-                    <version>3.1.0</version>
+                    <version>3.1.2</version>
                     <executions>
                         <execution>
                             <goals>
@@ -111,7 +111,7 @@
                 <plugin>
                     <groupId>pl.project13.maven</groupId>
                     <artifactId>git-commit-id-plugin</artifactId>
-                    <version>2.2.5</version>
+                    <version>3.0.0</version>
                 </plugin>
             </plugins>
         </pluginManagement>
diff --git a/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java b/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
index febffdccd7..db9c9e01ff 100644
--- a/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
+++ b/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
@@ -20,6 +20,10 @@
 import java.util.BitSet;
 
 /**
+ * This implementation stores the bits inside the values of a long-array. Be aware that the size of this array grows
+ * depending on the values you pass into this set. If you only want to add a few (possibly large) integers you should
+ * use {@link GHTBitSet} instead.
+ *
  * @author Peter Karich
  */
 public class GHBitSetImpl extends BitSet implements GHBitSet {
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
index 05edba0605..c0445d30ee 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
@@ -73,8 +73,8 @@ protected void initCollections(int size) {
     protected abstract SPTEntry createStartEntry(int node, double weight, boolean reverse);
 
     /**
-     * Creates a new entry of the shortest path tree (a {@link SPTEntry} or one of its subclasses) during a
-     * dijkstra expansion.
+     * Creates a new entry of the shortest path tree (a {@link SPTEntry} or one of its subclasses) during a dijkstra
+     * expansion.
      *
      * @param edge    the edge that is currently processed for the expansion
      * @param incEdge the id of the edge that is incoming to the node the edge is pointed at. usually this is the same as
@@ -248,13 +248,9 @@ protected void updateBestPath(EdgeIteratorState edgeState, SPTEntry entry, int t
             if (getIncomingEdge(entryOther) != getIncomingEdge(entry))
                 throw new IllegalStateException("cannot happen for edge based execution of " + getName());
 
-            if (entryOther.adjNode != entry.adjNode) {
-                // prevents the path to contain the edge at the meeting point twice and subtracts the weight (excluding turn weight => no previous edge)
-                entry = entry.getParent();
-                weight -= weighting.calcWeight(edgeState, reverse, EdgeIterator.NO_EDGE);
-            } else if (!traversalMode.hasUTurnSupport())
-                // we detected a u-turn at meeting point, skip if not supported
-                return;
+            // prevents the path to contain the edge at the meeting point twice and subtracts the weight (excluding turn weight => no previous edge)
+            entry = entry.getParent();
+            weight -= weighting.calcWeight(edgeState, reverse, EdgeIterator.NO_EDGE);
         }
 
         if (weight < bestPath.getWeight()) {
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirectionEdgeCHNoSOD.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirectionEdgeCHNoSOD.java
index 9aff7be09d..2d1550e234 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirectionEdgeCHNoSOD.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirectionEdgeCHNoSOD.java
@@ -18,13 +18,14 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.ch.CHEntry;
-import com.graphhopper.routing.ch.Path4CH;
+import com.graphhopper.routing.ch.EdgeBasedPathCH;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
@@ -37,13 +38,20 @@
     private final EdgeExplorer innerInExplorer;
     private final EdgeExplorer innerOutExplorer;
     private final TurnWeighting turnWeighting;
+    private final TurnCostExtension turnCostExtension;
 
     public AbstractBidirectionEdgeCHNoSOD(Graph graph, TurnWeighting weighting) {
         super(graph, weighting, TraversalMode.EDGE_BASED_2DIR);
         this.turnWeighting = weighting;
         // we need extra edge explorers, because they get called inside a loop that already iterates over edges
-        innerInExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.inEdges(flagEncoder));
-        innerOutExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.outEdges(flagEncoder));
+        // important: we have to use different filter ids, otherwise this will not work with QueryGraph's edge explorer
+        // cache, see #1623.
+        innerInExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.inEdges(flagEncoder).setFilterId(1));
+        innerOutExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.outEdges(flagEncoder).setFilterId(1));
+        if (!(graph.getExtension() instanceof TurnCostExtension)) {
+            throw new IllegalArgumentException("edge-based CH algorithms require a turn cost extension");
+        }
+        turnCostExtension = (TurnCostExtension) graph.getExtension();
     }
 
     @Override
@@ -87,12 +95,13 @@ protected void updateBestPath(EdgeIteratorState edgeState, SPTEntry entry, int t
             if (entry.getWeightOfVisitedPath() < bestPath.getWeight()) {
                 bestPath.setSwitchToFrom(reverse);
                 bestPath.setSPTEntry(entry);
-                bestPath.setSPTEntryTo(new SPTEntry(EdgeIterator.NO_EDGE, oppositeNode, 0));
+                bestPath.setSPTEntryTo(new CHEntry(oppositeNode, 0));
                 bestPath.setWeight(entry.getWeightOfVisitedPath());
                 return;
             }
         }
 
+        // todo: it would be sufficient (and maybe more efficient) to use an original edge explorer here ?
         EdgeIterator iter = reverse ?
                 innerInExplorer.setBaseNode(edgeState.getAdjNode()) :
                 innerOutExplorer.setBaseNode(edgeState.getAdjNode());
@@ -102,7 +111,7 @@ protected void updateBestPath(EdgeIteratorState edgeState, SPTEntry entry, int t
         while (iter.next()) {
             final int edgeId = getOrigEdgeId(iter, !reverse);
             final int prevOrNextOrigEdgeId = getOrigEdgeId(edgeState, reverse);
-            if (!traversalMode.hasUTurnSupport() && edgeId == prevOrNextOrigEdgeId) {
+            if (!traversalMode.hasUTurnSupport() && turnCostExtension.isUTurn(edgeId, prevOrNextOrigEdgeId)) {
                 continue;
             }
             int key = GHUtility.getEdgeKey(graph, edgeId, iter.getBaseNode(), !reverse);
@@ -127,7 +136,7 @@ protected void updateBestPath(EdgeIteratorState edgeState, SPTEntry entry, int t
 
     @Override
     protected Path createAndInitPath() {
-        bestPath = new Path4CH(graph, graph.getBaseGraph(), weighting);
+        bestPath = new EdgeBasedPathCH(graph, graph.getBaseGraph(), weighting);
         return bestPath;
     }
 
@@ -149,8 +158,11 @@ protected int getTraversalId(EdgeIteratorState edge, int origEdgeId, boolean rev
 
     @Override
     protected boolean accept(EdgeIteratorState edge, SPTEntry currEdge, boolean reverse) {
-        int edgeId = getOrigEdgeId(edge, !reverse);
-        if (!traversalMode.hasUTurnSupport() && edgeId == getIncomingEdge(currEdge))
+        final int incEdge = getIncomingEdge(currEdge);
+        if (incEdge == EdgeIterator.NO_EDGE)
+            return true;
+        final int prevOrNextEdgeId = getOrigEdgeId(edge, !reverse);
+        if (!traversalMode.hasUTurnSupport() && turnCostExtension.isUTurn(incEdge, prevOrNextEdgeId))
             return false;
 
         return additionalEdgeFilter == null || additionalEdgeFilter.accept(edge);
diff --git a/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java b/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
index 8b342cd9ec..145fb56228 100644
--- a/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
+++ b/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
@@ -157,7 +157,7 @@ public void setMaxExplorationFactor(double explorationFactor) {
     public void setMaxPaths(int maxPaths) {
         this.maxPaths = maxPaths;
         if (this.maxPaths < 2)
-            throw new IllegalStateException("Use normal algorithm with less overhead instead if no alternatives are required");
+            throw new IllegalArgumentException("Use normal algorithm with less overhead instead if no alternatives are required");
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java
index cfc3a31cc2..a91e137ce1 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java
@@ -65,7 +65,7 @@ private boolean entryIsStallable(SPTEntry entry, IntObjectMap<SPTEntry> bestWeig
         EdgeIterator iter = edgeExplorer.setBaseNode(entry.adjNode);
         while (iter.next()) {
             // no need to inspect the edge we are coming from
-            if (iter.getEdge() == entry.adjNode) {
+            if (iter.getEdge() == entry.edge) {
                 continue;
             }
             int traversalId = traversalMode.createTraversalId(iter, reverse);
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 2f32dcacf3..f3fe8c9855 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -234,8 +234,7 @@ public String getDebugInfo() {
     /**
      * Calculates the distance and time of the specified edgeId. Also it adds the edgeId to the path list.
      *
-     * @param prevEdgeId here the edge that comes before edgeId is necessary. I.e. for the reverse search we need the
-     *                   next edge.
+     * @param prevEdgeId the edge that comes before edgeId: --prevEdgeId-x-edgeId-->adjNode
      */
     protected void processEdge(int edgeId, int adjNode, int prevEdgeId) {
         EdgeIteratorState iter = graph.getEdgeIteratorState(edgeId, adjNode);
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
index 1c52802bdc..2c8dc99f39 100644
--- a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
+++ b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
@@ -17,10 +17,14 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+
+import static com.graphhopper.util.EdgeIterator.NO_EDGE;
 
 /**
  * This class creates a DijkstraPath from two Edge's resulting from a BidirectionalDijkstra
@@ -69,30 +73,77 @@ public Path extract() {
             sptEntry = edgeTo;
             edgeTo = ee;
         }
+        extractFwdPath();
+        processTurnAtMeetingPoint();
+        extractBwdPath();
+        extractSW.stop();
+        return setFound(true);
+    }
+
+    private void extractFwdPath() {
+        // we take the 'edgeFrom'/sptEntry that points at the meeting node and follow its parent pointers back to
+        // the source
         SPTEntry currEdge = sptEntry;
-        boolean nextEdgeValid = EdgeIterator.Edge.isValid(currEdge.edge);
-        int nextEdge;
-        while (nextEdgeValid) {
-            // the reverse search needs the next edge
-            nextEdgeValid = EdgeIterator.Edge.isValid(currEdge.parent.edge);
-            nextEdge = nextEdgeValid ? currEdge.parent.edge : EdgeIterator.NO_EDGE;
-            processEdge(currEdge.edge, currEdge.adjNode, nextEdge);
-            currEdge = currEdge.parent;
+        SPTEntry prevEdge = currEdge.parent;
+        while (EdgeIterator.Edge.isValid(currEdge.edge)) {
+            processEdge(currEdge.edge, currEdge.adjNode, getIncEdge(prevEdge));
+            currEdge = prevEdge;
+            prevEdge = currEdge.parent;
         }
-
         setFromNode(currEdge.adjNode);
+        // since we followed the fwd path in backward direction we need to reverse the edge ids
         reverseOrder();
-        currEdge = edgeTo;
-        int prevEdge = EdgeIterator.Edge.isValid(sptEntry.edge) ? sptEntry.edge : EdgeIterator.NO_EDGE;
-        int tmpEdge = currEdge.edge;
-        while (EdgeIterator.Edge.isValid(tmpEdge)) {
-            currEdge = currEdge.parent;
-            processEdge(tmpEdge, currEdge.adjNode, prevEdge);
-            prevEdge = tmpEdge;
-            tmpEdge = currEdge.edge;
+    }
+
+    private void extractBwdPath() {
+        // we take the edgeTo at the meeting node and follow its parent pointers to the target
+        SPTEntry currEdge = edgeTo;
+        SPTEntry nextEdge = currEdge.parent;
+        while (EdgeIterator.Edge.isValid(currEdge.edge)) {
+            processEdgeBwd(currEdge.edge, currEdge.adjNode, getIncEdge(nextEdge));
+            currEdge = nextEdge;
+            nextEdge = nextEdge.parent;
         }
         setEndNode(currEdge.adjNode);
-        extractSW.stop();
-        return setFound(true);
+    }
+
+    private void processTurnAtMeetingPoint() {
+        processTurn(getIncEdge(sptEntry), sptEntry.adjNode, getIncEdge(edgeTo));
+    }
+
+    /**
+     * Similar to {@link #processEdge(int, int, int)}, but with the situation we encounter when doing a backward
+     * search: nextEdgeId--x<--edgeId--adjNode
+     */
+    protected void processEdgeBwd(int edgeId, int adjNode, int nextEdgeId) {
+        EdgeIteratorState edge = graph.getEdgeIteratorState(edgeId, adjNode);
+        distance += edge.getDistance();
+        // special case for loop edges: since they do not have a meaningful direction we always need to read them
+        // in the 'fwd' direction, but be careful the turn costs have to be applied with reverse = true, see also
+        // same comment in EdgeBasedPath4CH
+        // todonow: consolidate this!
+        if (edge.getBaseNode() == edge.getAdjNode()) {
+            long millis = weighting.calcMillis(edge, false, NO_EDGE);
+            if (weighting instanceof TurnWeighting && EdgeIterator.Edge.isValid(nextEdgeId)) {
+                millis += 1000 * (long) ((TurnWeighting) weighting).calcTurnWeight(edge.getEdge(), edge.getBaseNode(), nextEdgeId);
+            }
+            time += millis;
+        } else {
+            time += weighting.calcMillis(edge, true, nextEdgeId);
+        }
+        addEdge(edgeId);
+    }
+
+    private void processTurn(int inEdge, int viaNode, int outEdge) {
+        if (!EdgeIterator.Edge.isValid(inEdge) || !EdgeIterator.Edge.isValid(outEdge)) {
+            return;
+        }
+        if (weighting instanceof TurnWeighting) {
+            time += ((TurnWeighting) weighting).calcTurnWeight(inEdge, viaNode, outEdge) * 1000;
+        }
+    }
+
+    protected int getIncEdge(SPTEntry entry) {
+        return entry.edge;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index c5639e5b9d..f3c1fecb76 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -57,8 +57,7 @@
     private final int mainEdges;
     private final QueryGraph baseGraph;
     private final GraphExtension wrappedExtension;
-    // TODO when spreading it on different threads we need multiple independent explorers
-    private final Map<Integer, EdgeExplorer> cacheMap = new HashMap<>(4);
+    private final Map<EdgeFilter, EdgeExplorer> cacheMap = new HashMap<>(4);
 
     // For every virtual node there are 4 edges: base-snap, snap-base, snap-adj, adj-snap.
     List<VirtualEdgeIteratorState> virtualEdges;
@@ -273,30 +272,25 @@ public boolean apply(int edgeId, List<QueryResult> results) {
                 EdgeIteratorState closestEdge = results.get(0).getClosestEdge();
                 final PointList fullPL = closestEdge.fetchWayGeometry(3);
                 int baseNode = closestEdge.getBaseNode();
-                // sort results on the same edge by the wayIndex and if equal by distance to pillar node
                 Collections.sort(results, new Comparator<QueryResult>() {
                     @Override
                     public int compare(QueryResult o1, QueryResult o2) {
-                        int diff = o1.getWayIndex() - o2.getWayIndex();
+                        int diff = Integer.compare(o1.getWayIndex(), o2.getWayIndex());
                         if (diff == 0) {
-                            // sort by distance from snappedPoint to fullPL.get(wayIndex) if wayIndex is identical
-                            GHPoint p1 = o1.getSnappedPoint();
-                            GHPoint p2 = o2.getSnappedPoint();
-                            if (p1.equals(p2))
-                                return 0;
-
-                            double fromLat = fullPL.getLatitude(o1.getWayIndex());
-                            double fromLon = fullPL.getLongitude(o1.getWayIndex());
-                            if (Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, p1.lat, p1.lon)
-                                    > Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, p2.lat, p2.lon))
-                                return 1;
-                            return -1;
+                            return Double.compare(distanceOfSnappedPointToPillarNode(o1), distanceOfSnappedPointToPillarNode(o2));
+                        } else {
+                            return diff;
                         }
-                        return diff;
+                    }
+                    private double distanceOfSnappedPointToPillarNode(QueryResult o) {
+                        GHPoint snappedPoint = o.getSnappedPoint();
+                        double fromLat = fullPL.getLatitude(o.getWayIndex());
+                        double fromLon = fullPL.getLongitude(o.getWayIndex());
+                        return Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, snappedPoint.lat, snappedPoint.lon);
                     }
                 });
 
-                GHPoint3D prevPoint = fullPL.toGHPoint(0);
+                GHPoint3D prevPoint = fullPL.get(0);
                 int adjNode = closestEdge.getAdjNode();
                 int origEdgeKey = GHUtility.createEdgeKey(baseNode, adjNode, closestEdge.getEdge(), false);
                 int origRevEdgeKey = GHUtility.createEdgeKey(baseNode, adjNode, closestEdge.getEdge(), true);
@@ -308,8 +302,7 @@ public int compare(QueryResult o1, QueryResult o2) {
                 // Create base and adjacent PointLists for all none-equal virtual nodes.
                 // We do so via inserting them at the correct position of fullPL and cutting the
                 // fullPL into the right pieces.
-                for (int counter = 0; counter < results.size(); counter++) {
-                    QueryResult res = results.get(counter);
+                for (QueryResult res : results) {
                     if (res.getClosestEdge().getBaseNode() != baseNode)
                         throw new IllegalStateException("Base nodes have to be identical but were not: " + closestEdge + " vs " + res.getClosestEdge());
 
@@ -348,7 +341,7 @@ public int compare(QueryResult o1, QueryResult o2) {
                 if (addedEdges)
                     createEdges(origEdgeKey, origRevEdgeKey,
                             prevPoint, prevWayIndex, false,
-                            fullPL.toGHPoint(fullPL.getSize() - 1), fullPL.getSize() - 2,
+                            fullPL.get(fullPL.getSize() - 1), fullPL.getSize() - 2,
                             fullPL, closestEdge, virtNodeId - 1, adjNode);
 
                 return true;
@@ -378,11 +371,11 @@ public boolean isVirtualNode(int nodeId) {
 
     /**
      * This method is an experimental feature to reduce memory and CPU resources if there are many
-     * locations ("hundreds") for one QueryGraph. It can make problems for custom or threaded
-     * algorithms or when using custom EdgeFilters for EdgeExplorer creation. Another limitation is
-     * that the same edge explorer is used even if a different vehicle/flagEncoder is chosen.
-     * Currently we can cache only the ALL_EDGES filter or instances of the DefaultEdgeFilter where
-     * three edge explorers will be created: forward OR backward OR both.
+     * locations ("hundreds") for one QueryGraph. EdgeExplorer instances are cached based on the {@link EdgeFilter}
+     * passed into {@link #createEdgeExplorer(EdgeFilter)}. For equal (in the java sense) {@link EdgeFilter}s always
+     * the same {@link EdgeExplorer} will be returned when caching is enabled. Care has to be taken for example for
+     * custom or threaded algorithms, when using custom {@link EdgeFilter}s, or when the same edge explorer is used
+     * with different vehicles/encoders.
      */
     public QueryGraph setUseEdgeExplorerCache(boolean useEECache) {
         this.useEdgeExplorerCache = useEECache;
@@ -581,32 +574,15 @@ public EdgeExplorer createEdgeExplorer(final EdgeFilter edgeFilter) {
             throw new IllegalStateException("Call lookup before using this graph");
 
         if (useEdgeExplorerCache) {
-            int counter = -1;
-            if (edgeFilter instanceof DefaultEdgeFilter) {
-                DefaultEdgeFilter dee = (DefaultEdgeFilter) edgeFilter;
-                counter = 0;
-                if (dee.acceptsBackward())
-                    counter = 1;
-                if (dee.acceptsForward())
-                    counter += 2;
-
-                if (counter == 0)
-                    throw new IllegalStateException("You tried to use an edge filter blocking every access");
-
-            } else if (edgeFilter == EdgeFilter.ALL_EDGES) {
-                counter = 4;
-            }
-
-            if (counter >= 0) {
-                EdgeExplorer cached = cacheMap.get(counter);
-                if (cached == null) {
-                    cached = createUncachedEdgeExplorer(edgeFilter);
-                    cacheMap.put(counter, cached);
-                }
-                return cached;
+            EdgeExplorer cached = cacheMap.get(edgeFilter);
+            if (cached == null) {
+                cached = createUncachedEdgeExplorer(edgeFilter);
+                cacheMap.put(edgeFilter, cached);
             }
+            return cached;
+        } else {
+            return createUncachedEdgeExplorer(edgeFilter);
         }
-        return createUncachedEdgeExplorer(edgeFilter);
     }
 
     private EdgeExplorer createUncachedEdgeExplorer(EdgeFilter edgeFilter) {
@@ -714,9 +690,6 @@ private boolean isInitialized() {
     }
 
     @Override
-    /**
-     * @see QueryGraph
-     */
     public EdgeExplorer createEdgeExplorer() {
         return createEdgeExplorer(EdgeFilter.ALL_EDGES);
     }
@@ -758,6 +731,15 @@ public int getOtherNode(int edge, int node) {
         return mainGraph.getOtherNode(edge, node);
     }
 
+    @Override
+    public boolean isAdjacentToNode(int edge, int node) {
+        if (isVirtualEdge(edge)) {
+            EdgeIteratorState virtualEdge = getEdgeIteratorState(edge, node);
+            return virtualEdge.getBaseNode() == node || virtualEdge.getAdjNode() == node;
+        }
+        return mainGraph.isAdjacentToNode(edge, node);
+    }
+
     private UnsupportedOperationException exc() {
         return new UnsupportedOperationException("QueryGraph cannot be modified.");
     }
@@ -775,16 +757,32 @@ public long getTurnCostFlags(int edgeFrom, int nodeVia, int edgeTo) {
                 return 0;
             } else if (isVirtualEdge(edgeFrom) || isVirtualEdge(edgeTo)) {
                 if (isVirtualEdge(edgeFrom)) {
-                    edgeFrom = queryResults.get((edgeFrom - mainEdges) / 4).getClosestEdge().getEdge();
+                    edgeFrom = getOriginalEdge(edgeFrom);
                 }
                 if (isVirtualEdge(edgeTo)) {
-                    edgeTo = queryResults.get((edgeTo - mainEdges) / 4).getClosestEdge().getEdge();
+                    edgeTo = getOriginalEdge(edgeTo);
                 }
                 return mainTurnExtension.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
-
             } else {
                 return mainTurnExtension.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
             }
         }
+
+        @Override
+        public boolean isUTurn(int edgeFrom, int edgeTo) {
+            // detecting a u-turn from a virtual to a non-virtual edge requires looking at the original edge of the
+            // virtual edge. however when we are turning between virtual edges we need to compare the virtual edge ids
+            // see #1593
+            if (isVirtualEdge(edgeFrom) && !isVirtualEdge(edgeTo)) {
+                edgeFrom = getOriginalEdge(edgeFrom);
+            } else if (!isVirtualEdge(edgeFrom) && isVirtualEdge(edgeTo)) {
+                edgeTo = getOriginalEdge(edgeTo);
+            }
+            return mainTurnExtension.isUTurn(edgeFrom, edgeTo);
+        }
+
+        private int getOriginalEdge(int edgeFrom) {
+            return queryResults.get((edgeFrom - mainEdges) / 4).getClosestEdge().getEdge();
+        }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedNodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedNodeContractor.java
index 5c103aeaa1..11917ae4c5 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedNodeContractor.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedNodeContractor.java
@@ -134,11 +134,11 @@ public float calculatePriority(int node) {
         float priority = params.edgeQuotientWeight * edgeQuotient +
                 params.originalEdgeQuotientWeight * origEdgeQuotient +
                 params.hierarchyDepthWeight * hierarchyDepth;
-        LOGGER.trace("node: %d, eq: %d / %d = %f, oeq: %d / %d = %f, depth: %d --> %f\n",
+        LOGGER.trace(String.format(Locale.ROOT, "node: %d, eq: %d / %d = %f, oeq: %d / %d = %f, depth: %d --> %f\n",
                 node,
                 numShortcuts, numPrevEdges, edgeQuotient,
                 numOrigEdges, numPrevOrigEdges, origEdgeQuotient,
-                hierarchyDepth, priority);
+                hierarchyDepth, priority));
         return priority;
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedPathCH.java b/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedPathCH.java
new file mode 100644
index 0000000000..3b97f366b8
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedPathCH.java
@@ -0,0 +1,55 @@
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.storage.ShortcutUnpacker;
+import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+
+import static com.graphhopper.util.EdgeIterator.NO_EDGE;
+
+
+public class EdgeBasedPathCH extends Path4CH {
+
+    private final TurnWeighting turnWeighting;
+
+    public EdgeBasedPathCH(Graph routingGraph, Graph baseGraph, final Weighting weighting) {
+        super(routingGraph, baseGraph, weighting);
+        if (!(weighting instanceof TurnWeighting)) {
+            throw new IllegalArgumentException("Need a TurnWeighting for edge-based CH");
+        }
+        turnWeighting = (TurnWeighting) weighting;
+    }
+
+    @Override
+    protected ShortcutUnpacker getShortcutUnpacker(Graph routingGraph, final Weighting weighting) {
+        return new ShortcutUnpacker(routingGraph, new ShortcutUnpacker.Visitor() {
+            @Override
+            public void visit(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+                distance += edge.getDistance();
+                // a one-way loop that is not a shortcut cannot possibly be read in the 'right' direction, because
+                // there is no way to distinguish the two directions. therefore we always read it in fwd direction.
+                // reverse still has to be considered to decide how to calculate the turn weight
+                // todo: turn cost clean-up, should we move this inside calcMillis ?
+                if (reverse && edge.getBaseNode() == edge.getAdjNode() && !((CHEdgeIteratorState) edge).isShortcut()) {
+                    long millis = weighting.calcMillis(edge, false, NO_EDGE);
+                    if (EdgeIterator.Edge.isValid(prevOrNextEdgeId)) {
+                        millis += 1000 * (long) turnWeighting.calcTurnWeight(edge.getEdge(), edge.getBaseNode(), prevOrNextEdgeId);
+                    }
+                    time += millis;
+                } else {
+                    time += weighting.calcMillis(edge, reverse, prevOrNextEdgeId);
+                }
+                addEdge(edge.getEdge());
+            }
+        }, true);
+    }
+
+    @Override
+    protected int getIncEdge(SPTEntry entry) {
+        return ((CHEntry) entry).incEdge;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
index ce6135e1a8..cbefc3d8d1 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
@@ -172,6 +172,7 @@ private long findShortcuts(ShortcutHandler sch) {
                 continue;
 
             final double incomingEdgeWeight = prepareWeighting.calcWeight(incomingEdges, true, EdgeIterator.NO_EDGE);
+            // this check is important to prevent calling calcMillis on inaccessible edges and also allows early exit
             if (Double.isInfinite(incomingEdgeWeight)) {
                 continue;
             }
@@ -360,7 +361,7 @@ public String toString() {
             else
                 str = from + "->";
 
-            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + ")";
+            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + "), dist: " + dist;
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
index f47a6ea926..e77cadf5d0 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
@@ -20,81 +20,39 @@
 import com.graphhopper.routing.PathBidirRef;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.util.CHEdgeIteratorState;
-import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.storage.ShortcutUnpacker;
+import com.graphhopper.util.EdgeIteratorState;
 
-import java.util.Locale;
+import static com.graphhopper.util.EdgeIterator.NO_EDGE;
 
-/**
- * Recursively unpack shortcuts.
- * <p>
- *
- * @author Peter Karich
- * @see PrepareContractionHierarchies
- */
 public class Path4CH extends PathBidirRef {
-    private final Graph routingGraph;
+    private final ShortcutUnpacker shortcutUnpacker;
 
-    public Path4CH(Graph routingGraph, Graph baseGraph, Weighting weighting) {
+    public Path4CH(Graph routingGraph, Graph baseGraph, final Weighting weighting) {
         super(baseGraph, weighting);
-        this.routingGraph = routingGraph;
+        this.shortcutUnpacker = getShortcutUnpacker(routingGraph, weighting);
     }
 
     @Override
-    protected final void processEdge(int edgeId, int endNode, int prevEdgeId) {
+    protected final void processEdge(int edgeId, int adjNode, int prevEdgeId) {
         // Shortcuts do only contain valid weight so first expand before adding
         // to distance and time
-        expandEdge(getEdge(edgeId, endNode), false);
+        shortcutUnpacker.visitOriginalEdgesFwd(edgeId, adjNode, true, prevEdgeId);
     }
 
-    private void expandEdge(CHEdgeIteratorState edge, boolean reverse) {
-        if (!edge.isShortcut()) {
-            distance += edge.getDistance();
-            time += weighting.calcMillis(edge, reverse, EdgeIterator.NO_EDGE);
-            addEdge(edge.getEdge());
-            return;
-        }
-        expandSkippedEdges(edge.getSkippedEdge1(), edge.getSkippedEdge2(), edge.getBaseNode(), edge.getAdjNode(), reverse);
+    @Override
+    protected void processEdgeBwd(int edgeId, int adjNode, int nextEdgeId) {
+        shortcutUnpacker.visitOriginalEdgesBwd(edgeId, adjNode, true, nextEdgeId);
     }
 
-    private void expandSkippedEdges(int skippedEdge1, int skippedEdge2, int from, int to, boolean reverse) {
-        // for edge-based CH we need to take special care for loop shortcuts
-        if (from != to) {
-            // get properties like speed of the edge in the correct direction
-            if (reverseOrder == reverse) {
-                int tmp = from;
-                from = to;
-                to = tmp;
-            }
-            CHEdgeIteratorState sk2to = getEdge(skippedEdge2, to);
-            if (sk2to != null) {
-                expandEdge(sk2to, !reverseOrder);
-                expandEdge(getEdge(skippedEdge1, from), reverseOrder);
-            } else {
-                expandEdge(getEdge(skippedEdge1, to), !reverseOrder);
-                expandEdge(getEdge(skippedEdge2, from), reverseOrder);
-            }
-        } else {
-            CHEdgeIteratorState sk1 = getEdge(skippedEdge1, from);
-            CHEdgeIteratorState sk2 = getEdge(skippedEdge2, from);
-            if (sk1.getAdjNode() == sk1.getBaseNode() || sk2.getAdjNode() == sk2.getBaseNode()) {
-                // this is a loop where both skipped edges are loops. but this should never happen.
-                throw new IllegalStateException(String.format(Locale.ROOT,
-                        "error: detected edge where both skipped edges are loops. from: %d, to: %d, " +
-                                "skip-edge1: %d, skip-edge2: %d, reverse: %b", from, to, skippedEdge1, skippedEdge2, reverse));
+    protected ShortcutUnpacker getShortcutUnpacker(Graph routingGraph, final Weighting weighting) {
+        return new ShortcutUnpacker(routingGraph, new ShortcutUnpacker.Visitor() {
+            @Override
+            public void visit(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+                distance += edge.getDistance();
+                time += weighting.calcMillis(edge, reverse, NO_EDGE);
+                addEdge(edge.getEdge());
             }
-
-            if (!reverseOrder) {
-                expandEdge(sk1, !reverse);
-                expandEdge(sk2, reverse);
-            } else {
-                expandEdge(sk2, reverse);
-                expandEdge(sk1, !reverse);
-            }
-        }
-    }
-
-    private CHEdgeIteratorState getEdge(int edgeId, int adjNode) {
-        return (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(edgeId, adjNode);
+        }, false);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworks.java b/core/src/main/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworks.java
index 91659fb0f2..69b8f0eb75 100644
--- a/core/src/main/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworks.java
+++ b/core/src/main/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworks.java
@@ -79,7 +79,7 @@ public void doWork() {
         int unvisitedDeadEnds = 0;
         for (FlagEncoder encoder : encoders) {
             // mark edges for one vehicle as inaccessible
-            PrepEdgeFilter filter = new PrepEdgeFilter(encoder);
+            DefaultEdgeFilter filter = DefaultEdgeFilter.allEdges(encoder);
             if (minOneWayNetworkSize > 0)
                 unvisitedDeadEnds += removeDeadEndUnvisitedNetworks(filter);
 
@@ -104,7 +104,7 @@ public int getMaxSubnetworks() {
     /**
      * This method finds the double linked components according to the specified filter.
      */
-    List<IntArrayList> findSubnetworks(PrepEdgeFilter filter) {
+    List<IntArrayList> findSubnetworks(DefaultEdgeFilter filter) {
         final BooleanEncodedValue accessEnc = filter.getAccessEnc();
         final EdgeExplorer explorer = ghStorage.createEdgeExplorer(filter);
         int locs = ghStorage.getNodes();
@@ -152,7 +152,7 @@ protected final boolean checkAdjacent(EdgeIteratorState edge) {
     /**
      * Deletes all but the largest subnetworks.
      */
-    int keepLargeNetworks(PrepEdgeFilter filter, List<IntArrayList> components) {
+    int keepLargeNetworks(DefaultEdgeFilter filter, List<IntArrayList> components) {
         if (components.size() <= 1)
             return 0;
 
@@ -195,7 +195,7 @@ int keepLargeNetworks(PrepEdgeFilter filter, List<IntArrayList> components) {
      *
      * @return number of removed edges
      */
-    int removeDeadEndUnvisitedNetworks(final PrepEdgeFilter bothFilter) {
+    int removeDeadEndUnvisitedNetworks(final DefaultEdgeFilter bothFilter) {
         StopWatch sw = new StopWatch(bothFilter.getAccessEnc() + " findComponents").start();
         final EdgeFilter outFilter = DefaultEdgeFilter.outEdges(bothFilter.getAccessEnc());
 
@@ -213,7 +213,7 @@ int removeDeadEndUnvisitedNetworks(final PrepEdgeFilter bothFilter) {
      *
      * @return number of removed edges
      */
-    int removeEdges(final PrepEdgeFilter bothFilter, List<IntArrayList> components, int min) {
+    int removeEdges(final DefaultEdgeFilter bothFilter, List<IntArrayList> components, int min) {
         // remove edges determined from nodes but only if less than minimum size
         EdgeExplorer explorer = ghStorage.createEdgeExplorer(bothFilter);
         int removedEdges = 0;
@@ -270,15 +270,4 @@ boolean detectNodeRemovedForAllEncoders(EdgeExplorer edgeExplorerAllEdges, int n
 
         return true;
     }
-
-    static class PrepEdgeFilter extends DefaultEdgeFilter {
-
-        public PrepEdgeFilter(FlagEncoder encoder) {
-            super(encoder.getAccessEnc(), true, true);
-        }
-
-        public BooleanEncodedValue getAccessEnc() {
-            return accessEnc;
-        }
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index 06bc1df0b8..dfc9e5d594 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -167,6 +167,7 @@ protected BikeCommonFlagEncoder(int speedBits, double speedFactor, int maxTurnCo
         setHighwaySpeed("cycleway", CYCLEWAY_SPEED);
         setHighwaySpeed("path", 10);
         setHighwaySpeed("footway", 6);
+        setHighwaySpeed("platform", 6);
         setHighwaySpeed("pedestrian", 6);
         setHighwaySpeed("track", 12);
         setHighwaySpeed("service", 14);
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
index 4b6eee72a8..9e4ed568b1 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
@@ -49,6 +49,7 @@ public BikeFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         addPushingSection("footway");
         addPushingSection("pedestrian");
         addPushingSection("steps");
+        addPushingSection("platform");
 
         avoidHighwayTags.add("trunk");
         avoidHighwayTags.add("trunk_link");
diff --git a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
index cc499b0a1f..1ae1fb4020 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
@@ -24,26 +24,28 @@
  * @author Peter Karich
  */
 public class DefaultEdgeFilter implements EdgeFilter {
+    private static int DEFAULT_FILTER_ID = 0;
     private final boolean bwd;
     private final boolean fwd;
-    protected final BooleanEncodedValue accessEnc;
+    private final BooleanEncodedValue accessEnc;
+    /**
+     * Used to be able to create non-equal filter instances with equal access encoder and fwd/bwd flags.
+     */
+    private int filterId;
 
-    protected DefaultEdgeFilter(BooleanEncodedValue accessEnc, boolean fwd, boolean bwd) {
+    private DefaultEdgeFilter(BooleanEncodedValue accessEnc, boolean fwd, boolean bwd, int filterId) {
         this.accessEnc = accessEnc;
         this.fwd = fwd;
         this.bwd = bwd;
+        this.filterId = filterId;
     }
 
     public static DefaultEdgeFilter outEdges(BooleanEncodedValue accessEnc) {
-        return new DefaultEdgeFilter(accessEnc, true, false);
+        return new DefaultEdgeFilter(accessEnc, true, false, DEFAULT_FILTER_ID);
     }
 
-    public static DefaultEdgeFilter outEdges(FlagEncoder flagEncoder) {
-        return new DefaultEdgeFilter(flagEncoder.getAccessEnc(), true, false);
-    }
-
-    public static DefaultEdgeFilter inEdges(FlagEncoder flagEncoder) {
-        return new DefaultEdgeFilter(flagEncoder.getAccessEnc(), false, true);
+    public static DefaultEdgeFilter inEdges(BooleanEncodedValue accessEnc) {
+        return new DefaultEdgeFilter(accessEnc, false, true, DEFAULT_FILTER_ID);
     }
 
     /**
@@ -51,8 +53,29 @@ public static DefaultEdgeFilter inEdges(FlagEncoder flagEncoder) {
      * Edges where neither one of the flags is enabled will still not be accepted. If you need to retrieve all edges
      * regardless of their encoding use {@link EdgeFilter#ALL_EDGES} instead.
      */
+    public static DefaultEdgeFilter allEdges(BooleanEncodedValue accessEnc) {
+        return new DefaultEdgeFilter(accessEnc, true, true, DEFAULT_FILTER_ID);
+    }
+
+    public static DefaultEdgeFilter outEdges(FlagEncoder flagEncoder) {
+        return DefaultEdgeFilter.outEdges(flagEncoder.getAccessEnc());
+    }
+
+    public static DefaultEdgeFilter inEdges(FlagEncoder flagEncoder) {
+        return DefaultEdgeFilter.inEdges(flagEncoder.getAccessEnc());
+    }
+
     public static DefaultEdgeFilter allEdges(FlagEncoder flagEncoder) {
-        return new DefaultEdgeFilter(flagEncoder.getAccessEnc(), true, true);
+        return DefaultEdgeFilter.allEdges(flagEncoder.getAccessEnc());
+    }
+
+    public DefaultEdgeFilter setFilterId(int filterId) {
+        this.filterId = filterId;
+        return this;
+    }
+
+    public BooleanEncodedValue getAccessEnc() {
+        return accessEnc;
     }
 
     @Override
@@ -67,16 +90,30 @@ public final boolean accept(EdgeIteratorState iter) {
         return fwd && iter.get(accessEnc) || bwd && iter.getReverse(accessEnc);
     }
 
-    public boolean acceptsBackward() {
-        return bwd;
+    @Override
+    public String toString() {
+        return accessEnc.toString() + ", bwd:" + bwd + ", fwd:" + fwd;
     }
 
-    public boolean acceptsForward() {
-        return fwd;
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        DefaultEdgeFilter that = (DefaultEdgeFilter) o;
+
+        if (bwd != that.bwd) return false;
+        if (fwd != that.fwd) return false;
+        if (filterId != that.filterId) return false;
+        return accessEnc.equals(that.accessEnc);
     }
 
     @Override
-    public String toString() {
-        return accessEnc.toString() + ", bwd:" + bwd + ", fwd:" + fwd;
+    public int hashCode() {
+        int result = (bwd ? 1 : 0);
+        result = 31 * result + (fwd ? 1 : 0);
+        result = 31 * result + accessEnc.hashCode();
+        result = 31 * result + filterId;
+        return result;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index e41a0d0c61..ccdd702744 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -109,6 +109,7 @@ public FootFlagEncoder(int speedBits, double speedFactor) {
         safeHighwayTags.add("track");
         safeHighwayTags.add("residential");
         safeHighwayTags.add("service");
+        safeHighwayTags.add("platform");
 
         avoidHighwayTags.add("trunk");
         avoidHighwayTags.add("trunk_link");
diff --git a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
index f0e7965cb7..b6f18a451c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
@@ -110,6 +110,7 @@ public MountainBikeFlagEncoder(int speedBits, double speedFactor, int maxTurnCos
         setHighwaySpeed("tertiary_link", 18);
 
         addPushingSection("footway");
+        addPushingSection("platform");
         addPushingSection("pedestrian");
         addPushingSection("steps");
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
index c2461c75cd..b93e50fbda 100644
--- a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
@@ -113,6 +113,7 @@ public RacingBikeFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts
 
         addPushingSection("path");
         addPushingSection("footway");
+        addPushingSection("platform");
         addPushingSection("pedestrian");
         addPushingSection("steps");
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
index ca6aaceb40..eac3125542 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
@@ -37,37 +37,25 @@
     /**
      * The simplest traversal mode but without turn restrictions or cost support.
      */
-    NODE_BASED(false, 1, false),
-    /**
-     * Strictly not recommended as it could lead to 'route not found' for bidirectional algorithms.
-     * An edged-based traversal mode with basic turn restriction and cost support, including the
-     * most scenarios. But without certain turn restrictions and without u-turns. As fast as node
-     * based.
-     */
-    EDGE_BASED_1DIR(true, 1, false),
+    NODE_BASED(false, false),
     /**
      * The bidirectional edged-based traversal mode with turn restriction and cost support. Without
      * u-turn support. 2 times slower than node based.
      */
-    EDGE_BASED_2DIR(true, 2, false),
+    EDGE_BASED_2DIR(true, false),
     /**
      * Not recommended as it leads to strange routes that outsmart the turn costs. The most feature
-     * rich edged-based traversal mode with turn restriction and cost support, including u-turns. 4
+     * rich edge-based traversal mode with turn restriction and cost support, including u-turns. 4
      * times slower than node based.
      */
-    EDGE_BASED_2DIR_UTURN(true, 2, true);
+    EDGE_BASED_2DIR_UTURN(true, true);
 
     private final boolean edgeBased;
-    private final int noOfStates;
     private final boolean uTurnSupport;
 
-    TraversalMode(boolean edgeBased, int noOfStates, boolean uTurnSupport) {
+    TraversalMode(boolean edgeBased, boolean uTurnSupport) {
         this.edgeBased = edgeBased;
-        this.noOfStates = noOfStates;
         this.uTurnSupport = uTurnSupport;
-
-        if (noOfStates != 1 && noOfStates != 2)
-            throw new IllegalArgumentException("Currently only 1 or 2 states allowed");
     }
 
     public static TraversalMode fromString(String name) {
@@ -91,14 +79,7 @@ public static TraversalMode fromString(String name) {
      * @return the identifier to access the shortest path tree
      */
     public final int createTraversalId(EdgeIteratorState iterState, boolean reverse) {
-        if (edgeBased) {
-            if (noOfStates == 1)
-                return iterState.getEdge();
-
-            return GHUtility.createEdgeKey(iterState.getBaseNode(), iterState.getAdjNode(), iterState.getEdge(), reverse);
-        }
-
-        return iterState.getAdjNode();
+        return createTraversalId(iterState.getBaseNode(), iterState.getAdjNode(), iterState.getEdge(), reverse);
     }
 
     /**
@@ -106,25 +87,17 @@ public final int createTraversalId(EdgeIteratorState iterState, boolean reverse)
      */
     public final int createTraversalId(int baseNode, int adjNode, int edgeId, boolean reverse) {
         if (edgeBased) {
-            if (noOfStates == 1)
-                return edgeId;
-
             return GHUtility.createEdgeKey(baseNode, adjNode, edgeId, reverse);
         }
-
         return adjNode;
     }
 
     public int reverseEdgeKey(int edgeKey) {
-        if (edgeBased && noOfStates > 1)
+        if (edgeBased)
             return GHUtility.reverseEdgeKey(edgeKey);
         return edgeKey;
     }
 
-    public int getNoOfStates() {
-        return noOfStates;
-    }
-
     public boolean isEdgeBased() {
         return edgeBased;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
index 7bcdda0fd4..92366a7798 100644
--- a/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
@@ -49,8 +49,8 @@ public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrN
         if (reverse && !edgeState.getReverse(accessEnc) || !reverse && !edgeState.get(accessEnc))
             throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. " +
                     "(" + edgeState.getBaseNode() + " - " + edgeState.getAdjNode() + ") "
-                            + edgeState.fetchWayGeometry(3) + " " + edgeState.getDistance() + " "
-                            + "Reverse:" + reverse + ", fwd:" + edgeState.get(accessEnc) + ", bwd:" + edgeState.getReverse(accessEnc));
+                    + edgeState.fetchWayGeometry(3) + ", dist: " + edgeState.getDistance() + " "
+                    + "Reverse:" + reverse + ", fwd:" + edgeState.get(accessEnc) + ", bwd:" + edgeState.getReverse(accessEnc) + ", fwd-speed: " + edgeState.get(avSpeedEnc) + ", bwd-speed: " + edgeState.getReverse(avSpeedEnc));
 
         double speed = reverse ? edgeState.getReverse(avSpeedEnc) : edgeState.get(avSpeedEnc);
         if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java
index dec1157968..5b253c37f9 100644
--- a/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java
@@ -44,7 +44,7 @@
      * @param turnCostExt the turn cost storage to be used
      */
     public TurnWeighting(Weighting superWeighting, TurnCostExtension turnCostExt) {
-        this.turnCostEncoder = (TurnCostEncoder) superWeighting.getFlagEncoder();
+        this.turnCostEncoder = superWeighting.getFlagEncoder();
         this.superWeighting = superWeighting;
         this.turnCostExt = turnCostExt;
 
@@ -57,7 +57,7 @@ public TurnWeighting(Weighting superWeighting, TurnCostExtension turnCostExt) {
      * 'tricking' other turn costs or restrictions.
      */
     public TurnWeighting setDefaultUTurnCost(double costInSeconds) {
-        this.defaultUTurnCost = costInSeconds;
+        defaultUTurnCost = costInSeconds;
         return this;
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/BaseGraph.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
index f2a938d17a..7afcea9a1d 100644
--- a/core/src/main/java/com/graphhopper/storage/BaseGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -800,6 +800,12 @@ public int getOtherNode(int edge, int node) {
         return edgeAccess.getOtherNode(node, edgePointer);
     }
 
+    @Override
+    public boolean isAdjacentToNode(int edge, int node) {
+        long edgePointer = edgeAccess.toPointer(edge);
+        return edgeAccess.isAdjacentToNode(node, edgePointer);
+    }
+
     public void setAdditionalEdgeField(long edgePointer, int value) {
         if (extStorage.isRequireEdgeField() && E_ADDITIONAL >= 0)
             edges.setInt(edgePointer + E_ADDITIONAL, value);
diff --git a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
index c142383c45..578a93404d 100644
--- a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
+++ b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
@@ -60,7 +60,6 @@
     int shortcutEntryBytes;
     // the nodesCH storage is limited via baseGraph.nodeCount too
     int nodeCHEntryBytes;
-    final int shortcutBytesForFlags = 4;
     private int N_LEVEL;
     // shortcut memory layout is synced with edges indices until E_FLAGS, then:
     private int S_SKIP_EDGE1, S_SKIP_EDGE2, S_ORIG_FIRST, S_ORIG_LAST;
@@ -241,6 +240,13 @@ public int getOtherNode(int edge, int node) {
         return edgeAccess.getOtherNode(node, edgePointer);
     }
 
+    @Override
+    public boolean isAdjacentToNode(int edge, int node) {
+        EdgeAccess edgeAccess = isShortcut(edge) ? chEdgeAccess : baseGraph.edgeAccess;
+        long edgePointer = edgeAccess.toPointer(edge);
+        return edgeAccess.isAdjacentToNode(node, edgePointer);
+    }
+
     void _prepareForContraction() {
         if (isReadyForContraction) {
             return;
diff --git a/core/src/main/java/com/graphhopper/storage/EdgeAccess.java b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
index 54f4e429c7..2231f73c41 100644
--- a/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
@@ -148,6 +148,10 @@ final int getOtherNode(int nodeThis, long edgePointer) {
         return nodeThis == nodeA ? getNodeB(edgePointer) : nodeA;
     }
 
+    final boolean isAdjacentToNode(int node, long edgePointer) {
+        return getNodeA(edgePointer) == node || getNodeB(edgePointer) == node;
+    }
+
     /**
      * Writes plain edge information to the edges index
      */
diff --git a/core/src/main/java/com/graphhopper/storage/Graph.java b/core/src/main/java/com/graphhopper/storage/Graph.java
index 1713447e21..51f9c4d559 100644
--- a/core/src/main/java/com/graphhopper/storage/Graph.java
+++ b/core/src/main/java/com/graphhopper/storage/Graph.java
@@ -87,6 +87,11 @@
      */
     int getOtherNode(int edge, int node);
 
+    /**
+     * @return true if the edge with id edge is adjacent to node, false otherwise
+     */
+    boolean isAdjacentToNode(int edge, int node);
+
     /**
      * @return all edges in this graph, where baseNode will be the smaller node.
      */
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index 2d7a4509a2..3c00cd8401 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -86,12 +86,12 @@ public void freeze() {
             }
         };
 
-        this.baseGraph = new BaseGraph(dir, encodingManager, withElevation, listener, extendedStorage);
+        baseGraph = new BaseGraph(dir, encodingManager, withElevation, listener, extendedStorage);
         for (Weighting w : nodeBasedCHWeightings) {
-            nodeBasedCHGraphs.add(new CHGraphImpl(w, dir, this.baseGraph, false));
+            nodeBasedCHGraphs.add(new CHGraphImpl(w, dir, baseGraph, false));
         }
         for (Weighting w : edgeBasedCHWeightings) {
-            edgeBasedCHGraphs.add(new CHGraphImpl(w, dir, this.baseGraph, true));
+            edgeBasedCHGraphs.add(new CHGraphImpl(w, dir, baseGraph, true));
         }
     }
 
@@ -467,6 +467,11 @@ public int getOtherNode(int edge, int node) {
         return baseGraph.getOtherNode(edge, node);
     }
 
+    @Override
+    public boolean isAdjacentToNode(int edge, int node) {
+        return baseGraph.isAdjacentToNode(edge, node);
+    }
+
     private Collection<CHGraphImpl> getAllCHGraphs() {
         // todo: this method is only used to have a 'view' on the two collections. we could also create this only once
         // as long as the graph collections are only modified in the constructor (otherwise we would have to make sure
diff --git a/core/src/main/java/com/graphhopper/storage/ShortcutUnpacker.java b/core/src/main/java/com/graphhopper/storage/ShortcutUnpacker.java
new file mode 100644
index 0000000000..5effacd346
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/ShortcutUnpacker.java
@@ -0,0 +1,125 @@
+package com.graphhopper.storage;
+
+import com.graphhopper.routing.ch.PrepareContractionHierarchies;
+import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeIteratorState;
+
+import java.util.Locale;
+
+import static com.graphhopper.util.EdgeIterator.NO_EDGE;
+
+/**
+ * Recursively unpack shortcuts.
+ * <p>
+ *
+ * @author Peter Karich
+ * @author easbar
+ * @see PrepareContractionHierarchies
+ */
+public class ShortcutUnpacker {
+    private final Graph graph;
+    private final Visitor visitor;
+    private final boolean edgeBased;
+    private boolean reverseOrder;
+
+    public ShortcutUnpacker(Graph graph, Visitor visitor, boolean edgeBased) {
+        this.graph = graph;
+        this.visitor = visitor;
+        this.edgeBased = edgeBased;
+    }
+
+    /**
+     * Finds an edge/shortcut with the given id and adjNode and calls the visitor for each original edge that is
+     * packed inside this shortcut (or if an original edge is given simply calls the visitor on it).
+     *
+     * @param reverseOrder if true the original edges will be traversed in reverse order
+     */
+    public void visitOriginalEdgesFwd(int edgeId, int adjNode, boolean reverseOrder, int prevOrNextEdgeId) {
+        doVisitOriginalEdges(edgeId, adjNode, reverseOrder, false, prevOrNextEdgeId);
+    }
+
+    public void visitOriginalEdgesBwd(int edgeId, int adjNode, boolean reverseOrder, int prevOrNextEdgeId) {
+        doVisitOriginalEdges(edgeId, adjNode, reverseOrder, true, prevOrNextEdgeId);
+    }
+
+    private void doVisitOriginalEdges(int edgeId, int adjNode, boolean reverseOrder, boolean reverse, int prevOrNextEdgeId) {
+        this.reverseOrder = reverseOrder;
+        CHEdgeIteratorState edge = getEdge(edgeId, adjNode);
+        if (edge == null) {
+            throw new IllegalArgumentException("Edge with id: " + edgeId + " does not exist or does not touch node " + adjNode);
+        }
+        expandEdge(edge, reverse, prevOrNextEdgeId);
+    }
+
+    private void expandEdge(CHEdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+        if (!edge.isShortcut()) {
+            visitor.visit(edge, reverse, prevOrNextEdgeId);
+            return;
+        }
+        if (edgeBased) {
+            expandSkippedEdgesEdgeBased(edge.getSkippedEdge1(), edge.getSkippedEdge2(), edge.getBaseNode(), edge.getAdjNode(), reverse, prevOrNextEdgeId);
+        } else {
+            expandSkippedEdgesNodeBased(edge.getSkippedEdge1(), edge.getSkippedEdge2(), edge.getBaseNode(), edge.getAdjNode(), reverse);
+        }
+    }
+
+    private void expandSkippedEdgesEdgeBased(int skippedEdge1, int skippedEdge2, int base, int adj, boolean reverse, int prevOrNextEdgeId) {
+        if (reverse) {
+            int tmp = skippedEdge1;
+            skippedEdge1 = skippedEdge2;
+            skippedEdge2 = tmp;
+        }
+        CHEdgeIteratorState sk2 = getEdge(skippedEdge2, adj);
+        assert sk2 != null : "skipped edge " + skippedEdge2 + " + is not attached to adjNode " + adj + ". this should " +
+                "never happen because edge-based CH does not use bidirectional shortcuts at the moment";
+        CHEdgeIteratorState sk1 = getEdge(skippedEdge1, sk2.getBaseNode());
+        if (base == adj && (sk1.getAdjNode() == sk1.getBaseNode() || sk2.getAdjNode() == sk2.getBaseNode())) {
+            throw new IllegalStateException(String.format(Locale.ROOT,
+                    "error: detected edge where a skipped edges is a loop. this should never happen. base: %d, adj: %d, " +
+                            "skip-edge1: %d, skip-edge2: %d, reverse: %b", base, adj, skippedEdge1, skippedEdge2, reverse));
+        }
+        int adjEdge = getOppositeEdge(sk1, base);
+        if (reverseOrder) {
+            expandEdge(sk2, reverse, adjEdge);
+            expandEdge(sk1, reverse, prevOrNextEdgeId);
+        } else {
+            expandEdge(sk1, reverse, prevOrNextEdgeId);
+            expandEdge(sk2, reverse, adjEdge);
+        }
+    }
+
+    private void expandSkippedEdgesNodeBased(int skippedEdge1, int skippedEdge2, int base, int adj, boolean reverse) {
+        CHEdgeIteratorState sk2 = getEdge(skippedEdge2, adj);
+        CHEdgeIteratorState sk1;
+        if (sk2 == null) {
+            sk2 = getEdge(skippedEdge1, adj);
+            sk1 = getEdge(skippedEdge2, sk2.getBaseNode());
+        } else {
+            sk1 = getEdge(skippedEdge1, sk2.getBaseNode());
+        }
+        if (reverseOrder) {
+            expandEdge(sk2, reverse, NO_EDGE);
+            expandEdge(sk1, reverse, NO_EDGE);
+        } else {
+            expandEdge(sk1, reverse, NO_EDGE);
+            expandEdge(sk2, reverse, NO_EDGE);
+        }
+    }
+
+    private int getOppositeEdge(CHEdgeIteratorState edgeState, int adjNode) {
+        assert edgeState.getBaseNode() == adjNode || edgeState.getAdjNode() == adjNode : "adjNode " + adjNode + " must be one of adj/base of edgeState: " + edgeState;
+        // since the first/last orig edge is not stateful (just like skipped1/2) we have to find out which one
+        // is attached to adjNode, similar as we do for skipped1/2.
+        return graph.isAdjacentToNode(edgeState.getOrigEdgeLast(), adjNode)
+                ? edgeState.getOrigEdgeFirst()
+                : edgeState.getOrigEdgeLast();
+    }
+
+    private CHEdgeIteratorState getEdge(int edgeId, int adjNode) {
+        return (CHEdgeIteratorState) graph.getEdgeIteratorState(edgeId, adjNode);
+    }
+
+    public interface Visitor {
+        void visit(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
index c7ad184aec..e1d43c193d 100644
--- a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
+++ b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
@@ -197,6 +197,10 @@ public long getTurnCostFlags(int edgeFrom, int nodeVia, int edgeTo) {
         return nextCostFlags(edgeFrom, nodeVia, edgeTo);
     }
 
+    public boolean isUTurn(int edgeFrom, int edgeTo) {
+        return edgeFrom == edgeTo;
+    }
+
     private long nextCostFlags(int edgeFrom, int nodeVia, int edgeTo) {
         int turnCostIndex = nodeAccess.getAdditionalNodeField(nodeVia);
         int i = 0;
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
index 005c2538a8..b44e2baea9 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
@@ -23,11 +23,11 @@
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.Circle;
 
 /**
  * Very slow O(n) LocationIndex but no RAM/disc required.
- * <p>
  *
  * @author Peter Karich
  */
@@ -102,6 +102,11 @@ public QueryResult findClosest(double queryLat, double queryLon, EdgeFilter edge
         return res;
     }
 
+    @Override
+    public void query(BBox queryBBox, Visitor function) {
+        throw new IllegalArgumentException("not implemented");
+    }
+
     @Override
     public LocationIndex create(long size) {
         return this;
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
index 653f666a5c..6d822a44c3 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
@@ -23,6 +23,7 @@
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.BBox;
 
 /**
  * Same as full index but calculates distance to all edges too
@@ -125,6 +126,11 @@ public QueryResult findClosest(double queryLat, double queryLon, EdgeFilter filt
         return res;
     }
 
+    @Override
+    public void query(BBox queryBBox, Visitor function) {
+        throw new IllegalArgumentException("not implemented");
+    }
+
     @Override
     public LocationIndex create(long size) {
         return this;
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
index 2ae3f58ca0..59445254ac 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
@@ -337,6 +337,11 @@ protected boolean goFurther(int baseNode) {
         return res;
     }
 
+    @Override
+    public void query(BBox queryBBox, Visitor function) {
+        throw new IllegalArgumentException("not implemented");
+    }
+
     public void goFurtherHook(int n) {
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
index a95d49f0d7..0717446450 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
@@ -17,8 +17,13 @@
  */
 package com.graphhopper.storage.index;
 
+import com.carrotsearch.hppc.IntHashSet;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.Storable;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.shapes.BBox;
 
 /**
  * Provides a way to map real world data "lat,lon" to internal ids/indices of a memory efficient graph
@@ -62,4 +67,56 @@
     LocationIndex setApproximation(boolean approxDist);
 
     void setSegmentSize(int bytes);
+
+    /**
+     * This method explores the nodes in this LocationIndex with the specified Visitor. It guarantees to visit all
+     * unique nodes included in the queryBBox but it could visit more.
+     */
+    void query(BBox queryBBox, Visitor function);
+
+    /**
+     * This interface allows to visit every node stored in the leafs of a LocationIndex.
+     */
+    abstract class Visitor {
+        public boolean isTileInfo() {
+            return false;
+        }
+
+        /**
+         * This method is called if isTileInfo is enabled.
+         */
+        public void onTile(BBox bbox, int depth) {
+        }
+
+        public abstract void onNode(int nodeId);
+    }
+
+    /**
+     * This abstract class allows to visit every edge from the stored nodes in the leafs of the tree for a requested
+     * area. It guarantees to visit all unique edges included in the queryBBox but it could be more.
+     */
+    abstract class EdgeVisitor extends Visitor {
+
+        private final IntHashSet edgeIds = new IntHashSet();
+        private final IntHashSet nodeIds = new IntHashSet();
+        private final EdgeExplorer edgeExplorer;
+
+        public EdgeVisitor(EdgeExplorer edgeExplorer) {
+            this.edgeExplorer = edgeExplorer;
+        }
+
+        public final void onNode(int nodeId) {
+            if (!nodeIds.add(nodeId))
+                return;
+
+            EdgeIterator iter = edgeExplorer.setBaseNode(nodeId);
+            while (iter.next()) {
+                if (!edgeIds.add(iter.getEdge()))
+                    continue;
+                onEdge(iter, nodeId, iter.getAdjNode());
+            }
+        }
+
+        public abstract void onEdge(EdgeIteratorState edge, int nodeA, int nodeB);
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index 7d4d374b48..1eb58fcc2d 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -18,6 +18,7 @@
 package com.graphhopper.storage.index;
 
 import com.carrotsearch.hppc.IntArrayList;
+import com.carrotsearch.hppc.IntHashSet;
 import com.carrotsearch.hppc.cursors.IntCursor;
 import com.carrotsearch.hppc.predicates.IntPredicate;
 import com.graphhopper.coll.GHBitSet;
@@ -29,18 +30,30 @@
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.Shape;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.util.*;
 
 /**
- * This implementation implements an n-tree to get the closest node or edge from GPS coordinates.
- * <p>
- * All leafs are at the same depth, otherwise it is quite complicated to calculate the Bresenham
- * line for different resolutions, especially if a leaf node could be split into a tree-node and
- * resolution changes.
- * <p>
+ * This class implements a Quadtree to get the closest node or edge from GPS coordinates.
+ * The following properties are different to an ordinary implementation:
+ * <ol>
+ * <li>To reduce overall size it can use 16 instead of just 4 cell if required</li>
+ * <li>Still all leafs are at the same depth, otherwise it is too complicated to calculate the Bresenham line for different
+ * resolutions, especially if a leaf node could be split into a tree-node and resolution changes.</li>
+ * <li>To further reduce size this Quadtree avoids storing the bounding box of every cell and calculates this per request instead.</li>
+ * <li>To simplify this querying and avoid a slow down for the most frequent queries ala "lat,lon" it encodes the point
+ * into a reverse spatial key {@see SpatialKeyAlgo} and can the use the resulting raw bits as cell index to recurse
+ * into the subtrees. E.g. if there are 3 layers with 16, 4 and 4 cells each, then the reverse spatial key has
+ * three parts: 4 bits for the cellIndex into the 16 cells, 2 bits for the next layer and 2 bits for the last layer.
+ * It is the reverse spatial key and not the forward spatial key as we need the start of the index for the current
+ * layer at index 0</li>
+ * <li>An array structure (DataAccess) is internally used and stores the offset to the next cell.
+ * E.g. in case of 4 cells, the offset is 0,1,2 or 3. Except when the leaf-depth is reached, then the value
+ * is the number of node IDs stored in the cell or, if negative, just a single node ID.</li>
+ * </ol>
  *
  * @author Peter Karich
  */
@@ -84,7 +97,7 @@ public LocationIndexTree(Graph g, Directory dir) {
         if (g instanceof CHGraph)
             throw new IllegalArgumentException("Use base graph for LocationIndexTree instead of CHGraph");
 
-        MAGIC_INT = Integer.MAX_VALUE / 22316;
+        MAGIC_INT = Integer.MAX_VALUE / 22317;
         this.graph = g;
         this.nodeAccess = g.getNodeAccess();
         dataAccess = dir.find("location_index", DAType.getPreferredInt(dir.getDefaultType()));
@@ -145,9 +158,7 @@ void prepareAlgo() {
         tmp /= 4;
         while (tmp > 1) {
             int tmpNo;
-            if (tmp >= 64) {
-                tmpNo = 64;
-            } else if (tmp >= 16) {
+            if (tmp >= 16) {
                 tmpNo = 16;
             } else if (tmp >= 4) {
                 tmpNo = 4;
@@ -335,17 +346,19 @@ IntArrayList getEntries() {
         return IntArrayList.from(entries);
     }
 
-    // fill node IDs according to how they are stored
+    /**
+     * This method fills the set with stored node IDs from the given spatial key part (a latitude-longitude prefix).
+     */
     final void fillIDs(long keyPart, int intIndex, GHIntHashSet set, int depth) {
         long pointer = (long) intIndex << 2;
         if (depth == entries.length) {
-            int value = dataAccess.getInt(pointer);
-            if (value < 0) {
+            int nextIntPointer = dataAccess.getInt(pointer);
+            if (nextIntPointer < 0) {
                 // single data entries (less disc space)
-                set.add(-(value + 1));
+                set.add(-(nextIntPointer + 1));
             } else {
-                long max = (long) value * 4;
-                // leaf entry => value is maxPointer
+                long max = (long) nextIntPointer * 4;
+                // leaf entry => nextIntPointer is maxPointer
                 for (long leafIndex = pointer + 4; leafIndex < max; leafIndex += 4) {
                     set.add(dataAccess.getInt(leafIndex));
                 }
@@ -353,10 +366,10 @@ final void fillIDs(long keyPart, int intIndex, GHIntHashSet set, int depth) {
             return;
         }
         int offset = (int) (bitmasks[depth] & keyPart) << 2;
-        int value = dataAccess.getInt(pointer + offset);
-        if (value > 0) {
+        int nextIntPointer = dataAccess.getInt(pointer + offset);
+        if (nextIntPointer > 0) {
             // tree entry => negative value points to subentries
-            fillIDs(keyPart >>> shifts[depth], value, set, depth + 1);
+            fillIDs(keyPart >>> shifts[depth], nextIntPointer, set, depth + 1);
         }
     }
 
@@ -429,12 +442,76 @@ public double getDeltaLon() {
         return deltaLon;
     }
 
-    GHPoint getCenter(double lat, double lon) {
-        GHPoint query = new GHPoint(lat, lon);
-        long key = keyAlgo.encode(query);
-        GHPoint center = new GHPoint();
-        keyAlgo.decode(key, center);
-        return center;
+    public void query(BBox queryShape, final Visitor function) {
+        BBox bbox = graph.getBounds();
+        final IntHashSet set = new IntHashSet();
+        query(START_POINTER, queryShape,
+                bbox.minLat, bbox.minLon, bbox.maxLat - bbox.minLat, bbox.maxLon - bbox.minLon,
+                new Visitor() {
+                    @Override
+                    public boolean isTileInfo() {
+                        return function.isTileInfo();
+                    }
+
+                    @Override
+                    public void onTile(BBox bbox, int width) {
+                        function.onTile(bbox, width);
+                    }
+
+                    @Override
+                    public void onNode(int nodeId) {
+                        if (set.add(nodeId))
+                            function.onNode(nodeId);
+                    }
+                }, 0);
+    }
+
+    final void query(int intPointer, Shape queryBBox,
+                     double minLat, double minLon,
+                     double deltaLatPerDepth, double deltaLonPerDepth,
+                     Visitor function, int depth) {
+        long pointer = (long) intPointer << 2;
+        if (depth == entries.length) {
+            int nextIntPointer = dataAccess.getInt(pointer);
+            if (nextIntPointer < 0) {
+                // single data entries (less disc space)
+                function.onNode(-(nextIntPointer + 1));
+            } else {
+                long maxPointer = (long) nextIntPointer * 4;
+                // loop through every leaf entry => nextIntPointer is maxPointer
+                for (long leafPointer = pointer + 4; leafPointer < maxPointer; leafPointer += 4) {
+                    // we could read the whole info at once via getBytes instead of getInt
+                    function.onNode(dataAccess.getInt(leafPointer));
+                }
+            }
+            return;
+        }
+        int max = (1 << shifts[depth]);
+        int factor = max == 4 ? 2 : 4;
+        deltaLonPerDepth /= factor;
+        deltaLatPerDepth /= factor;
+        for (int cellIndex = 0; cellIndex < max; cellIndex++) {
+            int nextIntPointer = dataAccess.getInt(pointer + cellIndex * 4);
+            if (nextIntPointer <= 0)
+                continue;
+            // this bit magic does two things for the 4 and 16 tiles case:
+            // 1. it assumes the cellIndex is a reversed spatial key and so it reverses it
+            // 2. it picks every second bit (e.g. for just latitudes) and interprets the result as an integer
+            int latCount = max == 4 ? (cellIndex & 1) : (cellIndex & 1) * 2 + ((cellIndex & 4) == 0 ? 0 : 1);
+            int lonCount = max == 4 ? (cellIndex >> 1) : (cellIndex & 2) + ((cellIndex & 8) == 0 ? 0 : 1);
+            double tmpMinLon = minLon + deltaLonPerDepth * lonCount,
+                    tmpMinLat = minLat + deltaLatPerDepth * latCount;
+
+            BBox bbox = (queryBBox != null || function.isTileInfo()) ? new BBox(tmpMinLon, tmpMinLon + deltaLonPerDepth, tmpMinLat, tmpMinLat + deltaLatPerDepth) : null;
+            if (function.isTileInfo())
+                function.onTile(bbox, depth);
+            if (queryBBox == null || queryBBox.contains(bbox)) {
+                // fill without a restriction!
+                query(nextIntPointer, null, tmpMinLat, tmpMinLon, deltaLatPerDepth, deltaLonPerDepth, function, depth + 1);
+            } else if (queryBBox.intersects(bbox)) {
+                query(nextIntPointer, queryBBox, tmpMinLat, tmpMinLon, deltaLatPerDepth, deltaLonPerDepth, function, depth + 1);
+            }
+        }
     }
 
     /**
@@ -446,8 +523,8 @@ GHPoint getCenter(double lat, double lon) {
      * @return true if no further call of this method is required. False otherwise, ie. a next
      * iteration is necessary and no early finish possible.
      */
-    public final boolean findNetworkEntries(double queryLat, double queryLon,
-                                            GHIntHashSet foundEntries, int iteration) {
+    final boolean findNetworkEntries(double queryLat, double queryLon,
+                                     GHIntHashSet foundEntries, int iteration) {
         // find entries in border of searchbox
         for (int yreg = -iteration; yreg <= iteration; yreg++) {
             double subqueryLat = queryLat + yreg * deltaLat;
@@ -502,7 +579,7 @@ final double calcMinDistance(double queryLat, double queryLon, GHIntHashSet poin
         return min;
     }
 
-    public final void findNetworkEntriesSingleRegion(GHIntHashSet storedNetworkEntryIds, double queryLat, double queryLon) {
+    final void findNetworkEntriesSingleRegion(GHIntHashSet storedNetworkEntryIds, double queryLat, double queryLon) {
         long keyPart = createReverseKey(queryLat, queryLon);
         fillIDs(keyPart, START_POINTER, storedNetworkEntryIds, 0);
     }
@@ -711,9 +788,6 @@ IntArrayList getResults() {
 
     // Space efficient sorted integer set. Suited for only a few entries.
     static class SortedIntSet extends IntArrayList {
-        public SortedIntSet() {
-        }
-
         public SortedIntSet(int capacity) {
             super(capacity);
         }
@@ -851,7 +925,7 @@ void addNode(InMemEntry entry, int nodeId, int depth, long keyPart, long key) {
 
         Collection<InMemEntry> getEntriesOf(int selectDepth) {
             List<InMemEntry> list = new ArrayList<>();
-            fillLayer(list, selectDepth, 0, ((InMemTreeEntry) root).getSubEntriesForDebug());
+            fillLayer(list, selectDepth, 0, root.getSubEntriesForDebug());
             return list;
         }
 
@@ -895,48 +969,48 @@ void print(InMemEntry e, StringBuilder sb, long key, int depth) {
         }
 
         // store and freezes tree
-        int store(InMemEntry entry, int intIndex) {
-            long refPointer = (long) intIndex * 4;
+        int store(InMemEntry entry, int intPointer) {
+            long pointer = (long) intPointer * 4;
             if (entry.isLeaf()) {
                 InMemLeafEntry leaf = ((InMemLeafEntry) entry);
                 IntArrayList entries = leaf.getResults();
                 int len = entries.size();
                 if (len == 0) {
-                    return intIndex;
+                    return intPointer;
                 }
                 size += len;
-                intIndex++;
+                intPointer++;
                 leafs++;
-                dataAccess.ensureCapacity((long) (intIndex + len + 1) * 4);
+                dataAccess.ensureCapacity((long) (intPointer + len + 1) * 4);
                 if (len == 1) {
                     // less disc space for single entries
-                    dataAccess.setInt(refPointer, -entries.get(0) - 1);
+                    dataAccess.setInt(pointer, -entries.get(0) - 1);
                 } else {
-                    for (int index = 0; index < len; index++, intIndex++) {
-                        dataAccess.setInt((long) intIndex * 4, entries.get(index));
+                    for (int index = 0; index < len; index++, intPointer++) {
+                        dataAccess.setInt((long) intPointer * 4, entries.get(index));
                     }
-                    dataAccess.setInt(refPointer, intIndex);
+                    dataAccess.setInt(pointer, intPointer);
                 }
             } else {
                 InMemTreeEntry treeEntry = ((InMemTreeEntry) entry);
                 int len = treeEntry.subEntries.length;
-                intIndex += len;
-                for (int subCounter = 0; subCounter < len; subCounter++, refPointer += 4) {
+                intPointer += len;
+                for (int subCounter = 0; subCounter < len; subCounter++, pointer += 4) {
                     InMemEntry subEntry = treeEntry.subEntries[subCounter];
                     if (subEntry == null) {
                         continue;
                     }
-                    dataAccess.ensureCapacity((long) (intIndex + 1) * 4);
-                    int beforeIntIndex = intIndex;
-                    intIndex = store(subEntry, beforeIntIndex);
-                    if (intIndex == beforeIntIndex) {
-                        dataAccess.setInt(refPointer, 0);
+                    dataAccess.ensureCapacity((long) (intPointer + 1) * 4);
+                    int prevIntPointer = intPointer;
+                    intPointer = store(subEntry, prevIntPointer);
+                    if (intPointer == prevIntPointer) {
+                        dataAccess.setInt(pointer, 0);
                     } else {
-                        dataAccess.setInt(refPointer, beforeIntIndex);
+                        dataAccess.setInt(pointer, prevIntPointer);
                     }
                 }
             }
-            return intIndex;
+            return intPointer;
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/GHUtility.java b/core/src/main/java/com/graphhopper/util/GHUtility.java
index 18ad578b8f..dd054f33f6 100644
--- a/core/src/main/java/com/graphhopper/util/GHUtility.java
+++ b/core/src/main/java/com/graphhopper/util/GHUtility.java
@@ -136,6 +136,7 @@ public static void printGraphForUnitTest(Graph g, FlagEncoder encoder) {
     }
 
     public static void printGraphForUnitTest(Graph g, FlagEncoder encoder, BBox bBox) {
+        System.out.println("WARNING: printGraphForUnitTest does not pay attention to custom edge speeds at the moment");
         NodeAccess na = g.getNodeAccess();
         for (int node = 0; node < g.getNodes(); ++node) {
             if (bBox.contains(na.getLat(node), na.getLon(node))) {
@@ -164,11 +165,12 @@ private static void printUnitTestEdge(FlagEncoder encoder, EdgeIteratorState edg
                 "graph.edge(%d, %d, %f, %s);\n", from, to, edge.getDistance(), fwd && bwd ? "true" : "false");
     }
 
-    public static void buildRandomGraph(Graph graph, long seed, int numNodes, double meanDegree, boolean allowLoops, boolean allowZeroDistance, double pBothDir, double pRandomOffset) {
+    public static void buildRandomGraph(Graph graph, Random random, int numNodes, double meanDegree, boolean allowLoops,
+                                        boolean allowZeroDistance, DecimalEncodedValue randomSpeedEnc,
+                                        double pNonZeroLoop, double pBothDir, double pRandomOffset) {
         if (numNodes < 2 || meanDegree < 1) {
             throw new IllegalArgumentException("numNodes must be >= 2, meanDegree >= 1");
         }
-        Random random = new Random(seed);
         for (int i = 0; i < numNodes; ++i) {
             double lat = 49.4 + (random.nextDouble() * 0.01);
             double lon = 9.7 + (random.nextDouble() * 0.01);
@@ -186,7 +188,7 @@ public static void buildRandomGraph(Graph graph, long seed, int numNodes, double
             }
             double distance = GHUtility.getDistance(from, to, graph.getNodeAccess());
             // allow loops with non-zero distance
-            if (from == to && random.nextDouble() < 0.7) {
+            if (from == to && random.nextDouble() < pNonZeroLoop) {
                 distance = random.nextDouble() * 1000;
             }
             if (!allowZeroDistance) {
@@ -199,7 +201,13 @@ public static void buildRandomGraph(Graph graph, long seed, int numNodes, double
             maxDist = Math.max(maxDist, distance);
             // using bidirectional edges will increase mean degree of graph above given value
             boolean bothDirections = random.nextDouble() < pBothDir;
-            graph.edge(from, to, distance, bothDirections);
+            EdgeIteratorState edge = graph.edge(from, to, distance, bothDirections);
+            double fwdSpeed = 10 + random.nextDouble() * 120;
+            double bwdSpeed = 10 + random.nextDouble() * 120;
+            if (randomSpeedEnc != null) {
+                edge.set(randomSpeedEnc, fwdSpeed);
+                edge.setReverse(randomSpeedEnc, bwdSpeed);
+            }
             numEdges++;
         }
         LOGGER.debug(String.format(Locale.ROOT, "Finished building random graph" +
@@ -238,8 +246,7 @@ public static void addRandomTurnCosts(Graph graph, long seed, FlagEncoder encode
                                 restricted = true;
                             }
                             double cost = restricted ? 0 : random.nextDouble() * maxTurnCost;
-                            turnCostExtension.addTurnInfo(inIter.getEdge(), node, outIter.getEdge(),
-                                    encoder.getTurnFlags(restricted, cost));
+                            turnCostExtension.addTurnInfo(inIter.getEdge(), node, outIter.getEdge(), encoder.getTurnFlags(restricted, cost));
                         }
                     }
                 }
@@ -458,7 +465,7 @@ public static EdgeIteratorState getEdge(Graph graph, int base, int adj) {
     public static int createEdgeKey(int nodeA, int nodeB, int edgeId, boolean reverse) {
         edgeId = edgeId << 1;
         if (reverse)
-            return (nodeA > nodeB) ? edgeId : edgeId + 1;
+            return (nodeA >= nodeB) ? edgeId : edgeId + 1;
         return (nodeA > nodeB) ? edgeId + 1 : edgeId;
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 8faeec1bdf..f7cc55f642 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -108,7 +108,7 @@ public void doWork(PathWrapper altRsp, List<Path> paths, EncodingManager encodin
                     if (pathIndex + 1 < paths.size()) {
                         ViaInstruction newInstr = new ViaInstruction(fullInstructions.get(fullInstructions.size() - 1));
                         newInstr.setViaCount(pathIndex + 1);
-                        fullInstructions.replaceLast(newInstr);
+                        fullInstructions.set(fullInstructions.size() - 1, newInstr);
                     }
                 }
 
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index 39e822d9a2..7d381c249c 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -36,7 +36,7 @@
             "cs_CZ", "da_DK", "de_DE", "el", "eo", "es", "en_US", "fa", "fil", "fi",
             "fr_FR", "fr_CH", "gl", "he", "hr_HR", "hsb", "hu_HU", "it", "ja", "ko", "lt_LT", "ne",
             "nl", "pl_PL", "pt_BR", "pt_PT", "ro", "ru", "sk", "sl_SI", "sr_RS", "sv_SE", "tr", "uk",
-            "vi_VI", "zh_CN", "zh_HK");
+            "vi_VI", "zh_CN", "zh_HK", "zh_TW");
     private final Map<String, Translation> translations = new HashMap<>();
 
     public static int countOccurence(String phrase, String splitter) {
diff --git a/core/src/main/java/com/graphhopper/util/Unzipper.java b/core/src/main/java/com/graphhopper/util/Unzipper.java
index 9537c2d6db..a8a0976ea5 100644
--- a/core/src/main/java/com/graphhopper/util/Unzipper.java
+++ b/core/src/main/java/com/graphhopper/util/Unzipper.java
@@ -56,13 +56,13 @@ public void unzip(InputStream fromIs, File toFolder, ProgressListener progressLi
             byte[] buffer = new byte[8 * 1024];
             while (ze != null) {
                 if (ze.isDirectory()) {
-                    new File(toFolder, ze.getName()).mkdir();
+                    getVerifiedFile(toFolder, ze).mkdir();
                 } else {
                     double factor = 1;
                     if (ze.getCompressedSize() > 0 && ze.getSize() > 0)
                         factor = (double) ze.getCompressedSize() / ze.getSize();
 
-                    File newFile = new File(toFolder, ze.getName());
+                    File newFile = getVerifiedFile(toFolder, ze);
                     FileOutputStream fos = new FileOutputStream(newFile);
                     try {
                         int len;
@@ -84,4 +84,12 @@ public void unzip(InputStream fromIs, File toFolder, ProgressListener progressLi
             zis.close();
         }
     }
+
+    // see #1628
+    File getVerifiedFile(File destinationDir, ZipEntry ze) throws IOException {
+        File destinationFile = new File(destinationDir, ze.getName());
+        if (!destinationFile.getCanonicalPath().startsWith(destinationDir.getCanonicalPath() + File.separator))
+            throw new SecurityException("Zip Entry is outside of the target dir: " + ze.getName());
+        return destinationFile;
+    }
 }
diff --git a/core/src/main/resources/com/graphhopper/util/it.txt b/core/src/main/resources/com/graphhopper/util/it.txt
index 45593d315b..2173685fe3 100644
--- a/core/src/main/resources/com/graphhopper/util/it.txt
+++ b/core/src/main/resources/com/graphhopper/util/it.txt
@@ -34,8 +34,8 @@ web.bus=Tram
 web.truck=Camion
 web.staticlink=permalink
 web.motorcycle=Moto
-via=attraverso
-finish=Arrivo!
+via=via
+finish=Arrivato a destinazione
 hour_abbr=hh
 day_abbr=gg
 min_abbr=mm
diff --git a/core/src/main/resources/com/graphhopper/util/zh_TW.txt b/core/src/main/resources/com/graphhopper/util/zh_TW.txt
new file mode 100644
index 0000000000..a91fd1775b
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/zh_TW.txt
@@ -0,0 +1,79 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=
+continue_onto= %1$s
+turn_left=
+turn_right=
+turn_slight_left=
+turn_slight_right=
+turn_sharp_left=
+turn_sharp_right=
+keep_left=
+keep_right=
+turn_onto=%1$s %2$s
+u_turn=
+unknown= '%1$s'
+web.search_button=
+web.from_hint=
+web.via_hint=
+web.to_hint=
+web.more_button=
+web.gpx_export_button=GPS
+web.route_info=%1$s  %2$s
+web.pt_route_info= %1$s %2$s  (%3$s)
+web.pt_route_info_walking= %1$s  (%2$s)
+web.locations_not_found=
+web.bike=
+web.racingbike=
+web.mtb=
+web.car=
+web.foot=
+web.hike=
+web.small_truck=
+web.bus=
+web.truck=
+web.staticlink=
+web.motorcycle=
+via=
+finish=
+hour_abbr=
+day_abbr=
+min_abbr=
+km_abbr=
+m_abbr=
+mi_abbr=
+ft_abbr=
+road=
+off_bike=
+cycleway=
+way=
+small_way=
+paved=
+unpaved=
+stopover= %1$s
+roundabout_enter=
+roundabout_exit= %1$s 
+roundabout_exit_onto= %1$s  %2$s
+total_ascend= %1$s
+total_descend= %1$s
+way_contains_ford=
+pt_start_trip= %1$s
+pt_end_trip= %1$s
+pt_transfer_to= %1$s
+web.start_label=
+web.intermediate_label=
+web.end_label=
+web.set_start=
+web.set_intermediate=
+web.set_end=
+web.center_map=
+web.show_coords=
+web.route=
+web.delete_from_route=
+web.marker=
+web.gh_offline_info=GraphHopper API 
+web.refresh_button=
+web.server_status=
+web.zoom_in=
+web.zoom_out=
+web.drag_to_reorder=
diff --git a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
index 60b70c23d6..bc07cd7e43 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
@@ -51,7 +51,6 @@ public AStarBidirectionTest(TraversalMode tMode) {
     public static Collection<Object[]> configs() {
         return Arrays.asList(new Object[][]{
                 {TraversalMode.NODE_BASED},
-                {TraversalMode.EDGE_BASED_1DIR},
                 {TraversalMode.EDGE_BASED_2DIR},
                 {TraversalMode.EDGE_BASED_2DIR_UTURN}
         });
diff --git a/core/src/test/java/com/graphhopper/routing/AStarTest.java b/core/src/test/java/com/graphhopper/routing/AStarTest.java
index 56f12bd467..5f35819a08 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarTest.java
@@ -46,7 +46,6 @@ public AStarTest(TraversalMode tMode) {
     public static Collection<Object[]> configs() {
         return Arrays.asList(new Object[][]{
                 {TraversalMode.NODE_BASED},
-                {TraversalMode.EDGE_BASED_1DIR},
                 {TraversalMode.EDGE_BASED_2DIR},
                 {TraversalMode.EDGE_BASED_2DIR_UTURN}
         });
diff --git a/core/src/test/java/com/graphhopper/routing/CHQueryWithTurnCostsTest.java b/core/src/test/java/com/graphhopper/routing/CHQueryWithTurnCostsTest.java
index 289ae68b1f..f5d85bdfd9 100644
--- a/core/src/test/java/com/graphhopper/routing/CHQueryWithTurnCostsTest.java
+++ b/core/src/test/java/com/graphhopper/routing/CHQueryWithTurnCostsTest.java
@@ -21,9 +21,10 @@
 import com.carrotsearch.hppc.IntArrayList;
 import com.graphhopper.routing.ch.PreparationWeighting;
 import com.graphhopper.routing.ch.PrepareEncoder;
-import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.LevelEdgeFilter;
+import com.graphhopper.routing.util.MotorcycleFlagEncoder;
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.routing.weighting.Weighting;
@@ -53,7 +54,7 @@
 @RunWith(Parameterized.class)
 public class CHQueryWithTurnCostsTest {
     private final int maxCost = 10;
-    private final CarFlagEncoder encoder = new CarFlagEncoder(5, 5, maxCost);
+    private final FlagEncoder encoder = new MotorcycleFlagEncoder(5, 5, maxCost);
     private final EncodingManager encodingManager = EncodingManager.create(encoder);
     private final Weighting weighting = new ShortestWeighting(encoder);
     private final GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHGraph(weighting).setEdgeBasedCH(true).create();
@@ -85,7 +86,7 @@ public void testFindPathWithTurnCosts_bidirected_no_shortcuts_smallGraph() {
         for (int i = 0; i < 3; ++i) {
             testPathCalculation(i, i, 0, IntArrayList.from(i));
         }
-        testPathCalculation(1, 2, 11, IntArrayList.from(1, 0, 2));
+        testPathCalculation(1, 2, 8, IntArrayList.from(1, 0, 2), 3);
         testPathCalculation(2, 1, 8, IntArrayList.from(2, 0, 1));
         testPathCalculation(0, 1, 3, IntArrayList.from(0, 1));
         testPathCalculation(0, 2, 5, IntArrayList.from(0, 2));
@@ -111,11 +112,92 @@ public void testFindPathWithTurnCosts_bidirected_no_shortcuts() {
         // contraction yields no shortcuts
         setLevelEqualToNodeIdForAllNodes();
 
-        testPathCalculation(0, 1, 40, IntArrayList.from(0, 2, 4, 6, 5, 3, 1));
-        testPathCalculation(1, 0, 28, IntArrayList.from(1, 3, 5, 6, 4, 2, 0));
-        testPathCalculation(4, 3, 23, IntArrayList.from(4, 6, 5, 3));
+        // note that we are using the shortest weighting but turn cost times are included whatsoever, see #1590
+        testPathCalculation(0, 1, 26, IntArrayList.from(0, 2, 4, 6, 5, 3, 1), 14);
+        testPathCalculation(1, 0, 26, IntArrayList.from(1, 3, 5, 6, 4, 2, 0), 2);
+        testPathCalculation(4, 3, 17, IntArrayList.from(4, 6, 5, 3), 6);
         testPathCalculation(0, 0, 0, IntArrayList.from(0));
         testPathCalculation(4, 4, 0, IntArrayList.from(4));
+
+        // also check if distance and times (including turn costs) are calculated correctly
+        Path path = createAlgo().calcPath(0, 1);
+        assertEquals("wrong weight", 40, path.getWeight(), 1.e-3);
+        assertEquals("wrong distance", 26, path.getDistance(), 1.e-3);
+        double weightPerMeter = 0.06;
+        assertEquals("wrong time", (26 * weightPerMeter + 14) * 1000, path.getTime(), 1.e-3);
+    }
+
+    @Test
+    public void testFindPathWithTurnCosts_loopShortcutBwdSearch() {
+        // the loop shortcut 4-4 will be encountered during the bwd search
+        //             3
+        //            / \
+        //           1   2
+        //            \ /
+        // 0 - 7 - 8 - 4 - 6 - 5
+        graph.edge(0, 7, 1, false);
+        graph.edge(7, 8, 1, false);
+        graph.edge(8, 4, 1, false);
+        graph.edge(4, 1, 1, false);
+        graph.edge(1, 3, 1, false);
+        graph.edge(3, 2, 1, false);
+        graph.edge(2, 4, 1, false);
+        graph.edge(4, 6, 1, false);
+        graph.edge(6, 5, 1, false);
+        addRestriction(8, 4, 6);
+        addRestriction(8, 4, 2);
+        addRestriction(1, 4, 6);
+
+        graph.freeze();
+
+        // from contracting node 1
+        addShortcut(4, 3, 3, 4, 3, 4, 2);
+        // from contracting node 2
+        addShortcut(3, 4, 5, 6, 5, 6, 2);
+        // from contracting node 3
+        addShortcut(4, 4, 3, 6, 9, 10, 4);
+        // from contracting node 4
+        addShortcut(8, 4, 2, 6, 2, 11, 5);
+        addShortcut(8, 6, 2, 7, 12, 7, 6);
+        setLevelEqualToNodeIdForAllNodes();
+
+        testPathCalculation(0, 5, 9, IntArrayList.from(0, 7, 8, 4, 1, 3, 2, 4, 6, 5));
+    }
+
+    @Test
+    public void testFindPathWithTurnCosts_loopShortcutFwdSearch() {
+        // the loop shortcut 4-4 will be encountered during the fwd search
+        //         3
+        //        / \
+        //       1   2
+        //        \ /
+        // 5 - 6 - 4 - 7 - 8 - 0
+        graph.edge(5, 6, 1, false);
+        graph.edge(6, 4, 1, false);
+        graph.edge(4, 1, 1, false);
+        graph.edge(1, 3, 1, false);
+        graph.edge(3, 2, 1, false);
+        graph.edge(2, 4, 1, false);
+        graph.edge(4, 7, 1, false);
+        graph.edge(7, 8, 1, false);
+        graph.edge(8, 0, 1, false);
+        addRestriction(6, 4, 7);
+        addRestriction(6, 4, 2);
+        addRestriction(1, 4, 7);
+        graph.freeze();
+
+        // from contracting node 1
+        addShortcut(4, 3, 2, 3, 2, 3, 2);
+        // from contracting node 2
+        addShortcut(3, 4, 4, 5, 4, 5, 2);
+        // from contracting node 3
+        addShortcut(4, 4, 2, 5, 9, 10, 4);
+        // from contracting node 4
+        addShortcut(6, 4, 1, 5, 1, 11, 5);
+        addShortcut(6, 7, 1, 6, 12, 6, 6);
+        setLevelEqualToNodeIdForAllNodes();
+
+        testPathCalculation(5, 0, 9, IntArrayList.from(5, 6, 4, 1, 3, 2, 4, 7, 8, 0));
     }
 
     @Test
@@ -138,13 +220,13 @@ public void testFindPathWithTurnCosts_directed_single_shortcut() {
         setLevelEqualToNodeIdForAllNodes();
 
         // when we are searching a path to the highest level node, the backward search will not expand any edges
-        testPathCalculation(1, 4, 19, IntArrayList.from(1, 2, 0, 3, 4));
-        testPathCalculation(2, 4, 10, IntArrayList.from(2, 0, 3, 4));
-        testPathCalculation(0, 4, 6, IntArrayList.from(0, 3, 4));
+        testPathCalculation(1, 4, 11, IntArrayList.from(1, 2, 0, 3, 4), 8);
+        testPathCalculation(2, 4, 7, IntArrayList.from(2, 0, 3, 4), 3);
+        testPathCalculation(0, 4, 5, IntArrayList.from(0, 3, 4), 1);
 
         // when we search a path to or start the search from a low level node both forward and backward searches run
-        testPathCalculation(1, 0, 11, IntArrayList.from(1, 2, 0));
-        testPathCalculation(0, 4, 6, IntArrayList.from(0, 3, 4));
+        testPathCalculation(1, 0, 6, IntArrayList.from(1, 2, 0), 5);
+        testPathCalculation(0, 4, 5, IntArrayList.from(0, 3, 4), 1);
     }
 
     @Test
@@ -165,7 +247,7 @@ public void testFindPathWithTurnCosts_directed_single_shortcut_fwdSearchStopsQui
         addShortcut(3, 2, 1, 2, 1, 2, 4);
         setLevelEqualToNodeIdForAllNodes();
 
-        testPathCalculation(1, 4, 15, IntArrayList.from(1, 3, 0, 2, 4));
+        testPathCalculation(1, 4, 9, IntArrayList.from(1, 3, 0, 2, 4), 6);
     }
 
     @Test
@@ -189,11 +271,11 @@ public void testFindPathWithTurnCosts_directed_two_shortcuts() {
         setLevelEqualToNodeIdForAllNodes();
 
         // the turn costs have to be accounted for also when the shortcuts are used
-        testPathCalculation(2, 4, 19, IntArrayList.from(2, 3, 1, 0, 4));
-        testPathCalculation(1, 4, 6, IntArrayList.from(1, 0, 4));
-        testPathCalculation(2, 0, 16, IntArrayList.from(2, 3, 1, 0));
-        testPathCalculation(3, 4, 10, IntArrayList.from(3, 1, 0, 4));
-        testPathCalculation(2, 1, 11, IntArrayList.from(2, 3, 1));
+        testPathCalculation(2, 4, 11, IntArrayList.from(2, 3, 1, 0, 4), 8);
+        testPathCalculation(1, 4, 5, IntArrayList.from(1, 0, 4), 1);
+        testPathCalculation(2, 0, 9, IntArrayList.from(2, 3, 1, 0), 7);
+        testPathCalculation(3, 4, 7, IntArrayList.from(3, 1, 0, 4), 3);
+        testPathCalculation(2, 1, 6, IntArrayList.from(2, 3, 1), 5);
     }
 
     @Test
@@ -212,7 +294,7 @@ public void testFindPath_directConnectionIsNotTheBestPath() {
 
         // no shortcuts here
         setLevelEqualToNodeIdForAllNodes();
-        testPathCalculation(0, 1, 18, IntArrayList.from(0, 2, 3, 1));
+        testPathCalculation(0, 1, 14, IntArrayList.from(0, 2, 3, 1), 4);
     }
 
     @Test
@@ -351,7 +433,7 @@ public void testFindPathWithTurnCosts_loop() {
         setLevelEqualToNodeIdForAllNodes();
 
         // without u-turns we need to take the loop
-        testPathCalculation(0, 1, 18, IntArrayList.from(0, 2, 3, 2, 1));
+        testPathCalculation(0, 1, 15, IntArrayList.from(0, 2, 3, 2, 1), 3);
 
         // additional check
         testPathCalculation(3, 1, 4, IntArrayList.from(3, 2, 1));
@@ -380,7 +462,7 @@ public void testFindPathWithTurnCosts_multiple_bridge_nodes() {
 
         // going via 2, 3 and 4 is possible, but we want the shortest path taking into account turn costs also at
         // the bridge node
-        testPathCalculation(0, 1, 7, IntArrayList.from(0, 3, 1));
+        testPathCalculation(0, 1, 5, IntArrayList.from(0, 3, 1), 2);
     }
 
     @Test
@@ -608,6 +690,13 @@ public void testFindPathWithTurnRestriction_two_different_loops() {
     }
 
     private void testPathCalculation(int from, int to, int expectedWeight, IntArrayList expectedNodes) {
+        testPathCalculation(from, to, expectedWeight, expectedNodes, 0);
+    }
+
+    private void testPathCalculation(int from, int to, int expectedEdgeWeight, IntArrayList expectedNodes, int expectedTurnCost) {
+        int expectedWeight = expectedEdgeWeight + expectedTurnCost;
+        int expectedDistance = expectedEdgeWeight;
+        int expectedTime = expectedEdgeWeight * 60 + expectedTurnCost * 1000;
         AbstractBidirectionEdgeCHNoSOD algo = createAlgo();
         Path path = algo.calcPath(from, to);
         if (expectedWeight < 0) {
@@ -617,6 +706,8 @@ private void testPathCalculation(int from, int to, int expectedWeight, IntArrayL
                 assertEquals(String.format(Locale.ROOT, "Unexpected path from %d to %d", from, to), expectedNodes, path.calcNodes());
             }
             assertEquals(String.format(Locale.ROOT, "Unexpected path weight from %d to %d", from, to), expectedWeight, path.getWeight(), 1.e-6);
+            assertEquals(String.format(Locale.ROOT, "Unexpected path distance from %d to %d", from, to), expectedDistance, path.getDistance(), 1.e-6);
+            assertEquals(String.format(Locale.ROOT, "Unexpected path time from %d to %d", from, to), expectedTime, path.getTime());
         }
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
index 9667bd3617..617ddc249b 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
@@ -45,7 +45,6 @@ public DijkstraBidirectionRefTest(TraversalMode tMode) {
     public static Collection<Object[]> configs() {
         return Arrays.asList(new Object[][]{
                 {TraversalMode.NODE_BASED},
-                {TraversalMode.EDGE_BASED_1DIR},
                 {TraversalMode.EDGE_BASED_2DIR},
                 {TraversalMode.EDGE_BASED_2DIR_UTURN}
         });
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
index 29fec92015..2ba58ff0e1 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
@@ -45,7 +45,6 @@ public DijkstraTest(TraversalMode tMode) {
     public static Collection<Object[]> configs() {
         return Arrays.asList(new Object[][]{
                 {TraversalMode.NODE_BASED},
-                {TraversalMode.EDGE_BASED_1DIR},
                 {TraversalMode.EDGE_BASED_2DIR},
                 {TraversalMode.EDGE_BASED_2DIR_UTURN}
         });
diff --git a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
index e9e39e371e..08dac53dbc 100644
--- a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
+++ b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
@@ -31,14 +31,15 @@
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Helper;
 import org.junit.Assume;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-import java.util.Arrays;
-import java.util.Collection;
+import java.util.*;
 
 import static com.graphhopper.util.GHUtility.getEdge;
 import static com.graphhopper.util.Parameters.Algorithms.*;
@@ -134,6 +135,62 @@ private Weighting createWeighting(FlagEncoder encoder, TurnCostExtension tcs, do
         return new TurnWeighting(new FastestWeighting(encoder), tcs).setDefaultUTurnCost(uTurnCosts);
     }
 
+    @Test
+    public void testRandomGraph() {
+        long seed = System.nanoTime();
+        final int numQueries = 100;
+        Random rnd = new Random(seed);
+        GraphHopperStorage g = createStorage(createEncodingManager(false));
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
+        GHUtility.buildRandomGraph(g, rnd, 50, 2.2, true, true, carEncoder.getAverageSpeedEnc(), 0.8, 0.8, 0.8);
+        GHUtility.addRandomTurnCosts(g, seed, carEncoder, 3, tcs);
+        g.freeze();
+        int numPathsNotFound = 0;
+        // todo: reduce redundancy with RandomCHRoutingTest
+        List<String> strictViolations = new ArrayList<>();
+        for (int i = 0; i < numQueries; i++) {
+            int from = rnd.nextInt(g.getNodes());
+            int to = rnd.nextInt(g.getNodes());
+            Weighting w = createWeighting(carEncoder, tcs, 40);
+            RoutingAlgorithm refAlgo = new Dijkstra(g, w, TraversalMode.EDGE_BASED_2DIR);
+            Path refPath = refAlgo.calcPath(from, to);
+            double refWeight = refPath.getWeight();
+            if (!refPath.isFound()) {
+                numPathsNotFound++;
+                continue;
+            }
+
+            RoutingAlgorithm algo = createAlgo(g, AlgorithmOptions.start()
+                    .weighting(w)
+                    .traversalMode(TraversalMode.EDGE_BASED_2DIR)
+                    .build());
+            Path path = algo.calcPath(from, to);
+            if (!path.isFound()) {
+                fail("path not found for " + from + "->" + to + ", expected weight: " + refWeight);
+            }
+
+            double weight = path.getWeight();
+            if (Math.abs(refWeight - weight) > 1.e-2) {
+                System.out.println("expected: " + refPath.calcNodes());
+                System.out.println("given:    " + path.calcNodes());
+                fail("wrong weight: " + from + "->" + to + ", dijkstra: " + refWeight + " vs. " + algoStr + ": " + path.getWeight());
+            }
+            if (Math.abs(path.getDistance() - refPath.getDistance()) > 1.e-1) {
+                strictViolations.add("wrong distance " + from + "->" + to + ", expected: " + refPath.getDistance() + ", given: " + path.getDistance());
+            }
+            if (Math.abs(path.getTime() - refPath.getTime()) > 50) {
+                strictViolations.add("wrong time " + from + "->" + to + ", expected: " + refPath.getTime() + ", given: " + path.getTime());
+            }
+        }
+        if (numPathsNotFound > 0.9 * numQueries) {
+            fail("Too many paths not found: " + numPathsNotFound + "/" + numQueries);
+        }
+        if (strictViolations.size() > 0.05 * numQueries) {
+            fail("Too many strict violations: " + strictViolations.size() + "/" + numQueries + "\n" +
+                    Helper.join("\n", strictViolations));
+        }
+    }
+
     @Test
     public void testBasicTurnRestriction() {
         GraphHopperStorage g = createStorage(createEncodingManager(true));
@@ -149,17 +206,42 @@ public void testBasicTurnRestriction() {
         // test 7-6-5 and reverse
         p = createAlgo(g, AlgorithmOptions.start().
                 weighting(createWeighting(carEncoder, tcs, 40)).
-                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
                 calcPath(5, 7);
         assertEquals(IntArrayList.from(5, 6, 7), p.calcNodes());
 
         p = createAlgo(g, AlgorithmOptions.start().
                 weighting(createWeighting(carEncoder, tcs, 40)).
-                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
                 calcPath(7, 5);
         assertEquals(IntArrayList.from(7, 6, 3, 2, 5), p.calcNodes());
     }
 
+    @Test
+    public void testLoop_issue1592() {
+        GraphHopperStorage g = createStorage(createEncodingManager(true));
+        // 0-6
+        //  \ \
+        //   4-3
+        //   |
+        //   1o
+        g.edge(0, 6, 10, true);
+        g.edge(6, 3, 10, true);
+        g.edge(0, 4, 1, true);
+        g.edge(4, 1, 1, true);
+        g.edge(4, 3, 1, true);
+        g.edge(1, 1, 10, true);
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
+        addTurnRestriction(g, tcs, 0, 4, 3);
+
+        Path p = createAlgo(g, AlgorithmOptions.start().
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
+                calcPath(0, 3);
+        assertEquals(14, p.getDistance(), 1.e-3);
+        assertEquals(IntArrayList.from(0, 4, 1, 1, 4, 3), p.calcNodes());
+    }
+
     @Test
     public void testTurnCosts_timeCalculation() {
         // 0 - 1 - 2 - 3 - 4
@@ -276,7 +358,7 @@ public void testBasicTurnCosts() {
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
         Path p = createAlgo(g, AlgorithmOptions.start().
                 weighting(createWeighting(carEncoder, tcs, 40)).
-                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
                 calcPath(5, 1);
 
         // no restriction and costs
@@ -288,7 +370,7 @@ public void testBasicTurnCosts() {
 
         p = createAlgo(g, AlgorithmOptions.start().
                 weighting(createWeighting(carEncoder, tcs, 40)).
-                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
                 calcPath(5, 1);
         assertEquals(IntArrayList.from(5, 6, 3, 1), p.calcNodes());
     }
@@ -322,12 +404,64 @@ public double calcTurnWeight(int edgeFrom, int nodeVia, int edgeTo) {
         assertEquals(1300, p.getTime(), .1);
     }
 
+    @Test
+    public void testLoopEdge() {
+        //   o
+        // 3-2-4
+        //  \|
+        //   0
+        final GraphHopperStorage g = createStorage(createEncodingManager(false));
+        g.edge(3, 2, 188, false);
+        g.edge(3, 0, 182, true);
+        g.edge(4, 2, 690, true);
+        g.edge(2, 2, 121, false);
+        g.edge(2, 0, 132, true);
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
+        addTurnRestriction(g, tcs, 2, 2, 0);
+        addTurnRestriction(g, tcs, 3, 2, 4);
+
+        Path p = createAlgo(g, AlgorithmOptions.start().
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
+                calcPath(3, 4);
+        assertEquals(IntArrayList.from(3, 2, 2, 4), p.calcNodes());
+        assertEquals(999, p.getDistance(), 1.e-3);
+    }
+
+    @Test
+    public void testDoubleLoopPTurn() {
+        // we cannot go 1-4-5, but taking the loop at 4 is cheaper than taking the one at 3
+        //  0-1
+        //    |
+        // o3-4o
+        //    |
+        //    5
+        final GraphHopperStorage g = createStorage(createEncodingManager(false));
+        g.edge(0, 1, 1, true);
+        g.edge(3, 4, 2, true);
+        g.edge(4, 4, 4, true);
+        g.edge(3, 3, 1, true);
+        g.edge(1, 4, 5, true);
+        g.edge(5, 4, 1, true);
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
+        addTurnRestriction(g, tcs, 1, 4, 5);
+
+        Path p = createAlgo(g, AlgorithmOptions.start().
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
+                calcPath(0, 5);
+        assertEquals(IntArrayList.from(0, 1, 4, 4, 5), p.calcNodes());
+        assertEquals(11, p.getDistance(), 1.e-3);
+        assertEquals(11 * 0.06, p.getWeight(), 1.e-3);
+        assertEquals(11 * 0.06 * 1000, p.getTime(), 1.e-3);
+    }
+
     private void addTurnRestriction(Graph g, TurnCostExtension tcs, int from, int via, int to) {
         long turnFlags = carEncoder.getTurnFlags(true, 0);
         addTurnFlags(g, tcs, from, via, to, turnFlags);
     }
 
-    private void addTurnCost(Graph g, TurnCostExtension tcs, int costs, int from, int via, int to) {
+    private void addTurnCost(Graph g, TurnCostExtension tcs, double costs, int from, int via, int to) {
         long turnFlags = carEncoder.getTurnFlags(false, costs);
         addTurnFlags(g, tcs, from, via, to, turnFlags);
     }
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index a25551e616..dab93e4429 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -87,20 +87,28 @@ public void testWayList() {
         // 0-1-2
         assertPList(Helper.createPointList(0, 0.1, 8, 1, 9, 1, 1, 0.1, 10, 1, 11, 1, 2, 0.1), path.calcPoints());
         InstructionList instr = path.calcInstructions(carManagerRoundabout, tr);
-        List<Map<String, Object>> res = instr.createJson();
-        Map<String, Object> tmp = res.get(0);
-        assertEquals(3000.0, tmp.get("distance"));
-        assertEquals(504000L, tmp.get("time"));
-        assertEquals("Continue", tmp.get("text"));
-        assertEquals("[0, 6]", tmp.get("interval").toString());
-
-        tmp = res.get(1);
-        assertEquals(0.0, tmp.get("distance"));
-        assertEquals(0L, tmp.get("time"));
-        assertEquals("Arrive at destination", tmp.get("text"));
-        assertEquals("[6, 6]", tmp.get("interval").toString());
-        int lastIndex = (Integer) ((List) res.get(res.size() - 1).get("interval")).get(0);
-        assertEquals(path.calcPoints().size() - 1, lastIndex);
+        Instruction tmp = instr.get(0);
+        assertEquals(3000.0, tmp.getDistance(), 0.0);
+        assertEquals(504000L, tmp.getTime());
+        assertEquals("continue", tmp.getTurnDescription(tr));
+//        assertEquals("[0, 6]", tmp.get("interval").toString());
+        assertEquals(6, tmp.getLength());
+//        System.out.println(tmp.getPoints());
+
+
+        tmp = instr.get(1);
+        assertEquals(0.0, tmp.getDistance(), 0.0);
+        assertEquals(0L, tmp.getTime());
+        assertEquals("arrive at destination", tmp.getTurnDescription(tr));
+//        assertEquals("[6, 6]", tmp.get("interval").toString());
+        assertEquals(0, tmp.getLength());
+//        System.out.println(tmp.getPoints());
+
+        int acc = 0;
+        for (Instruction instruction : instr) {
+            acc += instruction.getLength();
+        }
+        assertEquals(path.calcPoints().size() - 1, acc);
 
         // force minor change for instructions
         edge2.setName("2");
@@ -114,21 +122,23 @@ public void testWayList() {
         path.setSPTEntry(e1);
         path.extract();
         instr = path.calcInstructions(carManagerRoundabout, tr);
-        res = instr.createJson();
-
-        tmp = res.get(0);
-        assertEquals(1000.0, tmp.get("distance"));
-        assertEquals(360000L, tmp.get("time"));
-        assertEquals("Continue", tmp.get("text"));
-        assertEquals("[0, 3]", tmp.get("interval").toString());
-
-        tmp = res.get(1);
-        assertEquals(2000.0, tmp.get("distance"));
-        assertEquals(144000L, tmp.get("time"));
-        assertEquals("Turn sharp right onto 2", tmp.get("text"));
-        assertEquals("[3, 6]", tmp.get("interval").toString());
-        lastIndex = (Integer) ((List) res.get(res.size() - 1).get("interval")).get(0);
-        assertEquals(path.calcPoints().size() - 1, lastIndex);
+
+        tmp = instr.get(0);
+        assertEquals(1000.0, tmp.getDistance(), 0);
+        assertEquals(360000L, tmp.getTime());
+        assertEquals("continue", tmp.getTurnDescription(tr));
+        assertEquals(3, tmp.getLength());
+
+        tmp = instr.get(1);
+        assertEquals(2000.0, tmp.getDistance(), 0);
+        assertEquals(144000L, tmp.getTime());
+        assertEquals("turn sharp right onto 2", tmp.getTurnDescription(tr));
+        assertEquals(3, tmp.getLength());
+        acc = 0;
+        for (Instruction instruction : instr) {
+            acc += instruction.getLength();
+        }
+        assertEquals(path.calcPoints().size() - 1, acc);
 
         // now reverse order
         path = new Path(g, new FastestWeighting(encoder));
@@ -141,20 +151,22 @@ public void testWayList() {
         assertPList(Helper.createPointList(2, 0.1, 11, 1, 10, 1, 1, 0.1, 9, 1, 8, 1, 0, 0.1), path.calcPoints());
 
         instr = path.calcInstructions(carManagerRoundabout, tr);
-        res = instr.createJson();
-        tmp = res.get(0);
-        assertEquals(2000.0, tmp.get("distance"));
-        assertEquals(144000L, tmp.get("time"));
-        assertEquals("Continue onto 2", tmp.get("text"));
-        assertEquals("[0, 3]", tmp.get("interval").toString());
-
-        tmp = res.get(1);
-        assertEquals(1000.0, tmp.get("distance"));
-        assertEquals(360000L, tmp.get("time"));
-        assertEquals("Turn sharp left", tmp.get("text"));
-        assertEquals("[3, 6]", tmp.get("interval").toString());
-        lastIndex = (Integer) ((List) res.get(res.size() - 1).get("interval")).get(0);
-        assertEquals(path.calcPoints().size() - 1, lastIndex);
+        tmp = instr.get(0);
+        assertEquals(2000.0, tmp.getDistance(), 0);
+        assertEquals(144000L, tmp.getTime());
+        assertEquals("continue onto 2", tmp.getTurnDescription(tr));
+        assertEquals(3, tmp.getLength());
+
+        tmp = instr.get(1);
+        assertEquals(1000.0, tmp.getDistance(), 0);
+        assertEquals(360000L, tmp.getTime());
+        assertEquals("turn sharp left", tmp.getTurnDescription(tr));
+        assertEquals(3, tmp.getLength());
+        acc = 0;
+        for (Instruction instruction : instr) {
+            acc += instruction.getLength();
+        }
+        assertEquals(path.calcPoints().size() - 1, acc);
     }
 
     @Test
@@ -228,10 +240,10 @@ public void testCalcInstructionsRoundabout() {
             assertEquals("[1, 2, 3, 4, 5, 8]", p.calcNodes().toString());
             InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
             // Test instructions
-            List<String> tmpList = pick("text", wayList.createJson());
-            assertEquals(Arrays.asList("Continue onto MainStreet 1 2",
+            List<String> tmpList = getTurnDescriptions(wayList);
+            assertEquals(Arrays.asList("continue onto MainStreet 1 2",
                     "At roundabout, take exit 3 onto 5-8",
-                    "Arrive at destination"),
+                    "arrive at destination"),
                     tmpList);
             // Test Radian
             double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
@@ -242,10 +254,10 @@ public void testCalcInstructionsRoundabout() {
             p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED).
                     calcPath(1, 7);
             wayList = p.calcInstructions(mixedManagerRoundabout, tr);
-            tmpList = pick("text", wayList.createJson());
-            assertEquals(Arrays.asList("Continue onto MainStreet 1 2",
+            tmpList = getTurnDescriptions(wayList);
+            assertEquals(Arrays.asList("continue onto MainStreet 1 2",
                     "At roundabout, take exit 2 onto MainStreet 4 7",
-                    "Arrive at destination"),
+                    "arrive at destination"),
                     tmpList);
             // Test Radian
             delta = roundaboutGraph.getAngle(1, 2, 4, 7);
@@ -263,9 +275,9 @@ public void testCalcInstructionsRoundaboutBegin() {
                 .calcPath(2, 8);
         assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
-        List<String> tmpList = pick("text", wayList.createJson());
+        List<String> tmpList = getTurnDescriptions(wayList);
         assertEquals(Arrays.asList("At roundabout, take exit 3 onto 5-8",
-                "Arrive at destination"),
+                "arrive at destination"),
                 tmpList);
     }
 
@@ -279,10 +291,10 @@ public void testCalcInstructionsRoundaboutDirectExit() {
                 .calcPath(6, 8);
         assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto 3-6",
+        List<String> tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto 3-6",
                 "At roundabout, take exit 3 onto 5-8",
-                "Arrive at destination"),
+                "arrive at destination"),
                 tmpList);
         roundaboutGraph.inverse3to9();
     }
@@ -403,10 +415,10 @@ public void testCalcInstructionsRoundabout2() {
                 .calcPath(1, 8);
         assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto MainStreet 1 2",
+        List<String> tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto MainStreet 1 2",
                 "At roundabout, take exit 2 onto 5-8",
-                "Arrive at destination"),
+                "arrive at destination"),
                 tmpList);
         // Test Radian
         double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
@@ -481,9 +493,9 @@ public void testCalcInstructionsRoundaboutIssue353() {
                 .calcPath(6, 11);
         assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(carManagerRoundabout, tr);
-        List<String> tmpList = pick("text", wayList.createJson());
+        List<String> tmpList = getTurnDescriptions(wayList);
         assertEquals(Arrays.asList("At roundabout, take exit 1 onto MainStreet 1 11",
-                "Arrive at destination"),
+                "arrive at destination"),
                 tmpList);
     }
 
@@ -497,10 +509,10 @@ public void testCalcInstructionsRoundaboutClockwise() {
                 .calcPath(1, 8);
         assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto MainStreet 1 2",
+        List<String> tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto MainStreet 1 2",
                 "At roundabout, take exit 1 onto 5-8",
-                "Arrive at destination"),
+                "arrive at destination"),
                 tmpList);
         // Test Radian
         double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
@@ -868,11 +880,10 @@ public void testIgnoreInstructionsForSlightTurnWithOtherTurn() {
         assertEquals(2, wayList.size());
     }
 
-    List<String> pick(String key, List<Map<String, Object>> instructionJson) {
+    List<String> getTurnDescriptions(InstructionList instructionJson) {
         List<String> list = new ArrayList<>();
-
-        for (Map<String, Object> json : instructionJson) {
-            list.add(json.get(key).toString());
+        for (Instruction instruction : instructionJson) {
+            list.add(instruction.getTurnDescription(tr));
         }
         return list;
     }
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index e31511b31b..fda2a48546 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -33,9 +33,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashSet;
+import java.util.*;
 
 import static com.graphhopper.storage.index.QueryResult.Position.*;
 import static org.junit.Assert.*;
@@ -193,8 +191,8 @@ public void testMultipleVirtualNodes() {
         assertEquals(3, getPoints(queryGraph, 0, 3).getSize());
         PointList pl = getPoints(queryGraph, 3, 1);
         assertEquals(2, pl.getSize());
-        assertEquals(new GHPoint(1.5, 1.5), pl.toGHPoint(0));
-        assertEquals(new GHPoint(1, 2.5), pl.toGHPoint(1));
+        assertEquals(new GHPoint(1.5, 1.5), pl.get(0));
+        assertEquals(new GHPoint(1, 2.5), pl.get(1));
 
         EdgeIteratorState edge = GHUtility.getEdge(queryGraph, 3, 1);
         assertNotNull(queryGraph.getEdgeIteratorState(edge.getEdge(), 3));
@@ -678,7 +676,55 @@ public void useEECache() {
 
         EdgeExplorer edgeExplorer = queryGraph.createEdgeExplorer();
         // using cache means same reference
-        assertTrue(edgeExplorer == queryGraph.createEdgeExplorer());
+        assertSame(edgeExplorer, queryGraph.createEdgeExplorer());
+    }
+
+    @Test
+    public void useEECache_nestedLoop() {
+        //
+        // 0->3
+        // |\
+        // 1 2->6
+        //   |\
+        //   4 5
+        g.edge(0, 1, 10, false);
+        g.edge(0, 2, 10, false);
+        g.edge(0, 3, 10, false);
+        g.edge(2, 4, 10, false);
+        g.edge(2, 5, 10, false);
+        g.edge(2, 6, 10, false);
+
+        EdgeExplorer explorer = g.createEdgeExplorer();
+        EdgeIterator iter = explorer.setBaseNode(0);
+        assertTrue(iter.next());
+        QueryResult res = createLocationResult(0, 0, iter, 1, PILLAR);
+
+        QueryGraph queryGraph = new QueryGraph(g).setUseEdgeExplorerCache(true);
+        queryGraph.lookup(Collections.singletonList(res));
+
+        EdgeExplorer outerEdgeExplorer = queryGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(carEncoder));
+        EdgeExplorer innerEdgeExplorer = queryGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(carEncoder));
+
+        // without using filter id for DefaultEdgeFilter the filters are equal and using the explorers in a nested
+        // loop would fail
+        assertSame(outerEdgeExplorer, innerEdgeExplorer);
+
+        // using a different filter id for the second filter we get different explorers
+        outerEdgeExplorer = queryGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(carEncoder));
+        innerEdgeExplorer = queryGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(carEncoder).setFilterId(1));
+        assertNotSame(outerEdgeExplorer, innerEdgeExplorer);
+
+        // now we can safely use the two explorers in a nested loop
+        Set<String> edges = new HashSet<>();
+        EdgeIterator outerIter = outerEdgeExplorer.setBaseNode(0);
+        while (outerIter.next()) {
+            edges.add("o" + outerIter.getBaseNode() + "-" + outerIter.getAdjNode());
+            EdgeIterator innerIter = innerEdgeExplorer.setBaseNode(outerIter.getAdjNode());
+            while (innerIter.next()) {
+                edges.add("i" + innerIter.getBaseNode() + "-" + innerIter.getAdjNode());
+            }
+        }
+        assertEquals(new HashSet<>(Arrays.asList("o0-1", "o0-2", "o0-3", "i2-4", "i2-5", "i2-6")), edges);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java b/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java
index 917f5a7715..ab85c50f9e 100644
--- a/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java
@@ -2,21 +2,23 @@
 
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.profiles.DecimalEncodedValue;
-import com.graphhopper.routing.util.CarFlagEncoder;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Helper;
 import com.graphhopper.util.PMap;
 import com.graphhopper.util.shapes.BBox;
+import org.junit.Assume;
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -25,8 +27,10 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
+@RunWith(Parameterized.class)
 public class RandomCHRoutingTest {
-    private final TraversalMode traversalMode = TraversalMode.NODE_BASED;
+    private final TraversalMode traversalMode;
+    private final int maxTurnCosts;
     private Directory dir;
     private CarFlagEncoder encoder;
     private Weighting weighting;
@@ -34,37 +38,96 @@
     private LocationIndexTree locationIndex;
     private CHGraph chGraph;
 
+    @Parameterized.Parameters(name = "{0}")
+    public static Object[] params() {
+        return new Object[]{
+                TraversalMode.NODE_BASED,
+                TraversalMode.EDGE_BASED_2DIR
+        };
+    }
+
+    public RandomCHRoutingTest(TraversalMode traversalMode) {
+        this.traversalMode = traversalMode;
+        this.maxTurnCosts = 10;
+    }
+
     @Before
     public void init() {
         dir = new RAMDirectory();
-        encoder = new CarFlagEncoder();
+        encoder = new CarFlagEncoder(5, 5, maxTurnCosts);
         EncodingManager em = EncodingManager.create(encoder);
         weighting = new FastestWeighting(encoder);
-        graph = new GraphBuilder(em).setCHGraph(weighting).create();
+        GraphBuilder graphBuilder = new GraphBuilder(em);
+        graphBuilder.setEdgeBasedCH(traversalMode.isEdgeBased());
+        graph = graphBuilder.setCHGraph(weighting).create();
         chGraph = graph.getGraph(CHGraph.class);
     }
 
-
     /**
      * Runs random routing queries on a random query/CH graph with random speeds and adding random virtual edges and
      * nodes.
      */
     @Test
-    public void issues1574_1581_random() {
+    public void random() {
         // you might have to keep this test running in an infinite loop for several minutes to find potential routing
         // bugs (e.g. use intellij 'run until stop/failure').
         int numNodes = 50;
         long seed = System.nanoTime();
-        // for example these used to fail before fixing #1574 and/or #1581
-//        seed = 9348906923700L;
-//        seed = 9376976930825L;
-//        seed = 9436934744695L;
-//        seed = 10093639220394L;
-//        seed = 10785899964423L;
-
         System.out.println("seed: " + seed);
         Random rnd = new Random(seed);
-        buildRandomGraph(rnd, numNodes, 2.5, true, true, 0.9);
+        // we may not use an offset when query graph is involved, otherwise traveling via virtual edges will not be
+        // the same as taking the direct edge!
+        double pOffset = 0;
+        GHUtility.buildRandomGraph(graph, rnd, numNodes, 2.5, true, true, encoder.getAverageSpeedEnc(), 0.7, 0.9, pOffset);
+        if (traversalMode.isEdgeBased()) {
+            GHUtility.addRandomTurnCosts(graph, seed, encoder, maxTurnCosts, (TurnCostExtension) graph.getExtension());
+        }
+        runRandomTest(rnd, 20);
+    }
+
+    @Test
+    public void issue1574_1() {
+        Assume.assumeFalse(traversalMode.isEdgeBased());
+        Random rnd = new Random(9348906923700L);
+        buildRandomGraphLegacy(rnd, 50, 2.5, false, true, 0.9);
+        runRandomTest(rnd, 20);
+    }
+
+    @Test
+    public void issue1574_2() {
+        Assume.assumeFalse(traversalMode.isEdgeBased());
+        Random rnd = new Random(10093639220394L);
+        buildRandomGraphLegacy(rnd, 50, 2.5, false, true, 0.9);
+        runRandomTest(rnd, 20);
+    }
+
+    @Test
+    public void issue1582() {
+        Assume.assumeFalse(traversalMode.isEdgeBased());
+        Random rnd = new Random(4111485945982L);
+        buildRandomGraphLegacy(rnd, 10, 2.5, false, true, 0.9);
+        runRandomTest(rnd, 100);
+    }
+
+    @Test
+    public void issue1583() {
+        Assume.assumeFalse(traversalMode.isEdgeBased());
+        Random rnd = new Random(10785899964423L);
+        buildRandomGraphLegacy(rnd, 50, 2.5, true, true, 0.9);
+        runRandomTest(rnd, 20);
+    }
+
+    @Test
+    public void issue1593() {
+        Assume.assumeTrue(traversalMode.isEdgeBased());
+        long seed = 60643479675316L;
+        Random rnd = new Random(seed);
+        GHUtility.buildRandomGraph(graph, rnd, 50, 2.5, true, true, encoder.getAverageSpeedEnc(), 0.7, 0.9, 0.0);
+        GHUtility.addRandomTurnCosts(graph, seed, encoder, maxTurnCosts, (TurnCostExtension) graph.getExtension());
+        runRandomTest(rnd, 20);
+    }
+
+    private void runRandomTest(Random rnd, int numVirtualNodes) {
         locationIndex = new LocationIndexTree(graph, dir);
         locationIndex.prepareIndex();
 
@@ -72,20 +135,28 @@ public void issues1574_1581_random() {
         PrepareContractionHierarchies pch = new PrepareContractionHierarchies(chGraph, weighting, traversalMode);
         pch.doWork();
 
-        int numQueryGraph = 50;
+        int numQueryGraph = 25;
         for (int j = 0; j < numQueryGraph; j++) {
             QueryGraph queryGraph = new QueryGraph(graph);
             QueryGraph chQueryGraph = new QueryGraph(chGraph);
-            addVirtualNodesAndEdges(rnd, queryGraph, chQueryGraph);
+            // add virtual nodes and edges, because they can change the routing behavior and/or produce bugs, e.g.
+            // when via-points are used
+            addVirtualNodesAndEdges(rnd, queryGraph, chQueryGraph, numVirtualNodes);
 
             int numQueries = 100;
             int numPathsNotFound = 0;
+            List<String> strictViolations = new ArrayList<>();
             for (int i = 0; i < numQueries; i++) {
                 assertEquals("queryGraph and chQueryGraph should have equal number of nodes", queryGraph.getNodes(), chQueryGraph.getNodes());
                 int from = rnd.nextInt(queryGraph.getNodes());
                 int to = rnd.nextInt(queryGraph.getNodes());
-                DijkstraBidirectionRef refAlgo = new DijkstraBidirectionRef(queryGraph, weighting, TraversalMode.NODE_BASED);
+                Weighting w = traversalMode.isEdgeBased()
+                        ? new TurnWeighting(weighting, (TurnCostExtension) queryGraph.getExtension())
+                        : weighting;
+                // using plain dijkstra instead of bidirectional, because of #1592
+                RoutingAlgorithm refAlgo = new Dijkstra(queryGraph, w, traversalMode);
                 Path refPath = refAlgo.calcPath(from, to);
+                double refWeight = refPath.getWeight();
                 if (!refPath.isFound()) {
                     numPathsNotFound++;
                     continue;
@@ -94,24 +165,34 @@ public void issues1574_1581_random() {
                 RoutingAlgorithm algo = pch.createAlgo(chQueryGraph, AlgorithmOptions.start().hints(new PMap().put("stall_on_demand", true)).build());
                 Path path = algo.calcPath(from, to);
                 if (!path.isFound()) {
-                    fail("path not found for for " + from + "->" + to + ", expected weight: " + path.getWeight());
+                    fail("path not found for " + from + "->" + to + ", expected weight: " + refWeight);
                 }
 
                 double weight = path.getWeight();
-                double refWeight = refPath.getWeight();
-                if (Math.abs(refWeight - weight) > 1) {
+                if (Math.abs(refWeight - weight) > 1.e-2) {
+                    System.out.println("expected: " + refPath.calcNodes());
+                    System.out.println("given:    " + path.calcNodes());
                     fail("wrong weight: " + from + "->" + to + ", dijkstra: " + refWeight + " vs. ch: " + path.getWeight());
                 }
+                if (Math.abs(path.getDistance() - refPath.getDistance()) > 1.e-1) {
+                    strictViolations.add("wrong distance " + from + "->" + to + ", expected: " + refPath.getDistance() + ", given: " + path.getDistance());
+                }
+                if (Math.abs(path.getTime() - refPath.getTime()) > 50) {
+                    strictViolations.add("wrong time " + from + "->" + to + ", expected: " + refPath.getTime() + ", given: " + path.getTime());
+                }
             }
             if (numPathsNotFound > 0.9 * numQueries) {
                 fail("Too many paths not found: " + numPathsNotFound + "/" + numQueries);
             }
+            if (strictViolations.size() > 0.05 * numQueries) {
+                fail("Too many strict violations: " + strictViolations.size() + "/" + numQueries + "\n" +
+                        Helper.join("\n", strictViolations));
+            }
         }
     }
 
-    private void addVirtualNodesAndEdges(Random rnd, QueryGraph queryGraph, QueryGraph chQueryGraph) {
+    private void addVirtualNodesAndEdges(Random rnd, QueryGraph queryGraph, QueryGraph chQueryGraph, int numVirtualNodes) {
         BBox bbox = graph.getBounds();
-        int numVirtualNodes = 20;
         int count = 0;
         List<QueryResult> qrs = new ArrayList<>(numVirtualNodes);
         while (qrs.size() < numVirtualNodes) {
@@ -140,7 +221,11 @@ private double randomDoubleInRange(Random rnd, double min, double max) {
         return min + rnd.nextDouble() * (max - min);
     }
 
-    private void buildRandomGraph(Random random, int numNodes, double meanDegree, boolean allowLoops, boolean allowZeroDistance, double pBothDir) {
+    /**
+     * More or less does the same as {@link GHUtility#buildRandomGraph}, but since some special seeds
+     * are used in a few tests above this code is kept here. Do not use it for new tests.
+     */
+    private void buildRandomGraphLegacy(Random random, int numNodes, double meanDegree, boolean allowLoops, boolean allowZeroDistance, double pBothDir) {
         for (int i = 0; i < numNodes; ++i) {
             double lat = 49.4 + (random.nextDouble() * 0.0001);
             double lon = 9.7 + (random.nextDouble() * 0.0001);
diff --git a/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java b/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
index ee976e4451..20b425e285 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
@@ -21,18 +21,15 @@
 import com.graphhopper.Repeat;
 import com.graphhopper.RepeatRule;
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.util.CarFlagEncoder;
-import com.graphhopper.routing.util.DefaultEdgeFilter;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.CHGraph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.storage.*;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -41,9 +38,9 @@
 
 import java.util.*;
 
+import static com.graphhopper.routing.AbstractRoutingAlgorithmTester.updateDistancesFor;
 import static com.graphhopper.routing.ch.CHParameters.*;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
+import static org.junit.Assert.*;
 
 /**
  * Here we test if Contraction Hierarchies work with turn costs, i.e. we first contract the graph and then run
@@ -64,6 +61,7 @@
     private TurnCostExtension turnCostExtension;
     private TurnWeighting turnWeighting;
     private CHGraph chGraph;
+    private boolean checkStrict;
 
     @Rule
     public RepeatRule repeatRule = new RepeatRule();
@@ -79,6 +77,7 @@ public void init() {
         turnCostExtension = (TurnCostExtension) graph.getExtension();
         turnWeighting = new TurnWeighting(weighting, turnCostExtension);
         chGraph = graph.getGraph(CHGraph.class);
+        checkStrict = true;
     }
 
     @Test
@@ -90,17 +89,9 @@ public void testFindPath_randomContractionOrder_linear() {
         graph.edge(0, 3, 1, true);
         graph.edge(3, 4, 3, true);
         graph.freeze();
-
         addTurnCost(2, 1, 0, 2);
         addTurnCost(0, 3, 4, 4);
-
-        final IntArrayList expectedPath = IntArrayList.from(2, 1, 0, 3, 4);
-        final int expectedWeight = 15;
-
-        int from = 2;
-        int to = 4;
-
-        checkPathUsingRandomContractionOrder(expectedPath, expectedWeight, from, to);
+        checkPathUsingRandomContractionOrder(IntArrayList.from(2, 1, 0, 3, 4), 9, 6, 2, 4);
     }
 
     @Test
@@ -176,6 +167,7 @@ public void testFindPath_multipleInOutEdges_turnReplacementDifference() {
 
         RoutingAlgorithmFactory factory = prepareCH(Arrays.asList(6, 0, 1, 2, 8, 9, 10, 5, 3, 4, 7));
         // run queries for all cases (target/source edge possibly restricted/has costs)
+        checkStrict = false;
         compareCHQueryWithDijkstra(factory, 2, 10);
         compareCHQueryWithDijkstra(factory, 1, 10);
         compareCHQueryWithDijkstra(factory, 2, 9);
@@ -240,10 +232,7 @@ public void testFindPath_randomContractionOrder_simpleLoop() {
         addTurnCost(4, 2, 3, 4);
         addTurnCost(3, 2, 4, 2);
 
-        final IntArrayList expectedPath = IntArrayList.from(0, 4, 3, 2, 4, 1);
-        final int expectedWeight = 9;
-
-        checkPathUsingRandomContractionOrder(expectedPath, expectedWeight, 0, 1);
+        checkPathUsingRandomContractionOrder(IntArrayList.from(0, 4, 3, 2, 4, 1), 7, 2, 0, 1);
     }
 
     @Test
@@ -271,7 +260,7 @@ public void testFindPath_randomContractionOrder_singleDirectedLoop() {
         final int roadCosts = 12;
         final int turnCosts = 2;
 
-        checkPathUsingRandomContractionOrder(expectedPath, roadCosts + turnCosts, 3, 4);
+        checkPathUsingRandomContractionOrder(expectedPath, roadCosts, turnCosts, 3, 4);
     }
 
     @Test
@@ -300,7 +289,7 @@ public void testFindPath_randomContractionOrder_singleLoop() {
         final int roadCosts = 10;
         final int turnCosts = 2;
 
-        checkPathUsingRandomContractionOrder(expectedPath, roadCosts + turnCosts, 0, 6);
+        checkPathUsingRandomContractionOrder(expectedPath, roadCosts, turnCosts, 0, 6);
     }
 
     @Test
@@ -356,7 +345,7 @@ public void testFindPath_randomContractionOrder_singleLoopWithNoise() {
         final int roadCosts = 15;
         final int turnCosts = 2;
 
-        checkPathUsingRandomContractionOrder(expectedPath, roadCosts + turnCosts, 0, 14);
+        checkPathUsingRandomContractionOrder(expectedPath, roadCosts, turnCosts, 0, 14);
     }
 
     @Test
@@ -450,7 +439,7 @@ public void testFindPath_randomContractionOrder_complicatedGraphAndPath() {
         final int roadCosts = 49;
         final int turnCosts = 4;
 
-        checkPathUsingRandomContractionOrder(expectedPath, roadCosts + turnCosts, 0, 26);
+        checkPathUsingRandomContractionOrder(expectedPath, roadCosts, turnCosts, 0, 26);
     }
 
     @Test
@@ -472,7 +461,7 @@ public void testFindPath_pTurn_uTurnAtContractedNode() {
         addRestriction(5, 6, 1);
 
         final IntArrayList expectedPath = IntArrayList.from(5, 6, 4, 0, 3, 2, 4, 6, 1);
-        checkPath(expectedPath, 8, 5, 1, Arrays.asList(0, 1, 2, 3, 4, 5, 6));
+        checkPath(expectedPath, 8, 0, 5, 1, Arrays.asList(0, 1, 2, 3, 4, 5, 6));
     }
 
 
@@ -497,7 +486,7 @@ public void testFindPath_pTurn_uTurnAtContractedNode_twoShortcutsInAndOut() {
         addRestriction(5, 6, 7);
 
         final IntArrayList expectedPath = IntArrayList.from(5, 6, 1, 4, 0, 3, 2, 4, 1, 6, 7);
-        checkPath(expectedPath, 10, 5, 7, Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7));
+        checkPath(expectedPath, 10, 0, 5, 7, Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7));
     }
 
     @Test
@@ -580,6 +569,7 @@ public void testFindPath_highlyConnectedGraph_compareWithDijkstra() {
         }
 
         List<Integer> contractionOrder = getRandomIntegerSequence(chGraph.getNodes(), rnd);
+        checkStrict = false;
         compareCHWithDijkstra(numQueries, contractionOrder);
     }
 
@@ -610,6 +600,48 @@ public void testFindPath_bug2() {
         compareCHWithDijkstra(1000, contractionOrder);
     }
 
+    @Test
+    public void testFindPath_loop() {
+        //             3
+        //            / \
+        //           1   2
+        //            \ /
+        // 0 - 7 - 8 - 4 - 6 - 5
+        graph.edge(0, 7, 1, false);
+        graph.edge(7, 8, 1, false);
+        graph.edge(8, 4, 1, false);
+        graph.edge(4, 1, 1, false);
+        graph.edge(1, 3, 1, false);
+        graph.edge(3, 2, 1, false);
+        graph.edge(2, 4, 1, false);
+        graph.edge(4, 6, 1, false);
+        graph.edge(6, 5, 1, false);
+        addRestriction(8, 4, 6);
+        graph.freeze();
+
+        RoutingAlgorithmFactory factory = prepareCH(Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8));
+        compareCHQueryWithDijkstra(factory, 0, 5);
+    }
+
+    @Test
+    public void testFindPath_calcTurnCostTime() {
+        // here there will be a shortcut from 1 to 4 and when the path is unpacked it is important that
+        // the turn costs are included at node 1 even though the unpacked original edge 1-0 might be in the
+        // reverted state
+        // 2-1--3
+        //   |  |
+        //   0->4
+        EdgeIteratorState edge0 = graph.edge(1, 2, 1, true);
+        EdgeIteratorState edge1 = graph.edge(0, 4, 1, false);
+        EdgeIteratorState edge2 = graph.edge(4, 3, 1, true);
+        EdgeIteratorState edge3 = graph.edge(1, 3, 1, true);
+        EdgeIteratorState edge4 = graph.edge(1, 0, 1, true);
+        addTurnCost(edge0, edge4, 1, 8);
+        addRestriction(edge0, edge3, 1);
+        graph.freeze();
+        checkPath(IntArrayList.from(2, 1, 0, 4), 3, 8, 2, 4, Arrays.asList(2, 0, 1, 3, 4));
+    }
+
     @Test
     public void testFindPath_loopsMustAlwaysBeAccepted() {
         //     ---
@@ -623,7 +655,7 @@ public void testFindPath_loopsMustAlwaysBeAccepted() {
         addRestriction(edge0, edge2, 1);
         graph.freeze();
         final IntArrayList expectedPath = IntArrayList.from(0, 1, 1, 2, 3);
-        checkPath(expectedPath, 5, 0, 3, Arrays.asList(0, 2, 1, 3));
+        checkPath(expectedPath, 4, 1, 0, 3, Arrays.asList(0, 2, 1, 3));
     }
 
     @Test
@@ -655,7 +687,7 @@ public void testFindPath_compareWithDijkstra_zeroWeightLoops() {
         graph.freeze();
         IntArrayList expectedPath = IntArrayList.from(0, 1, 2, 3, 4);
         List<Integer> contractionOrder = Arrays.asList(2, 0, 4, 1, 3);
-        checkPath(expectedPath, 4, 0, 4, contractionOrder);
+        checkPath(expectedPath, 4, 0, 0, 4, contractionOrder);
     }
 
     @Test
@@ -677,7 +709,236 @@ public void testFindPath_compareWithDijkstra_zeroWeightLoops_withTurnRestriction
         graph.freeze();
         IntArrayList expectedPath = IntArrayList.from(0, 1, 2, 3, 3, 4);
         List<Integer> contractionOrder = Arrays.asList(2, 0, 4, 1, 3);
-        checkPath(expectedPath, 8, 0, 4, contractionOrder);
+        checkPath(expectedPath, 4, 4, 0, 4, contractionOrder);
+    }
+
+    @Test
+    public void testFindPath_oneWayLoop() {
+        //     o
+        // 0-1-2-3-4
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        addRestriction(1, 2, 3);
+        graph.freeze();
+        RoutingAlgorithmFactory pch = automaticPrepareCH();
+        compareCHQueryWithDijkstra(pch, 0, 3);
+        compareCHQueryWithDijkstra(pch, 1, 4);
+        automaticCompareCHWithDijkstra(100);
+    }
+
+    @Test
+    public void testFindPath_loopEdge() {
+        // 1-0
+        // | |
+        // 4-2o
+        graph.edge(1, 0, 802.964000, false);
+        graph.edge(1, 4, 615.195000, true);
+        graph.edge(2, 2, 181.788000, true);
+        graph.edge(0, 2, 191.996000, true);
+        graph.edge(2, 4, 527.821000, false);
+        addRestriction(0, 2, 4);
+        addTurnCost(0, 2, 2, 3);
+        addTurnCost(2, 2, 4, 4);
+        graph.freeze();
+        RoutingAlgorithmFactory pch = automaticPrepareCH();
+        compareCHQueryWithDijkstra(pch, 0, 4);
+    }
+
+    @Test
+    public void test_issue1593_full() {
+        //      6   5
+        //   1<-x-4-x-3
+        //  ||    |
+        //  |x7   x8
+        //  ||   /
+        //   2---
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 49.407117, 9.701306);
+        na.setNode(1, 49.406914, 9.703393);
+        na.setNode(2, 49.404004, 9.709110);
+        na.setNode(3, 49.400160, 9.708787);
+        na.setNode(4, 49.400883, 9.706347);
+        EdgeIteratorState edge0 = graph.edge(4, 3, 194.063000, true);
+        EdgeIteratorState edge1 = graph.edge(1, 2, 525.106000, true);
+        EdgeIteratorState edge2 = graph.edge(1, 2, 525.106000, true);
+        EdgeIteratorState edge3 = graph.edge(4, 1, 703.778000, false);
+        EdgeIteratorState edge4 = graph.edge(2, 4, 400.509000, true);
+        // cannot go 4-2-1 and 1-2-4 (at least when using edge1, there is still edge2!)
+        addRestriction(edge4, edge1, 2);
+        addRestriction(edge1, edge4, 2);
+        // cannot go 3-4-1
+        addRestriction(edge0, edge3, 4);
+        graph.freeze();
+        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
+        index.prepareIndex();
+        List<GHPoint> points = Arrays.asList(
+                // 8 (on edge4)
+                new GHPoint(49.401669187194116, 9.706821649608745),
+                // 5 (on edge0)
+                new GHPoint(49.40056349818417, 9.70767186472369),
+                // 7 (on edge2)
+                new GHPoint(49.406580835146556, 9.704665738628218),
+                // 6 (on edge3)
+                new GHPoint(49.40107534698834, 9.702248694088528)
+        );
+
+        List<QueryResult> queryResults = new ArrayList<>(points.size());
+        for (GHPoint point : points) {
+            queryResults.add(index.findClosest(point.getLat(), point.getLon(), EdgeFilter.ALL_EDGES));
+        }
+
+        RoutingAlgorithmFactory pch = automaticPrepareCH();
+        QueryGraph queryGraph = new QueryGraph(chGraph);
+        queryGraph.lookup(queryResults);
+        RoutingAlgorithm chAlgo = pch.createAlgo(queryGraph, AlgorithmOptions.start()
+                .traversalMode(TraversalMode.EDGE_BASED_2DIR)
+                .build());
+        Path path = chAlgo.calcPath(5, 6);
+        // there should not be a path from 5 to 6, because first we cannot go directly 5-4-6, so we need to go left
+        // to 8. then at 2 we cannot go on edge 1 because of another turn restriction, but we can go on edge 2 so we
+        // travel via the virtual node 7 to node 1. From there we cannot go to 6 because of the one-way so we go back
+        // to node 2 (no u-turn because of the duplicate edge) on edge1. And this is were the journey ends: we cannot
+        // go to 8 because of the turn restriction from edge1 to edge4 -> there should not be a path!
+        assertFalse("there should not be a path, but found: " + path.calcNodes(), path.isFound());
+    }
+
+    @Test
+    public void test_issue_1593_simple() {
+        // 1
+        // |
+        // 3-0-x-5-4
+        // |
+        // 2
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(1, 0.2, 0.0);
+        na.setNode(3, 0.1, 0.0);
+        na.setNode(2, 0.0, 0.0);
+        na.setNode(0, 0.1, 0.1);
+        na.setNode(5, 0.1, 0.2);
+        na.setNode(4, 0.1, 0.3);
+        EdgeIteratorState edge0 = graph.edge(3, 1, 10, true);
+        EdgeIteratorState edge1 = graph.edge(2, 3, 10, true);
+        graph.edge(3, 0, 10, true);
+        graph.edge(0, 5, 10, true);
+        graph.edge(5, 4, 10, true);
+        // cannot go, 2-3-1
+        addRestriction(edge1, edge0, 3);
+        graph.freeze();
+        RoutingAlgorithmFactory pch = prepareCH(Arrays.asList(0, 1, 2, 3, 4, 5));
+        assertEquals(5, chGraph.getOriginalEdges());
+        assertEquals("expected two shortcuts: 3->5 and 5->3", 7, chGraph.getEdges());
+        // there should be no path from 2 to 1, because of the turn restriction and because u-turns are not allowed
+        assertFalse(findPathUsingDijkstra(2, 1).isFound());
+        compareCHQueryWithDijkstra(pch, 2, 1);
+
+        // we have to pay attention when there are virtual nodes: turning from the shortcut 3-5 onto the
+        // virtual edge 5-x should be forbidden.
+        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
+        index.prepareIndex();
+        QueryResult qr = index.findClosest(0.1, 0.15, EdgeFilter.ALL_EDGES);
+        QueryGraph queryGraph = new QueryGraph(chGraph);
+        queryGraph.lookup(Collections.singletonList(qr));
+        assertEquals("expected one virtual node", 1, queryGraph.getNodes() - chGraph.getNodes());
+        RoutingAlgorithm chAlgo = pch.createAlgo(queryGraph, AlgorithmOptions.start()
+                .traversalMode(TraversalMode.EDGE_BASED_2DIR)
+                .build());
+        Path path = chAlgo.calcPath(2, 1);
+        assertFalse("no path should be found, but found " + path.calcNodes(), path.isFound());
+    }
+
+    @Test
+    public void test_issue_1623_query_graph_cache() {
+        // 4-2->5-3
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 49.408550, 9.701805);
+        na.setNode(1, 49.405988, 9.706111);
+        na.setNode(2, 49.400772, 9.706245);
+        na.setNode(3, 49.403167, 9.704774);
+        na.setNode(4, 49.405817, 9.704301);
+        na.setNode(5, 49.402488, 9.707799);
+        graph.edge(2, 5, 222.771000, false);
+        graph.edge(4, 2, 583.496000, true);
+        graph.edge(3, 5, 231.495000, true);
+        graph.freeze();
+
+        RoutingAlgorithmFactory pch = automaticPrepareCH();
+        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
+        index.prepareIndex();
+        QueryResult qr1 = index.findClosest(49.400772, 9.706245, EdgeFilter.ALL_EDGES);
+        QueryResult qr2 = index.findClosest(49.403167, 9.704774, EdgeFilter.ALL_EDGES);
+        QueryGraph queryGraph = new QueryGraph(chGraph);
+
+        // before fixing #1623 this test only worked for a disabled edge explorer cache
+        queryGraph.setUseEdgeExplorerCache(true);
+
+        queryGraph.lookup(Arrays.asList(qr1, qr2));
+        assertEquals(2, qr1.getClosestNode());
+        assertEquals(3, qr2.getClosestNode());
+        RoutingAlgorithm chAlgo = pch.createAlgo(queryGraph, AlgorithmOptions.start()
+                .traversalMode(TraversalMode.EDGE_BASED_2DIR)
+                .build());
+        Path path = chAlgo.calcPath(2, 3);
+        assertTrue("no path found", path.isFound());
+        assertEquals(IntArrayList.from(2, 5, 3), path.calcNodes());
+        assertEquals(454.266, path.getDistance(), 1.e-1);
+    }
+
+    @Test
+    public void testRouteViaVirtualNode() {
+        //   3
+        // 0-x-1-2
+        graph.edge(0, 1, 0, false);
+        graph.edge(1, 2, 0, false);
+        updateDistancesFor(graph, 0, 0.00, 0.00);
+        updateDistancesFor(graph, 1, 0.02, 0.02);
+        updateDistancesFor(graph, 2, 0.03, 0.03);
+        graph.freeze();
+        RoutingAlgorithmFactory pch = automaticPrepareCH();
+        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
+        index.prepareIndex();
+        QueryResult qr = index.findClosest(0.01, 0.01, EdgeFilter.ALL_EDGES);
+        QueryGraph queryGraph = new QueryGraph(chGraph);
+        queryGraph.lookup(Collections.singletonList(qr));
+        assertEquals(3, qr.getClosestNode());
+        assertEquals(0, qr.getClosestEdge().getEdge());
+        RoutingAlgorithm chAlgo = pch.createAlgo(queryGraph, AlgorithmOptions.start()
+                .traversalMode(TraversalMode.EDGE_BASED_2DIR)
+                .build());
+        Path path = chAlgo.calcPath(0, 2);
+        assertTrue("it should be possible to route via a virtual node, but no path found", path.isFound());
+        assertEquals(IntArrayList.from(0, 3, 1, 2), path.calcNodes());
+        assertEquals(Helper.DIST_PLANE.calcDist(0.00, 0.00, 0.03, 0.03), path.getDistance(), 1.e-1);
+    }
+
+    @Test
+    public void testRouteViaVirtualNode_withAlternative() {
+        //   3
+        // 0-x-1
+        //  \  |
+        //   \-2
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 2, 1, true);
+        graph.edge(2, 0, 1, true);
+        updateDistancesFor(graph, 0, 0.01, 0.00);
+        updateDistancesFor(graph, 1, 0.01, 0.02);
+        updateDistancesFor(graph, 2, 0.00, 0.02);
+        graph.freeze();
+        RoutingAlgorithmFactory pch = automaticPrepareCH();
+        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
+        index.prepareIndex();
+        QueryResult qr = index.findClosest(0.01, 0.01, EdgeFilter.ALL_EDGES);
+        QueryGraph queryGraph = new QueryGraph(chGraph);
+        queryGraph.lookup(Collections.singletonList(qr));
+        assertEquals(3, qr.getClosestNode());
+        assertEquals(0, qr.getClosestEdge().getEdge());
+        RoutingAlgorithm chAlgo = pch.createAlgo(queryGraph, AlgorithmOptions.start()
+                .traversalMode(TraversalMode.EDGE_BASED_2DIR)
+                .build());
+        Path path = chAlgo.calcPath(1, 0);
+        assertEquals(IntArrayList.from(1, 3, 0), path.calcNodes());
     }
 
     /**
@@ -692,9 +953,10 @@ public void testFindPath_random_compareWithDijkstra() {
         LOGGER.info("Seed used to generate graph: {}", seed);
         final Random rnd = new Random(seed);
         // for larger graphs preparation takes much longer the higher the degree is!
-        GHUtility.buildRandomGraph(graph, seed, 20, 3.0, true, true, 0.9, 0.8);
+        GHUtility.buildRandomGraph(graph, rnd, 20, 3.0, true, true, encoder.getAverageSpeedEnc(), 0.7, 0.9, 0.8);
         GHUtility.addRandomTurnCosts(graph, seed, encoder, maxCost, turnCostExtension);
         graph.freeze();
+        checkStrict = false;
         List<Integer> contractionOrder = getRandomIntegerSequence(chGraph.getNodes(), rnd);
         compareCHWithDijkstra(100, contractionOrder);
     }
@@ -707,9 +969,10 @@ public void testFindPath_random_compareWithDijkstra() {
     public void testFindPath_heuristic_compareWithDijkstra() {
         long seed = System.nanoTime();
         LOGGER.info("Seed used to generate graph: {}", seed);
-        GHUtility.buildRandomGraph(graph, seed, 20, 3.0, true, true, 0.9, 0.8);
+        GHUtility.buildRandomGraph(graph, new Random(seed), 20, 3.0, true, true, encoder.getAverageSpeedEnc(), 0.7, 0.9, 0.8);
         GHUtility.addRandomTurnCosts(graph, seed, encoder, maxCost, turnCostExtension);
         graph.freeze();
+        checkStrict = false;
         automaticCompareCHWithDijkstra(100);
     }
 
@@ -722,26 +985,36 @@ private double nextDist(int maxDist, Random rnd) {
         return rnd.nextDouble() * maxDist;
     }
 
-    private void checkPathUsingRandomContractionOrder(IntArrayList expectedPath, int expectedWeight, int from, int to) {
+    private void checkPathUsingRandomContractionOrder(IntArrayList expectedPath, int expectedWeight, int expectedTurnCosts, int from, int to) {
         List<Integer> contractionOrder = getRandomIntegerSequence(chGraph.getNodes());
-        checkPath(expectedPath, expectedWeight, from, to, contractionOrder);
+        checkPath(expectedPath, expectedWeight, expectedTurnCosts, from, to, contractionOrder);
     }
 
-    private void checkPath(IntArrayList expectedPath, int expectedWeight, int from, int to, List<Integer> contractionOrder) {
-        checkPathUsingDijkstra(expectedPath, expectedWeight, from, to);
-        checkPathUsingCH(expectedPath, expectedWeight, from, to, contractionOrder);
+    private void checkPath(IntArrayList expectedPath, int expectedEdgeWeight, int expectedTurnCosts, int from, int to, List<Integer> contractionOrder) {
+        checkPathUsingDijkstra(expectedPath, expectedEdgeWeight, expectedTurnCosts, from, to);
+        checkPathUsingCH(expectedPath, expectedEdgeWeight, expectedTurnCosts, from, to, contractionOrder);
     }
 
-    private void checkPathUsingDijkstra(IntArrayList expectedPath, int expectedWeight, int from, int to) {
+    private void checkPathUsingDijkstra(IntArrayList expectedPath, int expectedEdgeWeight, int expectedTurnCosts, int from, int to) {
         Path dijkstraPath = findPathUsingDijkstra(from, to);
+        int expectedWeight = expectedEdgeWeight + expectedTurnCosts;
+        int expectedDistance = expectedEdgeWeight;
+        int expectedTime = expectedEdgeWeight * 60 + expectedTurnCosts * 1000;
         assertEquals("Normal Dijkstra did not find expected path.", expectedPath, dijkstraPath.calcNodes());
         assertEquals("Normal Dijkstra did not calculate expected weight.", expectedWeight, dijkstraPath.getWeight(), 1.e-6);
+        assertEquals("Normal Dijkstra did not calculate expected distance.", expectedDistance, dijkstraPath.getDistance(), 1.e-6);
+        assertEquals("Normal Dijkstra did not calculate expected time.", expectedTime, dijkstraPath.getTime(), 1.e-6);
     }
 
-    private void checkPathUsingCH(IntArrayList expectedPath, int expectedWeight, int from, int to, List<Integer> contractionOrder) {
+    private void checkPathUsingCH(IntArrayList expectedPath, int expectedEdgeWeight, int expectedTurnCosts, int from, int to, List<Integer> contractionOrder) {
         Path chPath = findPathUsingCH(from, to, contractionOrder);
+        int expectedWeight = expectedEdgeWeight + expectedTurnCosts;
+        int expectedDistance = expectedEdgeWeight;
+        int expectedTime = expectedEdgeWeight * 60 + expectedTurnCosts * 1000;
         assertEquals("Contraction Hierarchies did not find expected path. contraction order=" + contractionOrder, expectedPath, chPath.calcNodes());
         assertEquals("Contraction Hierarchies did not calculate expected weight.", expectedWeight, chPath.getWeight(), 1.e-6);
+        assertEquals("Contraction Hierarchies did not calculate expected distance.", expectedDistance, chPath.getDistance(), 1.e-6);
+        assertEquals("Contraction Hierarchies did not calculate expected time.", expectedTime, chPath.getTime(), 1.e-6);
     }
 
     private Path findPathUsingDijkstra(int from, int to) {
@@ -812,15 +1085,20 @@ private void compareCHQueryWithDijkstra(RoutingAlgorithmFactory factory, int fro
         Path dijkstraPath = findPathUsingDijkstra(from, to);
         RoutingAlgorithm chAlgo = factory.createAlgo(chGraph, AlgorithmOptions.start().build());
         Path chPath = chAlgo.calcPath(from, to);
-        // todo: for increased precision some tests fail. this is because the weight is truncated, not rounded
-        // when storing shortcut edges. 
         boolean algosDisagree = Math.abs(dijkstraPath.getWeight() - chPath.getWeight()) > 1.e-2;
+        if (checkStrict) {
+            algosDisagree = algosDisagree
+                    || Math.abs(dijkstraPath.getDistance() - chPath.getDistance()) > 1.e-2
+                    || Math.abs(dijkstraPath.getTime() - chPath.getTime()) > 1;
+        }
         if (algosDisagree) {
             System.out.println("Graph that produced error:");
             GHUtility.printGraphForUnitTest(graph, encoder);
             fail("Dijkstra and CH did not find equal shortest paths for route from " + from + " to " + to + "\n" +
-                    " dijkstra: weight: " + dijkstraPath.getWeight() + ", nodes: " + dijkstraPath.calcNodes() + "\n" +
-                    "       ch: weight: " + chPath.getWeight() + ", nodes: " + chPath.calcNodes());
+                    " dijkstra: weight: " + dijkstraPath.getWeight() + ", distance: " + dijkstraPath.getDistance() +
+                    ", time: " + dijkstraPath.getTime() + ", nodes: " + dijkstraPath.calcNodes() + "\n" +
+                    "       ch: weight: " + chPath.getWeight() + ", distance: " + chPath.getDistance() +
+                    ", time: " + chPath.getTime() + ", nodes: " + chPath.calcNodes());
         }
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java b/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
index 8d09521584..14f388c56d 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
@@ -386,7 +386,7 @@ public void testNodeContraction_shortcutWeightRounding() {
     @Test
     public void testNodeContraction_preventUnnecessaryShortcutWithLoop() {
         // there should not be shortcuts where one of the skipped edges is a loop at the node to be contracted,
-        // see also #1581
+        // see also #1583
         CarFlagEncoder encoder = new CarFlagEncoder();
         EncodingManager encodingManager = EncodingManager.create(encoder);
         Weighting weighting = new FastestWeighting(encoder);
diff --git a/core/src/test/java/com/graphhopper/routing/ch/Path4CHTest.java b/core/src/test/java/com/graphhopper/routing/ch/Path4CHTest.java
new file mode 100644
index 0000000000..68b1927fe8
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/ch/Path4CHTest.java
@@ -0,0 +1,166 @@
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.routing.AbstractBidirectionEdgeCHNoSOD;
+import com.graphhopper.routing.DijkstraBidirectionEdgeCHNoSOD;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.LevelEdgeFilter;
+import com.graphhopper.routing.util.MotorcycleFlagEncoder;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class Path4CHTest {
+    private final int maxTurnCosts = 10;
+    private GraphHopperStorage graph;
+    private CHGraph chGraph;
+    private FlagEncoder encoder;
+    private Weighting weighting;
+    private TurnCostExtension turnCostExtension;
+
+    @Before
+    public void init() {
+        encoder = new MotorcycleFlagEncoder(5, 5, maxTurnCosts);
+        EncodingManager em = EncodingManager.create(encoder);
+        weighting = new FastestWeighting(encoder);
+        graph = new GraphBuilder(em).setEdgeBasedCH(true).setCHGraph(weighting).create();
+        chGraph = graph.getGraph(CHGraph.class);
+        turnCostExtension = (TurnCostExtension) graph.getExtension();
+    }
+
+    @Test
+    public void shortcut_chain() {
+        // 0   2   4   6   8
+        //  \ / \ / \ / \ /
+        //   1   3   5   7
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.edge(4, 5, 1, false);
+        graph.edge(5, 6, 1, false);
+        graph.edge(6, 7, 1, false);
+        graph.edge(7, 8, 1, false);
+        graph.freeze();
+        addTurnCost(1, 2, 3, 4);
+        addTurnCost(3, 4, 5, 2);
+        addTurnCost(5, 6, 7, 3);
+        // we 'contract' the graph such that only a few shortcuts are created and that the fwd/bwd searches for the
+        // 0-8 query meet at node 4 (make sure we include all three cases where turn cost times might come to play:
+        // fwd/bwd search and meeting point)
+        addShortcut(0, 2, 0, 1, 0, 1, 0.12, 2, 0);
+        addShortcut(2, 4, 2, 3, 2, 3, 0.12, 2, 0);
+        addShortcut(4, 6, 4, 5, 4, 5, 0.12, 2, 0);
+        addShortcut(6, 8, 6, 7, 6, 7, 0.12, 2, 0);
+        setCHOrder(1, 3, 5, 7, 0, 8, 2, 6, 4);
+
+        // going from 0 to 8 will create shortest path tree entries that follow the shortcuts.
+        // it is important that the original edge ids are used to calculate the turn costs.
+        checkPath(0, 8, 0.48, 8, 9);
+    }
+
+    private void setCHOrder(int... nodeIds) {
+        for (int i = 0; i < nodeIds.length; i++) {
+            chGraph.setLevel(nodeIds[i], i);
+        }
+    }
+
+    @Test
+    public void paths_different_fwd_bwd_speeds() {
+        //   5 3 2 1 4    turn costs ->
+        // 0-1-2-3-4-5-6
+        //   0 1 4 2 3    turn costs <-
+        DecimalEncodedValue speedEnc = encoder.getAverageSpeedEnc();
+        double fwdSpeed = 60;
+        double bwdSpeed = 30;
+        EdgeIteratorState edge0 = graph.edge(0, 1, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge1 = graph.edge(1, 2, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge2 = graph.edge(2, 3, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge3 = graph.edge(3, 4, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge4 = graph.edge(4, 5, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge5 = graph.edge(5, 6, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.freeze();
+
+        // turn costs ->
+        addTurnCost(edge0, edge1, 1, 5);
+        addTurnCost(edge1, edge2, 2, 3);
+        addTurnCost(edge2, edge3, 3, 2);
+        addTurnCost(edge3, edge4, 4, 1);
+        addTurnCost(edge4, edge5, 5, 4);
+        // turn costs <-
+        addTurnCost(edge5, edge4, 5, 3);
+        addTurnCost(edge4, edge3, 4, 2);
+        addTurnCost(edge3, edge2, 3, 4);
+        addTurnCost(edge2, edge1, 2, 1);
+        addTurnCost(edge1, edge0, 1, 0);
+
+        // shortcuts ->
+        addShortcut(0, 2, 0, 1, 0, 1, 0.12, 2, 5);
+        addShortcut(2, 4, 2, 3, 2, 3, 0.12, 2, 2);
+        addShortcut(4, 6, 4, 5, 4, 5, 0.12, 2, 4);
+        addShortcut(2, 6, 2, 5, 7, 8, 0.24, 4, 7);
+        addShortcut(0, 6, 0, 5, 6, 9, 0.36, 6, 12);
+
+        // shortcuts <-
+        addShortcut(6, 4, 5, 4, 5, 4, 0.24, 2, 3);
+        addShortcut(4, 2, 3, 2, 3, 2, 0.24, 2, 4);
+        addShortcut(2, 0, 1, 0, 1, 0, 0.24, 2, 0);
+        addShortcut(6, 2, 5, 2, 11, 12, 0.48, 4, 9);
+        addShortcut(6, 0, 5, 0, 14, 13, 0.60, 6, 10);
+
+        // strictly it would be cleaner to manually build the SPT and extract the path, but for convenience we
+        // use the routing algo to build it
+        checkPath(0, 6, 0.36, 6, 15);
+        checkPath(6, 0, 0.72, 6, 10);
+        checkPath(1, 3, 0.12, 2, 3);
+        checkPath(3, 1, 0.24, 2, 1);
+        checkPath(1, 5, 0.24, 4, 6);
+        checkPath(5, 1, 0.48, 4, 7);
+    }
+
+    private void addTurnCost(int from, int via, int to, int cost) {
+        addTurnCost(getEdge(from, via), getEdge(via, to), via, cost);
+    }
+
+    private void addTurnCost(EdgeIteratorState inEdge, EdgeIteratorState outEdge, int viaNode, int cost) {
+        turnCostExtension.addTurnInfo(inEdge.getEdge(), viaNode, outEdge.getEdge(), encoder.getTurnFlags(false, cost));
+    }
+
+    private EdgeIteratorState getEdge(int from, int to) {
+        return GHUtility.getEdge(graph, from, to);
+    }
+
+    private void addShortcut(int from, int to, int origFirst, int origLast, int skip1, int skip2, double edgeWeight, double distance, int turnCost) {
+        double weight = edgeWeight + turnCost * 1000;
+        chGraph.shortcutEdgeBased(from, to, PrepareEncoder.getScFwdDir(), weight, distance, skip1, skip2, origFirst, origLast);
+    }
+
+    private void checkPath(int from, int to, double edgeWeight, int distance, int turnCostTime) {
+        double expectedWeight = (edgeWeight + turnCostTime);
+        Path path = createAlgo().calcPath(from, to);
+        assertEquals("wrong weight", expectedWeight, path.getWeight(), 1.e-3);
+        assertEquals("wrong distance", distance, path.getDistance(), 1.e-3);
+        assertEquals("wrong time", expectedWeight * 1000, path.getTime(), 1.e-3);
+    }
+
+    private AbstractBidirectionEdgeCHNoSOD createAlgo() {
+        TurnWeighting chTurnWeighting = new TurnWeighting(new PreparationWeighting(weighting), turnCostExtension);
+        CHGraph lg = graph.getGraph(CHGraph.class, weighting);
+        AbstractBidirectionEdgeCHNoSOD algo = new DijkstraBidirectionEdgeCHNoSOD(lg, chTurnWeighting);
+        algo.setEdgeFilter(new LevelEdgeFilter(lg));
+        return algo;
+    }
+
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index 15ebdc3798..17f0472498 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -412,7 +412,7 @@ public int getNumNodes() {
                 });
         prepare.doWork();
         CHEdgeExplorer explorer = lg.createEdgeExplorer();
-        // shortcuts (and edges) leading to or coming from higher level nodes should be disconnected
+        // shortcuts (and edges) leading to or coming from lower level nodes should be disconnected
         // so far we are only disconnecting shortcuts however, see comments in CHGraphImpl.
         assertEquals(buildSet(7, 8, 0, 1, 2, 3), GHUtility.getNeighbors(explorer.setBaseNode(6)));
         assertEquals(buildSet(6, 0), GHUtility.getNeighbors(explorer.setBaseNode(4)));
@@ -427,22 +427,27 @@ public int getNumNodes() {
 
     @Test
     public void testStallOnDemandViaVirtuaNode_issue1574() {
-        // this test reproduces the issue that appeared in issue1574 and the problem is very intricate
-        // the problem is a combination of all these things:
+        // this test reproduces the issue that appeared in issue1574
+        // the problem is very intricate and a combination of all these things:
         // * contraction hierarchies
         // * stall-on-demand (without sod there is no problem, at least in this test)
         // * shortcuts weight rounding
         // * via nodes/virtual edges and the associated weight precision (without virtual nodes between source and target
         //   there is no problem, but this can happen for via routes
         // * the fact that the LevelEdgeFilter always accepts virtual nodes
+        // here we wil construct a special case where a connection is not found without the fix in #1574.
 
         // use fastest weighting in this test to be able to fine-tune some weights via the speed (see below)
         Weighting fastestWeighting = new FastestWeighting(carEncoder);
         final GraphHopperStorage g = createGHStorage(fastestWeighting);
         CHGraph lg = g.getGraph(CHGraph.class);
         // the following graph reproduces the issue. note that we will use the node ids as ch levels, so there will
-        // be a shortcuts from 1->3 and 2->3 (not the other way around, because of shortcut disconnections!)
-        // since the shortest path is strictly upward only the forward search runs here, this is also important!
+        // be a shortcut 3->2 visible at node 2 and another one 3->4 visible at node 3.
+        // we will fine-tune the edge-speeds such that without the fix node 4 will be stalled and node 5 will not get
+        // discovered. consequently, no path will be found, because only the forward search runs (from 0 to 7 the
+        // shortest path is strictly upward). node 4 is only stalled when node 2 gets stalled before, which in turn will
+        // happen due to the the virtual node between 3 and 1.
+        //
         // start 0 - 3 - x - 1 - 2
         //             \         |
         //               sc ---- 4 - 5 - 6 - 7 finish
@@ -463,16 +468,19 @@ public void testStallOnDemandViaVirtuaNode_issue1574() {
         updateDistancesFor(g, 7, 0.000, 0.0006);
 
         // we use the speed to fine tune some weights:
-        // the weight of edge 3-1 must be such that node 2 gets stalled in the forward search via the incoming shortcut
-        // at node 2 coming from 3. this happens because due to the virtual node x between 3 and 1, the spt entries
-        // calculated on the query graph (using the virtual edges) use different floating point rounding / arithmetics.
+        // the weight of edge 3-1 is chosen such that node 2 gets stalled in the forward search via the incoming shortcut
+        // at node 2 coming from 3. this happens because due to the virtual node x between 3 and 1, the weight of the
+        // spt entry at 2 is different to the sum of the weights of the spt entry at node 3 and the shortcut edge. this
+        // is due to different floating point rounding arithmetic of shortcuts and virtual edges on the query graph.
         edge31.set(carEncoder.getAverageSpeedEnc(), 22);
-
-        // just stalling node 2 due to the differently calculated weights for the virtual edges would be no problem, yet
-        // because the shortcut 3-4 still finds node 4. however node 4 might also get stalled via node 2. 'normally' this
-        // would not happen, because node 2 would not even be explored in the forward search, but because of the virtual
-        // node the strict upward search is modified and goes like 0-3-1-2 (i.e. it finds node 2).
-        // so no we fine tune the weight for 2-4 such that node 4 gets also stalled
+        edge31.setReverse(carEncoder.getAverageSpeedEnc(), 22);
+
+        // just stalling node 2 alone would not lead to connection not found, because the shortcut 3-4 still finds node
+        // 4. however, we can choose the weight of edge 2-4 such that node 4 also gets stalled via node 2.
+        // it is important that node 2 gets stalled before otherwise node 4 would have already be discovered.
+        // note that without the virtual node between 3 and 1 node 2 would not even be explored in the forward search,
+        // but because of the virtual node the strict upward search is modified and goes like 0-3-x-1-2.
+        edge24.set(carEncoder.getAverageSpeedEnc(), 27.5);
         edge24.setReverse(carEncoder.getAverageSpeedEnc(), 27.5);
 
         // prepare ch, use node ids as levels
@@ -488,7 +496,7 @@ public int getNumNodes() {
                 return g.getNodes();
             }
         }).doWork();
-        assertEquals("there should be exactly two shortcuts (3->2) and (3->4)", 2, lg.getEdges() - lg.getOriginalEdges());
+        assertEquals("there should be exactly two (bidirectional) shortcuts (2-3) and (3-4)", 2, lg.getEdges() - lg.getOriginalEdges());
 
         // insert virtual node and edges
         QueryResult qr = new QueryResult(0.0001, 0.0015);
@@ -501,11 +509,11 @@ public int getNumNodes() {
         queryGraph.lookup(Collections.singletonList(qr));
 
         // we make sure our weight fine tunings do what they are supposed to
-        double weight03 = getWeight(queryGraph, fastestWeighting, 0, 3);
-        double scWeight23 = weight03 + ((CHEdgeIteratorState) getEdge(lg, 2, 3)).getWeight();
-        double scWeight34 = weight03 + ((CHEdgeIteratorState) getEdge(lg, 3, 4)).getWeight();
-        double sptWeight2 = weight03 + getWeight(queryGraph, fastestWeighting, 3, 8) + getWeight(queryGraph, fastestWeighting, 8, 1) + getWeight(queryGraph, fastestWeighting, 1, 2);
-        double sptWeight4 = sptWeight2 + getWeight(queryGraph, fastestWeighting, 2, 4);
+        double weight03 = getWeight(queryGraph, fastestWeighting, 0, 3, false);
+        double scWeight23 = weight03 + ((CHEdgeIteratorState) getEdge(lg, 2, 3, true)).getWeight();
+        double scWeight34 = weight03 + ((CHEdgeIteratorState) getEdge(lg, 3, 4, false)).getWeight();
+        double sptWeight2 = weight03 + getWeight(queryGraph, fastestWeighting, 3, 8, false) + getWeight(queryGraph, fastestWeighting, 8, 1, false) + getWeight(queryGraph, fastestWeighting, 1, 2, false);
+        double sptWeight4 = sptWeight2 + getWeight(queryGraph, fastestWeighting, 2, 4, false);
         assertTrue("incoming shortcut weight 3->2 should be smaller than sptWeight at node 2 to make sure 2 gets stalled", scWeight23 < sptWeight2);
         assertTrue("sptWeight at node 4 should be smaller than shortcut weight 3->4 to make sure node 4 gets stalled", sptWeight4 < scWeight34);
 
@@ -513,12 +521,13 @@ public int getNumNodes() {
         assertEquals("wrong or no path found", IntArrayList.from(0, 3, 8, 1, 2, 4, 5, 6, 7), path.calcNodes());
     }
 
-    private double getWeight(Graph graph, Weighting w, int from, int to) {
-        return w.calcWeight(getEdge(graph, from, to), false, -1);
+    private double getWeight(Graph graph, Weighting w, int from, int to, boolean incoming) {
+        return w.calcWeight(getEdge(graph, from, to, false), incoming, -1);
     }
 
-    private EdgeIteratorState getEdge(Graph graph, int from, int to) {
-        EdgeIterator iter = graph.createEdgeExplorer().setBaseNode(from);
+    private EdgeIteratorState getEdge(Graph graph, int from, int to, boolean incoming) {
+        EdgeFilter filter = incoming ? DefaultEdgeFilter.inEdges(carEncoder) : DefaultEdgeFilter.outEdges(carEncoder);
+        EdgeIterator iter = graph.createEdgeExplorer(filter).setBaseNode(from);
         while (iter.next()) {
             if (iter.getAdjNode() == to) {
                 return iter;
@@ -664,7 +673,8 @@ public void testReusingNodeOrdering() {
         int numNodes = 5_000;
         int numQueries = 100;
         long seed = System.nanoTime();
-        GHUtility.buildRandomGraph(ghStorage, seed, numNodes, 1.3, false, false, 0.9, 0.8);
+        Random rnd = new Random(seed);
+        GHUtility.buildRandomGraph(ghStorage, rnd, numNodes, 1.3, true, true, carFlagEncoder.getAverageSpeedEnc(), 0.7, 0.9, 0.8);
         ghStorage.freeze();
 
         // create CH for cars
@@ -685,7 +695,6 @@ public void testReusingNodeOrdering() {
         motorCyclePch.doWork();
 
         // run a few sample queries to check correctness
-        Random rnd = new Random(seed);
         for (int i = 0; i < numQueries; ++i) {
             Dijkstra dijkstra = new Dijkstra(ghStorage, motorCycleWeighting, traversalMode);
             RoutingAlgorithm chAlgo = motorCyclePch.createAlgo(motorCycleCH, AlgorithmOptions.start().weighting(motorCycleWeighting).build());
diff --git a/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java
index 247cf18a0c..72f9f06358 100644
--- a/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.routing.subnetwork;
 
 import com.carrotsearch.hppc.IntArrayList;
-import com.graphhopper.routing.subnetwork.PrepareRoutingSubnetworks.PrepEdgeFilter;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
@@ -96,7 +95,7 @@ GraphHopperStorage createSubnetworkTestStorage2(EncodingManager em) {
     @Test
     public void testFindSubnetworks() {
         GraphHopperStorage g = createSubnetworkTestStorage();
-        PrepEdgeFilter filter = new PrepEdgeFilter(carFlagEncoder);
+        DefaultEdgeFilter filter = DefaultEdgeFilter.allEdges(carFlagEncoder);
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singletonList(carFlagEncoder));
         List<IntArrayList> components = instance.findSubnetworks(filter);
 
@@ -112,7 +111,7 @@ public void testFindSubnetworks() {
     @Test
     public void testKeepLargestNetworks() {
         GraphHopperStorage g = createSubnetworkTestStorage();
-        PrepEdgeFilter filter = new PrepEdgeFilter(carFlagEncoder);
+        DefaultEdgeFilter filter = DefaultEdgeFilter.allEdges(carFlagEncoder);
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singletonList(carFlagEncoder));
         List<IntArrayList> components = instance.findSubnetworks(filter);
         assertEquals(3, components.size());
@@ -253,7 +252,7 @@ public void testRemoveDeadEndUnvisitedNetworks() {
 
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singletonList(carFlagEncoder)).
                 setMinOneWayNetworkSize(3);
-        int removed = instance.removeDeadEndUnvisitedNetworks(new PrepEdgeFilter(carFlagEncoder));
+        int removed = instance.removeDeadEndUnvisitedNetworks(DefaultEdgeFilter.allEdges(carFlagEncoder));
 
         assertEquals(3, removed);
         instance.markNodesRemovedIfUnreachable();
@@ -269,7 +268,7 @@ public void testAddEdgesAfterwards() {
 
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singletonList(carFlagEncoder)).
                 setMinOneWayNetworkSize(3);
-        int removed = instance.removeDeadEndUnvisitedNetworks(new PrepEdgeFilter(carFlagEncoder));
+        int removed = instance.removeDeadEndUnvisitedNetworks(DefaultEdgeFilter.allEdges(carFlagEncoder));
 
         assertEquals(3, removed);
         instance.markNodesRemovedIfUnreachable();
@@ -309,7 +308,7 @@ public void testNodeOrderingRegression() {
 
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singletonList(carFlagEncoder)).
                 setMinOneWayNetworkSize(2);
-        int removedEdges = instance.removeDeadEndUnvisitedNetworks(new PrepEdgeFilter(carFlagEncoder));
+        int removedEdges = instance.removeDeadEndUnvisitedNetworks(DefaultEdgeFilter.allEdges(carFlagEncoder));
         assertEquals(2, removedEdges);
     }
 
@@ -336,7 +335,7 @@ public void test481() {
         instance.doWork();
 
         // only one remaining network
-        List<IntArrayList> components = instance.findSubnetworks(new PrepEdgeFilter(carFlagEncoder));
+        List<IntArrayList> components = instance.findSubnetworks(DefaultEdgeFilter.allEdges(carFlagEncoder));
         assertEquals(1, components.size());
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
index ee1fae741c..d112f0364f 100644
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
@@ -179,6 +179,20 @@ public void testAccess() {
         way.setTag("railway", "abandoned");
         assertTrue(encoder.getAccess(way).isWay());
 
+        way.clearTags();
+        way.setTag("highway", "platform");
+        assertTrue(encoder.getAccess(way).isWay());
+
+        way.clearTags();
+        way.setTag("highway", "platform");
+        way.setTag("bicycle", "dismount");
+        assertTrue(encoder.getAccess(way).isWay());
+
+        way.clearTags();
+        way.setTag("highway", "platform");
+        way.setTag("bicycle", "no");
+        assertTrue(encoder.getAccess(way).canSkip());
+
         DateFormat simpleDateFormat = Helper.createFormatter("yyyy MMM dd");
 
         way.clearTags();
@@ -354,6 +368,16 @@ public void testHandleCommonWayTags() {
         wayType = getWayTypeFromFlags(way);
         assertEquals("get off the bike", wayType);
 
+        way.clearTags();
+        way.setTag("highway", "platform");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike", wayType);
+
+        way.clearTags();
+        way.setTag("highway", "platform");
+        way.setTag("bicycle", "yes");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("", wayType);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
index 071c49626b..7ade7832fc 100644
--- a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
@@ -93,6 +93,16 @@ public void testGetSpeed() {
         assertEquals(PUSHING_SECTION_SPEED * 2, encoder.getSpeed(way));
         assertPriority(PREFER.getValue(), way);
 
+        way.clearTags();
+        way.setTag("highway", "platform");
+        way.setTag("surface", "paved");
+        way.setTag("bicycle", "yes");
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+        way.setTag("segregated", "yes");
+        assertEquals(PUSHING_SECTION_SPEED * 2, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+
         way.clearTags();
         way.setTag("highway", "cycleway");
         assertEquals(18, encoder.getSpeed(way));
@@ -161,6 +171,12 @@ public void testGetSpeed() {
         assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
         assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
 
+        way.clearTags();
+        way.setTag("highway", "platform");
+        way.setTag("surface", "paved");
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+
         way.clearTags();
         way.setTag("highway", "footway");
         way.setTag("surface", "paved");
@@ -168,6 +184,13 @@ public void testGetSpeed() {
         assertEquals(cyclewaySpeed, encoder.getSpeed(way));
         assertPriority(VERY_NICE.getValue(), way);
 
+        way.clearTags();
+        way.setTag("highway", "platform");
+        way.setTag("surface", "paved");
+        way.setTag("bicycle", "designated");
+        assertEquals(cyclewaySpeed, encoder.getSpeed(way));
+        assertPriority(VERY_NICE.getValue(), way);
+
         way.clearTags();
         way.setTag("highway", "track");
         assertEquals(12, encoder.getSpeed(way));
@@ -469,6 +492,25 @@ public void testHandleWayTagsInfluencedByRelation() {
         relFlags = encoder.handleRelationTags(0, osmRel);
         wayType = getWayTypeFromFlags(osmWay, relFlags);
         assertEquals("get off the bike", wayType);
+
+        // Test for highway=platform.
+        osmRel.clearTags();
+        osmWay.clearTags();
+        osmWay.setTag("highway", "platform");
+
+        // First tests without a cycle route relation, this is a get off the bike
+        relFlags = encoder.handleRelationTags(0, osmRel);
+        wayType = getWayTypeFromFlags(osmWay, relFlags);
+        assertEquals("get off the bike", wayType);
+
+        // now as part of a cycle route relation
+        osmRel.setTag("type", "route");
+        osmRel.setTag("route", "bicycle");
+        osmRel.setTag("network", "lcn");
+        relFlags = encoder.handleRelationTags(0, osmRel);
+        wayType = getWayTypeFromFlags(osmWay, relFlags);
+        assertEquals("", wayType);
+
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
index 91f18ba958..1b74cbaa7b 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
@@ -130,6 +130,9 @@ public void testAccess() {
         way.setTag("highway", "footway");
         assertTrue(footEncoder.getAccess(way).isWay());
 
+        way.setTag("highway", "platform");
+        assertTrue(footEncoder.getAccess(way).isWay());
+
         way.setTag("highway", "motorway");
         assertTrue(footEncoder.getAccess(way).canSkip());
 
diff --git a/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java b/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java
index f2db4b59fb..55982a04ea 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java
@@ -124,13 +124,13 @@ public void testBlockAreasWithPolygon() {
         GraphEdgeIdFinder.BlockArea blockArea = graphFinder.parseBlockArea("2,1, 0,2, 2,3", DefaultEdgeFilter.allEdges(encoder), 1000 * 1000);
 
         GHIntHashSet blockedEdges = new GHIntHashSet();
-        blockedEdges.addAll(new int[]{1, 2, 6, 7});
+        blockedEdges.addAll(1, 2, 6, 7);
         assertEquals(blockedEdges, blockArea.blockedEdges);
 
         blockArea = graphFinder.parseBlockArea("2,1, 1,3, 1,2, 0,1", DefaultEdgeFilter.allEdges(encoder), 1000 * 1000);
 
         blockedEdges = new GHIntHashSet();
-        blockedEdges.addAll(new int[]{4, 9, 6, 7});
+        blockedEdges.addAll(4, 9, 6, 7);
         assertEquals(blockedEdges, blockArea.blockedEdges);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
index 20933a742f..f8c2dbf3d0 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
@@ -441,6 +441,38 @@ public void testAddShortcut_edgeBased() {
         assertEquals(1, iter.getOrigEdgeLast());
     }
 
+    @Test
+    public void testGetEdgeIterator() {
+        graph = newGHStorage(false, true);
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.freeze();
+        CHGraph lg = getGraph(graph);
+        addShortcut(lg, 0, 2, true, 0, 1, 0, 1, 2);
+
+        CHEdgeIteratorState sc02 = lg.getEdgeIteratorState(2, 2);
+        assertNotNull(sc02);
+        assertEquals(0, sc02.getBaseNode());
+        assertEquals(2, sc02.getAdjNode());
+        assertEquals(2, sc02.getEdge());
+        assertEquals(0, sc02.getSkippedEdge1());
+        assertEquals(1, sc02.getSkippedEdge2());
+        assertEquals(0, sc02.getOrigEdgeFirst());
+        assertEquals(1, sc02.getOrigEdgeLast());
+
+        CHEdgeIteratorState sc20 = lg.getEdgeIteratorState(2, 0);
+        assertNotNull(sc20);
+        assertEquals(2, sc20.getBaseNode());
+        assertEquals(0, sc20.getAdjNode());
+        assertEquals(2, sc20.getEdge());
+        // note these are not stateful! i.e. even though we are looking at the edge 2->0 the first skipped/orig edge
+        // is still edge 0 and the second skipped/last orig edge is edge 1
+        assertEquals(0, sc20.getSkippedEdge1());
+        assertEquals(1, sc20.getSkippedEdge2());
+        assertEquals(0, sc20.getOrigEdgeFirst());
+        assertEquals(1, sc20.getOrigEdgeLast());
+    }
+
     private void addShortcut(CHGraph chGraph, int from, int to, boolean fwd, int firstOrigEdge, int lastOrigEdge,
                              int skipEdge1, int skipEdge2, int distance) {
         CHEdgeIteratorState shortcut = chGraph.shortcut(from, to);
diff --git a/core/src/test/java/com/graphhopper/storage/ShortcutUnpackerTest.java b/core/src/test/java/com/graphhopper/storage/ShortcutUnpackerTest.java
new file mode 100644
index 0000000000..9ce917bde7
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/storage/ShortcutUnpackerTest.java
@@ -0,0 +1,338 @@
+package com.graphhopper.storage;
+
+import com.carrotsearch.hppc.DoubleArrayList;
+import com.carrotsearch.hppc.IntArrayList;
+import com.graphhopper.routing.ch.PrepareEncoder;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.MotorcycleFlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.util.EdgeIteratorState;
+import org.junit.Assume;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(Parameterized.class)
+public class ShortcutUnpackerTest {
+    private final static int PREV_EDGE = 12;
+    private final static int NEXT_EDGE = 13;
+    private final boolean edgeBased;
+    private FlagEncoder encoder;
+    private Weighting weighting;
+    private GraphHopperStorage graph;
+    private CHGraph chGraph;
+    private TurnCostExtension turnCostExtension;
+
+    @Parameterized.Parameters(name = "{0}")
+    public static Object[] params() {
+        return new Object[]{
+                TraversalMode.NODE_BASED,
+                TraversalMode.EDGE_BASED_2DIR
+        };
+    }
+
+    public ShortcutUnpackerTest(TraversalMode traversalMode) {
+        this.edgeBased = traversalMode.isEdgeBased();
+    }
+
+    @Before
+    public void init() {
+        // use motorcycle to be able to set different fwd/bwd speeds
+        encoder = new MotorcycleFlagEncoder(5, 5, 10);
+        EncodingManager encodingManager = EncodingManager.create(encoder);
+        weighting = new FastestWeighting(encoder);
+        graph = new GraphBuilder(encodingManager).setCHGraph(weighting).setEdgeBasedCH(edgeBased).create();
+        chGraph = graph.getGraph(CHGraph.class, weighting);
+        if (edgeBased) {
+            turnCostExtension = (TurnCostExtension) graph.getExtension();
+        }
+    }
+
+    @Test
+    public void testUnpacking() {
+        // 0-1-2-3-4-5-6
+        DecimalEncodedValue speedEnc = encoder.getAverageSpeedEnc();
+        double fwdSpeed = 60;
+        double bwdSpeed = 30;
+        graph.edge(0, 1, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(1, 2, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(2, 3, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(3, 4, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(4, 5, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(5, 6, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.freeze();
+        shortcut(0, 2, 0, 1, 0, 1);
+        shortcut(2, 4, 2, 3, 2, 3);
+        shortcut(4, 6, 4, 5, 4, 5);
+        shortcut(2, 6, 7, 8, 2, 5);
+        shortcut(0, 6, 6, 9, 0, 5);
+
+        {
+            // unpack the shortcut 0->6, traverse original edges in 'forward' order (from node 0 to 6)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesFwd(10, 6, false, PREV_EDGE);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.edgeIds);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.baseNodes);
+            assertEquals(IntArrayList.from(1, 2, 3, 4, 5, 6), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+            if (edgeBased) {
+                assertEquals(IntArrayList.from(PREV_EDGE, 0, 1, 2, 3, 4), visitor.prevOrNextEdgeIds);
+            }
+        }
+
+        {
+            // unpack the shortcut 0->6, traverse original edges in 'backward' order (from node 6 to 0)
+            // note that traversing in backward order does not mean the original edges are read in reverse (e.g. fwd speed still applies)
+            // -> only the order of the original edges is reversed
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesFwd(10, 6, true, PREV_EDGE);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.edgeIds);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.baseNodes);
+            assertEquals(IntArrayList.from(6, 5, 4, 3, 2, 1), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+            if (edgeBased) {
+                assertEquals(IntArrayList.from(4, 3, 2, 1, 0, PREV_EDGE), visitor.prevOrNextEdgeIds);
+            }
+        }
+
+        {
+            // unpack the shortcut 6<-0 in reverse, i.e. with 6 as base node. traverse original edges in 'forward' order (from node 6 to 0)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesBwd(10, 0, false, NEXT_EDGE);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.edgeIds);
+            assertEquals(IntArrayList.from(6, 5, 4, 3, 2, 1), visitor.baseNodes);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+            if (edgeBased) {
+                assertEquals(IntArrayList.from(NEXT_EDGE, 5, 4, 3, 2, 1), visitor.prevOrNextEdgeIds);
+            }
+        }
+
+        {
+            // unpack the shortcut 6<-0 in reverse, i.e. with 60as base node. traverse original edges in 'backward' order (from node 0 to 6)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesBwd(10, 0, true, NEXT_EDGE);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.edgeIds);
+            assertEquals(IntArrayList.from(1, 2, 3, 4, 5, 6), visitor.baseNodes);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+            if (edgeBased) {
+                assertEquals(IntArrayList.from(1, 2, 3, 4, 5, NEXT_EDGE), visitor.prevOrNextEdgeIds);
+            }
+        }
+    }
+
+    @Test
+    public void loopShortcut() {
+        Assume.assumeTrue("loop shortcuts only exist for edge-based CH", edgeBased);
+        //     3
+        //    / \
+        //   2   4
+        //    \ /
+        // 0 - 1 - 5
+        DecimalEncodedValue speedEnc = encoder.getAverageSpeedEnc();
+        double fwdSpeed = 60;
+        double bwdSpeed = 30;
+        graph.edge(0, 1, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(1, 2, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(2, 3, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(3, 4, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(4, 1, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(1, 5, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.freeze();
+        shortcut(1, 3, 1, 2, 1, 2);
+        shortcut(3, 1, 3, 4, 3, 4);
+        shortcut(1, 1, 6, 7, 1, 4);
+        shortcut(0, 1, 0, 8, 0, 4);
+        shortcut(0, 5, 9, 5, 0, 5);
+
+        {
+            // unpack the shortcut 0->5, traverse original edges in 'forward' order (from node 0 to 5)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesFwd(10, 5, false, PREV_EDGE);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.edgeIds);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 1), visitor.baseNodes);
+            assertEquals(IntArrayList.from(1, 2, 3, 4, 1, 5), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+            assertEquals(IntArrayList.from(PREV_EDGE, 0, 1, 2, 3, 4), visitor.prevOrNextEdgeIds);
+        }
+
+        {
+            // unpack the shortcut 0->5, traverse original edges in 'backward' order (from node 5 to 0)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesFwd(10, 5, true, PREV_EDGE);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.edgeIds);
+            assertEquals(IntArrayList.from(1, 4, 3, 2, 1, 0), visitor.baseNodes);
+            assertEquals(IntArrayList.from(5, 1, 4, 3, 2, 1), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+            assertEquals(IntArrayList.from(4, 3, 2, 1, 0, PREV_EDGE), visitor.prevOrNextEdgeIds);
+        }
+
+        {
+            // unpack the shortcut 5<-0, traverse original edges in 'forward' order (from node 5 to 0)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesBwd(10, 0, false, NEXT_EDGE);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.edgeIds);
+            assertEquals(IntArrayList.from(5, 1, 4, 3, 2, 1), visitor.baseNodes);
+            assertEquals(IntArrayList.from(1, 4, 3, 2, 1, 0), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+            assertEquals(IntArrayList.from(NEXT_EDGE, 5, 4, 3, 2, 1), visitor.prevOrNextEdgeIds);
+        }
+
+        {
+            // unpack the shortcut 5<-0, traverse original edges in 'backward' order (from node 0 to 5)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesBwd(10, 0, true, NEXT_EDGE);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.edgeIds);
+            assertEquals(IntArrayList.from(1, 2, 3, 4, 1, 5), visitor.baseNodes);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 1), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+            assertEquals(IntArrayList.from(1, 2, 3, 4, 5, NEXT_EDGE), visitor.prevOrNextEdgeIds);
+        }
+    }
+
+    @Test
+    public void withTurnWeighting() {
+        Assume.assumeTrue(edgeBased);
+        //      2 5 3 2 1 4 6      turn costs ->
+        // prev 0-1-2-3-4-5-6 next
+        //      1 0 1 4 2 3 2      turn costs <-
+        DecimalEncodedValue speedEnc = encoder.getAverageSpeedEnc();
+        double fwdSpeed = 60;
+        double bwdSpeed = 30;
+        EdgeIteratorState edge0 = graph.edge(0, 1, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge1 = graph.edge(1, 2, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge2 = graph.edge(2, 3, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge3 = graph.edge(3, 4, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge4 = graph.edge(4, 5, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge5 = graph.edge(5, 6, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.freeze();
+
+        // turn costs ->
+        turnCostExtension.addTurnInfo(PREV_EDGE, 0, edge0.getEdge(), encoder.getTurnFlags(false, 2));
+        addTurnCost(edge0, edge1, 1, 5);
+        addTurnCost(edge1, edge2, 2, 3);
+        addTurnCost(edge2, edge3, 3, 2);
+        addTurnCost(edge3, edge4, 4, 1);
+        addTurnCost(edge4, edge5, 5, 4);
+        turnCostExtension.addTurnInfo(edge5.getEdge(), 6, NEXT_EDGE, encoder.getTurnFlags(false, 6));
+        // turn costs <-
+        turnCostExtension.addTurnInfo(NEXT_EDGE, 6, edge5.getEdge(), encoder.getTurnFlags(false, 2));
+        addTurnCost(edge5, edge4, 5, 3);
+        addTurnCost(edge4, edge3, 4, 2);
+        addTurnCost(edge3, edge2, 3, 4);
+        addTurnCost(edge2, edge1, 2, 1);
+        addTurnCost(edge1, edge0, 1, 0);
+        turnCostExtension.addTurnInfo(edge0.getEdge(), 0, PREV_EDGE, encoder.getTurnFlags(false, 1));
+
+        shortcut(0, 2, 0, 1, 0, 1);
+        shortcut(2, 4, 2, 3, 2, 3);
+        shortcut(4, 6, 4, 5, 4, 5);
+        shortcut(2, 6, 7, 8, 2, 5);
+        shortcut(0, 6, 6, 9, 0, 5);
+
+        {
+            // unpack the shortcut 0->6, traverse original edges in 'forward' order (from node 0 to 6)
+            TurnWeightingVisitor visitor = new TurnWeightingVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesFwd(10, 6, false, PREV_EDGE);
+            assertEquals("wrong weight", 6 * 0.06, visitor.weight, 1.e-3);
+            assertEquals("wrong time", (6 * 60 + 17000), visitor.time);
+        }
+
+        {
+            // unpack the shortcut 0->6, traverse original edges in 'backward' order (from node 6 to 0)
+            TurnWeightingVisitor visitor = new TurnWeightingVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesFwd(10, 6, true, PREV_EDGE);
+            assertEquals("wrong weight", 6 * 0.06, visitor.weight, 1.e-3);
+            assertEquals("wrong time", (6 * 60 + 17000), visitor.time);
+        }
+
+        {
+            // unpack the shortcut 6<-0, traverse original edges in 'forward' order (from node 6 to 0)
+            TurnWeightingVisitor visitor = new TurnWeightingVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesBwd(10, 0, false, NEXT_EDGE);
+            assertEquals("wrong weight", 6 * 0.06, visitor.weight, 1.e-3);
+            assertEquals("wrong time", (6 * 60 + 21000), visitor.time);
+        }
+
+        {
+            // unpack the shortcut 6<-0, traverse original edges in 'backward' order (from node 0 to 6)
+            TurnWeightingVisitor visitor = new TurnWeightingVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesBwd(10, 0, true, NEXT_EDGE);
+            assertEquals("wrong weight", 6 * 0.06, visitor.weight, 1.e-3);
+            assertEquals("wrong time", (6 * 60 + 21000), visitor.time);
+        }
+    }
+
+    private void addTurnCost(EdgeIteratorState inEdge, EdgeIteratorState outEdge, int viaNode, double costs) {
+        turnCostExtension.addTurnInfo(inEdge.getEdge(), viaNode, outEdge.getEdge(), encoder.getTurnFlags(false, costs));
+    }
+
+    private void shortcut(int baseNode, int adjNode, int skip1, int skip2, int origFirst, int origLast) {
+        // shortcut weight/distance is not important for us here
+        double weight = 1;
+        double distance = 1;
+        if (edgeBased) {
+            chGraph.shortcutEdgeBased(baseNode, adjNode, PrepareEncoder.getScFwdDir(), weight, distance, skip1, skip2, origFirst, origLast);
+        } else {
+            chGraph.shortcut(baseNode, adjNode, PrepareEncoder.getScFwdDir(), weight, distance, skip1, skip2);
+        }
+    }
+
+    private class TestVisitor implements ShortcutUnpacker.Visitor {
+        private final IntArrayList edgeIds = new IntArrayList();
+        private final IntArrayList adjNodes = new IntArrayList();
+        private final IntArrayList baseNodes = new IntArrayList();
+        private final IntArrayList prevOrNextEdgeIds = new IntArrayList();
+        private final DoubleArrayList weights = new DoubleArrayList();
+        private final DoubleArrayList distances = new DoubleArrayList();
+        private final DoubleArrayList times = new DoubleArrayList();
+
+        @Override
+        public void visit(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+            edgeIds.add(edge.getEdge());
+            baseNodes.add(edge.getBaseNode());
+            adjNodes.add(edge.getAdjNode());
+            weights.add(weighting.calcWeight(edge, reverse, prevOrNextEdgeId));
+            distances.add(edge.getDistance());
+            times.add(weighting.calcMillis(edge, reverse, prevOrNextEdgeId));
+            prevOrNextEdgeIds.add(prevOrNextEdgeId);
+        }
+    }
+
+    private class TurnWeightingVisitor implements ShortcutUnpacker.Visitor {
+        private final TurnWeighting turnWeighting = new TurnWeighting(weighting, turnCostExtension);
+        private long time = 0;
+        private double weight = 0;
+
+        @Override
+        public void visit(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+            time += turnWeighting.calcMillis(edge, reverse, prevOrNextEdgeId);
+            weight += weighting.calcWeight(edge, reverse, prevOrNextEdgeId);
+        }
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index bc35fe84d8..729c4e255f 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -26,6 +26,7 @@
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
 
@@ -34,8 +35,7 @@
 import java.util.Collections;
 import java.util.List;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
@@ -104,6 +104,22 @@ public void testSnappedPointAndGeometry() {
         assertEquals(new GHPoint(-0.441624, 0.317259), res.getSnappedPoint());
     }
 
+    @Test
+    public void testQuery() {
+        Graph graph = createTestGraph2();
+        LocationIndexTree index = createIndex(graph, 500);
+        final ArrayList set = new ArrayList();
+        index.query(new BBox(11.57314, 11.57614, 49.94553, 49.94853), new LocationIndex.Visitor() {
+            @Override
+            public void onNode(int nodeId) {
+                set.add(nodeId);
+            }
+        });
+        assertEquals(17, set.size());
+        assertTrue(set.containsAll(Arrays.asList(2, 3, 4, 5, 6)));
+        assertFalse(set.containsAll(Arrays.asList(17, 18, 25, 30)));
+    }
+
     @Test
     public void testInMemIndex() {
         Graph graph = createTestGraph(encodingManager);
@@ -196,11 +212,12 @@ public void testInMemIndex3() {
         LocationIndexTree index = createIndexNoPrepare(createTestGraph(encodingManager), 10000);
         index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
-        assertEquals(IntArrayList.from(new int[]{64, 4}), index.getEntries());
+        assertEquals(IntArrayList.from(new int[]{16, 4, 4}), index.getEntries());
 
-        assertEquals(33, inMemIndex.getEntriesOf(0).size());
-        assertEquals(69, inMemIndex.getEntriesOf(1).size());
-        assertEquals(0, inMemIndex.getEntriesOf(2).size());
+        assertEquals(13, inMemIndex.getEntriesOf(0).size());
+        assertEquals(33, inMemIndex.getEntriesOf(1).size());
+        assertEquals(69, inMemIndex.getEntriesOf(2).size());
+        assertEquals(0, inMemIndex.getEntriesOf(3).size());
 
         index.dataAccess.create(1024);
         inMemIndex.store(inMemIndex.root, LocationIndexTree.START_POINTER);
@@ -213,7 +230,7 @@ public void testInMemIndex3() {
     @Test
     public void testReverseSpatialKey() {
         LocationIndexTree index = createIndex(createTestGraph(encodingManager), 200);
-        assertEquals(IntArrayList.from(new int[]{64, 64, 64, 4}), index.getEntries());
+        assertEquals(IntArrayList.from(new int[]{16, 16, 16, 16, 4, 4}), index.getEntries());
 
         // 10111110111110101010
         String str44 = "00000000000000000000000000000000000000000000";
diff --git a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
index bd98a5afae..1b423322c6 100644
--- a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
+++ b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
@@ -170,6 +170,9 @@ public void testEdgeStuff() {
         assertEquals(8, GHUtility.createEdgeKey(1, 2, 4, false));
         assertEquals(9, GHUtility.createEdgeKey(2, 1, 4, false));
 
+        assertEquals(6, GHUtility.createEdgeKey(1, 1, 3, false));
+        assertEquals(6, GHUtility.createEdgeKey(1, 1, 3, true));
+
         assertTrue(GHUtility.isSameEdgeKeys(GHUtility.createEdgeKey(1, 2, 4, false), GHUtility.createEdgeKey(1, 2, 4, false)));
         assertTrue(GHUtility.isSameEdgeKeys(GHUtility.createEdgeKey(2, 1, 4, false), GHUtility.createEdgeKey(1, 2, 4, false)));
         assertFalse(GHUtility.isSameEdgeKeys(GHUtility.createEdgeKey(1, 2, 4, false), GHUtility.createEdgeKey(1, 2, 5, false)));
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index 10dfee10f8..a6ab1e20aa 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.util;
 
 import com.carrotsearch.hppc.IntArrayList;
-import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.Dijkstra;
 import com.graphhopper.routing.Path;
 import com.graphhopper.routing.profiles.BooleanEncodedValue;
@@ -29,22 +28,13 @@
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.IntsRef;
 import com.graphhopper.storage.NodeAccess;
 import org.junit.Before;
 import org.junit.Test;
-import org.xml.sax.SAXException;
-
-import javax.xml.XMLConstants;
-import javax.xml.transform.Source;
-import javax.xml.transform.stream.StreamSource;
-import javax.xml.validation.Schema;
-import javax.xml.validation.SchemaFactory;
-import javax.xml.validation.Validator;
-import java.io.StringReader;
+
 import java.util.*;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
@@ -64,7 +54,18 @@ public void setUp() {
         roundaboutEnc = carManager.getBooleanEncodedValue(EncodingManager.ROUNDABOUT);
     }
 
-    @SuppressWarnings("unchecked")
+    private List<String> getTurnDescriptions(InstructionList instructionList) {
+        return getTurnDescriptions(instructionList, usTR);
+    }
+
+    private List<String> getTurnDescriptions(InstructionList instructionList, Translation tr) {
+        List<String> list = new ArrayList<>();
+        for (Instruction instruction : instructionList) {
+            list.add(instruction.getTurnDescription(tr));
+        }
+        return list;
+    }
+
     @Test
     public void testWayList() {
         Graph g = new GraphBuilder(carManager).create();
@@ -112,95 +113,49 @@ public void testWayList() {
         iter2.setName("8-9");
         iter2.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(0, 10);
-        InstructionList wayList = p.calcInstructions(roundaboutEnc, usTR);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto 0-1", "Turn right onto 1-4", "Turn left onto 7-8", "Arrive at destination"),
+        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), TraversalMode.NODE_BASED).calcPath(0, 10);
+        InstructionList wayList = p.calcInstructions(roundaboutEnc, trMap.getWithFallBack(Locale.US));
+        List<String> tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto 0-1", "turn right onto 1-4", "turn left onto 7-8", "arrive at destination"),
                 tmpList);
 
         wayList = p.calcInstructions(roundaboutEnc, trMap.getWithFallBack(Locale.GERMAN));
-        tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Dem Straenverlauf von 0-1 folgen", "Rechts abbiegen auf 1-4", "Links abbiegen auf 7-8", "Ziel erreicht"),
+        tmpList = getTurnDescriptions(wayList, trMap.getWithFallBack(Locale.GERMAN));
+        assertEquals(Arrays.asList("dem Straenverlauf von 0-1 folgen", "rechts abbiegen auf 1-4", "links abbiegen auf 7-8", "Ziel erreicht"),
                 tmpList);
 
         assertEquals(70000.0, sumDistances(wayList), 1e-1);
 
-        List<GPXEntry> gpxes = wayList.createGPXList();
-        assertEquals(10, gpxes.size());
-        // check order of tower nodes        
-        assertEquals(1, gpxes.get(0).getLon(), 1e-6);
-        assertEquals(1.4, gpxes.get(gpxes.size() - 1).getLon(), 1e-6);
+        PointList points = p.calcPoints();
+        assertEquals(10, points.size());
+        // check order of tower nodes
+        assertEquals(1, points.getLon(0), 1e-6);
+        assertEquals(1.4, points.getLon(points.size() - 1), 1e-6);
 
-        // check order of pillar nodes        
-        assertEquals(1.15, gpxes.get(4).getLon(), 1e-6);
-        assertEquals(1.16, gpxes.get(5).getLon(), 1e-6);
-        assertEquals(1.16, gpxes.get(5).getLon(), 1e-6);
+        // check order of pillar nodes
+        assertEquals(1.15, points.getLon(4), 1e-6);
+        assertEquals(1.16, points.getLon(5), 1e-6);
 
         compare(Arrays.asList(asL(1.2d, 1.0d), asL(1.2d, 1.1), asL(1.0, 1.1), asL(1.1, 1.4)),
-                wayList.createStartPoints());
+                createStartPoints(wayList));
 
-        p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(6, 2);
+        p = new Dijkstra(g, new ShortestWeighting(carEncoder), TraversalMode.NODE_BASED).calcPath(6, 2);
         assertEquals(42000, p.getDistance(), 1e-2);
-        assertEquals(IntArrayList.from(new int[]{6, 7, 8, 5, 2}), p.calcNodes());
+        assertEquals(IntArrayList.from(6, 7, 8, 5, 2), p.calcNodes());
 
-        wayList = p.calcInstructions(roundaboutEnc, usTR);
-        tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto 6-7", "Turn left onto 5-8", "Arrive at destination"),
+        wayList = p.calcInstructions(roundaboutEnc, trMap.getWithFallBack(Locale.US));
+        tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto 6-7", "turn left onto 5-8", "arrive at destination"),
                 tmpList);
 
         compare(Arrays.asList(asL(1d, 1d), asL(1d, 1.2), asL(1.2, 1.2)),
-                wayList.createStartPoints());
+                createStartPoints(wayList));
 
         // special case of identical start and end
-        p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(0, 0);
-        wayList = p.calcInstructions(roundaboutEnc, usTR);
+        p = new Dijkstra(g, new ShortestWeighting(carEncoder), TraversalMode.NODE_BASED).calcPath(0, 0);
+        wayList = p.calcInstructions(roundaboutEnc, trMap.getWithFallBack(Locale.US));
         assertEquals(1, wayList.size());
-        assertEquals("arrive at destination", wayList.get(0).getTurnDescription(usTR));
-    }
-
-    List<String> pick(String key, List<Map<String, Object>> instructionJson) {
-        List<String> list = new ArrayList<>();
-
-        for (Map<String, Object> json : instructionJson) {
-            list.add(json.get(key).toString());
-        }
-        return list;
-    }
-
-    List<List<Double>> createList(PointList pl, List<Integer> integs) {
-        List<List<Double>> list = new ArrayList<>();
-        for (int i : integs) {
-            List<Double> entryList = new ArrayList<>(2);
-            entryList.add(pl.getLatitude(i));
-            entryList.add(pl.getLongitude(i));
-            list.add(entryList);
-        }
-        return list;
-    }
-
-    void compare(List<List<Double>> expected, List<List<Double>> actual) {
-        for (int i = 0; i < expected.size(); i++) {
-            List<Double> e = expected.get(i);
-            List<Double> wasE = actual.get(i);
-            for (int j = 0; j < e.size(); j++) {
-                assertEquals("at index " + i + " value index " + j + " and value " + e + " vs " + wasE + "\n" + "Expected: " + expected + "\n" + "Actual: " + actual
-                        , e.get(j),
-                        wasE.get(j),
-                        1e-5d);
-            }
-        }
-    }
-
-    List<Double> asL(Double... list) {
-        return Arrays.asList(list);
-    }
-
-    double sumDistances(InstructionList il) {
-        double val = 0;
-        for (Instruction i : il) {
-            val += i.getDistance();
-        }
-        return val;
+        assertEquals("arrive at destination", wayList.get(0).getTurnDescription(trMap.getWithFallBack(Locale.US)));
     }
 
     @Test
@@ -229,14 +184,14 @@ public void testWayList2() {
         Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(2, 3);
 
         InstructionList wayList = p.calcInstructions(roundaboutEnc, usTR);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto 2-4", "Turn slight right onto 3-4", "Arrive at destination"),
+        List<String> tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto 2-4", "turn slight right onto 3-4", "arrive at destination"),
                 tmpList);
 
         p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(3, 5);
         wayList = p.calcInstructions(roundaboutEnc, usTR);
-        tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto 3-4", "Keep right onto 4-5", "Arrive at destination"),
+        tmpList = getTurnDescriptions( wayList);
+        assertEquals(Arrays.asList("continue onto 3-4", "keep right onto 4-5", "arrive at destination"),
                 tmpList);
     }
 
@@ -267,176 +222,8 @@ public void testNoInstructionIfSameStreet() {
 
         Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(2, 3);
         InstructionList wayList = p.calcInstructions(roundaboutEnc, usTR);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto street", "Turn right onto street", "Arrive at destination"), tmpList);
-    }
-
-    @Test
-    public void testInstructionsWithTimeAndPlace() {
-        Graph g = new GraphBuilder(carManager).create();
-        //   n-4-5   (n: pillar node)
-        //   |
-        // 7-3-2-6
-        //     |
-        //     1
-        NodeAccess na = g.getNodeAccess();
-        na.setNode(1, 15.0, 10);
-        na.setNode(2, 15.1, 10);
-        na.setNode(3, 15.1, 9.9);
-        na.setNode(4, 15.2, 9.9);
-        na.setNode(5, 15.2, 10);
-        na.setNode(6, 15.1, 10.1);
-        na.setNode(7, 15.1, 9.8);
-
-        g.edge(1, 2, 7000, true).setName("1-2").setFlags(flagsForSpeed(carManager, 70));
-        g.edge(2, 3, 8000, true).setName("2-3").setFlags(flagsForSpeed(carManager, 80));
-        g.edge(2, 6, 10000, true).setName("2-6").setFlags(flagsForSpeed(carManager, 10));
-        g.edge(3, 4, 9000, true).setName("3-4").setFlags(flagsForSpeed(carManager, 90));
-        g.edge(3, 7, 10000, true).setName("3-7").setFlags(flagsForSpeed(carManager, 10));
-        g.edge(4, 5, 10000, true).setName("4-5").setFlags(flagsForSpeed(carManager, 100));
-
-        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(1, 5);
-        InstructionList wayList = p.calcInstructions(roundaboutEnc, usTR);
-        assertEquals(4, wayList.size());
-
-        List<GPXEntry> gpxList = wayList.createGPXList();
-        assertEquals(34000, p.getDistance(), 1e-1);
-        assertEquals(34000, sumDistances(wayList), 1e-1);
-        assertEquals(5, gpxList.size());
-        assertEquals(1604120, p.getTime());
-        assertEquals(1604120, gpxList.get(gpxList.size() - 1).getTime());
-
-        assertEquals(Instruction.CONTINUE_ON_STREET, wayList.get(0).getSign());
-        assertEquals(15, wayList.get(0).getFirstLat(), 1e-3);
-        assertEquals(10, wayList.get(0).getFirstLon(), 1e-3);
-
-        assertEquals(Instruction.TURN_LEFT, wayList.get(1).getSign());
-        assertEquals(15.1, wayList.get(1).getFirstLat(), 1e-3);
-        assertEquals(10, wayList.get(1).getFirstLon(), 1e-3);
-
-        assertEquals(Instruction.TURN_RIGHT, wayList.get(2).getSign());
-        assertEquals(15.1, wayList.get(2).getFirstLat(), 1e-3);
-        assertEquals(9.9, wayList.get(2).getFirstLon(), 1e-3);
-
-        String gpxStr = wayList.createGPX("test", 0, Constants.VERSION);
-        verifyGPX(gpxStr);
-
-        assertTrue(gpxStr, gpxStr.contains("<trkpt lat=\"15.0\" lon=\"10.0\"><time>1970-01-01T00:00:00Z</time>"));
-        assertTrue(gpxStr, gpxStr.contains("<extensions>") && gpxStr.contains("</extensions>"));
-        assertTrue(gpxStr, gpxStr.contains("<rtept lat=\"15.1\" lon=\"10.0\">"));
-        assertTrue(gpxStr, gpxStr.contains("<gh:distance>8000.0</gh:distance>"));
-        assertTrue(gpxStr, gpxStr.contains("<desc>turn left onto 2-3</desc>"));
-        assertTrue(gpxStr, gpxStr.contains("<gh:sign>-2</gh:sign>"));
-
-        assertTrue(gpxStr, gpxStr.contains("<gh:direction>N</gh:direction>"));
-        assertTrue(gpxStr, gpxStr.contains("<gh:azimuth>0.0</gh:azimuth>"));
-
-        assertFalse(gpxStr, gpxStr.contains("NaN"));
-    }
-
-    @Test
-    public void testCreateGPXIncludesRoundaboutExitNumber() {
-        InstructionList instructions = new InstructionList(usTR);
-
-        PointList pl = new PointList();
-        pl.add(52.555423473315, 13.43890086052345);
-        pl.add(52.555550691982, 13.43946393816465);
-        pl.add(52.555619423589, 13.43886994061328);
-        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
-                InstructionAnnotation.EMPTY, pl)
-                .setRadian(2.058006514284998d)
-                .setExitNumber(3)
-                .setExited();
-        instructions.add(instr);
-        instructions.add(new FinishInstruction(52.555619423589, 13.43886994061328, 0));
-
-        String gpxStr = instructions.createGPX("test", 0, true, true, false, false, Constants.VERSION);
-
-        assertTrue(gpxStr, gpxStr.contains("<gh:exit_number>3</gh:exit_number>"));
-        verifyGPX(gpxStr);
-    }
-
-    @Test
-    public void testCreateGPXCorrectFormattingSmallNumbers() {
-        InstructionList instructions = new InstructionList(usTR);
-
-        PointList pl = new PointList();
-        pl.add(0.000001, 0.000001);
-        pl.add(-0.000123, -0.000125);
-        Instruction instruction = new Instruction(0, "do it", null, pl);
-        instructions.add(instruction);
-        instructions.add(new FinishInstruction(0.000852, 0.000852, 0));
-
-        String gpxStr = instructions.createGPX("test", 0, true, true, true, true, Constants.VERSION);
-
-        assertFalse(gpxStr, gpxStr.contains("E-"));
-        assertTrue(gpxStr, gpxStr.contains("0.000001"));
-        assertTrue(gpxStr, gpxStr.contains("-0.000125"));
-        verifyGPX(gpxStr);
-    }
-
-    @Test
-    public void testCreateGPXWithEle() {
-        final List<GPXEntry> fakeList = new ArrayList<>();
-        fakeList.add(new GPXEntry(12, 13, 0));
-        fakeList.add(new GPXEntry(12.5, 13, 1000));
-        InstructionList il = new InstructionList(usTR) {
-            @Override
-            public List<GPXEntry> createGPXList() {
-                return fakeList;
-            }
-        };
-        String gpxStr = il.createGPX("test", 0, Constants.VERSION);
-        verifyGPX(gpxStr);
-        assertFalse(gpxStr, gpxStr.contains("NaN"));
-        assertFalse(gpxStr, gpxStr.contains("<ele>"));
-
-        fakeList.clear();
-        fakeList.add(new GPXEntry(12, 13, 11, 0));
-        fakeList.add(new GPXEntry(12.5, 13, 10, 1000));
-        gpxStr = il.createGPX("test", 0, true, true, true, true, Constants.VERSION);
-
-        assertTrue(gpxStr, gpxStr.contains("<ele>11.0</ele>"));
-        assertFalse(gpxStr, gpxStr.contains("NaN"));
-    }
-
-    @Test
-    public void testCreateGPX() {
-        InstructionAnnotation ea = InstructionAnnotation.EMPTY;
-        InstructionList instructions = new InstructionList(usTR);
-        PointList pl = new PointList();
-        pl.add(49.942576, 11.580384);
-        pl.add(49.941858, 11.582422);
-        instructions.add(new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl).setDistance(240).setTime(15000));
-
-        pl = new PointList();
-        pl.add(49.941575, 11.583501);
-        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(4000));
-
-        pl = new PointList();
-        pl.add(49.941389, 11.584311);
-        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(3000));
-        instructions.add(new FinishInstruction(49.941029, 11.584514, 0));
-
-        List<GPXEntry> result = instructions.createGPXList();
-        assertEquals(5, result.size());
-
-        assertEquals(0, result.get(0).getTime());
-        assertEquals(10391, result.get(1).getTime());
-        assertEquals(15000, result.get(2).getTime());
-        assertEquals(19000, result.get(3).getTime());
-        assertEquals(22000, result.get(4).getTime());
-
-        verifyGPX(instructions.createGPX(Constants.VERSION));
-    }
-
-    private IntsRef flagsForSpeed(EncodingManager encodingManager, int speedKmPerHour) {
-        ReaderWay way = new ReaderWay(1);
-        way.setTag("highway", "motorway");
-        way.setTag("maxspeed", String.format("%d km/h", speedKmPerHour));
-        EncodingManager.AcceptWay map = new EncodingManager.AcceptWay();
-        encodingManager.acceptWay(way, map);
-        return encodingManager.handleWayTags(way, map, 0);
+        List<String> tmpList = getTurnDescriptions( wayList);
+        assertEquals(Arrays.asList("continue onto street", "turn right onto street", "arrive at destination"), tmpList);
     }
 
     @Test
@@ -445,26 +232,6 @@ public void testEmptyList() {
         Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(0, 1);
         InstructionList il = p.calcInstructions(roundaboutEnc, usTR);
         assertEquals(0, il.size());
-        assertEquals(0, il.createStartPoints().size());
-    }
-
-    public void verifyGPX(String gpx) {
-        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
-        Schema schema = null;
-        try {
-            Source schemaFile = new StreamSource(getClass().getResourceAsStream("gpx-schema.xsd"));
-            schema = schemaFactory.newSchema(schemaFile);
-
-            // using more schemas: http://stackoverflow.com/q/1094893/194609
-        } catch (SAXException e1) {
-            throw new IllegalStateException("There was a problem with the schema supplied for validation. Message:" + e1.getMessage());
-        }
-        Validator validator = schema.newValidator();
-        try {
-            validator.validate(new StreamSource(new StringReader(gpx)));
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
     }
 
     @Test
@@ -506,10 +273,46 @@ public void testFind() {
         assertEquals("3-4", wayList.find(15.099, 9.9, 1000).getName());
     }
 
-    @Test
-    public void testXMLEscape_issue572() {
-        assertEquals("_", InstructionList.simpleXMLEscape("<"));
-        assertEquals("_blup_", InstructionList.simpleXMLEscape("<blup>"));
-        assertEquals("a&amp;b", InstructionList.simpleXMLEscape("a&b"));
+    private List<String> pick(String key, List<Map<String, Object>> instructionJson) {
+        List<String> list = new ArrayList<>();
+
+        for (Map<String, Object> json : instructionJson) {
+            list.add(json.get(key).toString());
+        }
+        return list;
     }
+
+    private void compare(List<List<Double>> expected, List<List<Double>> actual) {
+        for (int i = 0; i < expected.size(); i++) {
+            List<Double> e = expected.get(i);
+            List<Double> wasE = actual.get(i);
+            for (int j = 0; j < e.size(); j++) {
+                assertEquals("at index " + i + " value index " + j + " and value " + e + " vs " + wasE + "\n" + "Expected: " + expected + "\n" + "Actual: " + actual
+                        , e.get(j),
+                        wasE.get(j),
+                        1e-5d);
+            }
+        }
+    }
+
+    private List<Double> asL(Double... list) {
+        return Arrays.asList(list);
+    }
+
+    private static List<List<Double>> createStartPoints(List<Instruction> instructions) {
+        List<List<Double>> res = new ArrayList<>(instructions.size());
+        for (Instruction instruction : instructions) {
+            res.add(Arrays.asList(instruction.getPoints().getLatitude(0), instruction.getPoints().getLongitude(0)));
+        }
+        return res;
+    }
+
+    private double sumDistances(InstructionList il) {
+        double val = 0;
+        for (Instruction i : il) {
+            val += i.getDistance();
+        }
+        return val;
+    }
+
 }
diff --git a/docs/android/index.md b/docs/android/index.md
index 262e24afcf..455a919886 100644
--- a/docs/android/index.md
+++ b/docs/android/index.md
@@ -23,7 +23,7 @@ Please read [here](./android-studio-setup.md) for a detailed instruction.
 
 ## None-Android Studio
 
-Download the [Android SDK](http://developer.android.com/sdk/installing/index.html?pkg=tools) and go to the Android SDK Manager and install the latest SDK.
+You need to download the SDK tools and then install builds-tools and platform (both e.g. v27). The process is described in more details for linux [here](https://gist.github.com/karussell/86fa2554c552a204ae7be2964b870bab).
 
 ### Maven or NetBeans
  1. Download [Maven Android SDK Deployer](https://github.com/simpligility/maven-android-sdk-deployer) and execute `mvn install -P 5.1` - it uses [Android Maven Plugin](http://simpligility.github.io/android-maven-plugin/) under the hood where you need to set up `ANDROID_HOME`
diff --git a/docs/core/low-level-api.md b/docs/core/low-level-api.md
index c0b6d3e8bb..4cada3cae0 100644
--- a/docs/core/low-level-api.md
+++ b/docs/core/low-level-api.md
@@ -46,7 +46,7 @@ create new virtual nodes or if close enough use the existing junction node.
 
 ```java
 FlagEncoder encoder = new CarFlagEncoder();
-EncodingManager em = new EncodingManager(encoder);
+EncodingManager em = EncodingManager.create(encoder);
 GraphBuilder gb = new GraphBuilder(em).setLocation("graphhopper_folder").setStore(true);
 GraphStorage graph = gb.create();
 // Make a weighted edge between two nodes.
diff --git a/docs/core/routing.md b/docs/core/routing.md
index fcb130c68b..97078e7f4e 100644
--- a/docs/core/routing.md
+++ b/docs/core/routing.md
@@ -11,7 +11,7 @@ GraphHopper hopper = new GraphHopperOSM().forServer();
 hopper.setDataReaderFile(osmFile);
 // where to store graphhopper files?
 hopper.setGraphHopperLocation(graphFolder);
-hopper.setEncodingManager(new EncodingManager("car"));
+hopper.setEncodingManager(EncodingManager.create("car"));
 
 // now this can take minutes if it imports or a few seconds for loading
 // of course this is dependent on the area you import
@@ -60,7 +60,7 @@ config.yml `prepare.ch.weightings=no`) or on a per request base by adding `ch.di
 (see config.yml `prepare.lm.weightings=fastest`).
 
 If you need multiple vehicle profiles you can specify a list of vehicle profiles (see
-config.yml e.g. `graph.flag_encoders=car,bike` or use `new EncodingManager("car,bike")`). 
+config.yml e.g. `graph.flag_encoders=car,bike` or use `EncodingManager.create("car,bike")`). 
 
 To calculate a route you have to pick one vehicle and optionally an algorithm like `bidirectional_astar`:
 
@@ -69,7 +69,7 @@ GraphHopper hopper = new GraphHopperOSM().forServer();
 hopper.setCHEnabled(false);
 hopper.setOSMFile(osmFile);
 hopper.setGraphHopperLocation(graphFolder);
-hopper.setEncodingManager(new EncodingManager("car,bike"));
+hopper.setEncodingManager(EncodingManager.create("car,bike"));
 
 hopper.importOrLoad();
 
diff --git a/pom.xml b/pom.xml
index 4654dd5de2..2294e7be2a 100644
--- a/pom.xml
+++ b/pom.xml
@@ -15,11 +15,16 @@
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
-        <slf4j.version>1.7.25</slf4j.version>
+        <slf4j.version>1.7.26</slf4j.version>
         <log4j.version>1.2.17</log4j.version>
-        <commons-compress.version>1.15</commons-compress.version>
-        <jackson.version>2.9.6</jackson.version>
-        <dropwizard.version>1.3.5</dropwizard.version>
+        <commons-compress.version>1.18</commons-compress.version>
+
+        <!-- for the correct jackson and guava versions see https://github.com/dropwizard/dropwizard/blob/release/1.3.x/dropwizard-bom/pom.xml -->
+        <!-- make also sure that the dropwizard version is working with 1.3.5 of dropwizard-configurable-assets-bundle used in web -->
+        <dropwizard.version>1.3.12</dropwizard.version>
+        <jackson.version>2.9.9</jackson.version>
+        <guava.version>24.1.1-jre</guava.version>
+
         <directions-api-client.version>0.10.1-3</directions-api-client.version>
         <maven.compiler.target>1.8</maven.compiler.target>
 
@@ -90,7 +95,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.8.0</version>
+                <version>3.8.1</version>
                 <configuration>
                     <!--
                     <compilerArgument>-Xlint:unchecked</compilerArgument>
@@ -109,7 +114,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.22.1</version>
+                <version>2.22.2</version>
                 <configuration>
                     <argLine>-Xmx100m -Xms100m</argLine>
                 </configuration>
@@ -118,7 +123,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-failsafe-plugin</artifactId>
-                <version>2.22.1</version>
+                <version>2.22.2</version>
                 <executions>
                     <execution>
                         <goals>
@@ -132,18 +137,18 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-assembly-plugin</artifactId>
-                <version>3.1.0</version>
+                <version>3.1.1</version>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-jar-plugin</artifactId>
-                <version>3.1.0</version>
+                <version>3.1.1</version>
             </plugin>
             <!-- example https://github.com/tananaev/traccar/blob/master/checkstyle.xml -->
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-checkstyle-plugin</artifactId>
-                <version>2.17</version>
+                <version>3.1.0</version>
                 <configuration>
                     <configLocation>${user.dir}/core/files/checkstyle.xml</configLocation>
                     <failsOnError>true</failsOnError>
@@ -165,7 +170,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-pmd-plugin</artifactId>
-                <version>3.7</version>
+                <version>3.12</version>
                 <!-- e.g. under core/target/site/pmd.html
                 <configuration>
                     <format>html</format>
@@ -251,7 +256,7 @@
                     <plugin>
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-javadoc-plugin</artifactId>
-                        <version>3.0.1</version>
+                        <version>3.1.0</version>
                         <configuration>
                           <quiet>true</quiet>
                         </configuration>
@@ -267,7 +272,7 @@
                     <plugin>
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-source-plugin</artifactId>
-                        <version>3.0.1</version>
+                        <version>3.1.0</version>
                         <executions>
                             <execution>
                                 <id>attach-sources</id>
diff --git a/reader-gtfs/pom.xml b/reader-gtfs/pom.xml
index bc9d5fdfd6..bc34354627 100644
--- a/reader-gtfs/pom.xml
+++ b/reader-gtfs/pom.xml
@@ -21,6 +21,11 @@
             <artifactId>graphhopper-core</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-web-api</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
         <dependency>
             <groupId>com.graphhopper</groupId>
             <artifactId>graphhopper-reader-osm</artifactId>
@@ -29,7 +34,7 @@
         <dependency>
             <groupId>com.google.guava</groupId>
             <artifactId>guava</artifactId>
-            <version>24.0-jre</version>
+            <version>${guava.version}</version>
         </dependency>
         <dependency>
             <groupId>net.sourceforge.javacsv</groupId>
@@ -52,21 +57,30 @@
             <version>${slf4j.version}</version>
         </dependency>   
         <dependency>
-            <groupId>org.slf4j</groupId>
-            <artifactId>slf4j-log4j12</artifactId>
-            <version>${slf4j.version}</version>
-            <scope>test</scope>
+            <groupId>com.google.transit</groupId>
+            <artifactId>gtfs-realtime-bindings</artifactId>
+            <version>0.0.4</version>
         </dependency>
         <dependency>
-            <groupId>log4j</groupId>
-            <artifactId>log4j</artifactId>
-            <version>${log4j.version}</version>
-            <scope>test</scope>
+            <groupId>io.dropwizard</groupId>
+            <artifactId>dropwizard-core</artifactId>
+            <version>${dropwizard.version}</version>
         </dependency>
         <dependency>
-            <groupId>com.google.transit</groupId>
-            <artifactId>gtfs-realtime-bindings</artifactId>
-            <version>0.0.4</version>
+            <groupId>io.dropwizard</groupId>
+            <artifactId>dropwizard-client</artifactId>
+            <version>${dropwizard.version}</version>
+        </dependency>
+        <!-- see #1606 HK2 service reification failed -->
+        <dependency>
+            <groupId>javax.activation</groupId>
+            <artifactId>activation</artifactId>
+            <version>1.1.1</version>
+        </dependency>
+	<dependency>
+            <groupId>javax.xml.bind</groupId>
+            <artifactId>jaxb-api</artifactId>
+            <version>2.3.0</version>
         </dependency>
 
         <dependency>
@@ -82,6 +96,12 @@
             <version>4.12</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>io.dropwizard</groupId>
+            <artifactId>dropwizard-testing</artifactId>
+            <version>${dropwizard.version}</version>
+            <scope>test</scope>
+        </dependency>
         <dependency>
             <groupId>org.hamcrest</groupId>
             <artifactId>hamcrest-library</artifactId>
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/FeedConfiguration.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/FeedConfiguration.java
new file mode 100644
index 0000000000..4bab2c1be1
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/FeedConfiguration.java
@@ -0,0 +1,63 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.dropwizard;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.google.transit.realtime.GtfsRealtime;
+
+import java.io.IOException;
+import java.net.URL;
+
+public class FeedConfiguration {
+
+    private URL url;
+    private String agencyId;
+    private String feedId;
+
+    @JsonProperty
+    public URL getUrl() {
+        return url;
+    }
+
+    @JsonProperty
+    public void setUrl(URL url) {
+        this.url = url;
+    }
+
+    @JsonProperty
+    public String getAgencyId() {
+        return agencyId;
+    }
+
+    @JsonProperty
+    public void setAgencyId(String agencyId) {
+        this.agencyId = agencyId;
+    }
+
+    @JsonProperty
+    public String getFeedId() {
+        return feedId;
+    }
+
+    @JsonProperty
+    public void setFeedId(String feedId) {
+        this.feedId = feedId;
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundle.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundle.java
new file mode 100644
index 0000000000..a61fbd6c95
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundle.java
@@ -0,0 +1,52 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.dropwizard;
+
+import com.graphhopper.reader.gtfs.RealtimeFeed;
+import io.dropwizard.ConfiguredBundle;
+import io.dropwizard.client.HttpClientBuilder;
+import io.dropwizard.setup.Bootstrap;
+import io.dropwizard.setup.Environment;
+import org.apache.http.client.HttpClient;
+import org.glassfish.hk2.utilities.binding.AbstractBinder;
+
+import javax.inject.Singleton;
+
+public class RealtimeBundle implements ConfiguredBundle<RealtimeBundleConfiguration> {
+
+    @Override
+    public void initialize(Bootstrap<?> bootstrap) {
+    }
+
+    @Override
+    public void run(RealtimeBundleConfiguration configuration, Environment environment) {
+        final HttpClient httpClient = new HttpClientBuilder(environment)
+                .using(configuration.gtfsrealtime().getHttpClientConfiguration())
+                .build("gtfs-realtime-feed-loader");
+        environment.jersey().register(new AbstractBinder() {
+            @Override
+            protected void configure() {
+                bind(httpClient).to(HttpClient.class);
+                bind(configuration).to(RealtimeBundleConfiguration.class);
+                bindFactory(RealtimeFeedLoadingCache.class, Singleton.class).to(RealtimeFeed.class);
+            }
+        });
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundleConfiguration.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundleConfiguration.java
new file mode 100644
index 0000000000..b772b43b9d
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundleConfiguration.java
@@ -0,0 +1,27 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.dropwizard;
+
+import java.util.List;
+
+public interface RealtimeBundleConfiguration {
+
+    RealtimeConfiguration gtfsrealtime();
+
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeConfiguration.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeConfiguration.java
new file mode 100644
index 0000000000..cf22843005
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeConfiguration.java
@@ -0,0 +1,49 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.dropwizard;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.google.transit.realtime.GtfsRealtime;
+import io.dropwizard.client.HttpClientConfiguration;
+
+import javax.validation.Valid;
+import javax.validation.constraints.NotNull;
+import java.io.IOException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+
+public class RealtimeConfiguration {
+
+    @Valid
+    @NotNull
+    @JsonProperty
+    private HttpClientConfiguration httpClient = new HttpClientConfiguration();
+
+    @JsonProperty
+    private List<FeedConfiguration> feeds = new ArrayList<>();
+
+    public List<FeedConfiguration> getFeeds() {
+        return feeds;
+    }
+
+    public HttpClientConfiguration getHttpClientConfiguration() {
+        return httpClient;
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeFeedLoadingCache.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeFeedLoadingCache.java
new file mode 100644
index 0000000000..b1c0634243
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeFeedLoadingCache.java
@@ -0,0 +1,108 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.dropwizard;
+
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListenableFutureTask;
+import com.google.transit.realtime.GtfsRealtime;
+import com.graphhopper.reader.gtfs.GtfsStorage;
+import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.reader.gtfs.RealtimeFeed;
+import com.graphhopper.storage.GraphHopperStorage;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.glassfish.hk2.api.Factory;
+
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import java.io.IOException;
+import java.net.URISyntaxException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+public class RealtimeFeedLoadingCache implements Factory<RealtimeFeed> {
+
+    private final HttpClient httpClient;
+    private final GraphHopperStorage graphHopperStorage;
+    private final GtfsStorage gtfsStorage;
+    private final PtFlagEncoder ptFlagEncoder;
+    private final RealtimeBundleConfiguration bundleConfiguration;
+    private final ExecutorService executor = Executors.newSingleThreadExecutor();
+    private final LoadingCache<String, RealtimeFeed> cache;
+
+    @Inject
+    RealtimeFeedLoadingCache(GraphHopperStorage graphHopperStorage, GtfsStorage gtfsStorage, PtFlagEncoder ptFlagEncoder, HttpClient httpClient, RealtimeBundleConfiguration bundleConfiguration) {
+        this.graphHopperStorage = graphHopperStorage;
+        this.gtfsStorage = gtfsStorage;
+        this.ptFlagEncoder = ptFlagEncoder;
+        this.bundleConfiguration = bundleConfiguration;
+        this.httpClient = httpClient;
+        this.cache = CacheBuilder.newBuilder()
+                .maximumSize(1)
+                .refreshAfterWrite(1, TimeUnit.MINUTES)
+                .build(new CacheLoader<String, RealtimeFeed>() {
+                    public RealtimeFeed load(String key) {
+                        return fetchFeedsAndCreateGraph();
+                    }
+
+                    @Override
+                    public ListenableFuture<RealtimeFeed> reload(String key, RealtimeFeed oldValue) {
+                        ListenableFutureTask<RealtimeFeed> task = ListenableFutureTask.create(() -> fetchFeedsAndCreateGraph());
+                        executor.execute(task);
+                        return task;
+                    }
+                });
+    }
+
+    @Override
+    public RealtimeFeed provide() {
+        try {
+            return cache.get("pups");
+        } catch (ExecutionException | RuntimeException e) {
+            e.printStackTrace();
+            return RealtimeFeed.empty(gtfsStorage);
+        }
+    }
+
+    @Override
+    public void dispose(RealtimeFeed instance) {
+
+    }
+
+    private RealtimeFeed fetchFeedsAndCreateGraph() {
+        Map<String, GtfsRealtime.FeedMessage> feedMessageMap = new HashMap<>();
+        for (FeedConfiguration configuration : bundleConfiguration.gtfsrealtime().getFeeds()) {
+            try {
+                GtfsRealtime.FeedMessage feedMessage = GtfsRealtime.FeedMessage.parseFrom(httpClient.execute(new HttpGet(configuration.getUrl().toURI())).getEntity().getContent());
+                feedMessageMap.put(configuration.getFeedId(), feedMessage);
+            } catch (IOException | URISyntaxException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return RealtimeFeed.fromProtobuf(graphHopperStorage, gtfsStorage, ptFlagEncoder, feedMessageMap);
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/ws/LocationConverterProvider.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/ws/LocationConverterProvider.java
new file mode 100644
index 0000000000..05de238812
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/ws/LocationConverterProvider.java
@@ -0,0 +1,57 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.ws;
+
+import com.graphhopper.MultiException;
+import com.graphhopper.reader.gtfs.GHLocation;
+
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ParamConverter;
+import javax.ws.rs.ext.ParamConverterProvider;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+public class LocationConverterProvider implements ParamConverterProvider {
+
+    @Override
+    public <T> ParamConverter<T> getConverter(Class<T> rawType, Type genericType, Annotation[] annotations) {
+        if (rawType.equals(GHLocation.class)) {
+            return new ParamConverter<T>() {
+                @Override
+                public T fromString(String value) {
+                    try {
+                        return (T) GHLocation.fromString(value);
+                    } catch (IllegalArgumentException ex) {
+                        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)
+                                .entity(new MultiException(ex))
+                                .build());
+                    }
+                }
+
+                @Override
+                public String toString(T value) {
+                    return value.toString();
+                }
+            };
+        }
+        return null;
+    }
+}
+
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EmptyLocationIndex.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EmptyLocationIndex.java
index 4226826eaf..fa317e8539 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EmptyLocationIndex.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EmptyLocationIndex.java
@@ -21,6 +21,7 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.shapes.BBox;
 
 class EmptyLocationIndex implements LocationIndex {
     @Override
@@ -38,6 +39,10 @@ public QueryResult findClosest(double lat, double lon, EdgeFilter edgeFilter) {
         return new QueryResult(lat, lon);
     }
 
+    @Override
+    public void query(BBox queryBBox, Visitor function) {
+    }
+
     @Override
     public LocationIndex setApproximation(boolean approxDist) {
         return this;
@@ -45,7 +50,6 @@ public LocationIndex setApproximation(boolean approxDist) {
 
     @Override
     public void setSegmentSize(int bytes) {
-
     }
 
     @Override
@@ -60,12 +64,10 @@ public LocationIndex create(long byteCount) {
 
     @Override
     public void flush() {
-
     }
 
     @Override
     public void close() {
-
     }
 
     @Override
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHLocation.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHLocation.java
new file mode 100644
index 0000000000..d2dc2c6719
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHLocation.java
@@ -0,0 +1,38 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.graphhopper.util.shapes.GHPoint;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class GHLocation {
+
+    private static final Pattern PATTERN = Pattern.compile("^Stop\\((.*)\\)$");
+
+    public static GHLocation fromString(String s) {
+        final Matcher matcher = PATTERN.matcher(s);
+        if (matcher.find()) {
+            return new GHStationLocation(matcher.group(1));
+        } else {
+            return new GHPointLocation(GHPoint.fromString(s));
+        }
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHPointLocation.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHPointLocation.java
new file mode 100644
index 0000000000..ab64514de5
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHPointLocation.java
@@ -0,0 +1,34 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.graphhopper.util.shapes.GHPoint;
+
+public class GHPointLocation extends GHLocation {
+    public final GHPoint ghPoint;
+
+    public GHPointLocation(GHPoint ghPoint) {
+        this.ghPoint = ghPoint;
+    }
+
+    @Override
+    public String toString() {
+        return ghPoint.toString();
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHStationLocation.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHStationLocation.java
new file mode 100644
index 0000000000..29d47a06c1
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHStationLocation.java
@@ -0,0 +1,27 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+public class GHStationLocation extends GHLocation {
+    public final String stop_id;
+
+    public GHStationLocation(String ghPoint) {
+        this.stop_id = ghPoint;
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
index 2d6cdaa513..978b5770d4 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
@@ -18,13 +18,10 @@
 
 package com.graphhopper.reader.gtfs;
 
-import com.google.common.collect.ArrayListMultimap;
-import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
@@ -45,17 +42,12 @@
     private final GtfsStorage gtfsStorage;
     private final RealtimeFeed realtimeFeed;
     private final boolean reverse;
-    private final List<EdgeIteratorState> extraEdges = new ArrayList<>();
-    private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesBySource = ArrayListMultimap.create();
-    private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesByDestination = ArrayListMultimap.create();
-    private final Graph graph;
     private final Weighting accessEgressWeighting;
     private final boolean walkOnly;
     private double walkSpeedKmH;
 
 
-    public GraphExplorer(Graph graph, Weighting accessEgressWeighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, List<VirtualEdgeIteratorState> extraEdges, boolean walkOnly, double walkSpeedKmh) {
-        this.graph = graph;
+    public GraphExplorer(Graph graph, Weighting accessEgressWeighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, boolean walkOnly, double walkSpeedKmh) {
         this.accessEgressWeighting = accessEgressWeighting;
         DefaultEdgeFilter accessEgressIn = DefaultEdgeFilter.inEdges(accessEgressWeighting.getFlagEncoder());
         DefaultEdgeFilter accessEgressOut = DefaultEdgeFilter.outEdges(accessEgressWeighting.getFlagEncoder());
@@ -68,27 +60,15 @@ public GraphExplorer(Graph graph, Weighting accessEgressWeighting, PtFlagEncoder
         this.gtfsStorage = gtfsStorage;
         this.realtimeFeed = realtimeFeed;
         this.reverse = reverse;
-        this.extraEdges.addAll(extraEdges);
-        for (VirtualEdgeIteratorState extraEdge : extraEdges) {
-            if (extraEdge == null) {
-                throw new RuntimeException();
-            }
-            extraEdgesBySource.put(extraEdge.getBaseNode(), extraEdge);
-            extraEdgesByDestination.put(extraEdge.getAdjNode(), new VirtualEdgeIteratorState(extraEdge.getOriginalEdgeKey(), extraEdge.getEdge(), extraEdge.getAdjNode(),
-                    extraEdge.getBaseNode(), extraEdge.getDistance(), extraEdge.getFlags(), extraEdge.getName(), extraEdge.fetchWayGeometry(3), false));
-        }
         this.walkOnly = walkOnly;
         this.walkSpeedKmH = walkSpeedKmh;
     }
 
     Stream<EdgeIteratorState> exploreEdgesAround(Label label) {
-        final List<VirtualEdgeIteratorState> extraEdges = reverse ? extraEdgesByDestination.get(label.adjNode) : extraEdgesBySource.get(label.adjNode);
-        return Stream.concat(
-                label.adjNode < graph.getNodes() ? mainEdgesAround(label) : Stream.empty(),
-                extraEdges.stream()).filter(new EdgeIteratorStatePredicate(label));
+        return allEdgesAround(label).filter(new EdgeIteratorStatePredicate(label));
     }
 
-    private Stream<EdgeIteratorState> mainEdgesAround(Label label) {
+    private Stream<EdgeIteratorState> allEdgesAround(Label label) {
         return StreamSupport.stream(new Spliterators.AbstractSpliterator<EdgeIteratorState>(0, 0) {
             EdgeIterator edgeIterator = edgeExplorer.setBaseNode(label.adjNode);
 
@@ -191,33 +171,6 @@ int calcNTransfers(EdgeIteratorState edge) {
         return edge.get(flagEncoder.getTransfersEnc());
     }
 
-    EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
-        if (edgeId == -1) {
-            throw new RuntimeException();
-        }
-        for (EdgeIteratorState extraEdge : extraEdges) {
-            if (extraEdge.getEdge() == edgeId) {
-                if (extraEdge.getAdjNode() != adjNode) {
-                    throw new IllegalStateException();
-                }
-                return extraEdge;
-            }
-        }
-        EdgeIteratorState edge = graph.getEdgeIteratorState(edgeId, adjNode);
-        if (edge.getAdjNode() != adjNode) {
-            throw new IllegalStateException();
-        }
-        return edge;
-    }
-
-    NodeAccess getNodeAccess() {
-        return graph.getNodeAccess();
-    }
-
-    public Graph getGraph() {
-        return graph;
-    }
-
     private class EdgeIteratorStatePredicate implements Predicate<EdgeIteratorState> {
         private final Label label;
         boolean foundEnteredTimeExpandedNetworkEdge;
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index 9f497b0d8b..df65883599 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -20,8 +20,12 @@
 
 import com.conveyal.gtfs.GTFSFeed;
 import com.conveyal.gtfs.model.Transfer;
+import com.fasterxml.jackson.databind.node.ObjectNode;
 import com.google.transit.realtime.GtfsRealtime;
-import com.graphhopper.*;
+import com.graphhopper.GHResponse;
+import com.graphhopper.PathWrapper;
+import com.graphhopper.Trip;
+import com.graphhopper.http.WebHelper;
 import com.graphhopper.reader.osm.OSMReader;
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.VirtualEdgeIteratorState;
@@ -39,6 +43,9 @@
 import com.graphhopper.util.exceptions.PointNotFoundException;
 import com.graphhopper.util.shapes.GHPoint;
 
+import javax.inject.Inject;
+import javax.ws.rs.*;
+import javax.ws.rs.core.MediaType;
 import java.io.File;
 import java.io.IOException;
 import java.time.Instant;
@@ -48,9 +55,8 @@
 import java.util.stream.Stream;
 import java.util.zip.ZipFile;
 
-import static com.graphhopper.util.Parameters.PT.PROFILE_QUERY;
-
-public final class GraphHopperGtfs implements GraphHopperAPI {
+@Path("route")
+public final class GraphHopperGtfs {
 
     public static class Factory {
         private final TranslationMap translationMap;
@@ -67,7 +73,7 @@ private Factory(PtFlagEncoder flagEncoder, TranslationMap translationMap, GraphH
             this.gtfsStorage = gtfsStorage;
         }
 
-        public GraphHopperGtfs createWith(GtfsRealtime.FeedMessage realtimeFeed, String agencyId) {
+        public GraphHopperGtfs createWith(GtfsRealtime.FeedMessage realtimeFeed) {
             Map<String, GtfsRealtime.FeedMessage> realtimeFeeds = new HashMap<>();
             realtimeFeeds.put("gtfs_0", realtimeFeed);
             return new GraphHopperGtfs(flagEncoder, translationMap, graphHopperStorage, locationIndex, gtfsStorage, RealtimeFeed.fromProtobuf(graphHopperStorage, gtfsStorage, flagEncoder, realtimeFeeds));
@@ -103,8 +109,8 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
         private final double walkSpeedKmH;
         private final double maxWalkDistancePerLeg;
         private final int blockedRouteTypes;
-        private final GHPoint enter;
-        private final GHPoint exit;
+        private final GHLocation enter;
+        private final GHLocation exit;
         private final Translation translation;
         private final List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>(realtimeFeed.getAdditionalEdges());
 
@@ -114,43 +120,58 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
         private GraphExplorer graphExplorer;
         private int visitedNodes;
 
-        RequestHandler(GHRequest request) {
-            maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, 1_000_000);
-            profileQuery = request.getHints().getBool(PROFILE_QUERY, false);
-            ignoreTransfers = request.getHints().getBool(Parameters.PT.IGNORE_TRANSFERS, profileQuery);
-            betaTransfers = request.getHints().getDouble("beta_transfers", 0.0);
-            betaWalkTime = request.getHints().getDouble("beta_walk_time", 1.0);
-            limitSolutions = request.getHints().getInt(Parameters.PT.LIMIT_SOLUTIONS, profileQuery ? 5 : ignoreTransfers ? 1 : Integer.MAX_VALUE);
-            final String departureTimeString = request.getHints().get(Parameters.PT.EARLIEST_DEPARTURE_TIME, "");
-            try {
-                initialTime = Instant.parse(departureTimeString);
-            } catch (DateTimeParseException e) {
-                throw new IllegalArgumentException(String.format(Locale.ROOT, "Illegal value for required parameter %s: [%s]", Parameters.PT.EARLIEST_DEPARTURE_TIME, departureTimeString));
-            }
-            arriveBy = request.getHints().getBool(Parameters.PT.ARRIVE_BY, false);
-            walkSpeedKmH = request.getHints().getDouble(Parameters.PT.WALK_SPEED, 5.0);
-            blockedRouteTypes = request.getHints().getInt(Parameters.PT.BLOCKED_ROUTE_TYPES, 0);
+        RequestHandler(Request request) {
+            maxVisitedNodesForRequest = request.getMaxVisitedNodes();
+            profileQuery = request.isProfileQuery();
+            ignoreTransfers = Optional.ofNullable(request.getIgnoreTransfers()).orElse(request.isProfileQuery());
+            betaTransfers = request.getBetaTransfers();
+            betaWalkTime = request.getBetaWalkTime();
+            limitSolutions = Optional.ofNullable(request.getLimitSolutions()).orElse(profileQuery ? 5 : ignoreTransfers ? 1 : Integer.MAX_VALUE);
+            initialTime = request.getEarliestDepartureTime();
+            arriveBy = request.isArriveBy();
+            walkSpeedKmH = request.getWalkSpeedKmH();
+            blockedRouteTypes = request.getBlockedRouteTypes();
             translation = translationMap.getWithFallBack(request.getLocale());
             if (request.getPoints().size() != 2) {
                 throw new IllegalArgumentException("Exactly 2 points have to be specified, but was:" + request.getPoints().size());
             }
             enter = request.getPoints().get(0);
             exit = request.getPoints().get(1);
-            maxWalkDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, Integer.MAX_VALUE);
+            maxWalkDistancePerLeg = request.getMaxWalkDistancePerLeg();
         }
 
         GHResponse route() {
             StopWatch stopWatch = new StopWatch().start();
-
+            ArrayList<QueryResult> pointQueryResults = new ArrayList<>();
             ArrayList<QueryResult> allQueryResults = new ArrayList<>();
-
-            QueryResult source = findClosest(enter, 0);
-            QueryResult dest = findClosest(exit, 1);
-            allQueryResults.add(source);
-            allQueryResults.add(dest);
-            queryGraph.lookup(Arrays.asList(source, dest)); // modifies queryGraph, source and dest!
-
-            PointList startAndEndpoint = pointListFrom(Arrays.asList(source, dest));
+            PointList points = new PointList(2, false);
+            if (enter instanceof GHPointLocation) {
+                final QueryResult closest = findClosest(((GHPointLocation) enter).ghPoint, 0);
+                pointQueryResults.add(closest);
+                allQueryResults.add(closest);
+                points.add(closest.getSnappedPoint());
+            } else if (enter instanceof GHStationLocation) {
+                final String stop_id = ((GHStationLocation) enter).stop_id;
+                final int node = gtfsStorage.getStationNodes().get(stop_id);
+                final QueryResult station = new QueryResult(graphHopperStorage.getNodeAccess().getLat(node), graphHopperStorage.getNodeAccess().getLon(node));
+                station.setClosestNode(node);
+                allQueryResults.add(station);
+                points.add(graphHopperStorage.getNodeAccess().getLat(node), graphHopperStorage.getNodeAccess().getLon(node));
+            }
+            if (exit instanceof GHPointLocation) {
+                final QueryResult closest = findClosest(((GHPointLocation) exit).ghPoint, 1);
+                pointQueryResults.add(closest);
+                allQueryResults.add(closest);
+                points.add(closest.getSnappedPoint());
+            } else if (exit instanceof GHStationLocation) {
+                final String stop_id = ((GHStationLocation) exit).stop_id;
+                final int node = gtfsStorage.getStationNodes().get(stop_id);
+                final QueryResult station = new QueryResult(graphHopperStorage.getNodeAccess().getLat(node), graphHopperStorage.getNodeAccess().getLon(node));
+                station.setClosestNode(node);
+                allQueryResults.add(station);
+                points.add(graphHopperStorage.getNodeAccess().getLat(node), graphHopperStorage.getNodeAccess().getLon(node));
+            }
+            queryGraph.lookup(pointQueryResults); // modifies queryGraph and queryResults!
             response.addDebugInfo("idLookup:" + stopWatch.stop().getSeconds() + "s");
 
             int startNode;
@@ -163,7 +184,7 @@ GHResponse route() {
                 destNode = allQueryResults.get(1).getClosestNode();
             }
             List<List<Label.Transition>> solutions = findPaths(startNode, destNode);
-            parseSolutionsAndAddToResponse(solutions, startAndEndpoint);
+            parseSolutionsAndAddToResponse(solutions, points);
             return response;
         }
 
@@ -181,7 +202,7 @@ private QueryResult findClosest(GHPoint point, int indexForErrorMessage) {
 
         private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutions, PointList waypoints) {
             for (List<Label.Transition> solution : solutions) {
-                final List<Trip.Leg> legs = tripFromLabel.getTrip(translation, graphExplorer, accessEgressWeighting, solution);
+                final List<Trip.Leg> legs = tripFromLabel.getTrip(translation, queryGraph, accessEgressWeighting, solution);
                 final PathWrapper pathWrapper = tripFromLabel.createPathWrapper(translation, waypoints, legs);
                 pathWrapper.setImpossible(solution.stream().anyMatch(t -> t.label.impossible));
                 pathWrapper.setTime((solution.get(solution.size() - 1).label.currentTime - solution.get(0).label.currentTime));
@@ -194,7 +215,7 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
 
         private List<List<Label.Transition>> findPaths(int startNode, int destNode) {
             StopWatch stopWatch = new StopWatch().start();
-            final GraphExplorer accessEgressGraphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, !arriveBy, extraEdges, true, walkSpeedKmH);
+            final GraphExplorer accessEgressGraphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, !arriveBy, true, walkSpeedKmH);
             boolean reverse = !arriveBy;
             GtfsStorage.EdgeType edgeType = reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT;
             MultiCriteriaLabelSetting stationRouter = new MultiCriteriaLabelSetting(accessEgressGraphExplorer, flagEncoder, reverse, maxWalkDistancePerLeg, false, false, false, maxVisitedNodesForRequest, new ArrayList<>());
@@ -206,7 +227,7 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
                 if (label.adjNode == startNode) {
                     stationLabels.add(label);
                     break;
-                } else if (label.edge != -1 && accessEgressGraphExplorer.getEdgeIteratorState(label.edge, label.parent.adjNode).get(flagEncoder.getTypeEnc()) == edgeType) {
+                } else if (label.edge != -1 && queryGraph.getEdgeIteratorState(label.edge, label.parent.adjNode).get(flagEncoder.getTypeEnc()) == edgeType) {
                     stationLabels.add(label);
                 }
             }
@@ -217,7 +238,7 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
                 reverseSettledSet.put(stationLabel.adjNode, stationLabel);
             }
 
-            graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, extraEdges, false, walkSpeedKmH);
+            graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, false, walkSpeedKmH);
             List<Label> discoveredSolutions = new ArrayList<>();
             final long smallestStationLabelWeight;
             MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, arriveBy, maxWalkDistancePerLeg, true, !ignoreTransfers, profileQuery, maxVisitedNodesForRequest, discoveredSolutions);
@@ -258,12 +279,12 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
 
             List<List<Label.Transition>> pathsToStations = discoveredSolutions.stream()
                     .map(originalSolutions::get)
-                    .map(l -> new TripFromLabel(gtfsStorage, realtimeFeed).getTransitions(arriveBy, flagEncoder, graphExplorer, l)).collect(Collectors.toList());
+                    .map(l -> tripFromLabel.getTransitions(arriveBy, flagEncoder, queryGraph, l)).collect(Collectors.toList());
 
             List<List<Label.Transition>> paths = pathsToStations.stream().map(p -> {
                 if (arriveBy) {
                     List<Label.Transition> pp = new ArrayList<>(p.subList(1, p.size()));
-                    List<Label.Transition> pathFromStation = pathFromStation(accessEgressGraphExplorer, reverseSettledSet.get(p.get(0).label.adjNode));
+                    List<Label.Transition> pathFromStation = pathFromStation(reverseSettledSet.get(p.get(0).label.adjNode));
                     long diff = p.get(0).label.currentTime - pathFromStation.get(pathFromStation.size() - 1).label.currentTime;
                     List<Label.Transition> patchedPathFromStation = pathFromStation.stream().map(t -> {
                         return new Label.Transition(new Label(t.label.currentTime + diff, t.label.edge, t.label.adjNode, t.label.nTransfers, t.label.nWalkDistanceConstraintViolations, t.label.walkDistanceOnCurrentLeg, t.label.departureTime, t.label.walkTime, t.label.residualDelay, t.label.impossible, null), t.edge);
@@ -272,7 +293,7 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
                     return pp;
                 } else {
                     List<Label.Transition> pp = new ArrayList<>(p);
-                    List<Label.Transition> pathFromStation = pathFromStation(accessEgressGraphExplorer, reverseSettledSet.get(p.get(p.size() - 1).label.adjNode));
+                    List<Label.Transition> pathFromStation = pathFromStation(reverseSettledSet.get(p.get(p.size() - 1).label.adjNode));
                     long diff = p.get(p.size() - 1).label.currentTime - pathFromStation.get(0).label.currentTime;
                     List<Label.Transition> patchedPathFromStation = pathFromStation.subList(1, pathFromStation.size()).stream().map(t -> {
                         return new Label.Transition(new Label(t.label.currentTime + diff, t.label.edge, t.label.adjNode, t.label.nTransfers, t.label.nWalkDistanceConstraintViolations, t.label.walkDistanceOnCurrentLeg, t.label.departureTime, t.label.walkTime, t.label.residualDelay, t.label.impossible, null), t.edge);
@@ -295,11 +316,12 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
             return paths;
         }
 
-        private List<Label.Transition> pathFromStation(GraphExplorer accessEgressGraphExplorer, Label l) {
-            return new TripFromLabel(gtfsStorage, realtimeFeed).getTransitions(!arriveBy, flagEncoder, accessEgressGraphExplorer, l);
+        private List<Label.Transition> pathFromStation(Label l) {
+            return tripFromLabel.getTransitions(!arriveBy, flagEncoder, queryGraph, l);
         }
     }
 
+    @Inject
     public GraphHopperGtfs(PtFlagEncoder flagEncoder, TranslationMap translationMap, GraphHopperStorage graphHopperStorage, LocationIndex locationIndex, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed) {
         this.flagEncoder = flagEncoder;
         this.accessEgressWeighting = new FastestWeighting(graphHopperStorage.getEncodingManager().getEncoder("foot"));
@@ -388,12 +410,36 @@ public static LocationIndex createOrLoadIndex(GHDirectory directory, GraphHopper
         return locationIndex;
     }
 
-    public boolean load(String graphHopperFolder) {
-        throw new IllegalStateException("We are always loaded, or we wouldn't exist.");
+    @GET
+    @Produces(MediaType.APPLICATION_JSON)
+    public ObjectNode route(@QueryParam("point") List<GHLocation> requestPoints,
+                            @QueryParam(Parameters.PT.EARLIEST_DEPARTURE_TIME) String departureTimeString,
+                            @QueryParam("locale") String localeStr,
+                            @QueryParam(Parameters.PT.IGNORE_TRANSFERS) Boolean ignoreTransfers,
+                            @QueryParam(Parameters.PT.PROFILE_QUERY) Boolean profileQuery,
+                            @QueryParam(Parameters.PT.LIMIT_SOLUTIONS) Integer limitSolutions) {
+
+        if (departureTimeString == null) {
+            throw new BadRequestException(String.format(Locale.ROOT, "Illegal value for required parameter %s: [%s]", Parameters.PT.EARLIEST_DEPARTURE_TIME, departureTimeString));
+        }
+        Instant departureTime;
+        try {
+            departureTime = Instant.parse(departureTimeString);
+        } catch (DateTimeParseException e) {
+            throw new BadRequestException(String.format(Locale.ROOT, "Illegal value for required parameter %s: [%s]", Parameters.PT.EARLIEST_DEPARTURE_TIME, departureTimeString));
+        }
+
+        Request request = new Request(requestPoints, departureTime);
+        Optional.ofNullable(profileQuery).ifPresent(request::setProfileQuery);
+        Optional.ofNullable(ignoreTransfers).ifPresent(request::setIgnoreTransfers);
+        Optional.ofNullable(localeStr).ifPresent(s -> request.setLocale(Helper.getLocale(s)));
+        Optional.ofNullable(limitSolutions).ifPresent(request::setLimitSolutions);
+
+        GHResponse route = new RequestHandler(request).route();
+        return WebHelper.jsonObject(route, true, true, false, false, 0.0f);
     }
 
-    @Override
-    public GHResponse route(GHRequest request) {
+    public GHResponse route(Request request) {
         return new RequestHandler(request).route();
     }
 
@@ -421,7 +467,7 @@ public GHResponse route(GHRequest request) {
 
                     QueryGraph queryGraph = new QueryGraph(graphHopperStorage);
                     queryGraph.lookup(Collections.emptyList());
-                    final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, false, Collections.emptyList(), true, 5.0);
+                    final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, false, true, 5.0);
 
                     MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, false, Double.MAX_VALUE, false, false, false, Integer.MAX_VALUE, new ArrayList<>());
                     Iterator<Label> iterator = router.calcLabels(fromnode, tonode, Instant.ofEpochMilli(0), 0).iterator();
@@ -444,12 +490,4 @@ public GHResponse route(GHRequest request) {
                 });
     }
 
-    private PointList pointListFrom(List<QueryResult> queryResults) {
-        PointList waypoints = new PointList(queryResults.size(), true);
-        for (QueryResult qr : queryResults) {
-            waypoints.add(qr.getSnappedPoint());
-        }
-        return waypoints;
-    }
-
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphSupport.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphSupport.java
index 53b85c0ed3..ad73a38a63 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphSupport.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphSupport.java
@@ -312,6 +312,11 @@ public GraphExtension getExtension() {
             public int getOtherNode(int edge, int node) {
                 throw new UnsupportedOperationException();
             }
+
+            @Override
+            public boolean isAdjacentToNode(int edge, int node) {
+                throw new UnsupportedOperationException();
+            }
         };
     }
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java
index bee02ff8eb..68e43af17d 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java
@@ -19,6 +19,7 @@
 
 import java.text.SimpleDateFormat;
 import java.time.LocalDateTime;
+import java.time.LocalTime;
 import java.util.Date;
 import java.util.Locale;
 
@@ -47,7 +48,11 @@ public static int time(int hours, int minutes) {
     }
     
     public static int time(LocalDateTime localDateTime) {
-        return time(localDateTime.getHour(), localDateTime.getMinute(), 0);
+        return time(localDateTime.getHour(), localDateTime.getMinute(), localDateTime.getSecond());
+    }
+
+    public static int time(LocalTime localTime) {
+        return time(localTime.getHour(), localTime.getMinute(), localTime.getSecond());
     }
 
     public static LocalDateTime localDateTimeFromDate(Date date) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
index 2b0ce9a2ee..04ce0bf650 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
@@ -123,7 +123,10 @@ void connectStopsToStreetNetwork() {
                 } else {
                     streetNode = locationQueryResult.getClosestNode();
                 }
-                gtfsStorage.getStationNodes().put(stop.stop_id, streetNode);
+                Integer prev = gtfsStorage.getStationNodes().put(stop.stop_id, streetNode);
+                if (prev != null) {
+                    throw new RuntimeException("Duplicate stop id: "+stop.stop_id);
+                }
             }
         }
     }
@@ -658,7 +661,8 @@ private void insertOutboundTransfers(String toStopId, String toRouteId, int mini
 
     private String getRouteName(GTFSFeed feed, Trip trip) {
         Route route = feed.routes.get(trip.route_id);
-        return (route.route_long_name != null ? route.route_long_name : route.route_short_name) + " " + trip.trip_headsign;
+        String routePart = route != null ? (route.route_long_name != null ? route.route_long_name : route.route_short_name) : "extra";
+        return routePart + " " + trip.trip_headsign;
     }
 
     private void setEdgeTypeAndClearDistance(EdgeIteratorState edge, GtfsStorage.EdgeType edgeType) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
index 03d92d02c8..d584c7020a 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.reader.gtfs;
 
+import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIteratorState;
 
 import java.time.Instant;
@@ -63,20 +64,21 @@ public String toString() {
 
     public final long currentTime;
 
-    final int edge;
+    public final int edge;
     public final int adjNode;
 
-    final int nTransfers;
-    final int nWalkDistanceConstraintViolations;
+    public final int nTransfers;
+    public final int nWalkDistanceConstraintViolations;
 
-    final double walkDistanceOnCurrentLeg;
-    final Long departureTime;
-    final long walkTime;
+    public final double walkDistanceOnCurrentLeg;
+    public final Long departureTime;
+    public final long walkTime;
 
     final long residualDelay;
     final boolean impossible;
 
-    final Label parent;
+    public final Label parent;
+    public boolean deleted = false;
 
     Label(long currentTime, int edgeId, int adjNode, int nTransfers, int nWalkDistanceConstraintViolations, double walkDistance, Long departureTime, long walkTime, long residualDelay, boolean impossible, Label parent) {
         this.currentTime = currentTime;
@@ -97,7 +99,7 @@ public String toString() {
         return adjNode + " " + Instant.ofEpochMilli(currentTime) + " " + nTransfers + " " + nWalkDistanceConstraintViolations + " " +  (departureTime != null ? Instant.ofEpochMilli(departureTime) : "");
     }
 
-    static Iterable<Transition> reverseEdges(Label leaf, GraphExplorer graph, PtFlagEncoder flagEncoder, boolean reverseEdgeFlags) {
+    static Iterable<Transition> reverseEdges(Label leaf, Graph graph, PtFlagEncoder flagEncoder, boolean reverseEdgeFlags) {
         return new Iterable<Transition>() {
             @Override
             public Iterator<Transition> iterator() {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
index d766040745..e605759a3c 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
@@ -43,6 +43,10 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
 import java.time.*;
 import java.time.temporal.ChronoUnit;
 import java.util.*;
@@ -250,6 +254,11 @@ public GraphExtension getExtension() {
             public int getOtherNode(int edge, int node) {
                 throw new UnsupportedOperationException();
             }
+
+            @Override
+            public boolean isAdjacentToNode(int edge, int node) {
+                throw new UnsupportedOperationException();
+            }
         };
 
         Map<GtfsStorage.Validity, Integer> operatingDayPatterns = new HashMap<>(staticGtfs.getOperatingDayPatterns());
@@ -405,17 +414,28 @@ boolean isBlocked(int edgeId) {
     }
 
     public Optional<GtfsReader.TripWithStopTimes> getTripUpdate(GTFSFeed staticFeed, GtfsRealtime.TripDescriptor tripDescriptor, Label.Transition boardEdge, Instant boardTime) {
-        logger.trace("getTripUpdate {}", tripDescriptor);
-        if (!isThisRealtimeUpdateAboutThisLineRun(boardEdge.edge.edgeIteratorState, boardTime)) {
+        try {
+            logger.trace("getTripUpdate {}", tripDescriptor);
+            if (!isThisRealtimeUpdateAboutThisLineRun(boardEdge.edge.edgeIteratorState, boardTime)) {
+                return Optional.empty();
+            } else {
+                GtfsRealtime.TripDescriptor normalizedTripDescriptor = normalize(tripDescriptor);
+                return feedMessages.values().stream().flatMap(feedMessage -> feedMessage.getEntityList().stream()
+                        .filter(e -> e.hasTripUpdate())
+                        .map(e -> e.getTripUpdate())
+                        .filter(tu -> normalize(tu.getTrip()).equals(normalizedTripDescriptor))
+                        .map(tu -> toTripWithStopTimes(staticFeed, tu)))
+                        .findFirst();
+            }
+        } catch (RuntimeException e) {
+            feedMessages.forEach((name, feed) -> {
+                try (OutputStream s = new FileOutputStream(name+".gtfsdump")) {
+                    feed.writeTo(s);
+                } catch (IOException e1) {
+                    throw new RuntimeException();
+                }
+            });
             return Optional.empty();
-        } else {
-            GtfsRealtime.TripDescriptor normalizedTripDescriptor = normalize(tripDescriptor);
-            return feedMessages.values().stream().flatMap(feedMessage -> feedMessage.getEntityList().stream()
-                    .filter(e -> e.hasTripUpdate())
-                    .map(e -> e.getTripUpdate())
-                    .filter(tu -> normalize(tu.getTrip()).equals(normalizedTripDescriptor))
-                    .map(tu -> toTripWithStopTimes(staticFeed, tu)))
-                    .findFirst();
         }
     }
 
@@ -506,6 +526,9 @@ boolean isBlocked(int edgeId) {
                 stopTimes.add(stopTime);
                 logger.trace("Number of stop times: {}", stopTimes.size());
             } else {
+                // http://localhost:3000/route?point=45.51043713898763%2C-122.68381118774415&point=45.522104713562825%2C-122.6455307006836&weighting=fastest&pt.earliest_departure_time=2018-08-24T16%3A56%3A17Z&arrive_by=false&pt.max_walk_distance_per_leg=1000&pt.limit_solutions=5&locale=en-US&vehicle=pt&elevation=false&use_miles=false&points_encoded=false&pt.profile=true
+                // long query:
+                // http://localhost:3000/route?point=45.518526513612244%2C-122.68612861633302&point=45.52908004573869%2C-122.6862144470215&weighting=fastest&pt.earliest_departure_time=2018-08-24T16%3A51%3A20Z&arrive_by=false&pt.max_walk_distance_per_leg=10000&pt.limit_solutions=4&locale=en-US&vehicle=pt&elevation=false&use_miles=false&points_encoded=false&pt.profile=true
                 throw new RuntimeException();
             }
         }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Request.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Request.java
new file mode 100644
index 0000000000..c328a55d93
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Request.java
@@ -0,0 +1,152 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.GHPoint;
+
+import java.time.Instant;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Locale;
+
+public class Request {
+    private List<GHLocation> points;
+    private Instant earliestDepartureTime;
+    private int maxVisitedNodes = 1_000_000;
+    private boolean profileQuery;
+    private Boolean ignoreTransfers;
+    private double betaTransfers = 0.0;
+    private double betaWalkTime = 1.0;
+    private Integer limitSolutions;
+    private boolean arriveBy;
+    private double walkSpeedKmH = 5.0;
+    private int blockedRouteTypes;
+    private Locale locale = Helper.getLocale("en");
+    private double maxWalkDistancePerLeg = Integer.MAX_VALUE;
+
+    public Request(List<GHLocation> points, Instant departureTime) {
+        this.points = points;
+        this.earliestDepartureTime = departureTime;
+    }
+
+    public Request(double from_lat, double from_lon, double to_lat, double to_lon) {
+        this.points = Arrays.asList(new GHPointLocation(new GHPoint(from_lat, from_lon)), new GHPointLocation(new GHPoint(to_lat, to_lon)));
+    }
+
+    public int getMaxVisitedNodes() {
+        return maxVisitedNodes;
+    }
+
+    public void setMaxVisitedNodes(int maxVisitedNodes) {
+        this.maxVisitedNodes = maxVisitedNodes;
+    }
+
+    public boolean isProfileQuery() {
+        return profileQuery;
+    }
+
+    public void setProfileQuery(boolean profileQuery) {
+        this.profileQuery = profileQuery;
+    }
+
+    public Boolean getIgnoreTransfers() {
+        return ignoreTransfers;
+    }
+
+    public void setIgnoreTransfers(Boolean ignoreTransfers) {
+        this.ignoreTransfers = ignoreTransfers;
+    }
+
+    public double getBetaTransfers() {
+        return betaTransfers;
+    }
+
+    public void setBetaTransfers(double betaTransfers) {
+        this.betaTransfers = betaTransfers;
+    }
+
+    public double getBetaWalkTime() {
+        return betaWalkTime;
+    }
+
+    public void setBetaWalkTime(double betaWalkTime) {
+        this.betaWalkTime = betaWalkTime;
+    }
+
+    public Integer getLimitSolutions() {
+        return limitSolutions;
+    }
+
+    public void setLimitSolutions(Integer limitSolutions) {
+        this.limitSolutions = limitSolutions;
+    }
+
+    public Instant getEarliestDepartureTime() {
+        return earliestDepartureTime;
+    }
+
+    public void setEarliestDepartureTime(Instant earliestDepartureTime) {
+        this.earliestDepartureTime = earliestDepartureTime;
+    }
+
+    public boolean isArriveBy() {
+        return arriveBy;
+    }
+
+    public void setArriveBy(boolean arriveBy) {
+        this.arriveBy = arriveBy;
+    }
+
+    public double getWalkSpeedKmH() {
+        return walkSpeedKmH;
+    }
+
+    public void setWalkSpeedKmH(double walkSpeedKmH) {
+        this.walkSpeedKmH = walkSpeedKmH;
+    }
+
+    public int getBlockedRouteTypes() {
+        return blockedRouteTypes;
+    }
+
+    public void setBlockedRouteTypes(int blockedRouteTypes) {
+        this.blockedRouteTypes = blockedRouteTypes;
+    }
+
+    public Locale getLocale() {
+        return locale;
+    }
+
+    public void setLocale(Locale locale) {
+        this.locale = locale;
+    }
+
+    public List<GHLocation> getPoints() {
+        return points;
+    }
+
+    public double getMaxWalkDistancePerLeg() {
+        return maxWalkDistancePerLeg;
+    }
+
+    public void setMaxWalkDistancePerLeg(double maxWalkDistancePerLeg) {
+        this.maxWalkDistancePerLeg = maxWalkDistancePerLeg;
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Transfers.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Transfers.java
index 2de446bad3..4577bacada 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Transfers.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Transfers.java
@@ -94,10 +94,10 @@ private Transfer findMostSpecificRule(List<Transfer> transfers, String fromRoute
         final ArrayList<Transfer> transfersBySpecificity = new ArrayList<>(transfers);
         transfersBySpecificity.sort(Comparator.comparingInt(t -> {
             int score = 0;
-            if (fromRouteId.equals(t.from_route_id)) {
+            if (Objects.equals(fromRouteId, t.from_route_id)) {
                 score++;
             }
-            if (toRouteId.equals(t.to_route_id)) {
+            if (Objects.equals(toRouteId, t.to_route_id)) {
                 score++;
             }
             return -score;
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
index dd602d699f..7749ac871c 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
@@ -29,6 +29,7 @@
 import com.graphhopper.routing.InstructionsFromEdges;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
 import com.graphhopper.util.*;
 import org.locationtech.jts.geom.Coordinate;
 import org.locationtech.jts.geom.Geometry;
@@ -60,11 +61,6 @@
         this.realtimeFeed = realtimeFeed;
     }
 
-    PathWrapper parseSolutionIntoPath(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, Weighting weighting, Label solution, PointList waypoints) {
-        final List<Trip.Leg> legs = getTrip(arriveBy, encoder, tr, queryGraph, weighting, solution);
-        return createPathWrapper(tr, waypoints, legs);
-    }
-
     PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg> legs) {
         if (legs.size() > 1 && legs.get(0) instanceof Trip.WalkLeg) {
             final Trip.WalkLeg accessLeg = (Trip.WalkLeg) legs.get(0);
@@ -120,18 +116,13 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
         return path;
     }
 
-    List<Trip.Leg> getTrip(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, Weighting weighting, Label solution) {
-        List<Label.Transition> transitions = getTransitions(arriveBy, encoder, queryGraph, solution);
-        return getTrip(tr, queryGraph, weighting, transitions);
-    }
-
-    List<Trip.Leg> getTrip(Translation tr, GraphExplorer queryGraph, Weighting weighting, List<Label.Transition> transitions) {
+    List<Trip.Leg> getTrip(Translation tr, Graph queryGraph, Weighting weighting, List<Label.Transition> transitions) {
         final List<List<Label.Transition>> partitions = getPartitions(transitions);
         final List<Trip.Leg> legs = getLegs(tr, queryGraph, weighting, partitions);
         return legs;
     }
 
-    List<Label.Transition> getTransitions(boolean arriveBy, PtFlagEncoder encoder, GraphExplorer queryGraph, Label solution) {
+    List<Label.Transition> getTransitions(boolean arriveBy, PtFlagEncoder encoder, Graph queryGraph, Label solution) {
         List<Label.Transition> transitions = new ArrayList<>();
         if (arriveBy) {
             reverseEdges(solution, queryGraph, encoder, false)
@@ -162,7 +153,7 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
         return partitions;
     }
 
-    private List<Trip.Leg> getLegs(Translation tr, GraphExplorer queryGraph, Weighting weighting, List<List<Label.Transition>> partitions) {
+    private List<Trip.Leg> getLegs(Translation tr, Graph queryGraph, Weighting weighting, List<List<Label.Transition>> partitions) {
         return partitions.stream().flatMap(partition -> parsePathIntoLegs(partition, queryGraph, weighting, tr).stream()).collect(Collectors.toList());
     }
 
@@ -194,7 +185,7 @@ private InstructionList getInstructions(Translation tr, List<Trip.Leg> legs) {
                 arrivalPointList.add(arrivalStop.geometry.getY(), arrivalStop.geometry.getX());
                 Instruction arrivalInstruction = new Instruction(Instruction.PT_END_TRIP, arrivalStop.stop_name, InstructionAnnotation.EMPTY, arrivalPointList);
                 if (ptLeg.isInSameVehicleAsPrevious) {
-                    instructions.replaceLast(arrivalInstruction);
+                    instructions.set(instructions.size() - 1, arrivalInstruction);
                 } else {
                     instructions.add(arrivalInstruction);
                 }
@@ -330,7 +321,7 @@ private void validateTripUpdate(GtfsReader.TripWithStopTimes tripUpdate) {
     // One could argue that one should never write a parser
     // by hand, because it is always ugly, but use a parser library.
     // The code would then read like a specification of what paths through the graph mean.
-    private List<Trip.Leg> parsePathIntoLegs(List<Label.Transition> path, GraphExplorer graph, Weighting weighting, Translation tr) {
+    private List<Trip.Leg> parsePathIntoLegs(List<Label.Transition> path, Graph graph, Weighting weighting, Translation tr) {
         if (path.size() <= 1) {
             return Collections.emptyList();
         }
@@ -379,7 +370,7 @@ private void validateTripUpdate(GtfsReader.TripWithStopTimes tripUpdate) {
             return result;
         } else {
             InstructionList instructions = new InstructionList(tr);
-            InstructionsFromEdges instructionsFromEdges = new InstructionsFromEdges(path.get(1).edge.edgeIteratorState.getBaseNode(), graph.getGraph(),
+            InstructionsFromEdges instructionsFromEdges = new InstructionsFromEdges(path.get(1).edge.edgeIteratorState.getBaseNode(), graph,
                     weighting, weighting.getFlagEncoder(), weighting.getFlagEncoder().getBooleanEncodedValue(EncodingManager.ROUNDABOUT), graph.getNodeAccess(), tr, instructions);
             int prevEdgeId = -1;
             for (int i = 1; i < path.size(); i++) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
index 032292df9b..adbb9bc776 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
@@ -18,6 +18,9 @@
 
 package com.graphhopper.reader.gtfs;
 
+import com.carrotsearch.hppc.IntObjectHashMap;
+import com.carrotsearch.hppc.IntObjectMap;
+import com.google.common.collect.ArrayListMultimap;
 import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.profiles.DecimalEncodedValue;
@@ -30,34 +33,50 @@
 import com.graphhopper.storage.IntsRef;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
 
+import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 import java.util.stream.IntStream;
+import java.util.stream.StreamSupport;
 
 public class WrapperGraph implements Graph {
 
-    private final Graph baseGraph;
-    private final List<VirtualEdgeIteratorState> extraEdges;
+    private final Graph mainGraph;
+    private final IntObjectMap<EdgeIteratorState> extraEdges = new IntObjectHashMap<>();
+    private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesBySource = ArrayListMultimap.create();
+    private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesByDestination = ArrayListMultimap.create();
 
-    public WrapperGraph(Graph baseGraph, List<VirtualEdgeIteratorState> extraEdges) {
-        this.baseGraph = baseGraph;
-        this.extraEdges = extraEdges;
+
+    public WrapperGraph(Graph mainGraph, List<VirtualEdgeIteratorState> extraEdges) {
+        this.mainGraph = mainGraph;
+        extraEdges.forEach(e -> this.extraEdges.put(e.getEdge(), e));
+        for (VirtualEdgeIteratorState extraEdge : extraEdges) {
+            if (extraEdge == null) {
+                throw new RuntimeException();
+            }
+            extraEdgesBySource.put(extraEdge.getBaseNode(), extraEdge);
+            extraEdgesByDestination.put(extraEdge.getAdjNode(), new VirtualEdgeIteratorState(extraEdge.getOriginalEdgeKey(), extraEdge.getEdge(), extraEdge.getAdjNode(),
+                    extraEdge.getBaseNode(), extraEdge.getDistance(), extraEdge.getFlags(), extraEdge.getName(), extraEdge.fetchWayGeometry(3), true));
+        }
     }
 
     @Override
     public Graph getBaseGraph() {
-        return baseGraph;
+        return this;
     }
 
     @Override
     public int getNodes() {
         return IntStream.concat(
-                IntStream.of(baseGraph.getNodes() - 1),
-                extraEdges.stream().flatMapToInt(edge -> IntStream.of(edge.getBaseNode(), edge.getAdjNode())))
-                .max().getAsInt() + 1;
+                IntStream.of(mainGraph.getNodes() - 1),
+                StreamSupport.stream(extraEdges.values().spliterator(), false)
+                        .flatMapToInt(cursor -> IntStream.of(cursor.value.getBaseNode(), cursor.value.getAdjNode()))
+        ).max().getAsInt() + 1;
     }
 
     @Override
@@ -67,17 +86,17 @@ public int getEdges() {
 
     @Override
     public NodeAccess getNodeAccess() {
-        return baseGraph.getNodeAccess();
+        return mainGraph.getNodeAccess();
     }
 
     @Override
     public BBox getBounds() {
-        return baseGraph.getBounds();
+        return mainGraph.getBounds();
     }
 
     @Override
     public EdgeIteratorState edge(int a, int b) {
-        return baseGraph.getEdgeIteratorState(a, b);
+        throw new RuntimeException();
     }
 
     @Override
@@ -87,7 +106,12 @@ public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirecti
 
     @Override
     public EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
-        return baseGraph.getEdgeIteratorState(edgeId, adjNode);
+        EdgeIteratorState edgeIteratorState = extraEdges.get(edgeId);
+        if (edgeIteratorState != null) {
+            return edgeIteratorState;
+        } else {
+            return mainGraph.getEdgeIteratorState(edgeId, adjNode);
+        }
     }
 
     @Override
@@ -96,8 +120,8 @@ public AllEdgesIterator getAllEdges() {
             @Override
             public int length() {
                 return IntStream.concat(
-                        IntStream.of(baseGraph.getAllEdges().length() - 1),
-                        extraEdges.stream().mapToInt(VirtualEdgeIteratorState::getEdge))
+                        IntStream.of(mainGraph.getAllEdges().length() - 1),
+                        StreamSupport.stream(extraEdges.values().spliterator(), false).mapToInt(cursor -> cursor.value.getEdge()))
                         .max().getAsInt() + 1;
             }
 
@@ -275,12 +299,235 @@ public EdgeIteratorState copyPropertiesFrom(EdgeIteratorState e) {
 
     @Override
     public EdgeExplorer createEdgeExplorer(EdgeFilter filter) {
-        return baseGraph.createEdgeExplorer(filter);
+        EdgeExplorer baseGraphEdgeExplorer = mainGraph.createEdgeExplorer(filter);
+        return new EdgeExplorer() {
+            @Override
+            public EdgeIterator setBaseNode(int baseNode) {
+                final List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
+                extraEdges.addAll(extraEdgesBySource.get(baseNode));
+                extraEdges.addAll(extraEdgesByDestination.get(baseNode));
+                Iterator<VirtualEdgeIteratorState> iterator = extraEdges.iterator();
+                return new EdgeIterator() {
+
+                    EdgeIteratorState current = null;
+                    EdgeIterator baseGraphEdgeIterator = baseGraphIterator();
+                    private EdgeIterator baseGraphIterator() {
+                        if (baseNode < mainGraph.getNodes()) {
+                            return baseGraphEdgeExplorer.setBaseNode(baseNode);
+                        } else {
+                            return null;
+                        }
+                    }
+
+                    @Override
+                    public boolean next() {
+                        if (baseGraphEdgeIterator != null) {
+                            if (baseGraphEdgeIterator.next()) {
+                                current = baseGraphEdgeIterator;
+                                return true;
+                            } else {
+                                baseGraphEdgeIterator = null;
+                            }
+                        }
+                        while(iterator.hasNext()) {
+                            current = iterator.next();
+                            if (filter.accept(current)) {
+                                return true;
+                            }
+                        }
+                        return false;
+                    }
+
+                    @Override
+                    public int getEdge() {
+                        return current.getEdge();
+                    }
+
+                    @Override
+                    public int getOrigEdgeFirst() {
+                        return current.getOrigEdgeFirst();
+                    }
+
+                    @Override
+                    public int getOrigEdgeLast() {
+                        return current.getOrigEdgeLast();
+                    }
+
+                    @Override
+                    public int getBaseNode() {
+                        return current.getBaseNode();
+                    }
+
+                    @Override
+                    public int getAdjNode() {
+                        return current.getAdjNode();
+                    }
+
+                    @Override
+                    public PointList fetchWayGeometry(int mode) {
+                        return current.fetchWayGeometry(mode);
+                    }
+
+                    @Override
+                    public EdgeIteratorState setWayGeometry(PointList list) {
+                        current.setWayGeometry(list);
+                        return this;
+                    }
+
+                    @Override
+                    public double getDistance() {
+                        return current.getDistance();
+                    }
+
+                    @Override
+                    public EdgeIteratorState setDistance(double dist) {
+                        current.setDistance(dist);
+                        return this;
+                    }
+
+                    @Override
+                    public IntsRef getFlags() {
+                        return current.getFlags();
+                    }
+
+                    @Override
+                    public EdgeIteratorState setFlags(IntsRef edgeFlags) {
+                        current.setFlags(edgeFlags);
+                        return this;
+                    }
+
+                    @Override
+                    public int getAdditionalField() {
+                        return current.getAdditionalField();
+                    }
+
+                    @Override
+                    public EdgeIteratorState setAdditionalField(int value) {
+                        current.setAdditionalField(value);
+                        return this;
+                    }
+
+                    @Override
+                    public boolean get(BooleanEncodedValue property) {
+                        return current.get(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState set(BooleanEncodedValue property, boolean value) {
+                        current.set(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public boolean getReverse(BooleanEncodedValue property) {
+                        return current.getReverse(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState setReverse(BooleanEncodedValue property, boolean value) {
+                        current.setReverse(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public int get(IntEncodedValue property) {
+                        return current.get(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState set(IntEncodedValue property, int value) {
+                        current.set(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public int getReverse(IntEncodedValue property) {
+                        return current.getReverse(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState setReverse(IntEncodedValue property, int value) {
+                        current.setReverse(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public double get(DecimalEncodedValue property) {
+                        return current.get(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState set(DecimalEncodedValue property, double value) {
+                        current.set(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public double getReverse(DecimalEncodedValue property) {
+                        return current.getReverse(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState setReverse(DecimalEncodedValue property, double value) {
+                        current.setReverse(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public <T extends Enum> T get(EnumEncodedValue<T> property) {
+                        return current.get(property);
+                    }
+
+                    @Override
+                    public <T extends Enum> EdgeIteratorState set(EnumEncodedValue<T> property, T value) {
+                        current.set(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public <T extends Enum> T getReverse(EnumEncodedValue<T> property) {
+                        return current.getReverse(property);
+                    }
+
+                    @Override
+                    public <T extends Enum> EdgeIteratorState setReverse(EnumEncodedValue<T> property, T value) {
+                        current.setReverse(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public String getName() {
+                        return current.getName();
+                    }
+
+                    @Override
+                    public EdgeIteratorState setName(String name) {
+                        current.setName(name);
+                        return this;
+                    }
+
+                    @Override
+                    public EdgeIteratorState detach(boolean reverse) {
+                        return current.detach(reverse);
+                    }
+
+                    @Override
+                    public EdgeIteratorState copyPropertiesFrom(EdgeIteratorState e) {
+                        return current.copyPropertiesFrom(e);
+                    }
+
+                    @Override
+                    public String toString() {
+                        return current.toString();
+                    }
+                };
+            }
+        };
     }
 
     @Override
     public EdgeExplorer createEdgeExplorer() {
-        return baseGraph.createEdgeExplorer();
+        return createEdgeExplorer(EdgeFilter.ALL_EDGES);
     }
 
     @Override
@@ -290,11 +537,16 @@ public Graph copyTo(Graph g) {
 
     @Override
     public GraphExtension getExtension() {
-        return baseGraph.getExtension();
+        return mainGraph.getExtension();
     }
 
     @Override
     public int getOtherNode(int edge, int node) {
-        return baseGraph.getOtherNode(edge, node);
+        return mainGraph.getOtherNode(edge, node);
+    }
+
+    @Override
+    public boolean isAdjacentToNode(int edge, int node) {
+        return mainGraph.isAdjacentToNode(edge, node);
     }
 }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java b/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
index d2791b7f9c..97eaa2cf1d 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
@@ -18,9 +18,7 @@
 
 package com.graphhopper;
 
-import com.graphhopper.reader.gtfs.GraphHopperGtfs;
-import com.graphhopper.reader.gtfs.GtfsStorage;
-import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.reader.gtfs.*;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.GHDirectory;
@@ -28,6 +26,7 @@
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters;
+import com.graphhopper.util.shapes.GHPoint;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -74,12 +73,12 @@ public static void close() {
     public void testRoute1() {
         final double FROM_LAT = 36.9010208, FROM_LON = -116.7659466;
         final double TO_LAT =  36.9059371, TO_LON = -116.7618071;
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,9,0,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,9,0,0).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
index c089ae38b7..c35bbf9b46 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
@@ -21,6 +21,7 @@
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.reader.gtfs.Request;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FootFlagEncoder;
@@ -29,7 +30,6 @@
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Instruction;
-import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
 import org.junit.Assume;
 import org.junit.BeforeClass;
@@ -84,12 +84,12 @@ public static void close() {
     public void testRoute1() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 0, 0, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -101,11 +101,11 @@ public void testRoute1() {
     public void testRoute1DoesNotGoAt654() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 54).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 54).atZone(zoneId).toInstant());
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -117,13 +117,13 @@ public void testRoute1DoesNotGoAt654() {
     public void testRoute1GoesAt744() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 7, 44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.BLOCKED_ROUTE_TYPES, 1); // Blocking trams shouldn't matter, this is a bus.
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 7, 44).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setBlockedRouteTypes(1); // Blocking trams shouldn't matter, this is a bus.
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -135,12 +135,12 @@ public void testRoute1GoesAt744() {
     public void testNoSolutionIfIDontLikeBusses() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 7, 44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.BLOCKED_ROUTE_TYPES, 8);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 7, 44).atZone(zoneId).toInstant());
+        ghRequest.setBlockedRouteTypes(8);
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -151,12 +151,12 @@ public void testNoSolutionIfIDontLikeBusses() {
     public void testRoute1ArriveBy() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 49).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 49).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
 
         GHResponse route = graphHopper.route(ghRequest);
 
@@ -170,13 +170,13 @@ public void testRoute1ArriveBy() {
     public void testRoute1ArriveBy2() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
         // Tests that it also works when the query arrival time is not exactly the scheduled arrival time of the solution
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 50).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 50).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
 
         GHResponse route = graphHopper.route(ghRequest);
 
@@ -191,14 +191,14 @@ public void testRoute1ArriveBy2() {
     public void testRoute1ProfileEarliestArrival() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 21);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setProfileQuery(true);
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setLimitSolutions(21);
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
@@ -216,14 +216,14 @@ public void testRoute1ProfileEarliestArrival() {
     public void testRoute1ProfileOvernight() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 23, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 21);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 23, 0).atZone(zoneId).toInstant());
+        ghRequest.setProfileQuery(true);
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setLimitSolutions(21);
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
@@ -241,15 +241,15 @@ public void testRoute1ProfileOvernight() {
     public void testRoute1ProfileLatestDeparture() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 13, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 4);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 13, 0).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
+        ghRequest.setProfileQuery(true);
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setLimitSolutions(4);
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
@@ -287,11 +287,11 @@ public void testRoute4() {
     public void testRoute5() {
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.88108, TO_LON = -116.81797; // BULLFROG stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.toString(), route.hasErrors());
@@ -306,12 +306,12 @@ public void testRoute5() {
     public void testRoute5Arrival() {
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.88108, TO_LON = -116.81797; // BULLFROG stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 8, 10).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 8, 10).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -333,12 +333,12 @@ public void testRouteWithLaterDepartureTime() {
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.914894, TO_LON = -116.76821; // NADAV stop
         // Missed the bus at 10 by one minute, will have to use the 10:30 one.
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 10, 1).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 10, 1).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -350,11 +350,11 @@ public void testRouteWithLaterDepartureTime() {
     public void testWeekendRouteWorksOnlyOnWeekend() {
         final double FROM_LAT = 36.868446, FROM_LON = -116.784582; // BEATTY_AIRPORT stop
         final double TO_LAT = 36.641496, TO_LON = -116.40094; // AMV stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant()); // Monday morning
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant()); // Monday morning
 
 
         GHResponse route = graphHopper.route(ghRequest);
@@ -362,11 +362,11 @@ public void testWeekendRouteWorksOnlyOnWeekend() {
         // On Mondays, there is only a complicated evening trip.
         assertEquals("Expected travel time == scheduled travel time", time(22, 0), route.getBest().getTime());
 
-        ghRequest = new GHRequest(
+        ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 6, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 6, 0, 0).atZone(zoneId).toInstant());
         route = graphHopper.route(ghRequest);
         assertFalse(route.getAll().isEmpty());
         assertEquals("Expected travel time == scheduled travel time", time(9, 0), route.getBest().getTime());
@@ -379,11 +379,11 @@ public void testWeekendRouteWorksOnlyOnWeekend() {
     public void testBlockTrips() {
         final double FROM_LAT = 36.868446, FROM_LON = -116.784582; // BEATTY_AIRPORT stop
         final double TO_LAT = 36.425288, TO_LON = -117.133162; // FUR_CREEK_RES stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 8, 0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 8, 0).atZone(zoneId).toInstant());
         GHResponse response = graphHopper.route(ghRequest);
         assertEquals("Only find one solution. If blocks wouldn't work, there would be two. (There is a slower alternative without transfer.)", 1, response.getAll().size());
         assertEquals("Expected travel time == scheduled travel time", time(1, 20), response.getBest().getTime());
@@ -396,11 +396,11 @@ public void testBlockTrips() {
     public void testBlockWithComplicatedValidityIntersections() {
         final double FROM_LAT = 36.868446, FROM_LON = -116.784582; // BEATTY_AIRPORT stop
         final double TO_LAT = 36.641496, TO_LON = -116.40094; // AMV stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 18, 0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 18, 0).atZone(zoneId).toInstant());
         GHResponse response = graphHopper.route(ghRequest);
         PathWrapper mondayTrip = response.getBest();
         assertEquals("Monday trip has no transfers", 0, mondayTrip.getNumChanges());
@@ -409,7 +409,7 @@ public void testBlockWithComplicatedValidityIntersections() {
         assertEquals("FUNNY_BLOCK_BFC1", (((Trip.PtLeg) mondayTrip.getLegs().get(1)).trip_id));
         assertEquals("FUNNY_BLOCK_FCAMV1", (((Trip.PtLeg) mondayTrip.getLegs().get(2)).trip_id));
 
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 7, 18, 0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 7, 18, 0).atZone(zoneId).toInstant());
         response = graphHopper.route(ghRequest);
         PathWrapper sundayTrip = response.getBest();
         assertEquals("Sunday trip has no transfers", 0, sundayTrip.getNumChanges());
@@ -429,29 +429,29 @@ public void testTransferRules() {
         final double TO1_LAT = 36.641496, TO1_LON = -116.40094; // AMV stop
         final double TO2_LAT = 36.88108, TO2_LON = -116.81797; // BULLFROG stop
 
-        GHRequest request = new GHRequest(
+        Request request = new Request(
                 FROM_LAT, FROM_LON,
                 TO1_LAT, TO1_LON
         );
-        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 6, 7, 30).atZone(zoneId).toInstant());
+        request.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 6, 7, 30).atZone(zoneId).toInstant());
 
         GHResponse response = graphHopper.route(request);
         assertEquals("Transfer rule: 11 minutes. Will miss connection, and be there at 14.", time(6, 30), response.getBest().getTime());
 
-        request = new GHRequest(
+        request = new Request(
                 FROM_LAT, FROM_LON,
                 TO2_LAT, TO2_LON
         );
-        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 6, 7, 30).atZone(zoneId).toInstant());
+        request.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 6, 7, 30).atZone(zoneId).toInstant());
 
         response = graphHopper.route(request);
         assertEquals("Will still be there at 8:10 because there is a route-specific exception for this route.", time(0, 40), response.getBest().getTime());
 
-        request = new GHRequest(
+        request = new Request(
                 TO2_LAT, TO2_LON,
                 FROM_LAT, FROM_LON
         );
-        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 6, 12, 5).atZone(zoneId).toInstant());
+        request.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 6, 12, 5).atZone(zoneId).toInstant());
 
         response = graphHopper.route(request);
         assertEquals("Will take 1:15 because of a 'from route' exception with a longer transfer time.", time(1, 15), response.getBest().getTime());
@@ -459,12 +459,12 @@ public void testTransferRules() {
 
 
     private void assertTravelTimeIs(GraphHopperGtfs graphHopper, double FROM_LAT, double FROM_LON, double TO_LAT, double TO_LON, int expectedWeight) {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -473,12 +473,12 @@ private void assertTravelTimeIs(GraphHopperGtfs graphHopper, double FROM_LAT, do
     }
 
     private void assertNoRoute(GraphHopperGtfs graphHopper, double from_lat, double from_lon, double to_lat, double to_lon) {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 from_lat, from_lon,
                 to_lat, to_lon
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         GHResponse route = graphHopper.route(ghRequest);
         assertTrue(route.getAll().isEmpty());
@@ -488,14 +488,14 @@ private void assertNoRoute(GraphHopperGtfs graphHopper, double from_lat, double
     public void testTransferByArrival() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to be there at 7:20
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 7, 20).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 7, 20).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -506,11 +506,11 @@ public void testTransferByArrival() {
 
     @Test
     public void testCustomObjectiveFunction() {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 36.868446, -116.784582,  // BEATTY_AIRPORT stop
                 36.425288, -117.133162       // FUR_CREEK_RES stop
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 14, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 14, 0, 0).atZone(zoneId).toInstant());
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -526,16 +526,16 @@ public void testCustomObjectiveFunction() {
         // Wiggle it by epsilon, and I should prefer one over the other.
         double betaTransfers = solutionWithoutTransfer.getTime() - solutionWithTransfer.getTime();
 
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.setIgnoreTransfers(true);
         // Well, not actually ignore them, but don't do multi-criteria search
 
-        ghRequest.getHints().put("beta_transfers", betaTransfers - 10);
+        ghRequest.setBetaTransfers(betaTransfers - 10);
         response = graphHopper.route(ghRequest);
 
         assertEquals("Get exactly one solution", 1, response.getAll().size());
         assertEquals("Prefer solution with transfers when I give the smaller beta", solutionWithTransfer.getTime(), response.getBest().getTime());
 
-        ghRequest.getHints().put("beta_transfers", betaTransfers + 10);
+        ghRequest.setBetaTransfers(betaTransfers + 10);
 
         response = graphHopper.route(ghRequest);
 
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
index 3ef9c3bc70..7a9c7eb406 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
@@ -21,13 +21,13 @@
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.reader.gtfs.Request;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
-import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -70,12 +70,12 @@ public static void close() {
 
     @Test
     public void testDepartureTimeOfAccessLegInProfileQuery() {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 36.91311729030539, -116.76769495010377,
                 36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setProfileQuery(true);
 
         GHResponse response = graphHopper.route(ghRequest);
         assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(243);
@@ -91,12 +91,12 @@ public void testDepartureTimeOfAccessLegInProfileQuery() {
 
     @Test
     public void testDepartureTimeOfAccessLeg() {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 36.91311729030539, -116.76769495010377,
                 36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put("beta_walk_time", 2.0); // I somewhat dislike walking
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setBetaWalkTime(2.0); // I somewhat dislike walking
 
         GHResponse response = graphHopper.route(ghRequest);
         assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(129);
@@ -121,7 +121,7 @@ public void testDepartureTimeOfAccessLeg() {
 
         // I like walking exactly as I like riding a bus (per travel time unit)
         // Now, the walk solution dominates, and we get no transit solution.
-        ghRequest.getHints().put("beta_walk_time", 1.0);
+        ghRequest.setBetaWalkTime(1.0);
         response = graphHopper.route(ghRequest);
         assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(138);
         assertThat(response.getAll().stream().filter(p -> p.getLegs().size() > 1).findFirst()).isEmpty();
@@ -129,12 +129,12 @@ public void testDepartureTimeOfAccessLeg() {
 
     @Test
     public void testFastWalking() {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 36.91311729030539, -116.76769495010377,
                 36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 50); // Yes, I can walk very fast, 50 km/h. Problem?
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setWalkSpeedKmH(50); // Yes, I can walk very fast, 50 km/h. Problem?
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -149,13 +149,13 @@ public void testFastWalking() {
 
     @Test
     public void testFastWalkingInProfileQuery() {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 36.91311729030539, -116.76769495010377,
                 36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 50); // Yes, I can walk very fast, 50 km/h. Problem?
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setWalkSpeedKmH(50); // Yes, I can walk very fast, 50 km/h. Problem?
+        ghRequest.setProfileQuery(true);
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -170,24 +170,24 @@ public void testFastWalkingInProfileQuery() {
 
     @Test
     public void testProfileQueryDoesntEndPrematurely() {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 36.91311729030539, -116.76769495010377,
                 36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
         // Provoke a situation where solutions which are later dominated will be found early.
         // If everything is right, the n-th solution should be the same, no matter if I ask for n, or for n+m solutions.
-        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 1); // No, I cannot walk very fast, 1 km/h. Problem?
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
+        ghRequest.setWalkSpeedKmH(1); // No, I cannot walk very fast, 1 km/h. Problem?
+        ghRequest.setProfileQuery(true);
 
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 1);
+        ghRequest.setLimitSolutions(1);
         GHResponse response1 = graphHopper.route(ghRequest);
         assertThat(response1.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(142);
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 3);
+        ghRequest.setLimitSolutions(3);
         GHResponse response3 = graphHopper.route(ghRequest);
         assertThat(response3.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(230);
         assertThat(response1.getAll().get(0).getTime()).isEqualTo(response3.getAll().get(0).getTime());
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 5);
+        ghRequest.setLimitSolutions(5);
         GHResponse response5 = graphHopper.route(ghRequest);
         assertThat(response5.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(334);
         assertThat(response3.getAll().get(2).getTime()).isEqualTo(response5.getAll().get(2).getTime());
@@ -195,13 +195,13 @@ public void testProfileQueryDoesntEndPrematurely() {
 
     @Test
     public void testHighDisutilityOfWalking() {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 36.91311729030539, -116.76769495010377,
                 36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 50); // Yes, I can walk very fast, 50 km/h. Problem?
-        ghRequest.getHints().put("beta_walk_time", 20); // But I dislike walking a lot.
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setWalkSpeedKmH(50); // Yes, I can walk very fast, 50 km/h. Problem?
+        ghRequest.setBetaWalkTime(20); // But I dislike walking a lot.
 
         GHResponse response = graphHopper.route(ghRequest);
 
diff --git a/reader-gtfs/src/test/java/com/graphhopper/PtRouteResourceIT.java b/reader-gtfs/src/test/java/com/graphhopper/PtRouteResourceIT.java
new file mode 100644
index 0000000000..da31774cc7
--- /dev/null
+++ b/reader-gtfs/src/test/java/com/graphhopper/PtRouteResourceIT.java
@@ -0,0 +1,97 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper;
+
+import com.graphhopper.gtfs.ws.LocationConverterProvider;
+import com.graphhopper.jackson.Jackson;
+import com.graphhopper.reader.gtfs.GraphHopperGtfs;
+import com.graphhopper.reader.gtfs.GtfsStorage;
+import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.storage.GHDirectory;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.Parameters;
+import io.dropwizard.testing.junit.ResourceTestRule;
+import org.junit.ClassRule;
+import org.junit.Test;
+
+import javax.ws.rs.core.Response;
+import java.io.File;
+import java.util.Arrays;
+import java.util.Collections;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+public class PtRouteResourceIT {
+
+    private static final String GRAPH_LOC = "target/PtRouteResourceIT";
+    private static GraphHopperGtfs graphHopper;
+
+    static {
+        Helper.removeDir(new File(GRAPH_LOC));
+        final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
+        final CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
+        final FootFlagEncoder footFlagEncoder = new FootFlagEncoder();
+
+        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(carFlagEncoder, ptFlagEncoder, footFlagEncoder), 8);
+        GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
+        GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
+        GraphHopperStorage graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.singleton("files/beatty.osm"));
+        LocationIndex locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
+        graphHopper = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage)
+                .createWithoutRealtimeFeed();
+    }
+
+    @ClassRule
+    public static final ResourceTestRule resources = ResourceTestRule.builder()
+            .addProvider(new LocationConverterProvider())
+            .setMapper(Jackson.newObjectMapper())
+            .addResource(graphHopper)
+            .build();
+
+    @Test
+    public void testStationStationQuery() {
+        final Response response = resources.target("/route")
+                .queryParam("point", "Stop(NADAV)")
+                .queryParam("point", "Stop(NANAA)")
+                .queryParam(Parameters.PT.EARLIEST_DEPARTURE_TIME, "2007-01-01T08:00:00Z")
+                .request().buildGet().invoke();
+        assertEquals(200, response.getStatus());
+        GHResponse ghResponse = response.readEntity(GHResponse.class);
+        assertFalse(ghResponse.hasErrors());
+    }
+
+    @Test
+    public void testPointPointQuery() {
+        final Response response = resources.target("/route")
+                .queryParam("point","36.914893,-116.76821") // NADAV stop
+                .queryParam("point","36.914944,-116.761472") //NANAA stop
+                .queryParam(Parameters.PT.EARLIEST_DEPARTURE_TIME, "2007-01-01T08:00:00Z")
+                .request().buildGet().invoke();
+        assertEquals(200, response.getStatus());
+        GHResponse ghResponse = response.readEntity(GHResponse.class);
+        assertFalse(ghResponse.hasErrors());
+    }
+
+}
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index 210475b25e..8940037718 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -22,6 +22,7 @@
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.reader.gtfs.Request;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FootFlagEncoder;
@@ -29,20 +30,13 @@
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
-import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
 import java.io.File;
 import java.math.BigDecimal;
-import java.time.Duration;
-import java.time.Instant;
-import java.time.LocalDate;
-import java.time.LocalDateTime;
-import java.time.LocalTime;
-import java.time.ZoneId;
-import java.time.ZonedDateTime;
+import java.time.*;
 import java.util.Arrays;
 import java.util.Collections;
 
@@ -90,14 +84,14 @@ public static void close() {
     public void testSkipDepartureStop() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to skip my departure stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -112,7 +106,7 @@ public void testSkipDepartureStop() {
                 .setStopSequence(3)
                 .setScheduleRelationship(SKIPPED);
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
 
         PathWrapper possibleAlternative = response.getAll().stream().filter(a -> !a.isImpossible()).findFirst().get();
         assertFalse(((Trip.PtLeg) possibleAlternative.getLegs().get(0)).stops.get(0).departureCancelled);
@@ -127,14 +121,14 @@ public void testSkipDepartureStop() {
     public void testHeavyDelayWhereWeShouldTakeOtherTripInstead() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to be super-late :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -150,7 +144,7 @@ public void testHeavyDelayWhereWeShouldTakeOtherTripInstead() {
                 .setStopSequence(3)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(3600).build());
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(2, response.getAll().size());
 
         PathWrapper best = response.getBest();
@@ -169,14 +163,14 @@ public void testHeavyDelayWhereWeShouldTakeOtherTripInstead() {
     public void testCanUseDelayedTripWhenIAmLateToo() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,46).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,46).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to be super-late :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -192,7 +186,7 @@ public void testCanUseDelayedTripWhenIAmLateToo() {
                 .setStopSequence(3)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(120).build());
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
 
         assertEquals("I am two minutes late for my bus, but the bus is two minutes late, too, so I catch it!", time(0, 5), response.getBest().getTime(), 0.1);
     }
@@ -201,14 +195,14 @@ public void testCanUseDelayedTripWhenIAmLateToo() {
     public void testSkipArrivalStop() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to skip my arrival stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -223,7 +217,7 @@ public void testSkipArrivalStop() {
                 .setStopSequence(4)
                 .setScheduleRelationship(SKIPPED);
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(3, response.getAll().size());
 
         assertEquals("I have to continue to STAGECOACH and then go back one stop with the 07:00 bus.", time(0, 21), response.getBest().getTime(), 0.1);
@@ -237,14 +231,14 @@ public void testSkipArrivalStop() {
     public void testSkipTransferStop() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to skip my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -259,7 +253,7 @@ public void testSkipTransferStop() {
                 .setStopSequence(5)
                 .setScheduleRelationship(SKIPPED);
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(2, response.getAll().size());
 
         assertEquals("The 6:44 bus will not call at STAGECOACH, so I will be 30 min late at the airport.", time(1, 6), response.getBest().getTime(), 0.1);
@@ -273,15 +267,15 @@ public void testSkipTransferStop() {
     public void testExtraTrip() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to skip my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -319,7 +313,7 @@ public void testExtraTrip() {
 
         }
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
         assertEquals("Luckily, there is an extra service directly from my stop to the airport, at 6:45, taking 30 minutes", time(0, 31), response.getBest().getTime(), 0.1);
@@ -333,15 +327,15 @@ public void testExtraTrip() {
     public void testExtraTripWorksOnlyOnSpecifiedDay() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:45, but tomorrow
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,2,6,45).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,2,6,45).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
         feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
@@ -367,7 +361,7 @@ public void testExtraTripWorksOnlyOnSpecifiedDay() {
                 .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15).atZone(zoneId).toEpochSecond()));
 
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
         assertEquals("There is an extra trip at 6:45 tomorrow, but that doesn't concern me today.", time(1, 5), response.getBest().getTime(), 0.1);
@@ -377,15 +371,15 @@ public void testExtraTripWorksOnlyOnSpecifiedDay() {
     public void testZeroDelay() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         GHResponse responseWithoutRealtimeUpdate = graphHopperFactory.createWithoutRealtimeFeed().route(ghRequest);
 
@@ -401,7 +395,7 @@ public void testZeroDelay() {
                 .setScheduleRelationship(SCHEDULED)
                 .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(0).build());
 
-        GHResponse responseWithRealtimeUpdate = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse responseWithRealtimeUpdate = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, responseWithRealtimeUpdate.getAll().size());
 
         Trip.PtLeg responseWithRealtimeUpdateBest = (Trip.PtLeg) responseWithRealtimeUpdate.getBest().getLegs().get(0);
@@ -417,16 +411,16 @@ public void testZeroDelay() {
     public void testDelayWithoutTransfer() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
         Instant initialTime = LocalDateTime.of(2007, 1, 1, 6, 44).atZone(zoneId).toInstant();
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, initialTime);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(initialTime);
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // The 6:00 departure of my line is going to be late by 3 minutes
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -440,7 +434,7 @@ public void testDelayWithoutTransfer() {
                 .setScheduleRelationship(SCHEDULED)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(180).build());
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
         assertEquals("My line run is 3 minutes late.", time(0, 8), response.getBest().getLegs().get(response.getBest().getLegs().size() - 1).getArrivalTime().toInstant().toEpochMilli() - initialTime.toEpochMilli(), 0.1);
@@ -451,16 +445,16 @@ public void testDelayWithoutTransfer() {
     public void testDelayFromBeginningWithoutTransfer() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
         Instant initialTime = LocalDateTime.of(2007, 1, 1, 6, 44).atZone(zoneId).toInstant();
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, initialTime);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(initialTime);
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // The 6:00 departure of my line is going to be "late" by 0 minutes
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -476,7 +470,7 @@ public void testDelayFromBeginningWithoutTransfer() {
                 .setScheduleRelationship(SCHEDULED)
                 .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(180).build());
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
         Trip.PtLeg ptLeg = ((Trip.PtLeg) response.getBest().getLegs().get(0));
@@ -488,13 +482,13 @@ public void testDelayFromBeginningWithoutTransfer() {
     public void testBlockTrips() {
         final double FROM_LAT = 36.868446, FROM_LON = -116.784582; // BEATTY_AIRPORT stop
         final double TO_LAT = 36.425288, TO_LON = -117.133162; // FUR_CREEK_RES stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,8,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,8,0).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // My line does not stop at Bullfrog today. If this was a real transfer, I would not be
         // able to change lines there. But it is not a real transfer, so I can go on as planned.
@@ -508,7 +502,7 @@ public void testBlockTrips() {
                 .setStopSequence(2)
                 .setScheduleRelationship(SKIPPED);
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals("I can still use the AB1 trip", "AB1", (((Trip.PtLeg) response.getBest().getLegs().get(0)).trip_id));
         assertEquals("It takes", time(1,20), response.getBest().getTime());
     }
@@ -529,12 +523,12 @@ public void testBlockTripSkipsStop() {
 
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.88108, TO_LON = -116.81797; // BULLFROG stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
-        GHResponse route = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
+        GHResponse route = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
 
         assertFalse(route.hasErrors());
         assertTrue(route.getAll().get(route.getAll().size()-1).isImpossible());
@@ -551,14 +545,14 @@ public void testBlockTripSkipsStop() {
     public void testMissedTransferBecauseOfDelay() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to be 5 minutes late at my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -572,7 +566,7 @@ public void testMissedTransferBecauseOfDelay() {
                 .setScheduleRelationship(SCHEDULED)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(300).build());
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(2, response.getAll().size());
 
         assertEquals("The 6:44 bus will be late at STAGECOACH, so I will be 30 min late at the airport.", time(1, 6), response.getBest().getTime(), 0.1);
@@ -587,14 +581,14 @@ public void testMissedTransferBecauseOfDelay() {
     public void testMissedTransferButExtraTripOnFirstLeg() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to be 5 minutes late at my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -625,7 +619,7 @@ public void testMissedTransferButExtraTripOnFirstLeg() {
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,46).atZone(zoneId).toEpochSecond()))
                 .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,46).atZone(zoneId).toEpochSecond()));
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
 //        assertEquals(2, response.getAll().size());
 
         assertEquals("The 6:44 bus will be late at STAGECOACH, but I won't be late because there's an extra trip.", time(0, 36), response.getBest().getTime(), 0.1);
@@ -635,14 +629,14 @@ public void testMissedTransferButExtraTripOnFirstLeg() {
     public void testMissedTransferButExtraTripOnSecondLeg() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to be 5 minutes late at my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -673,7 +667,7 @@ public void testMissedTransferButExtraTripOnSecondLeg() {
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,20).atZone(zoneId).toEpochSecond()))
                 .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,20).atZone(zoneId).toEpochSecond()));
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
 //        assertEquals(2, response.getAll().size());
 
         assertEquals("The 6:44 bus will be late at STAGECOACH, but I won't be late because there's an extra trip.", time(0, 36), response.getBest().getTime(), 0.1);
@@ -685,15 +679,15 @@ public void testMissedTransferButExtraTripOnSecondLeg() {
     public void testMissedTransferBecauseOfDelayBackwards() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to be there at 7:20
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,8,20).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,8,20).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to skip my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -707,7 +701,7 @@ public void testMissedTransferBecauseOfDelayBackwards() {
                 .setScheduleRelationship(SCHEDULED)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(300).build());
 
-        GraphHopperGtfs graphHopper = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId);
+        GraphHopperGtfs graphHopper = graphHopperFactory.createWith(feedMessageBuilder.build());
         GHResponse response = graphHopper.route(ghRequest);
         assertEquals(2, response.getAll().size());
 
@@ -719,7 +713,7 @@ public void testMissedTransferBecauseOfDelayBackwards() {
         assertEquals("Five minutes late", 300, Duration.between(delayedStop.plannedArrivalTime.toInstant(), delayedStop.predictedArrivalTime.toInstant()).getSeconds());
 
         // But when I ask about tomorrow, it works as planned
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,2,8,20).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,2,8,20).atZone(zoneId).toInstant());
         response = graphHopper.route(ghRequest);
         assertEquals(1, response.getAll().size());
 
@@ -732,11 +726,11 @@ public void testMissedTransferBecauseOfDelayBackwards() {
     public void testDelayAtEndForNonFrequencyBasedTrip() {
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.88108, TO_LON = -116.81797; // BULLFROG stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
 
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
         feedMessageBuilder.setHeader(header());
@@ -749,7 +743,7 @@ public void testDelayAtEndForNonFrequencyBasedTrip() {
                 .setScheduleRelationship(SCHEDULED)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(300).build());
 
-        GraphHopperGtfs graphHopper = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId);
+        GraphHopperGtfs graphHopper = graphHopperFactory.createWith(feedMessageBuilder.build());
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
diff --git a/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java
index b8469c6382..5aba5806ed 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java
@@ -34,6 +34,7 @@
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
 import static org.hamcrest.collection.IsEmptyIterable.emptyIterable;
@@ -54,17 +55,6 @@ public GraphExplorerTest() {
         encodingManager = EncodingManager.create(Arrays.asList(pt, foot), 8);
     }
 
-    @Test
-    public void testEverythingEmpty() {
-        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
-        GtfsStorage gtfsStorage = mock(GtfsStorage.class);
-        RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
-        List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
-        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
-        assertThat((Iterable<EdgeIteratorState>) () -> testee.exploreEdgesAround(new Label(0, 0, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).iterator(),
-                emptyIterable());
-    }
-
     @Test
     public void testNonEmptyGraph() {
         GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
@@ -77,7 +67,9 @@ public void testNonEmptyGraph() {
         RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
         List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
 
-        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        QueryGraph queryGraph = new QueryGraph(graph);
+        queryGraph.lookup(Collections.emptyList());
+        GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, false, 5.0);
 
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 4, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
                 contains(d.toString()));
@@ -100,7 +92,10 @@ public void testExtraEdgesWithEmptyGraph() {
         g.set(foot.getAccessEnc(), true);
         extraEdges.add(g);
 
-        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        WrapperGraph wrapperGraph = new WrapperGraph(graph, extraEdges);
+        QueryGraph queryGraph = new QueryGraph(wrapperGraph);
+        queryGraph.lookup(Collections.emptyList());
+        GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, false, 5.0);
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
                 contains(e.toString()));
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
@@ -133,13 +128,19 @@ public void testExtraEdgesWithNonEmptyGraph() {
         h.set(foot.getAccessEnc(), true);
         extraEdges.add(h);
 
-        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
-        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
-                contains(e.toString()));
-        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
-                contains(f.toString(), g.toString()));
-        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 4, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
-                contains(d.toString(), h.toString()));
+        WrapperGraph wrapperGraph = new WrapperGraph(graph, extraEdges);
+        QueryGraph queryGraph = new QueryGraph(wrapperGraph);
+        queryGraph.lookup(Collections.emptyList());
+        GraphExplorer forward = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, false, 5.0);
+        assertThat(() -> forward.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains("0->1"));
+        assertThat(() -> forward.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains("1->2", "1->3"));
+        assertThat(() -> forward.exploreEdgesAround(new Label(0, -1, 4, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains("0 4-5", "4->7"));
+        GraphExplorer backward = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, true, false, 5.0);
+        assertThat(() -> backward.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains("1->0"));
     }
 
     @Test
@@ -196,7 +197,7 @@ public void testExtraEdgesWithNonEmptyGraphAndQueryGraph() {
         point2.calcSnappedPoint(new DistanceCalc2D());
         queryGraph.lookup(point1, point2);
 
-        GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, false, 5.0);
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
                 contains(e.toString()));
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
diff --git a/reader-osm/pom.xml b/reader-osm/pom.xml
index a85e9e6a14..03d0a48b3e 100644
--- a/reader-osm/pom.xml
+++ b/reader-osm/pom.xml
@@ -25,7 +25,7 @@
         <dependency>
             <groupId>org.openstreetmap.osmosis</groupId>
             <artifactId>osmosis-osm-binary</artifactId>
-            <version>0.46</version>
+            <version>0.47</version>
         </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
index 24367cbb6d..e865a2a0d6 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
@@ -325,17 +325,15 @@ void processWay(ReaderWay way) {
         // TODO move this after we have created the edge and know the coordinates => encodingManager.applyWayTags
         LongArrayList osmNodeIds = way.getNodes();
         // Estimate length of ways containing a route tag e.g. for ferry speed calculation
-        if (osmNodeIds.size() > 1) {
-            int first = getNodeMap().get(osmNodeIds.get(0));
-            int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
-            double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
-            double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
-            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
-                double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
-                // Add artificial tag for the estimated distance and center
-                way.setTag("estimated_distance", estimatedDist);
-                way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
-            }
+        int first = getNodeMap().get(osmNodeIds.get(0));
+        int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
+        double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
+        double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
+        if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
+            double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
+            // Add artificial tag for the estimated distance and center
+            way.setTag("estimated_distance", estimatedDist);
+            way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
         }
 
         if (way.getTag("duration") != null) {
diff --git a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
index a55dded8c3..26a32040de 100644
--- a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -28,13 +28,11 @@
 import com.graphhopper.util.details.PathDetail;
 import com.graphhopper.util.exceptions.PointDistanceExceededException;
 import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.GHPoint3D;
 import org.junit.*;
 
 import java.io.File;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 
 import static com.graphhopper.util.Parameters.Algorithms.*;
 import static org.junit.Assert.*;
@@ -101,33 +99,29 @@ public void testMonacoWithInstructions() {
         InstructionList il = arsp.getInstructions();
         assertEquals(21, il.size());
 
-        List<Map<String, Object>> resultJson = il.createJson();
         // TODO roundabout fine tuning -> enter + leave roundabout (+ two rounabouts -> is it necessary if we do not leave the street?)
-        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
-        assertEquals("Continue onto Avenue des Papalins", resultJson.get(1).get("text"));
-        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(4).get("text"));
-        assertEquals("Turn left", resultJson.get(5).get("text"));
-        assertEquals("Turn right onto Avenue Albert II", resultJson.get(6).get("text"));
-
-        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
-        assertEquals(96, (Double) resultJson.get(1).get("distance"), 1);
-        assertEquals(178, (Double) resultJson.get(2).get("distance"), 1);
-        assertEquals(13, (Double) resultJson.get(3).get("distance"), 1);
-        assertEquals(10, (Double) resultJson.get(4).get("distance"), 1);
-        assertEquals(42, (Double) resultJson.get(5).get("distance"), 1);
-
-        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
-        assertEquals(69, (Long) resultJson.get(1).get("time") / 1000);
-        assertEquals(128, (Long) resultJson.get(2).get("time") / 1000);
-        assertEquals(9, (Long) resultJson.get(3).get("time") / 1000);
-        assertEquals(7, (Long) resultJson.get(4).get("time") / 1000);
-        assertEquals(30, (Long) resultJson.get(5).get("time") / 1000);
-
-        List<GPXEntry> list = arsp.getInstructions().createGPXList();
-        assertEquals(87, list.size());
-        final long lastEntryMillis = list.get(list.size() - 1).getTime();
-        final long totalResponseMillis = arsp.getTime();
-        assertEquals(totalResponseMillis, lastEntryMillis);
+        Translation tr = hopper.getTranslationMap().getWithFallBack(Locale.US);
+        assertEquals("continue onto Avenue des Guelfes", il.get(0).getTurnDescription(tr));
+        assertEquals("continue onto Avenue des Papalins", il.get(1).getTurnDescription(tr));
+        assertEquals("turn sharp right onto Quai Jean-Charles Rey", il.get(4).getTurnDescription(tr));
+        assertEquals("turn left", il.get(5).getTurnDescription(tr));
+        assertEquals("turn right onto Avenue Albert II", il.get(6).getTurnDescription(tr));
+
+        assertEquals(11, il.get(0).getDistance(), 1);
+        assertEquals(96, il.get(1).getDistance(), 1);
+        assertEquals(178, il.get(2).getDistance(), 1);
+        assertEquals(13, il.get(3).getDistance(), 1);
+        assertEquals(10, il.get(4).getDistance(), 1);
+        assertEquals(42, il.get(5).getDistance(), 1);
+
+        assertEquals(7, il.get(0).getTime() / 1000);
+        assertEquals(69, il.get(1).getTime() / 1000);
+        assertEquals(128, il.get(2).getTime() / 1000);
+        assertEquals(9, il.get(3).getTime() / 1000);
+        assertEquals(7, il.get(4).getTime() / 1000);
+        assertEquals(30, il.get(5).getTime() / 1000);
+
+        assertEquals(87, arsp.getPoints().size());
     }
 
     @Test
@@ -154,6 +148,7 @@ public void testUTurn() {
                 setGraphHopperLocation(tmpGraphFile).
                 setEncodingManager(EncodingManager.create("car"));
         tmpHopper.importOrLoad();
+        Translation tr = hopper.getTranslationMap().getWithFallBack(Locale.US);
 
         GHRequest request = new GHRequest();
         //Force initial U-Turn
@@ -168,11 +163,10 @@ public void testUTurn() {
         InstructionList il = arsp.getInstructions();
         assertEquals(3, il.size());
 
-        List<Map<String, Object>> resultJson = il.createJson();
         // Initial U-turn
-        assertEquals("Make a U-turn onto Avenue Princesse Grace", resultJson.get(0).get("text"));
+        assertEquals("make a U-turn onto Avenue Princesse Grace", il.get(0).getTurnDescription(tr));
         // Second U-turn to get to destination
-        assertEquals("Make a U-turn onto Avenue Princesse Grace", resultJson.get(1).get("text"));
+        assertEquals("make a U-turn onto Avenue Princesse Grace", il.get(1).getTurnDescription(tr));
     }
 
     @Test
@@ -251,14 +245,14 @@ public void testPointHint() {
         req.setPointHints(new ArrayList<>(Arrays.asList("Laufamholzstrae, 90482, Nrnberg, Deutschland", "")));
         GHResponse rsp = tmpHopper.route(req);
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
-        GHPoint snappedPoint = rsp.getBest().getWaypoints().toGHPoint(0);
+        GHPoint snappedPoint = rsp.getBest().getWaypoints().get(0);
         assertEquals(49.465686, snappedPoint.getLat(), .000001);
         assertEquals(11.154605, snappedPoint.getLon(), .000001);
 
         req.setPointHints(new ArrayList<>(Arrays.asList("", "")));
         rsp = tmpHopper.route(req);
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
-        snappedPoint = rsp.getBest().getWaypoints().toGHPoint(0);
+        snappedPoint = rsp.getBest().getWaypoints().get(0);
         assertEquals(49.465502, snappedPoint.getLat(), .000001);
         assertEquals(11.154498, snappedPoint.getLon(), .000001);
 
@@ -266,7 +260,7 @@ public void testPointHint() {
         req.setPointHints(new ArrayList<>(Arrays.asList("xy", "")));
         rsp = tmpHopper.route(req);
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
-        snappedPoint = rsp.getBest().getWaypoints().toGHPoint(0);
+        snappedPoint = rsp.getBest().getWaypoints().get(0);
         assertEquals(49.465502, snappedPoint.getLat(), .000001);
         assertEquals(11.154498, snappedPoint.getLon(), .000001);
     }
@@ -365,6 +359,7 @@ public void testNorthBayreuthBlockeEdges() {
 
     @Test
     public void testMonacoVia() {
+        Translation tr = hopper.getTranslationMap().getWithFallBack(Locale.US);
         GHResponse rsp = hopper.route(new GHRequest().
                 addPoint(new GHPoint(43.727687, 7.418737)).
                 addPoint(new GHPoint(43.74958, 7.436566)).
@@ -377,36 +372,35 @@ public void testMonacoVia() {
 
         InstructionList il = arsp.getInstructions();
         assertEquals(38, il.size());
-        List<Map<String, Object>> resultJson = il.createJson();
-        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
-        assertEquals("Continue onto Avenue des Papalins", resultJson.get(1).get("text"));
-        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(4).get("text"));
-        assertEquals("Turn left", resultJson.get(5).get("text"));
-        assertEquals("Turn right onto Avenue Albert II", resultJson.get(6).get("text"));
-
-        assertEquals("Waypoint 1", resultJson.get(20).get("text"));
-        assertEquals(Instruction.U_TURN_UNKNOWN, resultJson.get(21).get("sign"));
-
-        assertEquals("Continue onto Avenue Albert II", resultJson.get(31).get("text"));
-        assertEquals("Turn left", resultJson.get(32).get("text"));
-        assertEquals("Turn right onto Quai Jean-Charles Rey", resultJson.get(33).get("text"));
-        assertEquals("Turn sharp left onto Avenue des Papalins", resultJson.get(34).get("text"));
-        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(36).get("text"));
-        assertEquals("Arrive at destination", resultJson.get(37).get("text"));
-
-        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
-        assertEquals(97, (Double) resultJson.get(1).get("distance"), 1);
-        assertEquals(178, (Double) resultJson.get(2).get("distance"), 1);
-        assertEquals(13, (Double) resultJson.get(3).get("distance"), 1);
-        assertEquals(10, (Double) resultJson.get(4).get("distance"), 1);
-        assertEquals(42, (Double) resultJson.get(5).get("distance"), 1);
-
-        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
-        assertEquals(69, (Long) resultJson.get(1).get("time") / 1000);
-        assertEquals(128, (Long) resultJson.get(2).get("time") / 1000);
-        assertEquals(9, (Long) resultJson.get(3).get("time") / 1000);
-        assertEquals(7, (Long) resultJson.get(4).get("time") / 1000);
-        assertEquals(30, (Long) resultJson.get(5).get("time") / 1000);
+        assertEquals("continue onto Avenue des Guelfes", il.get(0).getTurnDescription(tr));
+        assertEquals("continue onto Avenue des Papalins", il.get(1).getTurnDescription(tr));
+        assertEquals("turn sharp right onto Quai Jean-Charles Rey", il.get(4).getTurnDescription(tr));
+        assertEquals("turn left", il.get(5).getTurnDescription(tr));
+        assertEquals("turn right onto Avenue Albert II", il.get(6).getTurnDescription(tr));
+
+        assertEquals("waypoint 1", il.get(20).getTurnDescription(tr));
+        assertEquals(Instruction.U_TURN_UNKNOWN, il.get(21).getSign());
+
+        assertEquals("continue onto Avenue Albert II", il.get(31).getTurnDescription(tr));
+        assertEquals("turn left", il.get(32).getTurnDescription(tr));
+        assertEquals("turn right onto Quai Jean-Charles Rey", il.get(33).getTurnDescription(tr));
+        assertEquals("turn sharp left onto Avenue des Papalins", il.get(34).getTurnDescription(tr));
+        assertEquals("continue onto Avenue des Guelfes", il.get(36).getTurnDescription(tr));
+        assertEquals("arrive at destination", il.get(37).getTurnDescription(tr));
+
+        assertEquals(11, il.get(0).getDistance(), 1);
+        assertEquals(97, il.get(1).getDistance(), 1);
+        assertEquals(178, il.get(2).getDistance(), 1);
+        assertEquals(13, il.get(3).getDistance(), 1);
+        assertEquals(10, il.get(4).getDistance(), 1);
+        assertEquals(42, il.get(5).getDistance(), 1);
+
+        assertEquals(7, il.get(0).getTime() / 1000);
+        assertEquals(69, il.get(1).getTime() / 1000);
+        assertEquals(128, il.get(2).getTime() / 1000);
+        assertEquals(9, il.get(3).getTime() / 1000);
+        assertEquals(7, il.get(4).getTime() / 1000);
+        assertEquals(30, il.get(5).getTime() / 1000);
 
         // special case of identical start and end point
         rsp = hopper.route(new GHRequest().
@@ -419,8 +413,8 @@ public void testMonacoVia() {
         assertEquals(0, arsp.getRouteWeight(), .1);
         assertEquals(1, arsp.getPoints().getSize());
         assertEquals(1, arsp.getInstructions().size());
-        assertEquals("Arrive at destination", arsp.getInstructions().createJson().get(0).get("text"));
-        assertEquals(Instruction.FINISH, arsp.getInstructions().createJson().get(0).get("sign"));
+        assertEquals("arrive at destination", arsp.getInstructions().get(0).getTurnDescription(tr));
+        assertEquals(Instruction.FINISH, arsp.getInstructions().get(0).getSign());
 
         rsp = hopper.route(new GHRequest().
                 addPoint(new GHPoint(43.727687, 7.418737)).
@@ -433,8 +427,8 @@ public void testMonacoVia() {
         assertEquals(0, arsp.getRouteWeight(), .1);
         assertEquals(1, arsp.getPoints().getSize());
         assertEquals(2, arsp.getInstructions().size());
-        assertEquals(Instruction.REACHED_VIA, arsp.getInstructions().createJson().get(0).get("sign"));
-        assertEquals(Instruction.FINISH, arsp.getInstructions().createJson().get(1).get("sign"));
+        assertEquals(Instruction.REACHED_VIA, arsp.getInstructions().get(0).getSign());
+        assertEquals(Instruction.FINISH, arsp.getInstructions().get(1).getSign());
     }
 
     @Test
@@ -611,15 +605,13 @@ public void testSRTMWithInstructions() throws Exception {
         assertEquals(99, arsp.getAscend(), 1e-1);
         assertEquals(150, arsp.getDescend(), 1e-1);
 
-        List<GPXEntry> list = arsp.getInstructions().createGPXList();
-        assertEquals(54, list.size());
-        final long lastEntryMillis = list.get(list.size() - 1).getTime();
-        assertEquals(new GPXEntry(43.73068455771767, 7.421283689825812, 62.0, 0), list.get(0));
-        assertEquals(new GPXEntry(43.727680946587874, 7.4191987684222065, 11.0, lastEntryMillis), list.get(list.size() - 1));
+        assertEquals(54, arsp.getPoints().size());
+        assertEquals(new GHPoint3D(43.73068455771767, 7.421283689825812, 62.0), arsp.getPoints().get(0));
+        assertEquals(new GHPoint3D(43.727680946587874, 7.4191987684222065, 11.0), arsp.getPoints().get(arsp.getPoints().size()-1));
 
-        assertEquals(62, il.createGPXList().get(0).getElevation(), 1e-2);
-        assertEquals(66, il.createGPXList().get(1).getElevation(), 1e-2);
-        assertEquals(52, il.createGPXList().get(10).getElevation(), 1e-2);
+        assertEquals(62, arsp.getPoints().get(0).getElevation(), 1e-2);
+        assertEquals(66, arsp.getPoints().get(1).getElevation(), 1e-2);
+        assertEquals(52, arsp.getPoints().get(10).getElevation(), 1e-2);
     }
 
     @Test
@@ -690,6 +682,7 @@ public void testKremsCyclewayInstructionsWithWayTypeInfo() {
                 setEncodingManager(EncodingManager.create(tmpImportVehicles)).
                 importOrLoad();
 
+        Translation tr = tmpHopper.getTranslationMap().getWithFallBack(Locale.US);
         GHResponse rsp = tmpHopper.route(new GHRequest(48.410987, 15.599492, 48.383419, 15.659294).
                 setAlgorithm(ASTAR).setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
 
@@ -699,25 +692,24 @@ public void testKremsCyclewayInstructionsWithWayTypeInfo() {
 
         InstructionList il = arsp.getInstructions();
         assertEquals(24, il.size());
-        List<Map<String, Object>> resultJson = il.createJson();
-
-        assertEquals("Continue onto Obere Landstrae", resultJson.get(0).get("text"));
-        assertEquals("get off the bike", resultJson.get(0).get("annotation_text"));
-        assertEquals(69.28, (Double) resultJson.get(0).get("heading"), .01);
-        assertEquals("Turn left onto Kirchengasse", resultJson.get(1).get("text"));
-        assertEquals("get off the bike", resultJson.get(1).get("annotation_text"));
-
-        assertEquals("Turn right onto Pfarrplatz", resultJson.get(2).get("text"));
-        assertEquals("Turn right onto Margarethenstrae", resultJson.get(3).get("text"));
-        assertEquals("Keep left onto Hoher Markt", resultJson.get(5).get("text"));
-        assertEquals("Turn right onto Wegscheid", resultJson.get(7).get("text"));
-        assertEquals("Turn right onto Ringstrae, L73", resultJson.get(9).get("text"));
-        assertEquals("Keep left onto Eyblparkstrae", resultJson.get(10).get("text"));
-        assertEquals("Keep left onto Austrae", resultJson.get(11).get("text"));
-        assertEquals("Keep left onto Rechte Kremszeile", resultJson.get(12).get("text"));
+
+        assertEquals("continue onto Obere Landstrae", il.get(0).getTurnDescription(tr));
+        assertEquals("get off the bike", il.get(0).getAnnotation().getMessage());
+        assertEquals(69.28, (Double) il.get(0).getExtraInfoJSON().get("heading"), .01);
+        assertEquals("turn left onto Kirchengasse", il.get(1).getTurnDescription(tr));
+        assertEquals("get off the bike", il.get(1).getAnnotation().getMessage());
+
+        assertEquals("turn right onto Pfarrplatz", il.get(2).getTurnDescription(tr));
+        assertEquals("turn right onto Margarethenstrae", il.get(3).getTurnDescription(tr));
+        assertEquals("keep left onto Hoher Markt", il.get(5).getTurnDescription(tr));
+        assertEquals("turn right onto Wegscheid", il.get(7).getTurnDescription(tr));
+        assertEquals("turn right onto Ringstrae, L73", il.get(9).getTurnDescription(tr));
+        assertEquals("keep left onto Eyblparkstrae", il.get(10).getTurnDescription(tr));
+        assertEquals("keep left onto Austrae", il.get(11).getTurnDescription(tr));
+        assertEquals("keep left onto Rechte Kremszeile", il.get(12).getTurnDescription(tr));
         //..
-        assertEquals("Turn right onto Treppelweg", resultJson.get(19).get("text"));
-        assertEquals("cycleway", resultJson.get(19).get("annotation_text"));
+        assertEquals("turn right onto Treppelweg", il.get(19).getTurnDescription(tr));
+        assertEquals("cycleway", il.get(19).getAnnotation().getMessage());
     }
 
     @Test
@@ -1081,4 +1073,5 @@ public void testCHOnOffWithTurnCosts() {
         // just a quick check that we did not run the same algorithm twice
         assertNotEquals(rsp1.getHints().get("visited_nodes.sum", "_"), rsp2.getHints().get("visited_nodes.sum", "_"));
     }
+
 }
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
index a63e3378f4..31a5fed242 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
@@ -32,11 +32,10 @@
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
-import com.graphhopper.util.CmdArgs;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.Instruction;
-import com.graphhopper.util.Parameters;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.util.*;
 import com.graphhopper.util.Parameters.Routing;
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.After;
 import org.junit.Before;
@@ -44,10 +43,7 @@
 
 import java.io.File;
 import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
+import java.util.*;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -149,6 +145,60 @@ public void testLoadOSMNoCH() {
         gh.close();
     }
 
+    @Test
+    public void testQueryLocationIndexWithBBox() {
+        GraphHopper gh = new GraphHopperOSM().setStoreOnFlush(true).
+                setEncodingManager(EncodingManager.create("car")).
+                setCHEnabled(false).
+                setGraphHopperLocation("./target/monacotmp-gh").
+                setDataReaderFile("../core/files/monaco.osm.gz");
+        gh.importOrLoad();
+
+        final NodeAccess na = gh.getGraphHopperStorage().getNodeAccess();
+        final Collection<Integer> indexNodeList = new TreeSet<>();
+        LocationIndexTree index = (LocationIndexTree) gh.getLocationIndex();
+        final EdgeExplorer edgeExplorer = gh.getGraphHopperStorage().createEdgeExplorer();
+        final BBox bbox = new BBox(7.422, 7.429, 43.729, 43.734);
+        index.query(bbox, new LocationIndexTree.EdgeVisitor(edgeExplorer) {
+            @Override
+            public void onTile(BBox bbox, int width) {
+            }
+
+            @Override
+            public void onEdge(EdgeIteratorState edge, int nodeA, int nodeB) {
+                for (int i = 0; i < 2; i++) {
+                    int nodeId = i == 0 ? nodeA : nodeB;
+                    double lat = na.getLatitude(nodeId);
+                    double lon = na.getLongitude(nodeId);
+                    if (bbox.contains(lat, lon))
+                        indexNodeList.add(nodeId);
+                }
+            }
+        });
+
+        assertEquals(57, indexNodeList.size());
+        for (int nodeId : indexNodeList) {
+            if (!bbox.contains(na.getLatitude(nodeId), na.getLongitude(nodeId)))
+                fail("bbox " + bbox + " should contain " + nodeId);
+        }
+
+        final Collection<Integer> bfsNodeList = new TreeSet<>();
+        new BreadthFirstSearch() {
+            @Override
+            protected boolean goFurther(int nodeId) {
+                double lat = na.getLatitude(nodeId);
+                double lon = na.getLongitude(nodeId);
+                if (bbox.contains(lat, lon))
+                    bfsNodeList.add(nodeId);
+
+                return true;
+            }
+        }.start(edgeExplorer, index.findClosest(43.731, 7.425, EdgeFilter.ALL_EDGES).getClosestNode());
+
+        assertTrue("index size: " + indexNodeList.size() + ", bfs size: " + bfsNodeList.size(), indexNodeList.size() >= bfsNodeList.size());
+        assertTrue("index size: " + indexNodeList.size() + ", bfs size: " + bfsNodeList.size(), indexNodeList.containsAll(bfsNodeList));
+    }
+
     @Test
     public void testLoadingWithDifferentCHConfig_issue471() {
         // with CH should not be loadable without CH configured
@@ -301,9 +351,9 @@ public void testSortedGraph_noCH() {
                 setAlgorithm(DIJKSTRA_BI)).getBest();
         assertFalse(rsp.hasErrors());
         assertEquals(3, rsp.getPoints().getSize());
-        assertEquals(new GHPoint(51.24921503475044, 9.431716451757769), rsp.getPoints().toGHPoint(0));
-        assertEquals(new GHPoint(52.0, 9.0), rsp.getPoints().toGHPoint(1));
-        assertEquals(new GHPoint(51.199999850988384, 9.39999970197677), rsp.getPoints().toGHPoint(2));
+        assertEquals(new GHPoint(51.24921503475044, 9.431716451757769), rsp.getPoints().get(0));
+        assertEquals(new GHPoint(52.0, 9.0), rsp.getPoints().get(1));
+        assertEquals(new GHPoint(51.199999850988384, 9.39999970197677), rsp.getPoints().get(2));
 
         GHRequest req = new GHRequest(51.2492152, 9.4317166, 51.2, 9.4);
         boolean old = instance.getEncodingManager().isEnableInstructions();
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index 725af9b51e..c2ccb46121 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -199,7 +199,7 @@ protected void paintComponent(Graphics g) {
             Random rand = new Random();
 
             @Override
-            public void paintComponent(Graphics2D g2) {
+            public void paintComponent(final Graphics2D g2) {
                 clearGraphics(g2);
                 int locs = graph.getNodes();
                 Rectangle d = getBounds();
@@ -275,13 +275,38 @@ public void paintComponent(Graphics2D g2) {
                     boolean fwd = edge.get(accessEnc);
                     boolean bwd = edge.getReverse(accessEnc);
                     float width = speed > 90 ? 1f : 0.8f;
-                    if (fwd && !bwd) {
-                        mg.plotDirectedEdge(g2, lat, lon, lat2, lon2, width);
-                    } else {
-                        mg.plotEdge(g2, lat, lon, lat2, lon2, width);
+                    PointList pl = edge.fetchWayGeometry(3);
+                    for (int i = 1; i < pl.size(); i++) {
+                        if (fwd && !bwd) {
+                            mg.plotDirectedEdge(g2, pl.getLatitude(i - 1), pl.getLongitude(i - 1), pl.getLatitude(i), pl.getLongitude(i), width);
+                        } else {
+                            mg.plotEdge(g2, pl.getLatitude(i - 1), pl.getLongitude(i - 1), pl.getLatitude(i), pl.getLongitude(i), width);
+                        }
                     }
                 }
 
+                index.query(graph.getBounds(), new LocationIndexTree.Visitor() {
+                    @Override
+                    public boolean isTileInfo() {
+                        return true;
+                    }
+
+                    @Override
+                    public void onTile(BBox bbox, int depth) {
+                        int width = Math.max(1, Math.min(4, 4 - depth));
+                        g2.setColor(Color.GRAY);
+                        mg.plotEdge(g2, bbox.minLat, bbox.minLon, bbox.minLat, bbox.maxLon, width);
+                        mg.plotEdge(g2, bbox.minLat, bbox.maxLon, bbox.maxLat, bbox.maxLon, width);
+                        mg.plotEdge(g2, bbox.maxLat, bbox.maxLon, bbox.maxLat, bbox.minLon, width);
+                        mg.plotEdge(g2, bbox.maxLat, bbox.minLon, bbox.minLat, bbox.minLon, width);
+                    }
+
+                    @Override
+                    public void onNode(int node) {
+                        // mg.plotNode(g2, node, Color.BLUE);
+                    }
+                });
+
                 g2.setColor(Color.WHITE);
                 g2.fillRect(0, 0, 1000, 20);
                 for (int i = 4; i < speedColors.length; i++) {
diff --git a/web-api/src/main/java/com/graphhopper/http/api/JsonErrorEntity.java b/web-api/src/main/java/com/graphhopper/http/api/JsonErrorEntity.java
new file mode 100644
index 0000000000..5391637a66
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/http/api/JsonErrorEntity.java
@@ -0,0 +1,60 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http.api;
+
+import com.fasterxml.jackson.annotation.JsonValue;
+import com.fasterxml.jackson.databind.node.ArrayNode;
+import com.fasterxml.jackson.databind.node.JsonNodeFactory;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+import com.graphhopper.util.exceptions.GHException;
+
+import java.util.List;
+
+public class JsonErrorEntity {
+
+    private final List<Throwable> errors;
+
+    public JsonErrorEntity(List<Throwable> t) {
+        this.errors = t;
+    }
+
+    @JsonValue
+    ObjectNode jsonErrorResponse() {
+        ObjectNode json = JsonNodeFactory.instance.objectNode();
+        json.put("message", getMessage(errors.get(0)));
+        ArrayNode errorHintList = json.putArray("hints");
+        for (Throwable t : errors) {
+            ObjectNode error = errorHintList.addObject();
+            error.put("message", getMessage(t));
+            error.put("details", t.getClass().getName());
+            if (t instanceof GHException) {
+                ((GHException) t).getDetails().forEach(error::putPOJO);
+            }
+        }
+        return json;
+    }
+
+    private String getMessage(Throwable t) {
+        if (t.getMessage() == null)
+            return t.getClass().getSimpleName();
+        else
+            return t.getMessage();
+    }
+
+}
diff --git a/web-api/src/main/java/com/graphhopper/jackson/GHResponseDeserializer.java b/web-api/src/main/java/com/graphhopper/jackson/GHResponseDeserializer.java
new file mode 100644
index 0000000000..52057d0c89
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/GHResponseDeserializer.java
@@ -0,0 +1,42 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.GHResponse;
+import com.graphhopper.PathWrapper;
+
+import java.io.IOException;
+
+public class GHResponseDeserializer extends JsonDeserializer<GHResponse> {
+    @Override
+    public GHResponse deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
+        GHResponse ghResponse = new GHResponse();
+        JsonNode treeNode = p.readValueAsTree();
+        for (JsonNode path : treeNode.get("paths")) {
+            PathWrapper pathWrapper = ((ObjectMapper) p.getCodec()).convertValue(path, PathWrapper.class);
+            ghResponse.add(pathWrapper);
+        }
+        return ghResponse;
+    }
+}
diff --git a/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java b/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java
index c26a46e270..3c5ef5049d 100644
--- a/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java
+++ b/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java
@@ -1,7 +1,9 @@
 package com.graphhopper.jackson;
 
 import com.fasterxml.jackson.databind.module.SimpleModule;
+import com.graphhopper.GHResponse;
 import com.graphhopper.MultiException;
+import com.graphhopper.PathWrapper;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.details.PathDetail;
@@ -11,6 +13,8 @@
 public class GraphHopperModule extends SimpleModule {
 
     public GraphHopperModule() {
+        addDeserializer(GHResponse.class, new GHResponseDeserializer());
+        addDeserializer(PathWrapper.class, new PathWrapperDeserializer());
         addDeserializer(BBox.class, new BBoxDeserializer());
         addSerializer(BBox.class, new BBoxSerializer());
         addDeserializer(GHPoint.class, new GHPointDeserializer());
diff --git a/web-api/src/main/java/com/graphhopper/jackson/InstructionListSerializer.java b/web-api/src/main/java/com/graphhopper/jackson/InstructionListSerializer.java
index f584c82d15..92965c465f 100644
--- a/web-api/src/main/java/com/graphhopper/jackson/InstructionListSerializer.java
+++ b/web-api/src/main/java/com/graphhopper/jackson/InstructionListSerializer.java
@@ -3,13 +3,44 @@
 import com.fasterxml.jackson.core.JsonGenerator;
 import com.fasterxml.jackson.databind.JsonSerializer;
 import com.fasterxml.jackson.databind.SerializerProvider;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.Instruction;
+import com.graphhopper.util.InstructionAnnotation;
 import com.graphhopper.util.InstructionList;
 
 import java.io.IOException;
+import java.util.*;
 
 public class InstructionListSerializer extends JsonSerializer<InstructionList> {
     @Override
     public void serialize(InstructionList instructions, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
-        jsonGenerator.writeObject(instructions.createJson());
+        List<Map<String, Object>> instrList = new ArrayList<>(instructions.size());
+        int pointsIndex = 0;
+        for (Instruction instruction : instructions) {
+            Map<String, Object> instrJson = new HashMap<>();
+            instrList.add(instrJson);
+
+            InstructionAnnotation ia = instruction.getAnnotation();
+            String text = instruction.getTurnDescription(instructions.getTr());
+            if (Helper.isEmpty(text))
+                text = ia.getMessage();
+            instrJson.put("text", Helper.firstBig(text));
+            if (!ia.isEmpty()) {
+                instrJson.put("annotation_text", ia.getMessage());
+                instrJson.put("annotation_importance", ia.getImportance());
+            }
+
+            instrJson.put("street_name", instruction.getName());
+            instrJson.put("time", instruction.getTime());
+            instrJson.put("distance", Helper.round(instruction.getDistance(), 3));
+            instrJson.put("sign", instruction.getSign());
+            instrJson.putAll(instruction.getExtraInfoJSON());
+
+            int tmpIndex = pointsIndex + instruction.getLength();
+            instrJson.put("interval", Arrays.asList(pointsIndex, tmpIndex));
+            pointsIndex = tmpIndex;
+
+        }
+        jsonGenerator.writeObject(instrList);
     }
 }
diff --git a/web-api/src/main/java/com/graphhopper/jackson/PathWrapperDeserializer.java b/web-api/src/main/java/com/graphhopper/jackson/PathWrapperDeserializer.java
new file mode 100644
index 0000000000..6f782bff26
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/PathWrapperDeserializer.java
@@ -0,0 +1,244 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.type.TypeReference;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.PathWrapper;
+import com.graphhopper.http.WebHelper;
+import com.graphhopper.util.*;
+import com.graphhopper.util.details.PathDetail;
+import com.graphhopper.util.exceptions.*;
+import org.locationtech.jts.geom.LineString;
+
+import java.io.IOException;
+import java.util.*;
+
+public class PathWrapperDeserializer extends JsonDeserializer<PathWrapper> {
+    @Override
+    public PathWrapper deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
+        return createPathWrapper((ObjectMapper) p.getCodec(), p.readValueAsTree(), false, true);
+    }
+
+    public static PathWrapper createPathWrapper(ObjectMapper objectMapper, JsonNode path, boolean hasElevation, boolean turnDescription) {
+        PathWrapper pathWrapper = new PathWrapper();
+        pathWrapper.addErrors(readErrors(objectMapper, path));
+        if (pathWrapper.hasErrors())
+            return pathWrapper;
+
+        if (path.has("snapped_waypoints")) {
+            JsonNode snappedWaypoints = path.get("snapped_waypoints");
+            PointList snappedPoints = deserializePointList(objectMapper, snappedWaypoints, hasElevation);
+            pathWrapper.setWaypoints(snappedPoints);
+        }
+
+        if (path.has("ascend")) {
+            pathWrapper.setAscend(path.get("ascend").asDouble());
+        }
+        if (path.has("descend")) {
+            pathWrapper.setDescend(path.get("descend").asDouble());
+        }
+        if (path.has("weight")) {
+            pathWrapper.setRouteWeight(path.get("weight").asDouble());
+        }
+        if (path.has("description")) {
+            JsonNode descriptionNode = path.get("description");
+            if (descriptionNode.isArray()) {
+                List<String> description = new ArrayList<>(descriptionNode.size());
+                for (JsonNode descNode : descriptionNode) {
+                    description.add(descNode.asText());
+                }
+                pathWrapper.setDescription(description);
+            } else {
+                throw new IllegalStateException("Description has to be an array");
+            }
+        }
+
+        if (path.has("points")) {
+            final PointList pointList = deserializePointList(objectMapper, path.get("points"), hasElevation);
+            pathWrapper.setPoints(pointList);
+
+            if (path.has("instructions")) {
+                JsonNode instrArr = path.get("instructions");
+
+                InstructionList il = new InstructionList(null);
+                int viaCount = 1;
+                for (JsonNode jsonObj : instrArr) {
+                    double instDist = jsonObj.get("distance").asDouble();
+                    String text = turnDescription ? jsonObj.get("text").asText() : jsonObj.get("street_name").asText();
+                    long instTime = jsonObj.get("time").asLong();
+                    int sign = jsonObj.get("sign").asInt();
+                    JsonNode iv = jsonObj.get("interval");
+                    int from = iv.get(0).asInt();
+                    int to = iv.get(1).asInt();
+                    PointList instPL = new PointList(to - from, hasElevation);
+                    for (int j = from; j <= to; j++) {
+                        instPL.add(pointList, j);
+                    }
+
+                    InstructionAnnotation ia = InstructionAnnotation.EMPTY;
+                    if (jsonObj.has("annotation_importance") && jsonObj.has("annotation_text")) {
+                        ia = new InstructionAnnotation(jsonObj.get("annotation_importance").asInt(), jsonObj.get("annotation_text").asText());
+                    }
+
+                    Instruction instr;
+                    if (sign == Instruction.USE_ROUNDABOUT || sign == Instruction.LEAVE_ROUNDABOUT) {
+                        RoundaboutInstruction ri = new RoundaboutInstruction(sign, text, ia, instPL);
+
+                        if (jsonObj.has("exit_number")) {
+                            ri.setExitNumber(jsonObj.get("exit_number").asInt());
+                        }
+
+                        if (jsonObj.has("exited")) {
+                            if (jsonObj.get("exited").asBoolean())
+                                ri.setExited();
+                        }
+
+                        if (jsonObj.has("turn_angle")) {
+                            // TODO provide setTurnAngle setter
+                            double angle = jsonObj.get("turn_angle").asDouble();
+                            ri.setDirOfRotation(angle);
+                            ri.setRadian((angle < 0 ? -Math.PI : Math.PI) - angle);
+                        }
+
+                        instr = ri;
+                    } else if (sign == Instruction.REACHED_VIA) {
+                        ViaInstruction tmpInstr = new ViaInstruction(text, ia, instPL);
+                        tmpInstr.setViaCount(viaCount);
+                        viaCount++;
+                        instr = tmpInstr;
+                    } else if (sign == Instruction.FINISH) {
+                        instr = new FinishInstruction(text, instPL, 0);
+                    } else {
+                        instr = new Instruction(sign, text, ia, instPL);
+                        if (sign == Instruction.CONTINUE_ON_STREET) {
+                            if (jsonObj.has("heading")) {
+                                instr.setExtraInfo("heading", jsonObj.get("heading").asDouble());
+                            }
+                        }
+                    }
+
+                    // Usually, the translation is done from the routing service so just use the provided string
+                    // instead of creating a combination with sign and name etc.
+                    // This is called the turn description.
+                    // This can be changed by passing <code>turn_description=false</code>.
+                    if (turnDescription)
+                        instr.setUseRawName();
+
+                    instr.setDistance(instDist).setTime(instTime);
+                    il.add(instr);
+                }
+                pathWrapper.setInstructions(il);
+            }
+
+            if (path.has("details")) {
+                JsonNode details = path.get("details");
+                Map<String, List<PathDetail>> pathDetails = new HashMap<>(details.size());
+                Iterator<Map.Entry<String, JsonNode>> detailIterator = details.fields();
+                while (detailIterator.hasNext()) {
+                    Map.Entry<String, JsonNode> detailEntry = detailIterator.next();
+                    List<PathDetail> pathDetailList = new ArrayList<>();
+                    for (JsonNode pathDetail : detailEntry.getValue()) {
+                        PathDetail pd = objectMapper.convertValue(pathDetail, PathDetail.class);
+                        pathDetailList.add(pd);
+                    }
+                    pathDetails.put(detailEntry.getKey(), pathDetailList);
+                }
+                pathWrapper.addPathDetails(pathDetails);
+            }
+        }
+
+        double distance = path.get("distance").asDouble();
+        long time = path.get("time").asLong();
+        pathWrapper.setDistance(distance).setTime(time);
+        return pathWrapper;
+    }
+
+    private static PointList deserializePointList(ObjectMapper objectMapper, JsonNode jsonNode, boolean hasElevation) {
+        PointList snappedPoints;
+        if (jsonNode.isTextual()) {
+            snappedPoints = WebHelper.decodePolyline(jsonNode.asText(), 5, hasElevation);
+        } else {
+            LineString lineString = objectMapper.convertValue(jsonNode, LineString.class);
+            snappedPoints = PointList.fromLineString(lineString);
+        }
+        return snappedPoints;
+    }
+
+    public static List<Throwable> readErrors(ObjectMapper objectMapper, JsonNode json) {
+        List<Throwable> errors = new ArrayList<>();
+        JsonNode errorJson;
+
+        if (json.has("message")) {
+            if (json.has("hints")) {
+                errorJson = json.get("hints");
+            } else {
+                // should not happen
+                errors.add(new RuntimeException(json.get("message").asText()));
+                return errors;
+            }
+        } else
+            return errors;
+
+        for (JsonNode error : errorJson) {
+            String exClass = "";
+            if (error.has("details"))
+                exClass = error.get("details").asText();
+
+            String exMessage = error.get("message").asText();
+
+            if (exClass.equals(UnsupportedOperationException.class.getName()))
+                errors.add(new UnsupportedOperationException(exMessage));
+            else if (exClass.equals(IllegalStateException.class.getName()))
+                errors.add(new IllegalStateException(exMessage));
+            else if (exClass.equals(RuntimeException.class.getName()))
+                errors.add(new DetailedRuntimeException(exMessage, toMap(objectMapper, error)));
+            else if (exClass.equals(IllegalArgumentException.class.getName()))
+                errors.add(new DetailedIllegalArgumentException(exMessage, toMap(objectMapper, error)));
+            else if (exClass.equals(ConnectionNotFoundException.class.getName())) {
+                errors.add(new ConnectionNotFoundException(exMessage, toMap(objectMapper, error)));
+            } else if (exClass.equals(PointNotFoundException.class.getName())) {
+                int pointIndex = error.get("point_index").asInt();
+                errors.add(new PointNotFoundException(exMessage, pointIndex));
+            } else if (exClass.equals(PointOutOfBoundsException.class.getName())) {
+                int pointIndex = error.get("point_index").asInt();
+                errors.add(new PointOutOfBoundsException(exMessage, pointIndex));
+            } else if (exClass.isEmpty())
+                errors.add(new DetailedRuntimeException(exMessage, toMap(objectMapper, error)));
+            else
+                errors.add(new DetailedRuntimeException(exClass + " " + exMessage, toMap(objectMapper, error)));
+        }
+
+        if (json.has("message") && errors.isEmpty())
+            errors.add(new RuntimeException(json.get("message").asText()));
+
+        return errors;
+    }
+
+    // Credits to: http://stackoverflow.com/a/24012023/194609
+    private static Map<String, Object> toMap(ObjectMapper objectMapper, JsonNode object) {
+        return objectMapper.convertValue(object, new TypeReference<Map<String, Object>>() {
+        });
+    }
+
+}
diff --git a/api/src/main/java/com/graphhopper/util/GPXEntry.java b/web-api/src/main/java/com/graphhopper/util/gpx/GPXEntry.java
similarity index 52%
rename from api/src/main/java/com/graphhopper/util/GPXEntry.java
rename to web-api/src/main/java/com/graphhopper/util/gpx/GPXEntry.java
index 49a1e0a803..27847c1705 100644
--- a/api/src/main/java/com/graphhopper/util/GPXEntry.java
+++ b/web-api/src/main/java/com/graphhopper/util/gpx/GPXEntry.java
@@ -15,62 +15,55 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.util;
+package com.graphhopper.util.gpx;
 
 import com.graphhopper.util.shapes.GHPoint;
-import com.graphhopper.util.shapes.GHPoint3D;
+
+import java.util.Objects;
 
 /**
  * @author Peter Karich
  */
-public class GPXEntry extends GHPoint3D {
-    private long time;
-
-    public GPXEntry(GHPoint p, long millis) {
-        this(p.lat, p.lon, millis);
-    }
-
-    public GPXEntry(double lat, double lon, long millis) {
-        super(lat, lon, Double.NaN);
-        this.time = millis;
-    }
+public class GPXEntry {
+    private GHPoint point;
+    private Long time;
 
-    public GPXEntry(double lat, double lon, double ele, long millis) {
-        super(lat, lon, ele);
-        this.time = millis;
+    public GPXEntry(GHPoint p) {
+        this.point = p;
     }
 
-    boolean is3D() {
-        return !Double.isNaN(ele);
+    public GPXEntry(GHPoint p, long time) {
+        this.point = p;
+        this.time = time;
     }
 
-    /**
-     * The time relative to the start time in milli seconds.
-     */
-    public long getTime() {
+    public Long getTime() {
         return time;
     }
 
-    public void setTime(long time) {
-        this.time = time;
+    public GHPoint getPoint() {
+        return point;
     }
 
     @Override
-    public int hashCode() {
-        return 59 * super.hashCode() + (int) (time ^ (time >>> 32));
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        GPXEntry gpxEntry = (GPXEntry) o;
+        return Objects.equals(point, gpxEntry.point) &&
+                Objects.equals(time, gpxEntry.time);
     }
 
     @Override
-    public boolean equals(Object obj) {
-        if (obj == null)
-            return false;
-
-        final GPXEntry other = (GPXEntry) obj;
-        return time == other.time && super.equals(obj);
+    public int hashCode() {
+        return Objects.hash(point, time);
     }
 
     @Override
     public String toString() {
-        return super.toString() + ", " + time;
+        return "GPXEntry{" +
+                "point=" + point +
+                ", time=" + time +
+                '}';
     }
 }
diff --git a/web-api/src/main/java/com/graphhopper/util/gpx/GpxFromInstructions.java b/web-api/src/main/java/com/graphhopper/util/gpx/GpxFromInstructions.java
new file mode 100644
index 0000000000..29522f0994
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/util/gpx/GpxFromInstructions.java
@@ -0,0 +1,173 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.util.gpx;
+
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.GHPoint3D;
+
+import java.text.DateFormat;
+import java.text.DecimalFormat;
+import java.text.DecimalFormatSymbols;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+
+public class GpxFromInstructions {
+
+    static String simpleXMLEscape(String str) {
+        // We could even use the 'more flexible' CDATA section but for now do the following. The 'and' could be important sometimes:
+        return str.replaceAll("&", "&amp;").
+                // but do not care for:
+                        replaceAll("[\\<\\>]", "_");
+    }
+
+    public static List<GPXEntry> createGPXList(InstructionList instructions) {
+        List<GPXEntry> gpxList = new ArrayList<>();
+        long timeOffset = 0;
+        for (Instruction instruction : instructions) {
+            int i = 0;
+            for (GHPoint3D point : instruction.getPoints()) {
+                GPXEntry gpxEntry;
+                if (i == 0) {
+                    gpxEntry = new GPXEntry(point, timeOffset);
+                } else {
+                    // We don't have timestamps for pillar nodes
+                    gpxEntry = new GPXEntry(point);
+                }
+                gpxList.add(gpxEntry);
+                i++;
+            }
+            timeOffset = timeOffset + instruction.getTime();
+        }
+        return gpxList;
+    }
+
+    private static void createWayPointBlock(StringBuilder output, Instruction instruction, DecimalFormat decimalFormat, Translation tr) {
+        output.append("\n<wpt ");
+        output.append("lat=\"").append(decimalFormat.format(instruction.getPoints().getLatitude(0)));
+        output.append("\" lon=\"").append(decimalFormat.format(instruction.getPoints().getLongitude(0))).append("\">");
+        String name;
+        if (instruction.getName().isEmpty())
+            name = instruction.getTurnDescription(tr);
+        else
+            name = instruction.getName();
+
+        output.append(" <name>").append(simpleXMLEscape(name)).append("</name>");
+        output.append("</wpt>");
+    }
+
+    public static String createGPX(InstructionList instructions, String trackName, long startTimeMillis, boolean includeElevation, boolean withRoute, boolean withTrack, boolean withWayPoints, String version, Translation tr) {
+        DateFormat formatter = Helper.createFormatter();
+
+        DecimalFormat decimalFormat = new DecimalFormat("#", DecimalFormatSymbols.getInstance(Locale.ROOT));
+        decimalFormat.setMinimumFractionDigits(1);
+        decimalFormat.setMaximumFractionDigits(6);
+        decimalFormat.setMinimumIntegerDigits(1);
+
+        String header = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>"
+                + "<gpx xmlns=\"http://www.topografix.com/GPX/1/1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""
+                + " creator=\"Graphhopper version " + version + "\" version=\"1.1\""
+                // This xmlns:gh acts only as ID, no valid URL necessary.
+                // Use a separate namespace for custom extensions to make basecamp happy.
+                + " xmlns:gh=\"https://graphhopper.com/public/schema/gpx/1.1\">"
+                + "\n<metadata>"
+                + "<copyright author=\"OpenStreetMap contributors\"/>"
+                + "<link href=\"http://graphhopper.com\">"
+                + "<text>GraphHopper GPX</text>"
+                + "</link>"
+                + "<time>" + formatter.format(startTimeMillis) + "</time>"
+                + "</metadata>";
+        StringBuilder gpxOutput = new StringBuilder(header);
+        if (!instructions.isEmpty()) {
+            if (withWayPoints) {
+                createWayPointBlock(gpxOutput, instructions.get(0), decimalFormat, tr);   // Start
+                for (Instruction currInstr : instructions) {
+                    if ((currInstr.getSign() == Instruction.REACHED_VIA) // Via
+                            || (currInstr.getSign() == Instruction.FINISH)) // End
+                    {
+                        createWayPointBlock(gpxOutput, currInstr, decimalFormat, tr);
+                    }
+                }
+            }
+            if (withRoute) {
+                gpxOutput.append("\n<rte>");
+                Instruction nextInstr = null;
+                for (Instruction currInstr : instructions) {
+                    if (null != nextInstr)
+                        createRteptBlock(gpxOutput, nextInstr, currInstr, decimalFormat, tr);
+
+                    nextInstr = currInstr;
+                }
+                createRteptBlock(gpxOutput, nextInstr, null, decimalFormat, tr);
+                gpxOutput.append("\n</rte>");
+            }
+        }
+        if (withTrack) {
+            gpxOutput.append("\n<trk><name>").append(trackName).append("</name>");
+
+            gpxOutput.append("<trkseg>");
+            for (GPXEntry entry : createGPXList(instructions)) {
+                gpxOutput.append("\n<trkpt lat=\"").append(decimalFormat.format(entry.getPoint().getLat()));
+                gpxOutput.append("\" lon=\"").append(decimalFormat.format(entry.getPoint().getLon())).append("\">");
+                if (includeElevation)
+                    gpxOutput.append("<ele>").append(Helper.round2(((GHPoint3D) entry.getPoint()).getEle())).append("</ele>");
+                if (entry.getTime() != null)
+                    gpxOutput.append("<time>").append(formatter.format(startTimeMillis + entry.getTime())).append("</time>");
+                gpxOutput.append("</trkpt>");
+            }
+            gpxOutput.append("\n</trkseg>");
+            gpxOutput.append("\n</trk>");
+        }
+
+        // we could now use 'wpt' for via points
+        gpxOutput.append("\n</gpx>");
+        return gpxOutput.toString();
+    }
+
+    private static void createRteptBlock(StringBuilder output, Instruction instruction, Instruction nextI, DecimalFormat decimalFormat, Translation tr) {
+        output.append("\n<rtept lat=\"").append(decimalFormat.format(instruction.getPoints().getLatitude(0))).
+                append("\" lon=\"").append(decimalFormat.format(instruction.getPoints().getLongitude(0))).append("\">");
+
+        if (!instruction.getName().isEmpty())
+            output.append("<desc>").append(simpleXMLEscape(instruction.getTurnDescription(tr))).append("</desc>");
+
+        output.append("<extensions>");
+        output.append("<gh:distance>").append(Helper.round(instruction.getDistance(), 1)).append("</gh:distance>");
+        output.append("<gh:time>").append(instruction.getTime()).append("</gh:time>");
+
+        String direction = instruction.calcDirection(nextI);
+        if (!direction.isEmpty())
+            output.append("<gh:direction>").append(direction).append("</gh:direction>");
+
+        double azimuth = instruction.calcAzimuth(nextI);
+        if (!Double.isNaN(azimuth))
+            output.append("<gh:azimuth>").append(Helper.round2(azimuth)).append("</gh:azimuth>");
+
+        if (instruction instanceof RoundaboutInstruction) {
+            RoundaboutInstruction ri = (RoundaboutInstruction) instruction;
+
+            output.append("<gh:exit_number>").append(ri.getExitNumber()).append("</gh:exit_number>");
+        }
+
+        output.append("<gh:sign>").append(instruction.getSign()).append("</gh:sign>");
+        output.append("</extensions>");
+        output.append("</rtept>");
+    }
+
+}
diff --git a/web-api/src/test/java/com/graphhopper/util/InstructionListRepresentationTest.java b/web-api/src/test/java/com/graphhopper/util/InstructionListRepresentationTest.java
index e878add342..73f50ef9f7 100644
--- a/web-api/src/test/java/com/graphhopper/util/InstructionListRepresentationTest.java
+++ b/web-api/src/test/java/com/graphhopper/util/InstructionListRepresentationTest.java
@@ -1,19 +1,22 @@
 package com.graphhopper.util;
 
-import com.fasterxml.jackson.core.JsonProcessingException;
 import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.jackson.Jackson;
 import org.junit.Test;
 
+import java.io.IOException;
 import java.util.Collections;
 import java.util.Locale;
 import java.util.Map;
 
-import static org.junit.Assert.*;
+import static io.dropwizard.testing.FixtureHelpers.fixture;
+import static org.junit.Assert.assertEquals;
 
 public class InstructionListRepresentationTest {
 
     @Test
-    public void testRoundaboutJsonIntegrity() {
+    public void testRoundaboutJsonIntegrity() throws IOException {
+        ObjectMapper objectMapper = Jackson.newObjectMapper();
         InstructionList il = new InstructionList(usTR);
 
         PointList pl = new PointList();
@@ -27,27 +30,14 @@ public void testRoundaboutJsonIntegrity() {
                 .setExitNumber(2)
                 .setExited();
         il.add(instr);
-
-        Map<String, Object> json = il.createJson().get(0);
-        // assert that all information is present in map for JSON
-        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
-        assertEquals(-1, (Double) json.get("turn_angle"), 0.01);
-        assertEquals("2", json.get("exit_number").toString());
-        // assert that a valid JSON object can be written
-        assertNotNull(write(json));
+        assertEquals(objectMapper.readTree(fixture("fixtures/roundabout1.json")).toString(), objectMapper.valueToTree(il).toString());
     }
 
-    private String write(Map<String, Object> json) {
-        try {
-            return new ObjectMapper().writeValueAsString(json);
-        } catch (JsonProcessingException e) {
-            throw new RuntimeException(e);
-        }
-    }
 
     // Roundabout with unknown dir of rotation
     @Test
-    public void testRoundaboutJsonNaN() {
+    public void testRoundaboutJsonNaN() throws IOException {
+        ObjectMapper objectMapper = Jackson.newObjectMapper();
         InstructionList il = new InstructionList(usTR);
 
         PointList pl = new PointList();
@@ -60,15 +50,10 @@ public void testRoundaboutJsonNaN() {
                 .setExitNumber(2)
                 .setExited();
         il.add(instr);
-
-        Map<String, Object> json = il.createJson().get(0);
-        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
-        assertNull(json.get("turn_angle"));
-        // assert that a valid JSON object can be written
-        assertNotNull(write(json));
+        assertEquals(objectMapper.readTree(fixture("fixtures/roundabout2.json")).toString(), objectMapper.valueToTree(il).toString());
     }
 
-    static Translation usTR = new Translation() {
+    private static Translation usTR = new Translation() {
         @Override
         public String tr(String key, Object... params) {
             if (key.equals("roundabout_exit_onto"))
diff --git a/web-api/src/test/resources/fixtures/roundabout1.json b/web-api/src/test/resources/fixtures/roundabout1.json
new file mode 100644
index 0000000000..1502f85039
--- /dev/null
+++ b/web-api/src/test/resources/fixtures/roundabout1.json
@@ -0,0 +1,11 @@
+[ {
+    "exit_number" : 2,
+    "distance" : 0.0,
+    "sign" : 6,
+    "exited" : true,
+    "turn_angle" : -1.0,
+    "interval" : [ 0, 3 ],
+    "text" : "At roundabout, take exit 2 onto streetname",
+    "time" : 0,
+    "street_name" : "streetname"
+} ]
\ No newline at end of file
diff --git a/web-api/src/test/resources/fixtures/roundabout2.json b/web-api/src/test/resources/fixtures/roundabout2.json
new file mode 100644
index 0000000000..5139688ceb
--- /dev/null
+++ b/web-api/src/test/resources/fixtures/roundabout2.json
@@ -0,0 +1,10 @@
+[ {
+    "exit_number" : 2,
+    "distance" : 0.0,
+    "sign" : 6,
+    "exited" : true,
+    "interval" : [ 0, 3 ],
+    "text" : "At roundabout, take exit 2 onto streetname",
+    "time" : 0,
+    "street_name" : "streetname"
+} ]
\ No newline at end of file
diff --git a/web-bundle/pom.xml b/web-bundle/pom.xml
index 330cd350ab..44c2fed1b7 100644
--- a/web-bundle/pom.xml
+++ b/web-bundle/pom.xml
@@ -43,13 +43,13 @@
         <dependency>
             <groupId>javax.xml.ws</groupId>
             <artifactId>jaxws-api</artifactId>
-            <version>2.3.0</version>
+            <version>2.3.1</version>
         </dependency>
         <!-- required for dropwizard -->
         <dependency>
             <groupId>com.google.guava</groupId>
             <artifactId>guava</artifactId>
-            <version>24.0-jre</version>
+            <version>${guava.version}</version>
         </dependency>
         <dependency>
             <groupId>io.dropwizard</groupId>
diff --git a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
index adaae90921..6bbe30847b 100644
--- a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
@@ -37,7 +37,6 @@
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
-import com.graphhopper.reader.gtfs.RealtimeFeed;
 import com.graphhopper.resources.*;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
@@ -209,28 +208,28 @@ private void runPtGraphHopper(CmdArgs configuration, Environment environment) {
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
         final GHDirectory ghDirectory = GraphHopperGtfs.createGHDirectory(configuration.get("graph.location", "target/tmp"));
         final GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
-        final EncodingManager encodingManager = new EncodingManager.Builder(8).add(ptFlagEncoder).add(new FootFlagEncoder()).add(new CarFlagEncoder()).build();
+        final EncodingManager encodingManager = new EncodingManager.Builder(configuration.getInt("graph.bytes_for_flags", 8)).add(ptFlagEncoder).add(new FootFlagEncoder()).add(new CarFlagEncoder()).build();
         final GraphHopperStorage graphHopperStorage = GraphHopperGtfs.createOrLoad(ghDirectory, encodingManager, ptFlagEncoder, gtfsStorage,
                 configuration.has("gtfs.file") ? Arrays.asList(configuration.get("gtfs.file", "").split(",")) : Collections.emptyList(),
                 configuration.has("datareader.file") ? Arrays.asList(configuration.get("datareader.file", "").split(",")) : Collections.emptyList());
         final TranslationMap translationMap = GraphHopperGtfs.createTranslationMap();
         final LocationIndex locationIndex = GraphHopperGtfs.createOrLoadIndex(ghDirectory, graphHopperStorage);
-        final GraphHopperAPI graphHopper = new GraphHopperGtfs(ptFlagEncoder, translationMap, graphHopperStorage, locationIndex, gtfsStorage, RealtimeFeed.empty(gtfsStorage));
         environment.jersey().register(new AbstractBinder() {
             @Override
             protected void configure() {
                 bind(configuration).to(CmdArgs.class);
-                bind(graphHopper).to(GraphHopperAPI.class);
                 bind(false).to(Boolean.class).named("hasElevation");
                 bind(locationIndex).to(LocationIndex.class);
                 bind(translationMap).to(TranslationMap.class);
                 bind(encodingManager).to(EncodingManager.class);
+                bind(ptFlagEncoder).to(PtFlagEncoder.class);
                 bind(graphHopperStorage).to(GraphHopperStorage.class);
+                bind(gtfsStorage).to(GtfsStorage.class);
                 bindFactory(RasterHullBuilderFactory.class).to(DelaunayTriangulationIsolineBuilder.class);
             }
         });
         environment.jersey().register(NearestResource.class);
-        environment.jersey().register(RouteResource.class);
+        environment.jersey().register(GraphHopperGtfs.class);
         environment.jersey().register(new PtIsochroneResource(gtfsStorage, encodingManager, graphHopperStorage, locationIndex));
         environment.jersey().register(I18NResource.class);
         environment.jersey().register(InfoResource.class);
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java b/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
index 4496fa7f4d..7c24ee5e15 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
@@ -31,7 +31,7 @@
 @Path("isochrone")
 public class IsochroneResource {
 
-    private static final Logger logger = LoggerFactory.getLogger(RouteResource.class);
+    private static final Logger logger = LoggerFactory.getLogger(IsochroneResource.class);
 
     private final GraphHopper graphHopper;
     private final EncodingManager encodingManager;
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java b/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java
index 9a39461cdf..876199520d 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java
@@ -22,7 +22,6 @@
 import com.graphhopper.json.geo.JsonFeature;
 import com.graphhopper.reader.gtfs.*;
 import com.graphhopper.routing.QueryGraph;
-import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
@@ -31,11 +30,10 @@
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Parameters;
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import org.locationtech.jts.geom.*;
-import org.locationtech.jts.index.strtree.STRtree;
 import org.locationtech.jts.triangulate.ConformingDelaunayTriangulator;
 import org.locationtech.jts.triangulate.ConstraintVertex;
 import org.locationtech.jts.triangulate.DelaunayTriangulationBuilder;
@@ -58,7 +56,6 @@
     private EncodingManager encodingManager;
     private GraphHopperStorage graphHopperStorage;
     private LocationIndex locationIndex;
-//    private final STRtree spatialIndex;
 
     private final Function<Label, Double> z = label -> (double) label.currentTime;
 
@@ -67,15 +64,6 @@ public PtIsochroneResource(GtfsStorage gtfsStorage, EncodingManager encodingMana
         this.encodingManager = encodingManager;
         this.graphHopperStorage = graphHopperStorage;
         this.locationIndex = locationIndex;
-//        spatialIndex = new STRtree();
-//        PtFlagEncoder ptFlagEncoder = (PtFlagEncoder) encodingManager.getEncoder("pt");
-//        AllEdgesIterator allEdges = graphHopperStorage.getAllEdges();
-//        while (allEdges.next()) {
-//            if (ptFlagEncoder.getEdgeType(allEdges.getFlags()) == GtfsStorage.EdgeType.HIGHWAY) {
-//                LineString geom = allEdges.fetchWayGeometry(3).toLineString(false);
-//                spatialIndex.insert(geom.getEnvelopeInternal(), allEdges.getEdge());
-//            }
-//        }
     }
 
     public static class Response {
@@ -114,7 +102,7 @@ public Response doGet(
         }
 
         PtFlagEncoder ptFlagEncoder = (PtFlagEncoder) encodingManager.getEncoder("pt");
-        GraphExplorer graphExplorer = new GraphExplorer(queryGraph, new FastestWeighting(encodingManager.getEncoder("foot")), ptFlagEncoder, gtfsStorage, RealtimeFeed.empty(gtfsStorage), reverseFlow, Collections.emptyList(), false, 5.0);
+        GraphExplorer graphExplorer = new GraphExplorer(queryGraph, new FastestWeighting(encodingManager.getEncoder("foot")), ptFlagEncoder, gtfsStorage, RealtimeFeed.empty(gtfsStorage), reverseFlow, false, 5.0);
         MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, ptFlagEncoder, reverseFlow, Double.MAX_VALUE, false, false, false, 1000000, Collections.emptyList());
 
         Map<Coordinate, Double> z1 = new HashMap<>();
@@ -133,17 +121,16 @@ public Response doGet(
             router.calcLabelsAndNeighbors(queryResult.getClosestNode(), -1, initialTime, blockedRouteTypes, sptVisitor, label -> label.currentTime <= targetZ);
             MultiPoint exploredPointsAndNeighbors = geometryFactory.createMultiPointFromCoords(z1.keySet().toArray(new Coordinate[0]));
 
-            // This is what we need to do once we can do bounding-box queries on our spatial index.
-            // Then it should be impossible for unreachable encroaching points to not be found.
-
-//            spatialIndex.query(exploredPointsAndNeighbors.getEnvelopeInternal(), edgeId -> {
-//                EdgeIteratorState e = graphHopperStorage.getEdgeIteratorState((int) edgeId, Integer.MIN_VALUE);
-//                Coordinate nodeCoordinate = new Coordinate(nodeAccess.getLongitude(e.getBaseNode()), nodeAccess.getLatitude(e.getBaseNode()));
-//                z1.merge(nodeCoordinate, Double.MAX_VALUE, Math::min);
-//                nodeCoordinate = new Coordinate(nodeAccess.getLongitude(e.getAdjNode()), nodeAccess.getLatitude(e.getAdjNode()));
-//                z1.merge(nodeCoordinate, Double.MAX_VALUE, Math::min);
-//            });
-//            exploredPointsAndNeighbors = geometryFactory.createMultiPointFromCoords(z1.keySet().toArray(new Coordinate[0]));
+            // Get at least all nodes within our bounding box (I think convex hull would be enough.)
+            // I think then we should have all possible encroaching points. (Proof needed.)
+            locationIndex.query(BBox.fromEnvelope(exploredPointsAndNeighbors.getEnvelopeInternal()), new LocationIndex.Visitor() {
+                @Override
+                public void onNode(int nodeId) {
+                    Coordinate nodeCoordinate = new Coordinate(nodeAccess.getLongitude(nodeId), nodeAccess.getLatitude(nodeId));
+                    z1.merge(nodeCoordinate, Double.MAX_VALUE, Math::min);
+                }
+            });
+            exploredPointsAndNeighbors = geometryFactory.createMultiPointFromCoords(z1.keySet().toArray(new Coordinate[0]));
 
             CoordinateList siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(exploredPointsAndNeighbors);
             List<ConstraintVertex> constraintVertices = new ArrayList<>();
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
index 517bbb51ee..9521fa1e66 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
@@ -22,12 +22,9 @@
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.MultiException;
 import com.graphhopper.http.WebHelper;
-import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.HintsMap;
-import com.graphhopper.util.Constants;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.Parameters;
-import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.*;
+import com.graphhopper.util.gpx.GpxFromInstructions;
 import com.graphhopper.util.shapes.GHPoint;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -168,7 +165,8 @@ public Response doGet(
         }
 
         long time = timeString != null ? Long.parseLong(timeString) : System.currentTimeMillis();
-        return Response.ok(ghRsp.getBest().getInstructions().createGPX(trackName, time, enableElevation, withRoute, withTrack, withWayPoints, version), "application/gpx+xml").
+        InstructionList instructions = ghRsp.getBest().getInstructions();
+        return Response.ok(GpxFromInstructions.createGPX(instructions, trackName, time, enableElevation, withRoute, withTrack, withWayPoints, version, instructions.getTr()), "application/gpx+xml").
                 header("Content-Disposition", "attachment;filename=" + "GraphHopper.gpx");
     }
 
diff --git a/web-bundle/src/test/java/com/graphhopper/util/gpx/GpxFromInstructionsTest.java b/web-bundle/src/test/java/com/graphhopper/util/gpx/GpxFromInstructionsTest.java
new file mode 100644
index 0000000000..bd7f3ea700
--- /dev/null
+++ b/web-bundle/src/test/java/com/graphhopper/util/gpx/GpxFromInstructionsTest.java
@@ -0,0 +1,243 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.util.gpx;
+
+import com.carrotsearch.hppc.IntArrayList;
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.Dijkstra;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.IntsRef;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.*;
+import org.junit.Before;
+import org.junit.Test;
+import org.xml.sax.SAXException;
+
+import javax.xml.XMLConstants;
+import javax.xml.transform.Source;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.validation.Schema;
+import javax.xml.validation.SchemaFactory;
+import javax.xml.validation.Validator;
+import java.io.StringReader;
+import java.util.*;
+
+import static org.junit.Assert.*;
+
+public class GpxFromInstructionsTest {
+
+    private EncodingManager carManager;
+    private FlagEncoder carEncoder;
+    private BooleanEncodedValue roundaboutEnc;
+    private TranslationMap trMap;
+
+    @Before
+    public void setUp() {
+        carEncoder = new CarFlagEncoder();
+        carManager = EncodingManager.create(carEncoder);
+        roundaboutEnc = carManager.getBooleanEncodedValue(EncodingManager.ROUNDABOUT);
+        trMap = new TranslationMap().doImport();
+    }
+
+    @Test
+    public void testInstructionsWithTimeAndPlace() {
+        Graph g = new GraphBuilder(carManager).create();
+        //   n-4-5   (n: pillar node)
+        //   |
+        // 7-3-2-6
+        //     |
+        //     1
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(1, 15.0, 10);
+        na.setNode(2, 15.1, 10);
+        na.setNode(3, 15.1, 9.9);
+        na.setNode(4, 15.2, 9.9);
+        na.setNode(5, 15.2, 10);
+        na.setNode(6, 15.1, 10.1);
+        na.setNode(7, 15.1, 9.8);
+
+        g.edge(1, 2, 7000, true).setName("1-2").setFlags(flagsForSpeed(carManager, 70));
+        g.edge(2, 3, 8000, true).setName("2-3").setFlags(flagsForSpeed(carManager, 80));
+        g.edge(2, 6, 10000, true).setName("2-6").setFlags(flagsForSpeed(carManager, 10));
+        g.edge(3, 4, 9000, true).setName("3-4").setFlags(flagsForSpeed(carManager, 90));
+        g.edge(3, 7, 10000, true).setName("3-7").setFlags(flagsForSpeed(carManager, 10));
+        g.edge(4, 5, 10000, true).setName("4-5").setFlags(flagsForSpeed(carManager, 100));
+
+        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), TraversalMode.NODE_BASED).calcPath(1, 5);
+        InstructionList wayList = p.calcInstructions(roundaboutEnc, trMap.getWithFallBack(Locale.US));
+        PointList points = p.calcPoints();
+        assertEquals(4, wayList.size());
+
+        assertEquals(34000, p.getDistance(), 1e-1);
+        assertEquals(34000, sumDistances(wayList), 1e-1);
+        assertEquals(5, points.size());
+        assertEquals(1604120, p.getTime());
+
+        assertEquals(Instruction.CONTINUE_ON_STREET, wayList.get(0).getSign());
+        assertEquals(15, wayList.get(0).getPoints().getLatitude(0), 1e-3);
+        assertEquals(10, wayList.get(0).getPoints().getLongitude(0), 1e-3);
+
+        assertEquals(Instruction.TURN_LEFT, wayList.get(1).getSign());
+        assertEquals(15.1, wayList.get(1).getPoints().getLatitude(0), 1e-3);
+        assertEquals(10, wayList.get(1).getPoints().getLongitude(0), 1e-3);
+
+        assertEquals(Instruction.TURN_RIGHT, wayList.get(2).getSign());
+        assertEquals(15.1, wayList.get(2).getPoints().getLatitude(0), 1e-3);
+        assertEquals(9.9, wayList.get(2).getPoints().getLongitude(0), 1e-3);
+
+        String gpxStr = GpxFromInstructions.createGPX(wayList, "test", (long) 0, false, true, true, true, Constants.VERSION, trMap.getWithFallBack(Locale.US));
+        verifyGPX(gpxStr);
+        System.out.println(gpxStr);
+
+        assertTrue(gpxStr, gpxStr.contains("<trkpt lat=\"15.0\" lon=\"10.0\"><time>1970-01-01T00:00:00Z</time>"));
+        assertTrue(gpxStr, gpxStr.contains("<extensions>") && gpxStr.contains("</extensions>"));
+        assertTrue(gpxStr, gpxStr.contains("<rtept lat=\"15.1\" lon=\"10.0\">"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:distance>8000.0</gh:distance>"));
+        assertTrue(gpxStr, gpxStr.contains("<desc>turn left onto 2-3</desc>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:sign>-2</gh:sign>"));
+
+        assertTrue(gpxStr, gpxStr.contains("<gh:direction>N</gh:direction>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:azimuth>0.0</gh:azimuth>"));
+
+        assertFalse(gpxStr, gpxStr.contains("NaN"));
+    }
+
+    @Test
+    public void testCreateGPX() {
+        InstructionAnnotation ea = InstructionAnnotation.EMPTY;
+        InstructionList instructions = new InstructionList(trMap.getWithFallBack(Locale.US));
+        PointList pl = new PointList();
+        pl.add(49.942576, 11.580384);
+        pl.add(49.941858, 11.582422);
+        instructions.add(new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl).setDistance(240).setTime(15000));
+
+        pl = new PointList();
+        pl.add(49.941575, 11.583501);
+        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(4000));
+
+        pl = new PointList();
+        pl.add(49.941389, 11.584311);
+        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(3000));
+        instructions.add(new FinishInstruction(49.941029, 11.584514, 0));
+
+        List<GPXEntry> result = GpxFromInstructions.createGPXList(instructions);
+        assertEquals(5, result.size());
+
+        assertEquals(0, result.get(0).getTime().longValue());
+        assertNull(result.get(1).getTime());
+        assertEquals(15000, result.get(2).getTime().longValue());
+        assertEquals(19000, result.get(3).getTime().longValue());
+        assertEquals(22000, result.get(4).getTime().longValue());
+
+        verifyGPX(GpxFromInstructions.createGPX(instructions, "GraphHopper", new Date().getTime(), false, true, true, true, Constants.VERSION, trMap.getWithFallBack(Locale.US)));
+    }
+
+    @Test
+    public void testCreateGPXIncludesRoundaboutExitNumber() {
+        InstructionList instructions = new InstructionList(trMap.getWithFallBack(Locale.US));
+
+        PointList pl = new PointList();
+        pl.add(52.555423473315, 13.43890086052345);
+        pl.add(52.555550691982, 13.43946393816465);
+        pl.add(52.555619423589, 13.43886994061328);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                InstructionAnnotation.EMPTY, pl)
+                .setRadian(2.058006514284998d)
+                .setExitNumber(3)
+                .setExited();
+        instructions.add(instr);
+        instructions.add(new FinishInstruction(52.555619423589, 13.43886994061328, 0));
+
+        String gpxStr = GpxFromInstructions.createGPX(instructions, "test", 0, true, true, false, false, Constants.VERSION, trMap.getWithFallBack(Locale.US));
+
+        assertTrue(gpxStr, gpxStr.contains("<gh:exit_number>3</gh:exit_number>"));
+        verifyGPX(gpxStr);
+    }
+
+    @Test
+    public void testCreateGPXCorrectFormattingSmallNumbers() {
+        InstructionList instructions = new InstructionList(trMap.getWithFallBack(Locale.US));
+
+        PointList pl = new PointList();
+        pl.add(0.000001, 0.000001);
+        pl.add(-0.000123, -0.000125);
+        Instruction instruction = new Instruction(0, "do it", null, pl);
+        instructions.add(instruction);
+        instructions.add(new FinishInstruction(0.000852, 0.000852, 0));
+
+        String gpxStr = GpxFromInstructions.createGPX(instructions, "test", 0, true, true, true, true, Constants.VERSION, trMap.getWithFallBack(Locale.US));
+
+        assertFalse(gpxStr, gpxStr.contains("E-"));
+        assertTrue(gpxStr, gpxStr.contains("0.000001"));
+        assertTrue(gpxStr, gpxStr.contains("-0.000125"));
+        verifyGPX(gpxStr);
+    }
+
+    @Test
+    public void testXMLEscape_issue572() {
+        assertEquals("_", GpxFromInstructions.simpleXMLEscape("<"));
+        assertEquals("_blup_", GpxFromInstructions.simpleXMLEscape("<blup>"));
+        assertEquals("a&amp;b", GpxFromInstructions.simpleXMLEscape("a&b"));
+    }
+
+    private IntsRef flagsForSpeed(EncodingManager encodingManager, int speedKmPerHour) {
+        ReaderWay way = new ReaderWay(1);
+        way.setTag("highway", "motorway");
+        way.setTag("maxspeed", String.format("%d km/h", speedKmPerHour));
+        EncodingManager.AcceptWay map = new EncodingManager.AcceptWay();
+        encodingManager.acceptWay(way, map);
+        return encodingManager.handleWayTags(way, map, 0);
+    }
+
+    private void verifyGPX(String gpx) {
+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
+        Schema schema = null;
+        try {
+            Source schemaFile = new StreamSource(getClass().getResourceAsStream("gpx-schema.xsd"));
+            schema = schemaFactory.newSchema(schemaFile);
+
+            // using more schemas: http://stackoverflow.com/q/1094893/194609
+        } catch (SAXException e1) {
+            throw new IllegalStateException("There was a problem with the schema supplied for validation. Message:" + e1.getMessage());
+        }
+        Validator validator = schema.newValidator();
+        try {
+            validator.validate(new StreamSource(new StringReader(gpx)));
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private double sumDistances(InstructionList il) {
+        double val = 0;
+        for (Instruction i : il) {
+            val += i.getDistance();
+        }
+        return val;
+    }
+
+}
diff --git a/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd b/web-bundle/src/test/resources/com/graphhopper/util/gpx/gpx-schema.xsd
similarity index 100%
rename from core/src/test/resources/com/graphhopper/util/gpx-schema.xsd
rename to web-bundle/src/test/resources/com/graphhopper/util/gpx/gpx-schema.xsd
diff --git a/web/package.json b/web/package.json
index a63f4d89e1..dc8661b100 100644
--- a/web/package.json
+++ b/web/package.json
@@ -27,7 +27,7 @@
     "browserify": "16.2.0",
     "browserify-swap": "0.2.2",
     "d3": "5.9.1",
-    "jquery": "3.3.1",
+    "jquery": "3.4.1",
     "leaflet": "1.3.1",
     "leaflet-contextmenu": "1.4.0",
     "leaflet-loading": "0.1.24",
diff --git a/web/pom.xml b/web/pom.xml
index 50a225ee9e..a0eccbb2a5 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -38,7 +38,7 @@
         <dependency>
             <groupId>io.dropwizard-bundles</groupId>
             <artifactId>dropwizard-configurable-assets-bundle</artifactId>
-            <version>${dropwizard.version}</version>
+            <version>1.3.5</version>
         </dependency>
         <dependency>
             <groupId>io.dropwizard</groupId>
@@ -76,7 +76,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-shade-plugin</artifactId>
-                <version>3.1.1</version>
+                <version>3.2.1</version>
                 <configuration>
                     <createDependencyReducedPom>true</createDependencyReducedPom>
                     <filters>
diff --git a/web/src/main/java/com/graphhopper/http/GHJerseyViolationExceptionMapper.java b/web/src/main/java/com/graphhopper/http/GHJerseyViolationExceptionMapper.java
new file mode 100644
index 0000000000..3cfa30059d
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/GHJerseyViolationExceptionMapper.java
@@ -0,0 +1,39 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http;
+
+import com.graphhopper.http.api.JsonErrorEntity;
+import io.dropwizard.jersey.validation.ConstraintMessage;
+import io.dropwizard.jersey.validation.JerseyViolationException;
+
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import java.util.stream.Collectors;
+
+public class GHJerseyViolationExceptionMapper implements ExceptionMapper<JerseyViolationException> {
+    @Override
+    public Response toResponse(final JerseyViolationException e) {
+        return Response
+                .status(ConstraintMessage.determineStatus(e.getConstraintViolations(), e.getInvocable()))
+                .type(MediaType.APPLICATION_JSON)
+                .entity(new JsonErrorEntity(e.getConstraintViolations().stream().map(v -> new IllegalArgumentException(v.getMessage())).collect(Collectors.toList())))
+                .build();
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java b/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
index 601643b45d..b98b46a7a1 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
@@ -17,12 +17,15 @@
  */
 package com.graphhopper.http;
 
+import com.graphhopper.gtfs.dropwizard.RealtimeBundle;
 import com.graphhopper.http.cli.ImportCommand;
 import com.graphhopper.http.resources.RootResource;
 import io.dropwizard.Application;
 import io.dropwizard.bundles.assets.ConfiguredAssetsBundle;
+import io.dropwizard.client.HttpClientBuilder;
 import io.dropwizard.setup.Bootstrap;
 import io.dropwizard.setup.Environment;
+import org.apache.http.client.HttpClient;
 
 import javax.servlet.DispatcherType;
 import java.util.EnumSet;
@@ -36,12 +39,14 @@ public static void main(String[] args) throws Exception {
     @Override
     public void initialize(Bootstrap<GraphHopperServerConfiguration> bootstrap) {
         bootstrap.addBundle(new GraphHopperBundle());
+        bootstrap.addBundle(new RealtimeBundle());
         bootstrap.addBundle(new ConfiguredAssetsBundle("/assets/", "/maps/", "index.html"));
-        bootstrap.addCommand(new ImportCommand(bootstrap.getObjectMapper()));
+        bootstrap.addCommand(new ImportCommand());
     }
 
     @Override
-    public void run(GraphHopperServerConfiguration configuration, Environment environment) {
+    public void run(GraphHopperServerConfiguration configuration, Environment environment) throws Exception {
+        environment.jersey().register(new GHJerseyViolationExceptionMapper());
         environment.jersey().register(new RootResource());
         environment.servlets().addFilter("cors", CORSFilter.class).addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, "*");
         environment.servlets().addFilter("ipfilter", new IPFilter(configuration.getGraphHopperConfiguration().get("jetty.whiteips", ""), configuration.getGraphHopperConfiguration().get("jetty.blackips", ""))).addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, "*");
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServerConfiguration.java b/web/src/main/java/com/graphhopper/http/GraphHopperServerConfiguration.java
index c786a4d37d..b09ab29897 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServerConfiguration.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServerConfiguration.java
@@ -19,6 +19,9 @@
 package com.graphhopper.http;
 
 import com.fasterxml.jackson.annotation.JsonProperty;
+import com.graphhopper.gtfs.dropwizard.RealtimeBundleConfiguration;
+import com.graphhopper.gtfs.dropwizard.FeedConfiguration;
+import com.graphhopper.gtfs.dropwizard.RealtimeConfiguration;
 import com.graphhopper.util.CmdArgs;
 import io.dropwizard.Configuration;
 import io.dropwizard.bundles.assets.AssetsBundleConfiguration;
@@ -26,8 +29,10 @@
 
 import javax.validation.Valid;
 import javax.validation.constraints.NotNull;
+import java.util.ArrayList;
+import java.util.List;
 
-public class GraphHopperServerConfiguration extends Configuration implements GraphHopperBundleConfiguration, AssetsBundleConfiguration {
+public class GraphHopperServerConfiguration extends Configuration implements GraphHopperBundleConfiguration, RealtimeBundleConfiguration, AssetsBundleConfiguration {
 
     @NotNull
     @JsonProperty
@@ -37,6 +42,9 @@
     @JsonProperty
     private final AssetsConfiguration assets = AssetsConfiguration.builder().build();
 
+    @JsonProperty
+    private final RealtimeConfiguration gtfsRealtime = new RealtimeConfiguration();
+
     public GraphHopperServerConfiguration() {
     }
 
@@ -49,4 +57,9 @@ public CmdArgs getGraphHopperConfiguration() {
     public AssetsConfiguration getAssetsConfiguration() {
         return assets;
     }
+
+    @Override
+    public RealtimeConfiguration gtfsrealtime() {
+        return gtfsRealtime;
+    }
 }
diff --git a/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java b/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java
index 8ce4b6e8c2..c2ec7c75f2 100644
--- a/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java
+++ b/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java
@@ -18,27 +18,47 @@
 
 package com.graphhopper.http.cli;
 
-import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.http.GraphHopperManaged;
 import com.graphhopper.http.GraphHopperServerConfiguration;
+import com.graphhopper.reader.gtfs.GraphHopperGtfs;
+import com.graphhopper.reader.gtfs.GtfsStorage;
+import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.storage.GHDirectory;
+import com.graphhopper.storage.GraphHopperStorage;
 import io.dropwizard.cli.ConfiguredCommand;
 import io.dropwizard.setup.Bootstrap;
 import net.sourceforge.argparse4j.inf.Namespace;
 
-public class ImportCommand extends ConfiguredCommand<GraphHopperServerConfiguration> {
+import java.util.Arrays;
+import java.util.Collections;
 
-    private final ObjectMapper objectMapper;
+public class ImportCommand extends ConfiguredCommand<GraphHopperServerConfiguration> {
 
-    public ImportCommand(ObjectMapper objectMapper) {
+    public ImportCommand() {
         super("import", "creates the graphhopper files used for later (faster) starts");
-        this.objectMapper = objectMapper;
     }
 
     @Override
-    protected void run(Bootstrap<GraphHopperServerConfiguration> bootstrap, Namespace namespace, GraphHopperServerConfiguration configuration) {
-        final GraphHopperManaged graphHopper = new GraphHopperManaged(configuration.getGraphHopperConfiguration(), objectMapper);
-        graphHopper.start();
-        graphHopper.stop();
+    protected void run(Bootstrap<GraphHopperServerConfiguration> bootstrap, Namespace namespace, GraphHopperServerConfiguration configuration) throws Exception {
+        if (configuration.getGraphHopperConfiguration().has("gtfs.file")) {
+            final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
+            final GHDirectory ghDirectory = GraphHopperGtfs.createGHDirectory(configuration.getGraphHopperConfiguration().get("graph.location", "target/tmp"));
+            final GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
+            final EncodingManager encodingManager = EncodingManager.create(Arrays.asList(ptFlagEncoder, new FootFlagEncoder(), new CarFlagEncoder()), 12);
+            final GraphHopperStorage graphHopperStorage = GraphHopperGtfs.createOrLoad(ghDirectory, encodingManager, ptFlagEncoder, gtfsStorage,
+                    configuration.getGraphHopperConfiguration().has("gtfs.file") ? Arrays.asList(configuration.getGraphHopperConfiguration().get("gtfs.file", "").split(",")) : Collections.emptyList(),
+                    configuration.getGraphHopperConfiguration().has("datareader.file") ? Arrays.asList(configuration.getGraphHopperConfiguration().get("datareader.file", "").split(",")) : Collections.emptyList());
+            graphHopperStorage.close();
+        } else {
+            final GraphHopperManaged graphHopper = new GraphHopperManaged(configuration.getGraphHopperConfiguration(), bootstrap.getObjectMapper());
+            graphHopper.start();
+            graphHopper.stop();
+        }
+
     }
 
 }
diff --git a/web/src/main/resources/assets/opensearch.xml b/web/src/main/resources/assets/opensearch.xml
index f306ef97c2..36c0b13811 100644
--- a/web/src/main/resources/assets/opensearch.xml
+++ b/web/src/main/resources/assets/opensearch.xml
@@ -6,7 +6,7 @@
     <Contact>info@graphhopper.com</Contact>    
     <Image height="16" width="16" type="image/x-icon">http://graphhopper.com/favicon.ico</Image>
     <Image height="16" width="16" type="image/x-icon">http://graphhopper.com/img/icon.png</Image>
-    <Url type="text/html" template="http://graphhopper.com/maps?q={searchTerms}"/>    
+    <Url type="text/html" template="https://graphhopper.com/maps/?point={searchTerms}"/>    
     <OutputEncoding>UTF-8</OutputEncoding>
     <InputEncoding>UTF-8</InputEncoding>
-</OpenSearchDescription>
\ No newline at end of file
+</OpenSearchDescription>
diff --git a/web/src/test/java/com/graphhopper/http/resources/GpxTravelTimeConsistencyTest.java b/web/src/test/java/com/graphhopper/http/resources/GpxTravelTimeConsistencyTest.java
new file mode 100644
index 0000000000..8a05ff25b3
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/resources/GpxTravelTimeConsistencyTest.java
@@ -0,0 +1,78 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http.resources;
+
+import com.graphhopper.GHRequest;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.PathWrapper;
+import com.graphhopper.reader.osm.GraphHopperOSM;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.util.gpx.GPXEntry;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.gpx.GpxFromInstructions;
+import com.graphhopper.util.shapes.GHPoint;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.io.File;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+public class GpxTravelTimeConsistencyTest {
+
+    public static final String DIR = "../core/files";
+    private static final String graphFileFoot = "target/gpxtraveltimeconsistency-it";
+    private static final String osmFile = DIR + "/monaco.osm.gz";
+    private static final String importVehicles = "foot";
+    private static GraphHopper hopper;
+
+    @BeforeClass
+    public static void beforeClass() {
+        Helper.removeDir(new File(graphFileFoot));
+        hopper = new GraphHopperOSM().
+                setOSMFile(osmFile).
+                setStoreOnFlush(true).
+                setCHEnabled(false).
+                setGraphHopperLocation(graphFileFoot).
+                setEncodingManager(EncodingManager.create(importVehicles)).
+                importOrLoad();
+    }
+
+    @Test
+    public void testGPXListTravelTimeConsistency() {
+        GHPoint routeStart = new GHPoint(43.727687, 7.418737);
+        GHPoint routeEnd = new GHPoint(43.74958, 7.436566);
+        GHRequest request = new GHRequest(routeStart, routeEnd);
+        request.setWeighting("fastest");
+        request.setVehicle("foot");
+        PathWrapper path = hopper.route(request).getBest();
+        List<GPXEntry> gpxList = GpxFromInstructions.createGPXList(path.getInstructions());
+        for(GPXEntry entry : gpxList) {
+            if (entry.getTime() != null ) {
+                GHRequest requestForWaypoint = new GHRequest(routeStart, entry.getPoint());
+                requestForWaypoint.setWeighting("fastest");
+                requestForWaypoint.setVehicle("foot");
+                PathWrapper partialPath = hopper.route(requestForWaypoint).getBest();
+                assertEquals("GPXListEntry timeStamp is expected to be the same as route duration.", partialPath.getTime(), entry.getTime().longValue());
+            }
+        }
+    }
+
+}
diff --git a/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java b/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
index 72e831b3cf..cd5ba49053 100644
--- a/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
+++ b/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
@@ -27,6 +27,7 @@
 import com.graphhopper.http.GraphHopperServerConfiguration;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.details.PathDetail;
 import com.graphhopper.util.exceptions.PointOutOfBoundsException;
 import com.graphhopper.util.shapes.GHPoint;
@@ -159,12 +160,12 @@ public void testGraphHopperWeb() throws Exception {
         assertTrue("distance wasn't correct:" + arsp.getDistance(), arsp.getDistance() > 20000);
         assertTrue("distance wasn't correct:" + arsp.getDistance(), arsp.getDistance() < 21000);
 
-        List<Map<String, Object>> instructions = arsp.getInstructions().createJson();
+        InstructionList instructions = arsp.getInstructions();
         assertEquals(26, instructions.size());
-        assertEquals("Continue onto la Callisa", instructions.get(0).get("text"));
-        assertEquals("At roundabout, take exit 2", instructions.get(4).get("text"));
-        assertEquals(true, instructions.get(4).get("exited"));
-        assertEquals(false, instructions.get(24).get("exited"));
+        assertEquals("Continue onto la Callisa", instructions.get(0).getTurnDescription(null));
+        assertEquals("At roundabout, take exit 2", instructions.get(4).getTurnDescription(null));
+        assertEquals(true, instructions.get(4).getExtraInfoJSON().get("exited"));
+        assertEquals(false, instructions.get(24).getExtraInfoJSON().get("exited"));
     }
 
     @Test
