diff --git a/.gitattributes b/.gitattributes
index ca8f2dfd33..9229c31f2c 100644
--- a/.gitattributes
+++ b/.gitattributes
@@ -3,6 +3,7 @@
 
 # Explicitly declare text files we want to always be normalized and converted 
 # to native line endings on checkout.
+*.sh text
 *.java text
 *.xml text
 *.js text
diff --git a/.gitignore b/.gitignore
index d5c6eb8b7a..83ce38371f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -26,4 +26,10 @@ core/docs/
 .*#
 cgiarprovider/
 /nbactions.xml
-tools/nb-configuration.xml
\ No newline at end of file
+tools/nb-configuration.xml
+android/build/
+android/app/build/
+android/.gradle
+.settings/
+.classpath
+.project
diff --git a/.travis.yml b/.travis.yml
index b1b8faf3f1..178e6f4a75 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -8,4 +8,7 @@ install: true
 script: ./core/files/travis-build.sh
 notifications:
   email:
-    - github@graphhopper.com
\ No newline at end of file
+    - github@graphhopper.com
+
+# enable container-based stack
+sudo: false
\ No newline at end of file
diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index 49cc8da521..0c1f909574 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -1,24 +1,34 @@
 [Members](https://github.com/graphhopper?tab=members) and [Contributors](https://github.com/graphhopper/graphhopper/contributors)
 
+ * AnahitaS, docs for Android, Android, Tomcat
+ * andreaswolf, flag encoder versioning and more
  * agouge, discussion and API refactoring
  * b3nn0, Android improvements
  * cgarreau, increase of routing success rate via subnetwork cleanup
  * daisy1754, fixed usage of graphhopper.sh script
  * dardin88, instructions improved
+ * dewos, web API bug fixes
+ * devemux86, improvements regarding Android and GPX
+ * dos65, bug fixes in routing algo
+ * drnextgis, ru translation and JS fixes
+ * duongnt, fixes in storage
  * lmar, improved instructions information
- * fredao, translations
+ * florent-morel, improvements regarding fords, #320
+ * fredao, translations 
+ * henningvs, doc improvements
+ * jansoe, one of the core developers
  * jansonhanson, general host config
  * JohannesPelzer, improved GPX information and various other things
- * karussell, lead developer
- * khuebner, pushes turn instructions forward 
+ * karussell, one of the core developers
+ * khuebner, pushed turn instructions forward
  * lmar, improved instructions
  * NopMap, massive improvements regarding OSM, parsing and encoding, route relations
  * ocampana, initial implementation for instructions
- * ratrun, route relations, GPX information and bike handling
- * rodneyodonnell, improved dead end removal
+ * ratrun, route relations, GPX information, bike handling etc
+ * rodneyodonnell, improved dead end removal and fords
  * rodo, more descriptions
 
 # Translations
 
 A lot people helped to create translations - thanks!
-See [this spreadsheet](https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0)
\ No newline at end of file
+See [this spreadsheet](https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0)
diff --git a/NOTICE.md b/NOTICE.md
index 2da14a4df8..85b2bf59be 100644
--- a/NOTICE.md
+++ b/NOTICE.md
@@ -1,6 +1,6 @@
 GraphHopper licensed under the Apache license, Version 2.0
 
-Copyright 2012-2013 Peter Karich
+Copyright 2012-2015 Peter Karich
 
 The core product includes the following software
  * slf4j.org - SLF4J distributed under the MIT license. 
@@ -10,6 +10,7 @@ The core product includes the following software
  * protobuf - New BSD license
  * OSM-binary - LGPL license
  * Osmosis - public domain, see osmosis-copying.txt under core/files
+ * XMLGraphics-Commons for CGIAR elevation files - (Apache License)
 
 tools
  * apache-compress
diff --git a/README.md b/README.md
index 0b78adb55e..726eaf0a82 100644
--- a/README.md
+++ b/README.md
@@ -3,27 +3,42 @@
 [![Build Status](https://secure.travis-ci.org/graphhopper/graphhopper.png?branch=master)](http://travis-ci.org/graphhopper/graphhopper)
 
 GraphHopper is a fast and memory efficient Java road routing engine released under Apache License 2.0.
-It is tuned towards road networks with OpenStreetMap data but can be useful for public transport problems as well.
+Per default it uses OpenStreetMap data but can import other data sources.
 
-Try it
+GraphHopper for the Web
 --------------
 
-See GraphHopper in action via [GraphHopper Maps](http://graphhopper.com/maps)!
+See GraphHopper in action on [GraphHopper Maps](https://graphhopper.com/maps)
 
+[![GraphHopper Maps](https://karussell.files.wordpress.com/2014/12/graphhopper-maps-0-4-preview.png)](https://graphhopper.com/maps)
 
-Get Started & Contribute
+GraphHopper Maps uses the [Directions API for Business](https://graphhopper.com/#directions-api), which provides 
+routing and matrix routing through GraphHopper and also a fast address search via [Photon](https://github.com/komoot/photon).
+Additionally the map tiles from various Providers are used and all is 
+available for free for a nice route planning experience!
+
+
+GraphHopper for Mobile
+---------------
+
+There are subprojects to make GraphHopper working offline
+on [Android](https://github.com/graphhopper/graphhopper/tree/master/android)
+and [iOS](http://github.com/graphhopper/graphhopper-ios)
+
+
+Get Started
 ---------------
 
-Read through our [docs](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md), 
-[how to contribute](https://github.com/graphhopper/graphhopper/blob/master/CONTRIBUTING.md) and 
+Read through our Documentation ([0.4](https://github.com/graphhopper/graphhopper/blob/0.4/docs/index.md), [unstable](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md)), 
 ask questions on [Stackoverflow](http://stackoverflow.com/questions/tagged/graphhopper)
-or sign up to the [mailing list](http://graphhopper.com/#developers).
+and sign up to the [mailing list](http://graphhopper.com/#developers).
 
-**Please only email me directly if you need consultancy** or can't explain your problem in the public.
 
-There are subprojects to make GraphHopper working on [Android](https://github.com/graphhopper/graphhopper/blob/master/docs/android/index.md), 
-[iOS](http://github.com/graphhopper/graphhopper-ios) or 
-as a [web application](https://github.com/graphhopper/graphhopper/tree/master/web).
+Contribute
+---------------
+
+Read through [how to contribute](https://github.com/graphhopper/graphhopper/blob/master/CONTRIBUTING.md)
+like finding and fixing bugs and improving our documentation or translations!
 
 
 Features
@@ -33,6 +48,6 @@ Features
  * Open Source
  * Memory efficient and fast
  * Highly customizable
- * Works on the desktop, as a web service and offline on Android
- * Well tested
- * [... more](http://graphhopper.com/#overview)
\ No newline at end of file
+ * Works on the desktop, as a web service and offline on Android or iOS
+ * Large test suite
+ * [... more](http://graphhopper.com/#overview)
diff --git a/android/.classpath b/android/.classpath
deleted file mode 100644
index 497def70c6..0000000000
--- a/android/.classpath
+++ /dev/null
@@ -1,14 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6">
-		<attributes>
-			<attribute name="maven.pomderived" value="true"/>
-		</attributes>
-	</classpathentry>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/android/.project b/android/.project
deleted file mode 100644
index 9f2869b63c..0000000000
--- a/android/.project
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>GraphHopper</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/android/.settings/org.eclipse.jdt.core.prefs b/android/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index b080d2ddc8..0000000000
--- a/android/.settings/org.eclipse.jdt.core.prefs
+++ /dev/null
@@ -1,4 +0,0 @@
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
-org.eclipse.jdt.core.compiler.compliance=1.6
-org.eclipse.jdt.core.compiler.source=1.6
diff --git a/android/README.md b/android/README.md
index b482c1b545..f896af0373 100644
--- a/android/README.md
+++ b/android/README.md
@@ -1,6 +1,6 @@
-This is a simple Eclipse project which uses graphhoppers routing and mapsforge to display the map.
-
-* Download the apk [here](http://graphhopper.com/#download)
-* More information about setup, maps creation etc is [in the wiki](https://github.com/graphhopper/graphhopper/wiki/Android)
+This maven module can be used for various IDEs like NetBeans or Eclipse to
+make GraphHopper offline routing working on Android. For offline
+maps the mapsforge project is used. For more information see the 
+[android docs](https://github.com/graphhopper/graphhopper/blob/master/docs/android/index.md).
 
 ![simple routing](http://karussell.files.wordpress.com/2012/09/graphhopper-android.png)
diff --git a/android/app/build.gradle b/android/app/build.gradle
new file mode 100644
index 0000000000..152d1dbb52
--- /dev/null
+++ b/android/app/build.gradle
@@ -0,0 +1,51 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 19
+    buildToolsVersion "21.1.2"
+
+    defaultConfig {
+        applicationId "com.graphhopper.android"
+        minSdkVersion 10
+        targetSdkVersion 22
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
+        }
+    }
+
+    lintOptions {
+        /* CGIARProvider refers to java.awt
+         * Helper7 refers to java.lang.management
+         * HeightTile refers to javax.imageio and java.awt
+         * OSMElement refers to javax.xml.stream
+         */
+        disable 'InvalidPackage'
+    }
+}
+
+/** only necessary if you need to use latest SNAPSHOT
+configurations.all {
+    // check for updates every build
+    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
+}
+ **/
+
+dependencies {
+    compile(group: 'com.graphhopper', name: 'graphhopper', version: '0.5-SNAPSHOT') {
+       exclude group: 'com.google.protobuf', module: 'protobuf-java'
+       exclude group: 'org.openstreetmap.osmosis', module: 'osmosis-osm-binary'
+       exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
+    }
+
+    compile group: 'org.mapsforge', name: 'mapsforge-core', version: '0.5.1'
+    compile group: 'org.mapsforge', name: 'mapsforge-map', version: '0.5.1'
+    compile group: 'org.mapsforge', name: 'mapsforge-map-android', version: '0.5.1'
+    compile group: 'org.mapsforge', name: 'mapsforge-map-reader', version: '0.5.1'
+
+    compile group: 'org.slf4j', name: 'slf4j-android', version: '1.7.12'
+    compile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.12'
+}
diff --git a/android/pom.xml b/android/app/pom.xml
similarity index 83%
rename from android/pom.xml
rename to android/app/pom.xml
index b257acaa32..c76f32f7cc 100644
--- a/android/pom.xml
+++ b/android/app/pom.xml
@@ -4,7 +4,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-android</artifactId>
-    <version>0.4-SNAPSHOT</version>
+    <version>0.5-SNAPSHOT</version>
     <name>GraphHopper Android</name>
     <packaging>apk</packaging>    
     <organization>
@@ -13,15 +13,13 @@
     </organization>
     
     <parent>
+        <relativePath>../..</relativePath>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.4-SNAPSHOT</version>
+        <version>0.5-SNAPSHOT</version>
     </parent>
     <properties>
-        <!--
-        <mapsforge.version>0.3-0.4.0-SNAPSHOT</mapsforge.version>
-        -->
-        <mapsforge.version>0.4.3</mapsforge.version>
+        <mapsforge.version>0.5.1</mapsforge.version>
         <!-- do not put the properties here as it differs from dev to dev <android.sdk.path>/home/peterk/Programme/android-sdk-linux_x86</android.sdk.path>
         instead use your IDE to set it up or specify android sdk via command line
         using -Dandroid.sdk.path=... or by setting environment variable ANDROID_HOME
@@ -35,12 +33,6 @@
             <version>${project.parent.version}</version>            
             <type>jar</type>
             <exclusions>
-                <!--
-                <exclusion>
-                    <groupId>org.slf4j</groupId>
-                    <artifactId>slf4j-api</artifactId>                    
-                </exclusion> 
-                -->
                 <exclusion>
                     <groupId>com.google.protobuf</groupId>
                     <artifactId>protobuf-java</artifactId>                    
@@ -84,13 +76,13 @@
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-android</artifactId>
-            <version>1.7.7</version>
+            <version>1.7.12</version>
         </dependency>
         
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-api</artifactId>
-            <version>1.7.7</version>
+            <version>1.7.12</version>
         </dependency>
 
         <!-- Make sure this is above (!) the android dependencies -->
@@ -112,39 +104,33 @@
     </dependencies>
 
     <build>
-        <!-- 
-        1. Use src/test/java for JUnit tests that don't call any Android APIs (directly or transitively)
-        2. Use src/main/java for JUnit tests that call Android APIs  
-        -->
-        <sourceDirectory>src</sourceDirectory>        
         <finalName>${project.artifactId}</finalName>        
-
+        
         <plugins>     
-            <!-- android (apache harmony) is nearly java but not really 1.6 -->
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.1</version>
                 <configuration>
                     <!-- <compilerArgument>-Xlint:unchecked</compilerArgument>
                     -->
-                    <source>1.5</source>
-                    <target>1.5</target>
+                    <source>1.7</source>
+                    <target>1.7</target>
                 </configuration>
             </plugin>       
             <plugin>
                 <!-- See http://code.google.com/p/maven-android-plugin/ -->
                 <groupId>com.jayway.maven.plugins.android.generation2</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.2</version>
+                <version>4.0.0-rc.2</version>
                 <extensions>true</extensions>
                 <configuration>
                     <sdk>
                         <!-- platform or api level (api level 8 = platform 2.2) -->                        
-                        <platform>10</platform>
+                        <platform>22</platform>
                     </sdk>
                     <deleteConflictingFiles>true</deleteConflictingFiles>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
+		    
                     <!--
                     bug in maven plugin I think
                     <extractDuplicates>true</extractDuplicates>
diff --git a/android/project.properties b/android/app/project.properties
similarity index 96%
rename from android/project.properties
rename to android/app/project.properties
index 4ab125693c..00cf62bacc 100644
--- a/android/project.properties
+++ b/android/app/project.properties
@@ -11,4 +11,4 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-19
+target=android-22
diff --git a/android/AndroidManifest.xml b/android/app/src/main/AndroidManifest.xml
similarity index 64%
rename from android/AndroidManifest.xml
rename to android/app/src/main/AndroidManifest.xml
index 4908215b43..aa1cea3964 100644
--- a/android/AndroidManifest.xml
+++ b/android/app/src/main/AndroidManifest.xml
@@ -1,29 +1,29 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.graphhopper.android"
-          android:versionCode="1"
-          android:versionName="0.1" >
+    package="com.graphhopper.android"
+    android:versionCode="1"
+    android:versionName="0.1" >
 
     <!-- mapsforge cache and saving maps -->
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
-    
+
     <!-- necessary to easily download maps via wifi -->
     <uses-permission android:name="android.permission.INTERNET" />
-    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />    
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
 
     <uses-sdk
-        android:minSdkVersion="8"
-        android:targetSdkVersion="19" />
+        android:minSdkVersion="10"
+        android:targetSdkVersion="22" />
 
     <application
-        android:allowBackup="true"
+        android:hardwareAccelerated="false"
+        android:allowBackup="true"        
         android:icon="@drawable/logo"
-        android:label="@string/app_name"        
+        android:label="@string/app_name"
         android:theme="@style/AppTheme" >
-        
         <activity
             android:name=".MainActivity"
-            android:label="@string/title_activity_main" 
-            android:screenOrientation="portrait">
+            android:label="@string/title_activity_main"
+            android:screenOrientation="portrait" >
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
 
diff --git a/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java b/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
new file mode 100644
index 0000000000..becd0e6280
--- /dev/null
+++ b/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
@@ -0,0 +1,67 @@
+package com.graphhopper.android;
+
+import com.graphhopper.util.Downloader;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.ProgressListener;
+import com.graphhopper.util.Unzipper;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+
+public class AndroidDownloader extends Downloader
+{
+    public AndroidDownloader()
+    {
+        super("GraphHopper Android");
+    }
+
+    @Override
+    public void downloadAndUnzip( String url, String toFolder, final ProgressListener progressListener ) throws IOException
+    {
+        HttpEntity entity = getEntity(url);
+        InputStream iStream = entity.getContent();
+        final long length = entity.getContentLength();
+
+        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener()
+        {
+            @Override
+            public void update( long sumBytes )
+            {
+                progressListener.update((int) (100 * sumBytes / length));
+            }
+        });
+    }
+
+    private HttpEntity getEntity( String url )
+    {
+        // there is something broken with HTTPS and Android HttpURLConnection
+        HttpClient httpclient = new DefaultHttpClient();
+        HttpGet httpget = new HttpGet(url);
+        try
+        {
+            HttpResponse response = httpclient.execute(httpget);
+            HttpEntity entity = response.getEntity();
+            if (entity == null)
+                throw new RuntimeException("no entity for URL " + url);
+
+            return entity;
+
+        } catch (Exception ex)
+        {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    @Override
+    public String downloadAsString( String url, boolean readErrorStreamNoException ) throws IOException
+    {
+        return Helper.isToString(getEntity(url).getContent());
+    }
+}
diff --git a/android/src/com/graphhopper/android/AndroidHelper.java b/android/app/src/main/java/com/graphhopper/android/AndroidHelper.java
similarity index 100%
rename from android/src/com/graphhopper/android/AndroidHelper.java
rename to android/app/src/main/java/com/graphhopper/android/AndroidHelper.java
diff --git a/android/src/com/graphhopper/android/GHAsyncTask.java b/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
similarity index 95%
rename from android/src/com/graphhopper/android/GHAsyncTask.java
rename to android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
index e1b0276a94..e60f0d4663 100644
--- a/android/src/com/graphhopper/android/GHAsyncTask.java
+++ b/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
@@ -20,9 +20,7 @@ protected C doInBackground( A... params )
         }
     }
 
-    ;
-
-	public boolean hasError()
+    public boolean hasError()
     {
         return error != null;
     }
diff --git a/android/src/com/graphhopper/android/MainActivity.java b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
similarity index 89%
rename from android/src/com/graphhopper/android/MainActivity.java
rename to android/app/src/main/java/com/graphhopper/android/MainActivity.java
index ea66e6fa82..b75c9b5e46 100644
--- a/android/src/com/graphhopper/android/MainActivity.java
+++ b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
@@ -21,6 +21,8 @@
 import org.mapsforge.map.layer.overlay.Marker;
 import org.mapsforge.map.layer.overlay.Polyline;
 import org.mapsforge.map.layer.renderer.TileRendererLayer;
+import org.mapsforge.map.reader.MapDataStore;
+import org.mapsforge.map.reader.MapFile;
 import org.mapsforge.map.rendertheme.InternalRenderTheme;
 
 import android.app.Activity;
@@ -50,8 +52,8 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
+import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.util.Constants;
-import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.ProgressListener;
@@ -70,11 +72,12 @@
     private volatile boolean prepareInProgress = false;
     private volatile boolean shortestPathRunning = false;
     private String currentArea = "berlin";
-    private String fileListURL = "https://graphhopper.com/public/maps/0.4/";
+    private String fileListURL = "https://graphhopper.com/public/maps/0.5/";
     private String prefixURL = fileListURL;
     private String downloadURL;
     private File mapsFolder;
     private TileCache tileCache;
+    private TileRendererLayer tileRendererLayer;
 
     protected boolean onMapTap( LatLong tapLatLong, Point layerXY, Point tapXY )
     {
@@ -175,6 +178,14 @@ protected void onDestroy()
         hopper = null;
         // necessary?
         System.gc();
+
+        // Cleanup Mapsforge
+        this.mapView.getLayerManager().getLayers().remove(this.tileRendererLayer);
+        this.tileRendererLayer.onDestroy();
+        this.tileCache.destroy();
+        this.mapView.getModel().mapViewPosition.destroy();
+        this.mapView.destroy();
+        AndroidGraphicFactory.clearResourceMemoryCache();
     }
 
     boolean isReady()
@@ -188,7 +199,7 @@ boolean isReady()
             logUser("Preparation still in progress");
             return false;
         }
-        log("Prepare finished but hopper not ready. This happens when there was an error while loading the files");
+        logUser("Prepare finished but hopper not ready. This happens when there was an error while loading the files");
         return false;
     }
 
@@ -238,8 +249,7 @@ private void chooseAreaFromRemote()
             protected List<String> saveDoInBackground( Void... params )
                     throws Exception
             {
-                String[] lines = new Downloader("GraphHopper Android").
-                        downloadAsString(fileListURL).split("\n");
+                String[] lines = new AndroidDownloader().downloadAsString(fileListURL, false).split("\n");
                 List<String> res = new ArrayList<String>();
                 for (String str : lines)
                 {
@@ -260,8 +270,13 @@ private void chooseAreaFromRemote()
             @Override
             protected void onPostExecute( List<String> nameList )
             {
-                if (hasError() || nameList.isEmpty())
+                if (nameList.isEmpty())
+                {
+                    logUser("No maps created for your version!? " + fileListURL);
+                    return;
+                } else if (hasError())
                 {
+                    getError().printStackTrace();
                     logUser("Are you connected to the internet? Problem while fetching remote area list: "
                             + getErrorMessage());
                     return;
@@ -272,10 +287,8 @@ protected void onPostExecute( List<String> nameList )
                     public void onSelect( String selectedArea, String selectedFile )
                     {
                         if (selectedFile == null
-                                || new File(mapsFolder, selectedArea + ".ghz")
-                                .exists()
-                                || new File(mapsFolder, selectedArea + "-gh")
-                                .exists())
+                                || new File(mapsFolder, selectedArea + ".ghz").exists()
+                                || new File(mapsFolder, selectedArea + "-gh").exists())
                         {
                             downloadURL = null;
                         } else
@@ -292,7 +305,7 @@ public void onSelect( String selectedArea, String selectedFile )
     }
 
     private void chooseArea( Button button, final Spinner spinner,
-            List<String> nameList, final MySpinnerListener mylistener )
+                             List<String> nameList, final MySpinnerListener mylistener )
     {
         final Map<String, String> nameToFullName = new TreeMap<String, String>();
         for (String fullName : nameList)
@@ -356,7 +369,7 @@ protected Object saveDoInBackground( Void... _ignore )
                 String localFolder = Helper.pruneFileEnd(AndroidHelper.getFileName(downloadURL));
                 localFolder = new File(mapsFolder, localFolder + "-gh").getAbsolutePath();
                 log("downloading & unzipping " + downloadURL + " to " + localFolder);
-                Downloader downloader = new Downloader("GraphHopper Android");
+                AndroidDownloader downloader = new AndroidDownloader();
                 downloader.setTimeout(30000);
                 downloader.downloadAndUnzip(downloadURL, localFolder,
                         new ProgressListener()
@@ -395,23 +408,22 @@ protected void onPostExecute( Object _ignore )
     void loadMap( File areaFolder )
     {
         logUser("loading map");
-        File mapFile = new File(areaFolder, currentArea + ".map");
+        MapDataStore mapDataStore = new MapFile(new File(areaFolder, currentArea + ".map"));
 
         mapView.getLayerManager().getLayers().clear();
 
-        TileRendererLayer tileRendererLayer = new TileRendererLayer(tileCache, mapView.getModel().mapViewPosition,
-                true, AndroidGraphicFactory.INSTANCE)
-                {
-                    @Override
-                    public boolean onLongPress( LatLong tapLatLong, Point layerXY, Point tapXY )
-                    {
-                        return onMapTap(tapLatLong, layerXY, tapXY);
-                    }
-                };
-        tileRendererLayer.setMapFile(mapFile);
+        tileRendererLayer = new TileRendererLayer(tileCache, mapDataStore,
+                mapView.getModel().mapViewPosition, false, true, AndroidGraphicFactory.INSTANCE)
+        {
+            @Override
+            public boolean onLongPress( LatLong tapLatLong, Point layerXY, Point tapXY )
+            {
+                return onMapTap(tapLatLong, layerXY, tapXY);
+            }
+        };
         tileRendererLayer.setTextScale(1.5f);
         tileRendererLayer.setXmlRenderTheme(InternalRenderTheme.OSMARENDER);
-        mapView.getModel().mapViewPosition.setMapPosition(new MapPosition(tileRendererLayer.getMapDatabase().getMapFileInfo().boundingBox.getCenterPoint(), (byte) 15));
+        mapView.getModel().mapViewPosition.setMapPosition(new MapPosition(mapDataStore.boundingBox().getCenterPoint(), (byte) 15));
         mapView.getLayerManager().getLayers().add(tileRendererLayer);
 
         setContentView(mapView);
@@ -459,9 +471,9 @@ private Polyline createPolyline( GHResponse response )
         paintStroke.setStyle(Style.STROKE);
         paintStroke.setColor(Color.argb(200, 0, 0xCC, 0x33));
         paintStroke.setDashPathEffect(new float[]
-        {
-            25, 15
-        });
+                {
+                        25, 15
+                });
         paintStroke.setStrokeWidth(8);
 
         // TODO: new mapsforge version wants an mapsforge-paint, not an android paint.
@@ -486,7 +498,7 @@ private Marker createMarker( LatLong p, int resource )
     }
 
     public void calcPath( final double fromLat, final double fromLon,
-            final double toLat, final double toLon )
+                          final double toLat, final double toLon )
     {
 
         log("calculating path ...");
@@ -498,7 +510,7 @@ protected GHResponse doInBackground( Void... v )
             {
                 StopWatch sw = new StopWatch().start();
                 GHRequest req = new GHRequest(fromLat, fromLon, toLat, toLon).
-                        setAlgorithm("dijkstrabi");
+                        setAlgorithm(AlgorithmOptions.DIJKSTRA_BI);
                 req.getHints().
                         put("instructions", "false");
                 GHResponse resp = hopper.route(req);
@@ -515,7 +527,7 @@ protected void onPostExecute( GHResponse resp )
                             / 1000f + ", nodes:" + resp.getPoints().getSize() + ", time:"
                             + time + " " + resp.getDebugInfo());
                     logUser("the route is " + (int) (resp.getDistance() / 100) / 10f
-                            + "km long, time:" + resp.getMillis() / 60000f + "min, debug:" + time);
+                            + "km long, time:" + resp.getTime() / 60000f + "min, debug:" + time);
 
                     mapView.getLayerManager().getLayers().add(createPolyline(resp));
                     //mapView.redraw();
@@ -540,8 +552,10 @@ private void log( String str, Throwable t )
 
     private void logUser( String str )
     {
+        log(str);
         Toast.makeText(this, str, Toast.LENGTH_LONG).show();
     }
+
     private static final int NEW_MENU_ID = Menu.FIRST + 1;
 
     @Override
diff --git a/android/res/drawable/flag_green.png b/android/app/src/main/res/drawable/flag_green.png
similarity index 100%
rename from android/res/drawable/flag_green.png
rename to android/app/src/main/res/drawable/flag_green.png
diff --git a/android/res/drawable/flag_red.png b/android/app/src/main/res/drawable/flag_red.png
similarity index 100%
rename from android/res/drawable/flag_red.png
rename to android/app/src/main/res/drawable/flag_red.png
diff --git a/android/res/drawable/logo.png b/android/app/src/main/res/drawable/logo.png
similarity index 100%
rename from android/res/drawable/logo.png
rename to android/app/src/main/res/drawable/logo.png
diff --git a/android/res/layout/main.xml b/android/app/src/main/res/layout/main.xml
similarity index 100%
rename from android/res/layout/main.xml
rename to android/app/src/main/res/layout/main.xml
diff --git a/android/res/values-large/dimens.xml b/android/app/src/main/res/values-large/dimens.xml
similarity index 100%
rename from android/res/values-large/dimens.xml
rename to android/app/src/main/res/values-large/dimens.xml
diff --git a/android/res/values/dimens.xml b/android/app/src/main/res/values/dimens.xml
similarity index 100%
rename from android/res/values/dimens.xml
rename to android/app/src/main/res/values/dimens.xml
diff --git a/android/res/values/strings.xml b/android/app/src/main/res/values/strings.xml
similarity index 100%
rename from android/res/values/strings.xml
rename to android/app/src/main/res/values/strings.xml
diff --git a/android/res/values/styles.xml b/android/app/src/main/res/values/styles.xml
similarity index 100%
rename from android/res/values/styles.xml
rename to android/app/src/main/res/values/styles.xml
diff --git a/android/build.gradle b/android/build.gradle
new file mode 100644
index 0000000000..fd24035602
--- /dev/null
+++ b/android/build.gradle
@@ -0,0 +1,19 @@
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+buildscript {
+    repositories {
+        mavenLocal()
+        mavenCentral()
+        /*jcenter()*/
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.0.0'
+    }
+}
+
+allprojects {
+    repositories {
+        mavenLocal()
+        mavenCentral()
+        /*jcenter()*/
+    }
+}
diff --git a/android/gradle/wrapper/gradle-wrapper.jar b/android/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..8c0fb64a86
Binary files /dev/null and b/android/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/android/gradle/wrapper/gradle-wrapper.properties b/android/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000000..0c71e760dc
--- /dev/null
+++ b/android/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Wed Apr 10 15:27:10 PDT 2013
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/android/gradlew b/android/gradlew
new file mode 100755
index 0000000000..91a7e269e1
--- /dev/null
+++ b/android/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/android/gradlew.bat b/android/gradlew.bat
new file mode 100644
index 0000000000..8a0b282aa6
--- /dev/null
+++ b/android/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/android/libs/mapsforge-core-0.4.3.jar b/android/libs/mapsforge-core-0.4.3.jar
deleted file mode 100644
index 82d62ee4f7..0000000000
Binary files a/android/libs/mapsforge-core-0.4.3.jar and /dev/null differ
diff --git a/android/libs/mapsforge-map-0.4.3.jar b/android/libs/mapsforge-map-0.4.3.jar
deleted file mode 100644
index eba6643ef4..0000000000
Binary files a/android/libs/mapsforge-map-0.4.3.jar and /dev/null differ
diff --git a/android/libs/mapsforge-map-android-0.4.3.jar b/android/libs/mapsforge-map-android-0.4.3.jar
deleted file mode 100644
index 0a6789d6c8..0000000000
Binary files a/android/libs/mapsforge-map-android-0.4.3.jar and /dev/null differ
diff --git a/android/libs/mapsforge-map-reader-0.4.3.jar b/android/libs/mapsforge-map-reader-0.4.3.jar
deleted file mode 100644
index 214bb5c8f3..0000000000
Binary files a/android/libs/mapsforge-map-reader-0.4.3.jar and /dev/null differ
diff --git a/android/libs/slf4j-android-1.6.1-RC1.jar b/android/libs/slf4j-android-1.6.1-RC1.jar
deleted file mode 100644
index 9bb01355a4..0000000000
Binary files a/android/libs/slf4j-android-1.6.1-RC1.jar and /dev/null differ
diff --git a/android/local.properties b/android/local.properties
new file mode 100644
index 0000000000..efc8662bc7
--- /dev/null
+++ b/android/local.properties
@@ -0,0 +1,7 @@
+## This file must *NOT* be checked into Version Control Systems,
+# as it contains information specific to your local configuration.
+#
+# Location of the SDK. This is only used by Gradle.
+#
+#Mon Jan 19 09:31:41 CET 2015
+sdk.dir=/home/peterk/Programme/adt-bundle-linux-x86/sdk
diff --git a/android/proguard-project.txt b/android/proguard-project.txt
deleted file mode 100644
index f2fe1559a2..0000000000
--- a/android/proguard-project.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-# To enable ProGuard in your project, edit project.properties
-# to define the proguard.config property as described in that file.
-#
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in ${sdk.dir}/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the ProGuard
-# include property in project.properties.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/android/scripts/googlecode_upload.py b/android/scripts/googlecode_upload.py
deleted file mode 100644
index 16912361ee..0000000000
--- a/android/scripts/googlecode_upload.py
+++ /dev/null
@@ -1,256 +0,0 @@
-#!/usr/bin/env python
-#
-# Copyright 2006, 2007 Google Inc. All Rights Reserved.
-# Author: danderson@google.com (David Anderson)
-#
-# Script for uploading files to a Google Code project.
-#
-# This is intended to be both a useful script for people who want to
-# streamline project uploads and a reference implementation for
-# uploading files to Google Code projects.
-#
-# To upload a file to Google Code, you need to provide a path to the
-# file on your local machine, a small summary of what the file is, a
-# project name, and a valid account that is a member or owner of that
-# project.  You can optionally provide a list of labels that apply to
-# the file.  The file will be uploaded under the same name that it has
-# in your local filesystem (that is, the "basename" or last path
-# component).  Run the script with '--help' to get the exact syntax
-# and available options.
-#
-# Note that the upload script requests that you enter your
-# googlecode.com password.  This is NOT your Gmail account password!
-# This is the password you use on googlecode.com for committing to
-# Subversion and uploading files.  You can find your password by going
-# to http://code.google.com/hosting/settings when logged in with your
-# Gmail account. If you have already committed to your project's
-# Subversion repository, the script will automatically retrieve your
-# credentials from there (unless disabled, see the output of '--help'
-# for details).
-#
-# If you are looking at this script as a reference for implementing
-# your own Google Code file uploader, then you should take a look at
-# the upload() function, which is the meat of the uploader.  You
-# basically need to build a multipart/form-data POST request with the
-# right fields and send it to https://PROJECT.googlecode.com/files .
-# Authenticate the request using HTTP Basic authentication, as is
-# shown below.
-#
-# Licensed under the terms of the Apache Software License 2.0:
-#  http://www.apache.org/licenses/LICENSE-2.0
-#
-# Questions, comments, feature requests and patches are most welcome.
-# Please direct all of these to the Google Code users group:
-#  http://groups.google.com/group/google-code-hosting
-
-"""Google Code file uploader script.
-"""
-
-__author__ = 'danderson@google.com (David Anderson)'
-
-import httplib
-import os.path
-import optparse
-import getpass
-import base64
-import sys
-
-
-def upload(file, project_name, user_name, password, summary, labels=None):
-  """Upload a file to a Google Code project's file server.
-
-  Args:
-    file: The local path to the file.
-    project_name: The name of your project on Google Code.
-    user_name: Your Google account name.
-    password: The googlecode.com password for your account.
-              Note that this is NOT your global Google Account password!
-    summary: A small description for the file.
-    labels: an optional list of label strings with which to tag the file.
-
-  Returns: a tuple:
-    http_status: 201 if the upload succeeded, something else if an
-                 error occured.
-    http_reason: The human-readable string associated with http_status
-    file_url: If the upload succeeded, the URL of the file on Google
-              Code, None otherwise.
-  """
-  # The login is the user part of user@gmail.com. If the login provided
-  # is in the full user@domain form, strip it down.
-  if user_name.endswith('@gmail.com'):
-    user_name = user_name[:user_name.index('@gmail.com')]
-
-  form_fields = [('summary', summary)]
-  if labels is not None:
-    form_fields.extend([('label', l.strip()) for l in labels])
-
-  content_type, body = encode_upload_request(form_fields, file)
-
-  upload_host = '%s.googlecode.com' % project_name
-  upload_uri = '/files'
-  auth_token = base64.b64encode('%s:%s'% (user_name, password))
-  headers = {
-    'Authorization': 'Basic %s' % auth_token,
-    'User-Agent': 'Googlecode.com uploader v0.9.4',
-    'Content-Type': content_type,
-    }
-
-  server = httplib.HTTPSConnection(upload_host)
-  server.request('POST', upload_uri, body, headers)
-  resp = server.getresponse()
-  server.close()
-
-  if resp.status == 201:
-    location = resp.getheader('Location', None)
-  else:
-    location = None
-  return resp.status, resp.reason, location
-
-
-def encode_upload_request(fields, file_path):
-  """Encode the given fields and file into a multipart form body.
-
-  fields is a sequence of (name, value) pairs. file is the path of
-  the file to upload. The file will be uploaded to Google Code with
-  the same file name.
-
-  Returns: (content_type, body) ready for httplib.HTTP instance
-  """
-  BOUNDARY = '----------Googlecode_boundary_reindeer_flotilla'
-  CRLF = '\r\n'
-
-  body = []
-
-  # Add the metadata about the upload first
-  for key, value in fields:
-    body.extend(
-      ['--' + BOUNDARY,
-       'Content-Disposition: form-data; name="%s"' % key,
-       '',
-       value,
-       ])
-
-  # Now add the file itself
-  file_name = os.path.basename(file_path)
-  f = open(file_path, 'rb')
-  file_content = f.read()
-  f.close()
-
-  body.extend(
-    ['--' + BOUNDARY,
-     'Content-Disposition: form-data; name="filename"; filename="%s"'
-     % file_name,
-     # The upload server determines the mime-type, no need to set it.
-     'Content-Type: application/octet-stream',
-     '',
-     file_content,
-     ])
-
-  # Finalize the form body
-  body.extend(['--' + BOUNDARY + '--', ''])
-
-  return 'multipart/form-data; boundary=%s' % BOUNDARY, CRLF.join(body)
-
-
-def upload_find_auth(file_path, project_name, summary, labels=None,
-                     user_name=None, password=None, tries=3):
-  """Find credentials and upload a file to a Google Code project's file server.
-
-  file_path, project_name, summary, and labels are passed as-is to upload.
-
-  Args:
-    file_path: The local path to the file.
-    project_name: The name of your project on Google Code.
-    summary: A small description for the file.
-    labels: an optional list of label strings with which to tag the file.
-    config_dir: Path to Subversion configuration directory, 'none', or None.
-    user_name: Your Google account name.
-    tries: How many attempts to make.
-  """
-  if user_name is None or password is None:
-    from netrc import netrc
-    authenticators = netrc().authenticators("code.google.com")
-    if authenticators:
-      if user_name is None:
-        user_name = authenticators[0]
-      if password is None:
-        password = authenticators[2]
-
-  while tries > 0:
-    if user_name is None:
-      # Read username if not specified or loaded from svn config, or on
-      # subsequent tries.
-      sys.stdout.write('Please enter your googlecode.com username: ')
-      sys.stdout.flush()
-      user_name = sys.stdin.readline().rstrip()
-    if password is None:
-      # Read password if not loaded from svn config, or on subsequent tries.
-      print 'Please enter your googlecode.com password.'
-      print '** Note that this is NOT your Gmail account password! **'
-      print 'It is the password you use to access Subversion repositories,'
-      print 'and can be found here: http://code.google.com/hosting/settings'
-      password = getpass.getpass()
-
-    status, reason, url = upload(file_path, project_name, user_name, password,
-                                 summary, labels)
-    # Returns 403 Forbidden instead of 401 Unauthorized for bad
-    # credentials as of 2007-07-17.
-    if status in [httplib.FORBIDDEN, httplib.UNAUTHORIZED]:
-      # Rest for another try.
-      user_name = password = None
-      tries = tries - 1
-    else:
-      # We're done.
-      break
-
-  return status, reason, url
-
-
-def main():
-  parser = optparse.OptionParser(usage='googlecode-upload.py -s SUMMARY '
-                                 '-p PROJECT [options] FILE')
-  parser.add_option('-s', '--summary', dest='summary',
-                    help='Short description of the file')
-  parser.add_option('-p', '--project', dest='project',
-                    help='Google Code project name')
-  parser.add_option('-u', '--user', dest='user',
-                    help='Your Google Code username')
-  parser.add_option('-w', '--password', dest='password',
-                    help='Your Google Code password')
-  parser.add_option('-l', '--labels', dest='labels',
-                    help='An optional list of comma-separated labels to attach '
-                    'to the file')
-
-  options, args = parser.parse_args()
-
-  if not options.summary:
-    parser.error('File summary is missing.')
-  elif not options.project:
-    parser.error('Project name is missing.')
-  elif len(args) < 1:
-    parser.error('File to upload not provided.')
-  elif len(args) > 1:
-    parser.error('Only one file may be specified.')
-
-  file_path = args[0]
-
-  if options.labels:
-    labels = options.labels.split(',')
-  else:
-    labels = None
-
-  status, reason, url = upload_find_auth(file_path, options.project,
-                                         options.summary, labels,
-                                         options.user, options.password)
-  if url:
-    print 'The file was uploaded successfully.'
-    print 'URL: %s' % url
-    return 0
-  else:
-    print 'An error occurred. Your file was not uploaded.'
-    print 'Google Code upload server said: %s (%s)' % (reason, status)
-    return 1
-
-
-if __name__ == '__main__':
-  sys.exit(main())
diff --git a/android/scripts/maven-install-mapsforge.sh b/android/scripts/maven-install-mapsforge.sh
deleted file mode 100755
index f1fac1393c..0000000000
--- a/android/scripts/maven-install-mapsforge.sh
+++ /dev/null
@@ -1,20 +0,0 @@
-# do the following
-# git clone https://code.google.com/p/mapsforge/
-# cd mapsforge; and fix http://code.google.com/p/mapsforge/issues/detail?id=461
-# mvn clean install
-# cp mapsforge-map/target/mapsforge-map-0.3.1-SNAPSHOT-jar-with-dependencies.jar graphhopper/android/libs/mapsforge-0.3.1-SNAPSHOT.jar
-
-# if we would do it via normal maven dependency management we run into strange things which I was not able to fix
-# http://stackoverflow.com/a/8315600/194609
-
-# MAVEN_HOME/bin/mvn
-MVN=mvn
-VERSION=0.4.0
-libs="map map-android map-reader core"
-
-for lib in $libs; do
-  FILE=$(ls ./libs/mapsforge-$lib-$VERSION.jar)
-  echo "installing file: $FILE"
-  ARGS="-DgroupId=com.graphhopper -DartifactId=mapsforge-$lib -Dversion=$VERSION -Dpackaging=jar -Dfile=$FILE"
-  $MVN install:install-file $ARGS
-done
diff --git a/android/settings.gradle b/android/settings.gradle
new file mode 100644
index 0000000000..e7b4def49c
--- /dev/null
+++ b/android/settings.gradle
@@ -0,0 +1 @@
+include ':app'
diff --git a/config-example.properties b/config-example.properties
index 026338ae2c..29f56a2fcb 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -1,40 +1,49 @@
-#################
-### OSMReader ###
-
-graph.dataaccess=RAM_STORE
-# graph.dataaccess=MMAP_STORE_SYNC
-
-# Default: use contraction hierarchies to speed things up. requires more RAM/disc space for holding the graph
-# Use chWeighting=no to disable it (more flexibility while querying) 
-# Java API usage is: GraphHopper.setCHWeighting("fastest")
-prepare.chWeighting=fastest
-
-# increase from 1 to 5, to reduce way geometry e.g. for android
-osmreader.wayPointMaxDistance=1
-
+##### Vehicles #####
+#
 # Possible options: car,foot,bike,bike2,mtb,racingbike,motorcycle (comma separated)
-# When using two or three option together remeber to set "prepare.chWeighting=no" above.
 # bike2 takes elevation data into account (like up-hill is slower than down-hill)
-# and requires enabling graph.elevation.provider below, e.g. see #169
+# and requires enabling graph.elevation.provider below
 graph.flagEncoders=car
 
-# to enable turn restrictions for car do
+# Enable turn restrictions for car or motorcycle. 
+# Currently you need to additionally set prepare.chWeighting=no before using this (see below and #270)
 # graph.flagEncoders=car|turnCosts=true
 
-# if you want to reduce storage size and you don't need instructions for a path uncomment this
-# osmreader.instructions=false
 
+##### Elevation #####
+#
 # To populate your graph with elevation data use SRTM, default is noop
 # graph.elevation.provider=srtm
-# default location for cache is used /tmp/srtm
+#
+# default location for cache is /tmp/srtm
 # graph.elevation.cachedir=./srtmprovider/
-# If you have a slow disk or plenty of RAM change the default MMAP to
+#
+# If you have a slow disk or plenty of RAM change the default MMAP to:
 # graph.elevation.dataaccess=RAM_STORE
 
-# Location index lookup. Advanced customization. Resolution is in meter, the search specifies the 'radius' in number of tiles.
-# E.g. decrease resolution for a faster lookup and increase region search for a more dynamic search and less 'location not found' results
-# index.highResolution=300
-# index.maxRegionSearch=4
 
-# if you want to support jsonp response type you need to add it explicitely here:
-#web.jsonpAllowed=true
+
+##### Storage #####
+#
+# configure the memory access, use RAM_STORE for well equipped servers, 
+# MMAP_STORE_SYNC could be used otherwise but will be a lot slower
+graph.dataaccess=RAM_STORE
+
+# if you want to reduce storage size and you don't need instructions for the resulting path use:
+# osmreader.instructions=false
+
+#### Speed-up Mode vs. Flexibility Mode ####
+#
+# By default the speed-up mode with the 'fastest' weighting is used. Internally a graph preparation via
+# contraction hierarchies is done to speed routing up. This requires more RAM/disc space for holding the
+# graph but less for every request. Also only the first vehicle of the flagEncoders list will be prepared.
+# prepare.chWeighting=fastest
+#
+# Disable the speed-up mode (contraction hierarchies, CH) via enabling the flexibility mode:
+# prepare.chWeighting=no
+
+
+##### Web #####
+# if you want to support jsonp response type you need to add it explicitely here. By default it is disabled for 
+# stronger security.
+# web.jsonpAllowed=true
diff --git a/core/files/N43E007hgt.zip b/core/files/N43E007.hgt.zip
similarity index 100%
rename from core/files/N43E007hgt.zip
rename to core/files/N43E007.hgt.zip
diff --git a/core/files/N49E011hgt.zip b/core/files/N49E011.hgt.zip
similarity index 100%
rename from core/files/N49E011hgt.zip
rename to core/files/N49E011.hgt.zip
diff --git a/core/files/N50E011hgt.zip b/core/files/N50E011.hgt.zip
similarity index 100%
rename from core/files/N50E011hgt.zip
rename to core/files/N50E011.hgt.zip
diff --git a/core/files/N52E008.hgt.zip b/core/files/N52E008.hgt.zip
new file mode 100644
index 0000000000..bbc3b2e502
Binary files /dev/null and b/core/files/N52E008.hgt.zip differ
diff --git a/core/files/N55W003hgt.zip b/core/files/N55W003.hgt.zip
similarity index 100%
rename from core/files/N55W003hgt.zip
rename to core/files/N55W003.hgt.zip
diff --git a/core/files/N55W004hgt.zip b/core/files/N55W004hgt.zip
deleted file mode 100644
index 3073befc2f..0000000000
Binary files a/core/files/N55W004hgt.zip and /dev/null differ
diff --git a/core/files/S29W072hgt.zip b/core/files/S29W072.hgt.zip
similarity index 100%
rename from core/files/S29W072hgt.zip
rename to core/files/S29W072.hgt.zip
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index cea8a4eb06..6200e2965e 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,12 +1,36 @@
-0.4.0
+0.5
+    removed visitedNodes method in GraphHopper replaced with per response information: response.getHints().getLong("visited_nodes.sum", 0)
+    added ability to store hints in GHResponse which will be forwarded to the json too
+    breaking change in HTTP API: error JSON format changed to be message:"" instead of within info.errors, see updated api documentation
+    made GHResponse.getMillis, Path.getMillis, GPXEntry.getMillis deprecated, use getTime instead
+    in AbstractFlagEncoder, parse*() and getStr() are now deprecated, use properties.get* instead
+
+0.4
+    translation key turn changed and merged with left etc into turn_left, turn_right etc
+    create location index before preparation in the GraphHopper class
+    encodingManager.getSingle() is removed and flagEncoder list is no longer sorted, the first vehicle is used for CH preparation    
+    removed LocationIndexTreeSC, use new LocationIndexTree(levelGraph.getBaseGraph(), directory) instead
+    getLevel and setLevel do no longer automatically increase node count, use getNodeAccess.ensureNode for that
+    normal algorithms are now possible on prepared graph use getBaseGraph, see #116
+    GHResponse no longer has isFound method, use !hasErrors instead
+    merged unused Edge class into EdgeEntry
+    astar and astarbi are now both none-heuristic and take parameters for beeline approximation: astar.approximation=BeelineSimplification|BeelineAccurate or astarbi.approximation=...
+    making GPX export according to the schema to support import from various tools like basecamp
+    refactoring: AllEdgesIterator.getMaxId is now named getCount
+    major change of internal API: moved method "Path RoutingAlgorithm.calcPath(QueryResult,QueryResult)" to a helper method QueryGraph.lookup, call queryResult.getClosestNode for the calcPath(nodeFrom,nodeTo) method
+    no cachedWays and cachedPoints in Path anymore
+    Path.findInstruction was moved to InstructionList.find
+    if start and end point are identical an algorithm will find the path consisting only of one node, one point and one instruction (finish instruction), but without edges
+    astarbi has new default values for approximation (false) and approximation_factor (1.2) in RoutingAlgorithmFactorySimple
+    instead of strings use the variables in AlgorithmOptions to specify an algorithm
+    use RoutingAlgorithmFactorySimple instead of RoutingAlgorithmFactory, also more constistent algorithm preparation handling due to new AlgorithmOptions, therefor removed NoOpAlgorithmPreparation
+    GHResponse.getXX methods now fail fast (throw an exception) if an error while route calculation occured. See #287
     renamed less often used URL parameter 'min_path_precision' to way_point_max_distance which makes it identical to the setWayPointMaxDistance method used for simplification at OSMImport
     removed douglas.minprecision from Java API ghRequest.hints => use wayPointMaxDistance instead
     encoder.supportTurnCost is replaced by encoder.supports(TurnWeighting.class)
-    CmdArgs is now a Map<String, String> instead Map<String, Object>. The value will be parsed up on every getXY call
+    CmdArgs is now a Map<String, String> instead Map<String, Object>. The value will be parsed up on every getXY call, makes storing string vs. object less error-prone
     removed GHRequest.getHint, instead use the provided methods in GHRequest.getHints().getXY and GHRequest.getHints().put
-    graph incompatibility as properties cannot be loaded => version increase necessary
-        renamed osmreader.bytesForFlags to graph.bytesForFlags
-        renamed config property osmreader.acceptWay to graph.flagEncoders
+    important graph incompatibility as properties cannot be loaded. renamed osmreader.bytesForFlags to graph.bytesForFlags, renamed config property osmreader.acceptWay to graph.flagEncoders
     default weighting is now fastest, fixing #261
     moved method GraphHopper.main into tools module and class com.graphhopper.tools.Import, see #250
     refactored GraphHopper.createWeighting to accept more than one configuration option, see #237
@@ -14,13 +38,12 @@
     moving the boolean parameter of GraphHopper.setInMemory into a separate method setStoreOnFlush
     renaming of GraphHopper.setCHShortcuts to setCHWeighting, as well as the property prepare.chShortcuts to prepare.chWeighting
     jsonp is disabled by default. You need to enable it in the config.properties, see the config-example.properties
-    EncodingManager cannot be null in GraphHopperStorage since 0.4. If you need to parse EncodingManager configuration from existing graph use EncodingManager.create
+    EncodingManager cannot be null in GraphHopperStorage. If you need to parse EncodingManager configuration from existing graph use EncodingManager.create
     no reflection done in EncodingManager which improves portability and makes configuration of encoders possible before adding to manager
     removed dijkstraNativebi as no performance advantage but maintenance disadvantage and similar to oneToManyDijkstra
     to provide context for turn costs we needed to add prevEdgeId into Weighting.calcWeight, see new documentation
     with the introduction of lock protection mechanism (see #112) GraphHopper needs always write access, see also #217
-    new GraphHopper.clean method to remove the graph directory via Java API
-    FlagEncoder: replaced isFoward and isBackward with more generic isBool(flags, FlagEncoder.FORWARD|BACKWARD)
+    new GraphHopper.clean method to remove the graph directory via Java API    
 
 0.3.0
     introduced prefer bits, now bike uses more bits and 3 bike encoder do not fit into 32 bit anymore, will be fixed later
diff --git a/core/files/intellij-settings.jar b/core/files/intellij-settings.jar
new file mode 100644
index 0000000000..a7553f8d0e
Binary files /dev/null and b/core/files/intellij-settings.jar differ
diff --git a/core/files/live_measurement.sh b/core/files/live_measurement.sh
deleted file mode 100755
index 1fbafd5ae6..0000000000
--- a/core/files/live_measurement.sh
+++ /dev/null
@@ -1,59 +0,0 @@
-#!/bin/bash
-
-# before execution do
-# 1. cp files/measurement.sh files/live_measurement.sh
-#    to ensure that you have your customized measurement.sh file available and git has no problems to switch versions
-# 2. adapt memory usage in JAVA_OPTS
-# 3. adapt the OSM location GH_MAIN
-# 4. adapt last_commits
-
-GH_HOME=$(dirname $0)/..
-cd $GH_HOME
-
-JAVA=$JAVA_HOME/bin/java
-if [ "x$JAVA_HOME" = "x" ]; then
- JAVA=java
-fi
-
-VERSION=`grep  "<name>" -A 1 pom.xml | grep version | cut -d'>' -f2 | cut -d'<' -f1`
-JAR=target/graphhopper-$VERSION-jar-with-dependencies.jar
-
-# make sure this stays the same for all measurements
-JAVA_OPTS="-Xmx1000m -Xms1000m" 
-
-GH_MAIN=/media/SAMSUNG/maps/unterfranken
-
-# should we call?
-# mvn clean install assembly:single
-
-# import graph
-OSM_XML=$GH_MAIN.osm
-GL=$GH_MAIN-gh
-ARGS="osmreader.graph-location=$GL osmreader.osm=$OSM_XML osmreader.chWeighting=fastest osmreader.type=CAR"
-echo -e "\ncreate graph via $ARGS, $JAR"
-$JAVA $JAVA_OPTS -cp $JAR com.graphhopper.reader.OSMReader $ARGS osmreader.doPrepare=false
-
-function startMeasurement {
-  COUNT=5000
-  ARGS="$ARGS osmreader.doPrepare=true measurement.count=$COUNT measurement.location=$M_FILE_NAME"
-  echo -e "\nperform measurement via $ARGS, $JAR"
-  $JAVA $JAVA_OPTS -cp $JAR com.graphhopper.util.Measurement $ARGS
-}
-
-# use current version
-mvn -DskipTests clean install assembly:single  
-startMeasurement
-exit
-
-# use git
-last_commits=1
-commits=$(git rev-list HEAD -n $last_commits)
-for commit in $commits; do
-  git checkout $commit -q
-  M_FILE_NAME=`git log -n 1 --pretty=oneline | grep -o "\ .*" |  tr " ,;" "_"`
-  M_FILE_NAME="measurement$M_FILE_NAME.properties"
-  echo -e "\nusing commit $commit and $M_FILE_NAME"
-  
-  mvn -DskipTests clean install assembly:single
-  startMeasurement
-done
diff --git a/core/files/map-bug432.osm.gz b/core/files/map-bug432.osm.gz
new file mode 100644
index 0000000000..e12a1de28d
Binary files /dev/null and b/core/files/map-bug432.osm.gz differ
diff --git a/core/files/postgis/gh_from_a_to_b_local.sql b/core/files/postgis/gh_from_a_to_b_local.sql
new file mode 100644
index 0000000000..380ae87141
--- /dev/null
+++ b/core/files/postgis/gh_from_a_to_b_local.sql
@@ -0,0 +1,62 @@
+
+CREATE OR REPLACE FUNCTION gh_from_a_to_b_local(lata double precision, lona double precision, latb double precision, lonb double precision, vehicle varchar)
+  RETURNS text[] AS
+$BODY$
+import requests, json,os
+def ms_to_hms(milliseconds):
+    hours, milliseconds = divmod(milliseconds, 3600000)
+    minutes, milliseconds = divmod(milliseconds, 60000)
+    seconds = float(milliseconds) / 1000
+    s = "%i:%02i" % (hours, minutes)
+    return s
+def ghroutetime(p1,p2,v):
+    gcurl="http://localhost:8989/route?"
+    params=[]
+    result={}
+    #result=''
+    for x in range(6):
+        params.append([])
+    params[0].append('point')
+    params[0].append(p1)
+    params[1].append('point')
+    params[1].append(p2)
+    params[2].append('instructions')
+    params[2].append('false')
+    params[3].append('calc_points')
+    params[3].append('true')
+    params[4].append('vehicle')
+    params[4].append(v)
+    params[5].append('points_encoded')
+    params[5].append('false')
+    data = requests.get(url=gcurl, params=params)
+    binary = data.content
+    result=json.loads(binary)
+    result['paths'][0]['time']=ms_to_hms(result['paths'][0]['time'])
+    distance=(result['paths'][0]['distance'])
+    time=result['paths'][0]['time']
+    geom=json.dumps(result['paths'][0]['points'])
+    return distance,time,geom
+def format_point(lat, lon):
+	p=str(lat)+', '+str(lon)
+	return p
+try:
+	dist,time,geom=ghroutetime(format_point(lata,lona),format_point(latb,lonb),vehicle)
+except:
+	dist,time,geom=0,0,''
+return dist,time,geom	
+$BODY$
+  LANGUAGE plpythonu VOLATILE
+  COST 100;
+  
+comment on function gh_from_a_to_b_local(lata double precision, lona double precision, latb double precision, lonb double precision, vehicle varchar) is 
+'
+pl/python function to enable graphhopper routing from postgis.
+Make sure to have created the extension plpythonu beforehand.
+
+Result is a text array with 
+
+Distance[m] 
+drivetime[hh:mm] 
+Geometry as GeoJSON in CRS 4326 (WGS84)
+To transform the GeoJSON geometry to wkb, use the postgis function "st_geomfromgeojson(geojson)"
+';
diff --git a/core/files/release.sh b/core/files/release.sh
deleted file mode 100755
index 4ecc63bdd1..0000000000
--- a/core/files/release.sh
+++ /dev/null
@@ -1,79 +0,0 @@
-#!/bin/bash
-
-# assumptions:
-# 1. you have run unit and integration tests successfully
-# 2. no changes on master
-
-# TODO when we understand the commands we can use the release plugin
-# mvn release:clean 
-# # Prepare: build, test, release version update, commit, tag, next snapshot version update, commit
-# mvn release:prepare -DgenerateBackupPoms=false
-# # Perform: export a release from SCM, run the deploy goal
-# mvn release:perform
-# https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide
-
-GH_CORE_HOME=$(dirname $0)/..
-cd $GH_CORE_HOME
-VERSION=0.1
-NEW_VERSION=0.2-SNAPSHOT
-TARGET=./target
-GIT_E=true
-
-mvn versions:set -DnewVersion=$VERSION -DgenerateBackupPoms=false
-# as android is not referenced in parent we need to do it manually
-cd android
-mvn versions:set -DnewVersion=$VERSION -DgenerateBackupPoms=false
-cd ..
-
-if [ "x$GIT_E" = "xtrue" ]; then
-  git checkout -b $VERSION
-  git add .
-  git commit -m "releasing $VERSION"
-fi
-
-
-##############################
-# create jar and android files
-mvn -DskipTests=true clean install assembly:single
-
-if [ $? -ne 0 ]; then
-  echo "cannot install jars?"
-  exit
-fi  
-
-# now create binary distribution where no maven is necessary to run import
-cp ../graphhopper.sh $TARGET/graphhopper.sh
-JAR=`cd $TARGET && ls -1 *-with-dependencies.jar`
-# use @ instead of the common / to avoid problems with paths in $JAR
-sed -i "s@JAR=.*@JAR=$JAR@g" $TARGET/graphhopper.sh
-# if you use -x option use backslash avoids shell substitution e.g. -x \*~
-zip -j $TARGET/graphhopper-$VERSION-bin.zip $TARGET/graphhopper.sh $TARGET/$JAR ../config-example.properties ../*.txt ../*.md
-
-
-########################
-# deployment to sonatype
-$MVN install deploy
-
-if [ $? -ne 0 ]; then
-  echo "cannot deploy to sonatype?"
-  exit
-fi    
-
-cd android
-export ANDROID_HOME=/install/android/sdk
-$MVN clean install deploy
-cd ..
-
-
-##########################
-# deployment to our server
-
-# TODO
-
-mvn versions:set -DnewVersion=$NEW_VERSION -DgenerateBackupPoms=false
-
-if [ "x$GIT_E" = "xtrue" ]; then
-  git checkout master
-  git add .
-  git commit -m "new development version $NEW_VERSION"
-fi
diff --git a/core/files/travis-build.sh b/core/files/travis-build.sh
index fd46e3dd5a..5f7138d9b3 100755
--- a/core/files/travis-build.sh
+++ b/core/files/travis-build.sh
@@ -1,20 +1,22 @@
 HOME=$(dirname $0)
 cd $HOME/../..
 
-modules="core web tools"
-for module in $modules; do
-  echo "====== INSTALL $module ====="
-  mvn -pl $module clean install -DskipTests=true
-  EXIT_VAL="$?"    
-  if [[ "x$EXIT_VAL" != "x0" ]]; then
-    exit $EXIT_VAL
-  fi 
-  
-  echo "====== TEST $module ====="
-  # verify necessary for failsafe, otherwise it won't fail the build!?
-  mvn -pl $module test failsafe:integration-test verify  
-  EXIT_VAL="$?"
-  if [[ "x$EXIT_VAL" != "x0" ]]; then
-    exit $EXIT_VAL
-  fi
-done
+mvn clean test verify
+
+#modules="core web tools"
+#for module in $modules; do
+#  echo "====== INSTALL $module ====="
+#  mvn -pl $module clean install -DskipTests=true
+#  EXIT_VAL="$?"    
+#  if [[ "x$EXIT_VAL" != "x0" ]]; then
+#    exit $EXIT_VAL
+#  fi 
+#  
+#  echo "====== TEST $module ====="
+#  # verify necessary for failsafe, otherwise it won't fail the build!?
+#  mvn -pl $module test failsafe:integration-test verify  
+#  EXIT_VAL="$?"
+#  if [[ "x$EXIT_VAL" != "x0" ]]; then
+#    exit $EXIT_VAL
+#  fi
+#done
diff --git a/core/files/update-translations.sh b/core/files/update-translations.sh
index da0517fa84..253bd32cb4 100755
--- a/core/files/update-translations.sh
+++ b/core/files/update-translations.sh
@@ -3,11 +3,11 @@ cd $HOME/..
 
 destination=src/main/resources/com/graphhopper/util/
 
-translations="en_US SKIP bg ca de_DE el es fil fr gl he it ja nl pt_PT pt_BR ro ru sk si sv_SE tr uk"
+translations="en_US SKIP ar bg ca cz de_DE el es fa fil fi fr gl he hsb hu_HU it ja lt_LT ne nl pl_PL pt_BR pt_PT ro ru si sk sv_SE tr uk vi_VI zh_CN"
 file=$1
 
 # You can execute the following
-# curl "https://docs.google.com/spreadsheet/pub?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc&single=true&gid=0&output=txt" > tmp.tsv
+# curl 'https://docs.google.com/spreadsheets/d/10HKSFmxGVEIO92loVQetVmjXT0qpf3EA2jxuQSSYTdU/export?format=tsv&id=10HKSFmxGVEIO92loVQetVmjXT0qpf3EA2jxuQSSYTdU&gid=0' > tmp.tsv
 # ./files/update-translations.sh tmp.tsv && rm tmp.tsv
 
 INDEX=1
diff --git a/core/pom.xml b/core/pom.xml
index 574cd0d1cd..451f8706ad 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -6,7 +6,7 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper</artifactId>
     <name>GraphHopper</name>
-    <version>0.4-SNAPSHOT</version>
+    <version>0.5-SNAPSHOT</version>
     <packaging>jar</packaging> 
     <description>
         GraphHopper is a fast and memory efficient Java road routing engine 
@@ -15,7 +15,7 @@
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.4-SNAPSHOT</version>
+        <version>0.5-SNAPSHOT</version>
     </parent>
         
     <properties>  
@@ -76,13 +76,22 @@
         <dependency>
             <groupId>com.google.protobuf</groupId>
             <artifactId>protobuf-java</artifactId>
-            <version>2.6.0</version>
+            <version>2.6.1</version>
         </dependency>        
         <dependency>
             <groupId>org.openstreetmap.osmosis</groupId>
             <artifactId>osmosis-osm-binary</artifactId>
             <version>0.43.1</version>
         </dependency>
+
+        <dependency>
+            <groupId>org.json</groupId>
+            <artifactId>json</artifactId>
+            <!-- keep oldish version as we want to support 1.5 for a while -->
+            <version>20140107</version>
+            <scope>test</scope>
+        </dependency>
+        
     </dependencies>
         
     <build>
@@ -91,46 +100,18 @@
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-assembly-plugin</artifactId>
-                    <version>2.4.1</version>
                     <configuration>                     
                         <!-- for usage on android -->
                         <descriptors>
                             <descriptor>src/main/assembly/android.xml</descriptor>
                         </descriptors>
                     </configuration>
-                </plugin>
-                <plugin>
-                    <groupId>org.apache.maven.plugins</groupId>
-                    <artifactId>maven-site-plugin</artifactId>
-                    <version>3.4</version>
-                    <configuration>
-                        <reportPlugins>
-                            <plugin>
-                                <!-- either call mvn compile site or mvn findbugs:gui -->
-                                <groupId>org.codehaus.mojo</groupId>
-                                <artifactId>findbugs-maven-plugin</artifactId>
-                                <version>2.5.2</version>
-                                <configuration>
-                                    <!-- <xmlOutput>true</xmlOutput> -->
-                                    <!-- Optional directory to put FindBugs xdoc xml report -->
-                                    <xmlOutputDirectory>target/site</xmlOutputDirectory>
-                                    <threshold>Normal</threshold>
-                                    <effort>Default</effort>
-                                    <!--
-                                    <threshold>High|Normal|Low|Exp|Ignore</threshold>
-                                    <effort>Min|Default|Max</effort>
-                                    -->
-                                </configuration>
-                            </plugin>
-                        </reportPlugins>
-                    </configuration>
-                </plugin>
+                </plugin>                
                 
                 <!-- create jar with test classes to be reused in other projects -->                
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-jar-plugin</artifactId>
-                    <version>2.4</version>
                     <executions>
                         <execution>
                             <goals>
diff --git a/core/src/main/java/com/graphhopper/GHRequest.java b/core/src/main/java/com/graphhopper/GHRequest.java
index 7c0441b375..4337f00b3d 100644
--- a/core/src/main/java/com/graphhopper/GHRequest.java
+++ b/core/src/main/java/com/graphhopper/GHRequest.java
@@ -19,27 +19,33 @@
 
 import com.graphhopper.routing.util.WeightingMap;
 import com.graphhopper.util.Helper;
-import com.graphhopper.util.PMap;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 
 /**
  * GraphHopper request wrapper to simplify requesting GraphHopper.
  * <p/>
+ *
  * @author Peter Karich
  * @author ratrun
  */
 public class GHRequest
 {
     private String algo = "";
-    private List<GHPoint> points;
+    private final List<GHPoint> points;
     private final WeightingMap hints = new WeightingMap();
     private String vehicle = "";
     private boolean possibleToAdd = false;
     private Locale locale = Locale.US;
 
+    // List of favored start (1st element) and arrival heading (all other).
+    // Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference
+    private final List<Double> favoredHeadings;
+
     public GHRequest()
     {
         this(5);
@@ -48,57 +54,159 @@ public GHRequest()
     public GHRequest( int size )
     {
         points = new ArrayList<GHPoint>(size);
+        favoredHeadings = new ArrayList<Double>(size);
         possibleToAdd = true;
     }
 
     /**
-     * Calculate the path from specified startPlace (fromLat, fromLon) to endPlace (toLat, toLon).
+     * Set routing request from specified startPlace (fromLat, fromLon) to endPlace (toLat, toLon)
+     * with a preferred start and end heading.
+     * Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference.
+     */
+    public GHRequest( double fromLat, double fromLon, double toLat, double toLon,
+                      double startHeading, double endHeading )
+    {
+        this(new GHPoint(fromLat, fromLon), new GHPoint(toLat, toLon), startHeading, endHeading);
+    }
+
+    /**
+     * Set routing request from specified startPlace (fromLat, fromLon) to endPlace (toLat, toLon)
      */
     public GHRequest( double fromLat, double fromLon, double toLat, double toLon )
     {
         this(new GHPoint(fromLat, fromLon), new GHPoint(toLat, toLon));
     }
 
+
     /**
-     * Calculate the path from specified startPlace to endPlace.
+     * Set routing request from specified startPlace to endPlace with a preferred start and end heading.
+     * Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference
      */
-    public GHRequest( GHPoint startPlace, GHPoint endPlace )
+    public GHRequest( GHPoint startPlace, GHPoint endPlace, double startHeading, double endHeading )
     {
         if (startPlace == null)
             throw new IllegalStateException("'from' cannot be null");
 
         if (endPlace == null)
             throw new IllegalStateException("'to' cannot be null");
+
         points = new ArrayList<GHPoint>(2);
         points.add(startPlace);
         points.add(endPlace);
+
+        favoredHeadings = new ArrayList<Double>(2);
+        validateAzimuthValue(startHeading);
+        favoredHeadings.add(startHeading);
+        validateAzimuthValue(endHeading);
+        favoredHeadings.add(endHeading);
     }
 
-    public GHRequest( List<GHPoint> points )
+    public GHRequest( GHPoint startPlace, GHPoint endPlace )
+    {
+        this(startPlace, endPlace, Double.NaN, Double.NaN);
+    }
+
+
+    /**
+     * Set routing request
+     *
+     * @param points          List of stopover points in order: start, 1st stop, 2nd stop, ..., end
+     * @param favoredHeadings List of favored headings for starting (start point) and arrival (via and end points)
+     *                        Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference
+     */
+    public GHRequest( List<GHPoint> points, List<Double> favoredHeadings )
     {
+        if (points.size() != favoredHeadings.size())
+            throw new IllegalArgumentException("Size of headings (" + favoredHeadings.size() +
+                    ") must match size of points (" + points.size() + ")");
+
+        for (Double heading : favoredHeadings)
+        {
+            validateAzimuthValue(heading);
+        }
         this.points = points;
+        this.favoredHeadings = favoredHeadings;
     }
 
-    public GHRequest addPoint( GHPoint point )
+    /**
+     * Set routing request
+     *
+     * @param points List of stopover points in order: start, 1st stop, 2nd stop, ..., end
+     */
+    public GHRequest( List<GHPoint> points )
+    {
+        this(points, Collections.nCopies(points.size(), Double.NaN));
+    }
+
+    /**
+     * Add stopover point to routing request.
+     *
+     * @param point          geographical position (see GHPoint)
+     * @param favoredHeading north based azimuth (clockwise) in (0, 360) or NaN for equal preference
+     */
+    public GHRequest addPoint( GHPoint point, Double favoredHeading )
     {
         if (point == null)
             throw new IllegalArgumentException("point cannot be null");
+
+
         if (!possibleToAdd)
             throw new IllegalStateException("Please call empty constructor if you intent to use "
                     + "more than two places via addPlace method.");
 
         points.add(point);
+        validateAzimuthValue(favoredHeading);
+        favoredHeadings.add(favoredHeading);
+        return this;
+    }
+
+    /**
+     * Add stopover point to routing request.
+     *
+     * @param point geographical position (see GHPoint)
+     */
+    public GHRequest addPoint( GHPoint point )
+    {
+        addPoint(point, Double.NaN);
         return this;
     }
 
+    /**
+     * @return north based azimuth (clockwise) in (0, 360) or NaN for equal preference
+     */
+    public double getFavoredHeading( int i )
+    {
+        return favoredHeadings.get(i);
+    }
+
+    /**
+     * @return if there exist a preferred heading for start/via/end point i
+     */
+    public boolean hasFavoredHeading( int i )
+    {
+        if (i >= favoredHeadings.size())
+            throw new IndexOutOfBoundsException("Index: " + i + " too large for list of size " + favoredHeadings.size());
+
+        return !Double.isNaN(favoredHeadings.get(i));
+    }
+
+    // validate Azimuth entry
+    private void validateAzimuthValue( Double heading )
+    {
+        // heading must be in (0, 360) oder Nan
+        if (!Double.isNaN(heading) && ((Double.compare(heading, 360) > 0) || (Double.compare(heading, 0) < 0)))
+        {
+            throw new IllegalArgumentException("Heading " + heading + " must be in range (0,360) or NaN");
+        }
+    }
+
     public List<GHPoint> getPoints()
     {
         return points;
     }
 
     /**
-     * Possible values: astar (A* algorithm, default), astarbi (bidirectional A*), dijkstra
-     * (Dijkstra) or dijkstrabi. Or specify empty to use default.
+     * For possible values see AlgorithmOptions.*
      */
     public GHRequest setAlgorithm( String algo )
     {
@@ -165,9 +273,12 @@ public String toString()
         for (GHPoint point : points)
         {
             if (res.isEmpty())
+            {
                 res = point.toString();
-            else
+            } else
+            {
                 res += "; " + point.toString();
+            }
         }
         return res + "(" + algo + ")";
     }
diff --git a/core/src/main/java/com/graphhopper/GHResponse.java b/core/src/main/java/com/graphhopper/GHResponse.java
index c0086f42da..d5fae8c28b 100644
--- a/core/src/main/java/com/graphhopper/GHResponse.java
+++ b/core/src/main/java/com/graphhopper/GHResponse.java
@@ -18,8 +18,10 @@
 package com.graphhopper;
 
 import com.graphhopper.util.InstructionList;
+import com.graphhopper.util.PMap;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -34,10 +36,10 @@
     private final List<Throwable> errors = new ArrayList<Throwable>(4);
     private PointList list = PointList.EMPTY;
     private double distance;
-    private double weight;
+    private double routeWeight;
     private long time;
-    private InstructionList instructions = InstructionList.EMPTY;
-    private boolean found;
+    private InstructionList instructions;
+    private final PMap hintsMap = new PMap();
 
     public GHResponse()
     {
@@ -45,6 +47,7 @@ public GHResponse()
 
     public String getDebugInfo()
     {
+        check("getDebugInfo");
         return debugInfo;
     }
 
@@ -55,6 +58,15 @@ public GHResponse setDebugInfo( String debugInfo )
         return this;
     }
 
+    private void check( String method )
+    {
+        if (hasErrors())
+        {
+            throw new RuntimeException("You cannot call " + method + " if response contains errors. Check this with ghResponse.hasErrors(). "
+                    + "Errors are: " + getErrors());
+        }
+    }
+
     /**
      * @return true if one or more error found
      */
@@ -88,6 +100,7 @@ public GHResponse setPoints( PointList points )
      */
     public PointList getPoints()
     {
+        check("getPoints");
         return list;
     }
 
@@ -100,15 +113,16 @@ public GHResponse setDistance( double distance )
     /**
      * This method returns the distance of the path. Always prefer this method over
      * getPoints().calcDistance
-     * <p>
+     * <p/>
      * @return distance in meter
      */
     public double getDistance()
     {
+        check("getDistance");
         return distance;
     }
 
-    public GHResponse setMillis( long timeInMillis )
+    public GHResponse setTime( long timeInMillis )
     {
         this.time = timeInMillis;
         return this;
@@ -116,15 +130,26 @@ public GHResponse setMillis( long timeInMillis )
 
     /**
      * @return time in millis
+     * @deprecated use getTime instead
      */
     public long getMillis()
     {
+        check("getMillis");
+        return time;
+    }
+
+    /**
+     * @return time in millis
+     */
+    public long getTime()
+    {
+        check("getTimes");
         return time;
     }
 
     public GHResponse setRouteWeight( double weight )
     {
-        this.weight = weight;
+        this.routeWeight = weight;
         return this;
     }
 
@@ -135,18 +160,8 @@ public GHResponse setRouteWeight( double weight )
      */
     public double getRouteWeight()
     {
-        return weight;
-    }
-
-    public GHResponse setFound( boolean found )
-    {
-        this.found = found;
-        return this;
-    }
-
-    public boolean isFound()
-    {
-        return found;
+        check("getRouteWeight");
+        return routeWeight;
     }
 
     /**
@@ -154,7 +169,8 @@ public boolean isFound()
      */
     public BBox calcRouteBBox( BBox _fallback )
     {
-        BBox bounds = BBox.INVERSE.clone();
+        check("calcRouteBBox");
+        BBox bounds = BBox.createInverse(_fallback.hasElevation());
         int len = list.getSize();
         if (len == 0)
             return _fallback;
@@ -163,17 +179,14 @@ public BBox calcRouteBBox( BBox _fallback )
         {
             double lat = list.getLatitude(i);
             double lon = list.getLongitude(i);
-            if (lat > bounds.maxLat)
-                bounds.maxLat = lat;
-
-            if (lat < bounds.minLat)
-                bounds.minLat = lat;
-
-            if (lon > bounds.maxLon)
-                bounds.maxLon = lon;
-
-            if (lon < bounds.minLon)
-                bounds.minLon = lon;
+            if (bounds.hasElevation())
+            {
+                double ele = list.getEle(i);
+                bounds.update(lat, lon, ele);
+            } else
+            {
+                bounds.update(lat, lon);
+            }
         }
         return bounds;
     }
@@ -181,8 +194,8 @@ public BBox calcRouteBBox( BBox _fallback )
     @Override
     public String toString()
     {
-        String str = "found:" + isFound() + ", nodes:" + list.getSize() + ": " + list.toString();
-        if (!instructions.isEmpty())
+        String str = "nodes:" + list.getSize() + "; " + list.toString();
+        if (instructions != null && !instructions.isEmpty())
             str += ", " + instructions.toString();
 
         if (hasErrors())
@@ -198,6 +211,15 @@ public void setInstructions( InstructionList instructions )
 
     public InstructionList getInstructions()
     {
+        check("getInstructions");
+        if (instructions == null)
+            throw new IllegalArgumentException("To access instructions you need to enable creation before routing");
+
         return instructions;
     }
+
+    public PMap getHints()
+    {
+        return hintsMap;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index f52f83bf88..5ec873dce5 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -22,14 +22,17 @@
 import com.graphhopper.reader.dem.CGIARProvider;
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.dem.SRTMProvider;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.RoutingAlgorithm;
+import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
-import com.graphhopper.storage.index.*;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.io.File;
 import java.io.IOException;
@@ -37,14 +40,12 @@
 import java.util.*;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 /**
  * Easy to use access point to configure import and (offline) routing.
  * <p/>
- * @see GraphHopperAPI
+ *
  * @author Peter Karich
+ * @see GraphHopperAPI
  */
 public class GraphHopper implements GraphHopperAPI
 {
@@ -61,23 +62,24 @@
     private LockFactory lockFactory = new NativeFSLockFactory();
     private final String fileLockName = "gh.lock";
     private boolean allowWrites = true;
-    private boolean enableInstructions = true;
+    boolean enableInstructions = true;
     private boolean fullyLoaded = false;
     // for routing
+    private double defaultWeightLimit = Double.MAX_VALUE;
     private boolean simplifyResponse = true;
     private TraversalMode traversalMode = TraversalMode.NODE_BASED;
+    private RoutingAlgorithmFactory algoFactory;
     // for index
     private LocationIndex locationIndex;
     private int preciseIndexResolution = 300;
     private int maxRegionSearch = 4;
     // for prepare
     private int minNetworkSize = 200;
-    private int minOnewayNetworkSize = 0;
-    // for CH prepare
-    private AlgorithmPreparation prepare;
+    private int minOneWayNetworkSize = 0;
+    // for CH prepare    
     private boolean doPrepare = true;
     private boolean chEnabled = true;
-    private String chWeighting = "fastest";
+    private String chWeightingStr = "fastest";
     private int periodicUpdates = -1;
     private int lazyUpdates = -1;
     private int neighborUpdates = -1;
@@ -87,10 +89,9 @@
     private double osmReaderWayPointMaxDistance = 1;
     private int workerThreads = -1;
     private boolean calcPoints = true;
-    // utils    
+    // utils
     private final TranslationMap trMap = new TranslationMap().doImport();
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
-    private final AtomicLong visitedSum = new AtomicLong(0);
 
     public GraphHopper()
     {
@@ -115,9 +116,20 @@ public GraphHopper setEncodingManager( EncodingManager em )
     {
         ensureNotLoaded();
         this.encodingManager = em;
+        if (em.needsTurnCostsSupport())
+            traversalMode = TraversalMode.EDGE_BASED_2DIR;
+
         return this;
     }
 
+    FlagEncoder getDefaultVehicle()
+    {
+        if (encodingManager == null)
+            throw new IllegalStateException("No encoding manager specified or loaded");
+
+        return encodingManager.fetchEdgeEncoders().get(0);
+    }
+
     public EncodingManager getEncodingManager()
     {
         return encodingManager;
@@ -174,18 +186,18 @@ public TraversalMode getTraversalMode()
     }
 
     /**
-     * Configures the underlying storage to be used on a well equipped server.
+     * Configures the underlying storage and response to be used on a well equipped server. Result
+     * also optimized for usage in the web module i.e. try reduce network IO.
      */
     public GraphHopper forServer()
     {
-        // simplify to reduce network IO
         setSimplifyResponse(true);
         return setInMemory();
     }
 
     /**
-     * Configures the underlying storage to be used on a Desktop computer with enough RAM but no
-     * network latency.
+     * Configures the underlying storage to be used on a Desktop computer or within another Java
+     * application with enough RAM but no network latency.
      */
     public GraphHopper forDesktop()
     {
@@ -194,8 +206,8 @@ public GraphHopper forDesktop()
     }
 
     /**
-     * Configures the underlying storage to be used on a less powerful machine like Android and
-     * Raspberry Pi with only few RAM.
+     * Configures the underlying storage to be used on a less powerful machine like Android or
+     * Raspberry Pi with only few MB of RAM.
      */
     public GraphHopper forMobile()
     {
@@ -215,6 +227,12 @@ public GraphHopper setPreciseIndexResolution( int precision )
         return this;
     }
 
+    public void setMinNetworkSize( int minNetworkSize, int minOneWayNetworkSize )
+    {
+        this.minNetworkSize = minNetworkSize;
+        this.minOneWayNetworkSize = minOneWayNetworkSize;
+    }
+
     /**
      * This method call results in an in-memory graph.
      */
@@ -229,7 +247,8 @@ public GraphHopper setInMemory()
      * Only valid option for in-memory graph and if you e.g. want to disable store on flush for unit
      * tests. Specify storeOnFlush to true if you want that existing data will be loaded FROM disc
      * and all in-memory data will be flushed TO disc after flush is called e.g. while OSM import.
-     * <p>
+     * <p/>
+     *
      * @param storeOnFlush true by default
      */
     public GraphHopper setStoreOnFlush( boolean storeOnFlush )
@@ -262,43 +281,62 @@ private GraphHopper setUnsafeMemory()
         return this;
     }
 
-    /**
-     * Disables "CH-preparation". Use only if you know what you do.
-     */
-    public GraphHopper setDoPrepare( boolean doPrepare )
-    {
-        this.doPrepare = doPrepare;
-        return this;
-    }
-
     /**
      * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
      * <p/>
+     *
      * @param weighting can be "fastest", "shortest" or your own weight-calculation type.
      * @see #setCHEnable(boolean)
      */
     public GraphHopper setCHWeighting( String weighting )
     {
         ensureNotLoaded();
-        chWeighting = weighting;
+        chWeightingStr = weighting;
         return this;
     }
 
     public String getCHWeighting()
     {
-        return chWeighting;
+        return chWeightingStr;
+    }
+
+    /**
+     * Disables the "CH-preparation" preparation only. Use only if you know what you do. To disable
+     * the full usage of CH use setCHEnable(false) instead.
+     */
+    public GraphHopper setDoPrepare( boolean doPrepare )
+    {
+        this.doPrepare = doPrepare;
+        return this;
     }
 
     /**
-     * Enables or disables contraction hierarchies. Enabled by default.
+     * Enables or disables contraction hierarchies (CH). This speed-up mode is enabled by default.
+     * Disabling CH is only recommended for short routes or in combination with
+     * setDefaultWeightLimit and called flexibility mode
+     * <p/>
+     *
+     * @see #setDefaultWeightLimit(double)
      */
     public GraphHopper setCHEnable( boolean enable )
     {
         ensureNotLoaded();
+        algoFactory = null;
         chEnabled = enable;
         return this;
     }
 
+    /**
+     * This methods stops the algorithm from searching further if the resulting path would go over
+     * specified weight, important if CH is disabled. The unit is defined by the used weighting
+     * created from createWeighting, e.g. distance for shortest or seconds for the standard
+     * FastestWeighting implementation.
+     */
+    public void setDefaultWeightLimit( double defaultWeightLimit )
+    {
+        this.defaultWeightLimit = defaultWeightLimit;
+    }
+
     public boolean isCHEnabled()
     {
         return chEnabled;
@@ -390,7 +428,8 @@ public String getOSMFile()
 
     /**
      * The underlying graph used in algorithms.
-     * <p>
+     * <p/>
+     *
      * @throws IllegalStateException if graph is not instantiated.
      */
     public GraphStorage getGraph()
@@ -404,6 +443,7 @@ public GraphStorage getGraph()
     public void setGraph( GraphStorage graph )
     {
         this.graph = graph;
+        fullyLoaded = true;
     }
 
     protected void setLocationIndex( LocationIndex locationIndex )
@@ -413,7 +453,8 @@ protected void setLocationIndex( LocationIndex locationIndex )
 
     /**
      * The location index created from the graph.
-     * <p>
+     * <p/>
+     *
      * @throws IllegalStateException if index is not initialized
      */
     public LocationIndex getLocationIndex()
@@ -424,11 +465,6 @@ public LocationIndex getLocationIndex()
         return locationIndex;
     }
 
-    public AlgorithmPreparation getPreparation()
-    {
-        return prepare;
-    }
-
     /**
      * Sorts the graph which requires more RAM while import. See #12
      */
@@ -521,7 +557,7 @@ public GraphHopper init( CmdArgs args )
 
         // optimizable prepare
         minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
-        minOnewayNetworkSize = args.getInt("prepare.minOnewayNetworkSize", minOnewayNetworkSize);
+        minOneWayNetworkSize = args.getInt("prepare.minOneWayNetworkSize", minOneWayNetworkSize);
 
         // prepare CH
         doPrepare = args.getBool("prepare.doPrepare", doPrepare);
@@ -537,16 +573,19 @@ public GraphHopper init( CmdArgs args )
 
         // osm import
         osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
-        String flagEncoders = args.get("graph.flagEncoders", "CAR");
-        if (flagEncoders.toLowerCase().contains("turncosts=true"))
-            traversalMode = TraversalMode.EDGE_BASED_2DIR;
-        encodingManager = new EncodingManager(flagEncoders, bytesForFlags);
+        String flagEncoders = args.get("graph.flagEncoders", "");
+        if (!flagEncoders.isEmpty())
+            setEncodingManager(new EncodingManager(flagEncoders, bytesForFlags));
+
         workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
         enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
 
         // index
         preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
         maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
+
+        // routing
+        defaultWeightLimit = args.getDouble("routing.defaultWeightLimit", defaultWeightLimit);
         return this;
     }
 
@@ -651,6 +690,7 @@ protected OSMReader initOSMReader( OSMReader reader )
     /**
      * Opens existing graph.
      * <p/>
+     *
      * @param graphHopperFolder is the folder containing graphhopper files (which can be compressed
      * too)
      */
@@ -692,7 +732,7 @@ public boolean load( String graphHopperFolder )
         setGraphHopperLocation(graphHopperFolder);
 
         if (encodingManager == null)
-            encodingManager = EncodingManager.create(ghLocation);
+            setEncodingManager(EncodingManager.create(ghLocation));
 
         if (!allowWrites && dataAccessType.isMMap())
             dataAccessType = DAType.MMAP_RO;
@@ -701,7 +741,7 @@ public boolean load( String graphHopperFolder )
         if (chEnabled)
             graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
         else if (encodingManager.needsTurnCostsSupport())
-            graph = new GraphHopperStorage(dir, encodingManager, hasElevation(), new TurnCostStorage());
+            graph = new GraphHopperStorage(dir, encodingManager, hasElevation(), new TurnCostExtension());
         else
             graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
 
@@ -733,18 +773,35 @@ else if (encodingManager.needsTurnCostsSupport())
         }
     }
 
+    public RoutingAlgorithmFactory getAlgorithmFactory()
+    {
+        if (algoFactory == null)
+            this.algoFactory = new RoutingAlgorithmFactorySimple();
+
+        return algoFactory;
+    }
+
+    public void setAlgorithmFactory( RoutingAlgorithmFactory algoFactory )
+    {
+        this.algoFactory = algoFactory;
+    }
+
     /**
      * Sets EncodingManager, does the preparation and creates the locationIndex
      */
     protected void postProcessing()
     {
-        encodingManager = graph.getEncodingManager();
+        initLocationIndex();
         if (chEnabled)
-            initCHPrepare();
+        {
+            if (algoFactory != null)
+                throw new IllegalStateException("Customizing of the routing algorithm factory is currently not supported");
+
+            algoFactory = createPrepare();
+        }
 
         if (!isPrepared())
             prepare();
-        initLocationIndex();
     }
 
     private boolean isPrepared()
@@ -752,34 +809,35 @@ private boolean isPrepared()
         return "true".equals(graph.getProperties().get("prepare.done"));
     }
 
-    protected void initCHPrepare()
+    protected RoutingAlgorithmFactory createPrepare()
     {
-        FlagEncoder encoder = encodingManager.getSingle();
-        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(encoder,
-                createWeighting(new WeightingMap(chWeighting), encoder), traversalMode);
+        FlagEncoder defaultVehicle = getDefaultVehicle();
+        Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), defaultVehicle);
+        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
+                (LevelGraph) graph, defaultVehicle, weighting, traversalMode);
         tmpPrepareCH.setPeriodicUpdates(periodicUpdates).
                 setLazyUpdates(lazyUpdates).
                 setNeighborUpdates(neighborUpdates).
                 setLogMessages(logMessages);
 
-        prepare = tmpPrepareCH;
-        prepare.setGraph(graph);
+        return tmpPrepareCH;
     }
 
     /**
      * Based on the weightingParameters and the specified vehicle a Weighting instance can be
      * created. Note that all URL parameters are available in the weightingParameters as String if
      * you use the GraphHopper Web module.
-     * <p>
-     * @see Weighting.Params.create
-     * @param wMap all parameters influencing the weighting. E.g. URL parameters coming via
-     * GHRequest
+     * <p/>
+     *
+     * @param weightingMap all parameters influencing the weighting. E.g. parameters coming via
+     * GHRequest.getHints or directly via "&api.xy=" from the URL of the web UI
      * @param encoder the required vehicle
      * @return the weighting to be used for route calculation
+     * @see WeightingMap
      */
-    public Weighting createWeighting( WeightingMap wMap, FlagEncoder encoder )
+    public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder )
     {
-        String weighting = wMap.getWeighting();
+        String weighting = weightingMap.getWeighting();
         Weighting result;
 
         if ("shortest".equalsIgnoreCase(weighting))
@@ -788,45 +846,44 @@ public Weighting createWeighting( WeightingMap wMap, FlagEncoder encoder )
         } else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
         {
             if (encoder.supports(PriorityWeighting.class))
-                result = new PriorityWeighting(encoder);
+                result = new PriorityWeighting(encoder, weightingMap);
             else
-                result = new FastestWeighting(encoder);
+                result = new FastestWeighting(encoder, weightingMap);
         } else
         {
             throw new UnsupportedOperationException("weighting " + weighting + " not supported");
         }
+        return result;
+    }
 
+    /**
+     * Potentially wraps the specified weighting into a TurnWeighting instance.
+     */
+    public Weighting createTurnWeighting( Weighting weighting, Graph graph, FlagEncoder encoder )
+    {
         if (encoder.supports(TurnWeighting.class))
-        {
-            result = new TurnWeighting(result, encoder, (TurnCostStorage) graph.getExtendedStorage());
-        }
-        return result;
+            return new TurnWeighting(weighting, encoder, (TurnCostExtension) graph.getExtension());
+        return weighting;
     }
 
     @Override
     public GHResponse route( GHRequest request )
     {
-        if (graph == null || !fullyLoaded)
-            throw new IllegalStateException("Call load or importOrLoad before routing");
-
-        if (graph.isClosed())
-            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
-
         GHResponse response = new GHResponse();
         List<Path> paths = getPaths(request, response);
         if (response.hasErrors())
             return response;
 
-        enableInstructions = request.getHints().getBool("instructions", enableInstructions);
-        calcPoints = request.getHints().getBool("calcPoints", calcPoints);
+        boolean tmpEnableInstructions = request.getHints().getBool("instructions", enableInstructions);
+        boolean tmpCalcPoints = request.getHints().getBool("calcPoints", calcPoints);
         double wayPointMaxDistance = request.getHints().getDouble("wayPointMaxDistance", 1d);
         Locale locale = request.getLocale();
         DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
 
         new PathMerger().
-                setCalcPoints(calcPoints).
+                setCalcPoints(tmpCalcPoints).
                 setDouglasPeucker(peucker).
-                setEnableInstructions(enableInstructions).
+                setEnableInstructions(tmpEnableInstructions).
                 setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0).
                 doWork(response, paths, trMap.getWithFallBack(locale));
         return response;
@@ -834,9 +891,15 @@ public GHResponse route( GHRequest request )
 
     protected List<Path> getPaths( GHRequest request, GHResponse rsp )
     {
+        if (graph == null || !fullyLoaded)
+            throw new IllegalStateException("Call load or importOrLoad before routing");
+
+        if (graph.isClosed())
+            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
+
         String vehicle = request.getVehicle();
         if (vehicle.isEmpty())
-            vehicle = encodingManager.getSingle().toString();
+            vehicle = getDefaultVehicle().toString();
 
         if (!encodingManager.supports(vehicle))
         {
@@ -863,69 +926,90 @@ public GHResponse route( GHRequest request )
             return Collections.emptyList();
         }
 
+        long visitedNodesSum = 0;
         FlagEncoder encoder = encodingManager.getEncoder(vehicle);
         EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
-        GHPoint startPoint = points.get(0);
+
         StopWatch sw = new StopWatch().start();
-        QueryResult fromRes = locationIndex.findClosest(startPoint.lat, startPoint.lon, edgeFilter);
-        String debug = "idLookup[0]:" + sw.stop().getSeconds() + "s";
-        sw.stop();
-        if (!fromRes.isValid())
+        List<QueryResult> qResults = new ArrayList<QueryResult>(points.size());
+        for (int placeIndex = 0; placeIndex < points.size(); placeIndex++)
         {
-            rsp.addError(new IllegalArgumentException("Cannot find point 0: " + startPoint));
+            GHPoint point = points.get(placeIndex);
+            QueryResult res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
+            if (!res.isValid())
+                rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": " + point));
+
+            qResults.add(res);
+        }
+
+        if (rsp.hasErrors())
             return Collections.emptyList();
+
+        String debug = "idLookup:" + sw.stop().getSeconds() + "s";
+
+        QueryGraph queryGraph;
+        RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory();
+        if (chEnabled && !vehicle.equalsIgnoreCase(getDefaultVehicle().toString()))
+        {
+            // fall back to normal traversing
+            tmpAlgoFactory = new RoutingAlgorithmFactorySimple();
+            queryGraph = new QueryGraph(graph.getBaseGraph());
+        } else
+        {
+            queryGraph = new QueryGraph(graph);
         }
 
+        queryGraph.lookup(qResults);
+
         List<Path> paths = new ArrayList<Path>(points.size() - 1);
+        QueryResult fromQResult = qResults.get(0);
+        Weighting weighting = createWeighting(request.getHints(), encoder);
+        weighting = createTurnWeighting(weighting, queryGraph, encoder);
+
+        double weightLimit = request.getHints().getDouble("defaultWeightLimit", defaultWeightLimit);
+        String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request.getAlgorithm();
+        AlgorithmOptions algoOpts = AlgorithmOptions.start().
+                algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).
+                build();
+
+        boolean viaTurnPenalty = request.getHints().getBool("pass_through", false);
         for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
         {
-            GHPoint point = points.get(placeIndex);
-            sw = new StopWatch().start();
-            QueryResult toRes = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
-            debug += ", [" + placeIndex + "] idLookup:" + sw.stop().getSeconds() + "s";
-            if (!toRes.isValid())
-            {
-                rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": " + point));
-                break;
-            }
 
-            sw = new StopWatch().start();
-            String algoStr = request.getAlgorithm().isEmpty() ? "dijkstrabi" : request.getAlgorithm();
-            RoutingAlgorithm algo = null;
-            if (chEnabled)
+            if (placeIndex == 1)
             {
-                if (prepare == null)
-                    throw new IllegalStateException("Preparation object is null. CH-preparation wasn't done or did you "
-                            + "forget to call setCHEnable(false)?");
-
-                if (algoStr.equals("dijkstrabi"))
-                    algo = prepare.createAlgo();
-                else if (algoStr.equals("astarbi"))
-                    algo = ((PrepareContractionHierarchies) prepare).createAStar();
-                else
-                {
-                    rsp.addError(new IllegalStateException(
-                            "Only dijkstrabi and astarbi is supported for LevelGraph (using contraction hierarchies)!"));
-                    break;
-                }
-            } else
+                // enforce start direction
+                queryGraph.enforceHeading(fromQResult.getClosestNode(), request.getFavoredHeading(0), false);
+            } else if (viaTurnPenalty)
             {
-                Weighting weighting = createWeighting(request.getHints(), encoder);
-                prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph, algoStr, encoder, weighting, tMode);
-                algo = prepare.createAlgo();
+                // enforce straight start after via stop
+                EdgeIteratorState incomingVirtualEdge = paths.get(placeIndex - 2).getFinalEdge();
+                queryGraph.enforceHeadingByEdgeId(fromQResult.getClosestNode(), incomingVirtualEdge.getEdge(), false);
             }
 
-            debug += ", algoInit:" + sw.stop().getSeconds() + "s";
+            QueryResult toQResult = qResults.get(placeIndex);
+
+            // enforce end direction
+            queryGraph.enforceHeading(toQResult.getClosestNode(), request.getFavoredHeading(placeIndex), true);
+
             sw = new StopWatch().start();
+            RoutingAlgorithm algo = tmpAlgoFactory.createAlgo(queryGraph, algoOpts);
+            algo.setWeightLimit(weightLimit);
+            debug += ", algoInit:" + sw.stop().getSeconds() + "s";
 
-            Path path = algo.calcPath(fromRes, toRes);
-            if (path.getMillis() < 0)
+            sw = new StopWatch().start();
+            Path path = algo.calcPath(fromQResult.getClosestNode(), toQResult.getClosestNode());
+            if (path.getTime() < 0)
                 throw new RuntimeException("Time was negative. Please report as bug and include:" + request);
 
             paths.add(path);
             debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, " + path.getDebugInfo();
-            visitedSum.addAndGet(algo.getVisitedNodes());
-            fromRes = toRes;
+
+            // reset all direction enforcements in queryGraph to avoid influencing next path
+            queryGraph.clearUnfavoredStatus();
+
+            visitedNodesSum += algo.getVisitedNodes();
+            fromQResult = toQResult;
         }
 
         if (rsp.hasErrors())
@@ -935,22 +1019,16 @@ else if (algoStr.equals("astarbi"))
             throw new RuntimeException("There should be exactly one more places than paths. places:" + points.size() + ", paths:" + paths.size());
 
         rsp.setDebugInfo(debug);
+        rsp.getHints().put("visited_nodes.sum", visitedNodesSum);
+        rsp.getHints().put("visited_nodes.average", (float) visitedNodesSum / (points.size() - 1));
         return paths;
     }
 
     protected LocationIndex createLocationIndex( Directory dir )
     {
-        LocationIndex tmpIndex;
-        if (graph instanceof LevelGraph)
-        {
-            tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
-        } else
-        {
-            tmpIndex = new LocationIndexTree(graph, dir);
-        }
+        LocationIndexTree tmpIndex = new LocationIndexTree(graph.getBaseGraph(), dir);
         tmpIndex.setResolution(preciseIndexResolution);
-        ((LocationIndexTree) tmpIndex).setMaxRegionSearch(maxRegionSearch);
-
+        tmpIndex.setMaxRegionSearch(maxRegionSearch);
         if (!tmpIndex.loadExisting())
         {
             ensureWriteAccess();
@@ -961,10 +1039,7 @@ protected LocationIndex createLocationIndex( Directory dir )
     }
 
     /**
-     * Initializes the location index. Currently this has to be done after the ch-preparation!
-     * Because - to improve performance - certain edges won't be available in a ch-graph and the
-     * index needs to know this and selects the correct nodes which still see the correct neighbors.
-     * See #116
+     * Initializes the location index after the import is done.
      */
     protected void initLocationIndex()
     {
@@ -996,16 +1071,12 @@ protected void optimize()
 
     protected void prepare()
     {
-        boolean tmpPrepare = doPrepare && prepare != null;
+        boolean tmpPrepare = doPrepare && getAlgorithmFactory() instanceof PrepareContractionHierarchies;
         if (tmpPrepare)
         {
             ensureWriteAccess();
-            if (prepare instanceof PrepareContractionHierarchies && encodingManager.getVehicleCount() > 1)
-                throw new IllegalArgumentException("Contraction hierarchies preparation "
-                        + "requires (at the moment) only one vehicle. But was:" + encodingManager);
-
-            logger.info("calling prepare.doWork for " + encodingManager.toString() + " ... (" + Helper.getMemInfo() + ")");
-            prepare.doWork();
+            logger.info("calling prepare.doWork for " + getDefaultVehicle() + " ... (" + Helper.getMemInfo() + ")");
+            ((PrepareContractionHierarchies) getAlgorithmFactory()).doWork();
             graph.getProperties().put("prepare.date", formatDateTime(new Date()));
         }
         graph.getProperties().put("prepare.done", tmpPrepare);
@@ -1013,22 +1084,24 @@ protected void prepare()
 
     protected void cleanUp()
     {
-        int prev = graph.getNodes();
+        int prevNodeCount = graph.getNodes();
         PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
         preparation.setMinNetworkSize(minNetworkSize);
-        preparation.setMinOnewayNetworkSize(this.minOnewayNetworkSize);
+        preparation.setMinOneWayNetworkSize(minOneWayNetworkSize);
         logger.info("start finding subnetworks, " + Helper.getMemInfo());
         preparation.doWork();
-        int n = graph.getNodes();
-        // calculate remaining subnetworks
+        int currNodeCount = graph.getNodes();
         int remainingSubnetworks = preparation.findSubnetworks().size();
-        logger.info("edges: " + graph.getAllEdges().getMaxId() + ", nodes " + n + ", there were " + preparation.getSubNetworks()
-                + " subnetworks. removed them => " + (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
+        logger.info("edges: " + graph.getAllEdges().getCount() + ", nodes " + currNodeCount
+                + ", there were " + preparation.getSubNetworks()
+                + " subnetworks. removed them => " + (prevNodeCount - currNodeCount)
+                + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
     }
 
     protected void flush()
     {
-        logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString() + ", " + Helper.getMemInfo() + ")");
+        logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString() + ", "
+                + Helper.getMemInfo() + ")");
         graph.flush();
         fullyLoaded = true;
     }
@@ -1050,7 +1123,7 @@ public void close()
             lockFactory.forceRemove(fileLockName, true);
         } catch (Exception ex)
         {
-            // silently fail
+            // silently fail e.g. on Windows where we cannot remove an unreleased native lock
         }
     }
 
@@ -1085,13 +1158,4 @@ protected void ensureWriteAccess()
         if (!allowWrites)
             throw new IllegalStateException("Writes are not allowed!");
     }
-
-    /**
-     * Returns the current sum of the visited nodes while routing. Mainly for statistic and
-     * debugging purposes.
-     */
-    public long getVisitedSum()
-    {
-        return visitedSum.get();
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/GraphHopperAPI.java b/core/src/main/java/com/graphhopper/GraphHopperAPI.java
index 5f81b8344f..f1bc8e66d8 100644
--- a/core/src/main/java/com/graphhopper/GraphHopperAPI.java
+++ b/core/src/main/java/com/graphhopper/GraphHopperAPI.java
@@ -20,27 +20,6 @@
 /**
  * Wrapper of the graphhopper online or offline API. Provides read only access.
  * <p/>
- * Usage:
- * <pre>
- *
- * // init offline graph
- * GraphHopperAPI gh = new GraphHopper().setInMemory(true);
- * gh.load("graph-hopper-folder");
- *
- * // init online service
- * GraphHopperAPI gh = new GraphHopperWeb();
- * gh.load("http://your-graphhopper-service.com");
- *
- * gh.algorithm("astar");
- * GHResponse ph = gh.route(new GHRequest(new GHPoint(fromLat, fromLon), new GHPoint(toLat, toLon)));
- * print(ph.distance() + " " + ph.time());
- * PointList points = response.getPoints();
- * for(int i = 0; i &lt; points.size(); i++) {
- *    add(point.latitude(i), point.longitude(i));
- * }
- *
- * </pre>
- * <p/>
  * @author Peter Karich
  */
 public interface GraphHopperAPI
@@ -48,7 +27,7 @@
     /**
      * Connects to the specified service (graphhopper URL) or loads a graph from the graphhopper
      * folder.
-     * <p>
+     * <p/>
      * @return true if successfully connected or loaded
      */
     boolean load( String urlOrFile );
diff --git a/core/src/main/java/com/graphhopper/coll/CompressedArray.java b/core/src/main/java/com/graphhopper/coll/CompressedArray.java
index 4036672e37..6fcb3fc3aa 100644
--- a/core/src/main/java/com/graphhopper/coll/CompressedArray.java
+++ b/core/src/main/java/com/graphhopper/coll/CompressedArray.java
@@ -21,6 +21,7 @@
 import com.graphhopper.storage.VLongStorage;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.io.ByteArrayOutputStream;
 import java.util.ArrayList;
 import java.util.List;
diff --git a/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java b/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
index d006901e16..7933a9f6f9 100644
--- a/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
+++ b/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
@@ -79,7 +79,7 @@ public GHBitSet copyTo( GHBitSet bs )
             int len = size();
             bs.ensureCapacity(len);
             for (int index = super.nextSetBit(0); index >= 0;
-                    index = super.nextSetBit(index + 1))
+                 index = super.nextSetBit(index + 1))
             {
                 bs.add(index);
             }
diff --git a/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java b/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java
index 4eca459cb2..53e9a4684f 100644
--- a/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java
+++ b/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java
@@ -18,7 +18,9 @@
 package com.graphhopper.coll;
 
 import com.graphhopper.util.Helper;
+
 import java.util.Arrays;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -472,6 +474,7 @@ static int binarySearch( long keys[], int start, int len, long key )
         int high = start + len, low = start - 1, guess;
         while (high - low > 1)
         {
+            // use >>> for average or we could get an integer overflow. 
             guess = (high + low) >>> 1;
             long guessedKey = keys[guess];
             if (guessedKey < key)
diff --git a/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java b/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java
index 7aaab98cc1..7b17fad7e7 100644
--- a/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java
+++ b/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java
@@ -19,6 +19,7 @@
 
 import gnu.trove.iterator.TIntIterator;
 import gnu.trove.set.hash.TIntHashSet;
+
 import java.util.Map.Entry;
 import java.util.TreeMap;
 
diff --git a/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java b/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
index faee1ee386..78bf9bc378 100644
--- a/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
+++ b/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
@@ -18,6 +18,7 @@
 package com.graphhopper.coll;
 
 import com.graphhopper.util.BitUtil;
+
 import java.util.TreeMap;
 
 /**
@@ -67,7 +68,7 @@ public void insert( int key, int value )
     public int peekValue()
     {
         long key = map.firstEntry().getKey();
-        return (int) (key >>> 32);
+        return (int) (key >> 32);
     }
 
     public int peekKey()
diff --git a/core/src/main/java/com/graphhopper/coll/OSMIDMap.java b/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
index 906242e37b..96c55d345f 100644
--- a/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
+++ b/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
@@ -104,6 +104,7 @@ static long binarySearch( DataAccess da, long start, long len, long key )
         byte[] longBytes = new byte[8];
         while (high - low > 1)
         {
+            // use >>> for average or we could get an integer overflow. 
             guess = (high + low) >>> 1;
             long tmp = guess << 3;
             da.getBytes(tmp, longBytes, 8);
diff --git a/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java b/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java
index 967b117b0e..e1f451a42d 100644
--- a/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java
+++ b/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.storage.VLongStorage;
 import com.graphhopper.util.Helper;
+
 import java.util.Arrays;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/coll/SparseArray.java b/core/src/main/java/com/graphhopper/coll/SparseArray.java
index 7b48993699..c9d9bf0392 100644
--- a/core/src/main/java/com/graphhopper/coll/SparseArray.java
+++ b/core/src/main/java/com/graphhopper/coll/SparseArray.java
@@ -373,7 +373,8 @@ private static int binarySearch( int[] a, int start, int len, int key )
         int high = start + len, low = start - 1, guess;
         while (high - low > 1)
         {
-            guess = (high + low) / 2;
+            // use >>> for average or we could get an integer overflow. 
+            guess = (high + low) >>> 1;
 
             if (a[guess] < key)
             {
diff --git a/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java b/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java
index 220c23d2f2..b3e95ef529 100644
--- a/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java
+++ b/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java
@@ -396,7 +396,8 @@ static int binarySearch( int[] a, int start, int len, int key )
         int high = start + len, low = start - 1, guess;
         while (high - low > 1)
         {
-            guess = (high + low) / 2;
+            // use >>> for average or we could get an integer overflow. 
+            guess = (high + low) >>> 1;
 
             if (a[guess] < key)
             {
@@ -434,6 +435,7 @@ private void checkIntegrity()
             }
         }
     }
+
     private int[] mKeys;
     private int[] mValues;
     private int mSize;
diff --git a/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java b/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java
index e84b46824c..2398eceec7 100644
--- a/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java
+++ b/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java
@@ -400,7 +400,8 @@ static int binarySearch( long[] a, int start, int len, long key )
         int high = start + len, low = start - 1, guess;
         while (high - low > 1)
         {
-            guess = (high + low) / 2;
+            // use >>> for average or we could get an integer overflow. 
+            guess = (high + low) >>> 1;
 
             if (a[guess] < key)
             {
@@ -438,6 +439,7 @@ private void checkIntegrity()
             }
         }
     }
+
     private long[] mKeys;
     private long[] mValues;
     private int mSize;
diff --git a/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java b/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
index 3b6e167958..06f694cbae 100644
--- a/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
+++ b/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
@@ -61,7 +61,7 @@ public LinearKeyAlgo setBounds( double minLonInit, double maxLonInit, double min
 
     public LinearKeyAlgo setBounds( BBox bounds )
     {
-        setBounds(bounds.minLon, bounds.maxLat, bounds.minLat, bounds.maxLat);
+        setBounds(bounds.minLon, bounds.maxLon, bounds.minLat, bounds.maxLat);
         return this;
     }
 
@@ -115,4 +115,5 @@ public double getLonDelta()
     {
         return lonDelta;
     }
+
 }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMElement.java b/core/src/main/java/com/graphhopper/reader/OSMElement.java
index 9820bbee00..c676cfad4a 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMElement.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMElement.java
@@ -131,7 +131,7 @@ public void setTag( String name, Object value )
      */
     public boolean hasTag( String key, Object value )
     {
-        return value.equals(properties.get(key));
+        return value.equals(getTag(key, ""));
     }
 
     /**
@@ -161,7 +161,7 @@ public boolean hasTag( String key, String... values )
      */
     public final boolean hasTag( String key, Set<String> values )
     {
-        return values.contains(properties.get(key));
+        return values.contains(getTag(key, ""));
     }
 
     /**
@@ -172,12 +172,25 @@ public boolean hasTag( List<String> keyList, Set<String> values )
     {
         for (String key : keyList)
         {
-            if (values.contains(properties.get(key)))
+            if (values.contains(getTag(key, "")))
                 return true;
         }
         return false;
     }
 
+    /**
+     * Returns the first existing tag of the specified list where the order is important.
+     */
+    public String getFirstPriorityTag( List<String> restrictions )
+    {
+        for (String str : restrictions)
+        {
+            if (hasTag(str))
+                return getTag(str);
+        }
+        return "";
+    }
+
     public void removeTag( String name )
     {
         properties.remove(name);
@@ -197,4 +210,10 @@ public boolean isType( int type )
     {
         return this.type == type;
     }
+
+    @Override
+    public String toString()
+    {
+        return properties.toString();
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMInputFile.java b/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
index 276227a0e5..43c5e70f38 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
@@ -240,6 +240,7 @@ public void close() throws IOException
                 pbfReaderThread.interrupt();
         }
     }
+
     Thread pbfReaderThread;
 
     private void openPBFReader( InputStream stream )
diff --git a/core/src/main/java/com/graphhopper/reader/OSMNode.java b/core/src/main/java/com/graphhopper/reader/OSMNode.java
index d8153cbea4..ea42f49425 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMNode.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMNode.java
@@ -18,6 +18,7 @@
 package com.graphhopper.reader;
 
 import com.graphhopper.util.PointAccess;
+
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
 
diff --git a/core/src/main/java/com/graphhopper/reader/OSMReader.java b/core/src/main/java/com/graphhopper/reader/OSMReader.java
index a24ad7a28c..a307501466 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMReader.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMReader.java
@@ -18,6 +18,7 @@
 package com.graphhopper.reader;
 
 import static com.graphhopper.util.Helper.nf;
+
 import gnu.trove.list.TLongList;
 import gnu.trove.list.array.TLongArrayList;
 import gnu.trove.map.TIntLongMap;
@@ -42,17 +43,14 @@
 import com.graphhopper.coll.LongIntMap;
 import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.dem.ElevationProvider;
-import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalc3D;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DouglasPeucker;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+import gnu.trove.map.TLongObjectMap;
+import gnu.trove.map.hash.TLongObjectHashMap;
+
+import java.util.*;
 
 /**
  * This class parses an OSM xml or pbf file and creates a graph from it. It does so in a two phase
@@ -61,7 +59,7 @@
  * 1. a) Reads ways from OSM file and stores all associated node ids in osmNodeIdToIndexMap. If a
  * node occurs once it is a pillar node and if more it is a tower node, otherwise
  * osmNodeIdToIndexMap returns EMPTY.
- * <p>
+ * <p/>
  * 1. b) Reads relations from OSM file. In case that the relation is a route relation, it stores
  * specific relation attributes required for routing into osmWayIdToRouteWeigthMap for all the ways
  * of the relation.
@@ -109,8 +107,8 @@
     private TIntLongMap edgeIdToOsmWayIdMap;
     private final TLongList barrierNodeIds = new TLongArrayList();
     protected PillarInfo pillarInfo;
-    private final DistanceCalc distCalc = new DistanceCalcEarth();
-    private final DistanceCalc3D distCalc3D = new DistanceCalc3D();
+    private final DistanceCalc distCalc = Helper.DIST_EARTH;
+    private final DistanceCalc3D distCalc3D = Helper.DIST_3D;
     private final DouglasPeucker simplifyAlgo = new DouglasPeucker();
     private boolean doSimplify = true;
     private int nextTowerId = 0;
@@ -120,6 +118,8 @@
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
     private boolean exitOnlyPillarNodeException = true;
     private File osmFile;
+    private Map<FlagEncoder, EdgeExplorer> outExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
+    private Map<FlagEncoder, EdgeExplorer> inExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
 
     public OSMReader( GraphStorage storage )
     {
@@ -444,20 +444,62 @@ public void processRelation( OSMRelation relation ) throws XMLStreamException
             OSMTurnRelation turnRelation = createTurnRelation(relation);
             if (turnRelation != null)
             {
-                ExtendedStorage extendedStorage = graphStorage.getExtendedStorage();
-                if (extendedStorage instanceof TurnCostStorage)
+                GraphExtension extendedStorage = graphStorage.getExtension();
+                if (extendedStorage instanceof TurnCostExtension)
                 {
-                    TurnCostStorage tcs = (TurnCostStorage) extendedStorage;
-                    Collection<TurnCostTableEntry> entries = encodingManager.analyzeTurnRelation(turnRelation, this);
+                    TurnCostExtension tcs = (TurnCostExtension) extendedStorage;
+                    Collection<TurnCostTableEntry> entries = analyzeTurnRelation(turnRelation);
                     for (TurnCostTableEntry entry : entries)
                     {
-                        tcs.addTurnInfo(entry.nodeViaNode, entry.edgeFrom, entry.edgeTo, entry.flags);
+                        tcs.addTurnInfo(entry.edgeFrom, entry.nodeVia, entry.edgeTo, entry.flags);
                     }
                 }
             }
         }
     }
 
+    public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation )
+    {
+        TLongObjectMap<TurnCostTableEntry> entries = new TLongObjectHashMap<OSMTurnRelation.TurnCostTableEntry>();
+
+        for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders())
+        {
+            for (TurnCostTableEntry entry : analyzeTurnRelation(encoder, turnRelation))
+            {
+                TurnCostTableEntry oldEntry = entries.get(entry.getItemId());
+                if (oldEntry != null)
+                {
+                    // merging different encoders
+                    oldEntry.flags |= entry.flags;
+                } else
+                {
+                    entries.put(entry.getItemId(), entry);
+                }
+            }
+        }
+
+        return entries.valueCollection();
+    }
+
+    public Collection<TurnCostTableEntry> analyzeTurnRelation( FlagEncoder encoder, OSMTurnRelation turnRelation )
+    {
+        if (!encoder.supports(TurnWeighting.class))
+            return Collections.emptyList();
+
+        EdgeExplorer edgeOutExplorer = outExplorerMap.get(encoder);
+        EdgeExplorer edgeInExplorer = inExplorerMap.get(encoder);
+
+        if (edgeOutExplorer == null || edgeInExplorer == null)
+        {
+            edgeOutExplorer = getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
+            outExplorerMap.put(encoder, edgeOutExplorer);
+
+            edgeInExplorer = getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(encoder, true, false));
+            inExplorerMap.put(encoder, edgeInExplorer);
+        }
+        return turnRelation.getRestrictionAsEntries(encoder, edgeOutExplorer, edgeInExplorer, this);
+    }
+
     /**
      * @return OSM way ID from specified edgeId. Only previously stored OSM-way-IDs are returned in
      * order to reduce memory overhead.
@@ -618,7 +660,7 @@ int addTowerNode( long osmId, double lat, double lon, double ele )
     /**
      * This method creates from an OSM way (via the osm ids) one or more edges in the graph.
      */
-    Collection<EdgeIteratorState> addOSMWay( TLongList osmNodeIds, long flags, long wayOsmId )
+    Collection<EdgeIteratorState> addOSMWay( final TLongList osmNodeIds, final long flags, final long wayOsmId )
     {
         PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
         List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
@@ -737,14 +779,20 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
                     pillarNodes.add(lat, lon);
             }
         }
-        if (towerNodeDistance == 0)
+        if (towerNodeDistance < 0.0001)
         {
             // As investigation shows often two paths should have crossed via one identical point 
-            // but end up in two very release points.
+            // but end up in two very close points.
             zeroCounter++;
             towerNodeDistance = 0.0001;
         }
 
+        if (Double.isInfinite(towerNodeDistance) || Double.isNaN(towerNodeDistance))
+        {
+            logger.warn("Bug in OSM or GraphHopper. Illegal tower node distance " + towerNodeDistance + " reset to 1m, osm way " + wayOsmId);
+            towerNodeDistance = 1;
+        }
+
         EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex).setDistance(towerNodeDistance).setFlags(flags);
         if (nodes > 2)
         {
@@ -853,7 +901,7 @@ private long createNewNodeId()
 
     /**
      * Creates an OSM turn relation out of an unspecified OSM relation
-     * <p>
+     * <p/>
      * @return the OSM turn relation, <code>null</code>, if unsupported turn relation
      */
     OSMTurnRelation createTurnRelation( OSMRelation relation )
@@ -957,10 +1005,11 @@ public OSMReader setOSMFile( File osmFile )
 
     private void printInfo( String str )
     {
-        LoggerFactory.getLogger(getClass()).info(
-                "finished " + str + " processing." + " nodes: " + graphStorage.getNodes() + ", osmIdMap.size:" + getNodeMap().getSize()
-                + ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB" + ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
-                + ", relFlagsMap.size:" + getRelFlagsMap().size() + " " + Helper.getMemInfo());
+        logger.info("finished " + str + " processing." + " nodes: " + graphStorage.getNodes()
+                + ", osmIdMap.size:" + getNodeMap().getSize() + ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB"
+                + ", nodeFlagsMap.size:" + getNodeFlagsMap().size() + ", relFlagsMap.size:" + getRelFlagsMap().size()
+                + ", zeroCounter:" + zeroCounter
+                + " " + Helper.getMemInfo());
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
index a675706c31..27c5c7051a 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
@@ -7,11 +7,12 @@
 import com.graphhopper.routing.util.TurnCostEncoder;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
+
 import java.util.*;
 
 /**
  * Helper object which gives node cost entries for a given OSM-relation of type "restriction"
- * <p>
+ * <p/>
  * @author Karl Hbner
  */
 public class OSMTurnRelation
@@ -69,26 +70,26 @@ long getOsmIdTo()
 
     /**
      * Transforms this relation into a collection of turn cost entries
-     * <p>
+     * <p/>
      * @param edgeOutExplorer an edge filter which only allows outgoing edges
      * @param edgeInExplorer an edge filter which only allows incoming edges
      * @return a collection of node cost entries which can be added to the graph later
      */
     public Collection<TurnCostTableEntry> getRestrictionAsEntries( TurnCostEncoder encoder,
-            EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, OSMReader osmReader )
+                                                                   EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, OSMReader osmReader )
     {
-        int viaNodeId = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
+        int nodeVia = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
 
         try
         {
             // street with restriction was not included (access or tag limits etc)
-            if (viaNodeId == OSMReader.EMPTY)
+            if (nodeVia == OSMReader.EMPTY)
                 return Collections.emptyList();
 
             int edgeIdFrom = EdgeIterator.NO_EDGE;
 
             // get all incoming edges and receive the edge which is defined by fromOsm
-            EdgeIterator iter = edgeInExplorer.setBaseNode(viaNodeId);
+            EdgeIterator iter = edgeInExplorer.setBaseNode(nodeVia);
 
             while (iter.next())
             {
@@ -104,19 +105,18 @@ long getOsmIdTo()
 
             final Collection<TurnCostTableEntry> entries = new ArrayList<TurnCostTableEntry>();
             // get all outgoing edges of the via node 
-            iter = edgeOutExplorer.setBaseNode(viaNodeId);
+            iter = edgeOutExplorer.setBaseNode(nodeVia);
             // for TYPE_ONLY_* we add ALL restrictions (from, via, * ) EXCEPT the given turn
-            // for TYPE_NO_*   we add ONE restriction  (from, via, to)
+            // for TYPE_NOT_*  we add ONE restriction  (from, via, to)
             while (iter.next())
             {
                 int edgeId = iter.getEdge();
-                long wayId = osmReader.getOsmIdOfInternalEdge(edgeId);                
-                if (edgeId != edgeIdFrom
-                        && (this.restriction == Type.ONLY && wayId != this.toOsmWayId
-                        || (this.restriction == Type.NOT && wayId == this.toOsmWayId && wayId >= 0)))
+                long wayId = osmReader.getOsmIdOfInternalEdge(edgeId);
+                if (edgeId != edgeIdFrom && this.restriction == Type.ONLY && wayId != this.toOsmWayId
+                        || this.restriction == Type.NOT && wayId == this.toOsmWayId && wayId >= 0)
                 {
                     final TurnCostTableEntry entry = new TurnCostTableEntry();
-                    entry.nodeViaNode = viaNodeId;
+                    entry.nodeVia = nodeVia;
                     entry.edgeFrom = edgeIdFrom;
                     entry.edgeTo = iter.getEdge();
                     entry.flags = encoder.getTurnFlags(true, 0);
@@ -145,7 +145,7 @@ public String toString()
     public static class TurnCostTableEntry
     {
         public int edgeFrom;
-        public int nodeViaNode;
+        public int nodeVia;
         public int edgeTo;
         public long flags;
 
@@ -161,7 +161,7 @@ public long getItemId()
         @Override
         public String toString()
         {
-            return "*-(" + edgeFrom + ")->" + nodeViaNode + "-(" + edgeTo + ")->*";
+            return "*-(" + edgeFrom + ")->" + nodeVia + "-(" + edgeTo + ")->*";
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/reader/OSMWay.java b/core/src/main/java/com/graphhopper/reader/OSMWay.java
index a4e0bfcee9..3f713757b1 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMWay.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMWay.java
@@ -23,7 +23,6 @@
 import javax.xml.stream.XMLStreamConstants;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
-import java.util.Map;
 
 /**
  * Represents an OSM Way
@@ -75,6 +74,6 @@ public TLongList getNodes()
     @Override
     public String toString()
     {
-        return "Way (" + getId() + ", " + nodes.size() + " nodes)";
+        return "Way id:" + getId() + ", nodes:" + nodes.size() + ", tags:" + super.toString();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/PillarInfo.java b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
index 2edee09bc7..9ef7e4664e 100644
--- a/core/src/main/java/com/graphhopper/reader/PillarInfo.java
+++ b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
@@ -25,7 +25,7 @@
 
 /**
  * This class helps to store lat,lon,ele for every node parsed in OSMReader
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class PillarInfo implements PointAccess
@@ -57,26 +57,28 @@ public int getDimension()
     }
 
     @Override
-    public void setNode( int id, double lat, double lon )
+    public void ensureNode( int nodeId )
     {
-//        if (is3D())
-//            throw new IllegalStateException("Can only be called if 3D is disabled");
+        long tmp = (long) nodeId * rowSizeInBytes;
+        da.ensureCapacity(tmp + rowSizeInBytes);
+    }
 
-        _setNode(id, lat, lon, Double.NaN);
+    @Override
+    public void setNode( int nodeId, double lat, double lon )
+    {
+        _setNode(nodeId, lat, lon, Double.NaN);
     }
 
     @Override
-    public void setNode( int id, double lat, double lon, double ele )
+    public void setNode( int nodeId, double lat, double lon, double ele )
     {
-//        if (!is3D())
-//            throw new IllegalStateException("Can only be called if 3D is enabled");
-        _setNode(id, lat, lon, ele);
+        _setNode(nodeId, lat, lon, ele);
     }
 
-    private void _setNode( int id, double lat, double lon, double ele )
+    private void _setNode( int nodeId, double lat, double lon, double ele )
     {
-        long tmp = (long) id * rowSizeInBytes;
-        da.ensureCapacity(tmp + rowSizeInBytes);
+        ensureNode(nodeId);
+        long tmp = (long) nodeId * rowSizeInBytes;
         da.setInt(tmp + LAT, Helper.degreeToInt(lat));
         da.setInt(tmp + LON, Helper.degreeToInt(lon));
 
diff --git a/core/src/main/java/com/graphhopper/reader/PrinctonReader.java b/core/src/main/java/com/graphhopper/reader/PrinctonReader.java
index 7b6a6438ba..977337760a 100644
--- a/core/src/main/java/com/graphhopper/reader/PrinctonReader.java
+++ b/core/src/main/java/com/graphhopper/reader/PrinctonReader.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.Helper;
+
 import java.io.BufferedReader;
 import java.io.InputStream;
 import java.io.InputStreamReader;
diff --git a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
index 12301de6c9..ada6645c76 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
@@ -24,6 +24,7 @@
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
+
 import java.awt.image.Raster;
 import java.io.*;
 import java.net.SocketTimeoutException;
@@ -31,6 +32,7 @@
 import java.util.Map;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipInputStream;
+
 import org.apache.xmlgraphics.image.codec.tiff.TIFFDecodeParam;
 import org.apache.xmlgraphics.image.codec.tiff.TIFFImageDecoder;
 import org.apache.xmlgraphics.image.codec.util.SeekableStream;
@@ -41,14 +43,14 @@
  * Elevation data from CGIAR project http://srtm.csi.cgiar.org/ 'PROCESSED SRTM DATA VERSION 4.1'.
  * Every file covers a region of 5x5 degree. License granted for all people using GraphHopper:
  * http://graphhopper.com/public/license/CGIAR.txt
- * <p>
+ * <p/>
  * Every zip contains readme.txt with the necessary information e.g.:
  * <ol>
  * <li>
  * All GeoTiffs with 6000 x 6000 pixels.
  * </li>
  * </ol>
- * <p>
+ * <p/>
  * @author NopMap
  * @author Peter Karich
  */
@@ -59,8 +61,8 @@
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final Map<String, HeightTile> cacheData = new HashMap<String, HeightTile>();
     private File cacheDir = new File("/tmp/cgiar");
-    // String baseUrl = "http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff";
-    private String baseUrl = "http://droppr.org/srtm/v4.1/6_5x5_TIFs";
+    // for alternatives see #346
+    private String baseUrl = "http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff";
     private Directory dir;
     private DAType daType = DAType.MMAP;
     final double precision = 1e7;
@@ -105,6 +107,11 @@ public ElevationProvider setCacheDir( File cacheDir )
         return this;
     }
 
+    protected File getCacheDir()
+    {
+        return cacheDir;
+    }        
+
     @Override
     public ElevationProvider setBaseURL( String baseUrl )
     {
@@ -210,7 +217,7 @@ public double getEle( double lat, double lon )
                     {
                         entry = zis.getNextEntry();
                     }
-
+                    
                     ss = SeekableStream.wrapInputStream(zis, true);
                     TIFFImageDecoder imageDecoder = new TIFFImageDecoder(ss, new TIFFDecodeParam());
                     raster = imageDecoder.decodeAsRaster();
@@ -315,6 +322,9 @@ private Directory getDirectory()
     public static void main( String[] args )
     {
         CGIARProvider provider = new CGIARProvider();
+        
+        System.out.println(provider.getEle(46, -20));
+        
         // 337.0
         System.out.println(provider.getEle(49.949784, 11.57517));
         // 453.0
diff --git a/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java b/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
index aed7740ae7..293b6a6e6d 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
@@ -19,6 +19,7 @@
 package com.graphhopper.reader.dem;
 
 import com.graphhopper.storage.DAType;
+
 import java.io.File;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
index c0c27c476e..f559b2d494 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
@@ -19,6 +19,7 @@
 package com.graphhopper.reader.dem;
 
 import com.graphhopper.storage.DataAccess;
+
 import java.awt.Color;
 import java.awt.Graphics;
 import java.awt.image.BufferedImage;
@@ -29,7 +30,7 @@
 
 /**
  * One rectangle of height data from Shuttle Radar Topography Mission.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class HeightTile
diff --git a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
index 8570012140..162d8fe404 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
@@ -23,20 +23,22 @@
 import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
 import gnu.trove.map.hash.TIntObjectHashMap;
+
 import java.io.*;
 import java.net.SocketTimeoutException;
 import java.util.zip.ZipInputStream;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * Elevation data from NASA (SRTM). Downloaded from http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/
- * <p>
+ * Elevation data from NASA (SRTM).
+ * <p/>
  * Important information about SRTM: the coordinates of the lower-left corner of tile N40W118 are 40
  * degrees north latitude and 118 degrees west longitude. To be more exact, these coordinates refer
  * to the geometric center of the lower left sample, which in the case of SRTM3 data will be about
  * 90 meters in extent.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class SRTMProvider implements ElevationProvider
@@ -72,7 +74,8 @@ public static void main( String[] args ) throws IOException
     private final TIntObjectHashMap<String> areas = new TIntObjectHashMap<String>();
     private final double precision = 1e7;
     private final double invPrecision = 1 / precision;
-    // mirror: base = "http://mirror.ufs.ac.za/datasets/SRTM3/"
+    // possible alternatives see #451
+    // http://mirror.ufs.ac.za/datasets/SRTM3/
     private String baseUrl = "http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/";
     private boolean calcMean = false;
 
@@ -97,15 +100,13 @@ private SRTMProvider init()
         try
         {
             String strs[] =
-            {
-                "Africa", "Australia", "Eurasia", "Islands", "North_America", "South_America"
-            };
+                    {
+                            "Africa", "Australia", "Eurasia", "Islands", "North_America", "South_America"
+                    };
             for (String str : strs)
             {
-                InputStream is = getClass().getResourceAsStream(str + "_names.txt.zip");
-                ZipInputStream zis = new ZipInputStream(is);
-                zis.getNextEntry();
-                for (String line : Helper.readFile(new InputStreamReader(zis, Helper.UTF_CS)))
+                InputStream is = getClass().getResourceAsStream(str + "_names.txt");
+                for (String line : Helper.readFile(new InputStreamReader(is, Helper.UTF_CS)))
                 {
                     int lat = Integer.parseInt(line.substring(1, 3));
                     if (line.substring(0, 1).charAt(0) == 'S')
@@ -251,7 +252,7 @@ public double getEle( double lat, double lon )
                 heights.create(bytes.length);
                 try
                 {
-                    String zippedURL = baseUrl + "/" + fileDetails + "hgt.zip";
+                    String zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
                     File file = new File(cacheDir, new File(zippedURL).getName());
                     InputStream is;
                     // get zip file if not already in cacheDir - unzip later and in-memory only!
@@ -270,8 +271,8 @@ public double getEle( double lat, double lon )
                                 continue;
                             } catch (FileNotFoundException ex)
                             {
-                                // now try different URL (with point!), necessary if mirror is used
-                                zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
+                                // now try different URL (without point!), necessary if mirror is used
+                                zippedURL = baseUrl + "/" + fileDetails + "hgt.zip";
                                 continue;
                             }
                         }
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java
index 58ab2d598c..a862aaf326 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java
@@ -12,9 +12,9 @@
 
 import java.io.IOException;
 import java.util.*;
-import java.util.logging.Level;
 import java.util.zip.DataFormatException;
 import java.util.zip.Inflater;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -85,13 +85,11 @@ private void processOsmHeader( byte[] data ) throws InvalidProtocolBufferExcepti
 
         // Build the list of active and unsupported features in the file.
         List<String> supportedFeatures = Arrays.asList("OsmSchema-V0.6", "DenseNodes");
-        List<String> activeFeatures = new ArrayList<String>();
         List<String> unsupportedFeatures = new ArrayList<String>();
         for (String feature : header.getRequiredFeaturesList())
         {
             if (supportedFeatures.contains(feature))
             {
-                activeFeatures.add(feature);
             } else
             {
                 unsupportedFeatures.add(feature);
@@ -140,7 +138,7 @@ private void processOsmHeader( byte[] data ) throws InvalidProtocolBufferExcepti
         Iterator<Integer> valueIterator = values.iterator();
         if (keyIterator.hasNext())
         {
-            Map<String, String> tags = new HashMap<String, String>();
+            Map<String, String> tags = new HashMap<String, String>(keys.size());
             while (keyIterator.hasNext())
             {
                 String key = fieldDecoder.decodeString(keyIterator.next());
@@ -291,8 +289,8 @@ private void processWays( List<Osmformat.Way> ways, PbfFieldDecoder fieldDecoder
     }
 
     private void buildRelationMembers( OSMRelation relation,
-            List<Long> memberIds, List<Integer> memberRoles, List<Osmformat.Relation.MemberType> memberTypes,
-            PbfFieldDecoder fieldDecoder )
+                                       List<Long> memberIds, List<Integer> memberRoles, List<Osmformat.Relation.MemberType> memberTypes,
+                                       PbfFieldDecoder fieldDecoder )
     {
 
         ArrayList<OSMRelation.Member> members = relation.getMembers();
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java
index 421979704f..6ff39041c0 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java
@@ -2,6 +2,7 @@
 package com.graphhopper.reader.pbf;
 
 import com.graphhopper.reader.OSMElement;
+
 import java.util.Date;
 
 import java.util.LinkedList;
@@ -37,7 +38,7 @@
      * @param sink The sink to send all decoded entities to.
      */
     public PbfDecoder( PbfStreamSplitter streamSplitter, ExecutorService executorService, int maxPendingBlobs,
-            Sink sink )
+                       Sink sink )
     {
         this.streamSplitter = streamSplitter;
         this.executorService = executorService;
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfFieldDecoder.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfFieldDecoder.java
index 7615e10ae1..a1921bed2e 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfFieldDecoder.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfFieldDecoder.java
@@ -9,7 +9,7 @@
  * Manages decoding of the lower level PBF data structures.
  * <p/>
  * @author Brett Henderson
- * <p/>
+ *         <p/>
  */
 public class PbfFieldDecoder
 {
diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
index 2fd110cef9..80b88f570f 100644
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.util.DistancePlaneProjection;
 import gnu.trove.map.TIntObjectMap;
 import gnu.trove.map.hash.TIntObjectHashMap;
 
@@ -25,11 +26,10 @@
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.util.WeightApproximator;
+import com.graphhopper.routing.util.BeelineWeightApproximator;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DistancePlaneProjection;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 
@@ -43,32 +43,28 @@
  */
 public class AStar extends AbstractRoutingAlgorithm
 {
-    private DistanceCalc dist;
+    private WeightApproximator weightApprox;
     private int visitedCount;
     private TIntObjectMap<AStarEdge> fromMap;
     private PriorityQueue<AStarEdge> prioQueueOpenSet;
     private AStarEdge currEdge;
     private int to1 = -1;
-    private double toLat;
-    private double toLon;
 
     public AStar( Graph g, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
         super(g, encoder, weighting, tMode);
         initCollections(1000);
-        setApproximation(true);
+        BeelineWeightApproximator defaultApprox = new BeelineWeightApproximator(nodeAccess, weighting);
+        defaultApprox.setDistanceCalc(new DistancePlaneProjection());
+        setApproximation(defaultApprox);
     }
 
     /**
-     * @param approx if true it enables an approximative distance calculation from lat,lon values
+     * @param approx defines how distance to goal Node is approximated
      */
-    public AStar setApproximation( boolean approx )
+    public AStar setApproximation( WeightApproximator approx )
     {
-        if (approx)
-            dist = new DistancePlaneProjection();
-        else
-            dist = new DistanceCalcEarth();
-
+        weightApprox = approx;
         return this;
     }
 
@@ -82,10 +78,11 @@ protected void initCollections( int size )
     public Path calcPath( int from, int to )
     {
         checkAlreadyRun();
-        toLat = nodeAccess.getLatitude(to);
-        toLon = nodeAccess.getLongitude(to);
         to1 = to;
-        currEdge = createEdgeEntry(from, 0);
+
+        weightApprox.setGoalNode(to);
+        double weightToGoal = weightApprox.approximate(from);
+        currEdge = new AStarEdge(EdgeIterator.NO_EDGE, from, 0 + weightToGoal, 0);
         if (!traversalMode.isEdgeBased())
         {
             fromMap.put(from, currEdge);
@@ -95,12 +92,15 @@ public Path calcPath( int from, int to )
 
     private Path runAlgo()
     {
-        double currWeightToGoal, distEstimation, tmpLat, tmpLon;
+        double currWeightToGoal, distEstimation;
         EdgeExplorer explorer = outEdgeExplorer;
         while (true)
         {
             int currVertex = currEdge.adjNode;
             visitedCount++;
+            if (isWeightLimitExceeded())
+                return createEmptyPath();
+
             if (finished())
                 break;
 
@@ -112,30 +112,29 @@ private Path runAlgo()
 
                 int neighborNode = iter.getAdjNode();
                 int traversalId = traversalMode.createTraversalId(iter, false);
-                double alreadyVisitedWeight = weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weightToCompare;
+                // cast to float to avoid rounding errors in comparison to float entry of AStarEdge weight
+                float alreadyVisitedWeight = (float) (weighting.calcWeight(iter, false, currEdge.edge)
+                        + currEdge.weightOfVisitedPath);
                 if (Double.isInfinite(alreadyVisitedWeight))
                     continue;
 
                 AStarEdge ase = fromMap.get(traversalId);
-                if (ase == null || ase.weightToCompare > alreadyVisitedWeight)
+                if ((ase == null) || ase.weightOfVisitedPath > alreadyVisitedWeight)
                 {
-                    tmpLat = nodeAccess.getLatitude(neighborNode);
-                    tmpLon = nodeAccess.getLongitude(neighborNode);
-                    currWeightToGoal = dist.calcDist(toLat, toLon, tmpLat, tmpLon);
-                    currWeightToGoal = weighting.getMinWeight(currWeightToGoal);
+                    currWeightToGoal = weightApprox.approximate(neighborNode);
                     distEstimation = alreadyVisitedWeight + currWeightToGoal;
                     if (ase == null)
                     {
                         ase = new AStarEdge(iter.getEdge(), neighborNode, distEstimation, alreadyVisitedWeight);
                         fromMap.put(traversalId, ase);
-                    } else if (ase.weight > distEstimation)
+                    } else
                     {
+                        assert (ase.weight > distEstimation) : "Inconsistent distance estimate";
                         prioQueueOpenSet.remove(ase);
                         ase.edge = iter.getEdge();
                         ase.weight = distEstimation;
-                        ase.weightToCompare = alreadyVisitedWeight;
-                    } else
-                        continue;
+                        ase.weightOfVisitedPath = alreadyVisitedWeight;
+                    }
 
                     ase.parent = currEdge;
                     prioQueueOpenSet.add(ase);
@@ -162,9 +161,9 @@ protected Path extractPath()
     }
 
     @Override
-    protected AStarEdge createEdgeEntry( int node, double dist )
+    protected EdgeEntry createEdgeEntry( int node, double weight )
     {
-        return new AStarEdge(EdgeIterator.NO_EDGE, node, dist, dist);
+        throw new IllegalStateException("use AStarEdge constructor directly");
     }
 
     @Override
@@ -179,23 +178,28 @@ public int getVisitedNodes()
         return visitedCount;
     }
 
+    @Override
+    protected boolean isWeightLimitExceeded()
+    {
+        return currEdge.weight > weightLimit;
+    }
+
     public static class AStarEdge extends EdgeEntry
     {
         // the variable 'weight' is used to let heap select smallest *full* distance.
         // but to compare distance we need it only from start:
-        double weightToCompare;
+        double weightOfVisitedPath;
 
-        public AStarEdge( int edgeId, int adjNode, double weightForHeap, double weightToCompare )
+        public AStarEdge( int edgeId, int adjNode, double weightForHeap, double weightOfVisitedPath )
         {
             super(edgeId, adjNode, weightForHeap);
-            // round makes distance smaller => heuristic should underestimate the distance!
-            this.weightToCompare = (float) weightToCompare;
+            this.weightOfVisitedPath = (float) weightOfVisitedPath;
         }
     }
 
     @Override
     public String getName()
     {
-        return "astar";
+        return AlgorithmOptions.ASTAR;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
index 42b420105b..7fd97d3d22 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
@@ -17,33 +17,28 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.*;
 import gnu.trove.map.TIntObjectMap;
 import gnu.trove.map.hash.TIntObjectHashMap;
 
 import java.util.PriorityQueue;
 
 import com.graphhopper.routing.AStar.AStarEdge;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.*;
-import com.graphhopper.util.shapes.GHPoint;
 
 /**
  * This class implements a bidirectional A* algorithm. It is interesting to note that a
  * bidirectional dijkstra is far more efficient than a single direction one. The same does not hold
- * for a bidirectional A* as the finish condition can not be so strict which leads to either
- * suboptimal paths or suboptimal node exploration (too many nodes). Still very good approximations
- * with a rougly twice times faster running time than the normal A* can be reached.
+ * for a bidirectional A* as the heuristic can not be as tight.
  * <p/>
- * Computing the Shortest Path: A Search Meets Graph Theory ->
- * http://research.microsoft.com/apps/pubs/default.aspx?id=64511
+ * See http://research.microsoft.com/apps/pubs/default.aspx?id=64511
  * http://i11www.iti.uni-karlsruhe.de/_media/teaching/sommer2012/routenplanung/vorlesung4.pdf
  * http://research.microsoft.com/pubs/64504/goldberg-sofsem07.pdf
  * http://www.cs.princeton.edu/courses/archive/spr06/cos423/Handouts/EPP%20shortest%20path%20algorithms.pdf
  * <p/>
- * better stop condition
+ * and
  * <p/>
  * 1. Ikeda, T., Hsu, M.-Y., Imai, H., Nishimura, S., Shimoura, H., Hashimoto, T., Tenmoku, K., and
  * Mitoh, K. (1994). A fast algorithm for finding better routes by ai search techniques. In VNIS,
@@ -56,10 +51,11 @@
  * www.lix.polytechnique.fr/~giacomon/papers/bidirtimedep.pdf
  * <p/>
  * @author Peter Karich
+ * @author jansoe
  */
 public class AStarBidirection extends AbstractBidirAlgo
 {
-    private DistanceCalc dist;
+    private ConsistentWeightApproximator weightApprox;
     private PriorityQueue<AStarEdge> prioQueueOpenSetFrom;
     private TIntObjectMap<AStarEdge> bestWeightMapFrom;
     private PriorityQueue<AStarEdge> prioQueueOpenSetTo;
@@ -67,9 +63,6 @@
     private TIntObjectMap<AStarEdge> bestWeightMapOther;
     protected AStarEdge currFrom;
     protected AStarEdge currTo;
-    protected double approximationFactor;
-    private GHPoint fromCoord;
-    private GHPoint toCoord;
     protected PathBidirRef bestPath;
 
     public AStarBidirection( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
@@ -77,9 +70,9 @@ public AStarBidirection( Graph graph, FlagEncoder encoder, Weighting weighting,
         super(graph, encoder, weighting, tMode);
         int nodes = Math.max(20, graph.getNodes());
         initCollections(nodes);
-
-        // different default value for approximation than AStar
-        setApproximation(false);
+        BeelineWeightApproximator defaultApprox = new BeelineWeightApproximator(nodeAccess, weighting);
+        defaultApprox.setDistanceCalc(new DistancePlaneProjection());
+        setApproximation(defaultApprox);
     }
 
     protected void initCollections( int size )
@@ -94,41 +87,31 @@ protected void initCollections( int size )
     /**
      * @param approx if true it enables approximative distance calculation from lat,lon values
      */
-    public AStarBidirection setApproximation( boolean approx )
+    public AStarBidirection setApproximation( WeightApproximator approx )
     {
-        if (approx)
-        {
-            dist = new DistancePlaneProjection();
-            approximationFactor = 0.5;
-        } else
-        {
-            dist = new DistanceCalcEarth();
-            approximationFactor = 1.2;
-        }
-        return this;
-    }
-
-    /**
-     * Specify a low value like 0.5 for worse but faster results. Or over 1.1 for more precise.
-     */
-    public AStarBidirection setApproximationFactor( double approxFactor )
-    {
-        this.approximationFactor = approxFactor;
+        weightApprox = new ConsistentWeightApproximator(approx);
         return this;
     }
 
     @Override
-    protected AStarEdge createEdgeEntry( int node, double dist )
+    protected EdgeEntry createEdgeEntry( int node, double weight )
     {
-        return new AStarEdge(EdgeIterator.NO_EDGE, node, dist, dist);
+        throw new IllegalStateException("use AStarEdge constructor directly");
     }
 
     @Override
-    public void initFrom( int from, double dist )
+    public void initFrom( int from, double weight )
     {
-        currFrom = createEdgeEntry(from, dist);
-        fromCoord = new GHPoint(nodeAccess.getLatitude(from), nodeAccess.getLongitude(from));
+        currFrom = new AStarEdge(EdgeIterator.NO_EDGE, from, weight, weight);
+        weightApprox.setSourceNode(from);
         prioQueueOpenSetFrom.add(currFrom);
+
+        if (currTo != null)
+        {
+            currFrom.weight += weightApprox.approximate(currFrom.adjNode, false);
+            currTo.weight += weightApprox.approximate(currTo.adjNode, true);
+        }
+
         if (!traversalMode.isEdgeBased())
         {
             bestWeightMapFrom.put(from, currFrom);
@@ -141,6 +124,9 @@ public void initFrom( int from, double dist )
         {
             if (currTo != null && currTo.adjNode == from)
             {
+                // special case of identical start and end
+                bestPath.edgeEntry = currFrom;
+                bestPath.edgeTo = currTo;
                 finishedFrom = true;
                 finishedTo = true;
             }
@@ -148,11 +134,18 @@ public void initFrom( int from, double dist )
     }
 
     @Override
-    public void initTo( int to, double dist )
+    public void initTo( int to, double weight )
     {
-        currTo = createEdgeEntry(to, dist);
-        toCoord = new GHPoint(nodeAccess.getLatitude(to), nodeAccess.getLongitude(to));
+        currTo = new AStarEdge(EdgeIterator.NO_EDGE, to, weight, weight);
+        weightApprox.setGoalNode(to);
         prioQueueOpenSetTo.add(currTo);
+
+        if (currFrom != null)
+        {
+            currFrom.weight += weightApprox.approximate(currFrom.adjNode, false);
+            currTo.weight += weightApprox.approximate(currTo.adjNode, true);
+        }
+
         if (!traversalMode.isEdgeBased())
         {
             bestWeightMapTo.put(to, currTo);
@@ -165,6 +158,9 @@ public void initTo( int to, double dist )
         {
             if (currFrom != null && currFrom.adjNode == to)
             {
+                // special case of identical start and end
+                bestPath.edgeEntry = currFrom;
+                bestPath.edgeTo = currTo;
                 finishedFrom = true;
                 finishedTo = true;
             }
@@ -181,27 +177,37 @@ protected Path createAndInitPath()
     @Override
     protected Path extractPath()
     {
-        return bestPath.extract();
+        if (finished())
+            return bestPath.extract();
+
+        return bestPath;
+    }
+
+    @Override
+    protected double getCurrentFromWeight()
+    {
+        return currFrom.weight;
     }
 
     @Override
-    void checkState( int fromBase, int fromAdj, int toBase, int toAdj )
+    protected double getCurrentToWeight()
     {
-        if (bestWeightMapFrom.isEmpty() || bestWeightMapTo.isEmpty())
-            throw new IllegalStateException("Either 'from'-edge or 'to'-edge is inaccessible. From:" + bestWeightMapFrom + ", to:" + bestWeightMapTo);
+        return currTo.weight;
     }
 
-    // Problem is the correct finish condition! if the bounds are too wide too many nodes are visited :/   
-    // d_f (v) + (v, w) + d_r (w) <  + p_r(t)
-    // where pi_r_of_t = p_r(t) = 1/2(pi_r(t) - pi_f(t) + pi_f(s)), and pi_f(t)=0
     @Override
     protected boolean finished()
     {
         if (finishedFrom || finishedTo)
             return true;
 
-        double tmp = bestPath.getWeight() * approximationFactor;
-        return currFrom.weightToCompare + currTo.weightToCompare >= tmp;
+        return currFrom.weight + currTo.weight >= bestPath.getWeight();
+    }
+
+    @Override
+    protected boolean isWeightLimitExceeded()
+    {
+        return currFrom.weight + currTo.weight > weightLimit;
     }
 
     @Override
@@ -212,7 +218,7 @@ boolean fillEdgesFrom()
 
         currFrom = prioQueueOpenSetFrom.poll();
         bestWeightMapOther = bestWeightMapTo;
-        fillEdges(currFrom, toCoord, prioQueueOpenSetFrom, bestWeightMapFrom, outEdgeExplorer, false);
+        fillEdges(currFrom, prioQueueOpenSetFrom, bestWeightMapFrom, outEdgeExplorer, false);
         visitedCountFrom++;
         return true;
     }
@@ -225,14 +231,13 @@ boolean fillEdgesTo()
 
         currTo = prioQueueOpenSetTo.poll();
         bestWeightMapOther = bestWeightMapFrom;
-        fillEdges(currTo, fromCoord, prioQueueOpenSetTo, bestWeightMapTo, inEdgeExplorer, true);
+        fillEdges(currTo, prioQueueOpenSetTo, bestWeightMapTo, inEdgeExplorer, true);
         visitedCountTo++;
         return true;
     }
 
-    private void fillEdges( AStarEdge currEdge, GHPoint goal,
-            PriorityQueue<AStarEdge> prioQueueOpenSet,
-            TIntObjectMap<AStarEdge> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
+    private void fillEdges( AStarEdge currEdge, PriorityQueue<AStarEdge> prioQueueOpenSet,
+                            TIntObjectMap<AStarEdge> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
     {
 
         int currNode = currEdge.adjNode;
@@ -246,39 +251,36 @@ private void fillEdges( AStarEdge currEdge, GHPoint goal,
             int traversalId = traversalMode.createTraversalId(iter, reverse);
             // TODO performance: check if the node is already existent in the opposite direction
             // then we could avoid the approximation as we already know the exact complete path!
-            double alreadyVisitedWeight = weighting.calcWeight(iter, reverse, currEdge.edge) + currEdge.weightToCompare;
+            float alreadyVisitedWeight = (float) (weighting.calcWeight(iter, reverse, currEdge.edge)
+                    + currEdge.weightOfVisitedPath);
             if (Double.isInfinite(alreadyVisitedWeight))
-                    continue;
-            
-            AStarEdge aee = shortestWeightMap.get(traversalId);
-            if (aee == null || aee.weightToCompare > alreadyVisitedWeight)
+                continue;
+
+            AStarEdge ase = shortestWeightMap.get(traversalId);
+            if (ase == null || ase.weightOfVisitedPath > alreadyVisitedWeight)
             {
-                double tmpLat = nodeAccess.getLatitude(neighborNode);
-                double tmpLon = nodeAccess.getLongitude(neighborNode);
-                double currWeightToGoal = dist.calcDist(goal.lat, goal.lon, tmpLat, tmpLon);
-                currWeightToGoal = weighting.getMinWeight(currWeightToGoal);
+                double currWeightToGoal = weightApprox.approximate(neighborNode, reverse);
                 double estimationFullDist = alreadyVisitedWeight + currWeightToGoal;
-                if (aee == null)
+                if (ase == null)
                 {
-                    aee = new AStarEdge(iter.getEdge(), neighborNode, estimationFullDist, alreadyVisitedWeight);
-                    shortestWeightMap.put(traversalId, aee);
-                } else if (aee.weight > estimationFullDist)
-                {
-                    prioQueueOpenSet.remove(aee);
-                    aee.edge = iter.getEdge();
-                    aee.weight = estimationFullDist;
-                    aee.weightToCompare = alreadyVisitedWeight;
+                    ase = new AStarEdge(iter.getEdge(), neighborNode, estimationFullDist, alreadyVisitedWeight);
+                    shortestWeightMap.put(traversalId, ase);
                 } else
-                    continue;
+                {
+                    assert (ase.weight > estimationFullDist) : "Inconsistent distance estimate";
+                    prioQueueOpenSet.remove(ase);
+                    ase.edge = iter.getEdge();
+                    ase.weight = estimationFullDist;
+                    ase.weightOfVisitedPath = alreadyVisitedWeight;
+                }
 
-                aee.parent = currEdge;
-                prioQueueOpenSet.add(aee);
-                updateBestPath(iter, aee, traversalId);
+                ase.parent = currEdge;
+                prioQueueOpenSet.add(ase);
+                updateBestPath(iter, ase, traversalId);
             }
         }
     }
 
-//    @Override -> TODO use only weight => then a simple EdgeEntry is possible
     public void updateBestPath( EdgeIteratorState edgeState, AStarEdge entryCurrent, int currLoc )
     {
         AStarEdge entryOther = bestWeightMapOther.get(currLoc);
@@ -287,7 +289,7 @@ public void updateBestPath( EdgeIteratorState edgeState, AStarEdge entryCurrent,
 
         boolean reverse = bestWeightMapFrom == bestWeightMapOther;
         // update 
-        double newWeight = entryCurrent.weightToCompare + entryOther.weightToCompare;
+        double newWeight = entryCurrent.weightOfVisitedPath + entryOther.weightOfVisitedPath;
         if (traversalMode.isEdgeBased())
         {
             if (entryOther.edge != entryCurrent.edge)
@@ -318,6 +320,6 @@ public void updateBestPath( EdgeIteratorState edgeState, AStarEdge entryCurrent,
     @Override
     public String getName()
     {
-        return "astarbi";
+        return AlgorithmOptions.ASTAR_BI;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
index c2fb75debd..c0c2fcd0f0 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
@@ -40,7 +40,9 @@
 
     protected abstract Path createAndInitPath();
 
-    abstract void checkState( int fromBase, int fromAdj, int toBase, int toAdj );
+    protected abstract double getCurrentFromWeight();
+
+    protected abstract double getCurrentToWeight();
 
     abstract boolean fillEdgesFrom();
 
@@ -62,15 +64,23 @@ public Path calcPath( int from, int to )
         return extractPath();
     }
 
-    void runAlgo()
+    protected void runAlgo()
     {
-        while (!finished())
+        while (!finished() && !isWeightLimitExceeded())
         {
-            if (!finishedFrom)
+            if (!finishedFrom && !finishedTo)
+            {
+                if (getCurrentFromWeight() < getCurrentToWeight())
+                    finishedFrom = !fillEdgesFrom();
+                else
+                    finishedTo = !fillEdgesTo();
+            } else if (!finishedFrom)
+            {
                 finishedFrom = !fillEdgesFrom();
-
-            if (!finishedTo)
+            } else
+            {
                 finishedTo = !fillEdgesTo();
+            }
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
index 828a3628d3..e52e24dd5a 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
@@ -21,27 +21,24 @@
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 
-import java.util.ArrayList;
-import java.util.List;
-
 /**
  * @author Peter Karich
  */
 public abstract class AbstractRoutingAlgorithm implements RoutingAlgorithm
 {
     private EdgeFilter additionalEdgeFilter;
-    protected Graph graph;
+    protected final Graph graph;
     protected NodeAccess nodeAccess;
     protected EdgeExplorer inEdgeExplorer;
     protected EdgeExplorer outEdgeExplorer;
     protected final Weighting weighting;
     protected final FlagEncoder flagEncoder;
     protected final TraversalMode traversalMode;
+    protected double weightLimit = Double.MAX_VALUE;
     private boolean alreadyRun;
 
     /**
@@ -55,37 +52,16 @@ public AbstractRoutingAlgorithm( Graph graph, FlagEncoder encoder, Weighting wei
         this.weighting = weighting;
         this.flagEncoder = encoder;
         this.traversalMode = traversalMode;
-        setGraph(graph);
-    }
-
-    /**
-     * Specify the graph on which this algorithm should operate. API glitch: this method overwrites
-     * graph specified while constructing the algorithm. Only necessary if graph is a QueryGraph.
-     */
-    protected RoutingAlgorithm setGraph( Graph graph )
-    {
         this.graph = graph;
         this.nodeAccess = graph.getNodeAccess();
         outEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, false, true));
         inEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, true, false));
-        return this;
-    }
-
-    protected QueryGraph createQueryGraph()
-    {
-        return new QueryGraph(graph);
     }
 
     @Override
-    public Path calcPath( QueryResult fromRes, QueryResult toRes )
+    public void setWeightLimit( double weight )
     {
-        QueryGraph queryGraph = createQueryGraph();
-        List<QueryResult> results = new ArrayList<QueryResult>(2);
-        results.add(fromRes);
-        results.add(toRes);
-        queryGraph.lookup(results);
-        setGraph(queryGraph);
-        return calcPath(fromRes.getClosestNode(), toRes.getClosestNode());
+        this.weightLimit = weight;
     }
 
     public RoutingAlgorithm setEdgeFilter( EdgeFilter additionalEdgeFilter )
@@ -114,9 +90,9 @@ protected void checkAlreadyRun()
         alreadyRun = true;
     }
 
-    protected EdgeEntry createEdgeEntry( int node, double dist )
+    protected EdgeEntry createEdgeEntry( int node, double weight )
     {
-        return new EdgeEntry(EdgeIterator.NO_EDGE, node, dist);
+        return new EdgeEntry(EdgeIterator.NO_EDGE, node, weight);
     }
 
     /**
@@ -135,6 +111,8 @@ protected EdgeEntry createEdgeEntry( int node, double dist )
      */
     protected abstract Path extractPath();
 
+    protected abstract boolean isWeightLimitExceeded();
+
     protected Path createEmptyPath()
     {
         return new Path(graph, flagEncoder);
diff --git a/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java b/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
new file mode 100644
index 0000000000..433ff9cff8
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
@@ -0,0 +1,194 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.util.PMap;
+
+/**
+ * The algorithm options. Create an immutable object via:
+ * <pre>
+ * AlgorithmOptions algoOpts = AlgorithmOptions.start().
+ *        algorithm(AlgorithmOptions.DIJKSTRA).
+ *        weighting(weighting).
+ *        build();
+ * </pre>
+ * <p/>
+ * @author Peter Karich
+ */
+public class AlgorithmOptions
+{
+    /**
+     * Bidirectional Dijkstra
+     */
+    public static final String DIJKSTRA_BI = "dijkstrabi";
+    /**
+     * Unidirectional Dijkstra
+     */
+    public static final String DIJKSTRA = "dijkstra";
+    /**
+     * one to many Dijkstra
+     */
+    public static final String DIJKSTRA_ONE_TO_MANY = "dijkstraOneToMany";
+    /**
+     * Unidirectional A*
+     */
+    public static final String ASTAR = "astar";
+    /**
+     * Bidirectional A*
+     */
+    public static final String ASTAR_BI = "astarbi";
+    private String algorithm = DIJKSTRA_BI;
+    private Weighting weighting;
+    private TraversalMode traversalMode = TraversalMode.NODE_BASED;
+    private FlagEncoder flagEncoder;
+    private final PMap hints = new PMap(5);
+
+    private AlgorithmOptions()
+    {
+    }
+
+    /**
+     * Default traversal mode NODE_BASED is used.
+     */
+    public AlgorithmOptions( String algorithm, FlagEncoder flagEncoder, Weighting weighting )
+    {
+        this.algorithm = algorithm;
+        this.weighting = weighting;
+        this.flagEncoder = flagEncoder;
+    }
+
+    public AlgorithmOptions( String algorithm, FlagEncoder flagEncoder, Weighting weighting, TraversalMode tMode )
+    {
+        this.algorithm = algorithm;
+        this.weighting = weighting;
+        this.flagEncoder = flagEncoder;
+        this.traversalMode = tMode;
+    }
+
+    /**
+     * @return the traversal mode, where node-based is the default.
+     */
+    public TraversalMode getTraversalMode()
+    {
+        return traversalMode;
+    }
+
+    public Weighting getWeighting()
+    {
+        assertNotNull(weighting, "weighting");
+        return weighting;
+    }
+
+    public String getAlgorithm()
+    {
+        assertNotNull(algorithm, "algorithm");
+        return algorithm;
+    }
+
+    public FlagEncoder getFlagEncoder()
+    {
+        assertNotNull(flagEncoder, "flagEncoder");
+        return flagEncoder;
+    }
+
+    public PMap getHints()
+    {
+        return hints;
+    }
+
+    private void assertNotNull( Object optionValue, String optionName )
+    {
+        if (optionValue == null)
+            throw new NullPointerException("Option '" + optionName + "' must NOT be null");
+    }
+
+    @Override
+    public String toString()
+    {
+        return algorithm + ", " + weighting + ", " + flagEncoder + ", " + traversalMode;
+    }
+
+    /**
+     * This method starts the building process for AlgorithmOptions.
+     */
+    public static Builder start()
+    {
+        return new Builder();
+    }
+
+    /**
+     * This method clones the specified AlgorithmOption object with the possibility for further
+     * changes.
+     */
+    public static Builder start( AlgorithmOptions opts )
+    {
+        Builder b = new Builder();
+        if (opts.algorithm != null)
+            b.algorithm(opts.getAlgorithm());
+        if (opts.flagEncoder != null)
+            b.flagEncoder(opts.getFlagEncoder());
+        if (opts.traversalMode != null)
+            b.traversalMode(opts.getTraversalMode());
+        if (opts.weighting != null)
+            b.weighting(opts.getWeighting());
+        return b;
+    }
+
+    public static class Builder
+    {
+        private final AlgorithmOptions opts = new AlgorithmOptions();
+
+        public Builder traversalMode( TraversalMode traversalMode )
+        {
+            if (traversalMode == null)
+                throw new IllegalArgumentException("null as traversal mode is not allowed");
+
+            this.opts.traversalMode = traversalMode;
+            return this;
+        }
+
+        public Builder weighting( Weighting weighting )
+        {
+            this.opts.weighting = weighting;
+            return this;
+        }
+
+        /**
+         * For possible values see AlgorithmOptions.*
+         */
+        public Builder algorithm( String algorithm )
+        {
+            this.opts.algorithm = algorithm;
+            return this;
+        }
+
+        public Builder flagEncoder( FlagEncoder flagEncoder )
+        {
+            this.opts.flagEncoder = flagEncoder;
+            return this;
+        }
+
+        public AlgorithmOptions build()
+        {
+            return opts;
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/Dijkstra.java b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
index a29522753e..f207b85e86 100644
--- a/core/src/main/java/com/graphhopper/routing/Dijkstra.java
+++ b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
@@ -38,11 +38,11 @@
  */
 public class Dijkstra extends AbstractRoutingAlgorithm
 {
-    private TIntObjectMap<EdgeEntry> fromMap;
-    private PriorityQueue<EdgeEntry> fromHeap;
+    protected TIntObjectMap<EdgeEntry> fromMap;
+    protected PriorityQueue<EdgeEntry> fromHeap;
+    protected EdgeEntry currEdge;
     private int visitedNodes;
     private int to = -1;
-    private EdgeEntry currEdge;
 
     public Dijkstra( Graph g, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
@@ -66,16 +66,17 @@ public Path calcPath( int from, int to )
         {
             fromMap.put(from, currEdge);
         }
-        return runAlgo();
+        runAlgo();
+        return extractPath();
     }
 
-    private Path runAlgo()
+    protected void runAlgo()
     {
         EdgeExplorer explorer = outEdgeExplorer;
         while (true)
         {
             visitedNodes++;
-            if (finished())
+            if (isWeightLimitExceeded() || finished())
                 break;
 
             int startNode = currEdge.adjNode;
@@ -111,13 +112,12 @@ private Path runAlgo()
             }
 
             if (fromHeap.isEmpty())
-                return createEmptyPath();
+                break;
 
             currEdge = fromHeap.poll();
             if (currEdge == null)
                 throw new AssertionError("Empty edge cannot happen");
         }
-        return extractPath();
     }
 
     @Override
@@ -129,20 +129,27 @@ protected boolean finished()
     @Override
     protected Path extractPath()
     {
-        if (currEdge == null || !finished())
+        if (currEdge == null || isWeightLimitExceeded() || !finished())
             return createEmptyPath();
+
         return new Path(graph, flagEncoder).setWeight(currEdge.weight).setEdgeEntry(currEdge).extract();
     }
 
     @Override
-    public String getName()
+    public int getVisitedNodes()
+    {
+        return visitedNodes;
+    }
+
+    @Override
+    protected boolean isWeightLimitExceeded()
     {
-        return "dijkstra";
+        return currEdge.weight > weightLimit;
     }
 
     @Override
-    public int getVisitedNodes()
+    public String getName()
     {
-        return visitedNodes;
+        return AlgorithmOptions.DIJKSTRA;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
index b17472b455..0b770831d9 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
@@ -37,7 +37,6 @@
  * <p/>
  * 'Ref' stands for reference implementation and is using the normal Java-'reference'-way.
  * <p/>
- * @see DijkstraBidirection for an array based but more complicated version
  * @author Peter Karich
  */
 public class DijkstraBidirectionRef extends AbstractBidirAlgo
@@ -68,9 +67,9 @@ protected void initCollections( int nodes )
     }
 
     @Override
-    public void initFrom( int from, double dist )
+    public void initFrom( int from, double weight )
     {
-        currFrom = createEdgeEntry(from, dist);
+        currFrom = createEdgeEntry(from, weight);
         openSetFrom.add(currFrom);
         if (!traversalMode.isEdgeBased())
         {
@@ -84,6 +83,9 @@ public void initFrom( int from, double dist )
         {
             if (currTo != null && currTo.adjNode == from)
             {
+                // special case of identical start and end
+                bestPath.edgeEntry = currFrom;
+                bestPath.edgeTo = currTo;
                 finishedFrom = true;
                 finishedTo = true;
             }
@@ -91,9 +93,9 @@ public void initFrom( int from, double dist )
     }
 
     @Override
-    public void initTo( int to, double dist )
+    public void initTo( int to, double weight )
     {
-        currTo = createEdgeEntry(to, dist);
+        currTo = createEdgeEntry(to, weight);
         openSetTo.add(currTo);
         if (!traversalMode.isEdgeBased())
         {
@@ -107,6 +109,9 @@ public void initTo( int to, double dist )
         {
             if (currFrom != null && currFrom.adjNode == to)
             {
+                // special case of identical start and end
+                bestPath.edgeEntry = currFrom;
+                bestPath.edgeTo = currTo;
                 finishedFrom = true;
                 finishedTo = true;
             }
@@ -123,14 +128,22 @@ protected Path createAndInitPath()
     @Override
     protected Path extractPath()
     {
-        return bestPath.extract();
+        if (finished())
+            return bestPath.extract();
+
+        return bestPath;
+    }
+
+    @Override
+    protected double getCurrentFromWeight()
+    {
+        return currFrom.weight;
     }
 
     @Override
-    void checkState( int fromBase, int fromAdj, int toBase, int toAdj )
+    protected double getCurrentToWeight()
     {
-        if (bestWeightMapFrom.isEmpty() || bestWeightMapTo.isEmpty())
-            throw new IllegalStateException("Either 'from'-edge or 'to'-edge is inaccessible. From:" + bestWeightMapFrom + ", to:" + bestWeightMapTo);
+        return currTo.weight;
     }
 
     @Override
@@ -171,8 +184,14 @@ public boolean finished()
         return currFrom.weight + currTo.weight >= bestPath.getWeight();
     }
 
+    @Override
+    protected boolean isWeightLimitExceeded()
+    {
+        return currFrom.weight + currTo.weight > weightLimit;
+    }
+
     void fillEdges( EdgeEntry currEdge, PriorityQueue<EdgeEntry> prioQueue,
-            TIntObjectMap<EdgeEntry> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
+                    TIntObjectMap<EdgeEntry> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
     {
         int currNode = currEdge.adjNode;
         EdgeIterator iter = explorer.setBaseNode(currNode);
@@ -246,12 +265,6 @@ protected void updateBestPath( EdgeIteratorState edgeState, EdgeEntry entryCurre
         }
     }
 
-    @Override
-    public String getName()
-    {
-        return "dijkstrabi";
-    }
-
     TIntObjectMap<EdgeEntry> getBestFromMap()
     {
         return bestWeightMapFrom;
@@ -296,4 +309,10 @@ void setBestPath( PathBidirRef bestPath )
     {
         this.bestPath = bestPath;
     }
+
+    @Override
+    public String getName()
+    {
+        return AlgorithmOptions.DIJKSTRA_BI;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
index 4b4b4280e6..a114e7b61b 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
@@ -22,10 +22,10 @@
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
 import gnu.trove.list.array.TIntArrayList;
+
 import java.util.Arrays;
 
 /**
@@ -45,7 +45,6 @@
     private IntDoubleBinHeap heap;
     private int visitedNodes;
     private boolean doClear = true;
-    private double limitWeight = Double.MAX_VALUE;
     private int limitVisitedNodes = Integer.MAX_VALUE;
     private int endNode;
     private int currNode, fromNode, to;
@@ -68,24 +67,12 @@ public DijkstraOneToMany( Graph graph, FlagEncoder encoder, Weighting weighting,
         changedNodes = new TIntArrayListWithCap();
     }
 
-    public DijkstraOneToMany setLimitWeight( double weight )
-    {
-        limitWeight = weight;
-        return this;
-    }
-
     public DijkstraOneToMany setLimitVisitedNodes( int nodes )
     {
         this.limitVisitedNodes = nodes;
         return this;
     }
 
-    @Override
-    public Path calcPath( QueryResult fromRes, QueryResult toRes )
-    {
-        throw new IllegalStateException("not supported yet");
-    }
-
     @Override
     public Path calcPath( int from, int to )
     {
@@ -101,8 +88,9 @@ public Path extractPath()
         if (endNode >= 0)
             p.setWeight(weights[endNode]);
         p.setFromNode(fromNode);
-        if (endNode < 0)
+        if (endNode < 0 || isWeightLimitExceeded())
             return p;
+
         return p.setEndNode(endNode).extract();
     }
 
@@ -151,7 +139,7 @@ public int findEndNode( int from, int to )
         {
             // Cached! Re-use existing data structures
             int parentNode = parents[to];
-            if (parentNode != EMPTY_PARENT && weights[to] < weights[currNode])
+            if (parentNode != EMPTY_PARENT && weights[to] <= weights[currNode])
                 return to;
 
             if (heap.isEmpty() || visitedNodes >= limitVisitedNodes)
@@ -170,7 +158,7 @@ public int findEndNode( int from, int to )
             EdgeIterator iter = outEdgeExplorer.setBaseNode(currNode);
             while (iter.next())
             {
-                int adjNode = iter.getAdjNode();                
+                int adjNode = iter.getAdjNode();
                 int prevEdgeId = edgeIds[adjNode];
                 if (!accept(iter, prevEdgeId))
                     continue;
@@ -198,7 +186,7 @@ public int findEndNode( int from, int to )
                 }
             }
 
-            if (heap.isEmpty() || visitedNodes >= limitVisitedNodes)
+            if (heap.isEmpty() || visitedNodes >= limitVisitedNodes || isWeightLimitExceeded())
                 return NOT_FOUND;
 
             // calling just peek and not poll is important if the next query is cached
@@ -213,7 +201,13 @@ public int findEndNode( int from, int to )
     @Override
     public boolean finished()
     {
-        return weights[currNode] >= limitWeight || currNode == to;
+        return currNode == to;
+    }
+
+    @Override
+    protected boolean isWeightLimitExceeded()
+    {
+        return weights[currNode] > weightLimit;
     }
 
     public void close()
@@ -233,7 +227,7 @@ public int getVisitedNodes()
     @Override
     public String getName()
     {
-        return "dijkstraOneToMany";
+        return AlgorithmOptions.DIJKSTRA_ONE_TO_MANY;
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 3ce1072cd2..49137f0146 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
@@ -24,6 +25,7 @@
 import com.graphhopper.util.*;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -34,6 +36,7 @@
  * <p/>
  * @author Peter Karich
  * @author Ottavio Campana
+ * @author jan soe
  */
 public class Path
 {
@@ -43,15 +46,13 @@
     protected double distance;
     // we go upwards (via EdgeEntry.parent) from the goal node to the origin node
     protected boolean reverseOrder = true;
-    protected long millis;
+    protected long time;
     private boolean found;
     protected EdgeEntry edgeEntry;
     final StopWatch extractSW = new StopWatch("extract");
     private int fromNode = -1;
     protected int endNode = -1;
     private TIntList edgeIds;
-    private PointList cachedPoints;
-    private InstructionList cachedWays;
     private double weight;
     private NodeAccess nodeAccess;
 
@@ -142,10 +143,19 @@ public double getDistance()
 
     /**
      * @return time in millis
+     * @deprecated use getTime instead
      */
     public long getMillis()
     {
-        return millis;
+        return time;
+    }
+
+    /**
+     * @return time in millis
+     */
+    public long getTime()
+    {
+        return time;
     }
 
     /**
@@ -185,6 +195,14 @@ public Path extract()
         return setFound(true);
     }
 
+    /**
+     * Yields the final edge of the path
+     */
+    public EdgeIteratorState getFinalEdge()
+    {
+        return graph.getEdgeProps(edgeIds.get(edgeIds.size() - 1), endNode);
+    }
+
     /**
      * @return the time it took to extract the path in nano (!) seconds
      */
@@ -206,7 +224,7 @@ protected void processEdge( int edgeId, int adjNode )
         EdgeIteratorState iter = graph.getEdgeProps(edgeId, adjNode);
         double dist = iter.getDistance();
         distance += dist;
-        millis += calcMillis(dist, iter.getFlags(), false);
+        time += calcMillis(dist, iter.getFlags(), false);
         addEdge(edgeId);
     }
 
@@ -216,15 +234,18 @@ protected void processEdge( int edgeId, int adjNode )
      */
     protected long calcMillis( double distance, long flags, boolean revert )
     {
-        if (revert && !encoder.isBool(flags, FlagEncoder.K_BACKWARD)
-                || !revert && !encoder.isBool(flags, FlagEncoder.K_FORWARD))
+        if (revert && !encoder.isBackward(flags)
+                || !revert && !encoder.isForward(flags))
             throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. "
-                    + "Reverse:" + revert + ", fwd:" + encoder.isBool(flags, FlagEncoder.K_FORWARD) + ", bwd:" + encoder.isBool(flags, FlagEncoder.K_BACKWARD));
+                    + "Reverse:" + revert + ", fwd:" + encoder.isForward(flags) + ", bwd:" + encoder.isBackward(flags));
 
         double speed = revert ? encoder.getReverseSpeed(flags) : encoder.getSpeed(flags);
         if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
             throw new IllegalStateException("Invalid speed stored in edge! " + speed);
 
+        if (speed == 0)
+            throw new IllegalStateException("Speed cannot be 0 for unblocked edge, use access properties to mark edge blocked! Should only occur for shortest path calculation. See #242.");
+
         return (long) (distance * 3600 / speed);
     }
 
@@ -239,7 +260,7 @@ protected long calcMillis( double distance, long flags, boolean revert )
     /**
      * Iterates over all edges in this path sorted from start to end and calls the visitor callback
      * for every edge.
-     * <p>
+     * <p/>
      * @param visitor callback to handle every edge. The edge is decoupled from the iterator and can
      * be stored.
      */
@@ -255,7 +276,7 @@ private void forEveryEdge( EdgeVisitor visitor )
                         + ", array index:" + i + ", edges:" + edgeIds.size());
 
             tmpNode = edgeBase.getBaseNode();
-            // later: more efficient swap
+            // more efficient swap, currently not implemented for virtual edges: visitor.next(edgeBase.detach(true), i);
             edgeBase = graph.getEdgeProps(edgeBase.getEdge(), tmpNode);
             visitor.next(edgeBase, i);
         }
@@ -288,7 +309,13 @@ public TIntList calcNodes()
     {
         final TIntArrayList nodes = new TIntArrayList(edgeIds.size() + 1);
         if (edgeIds.isEmpty())
+        {
+            if (isFound())
+            {
+                nodes.add(endNode);
+            }
             return nodes;
+        }
 
         int tmpNode = getFromNode();
         nodes.add(tmpNode);
@@ -305,20 +332,23 @@ public void next( EdgeIteratorState eb, int i )
 
     /**
      * This method calculated a list of points for this path
-     * <p>
-     * @return this path its geometry (cached)
+     * <p/>
+     * @return this path its geometry
      */
     public PointList calcPoints()
     {
-        if (cachedPoints != null)
-            return cachedPoints;
-
-        cachedPoints = new PointList(edgeIds.size() + 1, nodeAccess.is3D());
+        final PointList points = new PointList(edgeIds.size() + 1, nodeAccess.is3D());
         if (edgeIds.isEmpty())
-            return cachedPoints;
+        {
+            if (isFound())
+            {
+                points.add(graph.getNodeAccess(), endNode);
+            }
+            return points;
+        }
 
         int tmpNode = getFromNode();
-        cachedPoints.add(nodeAccess, tmpNode);
+        points.add(nodeAccess, tmpNode);
         forEveryEdge(new EdgeVisitor()
         {
             @Override
@@ -327,11 +357,11 @@ public void next( EdgeIteratorState eb, int index )
                 PointList pl = eb.fetchWayGeometry(2);
                 for (int j = 0; j < pl.getSize(); j++)
                 {
-                    cachedPoints.add(pl, j);
+                    points.add(pl, j);
                 }
             }
         });
-        return cachedPoints;
+        return points;
     }
 
     /**
@@ -339,9 +369,15 @@ public void next( EdgeIteratorState eb, int index )
      */
     public InstructionList calcInstructions( final Translation tr )
     {
-        cachedWays = new InstructionList(edgeIds.size() / 4, tr);
+        final InstructionList ways = new InstructionList(edgeIds.size() / 4, tr);
         if (edgeIds.isEmpty())
-            return cachedWays;
+        {
+            if (isFound())
+            {
+                ways.add(new FinishInstruction(nodeAccess, endNode));
+            }
+            return ways;
+        }
 
         final int tmpNode = getFromNode();
         forEveryEdge(new EdgeVisitor()
@@ -368,22 +404,29 @@ public InstructionList calcInstructions( final Translation tr )
              */
             private double prevLat = nodeAccess.getLatitude(tmpNode);
             private double prevLon = nodeAccess.getLongitude(tmpNode);
+            private double doublePrevLat, doublePrevLong; // Lat and Lon of node t-2
+            private int prevNode = -1;
             private double prevOrientation;
             private Instruction prevInstruction;
-            private PointList points = new PointList(10, nodeAccess.is3D());
-            private String name = null;
-            private InstructionAnnotation annotation;
+            private boolean prevInRoundabout = false;
+            private String name, prevName = null;
+            private InstructionAnnotation annotation, prevAnnotation;
+            private EdgeExplorer outEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
 
             @Override
             public void next( EdgeIteratorState edge, int index )
             {
                 // baseNode is the current node and adjNode is the next
                 int adjNode = edge.getAdjNode();
+                int baseNode = edge.getBaseNode();
                 long flags = edge.getFlags();
                 double adjLat = nodeAccess.getLatitude(adjNode);
                 double adjLon = nodeAccess.getLongitude(adjNode);
                 double latitude, longitude;
+
                 PointList wayGeo = edge.fetchWayGeometry(3);
+                boolean isRoundabout = encoder.isBool(flags, encoder.K_ROUNDABOUT);
+
                 if (wayGeo.getSize() <= 2)
                 {
                     latitude = adjLat;
@@ -392,87 +435,178 @@ public void next( EdgeIteratorState edge, int index )
                 {
                     latitude = wayGeo.getLatitude(1);
                     longitude = wayGeo.getLongitude(1);
-
-                    // overwrite previous lat,lon
-                    int baseNode = edge.getBaseNode();
-                    prevLat = nodeAccess.getLatitude(baseNode);
-                    prevLon = nodeAccess.getLongitude(baseNode);
+                    assert java.lang.Double.compare(prevLat, nodeAccess.getLatitude(baseNode)) == 0;
+                    assert java.lang.Double.compare(prevLon, nodeAccess.getLongitude(baseNode)) == 0;
                 }
 
-                double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
-                if (name == null)
+                name = edge.getName();
+                annotation = encoder.getAnnotation(flags, tr);
+
+                if ((prevName == null) && (!isRoundabout)) // very first instruction (if not in Roundabout)
                 {
-                    // very first instruction
-                    name = edge.getName();
-                    annotation = encoder.getAnnotation(flags, tr);
-                    prevInstruction = new Instruction(Instruction.CONTINUE_ON_STREET, name, annotation, points);
-                    updatePointsAndInstruction(edge, wayGeo);
-                    cachedWays.add(prevInstruction);
+                    int sign = Instruction.CONTINUE_ON_STREET;
+                    prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
+                    ways.add(prevInstruction);
+                    prevName = name;
+                    prevAnnotation = annotation;
+
                 } else
                 {
-                    double tmpOrientation = ac.alignOrientation(prevOrientation, orientation);
-                    String tmpName = edge.getName();
-                    InstructionAnnotation tmpAnnotation = encoder.getAnnotation(flags, tr);
-                    if ((!name.equals(tmpName))
-                            || (!annotation.equals(tmpAnnotation)))
+                    if (isRoundabout)
+                    // remark: names and annotations within roundabout are ignored
+                    {
+                        if (!prevInRoundabout) //just entered roundabout
+                        {
+                            int sign = Instruction.USE_ROUNDABOUT;
+                            RoundaboutInstruction roundaboutInstruction = new RoundaboutInstruction(sign, name,
+                                    annotation, new PointList(10, nodeAccess.is3D()));
+                            if (prevName != null)
+                            {
+                                // check if there is an exit at the same node the roundabout was entered
+                                EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(baseNode);
+                                while (edgeIter.next())
+                                {
+                                    if ((edgeIter.getAdjNode() != prevNode)
+                                            && !encoder.isBool(edgeIter.getFlags(), FlagEncoder.K_ROUNDABOUT))
+                                    {
+                                        roundaboutInstruction.increaseExitNumber();
+                                        break;
+                                    }
+                                }
+
+                                // previous orientation is last orientation before entering roundabout
+                                prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+
+                                // calculate direction of entrance turn to determine direction of rotation
+                                // right turn == counterclockwise and vice versa
+                                double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                                orientation = ac.alignOrientation(prevOrientation, orientation);
+                                double delta = (orientation - prevOrientation);
+                                roundaboutInstruction.setDirOfRotation(delta);
+
+                            } else // first instructions is roundabout instruction
+                            {
+                                prevOrientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                                prevName = name;
+                                prevAnnotation = annotation;
+                            }
+                            prevInstruction = roundaboutInstruction;
+                            ways.add(prevInstruction);
+                        }
+
+                        // Add passed exits to instruction. A node is countet if there is at least one outgoing edge
+                        // out of the roundabout
+                        EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(adjNode);
+                        while (edgeIter.next())
+                        {
+                            if (!encoder.isBool(edgeIter.getFlags(), encoder.K_ROUNDABOUT))
+                            {
+                                ((RoundaboutInstruction) prevInstruction).increaseExitNumber();
+                                break;
+                            }
+                        }
+
+                    } else if (prevInRoundabout) //previously in roundabout but not anymore
+                    {
+
+                        prevInstruction.setName(name);
+
+                        // calc angle between roundabout entrance and exit
+                        double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double deltaInOut = (orientation - prevOrientation);
+
+                        // calculate direction of exit turn to determine direction of rotation
+                        // right turn == counterclockwise and vice versa
+                        double recentOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        orientation = ac.alignOrientation(recentOrientation, orientation);
+                        double deltaOut = (orientation - recentOrientation);
+
+                        prevInstruction = ((RoundaboutInstruction) prevInstruction)
+                                .setRadian(deltaInOut)
+                                .setDirOfRotation(deltaOut)
+                                .setExited();
+
+                        prevName = name;
+                        prevAnnotation = annotation;
+
+                    } else if ((!name.equals(prevName)) || (!annotation.equals(prevAnnotation)))
                     {
-                        points = new PointList(10, nodeAccess.is3D());
-                        name = tmpName;
-                        annotation = tmpAnnotation;
-                        double delta = Math.abs(tmpOrientation - prevOrientation);
+                        prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double delta = orientation - prevOrientation;
+                        double absDelta = Math.abs(delta);
                         int sign;
-                        if (delta < 0.2)
+
+                        if (absDelta < 0.2)
                         {
                             // 0.2 ~= 11
                             sign = Instruction.CONTINUE_ON_STREET;
 
-                        } else if (delta < 0.8)
+                        } else if (absDelta < 0.8)
                         {
                             // 0.8 ~= 40
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_SLIGHT_LEFT;
                             else
                                 sign = Instruction.TURN_SLIGHT_RIGHT;
 
-                        } else if (delta < 1.8)
+                        } else if (absDelta < 1.8)
                         {
                             // 1.8 ~= 103
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_LEFT;
                             else
                                 sign = Instruction.TURN_RIGHT;
 
                         } else
                         {
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_SHARP_LEFT;
                             else
                                 sign = Instruction.TURN_SHARP_RIGHT;
 
                         }
-
-                        prevInstruction = new Instruction(sign, name, annotation, points);
-                        cachedWays.add(prevInstruction);
+                        prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
+                        ways.add(prevInstruction);
+                        prevName = name;
+                        prevAnnotation = annotation;
                     }
-
-                    updatePointsAndInstruction(edge, wayGeo);
                 }
 
-                prevLat = adjLat;
-                prevLon = adjLon;
+                updatePointsAndInstruction(edge, wayGeo);
+
                 if (wayGeo.getSize() <= 2)
-                    prevOrientation = orientation;
-                else
+                {
+                    doublePrevLat = prevLat;
+                    doublePrevLong = prevLon;
+                } else
                 {
                     int beforeLast = wayGeo.getSize() - 2;
-                    prevOrientation = ac.calcOrientation(wayGeo.getLatitude(beforeLast), wayGeo.getLongitude(beforeLast),
-                            adjLat, adjLon);
+                    doublePrevLat = wayGeo.getLatitude(beforeLast);
+                    doublePrevLong = wayGeo.getLongitude(beforeLast);
                 }
 
+                prevInRoundabout = isRoundabout;
+                prevNode = baseNode;
+                prevLat = adjLat;
+                prevLon = adjLon;
+
                 boolean lastEdge = index == edgeIds.size() - 1;
                 if (lastEdge)
-                    cachedWays.add(new FinishInstruction(adjLat, adjLon,
-                            nodeAccess.is3D() ? nodeAccess.getElevation(adjNode) : 0));
+                {
+                    if (isRoundabout)
+                    {
+                        // calc angle between roundabout entrance and finish
+                        double orientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double delta = (orientation - prevOrientation);
+                        ((RoundaboutInstruction) prevInstruction).setRadian(delta);
+
+                    }
+                    ways.add(new FinishInstruction(nodeAccess, adjNode));
+                }
             }
 
             private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
@@ -481,7 +615,7 @@ private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
                 int len = pl.size() - 1;
                 for (int i = 0; i < len; i++)
                 {
-                    points.add(pl, i);
+                    prevInstruction.getPoints().add(pl, i);
                 }
                 double newDist = edge.getDistance();
                 prevInstruction.setDistance(newDist + prevInstruction.getDistance());
@@ -490,37 +624,7 @@ private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
             }
         });
 
-        return cachedWays;
-    }
-
-    public Instruction findInstruction( double lat, double lon )
-    {
-        DistanceCalcEarth distanceCalc = new DistanceCalcEarth();
-
-        double distanceToPath = Double.MAX_VALUE;
-
-        int nextInstrNumber = 0;
-
-        // Search the closest edge to the point
-        for (int i = 0; i < cachedWays.getSize() - 1; i++)
-        {
-            double edgeNodeLat1 = cachedWays.get(i).getPoints().getLatitude(0);
-            double edgeNodeLon1 = cachedWays.get(i).getPoints().getLongitude(0);
-            int node2NOP = cachedWays.get(i + 1).getPoints().getSize();
-            double edgeNodeLat2 = cachedWays.get(i + 1).getPoints().getLatitude(node2NOP - 1);
-            double edgeNodeLon2 = cachedWays.get(i + 1).getPoints().getLongitude(node2NOP - 1);
-
-            //Calculate the distance from the point to the edge
-            double distanceToEdge = distanceCalc.calcNormalizedEdgeDistance(lat, lon, edgeNodeLat1, edgeNodeLon1, edgeNodeLat2, edgeNodeLon2);
-
-            if (distanceToEdge < distanceToPath)
-            {
-                distanceToPath = distanceToEdge;
-                nextInstrNumber = i + 1;
-            }
-        }
-
-        return cachedWays.get(nextInstrNumber);
+        return ways;
     }
 
     @Override
@@ -539,6 +643,6 @@ public String toDetailsString()
 
             str += edgeIds.get(i);
         }
-        return toString() + ", " + str;
+        return toString() + ", found:" + isFound() + ", " + str;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidir.java b/core/src/main/java/com/graphhopper/routing/PathBidir.java
index 39cb980c28..09a27cad73 100644
--- a/core/src/main/java/com/graphhopper/routing/PathBidir.java
+++ b/core/src/main/java/com/graphhopper/routing/PathBidir.java
@@ -35,7 +35,7 @@
     private EdgeWrapper edgeWTo;
 
     public PathBidir( Graph g, FlagEncoder encoder,
-            EdgeWrapper edgesFrom, EdgeWrapper edgesTo )
+                      EdgeWrapper edgesFrom, EdgeWrapper edgesTo )
     {
         super(g, encoder);
         this.edgeWFrom = edgesFrom;
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
index 06717a6d82..3ae0152479 100644
--- a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
+++ b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
@@ -21,7 +21,6 @@
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.GHUtility;
 
 /**
  * This class creates a DijkstraPath from two Edge's resulting from a BidirectionalDijkstra
@@ -66,8 +65,6 @@ public Path extract()
         if (edgeEntry == null || edgeTo == null)
             return this;
 
-//        int from = GHUtility.getAdjNode(graph, edgeEntry.edge, );
-//        int to = GHUtility.getAdjNode(graph, edgeTo.edge, );
         if (edgeEntry.adjNode != edgeTo.adjNode)
             throw new IllegalStateException("Locations of the 'to'- and 'from'-Edge has to be the same." + toString() + ", fromEntry:" + edgeEntry + ", toEntry:" + edgeTo);
 
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index c92b2b64c6..0c7a41b8d8 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -20,13 +20,14 @@
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.GHPoint3D;
-
 import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.map.TIntObjectMap;
 import gnu.trove.map.hash.TIntObjectHashMap;
@@ -34,16 +35,14 @@
 import gnu.trove.procedure.TObjectProcedure;
 import gnu.trove.set.hash.TIntHashSet;
 
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
+import java.util.*;
 
 /**
  * A class which is used to query the underlying graph with real GPS points. It does so by
  * introducing virtual nodes and edges. It is lightweight in order to be created every time a new
  * query comes in, which makes the behaviour thread safe.
  * <p/>
+ *
  * @author Peter Karich
  */
 public class QueryGraph implements Graph
@@ -52,26 +51,62 @@
     private final NodeAccess mainNodeAccess;
     private final int mainNodes;
     private final int mainEdges;
+    private final QueryGraph baseGraph;
+    private final GraphExtension wrappedExtension;
     private List<QueryResult> queryResults;
     /**
      * Virtual edges are created between existing graph and new virtual tower nodes. For every
      * virtual node there are 4 edges: base-snap, snap-base, snap-adj, adj-snap.
      */
-    private List<EdgeIteratorState> virtualEdges;
-    private final static int VE_BASE = 0, VE_BASE_REV = 1, VE_ADJ = 2, VE_ADJ_REV = 3;
+    List<VirtualEdgeIteratorState> virtualEdges;
+    final static int VE_BASE = 0, VE_BASE_REV = 1, VE_ADJ = 2, VE_ADJ_REV = 3;
 
     /**
      * Store lat,lon of virtual tower nodes.
      */
     private PointList virtualNodes;
-    private final DistanceCalc distCalc = new DistancePlaneProjection();
+    private static final AngleCalc ac = new AngleCalc();
+    private List<VirtualEdgeIteratorState> modifiedEdges = new ArrayList<VirtualEdgeIteratorState>(5);
 
     public QueryGraph( Graph graph )
     {
         mainGraph = graph;
         mainNodeAccess = graph.getNodeAccess();
         mainNodes = graph.getNodes();
-        mainEdges = graph.getAllEdges().getMaxId();
+        mainEdges = graph.getAllEdges().getCount();
+
+        if (mainGraph.getExtension() instanceof TurnCostExtension)
+            wrappedExtension = new QueryGraphTurnExt(this);
+        else
+            wrappedExtension = mainGraph.getExtension();
+
+        // create very lightweight QueryGraph which uses variables from this QueryGraph (same virtual edges)
+        baseGraph = new QueryGraph(graph.getBaseGraph(), this);
+    }
+
+    /**
+     * See 'lookup' for further variables that are initialized
+     */
+    private QueryGraph( Graph graph, QueryGraph superQueryGraph )
+    {
+        mainGraph = graph;
+        baseGraph = this;
+        wrappedExtension = superQueryGraph.wrappedExtension;
+        mainNodeAccess = graph.getNodeAccess();
+        mainNodes = superQueryGraph.mainNodes;
+        mainEdges = superQueryGraph.mainEdges;
+    }
+
+    /**
+     * Convenient method to initialize this QueryGraph with the two specified query results.
+     */
+    public QueryGraph lookup( QueryResult fromRes, QueryResult toRes )
+    {
+        List<QueryResult> results = new ArrayList<QueryResult>(2);
+        results.add(fromRes);
+        results.add(toRes);
+        lookup(results);
+        return this;
     }
 
     /**
@@ -83,9 +118,13 @@ public void lookup( List<QueryResult> resList )
         if (isInitialized())
             throw new IllegalStateException("Call lookup only once. Otherwise you'll have problems for queries sharing the same edge.");
 
-        virtualEdges = new ArrayList<EdgeIteratorState>(resList.size() * 2);
+        // initialize all none-final variables
+        virtualEdges = new ArrayList<VirtualEdgeIteratorState>(resList.size() * 2);
         virtualNodes = new PointList(resList.size(), mainNodeAccess.is3D());
         queryResults = new ArrayList<QueryResult>(resList.size());
+        baseGraph.virtualEdges = virtualEdges;
+        baseGraph.virtualNodes = virtualNodes;
+        baseGraph.queryResults = queryResults;
 
         TIntObjectMap<List<QueryResult>> edge2res = new TIntObjectHashMap<List<QueryResult>>(resList.size());
 
@@ -94,10 +133,13 @@ public void lookup( List<QueryResult> resList )
         for (QueryResult res : resList)
         {
             // Do not create virtual node for a query result if it is directly on a tower node or not found
-            EdgeIteratorState closestEdge = res.getClosestEdge();
-            if (res.getSnappedPosition() == QueryResult.Position.TOWER || closestEdge == null)
+            if (res.getSnappedPosition() == QueryResult.Position.TOWER)
                 continue;
 
+            EdgeIteratorState closestEdge = res.getClosestEdge();
+            if (closestEdge == null)
+                throw new IllegalStateException("Do not call QueryGraph.lookup with invalid QueryResult " + res);
+
             int base = closestEdge.getBaseNode();
 
             // Force the identical direction for all closest edges. 
@@ -167,8 +209,8 @@ public int compare( QueryResult o1, QueryResult o2 )
 
                             double fromLat = fullPL.getLatitude(o1.getWayIndex());
                             double fromLon = fullPL.getLongitude(o1.getWayIndex());
-                            if (distCalc.calcNormalizedDist(fromLat, fromLon, p1.lat, p1.lon)
-                                    > distCalc.calcNormalizedDist(fromLat, fromLon, p2.lat, p2.lon))
+                            if (Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, p1.lat, p1.lon)
+                                    > Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, p2.lat, p2.lon))
                                 return 1;
                             return -1;
                         }
@@ -178,54 +220,124 @@ public int compare( QueryResult o1, QueryResult o2 )
 
                 GHPoint3D prevPoint = fullPL.toGHPoint(0);
                 int adjNode = closestEdge.getAdjNode();
+                int origTraversalKey = GHUtility.createEdgeKey(baseNode, adjNode, closestEdge.getEdge(), false);
+                int origRevTraversalKey = GHUtility.createEdgeKey(baseNode, adjNode, closestEdge.getEdge(), true);
                 long reverseFlags = closestEdge.detach(true).getFlags();
                 int prevWayIndex = 1;
                 int prevNodeId = baseNode;
-                int counter = 0;
                 int virtNodeId = virtualNodes.getSize() + mainNodes;
-                // Create base and adjacent PointLists for all virtual nodes!
+                boolean addedEdges = false;
+
+                // Create base and adjacent PointLists for all none-equal virtual nodes.
                 // We do so via inserting them at the correct position of fullPL and cutting the                
                 // fullPL into the right pieces.
-                for (QueryResult res : results)
+                for (int counter = 0; counter < results.size(); counter++)
                 {
+                    QueryResult res = results.get(counter);
                     if (res.getClosestEdge().getBaseNode() != baseNode)
                         throw new IllegalStateException("Base nodes have to be identical but were not: " + closestEdge + " vs " + res.getClosestEdge());
 
-                    queryResults.add(res);
                     GHPoint3D currSnapped = res.getSnappedPoint();
-                    createEdges(prevPoint, prevWayIndex,
+
+                    // no new virtual nodes if exactly the same snapped point
+                    if (prevPoint.equals(currSnapped))
+                    {
+                        res.setClosestNode(prevNodeId);
+                        continue;
+                    }
+
+                    queryResults.add(res);
+                    createEdges(origTraversalKey, origRevTraversalKey,
+                            prevPoint, prevWayIndex,
                             res.getSnappedPoint(), res.getWayIndex(),
                             fullPL, closestEdge, prevNodeId, virtNodeId, reverseFlags);
 
                     virtualNodes.add(currSnapped.lat, currSnapped.lon, currSnapped.ele);
 
                     // add edges again to set adjacent edges for newVirtNodeId
-                    if (counter > 0)
+                    if (addedEdges)
                     {
                         virtualEdges.add(virtualEdges.get(virtualEdges.size() - 2));
                         virtualEdges.add(virtualEdges.get(virtualEdges.size() - 2));
                     }
 
+                    addedEdges = true;
                     res.setClosestNode(virtNodeId);
                     prevNodeId = virtNodeId;
                     prevWayIndex = res.getWayIndex() + 1;
                     prevPoint = currSnapped;
-                    counter++;
                     virtNodeId++;
                 }
 
-                // two edges between last result and adjacent node are still missing
-                createEdges(prevPoint, prevWayIndex, fullPL.toGHPoint(fullPL.getSize() - 1), fullPL.getSize() - 2,
-                        fullPL, closestEdge, virtNodeId - 1, adjNode, reverseFlags);
+                // two edges between last result and adjacent node are still missing if not all points skipped
+                if (addedEdges)
+                    createEdges(origTraversalKey, origRevTraversalKey,
+                            prevPoint, prevWayIndex,
+                            fullPL.toGHPoint(fullPL.getSize() - 1), fullPL.getSize() - 2,
+                            fullPL, closestEdge, virtNodeId - 1, adjNode, reverseFlags);
 
                 return true;
             }
         });
     }
 
-    private void createEdges( GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D currSnapped, int wayIndex,
-            PointList fullPL, EdgeIteratorState closestEdge,
-            int prevNodeId, int nodeId, long reverseFlags )
+    @Override
+    public Graph getBaseGraph()
+    {
+        // Note: if the mainGraph of this QueryGraph is a LevelGraph then ignoring the shortcuts will produce a 
+        // huge gap of edgeIds between base and virtual edge ids. The only solution would be to move virtual edges
+        // directly after normal edge ids which is ugly as we limit virtual edges to N edges and waste memory or make everything more complex.        
+        return baseGraph;
+    }
+
+    public boolean isVirtualEdge( int edgeId )
+    {
+        return edgeId >= mainEdges;
+    }
+
+    public boolean isVirtualNode( int nodeId )
+    {
+        return nodeId >= mainNodes;
+    }
+
+    class QueryGraphTurnExt extends TurnCostExtension
+    {
+        private final TurnCostExtension mainTurnExtension;
+
+        public QueryGraphTurnExt( QueryGraph qGraph )
+        {
+            this.mainTurnExtension = (TurnCostExtension) mainGraph.getExtension();
+        }
+
+        @Override
+        public long getTurnCostFlags( int edgeFrom, int nodeVia, int edgeTo )
+        {
+            if (isVirtualNode(nodeVia))
+            {
+                return 0;
+            } else if (isVirtualEdge(edgeFrom) || isVirtualEdge(edgeTo))
+            {
+                if (isVirtualEdge(edgeFrom))
+                {
+                    edgeFrom = queryResults.get((edgeFrom - mainEdges) / 4).getClosestEdge().getEdge();
+                }
+                if (isVirtualEdge(edgeTo))
+                {
+                    edgeTo = queryResults.get((edgeTo - mainEdges) / 4).getClosestEdge().getEdge();
+                }
+                return mainTurnExtension.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
+
+            } else
+            {
+                return mainTurnExtension.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
+            }
+        }
+    }
+
+    private void createEdges( int origTraversalKey, int origRevTraversalKey,
+                              GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D currSnapped, int wayIndex,
+                              PointList fullPL, EdgeIteratorState closestEdge,
+                              int prevNodeId, int nodeId, long reverseFlags )
     {
         int max = wayIndex + 1;
         // basePoints must have at least the size of 2 to make sure fetchWayGeometry(3) returns at least 2
@@ -238,19 +350,114 @@ private void createEdges( GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D cur
         basePoints.add(currSnapped.lat, currSnapped.lon, currSnapped.ele);
 
         PointList baseReversePoints = basePoints.clone(true);
-        double baseDistance = basePoints.calcDistance(distCalc);
-        int virtEdgeId = virtualEdges.size() + mainEdges;
+        double baseDistance = basePoints.calcDistance(Helper.DIST_PLANE);
+        int virtEdgeId = mainEdges + virtualEdges.size();
 
         // edges between base and snapped point
-        VirtualEdgeIState baseEdge = new VirtualEdgeIState(virtEdgeId, prevNodeId, nodeId,
-                baseDistance, closestEdge.getFlags(), closestEdge.getName(), basePoints);
-        VirtualEdgeIState baseReverseEdge = new VirtualEdgeIState(virtEdgeId, nodeId, prevNodeId,
-                baseDistance, reverseFlags, closestEdge.getName(), baseReversePoints);
+        VirtualEdgeIteratorState baseEdge = new VirtualEdgeIteratorState(origTraversalKey,
+                virtEdgeId, prevNodeId, nodeId, baseDistance, closestEdge.getFlags(), closestEdge.getName(), basePoints);
+        VirtualEdgeIteratorState baseReverseEdge = new VirtualEdgeIteratorState(origRevTraversalKey,
+                virtEdgeId, nodeId, prevNodeId, baseDistance, reverseFlags, closestEdge.getName(), baseReversePoints);
 
         virtualEdges.add(baseEdge);
         virtualEdges.add(baseReverseEdge);
     }
 
+    /**
+     * set edges at virtual node unfavored which require at least a turn of 100 from favoredHeading
+     * <p>
+     * @param nodeId VirtualNode at which edges get unfavored
+     * @param favoredHeading north based azimuth of favored heading between 0 and 360
+     * @param incoming if true, incoming edges are unfavored, else outgoing edges
+     * @return boolean indicating if enforcement took place
+     */
+    public boolean enforceHeading( int nodeId, Double favoredHeading, boolean incoming )
+    {
+        if (!isInitialized())
+            throw new IllegalStateException("QueryGraph.lookup has to be called in before heading enforcement");
+
+        if (Double.isNaN(favoredHeading))
+            return false;
+
+        if (!isVirtualNode(nodeId))
+            return false;
+
+        int virtNodeIDintern = nodeId - mainNodes;
+        favoredHeading = ac.convertAzimuth2xaxisAngle(favoredHeading);
+
+        // either penalize incoming or outgoing edges
+        List<Integer> edgePositions = incoming ? Arrays.asList(VE_BASE, VE_ADJ_REV) : Arrays.asList(VE_BASE_REV, VE_ADJ);
+        boolean enforcementOccured = false;
+        for (int edgePos : edgePositions)
+        {
+            VirtualEdgeIteratorState edge = virtualEdges.get(virtNodeIDintern * 4 + edgePos);
+
+            PointList wayGeo = edge.fetchWayGeometry(3);
+            double edgeOrientation;
+            if (incoming)
+            {
+                int numWayPoints = wayGeo.getSize();
+                edgeOrientation = ac.calcOrientation(wayGeo.getLat(numWayPoints - 2), wayGeo.getLon(numWayPoints - 2),
+                        wayGeo.getLat(numWayPoints - 1), wayGeo.getLon(numWayPoints - 1));
+            } else
+            {
+                edgeOrientation = ac.calcOrientation(wayGeo.getLat(0), wayGeo.getLon(0),
+                        wayGeo.getLat(1), wayGeo.getLon(1));
+            }
+
+            edgeOrientation = ac.alignOrientation(favoredHeading, edgeOrientation);
+            double delta = (edgeOrientation - favoredHeading);
+
+            if (Math.abs(delta) > 1.74) // penalize if a turn of more than 100
+            {
+                edge.setVirtualEdgePreference(true, false);
+                modifiedEdges.add(edge);
+                //also apply to opposite edge for reverse routing
+                VirtualEdgeIteratorState reverseEdge = virtualEdges.get(virtNodeIDintern * 4 + getPosOfReverseEdge(edgePos));
+                reverseEdge.setVirtualEdgePreference(true, true);
+                modifiedEdges.add(reverseEdge);
+                enforcementOccured = true;
+            }
+
+        }
+        return enforcementOccured;
+    }
+
+    /**
+     * set specific edge at virtual node unfavored, to enforce routing along other edges
+     * <p>
+     * @param nodeId VirtualNode at which edges get unfavored
+     * @param edgeId edge to become unfavored
+     * @param incoming if true, incoming edge is unfavored, else outgoing edge
+     * @return boolean indicating if enforcement took place
+     */
+    public boolean enforceHeadingByEdgeId( int nodeId, int edgeId, boolean incoming )
+    {
+        if (!isVirtualNode(nodeId))
+            return false;
+
+        VirtualEdgeIteratorState incomingEdge = (VirtualEdgeIteratorState) getEdgeProps(edgeId, nodeId);
+        VirtualEdgeIteratorState reverseEdge = (VirtualEdgeIteratorState) getEdgeProps(edgeId, incomingEdge.getBaseNode());
+        incomingEdge.setVirtualEdgePreference(true, !incoming);
+        modifiedEdges.add(incomingEdge);
+        reverseEdge.setVirtualEdgePreference(true, incoming);
+        modifiedEdges.add(reverseEdge);
+        return true;
+    }
+
+    /**
+     * removes the unfavored status of all virtual edges
+     */
+    public void clearUnfavoredStatus()
+    {
+        for (VirtualEdgeIteratorState edge : modifiedEdges)
+        {
+            edge.setVirtualEdgePreference(false, false);
+            edge.setVirtualEdgePreference(false, true);
+        }
+
+    }
+
     @Override
     public int getNodes()
     {
@@ -265,6 +472,12 @@ public NodeAccess getNodeAccess()
 
     private final NodeAccess nodeAccess = new NodeAccess()
     {
+        @Override
+        public void ensureNode( int nodeId )
+        {
+            mainNodeAccess.ensureNode(nodeId);
+        }
+
         @Override
         public boolean is3D()
         {
@@ -280,7 +493,7 @@ public int getDimension()
         @Override
         public double getLatitude( int nodeId )
         {
-            if (nodeId >= mainNodes)
+            if (isVirtualNode(nodeId))
                 return virtualNodes.getLatitude(nodeId - mainNodes);
             return mainNodeAccess.getLatitude(nodeId);
         }
@@ -288,7 +501,7 @@ public double getLatitude( int nodeId )
         @Override
         public double getLongitude( int nodeId )
         {
-            if (nodeId >= mainNodes)
+            if (isVirtualNode(nodeId))
                 return virtualNodes.getLongitude(nodeId - mainNodes);
             return mainNodeAccess.getLongitude(nodeId);
         }
@@ -296,7 +509,7 @@ public double getLongitude( int nodeId )
         @Override
         public double getElevation( int nodeId )
         {
-            if (nodeId >= mainNodes)
+            if (isVirtualNode(nodeId))
                 return virtualNodes.getElevation(nodeId - mainNodes);
             return mainNodeAccess.getElevation(nodeId);
         }
@@ -304,7 +517,7 @@ public double getElevation( int nodeId )
         @Override
         public int getAdditionalNodeField( int nodeId )
         {
-            if (nodeId >= mainNodes)
+            if (isVirtualNode(nodeId))
                 return 0;
             return mainNodeAccess.getAdditionalNodeField(nodeId);
         }
@@ -355,19 +568,15 @@ public BBox getBounds()
     @Override
     public EdgeIteratorState getEdgeProps( int origEdgeId, int adjNode )
     {
-        if (origEdgeId < mainEdges)
+        if (!isVirtualEdge(origEdgeId))
             return mainGraph.getEdgeProps(origEdgeId, adjNode);
 
         int edgeId = origEdgeId - mainEdges;
         EdgeIteratorState eis = virtualEdges.get(edgeId);
         if (eis.getAdjNode() == adjNode || adjNode == Integer.MIN_VALUE)
             return eis;
+        edgeId = getPosOfReverseEdge(edgeId);
 
-        // find reverse edge via convention. see virtualEdges comment above
-        if (edgeId % 2 == 0)
-            edgeId++;
-        else
-            edgeId--;
         EdgeIteratorState eis2 = virtualEdges.get(edgeId);
         if (eis2.getAdjNode() == adjNode)
             return eis2;
@@ -375,6 +584,17 @@ public EdgeIteratorState getEdgeProps( int origEdgeId, int adjNode )
                 + ". found edges were:" + eis + ", " + eis2);
     }
 
+    private int getPosOfReverseEdge( int edgeId )
+    {
+        // find reverse edge via convention. see virtualEdges comment above
+        if (edgeId % 2 == 0)
+            edgeId++;
+        else
+            edgeId--;
+
+        return edgeId;
+    }
+
     @Override
     public EdgeExplorer createEdgeExplorer( final EdgeFilter edgeFilter )
     {
@@ -406,10 +626,12 @@ public EdgeExplorer createEdgeExplorer( final EdgeFilter edgeFilter )
             int virtNode = mainNodes + i;
             node2EdgeMap.put(virtNode, virtEdgeIter);
 
-            // replace edge list of neighboring tower nodes: a) add virtual edges only and collect tower nodes where real edges will be added in step 2.
+            // replace edge list of neighboring tower nodes: 
+            // add virtual edges only and collect tower nodes where real edges will be added in step 2.
+            //
             // base node
             int towerNode = baseRevEdge.getAdjNode();
-            if (towerNode < mainNodes)
+            if (!isVirtualNode(towerNode))
             {
                 towerNodesToChange.add(towerNode);
                 addVirtualEdges(node2EdgeMap, edgeFilter, true, towerNode, i);
@@ -417,7 +639,7 @@ public EdgeExplorer createEdgeExplorer( final EdgeFilter edgeFilter )
 
             // adj node
             towerNode = adjEdge.getAdjNode();
-            if (towerNode < mainNodes)
+            if (!isVirtualNode(towerNode))
             {
                 towerNodesToChange.add(towerNode);
                 addVirtualEdges(node2EdgeMap, edgeFilter, false, towerNode, i);
@@ -455,7 +677,7 @@ public EdgeIterator setBaseNode( int baseNode )
      * Creates a fake edge iterator pointing to multiple edge states.
      */
     private void addVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2EdgeMap, EdgeFilter filter, boolean base,
-            int node, int virtNode )
+                                  int node, int virtNode )
     {
         VirtualEdgeIterator existingIter = node2EdgeMap.get(node);
         if (existingIter == null)
@@ -472,8 +694,8 @@ private void addVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2EdgeMap, E
 
     void fillVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl )
     {
-        if (towerNode >= mainNodes)
-            throw new IllegalStateException("should not happen:" + towerNode + ", " + node2Edge);
+        if (isVirtualNode(towerNode))
+            throw new IllegalStateException("Node should not be virtual:" + towerNode + ", " + node2Edge);
 
         VirtualEdgeIterator vIter = node2Edge.get(towerNode);
         TIntArrayList ignoreEdges = new TIntArrayList(vIter.count() * 2);
@@ -531,360 +753,14 @@ public Graph copyTo( Graph g )
         throw exc();
     }
 
-    private UnsupportedOperationException exc()
+    @Override
+    public GraphExtension getExtension()
     {
-        return new UnsupportedOperationException("QueryGraph cannot be modified.");
+        return wrappedExtension;
     }
 
-    static class VirtualEdgeIterator implements EdgeIterator, EdgeSkipIterState
-    {
-
-        private final List<EdgeIteratorState> edges;
-        private int current;
-
-        public VirtualEdgeIterator( int edgeCount )
-        {
-            edges = new ArrayList<EdgeIteratorState>(edgeCount);
-            reset();
-        }
-
-        void add( EdgeIteratorState edge )
-        {
-            edges.add(edge);
-        }
-
-        EdgeIterator reset()
-        {
-            current = -1;
-            return this;
-        }
-
-        int count()
-        {
-            return edges.size();
-        }
-
-        @Override
-        public boolean next()
-        {
-            current++;
-            return current < edges.size();
-        }
-
-        @Override
-        public EdgeIteratorState detach( boolean reverse )
-        {
-            if (reverse)
-                throw new IllegalStateException("Not yet supported");
-
-            return edges.get(current);
-        }
-
-        @Override
-        public int getEdge()
-        {
-            return edges.get(current).getEdge();
-        }
-
-        @Override
-        public int getBaseNode()
-        {
-            return edges.get(current).getBaseNode();
-        }
-
-        @Override
-        public int getAdjNode()
-        {
-            return edges.get(current).getAdjNode();
-        }
-
-        @Override
-        public PointList fetchWayGeometry( int mode )
-        {
-            return edges.get(current).fetchWayGeometry(mode);
-        }
-
-        @Override
-        public EdgeIteratorState setWayGeometry( PointList list )
-        {
-            return edges.get(current).setWayGeometry(list);
-        }
-
-        @Override
-        public double getDistance()
-        {
-            return edges.get(current).getDistance();
-        }
-
-        @Override
-        public EdgeIteratorState setDistance( double dist )
-        {
-            return edges.get(current).setDistance(dist);
-        }
-
-        @Override
-        public long getFlags()
-        {
-            return edges.get(current).getFlags();
-        }
-
-        @Override
-        public EdgeIteratorState setFlags( long flags )
-        {
-            return edges.get(current).setFlags(flags);
-        }
-
-        @Override
-        public String getName()
-        {
-            return edges.get(current).getName();
-        }
-
-        @Override
-        public EdgeIteratorState setName( String name )
-        {
-            return edges.get(current).setName(name);
-        }
-
-        @Override
-        public String toString()
-        {
-            return edges.toString();
-        }
-
-        @Override
-        public int getAdditionalField()
-        {
-            return edges.get(current).getAdditionalField();
-        }
-
-        @Override
-        public EdgeIteratorState setAdditionalField( int value )
-        {
-            return edges.get(current).setAdditionalField(value);
-        }
-
-        @Override
-        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-        {
-            return edges.get(current).copyPropertiesTo(edge);
-        }
-
-        @Override
-        public boolean isShortcut()
-        {
-            EdgeIteratorState edge = edges.get(current);
-            return edge instanceof EdgeSkipIterState && ((EdgeSkipIterState) edge).isShortcut();
-        }
-
-        @Override
-        public double getWeight()
-        {
-            // will be called only from PreparationWeighting and if isShortcut is true
-            return ((EdgeSkipIterState) edges.get(current)).getWeight();
-        }
-
-        @Override
-        public EdgeSkipIterState setWeight( double weight )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public int getSkippedEdge1()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public int getSkippedEdge2()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public void setSkippedEdges( int edge1, int edge2 )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-    }
-
-    /**
-     * Creates an edge state decoupled from a graph where nodes, pointList, etc are kept in memory.
-     */
-    private static class VirtualEdgeIState implements EdgeIteratorState, EdgeSkipIterState
+    private UnsupportedOperationException exc()
     {
-
-        private final PointList pointList;
-        private final int edgeId;
-        private double distance;
-        private long flags;
-        private String name;
-        private final int baseNode;
-        private final int adjNode;
-
-        public VirtualEdgeIState( int edgeId, int baseNode, int adjNode,
-                double distance, long flags, String name, PointList pointList )
-        {
-            this.edgeId = edgeId;
-            this.baseNode = baseNode;
-            this.adjNode = adjNode;
-            this.distance = distance;
-            this.flags = flags;
-            this.name = name;
-            this.pointList = pointList;
-        }
-
-        @Override
-        public int getEdge()
-        {
-            return edgeId;
-        }
-
-        @Override
-        public int getBaseNode()
-        {
-            return baseNode;
-        }
-
-        @Override
-        public int getAdjNode()
-        {
-            return adjNode;
-        }
-
-        @Override
-        public PointList fetchWayGeometry( int mode )
-        {
-            if (pointList.getSize() == 0)
-                return PointList.EMPTY;
-
-            // due to API we need to create a new instance per call!
-            if (mode == 3)
-                return pointList.clone(false);
-            else if (mode == 1)
-                return pointList.copy(0, pointList.getSize() - 1);
-            else if (mode == 2)
-                return pointList.copy(1, pointList.getSize());
-            else if (mode == 0)
-            {
-                if (pointList.getSize() == 1)
-                    return PointList.EMPTY;
-                return pointList.copy(1, pointList.getSize() - 1);
-            }
-
-            throw new UnsupportedOperationException("Illegal mode:" + mode);
-        }
-
-        @Override
-        public EdgeIteratorState setWayGeometry( PointList list )
-        {
-            throw new UnsupportedOperationException("Not supported for virtual edge. Set when creating it.");
-        }
-
-        @Override
-        public double getDistance()
-        {
-            return distance;
-        }
-
-        @Override
-        public EdgeIteratorState setDistance( double dist )
-        {
-            this.distance = dist;
-            return this;
-        }
-
-        @Override
-        public long getFlags()
-        {
-            return flags;
-        }
-
-        @Override
-        public EdgeIteratorState setFlags( long flags )
-        {
-            this.flags = flags;
-            return this;
-        }
-
-        @Override
-        public String getName()
-        {
-            return name;
-        }
-
-        @Override
-        public EdgeIteratorState setName( String name )
-        {
-            this.name = name;
-            return this;
-        }
-
-        @Override
-        public String toString()
-        {
-            return baseNode + "->" + adjNode;
-        }
-
-        @Override
-        public boolean isShortcut()
-        {
-            return false;
-        }
-
-        @Override
-        public int getAdditionalField()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public int getSkippedEdge1()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public int getSkippedEdge2()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public void setSkippedEdges( int edge1, int edge2 )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeIteratorState detach( boolean reverse )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeIteratorState setAdditionalField( int value )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeSkipIterState setWeight( double weight )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public double getWeight()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
+        return new UnsupportedOperationException("QueryGraph cannot be modified.");
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
index b1ee8174c5..b7a5abf53c 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.NotThreadSafe;
 
 /**
@@ -36,15 +35,10 @@
     Path calcPath( int from, int to );
 
     /**
-     * Calculates the best path between the specified query results from GPS lookup.
-     * <p/>
-     * Note: The underlying implementation introduces a state of the algorithm and so it is tightly
-     * coupled to the query! Reusing this instance should be done carefully: only from within one
-     * thread and only via this calcPath method.
-     * <p/>
-     * @return the path. Call the method found() to make sure that the path is valid.
+     * Limits the search to avoid full graph exploration in the case of disconnected networks. The
+     * default value is Double.MAX_VALUE. See #104
      */
-    Path calcPath( QueryResult from, QueryResult to );
+    void setWeightLimit( double weight );
 
     /**
      * @return name of this algorithm
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
index 6cb5c54455..675ed64816 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
@@ -17,51 +17,12 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
 
 /**
  * @author Peter Karich
  */
-public class RoutingAlgorithmFactory
+public interface RoutingAlgorithmFactory
 {
-    private final String algoStr;
-    private final boolean approx;
-    private final TraversalMode traversalMode;
-
-    /**
-     * @param algo possible values are astar (A* algorithm), astarbi (bidirectional A*), dijkstra
-     * (Dijkstra) or dijkstrabi.
-     */
-    public RoutingAlgorithmFactory( String algo, boolean approx, TraversalMode tMode )
-    {
-        this.algoStr = algo;
-        this.approx = approx;
-        this.traversalMode = tMode;
-    }
-
-    public RoutingAlgorithm createAlgo( Graph g, FlagEncoder encoder, Weighting weighting )
-    {
-        AbstractRoutingAlgorithm algo;
-        if ("dijkstrabi".equalsIgnoreCase(algoStr))
-        {
-            algo = new DijkstraBidirectionRef(g, encoder, weighting, traversalMode);        
-        } else if ("dijkstra".equalsIgnoreCase(algoStr))
-        {
-            algo = new Dijkstra(g, encoder, weighting, traversalMode);
-        } else if ("astarbi".equalsIgnoreCase(algoStr))
-        {
-            algo = new AStarBidirection(g, encoder, weighting, traversalMode).setApproximation(approx);
-        } else if ("dijkstraOneToMany".equalsIgnoreCase(algoStr))
-        {
-            algo = new DijkstraOneToMany(g, encoder, weighting, traversalMode);
-        } else
-        {
-            algo = new AStar(g, encoder, weighting, traversalMode);
-        }
-        
-        return algo;
-    }
+    RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts );
 }
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
new file mode 100644
index 0000000000..e3e11cef2b
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
@@ -0,0 +1,83 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.util.BeelineWeightApproximator;
+import com.graphhopper.routing.util.WeightApproximator;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.Helper;
+
+/**
+ * A simple factory creating normal algorithms (RoutingAlgorithm) without preparation.
+ * <p/>
+ * @author Peter Karich
+ */
+public class RoutingAlgorithmFactorySimple implements RoutingAlgorithmFactory
+{
+    @Override
+    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
+    {
+        String algoStr = opts.getAlgorithm();
+        if (AlgorithmOptions.DIJKSTRA_BI.equalsIgnoreCase(algoStr))
+        {
+            return new DijkstraBidirectionRef(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+        } else if (AlgorithmOptions.DIJKSTRA.equalsIgnoreCase(algoStr))
+        {
+            return new Dijkstra(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+        } else if (AlgorithmOptions.ASTAR_BI.equalsIgnoreCase(algoStr))
+        {
+            AStarBidirection aStarBi = new AStarBidirection(g, opts.getFlagEncoder(), opts.getWeighting(),
+                    opts.getTraversalMode());
+            aStarBi.setApproximation(getApproximation(AlgorithmOptions.ASTAR_BI, opts, g.getNodeAccess()));
+            return aStarBi;
+        } else if (AlgorithmOptions.DIJKSTRA_ONE_TO_MANY.equalsIgnoreCase(algoStr))
+        {
+            return new DijkstraOneToMany(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+        } else if (AlgorithmOptions.ASTAR.equalsIgnoreCase(algoStr))
+        {
+            AStar aStar = new AStar(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+            aStar.setApproximation(getApproximation(AlgorithmOptions.ASTAR, opts, g.getNodeAccess()));
+            return aStar;
+        } else
+        {
+            throw new IllegalArgumentException("Algorithm " + algoStr + " not found in " + getClass().getName());
+        }
+
+    }
+
+    private WeightApproximator getApproximation( String prop, AlgorithmOptions opts, NodeAccess na )
+    {
+        String approxAsStr = opts.getHints().get(prop + ".approximation", "BeelineSimplification");
+        if ("BeelineSimplification".equals(approxAsStr))
+        {
+            BeelineWeightApproximator approx = new BeelineWeightApproximator(na, opts.getWeighting());
+            approx.setDistanceCalc(Helper.DIST_PLANE);
+            return approx;
+
+        } else if ("BeelineAccurate".equals(approxAsStr))
+        {
+            BeelineWeightApproximator approx = new BeelineWeightApproximator(na, opts.getWeighting());
+            approx.setDistanceCalc(Helper.DIST_EARTH);
+            return approx;
+        } else
+        {
+            throw new IllegalArgumentException("Approximation " + approxAsStr + " not found in " + getClass().getName());
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
new file mode 100644
index 0000000000..b461ed4c7b
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright 2015 Peter Karich.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.util.*;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @author Peter Karich
+ */
+class VirtualEdgeIterator implements EdgeIterator, EdgeSkipIterState
+{
+    private final List<EdgeIteratorState> edges;
+    private int current;
+
+    public VirtualEdgeIterator( int edgeCount )
+    {
+        edges = new ArrayList<EdgeIteratorState>(edgeCount);
+        reset();
+    }
+
+    void add( EdgeIteratorState edge )
+    {
+        edges.add(edge);
+    }
+
+    EdgeIterator reset()
+    {
+        current = -1;
+        return this;
+    }
+
+    int count()
+    {
+        return edges.size();
+    }
+
+    @Override
+    public boolean next()
+    {
+        current++;
+        return current < edges.size();
+    }
+
+    @Override
+    public EdgeIteratorState detach( boolean reverse )
+    {
+        if (reverse)
+            throw new IllegalStateException("Not yet supported");
+        return edges.get(current);
+    }
+
+    @Override
+    public int getEdge()
+    {
+        return edges.get(current).getEdge();
+    }
+
+    @Override
+    public int getBaseNode()
+    {
+        return edges.get(current).getBaseNode();
+    }
+
+    @Override
+    public int getAdjNode()
+    {
+        return edges.get(current).getAdjNode();
+    }
+
+    @Override
+    public PointList fetchWayGeometry( int mode )
+    {
+        return edges.get(current).fetchWayGeometry(mode);
+    }
+
+    @Override
+    public EdgeIteratorState setWayGeometry( PointList list )
+    {
+        return edges.get(current).setWayGeometry(list);
+    }
+
+    @Override
+    public double getDistance()
+    {
+        return edges.get(current).getDistance();
+    }
+
+    @Override
+    public EdgeIteratorState setDistance( double dist )
+    {
+        return edges.get(current).setDistance(dist);
+    }
+
+    @Override
+    public long getFlags()
+    {
+        return edges.get(current).getFlags();
+    }
+
+    @Override
+    public EdgeIteratorState setFlags( long flags )
+    {
+        return edges.get(current).setFlags(flags);
+    }
+
+    @Override
+    public String getName()
+    {
+        return edges.get(current).getName();
+    }
+
+    @Override
+    public EdgeIteratorState setName( String name )
+    {
+        return edges.get(current).setName(name);
+    }
+
+    @Override
+    public boolean getBoolean(int key, boolean reverse, boolean _default)
+    {
+        return edges.get(current).getBoolean(key, reverse, _default);
+    }
+
+    @Override
+    public String toString()
+    {
+        return edges.toString();
+    }
+
+    @Override
+    public int getAdditionalField()
+    {
+        return edges.get(current).getAdditionalField();
+    }
+
+    @Override
+    public EdgeIteratorState setAdditionalField( int value )
+    {
+        return edges.get(current).setAdditionalField(value);
+    }
+
+    @Override
+    public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
+    {
+        return edges.get(current).copyPropertiesTo(edge);
+    }
+
+    @Override
+    public boolean isShortcut()
+    {
+        EdgeIteratorState edge = edges.get(current);
+        return edge instanceof EdgeSkipIterState && ((EdgeSkipIterState) edge).isShortcut();
+    }
+
+    @Override
+    public double getWeight()
+    {
+        // will be called only from PreparationWeighting and if isShortcut is true
+        return ((EdgeSkipIterState) edges.get(current)).getWeight();
+    }
+
+    @Override
+    public EdgeSkipIterState setWeight( double weight )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getSkippedEdge1()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getSkippedEdge2()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void setSkippedEdges( int edge1, int edge2 )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
new file mode 100644
index 0000000000..15b276508a
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
@@ -0,0 +1,240 @@
+/*
+ * Copyright 2015 Peter Karich.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.util.*;
+
+/**
+ * Creates an edge state decoupled from a graph where nodes, pointList, etc are kept in memory.
+ * <p/>
+ * Note, this class is not suited for public use and can change with minor releases unexpectedly or
+ * even gets removed.
+ */
+public class VirtualEdgeIteratorState implements EdgeIteratorState, EdgeSkipIterState
+{
+    private final PointList pointList;
+    private final int edgeId;
+    private double distance;
+    private long flags;
+    private String name;
+    private final int baseNode;
+    private final int adjNode;
+    private final int originalTraversalKey;
+    // indication if edges are dispreferred as start/stop edge 
+    private boolean unfavoredReverseEdge;
+    private boolean unfavored;
+
+
+    public VirtualEdgeIteratorState( int originalTraversalKey, int edgeId, int baseNode, int adjNode, double distance, long flags, String name, PointList pointList )
+    {
+        this.originalTraversalKey = originalTraversalKey;
+        this.edgeId = edgeId;
+        this.baseNode = baseNode;
+        this.adjNode = adjNode;
+        this.distance = distance;
+        this.flags = flags;
+        this.name = name;
+        this.pointList = pointList;
+    }
+
+    /**
+     * This method returns the original edge via its traversal key. I.e. also the direction is
+     * already correctly encoded.
+     * <p/>
+     * @see GHUtility#createEdgeKey(int, int, int, boolean)
+     */
+    public int getOriginalTraversalKey()
+    {
+        return originalTraversalKey;
+    }
+
+    @Override
+    public int getEdge()
+    {
+        return edgeId;
+    }
+
+    @Override
+    public int getBaseNode()
+    {
+        return baseNode;
+    }
+
+    @Override
+    public int getAdjNode()
+    {
+        return adjNode;
+    }
+
+    @Override
+    public PointList fetchWayGeometry( int mode )
+    {
+        if (pointList.getSize() == 0)
+            return PointList.EMPTY;
+        // due to API we need to create a new instance per call!
+        if (mode == 3)
+            return pointList.clone(false);
+        else if (mode == 1)
+            return pointList.copy(0, pointList.getSize() - 1);
+        else if (mode == 2)
+            return pointList.copy(1, pointList.getSize());
+        else if (mode == 0)
+        {
+            if (pointList.getSize() == 1)
+                return PointList.EMPTY;
+            return pointList.copy(1, pointList.getSize() - 1);
+        }
+        throw new UnsupportedOperationException("Illegal mode:" + mode);
+    }
+
+    @Override
+    public EdgeIteratorState setWayGeometry( PointList list )
+    {
+        throw new UnsupportedOperationException("Not supported for virtual edge. Set when creating it.");
+    }
+
+    @Override
+    public double getDistance()
+    {
+        return distance;
+    }
+
+    @Override
+    public EdgeIteratorState setDistance( double dist )
+    {
+        this.distance = dist;
+        return this;
+    }
+
+    @Override
+    public long getFlags()
+    {
+        return flags;
+    }
+
+    @Override
+    public EdgeIteratorState setFlags( long flags )
+    {
+        this.flags = flags;
+        return this;
+    }
+
+    @Override
+    public String getName()
+    {
+        return name;
+    }
+
+    @Override
+    public EdgeIteratorState setName( String name )
+    {
+        this.name = name;
+        return this;
+    }
+    
+    @Override
+    public boolean getBoolean(int key, boolean reverse, boolean _default )
+    {
+        if (key == EdgeIteratorState.K_UNFAVORED_EDGE)
+        {
+            if (reverse)
+                return unfavoredReverseEdge;
+            else
+                return unfavored;
+        }
+        // for non-existent keys return default
+        return _default;
+    }
+
+    /**
+     * set edge to unfavored status for routing from/to start/stop points
+     * @param reverse indicates if forward or backward direction is affected
+     */
+    public void setVirtualEdgePreference( boolean unfavored, boolean reverse )
+    {
+        if (reverse)
+              unfavoredReverseEdge = unfavored;
+        else
+            this.unfavored = unfavored;
+    }
+    
+    @Override
+    public String toString()
+    {
+        return baseNode + "->" + adjNode;
+    }
+
+    @Override
+    public boolean isShortcut()
+    {
+        return false;
+    }
+
+    @Override
+    public int getAdditionalField()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getSkippedEdge1()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getSkippedEdge2()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void setSkippedEdges( int edge1, int edge2 )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public EdgeIteratorState detach( boolean reverse )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public EdgeIteratorState setAdditionalField( int value )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public EdgeSkipIterState setWeight( double weight )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public double getWeight()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
index 54807733e7..03a5aaeeb6 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
@@ -25,22 +25,25 @@
 /**
  * Recursivly unpack shortcuts.
  * <p/>
- * @see PrepareContractionHierarchies
  * @author Peter Karich
+ * @see PrepareContractionHierarchies
  */
 public class Path4CH extends PathBidirRef
 {
-    public Path4CH( Graph g, FlagEncoder encoder )
+    private final Graph routingGraph;
+
+    public Path4CH( Graph routingGraph, Graph baseGraph, FlagEncoder encoder )
     {
-        super(g, encoder);
+        super(baseGraph, encoder);
+        this.routingGraph = routingGraph;
     }
 
     @Override
-    protected void processEdge( int tmpEdge, int endNode )
+    protected final void processEdge( int tmpEdge, int endNode )
     {
         // Shortcuts do only contain valid weight so first expand before adding
         // to distance and time
-        expandEdge((EdgeSkipIterState) graph.getEdgeProps(tmpEdge, endNode), false);
+        expandEdge((EdgeSkipIterState) routingGraph.getEdgeProps(tmpEdge, endNode), false);
     }
 
     private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
@@ -50,7 +53,7 @@ private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
             double dist = mainEdgeState.getDistance();
             distance += dist;
             long flags = mainEdgeState.getFlags();
-            millis += calcMillis(dist, flags, reverse);
+            time += calcMillis(dist, flags, reverse);
             addEdge(mainEdgeState.getEdge());
             return;
         }
@@ -58,6 +61,8 @@ private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
         int skippedEdge1 = mainEdgeState.getSkippedEdge1();
         int skippedEdge2 = mainEdgeState.getSkippedEdge2();
         int from = mainEdgeState.getBaseNode(), to = mainEdgeState.getAdjNode();
+
+        // get properties like speed of the edge in the correct direction
         if (reverse)
         {
             int tmp = from;
@@ -68,32 +73,32 @@ private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
         // getEdgeProps could possibly return an empty edge if the shortcut is available for both directions
         if (reverseOrder)
         {
-            EdgeSkipIterState edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, to);
+            EdgeSkipIterState edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, to);
             boolean empty = edgeState == null;
             if (empty)
-                edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, to);
+                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, to);
 
             expandEdge(edgeState, false);
 
             if (empty)
-                edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, from);
+                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, from);
             else
-                edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, from);
+                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, from);
 
             expandEdge(edgeState, true);
         } else
         {
-            EdgeSkipIterState iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, from);
+            EdgeSkipIterState iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, from);
             boolean empty = iter == null;
             if (empty)
-                iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, from);
+                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, from);
 
             expandEdge(iter, true);
 
             if (empty)
-                iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, to);
+                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, to);
             else
-                iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, to);
+                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, to);
 
             expandEdge(iter, false);
         }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
index fd3006faf1..1c2ec4c4bf 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
@@ -24,7 +24,7 @@
 
 /**
  * Used in CH preparation and therefor assumed that all edges are of type EdgeSkipIterState
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class PreparationWeighting implements Weighting
@@ -37,13 +37,13 @@ public PreparationWeighting( Weighting userWeighting )
     }
 
     @Override
-    public double getMinWeight( double distance )
+    public final double getMinWeight( double distance )
     {
         return userWeighting.getMinWeight(distance);
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId)
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
     {
         if (edgeState instanceof EdgeSkipIterState)
         {
@@ -60,9 +60,4 @@ public String toString()
     {
         return "PREPARE+" + userWeighting.toString();
     }
-
-    Weighting getUserWeighting()
-    {
-        return userWeighting;
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 8a79b645fb..c7c900cd97 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -25,15 +25,11 @@
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.DataAccess;
-import com.graphhopper.storage.DAType;
-import com.graphhopper.storage.GHDirectory;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.storage.LevelGraphStorage;
-import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
+
 import java.util.*;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -49,7 +45,7 @@
  * <p/>
  * @author Peter Karich
  */
-public class PrepareContractionHierarchies extends AbstractAlgoPreparation<PrepareContractionHierarchies>
+public class PrepareContractionHierarchies extends AbstractAlgoPreparation implements RoutingAlgorithmFactory
 {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final PreparationWeighting prepareWeighting;
@@ -60,15 +56,17 @@
     private EdgeSkipExplorer vehicleAllExplorer;
     private EdgeSkipExplorer vehicleAllTmpExplorer;
     private EdgeSkipExplorer calcPrioAllExplorer;
-    private LevelGraph g;
+    private final LevelEdgeFilter levelFilter;
+    private int maxLevel;
+    private final LevelGraph prepareGraph;
+
     // the most important nodes comes last
     private GHTreeMapComposed sortedNodes;
     private int oldPriorities[];
     private final DataAccess originalEdges;
     private final Map<Shortcut, Shortcut> shortcuts = new HashMap<Shortcut, Shortcut>();
     private IgnoreNodeFilter ignoreNodeFilter;
-    private DijkstraOneToMany algo;
-    private boolean removesHigher2LowerEdges = true;
+    private DijkstraOneToMany prepareAlgo;
     private long counter;
     private int newShortcuts;
     private long dijkstraCount;
@@ -83,29 +81,23 @@
     private double nodesContractedPercentage = 100;
     private double logMessagesPercentage = 20;
 
-    public PrepareContractionHierarchies( FlagEncoder encoder, Weighting weighting, TraversalMode traversalMode )
+    public PrepareContractionHierarchies( Directory dir, LevelGraph g, FlagEncoder encoder, Weighting weighting, TraversalMode traversalMode )
     {
+        this.prepareGraph = g;
         this.traversalMode = traversalMode;
         this.prepareFlagEncoder = encoder;
         long scFwdDir = encoder.setAccess(0, true, false);
+        levelFilter = new LevelEdgeFilter(prepareGraph);
 
         // shortcuts store weight in flags where we assume bit 1 and 2 are used for access restriction
         if ((scFwdDir & PrepareEncoder.getScFwdDir()) == 0)
-            throw new IllegalArgumentException("Currently only one vehicle is supported if you enable CH. "
-                    + "It seems that you have imported more than one.");
+            throw new IllegalArgumentException("Enabling the speed-up mode is currently only supported for the first vehicle.");
 
         prepareWeighting = new PreparationWeighting(weighting);
-        originalEdges = new GHDirectory("", DAType.RAM_INT).find("originalEdges");
+        originalEdges = dir.find("original_edges");
         originalEdges.create(1000);
     }
 
-    @Override
-    public PrepareContractionHierarchies setGraph( Graph g )
-    {
-        this.g = (LevelGraph) g;
-        return this;
-    }
-
     /**
      * The higher the values are the longer the preparation takes but the less shortcuts are
      * produced.
@@ -188,22 +180,9 @@ public void setInitialCollectionSize( int initialCollectionSize )
         this.initialCollectionSize = initialCollectionSize;
     }
 
-    /**
-     * Disconnect is very important to improve query time and preparation if enabled. It will remove
-     * the edge going from the higher level node to the currently contracted one. But the original
-     * graph is no longer available, so it is only useful for bidirectional CH algorithms. Default
-     * is true.
-     */
-    public PrepareContractionHierarchies setRemoveHigher2LowerEdges( boolean removeHigher2LowerEdges )
-    {
-        this.removesHigher2LowerEdges = removeHigher2LowerEdges;
-        return this;
-    }
-
     @Override
-    public PrepareContractionHierarchies doWork()
+    public void doWork()
     {
-        checkGraph();
         if (prepareFlagEncoder == null)
             throw new IllegalStateException("No vehicle encoder set.");
 
@@ -215,18 +194,17 @@ public PrepareContractionHierarchies doWork()
 
         initFromGraph();
         if (!prepareEdges())
-            return this;
+            return;
 
         if (!prepareNodes())
-            return this;
+            return;
 
         contractNodes();
-        return this;
     }
 
     boolean prepareEdges()
     {
-        EdgeIterator iter = g.getAllEdges();
+        EdgeIterator iter = prepareGraph.getAllEdges();
         int c = 0;
         while (iter.next())
         {
@@ -236,15 +214,15 @@ boolean prepareEdges()
         return c > 0;
     }
 
-    // TODO we can avoid node level if we store this into a temporary array and 
-    // disconnect all edges which goes from higher to lower level
-    // uninitialized nodes have a level of 0
-    // TODO we could avoid the second storage for skippedEdge as we could store that info into linkB or A if it is disconnected
     boolean prepareNodes()
     {
-        int len = g.getNodes();
+        int nodes = prepareGraph.getNodes();
+        for (int node = 0; node < nodes; node++)
+        {
+            prepareGraph.setLevel(node, maxLevel);
+        }
 
-        for (int node = 0; node < len; node++)
+        for (int node = 0; node < nodes; node++)
         {
             int priority = oldPriorities[node] = calculatePriority(node);
             sortedNodes.insert(node, priority);
@@ -258,7 +236,7 @@ boolean prepareNodes()
 
     void contractNodes()
     {
-        meanDegree = g.getAllEdges().getMaxId() / g.getNodes();
+        meanDegree = prepareGraph.getAllEdges().getCount() / prepareGraph.getNodes();
         int level = 1;
         counter = 0;
         int initSize = sortedNodes.getSize();
@@ -277,7 +255,7 @@ void contractNodes()
 
         // disable as preparation is slower and query time does not benefit
         long lastNodesLazyUpdates = lastNodesLazyUpdatePercentage == 0
-                ? 0l
+                ? 0L
                 : Math.round(sortedNodes.getSize() / 100d * lastNodesLazyUpdatePercentage);
 
         // according to paper "Polynomial-time Construction of Contraction Hierarchies for Multi-criteria Objectives" by Funke and Storandt
@@ -293,7 +271,7 @@ void contractNodes()
             neighborUpdate = false;
 
         StopWatch neighborSW = new StopWatch();
-        LevelGraphStorage lg = ((LevelGraphStorage) g);
+        LevelGraphStorage levelGraphCast = ((LevelGraphStorage) prepareGraph);
         while (!sortedNodes.isEmpty())
         {
             // periodically update priorities of ALL nodes            
@@ -301,10 +279,10 @@ void contractNodes()
             {
                 periodSW.start();
                 sortedNodes.clear();
-                int len = g.getNodes();
+                int len = prepareGraph.getNodes();
                 for (int node = 0; node < len; node++)
                 {
-                    if (g.getLevel(node) != 0)
+                    if (prepareGraph.getLevel(node) != maxLevel)
                         continue;
 
                     int priority = oldPriorities[node] = calculatePriority(node);
@@ -327,7 +305,7 @@ void contractNodes()
                         + ", t(lazy):" + (int) lazySW.getSeconds()
                         + ", t(neighbor):" + (int) neighborSW.getSeconds()
                         + ", meanDegree:" + (long) meanDegree
-                        + ", algo:" + algo.getMemoryUsageAsString()
+                        + ", algo:" + prepareAlgo.getMemoryUsageAsString()
                         + ", " + Helper.getMemInfo());
                 dijkstraSW = new StopWatch();
                 periodSW = new StopWatch();
@@ -353,25 +331,18 @@ void contractNodes()
 
             // contract!            
             newShortcuts += addShortcuts(polledNode);
-            g.setLevel(polledNode, level);
+            prepareGraph.setLevel(polledNode, level);
             level++;
 
             if (sortedNodes.getSize() < nodesToAvoidContract)
-            {
-                while (!sortedNodes.isEmpty())
-                {
-                    polledNode = sortedNodes.pollKey();
-                    g.setLevel(polledNode, level);
-                }
+                // skipped nodes are already set to maxLevel
                 break;
-            }
 
             EdgeSkipIterator iter = vehicleAllExplorer.setBaseNode(polledNode);
             while (iter.next())
             {
                 int nn = iter.getAdjNode();
-                if (g.getLevel(nn) != 0)
-                    // already contracted no update necessary
+                if (prepareGraph.getLevel(nn) != maxLevel)
                     continue;
 
                 if (neighborUpdate && rand.nextInt(100) < neighborUpdatePercentage)
@@ -385,8 +356,7 @@ void contractNodes()
                     neighborSW.stop();
                 }
 
-                if (removesHigher2LowerEdges)
-                    lg.disconnect(vehicleAllTmpExplorer, iter);
+                levelGraphCast.disconnect(vehicleAllTmpExplorer, iter);
             }
         }
 
@@ -397,7 +367,6 @@ void contractNodes()
                 + ", new shortcuts: " + newShortcuts
                 + ", " + prepareWeighting
                 + ", " + prepareFlagEncoder
-                + ", removeHigher2LowerEdges:" + removesHigher2LowerEdges
                 + ", dijkstras:" + dijkstraCount
                 + ", t(dijk):" + (int) dijkstraSW.getSeconds()
                 + ", t(period):" + (int) periodSW.getSeconds()
@@ -407,26 +376,27 @@ void contractNodes()
                 + ", initSize:" + initSize
                 + ", periodic:" + periodicUpdatesPercentage
                 + ", lazy:" + lastNodesLazyUpdatePercentage
-                + ", neighbor:" + neighborUpdatePercentage                
+                + ", neighbor:" + neighborUpdatePercentage
                 + ", " + Helper.getMemInfo());
     }
 
     public void close()
     {
-        algo.close();
+        prepareAlgo.close();
         originalEdges.close();
         sortedNodes = null;
         oldPriorities = null;
     }
+
     AddShortcutHandler addScHandler = new AddShortcutHandler();
     CalcShortcutHandler calcScHandler = new CalcShortcutHandler();
 
     interface ShortcutHandler
     {
         void foundShortcut( int u_fromNode, int w_toNode,
-                double existingDirectWeight, double distance,
-                EdgeIterator outgoingEdges,
-                int skippedEdge1, int incomingEdgeOrigCount );
+                            double existingDirectWeight, double distance,
+                            EdgeIterator outgoingEdges,
+                            int skippedEdge1, int incomingEdgeOrigCount );
 
         int getNode();
     }
@@ -453,9 +423,9 @@ public int getNode()
 
         @Override
         public void foundShortcut( int u_fromNode, int w_toNode,
-                double existingDirectWeight, double distance,
-                EdgeIterator outgoingEdges,
-                int skippedEdge1, int incomingEdgeOrigCount )
+                                   double existingDirectWeight, double distance,
+                                   EdgeIterator outgoingEdges,
+                                   int skippedEdge1, int incomingEdgeOrigCount )
         {
             shortcuts++;
             originalEdgesCount += incomingEdgeOrigCount + getOrigEdgeCount(outgoingEdges.getEdge());
@@ -485,17 +455,15 @@ public AddShortcutHandler setNode( int n )
 
         @Override
         public void foundShortcut( int u_fromNode, int w_toNode,
-                double existingDirectWeight, double existingDistSum,
-                EdgeIterator outgoingEdges,
-                int skippedEdge1, int incomingEdgeOrigCount )
+                                   double existingDirectWeight, double existingDistSum,
+                                   EdgeIterator outgoingEdges,
+                                   int skippedEdge1, int incomingEdgeOrigCount )
         {
             // FOUND shortcut 
             // but be sure that it is the only shortcut in the collection 
             // and also in the graph for u->w. If existing AND identical weight => update setProperties.
             // Hint: shortcuts are always one-way due to distinct level of every node but we don't
             // know yet the levels so we need to determine the correct direction or if both directions
-            // minor improvement: if (shortcuts.containsKey(sc) 
-            // then two shortcuts with the same nodes (u<->n.adjNode) exists => check current shortcut against both
             Shortcut sc = new Shortcut(u_fromNode, w_toNode, existingDirectWeight, existingDistSum);
             if (shortcuts.containsKey(sc))
                 return;
@@ -587,7 +555,7 @@ void findShortcuts( ShortcutHandler sch )
         {
             int u_fromNode = incomingEdges.getAdjNode();
             // accept only uncontracted nodes
-            if (g.getLevel(u_fromNode) != 0)
+            if (prepareGraph.getLevel(u_fromNode) != maxLevel)
                 continue;
 
             double v_u_dist = incomingEdges.getDistance();
@@ -597,13 +565,13 @@ void findShortcuts( ShortcutHandler sch )
             // collect outgoing nodes (goal-nodes) only once
             EdgeIterator outgoingEdges = vehicleOutExplorer.setBaseNode(sch.getNode());
             // force fresh maps etc as this cannot be determined by from node alone (e.g. same from node but different avoidNode)
-            algo.clear();
+            prepareAlgo.clear();
             tmpDegreeCounter++;
             while (outgoingEdges.next())
             {
                 int w_toNode = outgoingEdges.getAdjNode();
                 // add only uncontracted nodes
-                if (g.getLevel(w_toNode) != 0 || u_fromNode == w_toNode)
+                if (prepareGraph.getLevel(w_toNode) != maxLevel || u_fromNode == w_toNode)
                     continue;
 
                 // Limit weight as ferries or forbidden edges can increase local search too much.
@@ -612,23 +580,24 @@ void findShortcuts( ShortcutHandler sch )
                 double existingDirectWeight = v_u_weight + prepareWeighting.calcWeight(outgoingEdges, false, incomingEdges.getEdge());
                 if (Double.isNaN(existingDirectWeight))
                     throw new IllegalStateException("Weighting should never return NaN values"
-                            + ", in:" + getCoords(incomingEdges, g) + ", out:" + getCoords(outgoingEdges, g)
+                            + ", in:" + getCoords(incomingEdges, prepareGraph) + ", out:" + getCoords(outgoingEdges, prepareGraph)
                             + ", dist:" + outgoingEdges.getDistance() + ", speed:" + prepareFlagEncoder.getSpeed(outgoingEdges.getFlags()));
 
-                if (existingDirectWeight >= Double.MAX_VALUE)
+                if (Double.isInfinite(existingDirectWeight))
                     continue;
+
                 double existingDistSum = v_u_dist + outgoingEdges.getDistance();
-                algo.setLimitWeight(existingDirectWeight)
-                        .setLimitVisitedNodes((int) meanDegree * 100)
+                prepareAlgo.setWeightLimit(existingDirectWeight);
+                prepareAlgo.setLimitVisitedNodes((int) meanDegree * 100)
                         .setEdgeFilter(ignoreNodeFilter.setAvoidNode(sch.getNode()));
 
                 dijkstraSW.start();
                 dijkstraCount++;
-                int endNode = algo.findEndNode(u_fromNode, w_toNode);
+                int endNode = prepareAlgo.findEndNode(u_fromNode, w_toNode);
                 dijkstraSW.stop();
 
                 // compare end node as the limit could force dijkstra to finish earlier
-                if (endNode == w_toNode && algo.getWeight(endNode) <= existingDirectWeight)
+                if (endNode == w_toNode && prepareAlgo.getWeight(endNode) <= existingDirectWeight)
                     // FOUND witness path, so do not add shortcut                
                     continue;
 
@@ -672,10 +641,10 @@ int addShortcuts( int v )
                     {
                         throw new IllegalStateException("Shortcut cannot update itself! " + iter.getEdge()
                                 + ", skipEdge1:" + sc.skippedEdge1 + ", skipEdge2:" + sc.skippedEdge2
-                                + ", edge " + iter + ":" + getCoords(iter, g)
+                                + ", edge " + iter + ":" + getCoords(iter, prepareGraph)
                                 + ", sc:" + sc
-                                + ", skippedEdge1: " + getCoords(g.getEdgeProps(sc.skippedEdge1, sc.from), g)
-                                + ", skippedEdge2: " + getCoords(g.getEdgeProps(sc.skippedEdge2, sc.to), g)
+                                + ", skippedEdge1: " + getCoords(prepareGraph.getEdgeProps(sc.skippedEdge1, sc.from), prepareGraph)
+                                + ", skippedEdge2: " + getCoords(prepareGraph.getEdgeProps(sc.skippedEdge2, sc.to), prepareGraph)
                                 + ", neighbors:" + GHUtility.getNeighbors(iter));
                     }
 
@@ -692,7 +661,7 @@ int addShortcuts( int v )
 
             if (!updatedInGraph)
             {
-                EdgeSkipIterState edgeState = g.shortcut(sc.from, sc.to);
+                EdgeSkipIterState edgeState = prepareGraph.shortcut(sc.from, sc.to);
                 // note: flags overwrite weight => call first
                 edgeState.setFlags(sc.flags);
                 edgeState.setWeight(sc.weight);
@@ -716,20 +685,37 @@ String getCoords( EdgeIteratorState e, Graph g )
 
     PrepareContractionHierarchies initFromGraph()
     {
-        checkGraph();
-        vehicleInExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
-        vehicleOutExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
-        vehicleAllExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
-        vehicleAllTmpExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
-        calcPrioAllExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
-        ignoreNodeFilter = new IgnoreNodeFilter(g);
+        vehicleInExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
+        vehicleOutExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
+        final EdgeFilter allFilter = new DefaultEdgeFilter(prepareFlagEncoder, true, true);
+
+        // filter by vehicle and level number
+        final EdgeFilter accessWithLevelFilter = new LevelEdgeFilter(prepareGraph)
+        {
+            @Override
+            public final boolean accept( EdgeIteratorState edgeState )
+            {
+                if (!super.accept(edgeState))
+                    return false;
+
+                return allFilter.accept(edgeState);
+            }
+        };
+
+        maxLevel = prepareGraph.getNodes() + 1;
+        ignoreNodeFilter = new IgnoreNodeFilter(prepareGraph, maxLevel);
+        vehicleAllExplorer = prepareGraph.createEdgeExplorer(allFilter);
+        vehicleAllTmpExplorer = prepareGraph.createEdgeExplorer(allFilter);
+        calcPrioAllExplorer = prepareGraph.createEdgeExplorer(accessWithLevelFilter);
+
         // Use an alternative to PriorityQueue as it has some advantages: 
-        //   1. Gets automatically smaller if less entries are stored => less total RAM used (as Graph is increasing until the end)
+        //   1. Gets automatically smaller if less entries are stored => less total RAM used. 
+        //      Important because Graph is increasing until the end.
         //   2. is slightly faster
-        //   but we need additional priorities array to keep old value which is necessary for update method
+        //   but we need the additional oldPriorities array to keep the old value which is necessary for the update method
         sortedNodes = new GHTreeMapComposed();
-        oldPriorities = new int[g.getNodes()];
-        algo = new DijkstraOneToMany(g, prepareFlagEncoder, prepareWeighting, traversalMode);
+        oldPriorities = new int[prepareGraph.getNodes()];
+        prepareAlgo = new DijkstraOneToMany(prepareGraph, prepareFlagEncoder, prepareWeighting, traversalMode);
         return this;
     }
 
@@ -741,11 +727,13 @@ public int getShortcuts()
     static class IgnoreNodeFilter implements EdgeFilter
     {
         int avoidNode;
+        int maxLevel;
         LevelGraph graph;
 
-        public IgnoreNodeFilter( LevelGraph g )
+        public IgnoreNodeFilter( LevelGraph g, int maxLevel )
         {
             this.graph = g;
+            this.maxLevel = maxLevel;
         }
 
         public IgnoreNodeFilter setAvoidNode( int node )
@@ -757,9 +745,9 @@ public IgnoreNodeFilter setAvoidNode( int node )
         @Override
         public final boolean accept( EdgeIteratorState iter )
         {
-            // ignore if it is skipNode or a adjNode already contracted
+            // ignore if it is skipNode or adjNode is already contracted
             int node = iter.getAdjNode();
-            return avoidNode != node && graph.getLevel(node) == 0;
+            return avoidNode != node && graph.getLevel(node) == maxLevel;
         }
     }
 
@@ -779,110 +767,112 @@ private int getOrigEdgeCount( int index )
     }
 
     @Override
-    public RoutingAlgorithm createAlgo()
+    public RoutingAlgorithm createAlgo( Graph graph, AlgorithmOptions opts )
     {
-        checkGraph();
-        // do not change weight within DijkstraBidirectionRef => so use ShortestWeighting
-        DijkstraBidirectionRef dijkstrabi = new DijkstraBidirectionRef(g, prepareFlagEncoder, prepareWeighting, traversalMode)
+        AbstractBidirAlgo algo;
+        if (AlgorithmOptions.ASTAR_BI.equals(opts.getAlgorithm()))
         {
-            @Override
-            protected void initCollections( int nodes )
-            {
-                // algorithm with CH does not need that much memory pre allocated
-                super.initCollections(Math.min(initialCollectionSize, nodes));
-            }
-
-            @Override
-            public boolean finished()
+            AStarBidirection astarBi = new AStarBidirection(graph, prepareFlagEncoder, prepareWeighting, traversalMode)
             {
-                // we need to finish BOTH searches for CH!
-                if (finishedFrom && finishedTo)
-                    return true;
+                @Override
+                protected void initCollections( int nodes )
+                {
+                    // algorithm with CH does not need that much memory pre allocated
+                    super.initCollections(Math.min(initialCollectionSize, nodes));
+                }
 
-                // changed also the final finish condition for CH                
-                return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
-            }
+                @Override
+                protected boolean finished()
+                {
+                    // we need to finish BOTH searches for CH!
+                    if (finishedFrom && finishedTo)
+                        return true;
 
-            @Override
-            protected Path createAndInitPath()
-            {
-                bestPath = new Path4CH(graph, flagEncoder);
-                return bestPath;
-            }
+                    // changed finish condition for CH
+                    return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
+                }
 
-            @Override
-            public String getName()
-            {
-                return "dijkstrabiCH";
-            }
+                @Override
+                protected boolean isWeightLimitExceeded()
+                {
+                    return currFrom.weight > weightLimit && currTo.weight > weightLimit;
+                }
 
-            @Override
-            public String toString()
-            {
-                return getName() + "|" + prepareWeighting;
-            }
-        };
+                @Override
+                protected Path createAndInitPath()
+                {
+                    bestPath = new Path4CH(graph, graph.getBaseGraph(), flagEncoder);
+                    return bestPath;
+                }
 
-        if (!removesHigher2LowerEdges)
-            dijkstrabi.setEdgeFilter(new LevelEdgeFilter(g));
+                @Override
+                public String getName()
+                {
+                    return "astarbiCH";
+                }
 
-        return dijkstrabi;
-    }
+                @Override
 
-    public AStarBidirection createAStar()
-    {
-        checkGraph();
-        AStarBidirection astar = new AStarBidirection(g, prepareFlagEncoder, prepareWeighting, traversalMode)
+                public String toString()
+                {
+                    return getName() + "|" + prepareWeighting;
+                }
+            };
+            algo = astarBi;
+        } else if (AlgorithmOptions.DIJKSTRA_BI.equals(opts.getAlgorithm()))
         {
-            @Override
-            protected void initCollections( int nodes )
-            {
-                // algorithm with CH does not need that much memory pre allocated
-                super.initCollections(Math.min(initialCollectionSize, nodes));
-            }
-
-            @Override
-            protected boolean finished()
+            algo = new DijkstraBidirectionRef(graph, prepareFlagEncoder, prepareWeighting, traversalMode)
             {
-                // we need to finish BOTH searches for CH!
-                if (finishedFrom && finishedTo)
-                    return true;
+                @Override
+                protected void initCollections( int nodes )
+                {
+                    // algorithm with CH does not need that much memory pre allocated
+                    super.initCollections(Math.min(initialCollectionSize, nodes));
+                }
 
-                // changed finish condition for CH
-                double tmpWeight = bestPath.getWeight() * approximationFactor;
-                return currFrom.weight >= tmpWeight && currTo.weight >= tmpWeight;
-            }
+                @Override
+                public boolean finished()
+                {
+                    // we need to finish BOTH searches for CH!
+                    if (finishedFrom && finishedTo)
+                        return true;
 
-            @Override
-            protected Path createAndInitPath()
-            {
-                bestPath = new Path4CH(graph, flagEncoder);
-                return bestPath;
-            }
+                    // changed also the final finish condition for CH                
+                    return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
+                }
 
-            @Override
-            public String getName()
-            {
-                return "astarbiCH";
-            }
+                @Override
+                protected boolean isWeightLimitExceeded()
+                {
+                    return currFrom.weight > weightLimit && currTo.weight > weightLimit;
+                }
 
-            @Override
-            public String toString()
-            {
-                return getName() + "|" + prepareWeighting;
-            }
-        };
+                @Override
+                protected Path createAndInitPath()
+                {
+                    bestPath = new Path4CH(graph, graph.getBaseGraph(), flagEncoder);
+                    return bestPath;
+                }
 
-        if (!removesHigher2LowerEdges)
-            astar.setEdgeFilter(new LevelEdgeFilter(g));
+                @Override
+                public String getName()
+                {
+                    return "dijkstrabiCH";
+                }
 
-        return astar;
-    }
+                @Override
+                public String toString()
+                {
+                    return getName() + "|" + prepareWeighting;
+                }
+            };
+        } else
+        {
+            throw new UnsupportedOperationException("Algorithm " + opts.getAlgorithm() + " not supported for Contraction Hierarchies");
+        }
 
-    private void checkGraph()
-    {
-        if (g == null)
-            throw new NullPointerException("setGraph before usage");
+        algo.setEdgeFilter(levelFilter);
+        return algo;
     }
 
     private static class PriorityNode implements Comparable<PriorityNode>
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
index 6aee636cba..7fed0cca87 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
@@ -21,7 +21,7 @@
 /**
  * The flags are stored differently for shortcuts: just a weight and the direction flags. Currently
  * it is not allowed to store multiple vehicles.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class PrepareEncoder
@@ -44,7 +44,7 @@ public static final long getScFwdDir()
     /**
      * Returns true if flags1 can be overwritten in the edge by flags2 without restricting or
      * changing the directions of flags1.
-     * <p>
+     * <p/>
      * @return true if flags2 is enabled in both directions or if both flags are pointing into the
      * same direction.
      */
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java b/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java
index c98da4c65a..3de7c2c89a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java
@@ -17,36 +17,21 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.storage.Graph;
-
 /**
  * @author Peter Karich
  */
-public abstract class AbstractAlgoPreparation<T extends AlgorithmPreparation> implements AlgorithmPreparation
+public abstract class AbstractAlgoPreparation
 {
-    protected Graph _graph;
     private boolean prepared = false;
 
-    @Override
-    public AlgorithmPreparation setGraph( Graph g )
-    {
-        _graph = g;
-        return this;
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public T doWork()
+    public void doWork()
     {
         if (prepared)
             throw new IllegalStateException("Call doWork only once!");
 
         prepared = true;
-        // no operation        
-        return (T) this;
     }
 
-    @Override
     public boolean isPrepared()
     {
         return prepared;
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index 87d64cf311..03801d4a92 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -17,19 +17,14 @@
  */
 package com.graphhopper.routing.util;
 
-import java.util.Collection;
-import java.util.HashSet;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import com.graphhopper.reader.OSMNode;
-import com.graphhopper.reader.OSMReader;
-import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.util.*;
+
 import java.util.*;
 
 /**
@@ -44,7 +39,7 @@
 public abstract class AbstractFlagEncoder implements FlagEncoder, TurnCostEncoder
 {
     private final static Logger logger = LoggerFactory.getLogger(AbstractFlagEncoder.class);
-
+    protected final static int K_FORWARD = 0, K_BACKWARD = 1;
     /* Edge Flag Encoder fields */
     private long nodeBitMask;
     private long wayBitMask;
@@ -58,6 +53,12 @@
     protected long acceptBit;
     protected long ferryBit;
 
+    protected PMap properties;
+
+    // This value determines the maximal possible speed of any road regardless the maxspeed value
+    // lower values allow more compact representation of the routing graph
+    protected int maxPossibleSpeed;
+
     private EncodedValue turnCostEncoder;
     private long turnRestrictionBit;
     private final int maxTurnCosts;
@@ -68,19 +69,29 @@
 
     /* restriction definitions where order is important */
     protected final List<String> restrictions = new ArrayList<String>(5);
-    protected final HashSet<String> intendedValues = new HashSet<String>(5);
-    protected final HashSet<String> restrictedValues = new HashSet<String>(5);
-    protected final HashSet<String> ferries = new HashSet<String>(5);
-    protected final HashSet<String> oneways = new HashSet<String>(5);
-    protected final HashSet<String> acceptedRailways = new HashSet<String>(5);
+    protected final Set<String> intendedValues = new HashSet<String>(5);
+    protected final Set<String> restrictedValues = new HashSet<String>(5);
+    protected final Set<String> ferries = new HashSet<String>(5);
+    protected final Set<String> oneways = new HashSet<String>(5);
+    protected final Set<String> acceptedRailways = new HashSet<String>(5);
     // http://wiki.openstreetmap.org/wiki/Mapfeatures#Barrier
-    protected final HashSet<String> absoluteBarriers = new HashSet<String>(5);
-    protected final HashSet<String> potentialBarriers = new HashSet<String>(5);
+    protected final Set<String> absoluteBarriers = new HashSet<String>(5);
+    protected final Set<String> potentialBarriers = new HashSet<String>(5);
     private boolean blockByDefault = true;
     private boolean blockFords = true;
     protected final int speedBits;
     protected final double speedFactor;
 
+    public AbstractFlagEncoder( PMap properties )
+    {
+        throw new RuntimeException("This method must be overridden in derived classes");
+    }
+
+    public AbstractFlagEncoder( String propertiesStr )
+    {
+        this(new PMap(propertiesStr));
+    }
+
     /**
      * @param speedBits specify the number of bits used for speed
      * @param speedFactor specify the factor to multiple the stored value (can be used to increase
@@ -132,7 +143,7 @@ public boolean isBlockFords()
 
     /**
      * Defines the bits for the node flags, which are currently used for barriers only.
-     * <p>
+     * <p/>
      * @return incremented shift value pointing behind the last used bit
      */
     public int defineNodeBits( int index, int shift )
@@ -143,7 +154,6 @@ public int defineNodeBits( int index, int shift )
     /**
      * Defines bits used for edge flags used for access, speed etc.
      * <p/>
-     * @param index
      * @param shift bit offset for the first bit used by this encoder
      * @return incremented shift value pointing behind the last used bit
      */
@@ -170,7 +180,7 @@ public int defineWayBits( int index, int shift )
 
     /**
      * Defines the bits which are used for relation flags.
-     * <p>
+     * <p/>
      * @return incremented shift value pointing behind the last used bit
      */
     public int defineRelationBits( int index, int shift )
@@ -230,11 +240,16 @@ public long handleNodeTags( OSMNode node )
                 return directionBitMask;
         }
 
+        // In case explicit flag ford=no, don't block
         if (blockFords
                 && (node.hasTag("highway", "ford") || node.hasTag("ford"))
-                && !node.hasTag(restrictions, intendedValues))
+                && !node.hasTag(restrictions, intendedValues)
+                && !node.hasTag("ford", "no"))
+        {
             return directionBitMask;
 
+        }
+
         return 0;
     }
 
@@ -276,15 +291,24 @@ public long setAccess( long flags, boolean forward, boolean backward )
     @Override
     public long setSpeed( long flags, double speed )
     {
-        if (speed < 0)
-            throw new IllegalArgumentException("Speed cannot be negative: " + speed
+        if (speed < 0 || Double.isNaN(speed))
+            throw new IllegalArgumentException("Speed cannot be negative or NaN: " + speed
                     + ", flags:" + BitUtil.LITTLE.toBitString(flags));
 
+        if (speed < speedEncoder.factor / 2)
+            return setLowSpeed(flags, speed, false);
+
         if (speed > getMaxSpeed())
             speed = getMaxSpeed();
+
         return speedEncoder.setDoubleValue(flags, speed);
     }
 
+    protected long setLowSpeed( long flags, double speed, boolean reverse )
+    {
+        return setAccess(speedEncoder.setDoubleValue(flags, 0), false, false);
+    }
+
     @Override
     public double getSpeed( long flags )
     {
@@ -364,11 +388,24 @@ public boolean equals( Object obj )
     /**
      * @return the speed in km/h
      */
-    protected static double parseSpeed( String str )
+    protected double parseSpeed( String str )
     {
         if (Helper.isEmpty(str))
             return -1;
 
+        // on some German autobahns and a very few other places
+        if ("none".equals(str))
+            return 140;
+
+        if (str.endsWith(":rural") || str.endsWith(":trunk"))
+            return 80;
+
+        if (str.endsWith(":urban"))
+            return 50;
+
+        if (str.equals("walk") || str.endsWith(":living_street"))
+            return 6;
+
         try
         {
             int val;
@@ -541,7 +578,7 @@ long getNodeBitMask()
 
     /**
      * Defines the bits reserved for storing turn restriction and turn cost
-     * <p>
+     * <p/>
      * @param shift bit offset for the first bit used by this encoder
      * @return incremented shift value pointing behind the last used bit
      */
@@ -550,7 +587,7 @@ public int defineTurnBits( int index, int shift )
         if (maxTurnCosts == 0)
             return shift;
 
-        // optimization for turn restrictions only 
+        // optimization for turn restrictions only
         else if (maxTurnCosts == 1)
         {
             turnRestrictionBit = 1L << shift;
@@ -566,7 +603,7 @@ public final long getValue( long flags )
             {
                 // find value
                 flags &= mask;
-                flags >>= shift;
+                flags >>>= shift;
                 return flags;
             }
         };
@@ -633,19 +670,6 @@ else if (maxTurnCosts == 1)
         return turnCostEncoder.setValue(0L, (int) costs);
     }
 
-    public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
-    {
-        if (!supports(TurnWeighting.class))
-            return Collections.emptyList();
-
-        if (edgeOutExplorer == null || edgeInExplorer == null)
-        {
-            edgeOutExplorer = osmReader.getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(this, false, true));
-            edgeInExplorer = osmReader.getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(this, true, false));
-        }
-        return turnRelation.getRestrictionAsEntries(this, edgeOutExplorer, edgeInExplorer, osmReader);
-    }
-
     protected boolean isFerry( long internalFlags )
     {
         return (internalFlags & ferryBit) != 0;
@@ -656,6 +680,18 @@ protected boolean isAccept( long internalFlags )
         return (internalFlags & acceptBit) != 0;
     }
 
+    @Override
+    public boolean isBackward( long flags )
+    {
+        return (flags & backwardBit) != 0;
+    }
+
+    @Override
+    public boolean isForward( long flags )
+    {
+        return (flags & forwardBit) != 0;
+    }
+
     @Override
     public long setBool( long flags, int key, boolean value )
     {
@@ -678,9 +714,9 @@ public boolean isBool( long flags, int key )
         switch (key)
         {
             case K_FORWARD:
-                return (flags & forwardBit) != 0;
+                return isForward(flags);
             case K_BACKWARD:
-                return (flags & backwardBit) != 0;
+                return isBackward(flags);
             case K_ROUNDABOUT:
                 return (flags & roundaboutBit) != 0;
             default:
@@ -712,6 +748,7 @@ public double getDouble( long flags, int key )
         throw new UnsupportedOperationException("Unknown key " + key + " for double value.");
     }
 
+    @Deprecated
     protected static double parseDouble( String str, String key, double defaultD )
     {
         String val = getStr(str, key);
@@ -720,6 +757,7 @@ protected static double parseDouble( String str, String key, double defaultD )
         return Double.parseDouble(val);
     }
 
+    @Deprecated
     protected static long parseLong( String str, String key, long defaultL )
     {
         String val = getStr(str, key);
@@ -728,6 +766,7 @@ protected static long parseLong( String str, String key, long defaultL )
         return Long.parseLong(val);
     }
 
+    @Deprecated
     protected static boolean parseBoolean( String str, String key, boolean defaultB )
     {
         String val = getStr(str, key);
@@ -736,6 +775,7 @@ protected static boolean parseBoolean( String str, String key, boolean defaultB
         return Boolean.parseBoolean(val);
     }
 
+    @Deprecated
     protected static String getStr( String str, String key )
     {
         key = key.toLowerCase();
diff --git a/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java b/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
index 3f256b5280..3a88c83a7b 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
@@ -24,5 +24,8 @@
  */
 public interface AllEdgesIterator extends EdgeIterator
 {
-    int getMaxId();
+    /**
+     * @return the number of edges
+     */
+    int getCount();
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
new file mode 100644
index 0000000000..6164434da5
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
@@ -0,0 +1,55 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.Helper;
+
+/**
+ * Approximates the distance to the goal node by weighting the beeline distance according to the
+ * distance weighting
+ * <p/>
+ * @author jansoe
+ */
+public class BeelineWeightApproximator implements WeightApproximator
+{
+    private final NodeAccess nodeAccess;
+    private final Weighting weighting;
+    private DistanceCalc distanceCalc = Helper.DIST_EARTH;
+    private double toLat, toLon;
+
+    public BeelineWeightApproximator( NodeAccess nodeAccess, Weighting weighting )
+    {
+        this.nodeAccess = nodeAccess;
+        this.weighting = weighting;
+    }
+
+    @Override
+    public void setGoalNode( int toNode )
+    {
+        toLat = nodeAccess.getLatitude(toNode);
+        toLon = nodeAccess.getLongitude(toNode);
+    }
+
+    @Override
+    public WeightApproximator duplicate()
+    {
+        return new BeelineWeightApproximator(nodeAccess, weighting).setDistanceCalc(distanceCalc);
+    }
+
+    @Override
+    public double approximate( int fromNode )
+    {
+        double fromLat = nodeAccess.getLatitude(fromNode);
+        double fromLon = nodeAccess.getLongitude(fromNode);
+        double dist2goal = distanceCalc.calcDist(toLat, toLon, fromLat, fromLon);
+        double weight2goal = weighting.getMinWeight(dist2goal);
+        return weight2goal;
+    }
+
+    public BeelineWeightApproximator setDistanceCalc( DistanceCalc distanceCalc )
+    {
+        this.distanceCalc = distanceCalc;
+        return this;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
index 4fe1beb474..8f0d7eb0e4 100644
--- a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
@@ -21,17 +21,19 @@
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PMap;
 import com.graphhopper.util.PointList;
+
 import static com.graphhopper.util.Helper.*;
 
 /**
  * Stores two speed values into an edge to support avoiding too much incline
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class Bike2WeightFlagEncoder extends BikeFlagEncoder
 {
-    private EncodedDoubleValue reverseSpeed;
+    private EncodedDoubleValue reverseSpeedEncoder;
 
     public Bike2WeightFlagEncoder()
     {
@@ -40,7 +42,12 @@ public Bike2WeightFlagEncoder()
 
     public Bike2WeightFlagEncoder( String propertiesStr )
     {
-        super(propertiesStr);
+        super(new PMap(propertiesStr));
+    }
+
+    public Bike2WeightFlagEncoder( PMap properties )
+    {
+        super(properties);
     }
 
     public Bike2WeightFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
@@ -48,19 +55,26 @@ public Bike2WeightFlagEncoder( int speedBits, double speedFactor, int maxTurnCos
         super(speedBits, speedFactor, maxTurnCosts);
     }
 
+    @Override
+    public int getVersion()
+    {
+        return 1;
+    }
+
     @Override
     public int defineWayBits( int index, int shift )
     {
         shift = super.defineWayBits(index, shift);
-        reverseSpeed = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor, getHighwaySpeed("cycleway"), 30);
-        shift += reverseSpeed.getBits();
+        reverseSpeedEncoder = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor,
+                getHighwaySpeed("cycleway"), maxPossibleSpeed);
+        shift += reverseSpeedEncoder.getBits();
         return shift;
     }
 
     @Override
     public double getReverseSpeed( long flags )
     {
-        return reverseSpeed.getDoubleValue(flags);
+        return reverseSpeedEncoder.getDoubleValue(flags);
     }
 
     @Override
@@ -69,37 +83,36 @@ public long setReverseSpeed( long flags, double speed )
         if (speed < 0)
             throw new IllegalArgumentException("Speed cannot be negative: " + speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
 
+        if (speed < speedEncoder.factor / 2)
+            return setLowSpeed(flags, speed, true);
+
         if (speed > getMaxSpeed())
             speed = getMaxSpeed();
 
-        return reverseSpeed.setDoubleValue(flags, speed);
+        return reverseSpeedEncoder.setDoubleValue(flags, speed);
     }
 
     @Override
-    public long handleSpeed( OSMWay way, double speed, long encoded )
+    public long handleSpeed( OSMWay way, double speed, long flags )
     {
         // handle oneways
-        if ((way.hasTag("oneway", oneways) || way.hasTag("junction", "roundabout"))
-                && !way.hasTag("oneway:bicycle", "no")
-                && !way.hasTag("cycleway", oppositeLanes))
-        {
+        flags = super.handleSpeed(way, speed, flags);
+        if (isBackward(flags))
+            flags = setReverseSpeed(flags, speed);
 
-            if (way.hasTag("oneway", "-1"))
-            {
-                encoded |= backwardBit;
-                encoded = setReverseSpeed(encoded, speed);
-            } else
-            {
-                encoded |= forwardBit;
-                encoded = setSpeed(encoded, speed);
-            }
-        } else
-        {
-            encoded |= directionBitMask;
-            encoded = setSpeed(encoded, speed);
-            encoded = setReverseSpeed(encoded, speed);
-        }
-        return encoded;
+        if (isForward(flags))
+            flags = setSpeed(flags, speed);
+
+        return flags;
+    }
+
+    @Override
+    protected long setLowSpeed( long flags, double speed, boolean reverse )
+    {
+        if (reverse)
+            return setBool(reverseSpeedEncoder.setDoubleValue(flags, 0), K_BACKWARD, false);
+
+        return setBool(speedEncoder.setDoubleValue(flags, 0), K_FORWARD, false);
     }
 
     @Override
@@ -107,7 +120,7 @@ public long flagsDefault( boolean forward, boolean backward )
     {
         long flags = super.flagsDefault(forward, backward);
         if (backward)
-            return reverseSpeed.setDefaultValue(flags);
+            return reverseSpeedEncoder.setDefaultValue(flags);
 
         return flags;
     }
@@ -129,7 +142,7 @@ public long reverseFlags( long flags )
         flags = super.reverseFlags(flags);
 
         // swap speeds 
-        double otherValue = reverseSpeed.getDoubleValue(flags);
+        double otherValue = reverseSpeedEncoder.getDoubleValue(flags);
         flags = setReverseSpeed(flags, speedEncoder.getDoubleValue(flags));
         return setSpeed(flags, otherValue);
     }
@@ -156,9 +169,17 @@ public void applyWayTags( OSMWay way, EdgeIteratorState edge )
             double decEleSum = 0, decDist2DSum = 0;
             // double prevLat = pl.getLatitude(0), prevLon = pl.getLongitude(0);
             double prevEle = pl.getElevation(0);
-            double fullDist2D = 0;
+            double fullDist2D = edge.getDistance();
+
+            if (Double.isInfinite(fullDist2D))
+            {
+                System.err.println("infinity distance? for way:" + way.getId());
+                return;
+            }
+            // for short edges an incline makes no sense and for 0 distances could lead to NaN values for speed, see #432
+            if (fullDist2D < 1)
+                return;
 
-            fullDist2D = edge.getDistance();
             double eleDelta = pl.getElevation(pl.size() - 1) - prevEle;
             if (eleDelta > 0.1)
             {
@@ -199,7 +220,7 @@ public void applyWayTags( OSMWay way, EdgeIteratorState edge )
             double fwdDecline = decDist2DSum > 1 ? decEleSum / decDist2DSum : 0;
             double restDist2D = fullDist2D - incDist2DSum - decDist2DSum;
             double maxSpeed = getHighwaySpeed("cycleway");
-            if (isBool(flags, K_FORWARD))
+            if (isForward(flags))
             {
                 // use weighted mean so that longer incline infuences speed more than shorter
                 double speed = getSpeed(flags);
@@ -211,7 +232,7 @@ public void applyWayTags( OSMWay way, EdgeIteratorState edge )
                 flags = this.setSpeed(flags, keepIn(speed, PUSHING_SECTION_SPEED / 2, maxSpeed));
             }
 
-            if (isBool(flags, K_BACKWARD))
+            if (isBackward(flags))
             {
                 double speedReverse = getReverseSpeed(flags);
                 double bwFaster = 1 + 2 * keepIn(fwdIncline, 0, 0.2);
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index 084b956469..af99b1f01e 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -19,7 +19,9 @@
 
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.reader.OSMRelation;
+
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.InstructionAnnotation;
 import com.graphhopper.util.Translation;
@@ -47,16 +49,22 @@
     protected final Set<String> preferHighwayTags = new HashSet<String>();
     protected final Set<String> avoidHighwayTags = new HashSet<String>();
     protected final Set<String> unpavedSurfaceTags = new HashSet<String>();
-    private final Map<String, Integer> trackTypeSpeed = new HashMap<String, Integer>();
-    private final Map<String, Integer> surfaceSpeed = new HashMap<String, Integer>();
+    private final Map<String, Integer> trackTypeSpeeds = new HashMap<String, Integer>();
+    private final Map<String, Integer> surfaceSpeeds = new HashMap<String, Integer>();
     private final Set<String> roadValues = new HashSet<String>();
-    private final Map<String, Integer> highwaySpeed = new HashMap<String, Integer>();
+    private final Map<String, Integer> highwaySpeeds = new HashMap<String, Integer>();
     // convert network tag of bicycle routes into a way route code
     private final Map<String, Integer> bikeNetworkToCode = new HashMap<String, Integer>();
     protected EncodedValue relationCodeEncoder;
     private EncodedValue wayTypeEncoder;
     private EncodedValue preferWayEncoder;
 
+    // Car speed limit which switches the preference from UNCHANGED to AVOID_IF_POSSIBLE
+    private int avoidSpeedLimit;
+
+    // This is the specific bicycle class
+    private String specificBicycleClass;
+
     protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
     {
         super(speedBits, speedFactor, maxTurnCosts);
@@ -65,6 +73,7 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         restrictedValues.add("private");
         restrictedValues.add("no");
         restrictedValues.add("restricted");
+        restrictedValues.add("military");
 
         intendedValues.add("yes");
         intendedValues.add("designated");
@@ -80,10 +89,12 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         // potentialBarriers.add("lift_gate");
         potentialBarriers.add("swing_gate");
 
-        absoluteBarriers.add("kissing_gate");
         absoluteBarriers.add("stile");
         absoluteBarriers.add("turnstile");
 
+        // make intermodal connections possible but mark as pushing section
+        acceptedRailways.add("platform");
+
         unpavedSurfaceTags.add("unpaved");
         unpavedSurfaceTags.add("gravel");
         unpavedSurfaceTags.add("ground");
@@ -113,6 +124,8 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         roadValues.add("tertiary");
         roadValues.add("tertiary_link");
 
+        maxPossibleSpeed = 30;
+
         setTrackTypeSpeed("grade1", 18); // paved
         setTrackTypeSpeed("grade2", 12); // now unpaved ...
         setTrackTypeSpeed("grade3", 8);
@@ -150,7 +163,7 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         setHighwaySpeed("steps", PUSHING_SECTION_SPEED / 2);
 
         setHighwaySpeed("cycleway", 18);
-        setHighwaySpeed("path", 18);
+        setHighwaySpeed("path", 12);
         setHighwaySpeed("footway", 6);
         setHighwaySpeed("pedestrian", 6);
         setHighwaySpeed("track", 12);
@@ -183,6 +196,14 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         setCyclingNetworkPreference("mtb", PriorityCode.UNCHANGED.getValue());
 
         setCyclingNetworkPreference("deprecated", PriorityCode.AVOID_AT_ALL_COSTS.getValue());
+
+        setAvoidSpeedLimit(71);
+    }
+
+    @Override
+    public int getVersion()
+    {
+        return 1;
     }
 
     @Override
@@ -190,7 +211,8 @@ public int defineWayBits( int index, int shift )
     {
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
-        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, highwaySpeed.get("cycleway"), 30);
+        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, highwaySpeeds.get("cycleway"),
+                maxPossibleSpeed);
         shift += speedEncoder.getBits();
 
         unpavedBit = 1L << shift++;
@@ -224,10 +246,15 @@ public long acceptWay( OSMWay way )
                 if (bikeTag == null && !way.hasTag("foot") || "yes".equals(bikeTag))
                     return acceptBit | ferryBit;
             }
+
+            // special case not for all acceptedRailways, only platform
+            if (way.hasTag("railway", "platform"))
+                return acceptBit;
+
             return 0;
         }
 
-        if (!highwaySpeed.containsKey(highwayValue))
+        if (!highwaySpeeds.containsKey(highwayValue))
             return 0;
 
         // use the way if it is tagged for bikes
@@ -256,6 +283,9 @@ public long acceptWay( OSMWay way )
         String sacScale = way.getTag("sac_scale");
         if (sacScale != null)
         {
+            if ((way.hasTag("highway", "cycleway"))
+                    && (way.hasTag("sac_scale", "hiking")))
+                return acceptBit;
             if (!allowedSacScale(sacScale))
                 return 0;
         }
@@ -264,8 +294,8 @@ public long acceptWay( OSMWay way )
 
     boolean allowedSacScale( String sacScale )
     {
-        // other scales are nearly impossible by bike, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
-        return "hiking".equals(sacScale) || "mountain_hiking".equals(sacScale);
+        // other scales are nearly impossible by an ordinary bike, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
+        return "hiking".equals(sacScale);
     }
 
     @Override
@@ -309,12 +339,18 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
             encoded = handleSpeed(way, speed, encoded);
             encoded = handleBikeRelated(way, encoded, relationFlags > UNCHANGED.getValue());
 
+            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            if (isRoundabout)
+            {
+                encoded = setBool(encoded, K_ROUNDABOUT, true);
+            }
+
         } else
         {
             encoded = handleFerryTags(way,
-                    highwaySpeed.get("living_street"),
-                    highwaySpeed.get("track"),
-                    highwaySpeed.get("primary"));
+                    highwaySpeeds.get("living_street"),
+                    highwaySpeeds.get("track"),
+                    highwaySpeeds.get("primary"));
             encoded |= directionBitMask;
         }
         return encoded;
@@ -323,38 +359,47 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
     int getSpeed( OSMWay way )
     {
         int speed = PUSHING_SECTION_SPEED;
+        String highwayTag = way.getTag("highway");
+        Integer highwaySpeed = highwaySpeeds.get(highwayTag);
+
         String s = way.getTag("surface");
         if (!Helper.isEmpty(s))
         {
-            Integer sInt = surfaceSpeed.get(s);
-            if (sInt != null)
-                speed = sInt;
+            Integer surfaceSpeed = surfaceSpeeds.get(s);
+            if (surfaceSpeed != null)
+            {
+                speed = surfaceSpeed;
+                // Boost handling for good surfaces
+                if (highwaySpeed != null && surfaceSpeed > highwaySpeed)
+                {
+                    // Avoid boosting if pushing section
+                    if (pushingSections.contains(highwayTag))
+                        speed = highwaySpeed;
+                    else
+                        speed = surfaceSpeed;
+                }
+            }
         } else
         {
             String tt = way.getTag("tracktype");
             if (!Helper.isEmpty(tt))
             {
-                Integer tInt = trackTypeSpeed.get(tt);
+                Integer tInt = trackTypeSpeeds.get(tt);
                 if (tInt != null)
                     speed = tInt;
             } else
             {
-                String highway = way.getTag("highway");
-                if (!Helper.isEmpty(highway))
+                if (highwaySpeed != null)
                 {
-                    Integer hwInt = highwaySpeed.get(highway);
-                    if (hwInt != null)
-                    {
-                        if (way.getTag("service") == null)
-                            speed = hwInt;
-                        else
-                            speed = highwaySpeed.get("living_street");
-                    }
+                    if (!way.hasTag("service"))
+                        speed = highwaySpeed;
+                    else
+                        speed = highwaySpeeds.get("living_street");
                 }
             }
         }
 
-        // Until now we assumed that the way is no pusing section
+        // Until now we assumed that the way is no pushing section
         // Now we check, but only in case that our speed is bigger compared to the PUSHING_SECTION_SPEED
         if ((speed > PUSHING_SECTION_SPEED)
                 && (!way.hasTag("bicycle", intendedValues) && way.hasTag("highway", pushingSections)))
@@ -420,7 +465,7 @@ String getWayName( int pavementType, int wayType, Translation tr )
     /**
      * In this method we prefer cycleways or roads with designated bike access and avoid big roads
      * or roads with trams or pedestrian.
-     * <p>
+     * <p/>
      * @return new priority based on priorityFromRelation and on the tags in OSMWay.
      */
     protected int handlePriority( OSMWay way, int priorityFromRelation )
@@ -437,6 +482,39 @@ protected int handlePriority( OSMWay way, int priorityFromRelation )
         return weightToPrioMap.lastEntry().getValue();
     }
 
+    // Conversion of class value to priority. See http://wiki.openstreetmap.org/wiki/Class:bicycle
+    private PriorityCode convertCallValueToPriority( String tagvalue )
+    {
+        int classvalue;
+        try
+        {
+            classvalue = Integer.parseInt(tagvalue);
+        } catch (NumberFormatException e)
+        {
+            return PriorityCode.UNCHANGED;
+        }
+
+        switch (classvalue)
+        {
+            case 3:
+                return PriorityCode.BEST;
+            case 2:
+                return PriorityCode.VERY_NICE;
+            case 1:
+                return PriorityCode.PREFER;
+            case 0:
+                return PriorityCode.UNCHANGED;
+            case -1:
+                return PriorityCode.AVOID_IF_POSSIBLE;
+            case -2:
+                return PriorityCode.REACH_DEST;
+            case -3:
+                return PriorityCode.AVOID_AT_ALL_COSTS;
+            default:
+                return PriorityCode.UNCHANGED;
+        }
+    }
+
     /**
      * @param weightToPrioMap associate a weight with every priority. This sorted map allows
      * subclasses to 'insert' more important priorities as well as overwrite determined priorities.
@@ -453,23 +531,49 @@ void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
         double maxSpeed = getMaxSpeed(way);
         if (preferHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 30)
         {
-            weightToPrioMap.put(40d, PREFER.getValue());
-            if (way.hasTag("tunnel", intendedValues))
-                weightToPrioMap.put(40d, UNCHANGED.getValue());
+            if (maxSpeed < avoidSpeedLimit)
+            {
+                weightToPrioMap.put(40d, PREFER.getValue());
+                if (way.hasTag("tunnel", intendedValues))
+                    weightToPrioMap.put(40d, UNCHANGED.getValue());
+            }
+        } else
+        {
+            if (avoidHighwayTags.contains(highway) || ((maxSpeed >= avoidSpeedLimit) && (highway != "track")))
+            {
+                weightToPrioMap.put(50d, REACH_DEST.getValue());
+                if (way.hasTag("tunnel", intendedValues))
+                    weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
+            }
         }
 
-        if (pushingSections.contains(highway) || "parking_aisle".equals(service))
-            weightToPrioMap.put(50d, AVOID_IF_POSSIBLE.getValue());
-
-        if (avoidHighwayTags.contains(highway) || maxSpeed > 80)
+        if (pushingSections.contains(highway)
+                || way.hasTag("bicycle", "use_sidepath")
+                || "parking_aisle".equals(service))
         {
-            weightToPrioMap.put(50d, REACH_DEST.getValue());
-            if (way.hasTag("tunnel", intendedValues))
-                weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
+            if (way.hasTag("bicycle", "yes"))
+                weightToPrioMap.put(100d, UNCHANGED.getValue());
+            else
+                weightToPrioMap.put(50d, AVOID_IF_POSSIBLE.getValue());
         }
 
         if (way.hasTag("railway", "tram"))
             weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
+
+        String classBicycleSpecific = way.getTag(specificBicycleClass);
+        if (classBicycleSpecific != null)
+        {
+            // We assume that humans are better in classifying preferences compared to our algorithm above -> weight = 100
+            weightToPrioMap.put(100d, convertCallValueToPriority(classBicycleSpecific).getValue());
+        } else
+        {
+            String classBicycle = way.getTag("class:bicycle");
+            if (classBicycle != null)
+            {
+                weightToPrioMap.put(100d, convertCallValueToPriority(classBicycle).getValue());
+            }
+        }
+
     }
 
     /**
@@ -574,19 +678,30 @@ public long setLong( long flags, int key, long value )
 
     boolean isPushingSection( OSMWay way )
     {
-        return way.hasTag("highway", pushingSections);
+        return way.hasTag("highway", pushingSections) || way.hasTag("railway", "platform");
     }
 
     protected long handleSpeed( OSMWay way, double speed, long encoded )
     {
         encoded = setSpeed(encoded, speed);
 
-        // handle oneways
-        if ((way.hasTag("oneway", oneways) || way.hasTag("junction", "roundabout"))
+        // handle oneways        
+        boolean isOneway = way.hasTag("oneway", oneways)
+                || way.hasTag("oneway:bicycle", oneways)
+                || way.hasTag("vehicle:backward")
+                || way.hasTag("vehicle:forward")
+                || way.hasTag("bicycle:forward");
+
+        if ((isOneway || way.hasTag("junction", "roundabout"))
                 && !way.hasTag("oneway:bicycle", "no")
+                && !way.hasTag("bicycle:backward")
                 && !way.hasTag("cycleway", oppositeLanes))
         {
-            if (way.hasTag("oneway", "-1"))
+            boolean isBackward = way.hasTag("oneway", "-1")
+                    || way.hasTag("oneway:bicycle", "-1")
+                    || way.hasTag("vehicle:forward", "no")
+                    || way.hasTag("bicycle:forward", "no");
+            if (isBackward)
                 encoded |= backwardBit;
             else
                 encoded |= forwardBit;
@@ -620,22 +735,22 @@ public int getValue()
 
     protected void setHighwaySpeed( String highway, int speed )
     {
-        highwaySpeed.put(highway, speed);
+        highwaySpeeds.put(highway, speed);
     }
 
     protected int getHighwaySpeed( String key )
     {
-        return highwaySpeed.get(key);
+        return highwaySpeeds.get(key);
     }
 
     void setTrackTypeSpeed( String tracktype, int speed )
     {
-        trackTypeSpeed.put(tracktype, speed);
+        trackTypeSpeeds.put(tracktype, speed);
     }
 
     void setSurfaceSpeed( String surface, int speed )
     {
-        surfaceSpeed.put(surface, speed);
+        surfaceSpeeds.put(surface, speed);
     }
 
     void setCyclingNetworkPreference( String network, int code )
@@ -656,4 +771,15 @@ public boolean supports( Class<?> feature )
 
         return PriorityWeighting.class.isAssignableFrom(feature);
     }
+
+    public void setAvoidSpeedLimit( int limit )
+    {
+        avoidSpeedLimit = limit;
+    }
+
+    public void setSpecificBicycleClass( String subkey )
+    {
+        specificBicycleClass = "class:bicycle:" + subkey.toString();
+    }
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
index 32dc4a7a49..3b635f04bb 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.OSMWay;
+import com.graphhopper.util.PMap;
 
 /**
  * Specifies the settings for cycletouring/trekking
@@ -32,11 +33,18 @@ public BikeFlagEncoder()
         this(4, 2, 0);
     }
 
-    public BikeFlagEncoder( String propertiesStr )
+    public BikeFlagEncoder( String propertiesString )
     {
-        this((int) parseLong(propertiesStr, "speedBits", 4),
-                parseDouble(propertiesStr, "speedFactor", 2),
-                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+        this(new PMap(propertiesString));
+    }
+
+    public BikeFlagEncoder( PMap properties )
+    {
+        this((int) properties.getLong("speedBits", 4),
+                properties.getLong("speedFactor", 2),
+                properties.getBool("turnCosts", false) ? 3 : 0);
+        this.properties = properties;
+        this.setBlockFords(properties.getBool("blockFords", true));
     }
 
     public BikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
@@ -60,6 +68,15 @@ public BikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         preferHighwayTags.add("tertiary_link");
         preferHighwayTags.add("residential");
         preferHighwayTags.add("unclassified");
+
+        absoluteBarriers.add("kissing_gate");
+        setSpecificBicycleClass("touring");
+    }
+
+    @Override
+    public int getVersion()
+    {
+        return 1;
     }
 
     @Override
@@ -68,6 +85,7 @@ boolean isPushingSection( OSMWay way )
         String highway = way.getTag("highway");
         String trackType = way.getTag("tracktype");
         return way.hasTag("highway", pushingSections)
+                || way.hasTag("railway", "platform")
                 || "track".equals(highway) && trackType != null && !"grade1".equals(trackType);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 5cc001ad7d..39ae7d9d6c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -25,11 +25,13 @@
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.PMap;
+
 import java.util.*;
 
 /**
  * Defines bit layout for cars. (speed, access, ferries, ...)
- * <p>
+ * <p/>
  * @author Peter Karich
  * @author Nop
  */
@@ -52,11 +54,18 @@ public CarFlagEncoder()
         this(5, 5, 0);
     }
 
+    public CarFlagEncoder( PMap properties )
+    {
+        this((int) properties.getLong("speedBits", 5),
+                properties.getDouble("speedFactor", 5),
+                properties.getBool("turnCosts", false) ? 3 : 0);
+        this.properties = properties;
+        this.setBlockFords(properties.getBool("blockFords", true));
+    }
+
     public CarFlagEncoder( String propertiesStr )
     {
-        this((int) parseLong(propertiesStr, "speedBits", 5),
-                parseDouble(propertiesStr, "speedFactor", 5),
-                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+        this(new PMap(propertiesStr));
     }
 
     public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
@@ -69,6 +78,7 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         restrictedValues.add("no");
         restrictedValues.add("restricted");
         restrictedValues.add("delivery");
+        restrictedValues.add("military");
 
         intendedValues.add("yes");
         intendedValues.add("permissive");
@@ -100,6 +110,8 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         badSurfaceSpeedMap.add("ground");
         badSurfaceSpeedMap.add("grass");
 
+        maxPossibleSpeed = 140;
+
         // autobahn
         defaultSpeedMap.put("motorway", 100);
         defaultSpeedMap.put("motorway_link", 70);
@@ -127,6 +139,12 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         defaultSpeedMap.put("track", 15);
     }
 
+    @Override
+    public int getVersion()
+    {
+        return 1;
+    }
+
     /**
      * Define the place of the speedBits in the edge flags for car.
      */
@@ -135,7 +153,8 @@ public int defineWayBits( int index, int shift )
     {
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
-        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, defaultSpeedMap.get("secondary"), defaultSpeedMap.get("motorway"));
+        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, defaultSpeedMap.get("secondary"),
+                maxPossibleSpeed);
         return shift + speedEncoder.getBits();
     }
 
@@ -144,7 +163,7 @@ protected double getSpeed( OSMWay way )
         String highwayValue = way.getTag("highway");
         Integer speed = defaultSpeedMap.get(highwayValue);
         if (speed == null)
-            throw new IllegalStateException(toString() + ", no speed found for:" + highwayValue);
+            throw new IllegalStateException(toString() + ", no speed found for: " + highwayValue + ", tags: " + way);
 
         if (highwayValue.equals("track"))
         {
@@ -181,7 +200,7 @@ public long acceptWay( OSMWay way )
         if ("track".equals(highwayValue))
         {
             String tt = way.getTag("tracktype");
-            if (tt != null && !tt.equals("grade1"))
+            if (tt != null && !tt.equals("grade1") && !tt.equals("grade2") && !tt.equals("grade3"))
                 return 0;
         }
 
@@ -191,13 +210,18 @@ public long acceptWay( OSMWay way )
         if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
             return 0;
 
-        // do not drive street cars into fords
-        boolean carsAllowed = way.hasTag(restrictions, intendedValues);
-        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")) && !carsAllowed)
-            return 0;
+        // multiple restrictions needs special handling compared to foot and bike, see also motorcycle
+        String firstValue = way.getFirstPriorityTag(restrictions);
+        if (!firstValue.isEmpty())
+        {
+            if (restrictedValues.contains(firstValue))
+                return 0;
+            if (intendedValues.contains(firstValue))
+                return acceptBit;
+        }
 
-        // check access restrictions
-        if (way.hasTag(restrictions, restrictedValues) && !carsAllowed)
+        // do not drive street cars into fords
+        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")))
             return 0;
 
         // do not drive cars over railways (sometimes incorrectly mapped!)
@@ -236,9 +260,18 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
             if (isRoundabout)
                 encoded = setBool(encoded, K_ROUNDABOUT, true);
 
-            if (way.hasTag("oneway", oneways) || isRoundabout)
+            boolean isOneway = way.hasTag("oneway", oneways)
+                    || way.hasTag("vehicle:backward")
+                    || way.hasTag("vehicle:forward")
+                    || way.hasTag("motor_vehicle:backward")
+                    || way.hasTag("motor_vehicle:forward");
+
+            if (isOneway || isRoundabout)
             {
-                if (way.hasTag("oneway", "-1"))
+                boolean isBackward = way.hasTag("oneway", "-1")
+                        || way.hasTag("vehicle:forward", "no")
+                        || way.hasTag("motor_vehicle:forward", "no");
+                if (isBackward)
                     encoded |= backwardBit;
                 else
                     encoded |= forwardBit;
diff --git a/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
new file mode 100644
index 0000000000..483e4f837a
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
@@ -0,0 +1,42 @@
+package com.graphhopper.routing.util;
+
+/**
+ * Turns an unidirectional weight Approximation into a bidirectional consistent one.
+ * <p/>
+ * Ikeda, T., Hsu, M.-Y., Imai, H., Nishimura, S., Shimoura, H., Hashimoto, T., Tenmoku, K., and
+ * Mitoh, K. (1994). A fast algorithm for finding better routes by ai search techniques. In VNIS,
+ * pages 291296.
+ * <p/>
+ * @author jansoe
+ */
+public class ConsistentWeightApproximator
+{
+    private final WeightApproximator uniDirApproximatorForward, uniDirApproximatorReverse;
+
+    public ConsistentWeightApproximator( WeightApproximator weightApprox )
+    {
+        uniDirApproximatorForward = weightApprox;
+        uniDirApproximatorReverse = weightApprox.duplicate();
+    }
+
+    public void setSourceNode( int sourceNode )
+    {
+        uniDirApproximatorReverse.setGoalNode(sourceNode);
+    }
+
+    public void setGoalNode( int goalNode )
+    {
+        uniDirApproximatorForward.setGoalNode(goalNode);
+    }
+
+    public double approximate( int fromNode, boolean reverse )
+    {
+        double weightApproximation = 0.5
+                * (uniDirApproximatorForward.approximate(fromNode) - uniDirApproximatorReverse.approximate(fromNode));
+
+        if (reverse)
+            weightApproximation *= -1;
+
+        return weightApproximation;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
index 1cdd5bada9..e86ca2c43d 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
@@ -47,7 +47,7 @@ public DefaultEdgeFilter( FlagEncoder encoder, boolean in, boolean out )
     public final boolean accept( EdgeIteratorState iter )
     {
         long flags = iter.getFlags();
-        return out && encoder.isBool(flags, FlagEncoder.K_FORWARD) || in && encoder.isBool(flags, FlagEncoder.K_BACKWARD);
+        return out && encoder.isForward(flags) || in && encoder.isBackward(flags);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
index 8823be538b..a108e4826c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
@@ -29,12 +29,12 @@
     /**
      * @return true if the current edge should be processed and false otherwise.
      */
-    boolean accept( EdgeIteratorState edgeIterState );
+    boolean accept( EdgeIteratorState edgeState );
 
     static final EdgeFilter ALL_EDGES = new EdgeFilter()
     {
         @Override
-        public final boolean accept( EdgeIteratorState edgeIterState )
+        public final boolean accept( EdgeIteratorState edgeState )
         {
             return true;
         }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java b/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
index f00dc17928..e5233e75f0 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
@@ -55,7 +55,10 @@ public long setDefaultValue( long flags )
 
     public long setDoubleValue( long flags, double value )
     {
-        // scale value        
+        if (Double.isNaN(value))
+            throw new IllegalStateException("Value cannot be NaN");
+
+        // scale value
         long tmpValue = Math.round(value / factor);
         checkValue(Math.round(tmpValue * factor));
         tmpValue <<= shift;
@@ -71,13 +74,13 @@ public double getDoubleValue( long flags )
     {
         // find value
         flags &= mask;
-        flags >>= shift;
+        flags >>>= shift;
         return flags * factor;
     }
 
     /**
      * Swap the contents controlled by this value encoder with the given value.
-     * <p>
+     * <p/>
      * @return the new flags
      */
     public long swap( long flags, EncodedDoubleValue otherEncoder )
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java b/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
index d2c961bf15..d96090e13f 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
@@ -92,7 +92,7 @@ public long getValue( long flags )
     {
         // find value
         flags &= mask;
-        flags >>= shift;
+        flags >>>= shift;
         return Math.round(flags * factor);
     }
 
@@ -113,7 +113,7 @@ public long getMaxValue()
 
     /**
      * Swap the contents controlled by this value encoder with the given value.
-     * <p>
+     * <p/>
      * @return the new flags
      */
     public long swap( long flags, EncodedValue otherEncoder )
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index d5ff15f91b..573d1b4a99 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -17,24 +17,19 @@
  */
 package com.graphhopper.routing.util;
 
-import gnu.trove.map.TLongObjectMap;
-import gnu.trove.map.hash.TLongObjectHashMap;
-
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.List;
 
 import com.graphhopper.reader.OSMNode;
-import com.graphhopper.reader.OSMReader;
 import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.reader.OSMTurnRelation;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.storage.StorableProperties;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.PMap;
+
 import java.util.*;
 
 /**
@@ -66,8 +61,7 @@
 
     /**
      * Instantiate manager with the given list of encoders. The manager knows the default encoders:
-     * CAR, FOOT and BIKE (ignoring the case). Custom encoders can be specified by giving a full
-     * class name e.g. "car:com.graphhopper.myproject.MyCarEncoder"
+     * CAR, FOOT and BIKE (ignoring the case).
      * <p/>
      * @param flagEncodersStr comma delimited list of encoders. The order does not matter.
      */
@@ -101,25 +95,19 @@ public EncodingManager( List<? extends FlagEncoder> flagEncoders )
         this(flagEncoders, 4);
     }
 
-    public EncodingManager( List<? extends FlagEncoder> flagEncoders, int bytesForFlags )
+    public EncodingManager( List<? extends FlagEncoder> flagEncoders, int bytesForEdgeFlags )
     {
-        if (bytesForFlags != 4 && bytesForFlags != 8)
-            throw new IllegalStateException("For 'flags' currently only 4 or 8 bytes supported");
-
-        this.bitsForEdgeFlags = bytesForFlags * 8;
+        if (bytesForEdgeFlags != 4 && bytesForEdgeFlags != 8)
+            throw new IllegalStateException("For 'edge flags' currently only 4 or 8 bytes supported");
 
-        Collections.sort(flagEncoders, new Comparator<FlagEncoder>()
-        {
-            @Override
-            public int compare( FlagEncoder o1, FlagEncoder o2 )
-            {
-                return o1.toString().compareTo(o2.toString());
-            }
-        });
+        this.bitsForEdgeFlags = bytesForEdgeFlags * 8;
         for (FlagEncoder flagEncoder : flagEncoders)
         {
             registerEncoder((AbstractFlagEncoder) flagEncoder);
         }
+
+        if (edgeEncoders.isEmpty())
+            throw new IllegalStateException("No vehicles found");
     }
 
     public int getBytesForFlags()
@@ -147,39 +135,49 @@ public int getBytesForFlags()
                 entryVal = entry;
                 entry = entry.split("\\|")[0];
             }
+            PMap configuration = new PMap(entryVal);
 
             AbstractFlagEncoder fe;
             if (entry.equals(CAR))
-                fe = new CarFlagEncoder(entryVal);
+                fe = new CarFlagEncoder(configuration);
 
             else if (entry.equals(BIKE))
-                fe = new BikeFlagEncoder(entryVal);
+                fe = new BikeFlagEncoder(configuration);
 
             else if (entry.equals(BIKE2))
-                fe = new Bike2WeightFlagEncoder(entryVal);
+                fe = new Bike2WeightFlagEncoder(configuration);
 
             else if (entry.equals(RACINGBIKE))
-                fe = new RacingBikeFlagEncoder(entryVal);
+                fe = new RacingBikeFlagEncoder(configuration);
 
             else if (entry.equals(MOUNTAINBIKE))
-                fe = new MountainBikeFlagEncoder(entryVal);
+                fe = new MountainBikeFlagEncoder(configuration);
 
             else if (entry.equals(FOOT))
-                fe = new FootFlagEncoder(entryVal);
+                fe = new FootFlagEncoder(configuration);
 
             else if (entry.equals(MOTORCYCLE))
-                fe = new MotorcycleFlagEncoder(entryVal);
+                fe = new MotorcycleFlagEncoder(configuration);
 
             else
                 throw new IllegalArgumentException("entry in encoder list not supported " + entry);
 
+            if (configuration.has("version"))
+            {
+                if (fe.getVersion() != configuration.getInt("version", -1))
+                {
+                    throw new IllegalArgumentException("Encoder " + entry + " was used in version "
+                            + configuration.getLong("version", -1) + ", but current version is " + fe.getVersion());
+                }
+            }
+
             resultEncoders.add(fe);
         }
         return resultEncoders;
     }
 
     private static final String ERR = "Encoders are requesting more than %s bits of %s flags. ";
-    private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long.";
+    private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long via graph.bytesForFlags=8";
 
     private void registerEncoder( AbstractFlagEncoder encoder )
     {
@@ -279,11 +277,6 @@ public long handleWayTags( OSMWay way, long includeWay, long relationFlags )
         return flags;
     }
 
-    public int getVehicleCount()
-    {
-        return edgeEncoders.size();
-    }
-
     @Override
     public String toString()
     {
@@ -307,25 +300,16 @@ public String toDetailsString()
             if (str.length() > 0)
                 str.append(",");
 
-            str.append(encoder.toString());
-            str.append("|");
-            str.append(encoder.getPropertiesString());
+            str.append(encoder.toString())
+                    .append("|")
+                    .append(encoder.getPropertiesString())
+                    .append("|version=")
+                    .append(encoder.getVersion());
         }
 
         return str.toString();
     }
 
-    public FlagEncoder getSingle()
-    {
-        if (getVehicleCount() > 1)
-            throw new IllegalStateException("Multiple encoders are active. cannot return one:" + toString());
-
-        if (getVehicleCount() == 0)
-            throw new IllegalStateException("No encoder is active!");
-
-        return edgeEncoders.get(0);
-    }
-
     public long flagsDefault( boolean forward, boolean backward )
     {
         long flags = 0;
@@ -389,42 +373,6 @@ public long handleNodeTags( OSMNode node )
         return flags;
     }
 
-    private static int determineRequiredBits( int value )
-    {
-        int numberOfBits = 0;
-        while (value > 0)
-        {
-            value = value >> 1;
-            numberOfBits++;
-        }
-        return numberOfBits;
-    }
-
-    public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
-    {
-        TLongObjectMap<TurnCostTableEntry> entries = new TLongObjectHashMap<OSMTurnRelation.TurnCostTableEntry>();
-
-        int encoderCount = edgeEncoders.size();
-        for (int i = 0; i < encoderCount; i++)
-        {
-            AbstractFlagEncoder encoder = edgeEncoders.get(i);
-            for (TurnCostTableEntry entry : encoder.analyzeTurnRelation(turnRelation, osmReader))
-            {
-                TurnCostTableEntry oldEntry = entries.get(entry.getItemId());
-                if (oldEntry != null)
-                {
-                    // merging different encoders
-                    oldEntry.flags |= entry.flags;
-                } else
-                {
-                    entries.put(entry.getItemId(), entry);
-                }
-            }
-        }
-
-        return entries.valueCollection();
-    }
-
     public EncodingManager setEnableInstructions( boolean enableInstructions )
     {
         this.enableInstructions = enableInstructions;
@@ -458,6 +406,16 @@ public void applyWayTags( OSMWay way, EdgeIteratorState edge )
         }
     }
 
+    /**
+     * The returned list is never empty.
+     */
+    public List<FlagEncoder> fetchEdgeEncoders()
+    {
+        List<FlagEncoder> list = new ArrayList<FlagEncoder>();
+        list.addAll(edgeEncoders);
+        return list;
+    }
+
     static String fixWayName( String str )
     {
         if (str == null)
diff --git a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
index 789e41a269..2850ef17bb 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
@@ -18,11 +18,13 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PMap;
 
 /**
  * Calculates the fastest route with the specified vehicle (VehicleEncoder). Calculates the weight
  * in seconds.
  * <p/>
+ *
  * @author Peter Karich
  */
 public class FastestWeighting implements Weighting
@@ -32,13 +34,21 @@
      * costs or traffic light costs etc)
      */
     protected final static double SPEED_CONV = 3.6;
+    final static double DEFAULT_HEADING_PENALTY = 300; //[s]
+    private final double heading_penalty;
     protected final FlagEncoder encoder;
     private final double maxSpeed;
 
-    public FastestWeighting( FlagEncoder encoder )
+    public FastestWeighting( FlagEncoder encoder, PMap pMap )
     {
         this.encoder = encoder;
-        maxSpeed = encoder.getMaxSpeed() * SPEED_CONV;
+        heading_penalty = pMap.getDouble("heading_penalty", DEFAULT_HEADING_PENALTY);
+        maxSpeed = encoder.getMaxSpeed() / SPEED_CONV;
+    }
+
+    public FastestWeighting( FlagEncoder encoder )
+    {
+        this(encoder, new PMap(0));
     }
 
     @Override
@@ -49,11 +59,19 @@ public double getMinWeight( double distance )
 
     @Override
     public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
-    {        
+    {
         double speed = reverse ? encoder.getReverseSpeed(edge.getFlags()) : encoder.getSpeed(edge.getFlags());
         if (speed == 0)
             return Double.POSITIVE_INFINITY;
-        return edge.getDistance() / (speed * SPEED_CONV);
+
+        double time = edge.getDistance() / speed * SPEED_CONV;
+
+        // add direction penalties at start/stop/via points
+        boolean penalizeEdge = edge.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, reverse, false);
+        if (penalizeEdge)
+            time += heading_penalty;
+
+        return time;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
index b68eb0740f..cb024b32d9 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
@@ -28,6 +28,11 @@
  */
 public interface FlagEncoder extends TurnCostEncoder
 {
+    /**
+     * @return the version of this FlagEncoder to enforce none-compatibility when new attributes are introduced
+     */
+    int getVersion();
+
     /**
      * @return the maximum speed in km/h
      */
@@ -40,7 +45,7 @@
 
     /**
      * Sets the speed in km/h.
-     * <p>
+     * <p/>
      * @return modified setProperties
      */
     long setSpeed( long flags, double speed );
@@ -57,31 +62,33 @@
 
     /**
      * Sets the access of the edge.
-     * <p>
+     * <p/>
      * @return modified flags
      */
     long setAccess( long flags, boolean forward, boolean backward );
 
     /**
      * Sets speed and access properties.
-     * <p>
+     * <p/>
      * @return created flags
      */
     long setProperties( double speed, boolean forward, boolean backward );
 
-    /*
-     * Simple rules for every subclass which introduces a new key. It has to use the prefix K_ and
-     * uses a minimum value which is two magnitudes higher than in the super class. 
-     * Currently this means starting from 100, and subclasses of this class start from 10000 and so on.
-     */
     /**
      * Reports wether the edge is available in forward direction for a certain vehicle
      */
-    static final int K_FORWARD = 0;
+    boolean isForward( long flags );
+
     /**
      * Reports wether the edge is available in backward direction for a certain vehicle
      */
-    static final int K_BACKWARD = 1;
+    boolean isBackward( long flags );
+
+    /*
+     * Simple rules for every subclass which introduces a new key. It has to use the prefix K_ and
+     * uses a minimum value which is two magnitudes higher than in the super class. 
+     * Currently this means starting from 100, and subclasses of this class start from 10000 and so on.
+     */
     /**
      * Reports wether this edge is part of a roundabout.
      */
@@ -103,7 +110,7 @@
     long setLong( long flags, int key, long value );
 
     /**
-     * Returns arbitrary long value identified by the specified key. E.g. can be used to return the
+     * Returns arbitrary double value identified by the specified key. E.g. can be used to return the
      * maximum width or height allowed for an edge.
      */
     double getDouble( long flags, int key );
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index 45fe4127a1..2412ce41a8 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -22,12 +22,15 @@
 
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
+import com.graphhopper.util.PMap;
+
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import java.util.*;
 
 /**
  * Defines bit layout for pedestrians (speed, access, surface, ...).
- * <p>
+ * <p/>
  * @author Peter Karich
  * @author Nop
  * @author Karl Hbner
@@ -54,10 +57,19 @@ public FootFlagEncoder()
         this(4, 1);
     }
 
+    public FootFlagEncoder( PMap properties )
+    {
+        this(
+                (int) properties.getLong("speedBits", 4),
+                properties.getDouble("speedFactor", 1)
+        );
+        this.properties = properties;
+        this.setBlockFords(properties.getBool("blockFords", true));
+    }
+
     public FootFlagEncoder( String propertiesStr )
     {
-        this((int) parseLong(propertiesStr, "speedBits", 4),
-                parseDouble(propertiesStr, "speedFactor", 1));
+        this(new PMap(propertiesStr));
     }
 
     public FootFlagEncoder( int speedBits, double speedFactor )
@@ -67,6 +79,7 @@ public FootFlagEncoder( int speedBits, double speedFactor )
         restrictedValues.add("private");
         restrictedValues.add("no");
         restrictedValues.add("restricted");
+        restrictedValues.add("military");
 
         intendedValues.add("yes");
         intendedValues.add("designated");
@@ -81,7 +94,6 @@ public FootFlagEncoder( int speedBits, double speedFactor )
         setBlockByDefault(false);
         potentialBarriers.add("gate");
 
-        acceptedRailways.add("station");
         acceptedRailways.add("platform");
 
         safeHighwayTags.add("footway");
@@ -93,31 +105,37 @@ public FootFlagEncoder( int speedBits, double speedFactor )
         safeHighwayTags.add("residential");
         safeHighwayTags.add("service");
 
+        avoidHighwayTags.add("trunk");
+        avoidHighwayTags.add("trunk_link");
+        avoidHighwayTags.add("primary");
+        avoidHighwayTags.add("primary_link");
+        avoidHighwayTags.add("tertiary");
+        avoidHighwayTags.add("tertiary_link");
+        // for now no explicit avoiding #257
+        //avoidHighwayTags.add("cycleway"); 
+
         allowedHighwayTags.addAll(safeHighwayTags);
-        allowedHighwayTags.add("trunk");
-        allowedHighwayTags.add("trunk_link");
-        allowedHighwayTags.add("primary");
-        allowedHighwayTags.add("primary_link");
+        allowedHighwayTags.addAll(avoidHighwayTags);
+        allowedHighwayTags.add("cycleway");
         allowedHighwayTags.add("secondary");
         allowedHighwayTags.add("secondary_link");
-        allowedHighwayTags.add("tertiary");
-        allowedHighwayTags.add("tertiary_link");
         allowedHighwayTags.add("unclassified");
         allowedHighwayTags.add("road");
         // disallowed in some countries
         //allowedHighwayTags.add("bridleway");
 
-        avoidHighwayTags.add("trunk");
-        avoidHighwayTags.add("trunk_link");
-        avoidHighwayTags.add("primary");
-        avoidHighwayTags.add("primary_link");
-        avoidHighwayTags.add("tertiary");
-        avoidHighwayTags.add("tertiary_link");
-
         hikingNetworkToCode.put("iwn", BEST.getValue());
         hikingNetworkToCode.put("nwn", BEST.getValue());
         hikingNetworkToCode.put("rwn", VERY_NICE.getValue());
         hikingNetworkToCode.put("lwn", VERY_NICE.getValue());
+
+        maxPossibleSpeed = FERRY_SPEED;
+    }
+
+    @Override
+    public int getVersion()
+    {
+        return 1;
     }
 
     @Override
@@ -126,7 +144,7 @@ public int defineWayBits( int index, int shift )
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
         // larger value required - ferries are faster than pedestrians
-        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, MEAN_SPEED, FERRY_SPEED);
+        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, MEAN_SPEED, maxPossibleSpeed);
         shift += speedEncoder.getBits();
 
         preferWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 0, 7);
@@ -152,7 +170,7 @@ public int defineTurnBits( int index, int shift )
 
     /**
      * Foot flag encoder does not provide any turn cost / restrictions
-     * <p>
+     * <p/>
      * @return <code>false</code>
      */
     @Override
@@ -163,7 +181,7 @@ public boolean isTurnRestricted( long flag )
 
     /**
      * Foot flag encoder does not provide any turn cost / restrictions
-     * <p>
+     * <p/>
      * @return 0
      */
     @Override
@@ -181,7 +199,6 @@ public long getTurnFlags( boolean restricted, double costs )
     /**
      * Some ways are okay but not separate for pedestrians.
      * <p/>
-     * @param way
      */
     @Override
     public long acceptWay( OSMWay way )
@@ -195,6 +212,11 @@ public long acceptWay( OSMWay way )
                 if (footTag == null || "yes".equals(footTag))
                     return acceptBit | ferryBit;
             }
+
+            // special case not for all acceptedRailways, only platform
+            if (way.hasTag("railway", "platform"))
+                return acceptBit;
+
             return 0;
         }
 
@@ -224,9 +246,6 @@ public long acceptWay( OSMWay way )
         if (isBlockFords() && (way.hasTag("highway", "ford") || way.hasTag("ford")))
             return 0;
 
-        if (way.hasTag("bicycle", "official"))
-            return 0;
-
         // check access restrictions
         if (way.hasTag(restrictions, restrictedValues))
             return 0;
@@ -286,6 +305,12 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
 
             encoded = setLong(encoded, PriorityWeighting.KEY, handlePriority(way, priorityFromRelation));
 
+            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            if (isRoundabout)
+            {
+                encoded = setBool(encoded, K_ROUNDABOUT, true);
+            }
+
         } else
         {
             encoded = handleFerryTags(way, SLOW_SPEED, MEAN_SPEED, FERRY_SPEED);
@@ -360,15 +385,23 @@ void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
             weightToPrioMap.put(100d, PREFER.getValue());
 
         double maxSpeed = getMaxSpeed(way);
-        if (safeHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 20
-                || way.hasTag("sidewalk", sidewalks))
+        if (safeHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 20)
         {
             weightToPrioMap.put(40d, PREFER.getValue());
-
             if (way.hasTag("tunnel", intendedValues))
                 weightToPrioMap.put(40d, UNCHANGED.getValue());
         }
 
+        if (way.hasTag("bicycle", "official") || way.hasTag("bicycle", "designated"))
+        {
+            weightToPrioMap.put(44d, AVOID_IF_POSSIBLE.getValue());
+        }
+
+        if (way.hasTag("sidewalk", sidewalks))
+        {
+            weightToPrioMap.put(45d, PREFER.getValue());
+        }
+
         if (avoidHighwayTags.contains(highway) || maxSpeed > 50)
         {
             weightToPrioMap.put(50d, REACH_DEST.getValue());
diff --git a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
index 1db6312e76..985a4477d5 100644
--- a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
@@ -19,6 +19,8 @@
 
 import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.EdgeSkipIterator;
 
 /**
  * Only certain nodes are accepted and therefor the others are ignored.
@@ -27,16 +29,28 @@
  */
 public class LevelEdgeFilter implements EdgeFilter
 {
-    protected LevelGraph graph;
+    private final LevelGraph graph;
+    private final int maxNodes;
 
     public LevelEdgeFilter( LevelGraph g )
     {
         graph = g;
+        maxNodes = g.getNodes();
     }
 
     @Override
-    public boolean accept( EdgeIteratorState edgeIter )
+    public boolean accept( EdgeIteratorState edgeIterState )
     {
-        return graph.getLevel(edgeIter.getBaseNode()) <= graph.getLevel(edgeIter.getAdjNode());
+        int base = edgeIterState.getBaseNode();
+        int adj = edgeIterState.getAdjNode();
+        // always accept virtual edges, see #288
+        if (base >= maxNodes || adj >= maxNodes)
+            return true;
+
+        // minor performance improvement: shortcuts in wrong direction are disconnected, so no need to exclude them
+        if (((EdgeSkipIterState) edgeIterState).isShortcut())
+            return true;
+
+        return graph.getLevel(base) <= graph.getLevel(adj);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
index ce5f0aef68..34d1da2056 100644
--- a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
@@ -19,12 +19,15 @@
 
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.util.BitUtil;
+import com.graphhopper.util.PMap;
+
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import java.util.HashSet;
 
 /**
  * Defines bit layout for motorbikes
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class MotorcycleFlagEncoder extends CarFlagEncoder
@@ -34,11 +37,20 @@
     private final HashSet<String> avoidSet = new HashSet<String>();
     private final HashSet<String> preferSet = new HashSet<String>();
 
+    public MotorcycleFlagEncoder( PMap properties )
+    {
+        this(
+                (int) properties.getLong("speedBits", 5),
+                properties.getDouble("speedFactor", 5),
+                properties.getBool("turnCosts", false) ? 3 : 0
+        );
+        this.properties = properties;
+        this.setBlockFords(properties.getBool("blockFords", true));
+    }
+
     public MotorcycleFlagEncoder( String propertiesStr )
     {
-        this((int) parseLong(propertiesStr, "speedBits", 5),
-                parseDouble(propertiesStr, "speedFactor", 5),
-                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+        this(new PMap(propertiesStr));
     }
 
     public MotorcycleFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
@@ -63,6 +75,8 @@ public MotorcycleFlagEncoder( int speedBits, double speedFactor, int maxTurnCost
         preferSet.add("primary");
         preferSet.add("secondary");
 
+        maxPossibleSpeed = 120;
+
         // autobahn
         defaultSpeedMap.put("motorway", 100);
         defaultSpeedMap.put("motorway_link", 70);
@@ -90,6 +104,12 @@ public MotorcycleFlagEncoder( int speedBits, double speedFactor, int maxTurnCost
         defaultSpeedMap.put("track", 15);
     }
 
+    @Override
+    public int getVersion()
+    {
+        return 1;
+    }
+
     /**
      * Define the place of the speedBits in the edge flags for car.
      */
@@ -98,7 +118,8 @@ public int defineWayBits( int index, int shift )
     {
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
-        reverseSpeedEncoder = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor, defaultSpeedMap.get("secondary"), defaultSpeedMap.get("motorway"));
+        reverseSpeedEncoder = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor,
+                defaultSpeedMap.get("secondary"), maxPossibleSpeed);
         shift += reverseSpeedEncoder.getBits();
 
         preferWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 3, 7);
@@ -138,13 +159,17 @@ public long acceptWay( OSMWay way )
         if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
             return 0;
 
-        // do not drive street cars into fords
-        boolean carsAllowed = way.hasTag(restrictions, intendedValues);
-        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")) && !carsAllowed)
-            return 0;
+        String firstValue = way.getFirstPriorityTag(restrictions);
+        if (!firstValue.isEmpty())
+        {
+            if (restrictedValues.contains(firstValue))
+                return 0;
+            if (intendedValues.contains(firstValue))
+                return acceptBit;
+        }
 
-        // check access restrictions
-        if (way.hasTag(restrictions, restrictedValues) && !carsAllowed)
+        // do not drive street cars into fords
+        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")))
             return 0;
 
         // do not drive cars over railways (sometimes incorrectly mapped!)
@@ -220,12 +245,24 @@ public long setReverseSpeed( long flags, double speed )
         if (speed < 0)
             throw new IllegalArgumentException("Speed cannot be negative: " + speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
 
+        if (speed < speedEncoder.factor / 2)
+            return setLowSpeed(flags, speed, true);
+
         if (speed > getMaxSpeed())
             speed = getMaxSpeed();
 
         return reverseSpeedEncoder.setDoubleValue(flags, speed);
     }
 
+    @Override
+    protected long setLowSpeed( long flags, double speed, boolean reverse )
+    {
+        if (reverse)
+            return setBool(reverseSpeedEncoder.setDoubleValue(flags, 0), K_BACKWARD, false);
+
+        return setBool(speedEncoder.setDoubleValue(flags, 0), K_FORWARD, false);
+    }
+
     @Override
     public long flagsDefault( boolean forward, boolean backward )
     {
diff --git a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
index 26da91bb32..5f5c36b335 100644
--- a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
@@ -17,11 +17,16 @@
  */
 package com.graphhopper.routing.util;
 
+import static com.graphhopper.routing.util.PriorityCode.BEST;
+import static com.graphhopper.routing.util.PriorityCode.PREFER;
+import static com.graphhopper.routing.util.PriorityCode.UNCHANGED;
+import static com.graphhopper.routing.util.PriorityCode.VERY_NICE;
+
+import java.util.TreeMap;
+
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
-import static com.graphhopper.routing.util.BikeCommonFlagEncoder.PUSHING_SECTION_SPEED;
-import static com.graphhopper.routing.util.PriorityCode.*;
-import java.util.TreeMap;
+import com.graphhopper.util.PMap;
 
 /**
  * Specifies the settings for mountain biking
@@ -36,11 +41,20 @@ public MountainBikeFlagEncoder()
         this(4, 2, 0);
     }
 
+    public MountainBikeFlagEncoder( PMap properties )
+    {
+        this(
+                (int) properties.getLong("speedBits", 4),
+                properties.getDouble("speedFactor", 2),
+                properties.getBool("turnCosts", false) ? 3 : 0
+        );
+        this.properties = properties;
+        this.setBlockFords(properties.getBool("blockFords", true));
+    }
+
     public MountainBikeFlagEncoder( String propertiesStr )
     {
-        this((int) parseLong(propertiesStr, "speedBits", 4),
-                parseDouble(propertiesStr, "speedFactor", 2),
-                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+        this(new PMap(propertiesStr));
     }
 
     public MountainBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
@@ -128,6 +142,15 @@ public MountainBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCo
         preferHighwayTags.add("tertiary_link");
         preferHighwayTags.add("residential");
         preferHighwayTags.add("unclassified");
+
+        potentialBarriers.add("kissing_gate");
+        setSpecificBicycleClass("mtb");
+    }
+
+    @Override
+    public int getVersion()
+    {
+        return 1;
     }
 
     @Override
@@ -172,7 +195,7 @@ boolean allowedSacScale( String sacScale )
 
     @Override
     public String toString()
-    {        
+    {
         return "mtb";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/NoOpAlgorithmPreparation.java b/core/src/main/java/com/graphhopper/routing/util/NoOpAlgorithmPreparation.java
deleted file mode 100644
index c3e0f8b2fb..0000000000
--- a/core/src/main/java/com/graphhopper/routing/util/NoOpAlgorithmPreparation.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util;
-
-import com.graphhopper.routing.RoutingAlgorithm;
-import com.graphhopper.routing.RoutingAlgorithmFactory;
-import com.graphhopper.storage.Graph;
-
-/**
- * @author Peter Karich
- */
-public abstract class NoOpAlgorithmPreparation extends AbstractAlgoPreparation<NoOpAlgorithmPreparation>
-{
-    public NoOpAlgorithmPreparation()
-    {
-    }
-
-    /**
-     * Creates a preparation wrapper for the specified algorithm. Possible values for algorithmStr:
-     * astar (A* algorithm), astarbi (bidirectional A*), dijkstra (Dijkstra) or dijkstrabi.
-     */
-    public static AlgorithmPreparation createAlgoPrepare( Graph g, final String algorithmStr,
-            FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
-    {
-        return p(new RoutingAlgorithmFactory(algorithmStr, false, tMode), encoder, weighting).setGraph(g);
-    }
-
-    private static AlgorithmPreparation p( final RoutingAlgorithmFactory factory,
-            final FlagEncoder encoder, final Weighting weighting )
-    {
-        return new NoOpAlgorithmPreparation()
-        {
-            @Override
-            public RoutingAlgorithm createAlgo()
-            {
-                try
-                {
-                    return factory.createAlgo(_graph, encoder, weighting);
-                } catch (Exception ex)
-                {
-                    throw new RuntimeException(ex);
-                }
-            }
-
-            @Override
-            public String toString()
-            {
-                return createAlgo().getName() + ", " + encoder + ", " + weighting;
-            }
-        };
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
index 1a2293824c..f061e27043 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
@@ -21,6 +21,7 @@
 import com.graphhopper.coll.GHBitSetImpl;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.util.*;
+
 import java.util.*;
 import java.util.Map.Entry;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -43,21 +44,19 @@
     private final GraphStorage g;
     private final EdgeFilter edgeFilter;
     private int minNetworkSize = 200;
-    private int minOnewayNetworkSize = 0;
+    private int minOneWayNetworkSize = 0;
     private int subNetworks = -1;
     private final AtomicInteger maxEdgesPerNode = new AtomicInteger(0);
-    private final EncodingManager encodingManager;
+    private FlagEncoder singleEncoder;
 
     public PrepareRoutingSubnetworks( GraphStorage g, EncodingManager em )
     {
         this.g = g;
-        if (em.getVehicleCount() == 0)
-            throw new IllegalStateException("No vehicles found");
-        else if (em.getVehicleCount() > 1)
+        List<FlagEncoder> encoders = em.fetchEdgeEncoders();
+        if (encoders.size() > 1)
             edgeFilter = EdgeFilter.ALL_EDGES;
         else
-            edgeFilter = new DefaultEdgeFilter(em.getSingle());
-        this.encodingManager = em;
+            edgeFilter = new DefaultEdgeFilter(singleEncoder = encoders.get(0));
     }
 
     public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
@@ -66,9 +65,9 @@ public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
         return this;
     }
 
-    public PrepareRoutingSubnetworks setMinOnewayNetworkSize( int minOnewayNetworkSize )
+    public PrepareRoutingSubnetworks setMinOneWayNetworkSize( int minOnewayNetworkSize )
     {
-        this.minOnewayNetworkSize = minOnewayNetworkSize;
+        this.minOneWayNetworkSize = minOnewayNetworkSize;
         return this;
     }
 
@@ -78,9 +77,9 @@ public void doWork()
         Map<Integer, Integer> map = findSubnetworks();
         keepLargeNetworks(map);
 
-        int unvisitedDeadEnds = 0;
-        if ((this.minOnewayNetworkSize > 0) && (this.encodingManager.getVehicleCount() == 1))
-            unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(this.encodingManager.getSingle());
+        int unvisitedDeadEnds = -1;
+        if (minOneWayNetworkSize > 0 && singleEncoder != null)
+            unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(singleEncoder);
 
         logger.info("optimize to remove subnetworks (" + map.size() + "), zero-degree-nodes (" + del + "), "
                 + "unvisited-dead-end-nodes(" + unvisitedDeadEnds + "), "
@@ -150,11 +149,12 @@ protected final boolean checkAdjacent( EdgeIteratorState iter )
      */
     void keepLargeNetworks( Map<Integer, Integer> map )
     {
-        if (map.size() < 2)
+        if (map.size() <= 1)
             return;
 
         int biggestStart = -1;
         int maxCount = -1;
+        int allRemoved = 0;
         GHBitSetImpl bs = new GHBitSetImpl(g.getNodes());
         for (Entry<Integer, Integer> e : map.entrySet())
         {
@@ -165,32 +165,42 @@ void keepLargeNetworks( Map<Integer, Integer> map )
                 continue;
             }
 
+            int removed;
             if (maxCount < e.getValue())
             {
                 // new biggest area found. remove old
-                removeNetwork(biggestStart, maxCount, bs);
+                removed = removeNetwork(biggestStart, maxCount, bs);
 
                 biggestStart = e.getKey();
                 maxCount = e.getValue();
             } else
             {
-                removeNetwork(e.getKey(), e.getValue(), bs);
+                removed = removeNetwork(e.getKey(), e.getValue(), bs);
             }
+
+            allRemoved += removed;
+            if (removed > g.getNodes() / 3)
+                throw new IllegalStateException("Too many nodes were removed: " + removed + ", all nodes:" + g.getNodes() + ", all removed:" + allRemoved);
         }
+
+        if (allRemoved > g.getNodes() / 2)
+            throw new IllegalStateException("Too many total nodes were removed: " + allRemoved + ", all nodes:" + g.getNodes());
     }
 
     /**
      * Deletes the complete subnetwork reachable through start
      */
-    void removeNetwork( int start, int entries, final GHBitSet bs )
+    int removeNetwork( int start, int entries, final GHBitSet bs )
     {
         if (entries >= minNetworkSize)
         {
             // logger.info("did not remove large network (" + entries + ")");
-            return;
+            return 0;
         }
+
+        final AtomicInteger removed = new AtomicInteger(0);
         EdgeExplorer explorer = g.createEdgeExplorer(edgeFilter);
-        new DepthFirstSearch()
+        new BreadthFirstSearch()
         {
             @Override
             protected GHBitSet createBitSet()
@@ -202,9 +212,33 @@ protected GHBitSet createBitSet()
             protected boolean goFurther( int nodeId )
             {
                 g.markNodeRemoved(nodeId);
+                removed.incrementAndGet();
                 return super.goFurther(nodeId);
             }
         }.start(explorer, start);
+
+        if (entries != removed.get())
+            throw new IllegalStateException("Did not expect " + removed.get() + " removed nodes; "
+                    + " Expected:" + entries + ", all nodes:" + g.getNodes() + "; "
+                    + " Neighbours:" + toString(explorer.setBaseNode(start)) + "; "
+                    + " Start:" + start + "  (" + g.getNodeAccess().getLat(start) + "," + g.getNodeAccess().getLon(start) + ")");
+
+        return removed.get();
+    }
+
+    String toString( EdgeIterator iter )
+    {
+        String str = "";
+        while (iter.next())
+        {
+            int adjNode = iter.getAdjNode();
+            str += adjNode + " (" + g.getNodeAccess().getLat(adjNode) + "," + g.getNodeAccess().getLon(adjNode) + "), ";
+            str += "speed  (fwd:" + singleEncoder.getSpeed(iter.getFlags()) + ", rev:" + singleEncoder.getReverseSpeed(iter.getFlags()) + "), ";
+            str += "access (fwd:" + singleEncoder.isForward(iter.getFlags()) + ", rev:" + singleEncoder.isBackward(iter.getFlags()) + "), ";
+            str += "distance:" + iter.getDistance();
+            str += ";\n ";
+        }
+        return str;
     }
 
     /**
@@ -230,30 +264,32 @@ int removeZeroDegreeNodes()
     }
 
     /**
-     * Clean small networks that will be never be visited by this explorer See #86 For example,
-     * small areas like parking lots are sometimes connected to the whole network through a one-way road.
-     * This is clearly an error - but is causes the routing to fail when point get connected to this
-     * small area. This routines removed all these points from the graph.
+     * Clean small networks that will be never be visited by this explorer See #86 for example,
+     * small areas like parking lots are sometimes connected to the whole network through a one-way
+     * road. This is clearly an error - but is causes the routing to fail when a point gets
+     * connected to this small area. This routine removes all these points from the graph.
      * <p/>
-     * @return number of removed nodes;
+     * @return number of removed nodes
      */
     public int removeDeadEndUnvisitedNetworks( final FlagEncoder encoder )
     {
-        // Partition g into strongly connected components using Tarjan's Algorithm.
+        // Partition g into strongly connected components using Tarjan's algorithm.
         final EdgeFilter filter = new DefaultEdgeFilter(encoder, false, true);
         List<TIntArrayList> components = new TarjansStronglyConnectedComponentsAlgorithm(g, filter).findComponents();
 
         // remove components less than minimum size
-        int removed = 0;
-        for (TIntArrayList component : components) {
-
-            if (component.size() < minOnewayNetworkSize) {
-                for (int i = 0; i < component.size(); i++) {
+        int removedNodes = 0;
+        for (TIntArrayList component : components)
+        {
+            if (component.size() < minOneWayNetworkSize)
+            {
+                for (int i = 0; i < component.size(); i++)
+                {
                     g.markNodeRemoved(component.get(i));
-                    removed ++;
+                    removedNodes++;
                 }
             }
         }
-        return removed;
+        return removedNodes;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java b/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
index e21eab1310..4d1b653244 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
@@ -20,7 +20,7 @@
 /**
  * Used to store a priority value in the way flags of an edge. Used in combination with
  * PriorityWeighting
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public enum PriorityCode
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java b/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
index 1b20c872a4..fa0bae4eef 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
@@ -19,10 +19,11 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PMap;
 
 /**
  * Special weighting for (motor)bike
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class PriorityWeighting extends FastestWeighting
@@ -32,9 +33,14 @@
      */
     public static final int KEY = 101;
 
+    public PriorityWeighting( FlagEncoder encoder, PMap pMap )
+    {
+        super(encoder, pMap);
+    }
+
     public PriorityWeighting( FlagEncoder encoder )
     {
-        super(encoder);
+        this(encoder, new PMap(0));
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
index 9ccb9e1855..2d72a23410 100644
--- a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
@@ -18,7 +18,10 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.OSMWay;
+import com.graphhopper.util.PMap;
+
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import java.util.TreeMap;
 
 /**
@@ -34,13 +37,23 @@ public RacingBikeFlagEncoder()
         this(4, 2, 0);
     }
 
+    public RacingBikeFlagEncoder( PMap properties )
+    {
+        this(
+                (int) properties.getLong("speedBits", 4),
+                properties.getDouble("speedFactor", 2),
+                properties.getBool("turnCosts", false) ? 3 : 0
+        );
+        this.properties = properties;
+        this.setBlockFords(properties.getBool("blockFords", true));
+    }
+
     public RacingBikeFlagEncoder( String propertiesStr )
     {
-        this((int) parseLong(propertiesStr, "speedBits", 4),
-                parseDouble(propertiesStr, "speedFactor", 2),
-                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+        this(new PMap(propertiesStr));
     }
 
+
     public RacingBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
     {
         super(speedBits, speedFactor, maxTurnCosts);
@@ -114,6 +127,18 @@ public RacingBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCost
         setCyclingNetworkPreference("rcn", PriorityCode.VERY_NICE.getValue());
         setCyclingNetworkPreference("lcn", PriorityCode.UNCHANGED.getValue());
         setCyclingNetworkPreference("mtb", PriorityCode.UNCHANGED.getValue());
+
+        absoluteBarriers.add("kissing_gate");
+
+        setAvoidSpeedLimit(81);
+        setSpecificBicycleClass("roadcycling");
+
+    }
+
+    @Override
+    public int getVersion()
+    {
+        return 1;
     }
 
     @Override
@@ -141,6 +166,7 @@ boolean isPushingSection( OSMWay way )
         String highway = way.getTag("highway");
         String trackType = way.getTag("tracktype");
         return way.hasTag("highway", pushingSections)
+                || way.hasTag("railway", "platform")
                 || "track".equals(highway) && trackType != null && !"grade1".equals(trackType);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java b/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java
deleted file mode 100644
index 6e7769e6e1..0000000000
--- a/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util;
-
-import com.graphhopper.GraphHopper;
-import com.graphhopper.coll.MapEntry;
-import com.graphhopper.routing.RoutingAlgorithm;
-import com.graphhopper.routing.ch.PrepareContractionHierarchies;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.index.LocationIndex;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.util.StopWatch;
-import static com.graphhopper.routing.util.NoOpAlgorithmPreparation.*;
-import com.graphhopper.routing.util.TestAlgoCollector.OneRun;
-import com.graphhopper.storage.*;
-import com.graphhopper.storage.index.LocationIndexTreeSC;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map.Entry;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * Integration tests for one bigger area - at the moment Unterfranken (Germany). Execute via
- * ./graphhopper.sh test unterfranken.osm
- * <p/>
- * @author Peter Karich
- */
-public class RoutingAlgorithmSpecialAreaTests
-{
-    private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final Graph unterfrankenGraph;
-    private final LocationIndex idx;
-
-    public RoutingAlgorithmSpecialAreaTests( GraphHopper graphhopper )
-    {
-        this.unterfrankenGraph = graphhopper.getGraph();
-        StopWatch sw = new StopWatch().start();
-        idx = graphhopper.getLocationIndex();
-        logger.info(idx.getClass().getSimpleName() + " index. Size:"
-                + (float) idx.getCapacity() / (1 << 20) + " MB, took:" + sw.stop().getSeconds());
-    }
-
-    public void start()
-    {
-        testIndex();
-        testAlgos();
-    }
-
-    void testAlgos()
-    {
-        if (unterfrankenGraph instanceof LevelGraph)
-        {
-            throw new IllegalStateException("run testAlgos only with a none-LevelGraph. Use prepare.chWeighting=no "
-                    + "Or use prepare.chWeighting=shortest and avoid the preparation");
-        }
-
-        TestAlgoCollector testCollector = new TestAlgoCollector("testAlgos");
-        final EncodingManager encodingManager = new EncodingManager("CAR", 4);
-        CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
-        boolean ch = true;
-        Collection<Entry<AlgorithmPreparation, LocationIndex>> prepares = createAlgos(unterfrankenGraph, idx,
-                carEncoder, ch, TraversalMode.NODE_BASED, new ShortestWeighting(), encodingManager);
-        EdgeFilter ef = new DefaultEdgeFilter(carEncoder);
-
-        for (Entry<AlgorithmPreparation, LocationIndex> entry : prepares)
-        {
-            AlgorithmPreparation prepare = entry.getKey();
-            int failed = testCollector.errors.size();
-
-            OneRun or = new OneRun(50.0314, 10.5105, 50.0303, 10.5070, 571, 22);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(49.51451, 9.967346, 50.2920, 10.4650, 107909, 1929);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(50.0780, 9.1570, 49.5860, 9.9750, 95562, 1556);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(50.2800, 9.7190, 49.8960, 10.3890, 81016, 1724);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(49.8020, 9.2470, 50.4940, 10.1970, 134767, 2295);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(49.72449, 9.23482, 50.4140, 10.2750, 140809, 2680);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(50.1100, 10.7530, 49.6500, 10.3410, 77381, 1863);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-
-            System.out.println("unterfranken " + prepare.createAlgo() + ": " + (testCollector.errors.size() - failed) + " failed");
-        }
-
-        testCollector.printSummary();
-    }
-
-    private static class ME extends MapEntry<AlgorithmPreparation, LocationIndex>
-    {
-        public ME( AlgorithmPreparation ap, LocationIndex idx )
-        {
-            super(ap, idx);
-        }
-    }
-
-    public static Collection<Entry<AlgorithmPreparation, LocationIndex>> createAlgos( Graph g,
-            LocationIndex idx, FlagEncoder encoder, boolean withCh, TraversalMode tMode, Weighting weighting, EncodingManager manager )
-    {
-        List<Entry<AlgorithmPreparation, LocationIndex>> prepare = new ArrayList<Entry<AlgorithmPreparation, LocationIndex>>();
-        prepare.add(new ME(createAlgoPrepare(g, "astar", encoder, weighting, tMode), idx));
-        // prepare.add(new ME(createAlgoPrepare(g, "dijkstraOneToMany", encoder, weighting, edgeBased), idx));
-        prepare.add(new ME(createAlgoPrepare(g, "astarbi", encoder, weighting, tMode), idx));
-        prepare.add(new ME(createAlgoPrepare(g, "dijkstrabi", encoder, weighting, tMode), idx));
-        prepare.add(new ME(createAlgoPrepare(g, "dijkstra", encoder, weighting, tMode), idx));
-
-        if (withCh)
-        {
-            LevelGraph graphCH = (LevelGraph) ((GraphStorage) g).copyTo(new GraphBuilder(manager).
-                    set3D(g.getNodeAccess().is3D()).levelGraphCreate());
-            PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(encoder, weighting, tMode).
-                    setGraph(graphCH);
-            prepareCH.doWork();
-            LocationIndex idxCH = new LocationIndexTreeSC(graphCH, new RAMDirectory()).prepareIndex();
-            prepare.add(new ME(prepareCH, idxCH));
-
-            PrepareContractionHierarchies prepareCHAStar = new PrepareContractionHierarchies(encoder, weighting, tMode)
-            {
-                @Override
-                public RoutingAlgorithm createAlgo()
-                {
-                    return createAStar().setApproximation(true).setApproximationFactor(1);
-                }
-            }.setGraph(graphCH);
-            prepare.add(new ME(prepareCHAStar, idxCH));
-        }
-        return prepare;
-    }
-
-    void testIndex()
-    {
-        TestAlgoCollector testCollector = new TestAlgoCollector("testIndex");
-        testCollector.queryIndex(unterfrankenGraph, idx, 50.080539, 10.125854, 63.35);
-        testCollector.queryIndex(unterfrankenGraph, idx, 50.081146, 10.124496, 0.0);
-        testCollector.queryIndex(unterfrankenGraph, idx, 49.68243, 9.933271, 436.29);
-        testCollector.queryIndex(unterfrankenGraph, idx, 50.066495, 10.191836, 14.63);
-
-        testCollector.printSummary();
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
index 418caed170..3309065849 100644
--- a/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
@@ -34,7 +34,7 @@ public double getMinWeight( double currDistToGoal )
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId)
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
     {
         return edgeState.getDistance();
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java b/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java
index 1eff527304..4d028882a8 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java
@@ -13,12 +13,13 @@
 /**
  * Implementation of Tarjan's algorithm using an explicit stack.
  * (The traditional recursive approach runs into stack overflow pretty quickly.)
- *
+ * <p/>
  * Used for finding strongly connected components to detect dead-ends.
- *
+ * <p/>
  * http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm
  */
-public class TarjansStronglyConnectedComponentsAlgorithm {
+public class TarjansStronglyConnectedComponentsAlgorithm
+{
 
     private final GraphStorage g;
     private final TIntArrayStack nodeStack;
@@ -30,7 +31,8 @@
     private int index = 1;
     private final EdgeFilter edgeFilter;
 
-    public TarjansStronglyConnectedComponentsAlgorithm(final GraphStorage g, final EdgeFilter edgeFilter) {
+    public TarjansStronglyConnectedComponentsAlgorithm( final GraphStorage g, final EdgeFilter edgeFilter )
+    {
         this.g = g;
         this.nodeStack = new TIntArrayStack();
         this.onStack = new GHBitSetImpl(g.getNodes());
@@ -42,11 +44,14 @@ public TarjansStronglyConnectedComponentsAlgorithm(final GraphStorage g, final E
     /**
      * Find and return list of all strongly connected components in g.
      */
-    public List<TIntArrayList> findComponents() {
+    public List<TIntArrayList> findComponents()
+    {
 
         int nodes = g.getNodes();
-        for (int start = 0; start < nodes; start++) {
-            if (nodeIndex[start] == 0 && !g.isNodeRemoved(start)) {
+        for (int start = 0; start < nodes; start++)
+        {
+            if (nodeIndex[start] == 0 && !g.isNodeRemoved(start))
+            {
                 strongConnect(start);
             }
         }
@@ -55,29 +60,33 @@ public TarjansStronglyConnectedComponentsAlgorithm(final GraphStorage g, final E
     }
 
     // Find all components reachable from firstNode, add them to 'components'
-    private void strongConnect(int firstNode) {
+    private void strongConnect( int firstNode )
+    {
         final Stack<TarjanState> stateStack = new Stack<TarjanState>();
         stateStack.push(TarjanState.startState(firstNode));
 
         // nextState label is equivalent to the function entry point in the recursive Tarjan's algorithm.
         nextState:
 
-        while (!stateStack.empty()) {
+        while (!stateStack.empty())
+        {
             TarjanState state = stateStack.pop();
             final int start = state.start;
             final EdgeIterator iter;
 
-            if (state.isStart()) {
+            if (state.isStart())
+            {
                 // We're traversing a new node 'start'.  Set the depth index for this node to the smallest unused index.
                 nodeIndex[start] = index;
                 nodeLowLink[start] = index;
-                index ++;
+                index++;
                 nodeStack.push(start);
                 onStack.set(start);
 
                 iter = g.createEdgeExplorer(edgeFilter).setBaseNode(start);
 
-            } else { // if (state.isResume()) {
+            } else
+            { // if (state.isResume()) {
 
                 // We're resuming iteration over the next child of 'start', set lowLink as appropriate.
                 iter = state.iter;
@@ -91,23 +100,27 @@ private void strongConnect(int firstNode) {
             while (iter.next())
             {
                 int connectedId = iter.getAdjNode();
-                if (nodeIndex[connectedId] == 0) {
+                if (nodeIndex[connectedId] == 0)
+                {
                     // Push resume and start states onto state stack to continue our DFS through the graph after the jump.
                     // Ideally we'd just call strongConnectIterative(connectedId);
                     stateStack.push(TarjanState.resumeState(start, iter));
                     stateStack.push(TarjanState.startState(connectedId));
                     continue nextState;
-                } else if (onStack.contains(connectedId)) {
+                } else if (onStack.contains(connectedId))
+                {
                     nodeLowLink[start] = Math.min(nodeLowLink[start], nodeIndex[connectedId]);
                 }
             }
 
             // If nodeLowLink == nodeIndex, then we are the first element in a component.
             // Add all nodes higher up on nodeStack to this component.
-            if (nodeIndex[start] == nodeLowLink[start]) {
+            if (nodeIndex[start] == nodeLowLink[start])
+            {
                 TIntArrayList component = new TIntArrayList();
                 int node;
-                while ((node = nodeStack.pop()) != start) {
+                while ((node = nodeStack.pop()) != start)
+                {
                     component.add(node);
                     onStack.clear(node);
                 }
@@ -121,23 +134,30 @@ private void strongConnect(int firstNode) {
 
     // Internal stack state of algorithm, used to avoid recursive function calls and hitting stack overflow exceptions.
     // State is either 'start' for new nodes or 'resume' for partially traversed nodes.
-    private static class TarjanState {
+    private static class TarjanState
+    {
         final int start;
         final EdgeIterator iter;
 
         // Iterator only present in 'resume' state.
-        boolean isStart() { return iter == null; }
+        boolean isStart()
+        {
+            return iter == null;
+        }
 
-        private TarjanState(final int start, final EdgeIterator iter) {
+        private TarjanState( final int start, final EdgeIterator iter )
+        {
             this.start = start;
             this.iter = iter;
         }
 
-        public static TarjanState startState(int start) {
+        public static TarjanState startState( int start )
+        {
             return new TarjanState(start, null);
         }
 
-        public static TarjanState resumeState(int start, EdgeIterator iter) {
+        public static TarjanState resumeState( int start, EdgeIterator iter )
+        {
             return new TarjanState(start, iter);
         }
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
index 1356a796e1..9638077bd0 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
@@ -18,16 +18,14 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.GHResponse;
-import com.graphhopper.routing.Path;
+import com.graphhopper.routing.*;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.PathMerger;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.TranslationMap;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
@@ -38,24 +36,34 @@
 public class TestAlgoCollector
 {
     private final String name;
-    private final DistanceCalc distCalc = new DistanceCalcEarth();
+    private final DistanceCalc distCalc = Helper.DIST_EARTH;
     private final TranslationMap trMap = new TranslationMap().doImport();
-    public List<String> errors = new ArrayList<String>();
+    public final List<String> errors = new ArrayList<String>();
 
     public TestAlgoCollector( String name )
     {
         this.name = name;
     }
 
-    public TestAlgoCollector assertDistance( AlgorithmPreparation prepare, List<QueryResult> queryList, OneRun oneRun )
+    public TestAlgoCollector assertDistance( AlgoHelperEntry algoEntry, List<QueryResult> queryList,
+                                             OneRun oneRun )
     {
         List<Path> viaPaths = new ArrayList<Path>();
+        QueryGraph queryGraph = new QueryGraph(algoEntry.getQueryGraph());
+        queryGraph.lookup(queryList);
+        AlgorithmOptions opts = algoEntry.opts;
+        FlagEncoder encoder = opts.getFlagEncoder();
+        if (encoder.supports(TurnWeighting.class))
+            algoEntry.setAlgorithmOptions(AlgorithmOptions.start(opts).weighting(new TurnWeighting(opts.getWeighting(), opts.getFlagEncoder(), (TurnCostExtension) queryGraph.getExtension())).build());
+
         for (int i = 0; i < queryList.size() - 1; i++)
         {
-            Path path = prepare.createAlgo().calcPath(queryList.get(i), queryList.get(i + 1));
+            Path path = algoEntry.createAlgo(queryGraph).
+                    calcPath(queryList.get(i).getClosestNode(), queryList.get(i + 1).getClosestNode());
             // System.out.println(path.calcInstructions().createGPX("temp", 0, "GMT"));
             viaPaths.add(path);
         }
+
         PathMerger pathMerger = new PathMerger().
                 setCalcPoints(true).
                 setSimplifyResponse(false).
@@ -63,10 +71,10 @@ public TestAlgoCollector assertDistance( AlgorithmPreparation prepare, List<Quer
         GHResponse rsp = new GHResponse();
         pathMerger.doWork(rsp, viaPaths, trMap.getWithFallBack(Locale.US));
 
-        if (!rsp.isFound())
+        if (rsp.hasErrors())
         {
-            errors.add(prepare + " returns no path! expected distance: " + rsp.getDistance()
-                    + ", expected points: " + oneRun + ". " + queryList);
+            errors.add(algoEntry + " response contains errors. Expected distance: " + rsp.getDistance()
+                    + ", expected points: " + oneRun + ". " + queryList + ", errors:" + rsp.getErrors());
             return this;
         }
 
@@ -74,14 +82,14 @@ public TestAlgoCollector assertDistance( AlgorithmPreparation prepare, List<Quer
         double tmpDist = pointList.calcDistance(distCalc);
         if (Math.abs(rsp.getDistance() - tmpDist) > 2)
         {
-            errors.add(prepare + " path.getDistance was  " + rsp.getDistance()
+            errors.add(algoEntry + " path.getDistance was  " + rsp.getDistance()
                     + "\t pointList.calcDistance was " + tmpDist + "\t (expected points " + oneRun.getLocs()
                     + ", expected distance " + oneRun.getDistance() + ") " + queryList);
         }
 
         if (Math.abs(rsp.getDistance() - oneRun.getDistance()) > 2)
         {
-            errors.add(prepare + " returns path not matching the expected distance of " + oneRun.getDistance()
+            errors.add(algoEntry + " returns path not matching the expected distance of " + oneRun.getDistance()
                     + "\t Returned was " + rsp.getDistance() + "\t (expected points " + oneRun.getLocs()
                     + ", was " + pointList.getSize() + ") " + queryList);
         }
@@ -89,7 +97,7 @@ public TestAlgoCollector assertDistance( AlgorithmPreparation prepare, List<Quer
         // There are real world instances where A-B-C is identical to A-C (in meter precision).
         if (Math.abs(pointList.getSize() - oneRun.getLocs()) > 1)
         {
-            errors.add(prepare + " returns path not matching the expected points of " + oneRun.getLocs()
+            errors.add(algoEntry + " returns path not matching the expected points of " + oneRun.getLocs()
                     + "\t Returned was " + pointList.getSize() + "\t (expected distance " + oneRun.getDistance()
                     + ", was " + rsp.getDistance() + ") " + queryList);
         }
@@ -139,6 +147,51 @@ void printSummary()
         }
     }
 
+    public static class AlgoHelperEntry
+    {
+        private Graph queryGraph;
+        private final LocationIndex idx;
+        private AlgorithmOptions opts;
+
+        public AlgoHelperEntry( Graph g, AlgorithmOptions opts, LocationIndex idx )
+        {
+            this.queryGraph = g;
+            this.opts = opts;
+            this.idx = idx;
+        }
+
+        public Graph getQueryGraph()
+        {
+            return queryGraph;
+        }
+
+        public void setQueryGraph( Graph queryGraph )
+        {
+            this.queryGraph = queryGraph;
+        }
+
+        public void setAlgorithmOptions( AlgorithmOptions opts )
+        {
+            this.opts = opts;
+        }
+
+        public LocationIndex getIdx()
+        {
+            return idx;
+        }
+
+        public RoutingAlgorithm createAlgo( Graph qGraph )
+        {
+            return new RoutingAlgorithmFactorySimple().createAlgo(qGraph, opts);
+        }
+
+        @Override
+        public String toString()
+        {
+            return opts.getAlgorithm();
+        }
+    }
+
     public static class OneRun
     {
         private final List<AssumptionPerPath> assumptions = new ArrayList<AssumptionPerPath>();
diff --git a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
index 20738fd6a9..97016e72c9 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
@@ -20,6 +20,7 @@
 
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
+
 import java.util.Arrays;
 
 /**
@@ -27,7 +28,7 @@
  * Different options define how precise turn restrictions and costs are taken into account, but
  * still all are without via-way support. BTW: this would not be done at runtime, this would be a
  * pre-processing step to avoid performance penalities.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public enum TraversalMode
@@ -73,7 +74,7 @@
      * Returns the identifier to access the map of the shortest path tree according to the traversal
      * mode. E.g. returning the adjacent node id in node-based behavior whilst returning the edge id
      * in edge-based behavior
-     * <p>
+     * <p/>
      * @param iterState the current {@link EdgeIteratorState}
      * @param reverse <code>true</code>, if traversal in backward direction. Will be true only for
      * backward searches in bidirectional algorithms.
@@ -86,12 +87,35 @@ public final int createTraversalId( EdgeIteratorState iterState, boolean reverse
             if (noOfStates == 1)
                 return iterState.getEdge();
 
-            return GHUtility.createEdgeKey(iterState.getAdjNode(), iterState.getBaseNode(), iterState.getEdge(), reverse);
+            return GHUtility.createEdgeKey(iterState.getBaseNode(), iterState.getAdjNode(), iterState.getEdge(), reverse);
         }
 
         return iterState.getAdjNode();
     }
 
+    /**
+     * If you have an EdgeIteratorState the other createTraversalId is preferred!
+     */
+    public final int createTraversalId( int baseNode, int adjNode, int edgeId, boolean reverse )
+    {
+        if (edgeBased)
+        {
+            if (noOfStates == 1)
+                return edgeId;
+
+            return GHUtility.createEdgeKey(baseNode, adjNode, edgeId, reverse);
+        }
+
+        return adjNode;
+    }
+
+    public int reverseEdgeKey( int edgeKey )
+    {
+        if (edgeBased && noOfStates > 1)
+            return GHUtility.reverseEdgeKey(edgeKey);
+        return edgeKey;
+    }
+
     public int getNoOfStates()
     {
         return noOfStates;
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
index ca8ce6cb7c..fa769794f9 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
@@ -19,7 +19,7 @@
 
 /**
  * Encodes and decodes a turn restriction and turn costs within a integer flag
- * <p>
+ * <p/>
  * @author Karl Hbner
  */
 public interface TurnCostEncoder
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java b/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
index a2d54f09ec..9372701727 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
@@ -17,13 +17,13 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 
 /**
  * Provides methods to retrieve turn costs for a specific turn.
- * <p>
+ * <p/>
  * @author Karl Hbner
  * @author Peter Karich
  */
@@ -33,21 +33,21 @@
      * Encoder, which decodes the turn flags
      */
     private final TurnCostEncoder turnCostEncoder;
-    private final TurnCostStorage turnCostStorage;
+    private final TurnCostExtension turnCostExt;
     private final Weighting superWeighting;
     private double defaultUTurnCost = 40;
 
     /**
-     * @param turnCostStorage the turn cost storage to be used
+     * @param turnCostExt the turn cost storage to be used
      */
-    public TurnWeighting( Weighting superWeighting, TurnCostEncoder encoder, TurnCostStorage turnCostStorage )
+    public TurnWeighting( Weighting superWeighting, TurnCostEncoder encoder, TurnCostExtension turnCostExt )
     {
         this.turnCostEncoder = encoder;
         this.superWeighting = superWeighting;
-        this.turnCostStorage = turnCostStorage;
+        this.turnCostExt = turnCostExt;
         if (encoder == null)
             throw new IllegalArgumentException("No encoder set to calculate turn weight");
-        if (turnCostStorage == null)
+        if (turnCostExt == null)
             throw new RuntimeException("No storage set to calculate turn weight");
     }
 
@@ -89,7 +89,7 @@ public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prev
 
     public double calcTurnWeight( int edgeFrom, int nodeVia, int edgeTo )
     {
-        long turnFlags = turnCostStorage.getTurnCostFlags(nodeVia, edgeFrom, edgeTo);
+        long turnFlags = turnCostExt.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
         if (turnCostEncoder.isTurnRestricted(turnFlags))
             return Double.POSITIVE_INFINITY;
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
new file mode 100644
index 0000000000..9941a97067
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
@@ -0,0 +1,22 @@
+package com.graphhopper.routing.util;
+
+/**
+ * Specifies a weight approximation between an node and the goalNode according to the specified weighting.
+ * <p/>
+ * @author jansoe
+ */
+public interface WeightApproximator
+{
+
+    /**
+     * @return minimal weight fromNode to the goalNode
+     */
+    double approximate( int fromNode );
+
+    void setGoalNode( int to );
+
+    /**
+     * makes a deep copy of itself
+     */
+    WeightApproximator duplicate();
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java b/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
index b69f61d8f7..3caa6064ff 100644
--- a/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
+++ b/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
@@ -20,7 +20,6 @@
 import com.graphhopper.util.PMap;
 
 /**
- *
  * @author Peter Karich
  */
 public class WeightingMap extends PMap
@@ -31,8 +30,7 @@ public WeightingMap()
 
     /**
      * Convenient constructor if only one parameter is provided
-     * <p>
-     * @param weighting
+     * <p/>
      */
     public WeightingMap( String weighting )
     {
diff --git a/core/src/main/java/com/graphhopper/search/Geocoding.java b/core/src/main/java/com/graphhopper/search/Geocoding.java
index 06239cf252..f1db4c9024 100644
--- a/core/src/main/java/com/graphhopper/search/Geocoding.java
+++ b/core/src/main/java/com/graphhopper/search/Geocoding.java
@@ -18,6 +18,7 @@
 package com.graphhopper.search;
 
 import com.graphhopper.util.shapes.GHPlace;
+
 import java.util.List;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/search/NameIndex.java b/core/src/main/java/com/graphhopper/search/NameIndex.java
index 53bccab6c8..ec619f6c6f 100644
--- a/core/src/main/java/com/graphhopper/search/NameIndex.java
+++ b/core/src/main/java/com/graphhopper/search/NameIndex.java
@@ -20,6 +20,7 @@
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.Storable;
+import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.Helper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -30,13 +31,13 @@
  */
 public class NameIndex implements Storable<NameIndex>
 {
-    private static Logger logger = LoggerFactory.getLogger(NameIndex.class);
-    private static final int START_POINTER = 1;
-    private int bytePointer = START_POINTER;
-    private DataAccess names;
+    private static final Logger logger = LoggerFactory.getLogger(NameIndex.class);
+    private static final long START_POINTER = 1;
+    private final DataAccess names;
+    private long bytePointer = START_POINTER;
     // minor optimization for the previous stored name
     private String lastName;
-    private int lastIndex;
+    private long lastIndex;
 
     public NameIndex( Directory dir )
     {
@@ -55,7 +56,7 @@ public boolean loadExisting()
     {
         if (names.loadExisting())
         {
-            bytePointer = names.getHeader(0);
+            bytePointer = BitUtil.LITTLE.combineIntsToLong(names.getHeader(0), names.getHeader(4));
             return true;
         }
 
@@ -63,9 +64,9 @@ public boolean loadExisting()
     }
 
     /**
-     * @return the integer reference
+     * @return the byte pointer to the name
      */
-    public int put( String name )
+    public long put( String name )
     {
         if (name == null || name.isEmpty())
         {
@@ -76,7 +77,7 @@ public int put( String name )
             return lastIndex;
         }
         byte[] bytes = getBytes(name);
-        int oldPointer = bytePointer;
+        long oldPointer = bytePointer;
         names.ensureCapacity(bytePointer + 1 + bytes.length);
         byte[] sizeBytes = new byte[]
         {
@@ -86,10 +87,6 @@ public int put( String name )
         bytePointer++;
         names.setBytes(bytePointer, bytes, bytes.length);
         bytePointer += bytes.length;
-        if (bytePointer < 0)
-        {
-            throw new IllegalStateException("Way index is too large. Cannot contain more than 2GB");
-        }
         lastName = name;
         lastIndex = oldPointer;
         return oldPointer;
@@ -119,16 +116,15 @@ public int put( String name )
         return bytes;
     }
 
-    public String get( int pointer )
+    public String get( long pointer )
     {
         if (pointer < 0)
-        {
-            throw new IllegalStateException("pointer cannot be negative:" + pointer);
-        }
+            throw new IllegalStateException("Pointer to access NameIndex cannot be negative:" + pointer);
+
+        // default
         if (pointer == 0)
-        {
             return "";
-        }
+
         byte[] sizeBytes = new byte[1];
         names.getBytes(pointer, sizeBytes, 1);
         int size = sizeBytes[0] & 0xFF;
@@ -140,7 +136,8 @@ public String get( int pointer )
     @Override
     public void flush()
     {
-        names.setHeader(0, bytePointer);
+        names.setHeader(0, BitUtil.LITTLE.getIntLow(bytePointer));
+        names.setHeader(4, BitUtil.LITTLE.getIntHigh(bytePointer));
         names.flush();
     }
 
diff --git a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java b/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
index 164da777d0..1332f2b5a8 100644
--- a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
+++ b/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
@@ -18,6 +18,7 @@
 package com.graphhopper.search;
 
 import com.graphhopper.util.shapes.GHPlace;
+
 import java.util.List;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java b/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
index 1839ce1f43..846cb2ecde 100644
--- a/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.Helper;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
@@ -76,7 +77,7 @@ public void close()
     public boolean isClosed()
     {
         return closed;
-    }        
+    }
 
     @Override
     public void setHeader( int bytePos, int value )
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
similarity index 59%
rename from core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java
rename to core/src/main/java/com/graphhopper/storage/BaseGraph.java
index 6839b38ede..e551b2f593 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -1,79 +1,96 @@
 /*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.storage.index;
+package com.graphhopper.storage;
 
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.AllEdgesSkipIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.BBox;
 
 /**
- * The LevelGraph has some edges disconnected (to be more efficient), but this happens before the
- * index is created! So we need to take care of this and also ignore the introduced shortcuts e.g.
- * for calculating closest edges.
- * <p/>
- * TODO avoid some of the tricks if we move a disconnected edge to the end of the edge-list (instead
- * of just disconnecting them). And then while accessing them break iteration if we encounter the
- * first of those disconnected edges (this should have the same speed). Therefor we also need to
- * change the EdgeFilter interface and add a stop(EdgeIterator) method or similar.
- * <p/>
  * @author Peter Karich
  */
-public class LocationIndexTreeSC extends LocationIndexTree
+class BaseGraph implements Graph
 {
-    private final static EdgeFilter NO_SHORTCUT = new EdgeFilter()
-    {
-        @Override
-        public boolean accept( EdgeIteratorState edgeIterState )
-        {
-            return !((EdgeSkipIterator) edgeIterState).isShortcut();
-        }
-    };
     private final LevelGraph lg;
 
-    public LocationIndexTreeSC( LevelGraph g, Directory dir )
+    BaseGraph( LevelGraph lg )
+    {
+        this.lg = lg;
+    }
+
+    @Override
+    public Graph getBaseGraph()
+    {
+        return this;
+    }
+
+    @Override
+    public int getNodes()
+    {
+        return lg.getNodes();
+    }
+
+    @Override
+    public NodeAccess getNodeAccess()
+    {
+        return lg.getNodeAccess();
+    }
+
+    @Override
+    public BBox getBounds()
+    {
+        return lg.getBounds();
+    }
+
+    @Override
+    public EdgeIteratorState edge( int a, int b )
+    {
+        return lg.edge(a, b);
+    }
+
+    @Override
+    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirections )
     {
-        super(g, dir);
-        lg = g;
+        return lg.edge(a, b, distance, bothDirections);
     }
 
     @Override
-    protected int pickBestNode( int nodeA, int nodeB )
+    public EdgeIteratorState getEdgeProps( int edgeId, int adjNode )
     {
-        // return lower level nodes as those nodes are always connected to higher ones
-        // (high level nodes are potentially disconnected from lower ones in order to improve performance on Android)
-        if (lg.getLevel(nodeA) < lg.getLevel(nodeB))
-            return nodeA;
-        return nodeB;
+        if (lg.isShortcut(edgeId))
+            throw new IllegalStateException("Do not fetch shortcuts from BaseGraph use the LevelGraph instead");
+
+        return lg.getEdgeProps(edgeId, adjNode);
     }
 
     @Override
-    protected AllEdgesIterator getAllEdges()
+    public AllEdgesIterator getAllEdges()
     {
         final AllEdgesSkipIterator tmpIter = lg.getAllEdges();
         return new AllEdgesIterator()
         {
             @Override
-            public int getMaxId()
+            public int getCount()
             {
-                return tmpIter.getMaxId();
+                return tmpIter.getCount();
             }
 
             @Override
@@ -155,6 +172,12 @@ public EdgeIteratorState setName( String name )
                 return tmpIter.setName(name);
             }
 
+            @Override
+            public boolean getBoolean(int key, boolean reverse, boolean _default)
+            {
+                return tmpIter.getBoolean(key, reverse, _default);
+            }
+
             @Override
             public int getAdditionalField()
             {
@@ -182,8 +205,48 @@ public EdgeIteratorState detach( boolean reverse )
     }
 
     @Override
-    protected EdgeFilter getEdgeFilter()
+    public EdgeExplorer createEdgeExplorer( final EdgeFilter filter )
+    {
+        if (filter == EdgeFilter.ALL_EDGES)
+            return createEdgeExplorer();
+
+        return lg.createEdgeExplorer(new EdgeFilter()
+        {
+            @Override
+            public boolean accept( EdgeIteratorState edgeIterState )
+            {
+                if (((EdgeSkipIterator) edgeIterState).isShortcut())
+                    return false;
+
+                return filter.accept(edgeIterState);
+            }
+        });
+    }
+
+    private final static EdgeFilter NO_SHORTCUTS = new EdgeFilter()
+    {
+        @Override
+        public boolean accept( EdgeIteratorState edgeIterState )
+        {
+            return !((EdgeSkipIterator) edgeIterState).isShortcut();
+        }
+    };
+
+    @Override
+    public EdgeExplorer createEdgeExplorer()
+    {
+        return lg.createEdgeExplorer(NO_SHORTCUTS);
+    }
+
+    @Override
+    public Graph copyTo( Graph g )
+    {
+        throw new UnsupportedOperationException("Not supported yet.");
+    }
+
+    @Override
+    public GraphExtension getExtension()
     {
-        return NO_SHORTCUT;
+        return lg.getExtension();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/DAType.java b/core/src/main/java/com/graphhopper/storage/DAType.java
index a1d337c3d8..13117929fd 100644
--- a/core/src/main/java/com/graphhopper/storage/DAType.java
+++ b/core/src/main/java/com/graphhopper/storage/DAType.java
@@ -61,7 +61,9 @@
     {
         HEAP, MMAP, UNSAFE /*, DIRECT */
 
-    };
+    }
+
+    ;
     private final MemRef memRef;
     private final boolean storing;
     private final boolean integ;
diff --git a/core/src/main/java/com/graphhopper/storage/DataAccess.java b/core/src/main/java/com/graphhopper/storage/DataAccess.java
index b22c593851..0810cfe126 100644
--- a/core/src/main/java/com/graphhopper/storage/DataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/DataAccess.java
@@ -94,11 +94,11 @@
     /**
      * Ensures that the capacity of this object is at least the specified bytes. The first time you
      * have to call 'create' instead.
-     * <p>
-     * @see #create(long)
+     * <p/>
      * @return true if size was increased
+     * @see #create(long)
      */
-    boolean ensureCapacity(long bytes);
+    boolean ensureCapacity( long bytes );
 
     /**
      * Reduces the allocate space to the specified bytes. Warning: it'll free the space even if it
diff --git a/core/src/main/java/com/graphhopper/storage/Directory.java b/core/src/main/java/com/graphhopper/storage/Directory.java
index 53cf760bd7..43c1f7d36a 100644
--- a/core/src/main/java/com/graphhopper/storage/Directory.java
+++ b/core/src/main/java/com/graphhopper/storage/Directory.java
@@ -18,6 +18,7 @@
 package com.graphhopper.storage;
 
 import java.nio.ByteOrder;
+import java.util.Collection;
 
 /**
  * Maintains a collection of DataAccess objects stored at the same location. One GraphStorage per
@@ -50,6 +51,7 @@
      * Renames the specified DataAccess object into one.
      */
     // DataAccess rename( DataAccess da, String newName );
+
     /**
      * Removes the specified object from the directory.
      */
@@ -64,4 +66,9 @@
      * Removes all contained objects from the directory and releases its resources.
      */
     void clear();
+
+    /**
+     * Returns all created directories.
+     */
+    Collection<DataAccess> getAll();
 }
diff --git a/core/src/main/java/com/graphhopper/storage/Edge.java b/core/src/main/java/com/graphhopper/storage/Edge.java
deleted file mode 100644
index e4da0fef75..0000000000
--- a/core/src/main/java/com/graphhopper/storage/Edge.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.storage;
-
-/**
- * 'Edges' do not exist as separate objects in GraphHopper for the storage as this would be too
- * memory intensive. Look into EdgeIterator and Graph.getEdges(index) instead. But it is used as
- * base class in all algorithms except the native BidirectionalDijkstra.
- * <p/>
- * @see EdgeEntry
- * @author Peter Karich
- */
-public class Edge implements Comparable<Edge>
-{
-    public int edge;
-    public int adjNode;
-    public double weight;
-
-    public Edge( int edgeId, int adjNode, double weight )
-    {
-        this.edge = edgeId;
-        this.adjNode = adjNode;
-        this.weight = weight;
-    }
-
-    @Override
-    public int compareTo( Edge o )
-    {
-        return Double.compare(weight, o.weight);
-    }
-
-    @Override
-    public String toString()
-    {
-        return adjNode + " (" + edge + ") weight: " + weight;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/storage/EdgeEntry.java b/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
index e835cac4c7..184a4ba9fe 100644
--- a/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
+++ b/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
@@ -22,13 +22,18 @@
  * <p/>
  * @author Peter Karich
  */
-public class EdgeEntry extends Edge implements Cloneable
+public class EdgeEntry implements Cloneable, Comparable<EdgeEntry>
 {
+    public int edge;
+    public int adjNode;
+    public double weight;
     public EdgeEntry parent;
 
     public EdgeEntry( int edgeId, int adjNode, double weight )
     {
-        super(edgeId, adjNode, weight);
+        this.edge = edgeId;
+        this.adjNode = adjNode;
+        this.weight = weight;
     }
 
     @Override
@@ -50,4 +55,16 @@ public EdgeEntry cloneFull()
         }
         return de;
     }
+
+    @Override
+    public int compareTo( EdgeEntry o )
+    {
+        return Double.compare(weight, o.weight);
+    }
+
+    @Override
+    public String toString()
+    {
+        return adjNode + " (" + edge + ") weight: " + weight;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GHDirectory.java b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
index 68f12c3f56..4b01333f0f 100644
--- a/core/src/main/java/com/graphhopper/storage/GHDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
@@ -18,6 +18,7 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.Helper;
+
 import java.io.File;
 import java.nio.ByteOrder;
 import java.util.Collection;
@@ -120,7 +121,7 @@ public DataAccess find( String name, DAType type )
                     da = new RAMDataAccess(name, location, false, byteOrder);
             }
         } else if (type.isMMap())
-        {            
+        {
             da = new MMapDataAccess(name, location, byteOrder, type.isAllowWrites());
         } else
         {
@@ -196,7 +197,8 @@ protected void mkdirs()
             new File(location).mkdirs();
     }
 
-    Collection<DataAccess> getAll()
+    @Override
+    public Collection<DataAccess> getAll()
     {
         return map.values();
     }
diff --git a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
index d3a50c7956..3aa1a0a5f5 100644
--- a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
@@ -22,7 +22,7 @@
 
 /**
  * A helper class for GraphHopperStorage for its node access.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 class GHNodeAccess implements NodeAccess
@@ -36,6 +36,12 @@ public GHNodeAccess( GraphHopperStorage that, boolean withElevation )
         this.elevation = withElevation;
     }
 
+    @Override
+    public void ensureNode( int nodeId )
+    {
+        that.ensureNodeIndex(nodeId);
+    }
+
     @Override
     public final void setNode( int nodeId, double lat, double lon )
     {
@@ -43,10 +49,10 @@ public final void setNode( int nodeId, double lat, double lon )
     }
 
     @Override
-    public final void setNode( int index, double lat, double lon, double ele )
+    public final void setNode( int nodeId, double lat, double lon, double ele )
     {
-        that.ensureNodeIndex(index);
-        long tmp = (long) index * that.nodeEntryBytes;
+        that.ensureNodeIndex(nodeId);
+        long tmp = (long) nodeId * that.nodeEntryBytes;
         that.nodes.setInt(tmp + that.N_LAT, Helper.degreeToInt(lat));
         that.nodes.setInt(tmp + that.N_LON, Helper.degreeToInt(lon));
 
@@ -54,25 +60,13 @@ public final void setNode( int index, double lat, double lon, double ele )
         {
             // meter precision is sufficient for now
             that.nodes.setInt(tmp + that.N_ELE, Helper.eleToInt(ele));
-            if (ele > that.bounds.maxEle)
-                that.bounds.maxEle = ele;
+            that.bounds.update(lat, lon, ele);
 
-            if (ele < that.bounds.minEle)
-                that.bounds.minEle = ele;
+        } else
+        {
+            that.bounds.update(lat, lon);
         }
 
-        if (lat > that.bounds.maxLat)
-            that.bounds.maxLat = lat;
-
-        if (lat < that.bounds.minLat)
-            that.bounds.minLat = lat;
-
-        if (lon > that.bounds.maxLon)
-            that.bounds.maxLon = lon;
-
-        if (lon < that.bounds.minLon)
-            that.bounds.minLon = lon;
-
         // set the default value for the additional field of this node
         if (that.extStorage.isRequireNodeField())
             that.nodes.setInt(tmp + that.N_ADDITIONAL, that.extStorage.getDefaultNodeFieldValue());
diff --git a/core/src/main/java/com/graphhopper/storage/Graph.java b/core/src/main/java/com/graphhopper/storage/Graph.java
index 4ed4457156..7bdd3ce8ac 100644
--- a/core/src/main/java/com/graphhopper/storage/Graph.java
+++ b/core/src/main/java/com/graphhopper/storage/Graph.java
@@ -31,6 +31,12 @@
  */
 public interface Graph
 {
+    /**
+     * @return a graph which behaves like an unprepared graph and e.g. the normal unidirectional
+     * Dijkstra or any graph traversal algorithm can be executed.
+     */
+    Graph getBaseGraph();
+
     /**
      * @return the number of created locations - via setNode() or edge()
      */
@@ -96,8 +102,13 @@
 
     /**
      * Copy this Graph into the specified Graph g.
-     * <p>
+     * <p/>
      * @return the specified GraphStorage g
      */
     Graph copyTo( Graph g );
+
+    /**
+     * @return the graph extension like a TurnCostExtension
+     */
+    GraphExtension getExtension();
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
index 2381732ffa..cfcbc63c83 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
@@ -117,7 +117,7 @@ public GraphStorage build()
         else
         {
             if (encodingManager.needsTurnCostsSupport())
-                graph = new GraphHopperStorage(dir, encodingManager, elevation, new TurnCostStorage());
+                graph = new GraphHopperStorage(dir, encodingManager, elevation, new TurnCostExtension());
             else
                 graph = new GraphHopperStorage(dir, encodingManager, elevation);
         }
diff --git a/core/src/main/java/com/graphhopper/storage/ExtendedStorage.java b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
similarity index 82%
rename from core/src/main/java/com/graphhopper/storage/ExtendedStorage.java
rename to core/src/main/java/com/graphhopper/storage/GraphExtension.java
index bafb042ce0..380bf4ec82 100644
--- a/core/src/main/java/com/graphhopper/storage/ExtendedStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
@@ -21,7 +21,7 @@
  * If you need custom storages, like turn cost tables, or osmid tables for your graph you implement
  * this interface and put it in any graph storage you want.
  */
-public interface ExtendedStorage
+public interface GraphExtension extends Storable<GraphExtension>
 {
     /**
      * @return true, if and only if, if an additional field at the graphs node storage is required
@@ -48,46 +48,21 @@
      */
     void init( GraphStorage graph );
 
-    /**
-     * creates all additional data storages
-     */
-    void create( long initSize );
-
-    /**
-     * loads from existing data storages
-     */
-    boolean loadExisting();
-
     /**
      * sets the segment size in all additional data storages
      */
     void setSegmentSize( int bytes );
 
-    /**
-     * flushes all additional data storages
-     */
-    void flush();
-
-    /**
-     * closes all additional data storages
-     */
-    void close();
-
-    /**
-     * returns the sum of all additional data storages capacity
-     */
-    long getCapacity();
-
     /**
      * creates a copy of this extended storage
      */
-    ExtendedStorage copyTo( ExtendedStorage extStorage );
+    GraphExtension copyTo( GraphExtension extStorage );
 
     /**
      * default implementation defines no additional fields or any logic. there's like nothing , like
      * the default behavior.
      */
-    public class NoExtendedStorage implements ExtendedStorage
+    public class NoExtendedStorage implements GraphExtension
     {
 
         @Override
@@ -121,9 +96,10 @@ public void init( GraphStorage grap )
         }
 
         @Override
-        public void create( long initSize )
+        public GraphExtension create( long byteCount )
         {
             // noop
+            return this;
         }
 
         @Override
@@ -158,7 +134,7 @@ public long getCapacity()
         }
 
         @Override
-        public ExtendedStorage copyTo( ExtendedStorage extStorage )
+        public GraphExtension copyTo( GraphExtension extStorage )
         {
             // noop
             return extStorage;
@@ -168,6 +144,12 @@ public ExtendedStorage copyTo( ExtendedStorage extStorage )
         public String toString()
         {
             return "NoExt";
-        }       
+        }
+
+        @Override
+        public boolean isClosed()
+        {
+            return false;
+        }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index 368d32233c..fc47fe77d2 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -24,19 +24,12 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.search.NameIndex;
-import com.graphhopper.util.BitUtil;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.GHUtility;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.PointList;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 
 import static com.graphhopper.util.Helper.nf;
+
 import java.io.UnsupportedEncodingException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 /**
  * The main implementation which handles nodes and edges file format. It can be used with different
@@ -49,9 +42,9 @@
  * Life cycle: (1) object creation, (2) configuration via setters & getters, (3) create or
  * loadExisting, (4) usage, (5) flush, (6) close
  * <p/>
+ * @author Peter Karich
  * @see GraphBuilder Use the GraphBuilder class to create a (Level)GraphStorage easier.
  * @see LevelGraphStorage
- * @author Peter Karich
  */
 public class GraphHopperStorage implements GraphStorage
 {
@@ -98,16 +91,16 @@
     private final StorableProperties properties;
     private final BitUtil bitUtil;
     private boolean flagsSizeIsLong;
-    final ExtendedStorage extStorage;
+    final GraphExtension extStorage;
     private final NodeAccess nodeAccess;
 
     public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean withElevation )
     {
-        this(dir, encodingManager, withElevation, new ExtendedStorage.NoExtendedStorage());
+        this(dir, encodingManager, withElevation, new GraphExtension.NoExtendedStorage());
     }
 
     public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean withElevation,
-            ExtendedStorage extendedStorage )
+                               GraphExtension extendedStorage )
     {
         if (encodingManager == null)
             throw new IllegalArgumentException("EncodingManager cannot be null in GraphHopperStorage since 0.4. "
@@ -122,11 +115,17 @@ public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boole
         this.wayGeometry = dir.find("geometry");
         this.nameIndex = new NameIndex(dir);
         this.properties = new StorableProperties(dir);
-        this.bounds = BBox.INVERSE.clone();
+        this.bounds = BBox.createInverse(withElevation);
         this.nodeAccess = new GHNodeAccess(this, withElevation);
         extendedStorage.init(this);
     }
 
+    @Override
+    public Graph getBaseGraph()
+    {
+        return this;
+    }
+
     void checkInit()
     {
         if (initialized)
@@ -144,7 +143,7 @@ protected final int nextEdgeEntryIndex( int sizeInBytes )
     protected final int nextNodeEntryIndex( int sizeInBytes )
     {
         int tmp = nodeEntryIndex;
-        nodeEntryIndex += 4;
+        nodeEntryIndex += sizeInBytes;
         return tmp;
     }
 
@@ -316,7 +315,7 @@ public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirect
 
     /**
      * Create edge between nodes a and b
-     * <p>
+     * <p/>
      * @return EdgeIteratorState of newly created edge
      */
     @Override
@@ -365,7 +364,7 @@ void setEdgeCount( int cnt )
 
     /**
      * Determine next free edgeId and ensure byte capacity to store edge
-     * <p>
+     * <p/>
      * @return next free edgeId
      */
     private int nextEdge()
@@ -407,6 +406,10 @@ private long writeEdge( int edge, int nodeThis, int nodeOther, int nextEdge, int
             nextEdgeOther = tmp;
         }
 
+        if (edge < 0 || edge == EdgeIterator.NO_EDGE)
+            throw new IllegalStateException("Cannot write edge with illegal ID:" + edge
+                    + "; nodeThis:" + nodeThis + ", nodeOther:" + nodeOther);
+
         long edgePointer = (long) edge * edgeEntryBytes;
         edges.setInt(edgePointer + E_NODEA, nodeThis);
         edges.setInt(edgePointer + E_NODEB, nodeOther);
@@ -511,7 +514,7 @@ public AllEdgeIterator()
         }
 
         @Override
-        public int getMaxId()
+        public int getCount()
         {
             return edgeCount;
         }
@@ -617,11 +620,17 @@ public String getName()
         @Override
         public EdgeIteratorState setName( String name )
         {
-            int nameIndexRef = nameIndex.put(name);
-            edges.setInt(edgePointer + E_NAME, nameIndexRef);
+            GraphHopperStorage.this.setName(edgePointer, name);
             return this;
         }
 
+        @Override
+        public boolean getBoolean( int key, boolean reverse, boolean _default )
+        {
+            // for non-existent keys return default
+            return _default;
+        }
+
         @Override
         public EdgeIteratorState detach( boolean reverseArg )
         {
@@ -692,7 +701,7 @@ private long getFlags( long edgePointer, boolean reverse )
         if (flagsSizeIsLong)
         {
             int high = edges.getInt(edgePointer + E_FLAGS + 4);
-            res = ((long) high << 32) | (low & 0xFFFFFFFFL);
+            res = bitUtil.combineIntsToLong(low, high);
         }
         if (reverse)
             return reverseFlags(edgePointer, res);
@@ -709,12 +718,10 @@ private void setFlags( long edgePointer, boolean reverse, long flags )
         if (reverse)
             flags = reverseFlags(edgePointer, flags);
 
+        edges.setInt(edgePointer + E_FLAGS, bitUtil.getIntLow(flags));
+
         if (flagsSizeIsLong)
-        {
-            edges.setInt(edgePointer + E_FLAGS, (int) (flags & 0xFFFFFFFFL));
-            edges.setInt(edgePointer + E_FLAGS + 4, (int) (flags >> 32));
-        } else
-            edges.setInt(edgePointer + E_FLAGS, (int) (flags & 0xFFFFFFFFL));
+            edges.setInt(edgePointer + E_FLAGS + 4, bitUtil.getIntHigh(flags));
     }
 
     protected class SingleEdge extends EdgeIterable
@@ -800,13 +807,13 @@ public final boolean next()
                 adjNode = getOtherNode(baseNode, edgePointer);
                 reverse = baseNode > adjNode;
 
-                // position to next edge
+                // position to next edge                
                 nextEdge = edges.getInt(getLinkPosInEdgeArea(baseNode, adjNode, edgePointer));
                 if (nextEdge == edgeId)
                     throw new AssertionError("endless loop detected for " + baseNode + ", " + adjNode
                             + ", " + edgePointer + ", " + edgeId);
 
-                foundNext = filter == null || filter.accept(this);
+                foundNext = filter.accept(this);
                 if (foundNext)
                     break;
             }
@@ -887,11 +894,17 @@ public String getName()
             return nameIndex.get(nameIndexRef);
         }
 
+        @Override
+        public boolean getBoolean( int key, boolean reverse, boolean _default )
+        {
+            // for non-existent keys return default
+            return _default;
+        }
+
         @Override
         public EdgeIteratorState setName( String name )
         {
-            int nameIndexRef = nameIndex.put(name);
-            edges.setInt(edgePointer + E_NAME, nameIndexRef);
+            GraphHopperStorage.this.setName(edgePointer, name);
             return this;
         }
 
@@ -901,7 +914,7 @@ public EdgeIteratorState detach( boolean reverseArg )
             if (edgeId == nextEdge)
                 throw new IllegalStateException("call next before detaching");
 
-            EdgeIterable iter = iter = new EdgeIterable(filter);
+            EdgeIterable iter = new EdgeIterable(filter);
             iter.setBaseNode(baseNode);
             iter.setEdgeId(edgeId);
             iter.next();
@@ -1051,6 +1064,15 @@ private PointList fetchWayGeometry( long edgePointer, boolean reverse, int mode,
         return pillarNodes;
     }
 
+    private void setName( long edgePointer, String name )
+    {
+        long nameIndexRef = nameIndex.put(name);
+        if (nameIndexRef < 0)
+            throw new IllegalStateException("Too many names are stored, currently limited to int pointer");
+
+        edges.setInt(edgePointer + E_NAME, (int) nameIndexRef);
+    }
+
     @Override
     public Graph copyTo( Graph g )
     {
@@ -1137,7 +1159,7 @@ public void optimize()
         if (delNodes <= 0)
             return;
 
-        // Deletes only nodes. 
+        // Deletes only nodes.
         // It reduces the fragmentation of the node space but introduces new unused edges.
         inPlaceNodeRemove(delNodes);
 
@@ -1192,7 +1214,7 @@ private void invalidateEdge( long edgePointer )
     private void inPlaceNodeRemove( int removeNodeCount )
     {
         // Prepare edge-update of nodes which are connected to deleted nodes        
-        int toMoveNode = getNodes();
+        int toMoveNodes = getNodes();
         int itemsToMove = 0;
 
         // sorted map when we access it via keyAt and valueAt - see below!
@@ -1212,15 +1234,15 @@ private void inPlaceNodeRemove( int removeNodeCount )
                 toRemoveSet.add(delEdgesIter.getAdjNode());
             }
 
-            toMoveNode--;
-            for (; toMoveNode >= 0; toMoveNode--)
+            toMoveNodes--;
+            for (; toMoveNodes >= 0; toMoveNodes--)
             {
-                if (!removedNodes.contains(toMoveNode))
+                if (!removedNodes.contains(toMoveNodes))
                     break;
             }
 
-            if (toMoveNode >= removeNode)
-                oldToNewMap.put(toMoveNode, removeNode);
+            if (toMoveNodes >= removeNode)
+                oldToNewMap.put(toMoveNodes, removeNode);
 
             itemsToMove++;
         }
@@ -1287,7 +1309,7 @@ private void inPlaceNodeRemove( int removeNodeCount )
         }
 
         // *rewrites* all edges connected to moved nodes
-        // go through all edges and pick the necessary <- this is easier to implement then
+        // go through all edges and pick the necessary <- this is easier to implement than
         // a more efficient (?) breadth-first search
         EdgeIterator iter = getAllEdges();
         while (iter.next())
@@ -1318,6 +1340,9 @@ private void inPlaceNodeRemove( int removeNodeCount )
                 setWayGeometry(fetchWayGeometry(edgePointer, true, 0, -1, -1), edgePointer, false);
         }
 
+        if (removeNodeCount >= nodeCount)
+            throw new IllegalStateException("graph is empty after in-place removal but was " + removeNodeCount);
+
         // we do not remove the invalid edges => edgeCount stays the same!
         nodeCount -= removeNodeCount;
 
@@ -1482,6 +1507,13 @@ protected int loadNodesHeader()
         bounds.maxLon = Helper.intToDegree(nodes.getHeader(4 * 4));
         bounds.minLat = Helper.intToDegree(nodes.getHeader(5 * 4));
         bounds.maxLat = Helper.intToDegree(nodes.getHeader(6 * 4));
+
+        if (bounds.hasElevation())
+        {
+            bounds.minEle = Helper.intToEle(nodes.getHeader(7 * 4));
+            bounds.maxEle = Helper.intToEle(nodes.getHeader(8 * 4));
+        }
+
         return 7;
     }
 
@@ -1494,6 +1526,12 @@ protected int setNodesHeader()
         nodes.setHeader(4 * 4, Helper.degreeToInt(bounds.maxLon));
         nodes.setHeader(5 * 4, Helper.degreeToInt(bounds.minLat));
         nodes.setHeader(6 * 4, Helper.degreeToInt(bounds.maxLat));
+        if (bounds.hasElevation())
+        {
+            nodes.setHeader(7 * 4, Helper.eleToInt(bounds.minEle));
+            nodes.setHeader(8 * 4, Helper.eleToInt(bounds.maxEle));
+        }
+
         return 7;
     }
 
@@ -1558,7 +1596,7 @@ public boolean isClosed()
     }
 
     @Override
-    public ExtendedStorage getExtendedStorage()
+    public GraphExtension getExtension()
     {
         return extStorage;
     }
@@ -1575,7 +1613,7 @@ public String toDetailsString()
     {
         return "edges:" + nf(edgeCount) + "(" + edges.getCapacity() / Helper.MB + "), "
                 + "nodes:" + nf(nodeCount) + "(" + nodes.getCapacity() / Helper.MB + "), "
-                + "name: - (" + nameIndex.getCapacity() / Helper.MB + "), "
+                + "name: /(" + nameIndex.getCapacity() / Helper.MB + "), "
                 + "geo:" + nf(maxGeoRef) + "(" + wayGeometry.getCapacity() / Helper.MB + "), "
                 + "bounds:" + bounds;
     }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphStorage.java b/core/src/main/java/com/graphhopper/storage/GraphStorage.java
index f87f91ab09..4a556f3624 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphStorage.java
@@ -45,9 +45,4 @@
      * Performs optimization routines like deletion or node rearrangements.
      */
     void optimize();
-    
-    /**
-     * @return the extended storage, e.g. TurnCostStorage to store turn costs
-     */
-    ExtendedStorage getExtendedStorage();
 }
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraph.java b/core/src/main/java/com/graphhopper/storage/LevelGraph.java
index 8bca2098a9..d7917c32ef 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/LevelGraph.java
@@ -23,16 +23,29 @@
 import com.graphhopper.util.EdgeSkipIterState;
 
 /**
- * Extended graph interface which supports storing and retrieving the level for a node.
+ * Extended graph interface which supports storing and retrieving the level for a node and creating
+ * shortcuts, which are additional 'artificial' edges to speedup traversal in certain cases.
  * <p/>
  * @author Peter Karich
  */
 public interface LevelGraph extends Graph
 {
-    void setLevel( int index, int level );
-
-    int getLevel( int index );
-
+    /**
+     * This methods sets the level of the specified node.
+     */
+    void setLevel( int nodeId, int level );
+
+    /**
+     * @return the level of the specified node.
+     */
+    int getLevel( int nodeId );
+
+    boolean isShortcut( int edgeId );
+
+    /**
+     * This method creates a shortcut between a to b which is nearly identical to creating an edge
+     * except that it can be excluded or included for certain traversals or algorithms.
+     */
     EdgeSkipIterState shortcut( int a, int b );
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
index 1b666abd0c..571efa3eb2 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
@@ -27,8 +27,8 @@
  * A Graph necessary for shortcut algorithms like Contraction Hierarchies. This class enables the
  * storage to hold the level of a node and a shortcut edge per edge.
  * <p/>
- * @see GraphBuilder
  * @author Peter Karich
+ * @see GraphBuilder
  */
 public class LevelGraphStorage extends GraphHopperStorage implements LevelGraph
 {
@@ -42,10 +42,18 @@
     // after the last edge only shortcuts are stored
     private int lastEdgeIndex = -1;
     private final long scDirMask = PrepareEncoder.getScDirMask();
+    private final Graph baseGraph;
 
     public LevelGraphStorage( Directory dir, EncodingManager encodingManager, boolean enabled3D )
     {
         super(dir, encodingManager, enabled3D);
+        baseGraph = new BaseGraph(this);
+    }
+
+    @Override
+    public boolean isShortcut( int edgeId )
+    {
+        return edgeId > lastEdgeIndex;
     }
 
     @Override
@@ -59,17 +67,22 @@ protected void initStorage()
     }
 
     @Override
-    public final void setLevel( int index, int level )
+    public final void setLevel( int nodeIndex, int level )
     {
-        ensureNodeIndex(index);
-        nodes.setInt((long) index * nodeEntryBytes + I_LEVEL, level);
+        if (nodeIndex >= getNodes())
+            return;
+
+        nodes.setInt((long) nodeIndex * nodeEntryBytes + I_LEVEL, level);
     }
 
     @Override
-    public final int getLevel( int index )
+    public final int getLevel( int nodeIndex )
     {
-        ensureNodeIndex(index);
-        return nodes.getInt((long) index * nodeEntryBytes + I_LEVEL);
+        // automatically allocate new nodes only via creating edges or setting node properties
+        if (nodeIndex >= getNodes())
+            throw new IllegalStateException("node " + nodeIndex + " is invalid. Not in [0," + getNodes() + ")");
+
+        return nodes.getInt((long) nodeIndex * nodeEntryBytes + I_LEVEL);
     }
 
     @Override
@@ -82,7 +95,7 @@ public EdgeSkipIterState shortcut( int a, int b )
     public EdgeSkipIterState edge( int a, int b )
     {
         if (lastEdgeIndex + 1 < edgeCount)
-            throw new IllegalStateException("Cannot create after shortcut was created");
+            throw new IllegalStateException("Cannot create edge after first shortcut was created");
 
         lastEdgeIndex = edgeCount;
         return createEdge(a, b);
@@ -262,30 +275,25 @@ long reverseFlags( long edgePointer, long flags )
     /**
      * Disconnects the edges (higher->lower node) via the specified edgeState pointing from lower to
      * higher node.
-     * <p>
+     * <p/>
      * @param edgeState the edge from lower to higher
      */
     public void disconnect( EdgeSkipExplorer explorer, EdgeIteratorState edgeState )
     {
-        // search edge with opposite direction        
+        // search edge with opposite direction but we need to know the previousEdge for the internalEdgeDisconnect so we cannot simply do:
         // EdgeIteratorState tmpIter = getEdgeProps(iter.getEdge(), iter.getBaseNode());
         EdgeSkipIterator tmpIter = explorer.setBaseNode(edgeState.getAdjNode());
         int tmpPrevEdge = EdgeIterator.NO_EDGE;
-        boolean found = false;
         while (tmpIter.next())
         {
-            // If we disconnect shortcuts only we could run normal algos on the graph too
-            // BUT CH queries will be 10-20% slower and preparation will be 10% slower
-            if (/*tmpIter.isShortcut() &&*/tmpIter.getEdge() == edgeState.getEdge())
+            if (tmpIter.isShortcut() && tmpIter.getEdge() == edgeState.getEdge())
             {
-                found = true;
+                internalEdgeDisconnect(edgeState.getEdge(), (long) tmpPrevEdge * edgeEntryBytes, edgeState.getAdjNode(), edgeState.getBaseNode());
                 break;
             }
 
             tmpPrevEdge = tmpIter.getEdge();
         }
-        if (found)
-            internalEdgeDisconnect(edgeState.getEdge(), (long) tmpPrevEdge * edgeEntryBytes, edgeState.getAdjNode(), edgeState.getBaseNode());
     }
 
     @Override
@@ -409,7 +417,7 @@ final double getWeight( EdgeSkipIterState edge )
         if (!edge.isShortcut())
             throw new IllegalStateException("getWeight is only available for shortcuts");
 
-        double weight = (edge.getFlags() >> 2) / WEIGHT_FACTOR;
+        double weight = (edge.getFlags() >>> 2) / WEIGHT_FACTOR;
         if (weight >= MAX_WEIGHT)
             return Double.POSITIVE_INFINITY;
 
@@ -431,4 +439,10 @@ protected int setEdgesHeader()
         edges.setHeader(next * 4, lastEdgeIndex);
         return next + 1;
     }
+
+    @Override
+    public Graph getBaseGraph()
+    {
+        return baseGraph;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/Lock.java b/core/src/main/java/com/graphhopper/storage/Lock.java
index ca9c118e67..471b1277ac 100644
--- a/core/src/main/java/com/graphhopper/storage/Lock.java
+++ b/core/src/main/java/com/graphhopper/storage/Lock.java
@@ -20,7 +20,7 @@
 
 /**
  * A write lock. Influenced by Lucene code
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public interface Lock
@@ -32,6 +32,6 @@
     boolean isLocked();
 
     void release();
-    
+
     Exception getObtainFailedReason();
 }
diff --git a/core/src/main/java/com/graphhopper/storage/LockFactory.java b/core/src/main/java/com/graphhopper/storage/LockFactory.java
index 1d7170c40f..a4b276c0eb 100644
--- a/core/src/main/java/com/graphhopper/storage/LockFactory.java
+++ b/core/src/main/java/com/graphhopper/storage/LockFactory.java
@@ -35,7 +35,8 @@
     Lock create( String fileName, boolean writeAccess );
 
     /**
-     * Removes the specified lock.
+     * Removes the specified lock. Note: on windows we cannot forcefully remove an unreleased native
+     * lock
      */
     void forceRemove( String fileName, boolean writeAccess );
 }
diff --git a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
index 324168122c..989abf6218 100644
--- a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
@@ -20,6 +20,7 @@
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.NotThreadSafe;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
@@ -32,7 +33,7 @@
 
 /**
  * This is a data structure which uses the operating system to synchronize between disc and memory.
- * Use SynchDAWrapper if you intent to use this from multiple threads!
+ * Use {@link SynchedDAWrapper} if you intent to use this from multiple threads!
  * <p/>
  * @author Peter Karich
  */
@@ -171,7 +172,7 @@ private ByteBuffer newByteBuffer( long offset, long byteCount ) throws IOExcepti
         ByteBuffer buf = null;
         IOException ioex = null;
         // One retry if it fails. It could fail e.g. if previously buffer wasn't yet unmapped from the jvm
-        for (int trial = 0; trial < 1;)
+        for (int trial = 0; trial < 1; )
         {
             try
             {
@@ -299,7 +300,7 @@ void close( boolean forceClean )
     @Override
     public final void setInt( long bytePos, int value )
     {
-        int bufferIndex = (int) (bytePos >>> segmentSizePower);
+        int bufferIndex = (int) (bytePos >> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
         segments.get(bufferIndex).putInt(index, value);
     }
@@ -307,7 +308,7 @@ public final void setInt( long bytePos, int value )
     @Override
     public final int getInt( long bytePos )
     {
-        int bufferIndex = (int) (bytePos >>> segmentSizePower);
+        int bufferIndex = (int) (bytePos >> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
         return segments.get(bufferIndex).getInt(index);
     }
diff --git a/core/src/main/java/com/graphhopper/storage/MMapDirectory.java b/core/src/main/java/com/graphhopper/storage/MMapDirectory.java
index 5561bfaab3..4b31a627b3 100644
--- a/core/src/main/java/com/graphhopper/storage/MMapDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/MMapDirectory.java
@@ -20,8 +20,8 @@
 /**
  * Manages memory mapped DataAccess objects.
  * <p/>
- * @see MMapDataAccess
  * @author Peter Karich
+ * @see MMapDataAccess
  */
 public class MMapDirectory extends GHDirectory
 {
diff --git a/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
index f9640b2053..d794fa76fc 100644
--- a/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
+++ b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
@@ -19,6 +19,7 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.Helper;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
@@ -27,7 +28,7 @@
 
 /**
  * Creates a write lock file. Influenced by Lucene code
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class NativeFSLockFactory implements LockFactory
@@ -65,7 +66,7 @@ public synchronized void forceRemove( String fileName, boolean writeAccess )
         {
             create(fileName, writeAccess).release();
             File lockFile = new File(lockDir, fileName);
-            if (!lockFile.delete())
+            if (lockFile.exists() && !lockFile.delete())
                 throw new RuntimeException("Cannot delete " + lockFile);
         }
     }
@@ -240,7 +241,7 @@ public static void main( String[] args ) throws IOException
 
         file.createNewFile();
         FileChannel channel = new RandomAccessFile(file, "r").getChannel();
-        
+
         boolean shared = true;
         FileLock lock1 = channel.tryLock(0, Long.MAX_VALUE, shared);
 
diff --git a/core/src/main/java/com/graphhopper/storage/NodeAccess.java b/core/src/main/java/com/graphhopper/storage/NodeAccess.java
index 5221b1fb6b..0c0aaf1580 100644
--- a/core/src/main/java/com/graphhopper/storage/NodeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/NodeAccess.java
@@ -24,7 +24,7 @@
  * This interface specifies how to access properties of the nodes in the graph. Similar to
  * EdgeExplorer as it needs multiple instances for different threads or loops but without the need
  * for an additional iterator.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public interface NodeAccess extends PointAccess
@@ -38,7 +38,7 @@
 
     /**
      * Sets the additional value at the specified node index
-     * <p>
+     * <p/>
      * @throws AssertionError if, and only if, the extendedStorage does not require an additional
      * node field
      */
diff --git a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
index 3fe15fffc0..edad71b985 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
@@ -22,6 +22,7 @@
 import java.io.RandomAccessFile;
 import java.nio.ByteOrder;
 import java.util.Arrays;
+
 import org.slf4j.LoggerFactory;
 
 /**
@@ -92,7 +93,7 @@ public RAMDataAccess create( long bytes )
     }
 
     @Override
-    public boolean ensureCapacity(long bytes)
+    public boolean ensureCapacity( long bytes )
     {
         if (bytes < 0)
             throw new IllegalArgumentException("new capacity has to be strictly positive");
diff --git a/core/src/main/java/com/graphhopper/storage/RAMDirectory.java b/core/src/main/java/com/graphhopper/storage/RAMDirectory.java
index 8bc65dde68..0288e5523d 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMDirectory.java
@@ -20,9 +20,9 @@
 /**
  * Manages in-memory DataAccess objects.
  * <p/>
+ * @author Peter Karich
  * @see RAMDataAccess
  * @see RAMIntDataAccess
- * @author Peter Karich
  */
 public class RAMDirectory extends GHDirectory
 {
diff --git a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
index 7d8f66631c..b2598102a5 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
@@ -95,7 +95,7 @@ public RAMIntDataAccess create( long bytes )
     }
 
     @Override
-    public boolean ensureCapacity(long bytes)
+    public boolean ensureCapacity( long bytes )
     {
         if (bytes < 0)
             throw new IllegalArgumentException("new capacity has to be strictly positive");
@@ -266,8 +266,8 @@ public final short getShort( long bytePos )
         if (bytePos % 4 != 0 && bytePos % 4 != 2)
             throw new IllegalMonitorStateException("bytePos of wrong multiple for RAMInt " + bytePos);
 
-        long tmpIndex = bytePos >>> 1;
-        int bufferIndex = (int) (tmpIndex >>> segmentSizeIntsPower);
+        long tmpIndex = bytePos >> 1;
+        int bufferIndex = (int) (tmpIndex >> segmentSizeIntsPower);
         int index = (int) (tmpIndex & indexDivisor);
         if (tmpIndex * 2 == bytePos)
             return (short) segments[bufferIndex][index];
diff --git a/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
index 41b958fc1c..e17d8838b4 100644
--- a/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
+++ b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
@@ -23,7 +23,7 @@
 
 /**
  * Creates a write lock file. Influenced by Lucene code
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class SimpleFSLockFactory implements LockFactory
@@ -113,7 +113,7 @@ public synchronized boolean isLocked()
         @Override
         public synchronized void release()
         {
-            if (isLocked() && !lockFile.delete())
+            if (isLocked() && lockFile.exists() && !lockFile.delete())
                 throw new RuntimeException("Cannot release lock file: " + lockFile);
         }
 
diff --git a/core/src/main/java/com/graphhopper/storage/StorableProperties.java b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
index 7c8dec0694..c432160712 100644
--- a/core/src/main/java/com/graphhopper/storage/StorableProperties.java
+++ b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
+
 import java.io.IOException;
 import java.io.StringReader;
 import java.io.StringWriter;
@@ -113,7 +114,7 @@ public void close()
     public boolean isClosed()
     {
         return da.isClosed();
-    }        
+    }
 
     @Override
     public StorableProperties create( long size )
@@ -168,6 +169,10 @@ public boolean checkVersions( boolean silent )
         {
             return false;
         }
+
+        // The check for the encoder version is done in EncoderManager, as this class does not know about the
+        // registered encoders and their version
+
         return true;
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java b/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
index 841974263f..c157818730 100644
--- a/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
+++ b/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
@@ -100,7 +100,7 @@ public synchronized DataAccess create( long bytes )
     }
 
     @Override
-    public synchronized boolean ensureCapacity(long bytes)
+    public synchronized boolean ensureCapacity( long bytes )
     {
         return inner.ensureCapacity(bytes);
     }
diff --git a/core/src/main/java/com/graphhopper/storage/TurnCostStorage.java b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
similarity index 88%
rename from core/src/main/java/com/graphhopper/storage/TurnCostStorage.java
rename to core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
index c500592291..f8de969dc4 100644
--- a/core/src/main/java/com/graphhopper/storage/TurnCostStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
@@ -23,10 +23,11 @@
  * Holds turn cost tables for each node. The additional field of a node will be used to point
  * towards the first entry within a node cost table to identify turn restrictions, or later, turn
  * getCosts.
- * <p>
+ * <p/>
  * @author Karl Hbner
+ * @author Peter Karich
  */
-public class TurnCostStorage implements ExtendedStorage
+public class TurnCostExtension implements GraphExtension
 {
     /* pointer for no cost entry */
     private final int NO_TURN_ENTRY = -1;
@@ -46,7 +47,7 @@
     private GraphStorage graph;
     private NodeAccess nodeAccess;
 
-    public TurnCostStorage()
+    public TurnCostExtension()
     {
         TC_FROM = nextTurnCostEntryIndex();
         TC_TO = nextTurnCostEntryIndex();
@@ -64,7 +65,7 @@ public void init( GraphStorage graph )
 
         this.graph = graph;
         this.nodeAccess = graph.getNodeAccess();
-        this.turnCosts = this.graph.getDirectory().find("turnCosts");
+        this.turnCosts = this.graph.getDirectory().find("turn_costs");
     }
 
     private int nextTurnCostEntryIndex()
@@ -80,9 +81,10 @@ public void setSegmentSize( int bytes )
     }
 
     @Override
-    public void create( long initBytes )
+    public TurnCostExtension create( long initBytes )
     {
         turnCosts.create((long) initBytes * turnCostsEntryBytes);
+        return this;
     }
 
     @Override
@@ -120,7 +122,7 @@ public boolean loadExisting()
      * This method adds a new entry which is a turn restriction or cost information via the
      * turnFlags.
      */
-    public void addTurnInfo( int nodeIndex, int from, int to, long turnFlags )
+    public void addTurnInfo( int from, int viaNode, int to, long turnFlags )
     {
         // no need to store turn information
         if (turnFlags == EMPTY_FLAGS)
@@ -132,11 +134,11 @@ public void addTurnInfo( int nodeIndex, int from, int to, long turnFlags )
         ensureTurnCostIndex(newEntryIndex);
 
         // determine if we already have an cost entry for this node
-        int previousEntryIndex = nodeAccess.getAdditionalNodeField(nodeIndex);
+        int previousEntryIndex = nodeAccess.getAdditionalNodeField(viaNode);
         if (previousEntryIndex == NO_TURN_ENTRY)
         {
             // set cost-pointer to this new cost entry
-            nodeAccess.setAdditionalNodeField(nodeIndex, newEntryIndex);
+            nodeAccess.setAdditionalNodeField(viaNode, newEntryIndex);
         } else
         {
             int i = 0;
@@ -165,27 +167,27 @@ public void addTurnInfo( int nodeIndex, int from, int to, long turnFlags )
     /**
      * @return turn flags of the specified node and edge properties.
      */
-    public long getTurnCostFlags( int node, int edgeFrom, int edgeTo )
+    public long getTurnCostFlags( int edgeFrom, int nodeVia, int edgeTo )
     {
         if (edgeFrom == EdgeIterator.NO_EDGE || edgeTo == EdgeIterator.NO_EDGE)
             throw new IllegalArgumentException("from and to edge cannot be NO_EDGE");
-        if (node < 0)
+        if (nodeVia < 0)
             throw new IllegalArgumentException("via node cannot be negative");
 
-        return nextCostFlags(node, edgeFrom, edgeTo);
+        return nextCostFlags(edgeFrom, nodeVia, edgeTo);
     }
 
-    private long nextCostFlags( int node, int edgeFrom, int edgeTo )
+    private long nextCostFlags( int edgeFrom, int nodeVia, int edgeTo )
     {
-        int turnCostIndex = nodeAccess.getAdditionalNodeField(node);
+        int turnCostIndex = nodeAccess.getAdditionalNodeField(nodeVia);
         int i = 0;
         for (; i < 1000; i++)
         {
             if (turnCostIndex == NO_TURN_ENTRY)
                 break;
-            long turnCostPtr = (long) turnCostIndex * turnCostsEntryBytes;            
+            long turnCostPtr = (long) turnCostIndex * turnCostsEntryBytes;
             if (edgeFrom == turnCosts.getInt(turnCostPtr + TC_FROM))
-            {                
+            {
                 if (edgeTo == turnCosts.getInt(turnCostPtr + TC_TO))
                     return turnCosts.getInt(turnCostPtr + TC_FLAGS);
             }
@@ -233,14 +235,14 @@ public int getDefaultEdgeFieldValue()
     }
 
     @Override
-    public ExtendedStorage copyTo( ExtendedStorage clonedStorage )
+    public GraphExtension copyTo( GraphExtension clonedStorage )
     {
-        if (!(clonedStorage instanceof TurnCostStorage))
+        if (!(clonedStorage instanceof TurnCostExtension))
         {
             throw new IllegalStateException("the extended storage to clone must be the same");
         }
 
-        TurnCostStorage clonedTC = (TurnCostStorage) clonedStorage;
+        TurnCostExtension clonedTC = (TurnCostExtension) clonedStorage;
 
         turnCosts.copyTo(clonedTC.turnCosts);
         clonedTC.turnCostsCount = turnCostsCount;
@@ -248,6 +250,12 @@ public ExtendedStorage copyTo( ExtendedStorage clonedStorage )
         return clonedStorage;
     }
 
+    @Override
+    public boolean isClosed()
+    {
+        return turnCosts.isClosed();
+    }
+
     @Override
     public String toString()
     {
diff --git a/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java b/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
index 20d112c42b..b0481339a6 100644
--- a/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
@@ -18,6 +18,7 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.NotThreadSafe;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
@@ -28,11 +29,11 @@
  * This is a data structure which uses an unsafe access to native memory. The speed up compared to
  * RAMDataAccess is roughly 10% due to index calculations and BitUtil overhead in RAMDataAccess.
  * Notes:
- * <p>
+ * <p/>
  * 1. Highly experimental. Still some bugs and access through file/MMAP should work at some point
- * <p>
+ * <p/>
  * 2. Compared to MMAP no syncDAWrapper is need to make it read and write safe from multiple threads
- * <p>
+ * <p/>
  * 3. Cannot be used on Android as no memory allocation methods are available there
  * <p/>
  * @author Peter Karich
@@ -60,7 +61,7 @@
     }
 
     private long address;
-    private long capacity;    
+    private long capacity;
 
     UnsafeDataAccess( String name, String location, ByteOrder order )
     {
@@ -78,7 +79,7 @@ public UnsafeDataAccess create( long bytes )
     }
 
     @Override
-    public final boolean ensureCapacity(long bytes)
+    public final boolean ensureCapacity( long bytes )
     {
         return ensureCapacity(bytes, true);
     }
diff --git a/core/src/main/java/com/graphhopper/storage/VLongStorage.java b/core/src/main/java/com/graphhopper/storage/VLongStorage.java
index 87096def80..8595d5b49b 100644
--- a/core/src/main/java/com/graphhopper/storage/VLongStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/VLongStorage.java
@@ -76,8 +76,8 @@ void writeByte( byte b )
     /**
      * Writes an long in a variable-length format. Writes between one and nine bytes. Smaller values
      * take fewer bytes. Negative numbers are not supported.
-     * <p>
-     * The format is described further in {@link DataOutput#writeVInt(int)}.
+     * <p/>
+     * The format is described further in Lucene its DataOutput#writeVInt(int)
      * <p/>
      * See DataInput readVLong of Lucene
      */
@@ -95,7 +95,7 @@ public final void writeVLong( long i )
     /**
      * Reads a long stored in variable-length format. Reads between one and nine bytes. Smaller
      * values take fewer bytes. Negative numbers are not supported.
-     * <p>
+     * <p/>
      * The format is described further in DataOutput writeVInt(int) -> Lucene.
      */
     public long readVLong()
diff --git a/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java b/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
index ec3a4b9011..39550e04c6 100644
--- a/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
+++ b/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
@@ -21,7 +21,7 @@
  * We need the supercover line. The best algorithm is a 'voxel grid traversal algorithm' and
  * described in "A Fast Voxel Traversal Algorithm for Ray Tracing" by John Amanatides and Andrew Woo
  * (1987): http://www.cse.yorku.ca/~amana/research/grid.pdf
- * <p>
+ * <p/>
  * Other methods we used are Bresenham (only integer start and end values) and Xiaolin Wu (anti
  * aliasing). See some discussion here: http://stackoverflow.com/a/3234074/194609 and here
  * http://stackoverflow.com/q/24679963/194609
@@ -31,13 +31,13 @@
 public class BresenhamLine
 {
     public static void calcPoints( int y1, int x1, int y2, int x2,
-            PointEmitter emitter )
+                                   PointEmitter emitter )
     {
         bresenham(y1, x1, y2, x2, emitter);
     }
 
     public static void voxelTraversal( double y1, double x1, double y2, double x2,
-            PointEmitter emitter )
+                                       PointEmitter emitter )
     {
         // edge case
         x1 = fix(x1);
@@ -115,7 +115,7 @@ static final double frac( double val )
     }
 
     public static void bresenham( int y1, int x1, int y2, int x2,
-            PointEmitter emitter )
+                                  PointEmitter emitter )
     {
         boolean latIncreasing = y1 < y2;
         boolean lonIncreasing = x1 < x2;
@@ -145,7 +145,7 @@ public static void bresenham( int y1, int x1, int y2, int x2,
     }
 
     public static void xiaolinWu( double y1, double x1, double y2, double x2,
-            PointEmitter emitter )
+                                  PointEmitter emitter )
     {
         double dx = x2 - x1;
         double dy = y2 - y1;
@@ -238,10 +238,10 @@ public static void xiaolinWu( double y1, double x1, double y2, double x2,
     }
 
     public static void calcPoints( final double lat1, final double lon1,
-            final double lat2, final double lon2,
-            final PointEmitter emitter,
-            final double offsetLat, final double offsetLon,
-            final double deltaLat, final double deltaLon )
+                                   final double lat2, final double lon2,
+                                   final PointEmitter emitter,
+                                   final double offsetLat, final double offsetLon,
+                                   final double deltaLat, final double deltaLon )
     {
 //        double y1 = (lat1 - offsetLat) / deltaLat;
 //        double x1 = (lon1 - offsetLon) / deltaLon;
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
index 64e24b3706..8a0a88955f 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
@@ -22,8 +22,7 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DistancePlaneProjection;
+import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.Circle;
 
 /**
@@ -33,7 +32,7 @@
  */
 public class Location2IDFullIndex implements LocationIndex
 {
-    private DistanceCalc calc = new DistancePlaneProjection();
+    private DistanceCalc calc = Helper.DIST_PLANE;
     private final Graph graph;
     private final NodeAccess nodeAccess;
     private boolean closed = false;
@@ -54,9 +53,9 @@ public boolean loadExisting()
     public LocationIndex setApproximation( boolean approxDist )
     {
         if (approxDist)
-            calc = new DistancePlaneProjection();
+            calc = Helper.DIST_PLANE;
         else
-            calc = new DistanceCalcEarth();
+            calc = Helper.DIST_EARTH;
 
         return this;
     }
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
index 04769a6280..a189adffd4 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
@@ -24,6 +24,7 @@
 import com.graphhopper.util.DistancePlaneProjection;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.Helper;
 
 /**
  * Same as full index but calculates distance to all edges too
@@ -32,7 +33,7 @@
  */
 public class Location2IDFullWithEdgesIndex implements LocationIndex
 {
-    private DistanceCalc calc = new DistanceCalcEarth();
+    private DistanceCalc calc = Helper.DIST_EARTH;
     private final Graph graph;
     private final NodeAccess nodeAccess;
     private boolean closed = false;
@@ -60,10 +61,10 @@ public LocationIndex setApproximation( boolean approxDist )
     {
         if (approxDist)
         {
-            calc = new DistancePlaneProjection();
+            calc = Helper.DIST_PLANE;
         } else
         {
-            calc = new DistanceCalcEarth();
+            calc = Helper.DIST_EARTH;
         }
         return this;
     }
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
index 390d763af4..879fbf2a01 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
@@ -24,14 +24,12 @@
 import com.graphhopper.geohash.LinearKeyAlgo;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.*;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DistancePlaneProjection;
-import com.graphhopper.util.StopWatch;
-import com.graphhopper.util.BreadthFirstSearch;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.Arrays;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -40,17 +38,17 @@
  * implementation is the a very memory efficient representation for areas with lots of node and
  * edges, but lacks precision. No edge distances are measured.
  * <p/>
+ * @author Peter Karich
  * @see LocationIndexTree which is more precise but more complicated and also slightly slower
  * implementation of LocationIndex.
  * <p/>
- * @author Peter Karich
  */
 class Location2IDQuadtree implements LocationIndex
 {
     private final static int MAGIC_INT = Integer.MAX_VALUE / 12306;
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private KeyAlgo keyAlgo;
-    protected DistanceCalc distCalc = new DistancePlaneProjection();
+    protected DistanceCalc distCalc = Helper.DIST_PLANE;
     private final DataAccess index;
     private double maxRasterWidth2InMeterNormed;
     private final Graph graph;
@@ -69,9 +67,9 @@ public Location2IDQuadtree( Graph g, Directory dir )
     public LocationIndex setApproximation( boolean approxDist )
     {
         if (approxDist)
-            distCalc = new DistancePlaneProjection();
+            distCalc = Helper.DIST_PLANE;
         else
-            distCalc = new DistanceCalcEarth();
+            distCalc = Helper.DIST_EARTH;
 
         return this;
     }
@@ -320,7 +318,7 @@ public int findID( final double lat, final double lon )
 
     @Override
     public QueryResult findClosest( final double queryLat, final double queryLon,
-            final EdgeFilter edgeFilter )
+                                    final EdgeFilter edgeFilter )
     {
         if (isClosed())
             throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
index d0d82b92f3..7d4cf03a60 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
@@ -47,14 +47,18 @@
     int findID( double lat, double lon );
 
     /**
+     * This method returns the closest QueryResult for the specified location (lat, lon) and only if
+     * the filter accepts the edge as valid candidate (e.g. filtering away car-only results for bike
+     * search)
+     * <p/>
      * @param edgeFilter if a graph supports multiple vehicles we have to make sure that the entry
      * node into the graph is accessible from a selected vehicle. E.g. if you have a FOOT-query do:      <pre>
-     *   new DefaultEdgeFilter(new FootFlagEncoder());
+     *   new DefaultEdgeFilter(footFlagEncoder);
      * </pre>
-     * <p>
+     * <p/>
      * @return An object containing the closest node and edge for the specfied location. The node id
-     * has at least one edge which is accepted from the specified edgeFilter. If nothing is found it
-     * returns null.
+     * has at least one edge which is accepted from the specified edgeFilter. If nothing is found
+     * the method QueryResult.isValid will return false.
      */
     QueryResult findClosest( double lat, double lon, EdgeFilter edgeFilter );
 
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index 225012f10c..b5aff65a8c 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -20,11 +20,11 @@
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHTBitSet;
 import com.graphhopper.geohash.SpatialKeyAlgo;
-import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
@@ -33,7 +33,9 @@
 import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.procedure.TIntProcedure;
 import gnu.trove.set.hash.TIntHashSet;
+
 import java.util.*;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -50,8 +52,8 @@
 {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final int MAGIC_INT;
-    protected DistanceCalc distCalc = new DistancePlaneProjection();
-    private DistanceCalc preciseDistCalc = new DistanceCalcEarth();
+    protected DistanceCalc distCalc = Helper.DIST_PLANE;
+    private DistanceCalc preciseDistCalc = Helper.DIST_EARTH;
     protected final Graph graph;
     private final NodeAccess nodeAccess;
     final DataAccess dataAccess;
@@ -74,12 +76,18 @@
      */
     private double equalNormedDelta;
 
+    /**
+     * @param g the graph for which this index should do the lookup based on latitude,longitude.
+     */
     public LocationIndexTree( Graph g, Directory dir )
     {
+        if (g instanceof LevelGraph)
+            throw new IllegalArgumentException("Call LevelGraph.getBaseGraph() instead of using the LevelGraph itself");
+
         MAGIC_INT = Integer.MAX_VALUE / 22316;
         this.graph = g;
         this.nodeAccess = g.getNodeAccess();
-        dataAccess = dir.find("locationIndex");
+        dataAccess = dir.find("location_index");
     }
 
     public int getMinResolutionInMeter()
@@ -124,8 +132,11 @@ void prepareAlgo()
         // if we assume a minimum resolution like 0.5km for a leaf-tile                
         // n^(depth/2) = toMeter(dLon) / minResolution
         BBox bounds = graph.getBounds();
-        if (graph.getNodes() == 0 || !bounds.check())
-            throw new IllegalStateException("Bounds of graph are invalid: " + bounds);
+        if (graph.getNodes() == 0)
+            throw new IllegalStateException("Cannot create location index of empty graph!");
+
+        if (!bounds.isValid())
+            throw new IllegalStateException("Cannot create location index when graph has invalid bounds: " + bounds);
 
         double lat = Math.min(Math.abs(bounds.maxLat), Math.abs(bounds.minLat));
         double maxDistInMeter = Math.max(
@@ -235,27 +246,6 @@ public int findID( double lat, double lon )
         return res.getClosestNode();
     }
 
-    @Override
-    public boolean loadExisting()
-    {
-        if (initialized)
-            throw new IllegalStateException("Call loadExisting only once");
-
-        if (!dataAccess.loadExisting())
-            return false;
-
-        if (dataAccess.getHeader(0) != MAGIC_INT)
-            throw new IllegalStateException("incorrect location2id index version, expected:" + MAGIC_INT);
-
-        if (dataAccess.getHeader(1 * 4) != calcChecksum())
-            throw new IllegalStateException("location2id index was opened with incorrect graph");
-
-        setMinResolutionInMeter(dataAccess.getHeader(2 * 4));
-        prepareAlgo();
-        initialized = true;
-        return true;
-    }
-
     @Override
     public LocationIndex setResolution( int minResolutionInMeter )
     {
@@ -270,9 +260,9 @@ public LocationIndex setResolution( int minResolutionInMeter )
     public LocationIndex setApproximation( boolean approx )
     {
         if (approx)
-            distCalc = new DistancePlaneProjection();
+            distCalc = Helper.DIST_PLANE;
         else
-            distCalc = new DistanceCalcEarth();
+            distCalc = Helper.DIST_EARTH;
         return this;
     }
 
@@ -282,6 +272,28 @@ public LocationIndexTree create( long size )
         throw new UnsupportedOperationException("Not supported. Use prepareIndex instead.");
     }
 
+    @Override
+    public boolean loadExisting()
+    {
+        if (initialized)
+            throw new IllegalStateException("Call loadExisting only once");
+
+        if (!dataAccess.loadExisting())
+            return false;
+
+        if (dataAccess.getHeader(0) != MAGIC_INT)
+            throw new IllegalStateException("incorrect location index version, expected:" + MAGIC_INT);
+
+        if (dataAccess.getHeader(1 * 4) != calcChecksum())
+            throw new IllegalStateException("location index was opened with incorrect graph: "
+                    + dataAccess.getHeader(1 * 4) + " vs. " + calcChecksum());
+
+        setMinResolutionInMeter(dataAccess.getHeader(2 * 4));
+        prepareAlgo();
+        initialized = true;
+        return true;
+    }
+
     @Override
     public void flush()
     {
@@ -321,6 +333,7 @@ public LocationIndex prepareIndex()
                 + ", leafs:" + Helper.nf(inMem.leafs)
                 + ", precision:" + minResolutionInMeter
                 + ", depth:" + entries.length
+                + ", checksum:" + calcChecksum()
                 + ", entries:" + Arrays.toString(entries)
                 + ", entriesPerLeaf:" + entriesPerLeaf);
 
@@ -371,7 +384,7 @@ public InMemConstructionIndex( int noOfSubEntries )
 
         void prepare()
         {
-            final EdgeIterator allIter = getAllEdges();
+            final EdgeIterator allIter = graph.getAllEdges();
             try
             {
                 while (allIter.next())
@@ -404,8 +417,8 @@ void prepare()
         }
 
         void addNode( final int nodeA, final int nodeB,
-                final double lat1, final double lon1,
-                final double lat2, final double lon2 )
+                      final double lat1, final double lon1,
+                      final double lat2, final double lon2 )
         {
             PointEmitter pointEmitter = new PointEmitter()
             {
@@ -415,7 +428,7 @@ public void set( double lat, double lon )
                     long key = keyAlgo.encode(lat, lon);
                     long keyPart = createReverseKey(key);
                     // no need to feed both nodes as we search neighbors in fillIDs
-                    addNode(root, pickBestNode(nodeA, nodeB), 0, keyPart, key);
+                    addNode(root, nodeA, 0, keyPart, key);
                 }
             };
             BresenhamLine.calcPoints(lat1, lon1, lat2, lon2, pointEmitter,
@@ -525,7 +538,7 @@ int store( InMemEntry entry, int intIndex )
                 size += len;
                 intIndex++;
                 leafs++;
-                dataAccess.ensureCapacity((long)(intIndex + len + 1) * 4);
+                dataAccess.ensureCapacity((long) (intIndex + len + 1) * 4);
                 if (len == 1)
                 {
                     // less disc space for single entries
@@ -550,7 +563,7 @@ int store( InMemEntry entry, int intIndex )
                     {
                         continue;
                     }
-                    dataAccess.ensureCapacity((long)(intIndex + 1) * 4);
+                    dataAccess.ensureCapacity((long) (intIndex + 1) * 4);
                     int beforeIntIndex = intIndex;
                     intIndex = store(subEntry, beforeIntIndex);
                     if (intIndex == beforeIntIndex)
@@ -616,7 +629,7 @@ final long createReverseKey( long key )
     /**
      * calculate the distance to the nearest tile border for a given lat/lon coordinate in the
      * context of a spatial key tile.
-     * <p>
+     * <p/>
      */
     final double calculateRMin( double lat, double lon )
     {
@@ -784,11 +797,11 @@ public QueryResult findClosest( final double queryLat, final double queryLon, fi
         // clone storedIds to avoid interference with forEach
         final GHBitSet checkBitset = new GHTBitSet(new TIntHashSet(storedNetworkEntryIds));
         // find nodes from the network entries which are close to 'point'
-        final EdgeExplorer explorer = graph.createEdgeExplorer(getEdgeFilter());
+        final EdgeExplorer explorer = graph.createEdgeExplorer();
         storedNetworkEntryIds.forEach(new TIntProcedure()
         {
             @Override
-            public boolean execute( final int networkEntryNodeId )
+            public boolean execute( int networkEntryNodeId )
             {
                 new XFirstSearchCheck(queryLat, queryLon, checkBitset, edgeFilter)
                 {
@@ -907,16 +920,19 @@ protected boolean checkAdjacent( EdgeIteratorState currEdge )
                     tmpNormedDist = distCalc.calcNormalizedEdgeDistance(queryLat, queryLon,
                             tmpLat, tmpLon, wayLat, wayLon);
                     check(tmpClosestNode, tmpNormedDist, pointIndex, currEdge, pos);
-                } else if (pointIndex + 1 == len)
-                {
-                    tmpNormedDist = adjDist;
-                    pos = QueryResult.Position.TOWER;
                 } else
                 {
-                    tmpNormedDist = distCalc.calcNormalizedDist(queryLat, queryLon, wayLat, wayLon);
-                    pos = QueryResult.Position.PILLAR;
+                    if (pointIndex + 1 == len)
+                    {
+                        tmpNormedDist = adjDist;
+                        pos = QueryResult.Position.TOWER;
+                    } else
+                    {
+                        tmpNormedDist = distCalc.calcNormalizedDist(queryLat, queryLon, wayLat, wayLon);
+                        pos = QueryResult.Position.PILLAR;
+                    }
+                    check(tmpClosestNode, tmpNormedDist, pointIndex + 1, currEdge, pos);
                 }
-                check(tmpClosestNode, tmpNormedDist, pointIndex + 1, currEdge, pos);
 
                 if (tmpNormedDist <= equalNormedDelta)
                     return false;
@@ -932,23 +948,6 @@ protected boolean checkAdjacent( EdgeIteratorState currEdge )
         protected abstract boolean check( int node, double normedDist, int wayIndex, EdgeIteratorState iter, QueryResult.Position pos );
     }
 
-    protected int pickBestNode( int nodeA, int nodeB )
-    {
-        // For normal graph the node does not matter because if nodeA is conntected to nodeB
-        // then nodeB is also connect to nodeA, but for a LevelGraph this does not apply.
-        return nodeA;
-    }
-
-    protected EdgeFilter getEdgeFilter()
-    {
-        return EdgeFilter.ALL_EDGES;
-    }
-
-    protected AllEdgesIterator getAllEdges()
-    {
-        return graph.getAllEdges();
-    }
-
     // make entries static as otherwise we get an additional reference to this class (memory waste)
     static interface InMemEntry
     {
diff --git a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
index 80efeb8ae1..ac6619af5e 100644
--- a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
+++ b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
@@ -31,7 +31,7 @@
  * |
  * T--S----N
  * </pre>
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class QueryResult
@@ -44,6 +44,14 @@
     private GHPoint3D snappedPoint;
     private Position snappedPosition;
 
+    /**
+     * Due to precision differences it is hard to define when something is exactly 90 or "on-node"
+     * like TOWER or PILLAR or if it is more "on-edge" (EDGE). The default mechanism is to prefer
+     * "on-edge" even if it could be 90. To prefer "on-node" you could use e.g. GHPoint.equals with
+     * a default precision of 1e-6.
+     * <p/>
+     * @see DistanceCalc#validEdgeDistance
+     */
     public static enum Position
     {
         EDGE, TOWER, PILLAR
diff --git a/core/src/main/java/com/graphhopper/util/AngleCalc.java b/core/src/main/java/com/graphhopper/util/AngleCalc.java
index 4b1a3f1f65..d995c2ee30 100644
--- a/core/src/main/java/com/graphhopper/util/AngleCalc.java
+++ b/core/src/main/java/com/graphhopper/util/AngleCalc.java
@@ -17,16 +17,21 @@
  */
 package com.graphhopper.util;
 
+import static java.lang.Math.PI;
+import static java.lang.Math.cos;
+import static java.lang.Math.toRadians;
+
 /**
  * Calculates the angle of a turn, defined by three points. The fast atan2 method is from Jim Shima,
  * 1999, http://www.dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization
- * <p>
+ * <p/>
  * @author Johannes Pelzer
  * @author Peter Karich
  */
 public class AngleCalc
 {
     private final static double PI_4 = Math.PI / 4.0;
+    private final static double PI_2 = Math.PI / 2.0;
     private final static double PI3_4 = 3.0 * Math.PI / 4.0;
 
     static final double atan2( double y, double x )
@@ -53,12 +58,28 @@ static final double atan2( double y, double x )
 
     /**
      * Return orientation of line relative to east.
-     * <p>
+     * <p/>
      * @return Orientation in interval -pi to +pi where 0 is east
      */
     public double calcOrientation( double lat1, double lon1, double lat2, double lon2 )
     {
-        return atan2((lat2 - lat1), (lon2 - lon1));
+        double shrinkFactor = cos(toRadians((lat1 + lat2) / 2));
+        return Math.atan2((lat2 - lat1), shrinkFactor * (lon2 - lon1));
+    }
+
+    /**
+     * convert north based clockwise azimuth (0, 360) into x-axis/east based angle (-Pi, Pi)
+     */
+    public double convertAzimuth2xaxisAngle(double azimuth)
+    {
+        if (Double.compare(azimuth, 360)>0 || Double.compare(azimuth, 0)<0)
+        {
+            throw new IllegalArgumentException("Azimuth " + azimuth + " must be in (0, 360)");
+        }
+        double angleXY = PI_2 - azimuth/180.*Math.PI;
+        if (angleXY<-Math.PI) angleXY += 2*Math.PI;
+        if (angleXY>Math.PI) angleXY -= 2*Math.PI;
+        return angleXY;
     }
 
     /**
@@ -87,13 +108,13 @@ public double alignOrientation( double baseOrientation, double orientation )
     }
 
     /**
-     * Calculate Azimuth for a line given by two coordinates. Direction in 'degree' where 0 is
-     * north, 90 is east, 180 is south and 270 is west.
+     * Calculate the azimuth in degree for a line given by two coordinates. Direction in 'degree'
+     * where 0 is north, 90 is east, 180 is south and 270 is west.
      */
     double calcAzimuth( double lat1, double lon1, double lat2, double lon2 )
     {
         double orientation = -calcOrientation(lat1, lon1, lat2, lon2);
-        orientation = Helper.round4(orientation + Math.PI / 2);        
+        orientation = Helper.round4(orientation + Math.PI / 2);
         if (orientation < 0)
             orientation += 2 * Math.PI;
 
diff --git a/core/src/main/java/com/graphhopper/util/BitUtil.java b/core/src/main/java/com/graphhopper/util/BitUtil.java
index 2cc2bf043a..ef52addc82 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtil.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtil.java
@@ -21,17 +21,17 @@
 
 /**
  * Examples for BIG endianess (default for Java and computer network).
- * <p>
+ * <p/>
  * byte array: 0=>0100 0001 , 1=>1110 1011, 2=>...
- * <p>
+ * <p/>
  * long: highest=>0100 0001 , 1110 1011, ..., lowest=> ...
- * <p>
+ * <p/>
  * bits to string 0100 0001 , 1110 1011, ...
- * <p>
+ * <p/>
  * LITTLE endianess (default for GraphHopper and most microprocessors)
- * <p>
+ * <p/>
  * byte array ..., 6=>1110 1011, 7=>0100 0001
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public abstract class BitUtil
@@ -195,6 +195,9 @@ public final long fromBitString2Long( String str )
 
     public abstract byte[] fromBitString( String str );
 
+    /**
+     * Similar to Long.toBinaryString
+     */
     public final String toBitString( long value )
     {
         return toBitString(value, 64);
@@ -218,7 +221,7 @@ public String toLastBitString( long value, int bits )
 
     /**
      * Higher order bits comes first in the returned string.
-     * <p>
+     * <p/>
      * @param bits how many bits should be returned.
      */
     public String toBitString( long value, int bits )
@@ -251,7 +254,7 @@ public String toBitString( long value, int bits )
     public final long reverse( long value, int maxBits )
     {
         long res = 0;
-        for (; maxBits > 0; value >>= 1)
+        for (; maxBits > 0; value >>>= 1)
         {
             res <<= 1;
             res |= value & 1;
@@ -265,6 +268,21 @@ public final long reverse( long value, int maxBits )
         return res;
     }
 
+    public final int getIntLow( long longValue )
+    {
+        return (int) (longValue & 0xFFFFFFFFL);
+    }
+
+    public final int getIntHigh( long longValue )
+    {
+        return (int) (longValue >> 32);
+    }
+
+    public final long combineIntsToLong( int intLow, int intHigh )
+    {
+        return ((long) intHigh << 32) | (intLow & 0xFFFFFFFFL);
+    }
+
     public final long reverseLeft( long value, int maxBits )
     {
         long res = 0;
diff --git a/core/src/main/java/com/graphhopper/util/BitUtilLittle.java b/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
index e4ac8415d9..55a815cde7 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
@@ -44,16 +44,16 @@ public final int toInt( byte[] b, int offset )
     @Override
     public void fromShort( byte[] bytes, short value, int offset )
     {
-        bytes[offset + 1] = (byte) (value >> 8);
+        bytes[offset + 1] = (byte) (value >>> 8);
         bytes[offset] = (byte) (value);
     }
 
     @Override
     public final void fromInt( byte[] bytes, int value, int offset )
     {
-        bytes[offset + 3] = (byte) (value >> 24);
-        bytes[offset + 2] = (byte) (value >> 16);
-        bytes[offset + 1] = (byte) (value >> 8);
+        bytes[offset + 3] = (byte) (value >>> 24);
+        bytes[offset + 2] = (byte) (value >>> 16);
+        bytes[offset + 1] = (byte) (value >>> 8);
         bytes[offset] = (byte) (value);
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java b/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
index dab4a9bd47..05d3a3d009 100644
--- a/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
@@ -18,7 +18,6 @@
 package com.graphhopper.util;
 
 import com.graphhopper.coll.GHBitSet;
-import com.graphhopper.coll.GHBitSetImpl;
 
 /**
  * Implementattion of breadth first search (BFS)
@@ -27,9 +26,8 @@
  */
 public class BreadthFirstSearch extends XFirstSearch
 {
-
     @Override
-    public void start( EdgeExplorer explorer, int startNode)
+    public void start( EdgeExplorer explorer, int startNode )
     {
         SimpleIntDeque fifo = new SimpleIntDeque();
         GHBitSet visited = createBitSet();
@@ -39,20 +37,19 @@ public void start( EdgeExplorer explorer, int startNode)
         while (!fifo.isEmpty())
         {
             current = fifo.pop();
-            if (goFurther(current))
+            if (!goFurther(current))
+                continue;
+
+            EdgeIterator iter = explorer.setBaseNode(current);
+            while (iter.next())
             {
-                EdgeIterator iter = explorer.setBaseNode(current);
-                while (iter.next())
+                int connectedId = iter.getAdjNode();
+                if (checkAdjacent(iter) && !visited.contains(connectedId))
                 {
-                    int connectedId = iter.getAdjNode();
-                    if (checkAdjacent(iter) && !visited.contains(connectedId))
-                    {
-                        visited.add(connectedId);
-                        fifo.push(connectedId);
-                    }
+                    visited.add(connectedId);
+                    fifo.push(connectedId);
                 }
             }
         }
     }
-
 }
diff --git a/core/src/main/java/com/graphhopper/util/CmdArgs.java b/core/src/main/java/com/graphhopper/util/CmdArgs.java
index 6c4801f816..9109b37719 100644
--- a/core/src/main/java/com/graphhopper/util/CmdArgs.java
+++ b/core/src/main/java/com/graphhopper/util/CmdArgs.java
@@ -115,7 +115,7 @@ public static CmdArgs read( String[] args )
 
     /**
      * Command line configuration overwrites the ones in the config file.
-     * <p>
+     * <p/>
      * @return a new CmdArgs object if necessary.
      */
     public static CmdArgs readFromConfigAndMerge( CmdArgs args, String configKey, String configSysAttr )
diff --git a/core/src/main/java/com/graphhopper/util/Constants.java b/core/src/main/java/com/graphhopper/util/Constants.java
index 7eac90a65e..af5af167e5 100644
--- a/core/src/main/java/com/graphhopper/util/Constants.java
+++ b/core/src/main/java/com/graphhopper/util/Constants.java
@@ -15,6 +15,7 @@
 package com.graphhopper.util;
 
 import static com.graphhopper.util.Helper.readFile;
+
 import java.io.InputStreamReader;
 import java.util.List;
 
@@ -50,8 +51,8 @@
     public static final String OS_ARCH = System.getProperty("os.arch");
     public static final String OS_VERSION = System.getProperty("os.version");
     public static final String JAVA_VENDOR = System.getProperty("java.vendor");
-    public static final int VERSION_NODE = 3;
-    public static final int VERSION_EDGE = 9;
+    public static final int VERSION_NODE = 4;
+    public static final int VERSION_EDGE = 12;
     public static final int VERSION_GEOMETRY = 3;
     public static final int VERSION_LOCATION_IDX = 2;
     public static final int VERSION_NAME_IDX = 2;
diff --git a/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java b/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
index 7e7056cecb..987657798a 100644
--- a/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
@@ -23,28 +23,28 @@
 /**
  * Implementation of depth first search (DFS) by LIFO queue
  * <p/>
- * @author Peter Karich & Jan Slter
+ * @author Peter Karich
+ * @author Jan Slter
  */
 public class DepthFirstSearch extends XFirstSearch
 {
-
     /**
      * beginning with startNode add all following nodes to LIFO queue. If node has been already
      * explored before, skip reexploration.
      */
     @Override
-    public void start( EdgeExplorer explorer, int startNode)
+    public void start( EdgeExplorer explorer, int startNode )
     {
         TIntArrayStack stack = new TIntArrayStack();
 
         GHBitSet explored = createBitSet();
         stack.push(startNode);
         int current;
-        while (stack.size()>0)
+        while (stack.size() > 0)
         {
             current = stack.pop();
             if (!explored.contains(current) && goFurther(current))
-            {   
+            {
                 EdgeIterator iter = explorer.setBaseNode(current);
                 while (iter.next())
                 {
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc.java b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
index 0a58b949f5..79c6fd89bf 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
@@ -55,23 +55,26 @@
     double calcNormalizedDist( double fromLat, double fromLon, double toLat, double toLon );
 
     /**
-     * This method decides case 1: if we should use distance(r to edge) where r=(lat,lon) or case 2:
-     * min(distance(r to a), distance(r to b)) where edge=(a to b)
+     * This method decides for case 1: if we should use distance(r to edge) where r=(lat,lon) or
+     * case 2: min(distance(r to a), distance(r to b)) where edge=(a to b). Note that due to
+     * rounding errors it cannot properly detect if it is case 1 or 90.
+     * <pre>
+     * case 1 (including ):
+     *   r
+     *  .
+     * a-------b
+     *
+     * case 2:
+     * r
+     *  .
+     *    a-------b
+     * </pre>
      * <p/>
-     * @return true for case 1
+     * @return true for case 1 which is "on edge" or the special case of 90 to the edge
      */
-    // case 1:
-    //   r
-    //  . 
-    // a-------b
-    //    
-    // case 2:
-    // r
-    //  .
-    //    a-------b
     boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg );
+                               double a_lat_deg, double a_lon_deg,
+                               double b_lat_deg, double b_lon_deg );
 
     /**
      * This method calculates the distance from r to edge (a, b) where the crossing point is c
@@ -79,13 +82,13 @@ boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
      * @return the distance in normalized meter
      */
     double calcNormalizedEdgeDistance( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg );
+                                       double a_lat_deg, double a_lon_deg,
+                                       double b_lat_deg, double b_lon_deg );
 
     /**
      * @return the crossing point c of the vertical line from r to line (a, b)
      */
     GHPoint calcCrossingPointToEdge( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg );
+                                     double a_lat_deg, double a_lon_deg,
+                                     double b_lat_deg, double b_lon_deg );
 }
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java b/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java
index d4a2cb35e2..5261e89702 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java
@@ -32,7 +32,7 @@
      * @param toHeight in meters above 0
      */
     public double calcDist( double fromLat, double fromLon, double fromHeight,
-            double toLat, double toLon, double toHeight )
+                            double toLat, double toLon, double toHeight )
     {
         double len = super.calcDist(fromLat, fromLon, toLat, toLon);
         double delta = Math.abs(toHeight - fromHeight);
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
index 209ee796c8..fbcab38d95 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
+
 import static java.lang.Math.*;
 
 /**
@@ -88,12 +89,6 @@ public double calcCircumference( double lat )
         return 2 * PI * R * cos(toRadians(lat));
     }
 
-    public double calcSpatialKeyMaxDist( int bit )
-    {
-        bit = bit / 2 + 1;
-        return (int) C >> bit;
-    }
-
     public boolean isDateLineCrossOver( double lon1, double lon2 )
     {
         return abs(lon1 - lon2) > 180.0;
@@ -117,31 +112,32 @@ public BBox createBBox( double lat, double lon, double radiusInMeter )
 
     @Override
     public double calcNormalizedEdgeDistance( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg )
+                                              double a_lat_deg, double a_lon_deg,
+                                              double b_lat_deg, double b_lon_deg )
     {
         return calcNormalizedEdgeDistanceNew(r_lat_deg, r_lon_deg, a_lat_deg, a_lon_deg, b_lat_deg, b_lon_deg, false);
     }
 
     /**
      * New edge distance calculation where no validEdgeDistance check would be necessary
-     * <p>
+     * <p/>
      * @return the normalized distance of the query point "r" to the project point "c" onto the line
      * segment a-b
      */
     public double calcNormalizedEdgeDistanceNew( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg, boolean reduceToSegment )
+                                                 double a_lat_deg, double a_lon_deg,
+                                                 double b_lat_deg, double b_lon_deg, boolean reduceToSegment )
     {
-        double shrink_factor = cos((toRadians(a_lat_deg) + toRadians(b_lat_deg)) / 2);
+        double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
+
         double a_lat = a_lat_deg;
-        double a_lon = a_lon_deg * shrink_factor;
+        double a_lon = a_lon_deg * shrinkFactor;
 
         double b_lat = b_lat_deg;
-        double b_lon = b_lon_deg * shrink_factor;
+        double b_lon = b_lon_deg * shrinkFactor;
 
         double r_lat = r_lat_deg;
-        double r_lon = r_lon_deg * shrink_factor;
+        double r_lon = r_lon_deg * shrinkFactor;
 
         double delta_lon = b_lon - a_lon;
         double delta_lat = b_lat - a_lat;
@@ -168,23 +164,23 @@ else if (factor < 0)
         // x,y is projection of r onto segment a-b
         double c_lon = a_lon + factor * delta_lon;
         double c_lat = a_lat + factor * delta_lat;
-        return calcNormalizedDist(c_lat, c_lon / shrink_factor, r_lat_deg, r_lon_deg);
+        return calcNormalizedDist(c_lat, c_lon / shrinkFactor, r_lat_deg, r_lon_deg);
     }
 
     @Override
     public GHPoint calcCrossingPointToEdge( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg )
+                                            double a_lat_deg, double a_lon_deg,
+                                            double b_lat_deg, double b_lon_deg )
     {
-        double shrink_factor = cos((toRadians(a_lat_deg) + toRadians(b_lat_deg)) / 2);
+        double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
         double a_lat = a_lat_deg;
-        double a_lon = a_lon_deg * shrink_factor;
+        double a_lon = a_lon_deg * shrinkFactor;
 
         double b_lat = b_lat_deg;
-        double b_lon = b_lon_deg * shrink_factor;
+        double b_lon = b_lon_deg * shrinkFactor;
 
         double r_lat = r_lat_deg;
-        double r_lon = r_lon_deg * shrink_factor;
+        double r_lon = r_lon_deg * shrinkFactor;
 
         double delta_lon = b_lon - a_lon;
         double delta_lat = b_lat - a_lat;
@@ -211,38 +207,23 @@ else if (factor < 0)
         // x,y is projection of r onto segment a-b
         double c_lon = a_lon + factor * delta_lon;
         double c_lat = a_lat + factor * delta_lat;
-        return new GHPoint(c_lat, c_lon / shrink_factor);
+        return new GHPoint(c_lat, c_lon / shrinkFactor);
     }
 
-    /**
-     * This method decides case 1: if we should use distance(r to edge) where r=(lat,lon) or case 2:
-     * min(distance(r to a), distance(r to b)) where edge=(a to b)
-     * <p/>
-     * @return true for case 1
-     */
-    // case 1:
-    //   r
-    //  . 
-    // a-------b
-    //    
-    // case 2:
-    // r
-    //  .
-    //    a-------b
     @Override
     public boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg )
+                                      double a_lat_deg, double a_lon_deg,
+                                      double b_lat_deg, double b_lon_deg )
     {
-        double factor = cos((toRadians(a_lat_deg) + toRadians(b_lat_deg)) / 2);
+        double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
         double a_lat = a_lat_deg;
-        double a_lon = a_lon_deg * factor;
+        double a_lon = a_lon_deg * shrinkFactor;
 
         double b_lat = b_lat_deg;
-        double b_lon = b_lon_deg * factor;
+        double b_lon = b_lon_deg * shrinkFactor;
 
         double r_lat = r_lat_deg;
-        double r_lon = r_lon_deg * factor;
+        double r_lon = r_lon_deg * shrinkFactor;
 
         double ar_x = r_lon - a_lon;
         double ar_y = r_lat - a_lat;
diff --git a/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java b/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java
index e210cb7fbd..112bbaa1ab 100644
--- a/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java
+++ b/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.util.AngleCalc;
 import static java.lang.Math.*;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/util/DouglasPeucker.java b/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
index 24c0e94798..5612ac61e8 100644
--- a/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
+++ b/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
@@ -42,9 +42,9 @@ public void setApproximation( boolean a )
     {
         approx = a;
         if (approx)
-            calc = new DistancePlaneProjection();
+            calc = Helper.DIST_PLANE;
         else
-            calc = new DistanceCalcEarth();
+            calc = Helper.DIST_EARTH;
     }
 
     /**
@@ -172,5 +172,5 @@ int simplify( PointList points, int fromIndex, int lastIndex )
         return counter;
     }
 
-    
+
 }
diff --git a/core/src/main/java/com/graphhopper/util/Downloader.java b/core/src/main/java/com/graphhopper/util/Downloader.java
index 4014857e44..40ba9e0911 100644
--- a/core/src/main/java/com/graphhopper/util/Downloader.java
+++ b/core/src/main/java/com/graphhopper/util/Downloader.java
@@ -29,7 +29,6 @@
  */
 public class Downloader
 {
-
     public static void main( String[] args ) throws IOException
     {
         new Downloader("GraphHopper Downloader").downloadAndUnzip("http://graphhopper.com/public/maps/0.1/europe_germany_berlin.ghz", "somefolder",
@@ -42,11 +41,11 @@ public void update( long val )
                     }
                 });
     }
+
     private String referrer = "http://graphhopper.com";
     private final String userAgent;
     private String acceptEncoding = "gzip, deflate";
     private int timeout = 4000;
-    private int size = 1024 * 8;
 
     public Downloader( String userAgent )
     {
@@ -65,25 +64,35 @@ public Downloader setReferrer( String referrer )
         return this;
     }
 
-    public InputStream fetch( HttpURLConnection conn ) throws IOException
+    public InputStream fetch( HttpURLConnection conn, boolean readErrorStreamNoException ) throws IOException
     {
-        // create connection but before reading get the correct inputstream based on the compression
+        // create connection but before reading get the correct inputstream based on the compression and if error
         conn.connect();
-        String encoding = conn.getContentEncoding();
+
         InputStream is;
-        if (encoding != null && encoding.equalsIgnoreCase("gzip"))
-            is = new GZIPInputStream(conn.getInputStream());
-        else if (encoding != null && encoding.equalsIgnoreCase("deflate"))
-            is = new InflaterInputStream(conn.getInputStream(), new Inflater(true));
+        if (readErrorStreamNoException && conn.getResponseCode() >= 400 && conn.getErrorStream() != null)
+            is = conn.getErrorStream();
         else
             is = conn.getInputStream();
 
+        // wrap
+        try
+        {
+            String encoding = conn.getContentEncoding();
+            if (encoding != null && encoding.equalsIgnoreCase("gzip"))
+                is = new GZIPInputStream(is);
+            else if (encoding != null && encoding.equalsIgnoreCase("deflate"))
+                is = new InflaterInputStream(is, new Inflater(true));
+        } catch (IOException ex)
+        {
+        }
+
         return is;
     }
 
     public InputStream fetch( String url ) throws IOException
     {
-        return fetch((HttpURLConnection) createConnection(url));
+        return fetch((HttpURLConnection) createConnection(url), false);
     }
 
     public HttpURLConnection createConnection( String urlStr ) throws IOException
@@ -106,7 +115,8 @@ public HttpURLConnection createConnection( String urlStr ) throws IOException
     public void downloadFile( String url, String toFile ) throws IOException
     {
         HttpURLConnection conn = createConnection(url);
-        InputStream iStream = fetch(conn);
+        InputStream iStream = fetch(conn, false);
+        int size = 8 * 1024;
         BufferedOutputStream writer = new BufferedOutputStream(new FileOutputStream(toFile), size);
         InputStream in = new BufferedInputStream(iStream, size);
         try
@@ -128,40 +138,20 @@ public void downloadAndUnzip( String url, String toFolder, final ProgressListene
     {
         HttpURLConnection conn = createConnection(url);
         final int length = conn.getContentLength();
-        InputStream iStream = fetch(conn);
+        InputStream iStream = fetch(conn, false);
 
-        new Unzipper().setSize(size).unzip(iStream, new File(toFolder), new ProgressListener()
+        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener()
         {
             @Override
             public void update( long sumBytes )
             {
                 progressListener.update((int) (100 * sumBytes / length));
             }
-        });
-    }
-
-    public String downloadAsString( String url ) throws IOException
-    {
-        return readString(fetch(url));
+        });    
     }
 
-    private String readString( InputStream inputStream ) throws IOException
+    public String downloadAsString( String url, boolean readErrorStreamNoException ) throws IOException
     {
-        String encoding = "UTF-8";
-        InputStream in = new BufferedInputStream(inputStream, size);
-        try
-        {
-            byte[] buffer = new byte[size];
-            ByteArrayOutputStream output = new ByteArrayOutputStream();
-            int numRead;
-            while ((numRead = in.read(buffer)) != -1)
-            {
-                output.write(buffer, 0, numRead);
-            }
-            return output.toString(encoding);
-        } finally
-        {
-            in.close();
-        }
+        return Helper.isToString(fetch((HttpURLConnection) createConnection(url), readErrorStreamNoException));
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeExplorer.java b/core/src/main/java/com/graphhopper/util/EdgeExplorer.java
index 3d6cebd4c2..5cf1a23893 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeExplorer.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeExplorer.java
@@ -20,9 +20,9 @@
 /**
  * Class to get EdgeIterator create it via graph.createEdgeExplorer(). Use one instance per thread.
  * <p/>
+ * @author Peter Karich
  * @see EdgeIterator
  * @see EdgeIteratorState
- * @author Peter Karich
  */
 public interface EdgeExplorer
 {
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIterator.java b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
index a3f2107628..b28b715223 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
@@ -33,16 +33,15 @@
  *   int adjacentNodeId = iter.getAdjNode(); // this is the node where this edge state is "pointing to"
  *   ...
  * }
- *
+ * @author Peter Karich
  * @see EdgeIteratorState
  * @see EdgeExplorer
- * @author Peter Karich
  */
 public interface EdgeIterator extends EdgeIteratorState
 {
     /**
      * To be called to go to the next edge state.
-     * <p>
+     * <p/>
      * @return true if an edge state is available
      */
     boolean next();
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java b/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
index e790ec8afb..c5a78bbf55 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
@@ -20,12 +20,14 @@
 /**
  * This interface represents an edge and is one possible state of an EdgeIterator.
  * <p/>
+ * @author Peter Karich
  * @see EdgeIterator
  * @see EdgeExplorer
- * @author Peter Karich
  */
 public interface EdgeIteratorState
 {
+    final static int K_UNFAVORED_EDGE = -1;
+    
     /**
      * @return the edge id of the current edge. Do not make any assumptions about the concrete
      * values, except that for an implemention it is recommended that they'll be contiguous.
@@ -83,6 +85,13 @@
      */
     int getAdditionalField();
 
+    /**
+     * get additional boolean edge information
+     * @param reverse  if property of reverse edge direction should be returned
+     * @param _default default value if key is not found
+     */
+    boolean getBoolean( int key, boolean reverse, boolean _default);
+    
     /**
      * Updates the additional field value for this edge
      */
@@ -94,7 +103,7 @@
 
     /**
      * Clones this EdgeIteratorState.
-     * <p>
+     * <p/>
      * @param reverse if true a detached edgeState with reversed properties is created where base
      * and adjacent nodes, flags and wayGeometry are in reversed order. See #162 for more details
      * about why we need the new reverse parameter.
@@ -103,7 +112,7 @@
 
     /**
      * Copies the properties of this edge into the specified edge. Does not change nodes!
-     * <p>
+     * <p/>
      * @return the specified edge e
      */
     EdgeIteratorState copyPropertiesTo( EdgeIteratorState e );
diff --git a/core/src/main/java/com/graphhopper/util/EdgeSkipExplorer.java b/core/src/main/java/com/graphhopper/util/EdgeSkipExplorer.java
index c351f01757..a7709a6c3c 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeSkipExplorer.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeSkipExplorer.java
@@ -22,8 +22,8 @@
 /**
  * Support for skipped edge
  * <p/>
- * @see LevelGraph
  * @author Peter Karich
+ * @see LevelGraph
  */
 public interface EdgeSkipExplorer extends EdgeExplorer
 {
diff --git a/core/src/main/java/com/graphhopper/util/EdgeSkipIterator.java b/core/src/main/java/com/graphhopper/util/EdgeSkipIterator.java
index 26a5dfb725..11273da312 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeSkipIterator.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeSkipIterator.java
@@ -22,8 +22,8 @@
 /**
  * Support for skipped edge
  * <p/>
- * @see LevelGraph
  * @author Peter Karich
+ * @see LevelGraph
  */
 public interface EdgeSkipIterator extends EdgeIterator, EdgeSkipIterState
 {
diff --git a/core/src/main/java/com/graphhopper/util/EdgeWrapper.java b/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
index 95f5181be9..d0dfd27057 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
@@ -17,15 +17,17 @@
  */
 package com.graphhopper.util;
 
+import com.graphhopper.routing.PathBidir;
 import gnu.trove.map.hash.TIntIntHashMap;
+
 import java.util.Arrays;
 
 /**
  * This class acts as a HashMap (nodes to weights) and is used to implement references from one edge
  * to its parent.
  * <p/>
- * @see DijkstraBidirection
  * @author Peter Karich
+ * @see PathBidir
  */
 @NotThreadSafe
 public class EdgeWrapper
diff --git a/core/src/main/java/com/graphhopper/util/FinishInstruction.java b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
index d0b64b939e..a4ca0d21c6 100644
--- a/core/src/main/java/com/graphhopper/util/FinishInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
@@ -22,26 +22,28 @@
  */
 public class FinishInstruction extends Instruction
 {
-    private int count = -1;
-
     public FinishInstruction( final double lat, final double lon, final double ele )
     {
         super(FINISH, "", InstructionAnnotation.EMPTY, new PointList(2, true)
-        {   
+        {
             {
                 add(lat, lon, ele);
             }
         });
     }
 
-    void setVia( int i )
+    public FinishInstruction( PointAccess pointAccess, int node )
     {
-        sign = REACHED_VIA;
-        count = i;
+        this(pointAccess.getLatitude(node), pointAccess.getLongitude(node),
+                pointAccess.is3D() ? pointAccess.getElevation(node) : 0);
     }
 
-    public int getViaPosition()
+    @Override
+    public String getTurnDescription( Translation tr )
     {
-        return count;
+        if (rawName)
+            return getName();
+
+        return tr.tr("finish");
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/GHUtility.java b/core/src/main/java/com/graphhopper/util/GHUtility.java
index d3b0b2d93b..5332a4e3fc 100644
--- a/core/src/main/java/com/graphhopper/util/GHUtility.java
+++ b/core/src/main/java/com/graphhopper/util/GHUtility.java
@@ -27,6 +27,7 @@
 import com.graphhopper.storage.*;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
+
 import java.util.*;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -109,7 +110,8 @@ public static int count( EdgeIterator iter )
 
     public static Set<Integer> getNeighbors( EdgeIterator iter )
     {
-        Set<Integer> list = new HashSet<Integer>();
+        // make iteration order over set static => linked
+        Set<Integer> list = new LinkedHashSet<Integer>();
         while (iter.next())
         {
             list.add(iter.getAdjNode());
@@ -129,7 +131,7 @@ public static int count( EdgeIterator iter )
 
     public static void printEdgeInfo( final Graph g, FlagEncoder encoder )
     {
-        System.out.println("-- Graph n:" + g.getNodes() + " e:" + g.getAllEdges().getMaxId() + " ---");
+        System.out.println("-- Graph n:" + g.getNodes() + " e:" + g.getAllEdges().getCount() + " ---");
         AllEdgesIterator iter = g.getAllEdges();
         while (iter.next())
         {
@@ -139,8 +141,8 @@ public static void printEdgeInfo( final Graph g, FlagEncoder encoder )
                 AllEdgesSkipIterator aeSkip = (AllEdgesSkipIterator) iter;
                 sc = aeSkip.isShortcut() ? "sc" : "  ";
             }
-            String fwdStr = encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD) ? "fwd" : "   ";
-            String bckStr = encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD) ? "bckwd" : "";
+            String fwdStr = encoder.isForward(iter.getFlags()) ? "fwd" : "   ";
+            String bckStr = encoder.isBackward(iter.getFlags()) ? "bckwd" : "";
             System.out.println(sc + " " + iter + " " + fwdStr + " " + bckStr);
         }
     }
@@ -231,7 +233,7 @@ protected GHBitSet createBitSet()
                 @Override
                 protected boolean goFurther( int nodeId )
                 {
-                    list.set(nodeId, ref.incrementAndGet());                    
+                    list.set(nodeId, ref.incrementAndGet());
                     return super.goFurther(nodeId);
                 }
             }.start(explorer, startNode);
@@ -454,6 +456,12 @@ public EdgeIteratorState setName( String name )
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
+        @Override
+        public boolean getBoolean(int key, boolean reverse, boolean _default )
+        {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+        
         @Override
         public int getAdditionalField()
         {
@@ -520,4 +528,12 @@ public static boolean isSameEdgeKeys( int edgeKey1, int edgeKey2 )
     {
         return edgeKey1 / 2 == edgeKey2 / 2;
     }
+
+    /**
+     * Returns the edgeKey of the opposite direction
+     */
+    public static int reverseEdgeKey( int edgeKey )
+    {
+        return edgeKey % 2 == 0 ? edgeKey + 1 : edgeKey - 1;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/GPXEntry.java b/core/src/main/java/com/graphhopper/util/GPXEntry.java
index d9279ca1c3..cad353c103 100644
--- a/core/src/main/java/com/graphhopper/util/GPXEntry.java
+++ b/core/src/main/java/com/graphhopper/util/GPXEntry.java
@@ -50,13 +50,31 @@ boolean is3D()
     }
 
     /**
-     * The time relative to the start time.
+     * The time relative to the start time in milli seconds.
+     */
+    public long getTime()
+    {
+        return time;
+    }
+
+    public void setTime( long time )
+    {
+        this.time = time;
+    }
+
+    /**
+     * The time relative to the start time in milli seconds.
+     * <p/>
+     * @deprecated use getTime instead
      */
     public long getMillis()
     {
         return time;
     }
 
+    /**
+     * @deprecated use setTime instead
+     */
     public void setMillis( long time )
     {
         this.time = time;
diff --git a/core/src/main/java/com/graphhopper/util/Helper.java b/core/src/main/java/com/graphhopper/util/Helper.java
index 4a41404b17..b47030cc07 100644
--- a/core/src/main/java/com/graphhopper/util/Helper.java
+++ b/core/src/main/java/com/graphhopper/util/Helper.java
@@ -20,6 +20,7 @@
 import com.graphhopper.util.shapes.BBox;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
+
 import java.io.*;
 import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
@@ -31,18 +32,21 @@
 import java.text.NumberFormat;
 import java.util.*;
 import java.util.Map.Entry;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * Several utility classes which are compatible with Java6 on Android.
  * <p/>
- * @see Helper7 for none-Android compatible methods.
  * @author Peter Karich
+ * @see Helper7 for none-Android compatible methods.
  */
 public class Helper
 {
-    private static final DistanceCalc dce = new DistanceCalcEarth();
+    public static final DistanceCalc DIST_EARTH = new DistanceCalcEarth();
+    public static final DistanceCalc3D DIST_3D = new DistanceCalc3D();
+    public static final DistancePlaneProjection DIST_PLANE = new DistancePlaneProjection();
     private static final Logger logger = LoggerFactory.getLogger(Helper.class);
     public static Charset UTF_CS = Charset.forName("UTF-8");
     public static final long MB = 1L << 20;
@@ -60,6 +64,10 @@
 
     public static Locale getLocale( String param )
     {
+        int pointIndex = param.indexOf('.');
+        if (pointIndex > 0)
+            param = param.substring(0, pointIndex);
+
         param = param.replace("-", "_");
         int index = param.indexOf("_");
         if (index < 0)
@@ -163,6 +171,27 @@ public static void saveProperties( Map<String, String> map, Writer tmpWriter ) t
         }
     }
 
+    public static String isToString( InputStream inputStream ) throws IOException
+    {
+        int size = 1024 * 8;
+        String encoding = "UTF-8";
+        InputStream in = new BufferedInputStream(inputStream, size);
+        try
+        {
+            byte[] buffer = new byte[size];
+            ByteArrayOutputStream output = new ByteArrayOutputStream();
+            int numRead;
+            while ((numRead = in.read(buffer)) != -1)
+            {
+                output.write(buffer, 0, numRead);
+            }
+            return output.toString(encoding);
+        } finally
+        {
+            in.close();
+        }
+    }
+
     public static int idealIntArraySize( int need )
     {
         return idealByteArraySize(need * 4) / 4;
@@ -271,7 +300,7 @@ public static int calcIndexSize( BBox graphBounds )
         if (!graphBounds.isValid())
             throw new IllegalArgumentException("Bounding box is not valid to calculate index size: " + graphBounds);
 
-        double dist = dce.calcDist(graphBounds.maxLat, graphBounds.minLon,
+        double dist = DIST_EARTH.calcDist(graphBounds.maxLat, graphBounds.minLon,
                 graphBounds.minLat, graphBounds.maxLon);
         // convert to km and maximum is 50000km => 1GB
         dist = Math.min(dist / 1000, 50000);
@@ -335,6 +364,8 @@ public static final int degreeToInt( double deg )
     {
         if (deg >= Double.MAX_VALUE)
             return Integer.MAX_VALUE;
+        if (deg <= -Double.MAX_VALUE)
+            return -Integer.MAX_VALUE;
         return (int) (deg * DEGREE_FACTOR);
     }
 
@@ -347,6 +378,8 @@ public static final double intToDegree( int storedInt )
     {
         if (storedInt == Integer.MAX_VALUE)
             return Double.MAX_VALUE;
+        if (storedInt == -Integer.MAX_VALUE)
+            return -Double.MAX_VALUE;
         return (double) storedInt / DEGREE_FACTOR;
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index da4e2dabf3..c0f1cd4c48 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -17,12 +17,15 @@
  */
 package com.graphhopper.util;
 
+import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 
 public class Instruction
 {
     private static final AngleCalc ac = new AngleCalc();
-    private static final DistanceCalc3D distanceCalc = new DistanceCalc3D();
+
+    public static final int LEAVE_ROUNDABOUT = -6; // for future use
     public static final int TURN_SHARP_LEFT = -3;
     public static final int TURN_LEFT = -2;
     public static final int TURN_SLIGHT_LEFT = -1;
@@ -32,12 +35,15 @@
     public static final int TURN_SHARP_RIGHT = 3;
     public static final int FINISH = 4;
     public static final int REACHED_VIA = 5;
+    public static final int USE_ROUNDABOUT = 6;
+
+    protected boolean rawName;
     protected int sign;
-    private final String name;
-    private double distance;
-    private long time;
-    final PointList points;
-    private final InstructionAnnotation annotation;
+    protected String name;
+    protected double distance;
+    protected long time;
+    protected final PointList points;
+    protected final InstructionAnnotation annotation;
 
     /**
      * The points, distances and times have exactly the same count. The last point of this
@@ -51,24 +57,48 @@ public Instruction( int sign, String name, InstructionAnnotation ia, PointList p
         this.annotation = ia;
     }
 
+    /**
+     * This method does not perform translation or combination with the sign - it just uses the
+     * provided name as instruction.
+     */
+    public void setUseRawName()
+    {
+        rawName = true;
+    }
+
     public InstructionAnnotation getAnnotation()
     {
         return annotation;
     }
 
+    /**
+     * The instruction for the person/driver to execute.
+     */
     public int getSign()
     {
         return sign;
     }
 
-    /**
-     * The instruction for the person/driver to execute.
-     */
     public String getName()
     {
         return name;
     }
 
+    public void setName( String name )
+    {
+        this.name = name;
+    }
+
+    public Map<String, Object> getExtraInfoJSON()
+    {
+        return Collections.<String, Object>emptyMap();
+    }
+
+    public void setExtraInfo( String key, Object value )
+    {
+        throw new IllegalArgumentException("Key" + key + " is not a valid option");
+    }
+
     public Instruction setDistance( double distance )
     {
         this.distance = distance;
@@ -126,11 +156,11 @@ public PointList getPoints()
     /**
      * This method returns a list of gpx entries where the time (in time) is relative to the first
      * which is 0. It does NOT contain the last point which is the first of the next instruction.
-     * <p>
+     * <p/>
      * @return the time offset to add for the next instruction
      */
     long fillGPXList( List<GPXEntry> list, long time,
-            Instruction prevInstr, Instruction nextInstr, boolean firstInstr )
+                      Instruction prevInstr, Instruction nextInstr, boolean firstInstr )
     {
         checkOne();
         int len = points.size();
@@ -144,16 +174,16 @@ long fillGPXList( List<GPXEntry> list, long time,
 
         for (int i = 0; i < len; i++)
         {
+            list.add(new GPXEntry(lat, lon, ele, prevTime));
+
             boolean last = i + 1 == len;
             double nextLat = last ? nextInstr.getFirstLat() : points.getLatitude(i + 1);
             double nextLon = last ? nextInstr.getFirstLon() : points.getLongitude(i + 1);
             double nextEle = is3D ? (last ? nextInstr.getFirstEle() : points.getElevation(i + 1)) : Double.NaN;
-
-            list.add(new GPXEntry(lat, lon, ele, prevTime));
             if (is3D)
-                prevTime = Math.round(prevTime + this.time * distanceCalc.calcDist(nextLat, nextLon, nextEle, lat, lon, ele) / distance);
+                prevTime = Math.round(prevTime + this.time * Helper.DIST_3D.calcDist(nextLat, nextLon, nextEle, lat, lon, ele) / distance);
             else
-                prevTime = Math.round(prevTime + this.time * distanceCalc.calcDist(nextLat, nextLon, lat, lon) / distance);
+                prevTime = Math.round(prevTime + this.time * Helper.DIST_3D.calcDist(nextLat, nextLon, lat, lon) / distance);
 
             lat = nextLat;
             lon = nextLon;
@@ -176,12 +206,10 @@ public String toString()
     }
 
     /**
-     * Return Direction/Compass point based on the first tracksegment of the instruction. If
+     * Return the direction like 'NE' based on the first tracksegment of the instruction. If
      * Instruction does not contain enough coordinate points, an empty string will be returned.
-     * <p>
-     * @return
      */
-    String getDirection( Instruction nextI )
+    String calcDirection( Instruction nextI )
     {
         double azimuth = calcAzimuth(nextI);
         if (Double.isNaN(azimuth))
@@ -191,19 +219,11 @@ String getDirection( Instruction nextI )
     }
 
     /**
-     * Return Azimuth based on the first tracksegment of the instruction. If Instruction does not
-     * contain enough coordinate points, an empty string will be returned.
+     * Return the azimuth in degree based on the first tracksegment of this instruction. If this
+     * instruction contains less than 2 points then NaN will be returned or the specified
+     * instruction will be used if that is the finish instruction.
      */
-    String getAzimuth( Instruction nextI )
-    {
-        double az = calcAzimuth(nextI);
-        if (Double.isNaN(az))
-            return "";
-
-        return "" + Math.round(az);
-    }
-
-    private double calcAzimuth( Instruction nextI )
+    public double calcAzimuth( Instruction nextI )
     {
         double nextLat;
         double nextLon;
@@ -212,7 +232,7 @@ private double calcAzimuth( Instruction nextI )
         {
             nextLat = points.getLatitude(1);
             nextLon = points.getLongitude(1);
-        } else if (points.getSize() == 1 && null != nextI)
+        } else if (nextI != null && points.getSize() == 1)
         {
             nextLat = nextI.points.getLatitude(0);
             nextLon = nextI.points.getLongitude(0);
@@ -234,46 +254,43 @@ void checkOne()
 
     public String getTurnDescription( Translation tr )
     {
+        if (rawName)
+            return getName();
+
         String str;
-        String n = getName();
+        String streetName = getName();
         int indi = getSign();
-        if (indi == Instruction.FINISH)
-        {
-            str = tr.tr("finish");
-        } else if (indi == Instruction.REACHED_VIA)
-        {
-            str = tr.tr("stopover", ((FinishInstruction) this).getViaPosition());
-        } else if (indi == Instruction.CONTINUE_ON_STREET)
+        if (indi == Instruction.CONTINUE_ON_STREET)
         {
-            str = Helper.isEmpty(n) ? tr.tr("continue") : tr.tr("continue_onto", n);
+            str = Helper.isEmpty(streetName) ? tr.tr("continue") : tr.tr("continue_onto", streetName);
         } else
         {
             String dir = null;
             switch (indi)
             {
                 case Instruction.TURN_SHARP_LEFT:
-                    dir = tr.tr("sharp_left");
+                    dir = tr.tr("turn_sharp_left");
                     break;
                 case Instruction.TURN_LEFT:
-                    dir = tr.tr("left");
+                    dir = tr.tr("turn_left");
                     break;
                 case Instruction.TURN_SLIGHT_LEFT:
-                    dir = tr.tr("slight_left");
+                    dir = tr.tr("turn_slight_left");
                     break;
                 case Instruction.TURN_SLIGHT_RIGHT:
-                    dir = tr.tr("slight_right");
+                    dir = tr.tr("turn_slight_right");
                     break;
                 case Instruction.TURN_RIGHT:
-                    dir = tr.tr("right");
+                    dir = tr.tr("turn_right");
                     break;
                 case Instruction.TURN_SHARP_RIGHT:
-                    dir = tr.tr("sharp_right");
+                    dir = tr.tr("turn_sharp_right");
                     break;
             }
             if (dir == null)
-                throw new IllegalStateException("Indication not found " + indi);
+                throw new IllegalStateException("Turn indication not found " + indi);
 
-            str = Helper.isEmpty(n) ? tr.tr("turn", dir) : tr.tr("turn_onto", dir, n);
+            str = Helper.isEmpty(streetName) ? dir : tr.tr("turn_onto", dir, streetName);
         }
         return str;
     }
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index f1b63173a0..d4512f0436 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -18,7 +18,6 @@
 package com.graphhopper.util;
 
 import java.text.SimpleDateFormat;
-
 import java.util.*;
 
 /**
@@ -46,6 +45,14 @@ public InstructionList( int cap, Translation tr )
         this.tr = tr;
     }
 
+    public void replaceLast( Instruction instr )
+    {
+        if (instructions.isEmpty())
+            throw new IllegalStateException("Cannot replace last instruction as list is empty");
+
+        instructions.set(instructions.size() - 1, instr);
+    }
+
     public void add( Instruction instr )
     {
         instructions.add(instr);
@@ -61,47 +68,6 @@ public int size()
         return instructions.size();
     }
 
-    /**
-     * Returns the descriptions of the distance per instruction.
-     */
-    public List<String> createDistances( boolean mile )
-    {
-        List<String> labels = new ArrayList<String>(instructions.size());
-        for (int i = 0; i < instructions.size(); i++)
-        {
-            double distInMeter = instructions.get(i).getDistance();
-            if (mile)
-            {
-                // calculate miles
-                double distInMiles = distInMeter / 1000 / DistanceCalcEarth.KM_MILE;
-                if (distInMiles < 0.9)
-                {
-                    labels.add((int) Helper.round(distInMiles * 5280, 1) + " " + tr.tr("ftAbbr"));
-                } else
-                {
-                    if (distInMiles < 100)
-                        labels.add(Helper.round(distInMiles, 2) + " " + tr.tr("miAbbr"));
-                    else
-                        labels.add((int) Helper.round(distInMiles, 1) + " " + tr.tr("miAbbr"));
-                }
-            } else
-            {
-                if (distInMeter < 950)
-                {
-                    labels.add((int) Helper.round(distInMeter, 1) + " " + tr.tr("mAbbr"));
-                } else
-                {
-                    distInMeter /= 1000;
-                    if (distInMeter < 100)
-                        labels.add(Helper.round(distInMeter, 2) + " " + tr.tr("kmAbbr"));
-                    else
-                        labels.add((int) Helper.round(distInMeter, 1) + " " + tr.tr("kmAbbr"));
-                }
-            }
-        }
-        return labels;
-    }
-
     public List<Map<String, Object>> createJson()
     {
         List<Map<String, Object>> instrList = new ArrayList<Map<String, Object>>(instructions.size());
@@ -119,13 +85,14 @@ public int size()
             instrJson.put("text", Helper.firstBig(str));
             if (!ia.isEmpty())
             {
-                instrJson.put("annotationText", ia.getMessage());
-                instrJson.put("annotationImportance", ia.getImportance());
+                instrJson.put("annotation_text", ia.getMessage());
+                instrJson.put("annotation_importance", ia.getImportance());
             }
 
             instrJson.put("time", instruction.getTime());
             instrJson.put("distance", Helper.round(instruction.getDistance(), 3));
             instrJson.put("sign", instruction.getSign());
+            instrJson.putAll(instruction.getExtraInfoJSON());
 
             int tmpIndex = pointsIndex + instruction.getPoints().size();
             // the last instruction should not point to the next instruction
@@ -165,7 +132,7 @@ public String toString()
     /**
      * @return This method returns a list of gpx entries where the time (in millis) is relative to
      * the first which is 0.
-     * <p>
+     * <p/>
      */
     public List<GPXEntry> createGPXList()
     {
@@ -200,98 +167,90 @@ public String toString()
      */
     public String createGPX()
     {
-        return createGPX("GraphHopper", 0, "GMT");
+        return createGPX("GraphHopper", new Date().getTime());
     }
 
-    public String createGPX( String trackName, long startTimeMillis, String timeZoneId )
+    public String createGPX( String trackName, long startTimeMillis )
     {
         boolean includeElevation = getSize() > 0 ? get(0).getPoints().is3D() : false;
-        return createGPX(trackName, startTimeMillis, timeZoneId, includeElevation);
+        return createGPX(trackName, startTimeMillis, includeElevation);
     }
 
-    public String createGPX( String trackName, long startTimeMillis, String timeZoneId, boolean includeElevation )
+    public String createGPX( String trackName, long startTimeMillis, boolean includeElevation )
     {
-        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
-        TimeZone tz = TimeZone.getDefault();
-        if (!Helper.isEmpty(timeZoneId))
-            tz = TimeZone.getTimeZone(timeZoneId);
+        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
+        formatter.setTimeZone(TimeZone.getTimeZone("UTC"));
 
-        formatter.setTimeZone(tz);
         String header = "<?xml version='1.0' encoding='UTF-8' standalone='no' ?>"
                 + "<gpx xmlns='http://www.topografix.com/GPX/1/1' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'"
-                + " xsi:schemaLocation='https://graphhopper.com/public/schema https://graphhopper.com/public/schema/gpx-1.1.xsd'"
-                + " creator='Graphhopper' version='1.1'>"
-                + "<metadata>"
+                + " creator='Graphhopper' version='1.1'"
+                // This xmlns:gh acts only as ID, no valid URL necessary.
+                // Use a separate namespace for custom extensions to make basecamp happy.
+                + " xmlns:gh='https://graphhopper.com/public/schema/gpx/1.1'>"
+                + "\n<metadata>"
+                + "<copyright author=\"OpenStreetMap contributors\"/>"
                 + "<link href='http://graphhopper.com'>"
                 + "<text>GraphHopper GPX</text>"
                 + "</link>"
-                + "<time>" + tzHack(formatter.format(startTimeMillis)) + "</time>"
+                + "<time>" + formatter.format(startTimeMillis) + "</time>"
                 + "</metadata>";
         StringBuilder track = new StringBuilder(header);
         if (!isEmpty())
         {
-            track.append("<rte>");
-            Instruction nextI = null;
-            for (Instruction instr : instructions)
+            track.append("\n<rte>");
+            Instruction nextInstr = null;
+            for (Instruction currInstr : instructions)
             {
-                if (null != nextI)
-                    createRteptBlock(track, nextI, instr);
+                if (null != nextInstr)
+                    createRteptBlock(track, nextInstr, currInstr);
 
-                nextI = instr;
+                nextInstr = currInstr;
             }
-            createRteptBlock(track, nextI, null);
+            createRteptBlock(track, nextInstr, null);
             track.append("</rte>");
         }
 
-        track.append("<trk><name>").append(trackName).append("</name>");
+        track.append("\n<trk><name>").append(trackName).append("</name>");
 
         track.append("<trkseg>");
         for (GPXEntry entry : createGPXList())
         {
             track.append("\n<trkpt lat='").append(Helper.round6(entry.getLat()));
             track.append("' lon='").append(Helper.round6(entry.getLon())).append("'>");
-            track.append("<time>").append(tzHack(formatter.format(startTimeMillis + entry.getMillis()))).append("</time>");
             if (includeElevation)
                 track.append("<ele>").append(Helper.round2(entry.getEle())).append("</ele>");
-
+            track.append("<time>").append(formatter.format(startTimeMillis + entry.getTime())).append("</time>");
             track.append("</trkpt>");
         }
         track.append("</trkseg>");
         track.append("</trk>");
 
-        // TODO #147 use wpt for via points!
+        // we could now use 'wpt' for via points
         track.append("</gpx>");
         return track.toString().replaceAll("\\'", "\"");
     }
 
-    /**
-     * Hack to form valid timezone ala +01:00 instead +0100
-     */
-    private static String tzHack( String str )
-    {
-        return str.substring(0, str.length() - 2) + ":" + str.substring(str.length() - 2);
-    }
-
     private void createRteptBlock( StringBuilder output, Instruction instruction, Instruction nextI )
     {
-        output.append("<rtept lat=\"").append(Helper.round6(instruction.getFirstLat())).
+        output.append("\n<rtept lat=\"").append(Helper.round6(instruction.getFirstLat())).
                 append("\" lon=\"").append(Helper.round6(instruction.getFirstLon())).append("\">");
 
         if (!instruction.getName().isEmpty())
             output.append("<desc>").append(instruction.getTurnDescription(tr)).append("</desc>");
 
         output.append("<extensions>");
-        output.append("<distance>").append(Helper.round(instruction.getDistance(), 3)).append("</distance>");
-        output.append("<time>").append(instruction.getTime()).append("</time>");
+        output.append("<gh:distance>").append(Helper.round(instruction.getDistance(), 1)).append("</gh:distance>");
+        output.append("<gh:time>").append(instruction.getTime()).append("</gh:time>");
 
-        String direction = instruction.getDirection(nextI);
-        if (direction != null)
-            output.append("<direction>").append(direction).append("</direction>");
+        String direction = instruction.calcDirection(nextI);
+        if (!direction.isEmpty())
+            output.append("<gh:direction>").append(direction).append("</gh:direction>");
 
-        String azimuth = instruction.getAzimuth(nextI);
-        if (azimuth != null)
-            output.append("<azimuth>").append(azimuth).append("</azimuth>");
+        double azimuth = instruction.calcAzimuth(nextI);
+        if (!Double.isNaN(azimuth))
+            output.append("<gh:azimuth>").append(Helper.round2(azimuth)).append("</gh:azimuth>");
 
+        output.append("<gh:sign>").append(instruction.getSign()).append("</gh:sign>");
         output.append("</extensions>");
         output.append("</rtept>");
     }
@@ -308,4 +267,76 @@ private void createRteptBlock( StringBuilder output, Instruction instruction, In
         }
         return res;
     }
+
+    /**
+     * This method is useful for navigation devices to find the next instruction for the specified
+     * coordinate (e.g. the current position).
+     * <p/>
+     * @param maxDistance the maximum acceptable distance to the instruction (in meter)
+     * @return the next Instruction or null if too far away.
+     */
+    public Instruction find( double lat, double lon, double maxDistance )
+    {
+        // handle special cases
+        if (getSize() == 0)
+        {
+            return null;
+        }
+        PointList points = get(0).getPoints();
+        double prevLat = points.getLatitude(0);
+        double prevLon = points.getLongitude(0);
+        DistanceCalc distCalc = Helper.DIST_EARTH;
+        double foundMinDistance = distCalc.calcNormalizedDist(lat, lon, prevLat, prevLon);
+        int foundInstruction = 0;
+
+        // Search the closest edge to the query point
+        if (getSize() > 1)
+        {
+            for (int instructionIndex = 0; instructionIndex < getSize(); instructionIndex++)
+            {
+                points = get(instructionIndex).getPoints();
+                for (int pointIndex = 0; pointIndex < points.size(); pointIndex++)
+                {
+                    double currLat = points.getLatitude(pointIndex);
+                    double currLon = points.getLongitude(pointIndex);
+
+                    if (!(instructionIndex == 0 && pointIndex == 0))
+                    {
+                        // calculate the distance from the point to the edge
+                        double distance;
+                        int index = instructionIndex;
+                        if (distCalc.validEdgeDistance(lat, lon, currLat, currLon, prevLat, prevLon))
+                        {
+                            distance = distCalc.calcNormalizedEdgeDistance(lat, lon, currLat, currLon, prevLat, prevLon);
+                            if (pointIndex > 0)
+                                index++;
+                        } else
+                        {
+                            distance = distCalc.calcNormalizedDist(lat, lon, currLat, currLon);
+                            if (pointIndex > 0)
+                                index++;
+                        }
+
+                        if (distance < foundMinDistance)
+                        {
+                            foundMinDistance = distance;
+                            foundInstruction = index;
+                        }
+                    }
+                    prevLat = currLat;
+                    prevLon = currLon;
+                }
+            }
+        }
+
+        if (distCalc.calcDenormalizedDist(foundMinDistance) > maxDistance)
+            return null;
+
+        // special case finish condition
+        if (foundInstruction == getSize())
+            foundInstruction--;
+
+        return get(foundInstruction);
+    }
+
 }
diff --git a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
index 24cb8cd371..132c98c109 100644
--- a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
+++ b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.util;
 
 import java.text.DecimalFormat;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -63,25 +64,33 @@ public MiniPerfTest setIterations( int counts )
         return this;
     }
 
-    // in ms
+    /**
+     * @return minimum time of every call, in ms
+     */
     public double getMin()
     {
         return min / 1e6;
     }
 
-    // in ms
+    /**
+     * @return maximum time of every calls, in ms
+     */
     public double getMax()
     {
         return max / 1e6;
     }
 
-    // in ms
+    /**
+     * @return time for all calls accumulated, in ms
+     */
     public double getSum()
     {
         return fullTime / 1e6;
     }
 
-    // in ms
+    /**
+     * @return mean time per call, in ms
+     */
     public double getMean()
     {
         return getSum() / counts;
diff --git a/core/src/main/java/com/graphhopper/util/PMap.java b/core/src/main/java/com/graphhopper/util/PMap.java
index 4e3e493706..badbb59dd2 100644
--- a/core/src/main/java/com/graphhopper/util/PMap.java
+++ b/core/src/main/java/com/graphhopper/util/PMap.java
@@ -22,7 +22,7 @@
 
 /**
  * A properties map with convenient accessors
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class PMap
@@ -44,6 +44,22 @@ public PMap( Map<String, String> map )
         this.map = map;
     }
 
+    public PMap( String propertiesString )
+    {
+        // five chosen as arbitrary initial capacity
+        this.map = new HashMap<String, String>(5);
+
+        for (String s : propertiesString.split("\\|"))
+        {
+            s = s.trim();
+            int index = s.indexOf("=");
+            if (index < 0)
+                continue;
+
+            this.map.put(s.substring(0, index).toLowerCase(), s.substring(index + 1));
+        }
+    }
+
     public PMap put( String key, Object str )
     {
         if (str == null)
@@ -143,6 +159,14 @@ String get( String key )
         return val;
     }
 
+    /**
+     * This method copies the underlying structur into a new Map object
+     */
+    public Map<String, String> toMap()
+    {
+        return new HashMap<String, String>(map);
+    }
+
     private Map<String, String> getMap()
     {
         return map;
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 5141534f13..a33097d65b 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -20,26 +20,27 @@
 
 import com.graphhopper.GHResponse;
 import com.graphhopper.routing.Path;
+
 import java.util.List;
 
 /**
  * This class merges a list of points into one point recognizing the specified places.
- * <p>
+ * <p/>
  * @author Peter Karich
  * @author ratrun
  */
 public class PathMerger
 {
     private boolean enableInstructions = true;
-    private boolean simplifyResponse = false;
+    private boolean simplifyResponse = true;
     private DouglasPeucker douglasPeucker;
-    private boolean calcPoints;
+    private boolean calcPoints = true;
 
     public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
     {
         int origPoints = 0;
         StopWatch sw;
-        long fullMillis = 0;
+        long fullTimeInMillis = 0;
         double fullWeight = 0;
         double fullDistance = 0;
         boolean allFound = true;
@@ -49,7 +50,7 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
         for (int pathIndex = 0; pathIndex < paths.size(); pathIndex++)
         {
             Path path = paths.get(pathIndex);
-            fullMillis += path.getMillis();
+            fullTimeInMillis += path.getTime();
             fullDistance += path.getDistance();
             fullWeight += path.getWeight();
             if (enableInstructions)
@@ -60,7 +61,11 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
                 if (!il.isEmpty())
                 {
                     if (fullPoints.isEmpty())
-                        fullPoints = createSimilarPL(il.get(0).getPoints());
+                    {
+                        PointList pl = il.get(0).getPoints();
+                        // do a wild guess about the total number of points to avoid reallocation a bit
+                        fullPoints = new PointList(il.size() * Math.min(10, pl.size()), pl.is3D());
+                    }
 
                     for (Instruction i : il)
                     {
@@ -77,8 +82,9 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
                     // if not yet reached finish replace with 'reached via'
                     if (pathIndex + 1 < paths.size())
                     {
-                        FinishInstruction fi = (FinishInstruction) fullInstructions.get(fullInstructions.size() - 1);
-                        fi.setVia(pathIndex + 1);
+                        ViaInstruction newInstr = new ViaInstruction(fullInstructions.get(fullInstructions.size() - 1));
+                        newInstr.setViaCount(pathIndex + 1);
+                        fullInstructions.replaceLast(newInstr);
                     }
                 }
 
@@ -86,7 +92,7 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
             {
                 PointList tmpPoints = path.calcPoints();
                 if (fullPoints.isEmpty())
-                    fullPoints = createSimilarPL(tmpPoints);
+                    fullPoints = new PointList(tmpPoints.size(), tmpPoints.is3D());
 
                 if (simplifyResponse)
                 {
@@ -110,16 +116,14 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
         if (enableInstructions)
             rsp.setInstructions(fullInstructions);
 
-        rsp.setFound(allFound).
-                setPoints(fullPoints).
-                setRouteWeight(fullWeight).
-                setDistance(fullDistance).
-                setMillis(fullMillis);
-    }
+        if (!allFound)
+        {
+            rsp.addError(new RuntimeException("Not found"));
+        }
 
-    PointList createSimilarPL( PointList pl )
-    {
-        return new PointList(pl.size(), pl.is3D());
+        rsp.setPoints(fullPoints).
+                setRouteWeight(fullWeight).
+                setDistance(fullDistance).setTime(fullTimeInMillis);
     }
 
     public PathMerger setCalcPoints( boolean calcPoints )
diff --git a/core/src/main/java/com/graphhopper/util/PointAccess.java b/core/src/main/java/com/graphhopper/util/PointAccess.java
index e8a395192d..ee93ad219b 100644
--- a/core/src/main/java/com/graphhopper/util/PointAccess.java
+++ b/core/src/main/java/com/graphhopper/util/PointAccess.java
@@ -23,7 +23,6 @@
  */
 public interface PointAccess
 {
-
     /**
      * @return true if elevation data is stored and can be retrieved
      */
@@ -34,10 +33,16 @@
      */
     int getDimension();
 
+    /**
+     * This method ensures that the node with the specified index exists i.e. allocates space for
+     * it.
+     */
+    void ensureNode( int nodeId );
+
     /**
      * This method ensures that the node with the specified index exists and prepares access to it.
      * The index goes from 0 (inclusive) to graph.getNodes() (exclusive)
-     * <p>
+     * <p/>
      * This methods sets the latitude, longitude and elevation to the specified value.
      */
     void setNode( int nodeId, double lat, double lon );
@@ -45,7 +50,7 @@
     /**
      * This method ensures that the node with the specified index exists and prepares access to it.
      * The index goes from 0 (inclusive) to graph.getNodes() (exclusive)
-     * <p>
+     * <p/>
      * This methods sets the latitude, longitude and elevation to the specified value.
      */
     void setNode( int nodeId, double lat, double lon, double ele );
diff --git a/core/src/main/java/com/graphhopper/util/PointList.java b/core/src/main/java/com/graphhopper/util/PointList.java
index bea0842850..6cca560fee 100644
--- a/core/src/main/java/com/graphhopper/util/PointList.java
+++ b/core/src/main/java/com/graphhopper/util/PointList.java
@@ -20,8 +20,10 @@
 
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.GHPoint3D;
+
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Iterator;
 import java.util.List;
 
 /**
@@ -29,9 +31,9 @@
  * <p/>
  * @author Peter Karich
  */
-public class PointList implements PointAccess
+public class PointList implements Iterable<GHPoint3D>, PointAccess
 {
-    private final static DistanceCalc3D distCalc3D = new DistanceCalc3D();
+    private final static DistanceCalc3D distCalc3D = Helper.DIST_3D;
     private static String ERR_MSG = "Tried to access PointList with too big index!";
     private double[] latitudes;
     private double[] longitudes;
@@ -67,6 +69,12 @@ public int getDimension()
         return 2;
     }
 
+    @Override
+    public void ensureNode( int nodeId )
+    {
+        incCap(nodeId + 1);
+    }
+
     @Override
     public void setNode( int nodeId, double lat, double lon )
     {
@@ -94,7 +102,7 @@ else if (!Double.isNaN(ele))
 
     private void incCap( int newSize )
     {
-        if (newSize < latitudes.length)
+        if (newSize <= latitudes.length)
             return;
 
         int cap = newSize * 2;
@@ -296,14 +304,15 @@ public String toString()
         {
             if (includeElevation)
                 points.add(new Double[]
-                {
-                    Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i)), Helper.round2(getElevation(i))
-                });
+                        {
+                                Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i)),
+                                Helper.round2(getElevation(i))
+                        });
             else
                 points.add(new Double[]
-                {
-                    Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i))
-                });
+                        {
+                                Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i))
+                        });
         }
         return points;
     }
@@ -567,4 +576,33 @@ int getCapacity()
     {
         return latitudes.length;
     }
+
+    @Override
+    public Iterator<GHPoint3D> iterator()
+    {
+        return new Iterator<GHPoint3D>()
+        {
+            int counter = 0;
+
+            @Override
+            public boolean hasNext()
+            {
+                return counter < PointList.this.getSize();
+            }
+
+            @Override
+            public GHPoint3D next()
+            {
+                GHPoint3D point = PointList.this.toGHPoint(counter);
+                counter++;
+                return point;
+            }
+
+            @Override
+            public void remove()
+            {
+                throw new UnsupportedOperationException("Not supported.");
+            }
+        };
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
new file mode 100644
index 0000000000..185d7b480b
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
@@ -0,0 +1,133 @@
+package com.graphhopper.util;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * @author jansoe
+ */
+public class RoundaboutInstruction extends Instruction
+{
+    private int exitNumber = 0;
+    // 0 undetermined, 1 clockwise, -1 counterclockwise, 2 inconsistent
+    private int clockwise = 0;
+    private boolean exited = false;
+    private double radian = Double.NaN;
+
+    public RoundaboutInstruction( int sign, String name, InstructionAnnotation ia, PointList pl )
+    {
+        super(sign, name, ia, pl);
+    }
+
+    public RoundaboutInstruction increaseExitNumber()
+    {
+        this.exitNumber += 1;
+        return this;
+    }
+
+    public RoundaboutInstruction setExitNumber( int exitNumber )
+    {
+        this.exitNumber = exitNumber;
+        return this;
+    }
+
+    public RoundaboutInstruction setDirOfRotation( double deltaIn )
+    {
+        if (clockwise == 0)
+        {
+            clockwise = deltaIn > 0 ? 1 : -1;
+        } else
+        {
+            int clockwise2 = deltaIn > 0 ? 1 : -1;
+            if (clockwise != clockwise2)
+            {
+                clockwise = 2;
+            }
+        }
+        return this;
+    }
+
+    public RoundaboutInstruction setExited()
+    {
+        exited = true;
+        return this;
+    }
+
+    public boolean isExited()
+    {
+        return exited;
+    }
+
+    public int getExitNumber()
+    {
+        if (exited && exitNumber == 0)
+        {
+            throw new IllegalStateException("RoundaboutInstruction must contain exitNumber>0");
+        }
+        return exitNumber;
+    }
+
+    /**
+     * @return radian of angle -2PI < x < 2PI between roundabout entrance and exit
+     * values > 0 are clockwise rotation, <0 counterclockwise, NaN if direction of rotation unclear
+     */
+    public double getRadian()
+    {
+        if (Math.abs(clockwise) != 1)
+        {
+            return Double.NaN;
+        } else
+        {
+            double tmpRadian = Math.PI - clockwise * radian;
+            tmpRadian *= clockwise;
+            return tmpRadian;
+        }
+    }
+
+    public RoundaboutInstruction setRadian( double radian )
+    {
+        this.radian = radian;
+        return this;
+    }
+
+    @Override
+    public Map<String, Object> getExtraInfoJSON()
+    {
+        Map<String, Object> tmpMap = new HashMap<String, Object>(2);
+        tmpMap.put("exit_number", getExitNumber());
+        double radian = getRadian();
+        if (!Double.isNaN(radian))
+        {
+            tmpMap.put("turn_angle", Helper.round(radian, 2));
+        }
+
+        return tmpMap;
+
+    }
+
+    @Override
+    public String getTurnDescription( Translation tr )
+    {
+        if (rawName)
+            return getName();
+
+        String str;
+        String streetName = getName();
+        int indi = getSign();
+        if (indi == Instruction.USE_ROUNDABOUT)
+        {
+            if (!exited)
+            {
+                str = tr.tr("roundaboutEnter");
+            } else
+            {
+                str = Helper.isEmpty(streetName) ? tr.tr("roundaboutExit", getExitNumber())
+                        : tr.tr("roundaboutExitOnto", getExitNumber(), streetName);
+            }
+        } else
+        {
+            throw new IllegalStateException(indi + "no Roundabout indication");
+        }
+        return str;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index f1e420ef32..d4478781c0 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -22,18 +22,18 @@
 import java.util.Map.Entry;
 
 /**
- * A class which manages the translations in-memory. Translations are managed here:
- * https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0
+ * A class which manages the translations in-memory. See here for more information:
+ * ./docs/core/translations.md
  * <p/>
- * See here for more information: ./docs/core/translations.md
- * <p>
  * @author Peter Karich
  */
 public class TranslationMap
 {
     // ISO codes (639-1), use 'en_US' as reference
-    private static final List<String> LOCALES = Arrays.asList("bg", "ca", "de_DE", "el", "en_US", "es", "fil",
-            "fr", "gl", "he", "it", "ja", "nl", "pt_BR", "pt_PT", "ro", "ru", "si", "sk", "sv_SE", "tr", "uk");
+    private static final List<String> LOCALES = Arrays.asList("ar", "bg", "ca", "cs_CZ", "de_DE", "el",
+            "en_US", "es", "fa", "fil", "fi", "fr", "gl", "he", "hsb", "hu_HU", "it", "ja",
+            "lt_LT", "ne", "nl", "pl_PL", "pt_BR", "pt_PT", "ro", "ru", "si", "sk",
+            "sv_SE", "tr", "uk", "vi_VI", "zh_CN");
     private final Map<String, Translation> translations = new HashMap<String, Translation>();
 
     /**
@@ -153,8 +153,23 @@ private void postImportHook()
                 int expectedCount = countOccurence(enEntry.getValue(), "\\%");
                 if (expectedCount != countOccurence(value, "\\%"))
                 {
-                    sb.append(tr.getLocale()).append(" - error in ").append(enEntry.getKey()).append("->").
+                    sb.append(tr.getLocale()).append(" - error in ").
+                            append(enEntry.getKey()).append("->").
                             append(value).append("\n");
+                } else
+                {
+                    // try if formatting works, many times e.g. '%1$' instead of '%1$s'
+                    Object[] strs = new String[expectedCount];
+                    Arrays.fill(strs, "tmp");
+                    try
+                    {
+                        String.format(value, strs);
+                    } catch (Exception ex)
+                    {
+                        sb.append(tr.getLocale()).append(" - error ").append(ex.getMessage()).append("in ").
+                                append(enEntry.getKey()).append("->").
+                                append(value).append("\n");
+                    }
                 }
             }
         }
diff --git a/core/src/main/java/com/graphhopper/util/Unzipper.java b/core/src/main/java/com/graphhopper/util/Unzipper.java
index bcb4fee96e..5a68816e8d 100644
--- a/core/src/main/java/com/graphhopper/util/Unzipper.java
+++ b/core/src/main/java/com/graphhopper/util/Unzipper.java
@@ -26,14 +26,6 @@
  */
 public class Unzipper
 {
-    private int size = 1024 * 8;
-
-    public Unzipper setSize( int size )
-    {
-        this.size = size;
-        return this;
-    }
-
     public void unzip( String from, boolean remove ) throws IOException
     {
         String to = Helper.pruneFileEnd(from);
@@ -66,7 +58,7 @@ public void unzip( InputStream fromIs, File toFolder, ProgressListener progressL
         try
         {
             ZipEntry ze = zis.getNextEntry();
-            byte[] buffer = new byte[size];
+            byte[] buffer = new byte[8 * 1024];
             while (ze != null)
             {
                 if (ze.isDirectory())
diff --git a/core/src/main/java/com/graphhopper/util/ViaInstruction.java b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
new file mode 100644
index 0000000000..070aaed5a8
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2015 Peter Karich.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.util;
+
+/**
+ * @author Peter Karich
+ */
+public class ViaInstruction extends Instruction
+{
+    private int viaPosition = -1;
+
+    public ViaInstruction( String name, InstructionAnnotation ia, PointList pl )
+    {
+        super(REACHED_VIA, name, ia, pl);
+    }
+
+    public ViaInstruction( Instruction instr )
+    {
+        this(instr.getName(), instr.getAnnotation(), instr.getPoints());
+        setDistance(instr.getDistance());
+        setTime(instr.getTime());
+    }
+
+    public void setViaCount( int count )
+    {
+        this.viaPosition = count;
+    }
+
+    public int getViaCount()
+    {
+        if (viaPosition < 0)
+            throw new IllegalStateException("Uninitialized via count in instruction " + getName());
+
+        return viaPosition;
+    }
+
+    @Override
+    public String getTurnDescription( Translation tr )
+    {
+        if (rawName)
+            return getName();
+
+        return tr.tr("stopover", viaPosition);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/XFirstSearch.java b/core/src/main/java/com/graphhopper/util/XFirstSearch.java
index e049426257..31b56569a7 100644
--- a/core/src/main/java/com/graphhopper/util/XFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/XFirstSearch.java
@@ -27,12 +27,12 @@
  */
 public abstract class XFirstSearch
 {
-        protected GHBitSet createBitSet()
+    protected GHBitSet createBitSet()
     {
         return new GHBitSetImpl();
     }
 
-    public abstract void start( EdgeExplorer explorer, int startNode);
+    public abstract void start( EdgeExplorer explorer, int startNode );
 
     protected boolean goFurther( int nodeId )
     {
diff --git a/core/src/main/java/com/graphhopper/util/shapes/BBox.java b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
index 09e46810ca..9b6eb95f22 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.NumHelper;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -34,20 +35,7 @@
  */
 public class BBox implements Shape, Cloneable
 {
-    /**
-     * A bounding box which prefills the values with minimum values so that it can increase.
-     */
-    public static final BBox INVERSE = new BBox();
 
-    static
-    {
-        INVERSE.minLon = Double.MAX_VALUE;
-        INVERSE.maxLon = -Double.MAX_VALUE;
-        INVERSE.minLat = Double.MAX_VALUE;
-        INVERSE.maxLat = -Double.MAX_VALUE;
-        INVERSE.minEle = Double.MAX_VALUE;
-        INVERSE.maxEle = -Double.MAX_VALUE;
-    }
     // longitude (theta) = x, latitude (phi) = y, elevation = z
     public double minLon;
     public double maxLon;
@@ -55,17 +43,7 @@
     public double maxLat;
     public double minEle;
     public double maxEle;
-    private final boolean is3D;
-
-    private BBox()
-    {
-        this.is3D = false;
-    }
-
-    private BBox( boolean is3D )
-    {
-        this.is3D = is3D;
-    }
+    private final boolean elevation;
 
     public BBox( double minLon, double maxLon, double minLat, double maxLat )
     {
@@ -77,9 +55,9 @@ public BBox( double minLon, double maxLon, double minLat, double maxLat, double
         this(minLon, maxLon, minLat, maxLat, minEle, maxEle, true);
     }
 
-    public BBox( double minLon, double maxLon, double minLat, double maxLat, double minEle, double maxEle, boolean is3D )
+    public BBox( double minLon, double maxLon, double minLat, double maxLat, double minEle, double maxEle, boolean elevation )
     {
-        this.is3D = is3D;
+        this.elevation = elevation;
         this.maxLat = maxLat;
         this.minLon = minLon;
         this.minLat = minLat;
@@ -88,28 +66,73 @@ public BBox( double minLon, double maxLon, double minLat, double maxLat, double
         this.maxEle = maxEle;
     }
 
-    public boolean check()
+    public boolean hasElevation()
     {
-        // second longitude should be bigger than the first
-        if (minLon >= maxLon)
-            return false;
+        return elevation;
+    }
 
-        // second latitude should be smaller than the first
-        if (minLat >= maxLat)
-            return false;
+    /**
+     * Prefills BBox with minimum values so that it can increase.
+     */
+    public static BBox createInverse( boolean elevation )
+    {
+        if (elevation)
+        {
+            return new BBox(Double.MAX_VALUE, -Double.MAX_VALUE, Double.MAX_VALUE, -Double.MAX_VALUE,
+                    Double.MAX_VALUE, -Double.MAX_VALUE, true);
+        } else
+        {
+            return new BBox(Double.MAX_VALUE, -Double.MAX_VALUE, Double.MAX_VALUE, -Double.MAX_VALUE,
+                    Double.NaN, Double.NaN, false);
+        }
+    }
 
-        // second elevation should be smaller than the first
-        if (is3D && minEle >= maxEle)
-            return false;
+    public void update( double lat, double lon )
+    {
+        if (lat > maxLat)
+        {
+            maxLat = lat;
+        }
 
-        return true;
+        if (lat < minLat)
+        {
+            minLat = lat;
+        }
+
+        if (lon > maxLon)
+        {
+            maxLon = lon;
+        }
+        if (lon < minLon)
+        {
+            minLon = lon;
+        }
+    }
+
+    public void update( double lat, double lon, double elev )
+    {
+        if (elevation)
+        {
+            if (elev > maxEle)
+            {
+                maxEle = elev;
+            }
+            if (elev < minEle)
+            {
+                minEle = elev;
+            }
+        } else
+        {
+            throw new IllegalStateException("No BBox with elevation to update");
+        }
+        update(lat, lon);
 
     }
 
     @Override
     public BBox clone()
     {
-        return new BBox(minLon, maxLon, minLat, maxLat, minEle, maxEle, is3D);
+        return new BBox(minLon, maxLon, minLat, maxLat, minEle, maxEle, elevation);
     }
 
     @Override
@@ -172,7 +195,7 @@ public boolean contains( Circle c )
     public String toString()
     {
         String str = minLon + "," + maxLon + "," + minLat + "," + maxLat;
-        if (is3D)
+        if (elevation)
             str += "," + minEle + "," + maxEle;
 
         return str;
@@ -214,10 +237,29 @@ public int hashCode()
 
     public boolean isValid()
     {
-        return Double.doubleToLongBits(maxLat) != Double.doubleToLongBits(INVERSE.maxLat)
-                && Double.doubleToLongBits(minLat) != Double.doubleToLongBits(INVERSE.minLat)
-                && Double.doubleToLongBits(maxLon) != Double.doubleToLongBits(INVERSE.maxLon)
-                && Double.doubleToLongBits(minLon) != Double.doubleToLongBits(INVERSE.minLon);
+        // second longitude should be bigger than the first
+        if (minLon >= maxLon)
+            return false;
+
+        // second latitude should be smaller than the first
+        if (minLat >= maxLat)
+            return false;
+
+        if (elevation)
+        {
+            // equal elevation is okay
+            if (minEle > maxEle)
+                return false;
+
+            if (Double.compare(maxEle, -Double.MAX_VALUE) == 0
+                    || Double.compare(minEle, Double.MAX_VALUE) == 0)
+                return false;
+        }
+
+        return Double.compare(maxLat, -Double.MAX_VALUE) != 0
+                && Double.compare(minLat, Double.MAX_VALUE) != 0
+                && Double.compare(maxLon, -Double.MAX_VALUE) != 0
+                && Double.compare(minLon, Double.MAX_VALUE) != 0;
     }
 
     /**
@@ -230,12 +272,12 @@ public boolean isValid()
         list.add(Helper.round6(minLon));
         list.add(Helper.round6(minLat));
         // hmh
-        if (is3D)
+        if (elevation)
             list.add(Helper.round2(minEle));
 
         list.add(Helper.round6(maxLon));
         list.add(Helper.round6(maxLat));
-        if (is3D)
+        if (elevation)
             list.add(Helper.round2(maxEle));
 
         return list;
diff --git a/core/src/main/java/com/graphhopper/util/shapes/Circle.java b/core/src/main/java/com/graphhopper/util/shapes/Circle.java
index 2ff252007a..0eee29724e 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/Circle.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/Circle.java
@@ -18,15 +18,14 @@
 package com.graphhopper.util.shapes;
 
 import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.Helper;
 
 /**
  * @author Peter Karich
  */
 public class Circle implements Shape
 {
-    private final static DistanceCalc SINGLETON = new DistanceCalcEarth();
-    private DistanceCalc calc = SINGLETON;
+    private DistanceCalc calc = Helper.DIST_EARTH;
     private final double radiusInKm;
     private final double lat;
     private final double lon;
@@ -35,7 +34,7 @@
 
     public Circle( double lat, double lon, double radiusInMeter )
     {
-        this(lat, lon, radiusInMeter, SINGLETON);
+        this(lat, lon, radiusInMeter, Helper.DIST_EARTH);
     }
 
     public Circle( double lat, double lon, double radiusInMeter, DistanceCalc calc )
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
index 5ca18aa337..277a552a77 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
@@ -84,9 +84,9 @@ public String toString()
     public Double[] toGeoJson()
     {
         return new Double[]
-        {
-            lon, lat
-        };
+                {
+                        lon, lat
+                };
     }
 
     public static GHPoint parse( String str )
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java b/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
index cab721686c..6db1d59c78 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
@@ -77,8 +77,8 @@ public String toString()
     public Double[] toGeoJson()
     {
         return new Double[]
-        {
-            lon, lat, ele
-        };
+                {
+                        lon, lat, ele
+                };
     }
 }
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/Africa_names.txt b/core/src/main/resources/com/graphhopper/reader/dem/Africa_names.txt
new file mode 100644
index 0000000000..cc340c9692
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/reader/dem/Africa_names.txt
@@ -0,0 +1,3250 @@
+N00E006.hgt.zip
+N00E009.hgt.zip
+N00E010.hgt.zip
+N00E011.hgt.zip
+N00E012.hgt.zip
+N00E013.hgt.zip
+N00E014.hgt.zip
+N00E015.hgt.zip
+N00E016.hgt.zip
+N00E017.hgt.zip
+N00E018.hgt.zip
+N00E019.hgt.zip
+N00E020.hgt.zip
+N00E021.hgt.zip
+N00E022.hgt.zip
+N00E023.hgt.zip
+N00E024.hgt.zip
+N00E025.hgt.zip
+N00E026.hgt.zip
+N00E027.hgt.zip
+N00E028.hgt.zip
+N00E029.hgt.zip
+N00E030.hgt.zip
+N00E031.hgt.zip
+N00E032.hgt.zip
+N00E033.hgt.zip
+N00E034.hgt.zip
+N00E035.hgt.zip
+N00E036.hgt.zip
+N00E037.hgt.zip
+N00E038.hgt.zip
+N00E039.hgt.zip
+N00E040.hgt.zip
+N00E041.hgt.zip
+N00E042.hgt.zip
+N00E043.hgt.zip
+N01E007.hgt.zip
+N01E009.hgt.zip
+N01E010.hgt.zip
+N01E011.hgt.zip
+N01E012.hgt.zip
+N01E013.hgt.zip
+N01E014.hgt.zip
+N01E015.hgt.zip
+N01E016.hgt.zip
+N01E017.hgt.zip
+N01E018.hgt.zip
+N01E019.hgt.zip
+N01E020.hgt.zip
+N01E021.hgt.zip
+N01E022.hgt.zip
+N01E023.hgt.zip
+N01E024.hgt.zip
+N01E025.hgt.zip
+N01E026.hgt.zip
+N01E027.hgt.zip
+N01E028.hgt.zip
+N01E029.hgt.zip
+N01E030.hgt.zip
+N01E031.hgt.zip
+N01E032.hgt.zip
+N01E033.hgt.zip
+N01E034.hgt.zip
+N01E035.hgt.zip
+N01E036.hgt.zip
+N01E037.hgt.zip
+N01E038.hgt.zip
+N01E039.hgt.zip
+N01E040.hgt.zip
+N01E041.hgt.zip
+N01E042.hgt.zip
+N01E043.hgt.zip
+N01E044.hgt.zip
+N01E045.hgt.zip
+N02E009.hgt.zip
+N02E010.hgt.zip
+N02E011.hgt.zip
+N02E012.hgt.zip
+N02E013.hgt.zip
+N02E014.hgt.zip
+N02E015.hgt.zip
+N02E016.hgt.zip
+N02E017.hgt.zip
+N02E018.hgt.zip
+N02E019.hgt.zip
+N02E020.hgt.zip
+N02E021.hgt.zip
+N02E022.hgt.zip
+N02E023.hgt.zip
+N02E024.hgt.zip
+N02E025.hgt.zip
+N02E026.hgt.zip
+N02E027.hgt.zip
+N02E028.hgt.zip
+N02E029.hgt.zip
+N02E030.hgt.zip
+N02E031.hgt.zip
+N02E032.hgt.zip
+N02E033.hgt.zip
+N02E034.hgt.zip
+N02E035.hgt.zip
+N02E036.hgt.zip
+N02E037.hgt.zip
+N02E038.hgt.zip
+N02E039.hgt.zip
+N02E040.hgt.zip
+N02E041.hgt.zip
+N02E042.hgt.zip
+N02E043.hgt.zip
+N02E044.hgt.zip
+N02E045.hgt.zip
+N02E046.hgt.zip
+N03E008.hgt.zip
+N03E009.hgt.zip
+N03E010.hgt.zip
+N03E011.hgt.zip
+N03E012.hgt.zip
+N03E013.hgt.zip
+N03E014.hgt.zip
+N03E015.hgt.zip
+N03E016.hgt.zip
+N03E017.hgt.zip
+N03E018.hgt.zip
+N03E019.hgt.zip
+N03E020.hgt.zip
+N03E021.hgt.zip
+N03E022.hgt.zip
+N03E023.hgt.zip
+N03E024.hgt.zip
+N03E025.hgt.zip
+N03E026.hgt.zip
+N03E027.hgt.zip
+N03E028.hgt.zip
+N03E029.hgt.zip
+N03E030.hgt.zip
+N03E031.hgt.zip
+N03E032.hgt.zip
+N03E033.hgt.zip
+N03E034.hgt.zip
+N03E035.hgt.zip
+N03E036.hgt.zip
+N03E037.hgt.zip
+N03E038.hgt.zip
+N03E039.hgt.zip
+N03E040.hgt.zip
+N03E041.hgt.zip
+N03E042.hgt.zip
+N03E043.hgt.zip
+N03E044.hgt.zip
+N03E045.hgt.zip
+N03E046.hgt.zip
+N03E047.hgt.zip
+N04E005.hgt.zip
+N04E006.hgt.zip
+N04E007.hgt.zip
+N04E008.hgt.zip
+N04E009.hgt.zip
+N04E010.hgt.zip
+N04E011.hgt.zip
+N04E012.hgt.zip
+N04E013.hgt.zip
+N04E014.hgt.zip
+N04E015.hgt.zip
+N04E016.hgt.zip
+N04E017.hgt.zip
+N04E018.hgt.zip
+N04E019.hgt.zip
+N04E020.hgt.zip
+N04E021.hgt.zip
+N04E022.hgt.zip
+N04E023.hgt.zip
+N04E024.hgt.zip
+N04E025.hgt.zip
+N04E026.hgt.zip
+N04E027.hgt.zip
+N04E028.hgt.zip
+N04E029.hgt.zip
+N04E030.hgt.zip
+N04E031.hgt.zip
+N04E032.hgt.zip
+N04E033.hgt.zip
+N04E034.hgt.zip
+N04E035.hgt.zip
+N04E036.hgt.zip
+N04E037.hgt.zip
+N04E038.hgt.zip
+N04E039.hgt.zip
+N04E040.hgt.zip
+N04E041.hgt.zip
+N04E042.hgt.zip
+N04E043.hgt.zip
+N04E044.hgt.zip
+N04E045.hgt.zip
+N04E046.hgt.zip
+N04E047.hgt.zip
+N04E048.hgt.zip
+N04W002.hgt.zip
+N04W003.hgt.zip
+N04W006.hgt.zip
+N04W007.hgt.zip
+N04W008.hgt.zip
+N04W009.hgt.zip
+N04W010.hgt.zip
+N05E000.hgt.zip
+N05E001.hgt.zip
+N05E004.hgt.zip
+N05E005.hgt.zip
+N05E006.hgt.zip
+N05E007.hgt.zip
+N05E008.hgt.zip
+N05E009.hgt.zip
+N05E010.hgt.zip
+N05E011.hgt.zip
+N05E012.hgt.zip
+N05E013.hgt.zip
+N05E014.hgt.zip
+N05E015.hgt.zip
+N05E016.hgt.zip
+N05E017.hgt.zip
+N05E018.hgt.zip
+N05E019.hgt.zip
+N05E020.hgt.zip
+N05E021.hgt.zip
+N05E022.hgt.zip
+N05E023.hgt.zip
+N05E024.hgt.zip
+N05E025.hgt.zip
+N05E026.hgt.zip
+N05E027.hgt.zip
+N05E028.hgt.zip
+N05E029.hgt.zip
+N05E030.hgt.zip
+N05E031.hgt.zip
+N05E032.hgt.zip
+N05E033.hgt.zip
+N05E034.hgt.zip
+N05E035.hgt.zip
+N05E036.hgt.zip
+N05E037.hgt.zip
+N05E038.hgt.zip
+N05E039.hgt.zip
+N05E040.hgt.zip
+N05E041.hgt.zip
+N05E042.hgt.zip
+N05E043.hgt.zip
+N05E044.hgt.zip
+N05E045.hgt.zip
+N05E046.hgt.zip
+N05E047.hgt.zip
+N05E048.hgt.zip
+N05W001.hgt.zip
+N05W002.hgt.zip
+N05W003.hgt.zip
+N05W004.hgt.zip
+N05W005.hgt.zip
+N05W006.hgt.zip
+N05W007.hgt.zip
+N05W008.hgt.zip
+N05W009.hgt.zip
+N05W010.hgt.zip
+N05W011.hgt.zip
+N06E000.hgt.zip
+N06E001.hgt.zip
+N06E002.hgt.zip
+N06E003.hgt.zip
+N06E004.hgt.zip
+N06E005.hgt.zip
+N06E006.hgt.zip
+N06E007.hgt.zip
+N06E008.hgt.zip
+N06E009.hgt.zip
+N06E010.hgt.zip
+N06E011.hgt.zip
+N06E012.hgt.zip
+N06E013.hgt.zip
+N06E014.hgt.zip
+N06E015.hgt.zip
+N06E016.hgt.zip
+N06E017.hgt.zip
+N06E018.hgt.zip
+N06E019.hgt.zip
+N06E020.hgt.zip
+N06E021.hgt.zip
+N06E022.hgt.zip
+N06E023.hgt.zip
+N06E024.hgt.zip
+N06E025.hgt.zip
+N06E026.hgt.zip
+N06E027.hgt.zip
+N06E028.hgt.zip
+N06E029.hgt.zip
+N06E030.hgt.zip
+N06E031.hgt.zip
+N06E032.hgt.zip
+N06E033.hgt.zip
+N06E034.hgt.zip
+N06E035.hgt.zip
+N06E036.hgt.zip
+N06E037.hgt.zip
+N06E038.hgt.zip
+N06E039.hgt.zip
+N06E040.hgt.zip
+N06E041.hgt.zip
+N06E042.hgt.zip
+N06E043.hgt.zip
+N06E044.hgt.zip
+N06E045.hgt.zip
+N06E046.hgt.zip
+N06E047.hgt.zip
+N06E048.hgt.zip
+N06E049.hgt.zip
+N06W001.hgt.zip
+N06W002.hgt.zip
+N06W003.hgt.zip
+N06W004.hgt.zip
+N06W005.hgt.zip
+N06W006.hgt.zip
+N06W007.hgt.zip
+N06W008.hgt.zip
+N06W009.hgt.zip
+N06W010.hgt.zip
+N06W011.hgt.zip
+N06W012.hgt.zip
+N07E000.hgt.zip
+N07E001.hgt.zip
+N07E002.hgt.zip
+N07E003.hgt.zip
+N07E004.hgt.zip
+N07E005.hgt.zip
+N07E006.hgt.zip
+N07E007.hgt.zip
+N07E008.hgt.zip
+N07E009.hgt.zip
+N07E010.hgt.zip
+N07E011.hgt.zip
+N07E012.hgt.zip
+N07E013.hgt.zip
+N07E014.hgt.zip
+N07E015.hgt.zip
+N07E016.hgt.zip
+N07E017.hgt.zip
+N07E018.hgt.zip
+N07E019.hgt.zip
+N07E020.hgt.zip
+N07E021.hgt.zip
+N07E022.hgt.zip
+N07E023.hgt.zip
+N07E024.hgt.zip
+N07E025.hgt.zip
+N07E026.hgt.zip
+N07E027.hgt.zip
+N07E028.hgt.zip
+N07E029.hgt.zip
+N07E030.hgt.zip
+N07E031.hgt.zip
+N07E032.hgt.zip
+N07E033.hgt.zip
+N07E034.hgt.zip
+N07E035.hgt.zip
+N07E036.hgt.zip
+N07E037.hgt.zip
+N07E038.hgt.zip
+N07E039.hgt.zip
+N07E040.hgt.zip
+N07E041.hgt.zip
+N07E042.hgt.zip
+N07E043.hgt.zip
+N07E044.hgt.zip
+N07E045.hgt.zip
+N07E046.hgt.zip
+N07E047.hgt.zip
+N07E048.hgt.zip
+N07E049.hgt.zip
+N07W001.hgt.zip
+N07W002.hgt.zip
+N07W003.hgt.zip
+N07W004.hgt.zip
+N07W005.hgt.zip
+N07W006.hgt.zip
+N07W007.hgt.zip
+N07W008.hgt.zip
+N07W009.hgt.zip
+N07W010.hgt.zip
+N07W011.hgt.zip
+N07W012.hgt.zip
+N07W013.hgt.zip
+N07W014.hgt.zip
+N08E000.hgt.zip
+N08E001.hgt.zip
+N08E002.hgt.zip
+N08E003.hgt.zip
+N08E004.hgt.zip
+N08E005.hgt.zip
+N08E006.hgt.zip
+N08E007.hgt.zip
+N08E008.hgt.zip
+N08E009.hgt.zip
+N08E010.hgt.zip
+N08E011.hgt.zip
+N08E012.hgt.zip
+N08E013.hgt.zip
+N08E014.hgt.zip
+N08E015.hgt.zip
+N08E016.hgt.zip
+N08E017.hgt.zip
+N08E018.hgt.zip
+N08E019.hgt.zip
+N08E020.hgt.zip
+N08E021.hgt.zip
+N08E022.hgt.zip
+N08E023.hgt.zip
+N08E024.hgt.zip
+N08E025.hgt.zip
+N08E026.hgt.zip
+N08E027.hgt.zip
+N08E028.hgt.zip
+N08E029.hgt.zip
+N08E030.hgt.zip
+N08E031.hgt.zip
+N08E032.hgt.zip
+N08E033.hgt.zip
+N08E034.hgt.zip
+N08E035.hgt.zip
+N08E036.hgt.zip
+N08E037.hgt.zip
+N08E038.hgt.zip
+N08E039.hgt.zip
+N08E040.hgt.zip
+N08E041.hgt.zip
+N08E042.hgt.zip
+N08E043.hgt.zip
+N08E044.hgt.zip
+N08E045.hgt.zip
+N08E046.hgt.zip
+N08E047.hgt.zip
+N08E048.hgt.zip
+N08E049.hgt.zip
+N08E050.hgt.zip
+N08W001.hgt.zip
+N08W002.hgt.zip
+N08W003.hgt.zip
+N08W004.hgt.zip
+N08W005.hgt.zip
+N08W006.hgt.zip
+N08W007.hgt.zip
+N08W008.hgt.zip
+N08W009.hgt.zip
+N08W010.hgt.zip
+N08W011.hgt.zip
+N08W012.hgt.zip
+N08W013.hgt.zip
+N08W014.hgt.zip
+N09E000.hgt.zip
+N09E001.hgt.zip
+N09E002.hgt.zip
+N09E003.hgt.zip
+N09E004.hgt.zip
+N09E005.hgt.zip
+N09E006.hgt.zip
+N09E007.hgt.zip
+N09E008.hgt.zip
+N09E009.hgt.zip
+N09E010.hgt.zip
+N09E011.hgt.zip
+N09E012.hgt.zip
+N09E013.hgt.zip
+N09E014.hgt.zip
+N09E015.hgt.zip
+N09E016.hgt.zip
+N09E017.hgt.zip
+N09E018.hgt.zip
+N09E019.hgt.zip
+N09E020.hgt.zip
+N09E021.hgt.zip
+N09E022.hgt.zip
+N09E023.hgt.zip
+N09E024.hgt.zip
+N09E025.hgt.zip
+N09E026.hgt.zip
+N09E027.hgt.zip
+N09E028.hgt.zip
+N09E029.hgt.zip
+N09E030.hgt.zip
+N09E031.hgt.zip
+N09E032.hgt.zip
+N09E033.hgt.zip
+N09E034.hgt.zip
+N09E035.hgt.zip
+N09E036.hgt.zip
+N09E037.hgt.zip
+N09E038.hgt.zip
+N09E039.hgt.zip
+N09E040.hgt.zip
+N09E041.hgt.zip
+N09E042.hgt.zip
+N09E043.hgt.zip
+N09E044.hgt.zip
+N09E045.hgt.zip
+N09E046.hgt.zip
+N09E047.hgt.zip
+N09E048.hgt.zip
+N09E049.hgt.zip
+N09E050.hgt.zip
+N09W001.hgt.zip
+N09W002.hgt.zip
+N09W003.hgt.zip
+N09W004.hgt.zip
+N09W005.hgt.zip
+N09W006.hgt.zip
+N09W007.hgt.zip
+N09W008.hgt.zip
+N09W009.hgt.zip
+N09W010.hgt.zip
+N09W011.hgt.zip
+N09W012.hgt.zip
+N09W013.hgt.zip
+N09W014.hgt.zip
+N09W015.hgt.zip
+N10E000.hgt.zip
+N10E001.hgt.zip
+N10E002.hgt.zip
+N10E003.hgt.zip
+N10E004.hgt.zip
+N10E005.hgt.zip
+N10E006.hgt.zip
+N10E007.hgt.zip
+N10E008.hgt.zip
+N10E009.hgt.zip
+N10E010.hgt.zip
+N10E011.hgt.zip
+N10E012.hgt.zip
+N10E013.hgt.zip
+N10E014.hgt.zip
+N10E015.hgt.zip
+N10E016.hgt.zip
+N10E017.hgt.zip
+N10E018.hgt.zip
+N10E019.hgt.zip
+N10E020.hgt.zip
+N10E021.hgt.zip
+N10E022.hgt.zip
+N10E023.hgt.zip
+N10E024.hgt.zip
+N10E025.hgt.zip
+N10E026.hgt.zip
+N10E027.hgt.zip
+N10E028.hgt.zip
+N10E029.hgt.zip
+N10E030.hgt.zip
+N10E031.hgt.zip
+N10E032.hgt.zip
+N10E033.hgt.zip
+N10E034.hgt.zip
+N10E035.hgt.zip
+N10E036.hgt.zip
+N10E037.hgt.zip
+N10E038.hgt.zip
+N10E039.hgt.zip
+N10E040.hgt.zip
+N10E041.hgt.zip
+N10E042.hgt.zip
+N10E043.hgt.zip
+N10E044.hgt.zip
+N10E045.hgt.zip
+N10E046.hgt.zip
+N10E047.hgt.zip
+N10E048.hgt.zip
+N10E049.hgt.zip
+N10E050.hgt.zip
+N10E051.hgt.zip
+N10W001.hgt.zip
+N10W002.hgt.zip
+N10W003.hgt.zip
+N10W004.hgt.zip
+N10W005.hgt.zip
+N10W006.hgt.zip
+N10W007.hgt.zip
+N10W008.hgt.zip
+N10W009.hgt.zip
+N10W010.hgt.zip
+N10W011.hgt.zip
+N10W012.hgt.zip
+N10W013.hgt.zip
+N10W014.hgt.zip
+N10W015.hgt.zip
+N10W016.hgt.zip
+N11E000.hgt.zip
+N11E001.hgt.zip
+N11E002.hgt.zip
+N11E003.hgt.zip
+N11E004.hgt.zip
+N11E005.hgt.zip
+N11E006.hgt.zip
+N11E007.hgt.zip
+N11E008.hgt.zip
+N11E009.hgt.zip
+N11E010.hgt.zip
+N11E011.hgt.zip
+N11E012.hgt.zip
+N11E013.hgt.zip
+N11E014.hgt.zip
+N11E015.hgt.zip
+N11E016.hgt.zip
+N11E017.hgt.zip
+N11E018.hgt.zip
+N11E019.hgt.zip
+N11E020.hgt.zip
+N11E021.hgt.zip
+N11E022.hgt.zip
+N11E023.hgt.zip
+N11E024.hgt.zip
+N11E025.hgt.zip
+N11E026.hgt.zip
+N11E027.hgt.zip
+N11E028.hgt.zip
+N11E029.hgt.zip
+N11E030.hgt.zip
+N11E031.hgt.zip
+N11E032.hgt.zip
+N11E033.hgt.zip
+N11E034.hgt.zip
+N11E035.hgt.zip
+N11E036.hgt.zip
+N11E037.hgt.zip
+N11E038.hgt.zip
+N11E039.hgt.zip
+N11E040.hgt.zip
+N11E041.hgt.zip
+N11E042.hgt.zip
+N11E043.hgt.zip
+N11E047.hgt.zip
+N11E048.hgt.zip
+N11E049.hgt.zip
+N11E050.hgt.zip
+N11E051.hgt.zip
+N11W001.hgt.zip
+N11W002.hgt.zip
+N11W003.hgt.zip
+N11W004.hgt.zip
+N11W005.hgt.zip
+N11W006.hgt.zip
+N11W007.hgt.zip
+N11W008.hgt.zip
+N11W009.hgt.zip
+N11W010.hgt.zip
+N11W011.hgt.zip
+N11W012.hgt.zip
+N11W013.hgt.zip
+N11W014.hgt.zip
+N11W015.hgt.zip
+N11W016.hgt.zip
+N11W017.hgt.zip
+N12E000.hgt.zip
+N12E001.hgt.zip
+N12E002.hgt.zip
+N12E003.hgt.zip
+N12E004.hgt.zip
+N12E005.hgt.zip
+N12E006.hgt.zip
+N12E007.hgt.zip
+N12E008.hgt.zip
+N12E009.hgt.zip
+N12E010.hgt.zip
+N12E011.hgt.zip
+N12E012.hgt.zip
+N12E013.hgt.zip
+N12E014.hgt.zip
+N12E015.hgt.zip
+N12E016.hgt.zip
+N12E017.hgt.zip
+N12E018.hgt.zip
+N12E019.hgt.zip
+N12E020.hgt.zip
+N12E021.hgt.zip
+N12E022.hgt.zip
+N12E023.hgt.zip
+N12E024.hgt.zip
+N12E025.hgt.zip
+N12E026.hgt.zip
+N12E027.hgt.zip
+N12E028.hgt.zip
+N12E029.hgt.zip
+N12E030.hgt.zip
+N12E031.hgt.zip
+N12E032.hgt.zip
+N12E033.hgt.zip
+N12E034.hgt.zip
+N12E035.hgt.zip
+N12E036.hgt.zip
+N12E037.hgt.zip
+N12E038.hgt.zip
+N12E039.hgt.zip
+N12E040.hgt.zip
+N12E041.hgt.zip
+N12E042.hgt.zip
+N12E043.hgt.zip
+N12E044.hgt.zip
+N12E045.hgt.zip
+N12E052.hgt.zip
+N12E053.hgt.zip
+N12E054.hgt.zip
+N12W001.hgt.zip
+N12W002.hgt.zip
+N12W003.hgt.zip
+N12W004.hgt.zip
+N12W005.hgt.zip
+N12W006.hgt.zip
+N12W007.hgt.zip
+N12W008.hgt.zip
+N12W009.hgt.zip
+N12W010.hgt.zip
+N12W011.hgt.zip
+N12W012.hgt.zip
+N12W013.hgt.zip
+N12W014.hgt.zip
+N12W015.hgt.zip
+N12W016.hgt.zip
+N12W017.hgt.zip
+N13E000.hgt.zip
+N13E001.hgt.zip
+N13E002.hgt.zip
+N13E003.hgt.zip
+N13E004.hgt.zip
+N13E005.hgt.zip
+N13E006.hgt.zip
+N13E007.hgt.zip
+N13E008.hgt.zip
+N13E009.hgt.zip
+N13E010.hgt.zip
+N13E011.hgt.zip
+N13E012.hgt.zip
+N13E013.hgt.zip
+N13E014.hgt.zip
+N13E015.hgt.zip
+N13E016.hgt.zip
+N13E017.hgt.zip
+N13E018.hgt.zip
+N13E019.hgt.zip
+N13E020.hgt.zip
+N13E021.hgt.zip
+N13E022.hgt.zip
+N13E023.hgt.zip
+N13E024.hgt.zip
+N13E025.hgt.zip
+N13E026.hgt.zip
+N13E027.hgt.zip
+N13E028.hgt.zip
+N13E029.hgt.zip
+N13E030.hgt.zip
+N13E031.hgt.zip
+N13E032.hgt.zip
+N13E033.hgt.zip
+N13E034.hgt.zip
+N13E035.hgt.zip
+N13E036.hgt.zip
+N13E037.hgt.zip
+N13E038.hgt.zip
+N13E039.hgt.zip
+N13E040.hgt.zip
+N13E041.hgt.zip
+N13E042.hgt.zip
+N13E043.hgt.zip
+N13E044.hgt.zip
+N13E045.hgt.zip
+N13E046.hgt.zip
+N13E047.hgt.zip
+N13E048.hgt.zip
+N13W001.hgt.zip
+N13W002.hgt.zip
+N13W003.hgt.zip
+N13W004.hgt.zip
+N13W005.hgt.zip
+N13W006.hgt.zip
+N13W007.hgt.zip
+N13W008.hgt.zip
+N13W009.hgt.zip
+N13W010.hgt.zip
+N13W011.hgt.zip
+N13W012.hgt.zip
+N13W013.hgt.zip
+N13W014.hgt.zip
+N13W015.hgt.zip
+N13W016.hgt.zip
+N13W017.hgt.zip
+N14E000.hgt.zip
+N14E001.hgt.zip
+N14E002.hgt.zip
+N14E003.hgt.zip
+N14E004.hgt.zip
+N14E005.hgt.zip
+N14E006.hgt.zip
+N14E007.hgt.zip
+N14E008.hgt.zip
+N14E009.hgt.zip
+N14E010.hgt.zip
+N14E011.hgt.zip
+N14E012.hgt.zip
+N14E013.hgt.zip
+N14E014.hgt.zip
+N14E015.hgt.zip
+N14E016.hgt.zip
+N14E017.hgt.zip
+N14E018.hgt.zip
+N14E019.hgt.zip
+N14E020.hgt.zip
+N14E021.hgt.zip
+N14E022.hgt.zip
+N14E023.hgt.zip
+N14E024.hgt.zip
+N14E025.hgt.zip
+N14E026.hgt.zip
+N14E027.hgt.zip
+N14E028.hgt.zip
+N14E029.hgt.zip
+N14E030.hgt.zip
+N14E031.hgt.zip
+N14E032.hgt.zip
+N14E033.hgt.zip
+N14E034.hgt.zip
+N14E035.hgt.zip
+N14E036.hgt.zip
+N14E037.hgt.zip
+N14E038.hgt.zip
+N14E039.hgt.zip
+N14E040.hgt.zip
+N14E041.hgt.zip
+N14E042.hgt.zip
+N14E043.hgt.zip
+N14E044.hgt.zip
+N14E045.hgt.zip
+N14E046.hgt.zip
+N14E047.hgt.zip
+N14E048.hgt.zip
+N14E049.hgt.zip
+N14E050.hgt.zip
+N14W001.hgt.zip
+N14W002.hgt.zip
+N14W003.hgt.zip
+N14W004.hgt.zip
+N14W005.hgt.zip
+N14W006.hgt.zip
+N14W007.hgt.zip
+N14W008.hgt.zip
+N14W009.hgt.zip
+N14W010.hgt.zip
+N14W011.hgt.zip
+N14W012.hgt.zip
+N14W013.hgt.zip
+N14W014.hgt.zip
+N14W015.hgt.zip
+N14W016.hgt.zip
+N14W017.hgt.zip
+N14W018.hgt.zip
+N14W024.hgt.zip
+N14W025.hgt.zip
+N15E000.hgt.zip
+N15E001.hgt.zip
+N15E002.hgt.zip
+N15E003.hgt.zip
+N15E004.hgt.zip
+N15E005.hgt.zip
+N15E006.hgt.zip
+N15E007.hgt.zip
+N15E008.hgt.zip
+N15E009.hgt.zip
+N15E010.hgt.zip
+N15E011.hgt.zip
+N15E012.hgt.zip
+N15E013.hgt.zip
+N15E014.hgt.zip
+N15E015.hgt.zip
+N15E016.hgt.zip
+N15E017.hgt.zip
+N15E018.hgt.zip
+N15E019.hgt.zip
+N15E020.hgt.zip
+N15E021.hgt.zip
+N15E022.hgt.zip
+N15E023.hgt.zip
+N15E024.hgt.zip
+N15E025.hgt.zip
+N15E026.hgt.zip
+N15E027.hgt.zip
+N15E028.hgt.zip
+N15E029.hgt.zip
+N15E030.hgt.zip
+N15E031.hgt.zip
+N15E032.hgt.zip
+N15E033.hgt.zip
+N15E034.hgt.zip
+N15E035.hgt.zip
+N15E036.hgt.zip
+N15E037.hgt.zip
+N15E038.hgt.zip
+N15E039.hgt.zip
+N15E040.hgt.zip
+N15E041.hgt.zip
+N15E042.hgt.zip
+N15E043.hgt.zip
+N15E044.hgt.zip
+N15E045.hgt.zip
+N15E046.hgt.zip
+N15E047.hgt.zip
+N15E048.hgt.zip
+N15E049.hgt.zip
+N15E050.hgt.zip
+N15E051.hgt.zip
+N15E052.hgt.zip
+N15W001.hgt.zip
+N15W002.hgt.zip
+N15W003.hgt.zip
+N15W004.hgt.zip
+N15W005.hgt.zip
+N15W006.hgt.zip
+N15W007.hgt.zip
+N15W008.hgt.zip
+N15W009.hgt.zip
+N15W010.hgt.zip
+N15W011.hgt.zip
+N15W012.hgt.zip
+N15W013.hgt.zip
+N15W014.hgt.zip
+N15W015.hgt.zip
+N15W016.hgt.zip
+N15W017.hgt.zip
+N15W018.hgt.zip
+N15W023.hgt.zip
+N15W024.hgt.zip
+N15W025.hgt.zip
+N16E000.hgt.zip
+N16E001.hgt.zip
+N16E002.hgt.zip
+N16E003.hgt.zip
+N16E004.hgt.zip
+N16E005.hgt.zip
+N16E006.hgt.zip
+N16E007.hgt.zip
+N16E008.hgt.zip
+N16E009.hgt.zip
+N16E010.hgt.zip
+N16E011.hgt.zip
+N16E012.hgt.zip
+N16E013.hgt.zip
+N16E014.hgt.zip
+N16E015.hgt.zip
+N16E016.hgt.zip
+N16E017.hgt.zip
+N16E018.hgt.zip
+N16E019.hgt.zip
+N16E020.hgt.zip
+N16E021.hgt.zip
+N16E022.hgt.zip
+N16E023.hgt.zip
+N16E024.hgt.zip
+N16E025.hgt.zip
+N16E026.hgt.zip
+N16E027.hgt.zip
+N16E028.hgt.zip
+N16E029.hgt.zip
+N16E030.hgt.zip
+N16E031.hgt.zip
+N16E032.hgt.zip
+N16E033.hgt.zip
+N16E034.hgt.zip
+N16E035.hgt.zip
+N16E036.hgt.zip
+N16E037.hgt.zip
+N16E038.hgt.zip
+N16E039.hgt.zip
+N16E040.hgt.zip
+N16E041.hgt.zip
+N16E042.hgt.zip
+N16E043.hgt.zip
+N16E044.hgt.zip
+N16E045.hgt.zip
+N16E046.hgt.zip
+N16E047.hgt.zip
+N16E048.hgt.zip
+N16E049.hgt.zip
+N16E050.hgt.zip
+N16E051.hgt.zip
+N16E052.hgt.zip
+N16E053.hgt.zip
+N16E054.hgt.zip
+N16E055.hgt.zip
+N16W001.hgt.zip
+N16W002.hgt.zip
+N16W003.hgt.zip
+N16W004.hgt.zip
+N16W005.hgt.zip
+N16W006.hgt.zip
+N16W007.hgt.zip
+N16W008.hgt.zip
+N16W009.hgt.zip
+N16W010.hgt.zip
+N16W011.hgt.zip
+N16W012.hgt.zip
+N16W013.hgt.zip
+N16W014.hgt.zip
+N16W015.hgt.zip
+N16W016.hgt.zip
+N16W017.hgt.zip
+N16W023.hgt.zip
+N16W025.hgt.zip
+N16W026.hgt.zip
+N17E000.hgt.zip
+N17E001.hgt.zip
+N17E002.hgt.zip
+N17E003.hgt.zip
+N17E004.hgt.zip
+N17E005.hgt.zip
+N17E006.hgt.zip
+N17E007.hgt.zip
+N17E008.hgt.zip
+N17E009.hgt.zip
+N17E010.hgt.zip
+N17E011.hgt.zip
+N17E012.hgt.zip
+N17E013.hgt.zip
+N17E014.hgt.zip
+N17E015.hgt.zip
+N17E016.hgt.zip
+N17E017.hgt.zip
+N17E018.hgt.zip
+N17E019.hgt.zip
+N17E020.hgt.zip
+N17E021.hgt.zip
+N17E022.hgt.zip
+N17E023.hgt.zip
+N17E024.hgt.zip
+N17E025.hgt.zip
+N17E026.hgt.zip
+N17E027.hgt.zip
+N17E028.hgt.zip
+N17E029.hgt.zip
+N17E030.hgt.zip
+N17E031.hgt.zip
+N17E032.hgt.zip
+N17E033.hgt.zip
+N17E034.hgt.zip
+N17E035.hgt.zip
+N17E036.hgt.zip
+N17E037.hgt.zip
+N17E038.hgt.zip
+N17E039.hgt.zip
+N17E041.hgt.zip
+N17E042.hgt.zip
+N17E043.hgt.zip
+N17E044.hgt.zip
+N17E045.hgt.zip
+N17E046.hgt.zip
+N17E047.hgt.zip
+N17E048.hgt.zip
+N17E049.hgt.zip
+N17E050.hgt.zip
+N17E051.hgt.zip
+N17E052.hgt.zip
+N17E053.hgt.zip
+N17E054.hgt.zip
+N17E055.hgt.zip
+N17E056.hgt.zip
+N17W001.hgt.zip
+N17W002.hgt.zip
+N17W003.hgt.zip
+N17W004.hgt.zip
+N17W005.hgt.zip
+N17W006.hgt.zip
+N17W007.hgt.zip
+N17W008.hgt.zip
+N17W009.hgt.zip
+N17W010.hgt.zip
+N17W011.hgt.zip
+N17W012.hgt.zip
+N17W013.hgt.zip
+N17W014.hgt.zip
+N17W015.hgt.zip
+N17W016.hgt.zip
+N17W017.hgt.zip
+N17W025.hgt.zip
+N17W026.hgt.zip
+N18E000.hgt.zip
+N18E001.hgt.zip
+N18E002.hgt.zip
+N18E003.hgt.zip
+N18E004.hgt.zip
+N18E005.hgt.zip
+N18E006.hgt.zip
+N18E007.hgt.zip
+N18E008.hgt.zip
+N18E009.hgt.zip
+N18E010.hgt.zip
+N18E011.hgt.zip
+N18E012.hgt.zip
+N18E013.hgt.zip
+N18E014.hgt.zip
+N18E015.hgt.zip
+N18E016.hgt.zip
+N18E017.hgt.zip
+N18E018.hgt.zip
+N18E019.hgt.zip
+N18E020.hgt.zip
+N18E021.hgt.zip
+N18E022.hgt.zip
+N18E023.hgt.zip
+N18E024.hgt.zip
+N18E025.hgt.zip
+N18E026.hgt.zip
+N18E027.hgt.zip
+N18E028.hgt.zip
+N18E029.hgt.zip
+N18E030.hgt.zip
+N18E031.hgt.zip
+N18E032.hgt.zip
+N18E033.hgt.zip
+N18E034.hgt.zip
+N18E035.hgt.zip
+N18E036.hgt.zip
+N18E037.hgt.zip
+N18E038.hgt.zip
+N18E040.hgt.zip
+N18E041.hgt.zip
+N18E042.hgt.zip
+N18E043.hgt.zip
+N18E044.hgt.zip
+N18E045.hgt.zip
+N18E046.hgt.zip
+N18E047.hgt.zip
+N18E048.hgt.zip
+N18E049.hgt.zip
+N18E050.hgt.zip
+N18E051.hgt.zip
+N18E052.hgt.zip
+N18E053.hgt.zip
+N18E054.hgt.zip
+N18E055.hgt.zip
+N18E056.hgt.zip
+N18E057.hgt.zip
+N18W001.hgt.zip
+N18W002.hgt.zip
+N18W003.hgt.zip
+N18W004.hgt.zip
+N18W005.hgt.zip
+N18W006.hgt.zip
+N18W007.hgt.zip
+N18W008.hgt.zip
+N18W009.hgt.zip
+N18W010.hgt.zip
+N18W011.hgt.zip
+N18W012.hgt.zip
+N18W013.hgt.zip
+N18W014.hgt.zip
+N18W015.hgt.zip
+N18W016.hgt.zip
+N18W017.hgt.zip
+N19E000.hgt.zip
+N19E001.hgt.zip
+N19E002.hgt.zip
+N19E003.hgt.zip
+N19E004.hgt.zip
+N19E005.hgt.zip
+N19E006.hgt.zip
+N19E007.hgt.zip
+N19E008.hgt.zip
+N19E009.hgt.zip
+N19E010.hgt.zip
+N19E011.hgt.zip
+N19E012.hgt.zip
+N19E013.hgt.zip
+N19E014.hgt.zip
+N19E015.hgt.zip
+N19E016.hgt.zip
+N19E017.hgt.zip
+N19E018.hgt.zip
+N19E019.hgt.zip
+N19E020.hgt.zip
+N19E021.hgt.zip
+N19E022.hgt.zip
+N19E023.hgt.zip
+N19E024.hgt.zip
+N19E025.hgt.zip
+N19E026.hgt.zip
+N19E027.hgt.zip
+N19E028.hgt.zip
+N19E029.hgt.zip
+N19E030.hgt.zip
+N19E031.hgt.zip
+N19E032.hgt.zip
+N19E033.hgt.zip
+N19E034.hgt.zip
+N19E035.hgt.zip
+N19E036.hgt.zip
+N19E037.hgt.zip
+N19E038.hgt.zip
+N19E039.hgt.zip
+N19E040.hgt.zip
+N19E041.hgt.zip
+N19E042.hgt.zip
+N19E043.hgt.zip
+N19E044.hgt.zip
+N19E045.hgt.zip
+N19E046.hgt.zip
+N19E047.hgt.zip
+N19E048.hgt.zip
+N19E049.hgt.zip
+N19E050.hgt.zip
+N19E051.hgt.zip
+N19E052.hgt.zip
+N19E053.hgt.zip
+N19E054.hgt.zip
+N19E055.hgt.zip
+N19E056.hgt.zip
+N19E057.hgt.zip
+N19W001.hgt.zip
+N19W002.hgt.zip
+N19W003.hgt.zip
+N19W004.hgt.zip
+N19W005.hgt.zip
+N19W006.hgt.zip
+N19W007.hgt.zip
+N19W008.hgt.zip
+N19W009.hgt.zip
+N19W010.hgt.zip
+N19W011.hgt.zip
+N19W012.hgt.zip
+N19W013.hgt.zip
+N19W014.hgt.zip
+N19W015.hgt.zip
+N19W016.hgt.zip
+N19W017.hgt.zip
+N20E000.hgt.zip
+N20E001.hgt.zip
+N20E002.hgt.zip
+N20E003.hgt.zip
+N20E004.hgt.zip
+N20E005.hgt.zip
+N20E006.hgt.zip
+N20E007.hgt.zip
+N20E008.hgt.zip
+N20E009.hgt.zip
+N20E010.hgt.zip
+N20E011.hgt.zip
+N20E012.hgt.zip
+N20E013.hgt.zip
+N20E014.hgt.zip
+N20E015.hgt.zip
+N20E016.hgt.zip
+N20E017.hgt.zip
+N20E018.hgt.zip
+N20E019.hgt.zip
+N20E020.hgt.zip
+N20E021.hgt.zip
+N20E022.hgt.zip
+N20E023.hgt.zip
+N20E024.hgt.zip
+N20E025.hgt.zip
+N20E026.hgt.zip
+N20E027.hgt.zip
+N20E028.hgt.zip
+N20E029.hgt.zip
+N20E030.hgt.zip
+N20E031.hgt.zip
+N20E032.hgt.zip
+N20E033.hgt.zip
+N20E034.hgt.zip
+N20E035.hgt.zip
+N20E036.hgt.zip
+N20E037.hgt.zip
+N20E039.hgt.zip
+N20E040.hgt.zip
+N20E041.hgt.zip
+N20E042.hgt.zip
+N20E043.hgt.zip
+N20E044.hgt.zip
+N20E045.hgt.zip
+N20E046.hgt.zip
+N20E047.hgt.zip
+N20E048.hgt.zip
+N20E049.hgt.zip
+N20E050.hgt.zip
+N20E051.hgt.zip
+N20E052.hgt.zip
+N20E053.hgt.zip
+N20E054.hgt.zip
+N20E055.hgt.zip
+N20E056.hgt.zip
+N20E057.hgt.zip
+N20E058.hgt.zip
+N20W001.hgt.zip
+N20W002.hgt.zip
+N20W003.hgt.zip
+N20W004.hgt.zip
+N20W005.hgt.zip
+N20W006.hgt.zip
+N20W007.hgt.zip
+N20W008.hgt.zip
+N20W009.hgt.zip
+N20W010.hgt.zip
+N20W011.hgt.zip
+N20W012.hgt.zip
+N20W013.hgt.zip
+N20W014.hgt.zip
+N20W015.hgt.zip
+N20W016.hgt.zip
+N20W017.hgt.zip
+N20W018.hgt.zip
+N21E000.hgt.zip
+N21E001.hgt.zip
+N21E002.hgt.zip
+N21E003.hgt.zip
+N21E004.hgt.zip
+N21E005.hgt.zip
+N21E006.hgt.zip
+N21E007.hgt.zip
+N21E008.hgt.zip
+N21E009.hgt.zip
+N21E010.hgt.zip
+N21E011.hgt.zip
+N21E012.hgt.zip
+N21E013.hgt.zip
+N21E014.hgt.zip
+N21E015.hgt.zip
+N21E016.hgt.zip
+N21E017.hgt.zip
+N21E018.hgt.zip
+N21E019.hgt.zip
+N21E020.hgt.zip
+N21E021.hgt.zip
+N21E022.hgt.zip
+N21E023.hgt.zip
+N21E024.hgt.zip
+N21E025.hgt.zip
+N21E026.hgt.zip
+N21E027.hgt.zip
+N21E028.hgt.zip
+N21E029.hgt.zip
+N21E030.hgt.zip
+N21E031.hgt.zip
+N21E032.hgt.zip
+N21E033.hgt.zip
+N21E034.hgt.zip
+N21E035.hgt.zip
+N21E036.hgt.zip
+N21E037.hgt.zip
+N21E038.hgt.zip
+N21E039.hgt.zip
+N21E040.hgt.zip
+N21E041.hgt.zip
+N21E042.hgt.zip
+N21E043.hgt.zip
+N21E044.hgt.zip
+N21E045.hgt.zip
+N21E046.hgt.zip
+N21E047.hgt.zip
+N21E048.hgt.zip
+N21E049.hgt.zip
+N21E050.hgt.zip
+N21E051.hgt.zip
+N21E052.hgt.zip
+N21E053.hgt.zip
+N21E054.hgt.zip
+N21E055.hgt.zip
+N21E056.hgt.zip
+N21E057.hgt.zip
+N21E058.hgt.zip
+N21E059.hgt.zip
+N21W001.hgt.zip
+N21W002.hgt.zip
+N21W003.hgt.zip
+N21W004.hgt.zip
+N21W005.hgt.zip
+N21W006.hgt.zip
+N21W007.hgt.zip
+N21W008.hgt.zip
+N21W009.hgt.zip
+N21W010.hgt.zip
+N21W011.hgt.zip
+N21W012.hgt.zip
+N21W013.hgt.zip
+N21W014.hgt.zip
+N21W015.hgt.zip
+N21W016.hgt.zip
+N21W017.hgt.zip
+N21W018.hgt.zip
+N22E000.hgt.zip
+N22E001.hgt.zip
+N22E002.hgt.zip
+N22E003.hgt.zip
+N22E004.hgt.zip
+N22E005.hgt.zip
+N22E006.hgt.zip
+N22E007.hgt.zip
+N22E008.hgt.zip
+N22E009.hgt.zip
+N22E010.hgt.zip
+N22E011.hgt.zip
+N22E012.hgt.zip
+N22E013.hgt.zip
+N22E014.hgt.zip
+N22E015.hgt.zip
+N22E016.hgt.zip
+N22E017.hgt.zip
+N22E018.hgt.zip
+N22E019.hgt.zip
+N22E020.hgt.zip
+N22E021.hgt.zip
+N22E022.hgt.zip
+N22E023.hgt.zip
+N22E024.hgt.zip
+N22E025.hgt.zip
+N22E026.hgt.zip
+N22E027.hgt.zip
+N22E028.hgt.zip
+N22E029.hgt.zip
+N22E030.hgt.zip
+N22E031.hgt.zip
+N22E032.hgt.zip
+N22E033.hgt.zip
+N22E034.hgt.zip
+N22E035.hgt.zip
+N22E036.hgt.zip
+N22E038.hgt.zip
+N22E039.hgt.zip
+N22E040.hgt.zip
+N22E041.hgt.zip
+N22E042.hgt.zip
+N22E043.hgt.zip
+N22E044.hgt.zip
+N22E045.hgt.zip
+N22E046.hgt.zip
+N22E047.hgt.zip
+N22E048.hgt.zip
+N22E049.hgt.zip
+N22E050.hgt.zip
+N22E051.hgt.zip
+N22E052.hgt.zip
+N22E053.hgt.zip
+N22E054.hgt.zip
+N22E055.hgt.zip
+N22E056.hgt.zip
+N22E057.hgt.zip
+N22E058.hgt.zip
+N22E059.hgt.zip
+N22W001.hgt.zip
+N22W002.hgt.zip
+N22W003.hgt.zip
+N22W004.hgt.zip
+N22W005.hgt.zip
+N22W006.hgt.zip
+N22W007.hgt.zip
+N22W008.hgt.zip
+N22W009.hgt.zip
+N22W010.hgt.zip
+N22W011.hgt.zip
+N22W012.hgt.zip
+N22W013.hgt.zip
+N22W014.hgt.zip
+N22W015.hgt.zip
+N22W016.hgt.zip
+N22W017.hgt.zip
+N23E000.hgt.zip
+N23E001.hgt.zip
+N23E002.hgt.zip
+N23E003.hgt.zip
+N23E004.hgt.zip
+N23E005.hgt.zip
+N23E006.hgt.zip
+N23E007.hgt.zip
+N23E008.hgt.zip
+N23E009.hgt.zip
+N23E010.hgt.zip
+N23E011.hgt.zip
+N23E012.hgt.zip
+N23E013.hgt.zip
+N23E014.hgt.zip
+N23E015.hgt.zip
+N23E016.hgt.zip
+N23E017.hgt.zip
+N23E018.hgt.zip
+N23E019.hgt.zip
+N23E020.hgt.zip
+N23E021.hgt.zip
+N23E022.hgt.zip
+N23E023.hgt.zip
+N23E024.hgt.zip
+N23E025.hgt.zip
+N23E026.hgt.zip
+N23E027.hgt.zip
+N23E028.hgt.zip
+N23E029.hgt.zip
+N23E030.hgt.zip
+N23E031.hgt.zip
+N23E032.hgt.zip
+N23E033.hgt.zip
+N23E034.hgt.zip
+N23E035.hgt.zip
+N23E036.hgt.zip
+N23E038.hgt.zip
+N23E039.hgt.zip
+N23E040.hgt.zip
+N23E041.hgt.zip
+N23E042.hgt.zip
+N23E043.hgt.zip
+N23E044.hgt.zip
+N23E045.hgt.zip
+N23E046.hgt.zip
+N23E047.hgt.zip
+N23E048.hgt.zip
+N23E049.hgt.zip
+N23E050.hgt.zip
+N23E051.hgt.zip
+N23E052.hgt.zip
+N23E053.hgt.zip
+N23E054.hgt.zip
+N23E055.hgt.zip
+N23E056.hgt.zip
+N23E057.hgt.zip
+N23E058.hgt.zip
+N23E059.hgt.zip
+N23W001.hgt.zip
+N23W002.hgt.zip
+N23W003.hgt.zip
+N23W004.hgt.zip
+N23W005.hgt.zip
+N23W006.hgt.zip
+N23W007.hgt.zip
+N23W008.hgt.zip
+N23W009.hgt.zip
+N23W010.hgt.zip
+N23W011.hgt.zip
+N23W012.hgt.zip
+N23W013.hgt.zip
+N23W014.hgt.zip
+N23W015.hgt.zip
+N23W016.hgt.zip
+N23W017.hgt.zip
+N24E000.hgt.zip
+N24E001.hgt.zip
+N24E002.hgt.zip
+N24E003.hgt.zip
+N24E004.hgt.zip
+N24E005.hgt.zip
+N24E006.hgt.zip
+N24E007.hgt.zip
+N24E008.hgt.zip
+N24E009.hgt.zip
+N24E010.hgt.zip
+N24E011.hgt.zip
+N24E012.hgt.zip
+N24E013.hgt.zip
+N24E014.hgt.zip
+N24E015.hgt.zip
+N24E016.hgt.zip
+N24E017.hgt.zip
+N24E018.hgt.zip
+N24E019.hgt.zip
+N24E020.hgt.zip
+N24E021.hgt.zip
+N24E022.hgt.zip
+N24E023.hgt.zip
+N24E024.hgt.zip
+N24E025.hgt.zip
+N24E026.hgt.zip
+N24E027.hgt.zip
+N24E028.hgt.zip
+N24E029.hgt.zip
+N24E030.hgt.zip
+N24E031.hgt.zip
+N24E032.hgt.zip
+N24E033.hgt.zip
+N24E034.hgt.zip
+N24E035.hgt.zip
+N24E037.hgt.zip
+N24E038.hgt.zip
+N24E039.hgt.zip
+N24E040.hgt.zip
+N24E041.hgt.zip
+N24E042.hgt.zip
+N24E043.hgt.zip
+N24E044.hgt.zip
+N24E045.hgt.zip
+N24E046.hgt.zip
+N24E047.hgt.zip
+N24E048.hgt.zip
+N24E049.hgt.zip
+N24E050.hgt.zip
+N24E051.hgt.zip
+N24E052.hgt.zip
+N24E053.hgt.zip
+N24E054.hgt.zip
+N24E055.hgt.zip
+N24E056.hgt.zip
+N24E057.hgt.zip
+N24W001.hgt.zip
+N24W002.hgt.zip
+N24W003.hgt.zip
+N24W004.hgt.zip
+N24W005.hgt.zip
+N24W006.hgt.zip
+N24W007.hgt.zip
+N24W008.hgt.zip
+N24W009.hgt.zip
+N24W010.hgt.zip
+N24W011.hgt.zip
+N24W012.hgt.zip
+N24W013.hgt.zip
+N24W014.hgt.zip
+N24W015.hgt.zip
+N24W016.hgt.zip
+N25E000.hgt.zip
+N25E001.hgt.zip
+N25E002.hgt.zip
+N25E003.hgt.zip
+N25E004.hgt.zip
+N25E005.hgt.zip
+N25E006.hgt.zip
+N25E007.hgt.zip
+N25E008.hgt.zip
+N25E009.hgt.zip
+N25E010.hgt.zip
+N25E011.hgt.zip
+N25E012.hgt.zip
+N25E013.hgt.zip
+N25E014.hgt.zip
+N25E015.hgt.zip
+N25E016.hgt.zip
+N25E017.hgt.zip
+N25E018.hgt.zip
+N25E019.hgt.zip
+N25E020.hgt.zip
+N25E021.hgt.zip
+N25E022.hgt.zip
+N25E023.hgt.zip
+N25E024.hgt.zip
+N25E025.hgt.zip
+N25E026.hgt.zip
+N25E027.hgt.zip
+N25E028.hgt.zip
+N25E029.hgt.zip
+N25E030.hgt.zip
+N25E031.hgt.zip
+N25E032.hgt.zip
+N25E033.hgt.zip
+N25E034.hgt.zip
+N25E036.hgt.zip
+N25E037.hgt.zip
+N25E038.hgt.zip
+N25E039.hgt.zip
+N25E040.hgt.zip
+N25E041.hgt.zip
+N25E042.hgt.zip
+N25E043.hgt.zip
+N25E044.hgt.zip
+N25E045.hgt.zip
+N25E046.hgt.zip
+N25E047.hgt.zip
+N25E048.hgt.zip
+N25E049.hgt.zip
+N25E050.hgt.zip
+N25E051.hgt.zip
+N25E052.hgt.zip
+N25E054.hgt.zip
+N25E055.hgt.zip
+N25E056.hgt.zip
+N25E057.hgt.zip
+N25E058.hgt.zip
+N25E059.hgt.zip
+N25W001.hgt.zip
+N25W002.hgt.zip
+N25W003.hgt.zip
+N25W004.hgt.zip
+N25W005.hgt.zip
+N25W006.hgt.zip
+N25W007.hgt.zip
+N25W008.hgt.zip
+N25W009.hgt.zip
+N25W010.hgt.zip
+N25W011.hgt.zip
+N25W012.hgt.zip
+N25W013.hgt.zip
+N25W014.hgt.zip
+N25W015.hgt.zip
+N26E000.hgt.zip
+N26E001.hgt.zip
+N26E002.hgt.zip
+N26E003.hgt.zip
+N26E004.hgt.zip
+N26E005.hgt.zip
+N26E006.hgt.zip
+N26E007.hgt.zip
+N26E008.hgt.zip
+N26E009.hgt.zip
+N26E010.hgt.zip
+N26E011.hgt.zip
+N26E012.hgt.zip
+N26E013.hgt.zip
+N26E014.hgt.zip
+N26E015.hgt.zip
+N26E016.hgt.zip
+N26E017.hgt.zip
+N26E018.hgt.zip
+N26E019.hgt.zip
+N26E020.hgt.zip
+N26E021.hgt.zip
+N26E022.hgt.zip
+N26E023.hgt.zip
+N26E024.hgt.zip
+N26E025.hgt.zip
+N26E026.hgt.zip
+N26E027.hgt.zip
+N26E028.hgt.zip
+N26E029.hgt.zip
+N26E030.hgt.zip
+N26E031.hgt.zip
+N26E032.hgt.zip
+N26E033.hgt.zip
+N26E034.hgt.zip
+N26E035.hgt.zip
+N26E036.hgt.zip
+N26E037.hgt.zip
+N26E038.hgt.zip
+N26E039.hgt.zip
+N26E040.hgt.zip
+N26E041.hgt.zip
+N26E042.hgt.zip
+N26E043.hgt.zip
+N26E044.hgt.zip
+N26E045.hgt.zip
+N26E046.hgt.zip
+N26E047.hgt.zip
+N26E048.hgt.zip
+N26E049.hgt.zip
+N26E050.hgt.zip
+N26E051.hgt.zip
+N26E053.hgt.zip
+N26E054.hgt.zip
+N26E055.hgt.zip
+N26E056.hgt.zip
+N26E057.hgt.zip
+N26E058.hgt.zip
+N26E059.hgt.zip
+N26W001.hgt.zip
+N26W002.hgt.zip
+N26W003.hgt.zip
+N26W004.hgt.zip
+N26W005.hgt.zip
+N26W006.hgt.zip
+N26W007.hgt.zip
+N26W008.hgt.zip
+N26W009.hgt.zip
+N26W010.hgt.zip
+N26W011.hgt.zip
+N26W012.hgt.zip
+N26W013.hgt.zip
+N26W014.hgt.zip
+N26W015.hgt.zip
+N27E000.hgt.zip
+N27E001.hgt.zip
+N27E002.hgt.zip
+N27E003.hgt.zip
+N27E004.hgt.zip
+N27E005.hgt.zip
+N27E006.hgt.zip
+N27E007.hgt.zip
+N27E008.hgt.zip
+N27E009.hgt.zip
+N27E010.hgt.zip
+N27E011.hgt.zip
+N27E012.hgt.zip
+N27E013.hgt.zip
+N27E014.hgt.zip
+N27E015.hgt.zip
+N27E016.hgt.zip
+N27E017.hgt.zip
+N27E018.hgt.zip
+N27E019.hgt.zip
+N27E020.hgt.zip
+N27E021.hgt.zip
+N27E022.hgt.zip
+N27E023.hgt.zip
+N27E024.hgt.zip
+N27E025.hgt.zip
+N27E026.hgt.zip
+N27E027.hgt.zip
+N27E028.hgt.zip
+N27E029.hgt.zip
+N27E030.hgt.zip
+N27E031.hgt.zip
+N27E032.hgt.zip
+N27E033.hgt.zip
+N27E034.hgt.zip
+N27E035.hgt.zip
+N27E036.hgt.zip
+N27E037.hgt.zip
+N27E038.hgt.zip
+N27E039.hgt.zip
+N27E040.hgt.zip
+N27E041.hgt.zip
+N27E042.hgt.zip
+N27E043.hgt.zip
+N27E044.hgt.zip
+N27E045.hgt.zip
+N27E046.hgt.zip
+N27E047.hgt.zip
+N27E048.hgt.zip
+N27E049.hgt.zip
+N27E050.hgt.zip
+N27E051.hgt.zip
+N27E052.hgt.zip
+N27E053.hgt.zip
+N27E054.hgt.zip
+N27E055.hgt.zip
+N27E056.hgt.zip
+N27E057.hgt.zip
+N27E058.hgt.zip
+N27E059.hgt.zip
+N27W001.hgt.zip
+N27W002.hgt.zip
+N27W003.hgt.zip
+N27W004.hgt.zip
+N27W005.hgt.zip
+N27W006.hgt.zip
+N27W007.hgt.zip
+N27W008.hgt.zip
+N27W009.hgt.zip
+N27W010.hgt.zip
+N27W011.hgt.zip
+N27W012.hgt.zip
+N27W013.hgt.zip
+N27W014.hgt.zip
+N27W016.hgt.zip
+N27W017.hgt.zip
+N27W018.hgt.zip
+N27W019.hgt.zip
+N28E000.hgt.zip
+N28E001.hgt.zip
+N28E002.hgt.zip
+N28E003.hgt.zip
+N28E004.hgt.zip
+N28E005.hgt.zip
+N28E006.hgt.zip
+N28E007.hgt.zip
+N28E008.hgt.zip
+N28E009.hgt.zip
+N28E010.hgt.zip
+N28E011.hgt.zip
+N28E012.hgt.zip
+N28E013.hgt.zip
+N28E014.hgt.zip
+N28E015.hgt.zip
+N28E016.hgt.zip
+N28E017.hgt.zip
+N28E018.hgt.zip
+N28E019.hgt.zip
+N28E020.hgt.zip
+N28E021.hgt.zip
+N28E022.hgt.zip
+N28E023.hgt.zip
+N28E024.hgt.zip
+N28E025.hgt.zip
+N28E026.hgt.zip
+N28E027.hgt.zip
+N28E028.hgt.zip
+N28E029.hgt.zip
+N28E030.hgt.zip
+N28E031.hgt.zip
+N28E032.hgt.zip
+N28E033.hgt.zip
+N28E034.hgt.zip
+N28E035.hgt.zip
+N28E036.hgt.zip
+N28E037.hgt.zip
+N28E038.hgt.zip
+N28E039.hgt.zip
+N28E040.hgt.zip
+N28E041.hgt.zip
+N28E042.hgt.zip
+N28E043.hgt.zip
+N28E044.hgt.zip
+N28E045.hgt.zip
+N28E046.hgt.zip
+N28E047.hgt.zip
+N28E048.hgt.zip
+N28E050.hgt.zip
+N28E051.hgt.zip
+N28E052.hgt.zip
+N28E053.hgt.zip
+N28E054.hgt.zip
+N28E055.hgt.zip
+N28E056.hgt.zip
+N28E057.hgt.zip
+N28E058.hgt.zip
+N28E059.hgt.zip
+N28W001.hgt.zip
+N28W002.hgt.zip
+N28W003.hgt.zip
+N28W004.hgt.zip
+N28W005.hgt.zip
+N28W006.hgt.zip
+N28W007.hgt.zip
+N28W008.hgt.zip
+N28W009.hgt.zip
+N28W010.hgt.zip
+N28W011.hgt.zip
+N28W012.hgt.zip
+N28W013.hgt.zip
+N28W014.hgt.zip
+N28W015.hgt.zip
+N28W016.hgt.zip
+N28W017.hgt.zip
+N28W018.hgt.zip
+N28W019.hgt.zip
+N29E000.hgt.zip
+N29E001.hgt.zip
+N29E002.hgt.zip
+N29E003.hgt.zip
+N29E004.hgt.zip
+N29E005.hgt.zip
+N29E006.hgt.zip
+N29E007.hgt.zip
+N29E008.hgt.zip
+N29E009.hgt.zip
+N29E010.hgt.zip
+N29E011.hgt.zip
+N29E012.hgt.zip
+N29E013.hgt.zip
+N29E014.hgt.zip
+N29E015.hgt.zip
+N29E016.hgt.zip
+N29E017.hgt.zip
+N29E018.hgt.zip
+N29E019.hgt.zip
+N29E020.hgt.zip
+N29E021.hgt.zip
+N29E022.hgt.zip
+N29E023.hgt.zip
+N29E024.hgt.zip
+N29E025.hgt.zip
+N29E026.hgt.zip
+N29E027.hgt.zip
+N29E028.hgt.zip
+N29E029.hgt.zip
+N29E030.hgt.zip
+N29E031.hgt.zip
+N29E032.hgt.zip
+N29E033.hgt.zip
+N29E034.hgt.zip
+N29E035.hgt.zip
+N29E036.hgt.zip
+N29E037.hgt.zip
+N29E038.hgt.zip
+N29E039.hgt.zip
+N29E040.hgt.zip
+N29E041.hgt.zip
+N29E042.hgt.zip
+N29E043.hgt.zip
+N29E044.hgt.zip
+N29E045.hgt.zip
+N29E046.hgt.zip
+N29E047.hgt.zip
+N29E048.hgt.zip
+N29E049.hgt.zip
+N29E050.hgt.zip
+N29E051.hgt.zip
+N29E052.hgt.zip
+N29E053.hgt.zip
+N29E054.hgt.zip
+N29E055.hgt.zip
+N29E056.hgt.zip
+N29E057.hgt.zip
+N29E058.hgt.zip
+N29E059.hgt.zip
+N29W001.hgt.zip
+N29W002.hgt.zip
+N29W003.hgt.zip
+N29W004.hgt.zip
+N29W005.hgt.zip
+N29W006.hgt.zip
+N29W007.hgt.zip
+N29W008.hgt.zip
+N29W009.hgt.zip
+N29W010.hgt.zip
+N29W011.hgt.zip
+N29W014.hgt.zip
+N30E000.hgt.zip
+N30E001.hgt.zip
+N30E002.hgt.zip
+N30E003.hgt.zip
+N30E004.hgt.zip
+N30E005.hgt.zip
+N30E006.hgt.zip
+N30E007.hgt.zip
+N30E008.hgt.zip
+N30E009.hgt.zip
+N30E010.hgt.zip
+N30E011.hgt.zip
+N30E012.hgt.zip
+N30E013.hgt.zip
+N30E014.hgt.zip
+N30E015.hgt.zip
+N30E016.hgt.zip
+N30E017.hgt.zip
+N30E018.hgt.zip
+N30E019.hgt.zip
+N30E020.hgt.zip
+N30E021.hgt.zip
+N30E022.hgt.zip
+N30E023.hgt.zip
+N30E024.hgt.zip
+N30E025.hgt.zip
+N30E026.hgt.zip
+N30E027.hgt.zip
+N30E028.hgt.zip
+N30E029.hgt.zip
+N30E030.hgt.zip
+N30E031.hgt.zip
+N30E032.hgt.zip
+N30E033.hgt.zip
+N30E034.hgt.zip
+N30E035.hgt.zip
+N30E036.hgt.zip
+N30E037.hgt.zip
+N30E038.hgt.zip
+N30E039.hgt.zip
+N30E040.hgt.zip
+N30E041.hgt.zip
+N30E042.hgt.zip
+N30E043.hgt.zip
+N30E044.hgt.zip
+N30E045.hgt.zip
+N30E046.hgt.zip
+N30E047.hgt.zip
+N30E048.hgt.zip
+N30E049.hgt.zip
+N30E050.hgt.zip
+N30E051.hgt.zip
+N30E052.hgt.zip
+N30E053.hgt.zip
+N30E054.hgt.zip
+N30E055.hgt.zip
+N30E056.hgt.zip
+N30E057.hgt.zip
+N30E058.hgt.zip
+N30E059.hgt.zip
+N30W001.hgt.zip
+N30W002.hgt.zip
+N30W003.hgt.zip
+N30W004.hgt.zip
+N30W005.hgt.zip
+N30W006.hgt.zip
+N30W007.hgt.zip
+N30W008.hgt.zip
+N30W009.hgt.zip
+N30W010.hgt.zip
+N30W016.hgt.zip
+N30W017.hgt.zip
+N31E000.hgt.zip
+N31E001.hgt.zip
+N31E002.hgt.zip
+N31E003.hgt.zip
+N31E004.hgt.zip
+N31E005.hgt.zip
+N31E006.hgt.zip
+N31E007.hgt.zip
+N31E008.hgt.zip
+N31E009.hgt.zip
+N31E010.hgt.zip
+N31E011.hgt.zip
+N31E012.hgt.zip
+N31E013.hgt.zip
+N31E014.hgt.zip
+N31E015.hgt.zip
+N31E016.hgt.zip
+N31E017.hgt.zip
+N31E019.hgt.zip
+N31E020.hgt.zip
+N31E021.hgt.zip
+N31E022.hgt.zip
+N31E023.hgt.zip
+N31E024.hgt.zip
+N31E025.hgt.zip
+N31E026.hgt.zip
+N31E027.hgt.zip
+N31E028.hgt.zip
+N31E029.hgt.zip
+N31E030.hgt.zip
+N31E031.hgt.zip
+N31E032.hgt.zip
+N31E033.hgt.zip
+N31E034.hgt.zip
+N31E035.hgt.zip
+N31E036.hgt.zip
+N31E037.hgt.zip
+N31E038.hgt.zip
+N31E039.hgt.zip
+N31E040.hgt.zip
+N31E041.hgt.zip
+N31E042.hgt.zip
+N31E043.hgt.zip
+N31E044.hgt.zip
+N31E045.hgt.zip
+N31E046.hgt.zip
+N31E047.hgt.zip
+N31E048.hgt.zip
+N31E049.hgt.zip
+N31E050.hgt.zip
+N31E051.hgt.zip
+N31E052.hgt.zip
+N31E053.hgt.zip
+N31E054.hgt.zip
+N31E055.hgt.zip
+N31E056.hgt.zip
+N31E057.hgt.zip
+N31E058.hgt.zip
+N31E059.hgt.zip
+N31W001.hgt.zip
+N31W002.hgt.zip
+N31W003.hgt.zip
+N31W004.hgt.zip
+N31W005.hgt.zip
+N31W006.hgt.zip
+N31W007.hgt.zip
+N31W008.hgt.zip
+N31W009.hgt.zip
+N31W010.hgt.zip
+N32E000.hgt.zip
+N32E001.hgt.zip
+N32E002.hgt.zip
+N32E003.hgt.zip
+N32E004.hgt.zip
+N32E005.hgt.zip
+N32E006.hgt.zip
+N32E007.hgt.zip
+N32E008.hgt.zip
+N32E009.hgt.zip
+N32E010.hgt.zip
+N32E011.hgt.zip
+N32E012.hgt.zip
+N32E013.hgt.zip
+N32E014.hgt.zip
+N32E015.hgt.zip
+N32E019.hgt.zip
+N32E020.hgt.zip
+N32E021.hgt.zip
+N32E022.hgt.zip
+N32E023.hgt.zip
+N32E024.hgt.zip
+N32E034.hgt.zip
+N32E035.hgt.zip
+N32E036.hgt.zip
+N32E037.hgt.zip
+N32E038.hgt.zip
+N32E039.hgt.zip
+N32E040.hgt.zip
+N32E041.hgt.zip
+N32E042.hgt.zip
+N32E043.hgt.zip
+N32E044.hgt.zip
+N32E045.hgt.zip
+N32E046.hgt.zip
+N32E047.hgt.zip
+N32E048.hgt.zip
+N32E049.hgt.zip
+N32E050.hgt.zip
+N32E051.hgt.zip
+N32E052.hgt.zip
+N32E053.hgt.zip
+N32E054.hgt.zip
+N32E055.hgt.zip
+N32E056.hgt.zip
+N32E057.hgt.zip
+N32E058.hgt.zip
+N32E059.hgt.zip
+N32W001.hgt.zip
+N32W002.hgt.zip
+N32W003.hgt.zip
+N32W004.hgt.zip
+N32W005.hgt.zip
+N32W006.hgt.zip
+N32W007.hgt.zip
+N32W008.hgt.zip
+N32W009.hgt.zip
+N32W010.hgt.zip
+N32W017.hgt.zip
+N32W018.hgt.zip
+N33E000.hgt.zip
+N33E001.hgt.zip
+N33E002.hgt.zip
+N33E003.hgt.zip
+N33E004.hgt.zip
+N33E005.hgt.zip
+N33E006.hgt.zip
+N33E007.hgt.zip
+N33E008.hgt.zip
+N33E009.hgt.zip
+N33E010.hgt.zip
+N33E011.hgt.zip
+N33E035.hgt.zip
+N33E036.hgt.zip
+N33E037.hgt.zip
+N33E038.hgt.zip
+N33E039.hgt.zip
+N33E040.hgt.zip
+N33E041.hgt.zip
+N33E042.hgt.zip
+N33E043.hgt.zip
+N33E044.hgt.zip
+N33E045.hgt.zip
+N33E046.hgt.zip
+N33E047.hgt.zip
+N33E048.hgt.zip
+N33E049.hgt.zip
+N33E050.hgt.zip
+N33E051.hgt.zip
+N33E052.hgt.zip
+N33E053.hgt.zip
+N33E054.hgt.zip
+N33E055.hgt.zip
+N33E056.hgt.zip
+N33E057.hgt.zip
+N33E058.hgt.zip
+N33E059.hgt.zip
+N33W001.hgt.zip
+N33W002.hgt.zip
+N33W003.hgt.zip
+N33W004.hgt.zip
+N33W005.hgt.zip
+N33W006.hgt.zip
+N33W007.hgt.zip
+N33W008.hgt.zip
+N33W009.hgt.zip
+N33W017.hgt.zip
+N34E000.hgt.zip
+N34E001.hgt.zip
+N34E002.hgt.zip
+N34E003.hgt.zip
+N34E004.hgt.zip
+N34E005.hgt.zip
+N34E006.hgt.zip
+N34E007.hgt.zip
+N34E008.hgt.zip
+N34E009.hgt.zip
+N34E010.hgt.zip
+N34E011.hgt.zip
+N34E023.hgt.zip
+N34E024.hgt.zip
+N34E025.hgt.zip
+N34E026.hgt.zip
+N34E032.hgt.zip
+N34E033.hgt.zip
+N34E034.hgt.zip
+N34E035.hgt.zip
+N34E036.hgt.zip
+N34E037.hgt.zip
+N34E038.hgt.zip
+N34E039.hgt.zip
+N34E040.hgt.zip
+N34E041.hgt.zip
+N34E042.hgt.zip
+N34E043.hgt.zip
+N34E044.hgt.zip
+N34E045.hgt.zip
+N34E046.hgt.zip
+N34E047.hgt.zip
+N34E048.hgt.zip
+N34E049.hgt.zip
+N34E050.hgt.zip
+N34E051.hgt.zip
+N34E052.hgt.zip
+N34E053.hgt.zip
+N34E054.hgt.zip
+N34E055.hgt.zip
+N34E056.hgt.zip
+N34E057.hgt.zip
+N34E058.hgt.zip
+N34E059.hgt.zip
+N34W001.hgt.zip
+N34W002.hgt.zip
+N34W003.hgt.zip
+N34W004.hgt.zip
+N34W005.hgt.zip
+N34W006.hgt.zip
+N34W007.hgt.zip
+N36W026.hgt.zip
+N37W025.hgt.zip
+N37W026.hgt.zip
+N38W028.hgt.zip
+N38W029.hgt.zip
+N39W028.hgt.zip
+N39W029.hgt.zip
+N39W032.hgt.zip
+S01E006.hgt.zip
+S01E008.hgt.zip
+S01E009.hgt.zip
+S01E010.hgt.zip
+S01E011.hgt.zip
+S01E012.hgt.zip
+S01E013.hgt.zip
+S01E014.hgt.zip
+S01E015.hgt.zip
+S01E016.hgt.zip
+S01E017.hgt.zip
+S01E018.hgt.zip
+S01E019.hgt.zip
+S01E020.hgt.zip
+S01E021.hgt.zip
+S01E022.hgt.zip
+S01E023.hgt.zip
+S01E024.hgt.zip
+S01E025.hgt.zip
+S01E026.hgt.zip
+S01E027.hgt.zip
+S01E028.hgt.zip
+S01E029.hgt.zip
+S01E030.hgt.zip
+S01E031.hgt.zip
+S01E032.hgt.zip
+S01E033.hgt.zip
+S01E034.hgt.zip
+S01E035.hgt.zip
+S01E036.hgt.zip
+S01E037.hgt.zip
+S01E038.hgt.zip
+S01E039.hgt.zip
+S01E040.hgt.zip
+S01E041.hgt.zip
+S01E042.hgt.zip
+S02E005.hgt.zip
+S02E008.hgt.zip
+S02E009.hgt.zip
+S02E010.hgt.zip
+S02E011.hgt.zip
+S02E012.hgt.zip
+S02E013.hgt.zip
+S02E014.hgt.zip
+S02E015.hgt.zip
+S02E016.hgt.zip
+S02E017.hgt.zip
+S02E018.hgt.zip
+S02E019.hgt.zip
+S02E020.hgt.zip
+S02E021.hgt.zip
+S02E022.hgt.zip
+S02E023.hgt.zip
+S02E024.hgt.zip
+S02E025.hgt.zip
+S02E026.hgt.zip
+S02E027.hgt.zip
+S02E028.hgt.zip
+S02E029.hgt.zip
+S02E030.hgt.zip
+S02E031.hgt.zip
+S02E032.hgt.zip
+S02E033.hgt.zip
+S02E034.hgt.zip
+S02E035.hgt.zip
+S02E036.hgt.zip
+S02E037.hgt.zip
+S02E038.hgt.zip
+S02E039.hgt.zip
+S02E040.hgt.zip
+S02E041.hgt.zip
+S02E042.hgt.zip
+S03E009.hgt.zip
+S03E010.hgt.zip
+S03E011.hgt.zip
+S03E012.hgt.zip
+S03E013.hgt.zip
+S03E014.hgt.zip
+S03E015.hgt.zip
+S03E016.hgt.zip
+S03E017.hgt.zip
+S03E018.hgt.zip
+S03E019.hgt.zip
+S03E020.hgt.zip
+S03E021.hgt.zip
+S03E022.hgt.zip
+S03E023.hgt.zip
+S03E024.hgt.zip
+S03E025.hgt.zip
+S03E026.hgt.zip
+S03E027.hgt.zip
+S03E028.hgt.zip
+S03E029.hgt.zip
+S03E030.hgt.zip
+S03E031.hgt.zip
+S03E032.hgt.zip
+S03E033.hgt.zip
+S03E034.hgt.zip
+S03E035.hgt.zip
+S03E036.hgt.zip
+S03E037.hgt.zip
+S03E038.hgt.zip
+S03E039.hgt.zip
+S03E040.hgt.zip
+S03E041.hgt.zip
+S04E010.hgt.zip
+S04E011.hgt.zip
+S04E012.hgt.zip
+S04E013.hgt.zip
+S04E014.hgt.zip
+S04E015.hgt.zip
+S04E016.hgt.zip
+S04E017.hgt.zip
+S04E018.hgt.zip
+S04E019.hgt.zip
+S04E020.hgt.zip
+S04E021.hgt.zip
+S04E022.hgt.zip
+S04E023.hgt.zip
+S04E024.hgt.zip
+S04E025.hgt.zip
+S04E026.hgt.zip
+S04E027.hgt.zip
+S04E028.hgt.zip
+S04E029.hgt.zip
+S04E030.hgt.zip
+S04E031.hgt.zip
+S04E032.hgt.zip
+S04E033.hgt.zip
+S04E034.hgt.zip
+S04E035.hgt.zip
+S04E036.hgt.zip
+S04E037.hgt.zip
+S04E038.hgt.zip
+S04E039.hgt.zip
+S04E040.hgt.zip
+S04E055.hgt.zip
+S05E011.hgt.zip
+S05E012.hgt.zip
+S05E013.hgt.zip
+S05E014.hgt.zip
+S05E015.hgt.zip
+S05E016.hgt.zip
+S05E017.hgt.zip
+S05E018.hgt.zip
+S05E019.hgt.zip
+S05E020.hgt.zip
+S05E021.hgt.zip
+S05E022.hgt.zip
+S05E023.hgt.zip
+S05E024.hgt.zip
+S05E025.hgt.zip
+S05E026.hgt.zip
+S05E027.hgt.zip
+S05E028.hgt.zip
+S05E029.hgt.zip
+S05E030.hgt.zip
+S05E031.hgt.zip
+S05E032.hgt.zip
+S05E033.hgt.zip
+S05E034.hgt.zip
+S05E035.hgt.zip
+S05E036.hgt.zip
+S05E037.hgt.zip
+S05E038.hgt.zip
+S05E039.hgt.zip
+S05E053.hgt.zip
+S05E055.hgt.zip
+S06E011.hgt.zip
+S06E012.hgt.zip
+S06E013.hgt.zip
+S06E014.hgt.zip
+S06E015.hgt.zip
+S06E016.hgt.zip
+S06E017.hgt.zip
+S06E018.hgt.zip
+S06E019.hgt.zip
+S06E020.hgt.zip
+S06E021.hgt.zip
+S06E022.hgt.zip
+S06E023.hgt.zip
+S06E024.hgt.zip
+S06E025.hgt.zip
+S06E026.hgt.zip
+S06E027.hgt.zip
+S06E028.hgt.zip
+S06E029.hgt.zip
+S06E030.hgt.zip
+S06E031.hgt.zip
+S06E032.hgt.zip
+S06E033.hgt.zip
+S06E034.hgt.zip
+S06E035.hgt.zip
+S06E036.hgt.zip
+S06E037.hgt.zip
+S06E038.hgt.zip
+S06E039.hgt.zip
+S06E053.hgt.zip
+S06E055.hgt.zip
+S07E012.hgt.zip
+S07E013.hgt.zip
+S07E014.hgt.zip
+S07E015.hgt.zip
+S07E016.hgt.zip
+S07E017.hgt.zip
+S07E018.hgt.zip
+S07E019.hgt.zip
+S07E020.hgt.zip
+S07E021.hgt.zip
+S07E022.hgt.zip
+S07E023.hgt.zip
+S07E024.hgt.zip
+S07E025.hgt.zip
+S07E026.hgt.zip
+S07E027.hgt.zip
+S07E028.hgt.zip
+S07E029.hgt.zip
+S07E030.hgt.zip
+S07E031.hgt.zip
+S07E032.hgt.zip
+S07E033.hgt.zip
+S07E034.hgt.zip
+S07E035.hgt.zip
+S07E036.hgt.zip
+S07E037.hgt.zip
+S07E038.hgt.zip
+S07E039.hgt.zip
+S07E052.hgt.zip
+S07E053.hgt.zip
+S08E012.hgt.zip
+S08E013.hgt.zip
+S08E014.hgt.zip
+S08E015.hgt.zip
+S08E016.hgt.zip
+S08E017.hgt.zip
+S08E018.hgt.zip
+S08E019.hgt.zip
+S08E020.hgt.zip
+S08E021.hgt.zip
+S08E022.hgt.zip
+S08E023.hgt.zip
+S08E024.hgt.zip
+S08E025.hgt.zip
+S08E026.hgt.zip
+S08E027.hgt.zip
+S08E028.hgt.zip
+S08E029.hgt.zip
+S08E030.hgt.zip
+S08E031.hgt.zip
+S08E032.hgt.zip
+S08E033.hgt.zip
+S08E034.hgt.zip
+S08E035.hgt.zip
+S08E036.hgt.zip
+S08E037.hgt.zip
+S08E038.hgt.zip
+S08E039.hgt.zip
+S08E052.hgt.zip
+S08E056.hgt.zip
+S09E013.hgt.zip
+S09E014.hgt.zip
+S09E015.hgt.zip
+S09E016.hgt.zip
+S09E017.hgt.zip
+S09E018.hgt.zip
+S09E019.hgt.zip
+S09E020.hgt.zip
+S09E021.hgt.zip
+S09E022.hgt.zip
+S09E023.hgt.zip
+S09E024.hgt.zip
+S09E025.hgt.zip
+S09E026.hgt.zip
+S09E027.hgt.zip
+S09E028.hgt.zip
+S09E029.hgt.zip
+S09E030.hgt.zip
+S09E031.hgt.zip
+S09E032.hgt.zip
+S09E033.hgt.zip
+S09E034.hgt.zip
+S09E035.hgt.zip
+S09E036.hgt.zip
+S09E037.hgt.zip
+S09E038.hgt.zip
+S09E039.hgt.zip
+S10E012.hgt.zip
+S10E013.hgt.zip
+S10E014.hgt.zip
+S10E015.hgt.zip
+S10E016.hgt.zip
+S10E017.hgt.zip
+S10E018.hgt.zip
+S10E019.hgt.zip
+S10E020.hgt.zip
+S10E021.hgt.zip
+S10E022.hgt.zip
+S10E023.hgt.zip
+S10E024.hgt.zip
+S10E025.hgt.zip
+S10E026.hgt.zip
+S10E027.hgt.zip
+S10E028.hgt.zip
+S10E029.hgt.zip
+S10E030.hgt.zip
+S10E031.hgt.zip
+S10E032.hgt.zip
+S10E033.hgt.zip
+S10E034.hgt.zip
+S10E035.hgt.zip
+S10E036.hgt.zip
+S10E037.hgt.zip
+S10E038.hgt.zip
+S10E039.hgt.zip
+S10E046.hgt.zip
+S10E047.hgt.zip
+S10E050.hgt.zip
+S10E051.hgt.zip
+S11E013.hgt.zip
+S11E014.hgt.zip
+S11E015.hgt.zip
+S11E016.hgt.zip
+S11E017.hgt.zip
+S11E018.hgt.zip
+S11E019.hgt.zip
+S11E020.hgt.zip
+S11E021.hgt.zip
+S11E022.hgt.zip
+S11E023.hgt.zip
+S11E024.hgt.zip
+S11E025.hgt.zip
+S11E026.hgt.zip
+S11E027.hgt.zip
+S11E028.hgt.zip
+S11E029.hgt.zip
+S11E030.hgt.zip
+S11E031.hgt.zip
+S11E032.hgt.zip
+S11E033.hgt.zip
+S11E034.hgt.zip
+S11E035.hgt.zip
+S11E036.hgt.zip
+S11E037.hgt.zip
+S11E038.hgt.zip
+S11E039.hgt.zip
+S11E040.hgt.zip
+S11E047.hgt.zip
+S11E051.hgt.zip
+S11E056.hgt.zip
+S12E013.hgt.zip
+S12E014.hgt.zip
+S12E015.hgt.zip
+S12E016.hgt.zip
+S12E017.hgt.zip
+S12E018.hgt.zip
+S12E019.hgt.zip
+S12E020.hgt.zip
+S12E021.hgt.zip
+S12E022.hgt.zip
+S12E023.hgt.zip
+S12E024.hgt.zip
+S12E025.hgt.zip
+S12E026.hgt.zip
+S12E027.hgt.zip
+S12E028.hgt.zip
+S12E029.hgt.zip
+S12E030.hgt.zip
+S12E031.hgt.zip
+S12E032.hgt.zip
+S12E033.hgt.zip
+S12E034.hgt.zip
+S12E035.hgt.zip
+S12E036.hgt.zip
+S12E037.hgt.zip
+S12E038.hgt.zip
+S12E039.hgt.zip
+S12E040.hgt.zip
+S12E043.hgt.zip
+S12E047.hgt.zip
+S12E049.hgt.zip
+S13E012.hgt.zip
+S13E013.hgt.zip
+S13E014.hgt.zip
+S13E015.hgt.zip
+S13E016.hgt.zip
+S13E017.hgt.zip
+S13E018.hgt.zip
+S13E019.hgt.zip
+S13E020.hgt.zip
+S13E021.hgt.zip
+S13E022.hgt.zip
+S13E023.hgt.zip
+S13E024.hgt.zip
+S13E025.hgt.zip
+S13E026.hgt.zip
+S13E027.hgt.zip
+S13E028.hgt.zip
+S13E029.hgt.zip
+S13E030.hgt.zip
+S13E031.hgt.zip
+S13E032.hgt.zip
+S13E033.hgt.zip
+S13E034.hgt.zip
+S13E035.hgt.zip
+S13E036.hgt.zip
+S13E037.hgt.zip
+S13E038.hgt.zip
+S13E039.hgt.zip
+S13E040.hgt.zip
+S13E043.hgt.zip
+S13E044.hgt.zip
+S13E045.hgt.zip
+S13E048.hgt.zip
+S13E049.hgt.zip
+S14E012.hgt.zip
+S14E013.hgt.zip
+S14E014.hgt.zip
+S14E015.hgt.zip
+S14E016.hgt.zip
+S14E017.hgt.zip
+S14E018.hgt.zip
+S14E019.hgt.zip
+S14E020.hgt.zip
+S14E021.hgt.zip
+S14E022.hgt.zip
+S14E023.hgt.zip
+S14E024.hgt.zip
+S14E025.hgt.zip
+S14E026.hgt.zip
+S14E027.hgt.zip
+S14E028.hgt.zip
+S14E029.hgt.zip
+S14E030.hgt.zip
+S14E031.hgt.zip
+S14E032.hgt.zip
+S14E033.hgt.zip
+S14E034.hgt.zip
+S14E035.hgt.zip
+S14E036.hgt.zip
+S14E037.hgt.zip
+S14E038.hgt.zip
+S14E039.hgt.zip
+S14E040.hgt.zip
+S14E045.hgt.zip
+S14E047.hgt.zip
+S14E048.hgt.zip
+S14E049.hgt.zip
+S14E050.hgt.zip
+S15E012.hgt.zip
+S15E013.hgt.zip
+S15E014.hgt.zip
+S15E015.hgt.zip
+S15E016.hgt.zip
+S15E017.hgt.zip
+S15E018.hgt.zip
+S15E019.hgt.zip
+S15E020.hgt.zip
+S15E021.hgt.zip
+S15E022.hgt.zip
+S15E023.hgt.zip
+S15E024.hgt.zip
+S15E025.hgt.zip
+S15E026.hgt.zip
+S15E027.hgt.zip
+S15E028.hgt.zip
+S15E029.hgt.zip
+S15E030.hgt.zip
+S15E031.hgt.zip
+S15E032.hgt.zip
+S15E033.hgt.zip
+S15E034.hgt.zip
+S15E035.hgt.zip
+S15E036.hgt.zip
+S15E037.hgt.zip
+S15E038.hgt.zip
+S15E039.hgt.zip
+S15E040.hgt.zip
+S15E047.hgt.zip
+S15E048.hgt.zip
+S15E049.hgt.zip
+S15E050.hgt.zip
+S16E011.hgt.zip
+S16E012.hgt.zip
+S16E013.hgt.zip
+S16E014.hgt.zip
+S16E015.hgt.zip
+S16E016.hgt.zip
+S16E017.hgt.zip
+S16E018.hgt.zip
+S16E019.hgt.zip
+S16E020.hgt.zip
+S16E021.hgt.zip
+S16E022.hgt.zip
+S16E023.hgt.zip
+S16E024.hgt.zip
+S16E025.hgt.zip
+S16E026.hgt.zip
+S16E027.hgt.zip
+S16E028.hgt.zip
+S16E029.hgt.zip
+S16E030.hgt.zip
+S16E031.hgt.zip
+S16E032.hgt.zip
+S16E033.hgt.zip
+S16E034.hgt.zip
+S16E035.hgt.zip
+S16E036.hgt.zip
+S16E037.hgt.zip
+S16E038.hgt.zip
+S16E039.hgt.zip
+S16E040.hgt.zip
+S16E045.hgt.zip
+S16E046.hgt.zip
+S16E047.hgt.zip
+S16E048.hgt.zip
+S16E049.hgt.zip
+S16E050.hgt.zip
+S16E054.hgt.zip
+S17E011.hgt.zip
+S17E012.hgt.zip
+S17E013.hgt.zip
+S17E014.hgt.zip
+S17E015.hgt.zip
+S17E016.hgt.zip
+S17E017.hgt.zip
+S17E018.hgt.zip
+S17E019.hgt.zip
+S17E020.hgt.zip
+S17E021.hgt.zip
+S17E022.hgt.zip
+S17E023.hgt.zip
+S17E024.hgt.zip
+S17E025.hgt.zip
+S17E026.hgt.zip
+S17E027.hgt.zip
+S17E028.hgt.zip
+S17E029.hgt.zip
+S17E030.hgt.zip
+S17E031.hgt.zip
+S17E032.hgt.zip
+S17E033.hgt.zip
+S17E034.hgt.zip
+S17E035.hgt.zip
+S17E036.hgt.zip
+S17E037.hgt.zip
+S17E038.hgt.zip
+S17E039.hgt.zip
+S17E040.hgt.zip
+S17E043.hgt.zip
+S17E044.hgt.zip
+S17E045.hgt.zip
+S17E046.hgt.zip
+S17E047.hgt.zip
+S17E048.hgt.zip
+S17E049.hgt.zip
+S17E050.hgt.zip
+S17E059.hgt.zip
+S18E011.hgt.zip
+S18E012.hgt.zip
+S18E013.hgt.zip
+S18E014.hgt.zip
+S18E015.hgt.zip
+S18E016.hgt.zip
+S18E017.hgt.zip
+S18E018.hgt.zip
+S18E019.hgt.zip
+S18E020.hgt.zip
+S18E021.hgt.zip
+S18E022.hgt.zip
+S18E023.hgt.zip
+S18E024.hgt.zip
+S18E025.hgt.zip
+S18E026.hgt.zip
+S18E027.hgt.zip
+S18E028.hgt.zip
+S18E029.hgt.zip
+S18E030.hgt.zip
+S18E031.hgt.zip
+S18E032.hgt.zip
+S18E033.hgt.zip
+S18E034.hgt.zip
+S18E035.hgt.zip
+S18E036.hgt.zip
+S18E037.hgt.zip
+S18E038.hgt.zip
+S18E039.hgt.zip
+S18E042.hgt.zip
+S18E043.hgt.zip
+S18E044.hgt.zip
+S18E045.hgt.zip
+S18E046.hgt.zip
+S18E047.hgt.zip
+S18E048.hgt.zip
+S18E049.hgt.zip
+S19E011.hgt.zip
+S19E012.hgt.zip
+S19E013.hgt.zip
+S19E014.hgt.zip
+S19E015.hgt.zip
+S19E016.hgt.zip
+S19E017.hgt.zip
+S19E018.hgt.zip
+S19E019.hgt.zip
+S19E020.hgt.zip
+S19E021.hgt.zip
+S19E022.hgt.zip
+S19E023.hgt.zip
+S19E024.hgt.zip
+S19E025.hgt.zip
+S19E026.hgt.zip
+S19E027.hgt.zip
+S19E028.hgt.zip
+S19E029.hgt.zip
+S19E030.hgt.zip
+S19E031.hgt.zip
+S19E032.hgt.zip
+S19E033.hgt.zip
+S19E034.hgt.zip
+S19E035.hgt.zip
+S19E036.hgt.zip
+S19E037.hgt.zip
+S19E043.hgt.zip
+S19E044.hgt.zip
+S19E045.hgt.zip
+S19E046.hgt.zip
+S19E047.hgt.zip
+S19E048.hgt.zip
+S19E049.hgt.zip
+S20E012.hgt.zip
+S20E013.hgt.zip
+S20E014.hgt.zip
+S20E015.hgt.zip
+S20E016.hgt.zip
+S20E017.hgt.zip
+S20E018.hgt.zip
+S20E019.hgt.zip
+S20E020.hgt.zip
+S20E021.hgt.zip
+S20E022.hgt.zip
+S20E023.hgt.zip
+S20E024.hgt.zip
+S20E025.hgt.zip
+S20E026.hgt.zip
+S20E027.hgt.zip
+S20E028.hgt.zip
+S20E029.hgt.zip
+S20E030.hgt.zip
+S20E031.hgt.zip
+S20E032.hgt.zip
+S20E033.hgt.zip
+S20E034.hgt.zip
+S20E035.hgt.zip
+S20E044.hgt.zip
+S20E045.hgt.zip
+S20E046.hgt.zip
+S20E047.hgt.zip
+S20E048.hgt.zip
+S20E049.hgt.zip
+S20E057.hgt.zip
+S20E063.hgt.zip
+S21E013.hgt.zip
+S21E014.hgt.zip
+S21E015.hgt.zip
+S21E016.hgt.zip
+S21E017.hgt.zip
+S21E018.hgt.zip
+S21E019.hgt.zip
+S21E020.hgt.zip
+S21E021.hgt.zip
+S21E022.hgt.zip
+S21E023.hgt.zip
+S21E024.hgt.zip
+S21E025.hgt.zip
+S21E026.hgt.zip
+S21E027.hgt.zip
+S21E028.hgt.zip
+S21E029.hgt.zip
+S21E030.hgt.zip
+S21E031.hgt.zip
+S21E032.hgt.zip
+S21E033.hgt.zip
+S21E034.hgt.zip
+S21E035.hgt.zip
+S21E043.hgt.zip
+S21E044.hgt.zip
+S21E045.hgt.zip
+S21E046.hgt.zip
+S21E047.hgt.zip
+S21E048.hgt.zip
+S21E055.hgt.zip
+S21E057.hgt.zip
+S22E013.hgt.zip
+S22E014.hgt.zip
+S22E015.hgt.zip
+S22E016.hgt.zip
+S22E017.hgt.zip
+S22E018.hgt.zip
+S22E019.hgt.zip
+S22E020.hgt.zip
+S22E021.hgt.zip
+S22E022.hgt.zip
+S22E023.hgt.zip
+S22E024.hgt.zip
+S22E025.hgt.zip
+S22E026.hgt.zip
+S22E027.hgt.zip
+S22E028.hgt.zip
+S22E029.hgt.zip
+S22E030.hgt.zip
+S22E031.hgt.zip
+S22E032.hgt.zip
+S22E033.hgt.zip
+S22E034.hgt.zip
+S22E035.hgt.zip
+S22E043.hgt.zip
+S22E044.hgt.zip
+S22E045.hgt.zip
+S22E046.hgt.zip
+S22E047.hgt.zip
+S22E048.hgt.zip
+S22E055.hgt.zip
+S23E014.hgt.zip
+S23E015.hgt.zip
+S23E016.hgt.zip
+S23E017.hgt.zip
+S23E018.hgt.zip
+S23E019.hgt.zip
+S23E020.hgt.zip
+S23E021.hgt.zip
+S23E022.hgt.zip
+S23E023.hgt.zip
+S23E024.hgt.zip
+S23E025.hgt.zip
+S23E026.hgt.zip
+S23E027.hgt.zip
+S23E028.hgt.zip
+S23E029.hgt.zip
+S23E030.hgt.zip
+S23E031.hgt.zip
+S23E032.hgt.zip
+S23E033.hgt.zip
+S23E034.hgt.zip
+S23E035.hgt.zip
+S23E040.hgt.zip
+S23E043.hgt.zip
+S23E044.hgt.zip
+S23E045.hgt.zip
+S23E046.hgt.zip
+S23E047.hgt.zip
+S23E048.hgt.zip
+S24E014.hgt.zip
+S24E015.hgt.zip
+S24E016.hgt.zip
+S24E017.hgt.zip
+S24E018.hgt.zip
+S24E019.hgt.zip
+S24E020.hgt.zip
+S24E021.hgt.zip
+S24E022.hgt.zip
+S24E023.hgt.zip
+S24E024.hgt.zip
+S24E025.hgt.zip
+S24E026.hgt.zip
+S24E027.hgt.zip
+S24E028.hgt.zip
+S24E029.hgt.zip
+S24E030.hgt.zip
+S24E031.hgt.zip
+S24E032.hgt.zip
+S24E033.hgt.zip
+S24E034.hgt.zip
+S24E035.hgt.zip
+S24E043.hgt.zip
+S24E044.hgt.zip
+S24E045.hgt.zip
+S24E046.hgt.zip
+S24E047.hgt.zip
+S25E014.hgt.zip
+S25E015.hgt.zip
+S25E016.hgt.zip
+S25E017.hgt.zip
+S25E018.hgt.zip
+S25E019.hgt.zip
+S25E020.hgt.zip
+S25E021.hgt.zip
+S25E022.hgt.zip
+S25E023.hgt.zip
+S25E024.hgt.zip
+S25E025.hgt.zip
+S25E026.hgt.zip
+S25E027.hgt.zip
+S25E028.hgt.zip
+S25E029.hgt.zip
+S25E030.hgt.zip
+S25E031.hgt.zip
+S25E032.hgt.zip
+S25E033.hgt.zip
+S25E034.hgt.zip
+S25E035.hgt.zip
+S25E043.hgt.zip
+S25E044.hgt.zip
+S25E045.hgt.zip
+S25E046.hgt.zip
+S25E047.hgt.zip
+S26E014.hgt.zip
+S26E015.hgt.zip
+S26E016.hgt.zip
+S26E017.hgt.zip
+S26E018.hgt.zip
+S26E019.hgt.zip
+S26E020.hgt.zip
+S26E021.hgt.zip
+S26E022.hgt.zip
+S26E023.hgt.zip
+S26E024.hgt.zip
+S26E025.hgt.zip
+S26E026.hgt.zip
+S26E027.hgt.zip
+S26E028.hgt.zip
+S26E029.hgt.zip
+S26E030.hgt.zip
+S26E031.hgt.zip
+S26E032.hgt.zip
+S26E033.hgt.zip
+S26E034.hgt.zip
+S26E044.hgt.zip
+S26E045.hgt.zip
+S26E046.hgt.zip
+S26E047.hgt.zip
+S27E014.hgt.zip
+S27E015.hgt.zip
+S27E016.hgt.zip
+S27E017.hgt.zip
+S27E018.hgt.zip
+S27E019.hgt.zip
+S27E020.hgt.zip
+S27E021.hgt.zip
+S27E022.hgt.zip
+S27E023.hgt.zip
+S27E024.hgt.zip
+S27E025.hgt.zip
+S27E026.hgt.zip
+S27E027.hgt.zip
+S27E028.hgt.zip
+S27E029.hgt.zip
+S27E030.hgt.zip
+S27E031.hgt.zip
+S27E032.hgt.zip
+S28E015.hgt.zip
+S28E016.hgt.zip
+S28E017.hgt.zip
+S28E018.hgt.zip
+S28E019.hgt.zip
+S28E020.hgt.zip
+S28E021.hgt.zip
+S28E022.hgt.zip
+S28E023.hgt.zip
+S28E024.hgt.zip
+S28E025.hgt.zip
+S28E026.hgt.zip
+S28E027.hgt.zip
+S28E028.hgt.zip
+S28E029.hgt.zip
+S28E030.hgt.zip
+S28E031.hgt.zip
+S28E032.hgt.zip
+S29E015.hgt.zip
+S29E016.hgt.zip
+S29E017.hgt.zip
+S29E018.hgt.zip
+S29E019.hgt.zip
+S29E020.hgt.zip
+S29E021.hgt.zip
+S29E022.hgt.zip
+S29E023.hgt.zip
+S29E024.hgt.zip
+S29E025.hgt.zip
+S29E026.hgt.zip
+S29E027.hgt.zip
+S29E028.hgt.zip
+S29E029.hgt.zip
+S29E030.hgt.zip
+S29E031.hgt.zip
+S29E032.hgt.zip
+S30E016.hgt.zip
+S30E017.hgt.zip
+S30E018.hgt.zip
+S30E019.hgt.zip
+S30E020.hgt.zip
+S30E021.hgt.zip
+S30E022.hgt.zip
+S30E023.hgt.zip
+S30E024.hgt.zip
+S30E025.hgt.zip
+S30E026.hgt.zip
+S30E027.hgt.zip
+S30E028.hgt.zip
+S30E029.hgt.zip
+S30E030.hgt.zip
+S30E031.hgt.zip
+S31E017.hgt.zip
+S31E018.hgt.zip
+S31E019.hgt.zip
+S31E020.hgt.zip
+S31E021.hgt.zip
+S31E022.hgt.zip
+S31E023.hgt.zip
+S31E024.hgt.zip
+S31E025.hgt.zip
+S31E026.hgt.zip
+S31E027.hgt.zip
+S31E028.hgt.zip
+S31E029.hgt.zip
+S31E030.hgt.zip
+S32E017.hgt.zip
+S32E018.hgt.zip
+S32E019.hgt.zip
+S32E020.hgt.zip
+S32E021.hgt.zip
+S32E022.hgt.zip
+S32E023.hgt.zip
+S32E024.hgt.zip
+S32E025.hgt.zip
+S32E026.hgt.zip
+S32E027.hgt.zip
+S32E028.hgt.zip
+S32E029.hgt.zip
+S32E030.hgt.zip
+S33E017.hgt.zip
+S33E018.hgt.zip
+S33E019.hgt.zip
+S33E020.hgt.zip
+S33E021.hgt.zip
+S33E022.hgt.zip
+S33E023.hgt.zip
+S33E024.hgt.zip
+S33E025.hgt.zip
+S33E026.hgt.zip
+S33E027.hgt.zip
+S33E028.hgt.zip
+S33E029.hgt.zip
+S34E017.hgt.zip
+S34E018.hgt.zip
+S34E019.hgt.zip
+S34E020.hgt.zip
+S34E021.hgt.zip
+S34E022.hgt.zip
+S34E023.hgt.zip
+S34E024.hgt.zip
+S34E025.hgt.zip
+S34E026.hgt.zip
+S34E027.hgt.zip
+S35E018.hgt.zip
+S35E019.hgt.zip
+S35E020.hgt.zip
+S35E021.hgt.zip
+S35E022.hgt.zip
+S35E023.hgt.zip
+S35E024.hgt.zip
+S35E025.hgt.zip
\ No newline at end of file
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/Africa_names.txt.zip b/core/src/main/resources/com/graphhopper/reader/dem/Africa_names.txt.zip
deleted file mode 100644
index 968a5c0c88..0000000000
Binary files a/core/src/main/resources/com/graphhopper/reader/dem/Africa_names.txt.zip and /dev/null differ
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/Australia_names.txt b/core/src/main/resources/com/graphhopper/reader/dem/Australia_names.txt
new file mode 100644
index 0000000000..6807afc20d
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/reader/dem/Australia_names.txt
@@ -0,0 +1,1060 @@
+S11E119.hgt.zip
+S11E120.hgt.zip
+S11E121.hgt.zip
+S11E122.hgt.zip
+S11E123.hgt.zip
+S11E124.hgt.zip
+S11E132.hgt.zip
+S11E133.hgt.zip
+S11E141.hgt.zip
+S11E142.hgt.zip
+S11E143.hgt.zip
+S11E147.hgt.zip
+S11E148.hgt.zip
+S11E149.hgt.zip
+S11E150.hgt.zip
+S11E151.hgt.zip
+S11E152.hgt.zip
+S11E153.hgt.zip
+S11E161.hgt.zip
+S11E162.hgt.zip
+S11E165.hgt.zip
+S11E166.hgt.zip
+S11E179.hgt.zip
+S11W140.hgt.zip
+S11W151.hgt.zip
+S11W161.hgt.zip
+S11W162.hgt.zip
+S11W166.hgt.zip
+S12E122.hgt.zip
+S12E130.hgt.zip
+S12E131.hgt.zip
+S12E132.hgt.zip
+S12E133.hgt.zip
+S12E134.hgt.zip
+S12E135.hgt.zip
+S12E136.hgt.zip
+S12E141.hgt.zip
+S12E142.hgt.zip
+S12E143.hgt.zip
+S12E144.hgt.zip
+S12E151.hgt.zip
+S12E152.hgt.zip
+S12E153.hgt.zip
+S12E154.hgt.zip
+S12E159.hgt.zip
+S12E160.hgt.zip
+S12E166.hgt.zip
+S12E169.hgt.zip
+S12E170.hgt.zip
+S12W152.hgt.zip
+S12W166.hgt.zip
+S12W172.hgt.zip
+S13E122.hgt.zip
+S13E123.hgt.zip
+S13E130.hgt.zip
+S13E131.hgt.zip
+S13E132.hgt.zip
+S13E133.hgt.zip
+S13E134.hgt.zip
+S13E135.hgt.zip
+S13E136.hgt.zip
+S13E141.hgt.zip
+S13E142.hgt.zip
+S13E143.hgt.zip
+S13E168.hgt.zip
+S13E176.hgt.zip
+S13E177.hgt.zip
+S14E125.hgt.zip
+S14E126.hgt.zip
+S14E127.hgt.zip
+S14E129.hgt.zip
+S14E130.hgt.zip
+S14E131.hgt.zip
+S14E132.hgt.zip
+S14E133.hgt.zip
+S14E134.hgt.zip
+S14E135.hgt.zip
+S14E136.hgt.zip
+S14E141.hgt.zip
+S14E142.hgt.zip
+S14E143.hgt.zip
+S14E144.hgt.zip
+S14E166.hgt.zip
+S14E167.hgt.zip
+S14W164.hgt.zip
+S14W172.hgt.zip
+S14W173.hgt.zip
+S14W177.hgt.zip
+S15E121.hgt.zip
+S15E123.hgt.zip
+S15E124.hgt.zip
+S15E125.hgt.zip
+S15E126.hgt.zip
+S15E127.hgt.zip
+S15E128.hgt.zip
+S15E129.hgt.zip
+S15E130.hgt.zip
+S15E131.hgt.zip
+S15E132.hgt.zip
+S15E133.hgt.zip
+S15E134.hgt.zip
+S15E135.hgt.zip
+S15E136.hgt.zip
+S15E141.hgt.zip
+S15E142.hgt.zip
+S15E143.hgt.zip
+S15E144.hgt.zip
+S15E145.hgt.zip
+S15E166.hgt.zip
+S15E167.hgt.zip
+S15E168.hgt.zip
+S15W139.hgt.zip
+S15W142.hgt.zip
+S15W145.hgt.zip
+S15W146.hgt.zip
+S15W147.hgt.zip
+S15W148.hgt.zip
+S15W149.hgt.zip
+S15W169.hgt.zip
+S15W170.hgt.zip
+S15W171.hgt.zip
+S15W172.hgt.zip
+S15W178.hgt.zip
+S15W179.hgt.zip
+S16E123.hgt.zip
+S16E124.hgt.zip
+S16E125.hgt.zip
+S16E126.hgt.zip
+S16E127.hgt.zip
+S16E128.hgt.zip
+S16E129.hgt.zip
+S16E130.hgt.zip
+S16E131.hgt.zip
+S16E132.hgt.zip
+S16E133.hgt.zip
+S16E134.hgt.zip
+S16E135.hgt.zip
+S16E136.hgt.zip
+S16E137.hgt.zip
+S16E141.hgt.zip
+S16E142.hgt.zip
+S16E143.hgt.zip
+S16E144.hgt.zip
+S16E145.hgt.zip
+S16E166.hgt.zip
+S16E167.hgt.zip
+S16E168.hgt.zip
+S16W141.hgt.zip
+S16W143.hgt.zip
+S16W145.hgt.zip
+S16W146.hgt.zip
+S16W147.hgt.zip
+S16W148.hgt.zip
+S16W149.hgt.zip
+S16W155.hgt.zip
+S16W174.hgt.zip
+S16W176.hgt.zip
+S16W180.hgt.zip
+S17E122.hgt.zip
+S17E123.hgt.zip
+S17E124.hgt.zip
+S17E125.hgt.zip
+S17E126.hgt.zip
+S17E127.hgt.zip
+S17E128.hgt.zip
+S17E129.hgt.zip
+S17E130.hgt.zip
+S17E131.hgt.zip
+S17E132.hgt.zip
+S17E133.hgt.zip
+S17E134.hgt.zip
+S17E135.hgt.zip
+S17E136.hgt.zip
+S17E137.hgt.zip
+S17E138.hgt.zip
+S17E139.hgt.zip
+S17E140.hgt.zip
+S17E141.hgt.zip
+S17E142.hgt.zip
+S17E143.hgt.zip
+S17E144.hgt.zip
+S17E145.hgt.zip
+S17E146.hgt.zip
+S17E149.hgt.zip
+S17E150.hgt.zip
+S17E167.hgt.zip
+S17E168.hgt.zip
+S17E177.hgt.zip
+S17E178.hgt.zip
+S17E179.hgt.zip
+S17W141.hgt.zip
+S17W142.hgt.zip
+S17W143.hgt.zip
+S17W144.hgt.zip
+S17W145.hgt.zip
+S17W146.hgt.zip
+S17W147.hgt.zip
+S17W150.hgt.zip
+S17W151.hgt.zip
+S17W152.hgt.zip
+S17W153.hgt.zip
+S17W154.hgt.zip
+S17W155.hgt.zip
+S17W180.hgt.zip
+S18E118.hgt.zip
+S18E119.hgt.zip
+S18E122.hgt.zip
+S18E123.hgt.zip
+S18E124.hgt.zip
+S18E125.hgt.zip
+S18E126.hgt.zip
+S18E127.hgt.zip
+S18E128.hgt.zip
+S18E129.hgt.zip
+S18E130.hgt.zip
+S18E131.hgt.zip
+S18E132.hgt.zip
+S18E133.hgt.zip
+S18E134.hgt.zip
+S18E135.hgt.zip
+S18E136.hgt.zip
+S18E137.hgt.zip
+S18E138.hgt.zip
+S18E139.hgt.zip
+S18E140.hgt.zip
+S18E141.hgt.zip
+S18E142.hgt.zip
+S18E143.hgt.zip
+S18E144.hgt.zip
+S18E145.hgt.zip
+S18E146.hgt.zip
+S18E148.hgt.zip
+S18E155.hgt.zip
+S18E168.hgt.zip
+S18E176.hgt.zip
+S18E177.hgt.zip
+S18E178.hgt.zip
+S18E179.hgt.zip
+S18W139.hgt.zip
+S18W141.hgt.zip
+S18W142.hgt.zip
+S18W143.hgt.zip
+S18W144.hgt.zip
+S18W145.hgt.zip
+S18W146.hgt.zip
+S18W149.hgt.zip
+S18W150.hgt.zip
+S18W151.hgt.zip
+S18W179.hgt.zip
+S18W180.hgt.zip
+S19E121.hgt.zip
+S19E122.hgt.zip
+S19E123.hgt.zip
+S19E124.hgt.zip
+S19E125.hgt.zip
+S19E126.hgt.zip
+S19E127.hgt.zip
+S19E128.hgt.zip
+S19E129.hgt.zip
+S19E130.hgt.zip
+S19E131.hgt.zip
+S19E132.hgt.zip
+S19E133.hgt.zip
+S19E134.hgt.zip
+S19E135.hgt.zip
+S19E136.hgt.zip
+S19E137.hgt.zip
+S19E138.hgt.zip
+S19E139.hgt.zip
+S19E140.hgt.zip
+S19E141.hgt.zip
+S19E142.hgt.zip
+S19E143.hgt.zip
+S19E144.hgt.zip
+S19E145.hgt.zip
+S19E146.hgt.zip
+S19E162.hgt.zip
+S19E163.hgt.zip
+S19E168.hgt.zip
+S19E169.hgt.zip
+S19E177.hgt.zip
+S19E178.hgt.zip
+S19E179.hgt.zip
+S19W137.hgt.zip
+S19W138.hgt.zip
+S19W139.hgt.zip
+S19W140.hgt.zip
+S19W141.hgt.zip
+S19W142.hgt.zip
+S19W143.hgt.zip
+S19W160.hgt.zip
+S19W164.hgt.zip
+S19W170.hgt.zip
+S19W174.hgt.zip
+S19W175.hgt.zip
+S19W179.hgt.zip
+S19W180.hgt.zip
+S20E118.hgt.zip
+S20E119.hgt.zip
+S20E120.hgt.zip
+S20E121.hgt.zip
+S20E122.hgt.zip
+S20E123.hgt.zip
+S20E124.hgt.zip
+S20E125.hgt.zip
+S20E126.hgt.zip
+S20E127.hgt.zip
+S20E128.hgt.zip
+S20E129.hgt.zip
+S20E130.hgt.zip
+S20E131.hgt.zip
+S20E132.hgt.zip
+S20E133.hgt.zip
+S20E134.hgt.zip
+S20E135.hgt.zip
+S20E136.hgt.zip
+S20E137.hgt.zip
+S20E138.hgt.zip
+S20E139.hgt.zip
+S20E140.hgt.zip
+S20E141.hgt.zip
+S20E142.hgt.zip
+S20E143.hgt.zip
+S20E144.hgt.zip
+S20E145.hgt.zip
+S20E146.hgt.zip
+S20E147.hgt.zip
+S20E148.hgt.zip
+S20E158.hgt.zip
+S20E163.hgt.zip
+S20E169.hgt.zip
+S20E170.hgt.zip
+S20E177.hgt.zip
+S20E178.hgt.zip
+S20E179.hgt.zip
+S20W139.hgt.zip
+S20W140.hgt.zip
+S20W141.hgt.zip
+S20W142.hgt.zip
+S20W145.hgt.zip
+S20W146.hgt.zip
+S20W158.hgt.zip
+S20W159.hgt.zip
+S20W170.hgt.zip
+S20W175.hgt.zip
+S20W176.hgt.zip
+S20W179.hgt.zip
+S20W180.hgt.zip
+S21E115.hgt.zip
+S21E116.hgt.zip
+S21E117.hgt.zip
+S21E118.hgt.zip
+S21E119.hgt.zip
+S21E120.hgt.zip
+S21E121.hgt.zip
+S21E122.hgt.zip
+S21E123.hgt.zip
+S21E124.hgt.zip
+S21E125.hgt.zip
+S21E126.hgt.zip
+S21E127.hgt.zip
+S21E128.hgt.zip
+S21E129.hgt.zip
+S21E130.hgt.zip
+S21E131.hgt.zip
+S21E132.hgt.zip
+S21E133.hgt.zip
+S21E134.hgt.zip
+S21E135.hgt.zip
+S21E136.hgt.zip
+S21E137.hgt.zip
+S21E138.hgt.zip
+S21E139.hgt.zip
+S21E140.hgt.zip
+S21E141.hgt.zip
+S21E142.hgt.zip
+S21E143.hgt.zip
+S21E144.hgt.zip
+S21E145.hgt.zip
+S21E146.hgt.zip
+S21E147.hgt.zip
+S21E148.hgt.zip
+S21E149.hgt.zip
+S21E150.hgt.zip
+S21E154.hgt.zip
+S21E163.hgt.zip
+S21E164.hgt.zip
+S21E165.hgt.zip
+S21E166.hgt.zip
+S21E167.hgt.zip
+S21E169.hgt.zip
+S21W139.hgt.zip
+S21W140.hgt.zip
+S21W144.hgt.zip
+S21W158.hgt.zip
+S21W159.hgt.zip
+S21W175.hgt.zip
+S21W176.hgt.zip
+S21W179.hgt.zip
+S22E113.hgt.zip
+S22E114.hgt.zip
+S22E115.hgt.zip
+S22E116.hgt.zip
+S22E117.hgt.zip
+S22E118.hgt.zip
+S22E119.hgt.zip
+S22E120.hgt.zip
+S22E121.hgt.zip
+S22E122.hgt.zip
+S22E123.hgt.zip
+S22E124.hgt.zip
+S22E125.hgt.zip
+S22E126.hgt.zip
+S22E127.hgt.zip
+S22E128.hgt.zip
+S22E129.hgt.zip
+S22E130.hgt.zip
+S22E131.hgt.zip
+S22E132.hgt.zip
+S22E133.hgt.zip
+S22E134.hgt.zip
+S22E135.hgt.zip
+S22E136.hgt.zip
+S22E137.hgt.zip
+S22E138.hgt.zip
+S22E139.hgt.zip
+S22E140.hgt.zip
+S22E141.hgt.zip
+S22E142.hgt.zip
+S22E143.hgt.zip
+S22E144.hgt.zip
+S22E145.hgt.zip
+S22E146.hgt.zip
+S22E147.hgt.zip
+S22E148.hgt.zip
+S22E149.hgt.zip
+S22E150.hgt.zip
+S22E151.hgt.zip
+S22E152.hgt.zip
+S22E153.hgt.zip
+S22E154.hgt.zip
+S22E155.hgt.zip
+S22E158.hgt.zip
+S22E164.hgt.zip
+S22E165.hgt.zip
+S22E166.hgt.zip
+S22E167.hgt.zip
+S22E168.hgt.zip
+S22W136.hgt.zip
+S22W137.hgt.zip
+S22W139.hgt.zip
+S22W140.hgt.zip
+S22W141.hgt.zip
+S22W155.hgt.zip
+S22W158.hgt.zip
+S22W160.hgt.zip
+S22W175.hgt.zip
+S22W176.hgt.zip
+S22W179.hgt.zip
+S23E113.hgt.zip
+S23E114.hgt.zip
+S23E115.hgt.zip
+S23E116.hgt.zip
+S23E117.hgt.zip
+S23E118.hgt.zip
+S23E119.hgt.zip
+S23E120.hgt.zip
+S23E121.hgt.zip
+S23E122.hgt.zip
+S23E123.hgt.zip
+S23E124.hgt.zip
+S23E125.hgt.zip
+S23E126.hgt.zip
+S23E127.hgt.zip
+S23E128.hgt.zip
+S23E129.hgt.zip
+S23E130.hgt.zip
+S23E131.hgt.zip
+S23E132.hgt.zip
+S23E133.hgt.zip
+S23E134.hgt.zip
+S23E135.hgt.zip
+S23E136.hgt.zip
+S23E137.hgt.zip
+S23E138.hgt.zip
+S23E139.hgt.zip
+S23E140.hgt.zip
+S23E141.hgt.zip
+S23E142.hgt.zip
+S23E143.hgt.zip
+S23E144.hgt.zip
+S23E145.hgt.zip
+S23E146.hgt.zip
+S23E147.hgt.zip
+S23E148.hgt.zip
+S23E149.hgt.zip
+S23E150.hgt.zip
+S23E152.hgt.zip
+S23E155.hgt.zip
+S23E165.hgt.zip
+S23E166.hgt.zip
+S23E167.hgt.zip
+S23E168.hgt.zip
+S23E171.hgt.zip
+S23E172.hgt.zip
+S23W135.hgt.zip
+S23W137.hgt.zip
+S23W139.hgt.zip
+S23W152.hgt.zip
+S23W153.hgt.zip
+S23W177.hgt.zip
+S24E113.hgt.zip
+S24E114.hgt.zip
+S24E115.hgt.zip
+S24E116.hgt.zip
+S24E117.hgt.zip
+S24E118.hgt.zip
+S24E119.hgt.zip
+S24E120.hgt.zip
+S24E121.hgt.zip
+S24E122.hgt.zip
+S24E123.hgt.zip
+S24E124.hgt.zip
+S24E125.hgt.zip
+S24E126.hgt.zip
+S24E127.hgt.zip
+S24E128.hgt.zip
+S24E129.hgt.zip
+S24E130.hgt.zip
+S24E131.hgt.zip
+S24E132.hgt.zip
+S24E133.hgt.zip
+S24E134.hgt.zip
+S24E135.hgt.zip
+S24E136.hgt.zip
+S24E137.hgt.zip
+S24E138.hgt.zip
+S24E139.hgt.zip
+S24E140.hgt.zip
+S24E141.hgt.zip
+S24E142.hgt.zip
+S24E143.hgt.zip
+S24E144.hgt.zip
+S24E145.hgt.zip
+S24E146.hgt.zip
+S24E147.hgt.zip
+S24E148.hgt.zip
+S24E149.hgt.zip
+S24E150.hgt.zip
+S24E151.hgt.zip
+S24E152.hgt.zip
+S24E155.hgt.zip
+S24W131.hgt.zip
+S24W135.hgt.zip
+S24W136.hgt.zip
+S24W138.hgt.zip
+S24W148.hgt.zip
+S24W150.hgt.zip
+S25E113.hgt.zip
+S25E114.hgt.zip
+S25E115.hgt.zip
+S25E116.hgt.zip
+S25E117.hgt.zip
+S25E118.hgt.zip
+S25E119.hgt.zip
+S25E120.hgt.zip
+S25E121.hgt.zip
+S25E122.hgt.zip
+S25E123.hgt.zip
+S25E124.hgt.zip
+S25E125.hgt.zip
+S25E126.hgt.zip
+S25E127.hgt.zip
+S25E128.hgt.zip
+S25E129.hgt.zip
+S25E130.hgt.zip
+S25E131.hgt.zip
+S25E132.hgt.zip
+S25E133.hgt.zip
+S25E134.hgt.zip
+S25E135.hgt.zip
+S25E136.hgt.zip
+S25E137.hgt.zip
+S25E138.hgt.zip
+S25E139.hgt.zip
+S25E140.hgt.zip
+S25E141.hgt.zip
+S25E142.hgt.zip
+S25E143.hgt.zip
+S25E144.hgt.zip
+S25E145.hgt.zip
+S25E146.hgt.zip
+S25E147.hgt.zip
+S25E148.hgt.zip
+S25E149.hgt.zip
+S25E150.hgt.zip
+S25E151.hgt.zip
+S25E152.hgt.zip
+S25E153.hgt.zip
+S25W125.hgt.zip
+S25W129.hgt.zip
+S26E112.hgt.zip
+S26E113.hgt.zip
+S26E114.hgt.zip
+S26E115.hgt.zip
+S26E116.hgt.zip
+S26E117.hgt.zip
+S26E118.hgt.zip
+S26E119.hgt.zip
+S26E120.hgt.zip
+S26E121.hgt.zip
+S26E122.hgt.zip
+S26E123.hgt.zip
+S26E124.hgt.zip
+S26E125.hgt.zip
+S26E126.hgt.zip
+S26E127.hgt.zip
+S26E128.hgt.zip
+S26E129.hgt.zip
+S26E130.hgt.zip
+S26E131.hgt.zip
+S26E132.hgt.zip
+S26E133.hgt.zip
+S26E134.hgt.zip
+S26E135.hgt.zip
+S26E136.hgt.zip
+S26E137.hgt.zip
+S26E138.hgt.zip
+S26E139.hgt.zip
+S26E140.hgt.zip
+S26E141.hgt.zip
+S26E142.hgt.zip
+S26E143.hgt.zip
+S26E144.hgt.zip
+S26E145.hgt.zip
+S26E146.hgt.zip
+S26E147.hgt.zip
+S26E148.hgt.zip
+S26E149.hgt.zip
+S26E150.hgt.zip
+S26E151.hgt.zip
+S26E152.hgt.zip
+S26E153.hgt.zip
+S26W131.hgt.zip
+S27E113.hgt.zip
+S27E114.hgt.zip
+S27E115.hgt.zip
+S27E116.hgt.zip
+S27E117.hgt.zip
+S27E118.hgt.zip
+S27E119.hgt.zip
+S27E120.hgt.zip
+S27E121.hgt.zip
+S27E122.hgt.zip
+S27E123.hgt.zip
+S27E124.hgt.zip
+S27E125.hgt.zip
+S27E126.hgt.zip
+S27E127.hgt.zip
+S27E128.hgt.zip
+S27E129.hgt.zip
+S27E130.hgt.zip
+S27E131.hgt.zip
+S27E132.hgt.zip
+S27E133.hgt.zip
+S27E134.hgt.zip
+S27E135.hgt.zip
+S27E136.hgt.zip
+S27E137.hgt.zip
+S27E138.hgt.zip
+S27E139.hgt.zip
+S27E140.hgt.zip
+S27E141.hgt.zip
+S27E142.hgt.zip
+S27E143.hgt.zip
+S27E144.hgt.zip
+S27E145.hgt.zip
+S27E146.hgt.zip
+S27E147.hgt.zip
+S27E148.hgt.zip
+S27E149.hgt.zip
+S27E150.hgt.zip
+S27E151.hgt.zip
+S27E152.hgt.zip
+S27E153.hgt.zip
+S27W106.hgt.zip
+S28E113.hgt.zip
+S28E114.hgt.zip
+S28E115.hgt.zip
+S28E116.hgt.zip
+S28E117.hgt.zip
+S28E118.hgt.zip
+S28E119.hgt.zip
+S28E120.hgt.zip
+S28E121.hgt.zip
+S28E122.hgt.zip
+S28E123.hgt.zip
+S28E124.hgt.zip
+S28E125.hgt.zip
+S28E126.hgt.zip
+S28E127.hgt.zip
+S28E128.hgt.zip
+S28E129.hgt.zip
+S28E130.hgt.zip
+S28E131.hgt.zip
+S28E132.hgt.zip
+S28E133.hgt.zip
+S28E134.hgt.zip
+S28E135.hgt.zip
+S28E136.hgt.zip
+S28E137.hgt.zip
+S28E138.hgt.zip
+S28E139.hgt.zip
+S28E140.hgt.zip
+S28E141.hgt.zip
+S28E142.hgt.zip
+S28E143.hgt.zip
+S28E144.hgt.zip
+S28E145.hgt.zip
+S28E146.hgt.zip
+S28E147.hgt.zip
+S28E148.hgt.zip
+S28E149.hgt.zip
+S28E150.hgt.zip
+S28E151.hgt.zip
+S28E152.hgt.zip
+S28E153.hgt.zip
+S28W110.hgt.zip
+S28W144.hgt.zip
+S28W145.hgt.zip
+S29E113.hgt.zip
+S29E114.hgt.zip
+S29E115.hgt.zip
+S29E116.hgt.zip
+S29E117.hgt.zip
+S29E118.hgt.zip
+S29E119.hgt.zip
+S29E120.hgt.zip
+S29E121.hgt.zip
+S29E122.hgt.zip
+S29E123.hgt.zip
+S29E124.hgt.zip
+S29E125.hgt.zip
+S29E126.hgt.zip
+S29E127.hgt.zip
+S29E128.hgt.zip
+S29E129.hgt.zip
+S29E130.hgt.zip
+S29E131.hgt.zip
+S29E132.hgt.zip
+S29E133.hgt.zip
+S29E134.hgt.zip
+S29E135.hgt.zip
+S29E136.hgt.zip
+S29E137.hgt.zip
+S29E138.hgt.zip
+S29E139.hgt.zip
+S29E140.hgt.zip
+S29E141.hgt.zip
+S29E142.hgt.zip
+S29E143.hgt.zip
+S29E144.hgt.zip
+S29E145.hgt.zip
+S29E146.hgt.zip
+S29E147.hgt.zip
+S29E148.hgt.zip
+S29E149.hgt.zip
+S29E150.hgt.zip
+S29E151.hgt.zip
+S29E152.hgt.zip
+S29E153.hgt.zip
+S30E114.hgt.zip
+S30E115.hgt.zip
+S30E116.hgt.zip
+S30E117.hgt.zip
+S30E118.hgt.zip
+S30E119.hgt.zip
+S30E120.hgt.zip
+S30E121.hgt.zip
+S30E122.hgt.zip
+S30E123.hgt.zip
+S30E124.hgt.zip
+S30E125.hgt.zip
+S30E126.hgt.zip
+S30E127.hgt.zip
+S30E128.hgt.zip
+S30E129.hgt.zip
+S30E130.hgt.zip
+S30E131.hgt.zip
+S30E132.hgt.zip
+S30E133.hgt.zip
+S30E134.hgt.zip
+S30E135.hgt.zip
+S30E136.hgt.zip
+S30E137.hgt.zip
+S30E138.hgt.zip
+S30E139.hgt.zip
+S30E140.hgt.zip
+S30E141.hgt.zip
+S30E142.hgt.zip
+S30E143.hgt.zip
+S30E144.hgt.zip
+S30E145.hgt.zip
+S30E146.hgt.zip
+S30E147.hgt.zip
+S30E148.hgt.zip
+S30E149.hgt.zip
+S30E150.hgt.zip
+S30E151.hgt.zip
+S30E152.hgt.zip
+S30E153.hgt.zip
+S31E114.hgt.zip
+S31E115.hgt.zip
+S31E116.hgt.zip
+S31E117.hgt.zip
+S31E118.hgt.zip
+S31E119.hgt.zip
+S31E120.hgt.zip
+S31E121.hgt.zip
+S31E122.hgt.zip
+S31E123.hgt.zip
+S31E124.hgt.zip
+S31E125.hgt.zip
+S31E126.hgt.zip
+S31E127.hgt.zip
+S31E128.hgt.zip
+S31E129.hgt.zip
+S31E130.hgt.zip
+S31E131.hgt.zip
+S31E132.hgt.zip
+S31E133.hgt.zip
+S31E134.hgt.zip
+S31E135.hgt.zip
+S31E136.hgt.zip
+S31E137.hgt.zip
+S31E138.hgt.zip
+S31E139.hgt.zip
+S31E140.hgt.zip
+S31E141.hgt.zip
+S31E142.hgt.zip
+S31E143.hgt.zip
+S31E144.hgt.zip
+S31E145.hgt.zip
+S31E146.hgt.zip
+S31E147.hgt.zip
+S31E148.hgt.zip
+S31E149.hgt.zip
+S31E150.hgt.zip
+S31E151.hgt.zip
+S31E152.hgt.zip
+S31E153.hgt.zip
+S32E115.hgt.zip
+S32E116.hgt.zip
+S32E117.hgt.zip
+S32E118.hgt.zip
+S32E119.hgt.zip
+S32E120.hgt.zip
+S32E121.hgt.zip
+S32E122.hgt.zip
+S32E123.hgt.zip
+S32E124.hgt.zip
+S32E125.hgt.zip
+S32E126.hgt.zip
+S32E127.hgt.zip
+S32E128.hgt.zip
+S32E129.hgt.zip
+S32E130.hgt.zip
+S32E131.hgt.zip
+S32E132.hgt.zip
+S32E133.hgt.zip
+S32E134.hgt.zip
+S32E135.hgt.zip
+S32E136.hgt.zip
+S32E137.hgt.zip
+S32E138.hgt.zip
+S32E139.hgt.zip
+S32E140.hgt.zip
+S32E141.hgt.zip
+S32E142.hgt.zip
+S32E143.hgt.zip
+S32E144.hgt.zip
+S32E145.hgt.zip
+S32E146.hgt.zip
+S32E147.hgt.zip
+S32E148.hgt.zip
+S32E149.hgt.zip
+S32E150.hgt.zip
+S32E151.hgt.zip
+S32E152.hgt.zip
+S32E153.hgt.zip
+S32E159.hgt.zip
+S33E115.hgt.zip
+S33E116.hgt.zip
+S33E117.hgt.zip
+S33E118.hgt.zip
+S33E119.hgt.zip
+S33E120.hgt.zip
+S33E121.hgt.zip
+S33E122.hgt.zip
+S33E123.hgt.zip
+S33E124.hgt.zip
+S33E125.hgt.zip
+S33E126.hgt.zip
+S33E127.hgt.zip
+S33E128.hgt.zip
+S33E132.hgt.zip
+S33E133.hgt.zip
+S33E134.hgt.zip
+S33E135.hgt.zip
+S33E136.hgt.zip
+S33E137.hgt.zip
+S33E138.hgt.zip
+S33E139.hgt.zip
+S33E140.hgt.zip
+S33E141.hgt.zip
+S33E142.hgt.zip
+S33E143.hgt.zip
+S33E144.hgt.zip
+S33E145.hgt.zip
+S33E146.hgt.zip
+S33E147.hgt.zip
+S33E148.hgt.zip
+S33E149.hgt.zip
+S33E150.hgt.zip
+S33E151.hgt.zip
+S33E152.hgt.zip
+S34E114.hgt.zip
+S34E115.hgt.zip
+S34E116.hgt.zip
+S34E117.hgt.zip
+S34E118.hgt.zip
+S34E119.hgt.zip
+S34E120.hgt.zip
+S34E121.hgt.zip
+S34E122.hgt.zip
+S34E123.hgt.zip
+S34E124.hgt.zip
+S34E134.hgt.zip
+S34E135.hgt.zip
+S34E136.hgt.zip
+S34E137.hgt.zip
+S34E138.hgt.zip
+S34E139.hgt.zip
+S34E140.hgt.zip
+S34E141.hgt.zip
+S34E142.hgt.zip
+S34E143.hgt.zip
+S34E144.hgt.zip
+S34E145.hgt.zip
+S34E146.hgt.zip
+S34E147.hgt.zip
+S34E148.hgt.zip
+S34E149.hgt.zip
+S34E150.hgt.zip
+S34E151.hgt.zip
+S35E114.hgt.zip
+S35E115.hgt.zip
+S35E116.hgt.zip
+S35E117.hgt.zip
+S35E118.hgt.zip
+S35E119.hgt.zip
+S35E120.hgt.zip
+S35E121.hgt.zip
+S35E122.hgt.zip
+S35E123.hgt.zip
+S35E134.hgt.zip
+S35E135.hgt.zip
+S35E136.hgt.zip
+S35E137.hgt.zip
+S35E138.hgt.zip
+S35E139.hgt.zip
+S35E140.hgt.zip
+S35E141.hgt.zip
+S35E142.hgt.zip
+S35E143.hgt.zip
+S35E144.hgt.zip
+S35E145.hgt.zip
+S35E146.hgt.zip
+S35E147.hgt.zip
+S35E148.hgt.zip
+S35E149.hgt.zip
+S35E150.hgt.zip
+S35E151.hgt.zip
+S36E116.hgt.zip
+S36E117.hgt.zip
+S36E118.hgt.zip
+S36E135.hgt.zip
+S36E136.hgt.zip
+S36E137.hgt.zip
+S36E138.hgt.zip
+S36E139.hgt.zip
+S36E140.hgt.zip
+S36E141.hgt.zip
+S36E142.hgt.zip
+S36E143.hgt.zip
+S36E144.hgt.zip
+S36E145.hgt.zip
+S36E146.hgt.zip
+S36E147.hgt.zip
+S36E148.hgt.zip
+S36E149.hgt.zip
+S36E150.hgt.zip
+S37E136.hgt.zip
+S37E137.hgt.zip
+S37E139.hgt.zip
+S37E140.hgt.zip
+S37E141.hgt.zip
+S37E142.hgt.zip
+S37E143.hgt.zip
+S37E144.hgt.zip
+S37E145.hgt.zip
+S37E146.hgt.zip
+S37E147.hgt.zip
+S37E148.hgt.zip
+S37E149.hgt.zip
+S37E150.hgt.zip
+S38E139.hgt.zip
+S38E140.hgt.zip
+S38E141.hgt.zip
+S38E142.hgt.zip
+S38E143.hgt.zip
+S38E144.hgt.zip
+S38E145.hgt.zip
+S38E146.hgt.zip
+S38E147.hgt.zip
+S38E148.hgt.zip
+S38E149.hgt.zip
+S38E150.hgt.zip
+S39E140.hgt.zip
+S39E141.hgt.zip
+S39E142.hgt.zip
+S39E143.hgt.zip
+S39E144.hgt.zip
+S39E145.hgt.zip
+S39E146.hgt.zip
+S39E147.hgt.zip
+S40E143.hgt.zip
+S40E144.hgt.zip
+S40E146.hgt.zip
+S40E147.hgt.zip
+S40E148.hgt.zip
+S41E143.hgt.zip
+S41E144.hgt.zip
+S41E145.hgt.zip
+S41E146.hgt.zip
+S41E147.hgt.zip
+S41E148.hgt.zip
+S42E144.hgt.zip
+S42E145.hgt.zip
+S42E146.hgt.zip
+S42E147.hgt.zip
+S42E148.hgt.zip
+S43E145.hgt.zip
+S43E146.hgt.zip
+S43E147.hgt.zip
+S43E148.hgt.zip
+S44E145.hgt.zip
+S44E146.hgt.zip
+S44E147.hgt.zip
+S44E148.hgt.zip
\ No newline at end of file
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/Australia_names.txt.zip b/core/src/main/resources/com/graphhopper/reader/dem/Australia_names.txt.zip
deleted file mode 100644
index 8b0b0b3ab5..0000000000
Binary files a/core/src/main/resources/com/graphhopper/reader/dem/Australia_names.txt.zip and /dev/null differ
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/Eurasia_names.txt b/core/src/main/resources/com/graphhopper/reader/dem/Eurasia_names.txt
new file mode 100644
index 0000000000..d4e1308cd8
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/reader/dem/Eurasia_names.txt
@@ -0,0 +1,5876 @@
+N00E072.hgt.zip
+N00E073.hgt.zip
+N00E097.hgt.zip
+N00E098.hgt.zip
+N00E099.hgt.zip
+N00E100.hgt.zip
+N00E101.hgt.zip
+N00E102.hgt.zip
+N00E103.hgt.zip
+N00E104.hgt.zip
+N00E106.hgt.zip
+N00E107.hgt.zip
+N00E108.hgt.zip
+N00E109.hgt.zip
+N00E110.hgt.zip
+N00E111.hgt.zip
+N00E112.hgt.zip
+N00E113.hgt.zip
+N00E114.hgt.zip
+N00E115.hgt.zip
+N00E116.hgt.zip
+N00E117.hgt.zip
+N00E118.hgt.zip
+N00E119.hgt.zip
+N00E120.hgt.zip
+N00E121.hgt.zip
+N00E122.hgt.zip
+N00E123.hgt.zip
+N00E124.hgt.zip
+N00E126.hgt.zip
+N00E127.hgt.zip
+N00E128.hgt.zip
+N00E129.hgt.zip
+N00E130.hgt.zip
+N00E131.hgt.zip
+N00E134.hgt.zip
+N00E172.hgt.zip
+N00E173.hgt.zip
+N00W177.hgt.zip
+N01E073.hgt.zip
+N01E097.hgt.zip
+N01E098.hgt.zip
+N01E099.hgt.zip
+N01E100.hgt.zip
+N01E101.hgt.zip
+N01E102.hgt.zip
+N01E103.hgt.zip
+N01E104.hgt.zip
+N01E106.hgt.zip
+N01E107.hgt.zip
+N01E108.hgt.zip
+N01E109.hgt.zip
+N01E110.hgt.zip
+N01E111.hgt.zip
+N01E112.hgt.zip
+N01E113.hgt.zip
+N01E114.hgt.zip
+N01E115.hgt.zip
+N01E116.hgt.zip
+N01E117.hgt.zip
+N01E118.hgt.zip
+N01E119.hgt.zip
+N01E120.hgt.zip
+N01E121.hgt.zip
+N01E122.hgt.zip
+N01E124.hgt.zip
+N01E125.hgt.zip
+N01E126.hgt.zip
+N01E127.hgt.zip
+N01E128.hgt.zip
+N01E131.hgt.zip
+N01E154.hgt.zip
+N01E172.hgt.zip
+N01E173.hgt.zip
+N01W158.hgt.zip
+N02E072.hgt.zip
+N02E073.hgt.zip
+N02E095.hgt.zip
+N02E096.hgt.zip
+N02E097.hgt.zip
+N02E098.hgt.zip
+N02E099.hgt.zip
+N02E100.hgt.zip
+N02E101.hgt.zip
+N02E102.hgt.zip
+N02E103.hgt.zip
+N02E104.hgt.zip
+N02E105.hgt.zip
+N02E106.hgt.zip
+N02E107.hgt.zip
+N02E108.hgt.zip
+N02E109.hgt.zip
+N02E111.hgt.zip
+N02E112.hgt.zip
+N02E113.hgt.zip
+N02E114.hgt.zip
+N02E115.hgt.zip
+N02E116.hgt.zip
+N02E117.hgt.zip
+N02E118.hgt.zip
+N02E125.hgt.zip
+N02E127.hgt.zip
+N02E128.hgt.zip
+N02E131.hgt.zip
+N02E173.hgt.zip
+N02W158.hgt.zip
+N03E072.hgt.zip
+N03E073.hgt.zip
+N03E095.hgt.zip
+N03E096.hgt.zip
+N03E097.hgt.zip
+N03E098.hgt.zip
+N03E099.hgt.zip
+N03E100.hgt.zip
+N03E101.hgt.zip
+N03E102.hgt.zip
+N03E103.hgt.zip
+N03E105.hgt.zip
+N03E106.hgt.zip
+N03E107.hgt.zip
+N03E108.hgt.zip
+N03E112.hgt.zip
+N03E113.hgt.zip
+N03E114.hgt.zip
+N03E115.hgt.zip
+N03E116.hgt.zip
+N03E117.hgt.zip
+N03E125.hgt.zip
+N03E126.hgt.zip
+N03E131.hgt.zip
+N03E154.hgt.zip
+N03E172.hgt.zip
+N03E173.hgt.zip
+N03W160.hgt.zip
+N04E072.hgt.zip
+N04E073.hgt.zip
+N04E095.hgt.zip
+N04E096.hgt.zip
+N04E097.hgt.zip
+N04E098.hgt.zip
+N04E100.hgt.zip
+N04E101.hgt.zip
+N04E102.hgt.zip
+N04E103.hgt.zip
+N04E107.hgt.zip
+N04E108.hgt.zip
+N04E113.hgt.zip
+N04E114.hgt.zip
+N04E115.hgt.zip
+N04E116.hgt.zip
+N04E117.hgt.zip
+N04E118.hgt.zip
+N04E119.hgt.zip
+N04E125.hgt.zip
+N04E126.hgt.zip
+N04E127.hgt.zip
+N04E131.hgt.zip
+N04E132.hgt.zip
+N04E168.hgt.zip
+N04W161.hgt.zip
+N05E072.hgt.zip
+N05E073.hgt.zip
+N05E080.hgt.zip
+N05E094.hgt.zip
+N05E095.hgt.zip
+N05E096.hgt.zip
+N05E097.hgt.zip
+N05E100.hgt.zip
+N05E101.hgt.zip
+N05E102.hgt.zip
+N05E103.hgt.zip
+N05E114.hgt.zip
+N05E115.hgt.zip
+N05E116.hgt.zip
+N05E117.hgt.zip
+N05E118.hgt.zip
+N05E119.hgt.zip
+N05E120.hgt.zip
+N05E121.hgt.zip
+N05E124.hgt.zip
+N05E125.hgt.zip
+N05E126.hgt.zip
+N05E132.hgt.zip
+N05E153.hgt.zip
+N05E157.hgt.zip
+N05E162.hgt.zip
+N05E163.hgt.zip
+N05E168.hgt.zip
+N05E169.hgt.zip
+N05E172.hgt.zip
+N05W163.hgt.zip
+N06E072.hgt.zip
+N06E073.hgt.zip
+N06E079.hgt.zip
+N06E080.hgt.zip
+N06E081.hgt.zip
+N06E093.hgt.zip
+N06E095.hgt.zip
+N06E099.hgt.zip
+N06E100.hgt.zip
+N06E101.hgt.zip
+N06E102.hgt.zip
+N06E115.hgt.zip
+N06E116.hgt.zip
+N06E117.hgt.zip
+N06E118.hgt.zip
+N06E120.hgt.zip
+N06E121.hgt.zip
+N06E122.hgt.zip
+N06E123.hgt.zip
+N06E124.hgt.zip
+N06E125.hgt.zip
+N06E126.hgt.zip
+N06E134.hgt.zip
+N06E143.hgt.zip
+N06E149.hgt.zip
+N06E151.hgt.zip
+N06E152.hgt.zip
+N06E157.hgt.zip
+N06E158.hgt.zip
+N06E159.hgt.zip
+N06E160.hgt.zip
+N06E169.hgt.zip
+N06E171.hgt.zip
+N06E172.hgt.zip
+N06W163.hgt.zip
+N07E072.hgt.zip
+N07E073.hgt.zip
+N07E079.hgt.zip
+N07E080.hgt.zip
+N07E081.hgt.zip
+N07E093.hgt.zip
+N07E098.hgt.zip
+N07E099.hgt.zip
+N07E100.hgt.zip
+N07E113.hgt.zip
+N07E116.hgt.zip
+N07E117.hgt.zip
+N07E118.hgt.zip
+N07E121.hgt.zip
+N07E122.hgt.zip
+N07E123.hgt.zip
+N07E124.hgt.zip
+N07E125.hgt.zip
+N07E126.hgt.zip
+N07E134.hgt.zip
+N07E143.hgt.zip
+N07E144.hgt.zip
+N07E145.hgt.zip
+N07E146.hgt.zip
+N07E147.hgt.zip
+N07E149.hgt.zip
+N07E151.hgt.zip
+N07E152.hgt.zip
+N07E155.hgt.zip
+N07E157.hgt.zip
+N07E158.hgt.zip
+N07E168.hgt.zip
+N07E171.hgt.zip
+N08E073.hgt.zip
+N08E076.hgt.zip
+N08E077.hgt.zip
+N08E078.hgt.zip
+N08E079.hgt.zip
+N08E080.hgt.zip
+N08E081.hgt.zip
+N08E092.hgt.zip
+N08E093.hgt.zip
+N08E097.hgt.zip
+N08E098.hgt.zip
+N08E099.hgt.zip
+N08E100.hgt.zip
+N08E104.hgt.zip
+N08E105.hgt.zip
+N08E106.hgt.zip
+N08E111.hgt.zip
+N08E116.hgt.zip
+N08E117.hgt.zip
+N08E118.hgt.zip
+N08E122.hgt.zip
+N08E123.hgt.zip
+N08E124.hgt.zip
+N08E125.hgt.zip
+N08E126.hgt.zip
+N08E134.hgt.zip
+N08E137.hgt.zip
+N08E140.hgt.zip
+N08E144.hgt.zip
+N08E146.hgt.zip
+N08E147.hgt.zip
+N08E149.hgt.zip
+N08E150.hgt.zip
+N08E151.hgt.zip
+N08E152.hgt.zip
+N08E154.hgt.zip
+N08E165.hgt.zip
+N08E166.hgt.zip
+N08E167.hgt.zip
+N08E168.hgt.zip
+N08E170.hgt.zip
+N08E171.hgt.zip
+N09E076.hgt.zip
+N09E077.hgt.zip
+N09E078.hgt.zip
+N09E079.hgt.zip
+N09E080.hgt.zip
+N09E092.hgt.zip
+N09E097.hgt.zip
+N09E098.hgt.zip
+N09E099.hgt.zip
+N09E100.hgt.zip
+N09E102.hgt.zip
+N09E103.hgt.zip
+N09E104.hgt.zip
+N09E105.hgt.zip
+N09E106.hgt.zip
+N09E109.hgt.zip
+N09E117.hgt.zip
+N09E118.hgt.zip
+N09E119.hgt.zip
+N09E120.hgt.zip
+N09E121.hgt.zip
+N09E122.hgt.zip
+N09E123.hgt.zip
+N09E124.hgt.zip
+N09E125.hgt.zip
+N09E126.hgt.zip
+N09E138.hgt.zip
+N09E139.hgt.zip
+N09E140.hgt.zip
+N09E145.hgt.zip
+N09E160.hgt.zip
+N09E165.hgt.zip
+N09E166.hgt.zip
+N09E167.hgt.zip
+N09E169.hgt.zip
+N09E170.hgt.zip
+N10E072.hgt.zip
+N10E073.hgt.zip
+N10E075.hgt.zip
+N10E076.hgt.zip
+N10E077.hgt.zip
+N10E078.hgt.zip
+N10E079.hgt.zip
+N10E092.hgt.zip
+N10E097.hgt.zip
+N10E098.hgt.zip
+N10E099.hgt.zip
+N10E102.hgt.zip
+N10E103.hgt.zip
+N10E104.hgt.zip
+N10E105.hgt.zip
+N10E106.hgt.zip
+N10E107.hgt.zip
+N10E108.hgt.zip
+N10E114.hgt.zip
+N10E115.hgt.zip
+N10E118.hgt.zip
+N10E119.hgt.zip
+N10E120.hgt.zip
+N10E121.hgt.zip
+N10E122.hgt.zip
+N10E123.hgt.zip
+N10E124.hgt.zip
+N10E125.hgt.zip
+N10E126.hgt.zip
+N10E139.hgt.zip
+N10E165.hgt.zip
+N10E166.hgt.zip
+N10E168.hgt.zip
+N10E169.hgt.zip
+N10E170.hgt.zip
+N11E072.hgt.zip
+N11E073.hgt.zip
+N11E075.hgt.zip
+N11E076.hgt.zip
+N11E077.hgt.zip
+N11E078.hgt.zip
+N11E079.hgt.zip
+N11E092.hgt.zip
+N11E093.hgt.zip
+N11E097.hgt.zip
+N11E098.hgt.zip
+N11E099.hgt.zip
+N11E102.hgt.zip
+N11E103.hgt.zip
+N11E104.hgt.zip
+N11E105.hgt.zip
+N11E106.hgt.zip
+N11E107.hgt.zip
+N11E108.hgt.zip
+N11E109.hgt.zip
+N11E114.hgt.zip
+N11E115.hgt.zip
+N11E119.hgt.zip
+N11E120.hgt.zip
+N11E121.hgt.zip
+N11E122.hgt.zip
+N11E123.hgt.zip
+N11E124.hgt.zip
+N11E125.hgt.zip
+N11E162.hgt.zip
+N11E165.hgt.zip
+N11E166.hgt.zip
+N11E167.hgt.zip
+N11E169.hgt.zip
+N12E074.hgt.zip
+N12E075.hgt.zip
+N12E076.hgt.zip
+N12E077.hgt.zip
+N12E078.hgt.zip
+N12E079.hgt.zip
+N12E080.hgt.zip
+N12E092.hgt.zip
+N12E093.hgt.zip
+N12E097.hgt.zip
+N12E098.hgt.zip
+N12E099.hgt.zip
+N12E100.hgt.zip
+N12E101.hgt.zip
+N12E102.hgt.zip
+N12E103.hgt.zip
+N12E104.hgt.zip
+N12E105.hgt.zip
+N12E106.hgt.zip
+N12E107.hgt.zip
+N12E108.hgt.zip
+N12E109.hgt.zip
+N12E119.hgt.zip
+N12E120.hgt.zip
+N12E121.hgt.zip
+N12E122.hgt.zip
+N12E123.hgt.zip
+N12E124.hgt.zip
+N12E125.hgt.zip
+N12E170.hgt.zip
+N13E074.hgt.zip
+N13E075.hgt.zip
+N13E076.hgt.zip
+N13E077.hgt.zip
+N13E078.hgt.zip
+N13E079.hgt.zip
+N13E080.hgt.zip
+N13E092.hgt.zip
+N13E093.hgt.zip
+N13E094.hgt.zip
+N13E097.hgt.zip
+N13E098.hgt.zip
+N13E099.hgt.zip
+N13E100.hgt.zip
+N13E101.hgt.zip
+N13E102.hgt.zip
+N13E103.hgt.zip
+N13E104.hgt.zip
+N13E105.hgt.zip
+N13E106.hgt.zip
+N13E107.hgt.zip
+N13E108.hgt.zip
+N13E109.hgt.zip
+N13E120.hgt.zip
+N13E121.hgt.zip
+N13E122.hgt.zip
+N13E123.hgt.zip
+N13E124.hgt.zip
+N13E144.hgt.zip
+N14E074.hgt.zip
+N14E075.hgt.zip
+N14E076.hgt.zip
+N14E077.hgt.zip
+N14E078.hgt.zip
+N14E079.hgt.zip
+N14E080.hgt.zip
+N14E093.hgt.zip
+N14E097.hgt.zip
+N14E098.hgt.zip
+N14E099.hgt.zip
+N14E100.hgt.zip
+N14E101.hgt.zip
+N14E102.hgt.zip
+N14E103.hgt.zip
+N14E104.hgt.zip
+N14E105.hgt.zip
+N14E106.hgt.zip
+N14E107.hgt.zip
+N14E108.hgt.zip
+N14E109.hgt.zip
+N14E120.hgt.zip
+N14E121.hgt.zip
+N14E122.hgt.zip
+N14E123.hgt.zip
+N14E124.hgt.zip
+N14E145.hgt.zip
+N14E168.hgt.zip
+N14E169.hgt.zip
+N15E073.hgt.zip
+N15E074.hgt.zip
+N15E075.hgt.zip
+N15E076.hgt.zip
+N15E077.hgt.zip
+N15E078.hgt.zip
+N15E079.hgt.zip
+N15E080.hgt.zip
+N15E081.hgt.zip
+N15E094.hgt.zip
+N15E095.hgt.zip
+N15E097.hgt.zip
+N15E098.hgt.zip
+N15E099.hgt.zip
+N15E100.hgt.zip
+N15E101.hgt.zip
+N15E102.hgt.zip
+N15E103.hgt.zip
+N15E104.hgt.zip
+N15E105.hgt.zip
+N15E106.hgt.zip
+N15E107.hgt.zip
+N15E108.hgt.zip
+N15E109.hgt.zip
+N15E111.hgt.zip
+N15E119.hgt.zip
+N15E120.hgt.zip
+N15E121.hgt.zip
+N15E122.hgt.zip
+N15E145.hgt.zip
+N16E073.hgt.zip
+N16E074.hgt.zip
+N16E075.hgt.zip
+N16E076.hgt.zip
+N16E077.hgt.zip
+N16E078.hgt.zip
+N16E079.hgt.zip
+N16E080.hgt.zip
+N16E081.hgt.zip
+N16E082.hgt.zip
+N16E094.hgt.zip
+N16E095.hgt.zip
+N16E096.hgt.zip
+N16E097.hgt.zip
+N16E098.hgt.zip
+N16E099.hgt.zip
+N16E100.hgt.zip
+N16E101.hgt.zip
+N16E102.hgt.zip
+N16E103.hgt.zip
+N16E104.hgt.zip
+N16E105.hgt.zip
+N16E106.hgt.zip
+N16E107.hgt.zip
+N16E108.hgt.zip
+N16E111.hgt.zip
+N16E112.hgt.zip
+N16E119.hgt.zip
+N16E120.hgt.zip
+N16E121.hgt.zip
+N16E122.hgt.zip
+N16E145.hgt.zip
+N16E146.hgt.zip
+N17E073.hgt.zip
+N17E074.hgt.zip
+N17E075.hgt.zip
+N17E076.hgt.zip
+N17E077.hgt.zip
+N17E078.hgt.zip
+N17E079.hgt.zip
+N17E080.hgt.zip
+N17E081.hgt.zip
+N17E082.hgt.zip
+N17E083.hgt.zip
+N17E094.hgt.zip
+N17E095.hgt.zip
+N17E096.hgt.zip
+N17E097.hgt.zip
+N17E098.hgt.zip
+N17E099.hgt.zip
+N17E100.hgt.zip
+N17E101.hgt.zip
+N17E102.hgt.zip
+N17E103.hgt.zip
+N17E104.hgt.zip
+N17E105.hgt.zip
+N17E106.hgt.zip
+N17E107.hgt.zip
+N17E120.hgt.zip
+N17E121.hgt.zip
+N17E122.hgt.zip
+N17E145.hgt.zip
+N18E072.hgt.zip
+N18E073.hgt.zip
+N18E074.hgt.zip
+N18E075.hgt.zip
+N18E076.hgt.zip
+N18E077.hgt.zip
+N18E078.hgt.zip
+N18E079.hgt.zip
+N18E080.hgt.zip
+N18E081.hgt.zip
+N18E082.hgt.zip
+N18E083.hgt.zip
+N18E084.hgt.zip
+N18E093.hgt.zip
+N18E094.hgt.zip
+N18E095.hgt.zip
+N18E096.hgt.zip
+N18E097.hgt.zip
+N18E098.hgt.zip
+N18E099.hgt.zip
+N18E100.hgt.zip
+N18E101.hgt.zip
+N18E102.hgt.zip
+N18E103.hgt.zip
+N18E104.hgt.zip
+N18E105.hgt.zip
+N18E106.hgt.zip
+N18E108.hgt.zip
+N18E109.hgt.zip
+N18E110.hgt.zip
+N18E120.hgt.zip
+N18E121.hgt.zip
+N18E122.hgt.zip
+N18E145.hgt.zip
+N19E072.hgt.zip
+N19E073.hgt.zip
+N19E074.hgt.zip
+N19E075.hgt.zip
+N19E076.hgt.zip
+N19E077.hgt.zip
+N19E078.hgt.zip
+N19E079.hgt.zip
+N19E080.hgt.zip
+N19E081.hgt.zip
+N19E082.hgt.zip
+N19E083.hgt.zip
+N19E084.hgt.zip
+N19E085.hgt.zip
+N19E086.hgt.zip
+N19E092.hgt.zip
+N19E093.hgt.zip
+N19E094.hgt.zip
+N19E095.hgt.zip
+N19E096.hgt.zip
+N19E097.hgt.zip
+N19E098.hgt.zip
+N19E099.hgt.zip
+N19E100.hgt.zip
+N19E101.hgt.zip
+N19E102.hgt.zip
+N19E103.hgt.zip
+N19E104.hgt.zip
+N19E105.hgt.zip
+N19E106.hgt.zip
+N19E108.hgt.zip
+N19E109.hgt.zip
+N19E110.hgt.zip
+N19E111.hgt.zip
+N19E121.hgt.zip
+N19E122.hgt.zip
+N19E145.hgt.zip
+N19E166.hgt.zip
+N20E070.hgt.zip
+N20E071.hgt.zip
+N20E072.hgt.zip
+N20E073.hgt.zip
+N20E074.hgt.zip
+N20E075.hgt.zip
+N20E076.hgt.zip
+N20E077.hgt.zip
+N20E078.hgt.zip
+N20E079.hgt.zip
+N20E080.hgt.zip
+N20E081.hgt.zip
+N20E082.hgt.zip
+N20E083.hgt.zip
+N20E084.hgt.zip
+N20E085.hgt.zip
+N20E086.hgt.zip
+N20E087.hgt.zip
+N20E092.hgt.zip
+N20E093.hgt.zip
+N20E094.hgt.zip
+N20E095.hgt.zip
+N20E096.hgt.zip
+N20E097.hgt.zip
+N20E098.hgt.zip
+N20E099.hgt.zip
+N20E100.hgt.zip
+N20E101.hgt.zip
+N20E102.hgt.zip
+N20E103.hgt.zip
+N20E104.hgt.zip
+N20E105.hgt.zip
+N20E106.hgt.zip
+N20E107.hgt.zip
+N20E109.hgt.zip
+N20E110.hgt.zip
+N20E116.hgt.zip
+N20E121.hgt.zip
+N20E122.hgt.zip
+N20E136.hgt.zip
+N20E144.hgt.zip
+N20E145.hgt.zip
+N21E069.hgt.zip
+N21E070.hgt.zip
+N21E071.hgt.zip
+N21E072.hgt.zip
+N21E073.hgt.zip
+N21E074.hgt.zip
+N21E075.hgt.zip
+N21E076.hgt.zip
+N21E077.hgt.zip
+N21E078.hgt.zip
+N21E079.hgt.zip
+N21E080.hgt.zip
+N21E081.hgt.zip
+N21E082.hgt.zip
+N21E083.hgt.zip
+N21E084.hgt.zip
+N21E085.hgt.zip
+N21E086.hgt.zip
+N21E087.hgt.zip
+N21E088.hgt.zip
+N21E089.hgt.zip
+N21E090.hgt.zip
+N21E091.hgt.zip
+N21E092.hgt.zip
+N21E093.hgt.zip
+N21E094.hgt.zip
+N21E095.hgt.zip
+N21E096.hgt.zip
+N21E097.hgt.zip
+N21E098.hgt.zip
+N21E099.hgt.zip
+N21E100.hgt.zip
+N21E101.hgt.zip
+N21E102.hgt.zip
+N21E103.hgt.zip
+N21E104.hgt.zip
+N21E105.hgt.zip
+N21E106.hgt.zip
+N21E107.hgt.zip
+N21E108.hgt.zip
+N21E109.hgt.zip
+N21E110.hgt.zip
+N21E111.hgt.zip
+N21E112.hgt.zip
+N21E113.hgt.zip
+N21E114.hgt.zip
+N21E120.hgt.zip
+N21E121.hgt.zip
+N22E068.hgt.zip
+N22E069.hgt.zip
+N22E070.hgt.zip
+N22E071.hgt.zip
+N22E072.hgt.zip
+N22E073.hgt.zip
+N22E074.hgt.zip
+N22E075.hgt.zip
+N22E076.hgt.zip
+N22E077.hgt.zip
+N22E078.hgt.zip
+N22E079.hgt.zip
+N22E080.hgt.zip
+N22E081.hgt.zip
+N22E082.hgt.zip
+N22E083.hgt.zip
+N22E084.hgt.zip
+N22E085.hgt.zip
+N22E086.hgt.zip
+N22E087.hgt.zip
+N22E088.hgt.zip
+N22E089.hgt.zip
+N22E090.hgt.zip
+N22E091.hgt.zip
+N22E092.hgt.zip
+N22E093.hgt.zip
+N22E094.hgt.zip
+N22E095.hgt.zip
+N22E096.hgt.zip
+N22E097.hgt.zip
+N22E098.hgt.zip
+N22E099.hgt.zip
+N22E100.hgt.zip
+N22E101.hgt.zip
+N22E102.hgt.zip
+N22E103.hgt.zip
+N22E104.hgt.zip
+N22E105.hgt.zip
+N22E106.hgt.zip
+N22E107.hgt.zip
+N22E108.hgt.zip
+N22E109.hgt.zip
+N22E110.hgt.zip
+N22E111.hgt.zip
+N22E112.hgt.zip
+N22E113.hgt.zip
+N22E114.hgt.zip
+N22E115.hgt.zip
+N22E116.hgt.zip
+N22E120.hgt.zip
+N22E121.hgt.zip
+N23E067.hgt.zip
+N23E068.hgt.zip
+N23E069.hgt.zip
+N23E070.hgt.zip
+N23E071.hgt.zip
+N23E072.hgt.zip
+N23E073.hgt.zip
+N23E074.hgt.zip
+N23E075.hgt.zip
+N23E076.hgt.zip
+N23E077.hgt.zip
+N23E078.hgt.zip
+N23E079.hgt.zip
+N23E080.hgt.zip
+N23E081.hgt.zip
+N23E082.hgt.zip
+N23E083.hgt.zip
+N23E084.hgt.zip
+N23E085.hgt.zip
+N23E086.hgt.zip
+N23E087.hgt.zip
+N23E088.hgt.zip
+N23E089.hgt.zip
+N23E090.hgt.zip
+N23E091.hgt.zip
+N23E092.hgt.zip
+N23E093.hgt.zip
+N23E094.hgt.zip
+N23E095.hgt.zip
+N23E096.hgt.zip
+N23E097.hgt.zip
+N23E098.hgt.zip
+N23E099.hgt.zip
+N23E100.hgt.zip
+N23E101.hgt.zip
+N23E102.hgt.zip
+N23E103.hgt.zip
+N23E104.hgt.zip
+N23E105.hgt.zip
+N23E106.hgt.zip
+N23E107.hgt.zip
+N23E108.hgt.zip
+N23E109.hgt.zip
+N23E110.hgt.zip
+N23E111.hgt.zip
+N23E112.hgt.zip
+N23E113.hgt.zip
+N23E114.hgt.zip
+N23E115.hgt.zip
+N23E116.hgt.zip
+N23E117.hgt.zip
+N23E119.hgt.zip
+N23E120.hgt.zip
+N23E121.hgt.zip
+N24E066.hgt.zip
+N24E067.hgt.zip
+N24E068.hgt.zip
+N24E069.hgt.zip
+N24E070.hgt.zip
+N24E071.hgt.zip
+N24E072.hgt.zip
+N24E073.hgt.zip
+N24E074.hgt.zip
+N24E075.hgt.zip
+N24E076.hgt.zip
+N24E077.hgt.zip
+N24E078.hgt.zip
+N24E079.hgt.zip
+N24E080.hgt.zip
+N24E081.hgt.zip
+N24E082.hgt.zip
+N24E083.hgt.zip
+N24E084.hgt.zip
+N24E085.hgt.zip
+N24E086.hgt.zip
+N24E087.hgt.zip
+N24E088.hgt.zip
+N24E089.hgt.zip
+N24E090.hgt.zip
+N24E091.hgt.zip
+N24E092.hgt.zip
+N24E093.hgt.zip
+N24E094.hgt.zip
+N24E095.hgt.zip
+N24E096.hgt.zip
+N24E097.hgt.zip
+N24E098.hgt.zip
+N24E099.hgt.zip
+N24E100.hgt.zip
+N24E101.hgt.zip
+N24E102.hgt.zip
+N24E103.hgt.zip
+N24E104.hgt.zip
+N24E105.hgt.zip
+N24E106.hgt.zip
+N24E107.hgt.zip
+N24E108.hgt.zip
+N24E109.hgt.zip
+N24E110.hgt.zip
+N24E111.hgt.zip
+N24E112.hgt.zip
+N24E113.hgt.zip
+N24E114.hgt.zip
+N24E115.hgt.zip
+N24E116.hgt.zip
+N24E117.hgt.zip
+N24E118.hgt.zip
+N24E119.hgt.zip
+N24E120.hgt.zip
+N24E121.hgt.zip
+N24E122.hgt.zip
+N24E123.hgt.zip
+N24E124.hgt.zip
+N24E125.hgt.zip
+N24E131.hgt.zip
+N24E141.hgt.zip
+N24E153.hgt.zip
+N25E060.hgt.zip
+N25E061.hgt.zip
+N25E062.hgt.zip
+N25E063.hgt.zip
+N25E064.hgt.zip
+N25E065.hgt.zip
+N25E066.hgt.zip
+N25E067.hgt.zip
+N25E068.hgt.zip
+N25E069.hgt.zip
+N25E070.hgt.zip
+N25E071.hgt.zip
+N25E072.hgt.zip
+N25E073.hgt.zip
+N25E074.hgt.zip
+N25E075.hgt.zip
+N25E076.hgt.zip
+N25E077.hgt.zip
+N25E078.hgt.zip
+N25E079.hgt.zip
+N25E080.hgt.zip
+N25E081.hgt.zip
+N25E082.hgt.zip
+N25E083.hgt.zip
+N25E084.hgt.zip
+N25E085.hgt.zip
+N25E086.hgt.zip
+N25E087.hgt.zip
+N25E088.hgt.zip
+N25E089.hgt.zip
+N25E090.hgt.zip
+N25E091.hgt.zip
+N25E092.hgt.zip
+N25E093.hgt.zip
+N25E094.hgt.zip
+N25E095.hgt.zip
+N25E096.hgt.zip
+N25E097.hgt.zip
+N25E098.hgt.zip
+N25E099.hgt.zip
+N25E100.hgt.zip
+N25E101.hgt.zip
+N25E102.hgt.zip
+N25E103.hgt.zip
+N25E104.hgt.zip
+N25E105.hgt.zip
+N25E106.hgt.zip
+N25E107.hgt.zip
+N25E108.hgt.zip
+N25E109.hgt.zip
+N25E110.hgt.zip
+N25E111.hgt.zip
+N25E112.hgt.zip
+N25E113.hgt.zip
+N25E114.hgt.zip
+N25E115.hgt.zip
+N25E116.hgt.zip
+N25E117.hgt.zip
+N25E118.hgt.zip
+N25E119.hgt.zip
+N25E121.hgt.zip
+N25E122.hgt.zip
+N25E123.hgt.zip
+N25E124.hgt.zip
+N25E131.hgt.zip
+N25E141.hgt.zip
+N26E060.hgt.zip
+N26E061.hgt.zip
+N26E062.hgt.zip
+N26E063.hgt.zip
+N26E064.hgt.zip
+N26E065.hgt.zip
+N26E066.hgt.zip
+N26E067.hgt.zip
+N26E068.hgt.zip
+N26E069.hgt.zip
+N26E070.hgt.zip
+N26E071.hgt.zip
+N26E072.hgt.zip
+N26E073.hgt.zip
+N26E074.hgt.zip
+N26E075.hgt.zip
+N26E076.hgt.zip
+N26E077.hgt.zip
+N26E078.hgt.zip
+N26E079.hgt.zip
+N26E080.hgt.zip
+N26E081.hgt.zip
+N26E082.hgt.zip
+N26E083.hgt.zip
+N26E084.hgt.zip
+N26E085.hgt.zip
+N26E086.hgt.zip
+N26E087.hgt.zip
+N26E088.hgt.zip
+N26E089.hgt.zip
+N26E090.hgt.zip
+N26E091.hgt.zip
+N26E092.hgt.zip
+N26E093.hgt.zip
+N26E094.hgt.zip
+N26E095.hgt.zip
+N26E096.hgt.zip
+N26E097.hgt.zip
+N26E098.hgt.zip
+N26E099.hgt.zip
+N26E100.hgt.zip
+N26E101.hgt.zip
+N26E102.hgt.zip
+N26E103.hgt.zip
+N26E104.hgt.zip
+N26E105.hgt.zip
+N26E106.hgt.zip
+N26E107.hgt.zip
+N26E108.hgt.zip
+N26E109.hgt.zip
+N26E110.hgt.zip
+N26E111.hgt.zip
+N26E112.hgt.zip
+N26E113.hgt.zip
+N26E114.hgt.zip
+N26E115.hgt.zip
+N26E116.hgt.zip
+N26E117.hgt.zip
+N26E118.hgt.zip
+N26E119.hgt.zip
+N26E120.hgt.zip
+N26E126.hgt.zip
+N26E127.hgt.zip
+N26E128.hgt.zip
+N26E142.hgt.zip
+N27E060.hgt.zip
+N27E061.hgt.zip
+N27E062.hgt.zip
+N27E063.hgt.zip
+N27E064.hgt.zip
+N27E065.hgt.zip
+N27E066.hgt.zip
+N27E067.hgt.zip
+N27E068.hgt.zip
+N27E069.hgt.zip
+N27E070.hgt.zip
+N27E071.hgt.zip
+N27E072.hgt.zip
+N27E073.hgt.zip
+N27E074.hgt.zip
+N27E075.hgt.zip
+N27E076.hgt.zip
+N27E077.hgt.zip
+N27E078.hgt.zip
+N27E079.hgt.zip
+N27E080.hgt.zip
+N27E081.hgt.zip
+N27E082.hgt.zip
+N27E083.hgt.zip
+N27E084.hgt.zip
+N27E085.hgt.zip
+N27E086.hgt.zip
+N27E087.hgt.zip
+N27E088.hgt.zip
+N27E089.hgt.zip
+N27E090.hgt.zip
+N27E091.hgt.zip
+N27E092.hgt.zip
+N27E093.hgt.zip
+N27E094.hgt.zip
+N27E095.hgt.zip
+N27E096.hgt.zip
+N27E097.hgt.zip
+N27E098.hgt.zip
+N27E099.hgt.zip
+N27E100.hgt.zip
+N27E101.hgt.zip
+N27E102.hgt.zip
+N27E103.hgt.zip
+N27E104.hgt.zip
+N27E105.hgt.zip
+N27E106.hgt.zip
+N27E107.hgt.zip
+N27E108.hgt.zip
+N27E109.hgt.zip
+N27E110.hgt.zip
+N27E111.hgt.zip
+N27E112.hgt.zip
+N27E113.hgt.zip
+N27E114.hgt.zip
+N27E115.hgt.zip
+N27E116.hgt.zip
+N27E117.hgt.zip
+N27E118.hgt.zip
+N27E119.hgt.zip
+N27E120.hgt.zip
+N27E121.hgt.zip
+N27E127.hgt.zip
+N27E128.hgt.zip
+N27E129.hgt.zip
+N27E140.hgt.zip
+N27E142.hgt.zip
+N28E060.hgt.zip
+N28E061.hgt.zip
+N28E062.hgt.zip
+N28E063.hgt.zip
+N28E064.hgt.zip
+N28E065.hgt.zip
+N28E066.hgt.zip
+N28E067.hgt.zip
+N28E068.hgt.zip
+N28E069.hgt.zip
+N28E070.hgt.zip
+N28E071.hgt.zip
+N28E072.hgt.zip
+N28E073.hgt.zip
+N28E074.hgt.zip
+N28E075.hgt.zip
+N28E076.hgt.zip
+N28E077.hgt.zip
+N28E078.hgt.zip
+N28E079.hgt.zip
+N28E080.hgt.zip
+N28E081.hgt.zip
+N28E082.hgt.zip
+N28E083.hgt.zip
+N28E084.hgt.zip
+N28E085.hgt.zip
+N28E086.hgt.zip
+N28E087.hgt.zip
+N28E088.hgt.zip
+N28E089.hgt.zip
+N28E090.hgt.zip
+N28E091.hgt.zip
+N28E092.hgt.zip
+N28E093.hgt.zip
+N28E094.hgt.zip
+N28E095.hgt.zip
+N28E096.hgt.zip
+N28E097.hgt.zip
+N28E098.hgt.zip
+N28E099.hgt.zip
+N28E100.hgt.zip
+N28E101.hgt.zip
+N28E102.hgt.zip
+N28E103.hgt.zip
+N28E104.hgt.zip
+N28E105.hgt.zip
+N28E106.hgt.zip
+N28E107.hgt.zip
+N28E108.hgt.zip
+N28E109.hgt.zip
+N28E110.hgt.zip
+N28E111.hgt.zip
+N28E112.hgt.zip
+N28E113.hgt.zip
+N28E114.hgt.zip
+N28E115.hgt.zip
+N28E116.hgt.zip
+N28E117.hgt.zip
+N28E118.hgt.zip
+N28E119.hgt.zip
+N28E120.hgt.zip
+N28E121.hgt.zip
+N28E122.hgt.zip
+N28E128.hgt.zip
+N28E129.hgt.zip
+N28E130.hgt.zip
+N29E060.hgt.zip
+N29E061.hgt.zip
+N29E062.hgt.zip
+N29E063.hgt.zip
+N29E064.hgt.zip
+N29E065.hgt.zip
+N29E066.hgt.zip
+N29E067.hgt.zip
+N29E068.hgt.zip
+N29E069.hgt.zip
+N29E070.hgt.zip
+N29E071.hgt.zip
+N29E072.hgt.zip
+N29E073.hgt.zip
+N29E074.hgt.zip
+N29E075.hgt.zip
+N29E076.hgt.zip
+N29E077.hgt.zip
+N29E078.hgt.zip
+N29E079.hgt.zip
+N29E080.hgt.zip
+N29E081.hgt.zip
+N29E082.hgt.zip
+N29E083.hgt.zip
+N29E084.hgt.zip
+N29E085.hgt.zip
+N29E086.hgt.zip
+N29E087.hgt.zip
+N29E088.hgt.zip
+N29E089.hgt.zip
+N29E090.hgt.zip
+N29E091.hgt.zip
+N29E092.hgt.zip
+N29E093.hgt.zip
+N29E094.hgt.zip
+N29E095.hgt.zip
+N29E096.hgt.zip
+N29E097.hgt.zip
+N29E098.hgt.zip
+N29E099.hgt.zip
+N29E100.hgt.zip
+N29E101.hgt.zip
+N29E102.hgt.zip
+N29E103.hgt.zip
+N29E104.hgt.zip
+N29E105.hgt.zip
+N29E106.hgt.zip
+N29E107.hgt.zip
+N29E108.hgt.zip
+N29E109.hgt.zip
+N29E110.hgt.zip
+N29E111.hgt.zip
+N29E112.hgt.zip
+N29E113.hgt.zip
+N29E114.hgt.zip
+N29E115.hgt.zip
+N29E116.hgt.zip
+N29E117.hgt.zip
+N29E118.hgt.zip
+N29E119.hgt.zip
+N29E120.hgt.zip
+N29E121.hgt.zip
+N29E122.hgt.zip
+N29E129.hgt.zip
+N29E140.hgt.zip
+N30E060.hgt.zip
+N30E061.hgt.zip
+N30E062.hgt.zip
+N30E063.hgt.zip
+N30E064.hgt.zip
+N30E065.hgt.zip
+N30E066.hgt.zip
+N30E067.hgt.zip
+N30E068.hgt.zip
+N30E069.hgt.zip
+N30E070.hgt.zip
+N30E071.hgt.zip
+N30E072.hgt.zip
+N30E073.hgt.zip
+N30E074.hgt.zip
+N30E075.hgt.zip
+N30E076.hgt.zip
+N30E077.hgt.zip
+N30E078.hgt.zip
+N30E079.hgt.zip
+N30E080.hgt.zip
+N30E081.hgt.zip
+N30E082.hgt.zip
+N30E083.hgt.zip
+N30E084.hgt.zip
+N30E085.hgt.zip
+N30E086.hgt.zip
+N30E087.hgt.zip
+N30E088.hgt.zip
+N30E089.hgt.zip
+N30E090.hgt.zip
+N30E091.hgt.zip
+N30E092.hgt.zip
+N30E093.hgt.zip
+N30E094.hgt.zip
+N30E095.hgt.zip
+N30E096.hgt.zip
+N30E097.hgt.zip
+N30E098.hgt.zip
+N30E099.hgt.zip
+N30E100.hgt.zip
+N30E101.hgt.zip
+N30E102.hgt.zip
+N30E103.hgt.zip
+N30E104.hgt.zip
+N30E105.hgt.zip
+N30E106.hgt.zip
+N30E107.hgt.zip
+N30E108.hgt.zip
+N30E109.hgt.zip
+N30E110.hgt.zip
+N30E111.hgt.zip
+N30E112.hgt.zip
+N30E113.hgt.zip
+N30E114.hgt.zip
+N30E115.hgt.zip
+N30E116.hgt.zip
+N30E117.hgt.zip
+N30E118.hgt.zip
+N30E119.hgt.zip
+N30E120.hgt.zip
+N30E121.hgt.zip
+N30E122.hgt.zip
+N30E129.hgt.zip
+N30E130.hgt.zip
+N30E131.hgt.zip
+N30E140.hgt.zip
+N31E060.hgt.zip
+N31E061.hgt.zip
+N31E062.hgt.zip
+N31E063.hgt.zip
+N31E064.hgt.zip
+N31E065.hgt.zip
+N31E066.hgt.zip
+N31E067.hgt.zip
+N31E068.hgt.zip
+N31E069.hgt.zip
+N31E070.hgt.zip
+N31E071.hgt.zip
+N31E072.hgt.zip
+N31E073.hgt.zip
+N31E074.hgt.zip
+N31E075.hgt.zip
+N31E076.hgt.zip
+N31E077.hgt.zip
+N31E078.hgt.zip
+N31E079.hgt.zip
+N31E080.hgt.zip
+N31E081.hgt.zip
+N31E082.hgt.zip
+N31E083.hgt.zip
+N31E084.hgt.zip
+N31E085.hgt.zip
+N31E086.hgt.zip
+N31E087.hgt.zip
+N31E088.hgt.zip
+N31E089.hgt.zip
+N31E090.hgt.zip
+N31E091.hgt.zip
+N31E092.hgt.zip
+N31E093.hgt.zip
+N31E094.hgt.zip
+N31E095.hgt.zip
+N31E096.hgt.zip
+N31E097.hgt.zip
+N31E098.hgt.zip
+N31E099.hgt.zip
+N31E100.hgt.zip
+N31E101.hgt.zip
+N31E102.hgt.zip
+N31E103.hgt.zip
+N31E104.hgt.zip
+N31E105.hgt.zip
+N31E106.hgt.zip
+N31E107.hgt.zip
+N31E108.hgt.zip
+N31E109.hgt.zip
+N31E110.hgt.zip
+N31E111.hgt.zip
+N31E112.hgt.zip
+N31E113.hgt.zip
+N31E114.hgt.zip
+N31E115.hgt.zip
+N31E116.hgt.zip
+N31E117.hgt.zip
+N31E118.hgt.zip
+N31E119.hgt.zip
+N31E120.hgt.zip
+N31E121.hgt.zip
+N31E122.hgt.zip
+N31E128.hgt.zip
+N31E129.hgt.zip
+N31E130.hgt.zip
+N31E131.hgt.zip
+N31E139.hgt.zip
+N31E140.hgt.zip
+N32E060.hgt.zip
+N32E061.hgt.zip
+N32E062.hgt.zip
+N32E063.hgt.zip
+N32E064.hgt.zip
+N32E065.hgt.zip
+N32E066.hgt.zip
+N32E067.hgt.zip
+N32E068.hgt.zip
+N32E069.hgt.zip
+N32E070.hgt.zip
+N32E071.hgt.zip
+N32E072.hgt.zip
+N32E073.hgt.zip
+N32E074.hgt.zip
+N32E075.hgt.zip
+N32E076.hgt.zip
+N32E077.hgt.zip
+N32E078.hgt.zip
+N32E079.hgt.zip
+N32E080.hgt.zip
+N32E081.hgt.zip
+N32E082.hgt.zip
+N32E083.hgt.zip
+N32E084.hgt.zip
+N32E085.hgt.zip
+N32E086.hgt.zip
+N32E087.hgt.zip
+N32E088.hgt.zip
+N32E089.hgt.zip
+N32E090.hgt.zip
+N32E091.hgt.zip
+N32E092.hgt.zip
+N32E093.hgt.zip
+N32E094.hgt.zip
+N32E095.hgt.zip
+N32E096.hgt.zip
+N32E097.hgt.zip
+N32E098.hgt.zip
+N32E099.hgt.zip
+N32E100.hgt.zip
+N32E101.hgt.zip
+N32E102.hgt.zip
+N32E103.hgt.zip
+N32E104.hgt.zip
+N32E105.hgt.zip
+N32E106.hgt.zip
+N32E107.hgt.zip
+N32E108.hgt.zip
+N32E109.hgt.zip
+N32E110.hgt.zip
+N32E111.hgt.zip
+N32E112.hgt.zip
+N32E113.hgt.zip
+N32E114.hgt.zip
+N32E115.hgt.zip
+N32E116.hgt.zip
+N32E117.hgt.zip
+N32E118.hgt.zip
+N32E119.hgt.zip
+N32E120.hgt.zip
+N32E121.hgt.zip
+N32E128.hgt.zip
+N32E129.hgt.zip
+N32E130.hgt.zip
+N32E131.hgt.zip
+N32E132.hgt.zip
+N32E133.hgt.zip
+N32E139.hgt.zip
+N33E060.hgt.zip
+N33E061.hgt.zip
+N33E062.hgt.zip
+N33E063.hgt.zip
+N33E064.hgt.zip
+N33E065.hgt.zip
+N33E066.hgt.zip
+N33E067.hgt.zip
+N33E068.hgt.zip
+N33E069.hgt.zip
+N33E070.hgt.zip
+N33E071.hgt.zip
+N33E072.hgt.zip
+N33E073.hgt.zip
+N33E074.hgt.zip
+N33E075.hgt.zip
+N33E076.hgt.zip
+N33E077.hgt.zip
+N33E078.hgt.zip
+N33E079.hgt.zip
+N33E080.hgt.zip
+N33E081.hgt.zip
+N33E082.hgt.zip
+N33E083.hgt.zip
+N33E084.hgt.zip
+N33E085.hgt.zip
+N33E086.hgt.zip
+N33E087.hgt.zip
+N33E088.hgt.zip
+N33E089.hgt.zip
+N33E090.hgt.zip
+N33E091.hgt.zip
+N33E092.hgt.zip
+N33E093.hgt.zip
+N33E094.hgt.zip
+N33E095.hgt.zip
+N33E096.hgt.zip
+N33E097.hgt.zip
+N33E098.hgt.zip
+N33E099.hgt.zip
+N33E100.hgt.zip
+N33E101.hgt.zip
+N33E102.hgt.zip
+N33E103.hgt.zip
+N33E104.hgt.zip
+N33E105.hgt.zip
+N33E106.hgt.zip
+N33E107.hgt.zip
+N33E108.hgt.zip
+N33E109.hgt.zip
+N33E110.hgt.zip
+N33E111.hgt.zip
+N33E112.hgt.zip
+N33E113.hgt.zip
+N33E114.hgt.zip
+N33E115.hgt.zip
+N33E116.hgt.zip
+N33E117.hgt.zip
+N33E118.hgt.zip
+N33E119.hgt.zip
+N33E120.hgt.zip
+N33E126.hgt.zip
+N33E128.hgt.zip
+N33E129.hgt.zip
+N33E130.hgt.zip
+N33E131.hgt.zip
+N33E132.hgt.zip
+N33E133.hgt.zip
+N33E134.hgt.zip
+N33E135.hgt.zip
+N33E136.hgt.zip
+N33E138.hgt.zip
+N33E139.hgt.zip
+N34E060.hgt.zip
+N34E061.hgt.zip
+N34E062.hgt.zip
+N34E063.hgt.zip
+N34E064.hgt.zip
+N34E065.hgt.zip
+N34E066.hgt.zip
+N34E067.hgt.zip
+N34E068.hgt.zip
+N34E069.hgt.zip
+N34E070.hgt.zip
+N34E071.hgt.zip
+N34E072.hgt.zip
+N34E073.hgt.zip
+N34E074.hgt.zip
+N34E075.hgt.zip
+N34E076.hgt.zip
+N34E077.hgt.zip
+N34E078.hgt.zip
+N34E079.hgt.zip
+N34E080.hgt.zip
+N34E081.hgt.zip
+N34E082.hgt.zip
+N34E083.hgt.zip
+N34E084.hgt.zip
+N34E085.hgt.zip
+N34E086.hgt.zip
+N34E087.hgt.zip
+N34E088.hgt.zip
+N34E089.hgt.zip
+N34E090.hgt.zip
+N34E091.hgt.zip
+N34E092.hgt.zip
+N34E093.hgt.zip
+N34E094.hgt.zip
+N34E095.hgt.zip
+N34E096.hgt.zip
+N34E097.hgt.zip
+N34E098.hgt.zip
+N34E099.hgt.zip
+N34E100.hgt.zip
+N34E101.hgt.zip
+N34E102.hgt.zip
+N34E103.hgt.zip
+N34E104.hgt.zip
+N34E105.hgt.zip
+N34E106.hgt.zip
+N34E107.hgt.zip
+N34E108.hgt.zip
+N34E109.hgt.zip
+N34E110.hgt.zip
+N34E111.hgt.zip
+N34E112.hgt.zip
+N34E113.hgt.zip
+N34E114.hgt.zip
+N34E115.hgt.zip
+N34E116.hgt.zip
+N34E117.hgt.zip
+N34E118.hgt.zip
+N34E119.hgt.zip
+N34E120.hgt.zip
+N34E125.hgt.zip
+N34E126.hgt.zip
+N34E127.hgt.zip
+N34E128.hgt.zip
+N34E129.hgt.zip
+N34E130.hgt.zip
+N34E131.hgt.zip
+N34E132.hgt.zip
+N34E133.hgt.zip
+N34E134.hgt.zip
+N34E135.hgt.zip
+N34E136.hgt.zip
+N34E137.hgt.zip
+N34E138.hgt.zip
+N34E139.hgt.zip
+N35E000.hgt.zip
+N35E001.hgt.zip
+N35E002.hgt.zip
+N35E003.hgt.zip
+N35E004.hgt.zip
+N35E005.hgt.zip
+N35E006.hgt.zip
+N35E007.hgt.zip
+N35E008.hgt.zip
+N35E009.hgt.zip
+N35E010.hgt.zip
+N35E011.hgt.zip
+N35E012.hgt.zip
+N35E014.hgt.zip
+N35E023.hgt.zip
+N35E024.hgt.zip
+N35E025.hgt.zip
+N35E026.hgt.zip
+N35E027.hgt.zip
+N35E032.hgt.zip
+N35E033.hgt.zip
+N35E034.hgt.zip
+N35E035.hgt.zip
+N35E036.hgt.zip
+N35E037.hgt.zip
+N35E038.hgt.zip
+N35E039.hgt.zip
+N35E040.hgt.zip
+N35E041.hgt.zip
+N35E042.hgt.zip
+N35E043.hgt.zip
+N35E044.hgt.zip
+N35E045.hgt.zip
+N35E046.hgt.zip
+N35E047.hgt.zip
+N35E048.hgt.zip
+N35E049.hgt.zip
+N35E050.hgt.zip
+N35E051.hgt.zip
+N35E052.hgt.zip
+N35E053.hgt.zip
+N35E054.hgt.zip
+N35E055.hgt.zip
+N35E056.hgt.zip
+N35E057.hgt.zip
+N35E058.hgt.zip
+N35E059.hgt.zip
+N35E060.hgt.zip
+N35E061.hgt.zip
+N35E062.hgt.zip
+N35E063.hgt.zip
+N35E064.hgt.zip
+N35E065.hgt.zip
+N35E066.hgt.zip
+N35E067.hgt.zip
+N35E068.hgt.zip
+N35E069.hgt.zip
+N35E070.hgt.zip
+N35E071.hgt.zip
+N35E072.hgt.zip
+N35E073.hgt.zip
+N35E074.hgt.zip
+N35E075.hgt.zip
+N35E076.hgt.zip
+N35E077.hgt.zip
+N35E078.hgt.zip
+N35E079.hgt.zip
+N35E080.hgt.zip
+N35E081.hgt.zip
+N35E082.hgt.zip
+N35E083.hgt.zip
+N35E084.hgt.zip
+N35E085.hgt.zip
+N35E086.hgt.zip
+N35E087.hgt.zip
+N35E088.hgt.zip
+N35E089.hgt.zip
+N35E090.hgt.zip
+N35E091.hgt.zip
+N35E092.hgt.zip
+N35E093.hgt.zip
+N35E094.hgt.zip
+N35E095.hgt.zip
+N35E096.hgt.zip
+N35E097.hgt.zip
+N35E098.hgt.zip
+N35E099.hgt.zip
+N35E100.hgt.zip
+N35E101.hgt.zip
+N35E102.hgt.zip
+N35E103.hgt.zip
+N35E104.hgt.zip
+N35E105.hgt.zip
+N35E106.hgt.zip
+N35E107.hgt.zip
+N35E108.hgt.zip
+N35E109.hgt.zip
+N35E110.hgt.zip
+N35E111.hgt.zip
+N35E112.hgt.zip
+N35E113.hgt.zip
+N35E114.hgt.zip
+N35E115.hgt.zip
+N35E116.hgt.zip
+N35E117.hgt.zip
+N35E118.hgt.zip
+N35E119.hgt.zip
+N35E120.hgt.zip
+N35E125.hgt.zip
+N35E126.hgt.zip
+N35E127.hgt.zip
+N35E128.hgt.zip
+N35E129.hgt.zip
+N35E132.hgt.zip
+N35E133.hgt.zip
+N35E134.hgt.zip
+N35E135.hgt.zip
+N35E136.hgt.zip
+N35E137.hgt.zip
+N35E138.hgt.zip
+N35E139.hgt.zip
+N35E140.hgt.zip
+N35W001.hgt.zip
+N35W002.hgt.zip
+N35W003.hgt.zip
+N35W004.hgt.zip
+N35W005.hgt.zip
+N35W006.hgt.zip
+N35W007.hgt.zip
+N36E000.hgt.zip
+N36E001.hgt.zip
+N36E002.hgt.zip
+N36E003.hgt.zip
+N36E004.hgt.zip
+N36E005.hgt.zip
+N36E006.hgt.zip
+N36E007.hgt.zip
+N36E008.hgt.zip
+N36E009.hgt.zip
+N36E010.hgt.zip
+N36E011.hgt.zip
+N36E012.hgt.zip
+N36E014.hgt.zip
+N36E015.hgt.zip
+N36E021.hgt.zip
+N36E022.hgt.zip
+N36E023.hgt.zip
+N36E024.hgt.zip
+N36E025.hgt.zip
+N36E026.hgt.zip
+N36E027.hgt.zip
+N36E028.hgt.zip
+N36E029.hgt.zip
+N36E030.hgt.zip
+N36E031.hgt.zip
+N36E032.hgt.zip
+N36E033.hgt.zip
+N36E034.hgt.zip
+N36E035.hgt.zip
+N36E036.hgt.zip
+N36E037.hgt.zip
+N36E038.hgt.zip
+N36E039.hgt.zip
+N36E040.hgt.zip
+N36E041.hgt.zip
+N36E042.hgt.zip
+N36E043.hgt.zip
+N36E044.hgt.zip
+N36E045.hgt.zip
+N36E046.hgt.zip
+N36E047.hgt.zip
+N36E048.hgt.zip
+N36E049.hgt.zip
+N36E050.hgt.zip
+N36E051.hgt.zip
+N36E052.hgt.zip
+N36E053.hgt.zip
+N36E054.hgt.zip
+N36E055.hgt.zip
+N36E056.hgt.zip
+N36E057.hgt.zip
+N36E058.hgt.zip
+N36E059.hgt.zip
+N36E060.hgt.zip
+N36E061.hgt.zip
+N36E062.hgt.zip
+N36E063.hgt.zip
+N36E064.hgt.zip
+N36E065.hgt.zip
+N36E066.hgt.zip
+N36E067.hgt.zip
+N36E068.hgt.zip
+N36E069.hgt.zip
+N36E070.hgt.zip
+N36E071.hgt.zip
+N36E072.hgt.zip
+N36E073.hgt.zip
+N36E074.hgt.zip
+N36E075.hgt.zip
+N36E076.hgt.zip
+N36E077.hgt.zip
+N36E078.hgt.zip
+N36E079.hgt.zip
+N36E080.hgt.zip
+N36E081.hgt.zip
+N36E082.hgt.zip
+N36E083.hgt.zip
+N36E084.hgt.zip
+N36E085.hgt.zip
+N36E086.hgt.zip
+N36E087.hgt.zip
+N36E088.hgt.zip
+N36E089.hgt.zip
+N36E090.hgt.zip
+N36E091.hgt.zip
+N36E092.hgt.zip
+N36E093.hgt.zip
+N36E094.hgt.zip
+N36E095.hgt.zip
+N36E096.hgt.zip
+N36E097.hgt.zip
+N36E098.hgt.zip
+N36E099.hgt.zip
+N36E100.hgt.zip
+N36E101.hgt.zip
+N36E102.hgt.zip
+N36E103.hgt.zip
+N36E104.hgt.zip
+N36E105.hgt.zip
+N36E106.hgt.zip
+N36E107.hgt.zip
+N36E108.hgt.zip
+N36E109.hgt.zip
+N36E110.hgt.zip
+N36E111.hgt.zip
+N36E112.hgt.zip
+N36E113.hgt.zip
+N36E114.hgt.zip
+N36E115.hgt.zip
+N36E116.hgt.zip
+N36E117.hgt.zip
+N36E118.hgt.zip
+N36E119.hgt.zip
+N36E120.hgt.zip
+N36E121.hgt.zip
+N36E122.hgt.zip
+N36E125.hgt.zip
+N36E126.hgt.zip
+N36E127.hgt.zip
+N36E128.hgt.zip
+N36E129.hgt.zip
+N36E132.hgt.zip
+N36E133.hgt.zip
+N36E135.hgt.zip
+N36E136.hgt.zip
+N36E137.hgt.zip
+N36E138.hgt.zip
+N36E139.hgt.zip
+N36E140.hgt.zip
+N36W002.hgt.zip
+N36W003.hgt.zip
+N36W004.hgt.zip
+N36W005.hgt.zip
+N36W006.hgt.zip
+N36W007.hgt.zip
+N36W008.hgt.zip
+N36W009.hgt.zip
+N37E006.hgt.zip
+N37E007.hgt.zip
+N37E008.hgt.zip
+N37E009.hgt.zip
+N37E010.hgt.zip
+N37E011.hgt.zip
+N37E012.hgt.zip
+N37E013.hgt.zip
+N37E014.hgt.zip
+N37E015.hgt.zip
+N37E016.hgt.zip
+N37E020.hgt.zip
+N37E021.hgt.zip
+N37E022.hgt.zip
+N37E023.hgt.zip
+N37E024.hgt.zip
+N37E025.hgt.zip
+N37E026.hgt.zip
+N37E027.hgt.zip
+N37E028.hgt.zip
+N37E029.hgt.zip
+N37E030.hgt.zip
+N37E031.hgt.zip
+N37E032.hgt.zip
+N37E033.hgt.zip
+N37E034.hgt.zip
+N37E035.hgt.zip
+N37E036.hgt.zip
+N37E037.hgt.zip
+N37E038.hgt.zip
+N37E039.hgt.zip
+N37E040.hgt.zip
+N37E041.hgt.zip
+N37E042.hgt.zip
+N37E043.hgt.zip
+N37E044.hgt.zip
+N37E045.hgt.zip
+N37E046.hgt.zip
+N37E047.hgt.zip
+N37E048.hgt.zip
+N37E049.hgt.zip
+N37E050.hgt.zip
+N37E053.hgt.zip
+N37E054.hgt.zip
+N37E055.hgt.zip
+N37E056.hgt.zip
+N37E057.hgt.zip
+N37E058.hgt.zip
+N37E059.hgt.zip
+N37E060.hgt.zip
+N37E061.hgt.zip
+N37E062.hgt.zip
+N37E063.hgt.zip
+N37E064.hgt.zip
+N37E065.hgt.zip
+N37E066.hgt.zip
+N37E067.hgt.zip
+N37E068.hgt.zip
+N37E069.hgt.zip
+N37E070.hgt.zip
+N37E071.hgt.zip
+N37E072.hgt.zip
+N37E073.hgt.zip
+N37E074.hgt.zip
+N37E075.hgt.zip
+N37E076.hgt.zip
+N37E077.hgt.zip
+N37E078.hgt.zip
+N37E079.hgt.zip
+N37E080.hgt.zip
+N37E081.hgt.zip
+N37E082.hgt.zip
+N37E083.hgt.zip
+N37E084.hgt.zip
+N37E085.hgt.zip
+N37E086.hgt.zip
+N37E087.hgt.zip
+N37E088.hgt.zip
+N37E089.hgt.zip
+N37E090.hgt.zip
+N37E091.hgt.zip
+N37E092.hgt.zip
+N37E093.hgt.zip
+N37E094.hgt.zip
+N37E095.hgt.zip
+N37E096.hgt.zip
+N37E097.hgt.zip
+N37E098.hgt.zip
+N37E099.hgt.zip
+N37E100.hgt.zip
+N37E101.hgt.zip
+N37E102.hgt.zip
+N37E103.hgt.zip
+N37E104.hgt.zip
+N37E105.hgt.zip
+N37E106.hgt.zip
+N37E107.hgt.zip
+N37E108.hgt.zip
+N37E109.hgt.zip
+N37E110.hgt.zip
+N37E111.hgt.zip
+N37E112.hgt.zip
+N37E113.hgt.zip
+N37E114.hgt.zip
+N37E115.hgt.zip
+N37E116.hgt.zip
+N37E117.hgt.zip
+N37E118.hgt.zip
+N37E119.hgt.zip
+N37E120.hgt.zip
+N37E121.hgt.zip
+N37E122.hgt.zip
+N37E124.hgt.zip
+N37E125.hgt.zip
+N37E126.hgt.zip
+N37E127.hgt.zip
+N37E128.hgt.zip
+N37E129.hgt.zip
+N37E130.hgt.zip
+N37E131.hgt.zip
+N37E136.hgt.zip
+N37E137.hgt.zip
+N37E138.hgt.zip
+N37E139.hgt.zip
+N37E140.hgt.zip
+N37E141.hgt.zip
+N37W001.hgt.zip
+N37W002.hgt.zip
+N37W003.hgt.zip
+N37W004.hgt.zip
+N37W005.hgt.zip
+N37W006.hgt.zip
+N37W007.hgt.zip
+N37W008.hgt.zip
+N37W009.hgt.zip
+N38E000.hgt.zip
+N38E001.hgt.zip
+N38E008.hgt.zip
+N38E009.hgt.zip
+N38E012.hgt.zip
+N38E013.hgt.zip
+N38E014.hgt.zip
+N38E015.hgt.zip
+N38E016.hgt.zip
+N38E017.hgt.zip
+N38E020.hgt.zip
+N38E021.hgt.zip
+N38E022.hgt.zip
+N38E023.hgt.zip
+N38E024.hgt.zip
+N38E025.hgt.zip
+N38E026.hgt.zip
+N38E027.hgt.zip
+N38E028.hgt.zip
+N38E029.hgt.zip
+N38E030.hgt.zip
+N38E031.hgt.zip
+N38E032.hgt.zip
+N38E033.hgt.zip
+N38E034.hgt.zip
+N38E035.hgt.zip
+N38E036.hgt.zip
+N38E037.hgt.zip
+N38E038.hgt.zip
+N38E039.hgt.zip
+N38E040.hgt.zip
+N38E041.hgt.zip
+N38E042.hgt.zip
+N38E043.hgt.zip
+N38E044.hgt.zip
+N38E045.hgt.zip
+N38E046.hgt.zip
+N38E047.hgt.zip
+N38E048.hgt.zip
+N38E049.hgt.zip
+N38E053.hgt.zip
+N38E054.hgt.zip
+N38E055.hgt.zip
+N38E056.hgt.zip
+N38E057.hgt.zip
+N38E058.hgt.zip
+N38E059.hgt.zip
+N38E060.hgt.zip
+N38E061.hgt.zip
+N38E062.hgt.zip
+N38E063.hgt.zip
+N38E064.hgt.zip
+N38E065.hgt.zip
+N38E066.hgt.zip
+N38E067.hgt.zip
+N38E068.hgt.zip
+N38E069.hgt.zip
+N38E070.hgt.zip
+N38E071.hgt.zip
+N38E072.hgt.zip
+N38E073.hgt.zip
+N38E074.hgt.zip
+N38E075.hgt.zip
+N38E076.hgt.zip
+N38E077.hgt.zip
+N38E078.hgt.zip
+N38E079.hgt.zip
+N38E080.hgt.zip
+N38E081.hgt.zip
+N38E082.hgt.zip
+N38E083.hgt.zip
+N38E084.hgt.zip
+N38E085.hgt.zip
+N38E086.hgt.zip
+N38E087.hgt.zip
+N38E088.hgt.zip
+N38E089.hgt.zip
+N38E090.hgt.zip
+N38E091.hgt.zip
+N38E092.hgt.zip
+N38E093.hgt.zip
+N38E094.hgt.zip
+N38E095.hgt.zip
+N38E096.hgt.zip
+N38E097.hgt.zip
+N38E098.hgt.zip
+N38E099.hgt.zip
+N38E100.hgt.zip
+N38E101.hgt.zip
+N38E102.hgt.zip
+N38E103.hgt.zip
+N38E104.hgt.zip
+N38E105.hgt.zip
+N38E106.hgt.zip
+N38E107.hgt.zip
+N38E108.hgt.zip
+N38E109.hgt.zip
+N38E110.hgt.zip
+N38E111.hgt.zip
+N38E112.hgt.zip
+N38E113.hgt.zip
+N38E114.hgt.zip
+N38E115.hgt.zip
+N38E116.hgt.zip
+N38E117.hgt.zip
+N38E118.hgt.zip
+N38E120.hgt.zip
+N38E121.hgt.zip
+N38E124.hgt.zip
+N38E125.hgt.zip
+N38E126.hgt.zip
+N38E127.hgt.zip
+N38E128.hgt.zip
+N38E138.hgt.zip
+N38E139.hgt.zip
+N38E140.hgt.zip
+N38E141.hgt.zip
+N38W001.hgt.zip
+N38W002.hgt.zip
+N38W003.hgt.zip
+N38W004.hgt.zip
+N38W005.hgt.zip
+N38W006.hgt.zip
+N38W007.hgt.zip
+N38W008.hgt.zip
+N38W009.hgt.zip
+N38W010.hgt.zip
+N39E000.hgt.zip
+N39E001.hgt.zip
+N39E002.hgt.zip
+N39E003.hgt.zip
+N39E004.hgt.zip
+N39E008.hgt.zip
+N39E009.hgt.zip
+N39E015.hgt.zip
+N39E016.hgt.zip
+N39E017.hgt.zip
+N39E018.hgt.zip
+N39E019.hgt.zip
+N39E020.hgt.zip
+N39E021.hgt.zip
+N39E022.hgt.zip
+N39E023.hgt.zip
+N39E024.hgt.zip
+N39E025.hgt.zip
+N39E026.hgt.zip
+N39E027.hgt.zip
+N39E028.hgt.zip
+N39E029.hgt.zip
+N39E030.hgt.zip
+N39E031.hgt.zip
+N39E032.hgt.zip
+N39E033.hgt.zip
+N39E034.hgt.zip
+N39E035.hgt.zip
+N39E036.hgt.zip
+N39E037.hgt.zip
+N39E038.hgt.zip
+N39E039.hgt.zip
+N39E040.hgt.zip
+N39E041.hgt.zip
+N39E042.hgt.zip
+N39E043.hgt.zip
+N39E044.hgt.zip
+N39E045.hgt.zip
+N39E046.hgt.zip
+N39E047.hgt.zip
+N39E048.hgt.zip
+N39E049.hgt.zip
+N39E052.hgt.zip
+N39E053.hgt.zip
+N39E054.hgt.zip
+N39E055.hgt.zip
+N39E056.hgt.zip
+N39E057.hgt.zip
+N39E058.hgt.zip
+N39E059.hgt.zip
+N39E060.hgt.zip
+N39E061.hgt.zip
+N39E062.hgt.zip
+N39E063.hgt.zip
+N39E064.hgt.zip
+N39E065.hgt.zip
+N39E066.hgt.zip
+N39E067.hgt.zip
+N39E068.hgt.zip
+N39E069.hgt.zip
+N39E070.hgt.zip
+N39E071.hgt.zip
+N39E072.hgt.zip
+N39E073.hgt.zip
+N39E074.hgt.zip
+N39E075.hgt.zip
+N39E076.hgt.zip
+N39E077.hgt.zip
+N39E078.hgt.zip
+N39E079.hgt.zip
+N39E080.hgt.zip
+N39E081.hgt.zip
+N39E082.hgt.zip
+N39E083.hgt.zip
+N39E084.hgt.zip
+N39E085.hgt.zip
+N39E086.hgt.zip
+N39E087.hgt.zip
+N39E088.hgt.zip
+N39E089.hgt.zip
+N39E090.hgt.zip
+N39E091.hgt.zip
+N39E092.hgt.zip
+N39E093.hgt.zip
+N39E094.hgt.zip
+N39E095.hgt.zip
+N39E096.hgt.zip
+N39E097.hgt.zip
+N39E098.hgt.zip
+N39E099.hgt.zip
+N39E100.hgt.zip
+N39E101.hgt.zip
+N39E102.hgt.zip
+N39E103.hgt.zip
+N39E104.hgt.zip
+N39E105.hgt.zip
+N39E106.hgt.zip
+N39E107.hgt.zip
+N39E108.hgt.zip
+N39E109.hgt.zip
+N39E110.hgt.zip
+N39E111.hgt.zip
+N39E112.hgt.zip
+N39E113.hgt.zip
+N39E114.hgt.zip
+N39E115.hgt.zip
+N39E116.hgt.zip
+N39E117.hgt.zip
+N39E118.hgt.zip
+N39E119.hgt.zip
+N39E121.hgt.zip
+N39E122.hgt.zip
+N39E123.hgt.zip
+N39E124.hgt.zip
+N39E125.hgt.zip
+N39E126.hgt.zip
+N39E127.hgt.zip
+N39E128.hgt.zip
+N39E139.hgt.zip
+N39E140.hgt.zip
+N39E141.hgt.zip
+N39E142.hgt.zip
+N39W001.hgt.zip
+N39W002.hgt.zip
+N39W003.hgt.zip
+N39W004.hgt.zip
+N39W005.hgt.zip
+N39W006.hgt.zip
+N39W007.hgt.zip
+N39W008.hgt.zip
+N39W009.hgt.zip
+N39W010.hgt.zip
+N40E000.hgt.zip
+N40E003.hgt.zip
+N40E004.hgt.zip
+N40E008.hgt.zip
+N40E009.hgt.zip
+N40E012.hgt.zip
+N40E013.hgt.zip
+N40E014.hgt.zip
+N40E015.hgt.zip
+N40E016.hgt.zip
+N40E017.hgt.zip
+N40E018.hgt.zip
+N40E019.hgt.zip
+N40E020.hgt.zip
+N40E021.hgt.zip
+N40E022.hgt.zip
+N40E023.hgt.zip
+N40E024.hgt.zip
+N40E025.hgt.zip
+N40E026.hgt.zip
+N40E027.hgt.zip
+N40E028.hgt.zip
+N40E029.hgt.zip
+N40E030.hgt.zip
+N40E031.hgt.zip
+N40E032.hgt.zip
+N40E033.hgt.zip
+N40E034.hgt.zip
+N40E035.hgt.zip
+N40E036.hgt.zip
+N40E037.hgt.zip
+N40E038.hgt.zip
+N40E039.hgt.zip
+N40E040.hgt.zip
+N40E041.hgt.zip
+N40E042.hgt.zip
+N40E043.hgt.zip
+N40E044.hgt.zip
+N40E045.hgt.zip
+N40E046.hgt.zip
+N40E047.hgt.zip
+N40E048.hgt.zip
+N40E049.hgt.zip
+N40E050.hgt.zip
+N40E052.hgt.zip
+N40E053.hgt.zip
+N40E054.hgt.zip
+N40E055.hgt.zip
+N40E056.hgt.zip
+N40E057.hgt.zip
+N40E058.hgt.zip
+N40E059.hgt.zip
+N40E060.hgt.zip
+N40E061.hgt.zip
+N40E062.hgt.zip
+N40E063.hgt.zip
+N40E064.hgt.zip
+N40E065.hgt.zip
+N40E066.hgt.zip
+N40E067.hgt.zip
+N40E068.hgt.zip
+N40E069.hgt.zip
+N40E070.hgt.zip
+N40E071.hgt.zip
+N40E072.hgt.zip
+N40E073.hgt.zip
+N40E074.hgt.zip
+N40E075.hgt.zip
+N40E076.hgt.zip
+N40E077.hgt.zip
+N40E078.hgt.zip
+N40E079.hgt.zip
+N40E080.hgt.zip
+N40E081.hgt.zip
+N40E082.hgt.zip
+N40E083.hgt.zip
+N40E084.hgt.zip
+N40E085.hgt.zip
+N40E086.hgt.zip
+N40E087.hgt.zip
+N40E088.hgt.zip
+N40E089.hgt.zip
+N40E090.hgt.zip
+N40E091.hgt.zip
+N40E092.hgt.zip
+N40E093.hgt.zip
+N40E094.hgt.zip
+N40E095.hgt.zip
+N40E096.hgt.zip
+N40E097.hgt.zip
+N40E098.hgt.zip
+N40E099.hgt.zip
+N40E100.hgt.zip
+N40E101.hgt.zip
+N40E102.hgt.zip
+N40E103.hgt.zip
+N40E104.hgt.zip
+N40E105.hgt.zip
+N40E106.hgt.zip
+N40E107.hgt.zip
+N40E108.hgt.zip
+N40E109.hgt.zip
+N40E110.hgt.zip
+N40E111.hgt.zip
+N40E112.hgt.zip
+N40E113.hgt.zip
+N40E114.hgt.zip
+N40E115.hgt.zip
+N40E116.hgt.zip
+N40E117.hgt.zip
+N40E118.hgt.zip
+N40E119.hgt.zip
+N40E120.hgt.zip
+N40E121.hgt.zip
+N40E122.hgt.zip
+N40E123.hgt.zip
+N40E124.hgt.zip
+N40E125.hgt.zip
+N40E126.hgt.zip
+N40E127.hgt.zip
+N40E128.hgt.zip
+N40E129.hgt.zip
+N40E139.hgt.zip
+N40E140.hgt.zip
+N40E141.hgt.zip
+N40W001.hgt.zip
+N40W002.hgt.zip
+N40W003.hgt.zip
+N40W004.hgt.zip
+N40W005.hgt.zip
+N40W006.hgt.zip
+N40W007.hgt.zip
+N40W008.hgt.zip
+N40W009.hgt.zip
+N41E000.hgt.zip
+N41E001.hgt.zip
+N41E002.hgt.zip
+N41E003.hgt.zip
+N41E008.hgt.zip
+N41E009.hgt.zip
+N41E011.hgt.zip
+N41E012.hgt.zip
+N41E013.hgt.zip
+N41E014.hgt.zip
+N41E015.hgt.zip
+N41E016.hgt.zip
+N41E017.hgt.zip
+N41E019.hgt.zip
+N41E020.hgt.zip
+N41E021.hgt.zip
+N41E022.hgt.zip
+N41E023.hgt.zip
+N41E024.hgt.zip
+N41E025.hgt.zip
+N41E026.hgt.zip
+N41E027.hgt.zip
+N41E028.hgt.zip
+N41E029.hgt.zip
+N41E030.hgt.zip
+N41E031.hgt.zip
+N41E032.hgt.zip
+N41E033.hgt.zip
+N41E034.hgt.zip
+N41E035.hgt.zip
+N41E036.hgt.zip
+N41E037.hgt.zip
+N41E038.hgt.zip
+N41E039.hgt.zip
+N41E040.hgt.zip
+N41E041.hgt.zip
+N41E042.hgt.zip
+N41E043.hgt.zip
+N41E044.hgt.zip
+N41E045.hgt.zip
+N41E046.hgt.zip
+N41E047.hgt.zip
+N41E048.hgt.zip
+N41E049.hgt.zip
+N41E052.hgt.zip
+N41E053.hgt.zip
+N41E054.hgt.zip
+N41E055.hgt.zip
+N41E056.hgt.zip
+N41E057.hgt.zip
+N41E058.hgt.zip
+N41E059.hgt.zip
+N41E060.hgt.zip
+N41E061.hgt.zip
+N41E062.hgt.zip
+N41E063.hgt.zip
+N41E064.hgt.zip
+N41E065.hgt.zip
+N41E066.hgt.zip
+N41E067.hgt.zip
+N41E068.hgt.zip
+N41E069.hgt.zip
+N41E070.hgt.zip
+N41E071.hgt.zip
+N41E072.hgt.zip
+N41E073.hgt.zip
+N41E074.hgt.zip
+N41E075.hgt.zip
+N41E076.hgt.zip
+N41E077.hgt.zip
+N41E078.hgt.zip
+N41E079.hgt.zip
+N41E080.hgt.zip
+N41E081.hgt.zip
+N41E082.hgt.zip
+N41E083.hgt.zip
+N41E084.hgt.zip
+N41E085.hgt.zip
+N41E086.hgt.zip
+N41E087.hgt.zip
+N41E088.hgt.zip
+N41E089.hgt.zip
+N41E090.hgt.zip
+N41E091.hgt.zip
+N41E092.hgt.zip
+N41E093.hgt.zip
+N41E094.hgt.zip
+N41E095.hgt.zip
+N41E096.hgt.zip
+N41E097.hgt.zip
+N41E098.hgt.zip
+N41E099.hgt.zip
+N41E100.hgt.zip
+N41E101.hgt.zip
+N41E102.hgt.zip
+N41E103.hgt.zip
+N41E104.hgt.zip
+N41E105.hgt.zip
+N41E106.hgt.zip
+N41E107.hgt.zip
+N41E108.hgt.zip
+N41E109.hgt.zip
+N41E110.hgt.zip
+N41E111.hgt.zip
+N41E112.hgt.zip
+N41E113.hgt.zip
+N41E114.hgt.zip
+N41E115.hgt.zip
+N41E116.hgt.zip
+N41E117.hgt.zip
+N41E118.hgt.zip
+N41E119.hgt.zip
+N41E120.hgt.zip
+N41E121.hgt.zip
+N41E122.hgt.zip
+N41E123.hgt.zip
+N41E124.hgt.zip
+N41E125.hgt.zip
+N41E126.hgt.zip
+N41E127.hgt.zip
+N41E128.hgt.zip
+N41E129.hgt.zip
+N41E130.hgt.zip
+N41E139.hgt.zip
+N41E140.hgt.zip
+N41E141.hgt.zip
+N41E143.hgt.zip
+N41W001.hgt.zip
+N41W002.hgt.zip
+N41W003.hgt.zip
+N41W004.hgt.zip
+N41W005.hgt.zip
+N41W006.hgt.zip
+N41W007.hgt.zip
+N41W008.hgt.zip
+N41W009.hgt.zip
+N42E000.hgt.zip
+N42E001.hgt.zip
+N42E002.hgt.zip
+N42E003.hgt.zip
+N42E006.hgt.zip
+N42E008.hgt.zip
+N42E009.hgt.zip
+N42E010.hgt.zip
+N42E011.hgt.zip
+N42E012.hgt.zip
+N42E013.hgt.zip
+N42E014.hgt.zip
+N42E015.hgt.zip
+N42E016.hgt.zip
+N42E017.hgt.zip
+N42E018.hgt.zip
+N42E019.hgt.zip
+N42E020.hgt.zip
+N42E021.hgt.zip
+N42E022.hgt.zip
+N42E023.hgt.zip
+N42E024.hgt.zip
+N42E025.hgt.zip
+N42E026.hgt.zip
+N42E027.hgt.zip
+N42E028.hgt.zip
+N42E033.hgt.zip
+N42E034.hgt.zip
+N42E035.hgt.zip
+N42E040.hgt.zip
+N42E041.hgt.zip
+N42E042.hgt.zip
+N42E043.hgt.zip
+N42E044.hgt.zip
+N42E045.hgt.zip
+N42E046.hgt.zip
+N42E047.hgt.zip
+N42E048.hgt.zip
+N42E051.hgt.zip
+N42E052.hgt.zip
+N42E053.hgt.zip
+N42E054.hgt.zip
+N42E055.hgt.zip
+N42E056.hgt.zip
+N42E057.hgt.zip
+N42E058.hgt.zip
+N42E059.hgt.zip
+N42E060.hgt.zip
+N42E061.hgt.zip
+N42E062.hgt.zip
+N42E063.hgt.zip
+N42E064.hgt.zip
+N42E065.hgt.zip
+N42E066.hgt.zip
+N42E067.hgt.zip
+N42E068.hgt.zip
+N42E069.hgt.zip
+N42E070.hgt.zip
+N42E071.hgt.zip
+N42E072.hgt.zip
+N42E073.hgt.zip
+N42E074.hgt.zip
+N42E075.hgt.zip
+N42E076.hgt.zip
+N42E077.hgt.zip
+N42E078.hgt.zip
+N42E079.hgt.zip
+N42E080.hgt.zip
+N42E081.hgt.zip
+N42E082.hgt.zip
+N42E083.hgt.zip
+N42E084.hgt.zip
+N42E085.hgt.zip
+N42E086.hgt.zip
+N42E087.hgt.zip
+N42E088.hgt.zip
+N42E089.hgt.zip
+N42E090.hgt.zip
+N42E091.hgt.zip
+N42E092.hgt.zip
+N42E093.hgt.zip
+N42E094.hgt.zip
+N42E095.hgt.zip
+N42E096.hgt.zip
+N42E097.hgt.zip
+N42E098.hgt.zip
+N42E099.hgt.zip
+N42E100.hgt.zip
+N42E101.hgt.zip
+N42E102.hgt.zip
+N42E103.hgt.zip
+N42E104.hgt.zip
+N42E105.hgt.zip
+N42E106.hgt.zip
+N42E107.hgt.zip
+N42E108.hgt.zip
+N42E109.hgt.zip
+N42E110.hgt.zip
+N42E111.hgt.zip
+N42E112.hgt.zip
+N42E113.hgt.zip
+N42E114.hgt.zip
+N42E115.hgt.zip
+N42E116.hgt.zip
+N42E117.hgt.zip
+N42E118.hgt.zip
+N42E119.hgt.zip
+N42E120.hgt.zip
+N42E121.hgt.zip
+N42E122.hgt.zip
+N42E123.hgt.zip
+N42E124.hgt.zip
+N42E125.hgt.zip
+N42E126.hgt.zip
+N42E127.hgt.zip
+N42E128.hgt.zip
+N42E129.hgt.zip
+N42E130.hgt.zip
+N42E131.hgt.zip
+N42E132.hgt.zip
+N42E133.hgt.zip
+N42E134.hgt.zip
+N42E139.hgt.zip
+N42E140.hgt.zip
+N42E141.hgt.zip
+N42E142.hgt.zip
+N42E143.hgt.zip
+N42E144.hgt.zip
+N42E145.hgt.zip
+N42W001.hgt.zip
+N42W002.hgt.zip
+N42W003.hgt.zip
+N42W004.hgt.zip
+N42W005.hgt.zip
+N42W006.hgt.zip
+N42W007.hgt.zip
+N42W008.hgt.zip
+N42W009.hgt.zip
+N42W010.hgt.zip
+N43E000.hgt.zip
+N43E001.hgt.zip
+N43E002.hgt.zip
+N43E003.hgt.zip
+N43E004.hgt.zip
+N43E005.hgt.zip
+N43E006.hgt.zip
+N43E007.hgt.zip
+N43E008.hgt.zip
+N43E009.hgt.zip
+N43E010.hgt.zip
+N43E011.hgt.zip
+N43E012.hgt.zip
+N43E013.hgt.zip
+N43E015.hgt.zip
+N43E016.hgt.zip
+N43E017.hgt.zip
+N43E018.hgt.zip
+N43E019.hgt.zip
+N43E020.hgt.zip
+N43E021.hgt.zip
+N43E022.hgt.zip
+N43E023.hgt.zip
+N43E024.hgt.zip
+N43E025.hgt.zip
+N43E026.hgt.zip
+N43E027.hgt.zip
+N43E028.hgt.zip
+N43E039.hgt.zip
+N43E040.hgt.zip
+N43E041.hgt.zip
+N43E042.hgt.zip
+N43E043.hgt.zip
+N43E044.hgt.zip
+N43E045.hgt.zip
+N43E046.hgt.zip
+N43E047.hgt.zip
+N43E050.hgt.zip
+N43E051.hgt.zip
+N43E052.hgt.zip
+N43E053.hgt.zip
+N43E054.hgt.zip
+N43E055.hgt.zip
+N43E056.hgt.zip
+N43E057.hgt.zip
+N43E058.hgt.zip
+N43E059.hgt.zip
+N43E060.hgt.zip
+N43E061.hgt.zip
+N43E062.hgt.zip
+N43E063.hgt.zip
+N43E064.hgt.zip
+N43E065.hgt.zip
+N43E066.hgt.zip
+N43E067.hgt.zip
+N43E068.hgt.zip
+N43E069.hgt.zip
+N43E070.hgt.zip
+N43E071.hgt.zip
+N43E072.hgt.zip
+N43E073.hgt.zip
+N43E074.hgt.zip
+N43E075.hgt.zip
+N43E076.hgt.zip
+N43E077.hgt.zip
+N43E078.hgt.zip
+N43E079.hgt.zip
+N43E080.hgt.zip
+N43E081.hgt.zip
+N43E082.hgt.zip
+N43E083.hgt.zip
+N43E084.hgt.zip
+N43E085.hgt.zip
+N43E086.hgt.zip
+N43E087.hgt.zip
+N43E088.hgt.zip
+N43E089.hgt.zip
+N43E090.hgt.zip
+N43E091.hgt.zip
+N43E092.hgt.zip
+N43E093.hgt.zip
+N43E094.hgt.zip
+N43E095.hgt.zip
+N43E096.hgt.zip
+N43E097.hgt.zip
+N43E098.hgt.zip
+N43E099.hgt.zip
+N43E100.hgt.zip
+N43E101.hgt.zip
+N43E102.hgt.zip
+N43E103.hgt.zip
+N43E104.hgt.zip
+N43E105.hgt.zip
+N43E106.hgt.zip
+N43E107.hgt.zip
+N43E108.hgt.zip
+N43E109.hgt.zip
+N43E110.hgt.zip
+N43E111.hgt.zip
+N43E112.hgt.zip
+N43E113.hgt.zip
+N43E114.hgt.zip
+N43E115.hgt.zip
+N43E116.hgt.zip
+N43E117.hgt.zip
+N43E118.hgt.zip
+N43E119.hgt.zip
+N43E120.hgt.zip
+N43E121.hgt.zip
+N43E122.hgt.zip
+N43E123.hgt.zip
+N43E124.hgt.zip
+N43E125.hgt.zip
+N43E126.hgt.zip
+N43E127.hgt.zip
+N43E128.hgt.zip
+N43E129.hgt.zip
+N43E130.hgt.zip
+N43E131.hgt.zip
+N43E132.hgt.zip
+N43E133.hgt.zip
+N43E134.hgt.zip
+N43E135.hgt.zip
+N43E140.hgt.zip
+N43E141.hgt.zip
+N43E142.hgt.zip
+N43E143.hgt.zip
+N43E144.hgt.zip
+N43E145.hgt.zip
+N43E146.hgt.zip
+N43W001.hgt.zip
+N43W002.hgt.zip
+N43W003.hgt.zip
+N43W004.hgt.zip
+N43W005.hgt.zip
+N43W006.hgt.zip
+N43W007.hgt.zip
+N43W008.hgt.zip
+N43W009.hgt.zip
+N43W010.hgt.zip
+N44E000.hgt.zip
+N44E001.hgt.zip
+N44E002.hgt.zip
+N44E003.hgt.zip
+N44E004.hgt.zip
+N44E005.hgt.zip
+N44E006.hgt.zip
+N44E007.hgt.zip
+N44E008.hgt.zip
+N44E009.hgt.zip
+N44E010.hgt.zip
+N44E011.hgt.zip
+N44E012.hgt.zip
+N44E013.hgt.zip
+N44E014.hgt.zip
+N44E015.hgt.zip
+N44E016.hgt.zip
+N44E017.hgt.zip
+N44E018.hgt.zip
+N44E019.hgt.zip
+N44E020.hgt.zip
+N44E021.hgt.zip
+N44E022.hgt.zip
+N44E023.hgt.zip
+N44E024.hgt.zip
+N44E025.hgt.zip
+N44E026.hgt.zip
+N44E027.hgt.zip
+N44E028.hgt.zip
+N44E029.hgt.zip
+N44E033.hgt.zip
+N44E034.hgt.zip
+N44E035.hgt.zip
+N44E037.hgt.zip
+N44E038.hgt.zip
+N44E039.hgt.zip
+N44E040.hgt.zip
+N44E041.hgt.zip
+N44E042.hgt.zip
+N44E043.hgt.zip
+N44E044.hgt.zip
+N44E045.hgt.zip
+N44E046.hgt.zip
+N44E047.hgt.zip
+N44E050.hgt.zip
+N44E051.hgt.zip
+N44E052.hgt.zip
+N44E053.hgt.zip
+N44E054.hgt.zip
+N44E055.hgt.zip
+N44E056.hgt.zip
+N44E057.hgt.zip
+N44E058.hgt.zip
+N44E059.hgt.zip
+N44E060.hgt.zip
+N44E061.hgt.zip
+N44E062.hgt.zip
+N44E063.hgt.zip
+N44E064.hgt.zip
+N44E065.hgt.zip
+N44E066.hgt.zip
+N44E067.hgt.zip
+N44E068.hgt.zip
+N44E069.hgt.zip
+N44E070.hgt.zip
+N44E071.hgt.zip
+N44E072.hgt.zip
+N44E073.hgt.zip
+N44E074.hgt.zip
+N44E075.hgt.zip
+N44E076.hgt.zip
+N44E077.hgt.zip
+N44E078.hgt.zip
+N44E079.hgt.zip
+N44E080.hgt.zip
+N44E081.hgt.zip
+N44E082.hgt.zip
+N44E083.hgt.zip
+N44E084.hgt.zip
+N44E085.hgt.zip
+N44E086.hgt.zip
+N44E087.hgt.zip
+N44E088.hgt.zip
+N44E089.hgt.zip
+N44E090.hgt.zip
+N44E091.hgt.zip
+N44E092.hgt.zip
+N44E093.hgt.zip
+N44E094.hgt.zip
+N44E095.hgt.zip
+N44E096.hgt.zip
+N44E097.hgt.zip
+N44E098.hgt.zip
+N44E099.hgt.zip
+N44E100.hgt.zip
+N44E101.hgt.zip
+N44E102.hgt.zip
+N44E103.hgt.zip
+N44E104.hgt.zip
+N44E105.hgt.zip
+N44E106.hgt.zip
+N44E107.hgt.zip
+N44E108.hgt.zip
+N44E109.hgt.zip
+N44E110.hgt.zip
+N44E111.hgt.zip
+N44E112.hgt.zip
+N44E113.hgt.zip
+N44E114.hgt.zip
+N44E115.hgt.zip
+N44E116.hgt.zip
+N44E117.hgt.zip
+N44E118.hgt.zip
+N44E119.hgt.zip
+N44E120.hgt.zip
+N44E121.hgt.zip
+N44E122.hgt.zip
+N44E123.hgt.zip
+N44E124.hgt.zip
+N44E125.hgt.zip
+N44E126.hgt.zip
+N44E127.hgt.zip
+N44E128.hgt.zip
+N44E129.hgt.zip
+N44E130.hgt.zip
+N44E131.hgt.zip
+N44E132.hgt.zip
+N44E133.hgt.zip
+N44E134.hgt.zip
+N44E135.hgt.zip
+N44E136.hgt.zip
+N44E141.hgt.zip
+N44E142.hgt.zip
+N44E143.hgt.zip
+N44E144.hgt.zip
+N44E145.hgt.zip
+N44E146.hgt.zip
+N44E147.hgt.zip
+N44W001.hgt.zip
+N44W002.hgt.zip
+N45E000.hgt.zip
+N45E001.hgt.zip
+N45E002.hgt.zip
+N45E003.hgt.zip
+N45E004.hgt.zip
+N45E005.hgt.zip
+N45E006.hgt.zip
+N45E007.hgt.zip
+N45E008.hgt.zip
+N45E009.hgt.zip
+N45E010.hgt.zip
+N45E011.hgt.zip
+N45E012.hgt.zip
+N45E013.hgt.zip
+N45E014.hgt.zip
+N45E015.hgt.zip
+N45E016.hgt.zip
+N45E017.hgt.zip
+N45E018.hgt.zip
+N45E019.hgt.zip
+N45E020.hgt.zip
+N45E021.hgt.zip
+N45E022.hgt.zip
+N45E023.hgt.zip
+N45E024.hgt.zip
+N45E025.hgt.zip
+N45E026.hgt.zip
+N45E027.hgt.zip
+N45E028.hgt.zip
+N45E029.hgt.zip
+N45E030.hgt.zip
+N45E032.hgt.zip
+N45E033.hgt.zip
+N45E034.hgt.zip
+N45E035.hgt.zip
+N45E036.hgt.zip
+N45E037.hgt.zip
+N45E038.hgt.zip
+N45E039.hgt.zip
+N45E040.hgt.zip
+N45E041.hgt.zip
+N45E042.hgt.zip
+N45E043.hgt.zip
+N45E044.hgt.zip
+N45E045.hgt.zip
+N45E046.hgt.zip
+N45E047.hgt.zip
+N45E048.hgt.zip
+N45E049.hgt.zip
+N45E050.hgt.zip
+N45E051.hgt.zip
+N45E052.hgt.zip
+N45E053.hgt.zip
+N45E054.hgt.zip
+N45E055.hgt.zip
+N45E056.hgt.zip
+N45E057.hgt.zip
+N45E058.hgt.zip
+N45E059.hgt.zip
+N45E060.hgt.zip
+N45E061.hgt.zip
+N45E062.hgt.zip
+N45E063.hgt.zip
+N45E064.hgt.zip
+N45E065.hgt.zip
+N45E066.hgt.zip
+N45E067.hgt.zip
+N45E068.hgt.zip
+N45E069.hgt.zip
+N45E070.hgt.zip
+N45E071.hgt.zip
+N45E072.hgt.zip
+N45E073.hgt.zip
+N45E074.hgt.zip
+N45E075.hgt.zip
+N45E076.hgt.zip
+N45E077.hgt.zip
+N45E078.hgt.zip
+N45E079.hgt.zip
+N45E080.hgt.zip
+N45E081.hgt.zip
+N45E082.hgt.zip
+N45E083.hgt.zip
+N45E084.hgt.zip
+N45E085.hgt.zip
+N45E086.hgt.zip
+N45E087.hgt.zip
+N45E088.hgt.zip
+N45E089.hgt.zip
+N45E090.hgt.zip
+N45E091.hgt.zip
+N45E092.hgt.zip
+N45E093.hgt.zip
+N45E094.hgt.zip
+N45E095.hgt.zip
+N45E096.hgt.zip
+N45E097.hgt.zip
+N45E098.hgt.zip
+N45E099.hgt.zip
+N45E100.hgt.zip
+N45E101.hgt.zip
+N45E102.hgt.zip
+N45E103.hgt.zip
+N45E104.hgt.zip
+N45E105.hgt.zip
+N45E106.hgt.zip
+N45E107.hgt.zip
+N45E108.hgt.zip
+N45E109.hgt.zip
+N45E110.hgt.zip
+N45E111.hgt.zip
+N45E112.hgt.zip
+N45E113.hgt.zip
+N45E114.hgt.zip
+N45E115.hgt.zip
+N45E116.hgt.zip
+N45E117.hgt.zip
+N45E118.hgt.zip
+N45E119.hgt.zip
+N45E120.hgt.zip
+N45E121.hgt.zip
+N45E122.hgt.zip
+N45E123.hgt.zip
+N45E124.hgt.zip
+N45E125.hgt.zip
+N45E126.hgt.zip
+N45E127.hgt.zip
+N45E128.hgt.zip
+N45E129.hgt.zip
+N45E130.hgt.zip
+N45E131.hgt.zip
+N45E132.hgt.zip
+N45E133.hgt.zip
+N45E134.hgt.zip
+N45E135.hgt.zip
+N45E136.hgt.zip
+N45E137.hgt.zip
+N45E140.hgt.zip
+N45E141.hgt.zip
+N45E142.hgt.zip
+N45E147.hgt.zip
+N45E148.hgt.zip
+N45E149.hgt.zip
+N45E150.hgt.zip
+N45W001.hgt.zip
+N45W002.hgt.zip
+N46E000.hgt.zip
+N46E001.hgt.zip
+N46E002.hgt.zip
+N46E003.hgt.zip
+N46E004.hgt.zip
+N46E005.hgt.zip
+N46E006.hgt.zip
+N46E007.hgt.zip
+N46E008.hgt.zip
+N46E009.hgt.zip
+N46E010.hgt.zip
+N46E011.hgt.zip
+N46E012.hgt.zip
+N46E013.hgt.zip
+N46E014.hgt.zip
+N46E015.hgt.zip
+N46E016.hgt.zip
+N46E017.hgt.zip
+N46E018.hgt.zip
+N46E019.hgt.zip
+N46E020.hgt.zip
+N46E021.hgt.zip
+N46E022.hgt.zip
+N46E023.hgt.zip
+N46E024.hgt.zip
+N46E025.hgt.zip
+N46E026.hgt.zip
+N46E027.hgt.zip
+N46E028.hgt.zip
+N46E029.hgt.zip
+N46E030.hgt.zip
+N46E031.hgt.zip
+N46E032.hgt.zip
+N46E033.hgt.zip
+N46E034.hgt.zip
+N46E035.hgt.zip
+N46E036.hgt.zip
+N46E037.hgt.zip
+N46E038.hgt.zip
+N46E039.hgt.zip
+N46E040.hgt.zip
+N46E041.hgt.zip
+N46E042.hgt.zip
+N46E043.hgt.zip
+N46E044.hgt.zip
+N46E045.hgt.zip
+N46E046.hgt.zip
+N46E047.hgt.zip
+N46E048.hgt.zip
+N46E049.hgt.zip
+N46E050.hgt.zip
+N46E051.hgt.zip
+N46E052.hgt.zip
+N46E053.hgt.zip
+N46E054.hgt.zip
+N46E055.hgt.zip
+N46E056.hgt.zip
+N46E057.hgt.zip
+N46E058.hgt.zip
+N46E059.hgt.zip
+N46E060.hgt.zip
+N46E061.hgt.zip
+N46E062.hgt.zip
+N46E063.hgt.zip
+N46E064.hgt.zip
+N46E065.hgt.zip
+N46E066.hgt.zip
+N46E067.hgt.zip
+N46E068.hgt.zip
+N46E069.hgt.zip
+N46E070.hgt.zip
+N46E071.hgt.zip
+N46E072.hgt.zip
+N46E073.hgt.zip
+N46E074.hgt.zip
+N46E075.hgt.zip
+N46E076.hgt.zip
+N46E077.hgt.zip
+N46E078.hgt.zip
+N46E079.hgt.zip
+N46E080.hgt.zip
+N46E081.hgt.zip
+N46E082.hgt.zip
+N46E083.hgt.zip
+N46E084.hgt.zip
+N46E085.hgt.zip
+N46E086.hgt.zip
+N46E087.hgt.zip
+N46E088.hgt.zip
+N46E089.hgt.zip
+N46E090.hgt.zip
+N46E091.hgt.zip
+N46E092.hgt.zip
+N46E093.hgt.zip
+N46E094.hgt.zip
+N46E095.hgt.zip
+N46E096.hgt.zip
+N46E097.hgt.zip
+N46E098.hgt.zip
+N46E099.hgt.zip
+N46E100.hgt.zip
+N46E101.hgt.zip
+N46E102.hgt.zip
+N46E103.hgt.zip
+N46E104.hgt.zip
+N46E105.hgt.zip
+N46E106.hgt.zip
+N46E107.hgt.zip
+N46E108.hgt.zip
+N46E109.hgt.zip
+N46E110.hgt.zip
+N46E111.hgt.zip
+N46E112.hgt.zip
+N46E113.hgt.zip
+N46E114.hgt.zip
+N46E115.hgt.zip
+N46E116.hgt.zip
+N46E117.hgt.zip
+N46E118.hgt.zip
+N46E119.hgt.zip
+N46E120.hgt.zip
+N46E121.hgt.zip
+N46E122.hgt.zip
+N46E123.hgt.zip
+N46E124.hgt.zip
+N46E125.hgt.zip
+N46E126.hgt.zip
+N46E127.hgt.zip
+N46E128.hgt.zip
+N46E129.hgt.zip
+N46E130.hgt.zip
+N46E131.hgt.zip
+N46E132.hgt.zip
+N46E133.hgt.zip
+N46E134.hgt.zip
+N46E135.hgt.zip
+N46E136.hgt.zip
+N46E137.hgt.zip
+N46E138.hgt.zip
+N46E141.hgt.zip
+N46E142.hgt.zip
+N46E143.hgt.zip
+N46E149.hgt.zip
+N46E150.hgt.zip
+N46E151.hgt.zip
+N46E152.hgt.zip
+N46W001.hgt.zip
+N46W002.hgt.zip
+N46W003.hgt.zip
+N47E000.hgt.zip
+N47E001.hgt.zip
+N47E002.hgt.zip
+N47E003.hgt.zip
+N47E004.hgt.zip
+N47E005.hgt.zip
+N47E006.hgt.zip
+N47E007.hgt.zip
+N47E008.hgt.zip
+N47E009.hgt.zip
+N47E010.hgt.zip
+N47E011.hgt.zip
+N47E012.hgt.zip
+N47E013.hgt.zip
+N47E014.hgt.zip
+N47E015.hgt.zip
+N47E016.hgt.zip
+N47E017.hgt.zip
+N47E018.hgt.zip
+N47E019.hgt.zip
+N47E020.hgt.zip
+N47E021.hgt.zip
+N47E022.hgt.zip
+N47E023.hgt.zip
+N47E024.hgt.zip
+N47E025.hgt.zip
+N47E026.hgt.zip
+N47E027.hgt.zip
+N47E028.hgt.zip
+N47E029.hgt.zip
+N47E030.hgt.zip
+N47E031.hgt.zip
+N47E032.hgt.zip
+N47E033.hgt.zip
+N47E034.hgt.zip
+N47E035.hgt.zip
+N47E036.hgt.zip
+N47E037.hgt.zip
+N47E038.hgt.zip
+N47E039.hgt.zip
+N47E040.hgt.zip
+N47E041.hgt.zip
+N47E042.hgt.zip
+N47E043.hgt.zip
+N47E044.hgt.zip
+N47E045.hgt.zip
+N47E046.hgt.zip
+N47E047.hgt.zip
+N47E048.hgt.zip
+N47E049.hgt.zip
+N47E050.hgt.zip
+N47E051.hgt.zip
+N47E052.hgt.zip
+N47E053.hgt.zip
+N47E054.hgt.zip
+N47E055.hgt.zip
+N47E056.hgt.zip
+N47E057.hgt.zip
+N47E058.hgt.zip
+N47E059.hgt.zip
+N47E060.hgt.zip
+N47E061.hgt.zip
+N47E062.hgt.zip
+N47E063.hgt.zip
+N47E064.hgt.zip
+N47E065.hgt.zip
+N47E066.hgt.zip
+N47E067.hgt.zip
+N47E068.hgt.zip
+N47E069.hgt.zip
+N47E070.hgt.zip
+N47E071.hgt.zip
+N47E072.hgt.zip
+N47E073.hgt.zip
+N47E074.hgt.zip
+N47E075.hgt.zip
+N47E076.hgt.zip
+N47E077.hgt.zip
+N47E078.hgt.zip
+N47E079.hgt.zip
+N47E080.hgt.zip
+N47E081.hgt.zip
+N47E082.hgt.zip
+N47E083.hgt.zip
+N47E084.hgt.zip
+N47E085.hgt.zip
+N47E086.hgt.zip
+N47E087.hgt.zip
+N47E088.hgt.zip
+N47E089.hgt.zip
+N47E090.hgt.zip
+N47E091.hgt.zip
+N47E092.hgt.zip
+N47E093.hgt.zip
+N47E094.hgt.zip
+N47E095.hgt.zip
+N47E096.hgt.zip
+N47E097.hgt.zip
+N47E098.hgt.zip
+N47E099.hgt.zip
+N47E100.hgt.zip
+N47E101.hgt.zip
+N47E102.hgt.zip
+N47E103.hgt.zip
+N47E104.hgt.zip
+N47E105.hgt.zip
+N47E106.hgt.zip
+N47E107.hgt.zip
+N47E108.hgt.zip
+N47E109.hgt.zip
+N47E110.hgt.zip
+N47E111.hgt.zip
+N47E112.hgt.zip
+N47E113.hgt.zip
+N47E114.hgt.zip
+N47E115.hgt.zip
+N47E116.hgt.zip
+N47E117.hgt.zip
+N47E118.hgt.zip
+N47E119.hgt.zip
+N47E120.hgt.zip
+N47E121.hgt.zip
+N47E122.hgt.zip
+N47E123.hgt.zip
+N47E124.hgt.zip
+N47E125.hgt.zip
+N47E126.hgt.zip
+N47E127.hgt.zip
+N47E128.hgt.zip
+N47E129.hgt.zip
+N47E130.hgt.zip
+N47E131.hgt.zip
+N47E132.hgt.zip
+N47E133.hgt.zip
+N47E134.hgt.zip
+N47E135.hgt.zip
+N47E136.hgt.zip
+N47E137.hgt.zip
+N47E138.hgt.zip
+N47E139.hgt.zip
+N47E141.hgt.zip
+N47E142.hgt.zip
+N47E143.hgt.zip
+N47E152.hgt.zip
+N47E153.hgt.zip
+N47W001.hgt.zip
+N47W002.hgt.zip
+N47W003.hgt.zip
+N47W004.hgt.zip
+N47W005.hgt.zip
+N48E000.hgt.zip
+N48E001.hgt.zip
+N48E002.hgt.zip
+N48E003.hgt.zip
+N48E004.hgt.zip
+N48E005.hgt.zip
+N48E006.hgt.zip
+N48E007.hgt.zip
+N48E008.hgt.zip
+N48E009.hgt.zip
+N48E010.hgt.zip
+N48E011.hgt.zip
+N48E012.hgt.zip
+N48E013.hgt.zip
+N48E014.hgt.zip
+N48E015.hgt.zip
+N48E016.hgt.zip
+N48E017.hgt.zip
+N48E018.hgt.zip
+N48E019.hgt.zip
+N48E020.hgt.zip
+N48E021.hgt.zip
+N48E022.hgt.zip
+N48E023.hgt.zip
+N48E024.hgt.zip
+N48E025.hgt.zip
+N48E026.hgt.zip
+N48E027.hgt.zip
+N48E028.hgt.zip
+N48E029.hgt.zip
+N48E030.hgt.zip
+N48E031.hgt.zip
+N48E032.hgt.zip
+N48E033.hgt.zip
+N48E034.hgt.zip
+N48E035.hgt.zip
+N48E036.hgt.zip
+N48E037.hgt.zip
+N48E038.hgt.zip
+N48E039.hgt.zip
+N48E040.hgt.zip
+N48E041.hgt.zip
+N48E042.hgt.zip
+N48E043.hgt.zip
+N48E044.hgt.zip
+N48E045.hgt.zip
+N48E046.hgt.zip
+N48E047.hgt.zip
+N48E048.hgt.zip
+N48E049.hgt.zip
+N48E050.hgt.zip
+N48E051.hgt.zip
+N48E052.hgt.zip
+N48E053.hgt.zip
+N48E054.hgt.zip
+N48E055.hgt.zip
+N48E056.hgt.zip
+N48E057.hgt.zip
+N48E058.hgt.zip
+N48E059.hgt.zip
+N48E060.hgt.zip
+N48E061.hgt.zip
+N48E062.hgt.zip
+N48E063.hgt.zip
+N48E064.hgt.zip
+N48E065.hgt.zip
+N48E066.hgt.zip
+N48E067.hgt.zip
+N48E068.hgt.zip
+N48E069.hgt.zip
+N48E070.hgt.zip
+N48E071.hgt.zip
+N48E072.hgt.zip
+N48E073.hgt.zip
+N48E074.hgt.zip
+N48E075.hgt.zip
+N48E076.hgt.zip
+N48E077.hgt.zip
+N48E078.hgt.zip
+N48E079.hgt.zip
+N48E080.hgt.zip
+N48E081.hgt.zip
+N48E082.hgt.zip
+N48E083.hgt.zip
+N48E084.hgt.zip
+N48E085.hgt.zip
+N48E086.hgt.zip
+N48E087.hgt.zip
+N48E088.hgt.zip
+N48E089.hgt.zip
+N48E090.hgt.zip
+N48E091.hgt.zip
+N48E092.hgt.zip
+N48E093.hgt.zip
+N48E094.hgt.zip
+N48E095.hgt.zip
+N48E096.hgt.zip
+N48E097.hgt.zip
+N48E098.hgt.zip
+N48E099.hgt.zip
+N48E100.hgt.zip
+N48E101.hgt.zip
+N48E102.hgt.zip
+N48E103.hgt.zip
+N48E104.hgt.zip
+N48E105.hgt.zip
+N48E106.hgt.zip
+N48E107.hgt.zip
+N48E108.hgt.zip
+N48E109.hgt.zip
+N48E110.hgt.zip
+N48E111.hgt.zip
+N48E112.hgt.zip
+N48E113.hgt.zip
+N48E114.hgt.zip
+N48E115.hgt.zip
+N48E116.hgt.zip
+N48E117.hgt.zip
+N48E118.hgt.zip
+N48E119.hgt.zip
+N48E120.hgt.zip
+N48E121.hgt.zip
+N48E122.hgt.zip
+N48E123.hgt.zip
+N48E124.hgt.zip
+N48E125.hgt.zip
+N48E126.hgt.zip
+N48E127.hgt.zip
+N48E128.hgt.zip
+N48E129.hgt.zip
+N48E130.hgt.zip
+N48E131.hgt.zip
+N48E132.hgt.zip
+N48E133.hgt.zip
+N48E134.hgt.zip
+N48E135.hgt.zip
+N48E136.hgt.zip
+N48E137.hgt.zip
+N48E138.hgt.zip
+N48E139.hgt.zip
+N48E140.hgt.zip
+N48E141.hgt.zip
+N48E142.hgt.zip
+N48E144.hgt.zip
+N48E153.hgt.zip
+N48E154.hgt.zip
+N48W001.hgt.zip
+N48W002.hgt.zip
+N48W003.hgt.zip
+N48W004.hgt.zip
+N48W005.hgt.zip
+N48W006.hgt.zip
+N49E000.hgt.zip
+N49E001.hgt.zip
+N49E002.hgt.zip
+N49E003.hgt.zip
+N49E004.hgt.zip
+N49E005.hgt.zip
+N49E006.hgt.zip
+N49E007.hgt.zip
+N49E008.hgt.zip
+N49E009.hgt.zip
+N49E010.hgt.zip
+N49E011.hgt.zip
+N49E012.hgt.zip
+N49E013.hgt.zip
+N49E014.hgt.zip
+N49E015.hgt.zip
+N49E016.hgt.zip
+N49E017.hgt.zip
+N49E018.hgt.zip
+N49E019.hgt.zip
+N49E020.hgt.zip
+N49E021.hgt.zip
+N49E022.hgt.zip
+N49E023.hgt.zip
+N49E024.hgt.zip
+N49E025.hgt.zip
+N49E026.hgt.zip
+N49E027.hgt.zip
+N49E028.hgt.zip
+N49E029.hgt.zip
+N49E030.hgt.zip
+N49E031.hgt.zip
+N49E032.hgt.zip
+N49E033.hgt.zip
+N49E034.hgt.zip
+N49E035.hgt.zip
+N49E036.hgt.zip
+N49E037.hgt.zip
+N49E038.hgt.zip
+N49E039.hgt.zip
+N49E040.hgt.zip
+N49E041.hgt.zip
+N49E042.hgt.zip
+N49E043.hgt.zip
+N49E044.hgt.zip
+N49E045.hgt.zip
+N49E046.hgt.zip
+N49E047.hgt.zip
+N49E048.hgt.zip
+N49E049.hgt.zip
+N49E050.hgt.zip
+N49E051.hgt.zip
+N49E052.hgt.zip
+N49E053.hgt.zip
+N49E054.hgt.zip
+N49E055.hgt.zip
+N49E056.hgt.zip
+N49E057.hgt.zip
+N49E058.hgt.zip
+N49E059.hgt.zip
+N49E060.hgt.zip
+N49E061.hgt.zip
+N49E062.hgt.zip
+N49E063.hgt.zip
+N49E064.hgt.zip
+N49E065.hgt.zip
+N49E066.hgt.zip
+N49E067.hgt.zip
+N49E068.hgt.zip
+N49E069.hgt.zip
+N49E070.hgt.zip
+N49E071.hgt.zip
+N49E072.hgt.zip
+N49E073.hgt.zip
+N49E074.hgt.zip
+N49E075.hgt.zip
+N49E076.hgt.zip
+N49E077.hgt.zip
+N49E078.hgt.zip
+N49E079.hgt.zip
+N49E080.hgt.zip
+N49E081.hgt.zip
+N49E082.hgt.zip
+N49E083.hgt.zip
+N49E084.hgt.zip
+N49E085.hgt.zip
+N49E086.hgt.zip
+N49E087.hgt.zip
+N49E088.hgt.zip
+N49E089.hgt.zip
+N49E090.hgt.zip
+N49E091.hgt.zip
+N49E092.hgt.zip
+N49E093.hgt.zip
+N49E094.hgt.zip
+N49E095.hgt.zip
+N49E096.hgt.zip
+N49E097.hgt.zip
+N49E098.hgt.zip
+N49E099.hgt.zip
+N49E100.hgt.zip
+N49E101.hgt.zip
+N49E102.hgt.zip
+N49E103.hgt.zip
+N49E104.hgt.zip
+N49E105.hgt.zip
+N49E106.hgt.zip
+N49E107.hgt.zip
+N49E108.hgt.zip
+N49E109.hgt.zip
+N49E110.hgt.zip
+N49E111.hgt.zip
+N49E112.hgt.zip
+N49E113.hgt.zip
+N49E114.hgt.zip
+N49E115.hgt.zip
+N49E116.hgt.zip
+N49E117.hgt.zip
+N49E118.hgt.zip
+N49E119.hgt.zip
+N49E120.hgt.zip
+N49E121.hgt.zip
+N49E122.hgt.zip
+N49E123.hgt.zip
+N49E124.hgt.zip
+N49E125.hgt.zip
+N49E126.hgt.zip
+N49E127.hgt.zip
+N49E128.hgt.zip
+N49E129.hgt.zip
+N49E130.hgt.zip
+N49E131.hgt.zip
+N49E132.hgt.zip
+N49E133.hgt.zip
+N49E134.hgt.zip
+N49E135.hgt.zip
+N49E136.hgt.zip
+N49E137.hgt.zip
+N49E138.hgt.zip
+N49E139.hgt.zip
+N49E140.hgt.zip
+N49E142.hgt.zip
+N49E143.hgt.zip
+N49E144.hgt.zip
+N49E154.hgt.zip
+N49E155.hgt.zip
+N49W001.hgt.zip
+N49W002.hgt.zip
+N49W003.hgt.zip
+N49W006.hgt.zip
+N49W007.hgt.zip
+N50E000.hgt.zip
+N50E001.hgt.zip
+N50E002.hgt.zip
+N50E003.hgt.zip
+N50E004.hgt.zip
+N50E005.hgt.zip
+N50E006.hgt.zip
+N50E007.hgt.zip
+N50E008.hgt.zip
+N50E009.hgt.zip
+N50E010.hgt.zip
+N50E011.hgt.zip
+N50E012.hgt.zip
+N50E013.hgt.zip
+N50E014.hgt.zip
+N50E015.hgt.zip
+N50E016.hgt.zip
+N50E017.hgt.zip
+N50E018.hgt.zip
+N50E019.hgt.zip
+N50E020.hgt.zip
+N50E021.hgt.zip
+N50E022.hgt.zip
+N50E023.hgt.zip
+N50E024.hgt.zip
+N50E025.hgt.zip
+N50E026.hgt.zip
+N50E027.hgt.zip
+N50E028.hgt.zip
+N50E029.hgt.zip
+N50E030.hgt.zip
+N50E031.hgt.zip
+N50E032.hgt.zip
+N50E033.hgt.zip
+N50E034.hgt.zip
+N50E035.hgt.zip
+N50E036.hgt.zip
+N50E037.hgt.zip
+N50E038.hgt.zip
+N50E039.hgt.zip
+N50E040.hgt.zip
+N50E041.hgt.zip
+N50E042.hgt.zip
+N50E043.hgt.zip
+N50E044.hgt.zip
+N50E045.hgt.zip
+N50E046.hgt.zip
+N50E047.hgt.zip
+N50E048.hgt.zip
+N50E049.hgt.zip
+N50E050.hgt.zip
+N50E051.hgt.zip
+N50E052.hgt.zip
+N50E053.hgt.zip
+N50E054.hgt.zip
+N50E055.hgt.zip
+N50E056.hgt.zip
+N50E057.hgt.zip
+N50E058.hgt.zip
+N50E059.hgt.zip
+N50E060.hgt.zip
+N50E061.hgt.zip
+N50E062.hgt.zip
+N50E063.hgt.zip
+N50E064.hgt.zip
+N50E065.hgt.zip
+N50E066.hgt.zip
+N50E067.hgt.zip
+N50E068.hgt.zip
+N50E069.hgt.zip
+N50E070.hgt.zip
+N50E071.hgt.zip
+N50E072.hgt.zip
+N50E073.hgt.zip
+N50E074.hgt.zip
+N50E075.hgt.zip
+N50E076.hgt.zip
+N50E077.hgt.zip
+N50E078.hgt.zip
+N50E079.hgt.zip
+N50E080.hgt.zip
+N50E081.hgt.zip
+N50E082.hgt.zip
+N50E083.hgt.zip
+N50E084.hgt.zip
+N50E085.hgt.zip
+N50E086.hgt.zip
+N50E087.hgt.zip
+N50E088.hgt.zip
+N50E089.hgt.zip
+N50E090.hgt.zip
+N50E091.hgt.zip
+N50E092.hgt.zip
+N50E093.hgt.zip
+N50E094.hgt.zip
+N50E095.hgt.zip
+N50E096.hgt.zip
+N50E097.hgt.zip
+N50E098.hgt.zip
+N50E099.hgt.zip
+N50E100.hgt.zip
+N50E101.hgt.zip
+N50E102.hgt.zip
+N50E103.hgt.zip
+N50E104.hgt.zip
+N50E105.hgt.zip
+N50E106.hgt.zip
+N50E107.hgt.zip
+N50E108.hgt.zip
+N50E109.hgt.zip
+N50E110.hgt.zip
+N50E111.hgt.zip
+N50E112.hgt.zip
+N50E113.hgt.zip
+N50E114.hgt.zip
+N50E115.hgt.zip
+N50E116.hgt.zip
+N50E117.hgt.zip
+N50E118.hgt.zip
+N50E119.hgt.zip
+N50E120.hgt.zip
+N50E121.hgt.zip
+N50E122.hgt.zip
+N50E123.hgt.zip
+N50E124.hgt.zip
+N50E125.hgt.zip
+N50E126.hgt.zip
+N50E127.hgt.zip
+N50E128.hgt.zip
+N50E129.hgt.zip
+N50E130.hgt.zip
+N50E131.hgt.zip
+N50E132.hgt.zip
+N50E133.hgt.zip
+N50E134.hgt.zip
+N50E135.hgt.zip
+N50E136.hgt.zip
+N50E137.hgt.zip
+N50E138.hgt.zip
+N50E139.hgt.zip
+N50E140.hgt.zip
+N50E142.hgt.zip
+N50E143.hgt.zip
+N50E154.hgt.zip
+N50E155.hgt.zip
+N50E156.hgt.zip
+N50W001.hgt.zip
+N50W002.hgt.zip
+N50W003.hgt.zip
+N50W004.hgt.zip
+N50W005.hgt.zip
+N50W006.hgt.zip
+N51E000.hgt.zip
+N51E001.hgt.zip
+N51E002.hgt.zip
+N51E003.hgt.zip
+N51E004.hgt.zip
+N51E005.hgt.zip
+N51E006.hgt.zip
+N51E007.hgt.zip
+N51E008.hgt.zip
+N51E009.hgt.zip
+N51E010.hgt.zip
+N51E011.hgt.zip
+N51E012.hgt.zip
+N51E013.hgt.zip
+N51E014.hgt.zip
+N51E015.hgt.zip
+N51E016.hgt.zip
+N51E017.hgt.zip
+N51E018.hgt.zip
+N51E019.hgt.zip
+N51E020.hgt.zip
+N51E021.hgt.zip
+N51E022.hgt.zip
+N51E023.hgt.zip
+N51E024.hgt.zip
+N51E025.hgt.zip
+N51E026.hgt.zip
+N51E027.hgt.zip
+N51E028.hgt.zip
+N51E029.hgt.zip
+N51E030.hgt.zip
+N51E031.hgt.zip
+N51E032.hgt.zip
+N51E033.hgt.zip
+N51E034.hgt.zip
+N51E035.hgt.zip
+N51E036.hgt.zip
+N51E037.hgt.zip
+N51E038.hgt.zip
+N51E039.hgt.zip
+N51E040.hgt.zip
+N51E041.hgt.zip
+N51E042.hgt.zip
+N51E043.hgt.zip
+N51E044.hgt.zip
+N51E045.hgt.zip
+N51E046.hgt.zip
+N51E047.hgt.zip
+N51E048.hgt.zip
+N51E049.hgt.zip
+N51E050.hgt.zip
+N51E051.hgt.zip
+N51E052.hgt.zip
+N51E053.hgt.zip
+N51E054.hgt.zip
+N51E055.hgt.zip
+N51E056.hgt.zip
+N51E057.hgt.zip
+N51E058.hgt.zip
+N51E059.hgt.zip
+N51E060.hgt.zip
+N51E061.hgt.zip
+N51E062.hgt.zip
+N51E063.hgt.zip
+N51E064.hgt.zip
+N51E065.hgt.zip
+N51E066.hgt.zip
+N51E067.hgt.zip
+N51E068.hgt.zip
+N51E069.hgt.zip
+N51E070.hgt.zip
+N51E071.hgt.zip
+N51E072.hgt.zip
+N51E073.hgt.zip
+N51E074.hgt.zip
+N51E075.hgt.zip
+N51E076.hgt.zip
+N51E077.hgt.zip
+N51E078.hgt.zip
+N51E079.hgt.zip
+N51E080.hgt.zip
+N51E081.hgt.zip
+N51E082.hgt.zip
+N51E083.hgt.zip
+N51E084.hgt.zip
+N51E085.hgt.zip
+N51E086.hgt.zip
+N51E087.hgt.zip
+N51E088.hgt.zip
+N51E089.hgt.zip
+N51E090.hgt.zip
+N51E091.hgt.zip
+N51E092.hgt.zip
+N51E093.hgt.zip
+N51E094.hgt.zip
+N51E095.hgt.zip
+N51E096.hgt.zip
+N51E097.hgt.zip
+N51E098.hgt.zip
+N51E099.hgt.zip
+N51E100.hgt.zip
+N51E101.hgt.zip
+N51E102.hgt.zip
+N51E103.hgt.zip
+N51E104.hgt.zip
+N51E105.hgt.zip
+N51E106.hgt.zip
+N51E107.hgt.zip
+N51E108.hgt.zip
+N51E109.hgt.zip
+N51E110.hgt.zip
+N51E111.hgt.zip
+N51E112.hgt.zip
+N51E113.hgt.zip
+N51E114.hgt.zip
+N51E115.hgt.zip
+N51E116.hgt.zip
+N51E117.hgt.zip
+N51E118.hgt.zip
+N51E119.hgt.zip
+N51E120.hgt.zip
+N51E121.hgt.zip
+N51E122.hgt.zip
+N51E123.hgt.zip
+N51E124.hgt.zip
+N51E125.hgt.zip
+N51E126.hgt.zip
+N51E127.hgt.zip
+N51E128.hgt.zip
+N51E129.hgt.zip
+N51E130.hgt.zip
+N51E131.hgt.zip
+N51E132.hgt.zip
+N51E133.hgt.zip
+N51E134.hgt.zip
+N51E135.hgt.zip
+N51E136.hgt.zip
+N51E137.hgt.zip
+N51E138.hgt.zip
+N51E139.hgt.zip
+N51E140.hgt.zip
+N51E141.hgt.zip
+N51E142.hgt.zip
+N51E143.hgt.zip
+N51E156.hgt.zip
+N51E157.hgt.zip
+N51E158.hgt.zip
+N51W001.hgt.zip
+N51W002.hgt.zip
+N51W003.hgt.zip
+N51W004.hgt.zip
+N51W005.hgt.zip
+N51W006.hgt.zip
+N51W008.hgt.zip
+N51W009.hgt.zip
+N51W010.hgt.zip
+N51W011.hgt.zip
+N52E000.hgt.zip
+N52E001.hgt.zip
+N52E004.hgt.zip
+N52E005.hgt.zip
+N52E006.hgt.zip
+N52E007.hgt.zip
+N52E008.hgt.zip
+N52E009.hgt.zip
+N52E010.hgt.zip
+N52E011.hgt.zip
+N52E012.hgt.zip
+N52E013.hgt.zip
+N52E014.hgt.zip
+N52E015.hgt.zip
+N52E016.hgt.zip
+N52E017.hgt.zip
+N52E018.hgt.zip
+N52E019.hgt.zip
+N52E020.hgt.zip
+N52E021.hgt.zip
+N52E022.hgt.zip
+N52E023.hgt.zip
+N52E024.hgt.zip
+N52E025.hgt.zip
+N52E026.hgt.zip
+N52E027.hgt.zip
+N52E028.hgt.zip
+N52E029.hgt.zip
+N52E030.hgt.zip
+N52E031.hgt.zip
+N52E032.hgt.zip
+N52E033.hgt.zip
+N52E034.hgt.zip
+N52E035.hgt.zip
+N52E036.hgt.zip
+N52E037.hgt.zip
+N52E038.hgt.zip
+N52E039.hgt.zip
+N52E040.hgt.zip
+N52E041.hgt.zip
+N52E042.hgt.zip
+N52E043.hgt.zip
+N52E044.hgt.zip
+N52E045.hgt.zip
+N52E046.hgt.zip
+N52E047.hgt.zip
+N52E048.hgt.zip
+N52E049.hgt.zip
+N52E050.hgt.zip
+N52E051.hgt.zip
+N52E052.hgt.zip
+N52E053.hgt.zip
+N52E054.hgt.zip
+N52E055.hgt.zip
+N52E056.hgt.zip
+N52E057.hgt.zip
+N52E058.hgt.zip
+N52E059.hgt.zip
+N52E060.hgt.zip
+N52E061.hgt.zip
+N52E062.hgt.zip
+N52E063.hgt.zip
+N52E064.hgt.zip
+N52E065.hgt.zip
+N52E066.hgt.zip
+N52E067.hgt.zip
+N52E068.hgt.zip
+N52E069.hgt.zip
+N52E070.hgt.zip
+N52E071.hgt.zip
+N52E072.hgt.zip
+N52E073.hgt.zip
+N52E074.hgt.zip
+N52E075.hgt.zip
+N52E076.hgt.zip
+N52E077.hgt.zip
+N52E078.hgt.zip
+N52E079.hgt.zip
+N52E080.hgt.zip
+N52E081.hgt.zip
+N52E082.hgt.zip
+N52E083.hgt.zip
+N52E084.hgt.zip
+N52E085.hgt.zip
+N52E086.hgt.zip
+N52E087.hgt.zip
+N52E088.hgt.zip
+N52E089.hgt.zip
+N52E090.hgt.zip
+N52E091.hgt.zip
+N52E092.hgt.zip
+N52E093.hgt.zip
+N52E094.hgt.zip
+N52E095.hgt.zip
+N52E096.hgt.zip
+N52E097.hgt.zip
+N52E098.hgt.zip
+N52E099.hgt.zip
+N52E100.hgt.zip
+N52E101.hgt.zip
+N52E102.hgt.zip
+N52E103.hgt.zip
+N52E104.hgt.zip
+N52E105.hgt.zip
+N52E106.hgt.zip
+N52E107.hgt.zip
+N52E108.hgt.zip
+N52E109.hgt.zip
+N52E110.hgt.zip
+N52E111.hgt.zip
+N52E112.hgt.zip
+N52E113.hgt.zip
+N52E114.hgt.zip
+N52E115.hgt.zip
+N52E116.hgt.zip
+N52E117.hgt.zip
+N52E118.hgt.zip
+N52E119.hgt.zip
+N52E120.hgt.zip
+N52E121.hgt.zip
+N52E122.hgt.zip
+N52E123.hgt.zip
+N52E124.hgt.zip
+N52E125.hgt.zip
+N52E126.hgt.zip
+N52E127.hgt.zip
+N52E128.hgt.zip
+N52E129.hgt.zip
+N52E130.hgt.zip
+N52E131.hgt.zip
+N52E132.hgt.zip
+N52E133.hgt.zip
+N52E134.hgt.zip
+N52E135.hgt.zip
+N52E136.hgt.zip
+N52E137.hgt.zip
+N52E138.hgt.zip
+N52E139.hgt.zip
+N52E140.hgt.zip
+N52E141.hgt.zip
+N52E142.hgt.zip
+N52E143.hgt.zip
+N52E156.hgt.zip
+N52E157.hgt.zip
+N52E158.hgt.zip
+N52W001.hgt.zip
+N52W002.hgt.zip
+N52W003.hgt.zip
+N52W004.hgt.zip
+N52W005.hgt.zip
+N52W006.hgt.zip
+N52W007.hgt.zip
+N52W008.hgt.zip
+N52W009.hgt.zip
+N52W010.hgt.zip
+N52W011.hgt.zip
+N53E000.hgt.zip
+N53E004.hgt.zip
+N53E005.hgt.zip
+N53E006.hgt.zip
+N53E007.hgt.zip
+N53E008.hgt.zip
+N53E009.hgt.zip
+N53E010.hgt.zip
+N53E011.hgt.zip
+N53E012.hgt.zip
+N53E013.hgt.zip
+N53E014.hgt.zip
+N53E015.hgt.zip
+N53E016.hgt.zip
+N53E017.hgt.zip
+N53E018.hgt.zip
+N53E019.hgt.zip
+N53E020.hgt.zip
+N53E021.hgt.zip
+N53E022.hgt.zip
+N53E023.hgt.zip
+N53E024.hgt.zip
+N53E025.hgt.zip
+N53E026.hgt.zip
+N53E027.hgt.zip
+N53E028.hgt.zip
+N53E029.hgt.zip
+N53E030.hgt.zip
+N53E031.hgt.zip
+N53E032.hgt.zip
+N53E033.hgt.zip
+N53E034.hgt.zip
+N53E035.hgt.zip
+N53E036.hgt.zip
+N53E037.hgt.zip
+N53E038.hgt.zip
+N53E039.hgt.zip
+N53E040.hgt.zip
+N53E041.hgt.zip
+N53E042.hgt.zip
+N53E043.hgt.zip
+N53E044.hgt.zip
+N53E045.hgt.zip
+N53E046.hgt.zip
+N53E047.hgt.zip
+N53E048.hgt.zip
+N53E049.hgt.zip
+N53E050.hgt.zip
+N53E051.hgt.zip
+N53E052.hgt.zip
+N53E053.hgt.zip
+N53E054.hgt.zip
+N53E055.hgt.zip
+N53E056.hgt.zip
+N53E057.hgt.zip
+N53E058.hgt.zip
+N53E059.hgt.zip
+N53E060.hgt.zip
+N53E061.hgt.zip
+N53E062.hgt.zip
+N53E063.hgt.zip
+N53E064.hgt.zip
+N53E065.hgt.zip
+N53E066.hgt.zip
+N53E067.hgt.zip
+N53E068.hgt.zip
+N53E069.hgt.zip
+N53E070.hgt.zip
+N53E071.hgt.zip
+N53E072.hgt.zip
+N53E073.hgt.zip
+N53E074.hgt.zip
+N53E075.hgt.zip
+N53E076.hgt.zip
+N53E077.hgt.zip
+N53E078.hgt.zip
+N53E079.hgt.zip
+N53E080.hgt.zip
+N53E081.hgt.zip
+N53E082.hgt.zip
+N53E083.hgt.zip
+N53E084.hgt.zip
+N53E085.hgt.zip
+N53E086.hgt.zip
+N53E087.hgt.zip
+N53E088.hgt.zip
+N53E089.hgt.zip
+N53E090.hgt.zip
+N53E091.hgt.zip
+N53E092.hgt.zip
+N53E093.hgt.zip
+N53E094.hgt.zip
+N53E095.hgt.zip
+N53E096.hgt.zip
+N53E097.hgt.zip
+N53E098.hgt.zip
+N53E099.hgt.zip
+N53E100.hgt.zip
+N53E101.hgt.zip
+N53E102.hgt.zip
+N53E103.hgt.zip
+N53E104.hgt.zip
+N53E105.hgt.zip
+N53E106.hgt.zip
+N53E107.hgt.zip
+N53E108.hgt.zip
+N53E109.hgt.zip
+N53E110.hgt.zip
+N53E111.hgt.zip
+N53E112.hgt.zip
+N53E113.hgt.zip
+N53E114.hgt.zip
+N53E115.hgt.zip
+N53E116.hgt.zip
+N53E117.hgt.zip
+N53E118.hgt.zip
+N53E119.hgt.zip
+N53E120.hgt.zip
+N53E121.hgt.zip
+N53E122.hgt.zip
+N53E123.hgt.zip
+N53E124.hgt.zip
+N53E125.hgt.zip
+N53E126.hgt.zip
+N53E127.hgt.zip
+N53E128.hgt.zip
+N53E129.hgt.zip
+N53E130.hgt.zip
+N53E131.hgt.zip
+N53E132.hgt.zip
+N53E133.hgt.zip
+N53E134.hgt.zip
+N53E135.hgt.zip
+N53E136.hgt.zip
+N53E137.hgt.zip
+N53E138.hgt.zip
+N53E139.hgt.zip
+N53E140.hgt.zip
+N53E141.hgt.zip
+N53E142.hgt.zip
+N53E143.hgt.zip
+N53E155.hgt.zip
+N53E156.hgt.zip
+N53E157.hgt.zip
+N53E158.hgt.zip
+N53E159.hgt.zip
+N53E160.hgt.zip
+N53W001.hgt.zip
+N53W002.hgt.zip
+N53W003.hgt.zip
+N53W004.hgt.zip
+N53W005.hgt.zip
+N53W006.hgt.zip
+N53W007.hgt.zip
+N53W008.hgt.zip
+N53W009.hgt.zip
+N53W010.hgt.zip
+N53W011.hgt.zip
+N54E007.hgt.zip
+N54E008.hgt.zip
+N54E009.hgt.zip
+N54E010.hgt.zip
+N54E011.hgt.zip
+N54E012.hgt.zip
+N54E013.hgt.zip
+N54E014.hgt.zip
+N54E015.hgt.zip
+N54E016.hgt.zip
+N54E017.hgt.zip
+N54E018.hgt.zip
+N54E019.hgt.zip
+N54E020.hgt.zip
+N54E021.hgt.zip
+N54E022.hgt.zip
+N54E023.hgt.zip
+N54E024.hgt.zip
+N54E025.hgt.zip
+N54E026.hgt.zip
+N54E027.hgt.zip
+N54E028.hgt.zip
+N54E029.hgt.zip
+N54E030.hgt.zip
+N54E031.hgt.zip
+N54E032.hgt.zip
+N54E033.hgt.zip
+N54E034.hgt.zip
+N54E035.hgt.zip
+N54E036.hgt.zip
+N54E037.hgt.zip
+N54E038.hgt.zip
+N54E039.hgt.zip
+N54E040.hgt.zip
+N54E041.hgt.zip
+N54E042.hgt.zip
+N54E043.hgt.zip
+N54E044.hgt.zip
+N54E045.hgt.zip
+N54E046.hgt.zip
+N54E047.hgt.zip
+N54E048.hgt.zip
+N54E049.hgt.zip
+N54E050.hgt.zip
+N54E051.hgt.zip
+N54E052.hgt.zip
+N54E053.hgt.zip
+N54E054.hgt.zip
+N54E055.hgt.zip
+N54E056.hgt.zip
+N54E057.hgt.zip
+N54E058.hgt.zip
+N54E059.hgt.zip
+N54E060.hgt.zip
+N54E061.hgt.zip
+N54E062.hgt.zip
+N54E063.hgt.zip
+N54E064.hgt.zip
+N54E065.hgt.zip
+N54E066.hgt.zip
+N54E067.hgt.zip
+N54E068.hgt.zip
+N54E069.hgt.zip
+N54E070.hgt.zip
+N54E071.hgt.zip
+N54E072.hgt.zip
+N54E073.hgt.zip
+N54E074.hgt.zip
+N54E075.hgt.zip
+N54E076.hgt.zip
+N54E077.hgt.zip
+N54E078.hgt.zip
+N54E079.hgt.zip
+N54E080.hgt.zip
+N54E081.hgt.zip
+N54E082.hgt.zip
+N54E083.hgt.zip
+N54E084.hgt.zip
+N54E085.hgt.zip
+N54E086.hgt.zip
+N54E087.hgt.zip
+N54E088.hgt.zip
+N54E089.hgt.zip
+N54E090.hgt.zip
+N54E091.hgt.zip
+N54E092.hgt.zip
+N54E093.hgt.zip
+N54E094.hgt.zip
+N54E095.hgt.zip
+N54E096.hgt.zip
+N54E097.hgt.zip
+N54E098.hgt.zip
+N54E099.hgt.zip
+N54E100.hgt.zip
+N54E101.hgt.zip
+N54E102.hgt.zip
+N54E103.hgt.zip
+N54E104.hgt.zip
+N54E105.hgt.zip
+N54E106.hgt.zip
+N54E107.hgt.zip
+N54E108.hgt.zip
+N54E109.hgt.zip
+N54E110.hgt.zip
+N54E111.hgt.zip
+N54E112.hgt.zip
+N54E113.hgt.zip
+N54E114.hgt.zip
+N54E115.hgt.zip
+N54E116.hgt.zip
+N54E117.hgt.zip
+N54E118.hgt.zip
+N54E119.hgt.zip
+N54E120.hgt.zip
+N54E121.hgt.zip
+N54E122.hgt.zip
+N54E123.hgt.zip
+N54E124.hgt.zip
+N54E125.hgt.zip
+N54E126.hgt.zip
+N54E127.hgt.zip
+N54E128.hgt.zip
+N54E129.hgt.zip
+N54E130.hgt.zip
+N54E131.hgt.zip
+N54E132.hgt.zip
+N54E133.hgt.zip
+N54E134.hgt.zip
+N54E135.hgt.zip
+N54E136.hgt.zip
+N54E137.hgt.zip
+N54E138.hgt.zip
+N54E139.hgt.zip
+N54E140.hgt.zip
+N54E142.hgt.zip
+N54E155.hgt.zip
+N54E156.hgt.zip
+N54E157.hgt.zip
+N54E158.hgt.zip
+N54E159.hgt.zip
+N54E160.hgt.zip
+N54E161.hgt.zip
+N54E162.hgt.zip
+N54E166.hgt.zip
+N54E167.hgt.zip
+N54E168.hgt.zip
+N54W001.hgt.zip
+N54W002.hgt.zip
+N54W003.hgt.zip
+N54W004.hgt.zip
+N54W005.hgt.zip
+N54W006.hgt.zip
+N54W007.hgt.zip
+N54W008.hgt.zip
+N54W009.hgt.zip
+N54W010.hgt.zip
+N54W011.hgt.zip
+N55E008.hgt.zip
+N55E009.hgt.zip
+N55E010.hgt.zip
+N55E011.hgt.zip
+N55E012.hgt.zip
+N55E013.hgt.zip
+N55E014.hgt.zip
+N55E015.hgt.zip
+N55E020.hgt.zip
+N55E021.hgt.zip
+N55E022.hgt.zip
+N55E023.hgt.zip
+N55E024.hgt.zip
+N55E025.hgt.zip
+N55E026.hgt.zip
+N55E027.hgt.zip
+N55E028.hgt.zip
+N55E029.hgt.zip
+N55E030.hgt.zip
+N55E031.hgt.zip
+N55E032.hgt.zip
+N55E033.hgt.zip
+N55E034.hgt.zip
+N55E035.hgt.zip
+N55E036.hgt.zip
+N55E037.hgt.zip
+N55E038.hgt.zip
+N55E039.hgt.zip
+N55E040.hgt.zip
+N55E041.hgt.zip
+N55E042.hgt.zip
+N55E043.hgt.zip
+N55E044.hgt.zip
+N55E045.hgt.zip
+N55E046.hgt.zip
+N55E047.hgt.zip
+N55E048.hgt.zip
+N55E049.hgt.zip
+N55E050.hgt.zip
+N55E051.hgt.zip
+N55E052.hgt.zip
+N55E053.hgt.zip
+N55E054.hgt.zip
+N55E055.hgt.zip
+N55E056.hgt.zip
+N55E057.hgt.zip
+N55E058.hgt.zip
+N55E059.hgt.zip
+N55E060.hgt.zip
+N55E061.hgt.zip
+N55E062.hgt.zip
+N55E063.hgt.zip
+N55E064.hgt.zip
+N55E065.hgt.zip
+N55E066.hgt.zip
+N55E067.hgt.zip
+N55E068.hgt.zip
+N55E069.hgt.zip
+N55E070.hgt.zip
+N55E071.hgt.zip
+N55E072.hgt.zip
+N55E073.hgt.zip
+N55E074.hgt.zip
+N55E075.hgt.zip
+N55E076.hgt.zip
+N55E077.hgt.zip
+N55E078.hgt.zip
+N55E079.hgt.zip
+N55E080.hgt.zip
+N55E081.hgt.zip
+N55E082.hgt.zip
+N55E083.hgt.zip
+N55E084.hgt.zip
+N55E085.hgt.zip
+N55E086.hgt.zip
+N55E087.hgt.zip
+N55E088.hgt.zip
+N55E089.hgt.zip
+N55E090.hgt.zip
+N55E091.hgt.zip
+N55E092.hgt.zip
+N55E093.hgt.zip
+N55E094.hgt.zip
+N55E095.hgt.zip
+N55E096.hgt.zip
+N55E097.hgt.zip
+N55E098.hgt.zip
+N55E099.hgt.zip
+N55E100.hgt.zip
+N55E101.hgt.zip
+N55E102.hgt.zip
+N55E103.hgt.zip
+N55E104.hgt.zip
+N55E105.hgt.zip
+N55E106.hgt.zip
+N55E107.hgt.zip
+N55E108.hgt.zip
+N55E109.hgt.zip
+N55E110.hgt.zip
+N55E111.hgt.zip
+N55E112.hgt.zip
+N55E113.hgt.zip
+N55E114.hgt.zip
+N55E115.hgt.zip
+N55E116.hgt.zip
+N55E117.hgt.zip
+N55E118.hgt.zip
+N55E119.hgt.zip
+N55E120.hgt.zip
+N55E121.hgt.zip
+N55E122.hgt.zip
+N55E123.hgt.zip
+N55E124.hgt.zip
+N55E125.hgt.zip
+N55E126.hgt.zip
+N55E127.hgt.zip
+N55E128.hgt.zip
+N55E129.hgt.zip
+N55E130.hgt.zip
+N55E131.hgt.zip
+N55E132.hgt.zip
+N55E133.hgt.zip
+N55E134.hgt.zip
+N55E135.hgt.zip
+N55E136.hgt.zip
+N55E137.hgt.zip
+N55E138.hgt.zip
+N55E155.hgt.zip
+N55E156.hgt.zip
+N55E157.hgt.zip
+N55E158.hgt.zip
+N55E159.hgt.zip
+N55E160.hgt.zip
+N55E161.hgt.zip
+N55E162.hgt.zip
+N55E165.hgt.zip
+N55E166.hgt.zip
+N55W002.hgt.zip
+N55W003.hgt.zip
+N55W004.hgt.zip
+N55W005.hgt.zip
+N55W006.hgt.zip
+N55W007.hgt.zip
+N55W008.hgt.zip
+N55W009.hgt.zip
+N56E008.hgt.zip
+N56E009.hgt.zip
+N56E010.hgt.zip
+N56E011.hgt.zip
+N56E012.hgt.zip
+N56E013.hgt.zip
+N56E014.hgt.zip
+N56E015.hgt.zip
+N56E016.hgt.zip
+N56E018.hgt.zip
+N56E020.hgt.zip
+N56E021.hgt.zip
+N56E022.hgt.zip
+N56E023.hgt.zip
+N56E024.hgt.zip
+N56E025.hgt.zip
+N56E026.hgt.zip
+N56E027.hgt.zip
+N56E028.hgt.zip
+N56E029.hgt.zip
+N56E030.hgt.zip
+N56E031.hgt.zip
+N56E032.hgt.zip
+N56E033.hgt.zip
+N56E034.hgt.zip
+N56E035.hgt.zip
+N56E036.hgt.zip
+N56E037.hgt.zip
+N56E038.hgt.zip
+N56E039.hgt.zip
+N56E040.hgt.zip
+N56E041.hgt.zip
+N56E042.hgt.zip
+N56E043.hgt.zip
+N56E044.hgt.zip
+N56E045.hgt.zip
+N56E046.hgt.zip
+N56E047.hgt.zip
+N56E048.hgt.zip
+N56E049.hgt.zip
+N56E050.hgt.zip
+N56E051.hgt.zip
+N56E052.hgt.zip
+N56E053.hgt.zip
+N56E054.hgt.zip
+N56E055.hgt.zip
+N56E056.hgt.zip
+N56E057.hgt.zip
+N56E058.hgt.zip
+N56E059.hgt.zip
+N56E060.hgt.zip
+N56E061.hgt.zip
+N56E062.hgt.zip
+N56E063.hgt.zip
+N56E064.hgt.zip
+N56E065.hgt.zip
+N56E066.hgt.zip
+N56E067.hgt.zip
+N56E068.hgt.zip
+N56E069.hgt.zip
+N56E070.hgt.zip
+N56E071.hgt.zip
+N56E072.hgt.zip
+N56E073.hgt.zip
+N56E074.hgt.zip
+N56E075.hgt.zip
+N56E076.hgt.zip
+N56E077.hgt.zip
+N56E078.hgt.zip
+N56E079.hgt.zip
+N56E080.hgt.zip
+N56E081.hgt.zip
+N56E082.hgt.zip
+N56E083.hgt.zip
+N56E084.hgt.zip
+N56E085.hgt.zip
+N56E086.hgt.zip
+N56E087.hgt.zip
+N56E088.hgt.zip
+N56E089.hgt.zip
+N56E090.hgt.zip
+N56E091.hgt.zip
+N56E092.hgt.zip
+N56E093.hgt.zip
+N56E094.hgt.zip
+N56E095.hgt.zip
+N56E096.hgt.zip
+N56E097.hgt.zip
+N56E098.hgt.zip
+N56E099.hgt.zip
+N56E100.hgt.zip
+N56E101.hgt.zip
+N56E102.hgt.zip
+N56E103.hgt.zip
+N56E104.hgt.zip
+N56E105.hgt.zip
+N56E106.hgt.zip
+N56E107.hgt.zip
+N56E108.hgt.zip
+N56E109.hgt.zip
+N56E110.hgt.zip
+N56E111.hgt.zip
+N56E112.hgt.zip
+N56E113.hgt.zip
+N56E114.hgt.zip
+N56E115.hgt.zip
+N56E116.hgt.zip
+N56E117.hgt.zip
+N56E118.hgt.zip
+N56E119.hgt.zip
+N56E120.hgt.zip
+N56E121.hgt.zip
+N56E122.hgt.zip
+N56E123.hgt.zip
+N56E124.hgt.zip
+N56E125.hgt.zip
+N56E126.hgt.zip
+N56E127.hgt.zip
+N56E128.hgt.zip
+N56E129.hgt.zip
+N56E130.hgt.zip
+N56E131.hgt.zip
+N56E132.hgt.zip
+N56E133.hgt.zip
+N56E134.hgt.zip
+N56E135.hgt.zip
+N56E136.hgt.zip
+N56E137.hgt.zip
+N56E138.hgt.zip
+N56E143.hgt.zip
+N56E155.hgt.zip
+N56E156.hgt.zip
+N56E157.hgt.zip
+N56E158.hgt.zip
+N56E159.hgt.zip
+N56E160.hgt.zip
+N56E161.hgt.zip
+N56E162.hgt.zip
+N56E163.hgt.zip
+N56W003.hgt.zip
+N56W004.hgt.zip
+N56W005.hgt.zip
+N56W006.hgt.zip
+N56W007.hgt.zip
+N56W008.hgt.zip
+N57E006.hgt.zip
+N57E007.hgt.zip
+N57E008.hgt.zip
+N57E009.hgt.zip
+N57E010.hgt.zip
+N57E011.hgt.zip
+N57E012.hgt.zip
+N57E013.hgt.zip
+N57E014.hgt.zip
+N57E015.hgt.zip
+N57E016.hgt.zip
+N57E017.hgt.zip
+N57E018.hgt.zip
+N57E019.hgt.zip
+N57E021.hgt.zip
+N57E022.hgt.zip
+N57E023.hgt.zip
+N57E024.hgt.zip
+N57E025.hgt.zip
+N57E026.hgt.zip
+N57E027.hgt.zip
+N57E028.hgt.zip
+N57E029.hgt.zip
+N57E030.hgt.zip
+N57E031.hgt.zip
+N57E032.hgt.zip
+N57E033.hgt.zip
+N57E034.hgt.zip
+N57E035.hgt.zip
+N57E036.hgt.zip
+N57E037.hgt.zip
+N57E038.hgt.zip
+N57E039.hgt.zip
+N57E040.hgt.zip
+N57E041.hgt.zip
+N57E042.hgt.zip
+N57E043.hgt.zip
+N57E044.hgt.zip
+N57E045.hgt.zip
+N57E046.hgt.zip
+N57E047.hgt.zip
+N57E048.hgt.zip
+N57E049.hgt.zip
+N57E050.hgt.zip
+N57E051.hgt.zip
+N57E052.hgt.zip
+N57E053.hgt.zip
+N57E054.hgt.zip
+N57E055.hgt.zip
+N57E056.hgt.zip
+N57E057.hgt.zip
+N57E058.hgt.zip
+N57E059.hgt.zip
+N57E060.hgt.zip
+N57E061.hgt.zip
+N57E062.hgt.zip
+N57E063.hgt.zip
+N57E064.hgt.zip
+N57E065.hgt.zip
+N57E066.hgt.zip
+N57E067.hgt.zip
+N57E068.hgt.zip
+N57E069.hgt.zip
+N57E070.hgt.zip
+N57E071.hgt.zip
+N57E072.hgt.zip
+N57E073.hgt.zip
+N57E074.hgt.zip
+N57E075.hgt.zip
+N57E076.hgt.zip
+N57E077.hgt.zip
+N57E078.hgt.zip
+N57E079.hgt.zip
+N57E080.hgt.zip
+N57E081.hgt.zip
+N57E082.hgt.zip
+N57E083.hgt.zip
+N57E084.hgt.zip
+N57E085.hgt.zip
+N57E086.hgt.zip
+N57E087.hgt.zip
+N57E088.hgt.zip
+N57E089.hgt.zip
+N57E090.hgt.zip
+N57E091.hgt.zip
+N57E092.hgt.zip
+N57E093.hgt.zip
+N57E094.hgt.zip
+N57E095.hgt.zip
+N57E096.hgt.zip
+N57E097.hgt.zip
+N57E098.hgt.zip
+N57E099.hgt.zip
+N57E100.hgt.zip
+N57E101.hgt.zip
+N57E102.hgt.zip
+N57E103.hgt.zip
+N57E104.hgt.zip
+N57E105.hgt.zip
+N57E106.hgt.zip
+N57E107.hgt.zip
+N57E108.hgt.zip
+N57E109.hgt.zip
+N57E110.hgt.zip
+N57E111.hgt.zip
+N57E112.hgt.zip
+N57E113.hgt.zip
+N57E114.hgt.zip
+N57E115.hgt.zip
+N57E116.hgt.zip
+N57E117.hgt.zip
+N57E118.hgt.zip
+N57E119.hgt.zip
+N57E120.hgt.zip
+N57E121.hgt.zip
+N57E122.hgt.zip
+N57E123.hgt.zip
+N57E124.hgt.zip
+N57E125.hgt.zip
+N57E126.hgt.zip
+N57E127.hgt.zip
+N57E128.hgt.zip
+N57E129.hgt.zip
+N57E130.hgt.zip
+N57E131.hgt.zip
+N57E132.hgt.zip
+N57E133.hgt.zip
+N57E134.hgt.zip
+N57E135.hgt.zip
+N57E136.hgt.zip
+N57E137.hgt.zip
+N57E138.hgt.zip
+N57E139.hgt.zip
+N57E140.hgt.zip
+N57E156.hgt.zip
+N57E157.hgt.zip
+N57E158.hgt.zip
+N57E159.hgt.zip
+N57E160.hgt.zip
+N57E161.hgt.zip
+N57E162.hgt.zip
+N57E163.hgt.zip
+N57W002.hgt.zip
+N57W003.hgt.zip
+N57W004.hgt.zip
+N57W005.hgt.zip
+N57W006.hgt.zip
+N57W007.hgt.zip
+N57W008.hgt.zip
+N57W009.hgt.zip
+N57W014.hgt.zip
+N58E005.hgt.zip
+N58E006.hgt.zip
+N58E007.hgt.zip
+N58E008.hgt.zip
+N58E009.hgt.zip
+N58E010.hgt.zip
+N58E011.hgt.zip
+N58E012.hgt.zip
+N58E013.hgt.zip
+N58E014.hgt.zip
+N58E015.hgt.zip
+N58E016.hgt.zip
+N58E017.hgt.zip
+N58E018.hgt.zip
+N58E019.hgt.zip
+N58E021.hgt.zip
+N58E022.hgt.zip
+N58E023.hgt.zip
+N58E024.hgt.zip
+N58E025.hgt.zip
+N58E026.hgt.zip
+N58E027.hgt.zip
+N58E028.hgt.zip
+N58E029.hgt.zip
+N58E030.hgt.zip
+N58E031.hgt.zip
+N58E032.hgt.zip
+N58E033.hgt.zip
+N58E034.hgt.zip
+N58E035.hgt.zip
+N58E036.hgt.zip
+N58E037.hgt.zip
+N58E038.hgt.zip
+N58E039.hgt.zip
+N58E040.hgt.zip
+N58E041.hgt.zip
+N58E042.hgt.zip
+N58E043.hgt.zip
+N58E044.hgt.zip
+N58E045.hgt.zip
+N58E046.hgt.zip
+N58E047.hgt.zip
+N58E048.hgt.zip
+N58E049.hgt.zip
+N58E050.hgt.zip
+N58E051.hgt.zip
+N58E052.hgt.zip
+N58E053.hgt.zip
+N58E054.hgt.zip
+N58E055.hgt.zip
+N58E056.hgt.zip
+N58E057.hgt.zip
+N58E058.hgt.zip
+N58E059.hgt.zip
+N58E060.hgt.zip
+N58E061.hgt.zip
+N58E062.hgt.zip
+N58E063.hgt.zip
+N58E064.hgt.zip
+N58E065.hgt.zip
+N58E066.hgt.zip
+N58E067.hgt.zip
+N58E068.hgt.zip
+N58E069.hgt.zip
+N58E070.hgt.zip
+N58E071.hgt.zip
+N58E072.hgt.zip
+N58E073.hgt.zip
+N58E074.hgt.zip
+N58E075.hgt.zip
+N58E076.hgt.zip
+N58E077.hgt.zip
+N58E078.hgt.zip
+N58E079.hgt.zip
+N58E080.hgt.zip
+N58E081.hgt.zip
+N58E082.hgt.zip
+N58E083.hgt.zip
+N58E084.hgt.zip
+N58E085.hgt.zip
+N58E086.hgt.zip
+N58E087.hgt.zip
+N58E088.hgt.zip
+N58E089.hgt.zip
+N58E090.hgt.zip
+N58E091.hgt.zip
+N58E092.hgt.zip
+N58E093.hgt.zip
+N58E094.hgt.zip
+N58E095.hgt.zip
+N58E096.hgt.zip
+N58E097.hgt.zip
+N58E098.hgt.zip
+N58E099.hgt.zip
+N58E100.hgt.zip
+N58E101.hgt.zip
+N58E102.hgt.zip
+N58E103.hgt.zip
+N58E104.hgt.zip
+N58E105.hgt.zip
+N58E106.hgt.zip
+N58E107.hgt.zip
+N58E108.hgt.zip
+N58E109.hgt.zip
+N58E110.hgt.zip
+N58E111.hgt.zip
+N58E112.hgt.zip
+N58E113.hgt.zip
+N58E114.hgt.zip
+N58E115.hgt.zip
+N58E116.hgt.zip
+N58E117.hgt.zip
+N58E118.hgt.zip
+N58E119.hgt.zip
+N58E120.hgt.zip
+N58E121.hgt.zip
+N58E122.hgt.zip
+N58E123.hgt.zip
+N58E124.hgt.zip
+N58E125.hgt.zip
+N58E126.hgt.zip
+N58E127.hgt.zip
+N58E128.hgt.zip
+N58E129.hgt.zip
+N58E130.hgt.zip
+N58E131.hgt.zip
+N58E132.hgt.zip
+N58E133.hgt.zip
+N58E134.hgt.zip
+N58E135.hgt.zip
+N58E136.hgt.zip
+N58E137.hgt.zip
+N58E138.hgt.zip
+N58E139.hgt.zip
+N58E140.hgt.zip
+N58E141.hgt.zip
+N58E142.hgt.zip
+N58E150.hgt.zip
+N58E151.hgt.zip
+N58E152.hgt.zip
+N58E157.hgt.zip
+N58E158.hgt.zip
+N58E159.hgt.zip
+N58E160.hgt.zip
+N58E161.hgt.zip
+N58E162.hgt.zip
+N58E163.hgt.zip
+N58E164.hgt.zip
+N58W003.hgt.zip
+N58W004.hgt.zip
+N58W005.hgt.zip
+N58W006.hgt.zip
+N58W007.hgt.zip
+N58W008.hgt.zip
+N59E004.hgt.zip
+N59E005.hgt.zip
+N59E006.hgt.zip
+N59E007.hgt.zip
+N59E008.hgt.zip
+N59E009.hgt.zip
+N59E010.hgt.zip
+N59E011.hgt.zip
+N59E012.hgt.zip
+N59E013.hgt.zip
+N59E014.hgt.zip
+N59E015.hgt.zip
+N59E016.hgt.zip
+N59E017.hgt.zip
+N59E018.hgt.zip
+N59E019.hgt.zip
+N59E020.hgt.zip
+N59E021.hgt.zip
+N59E022.hgt.zip
+N59E023.hgt.zip
+N59E024.hgt.zip
+N59E025.hgt.zip
+N59E026.hgt.zip
+N59E027.hgt.zip
+N59E028.hgt.zip
+N59E029.hgt.zip
+N59E030.hgt.zip
+N59E031.hgt.zip
+N59E032.hgt.zip
+N59E033.hgt.zip
+N59E034.hgt.zip
+N59E035.hgt.zip
+N59E036.hgt.zip
+N59E037.hgt.zip
+N59E038.hgt.zip
+N59E039.hgt.zip
+N59E040.hgt.zip
+N59E041.hgt.zip
+N59E042.hgt.zip
+N59E043.hgt.zip
+N59E044.hgt.zip
+N59E045.hgt.zip
+N59E046.hgt.zip
+N59E047.hgt.zip
+N59E048.hgt.zip
+N59E049.hgt.zip
+N59E050.hgt.zip
+N59E051.hgt.zip
+N59E052.hgt.zip
+N59E053.hgt.zip
+N59E054.hgt.zip
+N59E055.hgt.zip
+N59E056.hgt.zip
+N59E057.hgt.zip
+N59E058.hgt.zip
+N59E059.hgt.zip
+N59E060.hgt.zip
+N59E061.hgt.zip
+N59E062.hgt.zip
+N59E063.hgt.zip
+N59E064.hgt.zip
+N59E065.hgt.zip
+N59E066.hgt.zip
+N59E067.hgt.zip
+N59E068.hgt.zip
+N59E069.hgt.zip
+N59E070.hgt.zip
+N59E071.hgt.zip
+N59E072.hgt.zip
+N59E073.hgt.zip
+N59E074.hgt.zip
+N59E075.hgt.zip
+N59E076.hgt.zip
+N59E077.hgt.zip
+N59E078.hgt.zip
+N59E079.hgt.zip
+N59E080.hgt.zip
+N59E081.hgt.zip
+N59E082.hgt.zip
+N59E083.hgt.zip
+N59E084.hgt.zip
+N59E085.hgt.zip
+N59E086.hgt.zip
+N59E087.hgt.zip
+N59E088.hgt.zip
+N59E089.hgt.zip
+N59E090.hgt.zip
+N59E091.hgt.zip
+N59E092.hgt.zip
+N59E093.hgt.zip
+N59E094.hgt.zip
+N59E095.hgt.zip
+N59E096.hgt.zip
+N59E097.hgt.zip
+N59E098.hgt.zip
+N59E099.hgt.zip
+N59E100.hgt.zip
+N59E101.hgt.zip
+N59E102.hgt.zip
+N59E103.hgt.zip
+N59E104.hgt.zip
+N59E105.hgt.zip
+N59E106.hgt.zip
+N59E107.hgt.zip
+N59E108.hgt.zip
+N59E109.hgt.zip
+N59E110.hgt.zip
+N59E111.hgt.zip
+N59E112.hgt.zip
+N59E113.hgt.zip
+N59E114.hgt.zip
+N59E115.hgt.zip
+N59E116.hgt.zip
+N59E117.hgt.zip
+N59E118.hgt.zip
+N59E119.hgt.zip
+N59E120.hgt.zip
+N59E121.hgt.zip
+N59E122.hgt.zip
+N59E123.hgt.zip
+N59E124.hgt.zip
+N59E125.hgt.zip
+N59E126.hgt.zip
+N59E127.hgt.zip
+N59E128.hgt.zip
+N59E129.hgt.zip
+N59E130.hgt.zip
+N59E131.hgt.zip
+N59E132.hgt.zip
+N59E133.hgt.zip
+N59E134.hgt.zip
+N59E135.hgt.zip
+N59E136.hgt.zip
+N59E137.hgt.zip
+N59E138.hgt.zip
+N59E139.hgt.zip
+N59E140.hgt.zip
+N59E141.hgt.zip
+N59E142.hgt.zip
+N59E143.hgt.zip
+N59E144.hgt.zip
+N59E145.hgt.zip
+N59E146.hgt.zip
+N59E147.hgt.zip
+N59E148.hgt.zip
+N59E149.hgt.zip
+N59E150.hgt.zip
+N59E151.hgt.zip
+N59E152.hgt.zip
+N59E153.hgt.zip
+N59E154.hgt.zip
+N59E155.hgt.zip
+N59E159.hgt.zip
+N59E160.hgt.zip
+N59E161.hgt.zip
+N59E162.hgt.zip
+N59E163.hgt.zip
+N59E164.hgt.zip
+N59E165.hgt.zip
+N59E166.hgt.zip
+N59W002.hgt.zip
+N59W003.hgt.zip
+N59W004.hgt.zip
+N59W005.hgt.zip
+N59W006.hgt.zip
+N59W007.hgt.zip
+N60E004.hgt.zip
+N60E005.hgt.zip
+N60E006.hgt.zip
+N60E007.hgt.zip
+N60E008.hgt.zip
+N60E009.hgt.zip
+N60E010.hgt.zip
+N60E011.hgt.zip
+N60E012.hgt.zip
+N60E013.hgt.zip
+N60E014.hgt.zip
+N60E015.hgt.zip
+N60E016.hgt.zip
+N60E017.hgt.zip
+N60E018.hgt.zip
+N60E019.hgt.zip
+N60E020.hgt.zip
+N60E021.hgt.zip
+N60E022.hgt.zip
+N60E023.hgt.zip
+N60E024.hgt.zip
+N60E025.hgt.zip
+N60E026.hgt.zip
+N60E027.hgt.zip
+N60E028.hgt.zip
+N60E029.hgt.zip
+N60E030.hgt.zip
+N60E031.hgt.zip
+N60E032.hgt.zip
+N60E033.hgt.zip
+N60E034.hgt.zip
+N60E035.hgt.zip
+N60E036.hgt.zip
+N60E037.hgt.zip
+N60E038.hgt.zip
+N60E039.hgt.zip
+N60E040.hgt.zip
+N60E041.hgt.zip
+N60E042.hgt.zip
+N60E043.hgt.zip
+N60E044.hgt.zip
+N60E045.hgt.zip
+N60E046.hgt.zip
+N60E047.hgt.zip
+N60E048.hgt.zip
+N60E049.hgt.zip
+N60E050.hgt.zip
+N60E051.hgt.zip
+N60E052.hgt.zip
+N60E053.hgt.zip
+N60E054.hgt.zip
+N60E055.hgt.zip
+N60E056.hgt.zip
+N60E057.hgt.zip
+N60E058.hgt.zip
+N60E059.hgt.zip
+N60E060.hgt.zip
+N60E061.hgt.zip
+N60E062.hgt.zip
+N60E063.hgt.zip
+N60E064.hgt.zip
+N60E065.hgt.zip
+N60E066.hgt.zip
+N60E067.hgt.zip
+N60E068.hgt.zip
+N60E069.hgt.zip
+N60E070.hgt.zip
+N60E071.hgt.zip
+N60E072.hgt.zip
+N60E073.hgt.zip
+N60E074.hgt.zip
+N60E075.hgt.zip
+N60E076.hgt.zip
+N60E077.hgt.zip
+N60E078.hgt.zip
+N60E079.hgt.zip
+N60E080.hgt.zip
+N60E081.hgt.zip
+N60E082.hgt.zip
+N60E083.hgt.zip
+N60E084.hgt.zip
+N60E085.hgt.zip
+N60E086.hgt.zip
+N60E087.hgt.zip
+N60E088.hgt.zip
+N60E089.hgt.zip
+N60E090.hgt.zip
+N60E091.hgt.zip
+N60E092.hgt.zip
+N60E093.hgt.zip
+N60E094.hgt.zip
+N60E095.hgt.zip
+N60E096.hgt.zip
+N60E097.hgt.zip
+N60E098.hgt.zip
+N60E099.hgt.zip
+N60E100.hgt.zip
+N60E101.hgt.zip
+N60E102.hgt.zip
+N60E103.hgt.zip
+N60E104.hgt.zip
+N60E105.hgt.zip
+N60E106.hgt.zip
+N60E107.hgt.zip
+N60E108.hgt.zip
+N60E109.hgt.zip
+N60E110.hgt.zip
+N60E111.hgt.zip
+N60E112.hgt.zip
+N60E113.hgt.zip
+N60E114.hgt.zip
+N60E115.hgt.zip
+N60E116.hgt.zip
+N60E117.hgt.zip
+N60E118.hgt.zip
+N60E119.hgt.zip
+N60E120.hgt.zip
+N60E121.hgt.zip
+N60E122.hgt.zip
+N60E123.hgt.zip
+N60E124.hgt.zip
+N60E125.hgt.zip
+N60E126.hgt.zip
+N60E127.hgt.zip
+N60E128.hgt.zip
+N60E129.hgt.zip
+N60E130.hgt.zip
+N60E131.hgt.zip
+N60E132.hgt.zip
+N60E133.hgt.zip
+N60E134.hgt.zip
+N60E135.hgt.zip
+N60E136.hgt.zip
+N60E137.hgt.zip
+N60E138.hgt.zip
+N60E139.hgt.zip
+N60E140.hgt.zip
+N60E141.hgt.zip
+N60E142.hgt.zip
+N60E143.hgt.zip
+N60E144.hgt.zip
+N60E145.hgt.zip
+N60E146.hgt.zip
+N60E147.hgt.zip
+N60E148.hgt.zip
+N60E149.hgt.zip
+N60E150.hgt.zip
+N60E151.hgt.zip
+N60E152.hgt.zip
+N60E153.hgt.zip
+N60E154.hgt.zip
+N60E155.hgt.zip
+N60E156.hgt.zip
+N60E159.hgt.zip
+N60E160.hgt.zip
+N60E161.hgt.zip
+N60E162.hgt.zip
+N60E163.hgt.zip
+N60E164.hgt.zip
+N60E165.hgt.zip
+N60E166.hgt.zip
+N60E167.hgt.zip
+N60E168.hgt.zip
+N60E169.hgt.zip
+N60E170.hgt.zip
+N60E171.hgt.zip
+N60E172.hgt.zip
+N60W001.hgt.zip
+N60W002.hgt.zip
+N60W003.hgt.zip
+S01E073.hgt.zip
+S01E098.hgt.zip
+S01E099.hgt.zip
+S01E100.hgt.zip
+S01E101.hgt.zip
+S01E102.hgt.zip
+S01E103.hgt.zip
+S01E104.hgt.zip
+S01E105.hgt.zip
+S01E109.hgt.zip
+S01E110.hgt.zip
+S01E111.hgt.zip
+S01E112.hgt.zip
+S01E113.hgt.zip
+S01E114.hgt.zip
+S01E115.hgt.zip
+S01E116.hgt.zip
+S01E117.hgt.zip
+S01E119.hgt.zip
+S01E120.hgt.zip
+S01E121.hgt.zip
+S01E122.hgt.zip
+S01E123.hgt.zip
+S01E127.hgt.zip
+S01E128.hgt.zip
+S01E129.hgt.zip
+S01E130.hgt.zip
+S01E131.hgt.zip
+S01E132.hgt.zip
+S01E133.hgt.zip
+S01E134.hgt.zip
+S01E135.hgt.zip
+S01E136.hgt.zip
+S01E145.hgt.zip
+S01E166.hgt.zip
+S01E169.hgt.zip
+S01E174.hgt.zip
+S01W161.hgt.zip
+S02E098.hgt.zip
+S02E099.hgt.zip
+S02E100.hgt.zip
+S02E101.hgt.zip
+S02E102.hgt.zip
+S02E103.hgt.zip
+S02E104.hgt.zip
+S02E105.hgt.zip
+S02E106.hgt.zip
+S02E108.hgt.zip
+S02E109.hgt.zip
+S02E110.hgt.zip
+S02E111.hgt.zip
+S02E112.hgt.zip
+S02E113.hgt.zip
+S02E114.hgt.zip
+S02E115.hgt.zip
+S02E116.hgt.zip
+S02E117.hgt.zip
+S02E119.hgt.zip
+S02E120.hgt.zip
+S02E121.hgt.zip
+S02E122.hgt.zip
+S02E123.hgt.zip
+S02E124.hgt.zip
+S02E125.hgt.zip
+S02E126.hgt.zip
+S02E127.hgt.zip
+S02E128.hgt.zip
+S02E129.hgt.zip
+S02E130.hgt.zip
+S02E131.hgt.zip
+S02E132.hgt.zip
+S02E133.hgt.zip
+S02E134.hgt.zip
+S02E135.hgt.zip
+S02E136.hgt.zip
+S02E137.hgt.zip
+S02E138.hgt.zip
+S02E139.hgt.zip
+S02E142.hgt.zip
+S02E143.hgt.zip
+S02E144.hgt.zip
+S02E145.hgt.zip
+S02E146.hgt.zip
+S02E147.hgt.zip
+S02E148.hgt.zip
+S02E149.hgt.zip
+S02E150.hgt.zip
+S02E174.hgt.zip
+S02E175.hgt.zip
+S02E176.hgt.zip
+S03E099.hgt.zip
+S03E100.hgt.zip
+S03E101.hgt.zip
+S03E102.hgt.zip
+S03E103.hgt.zip
+S03E104.hgt.zip
+S03E105.hgt.zip
+S03E106.hgt.zip
+S03E107.hgt.zip
+S03E108.hgt.zip
+S03E110.hgt.zip
+S03E111.hgt.zip
+S03E112.hgt.zip
+S03E113.hgt.zip
+S03E114.hgt.zip
+S03E115.hgt.zip
+S03E116.hgt.zip
+S03E117.hgt.zip
+S03E118.hgt.zip
+S03E119.hgt.zip
+S03E120.hgt.zip
+S03E121.hgt.zip
+S03E122.hgt.zip
+S03E123.hgt.zip
+S03E124.hgt.zip
+S03E125.hgt.zip
+S03E126.hgt.zip
+S03E127.hgt.zip
+S03E128.hgt.zip
+S03E129.hgt.zip
+S03E130.hgt.zip
+S03E131.hgt.zip
+S03E132.hgt.zip
+S03E133.hgt.zip
+S03E134.hgt.zip
+S03E135.hgt.zip
+S03E136.hgt.zip
+S03E137.hgt.zip
+S03E138.hgt.zip
+S03E139.hgt.zip
+S03E140.hgt.zip
+S03E141.hgt.zip
+S03E142.hgt.zip
+S03E145.hgt.zip
+S03E146.hgt.zip
+S03E147.hgt.zip
+S03E148.hgt.zip
+S03E149.hgt.zip
+S03E150.hgt.zip
+S03E151.hgt.zip
+S03E152.hgt.zip
+S03E175.hgt.zip
+S03E176.hgt.zip
+S03W172.hgt.zip
+S04E100.hgt.zip
+S04E101.hgt.zip
+S04E102.hgt.zip
+S04E103.hgt.zip
+S04E104.hgt.zip
+S04E105.hgt.zip
+S04E106.hgt.zip
+S04E107.hgt.zip
+S04E108.hgt.zip
+S04E110.hgt.zip
+S04E111.hgt.zip
+S04E112.hgt.zip
+S04E113.hgt.zip
+S04E114.hgt.zip
+S04E115.hgt.zip
+S04E116.hgt.zip
+S04E117.hgt.zip
+S04E118.hgt.zip
+S04E119.hgt.zip
+S04E120.hgt.zip
+S04E121.hgt.zip
+S04E122.hgt.zip
+S04E123.hgt.zip
+S04E125.hgt.zip
+S04E126.hgt.zip
+S04E127.hgt.zip
+S04E128.hgt.zip
+S04E129.hgt.zip
+S04E130.hgt.zip
+S04E131.hgt.zip
+S04E132.hgt.zip
+S04E133.hgt.zip
+S04E134.hgt.zip
+S04E135.hgt.zip
+S04E136.hgt.zip
+S04E137.hgt.zip
+S04E138.hgt.zip
+S04E139.hgt.zip
+S04E140.hgt.zip
+S04E141.hgt.zip
+S04E142.hgt.zip
+S04E143.hgt.zip
+S04E144.hgt.zip
+S04E150.hgt.zip
+S04E151.hgt.zip
+S04E152.hgt.zip
+S04E153.hgt.zip
+S04E154.hgt.zip
+S04W155.hgt.zip
+S04W171.hgt.zip
+S04W172.hgt.zip
+S04W175.hgt.zip
+S05E101.hgt.zip
+S05E102.hgt.zip
+S05E103.hgt.zip
+S05E104.hgt.zip
+S05E105.hgt.zip
+S05E114.hgt.zip
+S05E115.hgt.zip
+S05E116.hgt.zip
+S05E119.hgt.zip
+S05E120.hgt.zip
+S05E121.hgt.zip
+S05E122.hgt.zip
+S05E123.hgt.zip
+S05E129.hgt.zip
+S05E130.hgt.zip
+S05E131.hgt.zip
+S05E132.hgt.zip
+S05E133.hgt.zip
+S05E134.hgt.zip
+S05E135.hgt.zip
+S05E136.hgt.zip
+S05E137.hgt.zip
+S05E138.hgt.zip
+S05E139.hgt.zip
+S05E140.hgt.zip
+S05E141.hgt.zip
+S05E142.hgt.zip
+S05E143.hgt.zip
+S05E144.hgt.zip
+S05E145.hgt.zip
+S05E146.hgt.zip
+S05E149.hgt.zip
+S05E150.hgt.zip
+S05E151.hgt.zip
+S05E152.hgt.zip
+S05E153.hgt.zip
+S05E154.hgt.zip
+S05E155.hgt.zip
+S05E156.hgt.zip
+S05E157.hgt.zip
+S05E159.hgt.zip
+S05W155.hgt.zip
+S05W172.hgt.zip
+S05W173.hgt.zip
+S05W175.hgt.zip
+S06E071.hgt.zip
+S06E072.hgt.zip
+S06E102.hgt.zip
+S06E103.hgt.zip
+S06E104.hgt.zip
+S06E105.hgt.zip
+S06E106.hgt.zip
+S06E107.hgt.zip
+S06E108.hgt.zip
+S06E110.hgt.zip
+S06E112.hgt.zip
+S06E114.hgt.zip
+S06E117.hgt.zip
+S06E118.hgt.zip
+S06E119.hgt.zip
+S06E120.hgt.zip
+S06E121.hgt.zip
+S06E122.hgt.zip
+S06E123.hgt.zip
+S06E124.hgt.zip
+S06E127.hgt.zip
+S06E130.hgt.zip
+S06E131.hgt.zip
+S06E132.hgt.zip
+S06E133.hgt.zip
+S06E134.hgt.zip
+S06E137.hgt.zip
+S06E138.hgt.zip
+S06E139.hgt.zip
+S06E140.hgt.zip
+S06E141.hgt.zip
+S06E142.hgt.zip
+S06E143.hgt.zip
+S06E144.hgt.zip
+S06E145.hgt.zip
+S06E146.hgt.zip
+S06E147.hgt.zip
+S06E148.hgt.zip
+S06E149.hgt.zip
+S06E150.hgt.zip
+S06E151.hgt.zip
+S06E152.hgt.zip
+S06E154.hgt.zip
+S06E155.hgt.zip
+S06E159.hgt.zip
+S06E176.hgt.zip
+S06W156.hgt.zip
+S07E071.hgt.zip
+S07E105.hgt.zip
+S07E106.hgt.zip
+S07E107.hgt.zip
+S07E108.hgt.zip
+S07E109.hgt.zip
+S07E110.hgt.zip
+S07E111.hgt.zip
+S07E112.hgt.zip
+S07E113.hgt.zip
+S07E114.hgt.zip
+S07E115.hgt.zip
+S07E116.hgt.zip
+S07E118.hgt.zip
+S07E119.hgt.zip
+S07E120.hgt.zip
+S07E121.hgt.zip
+S07E122.hgt.zip
+S07E124.hgt.zip
+S07E126.hgt.zip
+S07E129.hgt.zip
+S07E130.hgt.zip
+S07E131.hgt.zip
+S07E132.hgt.zip
+S07E134.hgt.zip
+S07E138.hgt.zip
+S07E139.hgt.zip
+S07E140.hgt.zip
+S07E141.hgt.zip
+S07E142.hgt.zip
+S07E143.hgt.zip
+S07E144.hgt.zip
+S07E145.hgt.zip
+S07E146.hgt.zip
+S07E147.hgt.zip
+S07E148.hgt.zip
+S07E149.hgt.zip
+S07E150.hgt.zip
+S07E151.hgt.zip
+S07E154.hgt.zip
+S07E155.hgt.zip
+S07E156.hgt.zip
+S07E157.hgt.zip
+S07E176.hgt.zip
+S07E177.hgt.zip
+S08E072.hgt.zip
+S08E105.hgt.zip
+S08E106.hgt.zip
+S08E107.hgt.zip
+S08E108.hgt.zip
+S08E109.hgt.zip
+S08E110.hgt.zip
+S08E111.hgt.zip
+S08E112.hgt.zip
+S08E113.hgt.zip
+S08E114.hgt.zip
+S08E115.hgt.zip
+S08E117.hgt.zip
+S08E118.hgt.zip
+S08E120.hgt.zip
+S08E121.hgt.zip
+S08E122.hgt.zip
+S08E123.hgt.zip
+S08E125.hgt.zip
+S08E126.hgt.zip
+S08E127.hgt.zip
+S08E128.hgt.zip
+S08E129.hgt.zip
+S08E130.hgt.zip
+S08E131.hgt.zip
+S08E134.hgt.zip
+S08E137.hgt.zip
+S08E138.hgt.zip
+S08E139.hgt.zip
+S08E140.hgt.zip
+S08E141.hgt.zip
+S08E142.hgt.zip
+S08E143.hgt.zip
+S08E144.hgt.zip
+S08E145.hgt.zip
+S08E146.hgt.zip
+S08E147.hgt.zip
+S08E155.hgt.zip
+S08E156.hgt.zip
+S08E157.hgt.zip
+S08E158.hgt.zip
+S08E159.hgt.zip
+S08E160.hgt.zip
+S08E177.hgt.zip
+S08E178.hgt.zip
+S08W141.hgt.zip
+S09E110.hgt.zip
+S09E111.hgt.zip
+S09E112.hgt.zip
+S09E113.hgt.zip
+S09E114.hgt.zip
+S09E115.hgt.zip
+S09E116.hgt.zip
+S09E117.hgt.zip
+S09E118.hgt.zip
+S09E119.hgt.zip
+S09E120.hgt.zip
+S09E121.hgt.zip
+S09E122.hgt.zip
+S09E123.hgt.zip
+S09E124.hgt.zip
+S09E125.hgt.zip
+S09E126.hgt.zip
+S09E127.hgt.zip
+S09E128.hgt.zip
+S09E129.hgt.zip
+S09E130.hgt.zip
+S09E131.hgt.zip
+S09E137.hgt.zip
+S09E138.hgt.zip
+S09E139.hgt.zip
+S09E140.hgt.zip
+S09E141.hgt.zip
+S09E142.hgt.zip
+S09E143.hgt.zip
+S09E145.hgt.zip
+S09E146.hgt.zip
+S09E147.hgt.zip
+S09E148.hgt.zip
+S09E149.hgt.zip
+S09E150.hgt.zip
+S09E151.hgt.zip
+S09E152.hgt.zip
+S09E156.hgt.zip
+S09E157.hgt.zip
+S09E158.hgt.zip
+S09E159.hgt.zip
+S09E160.hgt.zip
+S09E161.hgt.zip
+S09E178.hgt.zip
+S09E179.hgt.zip
+S09W140.hgt.zip
+S09W141.hgt.zip
+S09W158.hgt.zip
+S09W159.hgt.zip
+S09W173.hgt.zip
+S10E116.hgt.zip
+S10E117.hgt.zip
+S10E118.hgt.zip
+S10E119.hgt.zip
+S10E120.hgt.zip
+S10E123.hgt.zip
+S10E124.hgt.zip
+S10E125.hgt.zip
+S10E126.hgt.zip
+S10E140.hgt.zip
+S10E141.hgt.zip
+S10E142.hgt.zip
+S10E143.hgt.zip
+S10E144.hgt.zip
+S10E146.hgt.zip
+S10E147.hgt.zip
+S10E148.hgt.zip
+S10E149.hgt.zip
+S10E150.hgt.zip
+S10E151.hgt.zip
+S10E152.hgt.zip
+S10E153.hgt.zip
+S10E158.hgt.zip
+S10E159.hgt.zip
+S10E160.hgt.zip
+S10E161.hgt.zip
+S10E167.hgt.zip
+S10E179.hgt.zip
+S10W139.hgt.zip
+S10W140.hgt.zip
+S10W141.hgt.zip
+S10W151.hgt.zip
+S10W158.hgt.zip
+S10W159.hgt.zip
+S10W162.hgt.zip
+S10W172.hgt.zip
+S11E105.hgt.zip
+S12E096.hgt.zip
+S13E096.hgt.zip
\ No newline at end of file
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/Eurasia_names.txt.zip b/core/src/main/resources/com/graphhopper/reader/dem/Eurasia_names.txt.zip
deleted file mode 100644
index 0fefc171d4..0000000000
Binary files a/core/src/main/resources/com/graphhopper/reader/dem/Eurasia_names.txt.zip and /dev/null differ
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/Islands_names.txt b/core/src/main/resources/com/graphhopper/reader/dem/Islands_names.txt
new file mode 100644
index 0000000000..b4b1442dab
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/reader/dem/Islands_names.txt
@@ -0,0 +1,141 @@
+N16W170.hgt.zip
+N18W156.hgt.zip
+N19W155.hgt.zip
+N19W156.hgt.zip
+N19W157.hgt.zip
+N20W156.hgt.zip
+N20W157.hgt.zip
+N20W158.hgt.zip
+N21W157.hgt.zip
+N21W158.hgt.zip
+N21W159.hgt.zip
+N21W160.hgt.zip
+N21W161.hgt.zip
+N22W160.hgt.zip
+N22W161.hgt.zip
+N23W162.hgt.zip
+N23W165.hgt.zip
+N23W167.hgt.zip
+N24W168.hgt.zip
+N25W168.hgt.zip
+N25W172.hgt.zip
+N26W174.hgt.zip
+N27W176.hgt.zip
+N28W178.hgt.zip
+N28W179.hgt.zip
+S08W015.hgt.zip
+S16W006.hgt.zip
+S17W006.hgt.zip
+S21W029.hgt.zip
+S21W030.hgt.zip
+S29E167.hgt.zip
+S30E167.hgt.zip
+S30W178.hgt.zip
+S31W179.hgt.zip
+S32W179.hgt.zip
+S35E172.hgt.zip
+S35E173.hgt.zip
+S36E173.hgt.zip
+S36E174.hgt.zip
+S36E175.hgt.zip
+S37E173.hgt.zip
+S37E174.hgt.zip
+S37E175.hgt.zip
+S37E176.hgt.zip
+S38E077.hgt.zip
+S38E174.hgt.zip
+S38E175.hgt.zip
+S38E176.hgt.zip
+S38E177.hgt.zip
+S38E178.hgt.zip
+S38W013.hgt.zip
+S39E077.hgt.zip
+S39E174.hgt.zip
+S39E175.hgt.zip
+S39E176.hgt.zip
+S39E177.hgt.zip
+S39E178.hgt.zip
+S40E173.hgt.zip
+S40E174.hgt.zip
+S40E175.hgt.zip
+S40E176.hgt.zip
+S40E177.hgt.zip
+S40E178.hgt.zip
+S41E172.hgt.zip
+S41E173.hgt.zip
+S41E174.hgt.zip
+S41E175.hgt.zip
+S41E176.hgt.zip
+S41W010.hgt.zip
+S41W011.hgt.zip
+S42E171.hgt.zip
+S42E172.hgt.zip
+S42E173.hgt.zip
+S42E174.hgt.zip
+S42E175.hgt.zip
+S42E176.hgt.zip
+S43E170.hgt.zip
+S43E171.hgt.zip
+S43E172.hgt.zip
+S43E173.hgt.zip
+S43E174.hgt.zip
+S44E168.hgt.zip
+S44E169.hgt.zip
+S44E170.hgt.zip
+S44E171.hgt.zip
+S44E172.hgt.zip
+S44E173.hgt.zip
+S44W176.hgt.zip
+S44W177.hgt.zip
+S45E167.hgt.zip
+S45E168.hgt.zip
+S45E169.hgt.zip
+S45E170.hgt.zip
+S45E171.hgt.zip
+S45W176.hgt.zip
+S45W177.hgt.zip
+S46E050.hgt.zip
+S46E166.hgt.zip
+S46E167.hgt.zip
+S46E168.hgt.zip
+S46E169.hgt.zip
+S46E170.hgt.zip
+S46E171.hgt.zip
+S47E037.hgt.zip
+S47E038.hgt.zip
+S47E050.hgt.zip
+S47E051.hgt.zip
+S47E052.hgt.zip
+S47E166.hgt.zip
+S47E167.hgt.zip
+S47E168.hgt.zip
+S47E169.hgt.zip
+S47E170.hgt.zip
+S48E167.hgt.zip
+S48E168.hgt.zip
+S48E179.hgt.zip
+S49E068.hgt.zip
+S49E069.hgt.zip
+S49E166.hgt.zip
+S50E068.hgt.zip
+S50E069.hgt.zip
+S50E070.hgt.zip
+S50E178.hgt.zip
+S51E068.hgt.zip
+S51E165.hgt.zip
+S51E166.hgt.zip
+S53E073.hgt.zip
+S53E168.hgt.zip
+S53E169.hgt.zip
+S54E072.hgt.zip
+S54E073.hgt.zip
+S54W038.hgt.zip
+S54W039.hgt.zip
+S55E003.hgt.zip
+S55E158.hgt.zip
+S55W036.hgt.zip
+S55W037.hgt.zip
+S55W038.hgt.zip
+S55W039.hgt.zip
+S56E158.hgt.zip
+S56W035.hgt.zip
\ No newline at end of file
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/Islands_names.txt.zip b/core/src/main/resources/com/graphhopper/reader/dem/Islands_names.txt.zip
deleted file mode 100644
index 8a8aa9c177..0000000000
Binary files a/core/src/main/resources/com/graphhopper/reader/dem/Islands_names.txt.zip and /dev/null differ
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/North_America_names.txt b/core/src/main/resources/com/graphhopper/reader/dem/North_America_names.txt
new file mode 100644
index 0000000000..0fbe0a50f5
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/reader/dem/North_America_names.txt
@@ -0,0 +1,2412 @@
+N10W110.hgt.zip
+N15W062.hgt.zip
+N15W064.hgt.zip
+N15W079.hgt.zip
+N15W080.hgt.zip
+N15W083.hgt.zip
+N15W084.hgt.zip
+N15W085.hgt.zip
+N15W086.hgt.zip
+N15W087.hgt.zip
+N15W088.hgt.zip
+N15W089.hgt.zip
+N15W090.hgt.zip
+N15W091.hgt.zip
+N15W092.hgt.zip
+N15W093.hgt.zip
+N15W094.hgt.zip
+N15W096.hgt.zip
+N15W097.hgt.zip
+N15W098.hgt.zip
+N16W062.hgt.zip
+N16W063.hgt.zip
+N16W086.hgt.zip
+N16W087.hgt.zip
+N16W088.hgt.zip
+N16W089.hgt.zip
+N16W090.hgt.zip
+N16W091.hgt.zip
+N16W092.hgt.zip
+N16W093.hgt.zip
+N16W094.hgt.zip
+N16W095.hgt.zip
+N16W096.hgt.zip
+N16W097.hgt.zip
+N16W098.hgt.zip
+N16W099.hgt.zip
+N16W100.hgt.zip
+N16W101.hgt.zip
+N17W062.hgt.zip
+N17W063.hgt.zip
+N17W064.hgt.zip
+N17W065.hgt.zip
+N17W066.hgt.zip
+N17W067.hgt.zip
+N17W068.hgt.zip
+N17W072.hgt.zip
+N17W076.hgt.zip
+N17W077.hgt.zip
+N17W078.hgt.zip
+N17W084.hgt.zip
+N17W088.hgt.zip
+N17W089.hgt.zip
+N17W090.hgt.zip
+N17W091.hgt.zip
+N17W092.hgt.zip
+N17W093.hgt.zip
+N17W094.hgt.zip
+N17W095.hgt.zip
+N17W096.hgt.zip
+N17W097.hgt.zip
+N17W098.hgt.zip
+N17W099.hgt.zip
+N17W100.hgt.zip
+N17W101.hgt.zip
+N17W102.hgt.zip
+N17W103.hgt.zip
+N18W063.hgt.zip
+N18W064.hgt.zip
+N18W065.hgt.zip
+N18W066.hgt.zip
+N18W067.hgt.zip
+N18W068.hgt.zip
+N18W069.hgt.zip
+N18W070.hgt.zip
+N18W071.hgt.zip
+N18W072.hgt.zip
+N18W073.hgt.zip
+N18W074.hgt.zip
+N18W075.hgt.zip
+N18W076.hgt.zip
+N18W077.hgt.zip
+N18W078.hgt.zip
+N18W079.hgt.zip
+N18W088.hgt.zip
+N18W089.hgt.zip
+N18W090.hgt.zip
+N18W091.hgt.zip
+N18W092.hgt.zip
+N18W093.hgt.zip
+N18W094.hgt.zip
+N18W095.hgt.zip
+N18W096.hgt.zip
+N18W097.hgt.zip
+N18W098.hgt.zip
+N18W099.hgt.zip
+N18W100.hgt.zip
+N18W101.hgt.zip
+N18W102.hgt.zip
+N18W103.hgt.zip
+N18W104.hgt.zip
+N18W105.hgt.zip
+N18W111.hgt.zip
+N18W112.hgt.zip
+N18W115.hgt.zip
+N19W069.hgt.zip
+N19W070.hgt.zip
+N19W071.hgt.zip
+N19W072.hgt.zip
+N19W073.hgt.zip
+N19W074.hgt.zip
+N19W075.hgt.zip
+N19W076.hgt.zip
+N19W077.hgt.zip
+N19W078.hgt.zip
+N19W080.hgt.zip
+N19W081.hgt.zip
+N19W082.hgt.zip
+N19W088.hgt.zip
+N19W089.hgt.zip
+N19W090.hgt.zip
+N19W091.hgt.zip
+N19W092.hgt.zip
+N19W096.hgt.zip
+N19W097.hgt.zip
+N19W098.hgt.zip
+N19W099.hgt.zip
+N19W100.hgt.zip
+N19W101.hgt.zip
+N19W102.hgt.zip
+N19W103.hgt.zip
+N19W104.hgt.zip
+N19W105.hgt.zip
+N19W106.hgt.zip
+N19W111.hgt.zip
+N20W073.hgt.zip
+N20W074.hgt.zip
+N20W075.hgt.zip
+N20W076.hgt.zip
+N20W077.hgt.zip
+N20W078.hgt.zip
+N20W079.hgt.zip
+N20W080.hgt.zip
+N20W087.hgt.zip
+N20W088.hgt.zip
+N20W089.hgt.zip
+N20W090.hgt.zip
+N20W091.hgt.zip
+N20W092.hgt.zip
+N20W093.hgt.zip
+N20W097.hgt.zip
+N20W098.hgt.zip
+N20W099.hgt.zip
+N20W100.hgt.zip
+N20W101.hgt.zip
+N20W102.hgt.zip
+N20W103.hgt.zip
+N20W104.hgt.zip
+N20W105.hgt.zip
+N20W106.hgt.zip
+N21W072.hgt.zip
+N21W073.hgt.zip
+N21W074.hgt.zip
+N21W076.hgt.zip
+N21W077.hgt.zip
+N21W078.hgt.zip
+N21W079.hgt.zip
+N21W080.hgt.zip
+N21W081.hgt.zip
+N21W082.hgt.zip
+N21W083.hgt.zip
+N21W084.hgt.zip
+N21W085.hgt.zip
+N21W087.hgt.zip
+N21W088.hgt.zip
+N21W089.hgt.zip
+N21W090.hgt.zip
+N21W091.hgt.zip
+N21W098.hgt.zip
+N21W099.hgt.zip
+N21W100.hgt.zip
+N21W101.hgt.zip
+N21W102.hgt.zip
+N21W103.hgt.zip
+N21W104.hgt.zip
+N21W105.hgt.zip
+N21W106.hgt.zip
+N21W107.hgt.zip
+N22W073.hgt.zip
+N22W074.hgt.zip
+N22W075.hgt.zip
+N22W076.hgt.zip
+N22W078.hgt.zip
+N22W079.hgt.zip
+N22W080.hgt.zip
+N22W081.hgt.zip
+N22W082.hgt.zip
+N22W083.hgt.zip
+N22W084.hgt.zip
+N22W085.hgt.zip
+N22W090.hgt.zip
+N22W092.hgt.zip
+N22W098.hgt.zip
+N22W099.hgt.zip
+N22W100.hgt.zip
+N22W101.hgt.zip
+N22W102.hgt.zip
+N22W103.hgt.zip
+N22W104.hgt.zip
+N22W105.hgt.zip
+N22W106.hgt.zip
+N22W107.hgt.zip
+N22W110.hgt.zip
+N22W111.hgt.zip
+N23W074.hgt.zip
+N23W075.hgt.zip
+N23W076.hgt.zip
+N23W077.hgt.zip
+N23W078.hgt.zip
+N23W080.hgt.zip
+N23W081.hgt.zip
+N23W082.hgt.zip
+N23W083.hgt.zip
+N23W084.hgt.zip
+N23W098.hgt.zip
+N23W099.hgt.zip
+N23W100.hgt.zip
+N23W101.hgt.zip
+N23W102.hgt.zip
+N23W103.hgt.zip
+N23W104.hgt.zip
+N23W105.hgt.zip
+N23W106.hgt.zip
+N23W107.hgt.zip
+N23W108.hgt.zip
+N23W110.hgt.zip
+N23W111.hgt.zip
+N24W075.hgt.zip
+N24W076.hgt.zip
+N24W077.hgt.zip
+N24W078.hgt.zip
+N24W079.hgt.zip
+N24W080.hgt.zip
+N24W081.hgt.zip
+N24W082.hgt.zip
+N24W083.hgt.zip
+N24W098.hgt.zip
+N24W099.hgt.zip
+N24W100.hgt.zip
+N24W101.hgt.zip
+N24W102.hgt.zip
+N24W103.hgt.zip
+N24W104.hgt.zip
+N24W105.hgt.zip
+N24W106.hgt.zip
+N24W107.hgt.zip
+N24W108.hgt.zip
+N24W109.hgt.zip
+N24W110.hgt.zip
+N24W111.hgt.zip
+N24W112.hgt.zip
+N24W113.hgt.zip
+N24W116.hgt.zip
+N25W077.hgt.zip
+N25W078.hgt.zip
+N25W079.hgt.zip
+N25W080.hgt.zip
+N25W081.hgt.zip
+N25W082.hgt.zip
+N25W098.hgt.zip
+N25W099.hgt.zip
+N25W100.hgt.zip
+N25W101.hgt.zip
+N25W102.hgt.zip
+N25W103.hgt.zip
+N25W104.hgt.zip
+N25W105.hgt.zip
+N25W106.hgt.zip
+N25W107.hgt.zip
+N25W108.hgt.zip
+N25W109.hgt.zip
+N25W110.hgt.zip
+N25W111.hgt.zip
+N25W112.hgt.zip
+N25W113.hgt.zip
+N26W077.hgt.zip
+N26W078.hgt.zip
+N26W079.hgt.zip
+N26W080.hgt.zip
+N26W081.hgt.zip
+N26W082.hgt.zip
+N26W083.hgt.zip
+N26W098.hgt.zip
+N26W099.hgt.zip
+N26W100.hgt.zip
+N26W101.hgt.zip
+N26W102.hgt.zip
+N26W103.hgt.zip
+N26W104.hgt.zip
+N26W105.hgt.zip
+N26W106.hgt.zip
+N26W107.hgt.zip
+N26W108.hgt.zip
+N26W109.hgt.zip
+N26W110.hgt.zip
+N26W112.hgt.zip
+N26W113.hgt.zip
+N26W114.hgt.zip
+N26W115.hgt.zip
+N27W078.hgt.zip
+N27W079.hgt.zip
+N27W081.hgt.zip
+N27W082.hgt.zip
+N27W083.hgt.zip
+N27W097.hgt.zip
+N27W098.hgt.zip
+N27W099.hgt.zip
+N27W100.hgt.zip
+N27W101.hgt.zip
+N27W102.hgt.zip
+N27W103.hgt.zip
+N27W104.hgt.zip
+N27W105.hgt.zip
+N27W106.hgt.zip
+N27W107.hgt.zip
+N27W108.hgt.zip
+N27W109.hgt.zip
+N27W110.hgt.zip
+N27W111.hgt.zip
+N27W112.hgt.zip
+N27W113.hgt.zip
+N27W114.hgt.zip
+N27W115.hgt.zip
+N27W116.hgt.zip
+N28W081.hgt.zip
+N28W082.hgt.zip
+N28W083.hgt.zip
+N28W090.hgt.zip
+N28W096.hgt.zip
+N28W097.hgt.zip
+N28W098.hgt.zip
+N28W099.hgt.zip
+N28W100.hgt.zip
+N28W101.hgt.zip
+N28W102.hgt.zip
+N28W103.hgt.zip
+N28W104.hgt.zip
+N28W105.hgt.zip
+N28W106.hgt.zip
+N28W107.hgt.zip
+N28W108.hgt.zip
+N28W109.hgt.zip
+N28W110.hgt.zip
+N28W111.hgt.zip
+N28W112.hgt.zip
+N28W113.hgt.zip
+N28W114.hgt.zip
+N28W115.hgt.zip
+N28W116.hgt.zip
+N28W119.hgt.zip
+N29W081.hgt.zip
+N29W082.hgt.zip
+N29W083.hgt.zip
+N29W084.hgt.zip
+N29W085.hgt.zip
+N29W086.hgt.zip
+N29W089.hgt.zip
+N29W090.hgt.zip
+N29W091.hgt.zip
+N29W092.hgt.zip
+N29W093.hgt.zip
+N29W094.hgt.zip
+N29W095.hgt.zip
+N29W096.hgt.zip
+N29W097.hgt.zip
+N29W098.hgt.zip
+N29W099.hgt.zip
+N29W100.hgt.zip
+N29W101.hgt.zip
+N29W102.hgt.zip
+N29W103.hgt.zip
+N29W104.hgt.zip
+N29W105.hgt.zip
+N29W106.hgt.zip
+N29W107.hgt.zip
+N29W108.hgt.zip
+N29W109.hgt.zip
+N29W110.hgt.zip
+N29W111.hgt.zip
+N29W112.hgt.zip
+N29W113.hgt.zip
+N29W114.hgt.zip
+N29W115.hgt.zip
+N29W116.hgt.zip
+N29W119.hgt.zip
+N30W082.hgt.zip
+N30W083.hgt.zip
+N30W084.hgt.zip
+N30W085.hgt.zip
+N30W086.hgt.zip
+N30W087.hgt.zip
+N30W088.hgt.zip
+N30W089.hgt.zip
+N30W090.hgt.zip
+N30W091.hgt.zip
+N30W092.hgt.zip
+N30W093.hgt.zip
+N30W094.hgt.zip
+N30W095.hgt.zip
+N30W096.hgt.zip
+N30W097.hgt.zip
+N30W098.hgt.zip
+N30W099.hgt.zip
+N30W100.hgt.zip
+N30W101.hgt.zip
+N30W102.hgt.zip
+N30W103.hgt.zip
+N30W104.hgt.zip
+N30W105.hgt.zip
+N30W106.hgt.zip
+N30W107.hgt.zip
+N30W108.hgt.zip
+N30W109.hgt.zip
+N30W110.hgt.zip
+N30W111.hgt.zip
+N30W112.hgt.zip
+N30W113.hgt.zip
+N30W114.hgt.zip
+N30W115.hgt.zip
+N30W116.hgt.zip
+N30W117.hgt.zip
+N31W081.hgt.zip
+N31W082.hgt.zip
+N31W083.hgt.zip
+N31W084.hgt.zip
+N31W085.hgt.zip
+N31W086.hgt.zip
+N31W087.hgt.zip
+N31W088.hgt.zip
+N31W089.hgt.zip
+N31W090.hgt.zip
+N31W091.hgt.zip
+N31W092.hgt.zip
+N31W093.hgt.zip
+N31W094.hgt.zip
+N31W095.hgt.zip
+N31W096.hgt.zip
+N31W097.hgt.zip
+N31W098.hgt.zip
+N31W099.hgt.zip
+N31W100.hgt.zip
+N31W101.hgt.zip
+N31W102.hgt.zip
+N31W103.hgt.zip
+N31W104.hgt.zip
+N31W105.hgt.zip
+N31W106.hgt.zip
+N31W107.hgt.zip
+N31W108.hgt.zip
+N31W109.hgt.zip
+N31W110.hgt.zip
+N31W111.hgt.zip
+N31W112.hgt.zip
+N31W113.hgt.zip
+N31W114.hgt.zip
+N31W115.hgt.zip
+N31W116.hgt.zip
+N31W117.hgt.zip
+N32W065.hgt.zip
+N32W080.hgt.zip
+N32W081.hgt.zip
+N32W082.hgt.zip
+N32W083.hgt.zip
+N32W084.hgt.zip
+N32W085.hgt.zip
+N32W086.hgt.zip
+N32W087.hgt.zip
+N32W088.hgt.zip
+N32W089.hgt.zip
+N32W090.hgt.zip
+N32W091.hgt.zip
+N32W092.hgt.zip
+N32W093.hgt.zip
+N32W094.hgt.zip
+N32W095.hgt.zip
+N32W096.hgt.zip
+N32W097.hgt.zip
+N32W098.hgt.zip
+N32W099.hgt.zip
+N32W100.hgt.zip
+N32W101.hgt.zip
+N32W102.hgt.zip
+N32W103.hgt.zip
+N32W104.hgt.zip
+N32W105.hgt.zip
+N32W106.hgt.zip
+N32W107.hgt.zip
+N32W108.hgt.zip
+N32W109.hgt.zip
+N32W110.hgt.zip
+N32W111.hgt.zip
+N32W112.hgt.zip
+N32W113.hgt.zip
+N32W114.hgt.zip
+N32W115.hgt.zip
+N32W116.hgt.zip
+N32W117.hgt.zip
+N32W118.hgt.zip
+N32W119.hgt.zip
+N33W078.hgt.zip
+N33W079.hgt.zip
+N33W080.hgt.zip
+N33W081.hgt.zip
+N33W082.hgt.zip
+N33W083.hgt.zip
+N33W084.hgt.zip
+N33W085.hgt.zip
+N33W086.hgt.zip
+N33W087.hgt.zip
+N33W088.hgt.zip
+N33W089.hgt.zip
+N33W090.hgt.zip
+N33W091.hgt.zip
+N33W092.hgt.zip
+N33W093.hgt.zip
+N33W094.hgt.zip
+N33W095.hgt.zip
+N33W096.hgt.zip
+N33W097.hgt.zip
+N33W098.hgt.zip
+N33W099.hgt.zip
+N33W100.hgt.zip
+N33W101.hgt.zip
+N33W102.hgt.zip
+N33W103.hgt.zip
+N33W104.hgt.zip
+N33W105.hgt.zip
+N33W106.hgt.zip
+N33W107.hgt.zip
+N33W108.hgt.zip
+N33W109.hgt.zip
+N33W110.hgt.zip
+N33W111.hgt.zip
+N33W112.hgt.zip
+N33W113.hgt.zip
+N33W114.hgt.zip
+N33W115.hgt.zip
+N33W116.hgt.zip
+N33W117.hgt.zip
+N33W118.hgt.zip
+N33W119.hgt.zip
+N33W120.hgt.zip
+N33W121.hgt.zip
+N34W077.hgt.zip
+N34W078.hgt.zip
+N34W079.hgt.zip
+N34W080.hgt.zip
+N34W081.hgt.zip
+N34W082.hgt.zip
+N34W083.hgt.zip
+N34W084.hgt.zip
+N34W085.hgt.zip
+N34W086.hgt.zip
+N34W087.hgt.zip
+N34W088.hgt.zip
+N34W089.hgt.zip
+N34W090.hgt.zip
+N34W091.hgt.zip
+N34W092.hgt.zip
+N34W093.hgt.zip
+N34W094.hgt.zip
+N34W095.hgt.zip
+N34W096.hgt.zip
+N34W097.hgt.zip
+N34W098.hgt.zip
+N34W099.hgt.zip
+N34W100.hgt.zip
+N34W101.hgt.zip
+N34W102.hgt.zip
+N34W103.hgt.zip
+N34W104.hgt.zip
+N34W105.hgt.zip
+N34W106.hgt.zip
+N34W107.hgt.zip
+N34W108.hgt.zip
+N34W109.hgt.zip
+N34W110.hgt.zip
+N34W111.hgt.zip
+N34W112.hgt.zip
+N34W113.hgt.zip
+N34W114.hgt.zip
+N34W115.hgt.zip
+N34W116.hgt.zip
+N34W117.hgt.zip
+N34W118.hgt.zip
+N34W119.hgt.zip
+N34W120.hgt.zip
+N34W121.hgt.zip
+N35W076.hgt.zip
+N35W077.hgt.zip
+N35W078.hgt.zip
+N35W079.hgt.zip
+N35W080.hgt.zip
+N35W081.hgt.zip
+N35W082.hgt.zip
+N35W083.hgt.zip
+N35W084.hgt.zip
+N35W085.hgt.zip
+N35W086.hgt.zip
+N35W087.hgt.zip
+N35W088.hgt.zip
+N35W089.hgt.zip
+N35W090.hgt.zip
+N35W091.hgt.zip
+N35W092.hgt.zip
+N35W093.hgt.zip
+N35W094.hgt.zip
+N35W095.hgt.zip
+N35W096.hgt.zip
+N35W097.hgt.zip
+N35W098.hgt.zip
+N35W099.hgt.zip
+N35W100.hgt.zip
+N35W101.hgt.zip
+N35W102.hgt.zip
+N35W103.hgt.zip
+N35W104.hgt.zip
+N35W105.hgt.zip
+N35W106.hgt.zip
+N35W107.hgt.zip
+N35W108.hgt.zip
+N35W109.hgt.zip
+N35W110.hgt.zip
+N35W111.hgt.zip
+N35W112.hgt.zip
+N35W113.hgt.zip
+N35W114.hgt.zip
+N35W115.hgt.zip
+N35W116.hgt.zip
+N35W117.hgt.zip
+N35W118.hgt.zip
+N35W119.hgt.zip
+N35W120.hgt.zip
+N35W121.hgt.zip
+N35W122.hgt.zip
+N36W076.hgt.zip
+N36W077.hgt.zip
+N36W078.hgt.zip
+N36W079.hgt.zip
+N36W080.hgt.zip
+N36W081.hgt.zip
+N36W082.hgt.zip
+N36W083.hgt.zip
+N36W084.hgt.zip
+N36W085.hgt.zip
+N36W086.hgt.zip
+N36W087.hgt.zip
+N36W088.hgt.zip
+N36W089.hgt.zip
+N36W090.hgt.zip
+N36W091.hgt.zip
+N36W092.hgt.zip
+N36W093.hgt.zip
+N36W094.hgt.zip
+N36W095.hgt.zip
+N36W096.hgt.zip
+N36W097.hgt.zip
+N36W098.hgt.zip
+N36W099.hgt.zip
+N36W100.hgt.zip
+N36W101.hgt.zip
+N36W102.hgt.zip
+N36W103.hgt.zip
+N36W104.hgt.zip
+N36W105.hgt.zip
+N36W106.hgt.zip
+N36W107.hgt.zip
+N36W108.hgt.zip
+N36W109.hgt.zip
+N36W110.hgt.zip
+N36W111.hgt.zip
+N36W112.hgt.zip
+N36W113.hgt.zip
+N36W114.hgt.zip
+N36W115.hgt.zip
+N36W116.hgt.zip
+N36W117.hgt.zip
+N36W118.hgt.zip
+N36W119.hgt.zip
+N36W120.hgt.zip
+N36W121.hgt.zip
+N36W122.hgt.zip
+N36W123.hgt.zip
+N37W076.hgt.zip
+N37W077.hgt.zip
+N37W078.hgt.zip
+N37W079.hgt.zip
+N37W080.hgt.zip
+N37W081.hgt.zip
+N37W082.hgt.zip
+N37W083.hgt.zip
+N37W084.hgt.zip
+N37W085.hgt.zip
+N37W086.hgt.zip
+N37W087.hgt.zip
+N37W088.hgt.zip
+N37W089.hgt.zip
+N37W090.hgt.zip
+N37W091.hgt.zip
+N37W092.hgt.zip
+N37W093.hgt.zip
+N37W094.hgt.zip
+N37W095.hgt.zip
+N37W096.hgt.zip
+N37W097.hgt.zip
+N37W098.hgt.zip
+N37W099.hgt.zip
+N37W100.hgt.zip
+N37W101.hgt.zip
+N37W102.hgt.zip
+N37W103.hgt.zip
+N37W104.hgt.zip
+N37W105.hgt.zip
+N37W106.hgt.zip
+N37W107.hgt.zip
+N37W108.hgt.zip
+N37W109.hgt.zip
+N37W110.hgt.zip
+N37W111.hgt.zip
+N37W112.hgt.zip
+N37W113.hgt.zip
+N37W114.hgt.zip
+N37W115.hgt.zip
+N37W116.hgt.zip
+N37W117.hgt.zip
+N37W118.hgt.zip
+N37W119.hgt.zip
+N37W120.hgt.zip
+N37W121.hgt.zip
+N37W122.hgt.zip
+N37W123.hgt.zip
+N37W124.hgt.zip
+N38W075.hgt.zip
+N38W076.hgt.zip
+N38W077.hgt.zip
+N38W078.hgt.zip
+N38W079.hgt.zip
+N38W080.hgt.zip
+N38W081.hgt.zip
+N38W082.hgt.zip
+N38W083.hgt.zip
+N38W084.hgt.zip
+N38W085.hgt.zip
+N38W086.hgt.zip
+N38W087.hgt.zip
+N38W088.hgt.zip
+N38W089.hgt.zip
+N38W090.hgt.zip
+N38W091.hgt.zip
+N38W092.hgt.zip
+N38W093.hgt.zip
+N38W094.hgt.zip
+N38W095.hgt.zip
+N38W096.hgt.zip
+N38W097.hgt.zip
+N38W098.hgt.zip
+N38W099.hgt.zip
+N38W100.hgt.zip
+N38W101.hgt.zip
+N38W102.hgt.zip
+N38W103.hgt.zip
+N38W104.hgt.zip
+N38W105.hgt.zip
+N38W106.hgt.zip
+N38W107.hgt.zip
+N38W108.hgt.zip
+N38W109.hgt.zip
+N38W110.hgt.zip
+N38W111.hgt.zip
+N38W112.hgt.zip
+N38W113.hgt.zip
+N38W114.hgt.zip
+N38W115.hgt.zip
+N38W116.hgt.zip
+N38W117.hgt.zip
+N38W118.hgt.zip
+N38W119.hgt.zip
+N38W120.hgt.zip
+N38W121.hgt.zip
+N38W122.hgt.zip
+N38W123.hgt.zip
+N38W124.hgt.zip
+N39W075.hgt.zip
+N39W076.hgt.zip
+N39W077.hgt.zip
+N39W078.hgt.zip
+N39W079.hgt.zip
+N39W080.hgt.zip
+N39W081.hgt.zip
+N39W082.hgt.zip
+N39W083.hgt.zip
+N39W084.hgt.zip
+N39W085.hgt.zip
+N39W086.hgt.zip
+N39W087.hgt.zip
+N39W088.hgt.zip
+N39W089.hgt.zip
+N39W090.hgt.zip
+N39W091.hgt.zip
+N39W092.hgt.zip
+N39W093.hgt.zip
+N39W094.hgt.zip
+N39W095.hgt.zip
+N39W096.hgt.zip
+N39W097.hgt.zip
+N39W098.hgt.zip
+N39W099.hgt.zip
+N39W100.hgt.zip
+N39W101.hgt.zip
+N39W102.hgt.zip
+N39W103.hgt.zip
+N39W104.hgt.zip
+N39W105.hgt.zip
+N39W106.hgt.zip
+N39W107.hgt.zip
+N39W108.hgt.zip
+N39W109.hgt.zip
+N39W110.hgt.zip
+N39W111.hgt.zip
+N39W112.hgt.zip
+N39W113.hgt.zip
+N39W114.hgt.zip
+N39W115.hgt.zip
+N39W116.hgt.zip
+N39W117.hgt.zip
+N39W118.hgt.zip
+N39W119.hgt.zip
+N39W120.hgt.zip
+N39W121.hgt.zip
+N39W122.hgt.zip
+N39W123.hgt.zip
+N39W124.hgt.zip
+N39W125.hgt.zip
+N40W073.hgt.zip
+N40W074.hgt.zip
+N40W075.hgt.zip
+N40W076.hgt.zip
+N40W077.hgt.zip
+N40W078.hgt.zip
+N40W079.hgt.zip
+N40W080.hgt.zip
+N40W081.hgt.zip
+N40W082.hgt.zip
+N40W083.hgt.zip
+N40W084.hgt.zip
+N40W085.hgt.zip
+N40W086.hgt.zip
+N40W087.hgt.zip
+N40W088.hgt.zip
+N40W089.hgt.zip
+N40W090.hgt.zip
+N40W091.hgt.zip
+N40W092.hgt.zip
+N40W093.hgt.zip
+N40W094.hgt.zip
+N40W095.hgt.zip
+N40W096.hgt.zip
+N40W097.hgt.zip
+N40W098.hgt.zip
+N40W099.hgt.zip
+N40W100.hgt.zip
+N40W101.hgt.zip
+N40W102.hgt.zip
+N40W103.hgt.zip
+N40W104.hgt.zip
+N40W105.hgt.zip
+N40W106.hgt.zip
+N40W107.hgt.zip
+N40W108.hgt.zip
+N40W109.hgt.zip
+N40W110.hgt.zip
+N40W111.hgt.zip
+N40W112.hgt.zip
+N40W113.hgt.zip
+N40W114.hgt.zip
+N40W115.hgt.zip
+N40W116.hgt.zip
+N40W117.hgt.zip
+N40W118.hgt.zip
+N40W119.hgt.zip
+N40W120.hgt.zip
+N40W121.hgt.zip
+N40W122.hgt.zip
+N40W123.hgt.zip
+N40W124.hgt.zip
+N40W125.hgt.zip
+N41W070.hgt.zip
+N41W071.hgt.zip
+N41W072.hgt.zip
+N41W073.hgt.zip
+N41W074.hgt.zip
+N41W075.hgt.zip
+N41W076.hgt.zip
+N41W077.hgt.zip
+N41W078.hgt.zip
+N41W079.hgt.zip
+N41W080.hgt.zip
+N41W081.hgt.zip
+N41W082.hgt.zip
+N41W083.hgt.zip
+N41W084.hgt.zip
+N41W085.hgt.zip
+N41W086.hgt.zip
+N41W087.hgt.zip
+N41W088.hgt.zip
+N41W089.hgt.zip
+N41W090.hgt.zip
+N41W091.hgt.zip
+N41W092.hgt.zip
+N41W093.hgt.zip
+N41W094.hgt.zip
+N41W095.hgt.zip
+N41W096.hgt.zip
+N41W097.hgt.zip
+N41W098.hgt.zip
+N41W099.hgt.zip
+N41W100.hgt.zip
+N41W101.hgt.zip
+N41W102.hgt.zip
+N41W103.hgt.zip
+N41W104.hgt.zip
+N41W105.hgt.zip
+N41W106.hgt.zip
+N41W107.hgt.zip
+N41W108.hgt.zip
+N41W109.hgt.zip
+N41W110.hgt.zip
+N41W111.hgt.zip
+N41W112.hgt.zip
+N41W113.hgt.zip
+N41W114.hgt.zip
+N41W115.hgt.zip
+N41W116.hgt.zip
+N41W117.hgt.zip
+N41W118.hgt.zip
+N41W119.hgt.zip
+N41W120.hgt.zip
+N41W121.hgt.zip
+N41W122.hgt.zip
+N41W123.hgt.zip
+N41W124.hgt.zip
+N41W125.hgt.zip
+N42W071.hgt.zip
+N42W072.hgt.zip
+N42W073.hgt.zip
+N42W074.hgt.zip
+N42W075.hgt.zip
+N42W076.hgt.zip
+N42W077.hgt.zip
+N42W078.hgt.zip
+N42W079.hgt.zip
+N42W080.hgt.zip
+N42W081.hgt.zip
+N42W082.hgt.zip
+N42W083.hgt.zip
+N42W084.hgt.zip
+N42W085.hgt.zip
+N42W086.hgt.zip
+N42W087.hgt.zip
+N42W088.hgt.zip
+N42W089.hgt.zip
+N42W090.hgt.zip
+N42W091.hgt.zip
+N42W092.hgt.zip
+N42W093.hgt.zip
+N42W094.hgt.zip
+N42W095.hgt.zip
+N42W096.hgt.zip
+N42W097.hgt.zip
+N42W098.hgt.zip
+N42W099.hgt.zip
+N42W100.hgt.zip
+N42W101.hgt.zip
+N42W102.hgt.zip
+N42W103.hgt.zip
+N42W104.hgt.zip
+N42W105.hgt.zip
+N42W106.hgt.zip
+N42W107.hgt.zip
+N42W108.hgt.zip
+N42W109.hgt.zip
+N42W110.hgt.zip
+N42W111.hgt.zip
+N42W112.hgt.zip
+N42W113.hgt.zip
+N42W114.hgt.zip
+N42W115.hgt.zip
+N42W116.hgt.zip
+N42W117.hgt.zip
+N42W118.hgt.zip
+N42W119.hgt.zip
+N42W120.hgt.zip
+N42W121.hgt.zip
+N42W122.hgt.zip
+N42W123.hgt.zip
+N42W124.hgt.zip
+N42W125.hgt.zip
+N43W060.hgt.zip
+N43W061.hgt.zip
+N43W065.hgt.zip
+N43W066.hgt.zip
+N43W067.hgt.zip
+N43W069.hgt.zip
+N43W070.hgt.zip
+N43W071.hgt.zip
+N43W072.hgt.zip
+N43W073.hgt.zip
+N43W074.hgt.zip
+N43W075.hgt.zip
+N43W076.hgt.zip
+N43W077.hgt.zip
+N43W078.hgt.zip
+N43W079.hgt.zip
+N43W080.hgt.zip
+N43W081.hgt.zip
+N43W082.hgt.zip
+N43W083.hgt.zip
+N43W084.hgt.zip
+N43W085.hgt.zip
+N43W086.hgt.zip
+N43W087.hgt.zip
+N43W088.hgt.zip
+N43W089.hgt.zip
+N43W090.hgt.zip
+N43W091.hgt.zip
+N43W092.hgt.zip
+N43W093.hgt.zip
+N43W094.hgt.zip
+N43W095.hgt.zip
+N43W096.hgt.zip
+N43W097.hgt.zip
+N43W098.hgt.zip
+N43W099.hgt.zip
+N43W100.hgt.zip
+N43W101.hgt.zip
+N43W102.hgt.zip
+N43W103.hgt.zip
+N43W104.hgt.zip
+N43W105.hgt.zip
+N43W106.hgt.zip
+N43W107.hgt.zip
+N43W108.hgt.zip
+N43W109.hgt.zip
+N43W110.hgt.zip
+N43W111.hgt.zip
+N43W112.hgt.zip
+N43W113.hgt.zip
+N43W114.hgt.zip
+N43W115.hgt.zip
+N43W116.hgt.zip
+N43W117.hgt.zip
+N43W118.hgt.zip
+N43W119.hgt.zip
+N43W120.hgt.zip
+N43W121.hgt.zip
+N43W122.hgt.zip
+N43W123.hgt.zip
+N43W124.hgt.zip
+N43W125.hgt.zip
+N44W060.hgt.zip
+N44W062.hgt.zip
+N44W063.hgt.zip
+N44W064.hgt.zip
+N44W065.hgt.zip
+N44W066.hgt.zip
+N44W067.hgt.zip
+N44W068.hgt.zip
+N44W069.hgt.zip
+N44W070.hgt.zip
+N44W071.hgt.zip
+N44W072.hgt.zip
+N44W073.hgt.zip
+N44W074.hgt.zip
+N44W075.hgt.zip
+N44W076.hgt.zip
+N44W077.hgt.zip
+N44W078.hgt.zip
+N44W079.hgt.zip
+N44W080.hgt.zip
+N44W081.hgt.zip
+N44W082.hgt.zip
+N44W083.hgt.zip
+N44W084.hgt.zip
+N44W085.hgt.zip
+N44W086.hgt.zip
+N44W087.hgt.zip
+N44W088.hgt.zip
+N44W089.hgt.zip
+N44W090.hgt.zip
+N44W091.hgt.zip
+N44W092.hgt.zip
+N44W093.hgt.zip
+N44W094.hgt.zip
+N44W095.hgt.zip
+N44W096.hgt.zip
+N44W097.hgt.zip
+N44W098.hgt.zip
+N44W099.hgt.zip
+N44W100.hgt.zip
+N44W101.hgt.zip
+N44W102.hgt.zip
+N44W103.hgt.zip
+N44W104.hgt.zip
+N44W105.hgt.zip
+N44W106.hgt.zip
+N44W107.hgt.zip
+N44W108.hgt.zip
+N44W109.hgt.zip
+N44W110.hgt.zip
+N44W111.hgt.zip
+N44W112.hgt.zip
+N44W113.hgt.zip
+N44W114.hgt.zip
+N44W115.hgt.zip
+N44W116.hgt.zip
+N44W117.hgt.zip
+N44W118.hgt.zip
+N44W119.hgt.zip
+N44W120.hgt.zip
+N44W121.hgt.zip
+N44W122.hgt.zip
+N44W123.hgt.zip
+N44W124.hgt.zip
+N44W125.hgt.zip
+N45W060.hgt.zip
+N45W061.hgt.zip
+N45W062.hgt.zip
+N45W063.hgt.zip
+N45W064.hgt.zip
+N45W065.hgt.zip
+N45W066.hgt.zip
+N45W067.hgt.zip
+N45W068.hgt.zip
+N45W069.hgt.zip
+N45W070.hgt.zip
+N45W071.hgt.zip
+N45W072.hgt.zip
+N45W073.hgt.zip
+N45W074.hgt.zip
+N45W075.hgt.zip
+N45W076.hgt.zip
+N45W077.hgt.zip
+N45W078.hgt.zip
+N45W079.hgt.zip
+N45W080.hgt.zip
+N45W081.hgt.zip
+N45W082.hgt.zip
+N45W083.hgt.zip
+N45W084.hgt.zip
+N45W085.hgt.zip
+N45W086.hgt.zip
+N45W087.hgt.zip
+N45W088.hgt.zip
+N45W089.hgt.zip
+N45W090.hgt.zip
+N45W091.hgt.zip
+N45W092.hgt.zip
+N45W093.hgt.zip
+N45W094.hgt.zip
+N45W095.hgt.zip
+N45W096.hgt.zip
+N45W097.hgt.zip
+N45W098.hgt.zip
+N45W099.hgt.zip
+N45W100.hgt.zip
+N45W101.hgt.zip
+N45W102.hgt.zip
+N45W103.hgt.zip
+N45W104.hgt.zip
+N45W105.hgt.zip
+N45W106.hgt.zip
+N45W107.hgt.zip
+N45W108.hgt.zip
+N45W109.hgt.zip
+N45W110.hgt.zip
+N45W111.hgt.zip
+N45W112.hgt.zip
+N45W113.hgt.zip
+N45W114.hgt.zip
+N45W115.hgt.zip
+N45W116.hgt.zip
+N45W117.hgt.zip
+N45W118.hgt.zip
+N45W119.hgt.zip
+N45W120.hgt.zip
+N45W121.hgt.zip
+N45W122.hgt.zip
+N45W123.hgt.zip
+N45W124.hgt.zip
+N45W125.hgt.zip
+N46W053.hgt.zip
+N46W054.hgt.zip
+N46W055.hgt.zip
+N46W056.hgt.zip
+N46W057.hgt.zip
+N46W060.hgt.zip
+N46W061.hgt.zip
+N46W062.hgt.zip
+N46W063.hgt.zip
+N46W064.hgt.zip
+N46W065.hgt.zip
+N46W066.hgt.zip
+N46W067.hgt.zip
+N46W068.hgt.zip
+N46W069.hgt.zip
+N46W070.hgt.zip
+N46W071.hgt.zip
+N46W072.hgt.zip
+N46W073.hgt.zip
+N46W074.hgt.zip
+N46W075.hgt.zip
+N46W076.hgt.zip
+N46W077.hgt.zip
+N46W078.hgt.zip
+N46W079.hgt.zip
+N46W080.hgt.zip
+N46W081.hgt.zip
+N46W082.hgt.zip
+N46W083.hgt.zip
+N46W084.hgt.zip
+N46W085.hgt.zip
+N46W086.hgt.zip
+N46W087.hgt.zip
+N46W088.hgt.zip
+N46W089.hgt.zip
+N46W090.hgt.zip
+N46W091.hgt.zip
+N46W092.hgt.zip
+N46W093.hgt.zip
+N46W094.hgt.zip
+N46W095.hgt.zip
+N46W096.hgt.zip
+N46W097.hgt.zip
+N46W098.hgt.zip
+N46W099.hgt.zip
+N46W100.hgt.zip
+N46W101.hgt.zip
+N46W102.hgt.zip
+N46W103.hgt.zip
+N46W104.hgt.zip
+N46W105.hgt.zip
+N46W106.hgt.zip
+N46W107.hgt.zip
+N46W108.hgt.zip
+N46W109.hgt.zip
+N46W110.hgt.zip
+N46W111.hgt.zip
+N46W112.hgt.zip
+N46W113.hgt.zip
+N46W114.hgt.zip
+N46W115.hgt.zip
+N46W116.hgt.zip
+N46W117.hgt.zip
+N46W118.hgt.zip
+N46W119.hgt.zip
+N46W120.hgt.zip
+N46W121.hgt.zip
+N46W122.hgt.zip
+N46W123.hgt.zip
+N46W124.hgt.zip
+N46W125.hgt.zip
+N47W053.hgt.zip
+N47W054.hgt.zip
+N47W055.hgt.zip
+N47W056.hgt.zip
+N47W057.hgt.zip
+N47W058.hgt.zip
+N47W059.hgt.zip
+N47W060.hgt.zip
+N47W061.hgt.zip
+N47W062.hgt.zip
+N47W063.hgt.zip
+N47W064.hgt.zip
+N47W065.hgt.zip
+N47W066.hgt.zip
+N47W067.hgt.zip
+N47W068.hgt.zip
+N47W069.hgt.zip
+N47W070.hgt.zip
+N47W071.hgt.zip
+N47W072.hgt.zip
+N47W073.hgt.zip
+N47W074.hgt.zip
+N47W075.hgt.zip
+N47W076.hgt.zip
+N47W077.hgt.zip
+N47W078.hgt.zip
+N47W079.hgt.zip
+N47W080.hgt.zip
+N47W081.hgt.zip
+N47W082.hgt.zip
+N47W083.hgt.zip
+N47W084.hgt.zip
+N47W085.hgt.zip
+N47W086.hgt.zip
+N47W088.hgt.zip
+N47W089.hgt.zip
+N47W090.hgt.zip
+N47W091.hgt.zip
+N47W092.hgt.zip
+N47W093.hgt.zip
+N47W094.hgt.zip
+N47W095.hgt.zip
+N47W096.hgt.zip
+N47W097.hgt.zip
+N47W098.hgt.zip
+N47W099.hgt.zip
+N47W100.hgt.zip
+N47W101.hgt.zip
+N47W102.hgt.zip
+N47W103.hgt.zip
+N47W104.hgt.zip
+N47W105.hgt.zip
+N47W106.hgt.zip
+N47W107.hgt.zip
+N47W108.hgt.zip
+N47W109.hgt.zip
+N47W110.hgt.zip
+N47W111.hgt.zip
+N47W112.hgt.zip
+N47W113.hgt.zip
+N47W114.hgt.zip
+N47W115.hgt.zip
+N47W116.hgt.zip
+N47W117.hgt.zip
+N47W118.hgt.zip
+N47W119.hgt.zip
+N47W120.hgt.zip
+N47W121.hgt.zip
+N47W122.hgt.zip
+N47W123.hgt.zip
+N47W124.hgt.zip
+N47W125.hgt.zip
+N48W053.hgt.zip
+N48W054.hgt.zip
+N48W055.hgt.zip
+N48W056.hgt.zip
+N48W057.hgt.zip
+N48W058.hgt.zip
+N48W059.hgt.zip
+N48W060.hgt.zip
+N48W065.hgt.zip
+N48W066.hgt.zip
+N48W067.hgt.zip
+N48W068.hgt.zip
+N48W069.hgt.zip
+N48W070.hgt.zip
+N48W071.hgt.zip
+N48W072.hgt.zip
+N48W073.hgt.zip
+N48W074.hgt.zip
+N48W075.hgt.zip
+N48W076.hgt.zip
+N48W077.hgt.zip
+N48W078.hgt.zip
+N48W079.hgt.zip
+N48W080.hgt.zip
+N48W081.hgt.zip
+N48W082.hgt.zip
+N48W083.hgt.zip
+N48W084.hgt.zip
+N48W085.hgt.zip
+N48W086.hgt.zip
+N48W087.hgt.zip
+N48W088.hgt.zip
+N48W089.hgt.zip
+N48W090.hgt.zip
+N48W091.hgt.zip
+N48W092.hgt.zip
+N48W093.hgt.zip
+N48W094.hgt.zip
+N48W095.hgt.zip
+N48W096.hgt.zip
+N48W097.hgt.zip
+N48W098.hgt.zip
+N48W099.hgt.zip
+N48W100.hgt.zip
+N48W101.hgt.zip
+N48W102.hgt.zip
+N48W103.hgt.zip
+N48W104.hgt.zip
+N48W105.hgt.zip
+N48W106.hgt.zip
+N48W107.hgt.zip
+N48W108.hgt.zip
+N48W109.hgt.zip
+N48W110.hgt.zip
+N48W111.hgt.zip
+N48W112.hgt.zip
+N48W113.hgt.zip
+N48W114.hgt.zip
+N48W115.hgt.zip
+N48W116.hgt.zip
+N48W117.hgt.zip
+N48W118.hgt.zip
+N48W119.hgt.zip
+N48W120.hgt.zip
+N48W121.hgt.zip
+N48W122.hgt.zip
+N48W123.hgt.zip
+N48W124.hgt.zip
+N48W125.hgt.zip
+N48W126.hgt.zip
+N49W054.hgt.zip
+N49W055.hgt.zip
+N49W056.hgt.zip
+N49W057.hgt.zip
+N49W058.hgt.zip
+N49W059.hgt.zip
+N49W062.hgt.zip
+N49W063.hgt.zip
+N49W064.hgt.zip
+N49W065.hgt.zip
+N49W066.hgt.zip
+N49W067.hgt.zip
+N49W068.hgt.zip
+N49W069.hgt.zip
+N49W070.hgt.zip
+N49W071.hgt.zip
+N49W072.hgt.zip
+N49W073.hgt.zip
+N49W074.hgt.zip
+N49W075.hgt.zip
+N49W076.hgt.zip
+N49W077.hgt.zip
+N49W078.hgt.zip
+N49W079.hgt.zip
+N49W080.hgt.zip
+N49W081.hgt.zip
+N49W082.hgt.zip
+N49W083.hgt.zip
+N49W084.hgt.zip
+N49W085.hgt.zip
+N49W086.hgt.zip
+N49W087.hgt.zip
+N49W088.hgt.zip
+N49W089.hgt.zip
+N49W090.hgt.zip
+N49W091.hgt.zip
+N49W092.hgt.zip
+N49W093.hgt.zip
+N49W094.hgt.zip
+N49W095.hgt.zip
+N49W096.hgt.zip
+N49W097.hgt.zip
+N49W098.hgt.zip
+N49W099.hgt.zip
+N49W100.hgt.zip
+N49W101.hgt.zip
+N49W102.hgt.zip
+N49W103.hgt.zip
+N49W104.hgt.zip
+N49W105.hgt.zip
+N49W106.hgt.zip
+N49W107.hgt.zip
+N49W108.hgt.zip
+N49W109.hgt.zip
+N49W110.hgt.zip
+N49W111.hgt.zip
+N49W112.hgt.zip
+N49W113.hgt.zip
+N49W114.hgt.zip
+N49W115.hgt.zip
+N49W116.hgt.zip
+N49W117.hgt.zip
+N49W118.hgt.zip
+N49W119.hgt.zip
+N49W120.hgt.zip
+N49W121.hgt.zip
+N49W122.hgt.zip
+N49W123.hgt.zip
+N49W124.hgt.zip
+N49W125.hgt.zip
+N49W126.hgt.zip
+N49W127.hgt.zip
+N49W128.hgt.zip
+N50W056.hgt.zip
+N50W057.hgt.zip
+N50W058.hgt.zip
+N50W059.hgt.zip
+N50W060.hgt.zip
+N50W061.hgt.zip
+N50W062.hgt.zip
+N50W063.hgt.zip
+N50W064.hgt.zip
+N50W065.hgt.zip
+N50W066.hgt.zip
+N50W067.hgt.zip
+N50W068.hgt.zip
+N50W069.hgt.zip
+N50W070.hgt.zip
+N50W071.hgt.zip
+N50W072.hgt.zip
+N50W073.hgt.zip
+N50W074.hgt.zip
+N50W075.hgt.zip
+N50W076.hgt.zip
+N50W077.hgt.zip
+N50W078.hgt.zip
+N50W079.hgt.zip
+N50W080.hgt.zip
+N50W081.hgt.zip
+N50W082.hgt.zip
+N50W083.hgt.zip
+N50W084.hgt.zip
+N50W085.hgt.zip
+N50W086.hgt.zip
+N50W087.hgt.zip
+N50W088.hgt.zip
+N50W089.hgt.zip
+N50W090.hgt.zip
+N50W091.hgt.zip
+N50W092.hgt.zip
+N50W093.hgt.zip
+N50W094.hgt.zip
+N50W095.hgt.zip
+N50W096.hgt.zip
+N50W097.hgt.zip
+N50W098.hgt.zip
+N50W099.hgt.zip
+N50W100.hgt.zip
+N50W101.hgt.zip
+N50W102.hgt.zip
+N50W103.hgt.zip
+N50W104.hgt.zip
+N50W105.hgt.zip
+N50W106.hgt.zip
+N50W107.hgt.zip
+N50W108.hgt.zip
+N50W109.hgt.zip
+N50W110.hgt.zip
+N50W111.hgt.zip
+N50W112.hgt.zip
+N50W113.hgt.zip
+N50W114.hgt.zip
+N50W115.hgt.zip
+N50W116.hgt.zip
+N50W117.hgt.zip
+N50W118.hgt.zip
+N50W119.hgt.zip
+N50W120.hgt.zip
+N50W121.hgt.zip
+N50W122.hgt.zip
+N50W123.hgt.zip
+N50W124.hgt.zip
+N50W125.hgt.zip
+N50W126.hgt.zip
+N50W127.hgt.zip
+N50W128.hgt.zip
+N50W129.hgt.zip
+N50W130.hgt.zip
+N51E177.hgt.zip
+N51E178.hgt.zip
+N51E179.hgt.zip
+N51W056.hgt.zip
+N51W057.hgt.zip
+N51W058.hgt.zip
+N51W059.hgt.zip
+N51W060.hgt.zip
+N51W061.hgt.zip
+N51W062.hgt.zip
+N51W063.hgt.zip
+N51W064.hgt.zip
+N51W065.hgt.zip
+N51W066.hgt.zip
+N51W067.hgt.zip
+N51W068.hgt.zip
+N51W069.hgt.zip
+N51W070.hgt.zip
+N51W071.hgt.zip
+N51W072.hgt.zip
+N51W073.hgt.zip
+N51W074.hgt.zip
+N51W075.hgt.zip
+N51W076.hgt.zip
+N51W077.hgt.zip
+N51W078.hgt.zip
+N51W079.hgt.zip
+N51W080.hgt.zip
+N51W081.hgt.zip
+N51W082.hgt.zip
+N51W083.hgt.zip
+N51W084.hgt.zip
+N51W085.hgt.zip
+N51W086.hgt.zip
+N51W087.hgt.zip
+N51W088.hgt.zip
+N51W089.hgt.zip
+N51W090.hgt.zip
+N51W091.hgt.zip
+N51W092.hgt.zip
+N51W093.hgt.zip
+N51W094.hgt.zip
+N51W095.hgt.zip
+N51W096.hgt.zip
+N51W097.hgt.zip
+N51W098.hgt.zip
+N51W099.hgt.zip
+N51W100.hgt.zip
+N51W101.hgt.zip
+N51W102.hgt.zip
+N51W103.hgt.zip
+N51W104.hgt.zip
+N51W105.hgt.zip
+N51W106.hgt.zip
+N51W107.hgt.zip
+N51W108.hgt.zip
+N51W109.hgt.zip
+N51W110.hgt.zip
+N51W111.hgt.zip
+N51W112.hgt.zip
+N51W113.hgt.zip
+N51W114.hgt.zip
+N51W115.hgt.zip
+N51W116.hgt.zip
+N51W117.hgt.zip
+N51W118.hgt.zip
+N51W119.hgt.zip
+N51W120.hgt.zip
+N51W121.hgt.zip
+N51W122.hgt.zip
+N51W123.hgt.zip
+N51W124.hgt.zip
+N51W125.hgt.zip
+N51W126.hgt.zip
+N51W127.hgt.zip
+N51W128.hgt.zip
+N51W129.hgt.zip
+N51W131.hgt.zip
+N51W132.hgt.zip
+N51W176.hgt.zip
+N51W177.hgt.zip
+N51W178.hgt.zip
+N51W179.hgt.zip
+N51W180.hgt.zip
+N52E172.hgt.zip
+N52E173.hgt.zip
+N52E174.hgt.zip
+N52E175.hgt.zip
+N52E177.hgt.zip
+N52E178.hgt.zip
+N52E179.hgt.zip
+N52W056.hgt.zip
+N52W057.hgt.zip
+N52W058.hgt.zip
+N52W059.hgt.zip
+N52W060.hgt.zip
+N52W061.hgt.zip
+N52W062.hgt.zip
+N52W063.hgt.zip
+N52W064.hgt.zip
+N52W065.hgt.zip
+N52W066.hgt.zip
+N52W067.hgt.zip
+N52W068.hgt.zip
+N52W069.hgt.zip
+N52W070.hgt.zip
+N52W071.hgt.zip
+N52W072.hgt.zip
+N52W073.hgt.zip
+N52W074.hgt.zip
+N52W075.hgt.zip
+N52W076.hgt.zip
+N52W077.hgt.zip
+N52W078.hgt.zip
+N52W079.hgt.zip
+N52W080.hgt.zip
+N52W081.hgt.zip
+N52W082.hgt.zip
+N52W083.hgt.zip
+N52W084.hgt.zip
+N52W085.hgt.zip
+N52W086.hgt.zip
+N52W087.hgt.zip
+N52W088.hgt.zip
+N52W089.hgt.zip
+N52W090.hgt.zip
+N52W091.hgt.zip
+N52W092.hgt.zip
+N52W093.hgt.zip
+N52W094.hgt.zip
+N52W095.hgt.zip
+N52W096.hgt.zip
+N52W097.hgt.zip
+N52W098.hgt.zip
+N52W099.hgt.zip
+N52W100.hgt.zip
+N52W101.hgt.zip
+N52W102.hgt.zip
+N52W103.hgt.zip
+N52W104.hgt.zip
+N52W105.hgt.zip
+N52W106.hgt.zip
+N52W107.hgt.zip
+N52W108.hgt.zip
+N52W109.hgt.zip
+N52W110.hgt.zip
+N52W111.hgt.zip
+N52W112.hgt.zip
+N52W113.hgt.zip
+N52W114.hgt.zip
+N52W115.hgt.zip
+N52W116.hgt.zip
+N52W117.hgt.zip
+N52W118.hgt.zip
+N52W119.hgt.zip
+N52W120.hgt.zip
+N52W121.hgt.zip
+N52W122.hgt.zip
+N52W123.hgt.zip
+N52W124.hgt.zip
+N52W125.hgt.zip
+N52W126.hgt.zip
+N52W127.hgt.zip
+N52W128.hgt.zip
+N52W129.hgt.zip
+N52W130.hgt.zip
+N52W131.hgt.zip
+N52W132.hgt.zip
+N52W133.hgt.zip
+N52W169.hgt.zip
+N52W170.hgt.zip
+N52W171.hgt.zip
+N52W172.hgt.zip
+N52W173.hgt.zip
+N52W174.hgt.zip
+N52W175.hgt.zip
+N52W176.hgt.zip
+N52W177.hgt.zip
+N53E172.hgt.zip
+N53W056.hgt.zip
+N53W057.hgt.zip
+N53W058.hgt.zip
+N53W059.hgt.zip
+N53W060.hgt.zip
+N53W061.hgt.zip
+N53W062.hgt.zip
+N53W063.hgt.zip
+N53W064.hgt.zip
+N53W065.hgt.zip
+N53W066.hgt.zip
+N53W067.hgt.zip
+N53W068.hgt.zip
+N53W069.hgt.zip
+N53W070.hgt.zip
+N53W071.hgt.zip
+N53W072.hgt.zip
+N53W073.hgt.zip
+N53W074.hgt.zip
+N53W075.hgt.zip
+N53W076.hgt.zip
+N53W077.hgt.zip
+N53W078.hgt.zip
+N53W079.hgt.zip
+N53W080.hgt.zip
+N53W081.hgt.zip
+N53W082.hgt.zip
+N53W083.hgt.zip
+N53W084.hgt.zip
+N53W085.hgt.zip
+N53W086.hgt.zip
+N53W087.hgt.zip
+N53W088.hgt.zip
+N53W089.hgt.zip
+N53W090.hgt.zip
+N53W091.hgt.zip
+N53W092.hgt.zip
+N53W093.hgt.zip
+N53W094.hgt.zip
+N53W095.hgt.zip
+N53W096.hgt.zip
+N53W097.hgt.zip
+N53W098.hgt.zip
+N53W099.hgt.zip
+N53W100.hgt.zip
+N53W101.hgt.zip
+N53W102.hgt.zip
+N53W103.hgt.zip
+N53W104.hgt.zip
+N53W105.hgt.zip
+N53W106.hgt.zip
+N53W107.hgt.zip
+N53W108.hgt.zip
+N53W109.hgt.zip
+N53W110.hgt.zip
+N53W111.hgt.zip
+N53W112.hgt.zip
+N53W113.hgt.zip
+N53W114.hgt.zip
+N53W115.hgt.zip
+N53W116.hgt.zip
+N53W117.hgt.zip
+N53W118.hgt.zip
+N53W119.hgt.zip
+N53W120.hgt.zip
+N53W121.hgt.zip
+N53W122.hgt.zip
+N53W123.hgt.zip
+N53W124.hgt.zip
+N53W125.hgt.zip
+N53W126.hgt.zip
+N53W127.hgt.zip
+N53W128.hgt.zip
+N53W129.hgt.zip
+N53W130.hgt.zip
+N53W131.hgt.zip
+N53W132.hgt.zip
+N53W133.hgt.zip
+N53W134.hgt.zip
+N53W167.hgt.zip
+N53W168.hgt.zip
+N53W169.hgt.zip
+N53W170.hgt.zip
+N54W057.hgt.zip
+N54W058.hgt.zip
+N54W059.hgt.zip
+N54W060.hgt.zip
+N54W061.hgt.zip
+N54W062.hgt.zip
+N54W063.hgt.zip
+N54W064.hgt.zip
+N54W065.hgt.zip
+N54W066.hgt.zip
+N54W067.hgt.zip
+N54W068.hgt.zip
+N54W069.hgt.zip
+N54W070.hgt.zip
+N54W071.hgt.zip
+N54W072.hgt.zip
+N54W073.hgt.zip
+N54W074.hgt.zip
+N54W075.hgt.zip
+N54W076.hgt.zip
+N54W077.hgt.zip
+N54W078.hgt.zip
+N54W079.hgt.zip
+N54W080.hgt.zip
+N54W081.hgt.zip
+N54W082.hgt.zip
+N54W083.hgt.zip
+N54W084.hgt.zip
+N54W085.hgt.zip
+N54W086.hgt.zip
+N54W087.hgt.zip
+N54W088.hgt.zip
+N54W089.hgt.zip
+N54W090.hgt.zip
+N54W091.hgt.zip
+N54W092.hgt.zip
+N54W093.hgt.zip
+N54W094.hgt.zip
+N54W095.hgt.zip
+N54W096.hgt.zip
+N54W097.hgt.zip
+N54W098.hgt.zip
+N54W099.hgt.zip
+N54W100.hgt.zip
+N54W101.hgt.zip
+N54W102.hgt.zip
+N54W103.hgt.zip
+N54W104.hgt.zip
+N54W105.hgt.zip
+N54W106.hgt.zip
+N54W107.hgt.zip
+N54W108.hgt.zip
+N54W109.hgt.zip
+N54W110.hgt.zip
+N54W111.hgt.zip
+N54W112.hgt.zip
+N54W113.hgt.zip
+N54W114.hgt.zip
+N54W115.hgt.zip
+N54W116.hgt.zip
+N54W117.hgt.zip
+N54W118.hgt.zip
+N54W119.hgt.zip
+N54W120.hgt.zip
+N54W121.hgt.zip
+N54W122.hgt.zip
+N54W123.hgt.zip
+N54W124.hgt.zip
+N54W125.hgt.zip
+N54W126.hgt.zip
+N54W127.hgt.zip
+N54W128.hgt.zip
+N54W129.hgt.zip
+N54W130.hgt.zip
+N54W131.hgt.zip
+N54W132.hgt.zip
+N54W133.hgt.zip
+N54W134.hgt.zip
+N54W160.hgt.zip
+N54W161.hgt.zip
+N54W162.hgt.zip
+N54W163.hgt.zip
+N54W164.hgt.zip
+N54W165.hgt.zip
+N54W166.hgt.zip
+N54W167.hgt.zip
+N55W059hgt.zip
+N55W060hgt.zip
+N55W061hgt.zip
+N55W062hgt.zip
+N55W063hgt.zip
+N55W064hgt.zip
+N55W065hgt.zip
+N55W066hgt.zip
+N55W067hgt.zip
+N55W068hgt.zip
+N55W069hgt.zip
+N55W070hgt.zip
+N55W071hgt.zip
+N55W072hgt.zip
+N55W073hgt.zip
+N55W074hgt.zip
+N55W075hgt.zip
+N55W076hgt.zip
+N55W077hgt.zip
+N55W078hgt.zip
+N55W079hgt.zip
+N55W080hgt.zip
+N55W081hgt.zip
+N55W083hgt.zip
+N55W084hgt.zip
+N55W085hgt.zip
+N55W086hgt.zip
+N55W087hgt.zip
+N55W088hgt.zip
+N55W089hgt.zip
+N55W090hgt.zip
+N55W091hgt.zip
+N55W092hgt.zip
+N55W093hgt.zip
+N55W094hgt.zip
+N55W095hgt.zip
+N55W096hgt.zip
+N55W097hgt.zip
+N55W098hgt.zip
+N55W099hgt.zip
+N55W100hgt.zip
+N55W101hgt.zip
+N55W102hgt.zip
+N55W103hgt.zip
+N55W104hgt.zip
+N55W105hgt.zip
+N55W106hgt.zip
+N55W107hgt.zip
+N55W108hgt.zip
+N55W109hgt.zip
+N55W110hgt.zip
+N55W111hgt.zip
+N55W112hgt.zip
+N55W113hgt.zip
+N55W114hgt.zip
+N55W115hgt.zip
+N55W116hgt.zip
+N55W117hgt.zip
+N55W118hgt.zip
+N55W119hgt.zip
+N55W120hgt.zip
+N55W121hgt.zip
+N55W122hgt.zip
+N55W123hgt.zip
+N55W124hgt.zip
+N55W125hgt.zip
+N55W126hgt.zip
+N55W127hgt.zip
+N55W128hgt.zip
+N55W129hgt.zip
+N55W130hgt.zip
+N55W131hgt.zip
+N55W132hgt.zip
+N55W133hgt.zip
+N55W134hgt.zip
+N55W135hgt.zip
+N55W156hgt.zip
+N55W157hgt.zip
+N55W159hgt.zip
+N55W160hgt.zip
+N55W161hgt.zip
+N55W162hgt.zip
+N55W163hgt.zip
+N55W164hgt.zip
+N56W061hgt.zip
+N56W062hgt.zip
+N56W063hgt.zip
+N56W064hgt.zip
+N56W065hgt.zip
+N56W066hgt.zip
+N56W067hgt.zip
+N56W068hgt.zip
+N56W069hgt.zip
+N56W070hgt.zip
+N56W071hgt.zip
+N56W072hgt.zip
+N56W073hgt.zip
+N56W074hgt.zip
+N56W075hgt.zip
+N56W076hgt.zip
+N56W077hgt.zip
+N56W078hgt.zip
+N56W079hgt.zip
+N56W080hgt.zip
+N56W081hgt.zip
+N56W088hgt.zip
+N56W089hgt.zip
+N56W090hgt.zip
+N56W091hgt.zip
+N56W092hgt.zip
+N56W093hgt.zip
+N56W094hgt.zip
+N56W095hgt.zip
+N56W096hgt.zip
+N56W097hgt.zip
+N56W098hgt.zip
+N56W099hgt.zip
+N56W100hgt.zip
+N56W101hgt.zip
+N56W102hgt.zip
+N56W103hgt.zip
+N56W104hgt.zip
+N56W105hgt.zip
+N56W106hgt.zip
+N56W107hgt.zip
+N56W108hgt.zip
+N56W109hgt.zip
+N56W110hgt.zip
+N56W111hgt.zip
+N56W112hgt.zip
+N56W113hgt.zip
+N56W114hgt.zip
+N56W115hgt.zip
+N56W116hgt.zip
+N56W117hgt.zip
+N56W118hgt.zip
+N56W119hgt.zip
+N56W120hgt.zip
+N56W121hgt.zip
+N56W122hgt.zip
+N56W123hgt.zip
+N56W124hgt.zip
+N56W125hgt.zip
+N56W126hgt.zip
+N56W127hgt.zip
+N56W128hgt.zip
+N56W129hgt.zip
+N56W130hgt.zip
+N56W131hgt.zip
+N56W132hgt.zip
+N56W133hgt.zip
+N56W134hgt.zip
+N56W135hgt.zip
+N56W136hgt.zip
+N56W154hgt.zip
+N56W155hgt.zip
+N56W157hgt.zip
+N56W158hgt.zip
+N56W159hgt.zip
+N56W160hgt.zip
+N56W161hgt.zip
+N56W162hgt.zip
+N56W170hgt.zip
+N57W062hgt.zip
+N57W063hgt.zip
+N57W064hgt.zip
+N57W065hgt.zip
+N57W066hgt.zip
+N57W067hgt.zip
+N57W068hgt.zip
+N57W069hgt.zip
+N57W070hgt.zip
+N57W071hgt.zip
+N57W072hgt.zip
+N57W073hgt.zip
+N57W074hgt.zip
+N57W075hgt.zip
+N57W076hgt.zip
+N57W077hgt.zip
+N57W078hgt.zip
+N57W079hgt.zip
+N57W080hgt.zip
+N57W090hgt.zip
+N57W091hgt.zip
+N57W092hgt.zip
+N57W093hgt.zip
+N57W094hgt.zip
+N57W095hgt.zip
+N57W096hgt.zip
+N57W097hgt.zip
+N57W098hgt.zip
+N57W099hgt.zip
+N57W100hgt.zip
+N57W101hgt.zip
+N57W102hgt.zip
+N57W103hgt.zip
+N57W104hgt.zip
+N57W105hgt.zip
+N57W106hgt.zip
+N57W107hgt.zip
+N57W108hgt.zip
+N57W109hgt.zip
+N57W110hgt.zip
+N57W111hgt.zip
+N57W112hgt.zip
+N57W113hgt.zip
+N57W114hgt.zip
+N57W115hgt.zip
+N57W116hgt.zip
+N57W117hgt.zip
+N57W118hgt.zip
+N57W119hgt.zip
+N57W120hgt.zip
+N57W121hgt.zip
+N57W122hgt.zip
+N57W123hgt.zip
+N57W124hgt.zip
+N57W125hgt.zip
+N57W126hgt.zip
+N57W127hgt.zip
+N57W128hgt.zip
+N57W129hgt.zip
+N57W130hgt.zip
+N57W131hgt.zip
+N57W132hgt.zip
+N57W133hgt.zip
+N57W134hgt.zip
+N57W135hgt.zip
+N57W136hgt.zip
+N57W137hgt.zip
+N57W153hgt.zip
+N57W154hgt.zip
+N57W155hgt.zip
+N57W156hgt.zip
+N57W157hgt.zip
+N57W158hgt.zip
+N57W159hgt.zip
+N57W170hgt.zip
+N57W171hgt.zip
+N58W063hgt.zip
+N58W064hgt.zip
+N58W065hgt.zip
+N58W066hgt.zip
+N58W067hgt.zip
+N58W068hgt.zip
+N58W069hgt.zip
+N58W070hgt.zip
+N58W071hgt.zip
+N58W072hgt.zip
+N58W073hgt.zip
+N58W074hgt.zip
+N58W075hgt.zip
+N58W076hgt.zip
+N58W077hgt.zip
+N58W078hgt.zip
+N58W079hgt.zip
+N58W080hgt.zip
+N58W081hgt.zip
+N58W093hgt.zip
+N58W094hgt.zip
+N58W095hgt.zip
+N58W096hgt.zip
+N58W097hgt.zip
+N58W098hgt.zip
+N58W099hgt.zip
+N58W100hgt.zip
+N58W101hgt.zip
+N58W102hgt.zip
+N58W103hgt.zip
+N58W104hgt.zip
+N58W105hgt.zip
+N58W106hgt.zip
+N58W107hgt.zip
+N58W108hgt.zip
+N58W109hgt.zip
+N58W110hgt.zip
+N58W111hgt.zip
+N58W112hgt.zip
+N58W113hgt.zip
+N58W114hgt.zip
+N58W115hgt.zip
+N58W116hgt.zip
+N58W117hgt.zip
+N58W118hgt.zip
+N58W119hgt.zip
+N58W120hgt.zip
+N58W121hgt.zip
+N58W122hgt.zip
+N58W123hgt.zip
+N58W124hgt.zip
+N58W125hgt.zip
+N58W126hgt.zip
+N58W127hgt.zip
+N58W128hgt.zip
+N58W129hgt.zip
+N58W130hgt.zip
+N58W131hgt.zip
+N58W132hgt.zip
+N58W133hgt.zip
+N58W134hgt.zip
+N58W135hgt.zip
+N58W136hgt.zip
+N58W137hgt.zip
+N58W138hgt.zip
+N58W139hgt.zip
+N58W152hgt.zip
+N58W153hgt.zip
+N58W154hgt.zip
+N58W155hgt.zip
+N58W156hgt.zip
+N58W157hgt.zip
+N58W158hgt.zip
+N58W159hgt.zip
+N58W160hgt.zip
+N58W161hgt.zip
+N58W162hgt.zip
+N58W163hgt.zip
+N59W044hgt.zip
+N59W045hgt.zip
+N59W046hgt.zip
+N59W064hgt.zip
+N59W065hgt.zip
+N59W066hgt.zip
+N59W067hgt.zip
+N59W069hgt.zip
+N59W070hgt.zip
+N59W071hgt.zip
+N59W072hgt.zip
+N59W073hgt.zip
+N59W074hgt.zip
+N59W075hgt.zip
+N59W076hgt.zip
+N59W077hgt.zip
+N59W078hgt.zip
+N59W079hgt.zip
+N59W080hgt.zip
+N59W081hgt.zip
+N59W095hgt.zip
+N59W096hgt.zip
+N59W097hgt.zip
+N59W098hgt.zip
+N59W099hgt.zip
+N59W100hgt.zip
+N59W101hgt.zip
+N59W102hgt.zip
+N59W103hgt.zip
+N59W104hgt.zip
+N59W105hgt.zip
+N59W106hgt.zip
+N59W107hgt.zip
+N59W108hgt.zip
+N59W109hgt.zip
+N59W110hgt.zip
+N59W111hgt.zip
+N59W112hgt.zip
+N59W113hgt.zip
+N59W114hgt.zip
+N59W115hgt.zip
+N59W116hgt.zip
+N59W117hgt.zip
+N59W118hgt.zip
+N59W119hgt.zip
+N59W120hgt.zip
+N59W121hgt.zip
+N59W122hgt.zip
+N59W123hgt.zip
+N59W124hgt.zip
+N59W125hgt.zip
+N59W126hgt.zip
+N59W127hgt.zip
+N59W128hgt.zip
+N59W129hgt.zip
+N59W130hgt.zip
+N59W131hgt.zip
+N59W132hgt.zip
+N59W133hgt.zip
+N59W134hgt.zip
+N59W135hgt.zip
+N59W136hgt.zip
+N59W137hgt.zip
+N59W138hgt.zip
+N59W139hgt.zip
+N59W140hgt.zip
+N59W141hgt.zip
+N59W142hgt.zip
+N59W144hgt.zip
+N59W145hgt.zip
+N59W147hgt.zip
+N59W148hgt.zip
+N59W149hgt.zip
+N59W150hgt.zip
+N59W151hgt.zip
+N59W152hgt.zip
+N59W153hgt.zip
+N59W154hgt.zip
+N59W155hgt.zip
+N59W156hgt.zip
+N59W157hgt.zip
+N59W158hgt.zip
+N59W159hgt.zip
+N59W160hgt.zip
+N59W161hgt.zip
+N59W162hgt.zip
+N59W163hgt.zip
+N59W164hgt.zip
+N59W165hgt.zip
+N60W043hgt.zip
+N60W044hgt.zip
+N60W045hgt.zip
+N60W046hgt.zip
+N60W047hgt.zip
+N60W048hgt.zip
+N60W049hgt.zip
+N60W064hgt.zip
+N60W065hgt.zip
+N60W066hgt.zip
+N60W068hgt.zip
+N60W069hgt.zip
+N60W070hgt.zip
+N60W071hgt.zip
+N60W072hgt.zip
+N60W073hgt.zip
+N60W074hgt.zip
+N60W075hgt.zip
+N60W076hgt.zip
+N60W077hgt.zip
+N60W078hgt.zip
+N60W079hgt.zip
+N60W095hgt.zip
+N60W096hgt.zip
+N60W097hgt.zip
+N60W098hgt.zip
+N60W099hgt.zip
+N60W100hgt.zip
+N60W101hgt.zip
+N60W102hgt.zip
+N60W103hgt.zip
+N60W104hgt.zip
+N60W105hgt.zip
+N60W106hgt.zip
+N60W107hgt.zip
+N60W108hgt.zip
+N60W109hgt.zip
+N60W110hgt.zip
+N60W111hgt.zip
+N60W112hgt.zip
+N60W113hgt.zip
+N60W114hgt.zip
+N60W115hgt.zip
+N60W116hgt.zip
+N60W117hgt.zip
+N60W118hgt.zip
+N60W119hgt.zip
+N60W120hgt.zip
+N60W121hgt.zip
+N60W122hgt.zip
+N60W123hgt.zip
+N60W124hgt.zip
+N60W125hgt.zip
+N60W126hgt.zip
+N60W127hgt.zip
+N60W128hgt.zip
+N60W129hgt.zip
+N60W130hgt.zip
+N60W131hgt.zip
+N60W132hgt.zip
+N60W133hgt.zip
+N60W134hgt.zip
+N60W135hgt.zip
+N60W136hgt.zip
+N60W137hgt.zip
+N60W138hgt.zip
+N60W139hgt.zip
+N60W140hgt.zip
+N60W141hgt.zip
+N60W142hgt.zip
+N60W143hgt.zip
+N60W144hgt.zip
+N60W145hgt.zip
+N60W146hgt.zip
+N60W147hgt.zip
+N60W148hgt.zip
+N60W149hgt.zip
+N60W150hgt.zip
+N60W151hgt.zip
+N60W152hgt.zip
+N60W153hgt.zip
+N60W154hgt.zip
+N60W155hgt.zip
+N60W156hgt.zip
+N60W157hgt.zip
+N60W158hgt.zip
+N60W159hgt.zip
+N60W160hgt.zip
+N60W161hgt.zip
+N60W162hgt.zip
+N60W163hgt.zip
+N60W164hgt.zip
+N60W165hgt.zip
+N60W166hgt.zip
+N60W167hgt.zip
+N60W168hgt.zip
+N60W173hgt.zip
+N60W174hgt.zip
\ No newline at end of file
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/North_America_names.txt.zip b/core/src/main/resources/com/graphhopper/reader/dem/North_America_names.txt.zip
deleted file mode 100644
index de10d69e00..0000000000
Binary files a/core/src/main/resources/com/graphhopper/reader/dem/North_America_names.txt.zip and /dev/null differ
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/South_America_names.txt b/core/src/main/resources/com/graphhopper/reader/dem/South_America_names.txt
new file mode 100644
index 0000000000..de903dbd35
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/reader/dem/South_America_names.txt
@@ -0,0 +1,1807 @@
+N00W050.hgt.zip
+N00W051.hgt.zip
+N00W052.hgt.zip
+N00W053.hgt.zip
+N00W054.hgt.zip
+N00W055.hgt.zip
+N00W056.hgt.zip
+N00W057.hgt.zip
+N00W058.hgt.zip
+N00W059.hgt.zip
+N00W060.hgt.zip
+N00W061.hgt.zip
+N00W062.hgt.zip
+N00W063.hgt.zip
+N00W064.hgt.zip
+N00W065.hgt.zip
+N00W066.hgt.zip
+N00W067.hgt.zip
+N00W068.hgt.zip
+N00W069.hgt.zip
+N00W070.hgt.zip
+N00W071.hgt.zip
+N00W072.hgt.zip
+N00W073.hgt.zip
+N00W074.hgt.zip
+N00W075.hgt.zip
+N00W076.hgt.zip
+N00W077.hgt.zip
+N00W078.hgt.zip
+N00W079.hgt.zip
+N00W080.hgt.zip
+N00W081.hgt.zip
+N00W090.hgt.zip
+N00W091.hgt.zip
+N00W092.hgt.zip
+N01W050.hgt.zip
+N01W051.hgt.zip
+N01W052.hgt.zip
+N01W053.hgt.zip
+N01W054.hgt.zip
+N01W055.hgt.zip
+N01W056.hgt.zip
+N01W057.hgt.zip
+N01W058.hgt.zip
+N01W059.hgt.zip
+N01W060.hgt.zip
+N01W061.hgt.zip
+N01W062.hgt.zip
+N01W063.hgt.zip
+N01W064.hgt.zip
+N01W065.hgt.zip
+N01W066.hgt.zip
+N01W067.hgt.zip
+N01W068.hgt.zip
+N01W069.hgt.zip
+N01W070.hgt.zip
+N01W071.hgt.zip
+N01W072.hgt.zip
+N01W073.hgt.zip
+N01W074.hgt.zip
+N01W075.hgt.zip
+N01W076.hgt.zip
+N01W077.hgt.zip
+N01W078.hgt.zip
+N01W079.hgt.zip
+N01W080.hgt.zip
+N01W092.hgt.zip
+N02W051.hgt.zip
+N02W052.hgt.zip
+N02W053.hgt.zip
+N02W054.hgt.zip
+N02W055.hgt.zip
+N02W056.hgt.zip
+N02W057.hgt.zip
+N02W058.hgt.zip
+N02W059.hgt.zip
+N02W060.hgt.zip
+N02W061.hgt.zip
+N02W062.hgt.zip
+N02W063.hgt.zip
+N02W064.hgt.zip
+N02W065.hgt.zip
+N02W066.hgt.zip
+N02W067.hgt.zip
+N02W068.hgt.zip
+N02W069.hgt.zip
+N02W070.hgt.zip
+N02W071.hgt.zip
+N02W072.hgt.zip
+N02W073.hgt.zip
+N02W074.hgt.zip
+N02W075.hgt.zip
+N02W076.hgt.zip
+N02W077.hgt.zip
+N02W078.hgt.zip
+N02W079.hgt.zip
+N03W051.hgt.zip
+N03W052.hgt.zip
+N03W053.hgt.zip
+N03W054.hgt.zip
+N03W055.hgt.zip
+N03W056.hgt.zip
+N03W057.hgt.zip
+N03W058.hgt.zip
+N03W059.hgt.zip
+N03W060.hgt.zip
+N03W061.hgt.zip
+N03W062.hgt.zip
+N03W063.hgt.zip
+N03W064.hgt.zip
+N03W065.hgt.zip
+N03W066.hgt.zip
+N03W067.hgt.zip
+N03W068.hgt.zip
+N03W069.hgt.zip
+N03W070.hgt.zip
+N03W071.hgt.zip
+N03W072.hgt.zip
+N03W073.hgt.zip
+N03W074.hgt.zip
+N03W075.hgt.zip
+N03W076.hgt.zip
+N03W077.hgt.zip
+N03W078.hgt.zip
+N03W079.hgt.zip
+N03W082.hgt.zip
+N04W052.hgt.zip
+N04W053.hgt.zip
+N04W054.hgt.zip
+N04W055.hgt.zip
+N04W056.hgt.zip
+N04W057.hgt.zip
+N04W058.hgt.zip
+N04W059.hgt.zip
+N04W060.hgt.zip
+N04W061.hgt.zip
+N04W062.hgt.zip
+N04W063.hgt.zip
+N04W064.hgt.zip
+N04W065.hgt.zip
+N04W066.hgt.zip
+N04W067.hgt.zip
+N04W068.hgt.zip
+N04W069.hgt.zip
+N04W070.hgt.zip
+N04W071.hgt.zip
+N04W072.hgt.zip
+N04W073.hgt.zip
+N04W074.hgt.zip
+N04W075.hgt.zip
+N04W076.hgt.zip
+N04W077.hgt.zip
+N04W078.hgt.zip
+N04W082.hgt.zip
+N05W053.hgt.zip
+N05W054.hgt.zip
+N05W055.hgt.zip
+N05W056.hgt.zip
+N05W057.hgt.zip
+N05W058.hgt.zip
+N05W059.hgt.zip
+N05W060.hgt.zip
+N05W061.hgt.zip
+N05W062.hgt.zip
+N05W063.hgt.zip
+N05W064.hgt.zip
+N05W065.hgt.zip
+N05W066.hgt.zip
+N05W067.hgt.zip
+N05W068.hgt.zip
+N05W069.hgt.zip
+N05W070.hgt.zip
+N05W071.hgt.zip
+N05W072.hgt.zip
+N05W073.hgt.zip
+N05W074.hgt.zip
+N05W075.hgt.zip
+N05W076.hgt.zip
+N05W077.hgt.zip
+N05W078.hgt.zip
+N05W088.hgt.zip
+N06W056.hgt.zip
+N06W057.hgt.zip
+N06W058.hgt.zip
+N06W059.hgt.zip
+N06W060.hgt.zip
+N06W061.hgt.zip
+N06W062.hgt.zip
+N06W063.hgt.zip
+N06W064.hgt.zip
+N06W065.hgt.zip
+N06W066.hgt.zip
+N06W067.hgt.zip
+N06W068.hgt.zip
+N06W069.hgt.zip
+N06W070.hgt.zip
+N06W071.hgt.zip
+N06W072.hgt.zip
+N06W073.hgt.zip
+N06W074.hgt.zip
+N06W075.hgt.zip
+N06W076.hgt.zip
+N06W077.hgt.zip
+N06W078.hgt.zip
+N07W059.hgt.zip
+N07W060.hgt.zip
+N07W061.hgt.zip
+N07W062.hgt.zip
+N07W063.hgt.zip
+N07W064.hgt.zip
+N07W065.hgt.zip
+N07W066.hgt.zip
+N07W067.hgt.zip
+N07W068.hgt.zip
+N07W069.hgt.zip
+N07W070.hgt.zip
+N07W071.hgt.zip
+N07W072.hgt.zip
+N07W073.hgt.zip
+N07W074.hgt.zip
+N07W075.hgt.zip
+N07W076.hgt.zip
+N07W077.hgt.zip
+N07W078.hgt.zip
+N07W079.hgt.zip
+N07W080.hgt.zip
+N07W081.hgt.zip
+N07W082.hgt.zip
+N07W083.hgt.zip
+N08W060.hgt.zip
+N08W061.hgt.zip
+N08W062.hgt.zip
+N08W063.hgt.zip
+N08W064.hgt.zip
+N08W065.hgt.zip
+N08W066.hgt.zip
+N08W067.hgt.zip
+N08W068.hgt.zip
+N08W069.hgt.zip
+N08W070.hgt.zip
+N08W071.hgt.zip
+N08W072.hgt.zip
+N08W073.hgt.zip
+N08W074.hgt.zip
+N08W075.hgt.zip
+N08W076.hgt.zip
+N08W077.hgt.zip
+N08W078.hgt.zip
+N08W079.hgt.zip
+N08W080.hgt.zip
+N08W081.hgt.zip
+N08W082.hgt.zip
+N08W083.hgt.zip
+N08W084.hgt.zip
+N09W061.hgt.zip
+N09W062.hgt.zip
+N09W063.hgt.zip
+N09W064.hgt.zip
+N09W065.hgt.zip
+N09W066.hgt.zip
+N09W067.hgt.zip
+N09W068.hgt.zip
+N09W069.hgt.zip
+N09W070.hgt.zip
+N09W071.hgt.zip
+N09W072.hgt.zip
+N09W073.hgt.zip
+N09W074.hgt.zip
+N09W075.hgt.zip
+N09W076.hgt.zip
+N09W077.hgt.zip
+N09W078.hgt.zip
+N09W079.hgt.zip
+N09W080.hgt.zip
+N09W081.hgt.zip
+N09W082.hgt.zip
+N09W083.hgt.zip
+N09W084.hgt.zip
+N09W085.hgt.zip
+N09W086.hgt.zip
+N10W061.hgt.zip
+N10W062.hgt.zip
+N10W063.hgt.zip
+N10W064.hgt.zip
+N10W065.hgt.zip
+N10W066.hgt.zip
+N10W067.hgt.zip
+N10W068.hgt.zip
+N10W069.hgt.zip
+N10W070.hgt.zip
+N10W071.hgt.zip
+N10W072.hgt.zip
+N10W073.hgt.zip
+N10W074.hgt.zip
+N10W075.hgt.zip
+N10W076.hgt.zip
+N10W084.hgt.zip
+N10W085.hgt.zip
+N10W086.hgt.zip
+N11W061.hgt.zip
+N11W062.hgt.zip
+N11W064.hgt.zip
+N11W065.hgt.zip
+N11W067.hgt.zip
+N11W068.hgt.zip
+N11W069.hgt.zip
+N11W070.hgt.zip
+N11W071.hgt.zip
+N11W072.hgt.zip
+N11W073.hgt.zip
+N11W074.hgt.zip
+N11W075.hgt.zip
+N11W084.hgt.zip
+N11W085.hgt.zip
+N11W086.hgt.zip
+N11W087.hgt.zip
+N12W062.hgt.zip
+N12W069.hgt.zip
+N12W070.hgt.zip
+N12W071.hgt.zip
+N12W072.hgt.zip
+N12W073.hgt.zip
+N12W082.hgt.zip
+N12W083.hgt.zip
+N12W084.hgt.zip
+N12W085.hgt.zip
+N12W086.hgt.zip
+N12W087.hgt.zip
+N12W088.hgt.zip
+N13W060.hgt.zip
+N13W061.hgt.zip
+N13W062.hgt.zip
+N13W081.hgt.zip
+N13W082.hgt.zip
+N13W084.hgt.zip
+N13W085.hgt.zip
+N13W086.hgt.zip
+N13W087.hgt.zip
+N13W088.hgt.zip
+N13W089.hgt.zip
+N13W090.hgt.zip
+N13W091.hgt.zip
+N13W092.hgt.zip
+N14W061.hgt.zip
+N14W062.hgt.zip
+N14W081.hgt.zip
+N14W083.hgt.zip
+N14W084.hgt.zip
+N14W085.hgt.zip
+N14W086.hgt.zip
+N14W087.hgt.zip
+N14W088.hgt.zip
+N14W089.hgt.zip
+N14W090.hgt.zip
+N14W091.hgt.zip
+N14W092.hgt.zip
+N14W093.hgt.zip
+S01W047.hgt.zip
+S01W048.hgt.zip
+S01W049.hgt.zip
+S01W050.hgt.zip
+S01W051.hgt.zip
+S01W052.hgt.zip
+S01W053.hgt.zip
+S01W054.hgt.zip
+S01W055.hgt.zip
+S01W056.hgt.zip
+S01W057.hgt.zip
+S01W058.hgt.zip
+S01W059.hgt.zip
+S01W060.hgt.zip
+S01W061.hgt.zip
+S01W062.hgt.zip
+S01W063.hgt.zip
+S01W064.hgt.zip
+S01W065.hgt.zip
+S01W066.hgt.zip
+S01W067.hgt.zip
+S01W068.hgt.zip
+S01W069.hgt.zip
+S01W070.hgt.zip
+S01W071.hgt.zip
+S01W072.hgt.zip
+S01W073.hgt.zip
+S01W074.hgt.zip
+S01W075.hgt.zip
+S01W076.hgt.zip
+S01W077.hgt.zip
+S01W078.hgt.zip
+S01W079.hgt.zip
+S01W080.hgt.zip
+S01W081.hgt.zip
+S01W090.hgt.zip
+S01W091.hgt.zip
+S01W092.hgt.zip
+S02W045.hgt.zip
+S02W046.hgt.zip
+S02W047.hgt.zip
+S02W048.hgt.zip
+S02W049.hgt.zip
+S02W050.hgt.zip
+S02W051.hgt.zip
+S02W052.hgt.zip
+S02W053.hgt.zip
+S02W054.hgt.zip
+S02W055.hgt.zip
+S02W056.hgt.zip
+S02W057.hgt.zip
+S02W058.hgt.zip
+S02W059.hgt.zip
+S02W060.hgt.zip
+S02W061.hgt.zip
+S02W062.hgt.zip
+S02W063.hgt.zip
+S02W064.hgt.zip
+S02W065.hgt.zip
+S02W066.hgt.zip
+S02W067.hgt.zip
+S02W068.hgt.zip
+S02W069.hgt.zip
+S02W070.hgt.zip
+S02W071.hgt.zip
+S02W072.hgt.zip
+S02W073.hgt.zip
+S02W074.hgt.zip
+S02W075.hgt.zip
+S02W076.hgt.zip
+S02W077.hgt.zip
+S02W078.hgt.zip
+S02W079.hgt.zip
+S02W080.hgt.zip
+S02W081.hgt.zip
+S02W082.hgt.zip
+S02W090.hgt.zip
+S02W091.hgt.zip
+S02W092.hgt.zip
+S03W040.hgt.zip
+S03W041.hgt.zip
+S03W042.hgt.zip
+S03W043.hgt.zip
+S03W044.hgt.zip
+S03W045.hgt.zip
+S03W046.hgt.zip
+S03W047.hgt.zip
+S03W048.hgt.zip
+S03W049.hgt.zip
+S03W050.hgt.zip
+S03W051.hgt.zip
+S03W052.hgt.zip
+S03W053.hgt.zip
+S03W054.hgt.zip
+S03W055.hgt.zip
+S03W056.hgt.zip
+S03W057.hgt.zip
+S03W058.hgt.zip
+S03W059.hgt.zip
+S03W060.hgt.zip
+S03W061.hgt.zip
+S03W062.hgt.zip
+S03W063.hgt.zip
+S03W064.hgt.zip
+S03W065.hgt.zip
+S03W066.hgt.zip
+S03W067.hgt.zip
+S03W068.hgt.zip
+S03W069.hgt.zip
+S03W070.hgt.zip
+S03W071.hgt.zip
+S03W072.hgt.zip
+S03W073.hgt.zip
+S03W074.hgt.zip
+S03W075.hgt.zip
+S03W076.hgt.zip
+S03W077.hgt.zip
+S03W078.hgt.zip
+S03W079.hgt.zip
+S03W080.hgt.zip
+S03W081.hgt.zip
+S03W082.hgt.zip
+S04W033.hgt.zip
+S04W034.hgt.zip
+S04W039.hgt.zip
+S04W040.hgt.zip
+S04W041.hgt.zip
+S04W042.hgt.zip
+S04W043.hgt.zip
+S04W044.hgt.zip
+S04W045.hgt.zip
+S04W046.hgt.zip
+S04W047.hgt.zip
+S04W048.hgt.zip
+S04W049.hgt.zip
+S04W050.hgt.zip
+S04W051.hgt.zip
+S04W052.hgt.zip
+S04W053.hgt.zip
+S04W054.hgt.zip
+S04W055.hgt.zip
+S04W056.hgt.zip
+S04W057.hgt.zip
+S04W058.hgt.zip
+S04W059.hgt.zip
+S04W060.hgt.zip
+S04W061.hgt.zip
+S04W062.hgt.zip
+S04W063.hgt.zip
+S04W064.hgt.zip
+S04W065.hgt.zip
+S04W066.hgt.zip
+S04W067.hgt.zip
+S04W068.hgt.zip
+S04W069.hgt.zip
+S04W070.hgt.zip
+S04W071.hgt.zip
+S04W072.hgt.zip
+S04W073.hgt.zip
+S04W074.hgt.zip
+S04W075.hgt.zip
+S04W076.hgt.zip
+S04W077.hgt.zip
+S04W078.hgt.zip
+S04W079.hgt.zip
+S04W080.hgt.zip
+S04W081.hgt.zip
+S05W037.hgt.zip
+S05W038.hgt.zip
+S05W039.hgt.zip
+S05W040.hgt.zip
+S05W041.hgt.zip
+S05W042.hgt.zip
+S05W043.hgt.zip
+S05W044.hgt.zip
+S05W045.hgt.zip
+S05W046.hgt.zip
+S05W047.hgt.zip
+S05W048.hgt.zip
+S05W049.hgt.zip
+S05W050.hgt.zip
+S05W051.hgt.zip
+S05W052.hgt.zip
+S05W053.hgt.zip
+S05W054.hgt.zip
+S05W055.hgt.zip
+S05W056.hgt.zip
+S05W057.hgt.zip
+S05W058.hgt.zip
+S05W059.hgt.zip
+S05W060.hgt.zip
+S05W061.hgt.zip
+S05W062.hgt.zip
+S05W063.hgt.zip
+S05W064.hgt.zip
+S05W065.hgt.zip
+S05W066.hgt.zip
+S05W067.hgt.zip
+S05W068.hgt.zip
+S05W069.hgt.zip
+S05W070.hgt.zip
+S05W071.hgt.zip
+S05W072.hgt.zip
+S05W073.hgt.zip
+S05W074.hgt.zip
+S05W075.hgt.zip
+S05W076.hgt.zip
+S05W077.hgt.zip
+S05W078.hgt.zip
+S05W079.hgt.zip
+S05W080.hgt.zip
+S05W081.hgt.zip
+S05W082.hgt.zip
+S06W036.hgt.zip
+S06W037.hgt.zip
+S06W038.hgt.zip
+S06W039.hgt.zip
+S06W040.hgt.zip
+S06W041.hgt.zip
+S06W042.hgt.zip
+S06W043.hgt.zip
+S06W044.hgt.zip
+S06W045.hgt.zip
+S06W046.hgt.zip
+S06W047.hgt.zip
+S06W048.hgt.zip
+S06W049.hgt.zip
+S06W050.hgt.zip
+S06W051.hgt.zip
+S06W052.hgt.zip
+S06W053.hgt.zip
+S06W054.hgt.zip
+S06W055.hgt.zip
+S06W056.hgt.zip
+S06W057.hgt.zip
+S06W058.hgt.zip
+S06W059.hgt.zip
+S06W060.hgt.zip
+S06W061.hgt.zip
+S06W062.hgt.zip
+S06W063.hgt.zip
+S06W064.hgt.zip
+S06W065.hgt.zip
+S06W066.hgt.zip
+S06W067.hgt.zip
+S06W068.hgt.zip
+S06W069.hgt.zip
+S06W070.hgt.zip
+S06W071.hgt.zip
+S06W072.hgt.zip
+S06W073.hgt.zip
+S06W074.hgt.zip
+S06W075.hgt.zip
+S06W076.hgt.zip
+S06W077.hgt.zip
+S06W078.hgt.zip
+S06W079.hgt.zip
+S06W080.hgt.zip
+S06W081.hgt.zip
+S06W082.hgt.zip
+S07W035.hgt.zip
+S07W036.hgt.zip
+S07W037.hgt.zip
+S07W038.hgt.zip
+S07W039.hgt.zip
+S07W040.hgt.zip
+S07W041.hgt.zip
+S07W042.hgt.zip
+S07W043.hgt.zip
+S07W044.hgt.zip
+S07W045.hgt.zip
+S07W046.hgt.zip
+S07W047.hgt.zip
+S07W048.hgt.zip
+S07W049.hgt.zip
+S07W050.hgt.zip
+S07W051.hgt.zip
+S07W052.hgt.zip
+S07W053.hgt.zip
+S07W054.hgt.zip
+S07W055.hgt.zip
+S07W056.hgt.zip
+S07W057.hgt.zip
+S07W058.hgt.zip
+S07W059.hgt.zip
+S07W060.hgt.zip
+S07W061.hgt.zip
+S07W062.hgt.zip
+S07W063.hgt.zip
+S07W064.hgt.zip
+S07W065.hgt.zip
+S07W066.hgt.zip
+S07W067.hgt.zip
+S07W068.hgt.zip
+S07W069.hgt.zip
+S07W070.hgt.zip
+S07W071.hgt.zip
+S07W072.hgt.zip
+S07W073.hgt.zip
+S07W074.hgt.zip
+S07W075.hgt.zip
+S07W076.hgt.zip
+S07W077.hgt.zip
+S07W078.hgt.zip
+S07W079.hgt.zip
+S07W080.hgt.zip
+S07W081.hgt.zip
+S07W082.hgt.zip
+S08W035.hgt.zip
+S08W036.hgt.zip
+S08W037.hgt.zip
+S08W038.hgt.zip
+S08W039.hgt.zip
+S08W040.hgt.zip
+S08W041.hgt.zip
+S08W042.hgt.zip
+S08W043.hgt.zip
+S08W044.hgt.zip
+S08W045.hgt.zip
+S08W046.hgt.zip
+S08W047.hgt.zip
+S08W048.hgt.zip
+S08W049.hgt.zip
+S08W050.hgt.zip
+S08W051.hgt.zip
+S08W052.hgt.zip
+S08W053.hgt.zip
+S08W054.hgt.zip
+S08W055.hgt.zip
+S08W056.hgt.zip
+S08W057.hgt.zip
+S08W058.hgt.zip
+S08W059.hgt.zip
+S08W060.hgt.zip
+S08W061.hgt.zip
+S08W062.hgt.zip
+S08W063.hgt.zip
+S08W064.hgt.zip
+S08W065.hgt.zip
+S08W066.hgt.zip
+S08W067.hgt.zip
+S08W068.hgt.zip
+S08W069.hgt.zip
+S08W070.hgt.zip
+S08W071.hgt.zip
+S08W072.hgt.zip
+S08W073.hgt.zip
+S08W074.hgt.zip
+S08W075.hgt.zip
+S08W076.hgt.zip
+S08W077.hgt.zip
+S08W078.hgt.zip
+S08W079.hgt.zip
+S08W080.hgt.zip
+S09W035.hgt.zip
+S09W036.hgt.zip
+S09W037.hgt.zip
+S09W038.hgt.zip
+S09W039.hgt.zip
+S09W040.hgt.zip
+S09W041.hgt.zip
+S09W042.hgt.zip
+S09W043.hgt.zip
+S09W044.hgt.zip
+S09W045.hgt.zip
+S09W046.hgt.zip
+S09W047.hgt.zip
+S09W048.hgt.zip
+S09W049.hgt.zip
+S09W050.hgt.zip
+S09W051.hgt.zip
+S09W052.hgt.zip
+S09W053.hgt.zip
+S09W054.hgt.zip
+S09W055.hgt.zip
+S09W056.hgt.zip
+S09W057.hgt.zip
+S09W058.hgt.zip
+S09W059.hgt.zip
+S09W060.hgt.zip
+S09W061.hgt.zip
+S09W062.hgt.zip
+S09W063.hgt.zip
+S09W064.hgt.zip
+S09W065.hgt.zip
+S09W066.hgt.zip
+S09W067.hgt.zip
+S09W068.hgt.zip
+S09W069.hgt.zip
+S09W070.hgt.zip
+S09W071.hgt.zip
+S09W072.hgt.zip
+S09W073.hgt.zip
+S09W074.hgt.zip
+S09W075.hgt.zip
+S09W076.hgt.zip
+S09W077.hgt.zip
+S09W078.hgt.zip
+S09W079.hgt.zip
+S09W080.hgt.zip
+S10W036.hgt.zip
+S10W037.hgt.zip
+S10W038.hgt.zip
+S10W039.hgt.zip
+S10W040.hgt.zip
+S10W041.hgt.zip
+S10W042.hgt.zip
+S10W043.hgt.zip
+S10W044.hgt.zip
+S10W045.hgt.zip
+S10W046.hgt.zip
+S10W047.hgt.zip
+S10W048.hgt.zip
+S10W049.hgt.zip
+S10W050.hgt.zip
+S10W051.hgt.zip
+S10W052.hgt.zip
+S10W053.hgt.zip
+S10W054.hgt.zip
+S10W055.hgt.zip
+S10W056.hgt.zip
+S10W057.hgt.zip
+S10W058.hgt.zip
+S10W059.hgt.zip
+S10W060.hgt.zip
+S10W061.hgt.zip
+S10W062.hgt.zip
+S10W063.hgt.zip
+S10W064.hgt.zip
+S10W065.hgt.zip
+S10W066.hgt.zip
+S10W067.hgt.zip
+S10W068.hgt.zip
+S10W069.hgt.zip
+S10W070.hgt.zip
+S10W071.hgt.zip
+S10W072.hgt.zip
+S10W073.hgt.zip
+S10W074.hgt.zip
+S10W075.hgt.zip
+S10W076.hgt.zip
+S10W077.hgt.zip
+S10W078.hgt.zip
+S10W079.hgt.zip
+S11W037.hgt.zip
+S11W038.hgt.zip
+S11W039.hgt.zip
+S11W040.hgt.zip
+S11W041.hgt.zip
+S11W042.hgt.zip
+S11W043.hgt.zip
+S11W044.hgt.zip
+S11W045.hgt.zip
+S11W046.hgt.zip
+S11W047.hgt.zip
+S11W048.hgt.zip
+S11W049.hgt.zip
+S11W050.hgt.zip
+S11W051.hgt.zip
+S11W052.hgt.zip
+S11W053.hgt.zip
+S11W054.hgt.zip
+S11W055.hgt.zip
+S11W056.hgt.zip
+S11W057.hgt.zip
+S11W058.hgt.zip
+S11W059.hgt.zip
+S11W060.hgt.zip
+S11W061.hgt.zip
+S11W062.hgt.zip
+S11W063.hgt.zip
+S11W064.hgt.zip
+S11W065.hgt.zip
+S11W066.hgt.zip
+S11W067.hgt.zip
+S11W068.hgt.zip
+S11W069.hgt.zip
+S11W070.hgt.zip
+S11W071.hgt.zip
+S11W072.hgt.zip
+S11W073.hgt.zip
+S11W074.hgt.zip
+S11W075.hgt.zip
+S11W076.hgt.zip
+S11W077.hgt.zip
+S11W078.hgt.zip
+S11W079.hgt.zip
+S12W038.hgt.zip
+S12W039.hgt.zip
+S12W040.hgt.zip
+S12W041.hgt.zip
+S12W042.hgt.zip
+S12W043.hgt.zip
+S12W044.hgt.zip
+S12W045.hgt.zip
+S12W046.hgt.zip
+S12W047.hgt.zip
+S12W048.hgt.zip
+S12W049.hgt.zip
+S12W050.hgt.zip
+S12W051.hgt.zip
+S12W052.hgt.zip
+S12W053.hgt.zip
+S12W054.hgt.zip
+S12W055.hgt.zip
+S12W056.hgt.zip
+S12W057.hgt.zip
+S12W058.hgt.zip
+S12W059.hgt.zip
+S12W060.hgt.zip
+S12W061.hgt.zip
+S12W062.hgt.zip
+S12W063.hgt.zip
+S12W064.hgt.zip
+S12W065.hgt.zip
+S12W066.hgt.zip
+S12W067.hgt.zip
+S12W068.hgt.zip
+S12W069.hgt.zip
+S12W070.hgt.zip
+S12W071.hgt.zip
+S12W072.hgt.zip
+S12W073.hgt.zip
+S12W074.hgt.zip
+S12W075.hgt.zip
+S12W076.hgt.zip
+S12W077.hgt.zip
+S12W078.hgt.zip
+S13W038.hgt.zip
+S13W039.hgt.zip
+S13W040.hgt.zip
+S13W041.hgt.zip
+S13W042.hgt.zip
+S13W043.hgt.zip
+S13W044.hgt.zip
+S13W045.hgt.zip
+S13W046.hgt.zip
+S13W047.hgt.zip
+S13W048.hgt.zip
+S13W049.hgt.zip
+S13W050.hgt.zip
+S13W051.hgt.zip
+S13W052.hgt.zip
+S13W053.hgt.zip
+S13W054.hgt.zip
+S13W055.hgt.zip
+S13W056.hgt.zip
+S13W057.hgt.zip
+S13W058.hgt.zip
+S13W059.hgt.zip
+S13W060.hgt.zip
+S13W061.hgt.zip
+S13W062.hgt.zip
+S13W063.hgt.zip
+S13W064.hgt.zip
+S13W065.hgt.zip
+S13W066.hgt.zip
+S13W067.hgt.zip
+S13W068.hgt.zip
+S13W069.hgt.zip
+S13W070.hgt.zip
+S13W071.hgt.zip
+S13W072.hgt.zip
+S13W073.hgt.zip
+S13W074.hgt.zip
+S13W075.hgt.zip
+S13W076.hgt.zip
+S13W077.hgt.zip
+S13W078.hgt.zip
+S14W039.hgt.zip
+S14W040.hgt.zip
+S14W041.hgt.zip
+S14W042.hgt.zip
+S14W043.hgt.zip
+S14W044.hgt.zip
+S14W045.hgt.zip
+S14W046.hgt.zip
+S14W047.hgt.zip
+S14W048.hgt.zip
+S14W049.hgt.zip
+S14W050.hgt.zip
+S14W051.hgt.zip
+S14W052.hgt.zip
+S14W053.hgt.zip
+S14W054.hgt.zip
+S14W055.hgt.zip
+S14W056.hgt.zip
+S14W057.hgt.zip
+S14W058.hgt.zip
+S14W059.hgt.zip
+S14W060.hgt.zip
+S14W061.hgt.zip
+S14W062.hgt.zip
+S14W063.hgt.zip
+S14W064.hgt.zip
+S14W065.hgt.zip
+S14W066.hgt.zip
+S14W067.hgt.zip
+S14W068.hgt.zip
+S14W069.hgt.zip
+S14W070.hgt.zip
+S14W071.hgt.zip
+S14W072.hgt.zip
+S14W073.hgt.zip
+S14W074.hgt.zip
+S14W075.hgt.zip
+S14W076.hgt.zip
+S14W077.hgt.zip
+S15W039.hgt.zip
+S15W040.hgt.zip
+S15W041.hgt.zip
+S15W042.hgt.zip
+S15W043.hgt.zip
+S15W044.hgt.zip
+S15W045.hgt.zip
+S15W046.hgt.zip
+S15W047.hgt.zip
+S15W048.hgt.zip
+S15W049.hgt.zip
+S15W050.hgt.zip
+S15W051.hgt.zip
+S15W052.hgt.zip
+S15W053.hgt.zip
+S15W054.hgt.zip
+S15W055.hgt.zip
+S15W056.hgt.zip
+S15W057.hgt.zip
+S15W058.hgt.zip
+S15W059.hgt.zip
+S15W060.hgt.zip
+S15W061.hgt.zip
+S15W062.hgt.zip
+S15W063.hgt.zip
+S15W064.hgt.zip
+S15W065.hgt.zip
+S15W066.hgt.zip
+S15W067.hgt.zip
+S15W068.hgt.zip
+S15W069.hgt.zip
+S15W070.hgt.zip
+S15W071.hgt.zip
+S15W072.hgt.zip
+S15W073.hgt.zip
+S15W074.hgt.zip
+S15W075.hgt.zip
+S15W076.hgt.zip
+S15W077.hgt.zip
+S16W039.hgt.zip
+S16W040.hgt.zip
+S16W041.hgt.zip
+S16W042.hgt.zip
+S16W043.hgt.zip
+S16W044.hgt.zip
+S16W045.hgt.zip
+S16W046.hgt.zip
+S16W047.hgt.zip
+S16W048.hgt.zip
+S16W049.hgt.zip
+S16W050.hgt.zip
+S16W051.hgt.zip
+S16W052.hgt.zip
+S16W053.hgt.zip
+S16W054.hgt.zip
+S16W055.hgt.zip
+S16W056.hgt.zip
+S16W057.hgt.zip
+S16W058.hgt.zip
+S16W059.hgt.zip
+S16W060.hgt.zip
+S16W061.hgt.zip
+S16W062.hgt.zip
+S16W063.hgt.zip
+S16W064.hgt.zip
+S16W065.hgt.zip
+S16W066.hgt.zip
+S16W067.hgt.zip
+S16W068.hgt.zip
+S16W069.hgt.zip
+S16W070.hgt.zip
+S16W071.hgt.zip
+S16W072.hgt.zip
+S16W073.hgt.zip
+S16W074.hgt.zip
+S16W075.hgt.zip
+S16W076.hgt.zip
+S17W039.hgt.zip
+S17W040.hgt.zip
+S17W041.hgt.zip
+S17W042.hgt.zip
+S17W043.hgt.zip
+S17W044.hgt.zip
+S17W045.hgt.zip
+S17W046.hgt.zip
+S17W047.hgt.zip
+S17W048.hgt.zip
+S17W049.hgt.zip
+S17W050.hgt.zip
+S17W051.hgt.zip
+S17W052.hgt.zip
+S17W053.hgt.zip
+S17W054.hgt.zip
+S17W055.hgt.zip
+S17W056.hgt.zip
+S17W057.hgt.zip
+S17W058.hgt.zip
+S17W059.hgt.zip
+S17W060.hgt.zip
+S17W061.hgt.zip
+S17W062.hgt.zip
+S17W063.hgt.zip
+S17W064.hgt.zip
+S17W065.hgt.zip
+S17W066.hgt.zip
+S17W067.hgt.zip
+S17W068.hgt.zip
+S17W069.hgt.zip
+S17W070.hgt.zip
+S17W071.hgt.zip
+S17W072.hgt.zip
+S17W073.hgt.zip
+S17W074.hgt.zip
+S17W075.hgt.zip
+S18W039.hgt.zip
+S18W040.hgt.zip
+S18W041.hgt.zip
+S18W042.hgt.zip
+S18W043.hgt.zip
+S18W044.hgt.zip
+S18W045.hgt.zip
+S18W046.hgt.zip
+S18W047.hgt.zip
+S18W048.hgt.zip
+S18W049.hgt.zip
+S18W050.hgt.zip
+S18W051.hgt.zip
+S18W052.hgt.zip
+S18W053.hgt.zip
+S18W054.hgt.zip
+S18W055.hgt.zip
+S18W056.hgt.zip
+S18W057.hgt.zip
+S18W058.hgt.zip
+S18W059.hgt.zip
+S18W060.hgt.zip
+S18W061.hgt.zip
+S18W062.hgt.zip
+S18W063.hgt.zip
+S18W064.hgt.zip
+S18W065.hgt.zip
+S18W066.hgt.zip
+S18W067.hgt.zip
+S18W068.hgt.zip
+S18W069.hgt.zip
+S18W070.hgt.zip
+S18W071.hgt.zip
+S18W072.hgt.zip
+S18W073.hgt.zip
+S19W040.hgt.zip
+S19W041.hgt.zip
+S19W042.hgt.zip
+S19W043.hgt.zip
+S19W044.hgt.zip
+S19W045.hgt.zip
+S19W046.hgt.zip
+S19W047.hgt.zip
+S19W048.hgt.zip
+S19W049.hgt.zip
+S19W050.hgt.zip
+S19W051.hgt.zip
+S19W052.hgt.zip
+S19W053.hgt.zip
+S19W054.hgt.zip
+S19W055.hgt.zip
+S19W056.hgt.zip
+S19W057.hgt.zip
+S19W058.hgt.zip
+S19W059.hgt.zip
+S19W060.hgt.zip
+S19W061.hgt.zip
+S19W062.hgt.zip
+S19W063.hgt.zip
+S19W064.hgt.zip
+S19W065.hgt.zip
+S19W066.hgt.zip
+S19W067.hgt.zip
+S19W068.hgt.zip
+S19W069.hgt.zip
+S19W070.hgt.zip
+S19W071.hgt.zip
+S20W040.hgt.zip
+S20W041.hgt.zip
+S20W042.hgt.zip
+S20W043.hgt.zip
+S20W044.hgt.zip
+S20W045.hgt.zip
+S20W046.hgt.zip
+S20W047.hgt.zip
+S20W048.hgt.zip
+S20W049.hgt.zip
+S20W050.hgt.zip
+S20W051.hgt.zip
+S20W052.hgt.zip
+S20W053.hgt.zip
+S20W054.hgt.zip
+S20W055.hgt.zip
+S20W056.hgt.zip
+S20W057.hgt.zip
+S20W058.hgt.zip
+S20W059.hgt.zip
+S20W060.hgt.zip
+S20W061.hgt.zip
+S20W062.hgt.zip
+S20W063.hgt.zip
+S20W064.hgt.zip
+S20W065.hgt.zip
+S20W066.hgt.zip
+S20W067.hgt.zip
+S20W068.hgt.zip
+S20W069.hgt.zip
+S20W070.hgt.zip
+S20W071.hgt.zip
+S21W041.hgt.zip
+S21W042.hgt.zip
+S21W043.hgt.zip
+S21W044.hgt.zip
+S21W045.hgt.zip
+S21W046.hgt.zip
+S21W047.hgt.zip
+S21W048.hgt.zip
+S21W049.hgt.zip
+S21W050.hgt.zip
+S21W051.hgt.zip
+S21W052.hgt.zip
+S21W053.hgt.zip
+S21W054.hgt.zip
+S21W055.hgt.zip
+S21W056.hgt.zip
+S21W057.hgt.zip
+S21W058.hgt.zip
+S21W059.hgt.zip
+S21W060.hgt.zip
+S21W061.hgt.zip
+S21W062.hgt.zip
+S21W063.hgt.zip
+S21W064.hgt.zip
+S21W065.hgt.zip
+S21W066.hgt.zip
+S21W067.hgt.zip
+S21W068.hgt.zip
+S21W069.hgt.zip
+S21W070.hgt.zip
+S21W071.hgt.zip
+S22W041.hgt.zip
+S22W042.hgt.zip
+S22W043.hgt.zip
+S22W044.hgt.zip
+S22W045.hgt.zip
+S22W046.hgt.zip
+S22W047.hgt.zip
+S22W048.hgt.zip
+S22W049.hgt.zip
+S22W050.hgt.zip
+S22W051.hgt.zip
+S22W052.hgt.zip
+S22W053.hgt.zip
+S22W054.hgt.zip
+S22W055.hgt.zip
+S22W056.hgt.zip
+S22W057.hgt.zip
+S22W058.hgt.zip
+S22W059.hgt.zip
+S22W060.hgt.zip
+S22W061.hgt.zip
+S22W062.hgt.zip
+S22W063.hgt.zip
+S22W064.hgt.zip
+S22W065.hgt.zip
+S22W066.hgt.zip
+S22W067.hgt.zip
+S22W068.hgt.zip
+S22W069.hgt.zip
+S22W070.hgt.zip
+S22W071.hgt.zip
+S23W041.hgt.zip
+S23W042.hgt.zip
+S23W043.hgt.zip
+S23W044.hgt.zip
+S23W045.hgt.zip
+S23W046.hgt.zip
+S23W047.hgt.zip
+S23W048.hgt.zip
+S23W049.hgt.zip
+S23W050.hgt.zip
+S23W051.hgt.zip
+S23W052.hgt.zip
+S23W053.hgt.zip
+S23W054.hgt.zip
+S23W055.hgt.zip
+S23W056.hgt.zip
+S23W057.hgt.zip
+S23W058.hgt.zip
+S23W059.hgt.zip
+S23W060.hgt.zip
+S23W061.hgt.zip
+S23W062.hgt.zip
+S23W063.hgt.zip
+S23W064.hgt.zip
+S23W065.hgt.zip
+S23W066.hgt.zip
+S23W067.hgt.zip
+S23W068.hgt.zip
+S23W069.hgt.zip
+S23W070.hgt.zip
+S23W071.hgt.zip
+S24W042.hgt.zip
+S24W043.hgt.zip
+S24W044.hgt.zip
+S24W045.hgt.zip
+S24W046.hgt.zip
+S24W047.hgt.zip
+S24W048.hgt.zip
+S24W049.hgt.zip
+S24W050.hgt.zip
+S24W051.hgt.zip
+S24W052.hgt.zip
+S24W053.hgt.zip
+S24W054.hgt.zip
+S24W055.hgt.zip
+S24W056.hgt.zip
+S24W057.hgt.zip
+S24W058.hgt.zip
+S24W059.hgt.zip
+S24W060.hgt.zip
+S24W061.hgt.zip
+S24W062.hgt.zip
+S24W063.hgt.zip
+S24W064.hgt.zip
+S24W065.hgt.zip
+S24W066.hgt.zip
+S24W067.hgt.zip
+S24W068.hgt.zip
+S24W069.hgt.zip
+S24W070.hgt.zip
+S24W071.hgt.zip
+S25W046.hgt.zip
+S25W047.hgt.zip
+S25W048.hgt.zip
+S25W049.hgt.zip
+S25W050.hgt.zip
+S25W051.hgt.zip
+S25W052.hgt.zip
+S25W053.hgt.zip
+S25W054.hgt.zip
+S25W055.hgt.zip
+S25W056.hgt.zip
+S25W057.hgt.zip
+S25W058.hgt.zip
+S25W059.hgt.zip
+S25W060.hgt.zip
+S25W061.hgt.zip
+S25W062.hgt.zip
+S25W063.hgt.zip
+S25W064.hgt.zip
+S25W065.hgt.zip
+S25W066.hgt.zip
+S25W067.hgt.zip
+S25W068.hgt.zip
+S25W069.hgt.zip
+S25W070.hgt.zip
+S25W071.hgt.zip
+S26W048.hgt.zip
+S26W049.hgt.zip
+S26W050.hgt.zip
+S26W051.hgt.zip
+S26W052.hgt.zip
+S26W053.hgt.zip
+S26W054.hgt.zip
+S26W055.hgt.zip
+S26W056.hgt.zip
+S26W057.hgt.zip
+S26W058.hgt.zip
+S26W059.hgt.zip
+S26W060.hgt.zip
+S26W061.hgt.zip
+S26W062.hgt.zip
+S26W063.hgt.zip
+S26W064.hgt.zip
+S26W065.hgt.zip
+S26W066.hgt.zip
+S26W067.hgt.zip
+S26W068.hgt.zip
+S26W069.hgt.zip
+S26W070.hgt.zip
+S26W071.hgt.zip
+S27W049.hgt.zip
+S27W050.hgt.zip
+S27W051.hgt.zip
+S27W052.hgt.zip
+S27W053.hgt.zip
+S27W054.hgt.zip
+S27W055.hgt.zip
+S27W056.hgt.zip
+S27W057.hgt.zip
+S27W058.hgt.zip
+S27W059.hgt.zip
+S27W060.hgt.zip
+S27W061.hgt.zip
+S27W062.hgt.zip
+S27W063.hgt.zip
+S27W064.hgt.zip
+S27W065.hgt.zip
+S27W066.hgt.zip
+S27W067.hgt.zip
+S27W068.hgt.zip
+S27W069.hgt.zip
+S27W070.hgt.zip
+S27W071.hgt.zip
+S27W080.hgt.zip
+S27W081.hgt.zip
+S28W049.hgt.zip
+S28W050.hgt.zip
+S28W051.hgt.zip
+S28W052.hgt.zip
+S28W053.hgt.zip
+S28W054.hgt.zip
+S28W055.hgt.zip
+S28W056.hgt.zip
+S28W057.hgt.zip
+S28W058.hgt.zip
+S28W059.hgt.zip
+S28W060.hgt.zip
+S28W061.hgt.zip
+S28W062.hgt.zip
+S28W063.hgt.zip
+S28W064.hgt.zip
+S28W065.hgt.zip
+S28W066.hgt.zip
+S28W067.hgt.zip
+S28W068.hgt.zip
+S28W069.hgt.zip
+S28W070.hgt.zip
+S28W071.hgt.zip
+S28W072.hgt.zip
+S29W049.hgt.zip
+S29W050.hgt.zip
+S29W051.hgt.zip
+S29W052.hgt.zip
+S29W053.hgt.zip
+S29W054.hgt.zip
+S29W055.hgt.zip
+S29W056.hgt.zip
+S29W057.hgt.zip
+S29W058.hgt.zip
+S29W059.hgt.zip
+S29W060.hgt.zip
+S29W061.hgt.zip
+S29W062.hgt.zip
+S29W063.hgt.zip
+S29W064.hgt.zip
+S29W065.hgt.zip
+S29W066.hgt.zip
+S29W067.hgt.zip
+S29W068.hgt.zip
+S29W069.hgt.zip
+S29W070.hgt.zip
+S29W071.hgt.zip
+S29W072.hgt.zip
+S30W050.hgt.zip
+S30W051.hgt.zip
+S30W052.hgt.zip
+S30W053.hgt.zip
+S30W054.hgt.zip
+S30W055.hgt.zip
+S30W056.hgt.zip
+S30W057.hgt.zip
+S30W058.hgt.zip
+S30W059.hgt.zip
+S30W060.hgt.zip
+S30W061.hgt.zip
+S30W062.hgt.zip
+S30W063.hgt.zip
+S30W064.hgt.zip
+S30W065.hgt.zip
+S30W066.hgt.zip
+S30W067.hgt.zip
+S30W068.hgt.zip
+S30W069.hgt.zip
+S30W070.hgt.zip
+S30W071.hgt.zip
+S30W072.hgt.zip
+S31W051.hgt.zip
+S31W052.hgt.zip
+S31W053.hgt.zip
+S31W054.hgt.zip
+S31W055.hgt.zip
+S31W056.hgt.zip
+S31W057.hgt.zip
+S31W058.hgt.zip
+S31W059.hgt.zip
+S31W060.hgt.zip
+S31W061.hgt.zip
+S31W062.hgt.zip
+S31W063.hgt.zip
+S31W064.hgt.zip
+S31W065.hgt.zip
+S31W066.hgt.zip
+S31W067.hgt.zip
+S31W068.hgt.zip
+S31W069.hgt.zip
+S31W070.hgt.zip
+S31W071.hgt.zip
+S31W072.hgt.zip
+S32W051.hgt.zip
+S32W052.hgt.zip
+S32W053.hgt.zip
+S32W054.hgt.zip
+S32W055.hgt.zip
+S32W056.hgt.zip
+S32W057.hgt.zip
+S32W058.hgt.zip
+S32W059.hgt.zip
+S32W060.hgt.zip
+S32W061.hgt.zip
+S32W062.hgt.zip
+S32W063.hgt.zip
+S32W064.hgt.zip
+S32W065.hgt.zip
+S32W066.hgt.zip
+S32W067.hgt.zip
+S32W068.hgt.zip
+S32W069.hgt.zip
+S32W070.hgt.zip
+S32W071.hgt.zip
+S32W072.hgt.zip
+S33W052.hgt.zip
+S33W053.hgt.zip
+S33W054.hgt.zip
+S33W055.hgt.zip
+S33W056.hgt.zip
+S33W057.hgt.zip
+S33W058.hgt.zip
+S33W059.hgt.zip
+S33W060.hgt.zip
+S33W061.hgt.zip
+S33W062.hgt.zip
+S33W063.hgt.zip
+S33W064.hgt.zip
+S33W065.hgt.zip
+S33W066.hgt.zip
+S33W067.hgt.zip
+S33W068.hgt.zip
+S33W069.hgt.zip
+S33W070.hgt.zip
+S33W071.hgt.zip
+S33W072.hgt.zip
+S34W053.hgt.zip
+S34W054.hgt.zip
+S34W055.hgt.zip
+S34W056.hgt.zip
+S34W057.hgt.zip
+S34W058.hgt.zip
+S34W059.hgt.zip
+S34W060.hgt.zip
+S34W061.hgt.zip
+S34W062.hgt.zip
+S34W063.hgt.zip
+S34W064.hgt.zip
+S34W065.hgt.zip
+S34W066.hgt.zip
+S34W067.hgt.zip
+S34W068.hgt.zip
+S34W069.hgt.zip
+S34W070.hgt.zip
+S34W071.hgt.zip
+S34W072.hgt.zip
+S34W079.hgt.zip
+S34W081.hgt.zip
+S35W054.hgt.zip
+S35W055.hgt.zip
+S35W056.hgt.zip
+S35W057.hgt.zip
+S35W058.hgt.zip
+S35W059.hgt.zip
+S35W060.hgt.zip
+S35W061.hgt.zip
+S35W062.hgt.zip
+S35W063.hgt.zip
+S35W064.hgt.zip
+S35W065.hgt.zip
+S35W066.hgt.zip
+S35W067.hgt.zip
+S35W068.hgt.zip
+S35W069.hgt.zip
+S35W070.hgt.zip
+S35W071.hgt.zip
+S35W072.hgt.zip
+S35W073.hgt.zip
+S36W058.hgt.zip
+S36W059.hgt.zip
+S36W060.hgt.zip
+S36W061.hgt.zip
+S36W062.hgt.zip
+S36W063.hgt.zip
+S36W064.hgt.zip
+S36W065.hgt.zip
+S36W066.hgt.zip
+S36W067.hgt.zip
+S36W068.hgt.zip
+S36W069.hgt.zip
+S36W070.hgt.zip
+S36W071.hgt.zip
+S36W072.hgt.zip
+S36W073.hgt.zip
+S37W057.hgt.zip
+S37W058.hgt.zip
+S37W059.hgt.zip
+S37W060.hgt.zip
+S37W061.hgt.zip
+S37W062.hgt.zip
+S37W063.hgt.zip
+S37W064.hgt.zip
+S37W065.hgt.zip
+S37W066.hgt.zip
+S37W067.hgt.zip
+S37W068.hgt.zip
+S37W069.hgt.zip
+S37W070.hgt.zip
+S37W071.hgt.zip
+S37W072.hgt.zip
+S37W073.hgt.zip
+S37W074.hgt.zip
+S38W057.hgt.zip
+S38W058.hgt.zip
+S38W059.hgt.zip
+S38W060.hgt.zip
+S38W061.hgt.zip
+S38W062.hgt.zip
+S38W063.hgt.zip
+S38W064.hgt.zip
+S38W065.hgt.zip
+S38W066.hgt.zip
+S38W067.hgt.zip
+S38W068.hgt.zip
+S38W069.hgt.zip
+S38W070.hgt.zip
+S38W071.hgt.zip
+S38W072.hgt.zip
+S38W073.hgt.zip
+S38W074.hgt.zip
+S39W058.hgt.zip
+S39W059.hgt.zip
+S39W060.hgt.zip
+S39W061.hgt.zip
+S39W062.hgt.zip
+S39W063.hgt.zip
+S39W064.hgt.zip
+S39W065.hgt.zip
+S39W066.hgt.zip
+S39W067.hgt.zip
+S39W068.hgt.zip
+S39W069.hgt.zip
+S39W070.hgt.zip
+S39W071.hgt.zip
+S39W072.hgt.zip
+S39W073.hgt.zip
+S39W074.hgt.zip
+S40W062.hgt.zip
+S40W063.hgt.zip
+S40W064.hgt.zip
+S40W065.hgt.zip
+S40W066.hgt.zip
+S40W067.hgt.zip
+S40W068.hgt.zip
+S40W069.hgt.zip
+S40W070.hgt.zip
+S40W071.hgt.zip
+S40W072.hgt.zip
+S40W073.hgt.zip
+S40W074.hgt.zip
+S41W063.hgt.zip
+S41W064.hgt.zip
+S41W065.hgt.zip
+S41W066.hgt.zip
+S41W067.hgt.zip
+S41W068.hgt.zip
+S41W069.hgt.zip
+S41W070.hgt.zip
+S41W071.hgt.zip
+S41W072.hgt.zip
+S41W073.hgt.zip
+S41W074.hgt.zip
+S42W063.hgt.zip
+S42W064.hgt.zip
+S42W065.hgt.zip
+S42W066.hgt.zip
+S42W067.hgt.zip
+S42W068.hgt.zip
+S42W069.hgt.zip
+S42W070.hgt.zip
+S42W071.hgt.zip
+S42W072.hgt.zip
+S42W073.hgt.zip
+S42W074.hgt.zip
+S42W075.hgt.zip
+S43W064.hgt.zip
+S43W065.hgt.zip
+S43W066.hgt.zip
+S43W067.hgt.zip
+S43W068.hgt.zip
+S43W069.hgt.zip
+S43W070.hgt.zip
+S43W071.hgt.zip
+S43W072.hgt.zip
+S43W073.hgt.zip
+S43W074.hgt.zip
+S43W075.hgt.zip
+S44W065.hgt.zip
+S44W066.hgt.zip
+S44W067.hgt.zip
+S44W068.hgt.zip
+S44W069.hgt.zip
+S44W070.hgt.zip
+S44W071.hgt.zip
+S44W072.hgt.zip
+S44W073.hgt.zip
+S44W074.hgt.zip
+S44W075.hgt.zip
+S45W066.hgt.zip
+S45W067.hgt.zip
+S45W068.hgt.zip
+S45W069.hgt.zip
+S45W070.hgt.zip
+S45W071.hgt.zip
+S45W072.hgt.zip
+S45W073.hgt.zip
+S45W074.hgt.zip
+S45W075.hgt.zip
+S45W076.hgt.zip
+S46W066.hgt.zip
+S46W067.hgt.zip
+S46W068.hgt.zip
+S46W069.hgt.zip
+S46W070.hgt.zip
+S46W071.hgt.zip
+S46W072.hgt.zip
+S46W073.hgt.zip
+S46W074.hgt.zip
+S46W075.hgt.zip
+S46W076.hgt.zip
+S47W067.hgt.zip
+S47W068.hgt.zip
+S47W069.hgt.zip
+S47W070.hgt.zip
+S47W071.hgt.zip
+S47W072.hgt.zip
+S47W073.hgt.zip
+S47W074.hgt.zip
+S47W075.hgt.zip
+S47W076.hgt.zip
+S48W066.hgt.zip
+S48W067.hgt.zip
+S48W068.hgt.zip
+S48W069.hgt.zip
+S48W070.hgt.zip
+S48W071.hgt.zip
+S48W072.hgt.zip
+S48W073.hgt.zip
+S48W074.hgt.zip
+S48W075.hgt.zip
+S48W076.hgt.zip
+S49W066.hgt.zip
+S49W067.hgt.zip
+S49W068.hgt.zip
+S49W069.hgt.zip
+S49W070.hgt.zip
+S49W071.hgt.zip
+S49W072.hgt.zip
+S49W073.hgt.zip
+S49W074.hgt.zip
+S49W075.hgt.zip
+S49W076.hgt.zip
+S50W068.hgt.zip
+S50W069.hgt.zip
+S50W070.hgt.zip
+S50W071.hgt.zip
+S50W072.hgt.zip
+S50W073.hgt.zip
+S50W074.hgt.zip
+S50W075.hgt.zip
+S50W076.hgt.zip
+S51W062.hgt.zip
+S51W068.hgt.zip
+S51W069.hgt.zip
+S51W070.hgt.zip
+S51W071.hgt.zip
+S51W072.hgt.zip
+S51W073.hgt.zip
+S51W074.hgt.zip
+S51W075.hgt.zip
+S51W076.hgt.zip
+S52W058.hgt.zip
+S52W059.hgt.zip
+S52W060.hgt.zip
+S52W061.hgt.zip
+S52W062.hgt.zip
+S52W069.hgt.zip
+S52W070.hgt.zip
+S52W071.hgt.zip
+S52W072.hgt.zip
+S52W073.hgt.zip
+S52W074.hgt.zip
+S52W075.hgt.zip
+S52W076.hgt.zip
+S53W059.hgt.zip
+S53W060.hgt.zip
+S53W061.hgt.zip
+S53W062.hgt.zip
+S53W069.hgt.zip
+S53W070.hgt.zip
+S53W071.hgt.zip
+S53W072.hgt.zip
+S53W073.hgt.zip
+S53W074.hgt.zip
+S53W075.hgt.zip
+S53W076.hgt.zip
+S54W068.hgt.zip
+S54W069.hgt.zip
+S54W070.hgt.zip
+S54W071.hgt.zip
+S54W072.hgt.zip
+S54W073.hgt.zip
+S54W074.hgt.zip
+S54W075.hgt.zip
+S55W064.hgt.zip
+S55W065.hgt.zip
+S55W066.hgt.zip
+S55W067.hgt.zip
+S55W068.hgt.zip
+S55W069.hgt.zip
+S55W070.hgt.zip
+S55W071.hgt.zip
+S55W072.hgt.zip
+S55W073.hgt.zip
+S55W074.hgt.zip
+S56W067.hgt.zip
+S56W068.hgt.zip
+S56W069.hgt.zip
+S56W070.hgt.zip
+S56W071.hgt.zip
+S56W072.hgt.zip
\ No newline at end of file
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/South_America_names.txt.zip b/core/src/main/resources/com/graphhopper/reader/dem/South_America_names.txt.zip
deleted file mode 100644
index d1db72dc34..0000000000
Binary files a/core/src/main/resources/com/graphhopper/reader/dem/South_America_names.txt.zip and /dev/null differ
diff --git a/core/src/main/resources/com/graphhopper/util/ar.txt b/core/src/main/resources/com/graphhopper/util/ar.txt
new file mode 100644
index 0000000000..561fee2dc3
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/ar.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=
+continue_onto=%1$s   
+turn_left= 
+turn_right= 
+turn_slight_left=  
+turn_slight_right=  
+turn_sharp_left=  
+turn_sharp_right=  
+turn_onto=%1$s  %1$s
+web.searchButton=
+web.fromHint=
+web.viaHint=
+web.toHint=
+web.moreButton=
+web.gpxExportButton=GPX 
+web.routeInfo=%1$s  %2$s
+web.locationsNotFound=     
+web.bike=
+web.racingbike= 
+web.mtb= 
+web.car=
+web.foot=
+web.staticlink= 
+web.motorcycle= 
+via= 
+finish=
+hourAbbr=
+dayAbbr=
+minAbbr=
+kmAbbr=
+mAbbr=
+miAbbr=
+ftAbbr=
+road=
+off_bike= 
+cycleway= 
+way=
+paved=
+unpaved= 
+stopover= %1$s
+roundaboutEnter= 
+roundaboutExit=       %1$s
+roundaboutExitOnto=       %1$s   %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/bg.txt b/core/src/main/resources/com/graphhopper/util/bg.txt
index d4dd0a473d..6051b86336 100644
--- a/core/src/main/resources/com/graphhopper/util/bg.txt
+++ b/core/src/main/resources/com/graphhopper/util/bg.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left= 
-sharp_right= 
-left=
-right=
-slight_left= 
-slight_right= 
 continue=
 continue_onto=  %1$s
-turn= %1$s
-turn_onto= %1$s  %2$s
+turn_left= 
+turn_right= 
+turn_slight_left=  
+turn_slight_right=  
+turn_sharp_left=  
+turn_sharp_right=  
+turn_onto=%1$s  %2$s
 web.searchButton=
 web.fromHint=
 web.viaHint=
@@ -24,6 +23,7 @@ web.mtb= 
 web.car=
 web.foot=
 web.staticlink= 
+web.motorcycle=
 via=
 finish= !
 hourAbbr=
@@ -40,5 +40,6 @@ way=
 paved=
 unpaved=
 stopover= %1$s
-roundaboutInstruction=      %1$s
-roundaboutInstructionWithDir=      %1$s   %2$s
+roundaboutEnter=   
+roundaboutExit=     %1$s
+roundaboutExitOnto=     %1$s  %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/ca.txt b/core/src/main/resources/com/graphhopper/util/ca.txt
index 5f74da7ad7..512ca12aa6 100644
--- a/core/src/main/resources/com/graphhopper/util/ca.txt
+++ b/core/src/main/resources/com/graphhopper/util/ca.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=just a l'esquerra
-sharp_right=just a la dreta
-left=a l'esquerra
-right=a la dreta
-slight_left=lleugerament a l'esquerra
-slight_right=lleugerament a la dreta
 continue=continua
 continue_onto=continua per %1$s
-turn=gira %1$s
-turn_onto=gira %1$s per %2$s
+turn_left=gira a l'esquerra
+turn_right=gira a la dreta
+turn_slight_left=gira lleugerament a l'esquerra
+turn_slight_right=gira lleugerament a la dreta
+turn_sharp_left=gira just a l'esquerra
+turn_sharp_right=gira just a la dreta
+turn_onto=%1$s per %2$s
 web.searchButton=Buscar
 web.fromHint=Des de
 web.viaHint=passant per
@@ -24,6 +23,7 @@ web.mtb=Bicicleta de montanya
 web.car=Cotxe
 web.foot=A peu
 web.staticlink=Enlla
+web.motorcycle=Motocicleta
 via=passant per
 finish=Has arribat !!
 hourAbbr=h
@@ -40,5 +40,6 @@ way=cam
 paved=pavimentat
 unpaved=sense pavimentar
 stopover=passant per %1$s
-roundaboutInstruction=Entra a la rotonda y agafa la %1$ sortida
-roundaboutInstructionWithDir=Entra a la rotonda y agafa la %1$s sortida direcci %2$s
+roundaboutEnter=Entra a la rotonda
+roundaboutExit=A la rotonda, agafa la %1$s sortida
+roundaboutExitOnto=A la rotonda, agafa la sortida %1$s cap a %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/cs_CZ.txt b/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
new file mode 100644
index 0000000000..623d688b84
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=pokraujte
+continue_onto=pokraujte na %1$s
+turn_left=odbote vlevo
+turn_right=odbote vpravo
+turn_slight_left=odbote mrn vpravo
+turn_slight_right=odbote mrn vpravo
+turn_sharp_left=odbote oste doleva
+turn_sharp_right=odbote oste doprava
+turn_onto=%1$s na %2$s
+web.searchButton=Vyhledat
+web.fromHint=Z
+web.viaHint=Pes 
+web.toHint=Do
+web.moreButton=vce
+web.gpxExportButton=Export do GPX
+web.routeInfo=%1$s bude trvat %2$s
+web.locationsNotFound=Navigovn nen dostupn. Pozice nenalezena v tto oblasti.
+web.bike=Kolo
+web.racingbike=Zvodn kolo
+web.mtb=Horsk kolo
+web.car=Automobil
+web.foot=Pky
+web.staticlink=nemnn odkaz
+web.motorcycle=Motocykl
+via=pes 
+finish=Cl!
+hourAbbr=h
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=silnice
+off_bike=sesednte z kola
+cycleway=cyklotrasa
+way=cesta
+paved=zpevnn
+unpaved=nezpevnn
+stopover=zastvka %1$s
+roundaboutEnter=Vjete na kruhov objezd
+roundaboutExit=Na kruhovm objezdu pouijte %1$s. vjezd
+roundaboutExitOnto=Na kruhovm objezdu pouijte %1$s. vjezd, smrem na %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/de_DE.txt b/core/src/main/resources/com/graphhopper/util/de_DE.txt
index d3d5bcce04..e778c5cc28 100644
--- a/core/src/main/resources/com/graphhopper/util/de_DE.txt
+++ b/core/src/main/resources/com/graphhopper/util/de_DE.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=scharf links
-sharp_right=scharf rechts
-left=links
-right=rechts
-slight_left=leicht links
-slight_right=leicht rechts
 continue=geradeaus
 continue_onto=geradeaus auf %1$s
-turn=%1$s abbiegen
-turn_onto=%1$s abbiegen auf %2$s
+turn_left=links abbiegen
+turn_right=rechts abbiegen
+turn_slight_left=leicht links abbiegen
+turn_slight_right=leicht rechts abbiegen
+turn_sharp_left=scharf links abbiegen
+turn_sharp_right=scharf rechts abbiegen
+turn_onto=%1$s auf %2$s
 web.searchButton=Suche
 web.fromHint=Von
 web.viaHint=ber
@@ -24,6 +23,7 @@ web.mtb=Mountainbike
 web.car=Auto
 web.foot=Zu Fu
 web.staticlink=Link
+web.motorcycle=Motorrad
 via=ber
 finish=Ziel erreicht!
 hourAbbr=h
@@ -40,5 +40,6 @@ way=Weg
 paved=befestigt
 unpaved=unbefestigt
 stopover=Zwischenziel %1$s
-roundaboutInstruction=In den Kreisverkehr einfahren und Ausfahrt %1$s nehmen
-roundaboutInstructionWithDir=In den Kreisverkehr einfahren und Ausfahrt %1$s in Richtung %2$s nehmen
+roundaboutEnter=In den Kreisverkehr einfahren
+roundaboutExit=Im Kreisverkehr Ausfahrt %1$s nehmen
+roundaboutExitOnto=Im Kreisverkehr Ausfahrt %1$s auf %2$s nehmen
diff --git a/core/src/main/resources/com/graphhopper/util/el.txt b/core/src/main/resources/com/graphhopper/util/el.txt
index bc4d623f03..b60ca9b5cd 100644
--- a/core/src/main/resources/com/graphhopper/util/el.txt
+++ b/core/src/main/resources/com/graphhopper/util/el.txt
@@ -1,21 +1,20 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left= 
-sharp_right= 
-left=
-right=
-slight_left= 
-slight_right= 
 continue=
 continue_onto=  %1$s
-turn= %1$s
-turn_onto= %1$s  %2$s
+turn_left= 
+turn_right= 
+turn_slight_left=  
+turn_slight_right=  
+turn_sharp_left=  
+turn_sharp_right=  
+turn_onto=%1$s  %2$s
 web.searchButton=
 web.fromHint=
-web.viaHint=
+web.viaHint=
 web.toHint=
 web.moreButton=
-web.gpxExportButton=GPX 
+web.gpxExportButton= GPX
 web.routeInfo=%1$s  %2$s
 web.locationsNotFound=    .      .
 web.bike=
@@ -24,6 +23,7 @@ web.mtb= 
 web.car=
 web.foot=
 web.staticlink= 
+web.motorcycle=
 via=
 finish=!
 hourAbbr=h
@@ -40,5 +40,6 @@ way=
 paved=
 unpaved=
 stopover=  %1$s
-roundaboutInstruction=        %1$s
-roundaboutInstructionWithDir=        %1$s   %2$s
+roundaboutEnter=   
+roundaboutExit=      %1$s
+roundaboutExitOnto=      %1$s  %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/en_US.txt b/core/src/main/resources/com/graphhopper/util/en_US.txt
index 73684cbc63..c886850443 100644
--- a/core/src/main/resources/com/graphhopper/util/en_US.txt
+++ b/core/src/main/resources/com/graphhopper/util/en_US.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=sharp left
-sharp_right=sharp right
-left=left
-right=right
-slight_left=slight left
-slight_right=slight right
 continue=continue
 continue_onto=continue onto %1$s
-turn=turn %1$s
-turn_onto=turn %1$s onto %2$s
+turn_left=turn left
+turn_right=turn right
+turn_slight_left=turn slight left
+turn_slight_right=turn slight right
+turn_sharp_left=turn sharp left
+turn_sharp_right=turn sharp right
+turn_onto=%1$s onto %2$s
 web.searchButton=Search
 web.fromHint=From
 web.viaHint=Via
@@ -24,6 +23,7 @@ web.mtb=Mountainbike
 web.car=Car
 web.foot=Foot
 web.staticlink=static link
+web.motorcycle=Motorcycle
 via=via
 finish=Finish!
 hourAbbr=h
@@ -40,5 +40,6 @@ way=way
 paved=paved
 unpaved=unpaved
 stopover=stopover %1$s
-roundaboutInstruction=Enter roundabout and use exit %1$s
-roundaboutInstructionWithDir=Enter roundabout and use exit %1$s in direction %2$s
+roundaboutEnter=Enter roundabout
+roundaboutExit=At roundabout, take exit %1$s
+roundaboutExitOnto=At roundabout, take exit %1$s onto %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/es.txt b/core/src/main/resources/com/graphhopper/util/es.txt
index b857400770..1ce8dc33b2 100644
--- a/core/src/main/resources/com/graphhopper/util/es.txt
+++ b/core/src/main/resources/com/graphhopper/util/es.txt
@@ -1,31 +1,31 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=justo a la izquierda
-sharp_right=justo a la derecha
-left=izquierda
-right=derecha
-slight_left=gire a la izquierda
-slight_right=gire a la derecha
 continue=contine
 continue_onto=contine por %1$s
-turn=gire %1$s
-turn_onto=gire %1$s por %2$s
+turn_left=gire a la izquierda
+turn_right=gire a la derecha
+turn_slight_left=gire leve a la izquierda
+turn_slight_right=gire leve a la derecha
+turn_sharp_left=gire fuerte a la izquierda
+turn_sharp_right=gire fuerte a la derecha
+turn_onto=%1$s por %2$s
 web.searchButton=Buscar
 web.fromHint=Desde
-web.viaHint=
-web.toHint=hasta
+web.viaHint=Pasando por
+web.toHint=Hasta
 web.moreButton=ms
-web.gpxExportButton=
+web.gpxExportButton=Exportar GPX
 web.routeInfo=%1$s tardar %2$s 
 web.locationsNotFound=No se ha encontrado la ruta. El destino no se encuentra en el rea.
 web.bike=Bicicleta
-web.racingbike=
-web.mtb=
+web.racingbike=Bicicleta de carrera
+web.mtb=Bicicleta de montaa
 web.car=Coche
-web.foot=A pi
-web.staticlink=
-via=
-finish=Objetivo logrado
+web.foot=A pie
+web.staticlink=enlace esttico
+web.motorcycle=Motocicleta
+via=pasando por
+finish=Fin del recorrido!
 hourAbbr=h
 dayAbbr=d
 minAbbr=min
@@ -33,12 +33,13 @@ kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-road=
-off_bike=
-cycleway=
-way=
-paved=
-unpaved=
-stopover=
-roundaboutInstruction=
-roundaboutInstructionWithDir=
+road=carretera
+off_bike=bjese de la bicicleta
+cycleway=Ciclova 
+way=camino
+paved=pavimentado
+unpaved=no pavimentado
+stopover=pasando por %1$s
+roundaboutEnter=Entre en la rotonda
+roundaboutExit=En la rotonda, tome la %1$s salida
+roundaboutExitOnto=En la rotonda, tome la %1$s salida hacia %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/fa.txt b/core/src/main/resources/com/graphhopper/util/fa.txt
new file mode 100644
index 0000000000..3c73dff23f
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/fa.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=  
+continue_onto= %1$s  
+turn_left=  
+turn_right=  
+turn_slight_left=   
+turn_slight_right=   
+turn_sharp_left=   
+turn_sharp_right=   
+turn_onto=  %1$s  %2$s
+web.searchButton=
+web.fromHint=
+web.viaHint= 
+web.toHint=
+web.moreButton=
+web.gpxExportButton=   GPX
+web.routeInfo=  %1$s   %2$s   
+web.locationsNotFound=  .     .
+web.bike=
+web.racingbike= 
+web.mtb= 
+web.car=
+web.foot=
+web.staticlink= 
+web.motorcycle=
+via= 
+finish=!
+hourAbbr=
+dayAbbr=
+minAbbr=
+kmAbbr=
+mAbbr=
+miAbbr=
+ftAbbr=
+road=
+off_bike=   
+cycleway= 
+way=
+paved=  
+unpaved=  
+stopover=  %1$s
+roundaboutEnter=   
+roundaboutExit=    %1$s   
+roundaboutExitOnto=    %1$s  %2$s   
diff --git a/core/src/main/resources/com/graphhopper/util/fi.txt b/core/src/main/resources/com/graphhopper/util/fi.txt
new file mode 100644
index 0000000000..b5d23f834a
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/fi.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=jatka
+continue_onto=jatka tielle %1$S
+turn_left=knny vasemmalle
+turn_right=knny oikealle
+turn_slight_left=knny loivasti vasemmalle
+turn_slight_right=knny loivasti oikealle
+turn_sharp_left=knny jyrksti vasemmalle
+turn_sharp_right=knny jyrksti oikealle
+turn_onto=%1$S tielle %2$S
+web.searchButton=Etsi
+web.fromHint=Lhtpaikka
+web.viaHint=Reittipiste
+web.toHint=Mrnp
+web.moreButton=lis
+web.gpxExportButton=GPX-tuonti
+web.routeInfo=%1$s kest %2$s
+web.locationsNotFound=Reittiohjeiden luonti eponnistui. Paikkaa ei lydy tlt alueelta.
+web.bike=Pyrll
+web.racingbike=Kilpapyrll
+web.mtb=Maastopyrll
+web.car=Autolla
+web.foot=Kvellen
+web.staticlink=
+web.motorcycle=Moottoripyrll
+via=kautta
+finish=Olet perill!
+hourAbbr=h
+dayAbbr=pv
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=tie
+off_bike=taluta pyr
+cycleway=pyrtie
+way=tie
+paved=pllystetty
+unpaved=pllystmtn
+stopover=%1$s. pyshdys
+roundaboutEnter=Aja liikenneympyrn
+roundaboutExit=Liikenneympyrst poistu %1$s. liittymst
+roundaboutExitOnto=Liikenneympyrst poistu %1$s. liittymst suuntaan %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/fil.txt b/core/src/main/resources/com/graphhopper/util/fil.txt
index c34bd37be7..31b7c554cd 100644
--- a/core/src/main/resources/com/graphhopper/util/fil.txt
+++ b/core/src/main/resources/com/graphhopper/util/fil.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=matalim kaliwa 
-sharp_right=matalim karapatan 
-left=kaliwa 
-right=karapatan 
-slight_left=bahagyang kaliwa
-slight_right=bahagyang kanan
 continue=tuwirn ang dan
 continue_onto=magpatuloy papunta sa %1$s
-turn=pagliko %1$s
-turn_onto=lumiko %1$s papunta sa %2$s
+turn_left=pagliko kaliwa
+turn_right=pagliko karapatan
+turn_slight_left=pagliko bahagyang kaliwa
+turn_slight_right=pagliko bahagyang kanan
+turn_sharp_left=pagliko matalim kaliwa
+turn_sharp_right=pagliko matalim karapatan
+turn_onto=%1$s papunta sa %2$s
 web.searchButton=Paghahanap
 web.fromHint=mula sa 
 web.viaHint=
@@ -23,8 +22,9 @@ web.racingbike=RacingBike
 web.mtb=MountainBike
 web.car=kotse
 web.foot=lumakad
-web.staticlink=
-via=
+web.staticlink=static link
+web.motorcycle=motorsiklo
+via=sa pamamagitan ng
 finish=Tapusin!
 hourAbbr=h
 dayAbbr=d
@@ -40,5 +40,6 @@ way=landas
 paved=aspaltado 
 unpaved=hindi aspaltado
 stopover=pamahingahan %1$s
-roundaboutInstruction=Lpasok rotonda at gamitin %1$s
-roundaboutInstructionWithDir=Epasok rotonda at gamitin %1$s direksyon %2$s
+roundaboutEnter=Lpasok Rotonda
+roundaboutExit=Sa rotonda, lumabas sa exit %1$s
+roundaboutExitOnto=Sa rotonda, lumabas sa exit papunta %1$s %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/fr.txt b/core/src/main/resources/com/graphhopper/util/fr.txt
index ff0fbb2614..7f77887d4f 100644
--- a/core/src/main/resources/com/graphhopper/util/fr.txt
+++ b/core/src/main/resources/com/graphhopper/util/fr.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=fort  gauche
-sharp_right=fort  droite
-left= gauche
-right= droite
-slight_left=lgrement  gauche
-slight_right=lgrement  droite
 continue=continuez
 continue_onto=continuez sur %1$s
-turn=tournez %1$s
-turn_onto=tournez %1$s sur %2$s
+turn_left=tournez  gauche
+turn_right=tournez  droite
+turn_slight_left=tournez lgrement  gauche
+turn_slight_right=tournez lgrement  droite
+turn_sharp_left=tournez fort  gauche
+turn_sharp_right=tournez fort  droite
+turn_onto=%1$s sur %2$s
 web.searchButton=Rechercher
 web.fromHint=De
 web.viaHint=via
@@ -24,6 +23,7 @@ web.mtb=VTT
 web.car=Voiture
 web.foot= pied
 web.staticlink=Lien
+web.motorcycle=Vlo
 via=via
 finish=Fini!
 hourAbbr=h
@@ -40,5 +40,6 @@ way=chemin
 paved=pav
 unpaved=non-pav
 stopover=escale %1$s
-roundaboutInstruction=empruntez le rond point et prenez la sortie %1$s
-roundaboutInstructionWithDir=empruntez le rond point et prenez la sortie %1$s, en direction de %2$s
+roundaboutEnter=Empruntez le rond-point
+roundaboutExit=Au rond-point, prennez la %1$s sortie
+roundaboutExitOnto=Au rond-point, prennez la %1$s sortie vers %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/gl.txt b/core/src/main/resources/com/graphhopper/util/gl.txt
index 4b93b10e45..d1e438d35f 100644
--- a/core/src/main/resources/com/graphhopper/util/gl.txt
+++ b/core/src/main/resources/com/graphhopper/util/gl.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=xusto  esquerda
-sharp_right=xusto  dereita
-left=esquerda
-right=dereita
-slight_left=vire  esquerda
-slight_right=vire  dereita
 continue=contine
 continue_onto=contine por %1$s
-turn=vire por %1$s
-turn_onto=vire %1$s por %2$s
+turn_left=vire por esquerda
+turn_right=vire por dereita
+turn_slight_left=vire  esquerda
+turn_slight_right=vire  dereita
+turn_sharp_left=vire por xusto  esquerda
+turn_sharp_right=vire por xusto  dereita
+turn_onto=%1$s por %2$s
 web.searchButton=buscar
 web.fromHint=dende
 web.viaHint=Va
@@ -24,6 +23,7 @@ web.mtb=Bicicleta de montaa
 web.car=autombil
 web.foot=A p
 web.staticlink=Enlace
+web.motorcycle=Motocicleta
 via=va
 finish=Obxectivo acadado
 hourAbbr=h
@@ -40,5 +40,6 @@ way=va
 paved=asfaltada
 unpaved=non pavimentada
 stopover=escala%1$s
-roundaboutInstruction= Entre na rotonda e tome a sada %1$s
-roundaboutInstructionWithDir=Entre na rotonda e tome a sada %1$s en direccin%2$s
+roundaboutEnter=Entre na rotonda
+roundaboutExit=Na rotonda tome a sada %1$s
+roundaboutExitOnto=Na rotonda, tome a sada %1$s cara %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/he.txt b/core/src/main/resources/com/graphhopper/util/he.txt
index 3ec68f2fde..963ba6a920 100644
--- a/core/src/main/resources/com/graphhopper/util/he.txt
+++ b/core/src/main/resources/com/graphhopper/util/he.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left= 
-sharp_right= 
-left=
-right=
-slight_left= 
-slight_right= 
 continue=
 continue_onto=  %1$s
-turn=  %1$s
-turn_onto=  %1$s  %2$s
+turn_left=
+turn_right=
+turn_slight_left= 
+turn_slight_right= 
+turn_sharp_left= 
+turn_sharp_right= 
+turn_onto=  %1$s  %2$s
 web.searchButton=
 web.fromHint=
 web.viaHint=
@@ -24,6 +23,7 @@ web.mtb= 
 web.car=
 web.foot=
 web.staticlink= 
+web.motorcycle=
 via=
 finish=!
 hourAbbr=
@@ -40,5 +40,6 @@ way=
 paved=
 unpaved= 
 stopover=   %1$s
-roundaboutInstruction=      %1$s
-roundaboutInstructionWithDir=      %1$s  %2$s
+roundaboutEnter=  
+roundaboutExit=,    %1$s
+roundaboutExitOnto=,    %1$s  %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/hsb.txt b/core/src/main/resources/com/graphhopper/util/hsb.txt
new file mode 100644
index 0000000000..eb762719a5
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/hsb.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=runjewon
+continue_onto=runjewon na %1$s
+turn_left=nalwo wotboi
+turn_right=naprawo wotboi
+turn_slight_left=zlochka nalwo wotboi
+turn_slight_right=zlochka naprawo wotboi
+turn_sharp_left=wtrje nalwo wotboi
+turn_sharp_right=wtrje naprawo wotboi
+turn_onto=%1$s na %2$s
+web.searchButton=pytaj
+web.fromHint=wot
+web.viaHint=pez
+web.toHint=do
+web.moreButton=wjac
+web.gpxExportButton=eksport do GPX
+web.routeInfo=za %1$s so trjeba %2$s
+web.locationsNotFound=ara njeje mna. Mstno so w tutej kninje njenamaka.
+web.bike=koleso
+web.racingbike=wubdowanske koleso
+web.mtb=mountainbike
+web.car=awto
+web.foot=pi
+web.staticlink=link
+web.motorcycle=motorske
+via=via
+finish=doj
+hourAbbr=hod.
+dayAbbr=dny
+minAbbr=mje
+kmAbbr=km
+mAbbr=m
+miAbbr=mile
+ftAbbr=ft
+road=drha
+off_bike=ie
+cycleway=kolesowarski pu
+way=pu
+paved=pitwjerdeny
+unpaved=njepitwjerdeny
+stopover=mjezycil %1$s
+roundaboutEnter=do kruneho wobchada zaj
+roundaboutExit=we krunym wobchade %1$s. wujzd wza
+roundaboutExitOnto=we krunym wobchade %1$s. wujzd na %2$s wza
diff --git a/core/src/main/resources/com/graphhopper/util/hu_HU.txt b/core/src/main/resources/com/graphhopper/util/hu_HU.txt
new file mode 100644
index 0000000000..f3da8f8616
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/hu_HU.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=Haladjon tovbb
+continue_onto=%1$s haladjon tovbb
+turn_left=Forduljon balra
+turn_right=Forduljon jobbra
+turn_slight_left=Forduljon enyhn balra
+turn_slight_right=Forduljon enyhn jobbra
+turn_sharp_left=Forduljon lesen balra
+turn_sharp_right=Forduljon lesen jobbra
+turn_onto=%1$s forduljon be %2$s
+web.searchButton=Keress
+web.fromHint=Honnan
+web.viaHint=Keresztl
+web.toHint=Hova
+web.moreButton=Tbb
+web.gpxExportButton=GPX export
+web.routeInfo=%1$s tart %2$s
+web.locationsNotFound=tvonaltervezs nem lehetsges.A megadott hely(ek) nem tallhat(ak).
+web.bike=Bicikli
+web.racingbike=Verseny bicikli
+web.mtb=Terep bicikli
+web.car=Aut
+web.foot=Gyalog
+web.staticlink=Statikus hivatkozs
+web.motorcycle=Motor
+via=t
+finish=Megrekezett!
+hourAbbr=ra
+dayAbbr=nap
+minAbbr=perc
+kmAbbr=kilomter
+mAbbr=mter
+miAbbr=mrfld
+ftAbbr=lps
+road=Orszgt
+off_bike=Tolva folytathatja
+cycleway=Kerkpr t
+way=t
+paved=Kvezett t
+unpaved=Fldes t
+stopover=Meg kell llni %1$s
+roundaboutEnter=Hajtson be a krforgalomba
+roundaboutExit=Hagyja el a krfrgalmat, kihajt %1$s
+roundaboutExitOnto=Hagyja el a krfrgalmat, kihajt %1$s, aztn hajtson r %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/it.txt b/core/src/main/resources/com/graphhopper/util/it.txt
index 6f16557c1d..869881f239 100644
--- a/core/src/main/resources/com/graphhopper/util/it.txt
+++ b/core/src/main/resources/com/graphhopper/util/it.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=nettamente a sinistra
-sharp_right=nettamente a destra
-left=a sinistra
-right=a destra
-slight_left=leggermente a sinistra
-slight_right=leggermente a destra
 continue=continua
 continue_onto=continua su %1$s
-turn=gira %1$s
-turn_onto=gira %1$s su %2$s
+turn_left=gira a sinistra
+turn_right=gira a destra
+turn_slight_left=gira leggermente a sinistra
+turn_slight_right=gira leggermente a destra
+turn_sharp_left=gira nettamente a sinistra
+turn_sharp_right=gira nettamente a destra
+turn_onto=%1$s su %2$s
 web.searchButton=Ricerca
 web.fromHint=Da
 web.viaHint=attraverso
@@ -24,6 +23,7 @@ web.mtb=Mountainbike
 web.car=Auto
 web.foot=A piedi
 web.staticlink=permalink
+web.motorcycle=Moto
 via=attraverso
 finish=Arrivo!
 hourAbbr=hh
@@ -40,5 +40,6 @@ way=via
 paved=pavimentata
 unpaved=non pavimentata
 stopover=sosta %1$s
-roundaboutInstruction=Prendere l'uscita %1$s
-roundaboutInstructionWithDir=Prendere l'uscita %1$s in direzione %2$s
+roundaboutEnter=Entrare nella rotatoria
+roundaboutExit=Nella rotatoria, prendere l'uscita %1$s
+roundaboutExitOnto=Nella rotatoria, prendere l'uscita %1$s su %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/ja.txt b/core/src/main/resources/com/graphhopper/util/ja.txt
index 1aa3a9e2d5..cdc1755b1c 100644
--- a/core/src/main/resources/com/graphhopper/util/ja.txt
+++ b/core/src/main/resources/com/graphhopper/util/ja.txt
@@ -1,18 +1,17 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=
-sharp_right=
-left=
-right=
-slight_left=
-slight_right=
 continue=
 continue_onto=%1$s
-turn=%1$s
+turn_left=
+turn_right=
+turn_slight_left=
+turn_slight_right=
+turn_sharp_left=
+turn_sharp_right=
 turn_onto=%1$s%2$s
 web.searchButton=
 web.fromHint=
-web.viaHint=
+web.viaHint=
 web.toHint=
 web.moreButton=
 web.gpxExportButton=GPX
@@ -23,8 +22,9 @@ web.racingbike=
 web.mtb=
 web.car=
 web.foot=
-web.staticlink=
-via=
+web.staticlink=
+web.motorcycle=
+via=
 finish=
 hourAbbr=
 dayAbbr=
@@ -40,5 +40,6 @@ way=
 paved=
 unpaved=
 stopover=%1$s
-roundaboutInstruction=%1$s
-roundaboutInstructionWithDir=%1$s%2$s
+roundaboutEnter=
+roundaboutExit=%1$s
+roundaboutExitOnto=%1$s%2$s
diff --git a/core/src/main/resources/com/graphhopper/util/lt_LT.txt b/core/src/main/resources/com/graphhopper/util/lt_LT.txt
new file mode 100644
index 0000000000..aba326b370
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/lt_LT.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=tskite
+continue_onto=tskite toliau %1$s
+turn_left=sukite  kair
+turn_right=sukite  dein
+turn_slight_left=laikykite kairiau
+turn_slight_right=laikykite deiniau
+turn_sharp_left=staigiai sukite kairn
+turn_sharp_right=staigiai sukite deinn
+turn_onto=%1$s  %2$s
+web.searchButton=Iekoti
+web.fromHint=Nuo
+web.viaHint=Per
+web.toHint=Iki
+web.moreButton=dar
+web.gpxExportButton=GPX eksportas
+web.routeInfo=%1$s utruksite %2$s
+web.locationsNotFound=Neimanoma sukurti marruto. Nurodyti takai nerasti ioje zonoje.
+web.bike=Dviratis
+web.racingbike=Plentinis dviratis
+web.mtb=MTB dviratis
+web.car=Automobilis
+web.foot=Psiomis
+web.staticlink=Nuoroda
+web.motorcycle=Motociklas
+via=per
+finish=Tikslas pasiektas!
+hourAbbr=h
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=kelias
+off_bike=nulipkite nuo dviraio
+cycleway=dvirai takas
+way=kelias
+paved=asfaltuotas
+unpaved=gruntinis
+stopover=sustojimas %1$s
+roundaboutEnter=vaiuokite  ied
+roundaboutExit=iede ivaiuokite %1$s ivaiavime
+roundaboutExitOnto=iede ivaiuokite %1$s ivaiavime   %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/ne.txt b/core/src/main/resources/com/graphhopper/util/ne.txt
new file mode 100644
index 0000000000..e502256a5e
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/ne.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=
+continue_onto=%1$s 
+turn_left=  
+turn_right=  
+turn_slight_left=   
+turn_slight_right=   
+turn_sharp_left=   
+turn_sharp_right=   
+turn_onto=%2$s  %1$s  
+web.searchButton= 
+web.fromHint= 
+web.viaHint=
+web.toHint=
+web.moreButton=
+web.gpxExportButton=GPX   
+web.routeInfo=%1$s   %2$s 
+web.locationsNotFound=     
+web.bike= 
+web.racingbike=  
+web.mtb= 
+web.car=
+web.foot=
+web.staticlink= 
+web.motorcycle= 
+via=
+finish=
+hourAbbr=
+dayAbbr=
+minAbbr=
+kmAbbr= 
+mAbbr=
+miAbbr=
+ftAbbr=
+road=
+off_bike=  
+cycleway=  
+way=
+paved=
+unpaved=
+stopover=%1$s   
+roundaboutEnter=  
+roundaboutExit= %1$s     
+roundaboutExitOnto= %1$s     %2$s  
diff --git a/core/src/main/resources/com/graphhopper/util/nl.txt b/core/src/main/resources/com/graphhopper/util/nl.txt
index 7893b2ef22..869f547fc1 100644
--- a/core/src/main/resources/com/graphhopper/util/nl.txt
+++ b/core/src/main/resources/com/graphhopper/util/nl.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=scherp naar links
-sharp_right=scherp naar rechts
-left=links
-right=rechts
-slight_left=licht naar links
-slight_right=licht naar rechts
-continue=ga door
-continue_onto=ga door op %1$s
-turn=%1$s afbuigen
-turn_onto=sla %1$s op %2$s
+continue=neem 
+continue_onto=blijf op %1$s
+turn_left=linksaf
+turn_right=rechtsaf
+turn_slight_left=houd links aan
+turn_slight_right=houd rechts aan
+turn_sharp_left=ga linksaf
+turn_sharp_right=ga rechtsaf
+turn_onto=%1$s naar %2$s
 web.searchButton=zoek
 web.fromHint=van
 web.viaHint=via
@@ -24,9 +23,10 @@ web.mtb=mountainbike
 web.car=auto
 web.foot=te voet
 web.staticlink=statische link
+web.motorcycle=motorfiets
 via=via
-finish=bestemming bereikt!
-hourAbbr=h
+finish=Bestemming bereikt
+hourAbbr=u
 dayAbbr=d
 minAbbr=min
 kmAbbr=km
@@ -39,6 +39,7 @@ cycleway=fietspad
 way=weg
 paved=verhard
 unpaved=onverhard
-stopover=tussenbestemming %1$s
-roundaboutInstruction=ga de rotonde op en gebruik afrit %1$s
-roundaboutInstructionWithDir=ga de rotonde op en gebruik affit %1$s in de richting %2$s
+stopover=tussenstop %1$s
+roundaboutEnter=ga de rotonde op
+roundaboutExit=neem afslag %1$s op de rotonde 
+roundaboutExitOnto=neem afslag %1$s naar %2$s op de rotonde 
diff --git a/core/src/main/resources/com/graphhopper/util/pl_PL.txt b/core/src/main/resources/com/graphhopper/util/pl_PL.txt
new file mode 100644
index 0000000000..47b3b4aace
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/pl_PL.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=kontynuuj
+continue_onto=kontynuuj na %1$s
+turn_left=skr w lewo
+turn_right=skr w prawo
+turn_slight_left=skr delikatnie w lewo
+turn_slight_right=skr delikatnie w prawo
+turn_sharp_left=skr ostro w lewo
+turn_sharp_right=skr ostro w prawo
+turn_onto=%1$s na %2$s
+web.searchButton=Szukaj
+web.fromHint=Z
+web.viaHint=Przez
+web.toHint=Do
+web.moreButton=wicej
+web.gpxExportButton=Eksportuj GPX
+web.routeInfo=%1$s zajmie %2$s
+web.locationsNotFound=Nie mona wyznaczy trasy. Lokalizacja(e) nie zostaa(y) znalezione. 
+web.bike=Rower
+web.racingbike=Rower wycigowy
+web.mtb=Rower grski
+web.car=Samochod
+web.foot=Pieszo
+web.staticlink=link
+web.motorcycle=Motocykl
+via=przez
+finish=Jeste u celu!
+hourAbbr=g
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=droga
+off_bike=zejd z roweru
+cycleway=trasa rowerowa
+way=trasa
+paved=utwierdzona
+unpaved=nieutwardzona
+stopover=przystanek %1$s
+roundaboutEnter=Wjed na rondo
+roundaboutExit=Zjed z ronda %1$s zjazdem
+roundaboutExitOnto=Zjed z ronda %1$s zjazdem na %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/pt_BR.txt b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
index fc78ebd5be..0854a07ceb 100644
--- a/core/src/main/resources/com/graphhopper/util/pt_BR.txt
+++ b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=curva acentuada  esquerda
-sharp_right=curva acentuada  direita
-left=esquerda
-right=direita
-slight_left=curva suave  esquerda
-slight_right=curva suave  direita
 continue=continuar
 continue_onto=continue na %1$s
-turn=vire  %1$s
-turn_onto=vire  %1$s em %2$s
+turn_left=vire  esquerda
+turn_right=vire  direita
+turn_slight_left=vire  curva suave  esquerda
+turn_slight_right=vire  curva suave  direita
+turn_sharp_left=vire  curva acentuada  esquerda
+turn_sharp_right=vire  curva acentuada  direita
+turn_onto=%1$s em %2$s
 web.searchButton=Pesquisar
 web.fromHint=De
 web.viaHint=Via
@@ -24,6 +23,7 @@ web.mtb=Mountainbike
 web.car=Carro
 web.foot=A p
 web.staticlink=Link esttico
+web.motorcycle=Motocicleta
 via=via
 finish=Destino alcanado
 hourAbbr=h
@@ -40,5 +40,6 @@ way=caminho
 paved=pavimentada
 unpaved=no pavimentada
 stopover=parada %1$s
-roundaboutInstruction=Entre na rotatria e saia na sada nmero %1$s
-roundaboutInstructionWithDir=Entre na rotatria e saia na sada nmero %1$s em direo a %2$s
+roundaboutEnter=Entre na rotatria
+roundaboutExit=Na rotatria, saia na %1$s sada
+roundaboutExitOnto=Na rotatria, saia na %1$s saida em direo a %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/pt_PT.txt b/core/src/main/resources/com/graphhopper/util/pt_PT.txt
index 10bffbb4d5..688050beb8 100644
--- a/core/src/main/resources/com/graphhopper/util/pt_PT.txt
+++ b/core/src/main/resources/com/graphhopper/util/pt_PT.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=curva apertada  esquerda
-sharp_right=curva apertada  direita
-left=esquerda
-right=direita
-slight_left=curva ligeira  esquerda
-slight_right=curva ligeira  direita
 continue=continuar
 continue_onto=continue na %1$s
-turn=vire  %1$s
-turn_onto=vire  %1$s para %2$s
+turn_left=vire  esquerda
+turn_right=vire  direita
+turn_slight_left=vire  curva ligeira  esquerda
+turn_slight_right=vire  curva ligeira  direita
+turn_sharp_left=vire  curva apertada  esquerda
+turn_sharp_right=vire  curva apertada  direita
+turn_onto=%1$s para %2$s
 web.searchButton=Pesquisar
 web.fromHint=De
 web.viaHint=Por
@@ -24,6 +23,7 @@ web.mtb=Bicicleta de montanha
 web.car=Carro
 web.foot=A p
 web.staticlink=Ligao permanente
+web.motorcycle=Motocicleta
 via=por
 finish=Chegou ao seu destino!
 hourAbbr=h
@@ -40,5 +40,6 @@ way=caminho
 paved=pavimentado
 unpaved=no pavimentada
 stopover=paragem %1$s
-roundaboutInstruction=Entre na rotunda e saia na sada nmero %1$s
-roundaboutInstructionWithDir=Entre na rotunda e saia na sada nmero %1$s em direo a %2$s
+roundaboutEnter=Entre na rotunda
+roundaboutExit=Na rotunda, saia na %1$s sada
+roundaboutExitOnto=Na rotunda, saia na %1$s saida em direo a %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/ro.txt b/core/src/main/resources/com/graphhopper/util/ro.txt
index af528cca78..3b59396800 100644
--- a/core/src/main/resources/com/graphhopper/util/ro.txt
+++ b/core/src/main/resources/com/graphhopper/util/ro.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=brusc la stnga
-sharp_right=brusc la dreapta
-left=stnga
-right=dreapta
-slight_left=uor la stnga
-slight_right=uor la dreapta
 continue=continu
 continue_onto=continu pe %1$s
-turn=schimbai direcia la %1$s
-turn_onto=schimbai direcia la %1$s pe %2$s
+turn_left=schimbai direcia la stnga
+turn_right=schimbai direcia la dreapta
+turn_slight_left=schimbai direcia la uor la stnga
+turn_slight_right=schimbai direcia la uor la dreapta
+turn_sharp_left=schimbai direcia la brusc la stnga
+turn_sharp_right=schimbai direcia la brusc la dreapta
+turn_onto=%1$s pe %2$s
 web.searchButton=Caut
 web.fromHint=De la
 web.viaHint=Prin
@@ -24,6 +23,7 @@ web.mtb=Mountainbike
 web.car=main
 web.foot=pe jos
 web.staticlink=link
+web.motorcycle=Motociclet
 via=prin
 finish=obiectiv atins
 hourAbbr=h
@@ -40,5 +40,6 @@ way=cale
 paved=pavat
 unpaved=nepavat
 stopover=escala %1$s
-roundaboutInstruction= Intrai n giratoriu i folosii ieirea %1$s
-roundaboutInstructionWithDir= Intrai n giratoriu i folosii ieirea %1$s n direcia %2$s
+roundaboutEnter=Intrai n giratoriu 
+roundaboutExit=La giratoriu folosii ieirea %1$s
+roundaboutExitOnto=La giratoriu folosii ieirea %1$s ctre %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/ru.txt b/core/src/main/resources/com/graphhopper/util/ru.txt
index 65dea0914f..d5b796eae4 100644
--- a/core/src/main/resources/com/graphhopper/util/ru.txt
+++ b/core/src/main/resources/com/graphhopper/util/ru.txt
@@ -1,44 +1,45 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left= 
-sharp_right= 
-left=
-right=
-slight_left= 
-slight_right= 
 continue=
 continue_onto=  %1$s
-turn= %1$s
-turn_onto= %1$s  %2$s
+turn_left= 
+turn_right= 
+turn_slight_left=  
+turn_slight_right=  
+turn_sharp_left=  
+turn_sharp_right=  
+turn_onto=%1$s  %2$s
 web.searchButton=
 web.fromHint=
-web.viaHint=
+web.viaHint=
 web.toHint=
 web.moreButton=
-web.gpxExportButton=
+web.gpxExportButton= GPX
 web.routeInfo=%1$s  %2$s
-web.locationsNotFound=  .   
+web.locationsNotFound=  .   .
 web.bike=
-web.racingbike=
-web.mtb=
+web.racingbike= 
+web.mtb= 
 web.car=
 web.foot=
-web.staticlink=
-via=
-finish= 
-hourAbbr=h
-dayAbbr=d
-minAbbr=min
-kmAbbr=km
-mAbbr=m
-miAbbr=mi
-ftAbbr=ft
-road=
-off_bike=
-cycleway=
-way=
-paved=
-unpaved=
-stopover=
-roundaboutInstruction=
-roundaboutInstructionWithDir=
+web.staticlink=
+web.motorcycle=
+via=
+finish= !
+hourAbbr=
+dayAbbr=
+minAbbr=
+kmAbbr=
+mAbbr=
+miAbbr=
+ftAbbr=
+road=
+off_bike=  
+cycleway=
+way=
+paved= 
+unpaved= 
+stopover= %1$s
+roundaboutEnter=  
+roundaboutExit=    %1$s
+roundaboutExitOnto=    %1$s  %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/si.txt b/core/src/main/resources/com/graphhopper/util/si.txt
index a398fc1826..7276fc5fa4 100644
--- a/core/src/main/resources/com/graphhopper/util/si.txt
+++ b/core/src/main/resources/com/graphhopper/util/si.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=ostro levo
-sharp_right=ostro desno
-left=levo
-right=desno
-slight_left=rahlo levo
-slight_right=rahlo desno
 continue=nadaljujte
 continue_onto=nadaljujte po %1$s
-turn=zavite %1$s
-turn_onto=zavite %1$s na %2$s
+turn_left=zavite levo
+turn_right=zavite desno
+turn_slight_left=zavite rahlo levo
+turn_slight_right=zavite rahlo desno
+turn_sharp_left=zavite ostro levo
+turn_sharp_right=zavite ostro desno
+turn_onto=%1$s na %2$s
 web.searchButton=Ii
 web.fromHint=Od 
 web.viaHint=
@@ -23,8 +22,9 @@ web.racingbike=cestno kolo
 web.mtb=gorsko kolo
 web.car=Avto
 web.foot=Pe
-web.staticlink=
-via=
+web.staticlink=povezava
+web.motorcycle=motorno kolo
+via=preko
 finish=Konec!
 hourAbbr=h
 dayAbbr=d
@@ -40,5 +40,6 @@ way=smer
 paved=tlakovana
 unpaved=netlakovana
 stopover=postanek %1$s
-roundaboutInstruction=zapelji v kroie in izberi izhod %1$
-roundaboutInstructionWithDir=zapelji v kroie in izberi izhod %1$ v smeri %2$s
+roundaboutEnter=zapeljite v kroie
+roundaboutExit=v kroiu izberite izhod %1$s
+roundaboutExitOnto=v kroiu izberite izhod %1$s na %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/sk.txt b/core/src/main/resources/com/graphhopper/util/sk.txt
index 3267b9dc25..7f6b68021f 100644
--- a/core/src/main/resources/com/graphhopper/util/sk.txt
+++ b/core/src/main/resources/com/graphhopper/util/sk.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=ostro doava
-sharp_right=ostro doprava
-left=doava
-right=doprava
-slight_left=mierne doava
-slight_right=mierne doprava
 continue=pokraujte
 continue_onto=pokraujte na %1$s
-turn=odbote %1$s
-turn_onto=odbote %1$s na %2$s
+turn_left=odbote doava
+turn_right=odbote doprava
+turn_slight_left=odbote mierne doava
+turn_slight_right=odbote mierne doprava
+turn_sharp_left=odbote ostro doava
+turn_sharp_right=odbote ostro doprava
+turn_onto=%1$s na %2$s
 web.searchButton=Vyhada
 web.fromHint=Z
 web.viaHint=Cez
@@ -24,9 +23,10 @@ web.mtb=Horsk bicykel
 web.car=Automobil
 web.foot=Peo
 web.staticlink=nemenn odkaz
+web.motorcycle=Motocykel
 via=cez
 finish=Cie!
-hourAbbr=Horsk bicykel
+hourAbbr=h
 dayAbbr=d
 minAbbr=min
 kmAbbr=km
@@ -40,5 +40,6 @@ way=smer
 paved=spevnen
 unpaved=nespevnen
 stopover=zastvka %1$s
-roundaboutInstruction=Vojdite na kruhov objazd a opustite ho cez %1$s. vjazd
-roundaboutInstructionWithDir=Vojdite na kruhov objazd a opustite ho cez %1$s. vjazd v smere %2$s
+roundaboutEnter=Vojdite na kruhov objazd
+roundaboutExit=Na kruhovom objazde, ho opustite cez %1$s. vjazd
+roundaboutExitOnto=Na kruhovom objazde, ho opustite cez %1$s. vjazd na %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/sv_SE.txt b/core/src/main/resources/com/graphhopper/util/sv_SE.txt
index cbfcb87d05..0fa1a74e85 100644
--- a/core/src/main/resources/com/graphhopper/util/sv_SE.txt
+++ b/core/src/main/resources/com/graphhopper/util/sv_SE.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=kraftigt vnster
-sharp_right=kraftigt hger
-left=vnster
-right=hger
-slight_left=svagt vnster
-slight_right=svagt hger
 continue=fortstt
 continue_onto=fortstt in p %1$s
-turn=svng %1$s
-turn_onto=svng %1$s in p %2$s
+turn_left=svng vnster
+turn_right=svng hger
+turn_slight_left=svng svagt vnster
+turn_slight_right=svng svagt hger
+turn_sharp_left=svng kraftigt vnster
+turn_sharp_right=svng kraftigt hger
+turn_onto=%1$s in p %2$s
 web.searchButton=Sk
 web.fromHint=Frn
 web.viaHint=Via
@@ -23,7 +22,8 @@ web.racingbike=Tvlingscykel
 web.mtb=Mountain bike
 web.car=Bil
 web.foot=Gng
-web.staticlink=Direktlnk
+web.staticlink=direktlnk
+web.motorcycle=Motorcykel
 via=via
 finish=Framme!
 hourAbbr= tim
@@ -40,5 +40,6 @@ way=vg
 paved=belagd
 unpaved=obelagd
 stopover=delml %1$s
-roundaboutInstruction=Kr in i rondellen och ta avfart %1$s
-roundaboutInstructionWithDir=Kr in i rondellen och ta avfart %1$s mot %2$s
+roundaboutEnter=Kr in i rondellen
+roundaboutExit=I rondellen, ta avfart %1$s
+roundaboutExitOnto=I rondellen, ta avfart %1$s in p %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/tr.txt b/core/src/main/resources/com/graphhopper/util/tr.txt
index f45d1ae345..5ae8584858 100644
--- a/core/src/main/resources/com/graphhopper/util/tr.txt
+++ b/core/src/main/resources/com/graphhopper/util/tr.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=sola keskin dn
-sharp_right=saa keskin dn
-left=sol 
-right=sa 
-slight_left=hafif sola
-slight_right=hafif saa
 continue=devam
 continue_onto=-e devam %1$s
-turn=dn %1$s
-turn_onto=-e dn %1$s %2$s
+turn_left=dn sol 
+turn_right=dn sa 
+turn_slight_left=dn hafif sola
+turn_slight_right=dn hafif saa
+turn_sharp_left=dn sola keskin dn
+turn_sharp_right=dn saa keskin dn
+turn_onto=%1$s %2$s
 web.searchButton=ara
 web.fromHint=-den 
 web.viaHint=araciligi ile
@@ -24,8 +23,9 @@ web.mtb=dag bisikleti
 web.car=Otomobil
 web.foot=Yryerek
 web.staticlink=duragan baglanti
+web.motorcycle=motorsiklet
 via=araciligi ile
-finish=Bitti !
+finish=Bitti!
 hourAbbr=s
 dayAbbr=g
 minAbbr=dak
@@ -40,5 +40,6 @@ way=yol
 paved=kaldrm
 unpaved=kaldrmsz yol
 stopover=mola yeri %1$s
-roundaboutInstruction=dner kavsaa girin ve ck kullann %1$
-roundaboutInstructionWithDir=dner kavaa girin ve k kullann %1$ - %2$s
+roundaboutEnter=kavaa gir
+roundaboutExit=kavaktan %1$s cka gir
+roundaboutExitOnto=kavaktan %1$s cktan %2$s sokaa gir
diff --git a/core/src/main/resources/com/graphhopper/util/uk.txt b/core/src/main/resources/com/graphhopper/util/uk.txt
index d0701f7371..a356a96217 100644
--- a/core/src/main/resources/com/graphhopper/util/uk.txt
+++ b/core/src/main/resources/com/graphhopper/util/uk.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left= 
-sharp_right= 
-left=
-right=
-slight_left= 
-slight_right= 
 continue=
 continue_onto=  %1$s
-turn= %1$s
-turn_onto= %1$s  %2$s
+turn_left= 
+turn_right= 
+turn_slight_left=  
+turn_slight_right=  
+turn_sharp_left=  
+turn_sharp_right=  
+turn_onto=%1$s  %2$s
 web.searchButton=
 web.fromHint=
 web.viaHint=
@@ -24,6 +23,7 @@ web.mtb= 
 web.car=
 web.foot=
 web.staticlink= 
+web.motorcycle=
 via=
 finish=    !
 hourAbbr= 
@@ -34,11 +34,12 @@ mAbbr= 
 miAbbr= 
 ftAbbr= 
 road=
-off_bike=,   
+off_bike=  
 cycleway= 
 way=
 paved= 
 unpaved= 
 stopover= %1$s
-roundaboutInstruction=      %1$s
-roundaboutInstructionWithDir=      %1$s   %2$s
+roundaboutEnter=  
+roundaboutExit=    %1$s
+roundaboutExitOnto=    %1$s  %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/vi_VI.txt b/core/src/main/resources/com/graphhopper/util/vi_VI.txt
new file mode 100644
index 0000000000..015af51a0e
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/vi_VI.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=tip tc
+continue_onto=tip tc theo %1$s
+turn_left=r tri
+turn_right=r phi
+turn_slight_left=r nh tri
+turn_slight_right=r nh phi
+turn_sharp_left=r tri ngay
+turn_sharp_right=r phi ngay
+turn_onto=%1$s theo %1$s
+web.searchButton=Tm
+web.fromHint=T
+web.viaHint=Qua
+web.toHint=n
+web.moreButton=thm
+web.gpxExportButton=Xut GPX
+web.routeInfo=%1$s mt %2$s
+web.locationsNotFound=Khng tm thy l trnh! Cc im  chn khng tm thy trong vng ny
+web.bike=Xe p
+web.racingbike=Xe ua
+web.mtb=Xe leo ni
+web.car= t
+web.foot=i b
+web.staticlink=lin kt tnh
+web.motorcycle=M t
+via=qua
+finish=Kt thc!
+hourAbbr=g
+dayAbbr=n
+minAbbr=p
+kmAbbr=km
+mAbbr=m
+miAbbr=dm
+ftAbbr=ft
+road=ng
+off_bike=b xe p
+cycleway=ng xe p
+way=ng
+paved=ng lt
+unpaved=ng khng lt
+stopover=im ngh %1$s
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/zh_CN.txt b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
new file mode 100644
index 0000000000..1a5809a030
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=
+continue_onto= %1$s
+turn_left=
+turn_right=
+turn_slight_left=
+turn_slight_right=
+turn_sharp_left=
+turn_sharp_right=
+turn_onto=%1$s   %2$s
+web.searchButton=
+web.fromHint=
+web.viaHint=
+web.toHint=
+web.moreButton=
+web.gpxExportButton=GPX
+web.routeInfo=%1$s  %2$s 
+web.locationsNotFound=
+web.bike=
+web.racingbike=
+web.mtb=
+web.car=
+web.foot=
+web.staticlink=
+web.motorcycle=
+via=
+finish=
+hourAbbr=
+dayAbbr=
+minAbbr=
+kmAbbr=
+mAbbr=
+miAbbr=
+ftAbbr=
+road=
+off_bike=
+cycleway=
+way=
+paved=
+unpaved=
+stopover= %1$s
+roundaboutEnter=
+roundaboutExit=%1$s
+roundaboutExitOnto=%1$s%2$s
diff --git a/core/src/test/java/com/graphhopper/GHRequestTest.java b/core/src/test/java/com/graphhopper/GHRequestTest.java
index e679159dc2..97b761ae88 100644
--- a/core/src/test/java/com/graphhopper/GHRequestTest.java
+++ b/core/src/test/java/com/graphhopper/GHRequestTest.java
@@ -18,11 +18,16 @@
  */
 package com.graphhopper;
 
+import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHRequestTest
@@ -36,4 +41,71 @@ public void testGetHint()
         // #173 - will throw an error: Integer cannot be cast to Double
         assertEquals(1, instance.getHints().getDouble("something", 2d), 1e1);
     }
+
+    @Test
+    public void testCorrectInit()
+    {
+        double lat0 = 51, lon0 = 1, lat1 = 52, lon1 = 2, lat2 = 53, lon2 = 3;
+
+        ArrayList<GHPoint> points = new ArrayList<GHPoint>(3);
+        points.add(new GHPoint(lat0, lon0));
+        points.add(new GHPoint(lat1, lon1));
+        points.add(new GHPoint(lat2, lon2));
+        List<Double> favoredHeadings = Arrays.asList(3.14, 4.15, Double.NaN);
+        List<Double> emptyHeadings = Arrays.asList(Double.NaN, Double.NaN, Double.NaN);
+
+        GHRequest instance;
+
+        instance = new GHRequest(points, favoredHeadings);
+        compareFavoredHeadings(instance, favoredHeadings);
+        assertEquals("Points not initialized correct", points, instance.getPoints());
+
+        instance = new GHRequest(points.get(0), points.get(1), favoredHeadings.get(0), favoredHeadings.get(1));
+        compareFavoredHeadings(instance, favoredHeadings.subList(0, 2));
+        assertEquals("Points not initialized correct", points.subList(0, 2), instance.getPoints());
+
+        instance = new GHRequest(lat0, lon0, lat1, lon1, favoredHeadings.get(0), favoredHeadings.get(1));
+        compareFavoredHeadings(instance, favoredHeadings.subList(0, 2));
+        assertEquals("Points not initialized correct", points.subList(0, 2), instance.getPoints());
+
+        instance = new GHRequest(3).addPoint(points.get(0), favoredHeadings.get(0)).
+                addPoint(points.get(1), favoredHeadings.get(1)).
+                addPoint(points.get(2), favoredHeadings.get(2));
+        compareFavoredHeadings(instance, favoredHeadings);
+        assertEquals("Points not initialized correct", points, instance.getPoints());
+
+        instance = new GHRequest().addPoint(points.get(0), favoredHeadings.get(0)).
+                addPoint(points.get(1), favoredHeadings.get(1)).
+                addPoint(points.get(2), favoredHeadings.get(2));
+        assertEquals("Points not initialized correct", points, instance.getPoints());
+        compareFavoredHeadings(instance, favoredHeadings);
+
+        // check init without favoredHeadings
+        instance = new GHRequest(points);
+        assertEquals("Points not initialized correct", points, instance.getPoints());
+        compareFavoredHeadings(instance, emptyHeadings);
+
+        instance = new GHRequest(points.get(0), points.get(1));
+        assertEquals("Points not initialized correct", points.subList(0, 2), instance.getPoints());
+        compareFavoredHeadings(instance, emptyHeadings.subList(0, 2));
+
+        instance = new GHRequest(lat0, lon0, lat1, lon1);
+        assertEquals("Points not initialized correct", points.subList(0, 2), instance.getPoints());
+        compareFavoredHeadings(instance, emptyHeadings.subList(0, 2));
+
+        instance = new GHRequest().addPoint(points.get(0)).addPoint(points.get(1)).addPoint(points.get(2));
+        assertEquals("Points not initialized correct", points, instance.getPoints());
+        compareFavoredHeadings(instance, emptyHeadings);
+    }
+
+    private void compareFavoredHeadings( GHRequest request, List<Double> expected )
+    {
+        for (int ind = 0; ind < expected.size(); ind++)
+        {
+            double favoredHeading = request.getFavoredHeading(ind);
+            assertEquals(ind + " favored Heading does not match" + expected.get(ind) + " vs ." + favoredHeading,
+                    expected.get(ind), favoredHeading, 0.01);
+        }
+
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/GHResponseTest.java b/core/src/test/java/com/graphhopper/GHResponseTest.java
new file mode 100644
index 0000000000..d303593cd6
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/GHResponseTest.java
@@ -0,0 +1,11 @@
+package com.graphhopper;
+
+import junit.framework.TestCase;
+
+public class GHResponseTest extends TestCase
+{
+    public void testToString() throws Exception
+    {
+        assertEquals("nodes:0; ", new GHResponse().toString());
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
index 03e770c979..86df0df099 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
@@ -22,10 +22,10 @@
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.NodeAccess;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GraphHopperAPITest
@@ -54,14 +54,14 @@ public void testLoad()
                 setEncodingManager(encodingManager).
                 setCHEnable(false).
                 loadGraph(graph);
-        GHResponse ph = instance.route(new GHRequest(42, 10.4, 42, 10));
-        assertTrue(ph.isFound());
-        assertEquals(80, ph.getDistance(), 1e-6);
-        assertEquals(42, ph.getPoints().getLatitude(0), 1e-5);
-        assertEquals(10.4, ph.getPoints().getLongitude(0), 1e-5);
-        assertEquals(41.9, ph.getPoints().getLatitude(1), 1e-5);
-        assertEquals(10.2, ph.getPoints().getLongitude(1), 1e-5);
-        assertEquals(3, ph.getPoints().getSize());
+        GHResponse rsp = instance.route(new GHRequest(42, 10.4, 42, 10));
+        assertFalse(rsp.hasErrors());
+        assertEquals(80, rsp.getDistance(), 1e-6);
+        assertEquals(42, rsp.getPoints().getLatitude(0), 1e-5);
+        assertEquals(10.4, rsp.getPoints().getLongitude(0), 1e-5);
+        assertEquals(41.9, rsp.getPoints().getLatitude(1), 1e-5);
+        assertEquals(10.2, rsp.getPoints().getLongitude(1), 1e-5);
+        assertEquals(3, rsp.getPoints().getSize());
         instance.close();
     }
 
@@ -77,15 +77,23 @@ public void testDisconnected179()
 
         graph.edge(0, 1, 10, true);
         graph.edge(2, 3, 10, true);
-        
+
         GraphHopper instance = new GraphHopper().
                 setStoreOnFlush(false).
                 setEncodingManager(encodingManager).
                 setCHEnable(false).
                 loadGraph(graph);
-        GHResponse ph = instance.route(new GHRequest(42, 10, 42, 10.4));
-        assertFalse(ph.isFound());
-        assertEquals(0, ph.getPoints().getSize());        
+        GHResponse rsp = instance.route(new GHRequest(42, 10, 42, 10.4));
+        assertTrue(rsp.hasErrors());
+
+        try
+        {
+            rsp.getPoints();
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
+
         instance.close();
     }
 
diff --git a/core/src/test/java/com/graphhopper/GraphHopperIT.java b/core/src/test/java/com/graphhopper/GraphHopperIT.java
new file mode 100644
index 0000000000..176a02b592
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -0,0 +1,416 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper;
+
+import com.graphhopper.reader.dem.SRTMProvider;
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.GHPoint;
+import org.junit.*;
+
+import java.io.File;
+import java.util.List;
+import java.util.Map;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author Peter Karich
+ */
+public class GraphHopperIT
+{
+    private static GraphHopper hopper;
+    private static final String graphFileFoot = "target/graphhopperIT-foot";
+    private static final String osmFile = "files/monaco.osm.gz";
+    private static final String importVehicles = "FOOT";
+    private static final String vehicle = "FOOT";
+    private static final String weightCalcStr = "shortest";
+
+    private final String tmpGraphFile = "target/graphhopperIT-tmp";
+
+    @Before
+    public void setUp()
+    {
+        Helper.removeDir(new File(tmpGraphFile));
+    }
+
+    @After
+    public void tearDown()
+    {
+        Helper.removeDir(new File(tmpGraphFile));
+    }
+
+    @BeforeClass
+    public static void beforeClass()
+    {
+        // make sure we are using fresh graphhopper files with correct vehicle
+        Helper.removeDir(new File(graphFileFoot));
+
+        hopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(osmFile).
+                setCHEnable(false).
+                setGraphHopperLocation(graphFileFoot).
+                setEncodingManager(new EncodingManager(importVehicles)).
+                importOrLoad();
+    }
+
+    @AfterClass
+    public static void afterClass()
+    {
+        Helper.removeDir(new File(graphFileFoot));
+    }
+
+    @Test
+    public void testMonacoWithInstructions() throws Exception
+    {
+        GHResponse rsp = hopper.route(new GHRequest(43.727687, 7.418737, 43.74958, 7.436566).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+
+        // identify the number of counts to compare with CH foot route
+        assertEquals(698, rsp.getHints().getLong("visited_nodes.sum", 0));
+        assertEquals(3437.6, rsp.getDistance(), .1);
+        assertEquals(89, rsp.getPoints().getSize());
+
+        InstructionList il = rsp.getInstructions();
+        assertEquals(13, il.size());
+
+        List<Map<String, Object>> resultJson = il.createJson();
+        // TODO roundabout fine tuning -> enter + leave roundabout (+ two rounabouts -> is it necessary if we do not leave the street?)
+        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
+        assertEquals("Continue onto Avenue des Papalins", resultJson.get(1).get("text"));
+        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
+        assertEquals("Turn left", resultJson.get(3).get("text"));
+        assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
+
+        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
+        assertEquals(289, (Double) resultJson.get(1).get("distance"), 1);
+        assertEquals(10, (Double) resultJson.get(2).get("distance"), 1);
+        assertEquals(43, (Double) resultJson.get(3).get("distance"), 1);
+        assertEquals(122, (Double) resultJson.get(4).get("distance"), 1);
+        assertEquals(447, (Double) resultJson.get(5).get("distance"), 1);
+
+        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
+        assertEquals(207, (Long) resultJson.get(1).get("time") / 1000);
+        assertEquals(7, (Long) resultJson.get(2).get("time") / 1000);
+        assertEquals(30, (Long) resultJson.get(3).get("time") / 1000);
+        assertEquals(87, (Long) resultJson.get(4).get("time") / 1000);
+        assertEquals(321, (Long) resultJson.get(5).get("time") / 1000);
+
+        List<GPXEntry> list = rsp.getInstructions().createGPXList();
+        assertEquals(89, list.size());
+        final long lastEntryMillis = list.get(list.size() - 1).getTime();
+        final long totalResponseMillis = rsp.getTime();
+        assertEquals(totalResponseMillis, lastEntryMillis);
+    }
+
+    @Test
+    public void testMonacoVia()
+    {
+        GHResponse rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.74958, 7.436566)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+
+        assertEquals(6875.1, rsp.getDistance(), .1);
+        assertEquals(179, rsp.getPoints().getSize());
+
+        InstructionList il = rsp.getInstructions();
+        assertEquals(26, il.size());
+        List<Map<String, Object>> resultJson = il.createJson();
+        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
+        assertEquals("Continue onto Avenue des Papalins", resultJson.get(1).get("text"));
+        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
+        assertEquals("Turn left", resultJson.get(3).get("text"));
+        assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
+
+        assertEquals("Stopover 1", resultJson.get(12).get("text"));
+
+        assertEquals("Continue onto Avenue Albert II", resultJson.get(20).get("text"));
+        assertEquals("Turn left", resultJson.get(21).get("text"));
+        assertEquals("Turn right onto Quai Jean-Charles Rey", resultJson.get(22).get("text"));
+        assertEquals("Turn sharp left onto Avenue des Papalins", resultJson.get(23).get("text"));
+        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(24).get("text"));
+        assertEquals("Finish!", resultJson.get(25).get("text"));
+
+        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
+        assertEquals(289, (Double) resultJson.get(1).get("distance"), 1);
+        assertEquals(10, (Double) resultJson.get(2).get("distance"), 1);
+        assertEquals(43, (Double) resultJson.get(3).get("distance"), 1);
+        assertEquals(122, (Double) resultJson.get(4).get("distance"), 1);
+        assertEquals(447, (Double) resultJson.get(5).get("distance"), 1);
+
+        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
+        assertEquals(207, (Long) resultJson.get(1).get("time") / 1000);
+        assertEquals(7, (Long) resultJson.get(2).get("time") / 1000);
+        assertEquals(30, (Long) resultJson.get(3).get("time") / 1000);
+        assertEquals(87, (Long) resultJson.get(4).get("time") / 1000);
+        assertEquals(321, (Long) resultJson.get(5).get("time") / 1000);
+
+        // special case of identical start and end point
+        rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+        assertEquals(0, rsp.getDistance(), .1);
+        assertEquals(0, rsp.getRouteWeight(), .1);
+        assertEquals(1, rsp.getPoints().getSize());
+        assertEquals(1, rsp.getInstructions().size());
+        assertEquals("Finish!", rsp.getInstructions().createJson().get(0).get("text"));
+        assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(0).get("sign"));
+
+        rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+        assertEquals(0, rsp.getDistance(), .1);
+        assertEquals(0, rsp.getRouteWeight(), .1);
+        assertEquals(2, rsp.getPoints().getSize());
+        assertEquals(2, rsp.getInstructions().size());
+        assertEquals(Instruction.REACHED_VIA, rsp.getInstructions().createJson().get(0).get("sign"));
+        assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(1).get("sign"));
+    }
+
+    @Test
+    public void testMonacoEnforcedDirection()
+    {
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(43.741069, 7.426854), 0.).
+                addPoint(new GHPoint(43.744445, 7.429483), 190.).
+                setVehicle(vehicle).setWeighting("fastest");
+        req.getHints().put("heading_penalty", "300");
+        GHResponse rsp = hopper.route(req);
+
+        assertEquals(873., rsp.getDistance(), 10.);
+        assertEquals(33, rsp.getPoints().getSize());
+    }
+
+    @Test
+    public void testMonacoStraightVia()
+    {
+        GHRequest rq = new GHRequest().
+                addPoint(new GHPoint(43.741069, 7.426854)).
+                addPoint(new GHPoint(43.740371, 7.426946)).
+                addPoint(new GHPoint(43.740794, 7.427294)).
+                setVehicle(vehicle).setWeighting("fastest");
+        rq.getHints().put("pass_through", true);
+        GHResponse rsp = hopper.route(rq);
+
+        assertEquals(297, rsp.getDistance(), 5.);
+        assertEquals(27, rsp.getPoints().getSize());
+    }
+
+    @Test
+    public void testSRTMWithInstructions() throws Exception
+    {
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(osmFile).
+                setCHEnable(false).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(importVehicles));
+
+        tmpHopper.setElevationProvider(new SRTMProvider().setCacheDir(new File("./files/")));
+        tmpHopper.importOrLoad();
+
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.730729, 7.421288, 43.727697, 7.419199).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+
+        assertEquals(1626.8, rsp.getDistance(), .1);
+        assertEquals(60, rsp.getPoints().getSize());
+        assertTrue(rsp.getPoints().is3D());
+
+        InstructionList il = rsp.getInstructions();
+        assertEquals(10, il.size());
+        assertTrue(il.get(0).getPoints().is3D());
+
+        String str = rsp.getPoints().toString();
+        assertEquals("(43.73068455771767,7.421283689825812,62.0), (43.73067957305937,7.421382123709815,66.0), "
+                + "(43.73109792316924,7.421546222751131,45.0), (43.73129908884985,7.421589994913116,45.0), "
+                + "(43.731327028527716,7.421414533736137,45.0), (43.73125047381037,7.421366291225693,45.0), "
+                + "(43.73125457162979,7.421274090288746,52.0), "
+                + "(43.73128213877862,7.421115579183003,52.0), (43.731362232521825,7.421145381506057,52.0), "
+                + "(43.731371359483255,7.421123216028286,52.0), (43.731485725897976,7.42117332118392,52.0), "
+                + "(43.731575132867135,7.420868778695214,52.0), (43.73160605277731,7.420824820268709,52.0), "
+                + "(43.7316401391843,7.420850152243305,52.0), (43.731674039326776,7.421050014072285,52.0)",
+                str.substring(0, 662));
+
+        assertEquals("(43.727778875703635,7.418772930326453,11.0), (43.72768239068275,7.419007064826944,11.0), "
+                + "(43.727680946587874,7.419198768422206,11.0)",
+                str.substring(str.length() - 132));
+
+        List<GPXEntry> list = rsp.getInstructions().createGPXList();
+        assertEquals(60, list.size());
+        final long lastEntryMillis = list.get(list.size() - 1).getTime();
+        assertEquals(new GPXEntry(43.73068455771767, 7.421283689825812, 62.0, 0), list.get(0));
+        assertEquals(new GPXEntry(43.727680946587874, 7.4191987684222065, 11.0, lastEntryMillis), list.get(list.size() - 1));
+
+        assertEquals(62, il.createGPXList().get(0).getElevation(), 1e-2);
+        assertEquals(66, il.createGPXList().get(1).getElevation(), 1e-2);
+        assertEquals(52, il.createGPXList().get(10).getElevation(), 1e-2);
+    }
+
+    @Test
+    public void testKremsCyclewayInstructionsWithWayTypeInfo()
+    {
+        String tmpOsmFile = "files/krems.osm.gz";
+        String tmpVehicle = "BIKE";
+        String tmpImportVehicles = "CAR,BIKE";
+        String tmpWeightCalcStr = "fastest";
+
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(tmpOsmFile).
+                setCHEnable(false).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                importOrLoad();
+
+        GHResponse rsp = tmpHopper.route(new GHRequest(48.410987, 15.599492, 48.383419, 15.659294).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+
+        assertEquals(6932.24, rsp.getDistance(), .1);
+        assertEquals(110, rsp.getPoints().getSize());
+
+        InstructionList il = rsp.getInstructions();
+        assertEquals(19, il.size());
+        List<Map<String, Object>> resultJson = il.createJson();
+
+        assertEquals("Continue onto Obere Landstrae", resultJson.get(0).get("text"));
+        assertEquals("get off the bike", resultJson.get(0).get("annotation_text"));
+        assertEquals("Turn left onto Kirchengasse", resultJson.get(1).get("text"));
+        assertEquals("get off the bike", resultJson.get(1).get("annotation_text"));
+
+        assertEquals("Turn right onto Pfarrplatz", resultJson.get(2).get("text"));
+        assertEquals("Turn right onto Margarethenstrae", resultJson.get(3).get("text"));
+        assertEquals("Turn slight left onto Hoher Markt", resultJson.get(4).get("text"));
+        assertEquals("Turn right onto Wegscheid", resultJson.get(5).get("text"));
+        assertEquals("Turn slight left onto Untere Landstrae", resultJson.get(6).get("text"));
+        assertEquals("Turn right onto Ringstrae, L73", resultJson.get(7).get("text"));
+        assertEquals("Continue onto Eyblparkstrae", resultJson.get(8).get("text"));
+        assertEquals("Turn slight left onto Austrae", resultJson.get(9).get("text"));
+        assertEquals("Turn slight left onto Rechte Kremszeile", resultJson.get(10).get("text"));
+        //..
+        assertEquals("Turn right onto Treppelweg", resultJson.get(15).get("text"));
+        assertEquals("cycleway", resultJson.get(15).get("annotation_text"));
+    }
+
+    @Test
+    public void testRoundaboutInstructionsWithCH()
+    {
+        String tmpOsmFile = "files/monaco.osm.gz";
+        String tmpVehicle = "car";
+        String tmpImportVehicles = "car,bike";
+        String tmpWeightCalcStr = "fastest";
+
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(tmpOsmFile).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                importOrLoad();
+
+        assertEquals(tmpVehicle, tmpHopper.getDefaultVehicle().toString());
+        assertFalse(RoutingAlgorithmFactorySimple.class.isAssignableFrom(tmpHopper.getAlgorithmFactory().getClass()));
+
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.745084, 7.430513, 43.745247, 7.430347)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(2, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
+
+        rsp = tmpHopper.route(new GHRequest(43.745968, 7.42907, 43.745832, 7.428614)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(2, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
+
+        rsp = tmpHopper.route(new GHRequest(43.745948, 7.42914, 43.746173, 7.428834)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(1, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
+
+        rsp = tmpHopper.route(new GHRequest(43.735817, 7.417096, 43.735666, 7.416587)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(2, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
+    }
+
+    @Test
+    public void testMultipleVehiclesAndDoCHForBike()
+    {
+        String tmpOsmFile = "files/monaco.osm.gz";
+        String tmpImportVehicles = "bike,car";
+
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(tmpOsmFile).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                importOrLoad();
+        assertEquals("bike", tmpHopper.getDefaultVehicle().toString());
+
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
+                .setVehicle("car"));
+        assertEquals(207, rsp.getTime() / 1000f, 1);
+        assertEquals(2838, rsp.getDistance(), 1);
+
+        rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
+                .setVehicle("bike"));
+        assertEquals(494, rsp.getTime() / 1000f, 1);
+        assertEquals(2192, rsp.getDistance(), 1);
+
+        rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
+                .setVehicle("foot"));
+        assertTrue("only bike and car were imported. foot request should fail", rsp.hasErrors());
+    }
+
+    @Test
+    public void testIfCHIsUsed() throws Exception
+    {
+        // route directly after import
+        executeCHFootRoute();
+
+        // now only load is called
+        executeCHFootRoute();
+    }
+
+    private void executeCHFootRoute()
+    {
+        String tmpOsmFile = "files/monaco.osm.gz";
+        String tmpImportVehicles = "foot";
+
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(tmpOsmFile).
+                setCHWeighting(weightCalcStr).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                importOrLoad();
+
+        // same query as in testMonacoWithInstructions
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.727687, 7.418737, 43.74958, 7.436566).
+                setVehicle(vehicle));
+
+        // identify the number of counts to compare with none-CH foot route which had nearly 700 counts
+        long sum = rsp.getHints().getLong("visited_nodes.sum", 0);
+        assertNotEquals(sum, 0);
+        assertTrue("Too many nodes visited " + sum, sum < 120);
+        assertEquals(3437.6, rsp.getDistance(), .1);
+        assertEquals(89, rsp.getPoints().getSize());
+        tmpHopper.close();
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index d30f92da68..62b1d02bed 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -18,25 +18,32 @@
 package com.graphhopper;
 
 import com.graphhopper.reader.DataReader;
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.RoutingAlgorithmFactory;
+import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.shapes.GHPoint;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
 import java.io.File;
 import java.io.IOException;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
-import org.junit.After;
-import org.junit.Test;
+
 import static org.junit.Assert.*;
-import org.junit.Before;
 
 /**
- *
  * @author Peter Karich
  */
 public class GraphHopperTest
@@ -68,22 +75,23 @@ public void testLoadOSM()
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         closableInstance.importOrLoad();
-        GHResponse ph = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
+        GHResponse rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
 
         closableInstance.close();
-        closableInstance = new GraphHopper().setStoreOnFlush(true).
-                setEncodingManager(new EncodingManager("CAR"));
+
+        // no encoding manager necessary
+        closableInstance = new GraphHopper().setStoreOnFlush(true);
         assertTrue(closableInstance.load(ghLoc));
-        ph = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
+        rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
 
         closableInstance.close();
         try
         {
-            ph = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+            rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
             assertTrue(false);
         } catch (Exception ex)
         {
@@ -109,18 +117,18 @@ public void testLoadOSMNoCH()
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         gh.importOrLoad();
-        GHResponse ph = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
+        GHResponse rsp = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
 
         gh.close();
         gh = new GraphHopper().setStoreOnFlush(true).
                 setCHEnable(false).
                 setEncodingManager(new EncodingManager("CAR"));
         assertTrue(gh.load(ghLoc));
-        ph = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
+        rsp = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
 
         gh.close();
     }
@@ -226,10 +234,11 @@ public void testPrepare()
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         instance.importOrLoad();
-        GHResponse ph = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).setAlgorithm("dijkstrabi"));
-        assertTrue(ph.isFound());
-        assertEquals("(51.24921503475044,9.431716451757769), (52.0,9.0), (51.199999850988384,9.39999970197677)", ph.getPoints().toString());
-        assertEquals(3, ph.getPoints().getSize());
+        GHResponse rsp = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).
+                setAlgorithm(AlgorithmOptions.DIJKSTRA_BI));
+        assertFalse(rsp.hasErrors());
+        assertEquals(Helper.createPointList(51.249215, 9.431716, 52.0, 9.0, 51.2, 9.4), rsp.getPoints());
+        assertEquals(3, rsp.getPoints().getSize());
     }
 
     @Test
@@ -242,12 +251,23 @@ public void testSortedGraph_noCH()
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         instance.importOrLoad();
-        GHResponse ph = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).setAlgorithm("dijkstrabi"));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
-        assertEquals(new GHPoint(51.24921503475044, 9.431716451757769), ph.getPoints().toGHPoint(0));
-        assertEquals(new GHPoint(52.0, 9.0), ph.getPoints().toGHPoint(1));
-        assertEquals(new GHPoint(51.199999850988384, 9.39999970197677), ph.getPoints().toGHPoint(2));
+        GHResponse rsp = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).
+                setAlgorithm(AlgorithmOptions.DIJKSTRA_BI));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
+        assertEquals(new GHPoint(51.24921503475044, 9.431716451757769), rsp.getPoints().toGHPoint(0));
+        assertEquals(new GHPoint(52.0, 9.0), rsp.getPoints().toGHPoint(1));
+        assertEquals(new GHPoint(51.199999850988384, 9.39999970197677), rsp.getPoints().toGHPoint(2));
+
+        GHRequest req = new GHRequest(51.2492152, 9.4317166, 51.2, 9.4);
+        boolean old = instance.enableInstructions;
+        req.getHints().put("instructions", true);
+        instance.route(req);
+        assertEquals(old, instance.enableInstructions);
+
+        req.getHints().put("instructions", false);
+        instance.route(req);
+        assertEquals("route method should not change instance field", old, instance.enableInstructions);
     }
 
     @Test
@@ -262,36 +282,36 @@ public void testFootAndCar()
         instance.importOrLoad();
 
         assertEquals(5, instance.getGraph().getNodes());
-        assertEquals(8, instance.getGraph().getAllEdges().getMaxId());
+        assertEquals(8, instance.getGraph().getAllEdges().getCount());
 
         // A to D
-        GHResponse res = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.CAR));
-        assertFalse(res.hasErrors());
-        assertTrue(res.isFound());
-        assertEquals(3, res.getPoints().getSize());
+        GHResponse rsp = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.CAR));
+        assertFalse(rsp.hasErrors());
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
         // => found A and D
-        assertEquals(50, res.getPoints().getLongitude(0), 1e-3);
-        assertEquals(11.1, res.getPoints().getLatitude(0), 1e-3);
-        assertEquals(51, res.getPoints().getLongitude(2), 1e-3);
-        assertEquals(11.3, res.getPoints().getLatitude(2), 1e-3);
+        assertEquals(50, rsp.getPoints().getLongitude(0), 1e-3);
+        assertEquals(11.1, rsp.getPoints().getLatitude(0), 1e-3);
+        assertEquals(51, rsp.getPoints().getLongitude(2), 1e-3);
+        assertEquals(11.3, rsp.getPoints().getLatitude(2), 1e-3);
 
         // A to D not allowed for foot. But the location index will choose a node close to D accessible to FOOT        
-        res = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.FOOT));
-        assertTrue(res.isFound());
-        assertEquals(2, res.getPoints().getSize());
+        rsp = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.FOOT));
+        assertFalse(rsp.hasErrors());
+        assertEquals(2, rsp.getPoints().getSize());
         // => found a point on edge A-B        
-        assertEquals(11.680, res.getPoints().getLatitude(1), 1e-3);
-        assertEquals(50.644, res.getPoints().getLongitude(1), 1e-3);
+        assertEquals(11.680, rsp.getPoints().getLatitude(1), 1e-3);
+        assertEquals(50.644, rsp.getPoints().getLongitude(1), 1e-3);
 
         // A to E only for foot
-        res = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.FOOT));
-        assertTrue(res.isFound());
-        assertEquals(3, res.getPoints().size());
+        rsp = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.FOOT));
+        assertFalse(rsp.hasErrors());
+        assertEquals(2, rsp.getPoints().size());
 
         // A D E for car
-        res = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.CAR));
-        assertTrue(res.isFound());
-        assertEquals(4, res.getPoints().getSize());
+        rsp = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.CAR));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
     }
 
     @Test
@@ -308,31 +328,36 @@ public void testFailsForWrongConfig() throws IOException
         assertEquals(5, instance.getGraph().getNodes());
         instance.close();
 
-        instance = new GraphHopper().init(
-                new CmdArgs().
-                put("osmreader.osm", testOsm3).
-                put("osmreader.dataaccess", "RAM").
-                put("graph.flagEncoders", "FOOT").
-                put("prepare.chWeighting", "no")).
-                setOSMFile(testOsm3);
+        // different config (flagEncoder list)
         try
         {
-            instance.load(ghLoc);
+            GraphHopper tmpGH = new GraphHopper().init(
+                    new CmdArgs().
+                    put("osmreader.osm", testOsm3).
+                    put("osmreader.dataaccess", "RAM").
+                    put("graph.flagEncoders", "FOOT").
+                    put("prepare.chWeighting", "no")).
+                    setOSMFile(testOsm3);
+            tmpGH.load(ghLoc);
             assertTrue(false);
         } catch (Exception ex)
         {
         }
 
-        // different order should be ok
-        instance = new GraphHopper().init(
-                new CmdArgs().
-                put("osmreader.osm", testOsm3).
-                put("osmreader.dataaccess", "RAM").
-                put("prepare.chWeighting", "no").
-                put("graph.flagEncoders", "CAR,FOOT")).
-                setOSMFile(testOsm3);
-        assertTrue(instance.load(ghLoc));
-        assertEquals(5, instance.getGraph().getNodes());
+        // different order is no longer okay, see #350
+        try
+        {
+            GraphHopper tmpGH = new GraphHopper().init(new CmdArgs().
+                    put("osmreader.osm", testOsm3).
+                    put("osmreader.dataaccess", "RAM").
+                    put("prepare.chWeighting", "no").
+                    put("graph.flagEncoders", "CAR,FOOT")).
+                    setOSMFile(testOsm3);
+            tmpGH.load(ghLoc);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
     }
 
     @Test
@@ -434,11 +459,11 @@ public void testFootOnly()
         instance.importOrLoad();
 
         assertEquals(2, instance.getGraph().getNodes());
-        assertEquals(2, instance.getGraph().getAllEdges().getMaxId());
+        assertEquals(2, instance.getGraph().getAllEdges().getCount());
 
         // A to E only for foot
         GHResponse res = instance.route(new GHRequest(11.1, 50, 11.2, 52).setVehicle(EncodingManager.FOOT));
-        assertTrue(res.isFound());
+        assertFalse(res.hasErrors());
         assertEquals(3, res.getPoints().getSize());
     }
 
@@ -486,7 +511,7 @@ public void testVia()
                 init(new CmdArgs().
                         put("osmreader.osm", testOsm3).
                         put("prepare.minNetworkSize", "1").
-                        put("graph.acceptWay", "CAR")).
+                        put("graph.flagEncoders", "CAR")).
                 setGraphHopperLocation(ghLoc);
         instance.importOrLoad();
 
@@ -495,19 +520,244 @@ public void testVia()
         GHPoint second = new GHPoint(12, 51);
         GHPoint third = new GHPoint(11.2, 51.9);
         GHResponse rsp12 = instance.route(new GHRequest().addPoint(first).addPoint(second));
-        assertTrue("should find 1->2", rsp12.isFound());
-        assertEquals(147931.5, rsp12.getDistance(), .1);
+        assertFalse("should find 1->2", rsp12.hasErrors());
+        assertEquals(147930.5, rsp12.getDistance(), .1);
         GHResponse rsp23 = instance.route(new GHRequest().addPoint(second).addPoint(third));
-        assertTrue("should find 2->3", rsp23.isFound());
+        assertFalse("should find 2->3", rsp23.hasErrors());
         assertEquals(176608.9, rsp23.getDistance(), .1);
 
         GHResponse rsp = instance.route(new GHRequest().addPoint(first).addPoint(second).addPoint(third));
 
         assertFalse(rsp.hasErrors());
-        assertTrue("should find 1->2->3", rsp.isFound());
+        assertFalse("should find 1->2->3", rsp.hasErrors());
         assertEquals(rsp12.getDistance() + rsp23.getDistance(), rsp.getDistance(), 1e-6);
         assertEquals(5, rsp.getPoints().getSize());
         assertEquals(5, rsp.getInstructions().size());
         assertEquals(Instruction.REACHED_VIA, rsp.getInstructions().get(1).getSign());
     }
+
+    @Test
+    public void testGetPathsDirectionEnforcement1()
+    {
+        // Test enforce start direction
+        // Note: This Test does not pass for CH enabled    
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // Start in middle of edge 4-5 
+        GHPoint start = new GHPoint(0.0015, 0.002);
+        // End at middle of edge 2-3
+        GHPoint end = new GHPoint(0.002, 0.0005);
+
+        // Test enforce south start direction; expected nodes (9)-5-8-3-(10)
+        GHRequest req = new GHRequest().addPoint(start, 180.).addPoint(end);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            9, 5, 8, 3, 10
+        }, paths.get(0).calcNodes().toArray());
+    }
+
+    @Test
+    public void testGetPathsDirectionEnforcement2()
+    {
+        // Test enforce start & end direction
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // Start in middle of edge 4-5 
+        GHPoint start = new GHPoint(0.0015, 0.002);
+        // End at middle of edge 2-3
+        GHPoint end = new GHPoint(0.002, 0.0005);
+
+        // Test enforce south start direction and east end direction ; expected nodes (9)-5-8-1-2-(10)
+        GHRequest req = new GHRequest().addPoint(start, 180.).addPoint(end, 90.);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            9, 5, 8, 1, 2, 10
+        }, paths.get(0).calcNodes().toArray());
+
+        // Test uni-directional case
+        req.setAlgorithm(AlgorithmOptions.DIJKSTRA);
+        response = new GHResponse();
+        paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            9, 5, 8, 1, 2, 10
+        }, paths.get(0).calcNodes().toArray());
+    }
+
+    @Test
+    public void testGetPathsDirectionEnforcement3()
+    {
+        // Test enforce via direction
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // Start in middle of edge 4-5 
+        GHPoint start = new GHPoint(0.0015, 0.002);
+        // End at middle of edge 2-3
+        GHPoint end = new GHPoint(0.002, 0.0005);
+        // Via Point betweeen 8-7
+        GHPoint via = new GHPoint(0.0005, 0.001);
+
+        GHRequest req = new GHRequest().addPoint(start).addPoint(via, 0.).addPoint(end);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            10, 5, 6, 7, 11
+        }, paths.get(0).calcNodes().toArray());
+    }
+
+    @Test
+    public void testGetPathsDirectionEnforcement4()
+    {
+        // Test straight via routing
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // Start in middle of edge 4-5 
+        GHPoint start = new GHPoint(0.0015, 0.002);
+        // End at middle of edge 2-3
+        GHPoint end = new GHPoint(0.002, 0.0005);
+        // Via Point betweeen 8-3
+        GHPoint via = new GHPoint(0.0015, 0.001);
+        GHRequest req = new GHRequest().addPoint(start).addPoint(via).addPoint(end);
+        req.getHints().put("pass_through", true);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            10, 4, 3, 11
+        }, paths.get(0).calcNodes().toArray());
+        assertArrayEquals(new int[]
+        {
+            11, 8, 1, 2, 9
+        }, paths.get(1).calcNodes().toArray());
+    }
+
+    @Test
+    public void testGetPathsDirectionEnforcement5()
+    {
+        // Test independence of previous enforcement for subsequent pathes
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // Start in middle of edge 4-5 
+        GHPoint start = new GHPoint(0.0015, 0.002);
+        // End at middle of edge 2-3
+        GHPoint end = new GHPoint(0.002, 0.0005);
+        // First go south and than come from west to via-point at 7-6. Then go back over previously punished (11)-4 edge
+        GHPoint via = new GHPoint(0.000, 0.0015);
+        GHRequest req = new GHRequest().addPoint(start, 0.).addPoint(via, 3.14 / 2).addPoint(end);
+        req.getHints().put("pass_through", true);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            10, 4, 3, 8, 7, 9
+        }, paths.get(0).calcNodes().toArray());
+        assertArrayEquals(new int[]
+        {
+            9, 6, 5, 10, 4, 3, 11
+        }, paths.get(1).calcNodes().toArray());
+    }
+
+    @Test
+    public void testGetPathsDirectionEnforcement6()
+    {
+        // Test if query results at tower nodes are ignored
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // QueryPoints directly on TowerNodes 
+        GHPoint start = new GHPoint(0, 0);
+        GHPoint via = new GHPoint(0.002, 0.000);
+        GHPoint end = new GHPoint(0.002, 0.002);
+
+        GHRequest req = new GHRequest().addPoint(start, 90.).addPoint(via, 270.).addPoint(end, 270.);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            0, 1, 2
+        }, paths.get(0).calcNodes().toArray());
+        assertArrayEquals(new int[]
+        {
+            2, 3, 4
+        }, paths.get(1).calcNodes().toArray());
+
+    }
+
+    private GraphHopper initSquareGraphInstance( boolean withCH )
+    {
+        EncodingManager encodingManager = new EncodingManager("car");
+
+        GraphStorage g;
+        if (withCH)
+        {
+            g = new LevelGraphStorage(new RAMDirectory(), encodingManager, false).create(20);
+        } else
+        {
+            g = new GraphHopperStorage(new RAMDirectory(), encodingManager, false).create(20);
+        }
+
+        //   2---3---4
+        //  /    |    \
+        //  1----8----5
+        //  /    |    /
+        //  0----7---6
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0.000, 0.000);
+        na.setNode(1, 0.001, 0.000);
+        na.setNode(2, 0.002, 0.000);
+        na.setNode(3, 0.002, 0.001);
+        na.setNode(4, 0.002, 0.002);
+        na.setNode(5, 0.001, 0.002);
+        na.setNode(6, 0.000, 0.002);
+        na.setNode(7, 0.000, 0.001);
+        na.setNode(8, 0.001, 0.001);
+
+        g.edge(0, 1, 100, true);
+        g.edge(1, 2, 100, true);
+        g.edge(2, 3, 100, true);
+        g.edge(3, 4, 100, true);
+        g.edge(4, 5, 100, true);
+        g.edge(5, 6, 100, true);
+        g.edge(6, 7, 100, true);
+        g.edge(7, 0, 100, true);
+
+        g.edge(1, 8, 110, true);
+        g.edge(3, 8, 110, true);
+        g.edge(5, 8, 110, true);
+        g.edge(7, 8, 110, true);
+
+        instance = new GraphHopper().
+                setCHEnable(withCH).
+                setCHWeighting("fastest").
+                setEncodingManager(encodingManager);
+        instance.setGraph(g);
+        instance.postProcessing();        
+
+        return instance;
+    }
+
+    @Test
+    public void testCustomFactoryForNoneCH()
+    {
+        GraphHopper closableInstance = new GraphHopper().setStoreOnFlush(true).
+                setCHEnable(false).
+                setEncodingManager(new EncodingManager("CAR")).
+                setGraphHopperLocation(ghLoc).
+                setOSMFile(testOsm);
+        RoutingAlgorithmFactory af = new RoutingAlgorithmFactorySimple();
+        closableInstance.setAlgorithmFactory(af);
+        closableInstance.importOrLoad();
+
+        assertTrue(af == closableInstance.getAlgorithmFactory());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java b/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
index 803d4d751d..5cc1e82fa4 100644
--- a/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
@@ -17,15 +17,17 @@
  */
 package com.graphhopper.coll;
 
-import com.graphhopper.storage.Edge;
+import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.EdgeIterator;
+
 import java.util.PriorityQueue;
 import java.util.Random;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public abstract class AbstractBinHeapTest
@@ -123,7 +125,7 @@ public void testRekey()
     @Test
     public void testSize()
     {
-        PriorityQueue<Edge> juQueue = new PriorityQueue<Edge>(100);
+        PriorityQueue<EdgeEntry> juQueue = new PriorityQueue<EdgeEntry>(100);
         BinHeapWrapper<Number, Integer> binHeap = createHeap(100);
 
         Random rand = new Random(1);
@@ -132,7 +134,7 @@ public void testSize()
         {
             int val = rand.nextInt();
             binHeap.insert(val, i);
-            juQueue.add(new Edge(EdgeIterator.NO_EDGE, i, val));
+            juQueue.add(new EdgeEntry(EdgeIterator.NO_EDGE, i, val));
         }
 
         assertEquals(juQueue.size(), binHeap.getSize());
diff --git a/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java b/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java
index 7a319c30c9..f923f29e0a 100644
--- a/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java
+++ b/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.coll;
 
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public abstract class AbstractMyBitSetTest
diff --git a/core/src/test/java/com/graphhopper/coll/BigLongIntMapTest.java b/core/src/test/java/com/graphhopper/coll/BigLongIntMapTest.java
index cf047c82b4..d5904de16f 100644
--- a/core/src/test/java/com/graphhopper/coll/BigLongIntMapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/BigLongIntMapTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.coll;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class BigLongIntMapTest
diff --git a/core/src/test/java/com/graphhopper/coll/BitSetImplTest.java b/core/src/test/java/com/graphhopper/coll/BitSetImplTest.java
index c88cd05eaf..51471ab1e6 100644
--- a/core/src/test/java/com/graphhopper/coll/BitSetImplTest.java
+++ b/core/src/test/java/com/graphhopper/coll/BitSetImplTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.coll;
 
 /**
- *
  * @author Peter Karich
  */
 public class BitSetImplTest extends AbstractMyBitSetTest
diff --git a/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java b/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
index 359acc5890..4f13821970 100644
--- a/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
+++ b/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
@@ -18,12 +18,14 @@
 package com.graphhopper.coll;
 
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.Random;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class CompressedArrayTest
diff --git a/core/src/test/java/com/graphhopper/coll/GHLongIntBTreeTest.java b/core/src/test/java/com/graphhopper/coll/GHLongIntBTreeTest.java
index 14c923e0e6..33f2582f5f 100644
--- a/core/src/test/java/com/graphhopper/coll/GHLongIntBTreeTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHLongIntBTreeTest.java
@@ -20,11 +20,12 @@
 import java.util.LinkedHashSet;
 import java.util.Random;
 import java.util.Set;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHLongIntBTreeTest
diff --git a/core/src/test/java/com/graphhopper/coll/GHSortedCollectionTest.java b/core/src/test/java/com/graphhopper/coll/GHSortedCollectionTest.java
index c5d9692d1a..890b0253fb 100644
--- a/core/src/test/java/com/graphhopper/coll/GHSortedCollectionTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHSortedCollectionTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.coll;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHSortedCollectionTest
diff --git a/core/src/test/java/com/graphhopper/coll/GHTBitSetTest.java b/core/src/test/java/com/graphhopper/coll/GHTBitSetTest.java
index 3af8c5672e..9a3c8bc4e6 100644
--- a/core/src/test/java/com/graphhopper/coll/GHTBitSetTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHTBitSetTest.java
@@ -20,7 +20,6 @@
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHTBitSetTest extends AbstractMyBitSetTest
diff --git a/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java b/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
index edf15886b1..f5ea5511d4 100644
--- a/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.coll;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHTreeMapComposedTest
diff --git a/core/src/test/java/com/graphhopper/coll/IntDoubleBinHeapTest.java b/core/src/test/java/com/graphhopper/coll/IntDoubleBinHeapTest.java
index c63edcfbf5..6f7109aee5 100644
--- a/core/src/test/java/com/graphhopper/coll/IntDoubleBinHeapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/IntDoubleBinHeapTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.coll;
 
 /**
- *
  * @author Peter Karich
  */
 public class IntDoubleBinHeapTest extends AbstractBinHeapTest
diff --git a/core/src/test/java/com/graphhopper/coll/IntIntBinHeapTest.java b/core/src/test/java/com/graphhopper/coll/IntIntBinHeapTest.java
index 21ec8aae4e..a755752b45 100644
--- a/core/src/test/java/com/graphhopper/coll/IntIntBinHeapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/IntIntBinHeapTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.coll;
 
 /**
- *
  * @author Peter Karich
  */
 public class IntIntBinHeapTest extends AbstractBinHeapTest
diff --git a/core/src/test/java/com/graphhopper/coll/OSMIDMapTest.java b/core/src/test/java/com/graphhopper/coll/OSMIDMapTest.java
index bf62ab9c80..1acc36741b 100644
--- a/core/src/test/java/com/graphhopper/coll/OSMIDMapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/OSMIDMapTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.RAMDirectory;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class OSMIDMapTest
diff --git a/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java b/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java
index cdb07c9544..fec5f54f3b 100644
--- a/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.coll;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class OSMIDSegmentedMapTest
diff --git a/core/src/test/java/com/graphhopper/coll/SparseLongLongArrayTest.java b/core/src/test/java/com/graphhopper/coll/SparseLongLongArrayTest.java
index 9643af641b..cb11ee8218 100644
--- a/core/src/test/java/com/graphhopper/coll/SparseLongLongArrayTest.java
+++ b/core/src/test/java/com/graphhopper/coll/SparseLongLongArrayTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.coll;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
@@ -29,17 +30,17 @@
     public void testBinarySearch()
     {
         long a[] = new long[]
-        {
-            9, 53, 100
-        };
+                {
+                        9, 53, 100
+                };
         assertEquals(~1, SparseLongLongArray.binarySearch(a, 0, 3, 50));
         assertEquals(~2, SparseLongLongArray.binarySearch(a, 0, 3, 55));
         assertEquals(~3, SparseLongLongArray.binarySearch(a, 0, 3, 155));
 
         a = new long[]
-        {
-            9
-        };
+                {
+                        9
+                };
         assertEquals(~0, SparseLongLongArray.binarySearch(a, 0, 1, 5));
         assertEquals(~1, SparseLongLongArray.binarySearch(a, 0, 1, 50));
     }
diff --git a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
index cb8e34888f..54ec767ac4 100644
--- a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
+++ b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
@@ -17,8 +17,11 @@
  */
 package com.graphhopper.geohash;
 
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
@@ -67,4 +70,22 @@ public void testDecode()
         assertEquals(16.3333333, latLon.lat, 1e-7);
         assertEquals(5.25, latLon.lon, 1e-7);
     }
+
+    /*
+    * Test if different constructors yield same results
+     */
+    @Test
+    public void testInstantiation()
+    {
+        double minLon = 0;
+        double minLat = 2;
+        double maxLat = 6;
+        double maxLon = 5;
+
+        BBox bounds = new BBox(minLon, maxLon, minLat, maxLat);
+        LinearKeyAlgo algo1 = new LinearKeyAlgo(4, 4).setBounds(bounds);
+        LinearKeyAlgo algo2 = new LinearKeyAlgo(4, 4).setBounds(minLon, maxLon, minLat, maxLat);
+        assertEquals(algo1.getLonDelta(), algo2.getLonDelta(), 1e-7);
+        assertEquals(algo1.getLatDelta(), algo2.getLatDelta(), 1e-7);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java b/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
index ca681b6bcd..ff4b3eb0b9 100644
--- a/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
+++ b/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
@@ -21,10 +21,10 @@
 import com.graphhopper.util.DistanceCalcEarth;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class SpatialKeyAlgoTest
@@ -233,9 +233,10 @@ public void testDifferentInitialBounds()
         algo.decode(1, coord);
         assertEquals(1, algo.encode(coord));
     }
-    
+
     @Test
-    public void testEdgeCases() {
+    public void testEdgeCases()
+    {
         double minLon = -1, maxLon = 1.6;
         double minLat = -1, maxLat = 0.5;
         int parts = 4;
diff --git a/core/src/test/java/com/graphhopper/reader/OSMElementTest.java b/core/src/test/java/com/graphhopper/reader/OSMElementTest.java
index ec6753870c..f1b7e610e0 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMElementTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMElementTest.java
@@ -19,11 +19,12 @@
 
 import java.util.HashMap;
 import java.util.Map;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class OSMElementTest
diff --git a/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java b/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java
index ff3610c9ae..4218bafe13 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java
@@ -19,10 +19,10 @@
 package com.graphhopper.reader;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class OSMNodeTest
diff --git a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
index b07039edda..dd643722af 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.reader;
 
 import static org.junit.Assert.*;
+
 import gnu.trove.list.TLongList;
 
 import java.io.File;
@@ -38,14 +39,7 @@
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.AbstractGraphStorageTester;
-import com.graphhopper.storage.ExtendedStorage;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.RAMDirectory;
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
@@ -53,6 +47,8 @@
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
 
+import java.util.*;
+
 /**
  * Tests the OSMReader with the normal helper initialized.
  * <p/>
@@ -89,7 +85,7 @@ public void tearDown()
     GraphStorage newGraph( String directory, EncodingManager encodingManager, boolean is3D, boolean turnRestrictionsImport )
     {
         return new GraphHopperStorage(new RAMDirectory(directory, false), encodingManager,
-                is3D, turnRestrictionsImport ? new TurnCostStorage() : new ExtendedStorage.NoExtendedStorage());
+                is3D, turnRestrictionsImport ? new TurnCostExtension() : new GraphExtension.NoExtendedStorage());
     }
 
     class GraphHopperTest extends GraphHopper
@@ -178,8 +174,8 @@ public void testMain()
         assertEquals(n50, iter.getAdjNode());
         AbstractGraphStorageTester.assertPList(Helper.createPointList(51.25, 9.43), iter.fetchWayGeometry(0));
         FlagEncoder flags = carEncoder;
-        assertTrue(flags.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(flags.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertTrue(flags.isForward(iter.getFlags()));
+        assertTrue(flags.isBackward(iter.getFlags()));
 
         assertTrue(iter.next());
         assertEquals("route 666", iter.getName());
@@ -191,8 +187,8 @@ public void testMain()
         assertEquals(n10, iter.getAdjNode());
         assertEquals(88643, iter.getDistance(), 1);
 
-        assertTrue(flags.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(flags.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertTrue(flags.isForward(iter.getFlags()));
+        assertTrue(flags.isBackward(iter.getFlags()));
         assertFalse(iter.next());
 
         // get third added location id=30
@@ -298,27 +294,27 @@ public void testOneWay()
         iter = carAllExplorer.setBaseNode(n20);
         assertTrue(iter.next());
         assertEquals(n23, iter.getAdjNode());
-        assertTrue(encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertFalse(encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(iter.getFlags()));
+        assertFalse(encoder.isBackward(iter.getFlags()));
 
         assertTrue(iter.next());
         assertEquals(n22, iter.getAdjNode());
-        assertFalse(encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertFalse(encoder.isForward(iter.getFlags()));
+        assertTrue(encoder.isBackward(iter.getFlags()));
 
         assertTrue(iter.next());
-        assertFalse(encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertFalse(encoder.isForward(iter.getFlags()));
+        assertTrue(encoder.isBackward(iter.getFlags()));
 
         assertTrue(iter.next());
         assertEquals(n30, iter.getAdjNode());
-        assertTrue(encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertFalse(encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(iter.getFlags()));
+        assertFalse(encoder.isBackward(iter.getFlags()));
 
         assertTrue(iter.next());
         assertEquals(n10, iter.getAdjNode());
-        assertFalse(encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertFalse(encoder.isForward(iter.getFlags()));
+        assertTrue(encoder.isBackward(iter.getFlags()));
     }
 
     @Test
@@ -523,14 +519,18 @@ public void testTurnRestrictions()
                 importOrLoad();
         GraphStorage graph = hopper.getGraph();
         assertEquals(15, graph.getNodes());
-        assertTrue(graph.getExtendedStorage() instanceof TurnCostStorage);
-        TurnCostStorage tcStorage = (TurnCostStorage) graph.getExtendedStorage();
-        
+        assertTrue(graph.getExtension() instanceof TurnCostExtension);
+        TurnCostExtension tcStorage = (TurnCostExtension) graph.getExtension();
+
+        int n1 = AbstractGraphStorageTester.getIdOf(graph, 50, 10);
         int n2 = AbstractGraphStorageTester.getIdOf(graph, 52, 10);
         int n3 = AbstractGraphStorageTester.getIdOf(graph, 52, 11);
         int n4 = AbstractGraphStorageTester.getIdOf(graph, 52, 12);
+        int n5 = AbstractGraphStorageTester.getIdOf(graph, 50, 12);
+        int n6 = AbstractGraphStorageTester.getIdOf(graph, 51, 11);
         int n8 = AbstractGraphStorageTester.getIdOf(graph, 54, 11);
 
+        int edge1_6 = GHUtility.getEdge(graph, n1, n6).getEdge();
         int edge2_3 = GHUtility.getEdge(graph, n2, n3).getEdge();
         int edge3_4 = GHUtility.getEdge(graph, n3, n4).getEdge();
         int edge3_8 = GHUtility.getEdge(graph, n3, n8).getEdge();
@@ -541,30 +541,30 @@ public void testTurnRestrictions()
 
         // (2-3)->(3-4) only_straight_on = (2-3)->(3-8) restricted
         // (4-3)->(3-8) no_right_turn = (4-3)->(3-8) restricted
-        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(n3, edge2_3, edge3_8)) > 0);
-        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(n3, edge4_3, edge3_8)) > 0);
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n3, edge2_3, edge3_4)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n3, edge2_3, edge3_2)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n3, edge2_3, edge3_4)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n3, edge4_3, edge3_2)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n3, edge8_3, edge3_2)));
-
-        int n1 = AbstractGraphStorageTester.getIdOf(graph, 50, 10);
-        int n5 = AbstractGraphStorageTester.getIdOf(graph, 50, 12);
-        int n6 = AbstractGraphStorageTester.getIdOf(graph, 51, 11);
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_8)) > 0);
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge4_3, n3, edge3_8)) > 0);
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_4)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_2)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_4)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge4_3, n3, edge3_2)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge8_3, n3, edge3_2)));
+
+        // u-turn restriction for (6-1)->(1-6) but not for (1-6)->(6-1)
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge1_6, n1, edge1_6)) > 0);
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge1_6, n6, edge1_6)));
 
         int edge4_5 = GHUtility.getEdge(graph, n4, n5).getEdge();
         int edge5_6 = GHUtility.getEdge(graph, n5, n6).getEdge();
         int edge5_1 = GHUtility.getEdge(graph, n5, n1).getEdge();
 
         // (4-5)->(5-1) right_turn_only = (4-5)->(5-6) restricted 
-        long costsFlags = tcStorage.getTurnCostFlags(n5, edge4_5, edge5_6);
+        long costsFlags = tcStorage.getTurnCostFlags(edge4_5, n5, edge5_6);
         assertFalse(carEncoder.isTurnRestricted(costsFlags));
-        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(n5, edge4_5, edge5_1)) > 0);
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge4_5, n5, edge5_1)) > 0);
 
         // for bike
         assertFalse(bikeEncoder.isTurnRestricted(costsFlags));
-        
+
         int n10 = AbstractGraphStorageTester.getIdOf(graph, 40, 10);
         int n11 = AbstractGraphStorageTester.getIdOf(graph, 40, 11);
         int n14 = AbstractGraphStorageTester.getIdOf(graph, 39, 11);
@@ -572,12 +572,12 @@ public void testTurnRestrictions()
         int edge10_11 = GHUtility.getEdge(graph, n10, n11).getEdge();
         int edge11_14 = GHUtility.getEdge(graph, n11, n14).getEdge();
 
-        assertEquals(0, tcStorage.getTurnCostFlags(n11, edge11_14, edge10_11));
+        assertEquals(0, tcStorage.getTurnCostFlags(edge11_14, n11, edge10_11));
 
-        costsFlags = tcStorage.getTurnCostFlags(n11, edge10_11, edge11_14);
+        costsFlags = tcStorage.getTurnCostFlags(edge10_11, n11, edge11_14);
         assertFalse(carEncoder.isTurnRestricted(costsFlags));
         assertTrue(bikeEncoder.isTurnRestricted(costsFlags));
-    }    
+    }
 
     @Test
     public void testEstimatedCenter()
@@ -704,4 +704,93 @@ public void testReadEleFromDataProvider()
         assertEquals(Helper.createPointList3D(49.501, 11.5001, 383.0, 49.5001, 11.501, 426.0),
                 edge.fetchWayGeometry(3));
     }
+
+    /**
+     * Tests the combination of different turn cost flags by different encoders.
+     */
+    @Test
+    public void testTurnFlagCombination()
+    {
+        final OSMTurnRelation.TurnCostTableEntry turnCostEntry_car = new OSMTurnRelation.TurnCostTableEntry();
+        final OSMTurnRelation.TurnCostTableEntry turnCostEntry_foot = new OSMTurnRelation.TurnCostTableEntry();
+        final OSMTurnRelation.TurnCostTableEntry turnCostEntry_bike = new OSMTurnRelation.TurnCostTableEntry();
+
+        CarFlagEncoder car = new CarFlagEncoder(5, 5, 24);
+        FootFlagEncoder foot = new FootFlagEncoder();
+        BikeFlagEncoder bike = new BikeFlagEncoder(4, 2, 24);
+        EncodingManager manager = new EncodingManager(Arrays.asList(bike, foot, car), 4);
+
+        OSMReader reader = new OSMReader(new GraphBuilder(manager).create())
+        {
+            @Override
+            public Collection<OSMTurnRelation.TurnCostTableEntry> analyzeTurnRelation( FlagEncoder encoder,
+                                                                                       OSMTurnRelation turnRelation )
+            {
+                // simulate by returning one turn cost entry directly
+                if (encoder.toString().equalsIgnoreCase("car"))
+                {
+
+                    return Collections.singleton(turnCostEntry_car);
+                } else if (encoder.toString().equalsIgnoreCase("foot"))
+                {
+                    return Collections.singleton(turnCostEntry_foot);
+                } else if (encoder.toString().equalsIgnoreCase("bike"))
+                {
+                    return Collections.singleton(turnCostEntry_bike);
+                } else
+                {
+                    throw new IllegalArgumentException("illegal encoder " + encoder.toString());
+                }
+            }
+        }.setEncodingManager(manager);
+
+        // turn cost entries for car and foot are for the same relations (same viaNode, edgeFrom and edgeTo), 
+        // turn cost entry for bike is for another relation (different viaNode) 
+        turnCostEntry_car.edgeFrom = 1;
+        turnCostEntry_foot.edgeFrom = 1;
+        turnCostEntry_bike.edgeFrom = 2;
+
+        // calculating arbitrary flags using the encoders
+        turnCostEntry_car.flags = car.getTurnFlags(true, 0);
+        turnCostEntry_foot.flags = foot.getTurnFlags(true, 0);
+        turnCostEntry_bike.flags = bike.getTurnFlags(false, 10);
+
+        // we expect two different entries: the first one is a combination of turn flags of car and foot, 
+        // since they provide the same relation, the other one is for bike only
+        long assertFlag1 = turnCostEntry_car.flags | turnCostEntry_foot.flags;
+        long assertFlag2 = turnCostEntry_bike.flags;
+
+        // combine flags of all encoders
+        Collection<OSMTurnRelation.TurnCostTableEntry> entries = reader.analyzeTurnRelation(null);
+
+        // we expect two different turnCost entries
+        assertEquals(2, entries.size());
+
+        for (OSMTurnRelation.TurnCostTableEntry entry : entries)
+        {
+            if (entry.edgeFrom == 1)
+            {
+                // the first entry provides turn flags for car and foot only 
+                assertEquals(assertFlag1, entry.flags);
+                assertTrue(car.isTurnRestricted(entry.flags));
+                assertFalse(foot.isTurnRestricted(entry.flags));
+                assertFalse(bike.isTurnRestricted(entry.flags));
+
+                assertTrue(Double.isInfinite(car.getTurnCost(entry.flags)));
+                assertEquals(0, foot.getTurnCost(entry.flags), 1e-1);
+                assertEquals(0, bike.getTurnCost(entry.flags), 1e-1);
+            } else if (entry.edgeFrom == 2)
+            {
+                // the 2nd entry provides turn flags for bike only
+                assertEquals(assertFlag2, entry.flags);
+                assertFalse(car.isTurnRestricted(entry.flags));
+                assertFalse(foot.isTurnRestricted(entry.flags));
+                assertFalse(bike.isTurnRestricted(entry.flags));
+
+                assertEquals(0, car.getTurnCost(entry.flags), 1e-1);
+                assertEquals(0, foot.getTurnCost(entry.flags), 1e-1);
+                assertEquals(10, bike.getTurnCost(entry.flags), 1e-1);
+            }
+        }
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java b/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
index 077834b967..ad83ce8f40 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
@@ -25,15 +25,17 @@
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.util.EdgeExplorer;
+
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class OSMTurnRelationTest
@@ -44,11 +46,11 @@ public void testGetRestrictionAsEntries()
         CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 3);
         final Map<Long, Integer> osmNodeToInternal = new HashMap<Long, Integer>();
         final Map<Integer, Long> internalToOSMEdge = new HashMap<Integer, Long>();
-                
+
         osmNodeToInternal.put(3L, 3);
         // edge ids are only stored if they occured before in an OSMRelation
-        internalToOSMEdge.put(3, 3L);        
-        internalToOSMEdge.put(4, 4L);        
+        internalToOSMEdge.put(3, 3L);
+        internalToOSMEdge.put(4, 4L);
 
         GraphStorage graph = new GraphBuilder(new EncodingManager(encoder)).create();
         EdgeBasedRoutingAlgorithmTest.initGraph(graph);
@@ -65,7 +67,7 @@ public int getInternalNodeIdOfOsmNode( long nodeOsmId )
             public long getOsmIdOfInternalEdge( int edgeId )
             {
                 Long l = internalToOSMEdge.get(edgeId);
-                if(l == null)
+                if (l == null)
                     return -1;
                 return l;
             }
@@ -83,14 +85,14 @@ public long getOsmIdOfInternalEdge( int edgeId )
         OSMTurnRelation.TurnCostTableEntry entry = iter.next();
         assertEquals(4, entry.edgeFrom);
         assertEquals(6, entry.edgeTo);
-        assertEquals(3, entry.nodeViaNode);
-        
+        assertEquals(3, entry.nodeVia);
+
         entry = iter.next();
         assertEquals(4, entry.edgeFrom);
         assertEquals(2, entry.edgeTo);
-        assertEquals(3, entry.nodeViaNode);
-        
-        
+        assertEquals(3, entry.nodeVia);
+
+
         // TYPE == NOT
         instance = new OSMTurnRelation(4, 3, 3, Type.NOT);
         result = instance.getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer, osmReader);
@@ -100,7 +102,7 @@ public long getOsmIdOfInternalEdge( int edgeId )
         entry = iter.next();
         assertEquals(4, entry.edgeFrom);
         assertEquals(3, entry.edgeTo);
-        assertEquals(3, entry.nodeViaNode);       
+        assertEquals(3, entry.nodeVia);
     }
 
 }
diff --git a/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java b/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java
index 24ebc4126e..d829052a6b 100644
--- a/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java
@@ -21,16 +21,20 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.Graph;
+
 import static com.graphhopper.util.GHUtility.*;
+
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.util.EdgeExplorer;
+
 import java.io.IOException;
 import java.util.zip.GZIPInputStream;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class PrinctonReaderTest
diff --git a/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
index e07c32fe02..8a5825bb84 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
@@ -18,11 +18,12 @@
  */
 package com.graphhopper.reader.dem;
 
+import java.io.File;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class CGIARProviderTest
@@ -57,4 +58,22 @@ public void testFileName()
         assertEquals("srtm_34_08", instance.getFileName(20, -15));
         assertEquals("srtm_37_02", instance.getFileName(52.1943832, 0.1363176));
     }
+
+    @Test
+    public void testFileNotFound()
+    {
+        CGIARProvider instance = new CGIARProvider();
+        File file = new File(instance.getCacheDir(), instance.getFileName(46, -20) + ".gh");
+        File zipFile = new File(instance.getCacheDir(), instance.getFileName(46, -20) + ".zip");
+        file.delete();
+        zipFile.delete();
+        
+        assertEquals(0, instance.getEle(46, -20), 1);
+
+        // file not found => small!
+        assertTrue(file.exists());
+        assertEquals(228, file.length());        
+        file.delete();
+        zipFile.delete();
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java b/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
index f9adbc5ae3..d56495704f 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
@@ -21,10 +21,10 @@
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.RAMDirectory;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class HeightTileTest
diff --git a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
index 79631a5a02..30f2439d3a 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
@@ -19,15 +19,18 @@
 package com.graphhopper.reader.dem;
 
 import com.graphhopper.storage.DAType;
+
 import java.io.File;
 import java.io.IOException;
+
 import org.junit.After;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 
 /**
- *
  * @author Peter Karich
  */
 public class SRTMProviderTest
diff --git a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
index 5a584597da..87c5790246 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.ShortestWeighting;
+
 import java.util.Arrays;
 import java.util.Collection;
 
@@ -24,15 +26,16 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-import com.graphhopper.routing.util.AlgorithmPreparation;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.NoOpAlgorithmPreparation;
 import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
 
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
 /**
- *
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
@@ -41,16 +44,24 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            { TraversalMode.NODE_BASED },
-            { TraversalMode.EDGE_BASED_1DIR },
-            { TraversalMode.EDGE_BASED_2DIR },
-            { TraversalMode.EDGE_BASED_2DIR_UTURN }
-        });
+                {
+                        {
+                                TraversalMode.NODE_BASED
+                        },
+                        {
+                                TraversalMode.EDGE_BASED_1DIR
+                        },
+                        {
+                                TraversalMode.EDGE_BASED_2DIR
+                        },
+                        {
+                                TraversalMode.EDGE_BASED_2DIR_UTURN
+                        }
+                });
     }
 
     private final TraversalMode traversalMode;
@@ -61,15 +72,51 @@ public AStarBidirectionTest( TraversalMode tMode )
     }
 
     @Override
-    public AlgorithmPreparation prepareGraph( Graph g, final FlagEncoder encoder, final Weighting w )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new AStarBidirection(_graph, encoder, w, traversalMode);
+                return new AStarBidirection(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(g);
+        };
+    }
+
+    @Test
+    public void testInitFromAndTo()
+    {
+        Graph g = createGraph(false);
+        g.edge(0, 1, 1, true);
+        updateDistancesFor(g, 0, 0.00, 0.00);
+        updateDistancesFor(g, 1, 0.01, 0.01);
+
+        final AtomicReference<AStar.AStarEdge> fromRef = new AtomicReference<AStar.AStarEdge>();
+        final AtomicReference<AStar.AStarEdge> toRef = new AtomicReference<AStar.AStarEdge>();
+        AStarBidirection astar = new AStarBidirection(g, carEncoder, new ShortestWeighting(), traversalMode)
+        {
+            @Override
+            public void initFrom( int from, double weight )
+            {
+                super.initFrom(from, weight);
+                fromRef.set(currFrom);
+            }
+
+            @Override
+            public void initTo( int to, double weight )
+            {
+                super.initTo(to, weight);
+                toRef.set(currTo);
+            }
+        };
+        astar.initFrom(0, 1);
+        astar.initTo(1, 0.5);
+
+        assertEquals(1, fromRef.get().weightOfVisitedPath, .1);
+        assertEquals(787.3, fromRef.get().weight, .1);
+
+        assertEquals(0.5, toRef.get().weightOfVisitedPath, .1);
+        assertEquals(786.8, toRef.get().weight, .1);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/AStarTest.java b/core/src/test/java/com/graphhopper/routing/AStarTest.java
index 7ad145aee5..492024905e 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
+
 import java.util.Arrays;
 import java.util.Collection;
 
@@ -36,16 +37,16 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            { TraversalMode.NODE_BASED },
-            { TraversalMode.EDGE_BASED_1DIR },
-            { TraversalMode.EDGE_BASED_2DIR },
-            { TraversalMode.EDGE_BASED_2DIR_UTURN }
-        });
+                {
+                        {TraversalMode.NODE_BASED},
+                        {TraversalMode.EDGE_BASED_1DIR},
+                        {TraversalMode.EDGE_BASED_2DIR},
+                        {TraversalMode.EDGE_BASED_2DIR_UTURN}
+                });
     }
 
     private final TraversalMode traversalMode;
@@ -56,15 +57,15 @@ public AStarTest( TraversalMode tMode )
     }
 
     @Override
-    public AlgorithmPreparation prepareGraph( Graph g, final FlagEncoder encoder, final Weighting w )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new AStar(_graph, encoder, w, traversalMode);
+                return new AStar(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(g);
+        };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index b3209ded80..31fd0bda81 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -21,16 +21,18 @@
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
-import com.graphhopper.storage.index.LocationIndexTreeSC;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import gnu.trove.list.TIntList;
+
 import java.util.Random;
+
 import static org.junit.Assert.*;
+
+import org.junit.Before;
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public abstract class AbstractRoutingAlgorithmTester
@@ -38,8 +40,18 @@
     // problem is: matrix graph is expensive to create to cache it in a static variable
     private static Graph matrixGraph;
     protected static final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
-    protected FlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
-    protected FlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
+    protected FlagEncoder carEncoder;
+    protected FlagEncoder footEncoder;
+    protected AlgorithmOptions defaultOpts;
+
+    @Before
+    public void setUp()
+    {
+        carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
+        footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
+        defaultOpts = AlgorithmOptions.start().flagEncoder(carEncoder).
+                weighting(new ShortestWeighting()).build();
+    }
 
     protected Graph createGraph( EncodingManager em, boolean is3D )
     {
@@ -51,20 +63,56 @@ protected Graph createGraph( boolean is3D )
         return createGraph(encodingManager, is3D);
     }
 
-    public AlgorithmPreparation prepareGraph( Graph g )
+    public RoutingAlgorithm createAlgo( Graph g )
     {
-        return prepareGraph(g, carEncoder, new ShortestWeighting());
+        return createAlgo(g, defaultOpts);
     }
 
-    public abstract AlgorithmPreparation prepareGraph( Graph g, FlagEncoder encoder, Weighting w );
+    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
+    {
+        return createFactory(g, opts).createAlgo(g, opts);
+    }
+
+    public abstract RoutingAlgorithmFactory createFactory( Graph g, AlgorithmOptions opts );
 
     @Test
     public void testCalcShortestPath()
     {
         Graph graph = createTestGraph();
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 7);
-        assertEquals(p.toString(), 13, p.getDistance(), 1e-4);
-        assertEquals(p.toString(), Helper.createTList(0, 4, 6, 5, 7), p.calcNodes());
+        RoutingAlgorithm algo = createAlgo(graph);
+        Path p = algo.calcPath(0, 7);
+        assertEquals(p.toString(), Helper.createTList(0, 4, 5, 7), p.calcNodes());
+        assertEquals(p.toString(), 62.1, p.getDistance(), .1);
+    }
+
+    @Test
+    public void testWeightLimit()
+    {
+        Graph graph = createTestGraph();
+        RoutingAlgorithm algo = createAlgo(graph);
+        algo.setWeightLimit(10);
+        Path p = algo.calcPath(0, 7);
+        assertTrue(algo.getVisitedNodes() < 7);
+        assertFalse(p.isFound());
+        assertEquals(p.toString(), Helper.createTList(), p.calcNodes());
+    }
+
+    @Test
+    public void testWeightLimit_issue380()
+    {
+        Graph graph = createGraph(false);
+        initGraphWeightLimit(graph);
+        RoutingAlgorithm algo = createAlgo(graph);
+        algo.setWeightLimit(3);
+        Path p = algo.calcPath(0, 4);
+        assertTrue(p.isFound());
+        assertEquals(3.0, p.getWeight(), 1e-6);
+
+        algo = createAlgo(graph);
+        algo.setWeightLimit(3);
+        p = algo.calcPath(0, 3);
+        assertTrue(p.isFound());
+        assertEquals(3.0, p.getWeight(), 1e-6);
     }
 
     // see calc-fastest-graph.svg
@@ -72,18 +120,21 @@ public void testCalcShortestPath()
     public void testCalcFastestPath()
     {
         Graph graphShortest = createGraph(false);
-        initDirectedAndDiffSpeed(graphShortest);
-        Path p1 = prepareGraph(graphShortest, carEncoder, new ShortestWeighting()).createAlgo().calcPath(0, 3);
+        initDirectedAndDiffSpeed(graphShortest, carEncoder);
+        Path p1 = createAlgo(graphShortest, defaultOpts).
+                calcPath(0, 3);
         assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
-        assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
-        assertEquals(p1.toString(), 144823, p1.getMillis());
+        assertEquals(p1.toString(), 402.3, p1.getDistance(), .1);
+        assertEquals(p1.toString(), 144823, p1.getTime());
 
         Graph graphFastest = createGraph(false);
-        initDirectedAndDiffSpeed(graphFastest);
-        Path p2 = prepareGraph(graphFastest, carEncoder, new FastestWeighting(carEncoder)).createAlgo().calcPath(0, 3);
+        initDirectedAndDiffSpeed(graphFastest, carEncoder);
+        Path p2 = createAlgo(graphFastest,
+                AlgorithmOptions.start().flagEncoder(carEncoder).weighting(new FastestWeighting(carEncoder)).build()).
+                calcPath(0, 3);
         assertEquals(Helper.createTList(0, 4, 6, 7, 5, 3), p2.calcNodes());
-        assertEquals(p2.toString(), 1261.714, p2.getDistance(), 1e-6);
-        assertEquals(p2.toString(), 111437, p2.getMillis());
+        assertEquals(p2.toString(), 1261.7, p2.getDistance(), 0.1);
+        assertEquals(p2.toString(), 111442, p2.getMillis());
     }
 
     // 0-1-2-3
@@ -91,28 +142,28 @@ public void testCalcFastestPath()
     // 4-5-- |
     // |/ \--7
     // 6----/
-    void initDirectedAndDiffSpeed( Graph graph )
+    protected void initDirectedAndDiffSpeed( Graph graph, FlagEncoder enc )
     {
-        graph.edge(0, 1).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(0, 4).setFlags(carEncoder.setProperties(100, true, false));
+        graph.edge(0, 1).setFlags(enc.setProperties(10, true, false));
+        graph.edge(0, 4).setFlags(enc.setProperties(100, true, false));
 
-        graph.edge(1, 4).setFlags(carEncoder.setProperties(10, true, true));
-        graph.edge(1, 5).setFlags(carEncoder.setProperties(10, true, true));
-        EdgeIteratorState edge12 = graph.edge(1, 2).setFlags(carEncoder.setProperties(10, true, true));
+        graph.edge(1, 4).setFlags(enc.setProperties(10, true, true));
+        graph.edge(1, 5).setFlags(enc.setProperties(10, true, true));
+        EdgeIteratorState edge12 = graph.edge(1, 2).setFlags(enc.setProperties(10, true, true));
 
-        graph.edge(5, 2).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(2, 3).setFlags(carEncoder.setProperties(10, true, false));
+        graph.edge(5, 2).setFlags(enc.setProperties(10, true, false));
+        graph.edge(2, 3).setFlags(enc.setProperties(10, true, false));
 
-        EdgeIteratorState edge53 = graph.edge(5, 3).setFlags(carEncoder.setProperties(20, true, false));
-        graph.edge(3, 7).setFlags(carEncoder.setProperties(10, true, false));
+        EdgeIteratorState edge53 = graph.edge(5, 3).setFlags(enc.setProperties(20, true, false));
+        graph.edge(3, 7).setFlags(enc.setProperties(10, true, false));
 
-        graph.edge(4, 6).setFlags(carEncoder.setProperties(100, true, false));
-        graph.edge(5, 4).setFlags(carEncoder.setProperties(10, true, false));
+        graph.edge(4, 6).setFlags(enc.setProperties(100, true, false));
+        graph.edge(5, 4).setFlags(enc.setProperties(10, true, false));
 
-        graph.edge(5, 6).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(7, 5).setFlags(carEncoder.setProperties(100, true, false));
+        graph.edge(5, 6).setFlags(enc.setProperties(10, true, false));
+        graph.edge(7, 5).setFlags(enc.setProperties(100, true, false));
 
-        graph.edge(6, 7).setFlags(carEncoder.setProperties(100, true, true));
+        graph.edge(6, 7).setFlags(enc.setProperties(100, true, true));
 
         updateDistancesFor(graph, 0, 0.002, 0);
         updateDistancesFor(graph, 1, 0.002, 0.001);
@@ -132,13 +183,15 @@ public void testCalcFootPath()
     {
         Graph graphShortest = createGraph(false);
         initFootVsCar(graphShortest);
-        Path p1 = prepareGraph(graphShortest, footEncoder, new ShortestWeighting()).createAlgo().calcPath(0, 7);
+        Path p1 = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(footEncoder).
+                weighting(new ShortestWeighting()).build()).
+                calcPath(0, 7);
         assertEquals(p1.toString(), 17000, p1.getDistance(), 1e-6);
-        assertEquals(p1.toString(), 12240 * 1000, p1.getMillis());
+        assertEquals(p1.toString(), 12240 * 1000, p1.getTime());
         assertEquals(Helper.createTList(0, 4, 5, 7), p1.calcNodes());
     }
 
-    void initFootVsCar( Graph graph )
+    protected void initFootVsCar( Graph graph )
     {
         graph.edge(0, 1).setDistance(7000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, false));
         graph.edge(0, 4).setDistance(5000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(20, true, false));
@@ -186,24 +239,26 @@ protected Graph createTestGraph()
         graph.edge(5, 6, 2, true);
         graph.edge(5, 7, 1, true);
 
-        graph.edge(6, 7, 5, true);
-        return graph;
-    }
+        EdgeIteratorState edge6_7 = graph.edge(6, 7, 5, true);
 
-    @Test
-    public void testCalcIfEmptyWay()
-    {
-        Graph graph = createTestGraph();
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 0);
-        assertEquals(p.calcNodes().toString(), 0, p.calcNodes().size());
-        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+        updateDistancesFor(graph, 0, 0.0010, 0.00001);
+        updateDistancesFor(graph, 1, 0.0008, 0.0000);
+        updateDistancesFor(graph, 2, 0.0005, 0.0001);
+        updateDistancesFor(graph, 3, 0.0006, 0.0002);
+        updateDistancesFor(graph, 4, 0.0009, 0.0001);
+        updateDistancesFor(graph, 5, 0.0007, 0.0001);
+        updateDistancesFor(graph, 6, 0.0009, 0.0002);
+        updateDistancesFor(graph, 7, 0.0008, 0.0003);
+
+        edge6_7.setDistance(5 * edge6_7.getDistance());
+        return graph;
     }
 
     @Test
     public void testNoPathFound()
     {
         Graph graph = createGraph(false);
-        assertFalse(prepareGraph(graph).createAlgo().calcPath(0, 1).isFound());
+        assertFalse(createAlgo(graph).calcPath(0, 1).isFound());
 
         // two disconnected areas
         graph.edge(0, 1, 7, true);
@@ -212,23 +267,22 @@ public void testNoPathFound()
         graph.edge(5, 7, 1, true);
         graph.edge(5, 8, 1, true);
         graph.edge(7, 8, 1, true);
-        RoutingAlgorithm algo = prepareGraph(graph).createAlgo();
+        RoutingAlgorithm algo = createAlgo(graph);
         assertFalse(algo.calcPath(0, 5).isFound());
-        // assertEquals(4, algo.getVisitedNodes());
+        // assertEquals(3, algo.getVisitedNodes());
 
         // disconnected as directed graph
         graph = createGraph(false);
         graph.edge(0, 1, 1, false);
         graph.edge(0, 2, 1, true);
-        algo = prepareGraph(graph).createAlgo();
-        assertFalse(algo.calcPath(1, 2).isFound());
+        assertFalse(createAlgo(graph).calcPath(1, 2).isFound());
     }
 
     @Test
     public void testWikipediaShortestPath()
     {
         Graph graph = createWikipediaTestGraph();
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 4);
+        Path p = createAlgo(graph).calcPath(0, 4);
         assertEquals(p.toString(), 20, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 4, p.calcNodes().size());
     }
@@ -237,9 +291,9 @@ public void testWikipediaShortestPath()
     public void testCalcIf1EdgeAway()
     {
         Graph graph = createTestGraph();
-        Path p = prepareGraph(graph).createAlgo().calcPath(1, 2);
+        Path p = createAlgo(graph).calcPath(1, 2);
         assertEquals(Helper.createTList(1, 2), p.calcNodes());
-        assertEquals(p.toString(), 2, p.getDistance(), 1e-4);
+        assertEquals(p.toString(), 35.1, p.getDistance(), .1);
     }
 
     // see wikipedia-graph.svg !
@@ -263,7 +317,7 @@ protected Graph createWikipediaTestGraph()
     // |    8  |
     // \   /   |
     //  7-6----5
-    public static void initBiGraph( Graph graph )
+    public static Graph initBiGraph( Graph graph )
     {
         // distance will be overwritten in second step as we need to calculate it from lat,lon
         graph.edge(0, 1, 1, true);
@@ -290,6 +344,7 @@ public static void initBiGraph( Graph graph )
         updateDistancesFor(graph, 7, 0, 0);
         updateDistancesFor(graph, 6, 0, 0.001);
         updateDistancesFor(graph, 5, 0, 0.004);
+        return graph;
     }
 
     private static final DistanceCalc distCalc = new DistanceCalcEarth();
@@ -301,10 +356,8 @@ public static void updateDistancesFor( Graph g, int node, double lat, double lon
         EdgeIterator iter = g.createEdgeExplorer().setBaseNode(node);
         while (iter.next())
         {
-            int adj = iter.getAdjNode();
-            double adjLat = na.getLatitude(adj);
-            double adjLon = na.getLongitude(adj);
-            iter.setDistance(distCalc.calcDist(lat, lon, adjLat, adjLon));
+            iter.setDistance(iter.fetchWayGeometry(3).calcDistance(distCalc));
+            // System.out.println(node + "->" + adj + ": " + iter.getDistance());
         }
     }
 
@@ -315,15 +368,15 @@ public void testBidirectional()
         initBiGraph(graph);
 
         // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 4);
+        Path p = createAlgo(graph).calcPath(0, 4);
         // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
         assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 4), p.calcNodes());
-        assertEquals(p.toString(), 335.77, p.getDistance(), 1e-2);
+        assertEquals(p.toString(), 335.8, p.getDistance(), .1);
 
-        p = prepareGraph(graph).createAlgo().calcPath(1, 2);
+        p = createAlgo(graph).calcPath(1, 2);
         // the other way around is even larger as 0-1 is already 11008.452
         assertEquals(p.toString(), Helper.createTList(1, 2), p.calcNodes());
-        assertEquals(p.toString(), 10007.679, p.getDistance(), 1e-4);
+        assertEquals(p.toString(), 10007.7, p.getDistance(), .1);
     }
 
     // 1-2-3-4-5
@@ -347,7 +400,7 @@ public void testBidirectional2()
         graph.edge(3, 8, 20, true);
         graph.edge(8, 6, 20, true);
 
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 4);
+        Path p = createAlgo(graph).calcPath(0, 4);
         assertEquals(p.toString(), 40, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 5, p.calcNodes().size());
         assertEquals(Helper.createTList(0, 7, 6, 5, 4), p.calcNodes());
@@ -357,7 +410,7 @@ public void testBidirectional2()
     public void testRekeyBugOfIntBinHeap()
     {
         // using Dijkstra + IntBinHeap then rekey loops endlessly
-        Path p = prepareGraph(getMatrixGraph()).createAlgo().calcPath(36, 91);
+        Path p = createAlgo(getMatrixGraph()).calcPath(36, 91);
         assertEquals(12, p.calcNodes().size());
 
         TIntList list = p.calcNodes();
@@ -372,7 +425,7 @@ public void testRekeyBugOfIntBinHeap()
     @Test
     public void testBug1()
     {
-        Path p = prepareGraph(getMatrixGraph()).createAlgo().calcPath(34, 36);
+        Path p = createAlgo(getMatrixGraph()).calcPath(34, 36);
         assertEquals(Helper.createTList(34, 35, 36), p.calcNodes());
         assertEquals(3, p.calcNodes().size());
         assertEquals(17, p.getDistance(), 1e-5);
@@ -381,7 +434,7 @@ public void testBug1()
     @Test
     public void testCorrectWeight()
     {
-        Path p = prepareGraph(getMatrixGraph()).createAlgo().calcPath(45, 72);
+        Path p = createAlgo(getMatrixGraph()).calcPath(45, 72);
         assertEquals(Helper.createTList(45, 44, 54, 64, 74, 73, 72), p.calcNodes());
         assertEquals(38f, p.getDistance(), 1e-3);
     }
@@ -393,7 +446,7 @@ public void testCannotCalculateSP()
         graph.edge(0, 1, 1, false);
         graph.edge(1, 2, 1, false);
 
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 2);
+        Path p = createAlgo(graph).calcPath(0, 2);
         assertEquals(p.toString(), 3, p.calcNodes().size());
     }
 
@@ -408,7 +461,7 @@ public void testDirectedGraphBug1()
         graph.edge(3, 4, 3, false);
         graph.edge(4, 2, 1, false);
 
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 2);
+        Path p = createAlgo(graph).calcPath(0, 2);
         assertEquals(Helper.createTList(0, 1, 2), p.calcNodes());
         assertEquals(p.toString(), 5.99, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 3, p.calcNodes().size());
@@ -424,7 +477,7 @@ public void testDirectedGraphBug2()
 
         graph.edge(3, 1, 4, true);
 
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 3);
+        Path p = createAlgo(graph).calcPath(0, 3);
         assertEquals(Helper.createTList(0, 1, 2, 3), p.calcNodes());
     }
 
@@ -436,34 +489,69 @@ public void testDirectedGraphBug2()
     public void testWithCoordinates()
     {
         Graph graph = createGraph(false);
-        NodeAccess na = graph.getNodeAccess();
-        na.setNode(0, 0, 2);
-        na.setNode(1, 0, 3.5);
-        na.setNode(2, 1, 1);
-        na.setNode(3, 1.5, 2.5);
-        na.setNode(4, 0.5, 4.5);
 
-        graph.edge(0, 1, 2, true).setWayGeometry(Helper.createPointList(0, 3));
-        graph.edge(2, 3, 2, true);
-        graph.edge(3, 4, 2, true).setWayGeometry(Helper.createPointList(1, 3.5));
+        graph.edge(0, 1, 2, true).setWayGeometry(Helper.createPointList(1.5, 1));
+        graph.edge(2, 3, 2, true).setWayGeometry(Helper.createPointList(0, 1.5));
+        graph.edge(3, 4, 2, true).setWayGeometry(Helper.createPointList(0, 2));
 
-        graph.edge(0, 2, 0.8, true).setWayGeometry(Helper.createPointList(0, 1.6, 0, 0, 1, 0));
+        // duplicate but one is longer
         graph.edge(0, 2, 1.2, true);
-        graph.edge(1, 3, 1.3, true);
+        graph.edge(0, 2, 1.5, true).setWayGeometry(Helper.createPointList(0.5, 0));
+
+        graph.edge(1, 3, 1.3, true).setWayGeometry(Helper.createPointList(0.5, 1.5));
         graph.edge(1, 4, 1, true);
 
-        AlgorithmPreparation prepare = prepareGraph(graph);
-        Path p = prepare.createAlgo().calcPath(4, 0);
+        updateDistancesFor(graph, 0, 1, 0.6);
+        updateDistancesFor(graph, 1, 1, 1.5);
+        updateDistancesFor(graph, 2, 0, 0);
+        updateDistancesFor(graph, 3, 0, 1);
+        updateDistancesFor(graph, 4, 0, 2);
+
+        AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, new ShortestWeighting());
+        RoutingAlgorithmFactory prepare = createFactory(graph, opts);
+        Path p = prepare.createAlgo(graph, opts).calcPath(4, 0);
         assertEquals(Helper.createTList(4, 1, 0), p.calcNodes());
-        assertEquals(Helper.createPointList(0.5, 4.5, 0, 3.5, 0, 3, 0, 2), p.calcPoints());
-        assertEquals(291110, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
+        assertEquals(Helper.createPointList(0, 2, 1, 1.5, 1.5, 1, 1, 0.6), p.calcPoints());
+        assertEquals(274128, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
 
         // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
-        p = prepare.createAlgo().calcPath(2, 1);
-        // System.out.println(p.toDetailsString());
+        p = prepare.createAlgo(graph, opts).calcPath(2, 1);
         assertEquals(Helper.createTList(2, 0, 1), p.calcNodes());
-        assertEquals(Helper.createPointList(1, 1, 1, 0, 0, 0, 0, 1.6, 0, 2, 0, 3, 0, 3.5), p.calcPoints());
-        assertEquals(611555, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
+        assertEquals(Helper.createPointList(0, 0, 1, 0.6, 1.5, 1, 1, 1.5), p.calcPoints());
+        assertEquals(279482, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
+    }
+
+    @Test
+    public void testCalcIfEmptyWay()
+    {
+        Graph graph = createTestGraph();
+        Path p = createAlgo(graph).calcPath(0, 0);
+        assertEquals(p.calcNodes().toString(), 1, p.calcNodes().size());
+        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+    }
+
+    @Test
+    public void testViaEdges_FromEqualsTo()
+    {
+        Graph graph = createTestGraph();
+        // identical tower nodes
+        Path p = calcPathViaQuery(graph, 0.001, 0.000, 0.001, 0.000);
+        assertTrue(p.isFound());
+        assertEquals(Helper.createTList(0), p.calcNodes());
+        // assertEquals(1, p.calcPoints().size());
+        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+
+        // identical query points on edge
+        p = calcPath(graph, 0, 1, 0, 1);
+        assertTrue(p.isFound());
+        assertEquals(Helper.createTList(8), p.calcNodes());
+        // assertEquals(1, p.calcPoints().size());
+        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+
+        // very close
+        p = calcPathViaQuery(graph, 0.00092, 0, 0.00091, 0);
+        assertEquals(Helper.createTList(8, 9), p.calcNodes());
+        assertEquals(p.toString(), 1.11, p.getDistance(), .1);
     }
 
     @Test
@@ -472,25 +560,15 @@ public void testViaEdges_BiGraph()
         Graph graph = createGraph(false);
         initBiGraph(graph);
 
-        // 0-7 to 4-3
+        // 0-7 to 4-3        
         Path p = calcPathViaQuery(graph, 0.0009, 0, 0.001, 0.001105);
         assertEquals(p.toString(), Helper.createTList(10, 7, 6, 8, 3, 9), p.calcNodes());
-        assertEquals(p.toString(), 324.11, p.getDistance(), 1e-2);
+        assertEquals(p.toString(), 324.11, p.getDistance(), 0.01);
 
         // 0-1 to 2-3
         p = calcPathViaQuery(graph, 0.001, 0.0001, 0.010, 0.0011);
-        assertEquals(p.toString(), Helper.createTList(10, 0, 7, 6, 8, 3, 9), p.calcNodes());
-        assertEquals(p.toString(), 1335.42, p.getDistance(), .2);
-    }
-
-    @Test
-    public void testViaEdges_FromEqualsTo()
-    {
-        Graph graph = createTestGraph();
-        Path p = calcPath(graph, 0, 1, 0, 1);
-        // or one node would be acceptable
-        assertEquals(Helper.createTList(8, 9), p.calcNodes());
-        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+        assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 9), p.calcNodes());
+        assertEquals(p.toString(), 1335.35, p.getDistance(), 0.01);
     }
 
     @Test
@@ -499,7 +577,7 @@ public void testViaEdges_WithCoordinates()
         Graph graph = createTestGraph();
         Path p = calcPath(graph, 0, 1, 2, 3);
         assertEquals(Helper.createTList(9, 1, 2, 8), p.calcNodes());
-        assertEquals(p.toString(), 2, p.getDistance(), 1e-4);
+        assertEquals(p.toString(), 56.7, p.getDistance(), .1);
     }
 
     @Test
@@ -527,9 +605,9 @@ public void testViaEdges_SpecialCases()
         assertEquals(p.toString(), 26.81, p.getDistance(), .1);
 
         // overlapping edges: 2-3 and 3-2
-        p = calcPathViaQuery(graph, 0.000049, 0.00015, 0.00001, 0.0001);
+        p = calcPathViaQuery(graph, 0.000049, 0.00014, 0.00001, 0.0001);
         assertEquals(Helper.createTList(5, 6), p.calcNodes());
-        assertEquals(p.toString(), 7, p.getDistance(), .1);
+        assertEquals(p.toString(), 6.2, p.getDistance(), .1);
 
         // 'from' and 'to' edge share one node '2': 1-2 to 3-2
         p = calcPathViaQuery(graph, 0.00009, 0.00011, 0.00001, 0.00011);
@@ -541,7 +619,7 @@ public void testViaEdges_SpecialCases()
     public void testQueryGraphAndFastest()
     {
         Graph graph = createGraph(false);
-        initDirectedAndDiffSpeed(graph);
+        initDirectedAndDiffSpeed(graph, carEncoder);
         Path p = calcPathViaQuery("fastest", graph, 0.002, 0.0005, 0.0017, 0.0031);
         assertEquals(Helper.createTList(9, 1, 5, 3, 8), p.calcNodes());
         assertEquals(602.98, p.getDistance(), 1e-1);
@@ -555,19 +633,20 @@ Path calcPathViaQuery( Graph graph, double fromLat, double fromLon, double toLat
 
     Path calcPathViaQuery( String weighting, Graph graph, double fromLat, double fromLon, double toLat, double toLon )
     {
-        LocationIndex index;
-        if (graph instanceof LevelGraph)
-            index = new LocationIndexTreeSC((LevelGraph) graph, new RAMDirectory());
-        else
-            index = new LocationIndexTree(graph, new RAMDirectory());
-
+        LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory());
         index.prepareIndex();
         QueryResult from = index.findClosest(fromLat, fromLon, EdgeFilter.ALL_EDGES);
         QueryResult to = index.findClosest(toLat, toLon, EdgeFilter.ALL_EDGES);
         Weighting w = new ShortestWeighting();
         if (weighting.equalsIgnoreCase("fastest"))
             w = new FastestWeighting(carEncoder);
-        return prepareGraph(graph, carEncoder, w).createAlgo().calcPath(from, to);
+
+        // correct order for CH: in factory do prepare and afterwards wrap in query graph
+        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(w).build();
+        RoutingAlgorithmFactory factory = createFactory(graph, opts);
+        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        return factory.createAlgo(qGraph, opts).
+                calcPath(from.getClosestNode(), to.getClosestNode());
     }
 
     Path calcPath( Graph graph, int fromNode1, int fromNode2, int toNode1, int toNode2 )
@@ -575,7 +654,10 @@ Path calcPath( Graph graph, int fromNode1, int fromNode2, int toNode1, int toNod
         // lookup two edges: fromNode1-fromNode2 and toNode1-toNode2        
         QueryResult from = newQR(graph, fromNode1, fromNode2);
         QueryResult to = newQR(graph, toNode1, toNode2);
-        return prepareGraph(graph).createAlgo().calcPath(from, to);
+
+        RoutingAlgorithmFactory factory = createFactory(graph, defaultOpts);
+        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        return factory.createAlgo(qGraph, defaultOpts).calcPath(from.getClosestNode(), to.getClosestNode());
     }
 
     /**
@@ -612,12 +694,30 @@ public void testTwoWeightsPerEdge()
 
         // for two weights per edge it happened that Path (and also the Weighting) read the wrong side 
         // of the speed and read 0 => infinity weight => overflow of millis => negative millis!
-        Path p = prepareGraph(graph, encoder, new FastestWeighting(encoder)).
-                createAlgo().calcPath(0, 10);
-//        assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
-        assertEquals(85124371, p.getMillis());
+        Path p = createAlgo(graph, AlgorithmOptions.start().flagEncoder(encoder).weighting(new FastestWeighting(encoder)).build()).calcPath(0, 10);
+        assertEquals(85124371, p.getTime());
         assertEquals(425622, p.getDistance(), 1);
-        assertEquals(6568, p.getWeight(), 1);
+        assertEquals(85124.4, p.getWeight(), 1);
+    }
+
+    @Test
+    public void test0SpeedButUnblocked_Issue242()
+    {
+        Graph graph = createGraph(false);
+        long flags = carEncoder.setAccess(carEncoder.setSpeed(0, 0), true, true);
+
+        graph.edge(0, 1).setFlags(flags).setDistance(10);
+        graph.edge(1, 2).setFlags(flags).setDistance(10);
+
+        RoutingAlgorithm algo = createAlgo(graph);
+        try
+        {
+            Path p = algo.calcPath(0, 2);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Speed cannot be 0"));
+        }
     }
 
     @Test
@@ -625,7 +725,7 @@ public void testTwoWeightsPerEdge2()
     {
         // other direction should be different!
         Graph graph = initEleGraph(createGraph(true));
-        Path p = prepareGraph(graph, carEncoder, new ShortestWeighting()).createAlgo().calcPath(0, 10);
+        Path p = createAlgo(graph).calcPath(0, 10);
         // GHUtility.printEdgeInfo(graph, carEncoder);
         assertEquals(Helper.createTList(0, 4, 6, 10), p.calcNodes());
         Weighting fakeWeighting = new Weighting()
@@ -633,7 +733,7 @@ public void testTwoWeightsPerEdge2()
             @Override
             public double getMinWeight( double distance )
             {
-                return distance;
+                return 0.8 * distance;
             }
 
             @Override
@@ -663,9 +763,13 @@ else if (adj == 4)
         graph = initEleGraph(createGraph(true));
         QueryResult from = newQR(graph, 3, 0);
         QueryResult to = newQR(graph, 10, 9);
-        p = prepareGraph(graph, carEncoder, fakeWeighting).createAlgo().calcPath(from, to);
+
+        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(fakeWeighting).build();
+        RoutingAlgorithmFactory factory = createFactory(graph, opts);
+        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        p = factory.createAlgo(qGraph, opts).calcPath(from.getClosestNode(), to.getClosestNode());
         assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
-        assertEquals(37009621, p.getMillis());
+        assertEquals(37009621, p.getTime());
         assertEquals(616827, p.getDistance(), 1);
         assertEquals(493462, p.getWeight(), 1);
     }
@@ -713,6 +817,30 @@ Graph initEleGraph( Graph g )
         return g;
     }
 
+    public static Graph initGraphWeightLimit( Graph g )
+    {
+        //      0----1
+        //     /     |
+        //    7--    |
+        //   /   |   |
+        //   6---5   |
+        //   |   |   |
+        //   4---3---2
+
+        g.edge(0, 1, 1, true);
+        g.edge(1, 2, 1, true);
+
+        g.edge(3, 2, 1, true);
+        g.edge(3, 5, 1, true);
+        g.edge(5, 7, 1, true);
+        g.edge(3, 4, 1, true);
+        g.edge(4, 6, 1, true);
+        g.edge(6, 7, 1, true);
+        g.edge(6, 5, 1, true);
+        g.edge(0, 7, 1, true);
+        return g;
+    }
+
     public Graph getMatrixGraph()
     {
         return getMatrixAlikeGraph();
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
index 91475c0a43..bd859f314e 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
+
 import java.util.Arrays;
 import java.util.Collection;
 
@@ -28,7 +29,6 @@
 import com.graphhopper.storage.Graph;
 
 /**
- *
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
@@ -37,16 +37,16 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            { TraversalMode.NODE_BASED },
-            { TraversalMode.EDGE_BASED_1DIR },
-            { TraversalMode.EDGE_BASED_2DIR },
-            { TraversalMode.EDGE_BASED_2DIR_UTURN }
-        });
+                {
+                        {TraversalMode.NODE_BASED},
+                        {TraversalMode.EDGE_BASED_1DIR},
+                        {TraversalMode.EDGE_BASED_2DIR},
+                        {TraversalMode.EDGE_BASED_2DIR_UTURN}
+                });
     }
 
     private final TraversalMode traversalMode;
@@ -57,15 +57,15 @@ public DijkstraBidirectionRefTest( TraversalMode tMode )
     }
 
     @Override
-    public AlgorithmPreparation prepareGraph( Graph defaultGraph, final FlagEncoder encoder, final Weighting w )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new DijkstraBidirectionRef(_graph, encoder, w, traversalMode);
+                return new DijkstraBidirectionRef(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(defaultGraph);
+        };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
index 73ea744950..c1c99dd41b 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
@@ -22,15 +22,18 @@
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
+
 import java.util.Arrays;
 import java.util.Collection;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 /**
- *
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
@@ -39,36 +42,38 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameterized.Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            { TraversalMode.NODE_BASED },
+                {
+                        {
+                                TraversalMode.NODE_BASED
+                        },
 //            TODO { TraversalMode.EDGE_BASED_1DIR },
 //            TODO { TraversalMode.EDGE_BASED_2DIR },
 //            TODO { TraversalMode.EDGE_BASED_2DIR_UTURN }
-        });
+                });
     }
 
-    private final TraversalMode traversalmode;
+    private final TraversalMode traversalMode;
 
     public DijkstraOneToManyTest( TraversalMode tMode )
     {
-        this.traversalmode = tMode;
+        this.traversalMode = tMode;
     }
 
     @Override
-    public AlgorithmPreparation prepareGraph( Graph defaultGraph, final FlagEncoder encoder, final Weighting w )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new DijkstraOneToMany(_graph, encoder, w, traversalmode);
+                return new DijkstraOneToMany(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(defaultGraph);
+        };
     }
 
     @Override
@@ -110,8 +115,7 @@ public void testTwoWeightsPerEdge2()
     @Test
     public void testIssue182()
     {
-        AlgorithmPreparation prep = prepareGraph(initGraph(createGraph(false)));
-        RoutingAlgorithm algo = prep.createAlgo();
+        RoutingAlgorithm algo = createAlgo(initGraph(createGraph(false)));
         Path p = algo.calcPath(0, 8);
         assertEquals(Helper.createTList(0, 7, 8), p.calcNodes());
 
@@ -121,7 +125,7 @@ public void testIssue182()
     }
 
     @Test
-    public void testIssue239()
+    public void testIssue239_and362()
     {
         Graph g = createGraph(false);
         g.edge(0, 1, 1, true);
@@ -132,23 +136,24 @@ public void testIssue239()
         g.edge(5, 6, 1, true);
         g.edge(6, 4, 1, true);
 
-        AlgorithmPreparation prep = prepareGraph(g);
-        DijkstraOneToMany algo = (DijkstraOneToMany) prep.createAlgo();
+        DijkstraOneToMany algo = (DijkstraOneToMany) createAlgo(g);
         assertEquals(-1, algo.findEndNode(0, 4));
         assertEquals(-1, algo.findEndNode(0, 4));
+
+        assertEquals(1, algo.findEndNode(0, 1));
+        assertEquals(1, algo.findEndNode(0, 1));
     }
 
     @Test
     public void testUseCache()
     {
-        AlgorithmPreparation prep = prepareGraph(createTestGraph());
-        RoutingAlgorithm algo = prep.createAlgo();
+        RoutingAlgorithm algo = createAlgo(createTestGraph());
         Path p = algo.calcPath(0, 4);
         assertEquals(Helper.createTList(0, 4), p.calcNodes());
 
         // expand SPT
         p = algo.calcPath(0, 7);
-        assertEquals(Helper.createTList(0, 4, 6, 5, 7), p.calcNodes());
+        assertEquals(Helper.createTList(0, 4, 5, 7), p.calcNodes());
 
         // use SPT
         p = algo.calcPath(0, 2);
@@ -165,8 +170,7 @@ public void testDifferentEdgeFilter()
         g.edge(4, 5, 10, true);
         g.edge(5, 6, 10, true);
 
-        AlgorithmPreparation prep = prepareGraph(g);
-        DijkstraOneToMany algo = (DijkstraOneToMany) prep.createAlgo();
+        DijkstraOneToMany algo = (DijkstraOneToMany) createAlgo(g);
         algo.setEdgeFilter(new EdgeFilter()
         {
             @Override
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
index 7e42cdfa81..9b51ac6fe5 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
+
 import java.util.Arrays;
 import java.util.Collection;
 
@@ -28,7 +29,6 @@
 import com.graphhopper.storage.Graph;
 
 /**
- *
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
@@ -37,19 +37,19 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            { TraversalMode.NODE_BASED },
-            { TraversalMode.EDGE_BASED_1DIR },
-            { TraversalMode.EDGE_BASED_2DIR },
-            { TraversalMode.EDGE_BASED_2DIR_UTURN }
-        });
+                {
+                        {TraversalMode.NODE_BASED},
+                        {TraversalMode.EDGE_BASED_1DIR},
+                        {TraversalMode.EDGE_BASED_2DIR},
+                        {TraversalMode.EDGE_BASED_2DIR_UTURN}
+                });
     }
 
-    private TraversalMode traversalMode;
+    private final TraversalMode traversalMode;
 
     public DijkstraTest( TraversalMode tMode )
     {
@@ -57,15 +57,15 @@ public DijkstraTest( TraversalMode tMode )
     }
 
     @Override
-    public AlgorithmPreparation prepareGraph( Graph defaultGraph, final FlagEncoder encoder, final Weighting weighting )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new Dijkstra(_graph, encoder, weighting, traversalMode);
+                return new Dijkstra(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(defaultGraph);
+        };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
index 2a08df8a6d..81e75cc3c3 100644
--- a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
+++ b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
@@ -22,13 +22,16 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
+
 import static org.junit.Assert.*;
 import static com.graphhopper.util.GHUtility.*;
+
 import java.util.Arrays;
 import java.util.Collection;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -56,14 +59,13 @@ EncodingManager createEncodingManager( boolean restrictedOnly )
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            { "dijkstra" },
-            { "dijkstrabi" },
-            { "astar" },
-            { "astarbi" },
-            { "dijkstraNative" },
-        // TODO { "dijkstraOneToMany" }
-        });
+                {
+                        {AlgorithmOptions.DIJKSTRA},
+                        {AlgorithmOptions.DIJKSTRA_BI},
+                        {AlgorithmOptions.ASTAR},
+                        {AlgorithmOptions.ASTAR_BI}
+                        // TODO { AlgorithmOptions.DIJKSTRA_ONE_TO_MANY }
+                });
     }
 
     private final String algoStr;
@@ -73,10 +75,10 @@ public EdgeBasedRoutingAlgorithmTest( String algo )
         this.algoStr = algo;
     }
 
-    public AlgorithmPreparation prepareGraph( Graph defaultGraph, final FlagEncoder encoder,
-            final Weighting w, TraversalMode tMode )
+    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
     {
-        return NoOpAlgorithmPreparation.createAlgoPrepare(defaultGraph, algoStr, encoder, w, tMode);
+        opts = AlgorithmOptions.start(opts).algorithm(algoStr).build();
+        return new RoutingAlgorithmFactorySimple().createAlgo(g, opts);
     }
 
     protected GraphStorage createGraph( EncodingManager em )
@@ -103,37 +105,37 @@ public static void initGraph( Graph g )
         g.edge(6, 7, 1, true);
     }
 
-    private void initTurnRestrictions( Graph g, TurnCostStorage tcs, TurnCostEncoder tEncoder )
+    private void initTurnRestrictions( Graph g, TurnCostExtension tcs, TurnCostEncoder tEncoder )
     {
         long tflags = tEncoder.getTurnFlags(true, 0);
 
         // only forward from 2-3 to 3-4 => limit 2,3->3,6 and 2,3->3,1
-        tcs.addTurnInfo(3, getEdge(g, 2, 3).getEdge(), getEdge(g, 3, 6).getEdge(), tflags);
-        tcs.addTurnInfo(3, getEdge(g, 2, 3).getEdge(), getEdge(g, 3, 1).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 2, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 2, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), tflags);
 
         // only right   from 5-2 to 2-3 => limit 5,2->2,0
-        tcs.addTurnInfo(2, getEdge(g, 5, 2).getEdge(), getEdge(g, 2, 0).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 0).getEdge(), tflags);
 
         // only right   from 7-6 to 6-3 => limit 7,6->6,5
-        tcs.addTurnInfo(6, getEdge(g, 7, 6).getEdge(), getEdge(g, 6, 5).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 7, 6).getEdge(), 6, getEdge(g, 6, 5).getEdge(), tflags);
 
         // no 5-6 to 6-3
-        tcs.addTurnInfo(6, getEdge(g, 5, 6).getEdge(), getEdge(g, 6, 3).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 5, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
         // no 4-3 to 3-1
-        tcs.addTurnInfo(3, getEdge(g, 4, 3).getEdge(), getEdge(g, 3, 1).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), tflags);
         // no 4-3 to 3-2
-        tcs.addTurnInfo(3, getEdge(g, 4, 3).getEdge(), getEdge(g, 3, 2).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, getEdge(g, 3, 2).getEdge(), tflags);
 
         // no u-turn at 6-7
-        tcs.addTurnInfo(7, getEdge(g, 6, 7).getEdge(), getEdge(g, 7, 6).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 6, 7).getEdge(), 7, getEdge(g, 7, 6).getEdge(), tflags);
 
         // no u-turn at 3-6
-        tcs.addTurnInfo(6, getEdge(g, 3, 6).getEdge(), getEdge(g, 6, 3).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 3, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
     }
 
-    Weighting createWeighting( FlagEncoder encoder, TurnCostStorage tcs )
+    Weighting createWeighting( FlagEncoder encoder, TurnCostExtension tcs, double turnCosts )
     {
-        return new TurnWeighting(new FastestWeighting(encoder), encoder, tcs);
+        return new TurnWeighting(new FastestWeighting(encoder), encoder, tcs).setDefaultUTurnCost(turnCosts);
     }
 
     @Test
@@ -141,19 +143,28 @@ public void testBasicTurnRestriction()
     {
         GraphStorage g = createGraph(createEncodingManager(true));
         initGraph(g);
-        TurnCostStorage tcs = (TurnCostStorage) g.getExtendedStorage();
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
         initTurnRestrictions(g, tcs, carEncoder);
-        Path p = prepareGraph(g, carEncoder, createWeighting(carEncoder, tcs), TraversalMode.EDGE_BASED_2DIR).
-                createAlgo().calcPath(5, 1);
+        Path p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
+                calcPath(5, 1);
         assertEquals(Helper.createTList(5, 2, 3, 4, 7, 6, 3, 1), p.calcNodes());
 
         // test 7-6-5 and reverse
-        p = prepareGraph(g, carEncoder, createWeighting(carEncoder, tcs), TraversalMode.EDGE_BASED_1DIR).
-                createAlgo().calcPath(5, 7);
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                calcPath(5, 7);
         assertEquals(Helper.createTList(5, 6, 7), p.calcNodes());
 
-        p = prepareGraph(g, carEncoder, createWeighting(carEncoder, tcs), TraversalMode.EDGE_BASED_1DIR).
-                createAlgo().calcPath(7, 5);
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                calcPath(7, 5);
         assertEquals(Helper.createTList(7, 6, 3, 2, 5), p.calcNodes());
     }
 
@@ -162,27 +173,33 @@ public void testUTurns()
     {
         GraphStorage g = createGraph(createEncodingManager(true));
         initGraph(g);
-        TurnCostStorage tcs = (TurnCostStorage) g.getExtendedStorage();
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
 
         long tflags = carEncoder.getTurnFlags(true, 0);
 
         // force u-turn via lowering the cost for it
         EdgeIteratorState e3_6 = getEdge(g, 3, 6);
         e3_6.setDistance(0.1);
-        getEdge(g, 3, 2).setDistance(8642);
-        getEdge(g, 1, 0).setDistance(8642);
+        getEdge(g, 3, 2).setDistance(864);
+        getEdge(g, 1, 0).setDistance(864);
 
-        tcs.addTurnInfo(6, getEdge(g, 7, 6).getEdge(), getEdge(g, 6, 5).getEdge(), tflags);
-        tcs.addTurnInfo(3, getEdge(g, 4, 3).getEdge(), e3_6.getEdge(), tflags);
-        Path p = prepareGraph(g, carEncoder, createWeighting(carEncoder, tcs), TraversalMode.EDGE_BASED_2DIR_UTURN).
-                createAlgo().calcPath(7, 5);
+        tcs.addTurnInfo(getEdge(g, 7, 6).getEdge(), 6, getEdge(g, 6, 5).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, e3_6.getEdge(), tflags);
+        AlgorithmOptions opts = AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 50)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
+        Path p = createAlgo(g, opts).calcPath(7, 5);
 
         assertEquals(Helper.createTList(7, 6, 3, 6, 5), p.calcNodes());
 
-        // no u-turn    from 6-3
-        tcs.addTurnInfo(3, getEdge(g, 6, 3).getEdge(), getEdge(g, 3, 6).getEdge(), tflags);
-        p = prepareGraph(g, carEncoder, createWeighting(carEncoder, tcs), TraversalMode.EDGE_BASED_2DIR_UTURN).
-                createAlgo().calcPath(7, 5);
+        // no u-turn for 6-3
+        opts = AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 100)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
+        tcs.addTurnInfo(getEdge(g, 6, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), tflags);
+        p = createAlgo(g, opts).calcPath(7, 5);
 
         assertEquals(Helper.createTList(7, 6, 3, 2, 5), p.calcNodes());
     }
@@ -192,9 +209,12 @@ public void testBasicTurnCosts()
     {
         GraphStorage g = createGraph(createEncodingManager(false));
         initGraph(g);
-        TurnCostStorage tcs = (TurnCostStorage) g.getExtendedStorage();
-        Path p = prepareGraph(g, carEncoder, createWeighting(carEncoder, tcs), TraversalMode.EDGE_BASED_1DIR).
-                createAlgo().calcPath(5, 1);
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
+        Path p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                calcPath(5, 1);
 
         // no restriction and costs
         EdgeIteratorState e3_6 = getEdge(g, 5, 6);
@@ -203,10 +223,13 @@ public void testBasicTurnCosts()
 
         // now introduce some turn costs
         long tflags = carEncoder.getTurnFlags(false, 2);
-        tcs.addTurnInfo(2, getEdge(g, 5, 2).getEdge(), getEdge(g, 2, 3).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 3).getEdge(), tflags);
 
-        p = prepareGraph(g, carEncoder, createWeighting(carEncoder, tcs), TraversalMode.EDGE_BASED_1DIR).
-                createAlgo().calcPath(5, 1);
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                calcPath(5, 1);
         assertEquals(Helper.createTList(5, 6, 3, 1), p.calcNodes());
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java b/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java
deleted file mode 100644
index 4b0abea3c1..0000000000
--- a/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java
+++ /dev/null
@@ -1,269 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing;
-
-import com.graphhopper.GHRequest;
-import com.graphhopper.GHResponse;
-import com.graphhopper.GraphHopper;
-import com.graphhopper.reader.dem.SRTMProvider;
-import com.graphhopper.routing.util.*;
-import com.graphhopper.util.*;
-import com.graphhopper.util.shapes.GHPoint;
-
-import java.io.File;
-import java.util.List;
-import java.util.Map;
-import org.junit.After;
-import org.junit.Test;
-import static org.junit.Assert.*;
-import org.junit.Before;
-
-/**
- * @author Peter Karich
- */
-public class GraphHopperIT
-{
-    String graphFile = "target/graph-GraphHopperIT";
-    String osmFile = "files/monaco.osm.gz";
-    String vehicle = "FOOT";
-    String importVehicles = "FOOT";
-    String weightCalcStr = "shortest";
-
-    @Before
-    public void setUp()
-    {
-        // make sure we are using fresh graphhopper files with correct vehicle
-        Helper.removeDir(new File(graphFile));
-    }
-
-    @After
-    public void tearDown()
-    {
-        Helper.removeDir(new File(graphFile));
-    }
-
-    @Test
-    public void testMonacoWithInstructions() throws Exception
-    {
-        GraphHopper hopper = new GraphHopper().
-                setStoreOnFlush(true).
-                setOSMFile(osmFile).
-                setCHEnable(false).
-                setGraphHopperLocation(graphFile).
-                setEncodingManager(new EncodingManager(importVehicles)).
-                importOrLoad();
-
-        GHResponse rsp = hopper.route(new GHRequest(43.727687, 7.418737, 43.74958, 7.436566).
-                setAlgorithm("astar").setVehicle(vehicle).setWeighting(weightCalcStr));
-
-        assertEquals(3437.6, rsp.getDistance(), .1);
-        assertEquals(89, rsp.getPoints().getSize());
-
-        InstructionList il = rsp.getInstructions();
-        assertEquals(13, il.size());
-
-        List<Map<String, Object>> resultJson = il.createJson();
-        // TODO roundabout fine tuning -> enter + leave roundabout (+ two rounabouts -> is it necessary if we do not leave the street?)
-        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
-        assertEquals("Turn slight left onto Avenue des Papalins", resultJson.get(1).get("text"));
-        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
-        assertEquals("Turn left", resultJson.get(3).get("text"));
-        assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
-
-        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
-        assertEquals(289, (Double) resultJson.get(1).get("distance"), 1);
-        assertEquals(10, (Double) resultJson.get(2).get("distance"), 1);
-        assertEquals(43, (Double) resultJson.get(3).get("distance"), 1);
-        assertEquals(122, (Double) resultJson.get(4).get("distance"), 1);
-        assertEquals(447, (Double) resultJson.get(5).get("distance"), 1);
-
-        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
-        assertEquals(207, (Long) resultJson.get(1).get("time") / 1000);
-        assertEquals(7, (Long) resultJson.get(2).get("time") / 1000);
-        assertEquals(30, (Long) resultJson.get(3).get("time") / 1000);
-        assertEquals(87, (Long) resultJson.get(4).get("time") / 1000);
-        assertEquals(321, (Long) resultJson.get(5).get("time") / 1000);
-
-        List<GPXEntry> list = rsp.getInstructions().createGPXList();
-        assertEquals(89, list.size());
-        final long lastEntryMillis = list.get(list.size() - 1).getMillis();
-        final long totalResponseMillis = rsp.getMillis();
-        assertEquals(totalResponseMillis, lastEntryMillis);
-    }
-
-    @Test
-    public void testSRTMWithInstructions() throws Exception
-    {
-        GraphHopper hopper = new GraphHopper().
-                setStoreOnFlush(true).
-                setOSMFile(osmFile).
-                setCHEnable(false).
-                setGraphHopperLocation(graphFile).
-                setEncodingManager(new EncodingManager(importVehicles));
-
-        hopper.setElevationProvider(new SRTMProvider().setCacheDir(new File("./files/")));
-        hopper.importOrLoad();
-
-        GHResponse rsp = hopper.route(new GHRequest(43.730729, 7.421288, 43.727697, 7.419199).
-                setAlgorithm("astar").setVehicle(vehicle).setWeighting(weightCalcStr));
-
-        assertEquals(1626.8, rsp.getDistance(), .1);
-        assertEquals(60, rsp.getPoints().getSize());
-        assertTrue(rsp.getPoints().is3D());
-
-        InstructionList il = rsp.getInstructions();
-        assertEquals(10, il.size());
-        assertTrue(il.get(0).getPoints().is3D());
-
-        String str = rsp.getPoints().toString();
-        assertEquals("(43.73068455771767,7.421283689825812,62.0), (43.73067957305937,7.421382123709815,66.0), "
-                + "(43.73109792316924,7.421546222751131,45.0), (43.73129908884985,7.421589994913116,45.0), "
-                + "(43.731327028527716,7.421414533736137,45.0), (43.73125047381037,7.421366291225693,45.0), "
-                + "(43.73125457162979,7.421274090288746,52.0), "
-                + "(43.73128213877862,7.421115579183003,52.0), (43.731362232521825,7.421145381506057,52.0), "
-                + "(43.731371359483255,7.421123216028286,52.0), (43.731485725897976,7.42117332118392,52.0), "
-                + "(43.731575132867135,7.420868778695214,52.0), (43.73160605277731,7.420824820268709,52.0), "
-                + "(43.7316401391843,7.420850152243305,52.0), (43.731674039326776,7.421050014072285,52.0)",
-                str.substring(0, 662));
-
-        assertEquals("(43.727778875703635,7.418772930326453,11.0), (43.72768239068275,7.419007064826944,11.0), "
-                + "(43.727680946587874,7.4191987684222065,11.0)",
-                str.substring(str.length() - 133));
-
-        List<GPXEntry> list = rsp.getInstructions().createGPXList();
-        assertEquals(60, list.size());
-        final long lastEntryMillis = list.get(list.size() - 1).getMillis();
-        assertEquals(new GPXEntry(43.73068455771767, 7.421283689825812, 62.0, 0), list.get(0));
-        assertEquals(new GPXEntry(43.727680946587874, 7.4191987684222065, 11.0, lastEntryMillis), list.get(list.size() - 1));
-
-        assertEquals(62, il.createGPXList().get(0).getElevation(), 1e-2);
-        assertEquals(66, il.createGPXList().get(1).getElevation(), 1e-2);
-        assertEquals(52, il.createGPXList().get(10).getElevation(), 1e-2);
-    }
-
-    @Test
-    public void testKremsCyclewayInstructionsWithWayTypeInfo()
-    {
-        String tmpOsmFile = "files/krems.osm.gz";
-        String tmpGraphFile = "target/graph-krems";
-        String tmpVehicle = "BIKE";
-        String tmpImportVehicles = "CAR,BIKE";
-        String tmpWeightCalcStr = "fastest";
-
-        try
-        {
-            // make sure we are using fresh graphhopper files with correct vehicle
-            Helper.removeDir(new File(tmpGraphFile));
-            GraphHopper hopper = new GraphHopper().
-                    setStoreOnFlush(true).
-                    setOSMFile(tmpOsmFile).
-                    setCHEnable(false).
-                    setGraphHopperLocation(tmpGraphFile).
-                    setEncodingManager(new EncodingManager(tmpImportVehicles)).
-                    importOrLoad();
-
-            GHResponse rsp = hopper.route(new GHRequest(48.410987, 15.599492, 48.383419, 15.659294).
-                    setAlgorithm("astar").setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
-
-            assertEquals(6932.24, rsp.getDistance(), .1);
-            assertEquals(110, rsp.getPoints().getSize());
-
-            InstructionList il = rsp.getInstructions();
-            assertEquals(19, il.size());
-            List<Map<String, Object>> resultJson = il.createJson();
-
-            assertEquals("Continue onto Obere Landstrae", resultJson.get(0).get("text"));
-            assertEquals("get off the bike", resultJson.get(0).get("annotationText"));
-            assertEquals("Turn sharp left onto Kirchengasse", resultJson.get(1).get("text"));
-            assertEquals("get off the bike", resultJson.get(1).get("annotationText"));
-
-            assertEquals("Turn sharp right onto Pfarrplatz", resultJson.get(2).get("text"));
-            assertEquals("Turn right onto Margarethenstrae", resultJson.get(3).get("text"));
-            assertEquals("Turn left onto Hoher Markt", resultJson.get(4).get("text"));
-            assertEquals("Turn slight right onto Wegscheid", resultJson.get(5).get("text"));
-            assertEquals("Turn slight left onto Untere Landstrae", resultJson.get(6).get("text"));
-            assertEquals("Turn right onto Ringstrae, L73", resultJson.get(7).get("text"));
-            assertEquals("Continue onto Eyblparkstrae", resultJson.get(8).get("text"));
-            assertEquals("Continue onto Austrae", resultJson.get(9).get("text"));
-            assertEquals("Turn slight left onto Rechte Kremszeile", resultJson.get(10).get("text"));
-            //..
-            assertEquals("Turn right onto Treppelweg", resultJson.get(15).get("text"));
-            assertEquals("cycleway", resultJson.get(15).get("annotationText"));
-
-        } catch (Exception ex)
-        {
-            throw new RuntimeException("cannot handle osm file " + tmpOsmFile, ex);
-        } finally
-        {
-            Helper.removeDir(new File(tmpGraphFile));
-        }
-    }
-
-    @Test
-    public void testMonacoVia()
-    {
-        GraphHopper hopper = new GraphHopper().
-                setStoreOnFlush(true).
-                setOSMFile(osmFile).
-                setCHEnable(false).
-                setGraphHopperLocation(graphFile).
-                setEncodingManager(new EncodingManager(importVehicles)).
-                importOrLoad();
-
-        GHResponse rsp = hopper.route(new GHRequest().
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                addPoint(new GHPoint(43.74958, 7.436566)).
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                setAlgorithm("astar").setVehicle(vehicle).setWeighting(weightCalcStr));
-
-        assertEquals(6875.1, rsp.getDistance(), .1);
-        assertEquals(179, rsp.getPoints().getSize());
-
-        InstructionList il = rsp.getInstructions();
-        assertEquals(26, il.size());
-        List<Map<String, Object>> resultJson = il.createJson();
-        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
-        assertEquals("Turn slight left onto Avenue des Papalins", resultJson.get(1).get("text"));
-        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
-        assertEquals("Turn left", resultJson.get(3).get("text"));
-        assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
-
-        assertEquals("Stopover 1", resultJson.get(12).get("text"));
-
-        assertEquals("Continue onto Avenue Albert II", resultJson.get(20).get("text"));
-        assertEquals("Turn left", resultJson.get(21).get("text"));
-        assertEquals("Turn right onto Quai Jean-Charles Rey", resultJson.get(22).get("text"));
-        assertEquals("Turn sharp left onto Avenue des Papalins", resultJson.get(23).get("text"));
-        assertEquals("Turn slight right onto Avenue des Guelfes", resultJson.get(24).get("text"));
-        assertEquals("Finish!", resultJson.get(25).get("text"));
-
-        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
-        assertEquals(289, (Double) resultJson.get(1).get("distance"), 1);
-        assertEquals(10, (Double) resultJson.get(2).get("distance"), 1);
-        assertEquals(43, (Double) resultJson.get(3).get("distance"), 1);
-        assertEquals(122, (Double) resultJson.get(4).get("distance"), 1);
-        assertEquals(447, (Double) resultJson.get(5).get("distance"), 1);
-
-        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
-        assertEquals(207, (Long) resultJson.get(1).get("time") / 1000);
-        assertEquals(7, (Long) resultJson.get(2).get("time") / 1000);
-        assertEquals(30, (Long) resultJson.get(3).get("time") / 1000);
-        assertEquals(87, (Long) resultJson.get(4).get("time") / 1000);
-        assertEquals(321, (Long) resultJson.get(5).get("time") / 1000);
-    }
-}
diff --git a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java b/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
index 6f0ffc7d6c..caa7680d98 100644
--- a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
@@ -24,7 +24,9 @@
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index adfe9ea1ec..0048b97018 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -17,33 +17,37 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.Helper;
+
 import static com.graphhopper.storage.AbstractGraphStorageTester.*;
+
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.*;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
+
+import java.util.*;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class PathTest
 {
-    private final EncodingManager carManager = new EncodingManager("CAR");
-    private final FlagEncoder encoder = new EncodingManager("CAR").getEncoder("CAR");
+    private final FlagEncoder encoder = new CarFlagEncoder();
+    private final EncodingManager carManager = new EncodingManager(encoder);
+    private final EncodingManager mixedEncoders = new EncodingManager(
+            new CarFlagEncoder(), new FootFlagEncoder(), new BikeFlagEncoder());
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation tr = trMap.getWithFallBack(Locale.US);
+    private final AngleCalc ac = new AngleCalc();
+    private final RoundaboutGraph roundaboutGraph = new RoundaboutGraph();
 
     @Test
     public void testFound()
@@ -141,7 +145,7 @@ public void testWayList()
         path.extract();
         // 2-1-0
         assertPList(Helper.createPointList(2, 0.1, 11, 1, 10, 1, 1, 0.1, 9, 1, 8, 1, 0, 0.1), path.calcPoints());
-        
+
         instr = path.calcInstructions(tr);
         res = instr.createJson();
         tmp = res.get(0);
@@ -192,16 +196,327 @@ public void testFindInstruction()
         path.setEdgeEntry(e1);
         path.extract();
 
-        path.calcInstructions(tr);
-        Instruction nextInstr1 = path.findInstruction(0.0, 0.1);
-        Instruction nextInstr2 = path.findInstruction(5.0, 0.4);
-        Instruction nextInstr3 = path.findInstruction(9.0, 0.53);
-        Instruction nextInstr4 = path.findInstruction(7.8, 0.25);
+        InstructionList il = path.calcInstructions(tr);
+        Instruction nextInstr0 = il.find(-0.001, 0.0, 1000);
+        assertEquals(Instruction.CONTINUE_ON_STREET, nextInstr0.getSign());
 
+        Instruction nextInstr1 = il.find(0.001, 0.001, 1000);
         assertEquals(Instruction.TURN_RIGHT, nextInstr1.getSign());
+
+        Instruction nextInstr2 = il.find(5.0, 0.004, 1000);
         assertEquals(Instruction.TURN_LEFT, nextInstr2.getSign());
+
+        Instruction nextInstr3 = il.find(9.99, 0.503, 1000);
         assertEquals(Instruction.TURN_SHARP_LEFT, nextInstr3.getSign());
+
+        // a bit far away ...
+        Instruction nextInstr4 = il.find(7.40, 0.25, 20000);
         assertEquals(Instruction.FINISH, nextInstr4.getSign());
+
+        // too far away
+        assertNull(il.find(50.8, 50.25, 1000));
+    }
+
+    private class RoundaboutGraph
+    {
+        private EdgeIteratorState edge3to6, edge3to9;
+        boolean clockwise = false;
+        final public Graph g = new GraphBuilder(mixedEncoders).create();
+        final public NodeAccess na = g.getNodeAccess();
+        List<EdgeIteratorState> roundaboutEdges = new LinkedList<EdgeIteratorState>();
+
+        private RoundaboutGraph()
+        {
+            //                          
+            //      8
+            //       \
+            //         5
+            //       /  \
+            //  1 - 2    4 - 7
+            //       \  /
+            //        3
+            //        | \
+            //        6 [ 9 ] edge 9 is turned off in default mode 
+
+            na.setNode(1, 52.514, 13.348);
+            na.setNode(2, 52.514, 13.349);
+            na.setNode(3, 52.5135, 13.35);
+            na.setNode(4, 52.514, 13.351);
+            na.setNode(5, 52.5145, 13.351);
+            na.setNode(6, 52.513, 13.35);
+            na.setNode(7, 52.514, 13.352);
+            na.setNode(8, 52.515, 13.351);
+            na.setNode(9, 52.513, 13.351);
+
+
+            EdgeIteratorState tmpEdge;
+            tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
+
+            // roundabout
+            tmpEdge = g.edge(3, 2, 5, false).setName("2-3");
+            roundaboutEdges.add(tmpEdge.detach(false));
+            tmpEdge = g.edge(4, 3, 5, false).setName("3-4");
+            roundaboutEdges.add(tmpEdge.detach(false));
+            tmpEdge = g.edge(5, 4, 5, false).setName("4-5");
+            roundaboutEdges.add(tmpEdge.detach(false));
+            tmpEdge = g.edge(2, 5, 5, false).setName("5-2");
+            roundaboutEdges.add(tmpEdge.detach(false));
+
+            tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
+            tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+
+            tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+            edge3to6 = tmpEdge.detach(false);
+
+            tmpEdge = g.edge(3, 9, 5, false).setName("3-9");
+            edge3to9 = tmpEdge.detach(false);
+
+            setRoundabout(clockwise);
+            inverse3to9();
+
+        }
+
+        public void setRoundabout( boolean clockwise )
+        {
+            for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
+            {
+                for (EdgeIteratorState edge : roundaboutEdges)
+                {
+                    edge.setFlags(encoder.setAccess(edge.getFlags(), clockwise, !clockwise));
+                    edge.setFlags(encoder.setBool(edge.getFlags(), encoder.K_ROUNDABOUT, true));
+                }
+            }
+            this.clockwise = clockwise;
+        }
+
+        public void inverse3to9()
+        {
+            for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
+            {
+                long flags = edge3to9.getFlags();
+                edge3to9.setFlags(encoder.setAccess(flags, !encoder.isForward(flags), false));
+            }
+        }
+
+        public void inverse3to6()
+        {
+            for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
+            {
+                long flags = edge3to6.getFlags();
+                edge3to6.setFlags(encoder.setAccess(flags, !encoder.isForward(flags), true));
+            }
+        }
+
+
+        private double getAngle( int n1, int n2, int n3, int n4 )
+        {
+            double inOrientation = ac.calcOrientation(na.getLat(n1), na.getLon(n1), na.getLat(n2), na.getLon(n2));
+            double outOrientation = ac.calcOrientation(na.getLat(n3), na.getLon(n3), na.getLat(n4), na.getLon(n4));
+            outOrientation = ac.alignOrientation(inOrientation, outOrientation);
+            double delta = (inOrientation - outOrientation);
+            delta = clockwise ? (Math.PI + delta) : -1 * (Math.PI - delta);
+            return delta;
+        }
+    }
+
+    /**
+     * Test roundabout instructions for different profiles
+     */
+    @Test
+    public void testCalcInstructionsRoundabout()
+    {
+        for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
+        {
+            Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                    .calcPath(1, 8);
+            InstructionList wayList = p.calcInstructions(tr);
+            // Test instructions
+            List<String> tmpList = pick("text", wayList.createJson());
+            assertEquals(Arrays.asList("Continue onto MainStreet",
+                            "At roundabout, take exit 3 onto 5-8",
+                            "Finish!"),
+                    tmpList);
+            // Test Radian
+            double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
+            RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+            assertEquals(delta, instr.getRadian(), 0.01);
+
+            // case of continuing a street through a roundabout
+            p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
+            wayList = p.calcInstructions(tr);
+            tmpList = pick("text", wayList.createJson());
+            assertEquals(Arrays.asList("Continue onto MainStreet",
+                            "At roundabout, take exit 2 onto MainStreet",
+                            "Finish!"),
+                    tmpList);
+            // Test Radian
+            delta = roundaboutGraph.getAngle(1, 2, 4, 7);
+            instr = (RoundaboutInstruction) wayList.get(1);
+            assertEquals(delta, instr.getRadian(), 0.01);
+        }
+    }
+
+    /**
+     * case starting in Roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutBegin()
+    {
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(2, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("At roundabout, take exit 3 onto 5-8",
+                        "Finish!"),
+                tmpList);
+    }
+
+    /**
+     * case with one node being containig already exit
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutDirectExit()
+    {
+        roundaboutGraph.inverse3to9();
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(6, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto 3-6",
+                        "At roundabout, take exit 3 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        roundaboutGraph.inverse3to9();
+    }
+
+    /**
+     * case with one edge being not an exit
+     */
+    @Test
+    public void testCalcInstructionsRoundabout2()
+    {
+        roundaboutGraph.inverse3to6();
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "At roundabout, take exit 2 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+        roundaboutGraph.inverse3to6();
+
+    }
+
+
+    /**
+     * see https://github.com/graphhopper/graphhopper/issues/353
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutIssue353()
+    {
+        final Graph g = new GraphBuilder(carManager).create();
+        final NodeAccess na = g.getNodeAccess();
+
+
+        //
+        //          8
+        //           \
+        //            5
+        //           /  \
+        //  11- 1 - 2    4 - 7
+        //      |     \  /
+        //      10 -9 -3
+        //       \    |
+        //        --- 6
+
+        na.setNode(1, 52.514, 13.348);
+        na.setNode(2, 52.514, 13.349);
+        na.setNode(3, 52.5135, 13.35);
+        na.setNode(4, 52.514, 13.351);
+        na.setNode(5, 52.5145, 13.351);
+        na.setNode(6, 52.513, 13.35);
+        na.setNode(7, 52.514, 13.352);
+        na.setNode(8, 52.515, 13.351);
+
+        // Sidelane
+        na.setNode(9, 52.5135, 13.349);
+        na.setNode(10, 52.5135, 13.348);
+        na.setNode(11, 52.514, 13.347);
+
+
+        EdgeIteratorState tmpEdge;
+        tmpEdge = g.edge(2, 1, 5, false).setName("MainStreet");
+        tmpEdge = g.edge(1, 11, 5, false).setName("MainStreet");
+
+
+        // roundabout
+        tmpEdge = g.edge(3, 9, 2, false).setName("3-9");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(9, 10, 2, false).setName("9-10");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(6, 10, 2, false).setName("6-10");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(10, 1, 2, false).setName("10-1");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(3, 2, 5, false).setName("2-3");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(4, 3, 5, false).setName("3-4");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(5, 4, 5, false).setName("4-5");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(2, 5, 5, false).setName("5-2");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+
+        tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
+        tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+        tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+
+
+        Path p = new Dijkstra(g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(6, 11);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("At roundabout, take exit 1 onto MainStreet",
+                        "Finish!"),
+                tmpList);
+    }
+
+    /**
+     * clockwise roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutClockwise()
+    {
+
+        roundaboutGraph.setRoundabout(true);
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "At roundabout, take exit 1 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+    List<String> pick( String key, List<Map<String, Object>> instructionJson )
+    {
+        List<String> list = new ArrayList<String>();
+
+        for (Map<String, Object> json : instructionJson)
+        {
+            list.add(json.get(key).toString());
+        }
+        return list;
     }
 
 }
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index f97d893b5c..c45f2cc45f 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -17,38 +17,39 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.DefaultEdgeFilter;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
+
 import static com.graphhopper.storage.index.QueryResult.Position.*;
+
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
 import gnu.trove.map.TIntObjectMap;
+
 import java.util.Arrays;
+
 import org.junit.After;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 
 /**
- *
  * @author Peter Karich
  */
 public class QueryGraphTest
 {
-    private final EncodingManager encodingManager = new EncodingManager("CAR");
+    private EncodingManager encodingManager;
+    private FlagEncoder carEncoder;
     private GraphStorage g;
 
     @Before
     public void setUp()
     {
+        carEncoder = new CarFlagEncoder();
+        encodingManager = new EncodingManager(carEncoder);
         g = new GraphHopperStorage(new RAMDirectory(), encodingManager, false).create(100);
     }
 
@@ -160,7 +161,7 @@ public void testFillVirtualEdges()
         {
 
             @Override
-            void fillVirtualEdges( TIntObjectMap<QueryGraph.VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl )
+            void fillVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl )
             {
                 super.fillVirtualEdges(node2Edge, towerNode, mainExpl);
                 // ignore nodes should include baseNode == 1
@@ -260,7 +261,7 @@ public void testVirtEdges()
         EdgeIterator iter = g.createEdgeExplorer().setBaseNode(0);
         iter.next();
 
-        QueryGraph.VirtualEdgeIterator vi = new QueryGraph.VirtualEdgeIterator(2);
+        VirtualEdgeIterator vi = new VirtualEdgeIterator(2);
         vi.add(iter.detach(false));
 
         assertTrue(vi.next());
@@ -313,7 +314,7 @@ public void testLoopStreet_Issue151()
 
         QueryResult qr = new QueryResult(-0.0005, 0.001);
         qr.setClosestEdge(edge);
-        qr.setWayIndex(0);
+        qr.setWayIndex(1);
         qr.calcSnappedPoint(new DistanceCalc2D());
 
         QueryGraph qg = new QueryGraph(g);
@@ -332,8 +333,7 @@ public void testOneWayLoop_Issue162()
         // | x
         // 0<-\
         // |
-        // 1
-        FlagEncoder carEncoder = encodingManager.getSingle();
+        // 1        
         NodeAccess na = g.getNodeAccess();
         na.setNode(0, 0, 0);
         na.setNode(1, 0, -0.001);
@@ -356,12 +356,12 @@ public void testOneWayLoop_Issue162()
         assertEquals(2, GHUtility.count(ee.setBaseNode(qr.getClosestNode())));
         EdgeIterator iter = ee.setBaseNode(qr.getClosestNode());
         iter.next();
-        assertTrue(iter.toString(), carEncoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertFalse(iter.toString(), carEncoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertTrue(iter.toString(), carEncoder.isForward(iter.getFlags()));
+        assertFalse(iter.toString(), carEncoder.isBackward(iter.getFlags()));
 
         iter.next();
-        assertFalse(iter.toString(), carEncoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(iter.toString(), carEncoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertFalse(iter.toString(), carEncoder.isForward(iter.getFlags()));
+        assertTrue(iter.toString(), carEncoder.isBackward(iter.getFlags()));
     }
 
     @Test
@@ -381,6 +381,35 @@ public void testEdgesShareOneNode()
         assertNotNull(GHUtility.getEdge(queryGraph, 0, 3));
     }
 
+    @Test
+    public void testAvoidDuplicateVirtualNodesIfIdentical()
+    {
+        initGraph(g);
+
+        EdgeIteratorState edgeState = GHUtility.getEdge(g, 0, 2);
+        QueryResult res1 = createLocationResult(0.5, 0, edgeState, 0, EDGE);
+        QueryResult res2 = createLocationResult(0.5, 0, edgeState, 0, EDGE);
+        QueryGraph queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(res1, res2));
+        assertEquals(new GHPoint(0.5, 0), res1.getSnappedPoint());
+        assertEquals(new GHPoint(0.5, 0), res2.getSnappedPoint());
+        assertEquals(3, res1.getClosestNode());
+        assertEquals(3, res2.getClosestNode());
+
+        // force skip due to **tower** node snapping in phase 2, but no virtual edges should be created for res1
+        edgeState = GHUtility.getEdge(g, 0, 1);
+        res1 = createLocationResult(1, 0, edgeState, 0, EDGE);
+        // now create virtual edges
+        edgeState = GHUtility.getEdge(g, 0, 2);
+        res2 = createLocationResult(0.5, 0, edgeState, 0, EDGE);
+        queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(res1, res2));
+        // make sure only one virtual node was created
+        assertEquals(queryGraph.getNodes(), g.getNodes() + 1);
+        EdgeIterator iter = queryGraph.createEdgeExplorer().setBaseNode(0);
+        assertEquals(GHUtility.asSet(1, 3), GHUtility.getNeighbors(iter));
+    }
+
     @Test
     public void testGetEdgeProps()
     {
@@ -404,7 +433,7 @@ PointList getPoints( Graph g, int base, int adj )
     }
 
     public QueryResult createLocationResult( double lat, double lon,
-            EdgeIteratorState edge, int wayIndex, QueryResult.Position pos )
+                                             EdgeIteratorState edge, int wayIndex, QueryResult.Position pos )
     {
         if (edge == null)
             throw new IllegalStateException("Specify edge != null");
@@ -417,7 +446,7 @@ public QueryResult createLocationResult( double lat, double lon,
     }
 
     @Test
-    public void testIterationBug_163()
+    public void testIteration_Issue163()
     {
         EdgeFilter outEdgeFilter = new DefaultEdgeFilter(encodingManager.getEncoder("CAR"), false, true);
         EdgeFilter inEdgeFilter = new DefaultEdgeFilter(encodingManager.getEncoder("CAR"), true, false);
@@ -441,10 +470,9 @@ public void testIterationBug_163()
         assertEdgeIdsStayingEqual(inExplorer, outExplorer, nodeA, nodeB);
 
         // setup query results
-        EdgeIterator it = outExplorer.setBaseNode(0);
-        it.next();
-        QueryResult res1 = createLocationResult(1.5, 3, it, 0, QueryResult.Position.EDGE);
-        QueryResult res2 = createLocationResult(1.5, 7, it, 0, QueryResult.Position.EDGE);
+        EdgeIteratorState it = GHUtility.getEdge(g, nodeA, nodeB);
+        QueryResult res1 = createLocationResult(1.5, 3, it, 1, QueryResult.Position.EDGE);
+        QueryResult res2 = createLocationResult(1.5, 7, it, 2, QueryResult.Position.EDGE);
 
         QueryGraph q = new QueryGraph(g);
         q.lookup(Arrays.asList(res1, res2));
@@ -478,4 +506,187 @@ private void assertEdgeIdsStayingEqual( EdgeExplorer inExplorer, EdgeExplorer ou
         assertEquals("The edge id is not the same,", expectedEdgeId, it.getEdge());
         assertFalse(it.next());
     }
+
+    @Test
+    public void testTurnCostsProperlyPropagated_Issue282()
+    {
+        TurnCostExtension turnExt = new TurnCostExtension();
+        FlagEncoder encoder = new CarFlagEncoder(5, 5, 15);
+
+        GraphStorage graphWithTurnCosts = new GraphHopperStorage(new RAMDirectory(),
+                new EncodingManager(encoder), false, turnExt).
+                create(100);
+        NodeAccess na = graphWithTurnCosts.getNodeAccess();
+        na.setNode(0, .00, .00);
+        na.setNode(1, .00, .01);
+        na.setNode(2, .01, .01);
+
+        EdgeIteratorState edge0 = graphWithTurnCosts.edge(0, 1, 10, true);
+        EdgeIteratorState edge1 = graphWithTurnCosts.edge(2, 1, 10, true);
+
+        QueryGraph qGraph = new QueryGraph(graphWithTurnCosts);
+        FastestWeighting weighting = new FastestWeighting(encoder);
+        TurnWeighting turnWeighting = new TurnWeighting(weighting, encoder, (TurnCostExtension) qGraph.getExtension());
+
+        assertEquals(0, turnWeighting.calcTurnWeight(edge0.getEdge(), 1, edge1.getEdge()), .1);
+
+        // now use turn costs and QueryGraph
+        turnExt.addTurnInfo(edge0.getEdge(), 1, edge1.getEdge(), encoder.getTurnFlags(false, 10));
+        assertEquals(10, turnWeighting.calcTurnWeight(edge0.getEdge(), 1, edge1.getEdge()), .1);
+
+        QueryResult res1 = createLocationResult(0.000, 0.005, edge0, 0, QueryResult.Position.EDGE);
+        QueryResult res2 = createLocationResult(0.005, 0.010, edge1, 0, QueryResult.Position.EDGE);
+
+        qGraph.lookup(Arrays.asList(res1, res2));
+
+        int fromQueryEdge = GHUtility.getEdge(qGraph, res1.getClosestNode(), 1).getEdge();
+        int toQueryEdge = GHUtility.getEdge(qGraph, res2.getClosestNode(), 1).getEdge();
+
+        assertEquals(10, turnWeighting.calcTurnWeight(fromQueryEdge, 1, toQueryEdge), .1);
+
+        graphWithTurnCosts.close();
+    }
+
+    private void initHorseshoeGraph( Graph g )
+    {
+        // setup graph
+        //   ____
+        //  |    |
+        //  |    |
+        //  0    1
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0, 0);
+        na.setNode(1, 0, 2);
+        g.edge(0, 1, 10, true).setWayGeometry(Helper.createPointList(2, 0, 2, 2));
+    }
+
+    private QueryResult fakeEdgeQueryResult( EdgeIteratorState edge, double lat, double lon, int wayIndex )
+    {
+        QueryResult qr = new QueryResult(lat, lon);
+        qr.setClosestEdge(edge);
+        qr.setWayIndex(wayIndex);
+        qr.setSnappedPosition(EDGE);
+        qr.calcSnappedPoint(new DistanceCalc2D());
+        return qr;
+    }
+
+    private boolean getEdgePreference( QueryGraph queryGraph, int virtualEdgeTypeId, boolean reverse, boolean _default )
+    {
+        boolean edgeUnfavored = queryGraph.virtualEdges.get(virtualEdgeTypeId).getBoolean(
+                EdgeIteratorState.K_UNFAVORED_EDGE, reverse, _default);
+        return edgeUnfavored;
+    }
+
+    @Test
+    public void testEnforceHeading()
+    {
+
+        initHorseshoeGraph(g);
+        EdgeIteratorState edge = GHUtility.getEdge(g, 0, 1);
+
+        // query result on first vertical part of way (upward)
+        QueryResult qr = fakeEdgeQueryResult(edge, 1.5, 0, 0);
+        QueryGraph queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(qr));
+
+        // enforce going out north
+        queryGraph.enforceHeading(qr.getClosestNode(), 0., false);
+        // test penalized south
+        boolean expect = true;
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE_REV, false, !expect));
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE, true, !expect));
+
+        queryGraph.clearUnfavoredStatus();
+        // test cleared edges south
+        expect = false;
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE_REV, false, !expect));
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE, true, !expect));
+
+        // enforce coming in north
+        queryGraph.enforceHeading(qr.getClosestNode(), 180., true);
+        // test penalized south
+        expect = true;
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE_REV, true, !expect));
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE, false, !expect));
+
+        // query result on second vertical part of way (downward)
+        qr = fakeEdgeQueryResult(edge, 1.5, 2, 2);
+        queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(qr));
+
+        // enforce going north
+        queryGraph.enforceHeading(qr.getClosestNode(), 0., false);
+        // test penalized south
+        expect = true;
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_ADJ, false, !expect));
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_ADJ_REV, true, !expect));
+
+        queryGraph.clearUnfavoredStatus();
+        // enforce coming in north
+        queryGraph.enforceHeading(qr.getClosestNode(), 180., true);
+        // test penalized south
+        expect = true;
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_ADJ, true, !expect));
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_ADJ_REV, false, !expect));
+    }
+
+    @Test
+    public void testEnforceHeadingByEdgeId()
+    {
+
+        initHorseshoeGraph(g);
+        EdgeIteratorState edge = GHUtility.getEdge(g, 0, 1);
+
+        // query result on first vertical part of way (upward)
+        QueryResult qr = fakeEdgeQueryResult(edge, 1.5, 0, 0);
+        QueryGraph queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(qr));
+
+        // enforce coming in north
+        queryGraph.enforceHeadingByEdgeId(2, 1, false);
+        // test penalized south
+        boolean expect = true;
+        VirtualEdgeIteratorState incomingEdge = (VirtualEdgeIteratorState) queryGraph.getEdgeProps(1, 2);
+
+        VirtualEdgeIteratorState incomingEdgeReverse = (VirtualEdgeIteratorState) queryGraph.getEdgeProps(1, incomingEdge.getBaseNode());
+        // expect incoming edge in reverse direction to be unfavored
+        assertEquals(expect, incomingEdge.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, true, !expect));
+        // expect reverse incoming edge to be unfavored
+        assertEquals(expect, incomingEdgeReverse.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, false, !expect));
+
+        queryGraph.clearUnfavoredStatus();
+        expect = false;
+        assertEquals(expect, incomingEdge.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, true, !expect));
+        // expect reverse incoming edge to be unfavored
+        assertEquals(expect, incomingEdgeReverse.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, false, !expect));
+    }
+
+    @Test
+    public void testInternalAPIOriginalTraversalKey()
+    {
+        initGraph(g);
+
+        EdgeExplorer explorer = g.createEdgeExplorer();
+        QueryGraph queryGraph = new QueryGraph(g);
+        EdgeIterator iter = explorer.setBaseNode(1);
+        assertTrue(iter.next());
+        int origEdgeId = iter.getEdge();
+        QueryResult res = createLocationResult(2, 1.5, iter, 1, PILLAR);
+        queryGraph.lookup(Arrays.asList(res));
+
+        assertEquals(new GHPoint(1.5, 1.5), res.getSnappedPoint());
+        assertEquals(3, res.getClosestNode());
+
+        EdgeExplorer qGraphExplorer = queryGraph.createEdgeExplorer();
+        iter = qGraphExplorer.setBaseNode(3);
+        assertTrue(iter.next());
+        assertEquals(0, iter.getAdjNode());
+        assertEquals(GHUtility.createEdgeKey(1, 0, origEdgeId, false),
+                ((VirtualEdgeIteratorState) queryGraph.getEdgeProps(iter.getEdge(), 0)).getOriginalTraversalKey());
+
+        assertTrue(iter.next());
+        assertEquals(1, iter.getAdjNode());
+        assertEquals(GHUtility.createEdgeKey(0, 1, origEdgeId, false),
+                ((VirtualEdgeIteratorState) queryGraph.getEdgeProps(iter.getEdge(), 1)).getOriginalTraversalKey());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
index 9ddf6ff9ce..addcbcddfc 100644
--- a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
+++ b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
@@ -21,22 +21,27 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.PrinctonReader;
 import com.graphhopper.reader.dem.SRTMProvider;
+import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.TestAlgoCollector.AlgoHelperEntry;
 import com.graphhopper.routing.util.TestAlgoCollector.OneRun;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.StopWatch;
+
 import java.io.File;
 import java.io.IOException;
 import java.util.*;
-import java.util.Map.Entry;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.zip.GZIPInputStream;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -78,11 +83,100 @@ public void setUp()
     @Test
     public void testMonaco()
     {
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+        Graph g = runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
                 createMonacoCar(), "CAR", true, "CAR", "shortest", false);
+
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+
+        // When OSM file stays unchanged make static edge and node IDs a requirement
+        assertEquals(GHUtility.asSet(9, 111, 182), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(10)));
+        assertEquals(GHUtility.asSet(19, 21), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(20)));
+        assertEquals(GHUtility.asSet(478, 84, 83), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(480)));
+
+        assertEquals(43.736989, g.getNodeAccess().getLat(10), 1e-6);
+        assertEquals(7.429758, g.getNodeAccess().getLon(201), 1e-6);
+    }
+
+    @Test
+    public void testMonacoMotorcycle()
+    {
+        List<OneRun> list = new ArrayList<OneRun>();
+        list.add(new OneRun(43.730729, 7.42135, 43.727697, 7.419199, 2697, 117));
+        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3749, 170));
+        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.4277, 3164, 165));
+        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 2423, 141));
+        list.add(new OneRun(43.730949, 7.412338, 43.739643, 7.424542, 2253, 120));
+        list.add(new OneRun(43.727592, 7.419333, 43.727712, 7.419333, 0, 1));
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-mc-gh",
+                list, "motorcycle", true, "motorcycle", "fastest", true);
+
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
+    @Test
+    public void testBike2_issue432()
+    {
+        List<OneRun> list = new ArrayList<OneRun>();
+        list.add(new OneRun(52.349969, 8.013813, 52.349713, 8.013293, 56, 7));
+        // reverse route avoids the location
+        list.add(new OneRun(52.349713, 8.013293, 52.349969, 8.013813, 293, 21));
+        runAlgo(testCollector, "files/map-bug432.osm.gz", "target/map-bug432-gh",
+                list, "bike2", true, "bike2", "fastest", true);
+
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
+    @Test
+    public void testMonacoAllAlgorithmsWithBaseGraph()
+    {
+        String vehicle = "car";
+        String graphFile = "target/monaco-gh";
+        String osmFile = "files/monaco.osm.gz";
+        String importVehicles = vehicle;
+
+        Helper.removeDir(new File(graphFile));
+        GraphHopper hopper = new GraphHopper().
+                // avoid that path.getDistance is too different to path.getPoint.calcDistance
+                setWayPointMaxDistance(0).
+                setOSMFile(osmFile).
+                setCHEnable(false).
+                setGraphHopperLocation(graphFile).
+                setEncodingManager(new EncodingManager(importVehicles));
+
+        hopper.importOrLoad();
+
+        FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
+        Weighting weighting = hopper.createWeighting(new WeightingMap("shortest"), encoder);
+
+        List<AlgoHelperEntry> prepares = createAlgos(hopper.getGraph(), hopper.getLocationIndex(),
+                encoder, true, TraversalMode.NODE_BASED, weighting, hopper.getEncodingManager());
+        AlgoHelperEntry chPrepare = prepares.get(prepares.size() - 1);
+        if (!(chPrepare.getQueryGraph() instanceof LevelGraph))
+            throw new IllegalStateException("Last prepared queryGraph has to be a levelGraph");
+
+        // set all normal algorithms to baseGraph of already prepared to see if all algorithms still work
+        Graph baseGraphOfCHPrepared = chPrepare.getQueryGraph().getBaseGraph();
+        for (AlgoHelperEntry ahe : prepares)
+        {
+            if (!(ahe.getQueryGraph() instanceof LevelGraph))
+            {
+                ahe.setQueryGraph(baseGraphOfCHPrepared);
+            }
+        }
+
+        List<OneRun> forEveryAlgo = createMonacoCar();
+        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
+        for (AlgoHelperEntry entry : prepares)
+        {
+            LocationIndex idx = entry.getIdx();
+            for (OneRun oneRun : forEveryAlgo)
+            {
+                List<QueryResult> list = oneRun.getList(idx, edgeFilter);
+                testCollector.assertDistance(entry, list, oneRun);
+            }
+        }
+    }
+
     @Test
     public void testOneWayCircleBug()
     {
@@ -122,9 +216,7 @@ public void testMoscowTurnCosts()
     {
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(55.813357, 37.5958585, 55.811042, 37.594689, 1043.99, 12));
-
-        // TODO #163
-        // list.add(new OneRun(55.813159,37.593884, 55.811278,37.594217, 1000, 12));
+        list.add(new OneRun(55.813159, 37.593884, 55.811278, 37.594217, 1048, 13));
         // TODO include CH
         boolean testAlsoCH = false, is3D = false;
         runAlgo(testCollector, "files/moscow.osm.gz", "target/graph-moscow",
@@ -178,9 +270,17 @@ public void testMonacoMixed()
     @Test
     public void testMonacoFoot()
     {
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+        Graph g = runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
                 createMonacoFoot(), "FOOT", true, "FOOT", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+
+        // see testMonaco for a similar ID test
+        assertEquals(GHUtility.asSet(2, 908, 570), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(10)));
+        assertEquals(GHUtility.asSet(443, 954, 739), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(440)));
+        assertEquals(GHUtility.asSet(910, 403, 122, 913), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(911)));
+
+        assertEquals(43.743705, g.getNodeAccess().getLat(100), 1e-6);
+        assertEquals(7.426362, g.getNodeAccess().getLon(701), 1e-6);
     }
 
     @Test
@@ -421,11 +521,11 @@ public void testNeudrossenfeld()
      * @param testAlsoCH if true also the CH algorithms will be tested which needs preparation and
      * takes a bit longer
      */
-    void runAlgo( TestAlgoCollector testCollector, String osmFile,
-            String graphFile, List<OneRun> forEveryAlgo, String importVehicles,
-            boolean testAlsoCH, String vehicle, String weightCalcStr, boolean is3D )
+    Graph runAlgo( TestAlgoCollector testCollector, String osmFile,
+                   String graphFile, List<OneRun> forEveryAlgo, String importVehicles,
+                   boolean testAlsoCH, String vehicle, String weightStr, boolean is3D )
     {
-        AlgorithmPreparation tmpPrepare = null;
+        AlgoHelperEntry algoEntry = null;
         OneRun tmpOneRun = null;
         try
         {
@@ -446,28 +546,30 @@ void runAlgo( TestAlgoCollector testCollector, String osmFile,
             TraversalMode tMode = importVehicles.toLowerCase().contains("turncosts=true")
                     ? TraversalMode.EDGE_BASED_1DIR : TraversalMode.NODE_BASED;
             FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
-            Weighting weighting = hopper.createWeighting(new WeightingMap(weightCalcStr), encoder);
+            Weighting weighting = hopper.createWeighting(new WeightingMap(weightStr), encoder);
 
-            Collection<Entry<AlgorithmPreparation, LocationIndex>> prepares = RoutingAlgorithmSpecialAreaTests.
-                    createAlgos(hopper.getGraph(), hopper.getLocationIndex(), encoder, testAlsoCH, tMode, weighting, hopper.getEncodingManager());
+            Collection<AlgoHelperEntry> prepares = createAlgos(hopper.getGraph(), hopper.getLocationIndex(),
+                    encoder, testAlsoCH, tMode, weighting, hopper.getEncodingManager());
             EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
-            for (Entry<AlgorithmPreparation, LocationIndex> entry : prepares)
+            for (AlgoHelperEntry entry : prepares)
             {
-                tmpPrepare = entry.getKey();
-                LocationIndex idx = entry.getValue();
+                algoEntry = entry;
+                LocationIndex idx = entry.getIdx();
                 for (OneRun oneRun : forEveryAlgo)
                 {
                     tmpOneRun = oneRun;
                     List<QueryResult> list = oneRun.getList(idx, edgeFilter);
-                    testCollector.assertDistance(tmpPrepare, list, oneRun);
+                    testCollector.assertDistance(algoEntry, list, oneRun);
                 }
             }
+
+            return hopper.getGraph();
         } catch (Exception ex)
         {
-            if (tmpPrepare == null)
+            if (algoEntry == null)
                 throw new RuntimeException("cannot handle file " + osmFile + ", " + ex.getMessage(), ex);
 
-            throw new RuntimeException("cannot handle " + tmpPrepare.toString() + ", for " + tmpOneRun
+            throw new RuntimeException("cannot handle " + algoEntry.toString() + ", for " + tmpOneRun
                     + ", file " + osmFile + ", " + ex.getMessage(), ex);
         } finally
         {
@@ -487,18 +589,17 @@ public void testPerformance() throws IOException
         Graph graph = new GraphBuilder(eManager).create();
 
         String bigFile = "10000EWD.txt.gz";
-        new PrinctonReader(graph).setStream(new GZIPInputStream(PrinctonReader.class.getResourceAsStream(bigFile), 8 * (1 << 10))).read();
-        Collection<Entry<AlgorithmPreparation, LocationIndex>> prepares = RoutingAlgorithmSpecialAreaTests.
-                createAlgos(graph, null, encoder, false, TraversalMode.NODE_BASED, new ShortestWeighting(), eManager);
-        for (Entry<AlgorithmPreparation, LocationIndex> entry : prepares)
+        new PrinctonReader(graph).setStream(new GZIPInputStream(PrinctonReader.class.getResourceAsStream(bigFile))).read();
+        Collection<AlgoHelperEntry> prepares = createAlgos(graph, null, encoder, false, TraversalMode.NODE_BASED,
+                new ShortestWeighting(), eManager);
+        for (AlgoHelperEntry entry : prepares)
         {
-            AlgorithmPreparation prepare = entry.getKey();
             StopWatch sw = new StopWatch();
             for (int i = 0; i < N; i++)
             {
                 int node1 = Math.abs(rand.nextInt(graph.getNodes()));
                 int node2 = Math.abs(rand.nextInt(graph.getNodes()));
-                RoutingAlgorithm d = prepare.createAlgo();
+                RoutingAlgorithm d = entry.createAlgo(graph);
                 if (i >= noJvmWarming)
                     sw.start();
 
@@ -511,7 +612,7 @@ public void testPerformance() throws IOException
             }
 
             float perRun = sw.stop().getSeconds() / ((float) (N - noJvmWarming));
-            System.out.println("# " + getClass().getSimpleName() + " " + prepare.createAlgo().getName()
+            System.out.println("# " + getClass().getSimpleName() + " " + entry
                     + ":" + sw.stop().getSeconds() + ", per run:" + perRun);
             assertTrue("speed to low!? " + perRun + " per run", perRun < 0.08);
         }
@@ -529,7 +630,8 @@ public void testMonacoParallel() throws IOException
                 setEncodingManager(encodingManager).
                 setCHEnable(false).
                 setWayPointMaxDistance(0).
-                setOSMFile("files/monaco.osm.gz").setGraphHopperLocation(graphFile).
+                setOSMFile("files/monaco.osm.gz").
+                setGraphHopperLocation(graphFile).
                 importOrLoad();
         final Graph g = hopper.getGraph();
         final LocationIndex idx = hopper.getLocationIndex();
@@ -537,23 +639,22 @@ public void testMonacoParallel() throws IOException
         List<Thread> threads = new ArrayList<Thread>();
         final AtomicInteger integ = new AtomicInteger(0);
         int MAX = 100;
-        FlagEncoder carEncoder = encodingManager.getEncoder("CAR");
+        final FlagEncoder carEncoder = encodingManager.getEncoder("CAR");
 
         // testing if algorithms are independent. should be. so test only two algorithms. 
         // also the preparing is too costly to be called for every thread
         int algosLength = 2;
-        Weighting weighting = new ShortestWeighting();
+        final Weighting weighting = new ShortestWeighting();
         final EdgeFilter filter = new DefaultEdgeFilter(carEncoder);
         for (int no = 0; no < MAX; no++)
         {
             for (int instanceNo = 0; instanceNo < instances.size(); instanceNo++)
             {
-                RoutingAlgorithm[] algos = new RoutingAlgorithm[]
+                String[] algos = new String[]
                 {
-                    new AStar(g, carEncoder, weighting, TraversalMode.NODE_BASED),
-                    new DijkstraBidirectionRef(g, carEncoder, weighting, TraversalMode.NODE_BASED)
+                    "astar", "dijkstrabi"
                 };
-                for (final RoutingAlgorithm algo : algos)
+                for (final String algoStr : algos)
                 {
                     // an algorithm is not thread safe! reuse via clear() is ONLY appropriated if used from same thread!
                     final int instanceIndex = instanceNo;
@@ -563,21 +664,9 @@ public void testMonacoParallel() throws IOException
                         public void run()
                         {
                             OneRun oneRun = instances.get(instanceIndex);
-                            testCollector.assertDistance(new NoOpAlgorithmPreparation()
-                            {
-                                @Override
-                                public RoutingAlgorithm createAlgo()
-                                {
-                                    return algo;
-                                }
-
-                                @Override
-                                public String toString()
-                                {
-                                    return algo.toString();
-                                }
-
-                            }, oneRun.getList(idx, filter), oneRun);
+                            AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(weighting).algorithm(algoStr).build();
+                            testCollector.assertDistance(new AlgoHelperEntry(g, opts, idx),
+                                    oneRun.getList(idx, filter), oneRun);
                             integ.addAndGet(1);
                         }
                     };
@@ -602,4 +691,48 @@ public String toString()
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
         hopper.close();
     }
+
+    static List<AlgoHelperEntry> createAlgos( Graph g,
+                                              LocationIndex idx, final FlagEncoder encoder, boolean withCh,
+                                              final TraversalMode tMode, final Weighting weighting, final EncodingManager manager )
+    {
+        List<AlgoHelperEntry> prepare = new ArrayList<AlgoHelperEntry>();
+        prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.ASTAR, encoder, weighting, tMode), idx));
+        // later: include dijkstraOneToMany        
+        prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA, encoder, weighting, tMode), idx));
+
+        final AlgorithmOptions astarbiOpts = new AlgorithmOptions(AlgorithmOptions.ASTAR_BI, encoder, weighting, tMode);
+        astarbiOpts.getHints().put(AlgorithmOptions.ASTAR_BI + ".approximation", "BeelineSimplification");
+        final AlgorithmOptions dijkstrabiOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting, tMode);
+        prepare.add(new AlgoHelperEntry(g, astarbiOpts, idx));
+        prepare.add(new AlgoHelperEntry(g, dijkstrabiOpts, idx));
+
+        if (withCh)
+        {
+            final LevelGraph graphCH = (LevelGraph) ((GraphStorage) g).copyTo(new GraphBuilder(manager).
+                    set3D(g.getNodeAccess().is3D()).levelGraphCreate());
+            final PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
+                    graphCH, encoder, weighting, tMode);
+            prepareCH.doWork();
+            LocationIndex idxCH = new LocationIndexTree(graphCH.getBaseGraph(), new RAMDirectory()).prepareIndex();
+            prepare.add(new AlgoHelperEntry(graphCH, dijkstrabiOpts, idxCH)
+            {
+                @Override
+                public RoutingAlgorithm createAlgo( Graph qGraph )
+                {
+                    return prepareCH.createAlgo(qGraph, dijkstrabiOpts);
+                }
+            });
+
+            prepare.add(new AlgoHelperEntry(graphCH, astarbiOpts, idxCH)
+            {
+                @Override
+                public RoutingAlgorithm createAlgo( Graph qGraph )
+                {
+                    return prepareCH.createAlgo(qGraph, astarbiOpts);
+                }
+            });
+        }
+        return prepare;
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
index d6adb30691..a7ad66405e 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
@@ -17,23 +17,15 @@
  */
 package com.graphhopper.routing.ch;
 
-import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
-import com.graphhopper.routing.util.CarFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.ShortestWeighting;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.storage.LevelGraphStorage;
-import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.routing.*;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.EdgeSkipIterState;
 import com.graphhopper.util.Helper;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
@@ -44,7 +36,7 @@
  */
 public class DijkstraBidirectionCHTest extends AbstractRoutingAlgorithmTester
 {
-    // graph is expensive to create and to prepare!
+    // matrix graph is expensive to create and to prepare!
     private static Graph preparedMatrixGraph;
 
     @Override
@@ -54,7 +46,7 @@ public Graph getMatrixGraph()
         {
             LevelGraph lg = (LevelGraph) createGraph(false);
             getMatrixAlikeGraph().copyTo(lg);
-            prepareGraph(lg);
+            createFactory(lg, defaultOpts);
             preparedMatrixGraph = lg;
         }
         return preparedMatrixGraph;
@@ -67,10 +59,17 @@ protected LevelGraph createGraph( EncodingManager em, boolean is3D )
     }
 
     @Override
-    public PrepareContractionHierarchies prepareGraph( Graph g, FlagEncoder encoder, Weighting w )
+    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
+    {
+        return createFactory(g, opts).createAlgo(g, opts);
+    }
+
+    @Override
+    public RoutingAlgorithmFactory createFactory( Graph g, AlgorithmOptions opts )
     {
-        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(encoder, w, TraversalMode.NODE_BASED).setGraph(g);
-        // hack: prepare matrixgraph only once
+        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
+                (LevelGraph) g, opts.getFlagEncoder(), opts.getWeighting(), TraversalMode.NODE_BASED);
+        // hack: prepare matrixGraph only once
         if (g != preparedMatrixGraph)
             ch.doWork();
 
@@ -115,11 +114,14 @@ public void testPathRecursiveUnpacking()
         g2.setLevel(7, 6);
         g2.setLevel(0, 7);
 
-        Path p = new PrepareContractionHierarchies(encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).
-                setGraph(g2).createAlgo().calcPath(0, 7);
+        ShortestWeighting weighting = new ShortestWeighting();
+        AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
+        Path p = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
+                g2, encoder, weighting, TraversalMode.NODE_BASED).
+                createAlgo(g2, opts).calcPath(0, 7);
 
         assertEquals(Helper.createTList(0, 2, 5, 7), p.calcNodes());
-        assertEquals(1064, p.getMillis());
+        assertEquals(1064, p.getTime());
         assertEquals(4.2, p.getDistance(), 1e-5);
     }
 
@@ -138,9 +140,60 @@ public long setProperties( double speed, boolean forward, boolean backward )
             }
         };
 
-        footEncoder = new EncodingManager("FOOT").getSingle();
+        footEncoder = new FootFlagEncoder();
+        new EncodingManager(footEncoder);
+
         super.testCalcFootPath();
         footEncoder = tmpFootEncoder;
         carEncoder = tmpCarEncoder;
     }
+
+    @Test
+    public void testBaseGraph()
+    {
+        CarFlagEncoder carFE = new CarFlagEncoder();
+        Graph g = createGraph(new EncodingManager(carFE), false);
+        initDirectedAndDiffSpeed(g, carFE);
+
+        // do CH preparation for car
+        createFactory(g, defaultOpts);
+
+        // use base graph for solving normal Dijkstra
+        Path p1 = new RoutingAlgorithmFactorySimple().createAlgo(g, defaultOpts).calcPath(0, 3);
+        assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
+        assertEquals(p1.toString(), 402.29, p1.getDistance(), 1e-2);
+        assertEquals(p1.toString(), 144823, p1.getTime());
+    }
+
+    @Test
+    public void testBaseGraphMultipleVehicles()
+    {
+        Graph g = createGraph(encodingManager, false);
+        initFootVsCar(g);
+
+        AlgorithmOptions footOptions = AlgorithmOptions.start().flagEncoder(footEncoder).
+                weighting(new FastestWeighting(footEncoder)).build();
+        AlgorithmOptions carOptions = AlgorithmOptions.start().flagEncoder(carEncoder).
+                weighting(new FastestWeighting(carEncoder)).build();
+
+        // do CH preparation for car
+        RoutingAlgorithmFactory contractedFactory = createFactory(g, carOptions);
+
+        // use contracted graph
+        Path p1 = contractedFactory.createAlgo(g, carOptions).calcPath(0, 7);
+        assertEquals(Helper.createTList(0, 4, 6, 7), p1.calcNodes());
+        assertEquals(p1.toString(), 15000, p1.getDistance(), 1e-6);
+
+        // use base graph for solving normal Dijkstra via car
+        Path p2 = new RoutingAlgorithmFactorySimple().createAlgo(g.getBaseGraph(), carOptions).calcPath(0, 7);
+        assertEquals(Helper.createTList(0, 4, 6, 7), p2.calcNodes());
+        assertEquals(p2.toString(), 15000, p2.getDistance(), 1e-6);
+        assertEquals(p2.toString(), 2700 * 1000, p2.getTime());
+
+        // use base graph for solving normal Dijkstra via foot
+        Path p3 = new RoutingAlgorithmFactorySimple().createAlgo(g.getBaseGraph(), footOptions).calcPath(0, 7);
+        assertEquals(p3.toString(), 17000, p3.getDistance(), 1e-6);
+        assertEquals(p3.toString(), 12240 * 1000, p3.getTime());
+        assertEquals(Helper.createTList(0, 4, 5, 7), p3.calcNodes());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index 7ba3f170ba..6bc6c85218 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -17,20 +17,18 @@
  */
 package com.graphhopper.routing.ch;
 
-import com.graphhopper.routing.Dijkstra;
-import com.graphhopper.routing.DijkstraOneToMany;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.RoutingAlgorithm;
+import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies.Shortcut;
 import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.storage.LevelGraphStorage;
-import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
+
 import java.util.Collection;
 import java.util.Iterator;
+
 import static org.junit.Assert.*;
+
+import org.junit.Before;
 import org.junit.Test;
 
 /**
@@ -41,7 +39,8 @@
     private final EncodingManager encodingManager = new EncodingManager("CAR");
     private final CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
     private final Weighting weighting = new ShortestWeighting();
-    private TraversalMode tMode = TraversalMode.NODE_BASED;
+    private final TraversalMode tMode = TraversalMode.NODE_BASED;
+    private Directory dir;
 
     LevelGraph createGraph()
     {
@@ -68,14 +67,23 @@ LevelGraph createExampleGraph()
         return g;
     }
 
+    @Before
+    public void setUp()
+    {
+        dir = new GHDirectory("", DAType.RAM_INT);
+    }
+
     @Test
     public void testShortestPathSkipNode()
     {
         LevelGraph g = createExampleGraph();
         double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(3));
-        int nodeEntry = algo.setLimitWeight(100).findEndNode(4, 2);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        prepare.initFromGraph().prepareNodes();
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(3));
+        algo.setWeightLimit(100);
+        int nodeEntry = algo.findEndNode(4, 2);
         assertTrue(algo.getWeight(nodeEntry) > normalDist);
 
         algo.clear();
@@ -90,11 +98,14 @@ public void testShortestPathSkipNode2()
         double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
         assertEquals(3, normalDist, 1e-5);
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(3));
-        int nodeEntry = algo.setLimitWeight(10).findEndNode(4, 2);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        prepare.initFromGraph().prepareNodes();
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(3));
+        algo.setWeightLimit(10);
+        int nodeEntry = algo.findEndNode(4, 2);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
 
-        nodeEntry = algo.setLimitWeight(10).findEndNode(4, 1);
+        nodeEntry = algo.findEndNode(4, 1);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
     }
 
@@ -103,8 +114,11 @@ public void testShortestPathLimit()
     {
         LevelGraph g = createExampleGraph();
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(0));
-        int endNode = algo.setLimitWeight(2).findEndNode(4, 1);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        prepare.initFromGraph().prepareNodes();
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(0));
+        algo.setWeightLimit(2);
+        int endNode = algo.findEndNode(4, 1);
         // did not reach endNode
         assertNotEquals(1, endNode);
     }
@@ -113,22 +127,20 @@ public void testShortestPathLimit()
     public void testAddShortcuts()
     {
         LevelGraph g = createExampleGraph();
-        int old = g.getAllEdges().getMaxId();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        int old = g.getAllEdges().getCount();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 1, g.getAllEdges().getMaxId());
+        assertEquals(old + 1, g.getAllEdges().getCount());
     }
 
     @Test
     public void testMoreComplexGraph()
     {
         LevelGraph g = initShortcutsGraph(createGraph());
-        int old = g.getAllEdges().getMaxId();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        int old = g.getAllEdges().getCount();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 10, g.getAllEdges().getMaxId());
+        assertEquals(old + 7, g.getAllEdges().getCount());
     }
 
     @Test
@@ -142,11 +154,10 @@ public void testDirectedGraph()
         g.edge(3, 5, 1, false);
         g.edge(4, 3, 1, false);
         int old = GHUtility.count(g.getAllEdges());
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(old + 2, GHUtility.count(g.getAllEdges()));
-        RoutingAlgorithm algo = prepare.createAlgo();
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(4, 2);
         assertEquals(3, p.getDistance(), 1e-6);
         assertEquals(Helper.createTList(4, 3, 5, 2), p.calcNodes());
@@ -158,12 +169,11 @@ public void testDirectedGraph2()
         LevelGraph g = createGraph();
         initDirected2(g);
         int old = GHUtility.count(g.getAllEdges());
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         prepare.doWork();
         // PrepareTowerNodesShortcutsTest.printEdges(g);
         assertEquals(old + 9, GHUtility.count(g.getAllEdges()));
-        RoutingAlgorithm algo = prepare.createAlgo();
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(0, 10);
         assertEquals(10, p.getDistance(), 1e-6);
         assertEquals(Helper.createTList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), p.calcNodes());
@@ -192,9 +202,9 @@ public void testDirectedGraph3()
         g.edge(3, 6, 2, true);
         g.edge(3, 7, 2, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         prepare.initFromGraph();
+        prepare.prepareNodes();
         // find all shortcuts if we contract node 1
         Collection<Shortcut> scs = prepare.testFindShortcuts(1);
         assertEquals(2, scs.size());
@@ -210,12 +220,11 @@ public void testDirectedGraph3()
 
         // both dirs
         assertTrue(sc1.toString(), sc1.from == 3 && sc1.to == 2);
-        assertTrue(sc1.toString(), carEncoder.isBool(sc1.flags, FlagEncoder.K_FORWARD)
-                && carEncoder.isBool(sc1.flags, FlagEncoder.K_BACKWARD));
+        assertTrue(sc1.toString(), carEncoder.isForward(sc1.flags) && carEncoder.isBackward(sc1.flags));
 
         // directed
         assertTrue(sc2.toString(), sc2.from == 2 && sc2.to == 3);
-        assertTrue(sc2.toString(), carEncoder.isBool(sc2.flags, FlagEncoder.K_FORWARD));
+        assertTrue(sc2.toString(), carEncoder.isForward(sc2.flags));
 
         assertEquals(sc1.toString(), 4, sc1.weight, 1e-4);
         assertEquals(sc2.toString(), 12, sc2.weight, 1e-4);
@@ -278,12 +287,11 @@ public void testRoundaboutUnpacking()
     {
         LevelGraph g = createGraph();
         initRoundaboutGraph(g);
-        int old = g.getAllEdges().getMaxId();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        int old = g.getAllEdges().getCount();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 22, g.getAllEdges().getMaxId());
-        RoutingAlgorithm algo = prepare.createAlgo();
+        assertEquals(old + 23, g.getAllEdges().getCount());
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(4, 7);
         assertEquals(Helper.createTList(4, 5, 6, 7), p.calcNodes());
     }
@@ -292,38 +300,51 @@ public void testRoundaboutUnpacking()
     public void testFindShortcuts_Roundabout()
     {
         LevelGraphStorage g = (LevelGraphStorage) createGraph();
-        EdgeIteratorState iter1_1 = g.edge(1, 3, 1, true);
-        EdgeIteratorState iter1_2 = g.edge(3, 4, 1, true);
-        EdgeIteratorState iter2_1 = g.edge(4, 5, 1, false);
-        EdgeIteratorState iter2_2 = g.edge(5, 6, 1, false);
-        EdgeIteratorState iter3_1 = g.edge(6, 7, 1, true);
-        EdgeIteratorState iter3_2 = g.edge(6, 8, 2, false);
-        g.edge(8, 4, 1, false);
-        g.setLevel(3, 3);
-        g.setLevel(5, 5);
-        g.setLevel(7, 7);
-        g.setLevel(8, 8);
+        EdgeIteratorState iter1_3 = g.edge(1, 3, 1, true);
+        EdgeIteratorState iter3_4 = g.edge(3, 4, 1, true);
+        EdgeIteratorState iter4_5 = g.edge(4, 5, 1, false);
+        EdgeIteratorState iter5_6 = g.edge(5, 6, 1, false);
+        EdgeIteratorState iter6_8 = g.edge(6, 8, 2, false);
+        EdgeIteratorState iter8_4 = g.edge(8, 4, 1, false);
+        g.edge(6, 7, 1, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         EdgeSkipIterState tmp = g.shortcut(1, 4);
         tmp.setFlags(PrepareEncoder.getScDirMask());
         tmp.setWeight(2);
-        tmp.setSkippedEdges(iter1_1.getEdge(), iter1_2.getEdge());
+        tmp.setSkippedEdges(iter1_3.getEdge(), iter3_4.getEdge());
         long f = PrepareEncoder.getScFwdDir();
         tmp = g.shortcut(4, 6);
         tmp.setFlags(f);
         tmp.setWeight(2);
-        tmp.setSkippedEdges(iter2_1.getEdge(), iter2_2.getEdge());
+        tmp.setSkippedEdges(iter4_5.getEdge(), iter5_6.getEdge());
         tmp = g.shortcut(6, 4);
         tmp.setFlags(f);
         tmp.setWeight(3);
-        tmp.setSkippedEdges(iter3_1.getEdge(), iter3_2.getEdge());
+        tmp.setSkippedEdges(iter6_8.getEdge(), iter8_4.getEdge());
 
         prepare.initFromGraph();
+        prepare.prepareNodes();
+        g.setLevel(3, 3);
+        g.setLevel(5, 5);
+        g.setLevel(7, 7);
+        g.setLevel(8, 8);
+
         // there should be two different shortcuts for both directions!
         Collection<Shortcut> sc = prepare.testFindShortcuts(4);
         assertEquals(2, sc.size());
+        Iterator<Shortcut> iter = sc.iterator();
+        Shortcut sc1 = iter.next();
+        Shortcut sc2 = iter.next();
+        if (sc1.from > sc2.from)
+        {
+            Shortcut tmpSc = sc1;
+            sc1 = sc2;
+            sc2 = tmpSc;
+        }
+
+        assertEquals("1->6, weight:4.0 (7,8)", sc1.toString());
+        assertEquals("6->1, weight:5.0 (9,7)", sc2.toString());
     }
 
     void initUnpackingGraph( LevelGraphStorage g, Weighting w )
@@ -376,9 +397,8 @@ public void testUnpackingOrder()
     {
         LevelGraphStorage g = (LevelGraphStorage) createGraph();
         initUnpackingGraph(g, weighting);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
-        RoutingAlgorithm algo = prepare.createAlgo();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-5);
         assertEquals(Helper.createTList(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
@@ -391,9 +411,8 @@ public void testUnpackingOrder_Fastest()
         Weighting w = new FastestWeighting(carEncoder);
         initUnpackingGraph(g, w);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, w, tMode).
-                setGraph(g);
-        RoutingAlgorithm algo = prepare.createAlgo();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-1);
         assertEquals(Helper.createTList(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
@@ -410,8 +429,7 @@ public void testCircleBug()
         g.edge(0, 1, 4, true);
         g.edge(0, 2, 10, true);
         g.edge(0, 3, 10, true);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(0, prepare.getShortcuts());
     }
@@ -435,8 +453,7 @@ public void testBug178()
         g.edge(3, 4, 1, true);
         g.edge(6, 3, 1, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(2, prepare.getShortcuts());
     }
@@ -537,7 +554,7 @@ public static LevelGraph initShortcutsGraph( LevelGraph g )
         return g;
     }
 
-//    public static void printEdges(LevelGraph g) {
+    //    public static void printEdges(LevelGraph g) {
 //        RawEdgeIterator iter = g.getAllEdges();
 //        while (iter.next()) {
 //            EdgeSkipIterator single = g.getEdgeProps(iter.edge(), iter.nodeB());
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
index 27e3d9415e..190f66bd43 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
@@ -19,10 +19,10 @@
 package com.graphhopper.routing.ch;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class PrepareEncoderTest
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
index 5485a7a5bd..a67b0f1f62 100644
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
@@ -19,11 +19,17 @@
 
 import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMWay;
+
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import com.graphhopper.util.Translation;
+
 import static com.graphhopper.util.TranslationMapTest.SINGLETON;
+
 import java.util.Locale;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -190,7 +196,7 @@ public void testTramStations()
         way.setTag("railway", "station");
         way.setTag("bicycle", "yes");
         // allow stations if explicitely tagged
-        assertNotSame(0, encoder.acceptWay(way));
+        assertNotEquals(0, encoder.acceptWay(way));
 
         way = new OSMWay(1);
         way.setTag("highway", "secondary");
@@ -198,6 +204,24 @@ public void testTramStations()
         way.setTag("bicycle", "no");
         // disallow
         assertEquals(0, encoder.acceptWay(way));
+
+        way = new OSMWay(1);
+        way.setTag("railway", "platform");
+        long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertNotEquals(0, flags);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "track");
+        way.setTag("railway", "platform");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertNotEquals(0, flags);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "track");
+        way.setTag("railway", "platform");
+        way.setTag("bicycle", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertEquals(0, flags);
     }
 
     @Test
@@ -287,6 +311,17 @@ public void testHandleCommonWayTags()
         way.setTag("surface", "grass");
         wayType = getWayTypeFromFlags(way);
         assertEquals("way, unpaved", wayType);
+
+        way.clearTags();
+        way.setTag("railway", "platform");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike", wayType);
+
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("railway", "platform");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike, unpaved", wayType);
     }
 
     @Test
@@ -324,17 +359,12 @@ public void testReduceToMaxSpeed()
     }
 
     @Test
-    public void testMaxAndMinSpeed()
+    public void testPreferenceForSlowSpeed()
     {
         OSMWay osmWay = new OSMWay(1);
         osmWay.setTag("highway", "tertiary");
         assertEquals(30, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 49, false))), 1e-1);
         assertPriority(PREFER.getValue(), osmWay);
-
-        osmWay.setTag("highway", "tertiary");
-        osmWay.setTag("maxspeed", "90");
-        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
-        assertPriority(REACH_DEST.getValue(), osmWay);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
index 2fc14399fb..40cb881ac7 100644
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.routing.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class AbstractFlagEncoderTest
@@ -29,15 +29,22 @@
     @Test
     public void testAcceptsCar()
     {
-        assertEquals(40, AbstractFlagEncoder.parseSpeed("40 km/h"), 1e-3);
-        assertEquals(40, AbstractFlagEncoder.parseSpeed("40km/h"), 1e-3);
-        assertEquals(40, AbstractFlagEncoder.parseSpeed("40kmh"), 1e-3);
-        assertEquals(64.374, AbstractFlagEncoder.parseSpeed("40mph"), 1e-3);
-        assertEquals(48.28, AbstractFlagEncoder.parseSpeed("30 mph"), 1e-3);
-        assertEquals(-1, AbstractFlagEncoder.parseSpeed(null), 1e-3);
-        assertEquals(18.52, AbstractFlagEncoder.parseSpeed("10 knots"), 1e-3);
-        assertEquals(19, AbstractFlagEncoder.parseSpeed("19 kph"), 1e-3);
-        assertEquals(19, AbstractFlagEncoder.parseSpeed("19kph"), 1e-3);
+        CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 0);
+        assertEquals(40, encoder.parseSpeed("40 km/h"), 1e-3);
+        assertEquals(40, encoder.parseSpeed("40km/h"), 1e-3);
+        assertEquals(40, encoder.parseSpeed("40kmh"), 1e-3);
+        assertEquals(64.374, encoder.parseSpeed("40mph"), 1e-3);
+        assertEquals(48.28, encoder.parseSpeed("30 mph"), 1e-3);
+        assertEquals(-1, encoder.parseSpeed(null), 1e-3);
+        assertEquals(18.52, encoder.parseSpeed("10 knots"), 1e-3);
+        assertEquals(19, encoder.parseSpeed("19 kph"), 1e-3);
+        assertEquals(19, encoder.parseSpeed("19kph"), 1e-3);
+
+        assertEquals(50, encoder.parseSpeed("RO:urban"), 1e-3);
+
+        assertEquals(80, encoder.parseSpeed("RU:rural"), 1e-3);
+
+        assertEquals(6, encoder.parseSpeed("walk"), 1e-3);
     }
 
     @Test
@@ -51,11 +58,4 @@ public void testParseDuration()
         assertEquals(60 * 20, AbstractFlagEncoder.parseDuration("0:20:00"));
         assertEquals(60 * 24 * 2 + 60 * 20 + 2, AbstractFlagEncoder.parseDuration("02:20:02"));
     }
-    
-    @Test
-    public void testParseProperties()
-    {
-        assertEquals(10, AbstractFlagEncoder.parseDouble("car|x", "prop", 10), .1);
-        assertEquals(12.2, AbstractFlagEncoder.parseDouble("car|x|prop=12.2", "prop", 10), .1);
-    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
index 51894b72b3..f559373833 100644
--- a/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
@@ -24,17 +24,24 @@
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class Bike2WeightFlagEncoderTest extends BikeFlagEncoderTest
 {
-    private Graph initExampleGraph( FlagEncoder instance )
+    private final EncodingManager em = new EncodingManager("bike,bike2");
+
+    @Override
+    protected BikeCommonFlagEncoder createBikeEncoder()
+    {
+        return (BikeCommonFlagEncoder) em.getEncoder("bike2");
+    }
+
+    private Graph initExampleGraph()
     {
-        EncodingManager em = new EncodingManager(instance);
         GraphStorage gs = new GraphHopperStorage(new RAMDirectory(), em, true).create(1000);
         NodeAccess na = gs.getNodeAccess();
         // 50--(0.0001)-->49--(0.0004)-->55--(0.0005)-->60
@@ -44,37 +51,47 @@ private Graph initExampleGraph( FlagEncoder instance )
                 setWayGeometry(Helper.createPointList3D(51.1, 12.0011, 49, 51.1, 12.0015, 55));
         edge.setDistance(100);
 
-        edge.setFlags(instance.setReverseSpeed(instance.setProperties(10, true, true), 15));
+        edge.setFlags(encoder.setReverseSpeed(encoder.setProperties(10, true, true), 15));
         return gs;
     }
 
     @Test
     public void testApplyWayTags()
     {
-        Bike2WeightFlagEncoder instance = new Bike2WeightFlagEncoder();
-        Graph graph = initExampleGraph(instance);
+        Graph graph = initExampleGraph();
         EdgeIteratorState edge = GHUtility.getEdge(graph, 0, 1);
         OSMWay way = new OSMWay(1);
-        instance.applyWayTags(way, edge);
+        encoder.applyWayTags(way, edge);
 
         long flags = edge.getFlags();
         // decrease speed
-        assertEquals(2, instance.getSpeed(flags), 1e-1);
+        assertEquals(2, encoder.getSpeed(flags), 1e-1);
         // increase speed but use maximum speed (calculated was 24)
-        assertEquals(18, instance.getReverseSpeed(flags), 1e-1);
+        assertEquals(18, encoder.getReverseSpeed(flags), 1e-1);
     }
-        
+
     @Test
     public void testUnchangedForStepsBridgeAndTunnel()
     {
-        Bike2WeightFlagEncoder instance = new Bike2WeightFlagEncoder();
-        Graph graph = initExampleGraph(instance);
+        Graph graph = initExampleGraph();
         EdgeIteratorState edge = GHUtility.getEdge(graph, 0, 1);
         long oldFlags = edge.getFlags();
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "steps");
-        instance.applyWayTags(way, edge);
+        encoder.applyWayTags(way, edge);
 
         assertEquals(oldFlags, edge.getFlags());
     }
+
+    @Test
+    public void testSetSpeed0_issue367()
+    {
+        long flags = encoder.setProperties(10, true, true);
+        flags = encoder.setSpeed(flags, 0);
+
+        assertEquals(0, encoder.getSpeed(flags), .1);
+        assertEquals(10, encoder.getReverseSpeed(flags), .1);
+        assertFalse(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
index ebe46f48cc..7636e6ac76 100644
--- a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
@@ -17,9 +17,13 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
+
+import static com.graphhopper.routing.util.BikeCommonFlagEncoder.PUSHING_SECTION_SPEED;
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import org.junit.Test;
 
 import static org.junit.Assert.*;
@@ -46,10 +50,52 @@ public void testGetSpeed()
         assertEquals(18, encoder.getSpeed(way));
         assertPriority(REACH_DEST.getValue(), way);
 
+        // Pushing section !! This is fine as we obey the law!
+        way.clearTags();
+        way.setTag("highway", "footway");
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+
+        // Pushing section irrespective of the pavement
+        way.setTag("surface", "paved");
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+
+        way.clearTags();
+        way.setTag("highway", "footway");
+        way.setTag("bicycle", "yes");
+        assertEquals(6, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
+
+        way.clearTags();
         way.setTag("highway", "footway");
+        way.setTag("surface", "paved");
+        way.setTag("bicycle", "yes");
+
+        assertEquals(6, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
+
+        way.clearTags();
+        way.setTag("highway", "path");
+        way.setTag("bicycle", "yes");
+        assertEquals(12, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
+
+        // Pushing section Ok !!
+        way.clearTags();
+        way.setTag("highway", "path");
+        way.setTag("surface", "paved");
         assertEquals(4, encoder.getSpeed(way));
         assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
 
+        way.clearTags();
+        way.setTag("highway", "footway");
+        way.setTag("surface", "paved");
+        way.setTag("bicycle", "designated");
+        assertEquals(6, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+
+        way.clearTags();
         way.setTag("highway", "track");
         assertEquals(12, encoder.getSpeed(way));
         assertPriority(UNCHANGED.getValue(), way);
@@ -91,7 +137,21 @@ public void testGetSpeed()
         assertEquals(18, encoder.getSpeed(way));
 
         way.setTag("surface", "unknown_surface");
-        assertEquals(4, encoder.getSpeed(way));
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        way.setTag("surface", "fine_gravel");
+        assertEquals(18, encoder.getSpeed(way));
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        way.setTag("surface", "paved");
+        assertEquals(18, encoder.getSpeed(way));
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        assertEquals(18, encoder.getSpeed(way));
 
         way.clearTags();
         way.setTag("highway", "residential");
@@ -141,6 +201,89 @@ public void testHandleWayTags()
         way.setTag("tracktype", "grade2");
         wayType = getWayTypeFromFlags(way);
         assertEquals("get off the bike, unpaved", wayType);
+
+        way.clearTags();
+        way.setTag("junction", "roundabout");
+        way.setTag("highway", "tertiary");
+        long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+    }
+
+    @Test
+    public void testOneway()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "tertiary");
+        long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.setTag("oneway", "yes");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
+        way.setTag("highway", "tertiary");
+        way.setTag("oneway:bicycle", "yes");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("vehicle:forward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertFalse(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("bicycle:forward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertFalse(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("vehicle:backward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("motor_vehicle:backward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        // attention bicycle:backward=no/yes has a completely different meaning!
+        // https://wiki.openstreetmap.org/wiki/Key:access#One-way_restrictions
+        way.setTag("highway", "tertiary");
+        way.setTag("oneway", "yes");
+        way.setTag("bicycle:backward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+
+        way.setTag("bicycle:backward", "yes");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+
+        way.clearTags();
+        way.setTag("highway", "tertiary");
+        way.setTag("oneway", "yes");
+        way.setTag("cycleway", "opposite");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
     }
 
     @Test
@@ -222,6 +365,32 @@ public void testUnchangedRelationShouldNotInfluencePriority()
         assertPriority(REACH_DEST.getValue(), osmWay, relFlags);
     }
 
+    @Test
+    @Override
+    public void testSacScale()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "path");
+        way.setTag("sac_scale", "hiking");
+        // allow
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("highway", "path");
+        way.setTag("sac_scale", "mountain_hiking");
+        // disallow
+        assertEquals(0, encoder.acceptWay(way));
+
+        way.setTag("highway", "cycleway");
+        way.setTag("sac_scale", "hiking");
+        // allow
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("highway", "cycleway");
+        way.setTag("sac_scale", "mountain_hiking");
+        // disallow
+        assertEquals(0, encoder.acceptWay(way));
+    }
+
     @Test
     public void testCalcPriority()
     {
@@ -250,6 +419,18 @@ public void testMaxSpeed()
         long allowed = encoder.acceptWay(way);
         long encoded = encoder.handleWayTags(way, allowed, 0);
         assertEquals(10, encoder.getSpeed(encoded), 1e-1);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "tertiary");
+        way.setTag("maxspeed", "90");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(way, 20, false))), 1e-1);
+        assertPriority(UNCHANGED.getValue(), way);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "track");
+        way.setTag("maxspeed", "90");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(way, 20, false))), 1e-1);
+        assertPriority(UNCHANGED.getValue(), way);
     }
 
     @Test
@@ -310,4 +491,50 @@ public void testTurnFlagEncoding_withCosts()
         assertTrue(encoder.isTurnRestricted(flags_r220));
         assertFalse(encoder.isTurnRestricted(flags_126));
     }
+
+    // Issue 407 : Always block kissing_gate execpt for mountainbikes
+    @Test
+    public void testBarrierAccess()
+    {
+        // kissing_gate without bicycle tag
+        OSMNode node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "kissing_gate");
+        // barrier!
+        assertFalse(encoder.handleNodeTags(node) == 0);
+
+        // kissing_gate with bicycle tag
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "kissing_gate");
+        node.setTag("bicycle", "yes");
+        // barrier!
+        assertFalse(encoder.handleNodeTags(node) == 0);
+    }
+
+    @Test
+    public void testclassBicycle()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "tertiary");
+        way.setTag("class:bicycle", "3");
+        assertPriority(BEST.getValue(), way);
+        way.setTag("class:bicycle", "2");
+        assertPriority(VERY_NICE.getValue(), way);
+        way.setTag("class:bicycle", "1");
+        assertPriority(PREFER.getValue(), way);
+        way.setTag("class:bicycle", "0");
+        assertPriority(UNCHANGED.getValue(), way);
+        way.setTag("class:bicycle", "invalidvalue");
+        assertPriority(UNCHANGED.getValue(), way);
+        way.setTag("class:bicycle", "-1");
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+        way.setTag("class:bicycle", "-2");
+        assertPriority(REACH_DEST.getValue(), way);
+        way.setTag("class:bicycle", "-3");
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), way);
+
+        // Now we test overriding by a specific class subtype
+        way.setTag("class:bicycle:touring", "2");
+        assertPriority(VERY_NICE.getValue(), way);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
index 0a6d47f4e7..3368bc9805 100644
--- a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMWay;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class CarFlagEncoderTest
@@ -48,17 +48,13 @@ public void testAccess()
         way.setTag("motorcar", "no");
         assertFalse(encoder.acceptWay(way) > 0);
 
+        // for now allow grade1+2+3 for every country, see #253
         way.clearTags();
         way.setTag("highway", "track");
         way.setTag("tracktype", "grade2");
-        // disallow too rough tracks
-        assertFalse(encoder.acceptWay(way) > 0);
-
-        way.clearTags();
-        way.setTag("highway", "service");
-        way.setTag("access", "no");
-        way.setTag("motorcar", "yes");
         assertTrue(encoder.acceptWay(way) > 0);
+        way.setTag("tracktype", "grade4");
+        assertFalse(encoder.acceptWay(way) > 0);
 
         way.clearTags();
         way.setTag("highway", "service");
@@ -86,38 +82,111 @@ public void testAccess()
         assertFalse(encoder.isFerry(encoder.acceptWay(way)));
 
         way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "yes");
+        way.setTag("motor_vehicle", "no");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "no");
+        way.setTag("motorcar", "yes");
+        assertTrue(encoder.acceptWay(way) > 0);
+    }
+
+    @Test
+    public void testMilitaryAccess()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "track");
+        way.setTag("access", "military");
+        assertFalse(encoder.acceptWay(way) > 0);
+    }
+
+    @Test
+    public void testFordAccess()
+    {
+        OSMNode node = new OSMNode(0, 0.0, 0.0);
+        node.setTag("ford", "yes");
+
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "unclassified");
+        way.setTag("ford", "yes");
+
+        // Node and way are initially blocking
+        assertTrue(encoder.isBlockFords());
+        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
+        try
+        {
+            // Now they are passable
+            encoder.setBlockFords(false);
+            assertTrue(encoder.acceptWay(way) > 0);
+            assertFalse(encoder.handleNodeTags(node) > 0);
+        } finally
+        {
+            encoder.setBlockFords(true);
+        }
+    }
+
+    @Test
+    public void testOneway()
+    {
+        OSMWay way = new OSMWay(1);
         way.setTag("highway", "primary");
         long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
         way.setTag("oneway", "yes");
         flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_FORWARD));
-        assertFalse(encoder.isBool(flags, FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("vehicle:forward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertFalse(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("vehicle:backward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
     }
 
     @Test
     public void testSetAccess()
     {
-        assertTrue(encoder.isBool(encoder.setProperties(0, true, true), FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(encoder.setProperties(0, true, true), FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(encoder.setProperties(0, true, true)));
+        assertTrue(encoder.isBackward(encoder.setProperties(0, true, true)));
 
-        assertTrue(encoder.isBool(encoder.setProperties(0, true, false), FlagEncoder.K_FORWARD));
-        assertFalse(encoder.isBool(encoder.setProperties(0, true, false), FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(encoder.setProperties(0, true, false)));
+        assertFalse(encoder.isBackward(encoder.setProperties(0, true, false)));
 
-        assertFalse(encoder.isBool(encoder.setProperties(0, false, true), FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(encoder.setProperties(0, false, true), FlagEncoder.K_BACKWARD));
+        assertFalse(encoder.isForward(encoder.setProperties(0, false, true)));
+        assertTrue(encoder.isBackward(encoder.setProperties(0, false, true)));
 
-        assertTrue(encoder.isBool(encoder.flagsDefault(true, true), FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(encoder.flagsDefault(true, true), FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(encoder.flagsDefault(true, true)));
+        assertTrue(encoder.isBackward(encoder.flagsDefault(true, true)));
 
-        assertTrue(encoder.isBool(encoder.flagsDefault(true, false), FlagEncoder.K_FORWARD));
-        assertFalse(encoder.isBool(encoder.flagsDefault(true, false), FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(encoder.flagsDefault(true, false)));
+        assertFalse(encoder.isBackward(encoder.flagsDefault(true, false)));
 
         long flags = encoder.flagsDefault(true, true);
         // disable access
-        assertFalse(encoder.isBool(encoder.setAccess(flags, false, false), FlagEncoder.K_FORWARD));
-        assertFalse(encoder.isBool(encoder.setAccess(flags, false, false), FlagEncoder.K_BACKWARD));
+        assertFalse(encoder.isForward(encoder.setAccess(flags, false, false)));
+        assertFalse(encoder.isBackward(encoder.setAccess(flags, false, false)));
     }
 
     @Test
@@ -128,7 +197,7 @@ public void testMaxSpeed()
         way.setTag("maxspeed", "500");
         long allowed = encoder.acceptWay(way);
         long encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(100, encoder.getSpeed(encoded), 1e-1);
+        assertEquals(140, encoder.getSpeed(encoded), 1e-1);
 
         way = new OSMWay(1);
         way.setTag("highway", "primary");
@@ -148,6 +217,12 @@ public void testMaxSpeed()
         way.setTag("maxspeed:backward", "20");
         encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
         assertEquals(20, encoder.getSpeed(encoded), 1e-1);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "motorway");
+        way.setTag("maxspeed", "none");
+        encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertEquals(125, encoder.getSpeed(encoded), .1);
     }
 
     @Test
@@ -196,31 +271,43 @@ public void testSetSpeed()
         assertEquals(10, encoder.getSpeed(encoder.setSpeed(0, 10)), 1e-1);
     }
 
+    @Test
+    public void testSetSpeed0_issue367()
+    {
+        long flags = encoder.setProperties(10, true, true);
+        flags = encoder.setSpeed(flags, encoder.speedFactor * 0.49);
+
+        assertEquals(0, encoder.getSpeed(flags), .1);
+        assertEquals(0, encoder.getReverseSpeed(flags), .1);
+        assertFalse(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+    }
+
     @Test
     public void testRoundabout()
     {
         long flags = encoder.setAccess(0, true, true);
         long resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, true);
         assertTrue(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
-        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(resFlags));
+        assertTrue(encoder.isBackward(resFlags));
 
         resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, false);
         assertFalse(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
-        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(resFlags));
+        assertTrue(encoder.isBackward(resFlags));
 
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "motorway");
         flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
         assertFalse(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
 
         way.setTag("junction", "roundabout");
         flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_FORWARD));
-        assertFalse(encoder.isBool(flags, FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
         assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
     }
 
@@ -240,8 +327,8 @@ public void testRailway()
 
         // on disallowed highway, railway is allowed, sometimes incorrectly mapped
         way.setTag("highway", "track");
-        assertTrue(encoder.acceptWay(way) > 0);        
-        
+        assertTrue(encoder.acceptWay(way) > 0);
+
         // this is fully okay as sometimes old rails are on the road
         way.setTag("highway", "primary");
         way.setTag("railway", "historic");
@@ -272,13 +359,13 @@ public void testRailway()
     public void testSwapDir()
     {
         long swappedFlags = encoder.reverseFlags(encoder.flagsDefault(true, true));
-        assertTrue(encoder.isBool(swappedFlags, FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(swappedFlags, FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isForward(swappedFlags));
+        assertTrue(encoder.isBackward(swappedFlags));
 
         swappedFlags = encoder.reverseFlags(encoder.flagsDefault(true, false));
 
-        assertFalse(encoder.isBool(swappedFlags, FlagEncoder.K_FORWARD));
-        assertTrue(encoder.isBool(swappedFlags, FlagEncoder.K_BACKWARD));
+        assertFalse(encoder.isForward(swappedFlags));
+        assertTrue(encoder.isBackward(swappedFlags));
 
         assertEquals(0, encoder.reverseFlags(0));
     }
@@ -383,23 +470,31 @@ public void testTurnFlagEncoding_withCosts()
     @Test
     public void testMaxValue()
     {
-        CarFlagEncoder instance = new CarFlagEncoder(8, 0.5, 0);
+        CarFlagEncoder instance = new CarFlagEncoder(10, 0.5, 0);
         EncodingManager em = new EncodingManager(instance);
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "motorway_link");
-        way.setTag("maxspeed", "70 mph");
+        way.setTag("maxspeed", "60 mph");
         long flags = instance.handleWayTags(way, 1, 0);
 
-        // double speed = AbstractFlagEncoder.parseSpeed("70 mph");
-        // => 112.654 * 0.9 => 101
+        // double speed = AbstractFlagEncoder.parseSpeed("60 mph");
+        // => 96.56 * 0.9 => 86.9
+        assertEquals(86.9, instance.getSpeed(flags), 1e-1);
         flags = instance.reverseFlags(flags);
-        assertEquals(100, instance.getSpeed(flags), 1e-1);
+        assertEquals(86.9, instance.getSpeed(flags), 1e-1);
+
+        // test that maxPossibleValue  is not exceeded
+        way = new OSMWay(2);
+        way.setTag("highway", "motorway_link");
+        way.setTag("maxspeed", "70 mph");
+        flags = instance.handleWayTags(way, 1, 0);
+        assertEquals(101.5, instance.getSpeed(flags), .1);
     }
 
     @Test
     public void testRegisterOnlyOnceAllowed()
     {
-        CarFlagEncoder instance = new CarFlagEncoder(8, 0.5, 0);
+        CarFlagEncoder instance = new CarFlagEncoder(10, 0.5, 0);
         EncodingManager em = new EncodingManager(instance);
         try
         {
@@ -419,28 +514,17 @@ public void testSetToMaxSpeed()
     }
 
     @Test
-    public void testFordAccess()
+    public void testCombination()
     {
-        OSMNode node = new OSMNode(0, 0.0, 0.0);
-        node.setTag("ford", "yes");
-
-        OSMWay way = new OSMWay(1);
-        way.setTag("highway", "unclassified");
-        way.setTag("ford", "yes");
-
-        // Node and way are initially blocking
-        assertTrue(encoder.isBlockFords());
-        assertFalse(encoder.acceptWay(way) > 0);
-        assertTrue(encoder.handleNodeTags(node) > 0);
-
-        try {
-            // Now they are passable
-            encoder.setBlockFords(false);
-            assertTrue(encoder.acceptWay(way) > 0);
-            assertFalse(encoder.handleNodeTags(node) > 0);
-        } finally {
-            encoder.setBlockFords(true);
-        }
+        OSMWay way = new OSMWay(123);
+        way.setTag("highway", "cycleway");
+        way.setTag("sac_scale", "hiking");
+
+        long flags = em.acceptWay(way);
+        long edgeFlags = em.handleWayTags(way, flags, 0);
+        assertFalse(encoder.isBackward(edgeFlags));
+        assertFalse(encoder.isForward(edgeFlags));
+        assertTrue(em.getEncoder("bike").isBackward(edgeFlags));
+        assertTrue(em.getEncoder("bike").isForward(edgeFlags));
     }
-
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
index 220a204e0f..f69318a049 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
@@ -20,10 +20,10 @@
 
 import com.graphhopper.reader.OSMWay;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class EncodedDoubleValueTest
@@ -53,7 +53,7 @@ public void testMaxValueAndSwap()
         long swappedFlags = instance1.swap(flags, instance2);
         assertEquals(expectedFlags, swappedFlags);
 
-        CarFlagEncoder carEncoder = new CarFlagEncoder(8, 0.5, 0);
+        CarFlagEncoder carEncoder = new CarFlagEncoder(10, 0.5, 0);
         new EncodingManager(carEncoder);
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "motorway_link");
@@ -62,6 +62,14 @@ public void testMaxValueAndSwap()
 
         // double speed = AbstractFlagEncoder.parseSpeed("70 mph");
         flags = carEncoder.reverseFlags(flags);
-        assertEquals(100, carEncoder.getSpeed(flags), 1e-1);
+        assertEquals(101.5, carEncoder.getSpeed(flags), 1e-1);
+    }
+
+    @Test
+    public void testUnsignedRightShift_issue417()
+    {
+        EncodedDoubleValue speedEncoder = new EncodedDoubleValue("Speed", 56, 8, 1, 30, 255);
+        Long flags = -72057594037927936L;
+        assertEquals(255, speedEncoder.getDoubleValue(flags), 0.01);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
index 9fcb71771d..6ceb80be0c 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.routing.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class EncodedValueTest
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
index cfacbe9a1c..90904a99fe 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
@@ -22,25 +22,22 @@
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
 
-import java.util.Collection;
-import java.util.Collections;
-
+import org.junit.Rule;
 import org.junit.Test;
 
-import com.graphhopper.reader.OSMReader;
 import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.reader.OSMTurnRelation;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.util.BitUtil;
-import java.util.*;
+import org.junit.rules.ExpectedException;
 
 /**
- *
  * @author Peter Karich
  */
 public class EncodingManagerTest
 {
+    @Rule
+    public ExpectedException thrown = ExpectedException.none();
+
     @Test
     public void testCompatibility()
     {
@@ -72,6 +69,13 @@ public void testEncoderAcceptNoException()
         assertFalse(manager.supports("FOOT"));
     }
 
+    @Test
+    public void testEncoderWithWrongVersionIsRejected()
+    {
+        thrown.expect(IllegalArgumentException.class);
+        EncodingManager manager = new EncodingManager("CAR|version=0");
+    }
+
     @Test
     public void testWrongEncoders()
     {
@@ -91,11 +95,57 @@ public void testWrongEncoders()
             assertTrue(false);
         } catch (Exception ex)
         {
-            assertEquals("Encoders are requesting more than 32 bits of way flags. Decrease the number of vehicles or increase the flags to take long.",
-                    ex.getMessage());
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoders are requesting more than 32 bits of way flags. Decrease the"));
         }
     }
 
+    @Test
+    public void testToDetailsStringIncludesEncoderVersionNumber()
+    {
+        FlagEncoder encoder = new AbstractFlagEncoder(1, 2.0, 3)
+        {
+            @Override
+            public int getVersion()
+            {
+                return 10;
+            }
+
+            @Override
+            public String toString()
+            {
+                return "newEncoder";
+            }
+
+            @Override
+            protected String getPropertiesString()
+            {
+                return "myProperties";
+            }
+
+            @Override
+            public long handleRelationTags( OSMRelation relation, long oldRelationFlags )
+            {
+                return 0;
+            }
+
+            @Override
+            public long acceptWay( OSMWay way )
+            {
+                return 0;
+            }
+
+            @Override
+            public long handleWayTags( OSMWay way, long allowed, long relationFlags )
+            {
+                return 0;
+            }
+        };
+
+        EncodingManager subject = new EncodingManager(encoder);
+
+        assertEquals("newEncoder|myProperties|version=10", subject.toDetailsString());
+    }
+
     @Test
     public void testCombineRelations()
     {
@@ -183,92 +233,6 @@ public void testFullBitMask()
         assertTrue(bitUtil.toBitString(foot.getNodeBitMask()).endsWith("00011111110000000"));
     }
 
-    /**
-     * Tests the combination of different turn cost flags by different encoders.
-     */
-    @Test
-    public void testTurnFlagCombination()
-    {
-        final TurnCostTableEntry turnCostEntry_car = new TurnCostTableEntry();
-        final TurnCostTableEntry turnCostEntry_foot = new TurnCostTableEntry();
-        final TurnCostTableEntry turnCostEntry_bike = new TurnCostTableEntry();
-
-        CarFlagEncoder car = new CarFlagEncoder(5, 5, 24)
-        {
-            @Override
-            public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
-            {
-                // simulate by returning one turn cost entry directly
-                return Collections.singleton(turnCostEntry_car);
-            }
-        };
-        FootFlagEncoder foot = new FootFlagEncoder()
-        {
-            @Override
-            public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
-            {
-                return Collections.singleton(turnCostEntry_foot);
-            }
-        };
-
-        BikeFlagEncoder bike = new BikeFlagEncoder(4, 2, 24)
-        {
-            @Override
-            public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
-            {
-                return Collections.singleton(turnCostEntry_bike);
-            }
-        };
-
-        EncodingManager manager = new EncodingManager(Arrays.asList(bike, foot, car), 4);
-
-        // turn cost entries for car and foot are for the same relations (same viaNode, edgeFrom and edgeTo), turn cost entry for bike is for another relation (different viaNode) 
-        turnCostEntry_car.edgeFrom = 1;
-        turnCostEntry_foot.edgeFrom = 1;
-        turnCostEntry_bike.edgeFrom = 2;
-
-        // calculating arbitrary flags using the encoders
-        turnCostEntry_car.flags = car.getTurnFlags(true, 0);
-        turnCostEntry_foot.flags = foot.getTurnFlags(true, 0);
-        turnCostEntry_bike.flags = bike.getTurnFlags(false, 10);
-
-        // we expect two different entries: the first one is a combination of turn flags of car and foot, since they provide the same relation, the other one is for bike only
-        long assertFlag1 = turnCostEntry_car.flags | turnCostEntry_foot.flags;
-        long assertFlag2 = turnCostEntry_bike.flags;
-
-        // RUN: analyze = combine flags of all encoders
-        Collection<TurnCostTableEntry> entries = manager.analyzeTurnRelation(null, null);
-
-        assertEquals(2, entries.size()); //we expect two different turnCost entries
-
-        for (TurnCostTableEntry entry : entries)
-        {
-            if (entry.edgeFrom == 1)
-            {
-                // the first entry provides turn flags for car and foot only 
-                assertEquals(assertFlag1, entry.flags);
-                assertTrue(car.isTurnRestricted(entry.flags));
-                assertFalse(foot.isTurnRestricted(entry.flags));
-                assertFalse(bike.isTurnRestricted(entry.flags));
-
-                assertTrue(Double.isInfinite(car.getTurnCost(entry.flags)));
-                assertEquals(0, foot.getTurnCost(entry.flags), 1e-1);
-                assertEquals(0, bike.getTurnCost(entry.flags), 1e-1);
-            } else if (entry.edgeFrom == 2)
-            {
-                // the 2nd entry provides turn flags for bike only
-                assertEquals(assertFlag2, entry.flags);
-                assertFalse(car.isTurnRestricted(entry.flags));
-                assertFalse(foot.isTurnRestricted(entry.flags));
-                assertFalse(bike.isTurnRestricted(entry.flags));
-
-                assertEquals(0, car.getTurnCost(entry.flags), 1e-1);
-                assertEquals(0, foot.getTurnCost(entry.flags), 1e-1);
-                assertEquals(10, bike.getTurnCost(entry.flags), 1e-1);
-            }
-        }
-    }
-
     @Test
     public void testFixWayName()
     {
@@ -284,7 +248,7 @@ public void testCompatibilityBug()
         osmWay.setTag("highway", "footway");
         osmWay.setTag("name", "test");
 
-        BikeFlagEncoder singleBikeEnc = (BikeFlagEncoder) manager2.getSingle();
+        BikeFlagEncoder singleBikeEnc = (BikeFlagEncoder) manager2.getEncoder("bike2");
         long flags = manager2.handleWayTags(osmWay, singleBikeEnc.acceptBit, 0);
         double singleSpeed = singleBikeEnc.getSpeed(flags);
         assertEquals(4, singleSpeed, 1e-3);
@@ -302,4 +266,32 @@ public void testCompatibilityBug()
         assertEquals(5, foot.getSpeed(flags), 1e-2);
         assertEquals(5, foot.getReverseSpeed(flags), 1e-2);
     }
+
+    @Test
+    public void testSupportFords()
+    {
+        // 1) no encoder crossing fords
+        String flagEncodersStr = "car,bike,foot";
+        EncodingManager manager = new EncodingManager(flagEncodersStr, 8);
+
+        assertTrue(((AbstractFlagEncoder) manager.getEncoder("car")).isBlockFords());
+        assertTrue(((AbstractFlagEncoder) manager.getEncoder("bike")).isBlockFords());
+        assertTrue(((AbstractFlagEncoder) manager.getEncoder("foot")).isBlockFords());
+
+        // 2) two encoders crossing fords
+        flagEncodersStr = "car,bike|blockFords=false,foot|blockFords=false";
+        manager = new EncodingManager(flagEncodersStr, 8);
+
+        assertTrue(((AbstractFlagEncoder) manager.getEncoder("car")).isBlockFords());
+        assertFalse(((AbstractFlagEncoder) manager.getEncoder("bike")).isBlockFords());
+        assertFalse(((AbstractFlagEncoder) manager.getEncoder("foot")).isBlockFords());
+
+        // 2) Try combined with another tag
+        flagEncodersStr = "car|turnCosts=true|blockFords=true,bike,foot|blockFords=false";
+        manager = new EncodingManager(flagEncodersStr, 8);
+
+        assertTrue(((AbstractFlagEncoder) manager.getEncoder("car")).isBlockFords());
+        assertTrue(((AbstractFlagEncoder) manager.getEncoder("bike")).isBlockFords());
+        assertFalse(((AbstractFlagEncoder) manager.getEncoder("foot")).isBlockFords());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
index 816310c551..11464b6731 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
@@ -17,10 +17,14 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.PMap;
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
@@ -37,6 +41,32 @@ public void testMinWeightHasSameUnitAs_getWeight()
         assertEquals(instance.getMinWeight(10), instance.calcWeight(createEdge(10, flags), false, EdgeIterator.NO_EDGE), 1e-8);
     }
 
+    @Test
+    public void testWeightWrongHeading()
+    {
+        FastestWeighting instance = new FastestWeighting(encoder, new PMap().put("heading_penalty", "100"));
+
+        VirtualEdgeIteratorState virtEdge = new VirtualEdgeIteratorState(0, 1, 1, 2, 10,
+                encoder.setProperties(10, true, true), "test", Helper.createPointList(51, 0, 51, 1));
+        double time = instance.calcWeight(virtEdge, false, 0);
+
+        virtEdge.setVirtualEdgePreference(true, false);
+        // heading penalty on edge
+        assertEquals(time + 100, instance.calcWeight(virtEdge, false, 0), 1e-8);
+        // but not in reverse heading
+        assertEquals(time, instance.calcWeight(virtEdge, true, 0), 1e-8);
+        // only after setting it
+        virtEdge.setVirtualEdgePreference(true, true);
+        assertEquals(time + 100, instance.calcWeight(virtEdge, true, 0), 1e-8);
+        // but not after releasing it
+        virtEdge.setVirtualEdgePreference(false, true);
+        assertEquals(time, instance.calcWeight(virtEdge, true, 0), 1e-8);
+
+        // test default penalty
+        instance = new FastestWeighting(encoder);
+        assertEquals(time + FastestWeighting.DEFAULT_HEADING_PENALTY, instance.calcWeight(virtEdge, false, 0), 1e-8);
+    }
+
     @Test
     public void testSpeed0()
     {
@@ -63,6 +93,12 @@ public long getFlags()
             {
                 return flags;
             }
+
+            @Override
+            public boolean getBoolean( int key, boolean reverse, boolean _default )
+            {
+                return _default;
+            }
         };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
index 4eb37f1984..bf68dea26c 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
@@ -25,10 +25,10 @@
 import com.graphhopper.util.GHUtility;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class FootFlagEncoderTest
@@ -60,12 +60,12 @@ public void testCombined()
         FlagEncoder carEncoder = encodingManager.getEncoder("CAR");
         long fl = footEncoder.setProperties(10, true, true) | carEncoder.setProperties(100, true, false);
         assertEquals(10, footEncoder.getSpeed(fl), 1e-1);
-        assertTrue(footEncoder.isBool(fl, FlagEncoder.K_FORWARD));
-        assertTrue(footEncoder.isBool(fl, FlagEncoder.K_BACKWARD));
+        assertTrue(footEncoder.isForward(fl));
+        assertTrue(footEncoder.isBackward(fl));
 
         assertEquals(100, carEncoder.getSpeed(fl), 1e-1);
-        assertTrue(carEncoder.isBool(fl, FlagEncoder.K_FORWARD));
-        assertFalse(carEncoder.isBool(fl, FlagEncoder.K_BACKWARD));
+        assertTrue(carEncoder.isForward(fl));
+        assertFalse(carEncoder.isBackward(fl));
 
         assertEquals(0, carEncoder.getSpeed(footEncoder.setProperties(10, true, true)), 1e-1);
     }
@@ -111,6 +111,8 @@ public void testAccess()
         assertTrue(footEncoder.acceptWay(way) > 0);
 
         way.setTag("bicycle", "official");
+        assertTrue(footEncoder.acceptWay(way) > 0);
+        way.setTag("foot", "no");
         assertFalse(footEncoder.acceptWay(way) > 0);
 
         way.setTag("foot", "official");
@@ -128,8 +130,16 @@ public void testAccess()
 
         way.clearTags();
         way.setTag("highway", "cycleway");
+        assertTrue(footEncoder.acceptWay(way) > 0);
+        way.setTag("foot", "no");
         assertFalse(footEncoder.acceptWay(way) > 0);
+        way.setTag("access", "yes");
+        assertFalse(footEncoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
         way.setTag("foot", "yes");
+        way.setTag("access", "no");
         assertTrue(footEncoder.acceptWay(way) > 0);
 
         way.clearTags();
@@ -147,10 +157,30 @@ public void testAccess()
     }
 
     @Test
-    public void testMixSpeedAndSafe()
+    public void testRailPlatformIssue366()
     {
         OSMWay way = new OSMWay(1);
+        way.setTag("railway", "platform");
+        long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
+        assertNotEquals(0, flags);
+
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("railway", "platform");
+        flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
+        assertNotEquals(0, flags);
+
+        way.clearTags();
+        // only tram, no highway => no access
+        way.setTag("railway", "tram");
+        flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
+        assertEquals(0, flags);
+    }
 
+    @Test
+    public void testMixSpeedAndSafe()
+    {
+        OSMWay way = new OSMWay(1);
         way.setTag("highway", "motorway");
         long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
         assertEquals(0, flags);
@@ -165,6 +195,22 @@ public void testMixSpeedAndSafe()
         assertEquals(5, footEncoder.getSpeed(flags), 1e-1);
     }
 
+    @Test
+    public void testPriority()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "cycleway");
+        assertEquals(PriorityCode.UNCHANGED.getValue(), footEncoder.handlePriority(way, 0));
+
+        way.setTag("highway", "track");
+        way.setTag("bicycle", "official");
+        assertEquals(PriorityCode.AVOID_IF_POSSIBLE.getValue(), footEncoder.handlePriority(way, 0));
+
+        way.setTag("highway", "track");
+        way.setTag("bicycle", "designated");
+        assertEquals(PriorityCode.AVOID_IF_POSSIBLE.getValue(), footEncoder.handlePriority(way, 0));
+    }
+
     @Test
     public void testSlowHiking()
     {
@@ -233,9 +279,42 @@ public void testBarrierAccess()
         node.setTag("foot", "yes");
         // no barrier!
         assertTrue(footEncoder.handleNodeTags(node) == 0);
-        
+
         node.setTag("locked", "yes");
         // barrier!
         assertTrue(footEncoder.handleNodeTags(node) > 0);
     }
+
+    @Test
+    public void handleWayTagsRoundabout()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("junction", "roundabout");
+        way.setTag("highway", "tertiary");
+        long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
+        assertTrue(footEncoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+    }
+
+    public void testFord()
+    {
+        // by default deny access through fords!
+        OSMNode node = new OSMNode(1, -1, -1);
+        node.setTag("ford", "no");
+        assertTrue(footEncoder.handleNodeTags(node) == 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("ford", "yes");
+        assertTrue(footEncoder.handleNodeTags(node) > 0);
+
+        // Now let's allow fords for foot
+        footEncoder.setBlockFords(Boolean.FALSE);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("ford", "no");
+        assertTrue(footEncoder.handleNodeTags(node) == 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("ford", "yes");
+        assertTrue(footEncoder.handleNodeTags(node) == 0);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
index 81df2aac3c..725da43dd8 100644
--- a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
@@ -19,16 +19,16 @@
 
 import com.graphhopper.reader.OSMWay;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class MotorcycleFlagEncoderTest
 {
-    private final EncodingManager em = new EncodingManager("CAR,BIKE,FOOT");
-    private final CarFlagEncoder encoder = (CarFlagEncoder) em.getEncoder("CAR");
+    private final EncodingManager em = new EncodingManager("motorcycle,foot");
+    private final MotorcycleFlagEncoder encoder = (MotorcycleFlagEncoder) em.getEncoder("motorcycle");
 
     @Test
     public void testHandleWayTags()
@@ -41,4 +41,16 @@ public void testHandleWayTags()
         assertEquals(20, encoder.getSpeed(result), .1);
         assertEquals(20, encoder.getReverseSpeed(result), .1);
     }
+
+    @Test
+    public void testSetSpeed0_issue367()
+    {
+        long flags = encoder.setProperties(10, true, true);
+        flags = encoder.setSpeed(flags, 0);
+
+        assertEquals(0, encoder.getSpeed(flags), .1);
+        assertEquals(10, encoder.getReverseSpeed(flags), .1);
+        assertFalse(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
index cc4bc85b83..cd76e482a1 100644
--- a/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
@@ -17,11 +17,14 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
-import com.graphhopper.routing.util.PriorityCode;
+
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 public class MountainBikeFlagEncoderTest extends AbstractBikeFlagEncoderTester
@@ -89,12 +92,15 @@ public void testSacScale()
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "service");
         way.setTag("sac_scale", "hiking");
-        // allow
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("highway", "service");
+        way.setTag("sac_scale", "mountain_hiking");
         assertTrue(encoder.acceptWay(way) > 0);
 
         way.setTag("sac_scale", "alpine_hiking");
         assertTrue(encoder.acceptWay(way) > 0);
-        
+
         way.setTag("sac_scale", "demanding_alpine_hiking");
         assertTrue(encoder.acceptWay(way) == 0);
     }
@@ -199,4 +205,30 @@ public void testHandleWayTagsInfluencedByRelation()
         assertPriority(PriorityCode.PREFER.getValue(), osmWay);
         assertEquals("", getWayTypeFromFlags(osmWay));
     }
+
+    // Issue 407 : Always block kissing_gate execpt for mountainbikes
+    @Test
+    public void testBarrierAccess()
+    {
+        // kissing_gate without bicycle tag
+        OSMNode node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "kissing_gate");
+        // No barrier!
+        assertTrue(encoder.handleNodeTags(node) == 0);
+
+        // kissing_gate with bicycle tag = no
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "kissing_gate");
+        node.setTag("bicycle", "no");
+        // barrier!
+        assertFalse(encoder.handleNodeTags(node) == 0);
+
+        // kissing_gate with bicycle tag
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "kissing_gate");
+        node.setTag("bicycle", "yes");
+        // No barrier!
+        assertTrue(encoder.handleNodeTags(node) == 0);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
index 36b2489024..81d5862083 100644
--- a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
@@ -23,18 +23,21 @@
 import com.graphhopper.util.GHUtility;
 
 import gnu.trove.list.array.TIntArrayList;
+
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
+
 import org.junit.*;
+
 import static org.junit.Assert.*;
+
 /**
- *
  * @author Peter Karich
  */
 public class PrepareRoutingSubnetworksTest
 {
-    private final EncodingManager em = new EncodingManager("CAR");
+    private final EncodingManager em = new EncodingManager("car");
 
     GraphStorage createGraph( EncodingManager eman )
     {
@@ -53,6 +56,7 @@ GraphStorage createSubnetworkTestGraph()
         g.edge(8, 11, 1, true);
         g.edge(12, 11, 1, true);
         g.edge(9, 12, 1, false);
+        g.edge(9, 15, 1, true);
 
         // large network
         g.edge(0, 13, 1, true);
@@ -79,7 +83,7 @@ public void testFindSubnetworks()
         // start is at 0 => large network
         assertEquals(5, (int) map.get(0));
         // next smallest and unvisited node is 1 => big network
-        assertEquals(7, (int) map.get(1));
+        assertEquals(8, (int) map.get(1));
         assertEquals(3, (int) map.get(6));
     }
 
@@ -92,11 +96,11 @@ public void testKeepLargestNetworks()
         instance.keepLargeNetworks(map);
         g.optimize();
 
-        assertEquals(7, g.getNodes());
+        assertEquals(8, g.getNodes());
         assertEquals(Arrays.<String>asList(), GHUtility.getProblems(g));
         map = instance.findSubnetworks();
         assertEquals(1, map.size());
-        assertEquals(7, (int) map.get(0));
+        assertEquals(8, (int) map.get(0));
     }
 
     GraphStorage createSubnetworkTestGraph2( EncodingManager em )
@@ -107,6 +111,8 @@ GraphStorage createSubnetworkTestGraph2( EncodingManager em )
         g.edge(1, 3, 1, true);
         g.edge(0, 2, 1, true);
         g.edge(2, 3, 1, true);
+        g.edge(3, 7, 1, true);
+        g.edge(7, 8, 1, true);
 
         // connecting both but do not allow CAR!
         g.edge(3, 4).setDistance(1);
@@ -126,10 +132,10 @@ public void testRemoveSubnetworkIfOnlyOneVehicle()
         instance.setMinNetworkSize(4);
         instance.doWork();
         g.optimize();
-        assertEquals(4, g.getNodes());
+        assertEquals(6, g.getNodes());
         assertEquals(Arrays.<String>asList(), GHUtility.getProblems(g));
         EdgeExplorer explorer = g.createEdgeExplorer();
-        assertEquals(GHUtility.asSet(2, 1), GHUtility.getNeighbors(explorer.setBaseNode(3)));
+        assertEquals(GHUtility.asSet(2, 1, 5), GHUtility.getNeighbors(explorer.setBaseNode(3)));
 
         // do not remove because small network is big enough
         g = createSubnetworkTestGraph2(em);
@@ -137,7 +143,7 @@ public void testRemoveSubnetworkIfOnlyOneVehicle()
         instance.setMinNetworkSize(3);
         instance.doWork();
         g.optimize();
-        assertEquals(7, g.getNodes());
+        assertEquals(9, g.getNodes());
 
         // do not remove because two two vehicles
         EncodingManager em2 = new EncodingManager("CAR,BIKE");
@@ -146,7 +152,7 @@ public void testRemoveSubnetworkIfOnlyOneVehicle()
         instance.setMinNetworkSize(3);
         instance.doWork();
         g.optimize();
-        assertEquals(7, g.getNodes());
+        assertEquals(9, g.getNodes());
     }
 
     GraphStorage createDeadEndUnvisitedNetworkGraph( EncodingManager em )
@@ -197,8 +203,9 @@ public void testRemoveDeadEndUnvisitedNetworks()
         GraphStorage g = createDeadEndUnvisitedNetworkGraph(em);
         assertEquals(11, g.getNodes());
 
-        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).setMinOnewayNetworkSize(3);
-        int removed = instance.removeDeadEndUnvisitedNetworks(em.getSingle());
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
+                setMinOneWayNetworkSize(3);
+        int removed = instance.removeDeadEndUnvisitedNetworks(em.getEncoder("car"));
 
         assertEquals(3, removed);
 
@@ -212,7 +219,7 @@ public void testTarjan()
         GraphStorage g = createSubnetworkTestGraph();
 
         // Requires a single vehicle type, otherwise we throw.
-        final FlagEncoder flagEncoder = em.getSingle();
+        final FlagEncoder flagEncoder = em.getEncoder("car");
         final EdgeFilter filter = new DefaultEdgeFilter(flagEncoder, false, true);
 
         TarjansStronglyConnectedComponentsAlgorithm tarjan = new TarjansStronglyConnectedComponentsAlgorithm(g, filter);
@@ -220,24 +227,36 @@ public void testTarjan()
         List<TIntArrayList> components = tarjan.findComponents();
 
         assertEquals(4, components.size());
-        assertEquals(new TIntArrayList(new int[]{ 13, 5, 3, 7, 0 }), components.get(0));
-        assertEquals(new TIntArrayList(new int[]{ 2, 4, 12, 11, 8, 1 }), components.get(1));
-        assertEquals(new TIntArrayList(new int[] {10, 14, 6}), components.get(2));
-        assertEquals(new TIntArrayList(new int[] {9}), components.get(3));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            13, 5, 3, 7, 0
+        }), components.get(0));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            2, 4, 12, 11, 8, 1
+        }), components.get(1));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            10, 14, 6
+        }), components.get(2));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            15, 9
+        }), components.get(3));
     }
 
     // Previous two-pass implementation failed on 1 -> 2 -> 0
     @Test
-    public void testNodeOrderingRegression() {
+    public void testNodeOrderingRegression()
+    {
         // 1 -> 2 -> 0
         GraphStorage g = createGraph(em);
         g.edge(1, 2, 1, false);
         g.edge(2, 0, 1, false);
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
+                setMinOneWayNetworkSize(2);
+        int removed = instance.removeDeadEndUnvisitedNetworks(em.getEncoder("car"));
 
-        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).setMinOnewayNetworkSize(2);
-        int removed = instance.removeDeadEndUnvisitedNetworks(em.getSingle());
-        
         assertEquals(3, removed);
     }
-
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
index b7b00c2ff5..ff59093c34 100644
--- a/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
@@ -19,13 +19,15 @@
 
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
+
 import static com.graphhopper.routing.util.BikeCommonFlagEncoder.PUSHING_SECTION_SPEED;
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author ratrun
  */
 public class RacingBikeFlagEncoderTest extends AbstractBikeFlagEncoderTester
@@ -74,9 +76,25 @@ public void testSacScale()
     {
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "service");
+        way.setTag("sac_scale", "mountain_hiking");
+        // disallow
+        assertEquals(0, encoder.acceptWay(way));
+
+        way.setTag("highway", "path");
         way.setTag("sac_scale", "hiking");
         // disallow
         assertEquals(0, encoder.acceptWay(way));
+
+        way.setTag("highway", "cycleway");
+        way.setTag("sac_scale", "hiking");
+        // but allow this as there is no reason for not allowing it
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        // This looks to be tagging error:
+        way.setTag("highway", "cycleway");
+        way.setTag("sac_scale", "mountain_hiking");
+        // we are coutious and disallow this
+        assertEquals(0, encoder.acceptWay(way));
     }
 
     @Test
@@ -97,6 +115,21 @@ public void testGetSpeed()
         way.clearTags();
         way.setTag("highway", "steps");
         assertEquals(2, getSpeedFromFlags(way), 1e-1);
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        assertEquals(20, getSpeedFromFlags(way), 1e-1);
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        way.setTag("surface", "paved");
+        assertEquals(20, getSpeedFromFlags(way), 1e-1);
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        way.setTag("surface", "unknownpavement");
+        assertEquals(PUSHING_SECTION_SPEED, getSpeedFromFlags(way), 1e-1);
+
     }
 
     @Test
@@ -170,4 +203,79 @@ public void testHandleWayTagsInfluencedByRelation()
         assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
         assertEquals("get off the bike, unpaved", getWayTypeFromFlags(osmWay, relFlags));
     }
+
+    @Test
+    public void testAvoidanceOfHighMaxSpeed()
+    {
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "tertiary");
+        osmWay.setTag("maxspeed", "50");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(PREFER.getValue(), osmWay);
+
+        osmWay.setTag("maxspeed", "60");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(PREFER.getValue(), osmWay);
+
+        osmWay.setTag("maxspeed", "80");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(PREFER.getValue(), osmWay);
+
+        osmWay.setTag("maxspeed", "90");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(UNCHANGED.getValue(), osmWay);
+
+        osmWay.setTag("maxspeed", "120");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(UNCHANGED.getValue(), osmWay);
+
+        osmWay.setTag("highway", "motorway");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(REACH_DEST.getValue(), osmWay);
+
+        osmWay.setTag("tunnel", "yes");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
+
+        osmWay.clearTags();
+        osmWay.setTag("highway", "motorway");
+        osmWay.setTag("tunnel", "yes");
+        osmWay.setTag("maxspeed", "80");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
+
+        osmWay.clearTags();
+        osmWay.setTag("highway", "motorway");
+        osmWay.setTag("tunnel", "yes");
+        osmWay.setTag("maxspeed", "120");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
+
+        osmWay.clearTags();
+        osmWay.setTag("highway", "notdefined");
+        osmWay.setTag("tunnel", "yes");
+        osmWay.setTag("maxspeed", "120");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
+
+        osmWay.clearTags();
+        osmWay.setTag("highway", "notdefined");
+        osmWay.setTag("maxspeed", "50");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(UNCHANGED.getValue(), osmWay);
+
+    }
+
+    @Test
+    public void testclassBicycle()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "tertiary");
+        way.setTag("class:bicycle:roadcycling", "3");
+        assertPriority(BEST.getValue(), way);
+
+        way.setTag("class:bicycle", "-2");
+        assertPriority(BEST.getValue(), way);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/search/NameIndexTest.java b/core/src/test/java/com/graphhopper/search/NameIndexTest.java
index c990ad6065..cdc35ad737 100644
--- a/core/src/test/java/com/graphhopper/search/NameIndexTest.java
+++ b/core/src/test/java/com/graphhopper/search/NameIndexTest.java
@@ -18,11 +18,13 @@
 package com.graphhopper.search;
 
 import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.util.Helper;
+import java.io.File;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class NameIndexTest
@@ -37,7 +39,7 @@ public void testNoErrorOnLargeName()
         {
             str += "";
         }
-        int result = index.put(str);
+        long result = index.put(str);
         assertEquals(127, index.get(result).length());
     }
 
@@ -45,10 +47,10 @@ public void testNoErrorOnLargeName()
     public void testPut()
     {
         NameIndex index = new NameIndex(new RAMDirectory()).create(1000);
-        int result = index.put("Something Street");
+        long result = index.put("Something Street");
         assertEquals("Something Street", index.get(result));
 
-        int existing = index.put("Something Street");
+        long existing = index.put("Something Street");
         assertEquals(result, existing);
 
         result = index.put("testing");
@@ -65,10 +67,10 @@ public void testCreate()
     {
         NameIndex index = new NameIndex(new RAMDirectory()).create(1000);
         String str1 = "nice";
-        int pointer1 = index.put(str1);
+        long pointer1 = index.put(str1);
 
         String str2 = "nice work ";
-        int pointer2 = index.put(str2);
+        long pointer2 = index.put(str2);
 
         assertEquals(str2, index.get(pointer2));
         assertEquals(str1, index.get(pointer1));
@@ -90,4 +92,26 @@ public void testTooLongNameNoError()
         index.put(str);
         index.close();
     }
+
+    @Test
+    public void testFlush()
+    {
+        String location = "./target/nameindex-store";
+        Helper.removeDir(new File(location));
+
+        NameIndex index = new NameIndex(new RAMDirectory(location, true)).create(1000);
+        long pointer = index.put("test");
+        index.flush();
+        index.close();
+
+        index = new NameIndex(new RAMDirectory(location, true));
+        assertTrue(index.loadExisting());
+        assertEquals("test", index.get(pointer));
+        // make sure bytePointer is correctly set after loadExisting
+        long newPointer = index.put("testing");
+        assertEquals(newPointer + ">" + pointer, pointer + "test".getBytes().length + 1, newPointer);
+        index.close();
+
+        Helper.removeDir(new File(location));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java b/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
index 8850b1c893..5f293ad0b1 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
@@ -18,10 +18,13 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.Helper;
+
 import java.io.File;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
index 98fe465365..a49cc8c096 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
@@ -17,20 +17,23 @@
  */
 package com.graphhopper.storage;
 
-import com.graphhopper.routing.util.*;
-import com.graphhopper.util.*;
-import static com.graphhopper.util.GHUtility.*;
-import com.graphhopper.util.shapes.BBox;
+import static com.graphhopper.util.GHUtility.count;
+import static org.junit.Assert.*;
+
 import java.io.Closeable;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import static org.junit.Assert.*;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
+import com.graphhopper.routing.util.*;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.BBox;
+
 /**
  * Abstract test class to be extended for implementations of the Graph interface. Graphs
  * implementing GraphStorage should extend GraphStorageTest instead.
@@ -686,7 +689,7 @@ public void testBounds()
     {
         graph = createGraph();
         BBox b = graph.getBounds();
-        assertEquals(BBox.INVERSE.maxLat, b.maxLat, 1e-6);
+        assertEquals(BBox.createInverse(false).maxLat, b.maxLat, 1e-6);
 
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 10, 20);
@@ -800,14 +803,14 @@ public void testCreateDuplicateEdges()
         EdgeIteratorState oneIter = graph.getEdgeProps(iter.getEdge(), 3);
         assertEquals(13, oneIter.getDistance(), 1e-6);
         assertEquals(2, oneIter.getBaseNode());
-        assertTrue(carEncoder.isBool(oneIter.getFlags(), FlagEncoder.K_FORWARD));
-        assertFalse(carEncoder.isBool(oneIter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertTrue(carEncoder.isForward(oneIter.getFlags()));
+        assertFalse(carEncoder.isBackward(oneIter.getFlags()));
 
         oneIter = graph.getEdgeProps(iter.getEdge(), 2);
         assertEquals(13, oneIter.getDistance(), 1e-6);
         assertEquals(3, oneIter.getBaseNode());
-        assertFalse(carEncoder.isBool(oneIter.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(carEncoder.isBool(oneIter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertFalse(carEncoder.isForward(oneIter.getFlags()));
+        assertTrue(carEncoder.isBackward(oneIter.getFlags()));
 
         graph.edge(3, 2, 14, true);
         assertEquals(4, GHUtility.count(carOutExplorer.setBaseNode(2)));
@@ -947,14 +950,14 @@ public void testGetAllEdgesWithDelete()
         graph.edge(2, 3, 1, true);
         AllEdgesIterator iter = graph.getAllEdges();
         assertEquals(4, GHUtility.count(iter));
-        assertEquals(4, iter.getMaxId());
+        assertEquals(4, iter.getCount());
 
         // delete
         graph.markNodeRemoved(1);
         graph.optimize();
         iter = graph.getAllEdges();
         assertEquals(2, GHUtility.count(iter));
-        assertEquals(4, iter.getMaxId());
+        assertEquals(4, iter.getCount());
 
         iter = graph.getAllEdges();
         iter.next();
@@ -1044,8 +1047,8 @@ public void test8BytesFlags()
         assertEquals(99.123, list.get(0).getSpeed(edge.getFlags()), 1e-3);
         long flags = GHUtility.getEdge(graph, 1, 0).getFlags();
         assertEquals(99.123, list.get(0).getSpeed(flags), 1e-3);
-        assertTrue(list.get(0).isBool(flags, FlagEncoder.K_FORWARD));
-        assertTrue(list.get(0).isBool(flags, FlagEncoder.K_BACKWARD));
+        assertTrue(list.get(0).isForward(flags));
+        assertTrue(list.get(0).isBackward(flags));
         edge = graph.edge(2, 3);
         edge.setFlags(list.get(1).setProperties(44.123, true, false));
         assertEquals(44.123, list.get(1).getSpeed(edge.getFlags()), 1e-3);
@@ -1053,8 +1056,8 @@ public void test8BytesFlags()
         flags = GHUtility.getEdge(graph, 3, 2).getFlags();
         assertEquals(44.123, list.get(1).getSpeed(flags), 1e-3);
         assertEquals(44.123, list.get(1).getReverseSpeed(flags), 1e-3);
-        assertFalse(list.get(1).isBool(flags, FlagEncoder.K_FORWARD));
-        assertTrue(list.get(1).isBool(flags, FlagEncoder.K_BACKWARD));
+        assertFalse(list.get(1).isForward(flags));
+        assertTrue(list.get(1).isBackward(flags));
     }
 
     @Test
@@ -1098,13 +1101,13 @@ public void testDetachEdge()
         assertEquals(2, iter.getAdjNode());
         assertEquals(1, edgeState2.fetchWayGeometry(0).getLatitude(0), 1e-1);
         assertEquals(2, edgeState2.getAdjNode());
-        assertTrue(carEncoder.isBool(edgeState2.getFlags(), FlagEncoder.K_FORWARD));
+        assertTrue(carEncoder.isForward(edgeState2.getFlags()));
 
         EdgeIteratorState edgeState3 = iter.detach(true);
         assertEquals(0, edgeState3.getAdjNode());
         assertEquals(2, edgeState3.getBaseNode());
         assertEquals(3, edgeState3.fetchWayGeometry(0).getLatitude(0), 1e-1);
-        assertFalse(carEncoder.isBool(edgeState3.getFlags(), FlagEncoder.K_FORWARD));
+        assertFalse(carEncoder.isForward(edgeState3.getFlags()));
         assertEquals(GHUtility.getEdge(graph, 0, 2).getFlags(), edgeState2.getFlags());
         assertEquals(GHUtility.getEdge(graph, 2, 0).getFlags(), edgeState3.getFlags());
 
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java b/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java
index 276392a40b..ad50056f67 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java
@@ -18,11 +18,16 @@
  */
 package com.graphhopper.storage;
 
+import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
+
 import java.io.File;
+
 import org.junit.After;
+
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -31,7 +36,6 @@
  */
 public abstract class AbstractLockFactoryTester
 {
-
     protected final File lockDir = new File("./target/lockingtest/");
 
     protected abstract LockFactory createLockFactory();
@@ -80,6 +84,11 @@ public void testForceDelete()
         Lock lock = instance.create("testlock", true);
         assertTrue(lock.tryLock());
         assertTrue(lock.isLocked());
+
+        // on windows we cannot forcefully remove an unreleased lock
+        if (Constants.WINDOWS)
+            lock.release();
+
         instance.forceRemove(lock.getName(), true);
         assertFalse(lock.isLocked());
     }
diff --git a/core/src/test/java/com/graphhopper/storage/DataAccessTest.java b/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
index f5ae8eb1d9..6beee78b72 100644
--- a/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
@@ -19,15 +19,18 @@
 
 import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.Helper;
+
 import java.io.File;
 import java.nio.ByteOrder;
+
 import org.junit.After;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public abstract class DataAccessTest
diff --git a/core/src/test/java/com/graphhopper/storage/EdgeTest.java b/core/src/test/java/com/graphhopper/storage/EdgeTest.java
index 6d840af599..cdc47c664f 100644
--- a/core/src/test/java/com/graphhopper/storage/EdgeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/EdgeTest.java
@@ -19,10 +19,10 @@
 
 import com.graphhopper.util.EdgeIterator;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class EdgeTest
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
index 1c0900623a..31c0a284b3 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
@@ -19,12 +19,14 @@
 
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
+
 import java.io.IOException;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public class GraphHopperStorageTest extends AbstractGraphStorageTester
@@ -67,16 +69,17 @@ public void testNoCreateCalled() throws IOException
     @Test
     public void testSave_and_fileFormat() throws IOException
     {
-        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
+        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
         NodeAccess na = graph.getNodeAccess();
-        na.setNode(0, 10, 10);
-        na.setNode(1, 11, 20);
-        na.setNode(2, 12, 12);
+        assertTrue(na.is3D());
+        na.setNode(0, 10, 10, 0);
+        na.setNode(1, 11, 20, 1);
+        na.setNode(2, 12, 12, 0.4);
 
         EdgeIteratorState iter2 = graph.edge(0, 1, 100, true);
-        iter2.setWayGeometry(Helper.createPointList(1.5, 1, 2, 3));
+        iter2.setWayGeometry(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0));
         EdgeIteratorState iter1 = graph.edge(0, 2, 200, true);
-        iter1.setWayGeometry(Helper.createPointList(3.5, 4.5, 5, 6));
+        iter1.setWayGeometry(Helper.createPointList3D(3.5, 4.5, 0, 5, 6, 0));
         graph.edge(9, 10, 200, true);
         graph.edge(9, 11, 200, true);
         graph.edge(1, 2, 120, false);
@@ -88,7 +91,7 @@ public void testSave_and_fileFormat() throws IOException
         graph.flush();
         graph.close();
 
-        graph = newGraph(new MMapDirectory(defaultGraphLoc), false);
+        graph = newGraph(new MMapDirectory(defaultGraphLoc), true);
         assertTrue(graph.loadExisting());
 
         assertEquals(12, graph.getNodes());
@@ -96,14 +99,17 @@ public void testSave_and_fileFormat() throws IOException
 
         assertEquals("named street1", graph.getEdgeProps(iter1.getEdge(), iter1.getAdjNode()).getName());
         assertEquals("named street2", graph.getEdgeProps(iter2.getEdge(), iter2.getAdjNode()).getName());
-        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList(4.4, 5.5, 6.6, 7.7));
+        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList3D(4.4, 5.5, 0, 6.6, 7.7, 0));
         checkGraph(graph);
     }
 
     protected void checkGraph( Graph g )
     {
         NodeAccess na = g.getNodeAccess();
-        assertEquals(new BBox(10, 20, 10, 12), g.getBounds());
+        assertTrue(na.is3D());
+        assertTrue(g.getBounds().isValid());
+
+        assertEquals(new BBox(10, 20, 10, 12, 0, 1), g.getBounds());
         assertEquals(10, na.getLatitude(0), 1e-2);
         assertEquals(10, na.getLongitude(0), 1e-2);
         EdgeExplorer explorer = g.createEdgeExplorer(carOutFilter);
@@ -112,12 +118,12 @@ protected void checkGraph( Graph g )
 
         EdgeIterator iter = explorer.setBaseNode(0);
         assertTrue(iter.next());
-        assertEquals(Helper.createPointList(3.5, 4.5, 5, 6), iter.fetchWayGeometry(0));
+        assertEquals(Helper.createPointList3D(3.5, 4.5, 0, 5, 6, 0), iter.fetchWayGeometry(0));
 
         assertTrue(iter.next());
-        assertEquals(Helper.createPointList(1.5, 1, 2, 3), iter.fetchWayGeometry(0));
-        assertEquals(Helper.createPointList(10, 10, 1.5, 1, 2, 3), iter.fetchWayGeometry(1));
-        assertEquals(Helper.createPointList(1.5, 1, 2, 3, 11, 20), iter.fetchWayGeometry(2));
+        assertEquals(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0), iter.fetchWayGeometry(0));
+        assertEquals(Helper.createPointList3D(10, 10, 0, 1.5, 1, 0, 2, 3, 0), iter.fetchWayGeometry(1));
+        assertEquals(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0, 11, 20, 1), iter.fetchWayGeometry(2));
 
         assertEquals(11, na.getLatitude(1), 1e-2);
         assertEquals(20, na.getLongitude(1), 1e-2);
@@ -131,9 +137,9 @@ protected void checkGraph( Graph g )
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(2)));
 
         EdgeIteratorState eib = GHUtility.getEdge(g, 1, 2);
-        assertEquals(Helper.createPointList(), eib.fetchWayGeometry(0));
-        assertEquals(Helper.createPointList(11, 20), eib.fetchWayGeometry(1));
-        assertEquals(Helper.createPointList(12, 12), eib.fetchWayGeometry(2));
+        assertEquals(Helper.createPointList3D(), eib.fetchWayGeometry(0));
+        assertEquals(Helper.createPointList3D(11, 20, 1), eib.fetchWayGeometry(1));
+        assertEquals(Helper.createPointList3D(12, 12, 0.4), eib.fetchWayGeometry(2));
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(2)));
     }
 
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
index 261860313d..5865ca16ac 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
@@ -28,17 +28,16 @@
 import static org.junit.Assert.assertTrue;
 
 /**
- *
  * @author Karl Hbner
  */
 public class GraphHopperStorageWithTurnCostsTest extends GraphHopperStorageTest
 {
-    private TurnCostStorage turnCostStorage;
+    private TurnCostExtension turnCostStorage;
 
     @Override
     protected GraphStorage newGraph( Directory dir, boolean is3D )
     {
-        turnCostStorage = new TurnCostStorage();
+        turnCostStorage = new TurnCostExtension();
         return new GraphHopperStorage(dir, encodingManager, is3D, turnCostStorage);
     }
 
@@ -48,26 +47,28 @@ protected GraphStorage newRAMGraph()
         return newGraph(new RAMDirectory(), false);
     }
 
+    @Override
     @Test
-    public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
+    public void testSave_and_fileFormat() throws IOException
     {
-        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
+        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
         NodeAccess na = graph.getNodeAccess();
-        na.setNode(0, 10, 10);
-        na.setNode(1, 11, 20);
-        na.setNode(2, 12, 12);
+        assertTrue(na.is3D());
+        na.setNode(0, 10, 10, 0);
+        na.setNode(1, 11, 20, 1);
+        na.setNode(2, 12, 12, 0.4);
 
         EdgeIteratorState iter2 = graph.edge(0, 1, 100, true);
-        iter2.setWayGeometry(Helper.createPointList(1.5, 1, 2, 3));
+        iter2.setWayGeometry(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0));
         EdgeIteratorState iter1 = graph.edge(0, 2, 200, true);
-        iter1.setWayGeometry(Helper.createPointList(3.5, 4.5, 5, 6));
+        iter1.setWayGeometry(Helper.createPointList3D(3.5, 4.5, 0, 5, 6, 0));
         graph.edge(9, 10, 200, true);
         graph.edge(9, 11, 200, true);
         graph.edge(1, 2, 120, false);
 
-        turnCostStorage.addTurnInfo(0, iter1.getEdge(), iter2.getEdge(), 1337);
-        turnCostStorage.addTurnInfo(0, iter2.getEdge(), iter1.getEdge(), 666);
-        turnCostStorage.addTurnInfo(1, iter1.getEdge(), iter2.getEdge(), 815);
+        turnCostStorage.addTurnInfo(iter1.getEdge(), 0, iter2.getEdge(), 1337);
+        turnCostStorage.addTurnInfo(iter2.getEdge(), 0, iter1.getEdge(), 666);
+        turnCostStorage.addTurnInfo(iter1.getEdge(), 1, iter2.getEdge(), 815);
 
         iter1.setName("named street1");
         iter2.setName("named street2");
@@ -76,7 +77,7 @@ public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
         graph.flush();
         graph.close();
 
-        graph = newGraph(new MMapDirectory(defaultGraphLoc), false);
+        graph = newGraph(new MMapDirectory(defaultGraphLoc), true);
         assertTrue(graph.loadExisting());
 
         assertEquals(12, graph.getNodes());
@@ -85,17 +86,18 @@ public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
         assertEquals("named street1", graph.getEdgeProps(iter1.getEdge(), iter1.getAdjNode()).getName());
         assertEquals("named street2", graph.getEdgeProps(iter2.getEdge(), iter2.getAdjNode()).getName());
 
-        assertEquals(1337, turnCostStorage.getTurnCostFlags(0, iter1.getEdge(), iter2.getEdge()));
-        assertEquals(666, turnCostStorage.getTurnCostFlags(0, iter2.getEdge(), iter1.getEdge()));
-        assertEquals(815, turnCostStorage.getTurnCostFlags(1, iter1.getEdge(), iter2.getEdge()));
-        assertEquals(0, turnCostStorage.getTurnCostFlags(3, iter1.getEdge(), iter2.getEdge()));
+        assertEquals(1337, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 0, iter2.getEdge()));
+        assertEquals(666, turnCostStorage.getTurnCostFlags(iter2.getEdge(), 0, iter1.getEdge()));
+        assertEquals(815, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 1, iter2.getEdge()));
+        assertEquals(0, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 3, iter2.getEdge()));
 
-        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList(4.4, 5.5, 6.6, 7.7));
+        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList3D(4.4, 5.5, 0, 6.6, 7.7, 0));
         checkGraph(graph);
     }
 
     @Test
-    public void testEnsureCapacity() throws IOException {
+    public void testEnsureCapacity() throws IOException
+    {
         graph = newGraph(new MMapDirectory(defaultGraphLoc), false);
         graph.setSegmentSize(128);
         graph.create(100); // 100 is the minimum size
@@ -106,7 +108,8 @@ public void testEnsureCapacity() throws IOException {
         Random r = new Random();
 
         NodeAccess na = graph.getNodeAccess();
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 100; i++)
+        {
             double randomLat = 90 * r.nextDouble();
             double randomLon = 180 * r.nextDouble();
 
@@ -114,23 +117,26 @@ public void testEnsureCapacity() throws IOException {
         }
 
         // Make node 50 the 'center' node
-        for (int nodeId = 51; nodeId < 100; nodeId++) {
+        for (int nodeId = 51; nodeId < 100; nodeId++)
+        {
             graph.edge(50, nodeId, r.nextDouble(), true);
         }
-        for (int nodeId = 0; nodeId < 50; nodeId++) {
+        for (int nodeId = 0; nodeId < 50; nodeId++)
+        {
             graph.edge(nodeId, 50, r.nextDouble(), true);
         }
 
         // add 100 turn cost entries around node 50
-        for (int edgeId = 0; edgeId < 50; edgeId++) {
-            turnCostStorage.addTurnInfo(50, edgeId, edgeId + 50, 1337);
-            turnCostStorage.addTurnInfo(50, edgeId + 50, edgeId, 1337);
+        for (int edgeId = 0; edgeId < 50; edgeId++)
+        {
+            turnCostStorage.addTurnInfo(edgeId, 50, edgeId + 50, 1337);
+            turnCostStorage.addTurnInfo(edgeId + 50, 50, edgeId, 1337);
         }
 
-        turnCostStorage.addTurnInfo(50, 0, 1, 1337);
+        turnCostStorage.addTurnInfo(0, 50, 1, 1337);
         assertEquals(104, turnCostStorage.getCapacity() / 16); // we are still good here
 
-        turnCostStorage.addTurnInfo(50, 0, 2, 1337);
+        turnCostStorage.addTurnInfo(0, 50, 2, 1337);
         // A new segment should be added, which will support 128 / 16 = 8 more entries.
         assertEquals(112, turnCostStorage.getCapacity() / 16);
     }
diff --git a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
index cad468fb81..e2b10885a4 100644
--- a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
@@ -17,15 +17,18 @@
  */
 package com.graphhopper.storage;
 
+import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.ch.PrepareEncoder;
 import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.LevelEdgeFilter;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeSkipIterState;
-import com.graphhopper.util.GHUtility;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.BBox;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
@@ -46,7 +49,7 @@ public GraphStorage newGraph( Directory dir, boolean is3D )
     }
 
     @Test
-    public void testCannotBeLoadedViaDifferentClass()
+    public void testCannotBeLoadedWithNormalGraphHopperStorageClass()
     {
         GraphStorage g = newGraph(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
         g.flush();
@@ -63,12 +66,15 @@ public void testCannotBeLoadedViaDifferentClass()
 
         g = newGraph(new RAMDirectory(defaultGraphLoc, true), false);
         assertTrue(g.loadExisting());
+        // empty graph still has invalid bounds
+        assertEquals(g.getBounds(), BBox.createInverse(false));
     }
 
     @Test
     public void testPriosWhileDeleting()
     {
         LevelGraphStorage g = createGraph();
+        g.getNodeAccess().ensureNode(19);
         for (int i = 0; i < 20; i++)
         {
             g.setLevel(i, i);
@@ -77,13 +83,14 @@ public void testPriosWhileDeleting()
         g.optimize();
         assertEquals(9, g.getLevel(9));
         assertNotSame(10, g.getLevel(10));
-        assertEquals(19, g.getNodes());
     }
 
     @Test
     public void testPrios()
     {
         LevelGraph g = createGraph();
+        g.getNodeAccess().ensureNode(30);
+
         assertEquals(0, g.getLevel(10));
 
         g.setLevel(10, 100);
@@ -174,15 +181,15 @@ public void testGetWeight()
         sc1.setFlags(flags);
         sc1.setWeight(100.123);
         assertEquals(100.123, sc1.getWeight(), 1e-3);
-        assertTrue(carEncoder.isBool(sc1.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(carEncoder.isBool(sc1.getFlags(), FlagEncoder.K_BACKWARD));
+        assertTrue(carEncoder.isForward(sc1.getFlags()));
+        assertTrue(carEncoder.isBackward(sc1.getFlags()));
 
         flags = carEncoder.setProperties(10, false, true);
         sc1.setFlags(flags);
         sc1.setWeight(100.123);
-        assertEquals(100.123, sc1.getWeight(), 1e-3);        
-        assertFalse(carEncoder.isBool(sc1.getFlags(), FlagEncoder.K_FORWARD));
-        assertTrue(carEncoder.isBool(sc1.getFlags(), FlagEncoder.K_BACKWARD));
+        assertEquals(100.123, sc1.getWeight(), 1e-3);
+        assertFalse(carEncoder.isForward(sc1.getFlags()));
+        assertTrue(carEncoder.isBackward(sc1.getFlags()));
     }
 
     @Test
@@ -207,4 +214,47 @@ public void testGetWeightIfAdvancedEncoder()
         sc1.setWeight(1.011011);
         assertEquals(1.011011, sc1.getWeight(), 1e-3);
     }
+
+    @Test
+    public void testQueryGraph()
+    {
+        LevelGraph levelGraph = createGraph();
+        NodeAccess na = levelGraph.getNodeAccess();
+        na.setNode(0, 1.00, 1.00);
+        na.setNode(1, 1.02, 1.00);
+        na.setNode(2, 1.04, 1.00);
+
+        EdgeIteratorState edge1 = levelGraph.edge(0, 1);
+        EdgeIteratorState edge2 = levelGraph.edge(1, 2);
+        levelGraph.shortcut(0, 1);
+
+        QueryGraph qGraph = new QueryGraph(levelGraph);
+        QueryResult fromRes = createQR(1.004, 1.01, 0, edge1);
+        QueryResult toRes = createQR(1.019, 1.00, 0, edge1);
+        qGraph.lookup(fromRes, toRes);
+
+        Graph oGraph = qGraph.getBaseGraph();
+        EdgeExplorer explorer = oGraph.createEdgeExplorer();
+
+        assertTrue(levelGraph.getNodes() < qGraph.getNodes());
+        assertTrue(oGraph.getNodes() == qGraph.getNodes());
+
+        // traverse virtual edges and normal edges but no shortcuts!
+        assertEquals(GHUtility.asSet(fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(0)));
+        assertEquals(GHUtility.asSet(toRes.getClosestNode(), 2), GHUtility.getNeighbors(explorer.setBaseNode(1)));
+
+        // get neighbors from virtual nodes
+        assertEquals(GHUtility.asSet(0, toRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(fromRes.getClosestNode())));
+        assertEquals(GHUtility.asSet(1, fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(toRes.getClosestNode())));
+    }
+
+    QueryResult createQR( double lat, double lon, int wayIndex, EdgeIteratorState edge )
+    {
+        QueryResult res = new QueryResult(lat, lon);
+        res.setClosestEdge(edge);
+        res.setWayIndex(wayIndex);
+        res.setSnappedPosition(QueryResult.Position.EDGE);
+        res.calcSnappedPoint(Helper.DIST_PLANE);
+        return res;
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
index 941d81b485..261a254183 100644
--- a/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.storage;
 
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/storage/MMapDirectoryTest.java b/core/src/test/java/com/graphhopper/storage/MMapDirectoryTest.java
index 722025ebe0..738e019cc0 100644
--- a/core/src/test/java/com/graphhopper/storage/MMapDirectoryTest.java
+++ b/core/src/test/java/com/graphhopper/storage/MMapDirectoryTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class MMapDirectoryTest extends AbstractDirectoryTester
diff --git a/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java b/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java
index ddeaa9e012..a853da7b02 100644
--- a/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java
+++ b/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java
@@ -19,11 +19,12 @@
 package com.graphhopper.storage;
 
 import java.nio.channels.OverlappingFileLockException;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class NativeFSLockFactoryTest extends AbstractLockFactoryTester
diff --git a/core/src/test/java/com/graphhopper/storage/RAMDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/RAMDataAccessTest.java
index 61430209fd..51ce1226b9 100644
--- a/core/src/test/java/com/graphhopper/storage/RAMDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/RAMDataAccessTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class RAMDataAccessTest extends DataAccessTest
diff --git a/core/src/test/java/com/graphhopper/storage/RAMDirectoryTest.java b/core/src/test/java/com/graphhopper/storage/RAMDirectoryTest.java
index 542d875c42..92cba0d9be 100644
--- a/core/src/test/java/com/graphhopper/storage/RAMDirectoryTest.java
+++ b/core/src/test/java/com/graphhopper/storage/RAMDirectoryTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class RAMDirectoryTest extends AbstractDirectoryTester
diff --git a/core/src/test/java/com/graphhopper/storage/RAMIntDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/RAMIntDataAccessTest.java
index fae20891f4..41c28047fc 100644
--- a/core/src/test/java/com/graphhopper/storage/RAMIntDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/RAMIntDataAccessTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class RAMIntDataAccessTest extends DataAccessTest
diff --git a/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java b/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
index 1f9badefe4..ef6bb7eef9 100644
--- a/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
+++ b/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
@@ -19,7 +19,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class SimpleFSLockFactoryTest extends AbstractLockFactoryTester
diff --git a/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java b/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java
index d758826e03..922a87db3d 100644
--- a/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java
+++ b/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java
@@ -18,12 +18,14 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.Helper;
+
 import java.io.File;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class StorablePropertiesTest
diff --git a/core/src/test/java/com/graphhopper/storage/SynchedDAWrapperTest.java b/core/src/test/java/com/graphhopper/storage/SynchedDAWrapperTest.java
index cebaee0c5b..76ec1c41e3 100644
--- a/core/src/test/java/com/graphhopper/storage/SynchedDAWrapperTest.java
+++ b/core/src/test/java/com/graphhopper/storage/SynchedDAWrapperTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class SynchedDAWrapperTest extends DataAccessTest
diff --git a/core/src/test/java/com/graphhopper/storage/UnsafeDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/UnsafeDataAccessTest.java
index 824f6a881f..db70ee4313 100644
--- a/core/src/test/java/com/graphhopper/storage/UnsafeDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/UnsafeDataAccessTest.java
@@ -18,12 +18,14 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.BitUtil;
+
 import java.nio.ByteOrder;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class UnsafeDataAccessTest extends DataAccessTest
diff --git a/core/src/test/java/com/graphhopper/storage/VLongStorageTest.java b/core/src/test/java/com/graphhopper/storage/VLongStorageTest.java
index 7cb369e6e1..1719234f99 100644
--- a/core/src/test/java/com/graphhopper/storage/VLongStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/VLongStorageTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.storage;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
index cf996add31..fa925c1504 100644
--- a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
+++ b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
@@ -31,11 +31,15 @@
 import com.graphhopper.util.DistanceCalcEarth;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
+
 import java.io.Closeable;
 import java.io.File;
 import java.util.Random;
+
 import org.junit.After;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -74,7 +78,7 @@ public void testSimpleGraph()
         Graph g = createGraph(new EncodingManager("CAR"));
         initSimpleGraph(g);
 
-        idx = createIndex(g, 8);
+        idx = createIndex(g, -1);
         assertEquals(4, idx.findID(5, 2));
         assertEquals(3, idx.findID(1.5, 2));
         assertEquals(0, idx.findID(-1, -1));
@@ -128,7 +132,7 @@ public void testSimpleGraph2()
         Graph g = createGraph(new EncodingManager("CAR"));
         initSimpleGraph(g);
 
-        idx = createIndex(g, 28);
+        idx = createIndex(g, -1);
         assertEquals(4, idx.findID(5, 2));
         assertEquals(3, idx.findID(1.5, 2));
         assertEquals(0, idx.findID(-1, -1));
@@ -153,7 +157,7 @@ public void testGrid()
         Graph g = createSampleGraph(new EncodingManager("CAR"));
         int locs = g.getNodes();
 
-        idx = createIndex(g, 120);
+        idx = createIndex(g, -1);
         // if we would use less array entries then some points gets the same key so avoid that for this test
         // e.g. for 16 we get "expected 6 but was 9" i.e 6 was overwritten by node j9 which is a bit closer to the grid center        
         // go through every point of the graph if all points are reachable
@@ -193,8 +197,8 @@ public void testGrid()
             }
 
             assertTrue(i + " orig:" + (float) lat + "," + (float) lon
-                    + " full:" + fullLat + "," + fullLon + " fullDist:" + fullDist
-                    + " found:" + newLat + "," + newLon + " foundDist:" + newDist,
+                            + " full:" + fullLat + "," + fullLon + " fullDist:" + fullDist
+                            + " found:" + newLat + "," + newLon + " foundDist:" + newDist,
                     Math.abs(fullDist - newDist) < 50000);
         }
         fullIndex.close();
@@ -211,7 +215,7 @@ boolean testGridIgnore( int i )
     public void testSinglePoints120()
     {
         Graph g = createSampleGraph(new EncodingManager("CAR"));
-        idx = createIndex(g, 120);
+        idx = createIndex(g, -1);
 
         assertEquals(1, idx.findID(1.637, 2.23));
         assertEquals(10, idx.findID(3.649, 1.375));
@@ -227,7 +231,7 @@ public void testSinglePoints120()
     public void testSinglePoints32()
     {
         Graph g = createSampleGraph(new EncodingManager("CAR"));
-        idx = createIndex(g, 32);
+        idx = createIndex(g, -1);
 
         // 10 or 6
         assertEquals(10, idx.findID(3.649, 1.375));
@@ -355,7 +359,7 @@ public void testDifferentVehicles()
         final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
         Graph g = createGraph(encodingManager);
         initSimpleGraph(g);
-        idx = createIndex(g, 32);
+        idx = createIndex(g, -1);
         assertEquals(1, idx.findID(1, -1));
 
         // now make all edges from node 1 accessible for CAR only
@@ -367,7 +371,7 @@ public void testDifferentVehicles()
         }
         idx.close();
 
-        idx = createIndex(g, 32);
+        idx = createIndex(g, -1);
         FootFlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
         assertEquals(2, idx.findClosest(1, -1, new DefaultEdgeFilter(footEncoder)).getClosestNode());
         Helper.close((Closeable) g);
diff --git a/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java b/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
index 50d76f5d68..36b61b1892 100644
--- a/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
@@ -21,14 +21,17 @@
 import com.graphhopper.geohash.SpatialKeyAlgo;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
+
 import java.util.ArrayList;
 import java.util.Arrays;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 
 /**
- *
  * @author Peter Karich
  */
 public class BresenhamLineTest
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java
index 5d6ef736fb..918c9c00a0 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.Graph;
 import org.junit.*;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class Location2IDFullIndexTest extends AbstractLocationIndexTester
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java
index dfb41251ce..65478c3cff 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.Graph;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class Location2IDFullWithEdgesIndexTest extends AbstractLocationIndexTester
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
index 801367d298..e192f7c8ee 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
@@ -21,11 +21,12 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.MMapDirectory;
 import com.graphhopper.storage.RAMDirectory;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public class Location2IDQuadtreeTest extends AbstractLocationIndexTester
@@ -33,13 +34,16 @@
     @Override
     public LocationIndex createIndex( Graph g, int resolution )
     {
-        return new Location2IDQuadtree(g, new MMapDirectory(location + "loc2idIndex")).setResolution(resolution).prepareIndex();
+        if (resolution < 0)
+            resolution = 120;
+        return new Location2IDQuadtree(g, new MMapDirectory(location + "loc2idIndex")).
+                setResolution(resolution).prepareIndex();
     }
 
     @Test
     public void testNormedDist()
     {
-        Location2IDQuadtree index = new Location2IDQuadtree(createGraph(new EncodingManager()), new RAMDirectory());
+        Location2IDQuadtree index = new Location2IDQuadtree(createGraph(new EncodingManager("car")), new RAMDirectory());
         index.initAlgo(5, 6);
         assertEquals(1, index.getNormedDist(0, 1), 1e-6);
         assertEquals(2, index.getNormedDist(0, 7), 1e-6);
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
similarity index 85%
rename from core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java
rename to core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
index 0b59bcb6c9..9df6bf1504 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
@@ -31,24 +31,35 @@
 import gnu.trove.list.TIntList;
 import gnu.trove.set.TIntSet;
 import gnu.trove.set.hash.TIntHashSet;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  */
-public class LocationIndexTreeSCTest extends LocationIndexTreeTest
+public class LocationIndexTreeForLevelGraphTest extends LocationIndexTreeTest
 {
     @Override
-    public LocationIndexTreeSC createIndex( Graph g, int resolution )
+    public LocationIndexTree createIndex( Graph g, int resolution )
+    {
+        if (resolution < 0)
+            resolution = 500000;
+        return (LocationIndexTree) createIndexNoPrepare(g, resolution).prepareIndex();
+    }
+
+    @Override
+    public LocationIndexTree createIndexNoPrepare( Graph g, int resolution )
     {
         Directory dir = new RAMDirectory(location);
-        LocationIndexTreeSC idx = new LocationIndexTreeSC((LevelGraph) g, dir);
-        idx.setResolution(1000000).prepareIndex();
-        return idx;
+        LocationIndexTree tmpIdx = new LocationIndexTree(g.getBaseGraph(), dir);
+        tmpIdx.setResolution(resolution);
+        return tmpIdx;
     }
 
     @Override
@@ -99,6 +110,7 @@ public void testLevelGraph()
     public void testSortHighLevelFirst()
     {
         final LevelGraph lg = createGraph(new RAMDirectory(), encodingManager, false);
+        lg.getNodeAccess().ensureNode(4);
         lg.setLevel(1, 10);
         lg.setLevel(2, 30);
         lg.setLevel(3, 20);
@@ -135,7 +147,7 @@ public void testLevelGraphBug()
         na.setNode(2, 0.5, 0.5);
         na.setNode(3, 0.5, 1);
         EdgeIteratorState iter1 = lg.edge(1, 0, 100, true);
-        EdgeIteratorState iter2 = lg.edge(2, 3, 100, true);
+        lg.edge(2, 3, 100, true);
 
         lg.setLevel(0, 11);
         lg.setLevel(1, 10);
@@ -147,15 +159,17 @@ public void testLevelGraphBug()
         // disconnect higher 3 from lower 2
         lg.disconnect(lg.createEdgeExplorer(), iter1);
 
-        LocationIndexTreeSC index = new LocationIndexTreeSC(lg, new RAMDirectory());
-        index.setResolution(100000);
-        index.prepareIndex();
+        LocationIndexTree index = createIndex(lg, 100000);
+
         // very close to 2, but should match the edge 0--1
         TIntHashSet set = index.findNetworkEntries(0.51, 0.2, index.maxRegionSearch);
+        assertEquals(0, index.findID(0.51, 0.2));
+        assertEquals(1, index.findID(0.1, 0.1));
+        assertEquals(2, index.findID(0.51, 0.51));
+        assertEquals(3, index.findID(0.51, 1.1));
         TIntSet expectedSet = new TIntHashSet();
-        expectedSet.add(1);
+        expectedSet.add(0);
         expectedSet.add(2);
         assertEquals(expectedSet, set);
-        assertEquals(0, index.findID(0.51, 0.2));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index 8fcb543aad..cd4b223136 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -26,12 +26,14 @@
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
 import gnu.trove.set.hash.TIntHashSet;
+
 import java.util.Arrays;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class LocationIndexTreeTest extends AbstractLocationIndexTester
@@ -42,14 +44,16 @@
     @Override
     public LocationIndexTree createIndex( Graph g, int resolution )
     {
-        return internalCreateIndex(g, 500000);
+        if (resolution < 0)
+            resolution = 500000;
+        return (LocationIndexTree) createIndexNoPrepare(g, resolution).prepareIndex();
     }
 
-    public LocationIndexTree internalCreateIndex( Graph g, int minMeter )
+    public LocationIndexTree createIndexNoPrepare( Graph g, int resolution )
     {
         Directory dir = new RAMDirectory(location);
         LocationIndexTree tmpIDX = new LocationIndexTree(g, dir);
-        tmpIDX.setResolution(minMeter).prepareIndex();
+        tmpIDX.setResolution(resolution);
         return tmpIDX;
     }
 
@@ -87,7 +91,7 @@ Graph createTestGraph()
     public void testSnappedPointAndGeometry()
     {
         Graph graph = createTestGraph();
-        LocationIndex index = createIndex(graph, 1000);
+        LocationIndex index = createIndex(graph, -1);
         // query directly the tower node
         QueryResult res = index.findClosest(-0.4, 0.9, EdgeFilter.ALL_EDGES);
         assertEquals(new GHPoint(-0.4, 0.9), res.getSnappedPoint());
@@ -103,8 +107,8 @@ public void testSnappedPointAndGeometry()
     public void testInMemIndex()
     {
         Graph graph = createTestGraph();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMinResolutionInMeter(50000).prepareAlgo();
+        LocationIndexTree index = createIndexNoPrepare(graph, 50000);
+        index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(4, 4), index.getEntries());
 
@@ -144,8 +148,8 @@ public void testInMemIndex()
     public void testInMemIndex2()
     {
         Graph graph = createTestGraph2();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMinResolutionInMeter(500).prepareAlgo();
+        LocationIndexTree index = createIndexNoPrepare(graph, 500);
+        index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(4, 4), index.getEntries());
         assertEquals(3, inMemIndex.getEntriesOf(0).size());
@@ -181,9 +185,8 @@ public void testInMemIndex2()
     @Test
     public void testInMemIndex3()
     {
-        Graph graph = createTestGraph();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMinResolutionInMeter(10000).prepareAlgo();
+        LocationIndexTree index = createIndexNoPrepare(createTestGraph(), 10000);
+        index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(64, 4), index.getEntries());
 
@@ -202,8 +205,7 @@ public void testInMemIndex3()
     @Test
     public void testReverseSpatialKey()
     {
-        LocationIndexTree index = new LocationIndexTree(createTestGraph(), new RAMDirectory());
-        index.setMinResolutionInMeter(200).prepareAlgo();
+        LocationIndexTree index = createIndex(createTestGraph(), 200);
         assertEquals(Helper.createTList(64, 64, 64, 4), index.getEntries());
 
         // 10111110111110101010
@@ -224,7 +226,7 @@ public void testMoreReal()
         graph.edge(1, 0, 1000, true);
         graph.edge(0, 2, 1000, true);
         graph.edge(0, 3, 1000, true).setWayGeometry(Helper.createPointList(51.21, 9.43));
-        LocationIndex index = internalCreateIndex(graph, 1000);
+        LocationIndex index = createIndex(graph, -1);
         assertEquals(2, index.findID(51.2, 9.4));
     }
 
@@ -261,7 +263,7 @@ private Graph createTestGraphWithWayGeometry()
     public void testWayGeometry()
     {
         Graph g = createTestGraphWithWayGeometry();
-        LocationIndex index = createIndex(g, 1000);
+        LocationIndex index = createIndex(g, -1);
         assertEquals(1, index.findID(0, 0));
         assertEquals(1, index.findID(0, 0.1));
         assertEquals(1, index.findID(0.1, 0.1));
@@ -289,7 +291,7 @@ public void testFindingWayGeometry()
     public void testEdgeFilter()
     {
         Graph graph = createTestGraph();
-        LocationIndexTree index = createIndex(graph, 1000);
+        LocationIndexTree index = createIndex(graph, -1);
 
         assertEquals(1, index.findClosest(-.6, -.6, EdgeFilter.ALL_EDGES).getClosestNode());
         assertEquals(2, index.findClosest(-.6, -.6, new EdgeFilter()
@@ -402,9 +404,7 @@ Graph createTestGraph2()
     public void testRMin()
     {
         Graph graph = createTestGraph();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMaxRegionSearch(1);
-        index.setMinResolutionInMeter(50000).prepareAlgo();
+        LocationIndexTree index = createIndex(graph, 50000);
 
         //query: 0.05 | -0.3
         DistanceCalc distCalc = new DistancePlaneProjection();
diff --git a/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java b/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java
index 48a9fc00ac..945b3fee3c 100644
--- a/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java
+++ b/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java
@@ -18,6 +18,7 @@
 package com.graphhopper.util;
 
 import static org.junit.Assert.assertEquals;
+
 import org.junit.Test;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
index 80d19d350a..e5257f79c7 100644
--- a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
+++ b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.util;
 
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
@@ -31,11 +32,15 @@
     @Test
     public void testOrientation()
     {
-        assertEquals(90.0, Math.toDegrees(ac.calcOrientation(0, 0, 10, 0)), 0.001);
-        assertEquals(45.0, Math.toDegrees(ac.calcOrientation(0, 0, 10, 10)), 0.001);
-        assertEquals(0.0, Math.toDegrees(ac.calcOrientation(0, 0, 0, 10)), 0.001);
-        assertEquals(-45.0, Math.toDegrees(ac.calcOrientation(0, 0, -10, 10)), 0.001);
-        assertEquals(-135.0, Math.toDegrees(ac.calcOrientation(0, 0, -10, -10)), 0.001);
+        assertEquals(90.0, Math.toDegrees(ac.calcOrientation(0, 0, 1, 0)), 0.01);
+        assertEquals(45.0, Math.toDegrees(ac.calcOrientation(0, 0, 1, 1)), 0.01);
+        assertEquals(0.0, Math.toDegrees(ac.calcOrientation(0, 0, 0, 1)), 0.01);
+        assertEquals(-45.0, Math.toDegrees(ac.calcOrientation(0, 0, -1, 1)), 0.01);
+        assertEquals(-135.0, Math.toDegrees(ac.calcOrientation(0, 0, -1, -1)), 0.01);
+
+        // is symetric?
+        assertEquals(90 - 32.76, Math.toDegrees(ac.calcOrientation(49.942, 11.580, 49.944, 11.582)), 0.01);
+        assertEquals(-90 - 32.76, Math.toDegrees(ac.calcOrientation(49.944, 11.582, 49.942, 11.580)), 0.01);
     }
 
     @Test
@@ -51,16 +56,19 @@ public void testAlignOrientation()
     public void testCombined()
     {
         double orientation = ac.calcOrientation(52.414918, 13.244221, 52.415333, 13.243595);
-        assertEquals(146.5, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
+        assertEquals(132.7, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
+
+        orientation = ac.calcOrientation(52.414918, 13.244221, 52.414573, 13.243627);
+        assertEquals(-136.38, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
     }
 
     @Test
     public void testCalcAzimuth()
     {
-        assertEquals(45.0, ac.calcAzimuth(0, 0, 10, 10), 0.001);
-        assertEquals(90.0, ac.calcAzimuth(0, 0, 0, 10), 0.001);
-        assertEquals(180.0, ac.calcAzimuth(0, 0, -10, 0), 0.001);
-        assertEquals(270.0, ac.calcAzimuth(0, 0, 0, -10), 0.001);
+        assertEquals(45.0, ac.calcAzimuth(0, 0, 1, 1), 0.001);
+        assertEquals(90.0, ac.calcAzimuth(0, 0, 0, 1), 0.001);
+        assertEquals(180.0, ac.calcAzimuth(0, 0, -1, 0), 0.001);
+        assertEquals(270.0, ac.calcAzimuth(0, 0, 0, -1), 0.001);
         assertEquals(0.0, ac.calcAzimuth(49.942, 11.580, 49.944, 11.580), 0.001);
     }
 
@@ -69,7 +77,7 @@ public void testAzimuthCompassPoint()
     {
         assertEquals("S", ac.azimuth2compassPoint(199));
     }
-    
+
     @Test
     public void testAtan2()
     {
@@ -84,4 +92,30 @@ public void testAtan2()
         assertEquals(90, Math.atan2(1, 0) * 180 / Math.PI, 1e-2);
         assertEquals(90, AngleCalc.atan2(1, 0) * 180 / Math.PI, 1e-2);
     }
+    
+    @Test
+    public void testConvertAzimuth2xaxisAngle()
+    {
+        assertEquals(Math.PI/2, ac.convertAzimuth2xaxisAngle(0), 1E-6);
+        assertEquals(Math.PI/2, Math.abs(ac.convertAzimuth2xaxisAngle(360)), 1E-6);
+        assertEquals(0, ac.convertAzimuth2xaxisAngle(90), 1E-6);
+        assertEquals(-Math.PI/2, ac.convertAzimuth2xaxisAngle(180), 1E-6);
+        assertEquals(Math.PI, Math.abs(ac.convertAzimuth2xaxisAngle(270)), 1E-6);
+        assertEquals(-3*Math.PI/4, ac.convertAzimuth2xaxisAngle(225), 1E-6);
+        assertEquals(3*Math.PI/4, ac.convertAzimuth2xaxisAngle(315), 1E-6);
+    }
+    
+    @Test
+    public void checkAzimuthConsitency()
+    {
+        double azimuthDegree =  ac.calcAzimuth(0, 0, 1, 1);
+        double radianXY = ac.calcOrientation(0, 0, 1, 1);
+        double radian2 = ac.convertAzimuth2xaxisAngle(azimuthDegree);
+        assertEquals(radianXY, radian2, 1E-3);
+
+        azimuthDegree =  ac.calcAzimuth(0, 4, 1, 3);
+        radianXY = ac.calcOrientation(0, 4, 1, 3);
+        radian2 = ac.convertAzimuth2xaxisAngle(azimuthDegree);
+        assertEquals(radianXY, radian2, 1E-3);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/BitUtilBigTest.java b/core/src/test/java/com/graphhopper/util/BitUtilBigTest.java
index be026ba6e6..893a59a548 100644
--- a/core/src/test/java/com/graphhopper/util/BitUtilBigTest.java
+++ b/core/src/test/java/com/graphhopper/util/BitUtilBigTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class BitUtilBigTest extends AbstractBitUtilTester
diff --git a/core/src/test/java/com/graphhopper/util/BitUtilLittleTest.java b/core/src/test/java/com/graphhopper/util/BitUtilLittleTest.java
index cf314ac516..d4e2d51ecf 100644
--- a/core/src/test/java/com/graphhopper/util/BitUtilLittleTest.java
+++ b/core/src/test/java/com/graphhopper/util/BitUtilLittleTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class BitUtilLittleTest extends AbstractBitUtilTester
diff --git a/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java b/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
index 80d48d7f28..bf5ae074d0 100644
--- a/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
+++ b/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
@@ -25,10 +25,10 @@
 import gnu.trove.set.hash.TIntHashSet;
 import org.junit.Before;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class BreadthFirstSearchTest
@@ -79,7 +79,7 @@ public boolean goFurther( int v )
         assertEquals(g.getNodes(), counter);
         assertEquals("{0, 5, 3, 2, 1, 10, 8, 7, 6, 9, 4}", list.toString());
     }
-    
+
     @Test
     public void testBFS2()
     {
@@ -110,5 +110,5 @@ public boolean goFurther( int v )
         assertEquals("{1, 5, 2, 6, 3, 4}", list.toString());
     }
 
-    
+
 }
diff --git a/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java b/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
index 9aa311807b..fce6e2d53f 100644
--- a/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
+++ b/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
@@ -25,14 +25,15 @@
 import gnu.trove.set.hash.TIntHashSet;
 import org.junit.Before;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author jan
  */
-public class DepthFirstSearchTest {
-    
+public class DepthFirstSearchTest
+{
+
     int counter;
     TIntHashSet set = new TIntHashSet();
     TIntList list = new TIntArrayList();
@@ -42,7 +43,7 @@ public void setup()
     {
         counter = 0;
     }
-    
+
     @Test
     public void testDFS1()
     {
@@ -58,13 +59,13 @@ public boolean goFurther( int v )
                 return super.goFurther(v);
             }
         };
-        
+
         EncodingManager em = new EncodingManager("CAR");
         FlagEncoder fe = em.getEncoder("CAR");
         Graph g = new GraphBuilder(em).create();
         g.edge(1, 2, 1, false);
         g.edge(1, 5, 1, false);
-        g.edge(1, 4, 1, false);       
+        g.edge(1, 4, 1, false);
         g.edge(2, 3, 1, false);
         g.edge(3, 4, 1, false);
         g.edge(5, 6, 1, false);
@@ -75,7 +76,7 @@ public boolean goFurther( int v )
         assertTrue(counter > 0);
         assertEquals("{1, 2, 3, 4, 5, 6}", list.toString());
     }
-    
+
     @Test
     public void testDFS2()
     {
@@ -91,7 +92,7 @@ public boolean goFurther( int v )
                 return super.goFurther(v);
             }
         };
-        
+
         EncodingManager em = new EncodingManager("CAR");
         FlagEncoder fe = em.getEncoder("CAR");
         Graph g = new GraphBuilder(em).create();
@@ -106,5 +107,5 @@ public boolean goFurther( int v )
         assertTrue(counter > 0);
         assertEquals("{1, 2, 3, 4}", list.toString());
     }
-    
+
 }
diff --git a/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java b/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
index 3f12d3d8e3..8d1d9c4985 100644
--- a/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
+++ b/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
@@ -18,11 +18,12 @@
 package com.graphhopper.util;
 
 import com.graphhopper.util.shapes.GHPoint;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public class DistanceCalcEarthTest
@@ -35,18 +36,6 @@ public void testCalcCircumference()
         assertEquals(DistanceCalcEarth.C, dc.calcCircumference(0), 1e-7);
     }
 
-    @Test
-    public void testGeohashMaxDist()
-    {
-        DistanceCalcEarth dce = new DistanceCalcEarth();
-        assertEquals(DistanceCalcEarth.C / 2, dce.calcSpatialKeyMaxDist(0), 1);
-        assertEquals(DistanceCalcEarth.C / 2, dce.calcSpatialKeyMaxDist(1), 1);
-        assertEquals(DistanceCalcEarth.C / 4, dce.calcSpatialKeyMaxDist(2), 1);
-        assertEquals(DistanceCalcEarth.C / 4, dce.calcSpatialKeyMaxDist(3), 1);
-        assertEquals(DistanceCalcEarth.C / 8, dce.calcSpatialKeyMaxDist(4), 1);
-        assertEquals(DistanceCalcEarth.C / 8, dce.calcSpatialKeyMaxDist(5), 1);
-    }
-
     @Test
     public void testDistance()
     {
@@ -130,6 +119,9 @@ public void testValidEdgeDistance()
         assertFalse(dc.validEdgeDistance(49.944482, 11.555446, 49.937964, 11.541824, 49.942272, 11.555643));
         // right bottom of the edge
         assertFalse(dc.validEdgeDistance(49.94085, 11.557356, 49.937964, 11.541824, 49.942272, 11.555643));
+
+        // rounding error
+        // assertFalse(dc.validEdgeDistance(0.001, 0.001, 0.001, 0.002, 0.00099987, 0.00099987));
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java b/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java
index c13e850f06..f8d7bd9a2a 100644
--- a/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java
+++ b/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class DouglasPeuckerTest
@@ -69,6 +69,7 @@ public void testSimplifyCheckPointCount()
         assertEquals(20, pointList.getSize());
         assertFalse(pointList.toString(), pointList.toString().contains("NaN"));
     }
+
     String points2 = "[[9.961074440801317,50.203764443183644],[9.96106605889796,50.20365789987872],[9.960999562464645,50.20318963087774],[9.96094144793469,50.202952888673984],[9.96223002587773,50.20267889356641],[9.962200968612752,50.20262022024289],"
             + "[9.961859918278305,50.201853928011374],[9.961668810881722,50.20138565901039],[9.96216874485095,50.20128507617008],[9.961953795595925,50.20088553877664],[9.961899033827313,50.200686794534775],[9.961716680863127,50.20014066696481],[9.961588158344957,50.199798499043254]]";
 
@@ -82,7 +83,7 @@ public void testSimplifyCheckPointOrder()
         assertEquals(11, pointList.getSize());
         assertFalse(pointList.toString(), pointList.toString().contains("NaN"));
         assertEquals("(50.203764443183644,9.961074440801317), (50.20318963087774,9.960999562464645), (50.202952888673984,9.96094144793469), (50.20267889356641,9.96223002587773), (50.201853928011374,9.961859918278305), "
-                + "(50.20138565901039,9.961668810881722), (50.20128507617008,9.96216874485095), (50.20088553877664,9.961953795595925), (50.200686794534775,9.961899033827313), (50.20014066696481,9.961716680863127), (50.199798499043254,9.961588158344957)",
+                        + "(50.20138565901039,9.961668810881722), (50.20128507617008,9.96216874485095), (50.20088553877664,9.961953795595925), (50.200686794534775,9.961899033827313), (50.20014066696481,9.961716680863127), (50.199798499043254,9.961588158344957)",
                 pointList.toString());
     }
 }
diff --git a/core/src/test/java/com/graphhopper/util/EdgeSkipIteratorTest.java b/core/src/test/java/com/graphhopper/util/EdgeSkipIteratorTest.java
index a9cd7acf44..2f5f731492 100644
--- a/core/src/test/java/com/graphhopper/util/EdgeSkipIteratorTest.java
+++ b/core/src/test/java/com/graphhopper/util/EdgeSkipIteratorTest.java
@@ -23,11 +23,12 @@
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.LevelGraph;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public class EdgeSkipIteratorTest
diff --git a/core/src/test/java/com/graphhopper/util/EdgeWrapperTest.java b/core/src/test/java/com/graphhopper/util/EdgeWrapperTest.java
index 0bf9821c66..3a1f77790e 100644
--- a/core/src/test/java/com/graphhopper/util/EdgeWrapperTest.java
+++ b/core/src/test/java/com/graphhopper/util/EdgeWrapperTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class EdgeWrapperTest
diff --git a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
index 026f4866c0..6a0def1aef 100644
--- a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
+++ b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
@@ -22,11 +22,12 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.storage.NodeAccess;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHUtilityTest
@@ -111,7 +112,7 @@ public void testCopyWithSelfRef()
         LevelGraph lg = new GraphBuilder(encodingManager).levelGraphCreate();
         GHUtility.copyTo(g, lg);
 
-        assertEquals(g.getAllEdges().getMaxId(), lg.getAllEdges().getMaxId());
+        assertEquals(g.getAllEdges().getCount(), lg.getAllEdges().getCount());
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/util/HelperTest.java b/core/src/test/java/com/graphhopper/util/HelperTest.java
index 26c942a3db..84ff8d2cae 100644
--- a/core/src/test/java/com/graphhopper/util/HelperTest.java
+++ b/core/src/test/java/com/graphhopper/util/HelperTest.java
@@ -19,13 +19,15 @@
 
 import java.io.File;
 import java.util.Locale;
+
 import org.junit.After;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 
 /**
- *
  * @author Peter Karich
  */
 public class HelperTest
@@ -69,6 +71,7 @@ public void testGetLocale() throws Exception
         assertEquals(Locale.GERMANY, Helper.getLocale("de-DE"));
         assertEquals(Locale.ENGLISH, Helper.getLocale("en"));
         assertEquals(Locale.US, Helper.getLocale("en_US"));
+        assertEquals(Locale.US, Helper.getLocale("en_US.UTF-8"));
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index cbb923f8d3..1b163e036b 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -25,30 +25,27 @@
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.routing.Dijkstra;
 import com.graphhopper.routing.Path;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.ShortestWeighting;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.NodeAccess;
-import java.io.StringReader;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
+
+import java.io.*;
 import java.util.*;
 import javax.xml.XMLConstants;
-import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.transform.Source;
-import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.stream.StreamSource;
 import javax.xml.validation.Schema;
 import javax.xml.validation.SchemaFactory;
 import javax.xml.validation.Validator;
+
+import org.json.JSONObject;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
-import org.xml.sax.InputSource;
+
+import org.junit.Before;
 import org.xml.sax.SAXException;
 
 /**
- *
  * @author Peter Karich
  */
 public class InstructionListTest
@@ -56,12 +53,20 @@
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation usTR = trMap.getWithFallBack(Locale.US);
     private final TraversalMode tMode = TraversalMode.NODE_BASED;
+    private EncodingManager carManager;
+    private FlagEncoder carEncoder;
+
+    @Before
+    public void setUp()
+    {
+        carEncoder = new CarFlagEncoder();
+        carManager = new EncodingManager(carEncoder);
+    }
 
     @SuppressWarnings("unchecked")
     @Test
     public void testWayList()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         // 0-1-2
         // | | |
@@ -107,27 +112,20 @@ public void testWayList()
         iter2.setName("8-9");
         iter2.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(0, 10);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 10);
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 0-1", "Turn right onto 1-4", "Continue onto 4-7",
-                "Turn left onto 7-8", "Continue onto 8-9", "Turn right", "Finish!"),
+                        "Turn left onto 7-8", "Continue onto 8-9", "Turn right", "Finish!"),
                 tmpList);
 
-        List<String> distStrings = wayList.createDistances(true);
-        assertEquals(Arrays.asList("6.21 mi", "6.21 mi", "6.21 mi", "6.21 mi", "12.43 mi", "6.21 mi", "0 ft"),
-                distStrings);
-
         wayList = p.calcInstructions(trMap.getWithFallBack(Locale.GERMAN));
         tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Geradeaus auf 0-1", "Rechts abbiegen auf 1-4", "Geradeaus auf 4-7",
-                "Links abbiegen auf 7-8", "Geradeaus auf 8-9", "Rechts abbiegen", "Ziel erreicht!"),
+                        "Links abbiegen auf 7-8", "Geradeaus auf 8-9", "Rechts abbiegen", "Ziel erreicht!"),
                 tmpList);
 
         assertEquals(70000.0, sumDistances(wayList), 1e-1);
-        distStrings = wayList.createDistances(false);
-        assertEquals(Arrays.asList("10.0 km", "10.0 km", "10.0 km", "10.0 km", "20.0 km", "10.0 km", "0 m"),
-                distStrings);
 
         List<GPXEntry> gpxes = wayList.createGPXList();
         assertEquals(10, gpxes.size());
@@ -141,10 +139,9 @@ public void testWayList()
         assertEquals(1.16, gpxes.get(5).getLon(), 1e-6);
 
         compare(Arrays.asList(asL(1.2d, 1.0d), asL(1.2d, 1.1), asL(1.1d, 1.1), asL(1.0, 1.1),
-                asL(1.0, 1.2), asL(1.1, 1.3), asL(1.1, 1.4)),
+                        asL(1.0, 1.2), asL(1.1, 1.3), asL(1.1, 1.4)),
                 wayList.createStartPoints());
 
-        FlagEncoder carEncoder = carManager.getSingle();
         p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(6, 2);
         assertEquals(42000, p.getDistance(), 1e-2);
         assertEquals(Helper.createTList(6, 7, 8, 5, 2), p.calcNodes());
@@ -154,10 +151,14 @@ public void testWayList()
         assertEquals(Arrays.asList("Continue onto 6-7", "Continue onto 7-8", "Turn left onto 5-8", "Continue onto 5-2", "Finish!"),
                 tmpList);
 
-        // assertEquals(Arrays.asList(0, 1, 4, 5, 6), wayList.createPointIndices());
-        // tmpList = createList(p.calcPoints(), wayList.createPointIndices());
         compare(Arrays.asList(asL(1d, 1d), asL(1d, 1.1), asL(1d, 1.2), asL(1.1, 1.2), asL(1.2, 1.2)),
                 wayList.createStartPoints());
+
+        // special case of identical start and end
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 0);
+        wayList = p.calcInstructions(usTR);
+        assertEquals(1, wayList.size());
+        assertEquals("Finish!", wayList.get(0).getTurnDescription(usTR));
     }
 
     List<String> pick( String key, List<Map<String, Object>> instructionJson )
@@ -215,7 +216,6 @@ void compare( List<List<Double>> expected, List<List<Double>> was )
     @Test
     public void testWayList2()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   2
         //    \.  5
@@ -237,14 +237,14 @@ public void testWayList2()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(2, 3);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(2, 3);
 
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 2-4", "Turn slight right onto 3-4", "Finish!"),
                 tmpList);
 
-        p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(3, 5);
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(3, 5);
         wayList = p.calcInstructions(usTR);
         tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 3-4", "Continue onto 4-5", "Finish!"),
@@ -255,7 +255,6 @@ public void testWayList2()
     @Test
     public void testNoInstructionIfSameStreet()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   2
         //    \.  5
@@ -277,7 +276,7 @@ public void testNoInstructionIfSameStreet()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(2, 3);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(2, 3);
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto street", "Finish!"), tmpList);
@@ -286,7 +285,6 @@ public void testNoInstructionIfSameStreet()
     @Test
     public void testInstructionsWithTimeAndPlace()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   4-5
         //   |
@@ -305,7 +303,7 @@ public void testInstructionsWithTimeAndPlace()
         g.edge(3, 4, 9000, true).setName("3-4").setFlags(flagsForSpeed(carManager, 90));
         g.edge(4, 5, 10000, true).setName("4-5").setFlags(flagsForSpeed(carManager, 100));
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(1, 5);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(1, 5);
         InstructionList wayList = p.calcInstructions(usTR);
         assertEquals(5, wayList.size());
 
@@ -313,8 +311,8 @@ public void testInstructionsWithTimeAndPlace()
         assertEquals(34000, p.getDistance(), 1e-1);
         assertEquals(34000, sumDistances(wayList), 1e-1);
         assertEquals(5, gpxList.size());
-        assertEquals(1604120, p.getMillis());
-        assertEquals(1604120, gpxList.get(gpxList.size() - 1).getMillis());
+        assertEquals(1604120, p.getTime());
+        assertEquals(1604120, gpxList.get(gpxList.size() - 1).getTime());
 
         assertEquals(Instruction.CONTINUE_ON_STREET, wayList.get(0).getSign());
         assertEquals(15, wayList.get(0).getFirstLat(), 1e-3);
@@ -332,20 +330,72 @@ public void testInstructionsWithTimeAndPlace()
         assertEquals(15.2, wayList.get(3).getFirstLat(), 1e-3);
         assertEquals(9.9, wayList.get(3).getFirstLon(), 1e-3);
 
-        String gpxStr = wayList.createGPX("test", 0, "GMT+1");
+        String gpxStr = wayList.createGPX("test", 0);
         verifyGPX(gpxStr);
 
-        assertTrue(gpxStr, gpxStr.contains("<trkpt lat=\"15.0\" lon=\"10.0\"><time>1970-01-01T01:00:00+01:00</time>"));
+        assertTrue(gpxStr, gpxStr.contains("<trkpt lat=\"15.0\" lon=\"10.0\"><time>1970-01-01T00:00:00Z</time>"));
         assertTrue(gpxStr, gpxStr.contains("<extensions>") && gpxStr.contains("</extensions>"));
         assertTrue(gpxStr, gpxStr.contains("<rtept lat=\"15.1\" lon=\"10.0\">"));
-        assertTrue(gpxStr, gpxStr.contains("<distance>8000.0</distance>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:distance>8000.0</gh:distance>"));
         assertTrue(gpxStr, gpxStr.contains("<desc>turn left onto 2-3</desc>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:sign>-2</gh:sign>"));
+
+        assertTrue(gpxStr, gpxStr.contains("<gh:direction>N</gh:direction>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:azimuth>0.0</gh:azimuth>"));
 
-        assertTrue(gpxStr, gpxStr.contains("<direction>N</direction>"));
-        assertTrue(gpxStr, gpxStr.contains("<azimuth>0</azimuth>"));
         assertFalse(gpxStr, gpxStr.contains("NaN"));
     }
 
+    @Test
+    public void testRoundaboutJsonIntegrity()
+    {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135, 13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                new InstructionAnnotation(0, ""), pl)
+                .setDirOfRotation(-0.1)
+                .setRadian(-Math.PI + 1)
+                .setExitNumber(2)
+                .setExited();
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);
+        // assert that all information is present in map for JSON
+        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
+        assertEquals(-1, (Double) json.get("turn_angle"), 0.01);
+        assertEquals("2", json.get("exit_number").toString());
+        // assert that a valid JSON object can be written
+        assertNotNull(new JSONObject(json).toString());
+    }
+
+    // Roundabout with unknown dir of rotation
+    @Test
+    public void testRoundaboutJsonNaN()
+    {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135, 13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                new InstructionAnnotation(0, ""), pl)
+                .setRadian(-Math.PI + 1)
+                .setExitNumber(2)
+                .setExited();
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);
+        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
+        assertNull(json.get("turn_angle"));
+        // assert that a valid JSON object can be written
+        assertNotNull(new JSONObject(json).toString());
+    }
+
     @Test
     public void testCreateGPXWithEle()
     {
@@ -360,7 +410,7 @@ public void testCreateGPXWithEle()
                 return fakeList;
             }
         };
-        String gpxStr = il.createGPX("test", 0, "GMT");
+        String gpxStr = il.createGPX("test", 0);
         verifyGPX(gpxStr);
         assertFalse(gpxStr, gpxStr.contains("NaN"));
         assertFalse(gpxStr, gpxStr.contains("<ele>"));
@@ -368,7 +418,7 @@ public void testCreateGPXWithEle()
         fakeList.clear();
         fakeList.add(new GPXEntry(12, 13, 11, 0));
         fakeList.add(new GPXEntry(12.5, 13, 10, 1000));
-        gpxStr = il.createGPX("test", 0, "GMT", true);
+        gpxStr = il.createGPX("test", 0, true);
 
         assertTrue(gpxStr, gpxStr.contains("<ele>11.0</ele>"));
         assertFalse(gpxStr, gpxStr.contains("NaN"));
@@ -396,11 +446,11 @@ public void testCreateGPX()
         List<GPXEntry> result = instructions.createGPXList();
         assertEquals(5, result.size());
 
-        assertEquals(0, result.get(0).getMillis());
-        assertEquals(10391, result.get(1).getMillis());
-        assertEquals(15000, result.get(2).getMillis());
-        assertEquals(19000, result.get(3).getMillis());
-        assertEquals(22000, result.get(4).getMillis());
+        assertEquals(0, result.get(0).getTime());
+        assertEquals(10391, result.get(1).getTime());
+        assertEquals(15000, result.get(2).getTime());
+        assertEquals(19000, result.get(3).getTime());
+        assertEquals(22000, result.get(4).getTime());
 
         verifyGPX(instructions.createGPX());
     }
@@ -416,25 +466,26 @@ private long flagsForSpeed( EncodingManager encodingManager, int speedKmPerHour
     @Test
     public void testEmptyList()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(0, 1);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 1);
         InstructionList il = p.calcInstructions(usTR);
         assertEquals(0, il.size());
         assertEquals(0, il.createStartPoints().size());
     }
 
     public void verifyGPX( String gpx )
-    {        
+    {
         SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
         Schema schema = null;
         try
         {
             Source schemaFile = new StreamSource(getClass().getResourceAsStream("gpx-schema.xsd"));
             schema = schemaFactory.newSchema(schemaFile);
+
+            // using more schemas: http://stackoverflow.com/q/1094893/194609
         } catch (SAXException e1)
         {
-            throw new IllegalStateException("There was a problem with the schema supplied for validation.");
+            throw new IllegalStateException("There was a problem with the schema supplied for validation. Message:" + e1.getMessage());
         }
         Validator validator = schema.newValidator();
         try
@@ -445,4 +496,45 @@ public void verifyGPX( String gpx )
             throw new RuntimeException(e);
         }
     }
+    
+    @Test
+    public void testFind()
+    {
+        Graph g = new GraphBuilder(carManager).create();
+        //   n-4-5   (n: pillar node)
+        //   |
+        //   3-2
+        //     |
+        //     1
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(1, 15.0, 10);
+        na.setNode(2, 15.1, 10);
+        na.setNode(3, 15.1, 9.9);
+        PointList waypoint = new PointList();
+        waypoint.add(15.2, 9.9);
+        na.setNode(4, 15.2, 10);
+        na.setNode(5, 15.2, 10.1);
+
+        g.edge(1, 2, 10000, true).setName("1-2");
+        g.edge(2, 3, 10000, true).setName("2-3");
+        g.edge(3, 4, 10000, true).setName("3-4").setWayGeometry(waypoint);
+        g.edge(4, 5, 10000, true).setName("4-5");
+
+
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(1, 5);
+        InstructionList wayList = p.calcInstructions(usTR);
+        
+        // query on first edge, get instruction for second edge
+        assertEquals("2-3", wayList.find(15.05, 10, 1000).getName());
+        
+        // query east of first edge, get instruction for second edge
+        assertEquals("2-3", wayList.find(15.05, 10.001, 1000).getName());
+
+        // query south-west of node 3, get instruction for third edge
+        assertEquals("3-4", wayList.find(15.099, 9.9, 1000).getName());
+
+        // query north-west of pillar node n , get instruction for fourth edge
+        assertEquals("4-5", wayList.find(15.21, 9.85, 100000).getName());
+
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/InstructionTest.java b/core/src/test/java/com/graphhopper/util/InstructionTest.java
index 0e7e4c52ef..522a3f0a96 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionTest.java
@@ -18,54 +18,57 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Johannes Pelzer
  */
 public class InstructionTest
 {
     @Test
-    public void testGetAzimuthAndGetDirection()
+    public void testCalcAzimuthAndGetDirection()
     {
         InstructionAnnotation ea = InstructionAnnotation.EMPTY;
         PointList pl = new PointList();
         pl.add(49.942, 11.584);
-        pl.add(49.942, 11.582);
-        Instruction i1 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl).setDistance(240).setTime(15000);
 
-        assertEquals("270", i1.getAzimuth(null));
-        assertEquals("W", i1.getDirection(null));
+        PointList nextPl = new PointList();
+        nextPl.add(49.942, 11.582);
+        Instruction currI = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl);
+        Instruction nextI = new Instruction(Instruction.CONTINUE_ON_STREET, "next", ea, nextPl);
+
+        assertEquals(270, currI.calcAzimuth(nextI), .1);
+        assertEquals("W", currI.calcDirection(nextI));
 
         PointList p2 = new PointList();
         p2.add(49.942, 11.580);
         p2.add(49.944, 11.582);
-        Instruction i2 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p2).setDistance(240).setTime(15000);
+        Instruction i2 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p2);
 
-        assertEquals("45", i2.getAzimuth(null));
-        assertEquals("NE", i2.getDirection(null));
+        assertEquals(32.76, i2.calcAzimuth(null), .1);
+        assertEquals("NE", i2.calcDirection(null));
 
         PointList p3 = new PointList();
         p3.add(49.942, 11.580);
         p3.add(49.944, 11.580);
-        Instruction i3 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p3).setDistance(240).setTime(15000);
+        Instruction i3 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p3);
 
-        assertEquals("0", i3.getAzimuth(null));
-        assertEquals("N", i3.getDirection(null));
+        assertEquals(0, i3.calcAzimuth(null), .1);
+        assertEquals("N", i3.calcDirection(null));
 
         PointList p4 = new PointList();
         p4.add(49.940, 11.580);
         p4.add(49.920, 11.586);
-        Instruction i4 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p4).setDistance(240).setTime(15000);
+        Instruction i4 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p4);
 
-        assertEquals("S", i4.getDirection(null));
+        assertEquals("S", i4.calcDirection(null));
 
         PointList p5 = new PointList();
         p5.add(49.940, 11.580);
-        Instruction i5 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p5).setDistance(240).setTime(15000);
+        Instruction i5 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p5);
 
-        assertEquals("", i5.getAzimuth(null));
-        assertEquals("", i5.getDirection(null));
+        assertTrue(Double.isNaN(i5.calcAzimuth(null)));
+        assertEquals("", i5.calcDirection(null));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/util/PMapTest.java b/core/src/test/java/com/graphhopper/util/PMapTest.java
new file mode 100644
index 0000000000..b9ae820355
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/util/PMapTest.java
@@ -0,0 +1,66 @@
+package com.graphhopper.util;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class PMapTest
+{
+
+    @Test
+    public void singleStringPropertyCanBeRetrieved()
+    {
+        PMap subject = new PMap("foo=bar");
+
+        Assert.assertEquals("bar", subject.get("foo"));
+    }
+
+    @Test
+    public void propertyFromStringWithMultiplePropertiesCanBeRetrieved()
+    {
+        PMap subject = new PMap("foo=valueA|bar=valueB");
+
+        Assert.assertEquals("valueA", subject.get("foo", ""));
+        Assert.assertEquals("valueB", subject.get("bar", ""));
+    }
+
+    @Test
+    public void keyCanHaveAnyCasing()
+    {
+        PMap subject = new PMap("foo=valueA|bar=valueB");
+
+        assertEquals("valueA", subject.get("foo", ""));
+        assertEquals("valueA", subject.get("FOO", ""));
+        assertEquals("valueA", subject.get("Foo", ""));
+    }
+
+    @Test
+    public void numericPropertyCanBeRetrievedAsLong()
+    {
+        PMap subject = new PMap("foo=1234|bar=5678");
+
+        assertEquals(1234L, subject.getLong("foo", 0));
+    }
+
+    @Test
+    public void numericPropertyCanBeRetrievedAsDouble()
+    {
+        PMap subject = new PMap("foo=123.45|bar=56.78");
+
+        assertEquals(123.45, subject.getDouble("foo", 0), 1e-4);
+    }
+
+    @Test
+    public void hasReturnsCorrectResult()
+    {
+        PMap subject = new PMap("foo=123.45|bar=56.78");
+
+        assertTrue(subject.has("foo"));
+        assertTrue(subject.has("bar"));
+        assertFalse(subject.has("baz"));
+    }
+
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/util/PointListTest.java b/core/src/test/java/com/graphhopper/util/PointListTest.java
index f5314e557f..7bd901b9f0 100644
--- a/core/src/test/java/com/graphhopper/util/PointListTest.java
+++ b/core/src/test/java/com/graphhopper/util/PointListTest.java
@@ -18,7 +18,9 @@
  */
 package com.graphhopper.util;
 
+import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
@@ -87,4 +89,19 @@ public void testAddPL()
             assertEquals(toAdd.getLatitude(i), instance.getLatitude(7 + i), 1e-1);
         }
     }
+
+    @Test
+    public void testIterable()
+    {
+        PointList toAdd = new PointList();
+        toAdd.add(1, 1);
+        toAdd.add(2, 2);
+        toAdd.add(3, 3);
+        int counter = 0;
+        for (GHPoint point : toAdd)
+        {
+            counter++;
+            assertEquals(counter, point.getLat(), 0.1);
+        }
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/SimpleIntDequeTest.java b/core/src/test/java/com/graphhopper/util/SimpleIntDequeTest.java
index c228f76148..3bbd105f37 100644
--- a/core/src/test/java/com/graphhopper/util/SimpleIntDequeTest.java
+++ b/core/src/test/java/com/graphhopper/util/SimpleIntDequeTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class SimpleIntDequeTest
diff --git a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
index 8103d03698..0f149fe65d 100644
--- a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
+++ b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
@@ -18,11 +18,12 @@
 package com.graphhopper.util;
 
 import java.util.Locale;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class TranslationMapTest
@@ -42,6 +43,9 @@ public void testToString()
         Translation ruMap = SINGLETON.getWithFallBack(new Locale("ru"));
         assertEquals("", ruMap.tr("web.FOOT"));
 
+        Translation zhMap = SINGLETON.getWithFallBack(new Locale("vi", "VI"));
+        assertEquals("i b", zhMap.tr("web.FOOT"));
+
         trMap = SINGLETON.get("de_DE");
         assertEquals("Zu Fu", trMap.tr("web.FOOT"));
 
@@ -58,4 +62,11 @@ public void testToString()
 
         // indonesia assertEquals("in", new Locale("id").getLanguage());
     }
+
+    @Test
+    public void testToRoundaboutString()
+    {
+        Translation ptMap = SINGLETON.get("pt");
+        assertTrue(ptMap.tr("roundaboutExitOnto", "1", "somestreet").contains("somestreet"));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java b/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
index 95b0918947..e1e894dda6 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalcEarth;
 import org.junit.*;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class BBoxTest
diff --git a/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java b/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java
index f6140bbe84..c210c58af1 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util.shapes;
 
 import org.junit.*;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class CircleTest
diff --git a/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java b/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
index e8847d47fd..4e2980bed7 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
@@ -19,10 +19,10 @@
 package com.graphhopper.util.shapes;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class CoordTrigTest
diff --git a/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java b/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
index aa8c97562e..3ea1f41435 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
@@ -19,10 +19,10 @@
 package com.graphhopper.util.shapes;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHPoint3DTest
diff --git a/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java b/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
index 6adac39794..eb324c71c5 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
@@ -19,10 +19,10 @@
 package com.graphhopper.util.shapes;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHPointTest
diff --git a/core/src/test/resources/com/graphhopper/reader/test-restrictions.xml b/core/src/test/resources/com/graphhopper/reader/test-restrictions.xml
index d2f47c47ea..0b27af2da6 100644
--- a/core/src/test/resources/com/graphhopper/reader/test-restrictions.xml
+++ b/core/src/test/resources/com/graphhopper/reader/test-restrictions.xml
@@ -11,7 +11,7 @@
       (2,3)->(3,4): straight_only
       (4,3)->(3,8): no_right_turn
       (4,5)->(5,6): right_turn_only
-      (6,1)->(1,5): no_u_turn
+      (6,1)->(1,6): no_u_turn
     -->
     
    <!-- 
@@ -186,7 +186,7 @@
     
     <relation id="1004">
         <member type="way" ref="61" role="from"/>
-        <member type="way" ref="51" role="to"/>
+        <member type="way" ref="61" role="to"/>
         <member type="node" ref="1" role="via"/>
         <tag k="restriction" v="no_u_turn"/>
         <tag k="type" v="restriction"/>
diff --git a/core/src/test/resources/com/graphhopper/routing/test-graph.svg b/core/src/test/resources/com/graphhopper/routing/test-graph.svg
index 54ada32f02..c9c1adc45e 100644
--- a/core/src/test/resources/com/graphhopper/routing/test-graph.svg
+++ b/core/src/test/resources/com/graphhopper/routing/test-graph.svg
@@ -13,7 +13,7 @@
    height="297mm"
    id="svg2"
    version="1.1"
-   inkscape:version="0.48.3.1 r9886"
+   inkscape:version="0.48.4 r9939"
    sodipodi:docname="test-graph.svg">
   <defs
      id="defs4" />
@@ -25,15 +25,15 @@
      inkscape:pageopacity="0.0"
      inkscape:pageshadow="2"
      inkscape:zoom="0.98994949"
-     inkscape:cx="184.29981"
+     inkscape:cx="186.32012"
      inkscape:cy="855.76121"
      inkscape:document-units="px"
      inkscape:current-layer="layer1"
      showgrid="false"
      inkscape:window-width="1600"
-     inkscape:window-height="1105"
+     inkscape:window-height="1136"
      inkscape:window-x="0"
-     inkscape:window-y="31"
+     inkscape:window-y="0"
      inkscape:window-maximized="1" />
   <metadata
      id="metadata7">
@@ -191,7 +191,7 @@
          sodipodi:role="line"
          id="tspan3008"
          x="104.04571"
-         y="51.30101">(6)</tspan></text>
+         y="51.30101">(111)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -202,7 +202,7 @@
          sodipodi:role="line"
          id="tspan3012"
          x="47.477169"
-         y="67.463455">(7)</tspan></text>
+         y="67.463455">(111)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -213,7 +213,7 @@
          sodipodi:role="line"
          id="tspan3016"
          x="97.984795"
-         y="81.605591">(2)</tspan></text>
+         y="81.605591">(89)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -224,7 +224,7 @@
          sodipodi:role="line"
          id="tspan3020"
          x="119.19799"
-         y="111.91016">(8)</tspan></text>
+         y="111.91016">(89)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -235,18 +235,18 @@
          sodipodi:role="line"
          id="tspan3024"
          x="86.873123"
-         y="153.32642">(2)</tspan></text>
+         y="153.32642">(89)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
-       x="156.57364"
-       y="160.39749"
+       x="147.48227"
+       y="157.36703"
        id="text3026"
        sodipodi:linespacing="125%"><tspan
          sodipodi:role="line"
          id="tspan3028"
-         x="156.57364"
-         y="160.39749">(5)</tspan></text>
+         x="147.48227"
+         y="157.36703">(22)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -257,7 +257,7 @@
          sodipodi:role="line"
          id="tspan3032"
          x="215.16249"
-         y="180.60054">(2)</tspan></text>
+         y="180.60054">(57)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -268,7 +268,7 @@
          sodipodi:role="line"
          id="tspan3036"
          x="228.29448"
-         y="136.15382">(2)</tspan></text>
+         y="136.15382">(70)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -279,7 +279,7 @@
          sodipodi:role="line"
          id="tspan3040"
          x="309.10669"
-         y="137.16399">(10)</tspan></text>
+         y="137.16399">(70)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -290,40 +290,40 @@
          sodipodi:role="line"
          id="tspan3044"
          x="268.70059"
-         y="105.84925">(1)</tspan></text>
+         y="105.84925">(79)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
-       x="209.10158"
-       y="96.757874"
+       x="208.09143"
+       y="95.747719"
        id="text3046"
        sodipodi:linespacing="125%"><tspan
          sodipodi:role="line"
          id="tspan3048"
-         x="209.10158"
-         y="96.757874">(2)</tspan></text>
+         x="208.09143"
+         y="95.747719">(79)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
-       x="157.58379"
-       y="103.82895"
+       x="153.54318"
+       y="102.81879"
        id="text3050"
        sodipodi:linespacing="125%"><tspan
          sodipodi:role="line"
          id="tspan3052"
-         x="157.58379"
-         y="103.82895">(7)</tspan></text>
+         x="153.54318"
+         y="102.81879">(101)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
-       x="227.28432"
-       y="67.463455"
+       x="221.2234"
+       y="66.4533"
        id="text3054"
        sodipodi:linespacing="125%"><tspan
          sodipodi:role="line"
          id="tspan3056"
-         x="227.28432"
-         y="67.463455">(4)</tspan></text>
+         x="221.2234"
+         y="66.4533">(101)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -334,6 +334,6 @@
          sodipodi:role="line"
          id="tspan3060"
          x="307.08636"
-         y="75.544678">(5)</tspan></text>
+         y="75.544678">(103)</tspan></text>
   </g>
 </svg>
diff --git a/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd b/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd
index 1ede4ba6bf..58cfdeb1ba 100644
--- a/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd
+++ b/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd
@@ -2,7 +2,7 @@
 <xsd:schema
     xmlns:xsd="http://www.w3.org/2001/XMLSchema"
     xmlns="http://www.topografix.com/GPX/1/1"
-    targetNamespace="http://www.topografix.com/GPX/1/1"
+    targetNamespace="http://www.topografix.com/GPX/1/1"    
     elementFormDefault="qualified">
 
     <xsd:annotation>
@@ -478,15 +478,15 @@
                 You can add extend GPX by adding your own elements from another schema here.
             </xsd:documentation>
         </xsd:annotation>
+        <!-- as we need separate namespace 'gh' could not get it working with proper validation :( so ignoring this for now-->
         <xsd:sequence>
-            <xsd:element name="distance" type="xsd:decimal"	minOccurs="0">                
-            </xsd:element>
-            <xsd:element name="time" type="xsd:nonNegativeInteger"	minOccurs="0">
-            </xsd:element>
-            <xsd:element name="direction" type="xsd:string"		minOccurs="0">                
-            </xsd:element>
-            <xsd:element name="azimuth"	type="xsd:string"		minOccurs="0">                
-            </xsd:element>
+            <xsd:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        You can add extend GPX by adding your own elements from another schema here.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:any>
         </xsd:sequence>
     </xsd:complexType>
 
diff --git a/docs/android/android-studio-setup.md b/docs/android/android-studio-setup.md
new file mode 100644
index 0000000000..913bee91b9
--- /dev/null
+++ b/docs/android/android-studio-setup.md
@@ -0,0 +1,21 @@
+# Open Demo App with Android Studio
+
+Get the [GraphHopper sources and demo](./index.md) before you proceed.
+
+## Setup
+
+[Download](http://developer.android.com/sdk/index.html) and start android studio. 
+Now you need to import the code formatting settings (File|Import Settings). Load them from core/files/intellij-settings.jar
+
+Open existing Android studio project and then open 'graphhopper/android' not the parent 'graphhopper'
+
+![Open Existing](./images/android-studio-open-existing.png)
+
+Import project from Gradle, but make sure the 'Gradle project' points to graphhopper/android
+
+![Import project from Gradle](./images/android-studio-import-project-from-gradle.png)
+
+## Start Demo
+
+ 1. Connect your device in development mode (USB debugging)
+ 2. Then hit SHIFT+F10 or click Run->Run 'app' in the menu
diff --git a/docs/android/images/android-studio-import-project-from-gradle.png b/docs/android/images/android-studio-import-project-from-gradle.png
new file mode 100644
index 0000000000..2b4aacf171
Binary files /dev/null and b/docs/android/images/android-studio-import-project-from-gradle.png differ
diff --git a/docs/android/images/android-studio-open-existing.png b/docs/android/images/android-studio-open-existing.png
new file mode 100644
index 0000000000..9e5891ef3f
Binary files /dev/null and b/docs/android/images/android-studio-open-existing.png differ
diff --git a/docs/android/index.md b/docs/android/index.md
index ae02db1b3a..cf86b7f66a 100644
--- a/docs/android/index.md
+++ b/docs/android/index.md
@@ -1,11 +1,13 @@
-## Get Demo
+# Get Demo
 
 [Download GraphHopper Demo APK](http://graphhopper.com/#download)
 
-## Set-up Development
-As starting point you can use [the demo project](https://github.com/graphhopper/graphhopper/tree/master/android) which can be used from Eclipse or NetBeans via maven command line.
+# Set-up Development
 
-### Before installation
+As starting point you can use [the demo project](https://github.com/graphhopper/graphhopper/tree/master/android) 
+which can be used from Android Studio, NetBeans, gradle or maven.
+
+Before the installation fetch the source, the OpenStreetMap data and the dependencies:
 
 ```bash
 $ git clone git://github.com/graphhopper/graphhopper.git graphhopper
@@ -13,21 +15,29 @@ $ cd graphhopper
 $ ./graphhopper.sh import your-area.pbf
 ```
 
-And go to the Android SDK Manager and install at least 2.3 (API 9)
+## Android Studio
 
-**Either via Maven and Command line -> use this for NetBeans**
- 1. Download [Maven SDK Deployer](https://github.com/mosabua/maven-android-sdk-deployer) and execute `mvn install -P 2.3` - it uses [Android Maven Plugin](http://code.google.com/p/maven-android-plugin/wiki/GettingStarted) under the hood where you need to set up ANDROID_HOME
- 2. Now do `./graphhopper.sh android`
+Please read [here](./android-studio-setup.md) for a detailed instruction.
 
-**Or Eclipse**
+## None-Android Studio
 
-Import Sources as Android project. If you want to customize graphhopper itself do:
- 1. `cd graphhopper; ./graphhopper.sh eclipse`
- 2. Refresh your Eclipse project and use it.
+Download the [Android SDK](http://developer.android.com/sdk/installing/index.html?pkg=tools) and 
+go to the Android SDK Manager and install at least 2.3 (API 9).
+
+### Maven or NetBeans
+ 1. Download [Maven Android SDK Deployer](https://github.com/simpligility/maven-android-sdk-deployer) and execute `mvn install -P 5.1` - it uses [Android Maven Plugin](http://simpligility.github.io/android-maven-plugin/) under the hood where you need to set up ANDROID_HOME
+ 2. Now do `./graphhopper.sh android`
 
-See [this](https://lists.openstreetmap.org/pipermail/graphhopper/2013-November/000501.html) for the discussion.
+### Gradle
+
+```bash
+$ cd graphhopper/android
+$ ./gradlew clean build
+# push to device, start manually
+$ gradle installDebug
+```
 
-**Maps**
+## Maps
 
 Now that you have a running android app you need to copy somehow the routing and maps data. 
 
diff --git a/docs/core/ch.md b/docs/core/ch.md
index 32cdbda276..4d55a5c847 100644
--- a/docs/core/ch.md
+++ b/docs/core/ch.md
@@ -6,14 +6,6 @@ In GraphHopper CH is enabled by default but can be easily disabled.
 To make CH work in GraphHopper a LevelGraphStorage instead of the normal GraphStorage 
 is necessary which allows to store shortcuts too.
 
-After a graph is prepared it cannot be used for graph exploration anymore, this is
-a limitation of the preparation and storage and is handled in issue #116.
-Due to that limitation a special location index is necessary (LocationIndexTreeSC).
-
-Also at the moment only one vehicle can be used if CH is enabled, see issue #111.
-
-So, if you still need graph exploration for your LevelGraphStorage you can specify 
-graphHopper.doPrepare(false) before you call importOrLoad, which avoids the CH preparation.
-Then do your graph explorations or whatever and store the graph.
-If you call importOrLoad next time without doPrepare(false) the CH-preparation will be done.
+A prepared graph can also be used for normal graph traversal IF you use graph.getBaseGraph().
 
+If CH is enabled multiple vehicles will work but only one works in speed-up mode and is faster, see issue #111.
diff --git a/docs/core/create-new-flagencoder.md b/docs/core/create-new-flagencoder.md
index ff93ae5036..be932c422a 100644
--- a/docs/core/create-new-flagencoder.md
+++ b/docs/core/create-new-flagencoder.md
@@ -20,6 +20,7 @@ see Bike2WeightFlagEncoder for an example. You'll have to overwrite the followin
  * flagsDefault 
  * setProperties
  * reverseFlags
+ * setLowSpeed
 
 To incorporate or precalculate values based on the elevation data you can hook into applyWayTags
 and call edge.fetchWayGeometry(3) or again, see Bike2WeightFlagEncoder.
diff --git a/docs/core/eclipse-setup.md b/docs/core/eclipse-setup.md
new file mode 100644
index 0000000000..b38754cea3
--- /dev/null
+++ b/docs/core/eclipse-setup.md
@@ -0,0 +1,154 @@
+Getting started with GraphHopper in Eclipse
+=========
+This manual covers step by step instructions on setting up a development and run environment for GraphHopper (web App only) using Eclipse. The instructions and tools used are platform independent and should be applicable for windows, Linux and Mac operating systems. 
+Instructions for Android branch will be provided in future.
+
+The first part of this document covers configuring Eclipse for cloning and importing GraphHopper repository. 
+Setting up Apache Tomcat server and configuring it to run GraphHopper is covered in [Setting up Apache Tomcat Server](./eclipse-tomcat-setup.md).
+
+###1. Download Eclipse
+
+The first step is to download latest version of Eclipse. We recommend that you download the ["Eclipse IDE for Java EE Developers"](http://www.eclipse.org/downloads/) package, instead of the package "for Java developers", as it includes many of the necessary plugins for webapp and API development.  
+
+**Note:** Make sure you grab the correct 32-bit or 64-bit version, depending on your machine and the version of the java installed in your computer. If for example you have a 32 bit java in your x64 machine, you still need to download a 32 bit version of eclipse or you may get an error while trying to open the eclipse.exe file.
+
+**Note:** GraphHopper is set to run with JRE 1.6. This document is written based on setting Eclipse Luna using JRE 1.6.  It may also work with newer versions of JRE, but it has not been tested yet.
+
+
+###2.	Eclipse Addition al Plugins
+Before getting started, you'll need to have a few Eclipse plugins installed to help with development. GraphHopper is versioned using Git and its build process and dependencies are managed by Maven, so certain additional Eclipse components will be needed to tie everything together:
+
+*	A git plugin, a popular choice is [EGit](http://eclipse.org/egit/) which is an "Eclipse team provider" (i.e. version control system plugin) for Git.
+*	The Eclipse Maven plugin, [m2eclipse](http://www.eclipse.org/m2e/) which adds Maven support to Eclipse, for editing project models and (automatically) running builds
+*	If you want to work on the web interfaces you also need [Web Tools Platform (WTP)](http://www.eclipse.org/webtools/)
+
+**Note**: EGit, WTP, and m2eclipse (as of version 1.0) are hosted by the [Eclipse foundation](http://www.eclipse.org/org/), and they are bundled with some packages of Eclipse.
+
+###3.	Configuring Eclipse with additional plugins
+Depending on the Eclipse package you chose, you may need to install one or more of the Eclipse components mentioned previously. You should be able to add all the needed components using either the "Install new software" dialog or the "Eclipse marketplace" component available under Eclipse's help menu. 
+
+####3.1. Using Eclipse Marketplace
+The Eclipse Marketplace seems to do a good job with EGit, m2eclipse (also referred to as m2e or "Maven Integration for Eclipse"), and m2e-wtp ("Maven Integration for Eclipse WTP").
+
+You should take the below steps to install your needed components:
+
+* In Eclipse, under _help_ menu, choose _Eclipse Marketplace_. 
+
+* In the opened window, search all _markets/all categories_ and in the _find_ dialoge box type the name of the needed component and click on _Go_ button:
+
+ * Search for egit if you need EGIT and EGit  Git Team Provider should be among first items to appear.
+ 
+ * Search for maven or m2eclipse if you need m2eclipse and m2eclipse  "Maven Integration for Eclipse should be among first items to appear. 
+   
+ * Search for wtp if you need m2e-wtp and m2eclipse  "Maven Integration for Eclipse WTP should be among first items to appear. 
+
+*   Click on _Install_ button. Please note if the component is already installed then there are two other buttons available instead of _Install_. _Update_ if there is an update for the component and _Uninstall_. For example in picture below the user has tried to install EGit using market place, while it has already been included in the package. 
+
+![](./images/egit.png)
+
+*	The Web Tools components can in fact be installed via the Eclipse Marketplace system, but they will not be found in a search unless you switch to the "EclipseSource Yoxos Marketplace" instead of the "Eclipse marketplace". This is accomplished by clicking on the Orange circle icon next to the purple Eclipse icon at the bottom of the Marketplace dialog box. 
+
+
+####3.2. Using Install New Software Option
+Alternatively, you can use the Install New Software option under the _help_ menu to install the needed components. Also if you do happen to miss some web development components try Install New Software Option instead of the Marketplace. 
+
+Based on needed components take the below steps:
+ 
+*	To install EGit in the "Work with:" dialog box, type the EGit server address  at http://download.eclipse.org/egit/updates. Select Eclipse Git Team Provider and JGit form option and click _Next_ and _Finish_ install.
+ 
+![](./images/egit2.png)  
+
+*	To install m2e In the "Work with:" dialog box, type the me2eclipse server address at http://download.eclipse.org/technology/m2e/releases. Select Maven Integration for Eclipse form option and click _Next_ and _Finish_ install. 
+
+![](./images/maven.png) 
+
+*	Also if you do happen to miss some web development components,   in the "Work with:" dialog box, type your eclipse server version (e.g. luna) address at http://download.eclipse.org/releases/luna and try  checking the "Web, XML, Java EE, and OSGi Enterprise Development" category, which should include everything you need.  
+
+
+###4.	Clone and import the GraphHopper Source
+At this step you need to clone the GraphHopper GitHub repository locally (get a copy of the GraphHopper source code). Repository cloning can be done using one of the below approaches:
+
+1. EGit Repositories View from within Eclipse
+
+2. Command-line Git tools. Once they are cloned into the local filesystem, the Maven projects in the GraphHopper Git repository can then be imported into Eclipse. 
+
+3. The clone and import operations can be done together using _File -> Import -> Maven -> Import Maven projects from SCM in Eclipse_.
+ 
+**Note:** When the initial clone operation is not done using the clone button in the EGit Repositories View (For example if it is done using command-line Git or "Import Maven projects from SCM"), you  need to inform Eclipse that your project is under Git version control if you want to do pull / push / commit operations from within Eclipse. In any case you can just perform these operations using command-line Git tools.
+
+**Note:**  It is suggested that repositories should be cloned somewhere outside your Eclipse workspace to avoid any misinterpretation or misuse of Git metadata by Eclipse and vice-versa. 
+
+Below we talk more about the first and third approaches of cloning.
+
+
+####4.1. Approach 1: Clone the GraphHopper repository with the EGit Repositories View
+
+* Switch to the "Git Repository Exploring" perspective in Eclipse by selecting:  _Window -> Open Perspective -> Git Repositories_ .
+If you don't see this option under "Open Perspective", choose:  _Window -> Open Perspective -> Other..._ and select "Git Repository Exploring". 
+
+![](./images/clone1.png)
+
+The "Repository Exploring perspective" is preconfigured to contain the Git Repositories view. Alternatively, you can add the Git Repositories view to your main Java perspective: _Window -> Show View -> Other -> Git Repositories_. 
+
+* In the Git Repositories view, click on the "Clone a Git Repository and add clone to this view" button as shown below:
+
+![](./images/clone2.png)
+
+* Enter https://github.com/graphhopper/graphhopper/ for the URI, select "HTTPS" for the protocol. Entering the GitHub username and password is not necessary for cloning the repository. However, if you want to contribute edits back, you'll need to enter your GitHub username and password here too.
+
+![](./images/clone3.png)
+
+* Click _Next_, then select all branches (the master branch is probably what need).
+
+* Click _Next_, then select the directory where you want the code to be checked out to. Then click _Finish_. It will take Eclipse a minute or two to download the source to your computer, and then the GraphHopper repository should appear in the "Git Repositories" panel. 
+
+**Note:** An alternate and easy way to this approach is to manually download the GraphHopper zip file directly from GitHub and save it in a local drive in your machine.
+
+**Note:** You still need to import the GraphHopper Maven projects from the local clone of the repository into Eclipse (see Importing existing GraphHopper Maven projects into Eclipse part).
+
+
+
+####4.2. Importing existing GraphHopper Maven projects into Eclipse
+
+If you used approach 1 or if you have downloaded the GraphHopper zip file directly form GitHub, you have cloned the GraphHopper repository but the GraphHopper Maven projects are not yet visible in Eclipse. To make the projects visible,cover the below steps:
+
+* Choose the menu option _File -> Import, and then browse to the Maven / Existing Maven Projects element_.
+
+![](./images/import1.png)
+
+* Browse to the local directory where you cloned the GraphHopper Git repository, and then select all the projects of interest.
+
+![](./images/import2.png)
+
+* Click _Finish_. It may take a while to initially build all the projects in your workspace. In the background, the Maven plugin is downloading all the project dependencies. If everything works fine you should be able to see each GraphHopper maven module checked out as an individual Eclipse project in your workspace.
+
+####4.3. Approach 2: Clone the GraphHopper repository and import Maven projects all at once
+To use this method follow the below steps:
+* In Eclipse, choose _File -> Import..._ then choose _Maven / Check out Maven projects from SCM_ in the dialog box, as shown below:
+
+![](./images/clone4.png)
+
+* Click _Next_, then confirm that you are using the Git version control sytstem using the dropdown box next to the label "SCM URL". 
+
+**Note:** The first time you use this option, this "git" option will probably not be available because an m2e/git connector must be installed. Use the blue "m2e marketplace" link in the lower right corner of this dialog box to find and install the m2e Maven SCM handler for Egit,  and the 'git' option should become available in the drop-down box.
+
+* specify the "Target Location" (in this case, the URL of the remote Github repository that you want to clone locally), as shown in below figure. This URL should be https://github.com/graphhopper/graphhopper/
+
+![](./images/clone5.png)
+
+* Click _Next_, then uncheck "Use default workspace location" and specify a directory outside your Eclipse workspace (e.g. ~/git). Your cloned copy of the repository will be placed in a subdirectory of the specified directory, with a rather uninformative name (e.g. ~/git/ maven.1424033308371).
+
+* Click _Finish_, and m2eclipse should both clone the repository and import the Maven projects into your workspace. The Graphhopper top-level maven module, as well as all the other sub-modules, should then appear in your project explorer view. 
+
+####4.4 Making Eclipse aware of your local GraphHopper Git repository
+
+If you use approach 2 or a command-line method, EGit will not be aware of the Git metadata in the new local repository. Therefore operations on the local Git repository will not automatically be possible from within Eclipse.You can choose to do all Git operations on the command line, or make EGit aware of the repository as follows: 
+
+*	Right-click the top-level GraphHopper project in the Project Explorer view and choose _Team -> Share Project_.
+
+*	Specify Git as the repository type and check Use or create repository in parent folder of project on the next page. The .git metadata directory should be found and indicated in the dialog box. At this point you can click the _Finish_ button. An orange cylinder should appear on the GraphHopper folder icon in the "Package Explorer", indicating that it is under version control.
+
+Now, you should be able to open the Git repositories view: _Window -> Show View -> Other -> Git Repositories_, and do push, pull, and commit operations in Eclipse. The advantage of this method over the command line is using EGit's graphical diff window which allows you to review changes and select files to commit.
+
+
+
diff --git a/docs/core/eclipse-tomcat-setup.md b/docs/core/eclipse-tomcat-setup.md
new file mode 100644
index 0000000000..40365e4836
--- /dev/null
+++ b/docs/core/eclipse-tomcat-setup.md
@@ -0,0 +1,148 @@
+Setting up Apache Tomcat Server
+=========
+After ["Configuring Eclipse to get started with GraphHopper"](https://github.com/graphhopper/graphhopper/blob/master/docs/core/eclipse-setup.md), in this document we cover how to set up Apache Tomcat server and configure it to run GraphHopper.
+
+###1. Install Apache Tomcat Server
+
+To install Tomcat server, open Eclipse and choose a workspace you have already configured to work with GraphHopper. Details for configuring eclipse can be found in this ["document"](https://github.com/graphhopper/graphhopper/blob/master/docs/core/eclipse-setup.md).
+
+ At first you have to make sure that Dynamic Web Module has been checked in the project: 
+
+* On Project explorer, right click on _graphhopper-web [graphhopper master]_ and go to "Properties". 
+
+* Choose "Project Facets" and make sure that "Dynamic Web Module" has been selected. If not, select it and then apply the changes.  
+
+![](./images/2.jpg)
+
+Now you are ready to add or create a new server:
+
+* If you do not see any tab called Servers , then go to _window -> Show view_ and then choose "Servers". Please note you may need to choose "Other..." and then "Servers".
+
+* If this is the first time you are creating a server, in the Servers area you will see a link as No servers are available click this link to create a new server. Click the link.
+
+![](./images/1.jpg)
+
+* Define a New Server window will be opened, In Select the server type. Open Apache and choose an appropriate Tomcat version. For this document we chose Tomcat v8.0 Server.
+
+* Leave Servers host name as  _localhost_. You can give any name that you want to Server name. Then click Next. 
+
+![](./images/3.jpg)
+
+* In Tomcat Server page, you need to specify the installation directory for Tomcat. At first in JRE part, choose the jre you have installed in your system (e.g.  jre 1.8.0_31).
+
+* If this is the first time you are installing this version of Tomcat you have to click on Download and Install to automatically get and install Tomcat, otherwise choose the installation directory for Tomcat as shown in figure. 
+
+![](./images/5.jpg)
+
+* If this is the first time you are installing a specific version of Tomcat, then the feature license page appears for you. Review the license to decide whether to accept the terms of the agreement. After accepting the terms, choose the installation directory and click "Next".
+
+* In Add and Remove page add _graphhopper-web_ from available: column to configured:. Then click on Finish.  Please note that you should wait until the installation completes so that the current Window automatically be closed.
+
+![](./images/4.jpg)
+
+
+###2.	Basic Configurations
+After downloading and installing Tomcat, you need to change some of the default settings: 
+
+* In the "Overview" tab double click the name of the created server. Now in your dashboard you should be able to see the whole overview of the server.
+
+![](./images/18.jpg)
+
+* In Timeouts part, change _start_ and _stop times_ appropriately. Please note that when running GraphHopper for the first time, a new graph should be created and it may take some time. Therefore these times (specially the start time) should be increased to give enough time for creating the graph. Here we chose 200 for both times.
+
+![](./images/6.jpg)
+
+* In The Ports part you can choose any port you want for the server to work with. You can also leave the default settings as the below figure.
+
+![](./images/7.jpg)
+
+* On "Project explorer", right click on _graphhopper-web [graphhopper master]_ and go to Build Path -->Configure build path --> Deployment Assembly. 
+* Make sure in the Web Deployment Assembly "src/main/webapp" is added as below figure.
+
+![](./images/9.jpg)
+
+* If not added,select "Add" button.
+ * In "Select Directive Type", choose _Folder_ and click "Next".
+ * In "Folder" page, click _src_ , then choose _main_  and then select _webapp_. Click "Finish"
+ 
+![](./images/15.jpg)
+###3.	VM Arguments Configuration
+At this step you need to include specific VM arguments corresponds to _map_ and _configuration_ files so that the GraphHopper works without any problem.  
+
+* First of all make sure that you have a configuration folder with _map_ and _configuration_ files. Therefore, create a folder (at any location in your system that you want) and copy the the appropriate _map_ and _configuration_ files to this folder as described below:
+
+ * **Configuration file (config.properties)**: Is a file that contains GraphHopper's configurations. From the GraphHopper git repository, copy the file named config-example.properties into the configuration folder you created. Rename the file to config.properties ( or any name you want).
+
+ * **Map file (map.osm)**:  Any .osm file can have the map data. The name of the .osm file is defined in the config.properties and by default it is map.osm. You can keep the default name. Get an .osm file and put it in the configuration folder and name it map.osm. Please note you can get an .osm file from ["OpenStreetMap site"](http://www.openstreetmap.org/#map=14/44.5763/-123.2788).
+ 
+ * **Graph folder**: This folder is created automatically based on defining the correct VM argument and upon running GraphHopper. Graph folder is used to keep the created graph by GraphHopper.
+ 
+* Now to add VM arguments, go to Overview part and in General information, click on Open launch configuration.
+
+* In (x)= Arguments  tab,  and in VM arguments part, add the necessary arguments and their corresponding paths that are not included. You only need to add the below arguments and paths:
+ * **1.-Dgraphhopper.config="_Path to config.properties file_"**: config.properties is a file that contains GraphHopper's configurations.
+ * **2.-Dgraphhopper.graph.location="_Path to graph folder_"**: In _graph_ folder ( with any optional name) a graph would be created. Upon running GraphHopper a folder ( with the name defined in VM arguments) will be created to keep the graph. So do not worry about manually creating it in the configuration folder.
+ * **3.-Dgraphhopper.osmreader.osm="_Path to map.osm file_"**:  *.osm file contains the map data. The name of the .osm file is defined in the config.properties and by default it is map.osm. 
+
+![](./images/8.jpg)
+
+
+
+* _-Xmx1G_  is optional and is used to restrict the maximum heap size for Java virtual machine. It should be configured based on the amount of RAM dedicated to run the server. Here we chose 1G. If you have enough RAM on your system, you can increase the number. For example change _-Xmx1G_ to _Xmx4G_. Please consider that if you choose a wrong amount of RAM, you may face errors. You may also want to not add this optional argument. In this case a predefined heap size will be allocated for Java virtual machine.
+
+###4.  Configuring Web Modules
+To complete setting up the Tomcat server go through the below steps: 
+
+* Click the Modules tab to go to Web Modules .
+
+* Select graphhopper-web row. Then click Edit.
+
+* Edit the path from "_/graphhopper-web_" to "_/_". 
+
+![](./images/13.jpg)
+
+###5. Run Server
+ After going through all the previous steps, you are ready to run GraphHopper using Apache Tomcat server in Eclipse. Right click on the name of you server and choose "Start". Or simply click on the green "start" icon.
+ If you faced no error and the server started successfully, in your browser type the server address and port. In our example it is : http://localhost:8080/. 
+ Congratulations! You have GraphHopper (with basic settings) running and ready for work!
+ However it is possible that you face an error as **"NoClassDefFoundError"**. If so, please see the section "6. Configuring Classpath and Resolving Maven Dependencies Problem"
+  
+ ![](./images/17.jpg)
+ 
+
+###6. Configuring Classpath and Resolving Maven Dependencies Problem
+Depending on your Eclipse version or the _m2e_ that you use, _Maven_ may not set _Classpath_ for dependencies properly. Therefore, while running your Tomcat server you may face an error as **"NoClassDefFoundError"**. 
+If you faced such an error, at first please check the below websites for the additional plug-ins, instructions on changing pom.xml and solving the similar problem:
+
+* ["Maven not setting classpath for dependencies properly"](http://stackoverflow.com/questions/4687609/maven-not-setting-classpath-for-dependencies-properly)
+
+* ["How to configure Eclipse build path to use Maven dependencies?"](http://stackoverflow.com/questions/2037188/how-to-configure-eclipse-build-path-to-use-maven-dependencies)
+
+However your problem may still not be solved. We could not find any accurate solution for this problem but here is a workaround: 
+
+* In Configure build path--> Java Build Path, click on Libraries tab and choose Maven Dependencies. Take a look at all .jar files". Be ready to find all these .jar files in your system, and to make a copy of them in a folder.
+
+![](./images/10.jpg)
+
+* You have to add all these files to Classpath as well. 
+ On Project explorer, right click on _graphhopper-web [graphhopper master]_ and go to Run As --> Run configuration then choose Classpass tab. Under User Entries , you see only a few .jar files. It should look like the below figure.
+ 
+ ![](./images/11.jpg)
+ 
+* You have to find the location of each .jar file, you saw previously in "Build Path" and add them as an External JARs to the Classpath. Since there are lots of files, we suggest that you at first manually copy (not cut!) all the .jar files into a folder so that you can use them in future as well.  
+
+* Again go to User Entries on Classpath and click on  External JARs.  In the Jar Selection Window go to the folder you already created with all the .Jar files and select all those files. Now your Classpath should look like below. 
+
+![](./images/12.jpg)
+
+* Finally you also have to add "graphhoper" Project to "Classpath". Click User Entries on Classpath and select "Add Projects...". Check "graphopper" and click "OK".
+ 
+ ![](./images/16.jpg)
+ 
+The Problem should be resolved with this workaround.
+ 
+ 
+ 
+
+
+
diff --git a/docs/core/elevation.md b/docs/core/elevation.md
new file mode 100644
index 0000000000..d973969aa5
--- /dev/null
+++ b/docs/core/elevation.md
@@ -0,0 +1,40 @@
+# Elevation
+
+Per default elevation is disabled. But you can easily enable it:
+`graph.elevation.provider=cgiar`
+or
+`graph.elevation.provider=srtm`
+
+then GraphHopper will automatically download the necessary data for the area and include elevation 
+for all vehicles - making also the distances a bit more precise. 
+
+The default cache directory (/tmp/srtm) will be used. For large areas it is highly recommended to 
+use a SSD disc, thus you need to specify the cache directory:
+`graph.elevation.cachedir=/myssd/ele_cache/`
+
+## What to download and where to store it? 
+
+All should work automatically. Another setting is to specify the location where the files are 
+downloaded - e.g. if the servers are not reachable, then you set:
+`graph.elevation.baseurl`
+
+E.g. for CGIAR there are two URLs you can use: `http://droppr.org/srtm/v4.1/6_5x5_TIFs` and
+`http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/`
+where the last one is only accessibly if you specify the 
+[full zip file](http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/srtm_01_02.zip)
+
+If the area is small and you need a faster import you can change the default MMAP setting to:
+`graph.elevation.dataaccess=RAM_STORE`
+
+## CGIAR vs. SRTM
+
+The CGIAR data is preferred because of the quality but is in general not public domain. 
+But we got a license for our and our users' usage: https://graphhopper.com/public/license/CGIAR.txt
+
+Using SRTM instead CGIAR has the minor advantage of a faster download, especially for smaller areas.
+
+## Custom Elevation Data
+
+Integrating your own elevation data is easy and just requires you to implement the
+ElevationProvider interface and then specify it via GraphHopper.setElevationProvider.
+Have a look in the existing implementations for a simple overview of caching and DataAccess usage.
\ No newline at end of file
diff --git a/docs/core/images/1.jpg b/docs/core/images/1.jpg
new file mode 100644
index 0000000000..777de4d6da
Binary files /dev/null and b/docs/core/images/1.jpg differ
diff --git a/docs/core/images/10.jpg b/docs/core/images/10.jpg
new file mode 100644
index 0000000000..7d50ff238e
Binary files /dev/null and b/docs/core/images/10.jpg differ
diff --git a/docs/core/images/11.jpg b/docs/core/images/11.jpg
new file mode 100644
index 0000000000..7e98136d8f
Binary files /dev/null and b/docs/core/images/11.jpg differ
diff --git a/docs/core/images/12.jpg b/docs/core/images/12.jpg
new file mode 100644
index 0000000000..1f408f117a
Binary files /dev/null and b/docs/core/images/12.jpg differ
diff --git a/docs/core/images/13.jpg b/docs/core/images/13.jpg
new file mode 100644
index 0000000000..aa4f1cff55
Binary files /dev/null and b/docs/core/images/13.jpg differ
diff --git a/docs/core/images/15.jpg b/docs/core/images/15.jpg
new file mode 100644
index 0000000000..077e5fb79f
Binary files /dev/null and b/docs/core/images/15.jpg differ
diff --git a/docs/core/images/16.jpg b/docs/core/images/16.jpg
new file mode 100644
index 0000000000..5197142ba4
Binary files /dev/null and b/docs/core/images/16.jpg differ
diff --git a/docs/core/images/17.jpg b/docs/core/images/17.jpg
new file mode 100644
index 0000000000..bceb49f6e4
Binary files /dev/null and b/docs/core/images/17.jpg differ
diff --git a/docs/core/images/18.jpg b/docs/core/images/18.jpg
new file mode 100644
index 0000000000..cd7e1dfc2d
Binary files /dev/null and b/docs/core/images/18.jpg differ
diff --git a/docs/core/images/2.jpg b/docs/core/images/2.jpg
new file mode 100644
index 0000000000..b5b90af561
Binary files /dev/null and b/docs/core/images/2.jpg differ
diff --git a/docs/core/images/3.jpg b/docs/core/images/3.jpg
new file mode 100644
index 0000000000..6db9ea63e0
Binary files /dev/null and b/docs/core/images/3.jpg differ
diff --git a/docs/core/images/4.jpg b/docs/core/images/4.jpg
new file mode 100644
index 0000000000..32d38e158e
Binary files /dev/null and b/docs/core/images/4.jpg differ
diff --git a/docs/core/images/5.jpg b/docs/core/images/5.jpg
new file mode 100644
index 0000000000..c9334b5ecb
Binary files /dev/null and b/docs/core/images/5.jpg differ
diff --git a/docs/core/images/6.jpg b/docs/core/images/6.jpg
new file mode 100644
index 0000000000..6cf5b0f3b6
Binary files /dev/null and b/docs/core/images/6.jpg differ
diff --git a/docs/core/images/7.jpg b/docs/core/images/7.jpg
new file mode 100644
index 0000000000..58e03063f8
Binary files /dev/null and b/docs/core/images/7.jpg differ
diff --git a/docs/core/images/8.jpg b/docs/core/images/8.jpg
new file mode 100644
index 0000000000..443a2507e8
Binary files /dev/null and b/docs/core/images/8.jpg differ
diff --git a/docs/core/images/9.jpg b/docs/core/images/9.jpg
new file mode 100644
index 0000000000..50ba8d4d74
Binary files /dev/null and b/docs/core/images/9.jpg differ
diff --git a/docs/core/images/clone1.png b/docs/core/images/clone1.png
new file mode 100644
index 0000000000..b05ec6fc9f
Binary files /dev/null and b/docs/core/images/clone1.png differ
diff --git a/docs/core/images/clone2.png b/docs/core/images/clone2.png
new file mode 100644
index 0000000000..7a8297f4a1
Binary files /dev/null and b/docs/core/images/clone2.png differ
diff --git a/docs/core/images/clone3.png b/docs/core/images/clone3.png
new file mode 100644
index 0000000000..d5a76bfe93
Binary files /dev/null and b/docs/core/images/clone3.png differ
diff --git a/docs/core/images/clone4.png b/docs/core/images/clone4.png
new file mode 100644
index 0000000000..b89d2a0ee3
Binary files /dev/null and b/docs/core/images/clone4.png differ
diff --git a/docs/core/images/clone5.png b/docs/core/images/clone5.png
new file mode 100644
index 0000000000..abef84335e
Binary files /dev/null and b/docs/core/images/clone5.png differ
diff --git a/docs/core/images/egit.png b/docs/core/images/egit.png
new file mode 100644
index 0000000000..b7b9ab7a61
Binary files /dev/null and b/docs/core/images/egit.png differ
diff --git a/docs/core/images/egit2.png b/docs/core/images/egit2.png
new file mode 100644
index 0000000000..1fad659389
Binary files /dev/null and b/docs/core/images/egit2.png differ
diff --git a/docs/core/images/import1.png b/docs/core/images/import1.png
new file mode 100644
index 0000000000..76c746f7ba
Binary files /dev/null and b/docs/core/images/import1.png differ
diff --git a/docs/core/images/import2.png b/docs/core/images/import2.png
new file mode 100644
index 0000000000..a384664bb6
Binary files /dev/null and b/docs/core/images/import2.png differ
diff --git a/docs/core/images/maven.png b/docs/core/images/maven.png
new file mode 100644
index 0000000000..2177c5296f
Binary files /dev/null and b/docs/core/images/maven.png differ
diff --git a/docs/core/location-index.md b/docs/core/location-index.md
index 9fa25b7c7a..69a18b839a 100644
--- a/docs/core/location-index.md
+++ b/docs/core/location-index.md
@@ -12,19 +12,12 @@ QueryResult qr = findClosest(lat, lon, EdgeFilter.ALL_EDGES );
 EdgeIteratorState edge = qr.getClosestEdge();
 ```
 
-If you don't use the GraphHopper class you have to handle every case on your own to build a location index.
-E.g. if it is a LevelGraph you need LocationIndexTreeSC otherwise LocationIndexTree:
+If you don't use the GraphHopper class you have to use the low level API:
 
 ```java
-LocationIndexTree tmpIndex;
-if (graph instanceof LevelGraph)
-   tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
-else
-   tmpIndex = new LocationIndexTree(graph, dir);
-
-tmpIndex.setResolution(preciseIndexResolution);
-tmpIndex.setSearchRegion(searchRegion);
-// now build the index if it cannot be loaded
-if (!tmpIndex.loadExisting())
-   tmpIndex.prepareIndex();
+LocationIndexTree index = new LocationIndexTree(graph.getBaseGraph(), dir);
+index.setResolution(preciseIndexResolution);
+index.setMaxRegionSearch(maxRegionSearch);
+if (!index.loadExisting())
+    index.prepareIndex();
 ```
\ No newline at end of file
diff --git a/docs/core/low-level-api.md b/docs/core/low-level-api.md
index f4f37617b2..29d9875f11 100644
--- a/docs/core/low-level-api.md
+++ b/docs/core/low-level-api.md
@@ -4,6 +4,21 @@ If you just start to use GraphHopper please refer to [routing docs](./routing.md
 or [the quickstart for developers](./quickstart-from-source.md)
 and come back here later if the higher level API does not suit your needs.
 
+### What are pillar and tower nodes?
+
+From road network sources like OpenStreetMap we fetch all nodes and create the routing graph but 
+only a sub-set of them are actual junctions, which are the ones we are interested in while routing.
+
+Those junction nodes (and end-standing nodes of dead alleys) we call *tower nodes* which also 
+have a graphhopper node ID associated, going from 0 to graph.getNodes(). 
+The helper nodes between the junctions we call 'pillar nodes' which can be fetched via
+`edgeIteratorState.fetchWayGeometry(0)`. Avoiding the traversal of pillar nodes while routing makes 
+routing a lot faster (~8 times).
+
+That splitting into pillar and tower nodes is also the reason why there can't be a unique mapping from 
+one OSM node ID to exactly one GraphHopper node ID. And as one OSM Way is often splitted into multiple 
+edges the same applies for edge IDs too.
+
 ### Create and save the graph
 
 ```java
@@ -25,7 +40,7 @@ graph.flush();
 ...
 GraphStorage graph = gb.load();
 // Load index
-LocationIndex index = new LocationIndexTree(graph, new RAMDirectory("graphhopper-folder", true));
+LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory("graphhopper-folder", true));
 if (!index.loadExisting())
     throw new IllegalStateException("location index cannot be loaded!");
 ```
@@ -34,8 +49,10 @@ if (!index.loadExisting())
 
 ```java
 QueryResult fromQR = index.findClosest(latitudeFrom, longituteFrom, EdgeFilter.ALL_EDGES);
-QueryResult toQR = index.findID(latitudeTo, longituteTo, EdgeFilter.ALL_EDGES);
-Path path = new Dijkstra(graph, encoder).calcPath(fromQR, toQR);
+QueryResult toQR = index.findClosest(latitudeTo, longituteTo, EdgeFilter.ALL_EDGES);
+QueryGraph queryGraph = new QueryGraph(graph);
+queryGraph.lookup(fromQR, toQR);
+Path path = new Dijkstra(queryGraph, encoder).calcPath(fromQR.getClosestNode(), toQR.getClosestNode());
 ```
 
 ### Calculate Path without LocationIndex
@@ -54,13 +71,14 @@ GraphBuilder gb = new GraphBuilder(em).
     setStore(true).
     setLevelGraph(true);
 GraphStorage graph = gb.create();
-// Make a weighted edge between two nodes.
+// Create a new edge between two nodes, set access, distance, speed, geometry, ..
 EdgeIteratorState edge = graph.edge(fromId, toId);
 ...
 
 // Prepare the graph for fast querying ...
-PrepareContractionHierarchies pch = new PrepareContractionHierarchies();
-pch.setGraph(graph).doWork();
+TraversalMode tMode = TraversalMode.NODE_BASED;
+PrepareContractionHierarchies pch = new PrepareContractionHierarchies(graph, encoder, weighting, tMode);
+pch.doWork();
 
 // flush after preparation!
 graph.flush();
@@ -69,15 +87,20 @@ graph.flush();
 GraphStorage graph = gb.load();
 
  // Load index
-Location2IDIndex index = new LocationIndexTreeSC(graph, new RAMDirectory("graphhopper-folder", true));
+LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory("graphhopper-folder", true));
 if (!index.loadExisting())
     throw new IllegalStateException("location2id index cannot be loaded!");
 
-// create the algorithm using the PrepareContractionHierarchies object
-RoutingAlgorithm algorithm = pch.createAlgo();
-
 // calculate path is identical
 QueryResult fromQR = index.findClosest(latitudeFrom, longituteFrom, EdgeFilter.ALL_EDGES);
-QueryResult toQR = index.findID(latitudeTo, longituteTo, EdgeFilter.ALL_EDGES);
-Path path = new Dijkstra(graph, encoder).calcPath(fromQR, toQR);
-```
\ No newline at end of file
+QueryResult toQR = index.findClosest(latitudeTo, longituteTo, EdgeFilter.ALL_EDGES);
+QueryGraph queryGraph = new QueryGraph(graph);
+queryGraph.lookup(fromQR, toQR);
+
+// create the algorithm using the PrepareContractionHierarchies object
+AlgorithmOptions algoOpts = AlgorithmOptions.start().
+   algorithm(AlgorithmOptions.DIJKSTRA_BI).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).
+   build();
+RoutingAlgorithm algorithm = pch.createAlgo(queryGraph, algoOpts);
+Path path = algorithm.calcPath(fromQR.getClosestNode(), toQR.getClosestNode());
+```
diff --git a/docs/core/quickstart-from-source.md b/docs/core/quickstart-from-source.md
index 2070687b2f..bc70a7917b 100644
--- a/docs/core/quickstart-from-source.md
+++ b/docs/core/quickstart-from-source.md
@@ -5,7 +5,7 @@
 For a start which requires only the JRE have a look [here](../web/quickstart.md). 
 Windows user can find a quick guide [here](./windows-setup.md). 
 
-Now, before you proceed install git and jdk6, 7 or 8. Then do:
+Now, before you proceed install git and jdk7 or 8, then do:
 
 ```bash
 $ git clone git://github.com/graphhopper/graphhopper.git
@@ -29,10 +29,16 @@ $ ./graphhopper.sh web north-america_us_new-york.pbf
 
 ## Start Development
 
-Open the project with NetBeans or enable Maven in your IDE. 
+Open the project with NetBeans, IntelliJ or enable Maven in your IDE. 
 [Maven](http://maven.apache.org/download.cgi) is downloaded to ```graphhopper/maven``` if not 
 installed when executing graphhopper.sh.
 
+### NetBeans, IntelliJ, Eclipse
+
+ * For IntelliJ you need to import the code formatting settings (File|Import Settings). Load them from core/files/intellij-settings.jar. See the [special setup](../android/android-studio-setup.md) for Android if using Android studio.
+ * For Eclipse please refer to [this separate setup documentation](./eclipse-setup.md).
+ * Nothing special needs to be done for NetBeans.
+
 ### Java, Embedded Usage
 
 Have a look into the [Java API documentation](./) for further details e.g. how [GraphHopper can
@@ -76,7 +82,7 @@ For simplicity you could just start jetty from maven and schedule it as backgrou
 Then the service will be accessible on port 11111.
 
 For production usage you can install the latest jetty (8 or 9) as a service but we prefer to have it bundled as a 
-simple jar. Tomcat should work too. To create a war file do `mvn clean war:war` and copy it from the target/ 
+simple jar. Tomcat should work too. To create a war file do `mvn clean install war:war` and copy it from the target/ 
 folder to your jetty installation. Then copy web/config.properties also there and change this properties 
 file to point to the required graphhopper folder. Increase the Xmx/Xms values of your jetty server e.g. 
 for world wide coverage with a hierarchical graph I do the following in bin/jetty.sh
@@ -128,4 +134,4 @@ Have a look in the more [technical documentation](./technical.md) or the [low le
 Further Links
 ---------------
  * [Spatial Key](http://karussell.wordpress.com/2012/05/23/spatial-keys-memory-efficient-geohashes/)
- * [Author@Twitter](https://twitter.com/timetabling)
\ No newline at end of file
+ * [Author@Twitter](https://twitter.com/timetabling)
diff --git a/docs/core/routing.md b/docs/core/routing.md
index 9239980a41..166b68d6bc 100644
--- a/docs/core/routing.md
+++ b/docs/core/routing.md
@@ -1,8 +1,8 @@
 To do routing in your Java code you'll need just a few lines of code:
 
 ```java
+// create singleton
 GraphHopper hopper = new GraphHopper().forServer();
-hopper.setInMemory(true);
 hopper.setOSMFile(osmFile);
 // where to store graphhopper files?
 hopper.setGraphHopperLocation(graphFolder);
@@ -15,7 +15,8 @@ hopper.importOrLoad();
 // simple configuration of the request object, see the GraphHopperServlet classs for more possibilities.
 GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).
     setWeighting("fastest").
-    setVehicle("car");
+    setVehicle("car").
+    setLocale(Locale.US);
 GHResponse rsp = hopper.route(req);
 
 // first check for errors
@@ -25,49 +26,65 @@ if(rsp.hasErrors()) {
    return;
 }
 
-// route was found? e.g. if disconnected areas (like island) 
-// no route can ever be found
-if(!rsp.isFound()) {
-   // handle properly
-   return;
-}
-
 // points, distance in meters and time in millis of the full path
 PointList pointList = rsp.getPoints();
 double distance = rsp.getDistance();
-long millis = rsp.getMillis();
+long timeInMs = rsp.getTime();
 
-// get the turn instructions for the path
 InstructionList il = rsp.getInstructions();
-Translation tr = trMap.getWithFallBack(Locale.US);
-List<String> iList = il.createDescription(tr);
+// iterate over every turn instruction
+for(Instruction instruction : il) {
+   instruction.getDistance();
+   ...
+}
+
+// or get the json
+List<Map<String, Object>> iList = il.createJson();
 
 // or get the result as gpx entries:
 List<GPXEntry> list = il.createGPXList();
 ```
 
-If you want a more flexible routing (but slower) you can disable contraction hierarchies
-and import multiple vehicles. Then pick one vehicle and optionally the algorithm like
-astar as algorithm:
+The default is to use the speed-up mode for one profile. If you need multiple profiles you 
+specify a list of profiles (e.g. car,bike) and the speed-up mode is applied to the first profile only (e.g. car).
+The other vehicles then use a more flexible routing.
+
+You can also completely disable the speed-up mode to make all vehicles using the flexibility mode.
+Then pick one vehicle and optionally the algorithm like 'bidirectional astar' as algorithm:
 
 ```java
 GraphHopper hopper = new GraphHopper().forServer();
-hopper.disableCHShortcuts();
-hopper.setInMemory(true);
+hopper.setCHEnable(false);
 hopper.setOSMFile(osmFile);
 hopper.setGraphHopperLocation(graphFolder);
 hopper.setEncodingManager(new EncodingManager("car,bike"));
 
 hopper.importOrLoad();
 
-GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).setVehicle("bike").setAlgorithm("astar");
+GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).
+    setVehicle("bike").setAlgorithm(AlgorithmOptions.ASTAR_BI);
 GHResponse res = hopper.route(req);
 ```
 
-In case you need the online routing API in a Java or Android application the GraphHopperWeb comes handy - see the 'web' sub module.
+In the flexibility mode it is also possible to add a desired heading (north based azimuth between 0 and 360 degree)
+to any point,
+```java
+GHRequest req = new GHRequest().addPoint(new GHPoint (latFrom, lonFrom), favoredHeading).addPoint(new GHPoint (latTo, lonTo));
+```
+or to avoid u-turns at via points
+```java
+req.getHints().put("pass_through", true);
+```
+ 
+In case you need a web access in a Java or an Android application the GraphHopperWeb class comes handy,
+ see the 'web' sub module or [the Java client for the GraphHopper Directions API](https://github.com/graphhopper/directions-api-java-client).
 
 ```java
 GraphHopperAPI gh = new GraphHopperWeb();
 gh.load("http://your-graphhopper-service.com");
+
+// or for the GraphHopper Directions API https://graphhopper.com/#directions-api
+// gh.load("https://graphhopper.com/api/1/route");
+
 GHResponse rsp = gh.route(new GHRequest(...));
-```
\ No newline at end of file
+```
diff --git a/docs/core/technical.md b/docs/core/technical.md
index 5cc0ea1372..4b45a58200 100644
--- a/docs/core/technical.md
+++ b/docs/core/technical.md
@@ -54,14 +54,12 @@ For [_Contraction Hierarchies_](http://ad-wiki.informatik.uni-freiburg.de/teachi
  we use the _LevelGraph_ which additionally holds shortcuts. While path extraction we need to identify those
  shortcuts and get the edges recursivly, this is done in Path4CH.
 
-## 3.1 OriginalGraph
-
-See issue [#116](https://github.com/graphhopper/graphhopper/issues/116) for the progress of this feature.
+## 3.1 Base Graph
 
 In order to traverse the _LevelGraph_ like a normal _Graph_ one needs to hide the shortcuts, which
-is done automatically for you if you call graph.getOriginalGraph(). This is necessary in a 
-_LocationIndex_ and partially in the _Path_ class in order to identify how many streets leave a junction
-or similar. See #116 for more information.
+is done automatically for you if you call graph.getBaseGraph(). This is necessary in a 
+_LocationIndex_ and in the _Path_ class in order to identify how many streets leave a junction
+or similar. See issue #116 for more information.
 
 
 ### 4. Connecting the Real World to the Graph
diff --git a/docs/core/translations.md b/docs/core/translations.md
index 30b9265a18..2cc52cb92a 100644
--- a/docs/core/translations.md
+++ b/docs/core/translations.md
@@ -2,8 +2,12 @@
 
 You can help improve GraphHopper by adding your language!
 
-See [this spreadsheet](https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0)
-and add a column for your language. Revisit it regularly to update or add new items.
+See [this spreadsheet](https://docs.google.com/spreadsheets/d/10HKSFmxGVEIO92loVQetVmjXT0qpf3EA2jxuQSSYTdU/edit?pli=1#gid=0)
+and add a column for your language. Revisit it regularly to update or add new items. And see your language live at GraphHopper Maps e.g. explicitely specify the locale via:
+
+[https://graphhopper.com/maps/?point=40.979898%2C-3.164062&point=39.909736%2C-2.8125&locale=de](https://graphhopper.com/maps/?point=40.979898%2C-3.164062&point=39.909736%2C-2.8125&locale=de) 
+
+de -> German, en -> Englisch, zh -> Simplified Chinese, ...
 
 ## Questions
 
@@ -24,7 +28,7 @@ want to try your changes or want to speed up the integration you can do the foll
 
  * Make GraphHopper working on your computer, where you need to git clone the repository - see [here](./quickstart-from-source.md) for more information.
  * If you created a new language then add it in lexicographical order to TranslationMap.LOCALES (core/src/main/java/com/graphhopper/util) and to the script: core/files/update-translations.sh
- * Do `cd graphhopper/core; curl "https://docs.google.com/spreadsheet/pub?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc&single=true&gid=0&output=txt" > tmp.tsv`
+ * Do `cd graphhopper/core; curl 'https://docs.google.com/spreadsheets/d/10HKSFmxGVEIO92loVQetVmjXT0qpf3EA2jxuQSSYTdU/export?format=tsv&id=10HKSFmxGVEIO92loVQetVmjXT0qpf3EA2jxuQSSYTdU&gid=0' > tmp.tsv`
  * Then `./files/update-translations.sh tmp.tsv && rm tmp.tsv`
  * Now you can see your changes via `git diff`. Make sure that is the only one with `git status`
  * Now execute `mvn clean test` to see if you did not miss arguments in your translation (see point 2 in the questions above)
@@ -33,4 +37,4 @@ want to try your changes or want to speed up the integration you can do the foll
 
 ## License Agreement
 
-Please sign the <a href="http://www.clahub.com/agreements/graphhopper/graphhopper">GraphHopper License Agreement</a>.
\ No newline at end of file
+Please sign the <a href="http://www.clahub.com/agreements/graphhopper/graphhopper">GraphHopper License Agreement</a>.
diff --git a/docs/core/weighting.md b/docs/core/weighting.md
index 0cfe351f42..9b206bb610 100644
--- a/docs/core/weighting.md
+++ b/docs/core/weighting.md
@@ -71,4 +71,6 @@ class MyGraphHopper extends GraphHopper {
 ```
 
 For forbiddenEdges you need to determine the edges from some GPS coordinates. 
-Have a look into the [location index docs](./location-index.md).
+Have a look into the [location index docs](./location-index.md). 
+
+If your blocking edges change per-request you need to disable the speed mode e.g. via `prepare.chWeighting=no`
diff --git a/docs/index.md b/docs/index.md
index a170ce92c4..7b0f01c7dd 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -1,17 +1,40 @@
-Users
----------------
- * [Read Overview](http://graphhopper.com/#overview)
- * [Add GraphHopper Maps to your Browser](./web/open-search.md)
- * [GraphHopper on Twitter](https://twitter.com/graphhopp)
- * [Quickstart](./web/quickstart.md) for users
-
-Developers
---------------- 
- * [Quickstart](./core/quickstart-from-source.md) for developers with git checkout and IDE setup etc
-   * [Android](./android/index.md)
-   * [Windows](./core/windows-setup.md)
- * [Translations](./core/translations.md)
- * [Slides from FOSDEM 2014](http://graphhopper.com/public/slides/)
- * [World-Wide-Road-Network](./core/world-wide.md)
- * [Changelog](https://github.com/graphhopper/graphhopper/blob/master/core/files/changelog.txt)
+# Users
 
+ * [Quickstart](./web/quickstart.md): HowTo for users.
+ * [Read Overview](https://graphhopper.com/#overview): Summary of the product Graphhopper. 
+ * [Add GraphHopper Maps to your Browser](./web/open-search.md): Instructions how to setup Graphhopper as the standart search enginge in your browser.
+ * [GraphHopper on Twitter](https://twitter.com/graphhopper): Find the official Graphhopper account on Twitter.
+
+# Translators
+
+* [Translations](./core/translations.md): Tutorial how to help with the Graphhopper translations or how to setup a new language.
+
+
+# Developers
+
+ * [Quickstart](./core/quickstart-from-source.md): Introduction for developers. Explains git checkout, IDE setup and commands for setting up a graphhopper server.
+ * [Android](./android/index.md): Instructions how to setup the demo project for Graphhopper on Android as base for further development (i.e. with Android Studio).
+ * [Windows](./core/windows-setup.md): Documentation about how to get an Graphhopper instance running on windows (cygwin).
+ * [Set up and run GraphHopper in Eclipse](./core/eclipse-setup.md): Detailed instructions how to setup Graphhopper in eclipse with maven.
+ * [iOS](https://github.com/graphhopper/graphhopper-ios/): Link to the Graphhopper-iOS github repository.
+
+## Core
+
+ * [Simple routing](./core/routing.md): Tutorial how to integrate GraphHopper in your Java application (or pick any JVM language)
+ * [Create custom weighting](./core/weighting.md): Documentation about how to create a custom weighting class to influence the track calculation.
+ * [Elevation](./core/elevation.md): Documentation how to enable the usage of elevation for the output of the track.
+ * [Technical overview](./core/technical.md): Technical details about how graphhoppers calculations are working.
+ * [Slides from 2014](https://graphhopper.com/public/slides/): Small presentations about how graphhopper ist working.
+ * [Contraction Hierarchies](./core/ch.md): Details about speeding up the track calculations by [Contraction Hierarchies](http://en.wikipedia.org/wiki/Contraction_hierarchies).
+
+## Web
+
+ * [Routing API](./web/api-doc.md): Documentation of the Web API to communicate with any graphhopper server via http.
+ 
+## Advanced Topics
+
+ * [Low level API](./core/low-level-api.md): Instructions how to use Graphhopper as a Java library.
+ * [Create new FlagEncoder](./core/create-new-flagencoder.md): Documentation to create new routing profiles to influence which ways to favor and how the track-time is calculated.
+ * [LocationIndex](./core/location-index.md): Documentation about how to get the location index for getting i.e. the nearest edge.
+ * [World-Wide-Road-Network](./core/world-wide.md): Details about using the whole world wide street data.
+ * [Changelog](https://github.com/graphhopper/graphhopper/blob/master/core/files/changelog.txt): Latest changes.
diff --git a/docs/web/api-doc.md b/docs/web/api-doc.md
index dc9733d0a9..4b0027bd75 100644
--- a/docs/web/api-doc.md
+++ b/docs/web/api-doc.md
@@ -1,7 +1,7 @@
 ## Routing Web API Docs
 
 In order to communicate with your or [our](http://graphhopper.com/#enterprise) hosted GraphHopper 
-server you need to understand how to use it.
+server you need to understand how to use it. There is a separate [JavaScript](https://github.com/graphhopper/directions-api-js-client) and [Java](https://github.com/graphhopper/directions-api-java-client) client for this API or use the plain JSON response for your language.
 
 ### A simple example
 [http://localhost:8989/route?point=45.752193%2C-0.686646&point=46.229253%2C-0.32959](http://localhost:8989/route?point=45.752193%2C-0.686646&point=46.229253%2C-0.32959)
@@ -14,7 +14,7 @@ All official parameters are shown in the following table
 
 Parameter   | Default | Description
 :-----------|:--------|:-----------
-point       | -       | Specifiy multiple points for which the route should be calculated. The order is important. Specify at least two points.
+point       | -       | Specify multiple points for which the route should be calculated. The order is important. Specify at least two points.
 locale      | en      | The locale of the result. E.g. `pt_PT` for Portuguese or `de` for German
 instructions| true    | If instruction should be calculated and returned
 vehicle     | car     | The vehicle for which the route should be calculated. Other vehicles are foot and bike
@@ -25,10 +25,34 @@ points_encoded     | true    | If `false` a GeoJson array in `point` is returned
 debug              | false   | If true, the output will be formated.
 calc_points        | true    | If the points for the route should be calculated at all. Sometimes only the distance and time is necessary.
 type               | json    | Specifies the resulting format of the route, for json the content type will be application/json. Other possible format options: <br> jsonp you'll need to provide the callback function via the callback parameter. The content type will be application/javascript<br> gpx, the content type will be application/xml
+heading            | NaN     | Favored heading direction for points. Specify either one heading for the start point or as many as there are points. In this case headings are associated by their order to the specific points. Headings are given as north based clockwise angle between 0 and 360 degree, NaN indicates non specific heading. Does only give valid results in the flexibility mode.
+heading_penalty    | 120     | Penalty for omitting a specified heading. The penalty corresponds to the accepted time delay in seconds in comparison to the route without a heading.
+pass_through       | false   | If `true` u-turns are avoided at via-points with regard to the heading_penalty. Does only give valid results in the flexibility mode.
 
 ## Example output for the case type=json
 
-Keep in mind that some attributes which are not documented here can be removed in the future - you should not rely on them!
+Keep in mind that some attributes which are not documented here can be removed in the future - 
+you should not rely on them! The JSON result contains the following structure:
+
+JSON path/attribute        | Description
+:--------------------------|:------------
+info.took                  | How many ms the request took on the server, of course without network latency taken into account.
+paths                      | An array of possible paths
+paths[0].distance          | The overall distance of the route, in meter
+paths[0].time              | The overall time of the route, in ms
+paths[0].points            | The polyline encoded coordinates of the path. Order is lat,lon,elelevation as it is no geoJson!
+paths[0].points_encoded    | Is true if the points are encoded, if not paths[0].points contains the geo json of the path (then order is lon,lat,elevation), which is easier to handle but consumes more bandwidth compared to encoded version
+paths[0].bbox              | The bounding box of the route, format: <br> minLon, minLat, maxLon, maxLat
+paths[0].instructions      | Contains information about the instructions for this route. The last instruction is always the Finish instruction and takes 0ms and 0meter. Keep in mind that instructions are currently under active development and can sometimes contain misleading information, so, make sure you always show an image of the map at the same time when navigating your users!
+paths[0].instructions[0].text                 | A description what the user has to do in order to follow the route. The language depends on the locale parameter.
+paths[0].instructions[0].distance             | The distance for this instruction, in meter
+paths[0].instructions[0].time                 | The duration for this instruction, in ms
+paths[0].instructions[0].interval             | An array containing the first and the last index (relative to paths[0].points) of the points for this instruction. This is useful to know for which part of the route the instructions are valid.
+paths[0].instructions[0].sign                 | A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5<br>USE_ROUNDABOUT = 6
+paths[0].instructions[0].annotation_text      | [optional] A text describing the instruction in more detail, e.g. like surface of the way, warnings or involved costs
+paths[0].instructions[0].annotation_importance| [optional] 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning
+paths[0].instructions[0].exit_number          | [optional] Only available for USE_ROUNDABOUT instructions. The count of exits at which the route leaves the roundabout.
+paths[0].instructions[0].turn_angle           | [optional] Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout: 0<r<2*PI for clockwise and -2PI<r<0 for counterclockwise transit. Null if the direction of rotation is undefined.
 
 ```json
 {
@@ -100,30 +124,9 @@ Keep in mind that some attributes which are not documented here can be removed i
 }
 ```
 
-The JSON result contains the following structure:
-
-JSON path/attribute        | Description
-:--------------------------|:------------
-info.took                  | How many ms the request took on the server, of course without network latency taken into account.
-paths                      | An array of possible paths
-paths[0].distance          | The overall distance of the route, in meter
-paths[0].time              | The overall time of the route, in ms
-paths[0].points            | The polyline encoded coordinates of the path. Order is lat,lon,elelevation as it is no geoJson!
-paths[0].points_encoded    | Is true if the points are encoded, if not paths[0].points contains the geo json of the path (then order is lon,lat,elevation), which is easier to handle but consumes more bandwidth compared to encoded version
-paths[0].bbox              | The bounding box of the route, format: <br> minLon, minLat, maxLon, maxLat
-paths[0].instructions      | Contains information about the instructions for this route. The last instruction is always the Finish instruction and takes 0ms and 0meter. Keep in mind that instructions are currently under active development and can sometimes contain misleading information, so, make sure you always show an image of the map at the same time when navigating your users!
-paths[0].instructions[0].text                 | A description what the user has to do in order to follow the route. The language depends on the locale parameter.
-paths[0].instructions[0].distance             | The distance for this instruction, in meter
-paths[0].instructions[0].time                 | The duration for this instruction, in ms
-paths[0].instructions[0].interval             | An array containing the first and the last index (relative to paths[0].points) of the points for this instruction. This is useful to know for which part of the route the instructions are valid.
-paths[0].instructions[0].sign                 | A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5
-paths[0].instructions[0].annotationText       | [optional] A text describing the instruction in more detail, e.g. like surface of the way, warnings or involved costs
-paths[0].instructions[0].annotationImportance | [optional] 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning
-
-
 ## Area information
 
-If you need to find out defails about the area or need to ping the service use '/info'
+If you need to find out details about the area or need to ping the service use '/info'
 
 [http://localhost:8989/info](http://localhost:8989/info)
 
@@ -147,13 +150,11 @@ import_date         | [optional] The date time at which the OSM import was done
 prepare_date        | [optional] The date time at which the preparation (contraction hierarchies) was done. If nothing was done this is empty
 supported_vehicles  | [deprecated] An array of strings for all supported vehicles
 
-### Output if expected error(s) while routing:
+### Error Output
 ```json
 {
-  "info": {"errors": [{
-    "details": "java.lang.IllegalArgumentException",
-    "message": "Cannot find point 2: 2248.224673, 3.867187"
-  }]}
+  "message": "Cannot find point 2: 2248.224673, 3.867187",
+  "hints": [{"message": "something", ...}]
 }
 ```
 
@@ -162,15 +163,14 @@ indicate a bug in the routing engine and is expected to a certain degree if too
 
 JSON path/attribute    | Description
 :----------------------|:------------
-info.errors            | A list of error messages
-info.errors[0].details | E.g. to see the underlying exception, if any
-info.errors[0].message | Not intended to be displayed to the user as it is currently not translated
+message                | Not intended to be displayed to the user as it is not translated
+hints                  | An optional list of details regarding the error message e.g. `[{"message": "first error message in hints"}]`
 
 
 ### HTTP Error codes
 
 HTTP error code | Reason
 :---------------|:------------
-500             | Internal server error. It is strongely recommended to send us the message and the link to it, as it is very likely a bug in our system.
+500             | Internal server error. It is strongly recommended to send us the message and the link to it, as it is very likely a bug in our system.
 501             | Only a special list of vehicles is supported
 400             | Something was wrong in your request
diff --git a/graphhopper.sh b/graphhopper.sh
index b2a1dda238..ada567281a 100755
--- a/graphhopper.sh
+++ b/graphhopper.sh
@@ -3,13 +3,13 @@
 GH_CLASS=com.graphhopper.tools.Import
 GH_HOME=$(dirname "$0")
 JAVA=$JAVA_HOME/bin/java
-if [ "x$JAVA_HOME" = "x" ]; then
+if [ "$JAVA_HOME" = "" ]; then
  JAVA=java
 fi
 
 vers=$($JAVA -version 2>&1 | grep "java version" | awk '{print $3}' | tr -d \")
 bit64=$($JAVA -version 2>&1 | grep "64-Bit")
-if [ "x$bit64" != "x" ]; then
+if [ "$bit64" != "" ]; then
   vers="$vers (64bit)"
 fi
 echo "## using java $vers from $JAVA_HOME"
@@ -22,13 +22,29 @@ fi
 ACTION=$1
 FILE=$2
 
-USAGE="./graphhopper.sh import|ui|test|measurement|miniui|extract|build <your-osm-file>"
-if [ "x$ACTION" = "x" ]; then
- echo -e "## action $ACTION not found. try \n$USAGE"
+function printUsage {
+ echo
+ echo "./graphhopper.sh import|web <your-osm-file>"
+ echo "./graphhopper.sh clean|build|help"
+ echo
+ echo "  help        this message"
+ echo "  import      creates the graphhopper files used for later (faster) starts"
+ echo "  web         starts a local server for user access at localhost:8989 and developer access at localhost:8989/route"
+ echo "  build       creates the graphhopper JAR (without the web module)"
+ echo "  clean       removes all JARs, necessary if you need to use the latest source (e.g. after switching the branch etc)"
+ echo "  measurement does performance analysis of the current source version via artificial, random routes (Measurement class)"
+ echo "  torture     can be used to test real world routes via feeding graphhopper logs into a graphhopper system (Torture class)"
+ echo "  miniui      is a simple Java/Swing application used for debugging purposes only (MiniGraphUI class)"
+ echo "  extract     calls the overpass API to easily grab any area as .osm file"
+}
+
+if [ "$ACTION" = "" ]; then
+ echo "## action $ACTION not found. try" 
+ printUsage
 fi
 
 function ensureOsmXml { 
-  if [ "x$OSM_FILE" = "x" ]; then
+  if [ "$OSM_FILE" = "" ]; then
     # skip
     return
   elif [ ! -s "$OSM_FILE" ]; then
@@ -61,17 +77,17 @@ function ensureOsmXml {
 
 function ensureMaven {
   # maven home existent?
-  if [ "x$MAVEN_HOME" = "x" ]; then
+  if [ "$MAVEN_HOME" = "" ]; then
     # not existent but probably is maven in the path?
     MAVEN_HOME=$(mvn -v | grep "Maven home" | cut -d' ' -f3)
-    if [ "x$MAVEN_HOME" = "x" ]; then
+    if [ "$MAVEN_HOME" = "" ]; then
       # try to detect previous downloaded version
       MAVEN_HOME="$GH_HOME/maven"
       if [ ! -f "$MAVEN_HOME/bin/mvn" ]; then
         echo "No Maven found in the PATH. Now downloading+installing it to $MAVEN_HOME"
         cd "$GH_HOME"
-        MVN_PACKAGE=apache-maven-3.2.3
-        wget -O maven.zip http://www.eu.apache.org/dist/maven/maven-3/3.2.3/binaries/$MVN_PACKAGE-bin.zip
+        MVN_PACKAGE=apache-maven-3.2.5
+        wget -O maven.zip http://archive.apache.org/dist/maven/maven-3/3.2.5/binaries/$MVN_PACKAGE-bin.zip
         unzip maven.zip
         mv $MVN_PACKAGE maven
         rm maven.zip
@@ -111,45 +127,46 @@ function packageCoreJar {
 function prepareEclipse {
  ensureMaven   
  packageCoreJar
- cp core/target/graphhopper-*-android.jar android/libs/   
+ # cp core/target/graphhopper-*-android.jar android/libs/   
 }
 
 
 ## now handle actions which do not take an OSM file
-if [ "x$ACTION" = "xclean" ]; then
+if [ "$ACTION" = "clean" ]; then
  rm -rf ./*/target
  exit
 
-elif [ "x$ACTION" = "xeclipse" ]; then
+elif [ "$ACTION" = "eclipse" ]; then
  prepareEclipse
  exit
 
-elif [ "x$ACTION" = "xbuild" ]; then
+elif [ "$ACTION" = "build" ]; then
  prepareEclipse
  exit  
  
-elif [ "x$ACTION" = "xextract" ]; then
+elif [ "$ACTION" = "extract" ]; then
  echo use "./graphhopper.sh extract \"left,bottom,right,top\""
  URL="http://overpass-api.de/api/map?bbox=$2"
  #echo "$URL"
  wget -O extract.osm "$URL"
  exit
  
-elif [ "x$ACTION" = "xandroid" ]; then
+elif [ "$ACTION" = "android" ]; then
  prepareEclipse
  "$MAVEN_HOME/bin/mvn" -P include-android --projects android install android:deploy android:run
  exit
 fi
 
-if [ "x$FILE" = "x" ]; then
-  echo -e "no file specified? try \n$USAGE"
+if [ "$FILE" = "" ]; then
+  echo -e "no file specified? try"
+  printUsage
   exit
 fi
 
 # NAME = file without extension if any
 NAME="${FILE%.*}"
 
-if [ "x$FILE" == "x-" ]; then
+if [ "$FILE" == "-" ]; then
    OSM_FILE=
 elif [ ${FILE: -4} == ".osm" ]; then
    OSM_FILE="$FILE"
@@ -175,7 +192,7 @@ VERSION=$(grep  "<name>" -A 1 pom.xml | grep version | cut -d'>' -f2 | cut -d'<'
 JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar
 
 LINK=$(echo $NAME | tr '_' '/')
-if [ "x$FILE" == "x-" ]; then
+if [ "$FILE" == "-" ]; then
    LINK=
 elif [ ${FILE: -4} == ".osm" ]; then 
    LINK="http://download.geofabrik.de/$LINK-latest.osm.bz2"
@@ -188,7 +205,7 @@ else
    LINK="http://download.geofabrik.de/$LINK-latest.osm.pbf"
 fi
 
-if [ "x$JAVA_OPTS" = "x" ]; then
+if [ "$JAVA_OPTS" = "" ]; then
   JAVA_OPTS="-Xmx1000m -Xms1000m -server"
 fi
 
@@ -199,9 +216,9 @@ packageCoreJar
 
 echo "## now $ACTION. JAVA_OPTS=$JAVA_OPTS"
 
-if [ "x$ACTION" = "xui" ] || [ "x$ACTION" = "xweb" ]; then
+if [ "$ACTION" = "ui" ] || [ "$ACTION" = "web" ]; then
   export MAVEN_OPTS="$MAVEN_OPTS $JAVA_OPTS"
-  if [ "x$JETTY_PORT" = "x" ]; then  
+  if [ "$JETTY_PORT" = "" ]; then  
     JETTY_PORT=8989
   fi
   WEB_JAR="$GH_HOME/web/target/graphhopper-web-$VERSION-with-dep.jar"
@@ -217,7 +234,7 @@ if [ "x$ACTION" = "xui" ] || [ "x$ACTION" = "xweb" ]; then
 
   RC_BASE=./web/src/main/webapp
 
-  if [ "x$GH_FOREGROUND" = "x" ]; then
+  if [ "$GH_FOREGROUND" = "" ]; then
     exec "$JAVA" $JAVA_OPTS -jar "$WEB_JAR" jetty.resourcebase=$RC_BASE \
 	jetty.port=$JETTY_PORT jetty.host=$JETTY_HOST \
     	config=$CONFIG $GH_WEB_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE"
@@ -226,41 +243,34 @@ if [ "x$ACTION" = "xui" ] || [ "x$ACTION" = "xweb" ]; then
     exec "$JAVA" $JAVA_OPTS -jar "$WEB_JAR" jetty.resourcebase=$RC_BASE \
     	jetty.port=$JETTY_PORT jetty.host=$JETTY_HOST \
     	config=$CONFIG $GH_WEB_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE" <&- &
-    if [ "x$GH_PID_FILE" != "x" ]; then
+    if [ "$GH_PID_FILE" != "" ]; then
        echo $! > $GH_PID_FILE
     fi
     exit $?                    
   fi
 
-elif [ "x$ACTION" = "ximport" ]; then
- "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS printVersion=true \
-      config=$CONFIG \
+elif [ "$ACTION" = "import" ]; then
+ "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS config=$CONFIG \
       $GH_IMPORT_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE"
 
 
-elif [ "x$ACTION" = "xtest" ]; then
- "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS printVersion=true config=$CONFIG \
- 	osmreader.wayPointMaxDistance=0 graph.location="$GRAPH" osmreader.osm="$OSM_FILE" prepare.chWeighting=false \
-	graph.testIT=true
-
-
-elif [ "x$ACTION" = "xtorture" ]; then
+elif [ "$ACTION" = "torture" ]; then
  "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.tools.QueryTorture $3 $4 $5 $6 $7 $8 $9
 
 
-elif [ "x$ACTION" = "xminiui" ]; then
- "$MAVEN_HOME/bin/mvn" -f "$GH_HOME/tools/pom.xml" -DskipTests clean install assembly:single
+elif [ "$ACTION" = "miniui" ]; then
+ "$MAVEN_HOME/bin/mvn" --projects tools -DskipTests clean install assembly:single
  JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar   
- "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.ui.MiniGraphUI osmreader.osm="$OSM_FILE" printVersion=true config=$CONFIG \
+ "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.ui.MiniGraphUI osmreader.osm="$OSM_FILE" config=$CONFIG \
               graph.location="$GRAPH"
 
 
-elif [ "x$ACTION" = "xmeasurement" ]; then
+elif [ "$ACTION" = "measurement" ]; then
  ARGS="config=$CONFIG graph.location=$GRAPH osmreader.osm=$OSM_FILE prepare.chWeighting=fastest graph.flagEncoders=CAR"
- # graph.doSort=true"
  echo -e "\ncreate graph via $ARGS, $JAR"
  START=$(date +%s)
- "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS $ARGS prepare.doPrepare=false
+ # avoid islands for measurement at all costs
+ "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS $ARGS prepare.doPrepare=false prepare.minNetworkSize=10000 prepare.minOnewayNetworkSize=10000
  END=$(date +%s)
  IMPORT_TIME=$(($END - $START))
 
@@ -276,9 +286,9 @@ elif [ "x$ACTION" = "xmeasurement" ]; then
  # use all <last_commits> versions starting from HEAD
  last_commits=$3
   
- if [ "x$last_commits" = "x" ]; then
+ if [ "$last_commits" = "" ]; then
    # use current version
-   "$MAVEN_HOME/bin/mvn" -f "$GH_HOME/core/pom.xml" -DskipTests clean install assembly:single
+   "$MAVEN_HOME/bin/mvn" --projects core,tools -DskipTests clean install assembly:single
    startMeasurement
    exit
  fi
@@ -291,7 +301,7 @@ elif [ "x$ACTION" = "xmeasurement" ]; then
    M_FILE_NAME="measurement$M_FILE_NAME.properties"
    echo -e "\nusing commit $commit and $M_FILE_NAME"
    
-   "$MAVEN_HOME/bin/mvn" -f "$GH_HOME/core/pom.xml" -DskipTests clean install assembly:single
+   "$MAVEN_HOME/bin/mvn" --projects core,tools -DskipTests clean install assembly:single
    startMeasurement
    echo -e "\nmeasurement.commit=$commit\n" >> "$M_FILE_NAME"
  done
diff --git a/pom.xml b/pom.xml
index 5042897e07..dadb688542 100644
--- a/pom.xml
+++ b/pom.xml
@@ -6,7 +6,7 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-parent</artifactId>
     <name>GraphHopper Parent Project</name>
-    <version>0.4-SNAPSHOT</version>
+    <version>0.5-SNAPSHOT</version>
     <packaging>pom</packaging> 
     <url>http://graphhopper.com</url> 
     <inceptionYear>2012</inceptionYear>
@@ -23,7 +23,7 @@
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
-        <slf4j.version>1.7.7</slf4j.version>
+        <slf4j.version>1.7.12</slf4j.version>
         <log4j.version>1.2.17</log4j.version>
         
         <!-- netbeans formatting rules -->
@@ -44,6 +44,8 @@
         <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.allowConvertToStarImport>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.allowConvertToStarImport>
         <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.countForUsingStaticStarImport>2</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.countForUsingStaticStarImport>
         <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.importGroupsOrder>*</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.importGroupsOrder>        
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineMethodParams>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineMethodParams>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineAnnotationArgs>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineAnnotationArgs>        
     </properties>
     
     <scm>
@@ -57,6 +59,11 @@
             <name>Peter Karich</name>
             <email>my.name@graphhopper.com</email>
         </developer>
+        <developer>
+            <id>jansoe</id>
+            <name>Jan Slter</name>
+            <email>my.name@graphhopper.com</email>
+        </developer>
     </developers>
     
     <mailingLists>
@@ -86,11 +93,13 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.1</version>
+                <version>3.3</version>
                 <configuration>
                     <!--
                     <compilerArgument>-Xlint:unchecked</compilerArgument>
                     -->
+                    
+                    <!-- suppress warning about Unsafe functionality -->
                     <compilerArgument>-XDignore.symbol.file</compilerArgument>
                     <fork>true</fork>
                     <source>1.6</source>
@@ -102,7 +111,7 @@
             <plugin>                
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.17</version>
+                <version>2.18.1</version>
                 <configuration>
                     <argLine>-Xmx100m -Xms100m</argLine>
                 </configuration>
@@ -111,7 +120,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-failsafe-plugin</artifactId>
-                <version>2.17</version>
+                <version>2.18.1</version>
                 <executions>
                     <execution>
                         <goals>
@@ -130,13 +139,27 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-javadoc-plugin</artifactId>
-                <version>2.10</version>
+                <version>2.10.3</version>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-source-plugin</artifactId>
-                <version>2.3</version>
+                <version>2.4</version>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-assembly-plugin</artifactId>
+                <version>2.5.4</version>                    
             </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <version>2.6</version>
+            </plugin>
+            <plugin>
+                <artifactId>maven-war-plugin</artifactId>
+                <version>2.6</version>                
+            </plugin>            
         </plugins>
     </build>    
     
@@ -144,7 +167,7 @@
         <dependency>
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
-            <version>4.11</version>
+            <version>4.12</version>
             <scope>test</scope>
         </dependency>        
     </dependencies>
@@ -164,7 +187,7 @@
                     <plugin>
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-gpg-plugin</artifactId>
-                        <version>1.5</version>
+                        <version>1.6</version>
                         <executions>
                             <execution>
                                 <id>sign-artifacts</id>
@@ -185,7 +208,7 @@
                 <activeByDefault>false</activeByDefault>
             </activation>
             <modules>
-                <module>android</module>
+                <module>android/app</module>
             </modules>
         </profile>
     </profiles>
diff --git a/tools/pom.xml b/tools/pom.xml
index 44f0ebd1ed..35aeb6f029 100644
--- a/tools/pom.xml
+++ b/tools/pom.xml
@@ -5,14 +5,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-tools</artifactId>
-    <version>0.4-SNAPSHOT</version>
+    <version>0.5-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Tools</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.4-SNAPSHOT</version>
+        <version>0.5-SNAPSHOT</version>
     </parent>
 
     <dependencies>
@@ -41,15 +41,14 @@
         <dependency>
             <groupId>org.apache.commons</groupId>
             <artifactId>commons-compress</artifactId>
-            <version>1.8.1</version>
+            <version>1.9</version>
         </dependency>
     </dependencies>
     <build>
         <plugins>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-assembly-plugin</artifactId>
-                <version>2.4.1</version>
+                <artifactId>maven-assembly-plugin</artifactId>                
                 <configuration>
                     <archive>
                         <manifest>
diff --git a/tools/src/main/java/com/graphhopper/tools/Bzip2.java b/tools/src/main/java/com/graphhopper/tools/Bzip2.java
index f47d748caf..a950b48f46 100644
--- a/tools/src/main/java/com/graphhopper/tools/Bzip2.java
+++ b/tools/src/main/java/com/graphhopper/tools/Bzip2.java
@@ -18,9 +18,11 @@
 package com.graphhopper.tools;
 
 import com.graphhopper.util.Helper;
+
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
+
 import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;
 
 /**
diff --git a/tools/src/main/java/com/graphhopper/tools/Import.java b/tools/src/main/java/com/graphhopper/tools/Import.java
index c9b5a98195..1627869017 100644
--- a/tools/src/main/java/com/graphhopper/tools/Import.java
+++ b/tools/src/main/java/com/graphhopper/tools/Import.java
@@ -1,7 +1,6 @@
 package com.graphhopper.tools;
 
 import com.graphhopper.GraphHopper;
-import com.graphhopper.routing.util.RoutingAlgorithmSpecialAreaTests;
 import com.graphhopper.util.CmdArgs;
 
 /**
@@ -14,12 +13,6 @@ public static void main( String[] strs ) throws Exception
         CmdArgs args = CmdArgs.read(strs);
         GraphHopper hopper = new GraphHopper().init(args);
         hopper.importOrLoad();
-        if (args.getBool("graph.testIT", false))
-        {
-            // important: use osmreader.wayPointMaxDistance=0
-            RoutingAlgorithmSpecialAreaTests tests = new RoutingAlgorithmSpecialAreaTests(hopper);
-            tests.start();
-        }
         hopper.close();
     }
 }
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index 9041b3f8e7..e59b0004d6 100644
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -20,20 +20,17 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
+import com.graphhopper.coll.GHBitSet;
+import com.graphhopper.coll.GHBitSetImpl;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.RAMDirectory;
-import com.graphhopper.util.CmdArgs;
-import com.graphhopper.util.Constants;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.MiniPerfTest;
-import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
+
 import java.io.FileWriter;
 import java.io.IOException;
 import java.text.SimpleDateFormat;
@@ -44,6 +41,7 @@
 import java.util.TreeMap;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -56,6 +54,7 @@ public static void main( String[] strs )
     {
         new Measurement().start(CmdArgs.read(strs));
     }
+
     private static final Logger logger = LoggerFactory.getLogger(Measurement.class);
     private final Map<String, String> properties = new TreeMap<String, String>();
     private long seed;
@@ -79,12 +78,12 @@ public void doPostProcessing()
         {
             // re-create index to avoid bug as pickNode in locationIndex.prepare could be wrong while indexing if level is not taken into account and assumed to be 0 for pre-initialized graph            
             StopWatch sw = new StopWatch().start();
-            int edges = getGraph().getAllEdges().getMaxId();
-            initCHPrepare();
+            int edges = getGraph().getAllEdges().getCount();
+            setAlgorithmFactory(createPrepare());
             super.prepare();
             setLocationIndex(createLocationIndex(new RAMDirectory()));
             put("prepare.time", sw.stop().getTime());
-            put("prepare.shortcuts", getGraph().getAllEdges().getMaxId() - edges);
+            put("prepare.shortcuts", getGraph().getAllEdges().getCount() - edges);
         }
     }
 
@@ -108,7 +107,7 @@ void start( CmdArgs args )
         int count = args.getInt("measurement.count", 5000);
 
         MeasureHopper hopper = new MeasureHopper();
-        hopper.forDesktop().setEnableInstructions(false);
+        hopper.forDesktop();
         if (!hopper.load(graphLocation))
             throw new IllegalStateException("Cannot load existing levelgraph at " + graphLocation);
 
@@ -121,20 +120,22 @@ void start( CmdArgs args )
         try
         {
             maxNode = g.getNodes();
-            printGraphDetails(g);
+            GHBitSet allowedEdges = printGraphDetails(g, vehicleStr);
+            printMiscUnitPerfTests(hopper, vehicleStr, count * 100, allowedEdges);
             printLocationIndexQuery(g, hopper.getLocationIndex(), count);
 
             // Route via dijkstrabi. Normal routing takes a lot of time => smaller query number than CH
             // => values are not really comparable to routingCH as e.g. the mean distance etc is different            
             hopper.setCHEnable(false);
-            printTimeOfRouteQuery(hopper, count / 20, "routing", vehicleStr);
+            printTimeOfRouteQuery(hopper, count / 20, "routing", vehicleStr, true);
 
             System.gc();
 
             // route via CH. do preparation before                        
             hopper.setCHEnable(true);
             hopper.doPostProcessing();
-            printTimeOfRouteQuery(hopper, count, "routingCH", vehicleStr);
+            printTimeOfRouteQuery(hopper, count, "routingCH", vehicleStr, true);
+            printTimeOfRouteQuery(hopper, count, "routingCH_no_instr", vehicleStr, false);
             logger.info("store into " + propLocation);
         } catch (Exception ex)
         {
@@ -160,13 +161,23 @@ void start( CmdArgs args )
         }
     }
 
-    private void printGraphDetails( GraphStorage g )
+    private GHBitSet printGraphDetails( GraphStorage g, String vehicleStr )
     {
         // graph size (edge, node and storage size)
         put("graph.nodes", g.getNodes());
-        put("graph.edges", g.getAllEdges().getMaxId());
+        put("graph.edges", g.getAllEdges().getCount());
         put("graph.sizeInMB", g.getCapacity() / Helper.MB);
-        put("graph.encoder", g.getEncodingManager().getSingle().toString());
+        put("graph.encoder", vehicleStr);
+
+        AllEdgesIterator iter = g.getAllEdges();
+        final int maxEdgesId = g.getAllEdges().getCount();
+        final GHBitSet allowedEdges = new GHBitSetImpl(maxEdgesId);
+        while (iter.next())
+        {
+            allowedEdges.add(iter.getEdge());
+        }
+        put("graph.valid_edges", allowedEdges.getCardinality());
+        return allowedEdges;
     }
 
     private void printLocationIndexQuery( Graph g, final LocationIndex idx, int count )
@@ -194,7 +205,57 @@ public int doCalc( boolean warmup, int run )
         print("location2id", miniPerf);
     }
 
-    private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String prefix, final String vehicle )
+    private void printMiscUnitPerfTests( final GraphHopper hopper, String vehicle, int count,
+                                         final GHBitSet allowedEdges )
+    {
+        final Random rand = new Random(seed);
+        final GraphStorage graph = hopper.getGraph();
+
+        FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
+        EdgeFilter outFilter = new DefaultEdgeFilter(encoder, false, true);
+        final EdgeExplorer outExplorer = graph.createEdgeExplorer(outFilter);
+        MiniPerfTest miniPerf = new MiniPerfTest()
+        {
+            @Override
+            public int doCalc( boolean warmup, int run )
+            {
+                int nodeId = rand.nextInt(maxNode);
+                return GHUtility.count(outExplorer.setBaseNode(nodeId));
+            }
+        }.setIterations(count).start();
+        print("unit_tests.out_edge_state_next", miniPerf);
+
+        final EdgeExplorer allExplorer = graph.createEdgeExplorer();
+        miniPerf = new MiniPerfTest()
+        {
+            @Override
+            public int doCalc( boolean warmup, int run )
+            {
+                int nodeId = rand.nextInt(maxNode);
+                return GHUtility.count(allExplorer.setBaseNode(nodeId));
+            }
+        }.setIterations(count).start();
+        print("unit_tests.all_edge_state_next", miniPerf);
+
+        final int maxEdgesId = graph.getAllEdges().getCount();
+        miniPerf = new MiniPerfTest()
+        {
+            @Override
+            public int doCalc( boolean warmup, int run )
+            {
+                while (true)
+                {
+                    int edgeId = rand.nextInt(maxEdgesId);
+                    if (allowedEdges.contains(edgeId))
+                        return graph.getEdgeProps(edgeId, Integer.MIN_VALUE).getEdge();
+                }
+            }
+        }.setIterations(count).start();
+        print("unit_tests.get_edge_state", miniPerf);
+    }
+
+    private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String prefix,
+                                        final String vehicle, final boolean withInstructions )
     {
         final Graph g = hopper.getGraph();
         final AtomicLong maxDistance = new AtomicLong(0);
@@ -204,6 +265,7 @@ private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String
         final AtomicInteger failedCount = new AtomicInteger(0);
         final DistanceCalc distCalc = new DistanceCalcEarth();
 
+        final AtomicLong visitedNodesSum = new AtomicLong(0);
 //        final AtomicLong extractTimeSum = new AtomicLong(0);
 //        final AtomicLong calcPointsTimeSum = new AtomicLong(0);
 //        final AtomicLong calcDistTimeSum = new AtomicLong(0);
@@ -224,28 +286,33 @@ public int doCalc( boolean warmup, int run )
                 GHRequest req = new GHRequest(fromLat, fromLon, toLat, toLon).
                         setWeighting("fastest").
                         setVehicle(vehicle);
+                req.getHints().put("instructions", withInstructions);
                 GHResponse res;
                 try
                 {
                     res = hopper.route(req);
                 } catch (Exception ex)
                 {
+                    // 'not found' can happen if import creates more than one subnetwork
                     throw new RuntimeException("Error while calculating route! "
                             + "nodes:" + from + " -> " + to + ", request:" + req, ex);
                 }
 
                 if (res.hasErrors())
-                    throw new IllegalStateException("errors should NOT happen in Measurement! " + res.getErrors());
+                {
+                    if (!warmup)
+                        failedCount.incrementAndGet();
+
+                    if (!res.getErrors().get(0).getMessage().toLowerCase().contains("not found"))
+                        logger.error("errors should NOT happen in Measurement! " + req + " => " + res.getErrors());
+
+                    return 0;
+                }
 
                 if (!warmup)
                 {
+                    visitedNodesSum.addAndGet(res.getHints().getLong("visited_nodes.sum", 0));
                     long dist = (long) res.getDistance();
-                    if (dist < 1)
-                    {
-                        failedCount.incrementAndGet();
-                        return 0;
-                    }
-
                     distSum.addAndGet(dist);
 
                     airDistSum.addAndGet((long) distCalc.calcDist(fromLat, fromLon, toLat, toLon));
@@ -272,6 +339,7 @@ public int doCalc( boolean warmup, int run )
         put(prefix + ".distanceMean", (float) distSum.get() / count);
         put(prefix + ".airDistanceMean", (float) airDistSum.get() / count);
         put(prefix + ".distanceMax", maxDistance.get());
+        put(prefix + ".visitedNodesMean", (float) visitedNodesSum.get() / count);
 
 //        put(prefix + ".extractTime", (float) extractTimeSum.get() / count / 1000000f);
 //        put(prefix + ".calcPointsTime", (float) calcPointsTimeSum.get() / count / 1000000f);
@@ -281,7 +349,7 @@ public int doCalc( boolean warmup, int run )
 
     void print( String prefix, MiniPerfTest perf )
     {
-        logger.info(perf.getReport());
+        logger.info(prefix + ": " + perf.getReport());
         put(prefix + ".sum", perf.getSum());
 //        put(prefix+".rms", perf.getRMS());
         put(prefix + ".min", perf.getMin());
diff --git a/tools/src/main/java/com/graphhopper/tools/QueryTorture.java b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
index e15a43fc5a..617ccf9b80 100644
--- a/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
+++ b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
@@ -24,13 +24,15 @@
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.io.*;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
+import java.net.URLEncoder;
+import java.util.*;
+import java.util.Map.Entry;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.zip.GZIPInputStream;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -45,6 +47,7 @@ public static void main( String[] args )
     {
         new QueryTorture().start(CmdArgs.read(args));
     }
+
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private ExecutorService service;
     private BlockingQueue<Query> queryQueue;
@@ -59,6 +62,7 @@ public static void main( String[] args )
     private int readQueries;
     private int maxQueries;
     private int timeout;
+    private int statusUpdateCnt;
 
     public QueryTorture()
     {
@@ -71,6 +75,7 @@ public void start( CmdArgs read )
         baseUrl = read.get("baseurl", "");
         maxQueries = read.getInt("maxqueries", 1000);
         timeout = read.getInt("timeout", 3000);
+        statusUpdateCnt = maxQueries / 10;
         if (Helper.isEmpty(baseUrl))
             throw new IllegalArgumentException("baseUrl cannot be empty!?");
 
@@ -173,12 +178,17 @@ void execute( int workerNo ) throws InterruptedException
         Query query = queryQueue.take();
         try
         {
-            String url = baseUrl + query.queryString;
-            String res = new Downloader("QueryTorture!").setTimeout(timeout).downloadAsString(url);
+            String url = baseUrl + query.createQueryString();
+            String res = new Downloader("QueryTorture!").setTimeout(timeout).downloadAsString(url, false);
             if (res.contains("errors"))
                 routingErrorCounter.incrementAndGet();
             else
                 successfullQueries.incrementAndGet();
+
+            if (successfullQueries.get() % statusUpdateCnt == 0)
+            {
+                logger.info("progress: " + (int) (successfullQueries.get() * 100 / maxQueries) + "%");
+            }
         } catch (IOException ex)
         {
             // logger.error("Error while querying " + query.queryString, ex);
@@ -196,14 +206,18 @@ public void run()
             {
                 try
                 {
-                    BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(logFile), Helper.UTF_CS));
+                    InputStream is;
+                    if (logFile.endsWith(".gz"))
+                        is = new GZIPInputStream(new FileInputStream(logFile));
+                    else
+                        is = new FileInputStream(logFile);
+
+                    BufferedReader reader = new BufferedReader(new InputStreamReader(is, Helper.UTF_CS));
                     try
                     {
-                        int logLineNo = 0;
                         String logLine;
                         while ((logLine = reader.readLine()) != null)
                         {
-                            logLineNo++;
                             Query q = Query.parse(logLine);
                             if (q == null)
                                 continue;
@@ -234,7 +248,8 @@ public void run()
                 {
                     logger.error("Stopped reading logs", ex);
                     // do not wait, just shut down
-                    service.shutdownNow();
+                    if (service != null)
+                        service.shutdownNow();
                 }
             }
         }.start();
@@ -242,9 +257,10 @@ public void run()
 
     static class Query
     {
-        String queryString;
         GHPoint start;
         GHPoint end;
+        List<String> points = new ArrayList<String>();
+        Map<String, String> params = new HashMap<String, String>();
 
         static Query parse( String logLine )
         {
@@ -259,25 +275,32 @@ static Query parse( String logLine )
                 return null;
 
             Query q = new Query();
-            q.queryString = logLine.substring(0, index);
-
-            for (String param : q.queryString.split("\\&"))
+            String queryString = logLine.substring(0, index);
+            String[] tmpStrings = queryString.split("\\&");
+            for (String paramStr : tmpStrings)
             {
-                if (!param.startsWith("point="))
+                int equalIndex = paramStr.indexOf("=");
+                if (equalIndex <= 0)
                     continue;
 
-                param = param.replace("%2C", ",");
-                GHPoint point = GHPoint.parse(param.substring(6));
+                String key = paramStr.substring(0, equalIndex);
+                String value = paramStr.substring(equalIndex + 1);
+                if (!paramStr.startsWith("point="))
+                {
+                    q.params.put(key, value);
+                    continue;
+                }
+
+                value = value.replace("%2C", ",");
+                GHPoint point = GHPoint.parse(value);
                 if (point == null)
                     continue;
 
+                q.points.add(value);
                 if (q.start == null)
                     q.start = point;
                 else if (q.end == null)
-                {
                     q.end = point;
-                    break;
-                }
             }
             if (q.start != null && q.end != null)
                 return q;
@@ -285,31 +308,47 @@ else if (q.end == null)
             return null;
         }
 
-        @Override
-        public int hashCode()
+        public void put( String key, String value )
         {
-            int hash = 5;
-            hash = 47 * hash + (this.queryString != null ? this.queryString.hashCode() : 0);
-            return hash;
+            params.put(key, value);
         }
 
-        @Override
-        public boolean equals( Object obj )
+        public String createQueryString()
+        {
+            String qStr = "";
+            for (String pointStr : points)
+            {
+                if (!qStr.isEmpty())
+                    qStr += "&";
+
+                qStr += "point=" + pointStr;
+            }
+            for (Entry<String, String> e : params.entrySet())
+            {
+                if (!qStr.isEmpty())
+                    qStr += "&";
+
+                qStr += e.getKey() + "=" + encodeURL(e.getValue());
+            }
+
+            return qStr;
+        }
+
+        static String encodeURL( String str )
         {
-            if (obj == null)
-                return false;
-            if (getClass() != obj.getClass())
-                return false;
-            final Query other = (Query) obj;
-            if ((this.queryString == null) ? (other.queryString != null) : !this.queryString.equals(other.queryString))
-                return false;
-            return true;
+            try
+            {
+                return URLEncoder.encode(str, "UTF-8");
+            } catch (Exception _ignore)
+            {
+                return str;
+            }
         }
 
         @Override
         public String toString()
         {
-            return queryString;
+            return createQueryString();
         }
     }
 }
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugAStar.java b/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
index 94afcf8e3d..5895e43c5c 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
@@ -24,6 +24,7 @@
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIteratorState;
+
 import java.awt.Color;
 import java.awt.Graphics2D;
 
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java b/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
index f7872e7bcf..46e8609e85 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
@@ -24,6 +24,7 @@
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIteratorState;
+
 import java.awt.Color;
 import java.awt.Graphics2D;
 
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
index 0ee0376450..6288307fb7 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
@@ -24,6 +24,7 @@
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIteratorState;
+
 import java.awt.Color;
 import java.awt.Graphics2D;
 
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
index 3b6e1264fa..5896045b7d 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
@@ -24,6 +24,7 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.EdgeIteratorState;
+
 import java.awt.Color;
 import java.awt.Graphics2D;
 
diff --git a/tools/src/main/java/com/graphhopper/ui/DefaultMapLayer.java b/tools/src/main/java/com/graphhopper/ui/DefaultMapLayer.java
index 42595d979f..d62fa20563 100644
--- a/tools/src/main/java/com/graphhopper/ui/DefaultMapLayer.java
+++ b/tools/src/main/java/com/graphhopper/ui/DefaultMapLayer.java
@@ -20,6 +20,7 @@
 import java.awt.*;
 import java.awt.image.BufferedImage;
 import java.awt.image.RescaleOp;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -36,9 +37,9 @@
     // a bit transparent:
 //    private RescaleOp op = new RescaleOp(new float[]{1f, 1f, 1f, 0.5f}, new float[4], null);
     private RescaleOp op = new RescaleOp(new float[]
-    {
-        1f, 1f, 1f, 1f
-    }, new float[4], null);
+            {
+                    1f, 1f, 1f, 1f
+            }, new float[4], null);
 
     protected abstract void paintComponent( Graphics2D createGraphics );
 
diff --git a/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java b/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
index 635f2f76c4..0c853caa50 100644
--- a/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
+++ b/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
@@ -20,9 +20,11 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.shapes.BBox;
+
 import java.awt.BasicStroke;
 import java.awt.Color;
 import java.awt.Graphics2D;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -74,7 +76,7 @@ public void plotText( Graphics2D g2, double lat, double lon, String text )
         g2.drawString(text, (int) getX(lon) + 5, (int) getY(lat) + 5);
     }
 
-    public void plotEdge( Graphics2D g2, double lat, double lon, double lat2, double lon2, int width )
+    public void plotEdge( Graphics2D g2, double lat, double lon, double lat2, double lon2, float width )
     {
         g2.setStroke(new BasicStroke(width));
         g2.drawLine((int) getX(lon), (int) getY(lat), (int) getX(lon2), (int) getY(lat2));
@@ -126,6 +128,7 @@ public void plot( Graphics2D g2, double lat, double lon, int width )
         double y = getY(lat);
         g2.fillOval((int) x, (int) y, width, width);
     }
+
     private Logger logger = LoggerFactory.getLogger(getClass());
 
     void scale( int x, int y, boolean zoomIn )
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index 9e992feb2a..30587d2d51 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -20,8 +20,7 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHTBitSet;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.RoutingAlgorithm;
+import com.graphhopper.routing.*;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
@@ -30,10 +29,12 @@
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import gnu.trove.list.TIntList;
+
 import java.awt.*;
 import java.awt.event.*;
 import java.util.Random;
 import javax.swing.*;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -55,9 +56,10 @@ public static void main( String[] strs ) throws Exception
         boolean debug = args.getBool("minigraphui.debug", false);
         new MiniGraphUI(hopper, debug).visualize();
     }
+
     private Logger logger = LoggerFactory.getLogger(getClass());
     private Path path;
-    private AlgorithmPreparation prepare;
+    private RoutingAlgorithmFactory algoFactory;
     private final Graph graph;
     private final NodeAccess na;
     private LocationIndexTree index;
@@ -70,18 +72,18 @@ public static void main( String[] strs ) throws Exception
     private boolean fastPaint = false;
     private final Weighting weighting;
     private final FlagEncoder encoder;
+    private AlgorithmOptions algoOpts;
 
     public MiniGraphUI( GraphHopper hopper, boolean debug )
     {
         this.graph = hopper.getGraph();
         this.na = graph.getNodeAccess();
-        prepare = hopper.getPreparation();
-        encoder = hopper.getEncodingManager().getSingle();
+        algoFactory = hopper.getAlgorithmFactory();
+        encoder = hopper.getEncodingManager().getEncoder("car");
         weighting = hopper.createWeighting(new WeightingMap("fastest"), encoder);
-        if (prepare == null)
-            prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph, "dijkstrabi", encoder, weighting, TraversalMode.NODE_BASED);
+        algoOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
 
-        logger.info("locations:" + graph.getNodes() + ", debug:" + debug + ", algo:" + prepare.createAlgo().getName());
+        logger.info("locations:" + graph.getNodes() + ", debug:" + debug + ", algoOpts:" + algoOpts);
         mg = new GraphicsWrapper(graph);
 
         // prepare node quadtree to 'enter' the graph. create a 313*313 grid => <3km
@@ -147,6 +149,8 @@ public void paintComponent( Graphics2D g2 )
                 g2.setColor(Color.black);
 
                 EdgeExplorer explorer = graph.createEdgeExplorer(EdgeFilter.ALL_EDGES);
+                Color[] speedColors = generateColors(15);
+
                 for (int nodeIndex = 0; nodeIndex < locs; nodeIndex++)
                 {
                     if (fastPaint && rand.nextInt(30) > 1)
@@ -158,10 +162,10 @@ public void paintComponent( Graphics2D g2 )
                     if (lat < b.minLat || lat > b.maxLat || lon < b.minLon || lon > b.maxLon)
                         continue;
 
-                    EdgeIterator iter = explorer.setBaseNode(nodeIndex);
-                    while (iter.next())
+                    EdgeIterator edge = explorer.setBaseNode(nodeIndex);
+                    while (edge.next())
                     {
-                        int nodeId = iter.getAdjNode();
+                        int nodeId = edge.getAdjNode();
                         int sum = nodeIndex + nodeId;
                         if (fastPaint)
                         {
@@ -175,11 +179,49 @@ public void paintComponent( Graphics2D g2 )
 
                         // mg.plotText(g2, lat * 0.9 + lat2 * 0.1, lon * 0.9 + lon2 * 0.1, iter.getName());
                         //mg.plotText(g2, lat * 0.9 + lat2 * 0.1, lon * 0.9 + lon2 * 0.1, "s:" + (int) encoder.getSpeed(iter.getFlags()));
-                        //g2.setColor(Color.BLACK);                        
-                        mg.plotEdge(g2, lat, lon, lat2, lon2);
-                        g2.setColor(Color.BLACK);
+                        double speed = encoder.getSpeed(edge.getFlags());
+                        Color color;
+                        if (speed >= 120)
+                        {
+                            // red
+                            color = speedColors[12];
+                        } else if (speed >= 100)
+                        {
+                            color = speedColors[10];
+                        } else if (speed >= 80)
+                        {
+                            color = speedColors[8];
+                        } else if (speed >= 60)
+                        {
+                            color = speedColors[6];
+                        } else if (speed >= 50)
+                        {
+                            color = speedColors[5];
+                        } else if (speed >= 40)
+                        {
+                            color = speedColors[4];
+                        } else if (speed >= 30)
+                        {
+                            color = Color.GRAY;
+                        } else
+                        {
+                            color = Color.LIGHT_GRAY;
+                        }
+
+                        g2.setColor(color);
+                        mg.plotEdge(g2, lat, lon, lat2, lon2, 1.2f);
                     }
                 }
+
+                g2.setColor(Color.WHITE);
+                g2.fillRect(0, 0, 1000, 20);
+                for (int i = 4; i < speedColors.length; i++)
+                {
+                    g2.setColor(speedColors[i]);
+                    g2.drawString("" + (i * 10), i * 30 - 100, 10);
+                }
+
+                g2.setColor(Color.BLACK);
             }
         });
 
@@ -192,7 +234,8 @@ public void paintComponent( Graphics2D g2 )
                     return;
 
                 makeTransparent(g2);
-                RoutingAlgorithm algo = prepare.createAlgo();
+                QueryGraph qGraph = new QueryGraph(graph).lookup(fromRes, toRes);
+                RoutingAlgorithm algo = algoFactory.createAlgo(qGraph, algoOpts);
                 if (algo instanceof DebugAlgo)
                 {
                     ((DebugAlgo) algo).setGraphics2D(g2);
@@ -215,7 +258,7 @@ public void paintComponent( Graphics2D g2 )
 //                    mg.plotText(g2, lat, lon, nodeId + ": " + dist);
 //                    mg.plotNode(g2, nodeId, Color.red);
 //                }
-                path = algo.calcPath(fromRes, toRes);
+                path = algo.calcPath(fromRes.getClosestNode(), toRes.getClosestNode());
                 sw.stop();
 
                 // if directed edges
@@ -226,7 +269,7 @@ public void paintComponent( Graphics2D g2 )
                 }
 
                 logger.info("found path in " + sw.getSeconds() + "s with nodes:"
-                        + path.calcNodes().size() + ", millis: " + path.getMillis() + ", " + path);
+                        + path.calcNodes().size() + ", millis: " + path.getTime() + ", " + path);
                 g2.setColor(Color.BLUE.brighter().brighter());
                 plotPath(path, g2, 1);
             }
@@ -241,6 +284,16 @@ public void paintComponent( Graphics2D g2 )
         }
     }
 
+    public Color[] generateColors( int n )
+    {
+        Color[] cols = new Color[n];
+        for (int i = 0; i < n; i++)
+        {
+            cols[i] = Color.getHSBColor((float) i / (float) n, 0.85f, 1.0f);
+        }
+        return cols;
+    }
+
     // for debugging
     private Path calcPath( RoutingAlgorithm algo )
     {
@@ -299,6 +352,7 @@ private Path plotPath( Path tmpPath, Graphics2D g2, int w )
         logger.info("dist:" + tmpPath.getDistance() + ", path points(" + list.getSize() + "):" + list + ", nodes:" + nodes);
         return tmpPath;
     }
+
     private QueryResult fromRes;
     private QueryResult toRes;
 
@@ -379,6 +433,7 @@ public void mouseClicked( MouseEvent e )
 
                             fromDone = !fromDone;
                         }
+
                         boolean dragging = false;
 
                         @Override
@@ -449,6 +504,7 @@ public void mousePressed( MouseEvent e )
             throw new RuntimeException(ex);
         }
     }
+
     // for moving
     int currentPosX;
     int currentPosY;
diff --git a/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java b/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
index 708bb57c52..0fb4b7ccd2 100644
--- a/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
+++ b/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
@@ -19,10 +19,10 @@
 
 import com.graphhopper.tools.QueryTorture.Query;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class QueryTortureTest
@@ -31,7 +31,7 @@
     public void testGetQuery()
     {
         Query result = Query.parse("2013-08-07 18:06:50,905 [qtp1329318374-81] INFO  graphhopper.http.GraphHopperServlet - point=51.076329,13.738409&point=52.517037,13.38886&type=jsonp 46.4.67.134 en_US Wget/1.13.4 (linux-gnu) 51.076329, 13.738409->52.517037, 13.38886, distance: 189.4806800000001, time:123min, points:907, took:0.007393159, debug - idLookup:0.002483692s, algoInit:1.20837E-4s, dijkstraCH-routing:0.003138361s, extract time:1.66755E-4, simplify (1219->907):0.001040086s, instructions:2.26986E-4s, dijkstrabi, fastest, CAR");
-        assertEquals("point=51.076329,13.738409&point=52.517037,13.38886&type=jsonp", result.queryString);
+        assertEquals("point=51.076329,13.738409&point=52.517037,13.38886&type=jsonp", result.createQueryString());
         assertEquals(51.076329, result.start.lat, 1e-5);
         assertEquals(13.38886, result.end.lon, 1e-5);
     }
diff --git a/web/Readme.md b/web/Readme.md
deleted file mode 100644
index 498ba0e605..0000000000
--- a/web/Readme.md
+++ /dev/null
@@ -1,6 +0,0 @@
-This application uses jQuery and Leaflet to display the calculated route from GraphHopper.
-Execute `./graphhopper.sh web europe_germany_berlin.osm` in the parent folder. 
-Then go to [http://localhost:8989/](http://localhost:8989/).
-Get the raw json query [here](http://localhost:8989/route?from=52.439688,13.276863&to=52.532932,13.479424)
-
-[![GraphHopper Maps image](http://karussell.files.wordpress.com/2013/07/maps-preview1.png)](http://graphhopper.com/maps/?point=new%20york&point=los%20angeles)
\ No newline at end of file
diff --git a/web/pom.xml b/web/pom.xml
index e324010ffa..9c8651a013 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -6,14 +6,14 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-web</artifactId>
     <packaging>jar</packaging>
-    <version>0.4-SNAPSHOT</version>
+    <version>0.5-SNAPSHOT</version>
     <name>GraphHopper Web</name>
     <description>Example on how to use GraphHopper in a web-based application</description>
         
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.4-SNAPSHOT</version>
+        <version>0.5-SNAPSHOT</version>
     </parent>
     <properties>
         <jetty.version>8.1.16.v20140903</jetty.version>
@@ -28,21 +28,21 @@
         
         <dependency>
             <groupId>org.json</groupId>
-            <artifactId>json</artifactId>
-            <version>20140107</version>            
+            <artifactId>json</artifactId>            
+            <version>20140107</version>
         </dependency>    
         
         <dependency>
             <groupId>com.google.inject</groupId>
             <artifactId>guice</artifactId>
-            <version>3.0</version>
+            <version>4.0</version>
         </dependency>
         
         <!-- necessary to use guice ('@Inject') in servlets -->
         <dependency>
             <groupId>com.google.inject.extensions</groupId>
             <artifactId>guice-servlet</artifactId>
-            <version>3.0</version>
+            <version>4.0</version>
         </dependency>
                 
         <dependency>
@@ -94,34 +94,22 @@
             <version>${jetty.version}</version>
             <scope>test</scope>
         </dependency>
-        <!--
-        <dependency>
-            <groupId>org.apache.httpcomponents</groupId>
-            <artifactId>httpclient</artifactId>
-            <version>4.2.5</version>
-            <scope>test</scope>
-        </dependency>
-        -->
+      
     </dependencies>
 
     <build>
         <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.17</version>
-            </plugin>
             <!-- create a jar file too, so others can use it more easily -->
             <plugin>
-                <artifactId>maven-war-plugin</artifactId>
-                <version>2.4</version>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-war-plugin</artifactId>                
                 <configuration>
                     <attachClasses>true</attachClasses>
                 </configuration>
             </plugin>            
             <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-assembly-plugin</artifactId>
-                <version>2.4.1</version>
                 <configuration>
                     <archive>
                         <manifest>
@@ -144,52 +132,6 @@
                         </goals>
                     </execution>
                 </executions>
-
-<!--
-                <executions>
-                    <execution>
-                        <id>build-jar</id>
-                        <configuration>
-                            <archive>
-                                <manifest>
-                                    <mainClass>com.graphhopper.http.GHServer</mainClass>
-                                </manifest>
-                            </archive>
-                    
-                            <descriptorRefs>
-                                <descriptorRef>jar-with-dependencies</descriptorRef>
-                            </descriptorRefs>
-                        </configuration>
-                        <phase>package</phase>
-                        <goals>
-                            <goal>single</goal>
-                        </goals>                        
-                    </execution>
-                    <execution>
-                        <id>build-zip</id>
-                        
-                        <configuration>
-                            <appendAssemblyId>false</appendAssemblyId>
-                            <descriptors>
-                                <descriptor>src/main/assembly/zip.xml</descriptor>                                        
-                            </descriptors>                            
-                        </configuration>
-                        <phase>package</phase>
-                        <goals>
-                            <goal>single</goal>
-                        </goals>
-                    </execution>
-                </executions>
-                -->
-                <!--                <executions>
-                    <execution>
-                        <id>make-assembly</id>  this is used for inheritance merges 
-                        <phase>package</phase>  bind to the packaging phase 
-                        <goals>
-                            <goal>single</goal>
-                        </goals>
-                    </execution>
-                </executions>-->
             </plugin>
  
         </plugins>
diff --git a/web/src/main/java/com/graphhopper/http/CORSFilter.java b/web/src/main/java/com/graphhopper/http/CORSFilter.java
index c29d7c55f9..983887d767 100644
--- a/web/src/main/java/com/graphhopper/http/CORSFilter.java
+++ b/web/src/main/java/com/graphhopper/http/CORSFilter.java
@@ -23,6 +23,7 @@
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 import javax.servlet.http.HttpServletResponse;
+
 import org.eclipse.jetty.servlets.UserAgentFilter;
 
 /**
diff --git a/web/src/main/java/com/graphhopper/http/DefaultModule.java b/web/src/main/java/com/graphhopper/http/DefaultModule.java
index e7d44c7433..61e8f52dc0 100644
--- a/web/src/main/java/com/graphhopper/http/DefaultModule.java
+++ b/web/src/main/java/com/graphhopper/http/DefaultModule.java
@@ -31,7 +31,7 @@
 public class DefaultModule extends AbstractModule
 {
     private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final CmdArgs args;
+    protected final CmdArgs args;
     private GraphHopper graphHopper;
 
     public DefaultModule( CmdArgs args )
@@ -77,6 +77,8 @@ protected void configure()
                 logger.info("jsonp disabled");
 
             bind(Boolean.class).annotatedWith(Names.named("jsonpAllowed")).toInstance(jsonpAllowed);
+
+            bind(RouteSerializer.class).toInstance(new SimpleRouteSerializer(graphHopper.getGraph().getBounds()));
         } catch (Exception ex)
         {
             throw new IllegalStateException("Couldn't load graph", ex);
diff --git a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
index 07fe5d9f38..20597cafad 100644
--- a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
@@ -17,24 +17,30 @@
  */
 package com.graphhopper.http;
 
-import java.io.IOException;
-import javax.inject.Named;
-import javax.inject.Inject;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import org.json.JSONException;
 import org.json.JSONObject;
-import static javax.servlet.http.HttpServletResponse.*;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.inject.Inject;
+import javax.inject.Named;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
+import static javax.servlet.http.HttpServletResponse.SC_OK;
+
 /**
  * @author Peter Karich
  */
 public class GHBaseServlet extends HttpServlet
 {
-    protected Logger logger = LoggerFactory.getLogger(getClass());
+    protected static Logger logger = LoggerFactory.getLogger(GHBaseServlet.class);
     @Inject
     @Named("jsonpAllowed")
     private boolean jsonpAllowed;
@@ -49,54 +55,67 @@ protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONO
             res.setContentType("application/javascript");
             if (!jsonpAllowed)
             {
-                res.sendError(SC_BAD_REQUEST, "Server is not configured to allow jsonp!");
+                writeError(res, SC_BAD_REQUEST, "Server is not configured to allow jsonp!");
                 return;
             }
 
             String callbackName = getParam(req, "callback", null);
             if (callbackName == null)
             {
-                res.sendError(SC_BAD_REQUEST, "No callback provided, necessary if type=jsonp");
+                writeError(res, SC_BAD_REQUEST, "No callback provided, necessary if type=jsonp");
                 return;
             }
 
             if (debug)
-            {
                 writeResponse(res, callbackName + "(" + json.toString(2) + ")");
-            } else
-            {
+            else
                 writeResponse(res, callbackName + "(" + json.toString() + ")");
-            }
+
         } else
         {
             res.setContentType("application/json");
             if (debug)
-            {
                 writeResponse(res, json.toString(2));
-            } else
-            {
+            else
                 writeResponse(res, json.toString());
-            }
         }
     }
 
-    void returnError( HttpServletResponse res, String errorMessage ) throws IOException
+    protected void writeError( HttpServletResponse res, int code, String message )
     {
-        res.sendError(SC_BAD_REQUEST, errorMessage);
+        JSONObject json = new JSONObject();
+        json.put("message", message);
+        writeJsonError(res, code, json);
+    }
+
+    protected void writeJsonError( HttpServletResponse res, int code, JSONObject json )
+    {
+        try
+        {
+            // no type parameter check here as jsonp does not work if an error
+            // also no debug parameter yet
+            res.setContentType("application/json");
+            res.setCharacterEncoding("UTF-8");
+            res.setStatus(code);
+            res.getWriter().append(json.toString(2));
+        } catch (IOException ex)
+        {
+            logger.error("Cannot write error " + ex.getMessage());
+        }
     }
 
-    protected String getParam( HttpServletRequest req, String string, String _default )
+    protected String getParam( HttpServletRequest req, String key, String _default )
     {
-        String[] l = req.getParameterMap().get(string);
+        String[] l = req.getParameterMap().get(key);
         if (l != null && l.length > 0)
             return l[0];
 
         return _default;
     }
 
-    protected String[] getParams( HttpServletRequest req, String string )
+    protected String[] getParams( HttpServletRequest req, String key )
     {
-        String[] l = req.getParameterMap().get(string);
+        String[] l = req.getParameterMap().get(key);
         if (l != null && l.length > 0)
         {
             return l;
@@ -104,47 +123,51 @@ protected String getParam( HttpServletRequest req, String string, String _defaul
         return new String[0];
     }
 
-    protected long getLongParam( HttpServletRequest req, String string, long _default )
+    protected List<Double> getDoubleParamList( HttpServletRequest req, String key )
     {
-        try
-        {
-            return Long.parseLong(getParam(req, string, "" + _default));
-        } catch (Exception ex)
+        String[] l = req.getParameterMap().get(key);
+        if (l != null && l.length > 0)
         {
-            return _default;
+            ArrayList<Double> doubleList = new ArrayList<Double>(l.length);
+            for (String s : l)
+            {
+                doubleList.add(Double.valueOf(s));
+            }
+            return doubleList;
         }
+        return Collections.emptyList();
     }
 
-    protected boolean getBooleanParam( HttpServletRequest req, String string, boolean _default )
+    protected long getLongParam( HttpServletRequest req, String key, long _default )
     {
         try
         {
-            return Boolean.parseBoolean(getParam(req, string, "" + _default));
+            return Long.parseLong(getParam(req, key, "" + _default));
         } catch (Exception ex)
         {
             return _default;
         }
     }
 
-    protected double getDoubleParam( HttpServletRequest req, String string, double _default )
+    protected boolean getBooleanParam( HttpServletRequest req, String key, boolean _default )
     {
         try
         {
-            return Double.parseDouble(getParam(req, string, "" + _default));
+            return Boolean.parseBoolean(getParam(req, key, "" + _default));
         } catch (Exception ex)
         {
             return _default;
         }
     }
 
-    public void writeError( HttpServletResponse res, int code, String str )
+    protected double getDoubleParam( HttpServletRequest req, String key, double _default )
     {
         try
         {
-            res.sendError(code, str);
-        } catch (IOException ex)
+            return Double.parseDouble(getParam(req, key, "" + _default));
+        } catch (Exception ex)
         {
-            logger.error("Cannot write error " + code + " message:" + str, ex);
+            return _default;
         }
     }
 
diff --git a/web/src/main/java/com/graphhopper/http/GHErrorHandler.java b/web/src/main/java/com/graphhopper/http/GHErrorHandler.java
new file mode 100644
index 0000000000..4af5465de5
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/GHErrorHandler.java
@@ -0,0 +1,60 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import java.io.IOException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.ErrorHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * @author Peter Karich
+ */
+public class GHErrorHandler extends ErrorHandler
+{
+    private static final long serialVersionUID = 1L;
+    private final Logger logger = LoggerFactory.getLogger(GHErrorHandler.class);
+
+    @Override
+    public void handle( String str, Request req, HttpServletRequest httpReq, HttpServletResponse httpRes ) throws IOException
+    {
+        Throwable throwable = (Throwable) httpReq.getAttribute("javax.servlet.error.exception");
+        if (throwable != null)
+        {
+            String message = throwable.getMessage();
+            logger.error(message + ", via:" + httpReq.getRequestURL(), throwable);
+        } else
+        {
+            String message = (String) httpReq.getAttribute("javax.servlet.error.message");
+            if (message != null)
+            {
+                logger.error("Internal error " + message + "! Via:" + httpReq.getRequestURL());
+            } else
+            {
+                logger.error("Internal error " + str + ", throwable not known! Via:" + httpReq.getRequestURL());
+            }
+        }
+
+        // you can't call sendError( 500, "Server Error" ) without triggering Jetty's DefaultErrorHandler
+        httpRes.setStatus(SC_INTERNAL_SERVER_ERROR);
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/GHGZIPHook.java b/web/src/main/java/com/graphhopper/http/GHGZIPHook.java
index 828684f0d1..2f8e9250da 100644
--- a/web/src/main/java/com/graphhopper/http/GHGZIPHook.java
+++ b/web/src/main/java/com/graphhopper/http/GHGZIPHook.java
@@ -22,6 +22,7 @@
 import javax.servlet.ServletException;
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
+
 import org.eclipse.jetty.servlets.GzipFilter;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
diff --git a/web/src/main/java/com/graphhopper/http/GHServer.java b/web/src/main/java/com/graphhopper/http/GHServer.java
index 4a749c50ad..c3ceda83aa 100644
--- a/web/src/main/java/com/graphhopper/http/GHServer.java
+++ b/web/src/main/java/com/graphhopper/http/GHServer.java
@@ -23,12 +23,14 @@
 import com.google.inject.Module;
 import com.google.inject.servlet.GuiceFilter;
 import com.graphhopper.util.CmdArgs;
-import java.net.InetSocketAddress;
+
+
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.servlet.ServletHolder;
 
 import java.util.EnumSet;
 import javax.servlet.DispatcherType;
+
 import org.eclipse.jetty.server.Handler;
 import org.eclipse.jetty.server.handler.HandlerList;
 import org.eclipse.jetty.server.handler.ResourceHandler;
@@ -76,6 +78,7 @@ public void start( Injector injector ) throws Exception
         server = new Server();
         // getSessionHandler and getSecurityHandler should always return null
         ServletContextHandler servHandler = new ServletContextHandler(ServletContextHandler.NO_SECURITY | ServletContextHandler.NO_SESSIONS);
+        servHandler.setErrorHandler(new GHErrorHandler());
         servHandler.setContextPath("/");
 
         servHandler.addServlet(new ServletHolder(new InvalidRequestServlet()), "/*");
diff --git a/web/src/main/java/com/graphhopper/http/GHServletModule.java b/web/src/main/java/com/graphhopper/http/GHServletModule.java
index 1acbdc3b52..ce66e0ec7a 100644
--- a/web/src/main/java/com/graphhopper/http/GHServletModule.java
+++ b/web/src/main/java/com/graphhopper/http/GHServletModule.java
@@ -19,6 +19,7 @@
 
 import com.google.inject.servlet.ServletModule;
 import com.graphhopper.util.CmdArgs;
+
 import java.util.HashMap;
 import java.util.Map;
 import javax.inject.Singleton;
@@ -29,7 +30,7 @@
 public class GHServletModule extends ServletModule
 {
     protected Map<String, String> params = new HashMap<String, String>();
-    private final CmdArgs args;
+    protected final CmdArgs args;
 
     public GHServletModule( CmdArgs args )
     {
@@ -64,5 +65,8 @@ protected void configureServlets()
 
         serve("/route*").with(GraphHopperServlet.class);
         bind(GraphHopperServlet.class).in(Singleton.class);
+
+        serve("/nearest*").with(NearestServlet.class);
+        bind(NearestServlet.class).in(Singleton.class);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index 5ba54048bd..f8733bf554 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -18,89 +18,111 @@
 package com.graphhopper.http;
 
 import com.graphhopper.GHRequest;
-import com.graphhopper.GraphHopper;
 import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.WeightingMap;
-import com.graphhopper.util.*;
-import com.graphhopper.util.Helper;
+import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.GHPoint;
-import java.io.IOException;
-import java.io.StringWriter;
-import java.util.*;
-import java.util.Map.Entry;
+import org.json.JSONObject;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+
 import javax.inject.Inject;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import static javax.servlet.http.HttpServletResponse.*;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.transform.Transformer;
 import javax.xml.transform.TransformerFactory;
 import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.stream.StreamResult;
-import org.json.JSONObject;
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
+import java.io.IOException;
+import java.io.StringWriter;
+import java.util.*;
+import java.util.Map.Entry;
+
+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
 
 /**
- * Servlet to use GraphHopper in a remote application (mobile or browser). Attention: If type is
- * json it returns the points in GeoJson format (longitude,latitude) unlike the format "lat,lon"
- * used otherwise.
+ * Servlet to use GraphHopper in a remote client application like mobile or browser. Note: If type
+ * is json it returns the points in GeoJson format (longitude,latitude) unlike the format "lat,lon"
+ * used otherwise. See the full API response format in docs/web/api-doc.md
  * <p/>
+ *
  * @author Peter Karich
  */
 public class GraphHopperServlet extends GHBaseServlet
 {
     @Inject
     private GraphHopper hopper;
+    @Inject
+    private RouteSerializer routeSerializer;
 
     @Override
-    public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
+    public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) throws ServletException, IOException
     {
+        List<GHPoint> infoPoints = getPoints(httpReq, "point");
+        GHResponse ghRsp = new GHResponse();
+
+        // we can reduce the path length based on the maximum differences to the original coordinates
+        double minPathPrecision = getDoubleParam(httpReq, "way_point_max_distance", 1d);
+        boolean writeGPX = "gpx".equalsIgnoreCase(getParam(httpReq, "type", "json"));
+        boolean enableInstructions = writeGPX || getBooleanParam(httpReq, "instructions", true);
+        boolean calcPoints = getBooleanParam(httpReq, "calc_points", true);
+        boolean enableElevation = getBooleanParam(httpReq, "elevation", false);
+        boolean pointsEncoded = getBooleanParam(httpReq, "points_encoded", true);
+
+        String vehicleStr = getParam(httpReq, "vehicle", "car");
+        String weighting = getParam(httpReq, "weighting", "fastest");
+        String algoStr = getParam(httpReq, "algorithm", "");
+        String localeStr = getParam(httpReq, "locale", "en");
+        List<Double> favoredHeadings = Collections.EMPTY_LIST;
         try
         {
-            writePath(req, res);
-        } catch (IllegalArgumentException ex)
-        {
-            writeError(res, SC_BAD_REQUEST, ex.getMessage());
-        } catch (Exception ex)
+            favoredHeadings = getDoubleParamList(httpReq, "heading");
+
+        } catch (java.lang.NumberFormatException e)
         {
-            logger.error("Error while executing request: " + req.getQueryString(), ex);
-            writeError(res, SC_INTERNAL_SERVER_ERROR, "Problem occured:" + ex.getMessage());
+            throw new RuntimeException(e);
         }
-    }
-
-    void writePath( HttpServletRequest req, HttpServletResponse res ) throws Exception
-    {
-        List<GHPoint> infoPoints = getPoints(req);
-
-        // we can reduce the path length based on the maximum differences to the original coordinates
-        double minPathPrecision = getDoubleParam(req, "way_point_max_distance", 1d);
-        boolean writeGPX = "gpx".equalsIgnoreCase(getParam(req, "type", "json"));
-        boolean enableInstructions = writeGPX || getBooleanParam(req, "instructions", true);
-        boolean calcPoints = getBooleanParam(req, "calc_points", true);
-        boolean elevation = getBooleanParam(req, "elevation", false);
-        String vehicleStr = getParam(req, "vehicle", "CAR").toUpperCase();
-        String weighting = getParam(req, "weighting", "fastest");
-        String algoStr = getParam(req, "algorithm", "");
-        String localeStr = getParam(req, "locale", "en");
 
         StopWatch sw = new StopWatch().start();
-        GHResponse ghRsp;
         if (!hopper.getEncodingManager().supports(vehicleStr))
         {
-            ghRsp = new GHResponse().addError(new IllegalArgumentException("Vehicle not supported: " + vehicleStr));
-        } else if (elevation && !hopper.hasElevation())
+            ghRsp.addError(new IllegalArgumentException("Vehicle not supported: " + vehicleStr));
+        } else if (enableElevation && !hopper.hasElevation())
         {
-            ghRsp = new GHResponse().addError(new IllegalArgumentException("Elevation not supported!"));
-        } else
+            ghRsp.addError(new IllegalArgumentException("Elevation not supported!"));
+        } else if (favoredHeadings.size() > 1 && favoredHeadings.size() != infoPoints.size())
+        {
+            ghRsp.addError(new IllegalArgumentException("number of headings must be <= 1 or equal number of points"));
+        }
+        if (!ghRsp.hasErrors())
         {
             FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
-            GHRequest request = new GHRequest(infoPoints);
 
-            initHints(request, req.getParameterMap());
+            GHRequest request;
+            if (favoredHeadings.size() > 0)
+            {
+                // if only one favored heading is specified take as start heading
+                if (favoredHeadings.size() == 1)
+                {
+                    List<Double> paddedHeadings = new ArrayList<Double>(Collections.nCopies(infoPoints.size(),
+                            Double.NaN));
+                    paddedHeadings.set(0, favoredHeadings.get(0));
+                    request = new GHRequest(infoPoints, paddedHeadings);
+                } else
+                {
+                    request = new GHRequest(infoPoints, favoredHeadings);
+                }
+            } else
+            {
+                request = new GHRequest(infoPoints);
+            }
+
+            initHints(request, httpReq.getParameterMap());
             request.setVehicle(algoVehicle.toString()).
                     setWeighting(weighting).
                     setAlgorithm(algoStr).
@@ -114,158 +136,122 @@ void writePath( HttpServletRequest req, HttpServletResponse res ) throws Excepti
         }
 
         float took = sw.stop().getSeconds();
-        String infoStr = req.getRemoteAddr() + " " + req.getLocale() + " " + req.getHeader("User-Agent");
-        PointList points = ghRsp.getPoints();
-        String logStr = req.getQueryString() + " " + infoStr + " " + infoPoints
-                + ", distance: " + ghRsp.getDistance() + ", time:" + Math.round(ghRsp.getMillis() / 60000f)
-                + "min, points:" + points.getSize() + ", took:" + took
-                + ", debug - " + ghRsp.getDebugInfo() + ", " + algoStr + ", "
-                + weighting + ", " + vehicleStr;
+        String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " " + httpReq.getHeader("User-Agent");
+        String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
+                + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
+        httpRes.setHeader("X-GH-Took", "" + Math.round(took * 1000));
 
         if (ghRsp.hasErrors())
             logger.error(logStr + ", errors:" + ghRsp.getErrors());
         else
-            logger.info(logStr);
+            logger.info(logStr + ", distance: " + ghRsp.getDistance()
+                    + ", time:" + Math.round(ghRsp.getTime() / 60000f)
+                    + "min, points:" + ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
 
         if (writeGPX)
-            writeResponse(res, createGPXString(req, res, ghRsp));
-        else
-            writeJson(req, res, new JSONObject(createJson(req, ghRsp, took)));
+        {
+            String xml = createGPXString(httpReq, httpRes, ghRsp);
+            if (ghRsp.hasErrors())
+            {
+                httpRes.setStatus(SC_BAD_REQUEST);
+                httpRes.getWriter().append(xml);
+            } else
+            {
+                writeResponse(httpRes, xml);
+            }
+        } else
+        {
+            Map<String, Object> map = routeSerializer.toJSON(ghRsp, calcPoints, pointsEncoded,
+                    enableElevation, enableInstructions);
+
+            // deprecated - remove in 0.5
+            Object infoMap = map.get("info");
+            if (infoMap != null)
+                ((Map) infoMap).put("took", Math.round(took * 1000));
+
+            if (ghRsp.hasErrors())
+                writeJsonError(httpRes, SC_BAD_REQUEST, new JSONObject(map));
+            else
+                writeJson(httpReq, httpRes, new JSONObject(map));
+        }
     }
 
     protected String createGPXString( HttpServletRequest req, HttpServletResponse res, GHResponse rsp )
-            throws Exception
     {
         boolean includeElevation = getBooleanParam(req, "elevation", false);
         res.setCharacterEncoding("UTF-8");
         res.setContentType("application/xml");
         String trackName = getParam(req, "track", "GraphHopper Track");
         res.setHeader("Content-Disposition", "attachment;filename=" + "GraphHopper.gpx");
-        String timeZone = getParam(req, "timezone", "GMT");
         long time = getLongParam(req, "millis", System.currentTimeMillis());
         if (rsp.hasErrors())
             return errorsToXML(rsp.getErrors());
         else
-            return rsp.getInstructions().createGPX(trackName, time, timeZone, includeElevation);
+            return rsp.getInstructions().createGPX(trackName, time, includeElevation);
     }
 
-    String errorsToXML( List<Throwable> list ) throws Exception
+    String errorsToXML( List<Throwable> list )
     {
-        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-        DocumentBuilder builder = factory.newDocumentBuilder();
-        Document doc = builder.newDocument();
-        Element gpxElement = doc.createElement("gpx");
-        gpxElement.setAttribute("creator", "GraphHopper");
-        gpxElement.setAttribute("version", "1.1");
-        doc.appendChild(gpxElement);
+        try
+        {
+            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            Document doc = builder.newDocument();
+            Element gpxElement = doc.createElement("gpx");
+            gpxElement.setAttribute("creator", "GraphHopper");
+            gpxElement.setAttribute("version", "1.1");
+            doc.appendChild(gpxElement);
 
-        Element mdElement = doc.createElement("metadata");
-        gpxElement.appendChild(mdElement);
+            Element mdElement = doc.createElement("metadata");
+            gpxElement.appendChild(mdElement);
 
-        Element errorsElement = doc.createElement("extensions");
-        mdElement.appendChild(errorsElement);
+            Element extensionsElement = doc.createElement("extensions");
+            mdElement.appendChild(extensionsElement);
 
-        for (Throwable t : list)
-        {
-            Element error = doc.createElement("error");
-            errorsElement.appendChild(error);
-            error.setAttribute("message", t.getMessage());
-            error.setAttribute("details", t.getClass().getName());
-        }
-        TransformerFactory transformerFactory = TransformerFactory.newInstance();
-        Transformer transformer = transformerFactory.newTransformer();
-        StringWriter writer = new StringWriter();
-        transformer.transform(new DOMSource(doc), new StreamResult(writer));
-        return writer.toString();
-    }
+            Element messageElement = doc.createElement("message");
+            extensionsElement.appendChild(messageElement);
+            messageElement.setTextContent(list.get(0).getMessage());
 
-    protected Map<String, Object> createJson( HttpServletRequest req, GHResponse rsp, float took )
-    {
-        boolean enableInstructions = getBooleanParam(req, "instructions", true);
-        boolean pointsEncoded = getBooleanParam(req, "points_encoded", true);
-        boolean calcPoints = getBooleanParam(req, "calc_points", true);
-        boolean includeElevation = getBooleanParam(req, "elevation", false);
-        Map<String, Object> json = new HashMap<String, Object>();
-        Map<String, Object> jsonInfo = new HashMap<String, Object>();
-        json.put("info", jsonInfo);
-        jsonInfo.put("copyrights", Arrays.asList("GraphHopper", "OpenStreetMap contributors"));
+            Element hintsElement = doc.createElement("hints");
+            extensionsElement.appendChild(hintsElement);
 
-        if (rsp.hasErrors())
-        {
-            List<Map<String, String>> list = new ArrayList<Map<String, String>>();
-            for (Throwable t : rsp.getErrors())
+            for (Throwable t : list)
             {
-                Map<String, String> map = new HashMap<String, String>();
-                map.put("message", t.getMessage());
-                map.put("details", t.getClass().getName());
-                list.add(map);
+                Element error = doc.createElement("error");
+                hintsElement.appendChild(error);
+                error.setAttribute("message", t.getMessage());
+                error.setAttribute("details", t.getClass().getName());
             }
-            jsonInfo.put("errors", list);
-        } else if (!rsp.isFound())
-        {
-            Map<String, String> map = new HashMap<String, String>();
-            map.put("message", "Not found");
-            map.put("details", "");
-            jsonInfo.put("errors", Collections.singletonList(map));
-        } else
+            TransformerFactory transformerFactory = TransformerFactory.newInstance();
+            Transformer transformer = transformerFactory.newTransformer();
+            StringWriter writer = new StringWriter();
+            transformer.transform(new DOMSource(doc), new StreamResult(writer));
+            return writer.toString();
+        } catch (Exception ex)
         {
-            jsonInfo.put("took", Math.round(took * 1000));
-            Map<String, Object> jsonPath = new HashMap<String, Object>();
-            jsonPath.put("distance", Helper.round(rsp.getDistance(), 3));
-            jsonPath.put("weight", Helper.round6(rsp.getDistance()));
-            jsonPath.put("time", rsp.getMillis());
-
-            if (calcPoints)
-            {
-                jsonPath.put("points_encoded", pointsEncoded);
-
-                PointList points = rsp.getPoints();
-                if (points.getSize() >= 2)
-                    jsonPath.put("bbox", rsp.calcRouteBBox(hopper.getGraph().getBounds()).toGeoJson());
-
-                jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
-
-                if (enableInstructions)
-                {
-                    InstructionList instructions = rsp.getInstructions();
-                    jsonPath.put("instructions", instructions.createJson());
-                }
-            }
-            json.put("paths", Collections.singletonList(jsonPath));
+            throw new RuntimeException(ex);
         }
-        return json;
-    }
-
-    protected Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
-    {
-        if (pointsEncoded)
-            return WebHelper.encodePolyline(points, includeElevation);
-
-        Map<String, Object> jsonPoints = new HashMap<String, Object>();
-        jsonPoints.put("type", "LineString");
-        jsonPoints.put("coordinates", points.toGeoJson(includeElevation));
-        return jsonPoints;
     }
 
-    private List<GHPoint> getPoints( HttpServletRequest req ) throws IOException
+    protected List<GHPoint> getPoints( HttpServletRequest req, String key )
     {
-        String[] pointsAsStr = getParams(req, "point");
+        String[] pointsAsStr = getParams(req, key);
         final List<GHPoint> infoPoints = new ArrayList<GHPoint>(pointsAsStr.length);
         for (String str : pointsAsStr)
         {
             String[] fromStrs = str.split(",");
             if (fromStrs.length == 2)
             {
-                GHPoint place = GHPoint.parse(str);
-                if (place != null)
-                    infoPoints.add(place);
+                GHPoint point = GHPoint.parse(str);
+                if (point != null)
+                    infoPoints.add(point);
             }
         }
 
         return infoPoints;
     }
 
-    private void initHints( GHRequest request, Map<String, String[]> parameterMap )
+    protected void initHints( GHRequest request, Map<String, String[]> parameterMap )
     {
         WeightingMap m = request.getHints();
         for (Entry<String, String[]> e : parameterMap.entrySet())
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
index 4730e231aa..f75bdfee4a 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
@@ -22,34 +22,28 @@
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+
+import java.util.List;
+
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * Main wrapper of the offline API for a simple and efficient usage.
+ * Main wrapper of the GraphHopper Directions API for a simple and efficient usage.
  * <p/>
  * @author Peter Karich
  */
 public class GraphHopperWeb implements GraphHopperAPI
 {
-    public static void main( String[] args )
-    {
-        GraphHopperAPI gh = new GraphHopperWeb();
-        gh.load("http://localhost:8989/route");
-        //GHResponse ph = gh.route(new GHRequest(53.080827, 9.074707, 50.597186, 11.184082));
-        GHResponse ph = gh.route(new GHRequest(49.6724, 11.3494, 49.6550, 11.4180));
-        System.out.println(ph);
-    }
     private final Logger logger = LoggerFactory.getLogger(getClass());
-    private String serviceUrl;
-    private boolean pointsEncoded = true;
-    private Downloader downloader = new Downloader("GraphHopperWeb");
-    private boolean instructions = true;
+    private Downloader downloader = new Downloader("GraphHopper Java Client");
+    private String routeServiceUrl = "https://graphhopper.com/api/1/route";
     private String key = "";
-    private boolean withElevation = false;
-    private final TranslationMap trMap = new TranslationMap().doImport();
+    private boolean instructions = true;
+    private boolean calcPoints = true;
+    private boolean elevation = false;
 
     public GraphHopperWeb()
     {
@@ -60,45 +54,44 @@ public void setDownloader( Downloader downloader )
         this.downloader = downloader;
     }
 
-    /**
-     * Example url: http://localhost:8989 or http://217.92.216.224:8080
-     */
     @Override
-    public boolean load( String url )
+    public boolean load( String serviceUrl )
     {
-        this.serviceUrl = url;
+        this.routeServiceUrl = serviceUrl;
         return true;
     }
 
-    public GraphHopperWeb setPointsEncoded( boolean b )
+    public GraphHopperWeb setKey( String key )
     {
-        pointsEncoded = b;
+        if (key == null || key.isEmpty())
+            throw new IllegalStateException("Key cannot be empty");
+
+        this.key = key;
         return this;
     }
 
-    public GraphHopperWeb setInstructions( boolean b )
+    public GraphHopperWeb setCalcPoints( boolean calcPoints )
     {
-        instructions = b;
+        this.calcPoints = calcPoints;
         return this;
     }
 
-    public GraphHopperWeb setElevation( boolean withElevation )
+    public GraphHopperWeb setInstructions( boolean b )
     {
-        this.withElevation = withElevation;
+        instructions = b;
         return this;
     }
 
-    public GraphHopperWeb setKey( String key )
+    public GraphHopperWeb setElevation( boolean withElevation )
     {
-        this.key = key;
+        this.elevation = withElevation;
         return this;
     }
 
     @Override
     public GHResponse route( GHRequest request )
     {
-        StopWatch sw = new StopWatch().start();
-        double took = 0;
+        StopWatch sw = new StopWatch().start();        
         try
         {
             String places = "";
@@ -107,120 +100,175 @@ public GHResponse route( GHRequest request )
                 places += "point=" + p.lat + "," + p.lon + "&";
             }
 
-            String url = serviceUrl
+            boolean tmpInstructions = request.getHints().getBool("instructions", instructions);
+            boolean tmpCalcPoints = request.getHints().getBool("calcPoints", calcPoints);
+
+            if (tmpInstructions && !tmpCalcPoints)
+                throw new IllegalStateException("Cannot calculate instructions without points (only points without instructions). "
+                        + "Use calcPoints=false and instructions=false to disable point and instruction calculation");
+
+            boolean tmpElevation = request.getHints().getBool("elevation", elevation);
+            String tmpKey = request.getHints().get("key", key);
+
+            String url = routeServiceUrl
                     + "?"
                     + places
                     + "&type=json"
-                    + "&points_encoded=" + pointsEncoded
-                    + "&way_point_max_distance=" + request.getHints().getDouble("wayPointMaxDistance", 1)
+                    + "&instructions=" + tmpInstructions
+                    + "&points_encoded=true"
+                    + "&calc_points=" + tmpCalcPoints
                     + "&algo=" + request.getAlgorithm()
                     + "&locale=" + request.getLocale().toString()
-                    + "&elevation=" + withElevation;
+                    + "&elevation=" + tmpElevation;
 
             if (!request.getVehicle().isEmpty())
                 url += "&vehicle=" + request.getVehicle();
 
-            if (!key.isEmpty())
-                url += "&key=" + key;
+            if (!tmpKey.isEmpty())
+                url += "&key=" + tmpKey;
 
-            String str = downloader.downloadAsString(url);
+            String str = downloader.downloadAsString(url, true);
             JSONObject json = new JSONObject(str);
+
             GHResponse res = new GHResponse();
+            readErrors(res.getErrors(), json);
+            if (res.hasErrors())
+                return res;
+            
+            JSONArray paths = json.getJSONArray("paths");
+            JSONObject firstPath = paths.getJSONObject(0);
+            readPath(res, firstPath, tmpCalcPoints, tmpInstructions, tmpElevation);
+            return res;
+
+        } catch (Exception ex)
+        {
+            throw new RuntimeException("Problem while fetching path " + request.getPoints() + ": " + ex.getMessage(), ex);
+        }
+    }
+
+    public static void readPath( GHResponse res, JSONObject firstPath,
+                                 boolean tmpCalcPoints,
+                                 boolean tmpInstructions,
+                                 boolean tmpElevation )
+    {
+        double distance = firstPath.getDouble("distance");
+        long time = firstPath.getLong("time");
+        if (tmpCalcPoints)
+        {
+            String pointStr = firstPath.getString("points");
+            PointList pointList = WebHelper.decodePolyline(pointStr, 100, tmpElevation);
+            res.setPoints(pointList);
 
-            if (json.getJSONObject("info").has("errors"))
+            if (tmpInstructions)
             {
-                JSONArray errors = json.getJSONObject("info").getJSONArray("errors");
+                JSONArray instrArr = firstPath.getJSONArray("instructions");
 
-                for (int i = 0; i < errors.length(); i++)
+                InstructionList il = new InstructionList(null);
+                int viaCount = 1;
+                for (int instrIndex = 0; instrIndex < instrArr.length(); instrIndex++)
                 {
-                    JSONObject error = errors.getJSONObject(i);
-                    String exClass = error.getString("details");
-                    String exMessage = error.getString("message");
+                    JSONObject jsonObj = instrArr.getJSONObject(instrIndex);
+                    double instDist = jsonObj.getDouble("distance");
+                    String text = jsonObj.getString("text");
+                    long instTime = jsonObj.getLong("time");
+                    int sign = jsonObj.getInt("sign");
+                    JSONArray iv = jsonObj.getJSONArray("interval");
+                    int from = iv.getInt(0);
+                    int to = iv.getInt(1);
+                    PointList instPL = new PointList(to - from, tmpElevation);
+                    for (int j = from; j <= to; j++)
+                    {
+                        instPL.add(pointList, j);
+                    }
 
-                    if (exClass.equals(UnsupportedOperationException.class.getName()))
+                    InstructionAnnotation ia = InstructionAnnotation.EMPTY;
+                    if (jsonObj.has("annotation_importance") && jsonObj.has("annotation_text"))
                     {
-                        res.addError(new UnsupportedOperationException(exMessage));
-                    } else if (exClass.equals(IllegalStateException.class.getName()))
+                        ia = new InstructionAnnotation(jsonObj.getInt("annotation_importance"), jsonObj.getString("annotation_text"));
+                    }
+
+                    Instruction instr;
+                    if (sign == Instruction.USE_ROUNDABOUT || sign == Instruction.LEAVE_ROUNDABOUT)
                     {
-                        res.addError(new IllegalStateException(exMessage));
-                    } else if (exClass.equals(RuntimeException.class.getName()))
+                        instr = new RoundaboutInstruction(sign, text, ia, instPL);
+                    } else if (sign == Instruction.REACHED_VIA)
                     {
-                        res.addError(new RuntimeException(exMessage));
-                    } else if (exClass.equals(IllegalArgumentException.class.getName()))
+                        ViaInstruction tmpInstr = new ViaInstruction(text, ia, instPL);
+                        tmpInstr.setViaCount(viaCount);
+                        viaCount++;
+                        instr = tmpInstr;
+                    } else if (sign == Instruction.FINISH)
                     {
-                        res.addError(new IllegalArgumentException(exMessage));
+                        instr = new FinishInstruction(instPL, 0);
                     } else
                     {
-                        res.addError(new Exception(exClass + " " + exMessage));
+                        instr = new Instruction(sign, text, ia, instPL);
                     }
-                }
 
-                return res;
+                    // The translation is done from the routing service so just use the provided string
+                    // instead of creating a combination with sign and name etc
+                    instr.setUseRawName();
 
-            } else
-            {
-                took = json.getJSONObject("info").getDouble("took");
-                JSONArray paths = json.getJSONArray("paths");
-                JSONObject firstPath = paths.getJSONObject(0);
-                double distance = firstPath.getDouble("distance");
-                int time = firstPath.getInt("time");
-                PointList pointList;
-                if (pointsEncoded)
-                {
-                    String pointStr = firstPath.getString("points");
-                    pointList = WebHelper.decodePolyline(pointStr, 100, withElevation);
-                } else
-                {
-                    JSONArray coords = firstPath.getJSONObject("points").getJSONArray("coordinates");
-                    pointList = new PointList(coords.length(), withElevation);
-                    for (int i = 0; i < coords.length(); i++)
-                    {
-                        JSONArray arr = coords.getJSONArray(i);
-                        double lon = arr.getDouble(0);
-                        double lat = arr.getDouble(1);
-                        if (withElevation)
-                            pointList.add(lat, lon, arr.getDouble(2));
-                        else
-                            pointList.add(lat, lon);
-                    }
+                    instr.setDistance(instDist).setTime(instTime);
+                    il.add(instr);
                 }
+                res.setInstructions(il);
+            }
+        }
+        res.setDistance(distance).setTime(time);
+    }
 
-                if (instructions)
-                {
-                    JSONArray instrArr = firstPath.getJSONArray("instructions");
+    public static void readErrors( List<Throwable> errors, JSONObject json )
+    {
+        JSONArray errorJson;
 
-                    InstructionList il = new InstructionList(trMap.getWithFallBack(request.getLocale()));
-                    for (int instrIndex = 0; instrIndex < instrArr.length(); instrIndex++)
-                    {
-                        JSONObject jsonObj = instrArr.getJSONObject(instrIndex);
-                        double instDist = jsonObj.getDouble("distance");
-                        String text = jsonObj.getString("text");
-                        long instTime = jsonObj.getLong("time");
-                        int sign = jsonObj.getInt("sign");
-                        JSONArray iv = jsonObj.getJSONArray("interval");
-                        int from = iv.getInt(0);
-                        int to = iv.getInt(1);
-                        PointList instPL = new PointList(to - from, withElevation);
-                        for (int j = from; j <= to; j++)
-                        {
-                            instPL.add(pointList, j);
-                        }
-
-                        // TODO way and payment type
-                        Instruction instr = new Instruction(sign, text, InstructionAnnotation.EMPTY, instPL).
-                                setDistance(instDist).setTime(instTime);
-                        il.add(instr);
-                    }
-                    res.setInstructions(il);
-                }
-                return res.setPoints(pointList).setDistance(distance).setMillis(time);
+        if (json.has("message"))
+        {
+            if (json.has("hints"))
+            {
+                errorJson = json.getJSONArray("hints");
+            } else
+            {
+                // should not happen
+                errors.add(new RuntimeException(json.getString("message")));
+                return;
             }
-        } catch (Exception ex)
+        } else if (json.has("info"))
         {
-            throw new RuntimeException("Problem while fetching path " + request.getPoints() + ": " + ex.getMessage(), ex);
-        } finally
+            // deprecated JSON format for errors, remove in 0.5 release
+            JSONObject jsonInfo = json.getJSONObject("info");
+            if (jsonInfo.has("errors"))
+                errorJson = jsonInfo.getJSONArray("errors");
+            else
+                return;
+
+        } else
+            return;
+
+        for (int i = 0; i < errorJson.length(); i++)
         {
-            logger.debug("Full request took:" + sw.stop().getSeconds() + ", API took:" + took);
+            JSONObject error = errorJson.getJSONObject(i);
+            String exClass = "";
+            if (error.has("details"))
+                exClass = error.getString("details");
+
+            String exMessage = error.getString("message");
+
+            if (exClass.equals(UnsupportedOperationException.class.getName()))
+                errors.add(new UnsupportedOperationException(exMessage));
+            else if (exClass.equals(IllegalStateException.class.getName()))
+                errors.add(new IllegalStateException(exMessage));
+            else if (exClass.equals(RuntimeException.class.getName()))
+                errors.add(new RuntimeException(exMessage));
+            else if (exClass.equals(IllegalArgumentException.class.getName()))
+                errors.add(new IllegalArgumentException(exMessage));
+            else if (exClass.isEmpty())
+                errors.add(new RuntimeException(exMessage));
+            else
+                errors.add(new RuntimeException(exClass + " " + exMessage));
         }
+
+        if (json.has("message") && errors.isEmpty())
+            errors.add(new RuntimeException(json.getString("message")));
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/I18NServlet.java b/web/src/main/java/com/graphhopper/http/I18NServlet.java
index 833246508a..46777addb3 100644
--- a/web/src/main/java/com/graphhopper/http/I18NServlet.java
+++ b/web/src/main/java/com/graphhopper/http/I18NServlet.java
@@ -20,13 +20,14 @@
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.TranslationMap;
 import com.graphhopper.util.Translation;
+
 import java.io.IOException;
 import java.util.Locale;
 import javax.inject.Inject;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import static javax.servlet.http.HttpServletResponse.*;
+
 import org.json.JSONObject;
 
 /**
@@ -40,33 +41,26 @@
     @Override
     public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
     {
-        try
-        {
-            String locale = "";
-            String path = req.getPathInfo();
-            if (!Helper.isEmpty(path) && path.startsWith("/"))
-                locale = path.substring(1);
-
-            if (Helper.isEmpty(locale))
-            {
-                // fall back to language specified in header e.g. via browser settings
-                String acceptLang = req.getHeader("Accept-Language");
-                if (!Helper.isEmpty(acceptLang))
-                    locale = acceptLang.split(",")[0];
-            }
+        String locale = "";
+        String path = req.getPathInfo();
+        if (!Helper.isEmpty(path) && path.startsWith("/"))
+            locale = path.substring(1);
 
-            Translation tr = map.get(locale);
-            JSONObject json = new JSONObject();
-            if (tr != null && !Locale.US.equals(tr.getLocale()))
-                json.put("default", tr.asMap());
-
-            json.put("locale", locale.toString());
-            json.put("en", map.get("en").asMap());
-            writeJson(req, res, json);
-        } catch (Exception ex)
+        if (Helper.isEmpty(locale))
         {
-            logger.error("Error while executing request: " + req.getQueryString(), ex);
-            writeError(res, SC_INTERNAL_SERVER_ERROR, "Problem occured:" + ex.getMessage());
+            // fall back to language specified in header e.g. via browser settings
+            String acceptLang = req.getHeader("Accept-Language");
+            if (!Helper.isEmpty(acceptLang))
+                locale = acceptLang.split(",")[0];
         }
+
+        Translation tr = map.get(locale);
+        JSONObject json = new JSONObject();
+        if (tr != null && !Locale.US.equals(tr.getLocale()))
+            json.put("default", tr.asMap());
+
+        json.put("locale", locale.toString());
+        json.put("en", map.get("en").asMap());
+        writeJson(req, res, json);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/IPFilter.java b/web/src/main/java/com/graphhopper/http/IPFilter.java
index 9b40dd4c02..b6076883a4 100644
--- a/web/src/main/java/com/graphhopper/http/IPFilter.java
+++ b/web/src/main/java/com/graphhopper/http/IPFilter.java
@@ -5,16 +5,17 @@
 import java.util.Set;
 import javax.servlet.*;
 import javax.servlet.http.HttpServletResponse;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * This IP filter class accepts a list of IPs for blacklisting OR for whitelisting (but not both).
- * <p>
+ * <p/>
  * Additionally to exact match a simple wildcard expression ala 1.2.3* or 1.*.3.4 is allowed.
- * <p>
+ * <p/>
  * The internal ip filter from jetty did not work (NP exceptions)
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class IPFilter implements Filter
diff --git a/web/src/main/java/com/graphhopper/http/InfoServlet.java b/web/src/main/java/com/graphhopper/http/InfoServlet.java
index 824d5c3ee1..626ba5f6d8 100644
--- a/web/src/main/java/com/graphhopper/http/InfoServlet.java
+++ b/web/src/main/java/com/graphhopper/http/InfoServlet.java
@@ -22,6 +22,7 @@
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.BBox;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
@@ -29,8 +30,10 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
 import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
+
 import org.json.JSONObject;
 
 /**
@@ -43,21 +46,6 @@
 
     @Override
     public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
-    {
-        try
-        {
-            writeInfos(req, res);
-        } catch (IllegalArgumentException ex)
-        {
-            writeError(res, SC_BAD_REQUEST, ex.getMessage());
-        } catch (Exception ex)
-        {
-            logger.error("Error while executing request: " + req.getQueryString(), ex);
-            writeError(res, SC_INTERNAL_SERVER_ERROR, "Problem occured:" + ex.getMessage());
-        }
-    }
-
-    void writeInfos( HttpServletRequest req, HttpServletResponse res ) throws Exception
     {
         BBox bb = hopper.getGraph().getBounds();
         List<Double> list = new ArrayList<Double>(4);
diff --git a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
index 9fd057f8e6..8de227530b 100644
--- a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
+++ b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
@@ -15,23 +15,20 @@
  */
 package com.graphhopper.http;
 
+import org.json.JSONObject;
+
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
-import org.json.JSONObject;
 
 public class InvalidRequestServlet extends GHBaseServlet
 {
-
     @Override
     protected void service( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
     {
-        res.setStatus(HttpServletResponse.SC_NOT_FOUND);
-        res.setContentType("text/plain");
-        res.setContentType("UTF-8");
         JSONObject json = new JSONObject();
-        json.put("error_code", "404");
-        writeJson(req, res, json);
+        json.put("message", "Not found");
+        writeJsonError(res, HttpServletResponse.SC_NOT_FOUND, json);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/NearestServlet.java b/web/src/main/java/com/graphhopper/http/NearestServlet.java
new file mode 100644
index 0000000000..5696fce229
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/NearestServlet.java
@@ -0,0 +1,86 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import com.graphhopper.GraphHopper;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.GHPoint3D;
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+import javax.inject.Inject;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+
+/**
+ * @author svantulden
+ */
+public class NearestServlet extends GHBaseServlet
+{
+    @Inject
+    private GraphHopper hopper;
+    private final DistanceCalc calc = Helper.DIST_EARTH;
+
+    @Override
+    public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) throws ServletException, IOException
+    {
+        String pointStr = getParam(httpReq, "point", null);
+        boolean enabledElevation = getBooleanParam(httpReq, "elevation", false);
+
+        JSONObject result = new JSONObject();
+        if (pointStr != null && !pointStr.equalsIgnoreCase(""))
+        {
+            GHPoint place = GHPoint.parse(pointStr);
+            LocationIndex index = hopper.getLocationIndex();
+            QueryResult qr = index.findClosest(place.lat, place.lon, EdgeFilter.ALL_EDGES);
+
+            if (!qr.isValid())
+            {
+                result.put("error", "Nearest point cannot be found!");
+            } else
+            {
+                GHPoint3D snappedPoint = qr.getSnappedPoint();
+                result.put("type", "Point");
+
+                JSONArray coord = new JSONArray();
+                coord.put(snappedPoint.lon);
+                coord.put(snappedPoint.lat);
+
+                if (hopper.hasElevation() && enabledElevation)
+                    coord.put(snappedPoint.ele);
+
+                result.put("coordinates", coord);
+
+                // Distance from input to snapped point in meters
+                result.put("distance", calc.calcDist(place.lat, place.lon, snappedPoint.lat, snappedPoint.lon));
+            }
+        } else
+        {
+            result.put("error", "No lat/lon specified!");
+        }
+
+        writeJson(httpReq, httpRes, result);
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java b/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
index f9cc20ae9a..1890d9628b 100644
--- a/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
+++ b/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
@@ -21,11 +21,13 @@
 import com.graphhopper.search.ReverseGeocoding;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPlace;
+
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.List;
+
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.slf4j.Logger;
@@ -45,6 +47,7 @@ public static void main( String[] args )
         System.out.println("reverse " + new NominatimGeocoder().places2names(new GHPlace(49.9027606, 11.577197),
                 new GHPlace(52.5198535, 13.4385964)));
     }
+
     private String nominatimUrl;
     private String nominatimReverseUrl;
     private BBox bounds;
@@ -157,7 +160,8 @@ public NominatimGeocoder setBounds( BBox bounds )
 
     HttpURLConnection openConnection( String url ) throws IOException
     {
-        HttpURLConnection hConn = (HttpURLConnection) new URL(url).openConnection();;
+        HttpURLConnection hConn = (HttpURLConnection) new URL(url).openConnection();
+        ;
         hConn.setRequestProperty("User-Agent", userAgent);
         hConn.setRequestProperty("content-charset", "UTF-8");
         hConn.setConnectTimeout(timeoutInMillis);
diff --git a/core/src/main/java/com/graphhopper/routing/util/AlgorithmPreparation.java b/web/src/main/java/com/graphhopper/http/RouteSerializer.java
similarity index 54%
rename from core/src/main/java/com/graphhopper/routing/util/AlgorithmPreparation.java
rename to web/src/main/java/com/graphhopper/http/RouteSerializer.java
index 2eb5a9e664..31af004887 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AlgorithmPreparation.java
+++ b/web/src/main/java/com/graphhopper/http/RouteSerializer.java
@@ -15,29 +15,29 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util;
+package com.graphhopper.http;
 
-import com.graphhopper.routing.RoutingAlgorithm;
-import com.graphhopper.storage.Graph;
+import com.graphhopper.GHResponse;
+import com.graphhopper.util.PointList;
+import java.util.Map;
 
 /**
- * Holds an algorithm which can be prepared and created.
- * <p/>
+ * This interface speficies how the route should be transformed into JSON.
+ * <p>
  * @author Peter Karich
  */
-public interface AlgorithmPreparation
+public interface RouteSerializer
 {
     /**
-     * Prepares the underlying graph to be used by a specialized algorithm.
+     * This method transforms the specified response into a JSON.
      */
-    AlgorithmPreparation doWork();
+    Map<String, Object> toJSON( GHResponse response,
+                                boolean calcPoints, boolean pointsEncoded,
+                                boolean includeElevation, boolean enableInstructions );
 
     /**
-     * @return true if doWork was already called.
+     * This method returns either a Map containing the GeoJSON of the specified points OR the string
+     * encoded polyline of it.
      */
-    boolean isPrepared();
-
-    AlgorithmPreparation setGraph( Graph g );
-
-    RoutingAlgorithm createAlgo();
+    Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation );
 }
diff --git a/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java b/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
new file mode 100644
index 0000000000..627b47b3a3
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
@@ -0,0 +1,105 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import com.graphhopper.GHResponse;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.InstructionList;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.BBox;
+import java.util.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class SimpleRouteSerializer implements RouteSerializer
+{
+    private final BBox maxBounds;
+
+    public SimpleRouteSerializer( BBox maxBounds )
+    {
+        this.maxBounds = maxBounds;
+    }
+
+    @Override
+    public Map<String, Object> toJSON( GHResponse rsp,
+                                       boolean calcPoints, boolean pointsEncoded,
+                                       boolean includeElevation, boolean enableInstructions )
+    {
+        Map<String, Object> json = new HashMap<String, Object>();
+
+        if (rsp.hasErrors())
+        {
+            json.put("message", rsp.getErrors().get(0).getMessage());
+            List<Map<String, String>> errorHintList = new ArrayList<Map<String, String>>();
+            for (Throwable t : rsp.getErrors())
+            {
+                Map<String, String> map = new HashMap<String, String>();
+                map.put("message", t.getMessage());
+                map.put("details", t.getClass().getName());
+                errorHintList.add(map);
+            }
+            json.put("hints", errorHintList);
+        } else
+        {
+            Map<String, Object> jsonInfo = new HashMap<String, Object>();
+            json.put("info", jsonInfo);
+            json.put("hints", rsp.getHints().toMap());
+            jsonInfo.put("copyrights", Arrays.asList("GraphHopper", "OpenStreetMap contributors"));
+            Map<String, Object> jsonPath = new HashMap<String, Object>();
+            jsonPath.put("distance", Helper.round(rsp.getDistance(), 3));
+            jsonPath.put("weight", Helper.round6(rsp.getDistance()));
+            jsonPath.put("time", rsp.getTime());
+
+            if (calcPoints)
+            {
+                jsonPath.put("points_encoded", pointsEncoded);
+
+                PointList points = rsp.getPoints();
+                if (points.getSize() >= 2)
+                {
+                    BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon, maxBounds.minLat, maxBounds.maxLat);
+                    jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
+                }
+
+                jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
+
+                if (enableInstructions)
+                {
+                    InstructionList instructions = rsp.getInstructions();
+                    jsonPath.put("instructions", instructions.createJson());
+                }
+            }
+            json.put("paths", Collections.singletonList(jsonPath));
+        }
+        return json;
+    }
+
+    @Override
+    public Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
+    {
+        if (pointsEncoded)
+            return WebHelper.encodePolyline(points, includeElevation);
+
+        Map<String, Object> jsonPoints = new HashMap<String, Object>();
+        jsonPoints.put("type", "LineString");
+        jsonPoints.put("coordinates", points.toGeoJson(includeElevation));
+        return jsonPoints;
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/WebHelper.java b/web/src/main/java/com/graphhopper/http/WebHelper.java
index 02e515b8e9..8a5aaeba92 100644
--- a/web/src/main/java/com/graphhopper/http/WebHelper.java
+++ b/web/src/main/java/com/graphhopper/http/WebHelper.java
@@ -18,6 +18,7 @@
 package com.graphhopper.http;
 
 import com.graphhopper.util.PointList;
+
 import java.io.BufferedInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -26,11 +27,11 @@
 
 /**
  * Code which handles polyline encoding and other web stuff.
- * <p>
+ * <p/>
  * The necessary information for polyline encoding is in this answer:
  * http://stackoverflow.com/a/24510799/194609 with a link to official Java sources as well as to a
  * good explanation.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class WebHelper
diff --git a/web/src/main/webapp/img/roundabout.png b/web/src/main/webapp/img/roundabout.png
new file mode 100644
index 0000000000..1a02efd5b9
Binary files /dev/null and b/web/src/main/webapp/img/roundabout.png differ
diff --git a/web/src/main/webapp/index.html b/web/src/main/webapp/index.html
index 9662342691..0cf58995bd 100644
--- a/web/src/main/webapp/index.html
+++ b/web/src/main/webapp/index.html
@@ -17,8 +17,8 @@
         <link rel="stylesheet" href="css/leaflet.contextmenu.css" />
         <link rel="stylesheet" href="css/leaflet.loading.css" />
         <link rel="stylesheet" href="css/ui-lightness/jquery-ui-1.10.4.css" />
-        <script async="yes" type="text/javascript" src="js/leaflet.contextmenu.js"></script>
-        <script async="yes" type="text/javascript" src="js/leaflet.loading.js"></script>
+        <script type="text/javascript" src="js/leaflet.contextmenu.js"></script>
+        <script type="text/javascript" src="js/leaflet.loading.js"></script>
         <script type="text/javascript" src="js/jquery-2.1.0.min.js"></script>        
         <script type="text/javascript" src="js/jquery-ui-1.10.4.custom.min.js"></script>      
         <script type="text/javascript" src="js/jquery.history.js"></script>
@@ -52,7 +52,7 @@
                 </form>      
                 <div id="export-link" title="Static Link" class="left"><a href="/maps"><img src='img/link.png'></a></div>
                 <div id="gpxExportButton" title="GPX Download"><a href=""><img alt="gpx" src='img/gpx.png'></a></div>
-                <div id="hosting">Powered by <a href='https://graphhopper.com/#enterprise'>GraphHopper API</a></div>                
+                <div id="hosting">Powered by <a href='https://graphhopper.com/#directions-api'>GraphHopper API</a></div>                
             </div>
             <div class="clear"> </div>
             <div id="info" class="small_text">
diff --git a/web/src/main/webapp/js/ghrequest.js b/web/src/main/webapp/js/ghrequest.js
index 25951a16cf..5dec96119a 100644
--- a/web/src/main/webapp/js/ghrequest.js
+++ b/web/src/main/webapp/js/ghrequest.js
@@ -9,6 +9,33 @@ window.log = function () {
     }
 };
 
+// compatiblity script taken from http://stackoverflow.com/a/11054570/194609
+if (!Function.prototype.bind) {
+    Function.prototype.bind = function (oThis) {
+        if (typeof this !== 'function') {
+            // closest thing possible to the ECMAScript 5
+            // internal IsCallable function
+            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
+        }
+
+        var aArgs = Array.prototype.slice.call(arguments, 1),
+                fToBind = this,
+                fNOP = function () {
+                },
+                fBound = function () {
+                    return fToBind.apply(this instanceof fNOP && oThis
+                            ? this
+                            : oThis,
+                            aArgs.concat(Array.prototype.slice.call(arguments)));
+                };
+
+        fNOP.prototype = this.prototype;
+        fBound.prototype = new fNOP();
+
+        return fBound;
+    };
+}
+
 GHRequest = function (host) {
     this.way_point_max_distance = 1;
     this.host = host;
@@ -26,11 +53,13 @@ GHRequest = function (host) {
     this.do_zoom = true;
     // use jsonp here if host allows CORS
     this.dataType = "json";
-    
+    // all URL parameters starting with "api." will be forwarded to GraphHopper directly    
+    this.api_params = [];
+
     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     // We know that you love 'free', we love it too :)! And so our entire software stack is free and even Open Source!      
     // Our routing service is also free for certain applications or smaller volume. Be fair, grab an API key and support us:
-    // http://graphhopper.com/#enterprise Misuse of API keys that you don't own is prohibited and you'll be blocked.                    
+    // https://graphhopper.com/#directions-api Misuse of API keys that you don't own is prohibited and you'll be blocked.                    
     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     this.key = "Cmmtvx01R56rdHcQQo7VjI6rgPgxuFLvqI8cR31u";
 
@@ -152,7 +181,7 @@ GHroute.prototype = {
         }
         return (this[to]);
     },
-    delete: function (value) {
+    removeSingle: function (value) {
         var index = false;
         if (!(isNaN(value) || value >= this.length) && this[value] !== undefined) {
             index = value;
@@ -168,13 +197,13 @@ GHroute.prototype = {
         return (this);
     },
     remove: function (from, to) {
-        var to = to || 1;
-        Array.prototype.splice.call(this, from, to);
+        var tmpTo = to || 1;
+        Array.prototype.splice.call(this, from, tmpTo);
         if (this.length === 1)
             Array.prototype.push.call(this, new GHInput());
         this.fire('route.remove', {
             from: from,
-            to: to
+            to: tmpTo
         });
         return (this);
     },
@@ -239,6 +268,7 @@ GHroute.prototype = {
             this._listeners[type] = [];
         }
         this._listeners[type].push(listener);
+        return this;
     },
     fire: function (event, options) {
         if (typeof event === "string") {
@@ -275,20 +305,26 @@ GHroute.prototype = {
     }
 };
 
-// todo
 GHRequest.prototype.init = function (params) {
-    //    for(var key in params) {
-    //        var val = params[key];
-    //        if(val === "false")
-    //            val = false;
-    //        else if(val === "true")
-    //            val = true;
-    //        else {            
-    //            if(parseFloat(val) != NaN)
-    //                val = parseFloat(val)
-    //        }
-    //        this[key] = val;
-    //    } 
+    for (var key in params) {
+        var val = params[key];
+        if (val === "false")
+            val = false;
+        else if (val === "true")
+            val = true;
+
+        // todo
+        // this[key] = val;
+
+        if (key.indexOf('api.') === 0) {
+            key = key.substring(4);
+            if (GHroute.isArray(val))
+                this.api_params[key] = val;
+            else
+                this.api_params[key] = [val];
+        }
+    }
+
     if (params.minPathPrecision)
         this.minPathPrecision = params.minPathPrecision;
     if (params.vehicle)
@@ -299,6 +335,8 @@ GHRequest.prototype.init = function (params) {
         this.algorithm = params.algorithm;
     if (params.locale)
         this.locale = params.locale;
+    if (params.key)
+        this.key = params.key;
 
     if ('do_zoom' in params)
         this.do_zoom = params.do_zoom;
@@ -357,50 +395,42 @@ GHRequest.prototype.hasElevation = function () {
     return this.elevation;
 };
 
-GHRequest.prototype.createGeocodeURL = function (host) {
+GHRequest.prototype.createGeocodeURL = function (host, prevIndex) {
     var tmpHost = this.host;
     if (host)
         tmpHost = host;
-    return this.createPath(tmpHost + "/geocode?limit=8&type=" + this.dataType + "&key=" + this.key + "&locale=" + this.locale);
+
+    var path = this.createPath(tmpHost + "/geocode?limit=6&type=" + this.dataType + "&key=" + this.key);
+    if (prevIndex >= 0 && prevIndex < this.route.size()) {
+        var point = this.route.getIndex(prevIndex);
+        path += "&lat=" + point.lat + "&lon=" + point.lng;
+    }
+    return path;
 };
 
 GHRequest.prototype.createURL = function () {
-    return this.createPath(this.host + "/route?" + this.createParams() + "&type=" + this.dataType + "&key=" + this.key);
+    return this.createPath(this.host + "/route?" + this.createPointParams(false) + "&type=" + this.dataType + "&key=" + this.key);
 };
 
 GHRequest.prototype.createGPXURL = function () {
-    // use points instead of strings
-    var str = "", point, i, l;
-
-    for (i = 0, l = this.route.size(); i < l; i++) {
-        point = this.route.getIndex(i);
-        if (i > 0)
-            str += "&";
-        str += "point=" + encodeURIComponent(point.toString());
-    }
-    return this.createPath(this.host + "/route?" + str + "&type=gpx&key=" + this.key);
+    return this.createPath(this.host + "/route?" + this.createPointParams(false) + "&type=gpx&key=" + this.key);
 };
 
 GHRequest.prototype.createHistoryURL = function () {
-    var str = "?", point, i, l;
-
-    for (i = 0, l = this.route.size(); i < l; i++) {
-        point = this.route.getIndex(i);
-        if (i > 0)
-            str += "&";
-        str += "point=" + encodeURIComponent(point.input);
-    }
-    return this.createPath(str);
+    return this.createPath("?" + this.createPointParams(true));
 };
 
-GHRequest.prototype.createParams = function () {
+GHRequest.prototype.createPointParams = function (useRawInput) {
     var str = "", point, i, l;
 
     for (i = 0, l = this.route.size(); i < l; i++) {
         point = this.route.getIndex(i);
         if (i > 0)
             str += "&";
-        str += "point=" + encodeURIComponent(point.toString());
+        if (useRawInput)
+            str += "point=" + encodeURIComponent(point.input);
+        else
+            str += "point=" + encodeURIComponent(point.toString());
     }
     return (str);
 };
@@ -427,6 +457,15 @@ GHRequest.prototype.createPath = function (url) {
         url += "&elevation=true";
     if (this.debug)
         url += "&debug=true";
+
+    for (var key in this.api_params) {
+        // entries in api_params are all arrays
+        var arr = this.api_params[key];
+        if (GHroute.isArray(arr))
+            for (var keyIndex in arr) {
+                url += "&" + key + "=" + arr[keyIndex];
+            }
+    }
     return url;
 };
 
@@ -507,19 +546,20 @@ GHRequest.prototype.doRequest = function (url, callback) {
             // problematic: this callback is not invoked when using JSONP!
             // http://stackoverflow.com/questions/19035557/jsonp-request-error-handling
             var msg = "API did not respond! ";
-            if (err && err.statusText && err.statusText !== "OK")
-                msg += err.statusText;
+            var json;
 
+            if (err && err.responseText && err.responseText.indexOf('{') >= 0) {
+                json = JSON.parse(err.responseText);
+            } else if (err && err.statusText && err.statusText !== "OK") {
+                msg += err.statusText;
+                var details = "Error for " + url;
+                json = {
+                    message: msg,
+                    hints: [{"message": msg, "details": details}]
+                };
+            }
             log(msg + " " + JSON.stringify(err));
-            var details = "Error for " + url;
-            var json = {
-                "info": {
-                    "errors": [{
-                            "message": msg,
-                            "details": details
-                        }]
-                }
-            };
+
             callback(json);
         },
         type: "GET",
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index a1c3a1200e..8c6086c96a 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -4,7 +4,7 @@ var host;
 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 // We know that you love 'free', we love it too :)! And so our entire software stack is free and even Open Source!      
 // Our routing service is also free for certain applications or smaller volume. Be fair, grab an API key and support us:
-// http://graphhopper.com/#enterprise Misuse of API keys that you don't own is prohibited and you'll be blocked.                    
+// https://graphhopper.com/#directions-api Misuse of API keys that you don't own is prohibited and you'll be blocked.                    
 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 if (!host) {
     if (location.port === '') {
@@ -15,7 +15,6 @@ if (!host) {
 }
 
 var ghRequest = new GHRequest(host);
-var tmpArgs = parseUrlWithHisto();
 var bounds = {};
 
 var nominatimURL = "https://nominatim.openstreetmap.org/search";
@@ -30,7 +29,7 @@ var defaultTranslationMap = null;
 var enTranslationMap = null;
 var routeSegmentPopup = null;
 var elevationControl = null;
-var activeLayer = 'Lyrk';
+var activeLayer = '';
 var i18nIsInitialized;
 
 var iconFrom = L.icon({
@@ -197,8 +196,8 @@ function initFromParams(params, doQuery) {
             resolveCoords([params.from, params.to], doQuery);
         else
             resolveCoords(params.point, doQuery);
-    } else if (params.point) {
-        ghRequest.from = new GHInput(params.point);
+    } else if (params.point && params.point.length === 1) {
+        ghRequest.from = new GHInput(params.point[0]);
         resolve("from", ghRequest.from);
         focus(ghRequest.from, 15, true);
     }
@@ -237,10 +236,10 @@ function checkInput() {
     // properly unbind previously click handlers
     $("#locationpoints .pointDelete").off();
 
-    // console.log("#### new checkInput #### ");
+    // console.log("## new checkInput");
     for (var i = 0; i < len; i++) {
         var div = $('#locationpoints > div.pointDiv').eq(i);
-        console.log(div.length + ", index:" + i + ", len:" + len);
+        // console.log(div.length + ", index:" + i + ", len:" + len);
         if (div.length === 0) {
             $('#locationpoints > div.pointAdd').before(nanoTemplate(template, {id: i}));
             div = $('#locationpoints > div.pointDiv').eq(i);
@@ -254,7 +253,7 @@ function checkInput() {
         if (len > 2) {
             div.find(".pointDelete").click(function () {
                 var index = $(this).parent().data('index');
-                ghRequest.route.delete(index);
+                ghRequest.route.removeSingle(index);
                 routingLayer.clearLayers();
                 routeLatLng(ghRequest, false);
             }).show();
@@ -320,6 +319,11 @@ function initMap(selectLayer) {
         subdomains: ['a', 'b', 'c']
     });
 
+    var omniscale = L.tileLayer.wms('https://maps.omniscale.net/v1/mapsgraph-bf48cc0b/tile', {
+        layers: 'osm',
+        attribution: osmAttr + ', &copy; <a href="http://maps.omniscale.com/">Omniscale</a>'
+    });
+
     var mapquest = L.tileLayer('http://{s}.mqcdn.com/tiles/1.0.0/osm/{z}/{x}/{y}.png', {
         attribution: osmAttr + ', <a href="http://open.mapquest.co.uk" target="_blank">MapQuest</a>',
         subdomains: ['otile1', 'otile2', 'otile3', 'otile4']
@@ -330,10 +334,19 @@ function initMap(selectLayer) {
         subdomains: ['otile1', 'otile2', 'otile3', 'otile4']
     });
 
-    var openMapsSurfer = L.tileLayer('http://openmapsurfer.uni-hd.de/tiles/roads/x={x}&y={y}&z={z}', {
+    var openMapSurfer = L.tileLayer('http://openmapsurfer.uni-hd.de/tiles/roads/x={x}&y={y}&z={z}', {
         attribution: osmAttr + ', <a href="http://openmapsurfer.uni-hd.de/contact.html">GIScience Heidelberg</a>'
     });
 
+    // not an option as too fast over limit
+//    var mapbox= L.tileLayer('https://{s}.tiles.mapbox.com/v4/peterk.map-vkt0kusv/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoicGV0ZXJrIiwiYSI6IkdFc2FJd2MifQ.YUd7dS_gOpT3xrQnB8_K-w', {
+//        attribution: osmAttr + ', <a href="https://www.mapbox.com/about/maps/">&copy; MapBox</a>'
+//    });
+
+    var sorbianLang = L.tileLayer('http://map.dgpsonline.eu/osmsb/{z}/{x}/{y}.png', {
+        attribution: osmAttr + ', <a href="http://www.alberding.eu/">&copy; Alberding GmbH, CC-BY-SA</a>'
+    });
+
     var thunderTransport = L.tileLayer('http://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png', {
         attribution: osmAttr + ', <a href="http://www.thunderforest.com/transport/" target="_blank">Thunderforest Transport</a>',
         subdomains: ['a', 'b', 'c']
@@ -363,17 +376,27 @@ function initMap(selectLayer) {
         subdomains: ['a', 'b', 'c']
     });
 
+    var mapLink = '<a href="http://www.esri.com/">Esri</a>';
+    var wholink = 'i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community';
+    var esriAerial = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
+        attribution: '&copy; ' + mapLink + ', ' + wholink,
+        maxZoom: 18
+    });
+
     var baseMaps = {
         "Lyrk": lyrk,
+        "Omniscale": omniscale,
         "MapQuest": mapquest,
         "MapQuest Aerial": mapquestAerial,
-        "OpenMapsSurfer": openMapsSurfer,
+        "Esri Aerial": esriAerial,
+        "OpenMapSurfer": openMapSurfer,
         "TF Transport": thunderTransport,
         "TF Cycle": thunderCycle,
         "TF Outdoors": thunderOutdoors,
         "WanderReitKarte": wrk,
         "OpenStreetMap": osm,
-        "OpenStreetMap.de": osmde
+        "OpenStreetMap.de": osmde,
+        "Sorbian Language": sorbianLang
     };
 
     var defaultLayer = baseMaps[selectLayer];
@@ -384,7 +407,7 @@ function initMap(selectLayer) {
     map = L.map('map', {
         layers: [defaultLayer],
         contextmenu: true,
-        contextmenuWidth: 140,
+        contextmenuWidth: 145,
         contextmenuItems: [{
                 separator: true,
                 index: 3,
@@ -450,8 +473,12 @@ function initMap(selectLayer) {
     L.control.layers(baseMaps/*, overlays*/).addTo(map);
 
     map.on('baselayerchange', function (a) {
-        if (a.name)
+        if (a.name) {
             activeLayer = a.name;
+            $("#export-link a").attr('href', function (i, v) {
+                return v.replace(/(layer=)([\w\s]+)/, '$1' + activeLayer);
+            });
+        }
     });
 
     L.control.scale().addTo(map);
@@ -546,7 +573,7 @@ function setIntermediateCoord(e) {
 
 function deleteCoord(e) {
     var latlng = e.target.getLatLng();
-    ghRequest.route.delete(latlng);
+    ghRequest.route.removeSingle(latlng);
     routingLayer.clearLayers();
     routeLatLng(ghRequest, false);
 }
@@ -558,9 +585,9 @@ function setEndCoord(e) {
     routeIfAllResolved();
 }
 
-function routeIfAllResolved() {
+function routeIfAllResolved(doQuery) {
     if (ghRequest.route.isResolved()) {
-        routeLatLng(ghRequest);
+        routeLatLng(ghRequest, doQuery);
         return true;
     }
     return false;
@@ -591,7 +618,8 @@ function setFlag(coord, index) {
                     draggable: true,
                     contextmenu: true,
                     contextmenuItems: [{
-                            text: 'Marker ' + ((toFrom === FROM) ? 'Start' : ((toFrom === TO) ? 'End' : 'Intermediate')),
+                            text: 'Marker ' + ((toFrom === FROM) ?
+                                    'Start' : ((toFrom === TO) ? 'End' : 'Intermediate ' + index)),
                             disabled: true,
                             index: 0,
                             state: 2
@@ -612,7 +640,8 @@ function setFlag(coord, index) {
                             state: 2
                         }],
                     contextmenuAtiveState: 2
-                }).addTo(routingLayer).bindPopup(((toFrom === FROM) ? 'Start' : ((toFrom === TO) ? 'End' : 'Intermediate')));
+                }).addTo(routingLayer).bindPopup(((toFrom === FROM) ?
+                'Start' : ((toFrom === TO) ? 'End' : 'Intermediate ' + index)));
         // intercept openPopup
         marker._openPopup = marker.openPopup;
         marker.openPopup = function () {
@@ -948,11 +977,15 @@ function routeLatLng(request, doQuery) {
     descriptionDiv.html('<img src="img/indicator.gif"/> Search Route ...');
     request.doRequest(urlForAPI, function (json) {
         descriptionDiv.html("");
-        if (json.info.errors) {
-            var tmpErrors = json.info.errors;
+        if (json.message) {
+            var tmpErrors = json.message;
             log(tmpErrors);
-            for (var m = 0; m < tmpErrors.length; m++) {
-                descriptionDiv.append("<div class='error'>" + tmpErrors[m].message + "</div>");
+            if (json.hints) {
+                for (var m = 0; m < json.hints.length; m++) {
+                    descriptionDiv.append("<div class='error'>" + json.hints[m].message + "</div>");
+                }
+            } else {
+                descriptionDiv.append("<div class='error'>" + tmpErrors + "</div>");
             }
             return;
         }
@@ -1047,18 +1080,20 @@ function routeLatLng(request, doQuery) {
                 hiddenDiv.toggle();
             });
             $("#info").append(toggly);
-            var infoStr = "took: " + round(json.info.took / 1000, 1000) + "s"
-                    + ", points: " + path.points.coordinates.length;
+            var infoStr = "points: " + path.points.coordinates.length;
 
             hiddenDiv.append("<span>" + infoStr + "</span>");
 
             var exportLink = $("#export-link a");
             exportLink.attr('href', urlForHistory);
-            var startOsmLink = $("<a>start</a>");
-            startOsmLink.attr("href", "https://www.openstreetmap.org/?zoom=14&mlat=" + request.from.lat + "&mlon=" + request.from.lng);
-            var endOsmLink = $("<a>end</a>");
-            endOsmLink.attr("href", "https://www.openstreetmap.org/?zoom=14&mlat=" + request.to.lat + "&mlon=" + request.to.lng);
-            hiddenDiv.append("<br/><span>View on OSM: </span>").append(startOsmLink).append(endOsmLink);
+            var osmRouteLink = $("<br/><a>view on OSM</a>");
+
+            var osmVehicle = "bicycle";
+            if (request.vehicle.toUpperCase() === "FOOT") {
+                osmVehicle = "foot";
+            }
+            osmRouteLink.attr("href", "http://www.openstreetmap.org/directions?engine=graphhopper_" + osmVehicle + "&route=" + encodeURIComponent(request.from.lat + "," + request.from.lng + ";" + request.to.lat + "," + request.to.lng));
+            hiddenDiv.append(osmRouteLink);
 
             var osrmLink = $("<a>OSRM</a>");
             osrmLink.attr("href", "http://map.project-osrm.org/?loc=" + request.from + "&loc=" + request.to);
@@ -1138,14 +1173,16 @@ function addInstruction(main, instr, instrIndex, lngLat) {
         sign = "marker-icon-red";
     else if (sign === 5)
         sign = "marker-icon-blue";
+    else if (sign === 6)
+        sign = "roundabout";
     else
         throw "did not found sign " + sign;
     var title = instr.text;
-    if (instr.annotationText) {
+    if (instr.annotation_text) {
         if (!title)
-            title = instr.annotationText;
+            title = instr.annotation_text;
         else
-            title = title + ", " + instr.annotationText;
+            title = title + ", " + instr.annotation_text;
     }
     var distance = instr.distance;
     var str = "<td class='instr_title'>" + title + "</td>";
@@ -1197,10 +1234,6 @@ function parseUrlWithHisto() {
     return parseUrl(window.location.search);
 }
 
-function parseUrlAndRequest() {
-    return parseUrl(window.location.search);
-}
-
 function parseUrl(query) {
     var index = query.indexOf('?');
     if (index >= 0)
@@ -1218,24 +1251,25 @@ function parseUrl(query) {
         if (value === "")
             continue;
 
-        if (typeof res[key] === "undefined") {
+        // force array for heading and point
+        if (typeof res[key] === "undefined"
+                && key !== "heading" && key !== "point") {
             if (value === 'true')
-                res[key] = true;
+                value = true;
             else if (value === 'false')
-                res[key] = false;
-            else {
-                var tmp = Number(value);
-                if (isNaN(tmp))
-                    res[key] = value;
-                else
-                    res[key] = Number(value);
-            }
-        } else if (typeof res[key] === "string") {
-            var arr = [res[key], value];
-            res[key] = arr;
-        } else
-            res[key].push(value);
+                value = false;
 
+            res[key] = value;
+        } else {
+            var tmpVal = res[key];
+            if (GHroute.isArray(tmpVal)) {
+                tmpVal.push(value);
+            } else if (tmpVal) {
+                res[key] = [tmpVal, value];
+            } else {
+                res[key] = [value];
+            }
+        }
     }
     return res;
 }
@@ -1403,15 +1437,16 @@ function setAutoCompleteList(index) {
             return val === undefined;
         },
         serviceUrl: function () {
-            // see http://graphhopper.com/#enterprise
-            return ghRequest.createGeocodeURL(host);
+            // see https://graphhopper.com/#directions-api
+            return ghRequest.createGeocodeURL(host, index - 1);
         },
         transformResult: function (response, originalQuery) {
             response.suggestions = [];
-            for (var i = 0; i < response.hits.length; i++) {
-                var hit = response.hits[i];
-                response.suggestions.push({value: dataToText(hit), data: hit});
-            }
+            if (response.hits)
+                for (var i = 0; i < response.hits.length; i++) {
+                    var hit = response.hits[i];
+                    response.suggestions.push({value: dataToText(hit), data: hit});
+                }
             return response;
         },
         onSearchError: function (element, q, jqXHR, textStatus, errorThrown) {
@@ -1433,7 +1468,7 @@ function setAutoCompleteList(index) {
             req.setCoord(point.lat, point.lng);
 
             req.input = suggestion.value;
-            if (!routeIfAllResolved())
+            if (!routeIfAllResolved(true))
                 focus(req, 15, index);
 
             myAutoDiv.autocomplete().enable();
diff --git a/web/src/test/java/com/graphhopper/http/BaseServletTester.java b/web/src/test/java/com/graphhopper/http/BaseServletTester.java
index b1c47148fe..924d19d696 100644
--- a/web/src/test/java/com/graphhopper/http/BaseServletTester.java
+++ b/web/src/test/java/com/graphhopper/http/BaseServletTester.java
@@ -22,10 +22,15 @@
 import com.google.inject.Module;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Downloader;
+import com.graphhopper.util.Helper;
 import org.json.JSONObject;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.net.HttpURLConnection;
+
+import static org.junit.Assert.assertEquals;
+
 /**
  * @author Peter Karich
  */
@@ -95,13 +100,45 @@ public static void shutdownJetty( boolean force )
         server = null;
     }
 
-    protected String getTestAPIUrl()
+    protected String getTestRouteAPIUrl()
     {
         String host = "localhost";
         return "http://" + host + ":" + port + "/route";
     }
 
-    protected JSONObject query( String query ) throws Exception
+    protected String getTestNearestAPIUrl()
+    {
+        String host = "localhost";
+        return "http://" + host + ":" + port + "/nearest";
+    }
+
+    protected String queryString( String query, int code ) throws Exception
+    {
+        String resQuery = "";
+        for (String q : query.split("\\&"))
+        {
+            int index = q.indexOf("=");
+            if (index > 0)
+                resQuery += q.substring(0, index + 1) + WebHelper.encodeURL(q.substring(index + 1));
+            else
+                resQuery += WebHelper.encodeURL(q);
+
+            resQuery += "&";
+        }
+        String url = getTestRouteAPIUrl() + "?" + resQuery;
+        Downloader downloader = new Downloader("web integration tester").setTimeout(1000);
+        HttpURLConnection conn = downloader.createConnection(url);
+        conn.connect();
+        assertEquals(code, conn.getResponseCode());
+        return Helper.isToString(downloader.fetch(conn, true));
+    }
+
+    protected JSONObject query( String query, int code ) throws Exception
+    {
+        return new JSONObject(queryString(query, code));
+    }
+
+    protected JSONObject nearestQuery( String query ) throws Exception
     {
         String resQuery = "";
         for (String q : query.split("\\&"))
@@ -114,8 +151,8 @@ protected JSONObject query( String query ) throws Exception
 
             resQuery += "&";
         }
-        String url = getTestAPIUrl() + "?" + resQuery;
+        String url = getTestNearestAPIUrl() + "?" + resQuery;
         Downloader downloader = new Downloader("web integration tester");
-        return new JSONObject(downloader.downloadAsString(url));
-    }    
+        return new JSONObject(downloader.downloadAsString(url, true));
+    }
 }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
index 10a09d601d..fef0887478 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
@@ -22,11 +22,16 @@
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
-import java.io.File;
+import com.graphhopper.util.shapes.GHPoint;
 import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
+
+import java.io.File;
+import java.util.List;
+import java.util.Map;
+
 import static org.junit.Assert.*;
 
 /**
@@ -56,7 +61,7 @@ public void setUp()
     @Test
     public void testBasicQuery() throws Exception
     {
-        JSONObject json = query("point=42.554851,1.536198&point=42.510071,1.548128");
+        JSONObject json = query("point=42.554851,1.536198&point=42.510071,1.548128", 200);
         JSONObject infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
         JSONObject path = json.getJSONArray("paths").getJSONObject(0);
@@ -65,50 +70,88 @@ public void testBasicQuery() throws Exception
         assertTrue("distance wasn't correct:" + distance, distance < 9500);
     }
 
+    @Test
+    public void testQuerywithDirections() throws Exception
+    {
+        // Note, in general specifying directions does not work with CH, but this is an example where it works
+        JSONObject json = query("point=42.496696,1.499323&point=42.497257,1.501501&heading=240&heading=240", 200);
+        JSONObject infoJson = json.getJSONObject("info");
+        assertFalse(infoJson.has("errors"));
+        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
+        double distance = path.getDouble("distance");
+        assertTrue("distance wasn't correct:" + distance, distance > 960);
+        assertTrue("distance wasn't correct:" + distance, distance < 970);
+    }
+
+    @Test
+    public void testQuerywithStraightVia() throws Exception
+    {
+        // Note, in general specifying straightvia does not work with CH, but this is an example where it works
+        JSONObject json = query(
+                "point=42.534133,1.581473&point=42.534781,1.582149&point=42.535042,1.582514&pass_through=true", 200);
+        JSONObject infoJson = json.getJSONObject("info");
+        assertFalse(infoJson.has("errors"));
+        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
+        double distance = path.getDouble("distance");
+        assertTrue("distance wasn't correct:" + distance, distance > 320);
+        assertTrue("distance wasn't correct:" + distance, distance < 325);
+    }
+
+
     @Test
     public void testJsonRounding() throws Exception
     {
-        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false");
+        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false", 200);
         JSONObject cson = json.getJSONArray("paths").getJSONObject(0).getJSONObject("points");
-        assertTrue("unexpected precision!", cson.toString().indexOf("[1.536374,42.554839]") >= 0);
+        assertTrue("unexpected precision!", cson.toString().contains("[1.536374,42.554839]"));
     }
 
     @Test
     public void testFailIfElevationRequestedButNotIncluded() throws Exception
     {
-        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false&elevation=true");
-        JSONObject infoJson = json.getJSONObject("info");
-        assertTrue(infoJson.has("errors"));
-        assertEquals("Elevation not supported!", infoJson.getJSONArray("errors").getJSONObject(0).getString("message"));
+        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false&elevation=true", 400);
+        assertTrue(json.has("message"));
+        assertEquals("Elevation not supported!", json.get("message"));
+        assertEquals("Elevation not supported!", json.getJSONArray("hints").getJSONObject(0).getString("message"));
     }
 
     @Test
     public void testGraphHopperWeb() throws Exception
     {
         GraphHopperAPI hopper = new GraphHopperWeb();
-        assertTrue(hopper.load(getTestAPIUrl()));
+        assertTrue(hopper.load(getTestRouteAPIUrl()));
         GHResponse rsp = hopper.route(new GHRequest(42.554851, 1.536198, 42.510071, 1.548128));
         assertTrue(rsp.getErrors().toString(), rsp.getErrors().isEmpty());
         assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() > 9000);
         assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() < 9500);
+
+        rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(42.554851, 1.536198)).
+                addPoint(new GHPoint(42.531896, 1.553278)).
+                addPoint(new GHPoint(42.510071, 1.548128)));
+        assertTrue(rsp.getErrors().toString(), rsp.getErrors().isEmpty());
+        assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() > 20000);
+        assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() < 21000);
+
+        List<Map<String, Object>> instructions = rsp.getInstructions().createJson();
+        assertEquals(23, instructions.size());
+        assertEquals("Continue onto la Callisa", instructions.get(0).get("text"));
+        assertEquals("At roundabout, take exit 2", instructions.get(3).get("text"));
     }
 
     @Test
     public void testGraphHopperWebRealExceptions()
     {
-        GHResponse rsp;
-        Throwable ex;
-
         GraphHopperAPI hopper = new GraphHopperWeb();
-        assertTrue(hopper.load(getTestAPIUrl()));
+        assertTrue(hopper.load(getTestRouteAPIUrl()));
 
         // IllegalStateException (Wrong Request)
-        rsp = hopper.route(new GHRequest());
+        GHResponse rsp = hopper.route(new GHRequest());
         assertFalse("Errors expected but not found.", rsp.getErrors().isEmpty());
 
-        ex = rsp.getErrors().get(0);
+        Throwable ex = rsp.getErrors().get(0);
         assertTrue("Wrong Exception found: " + ex.getClass().getName()
-            + ", IllegalStateException expected.", ex instanceof IllegalStateException);
+                + ", IllegalStateException expected.", ex instanceof IllegalStateException);
 
         // IllegalArgumentException (Wrong Points)
         rsp = hopper.route(new GHRequest(0.0, 0.0, 0.0, 0.0));
@@ -130,4 +173,22 @@ public void testGraphHopperWebRealExceptions()
         // RuntimeException
         // Exception
     }
+
+    @Test
+    public void testGPX() throws Exception
+    {
+        String str = queryString("point=42.554851,1.536198&point=42.510071,1.548128&type=gpx", 200);
+        assertTrue(str.contains("<gh:distance>115.1</gh:distance>"));
+        assertTrue(str.contains("<trkpt lat=\"42.554839\" lon=\"1.536374\"><time>"));
+    }
+
+    @Test
+    public void testGPXWithError() throws Exception
+    {
+        String str = queryString("point=42.554851,1.536198&type=gpx", 400);
+        assertFalse(str, str.contains("<html>"));
+        assertFalse(str, str.contains("{"));
+        assertTrue("Expected error but was: " + str, str.contains("<message>At least 2 points has to be specified, but was:1</message>"));
+        assertTrue("Expected error but was: " + str, str.contains("<hints><error details=\"java"));
+    }
 }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
index a33c669719..248b1cdee9 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
@@ -19,11 +19,14 @@
 
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
+
 import java.io.File;
+
 import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
@@ -56,7 +59,7 @@ public void setUp()
     @Test
     public void testElevation() throws Exception
     {
-        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=true");
+        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=true", 200);
         JSONObject infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
         JSONObject path = json.getJSONArray("paths").getJSONObject(0);
@@ -65,14 +68,18 @@ public void testElevation() throws Exception
         assertTrue("distance wasn't correct:" + distance, distance < 2700);
 
         JSONObject cson = path.getJSONObject("points");
-        assertTrue("no elevation?", cson.toString().indexOf("[7.421392,43.7307,66]") >= 0);
+        assertTrue("no elevation?", cson.toString().contains("[7.421392,43.7307,66]"));
+
+        // Although we include elevation DO NOT include it in the bbox as bbox.toGeoJSON messes up when reading
+        // or reading with and without elevation would be too complex for the client with no real use
+        assertEquals(4, path.getJSONArray("bbox").length());
     }
 
     @Test
     public void testNoElevation() throws Exception
     {
         // default is elevation=false
-        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false");
+        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false", 200);
         JSONObject infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
         JSONObject path = json.getJSONArray("paths").getJSONObject(0);
@@ -80,14 +87,14 @@ public void testNoElevation() throws Exception
         assertTrue("distance wasn't correct:" + distance, distance > 2500);
         assertTrue("distance wasn't correct:" + distance, distance < 2700);
         JSONObject cson = path.getJSONObject("points");
-        assertTrue("Elevation should not be included!", cson.toString().indexOf("[7.421392,43.7307]") >= 0);
+        assertTrue("Elevation should not be included!", cson.toString().contains("[7.421392,43.7307]"));
 
         // disable elevation
-        json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=false");
+        json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=false", 200);
         infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
         path = json.getJSONArray("paths").getJSONObject(0);
         cson = path.getJSONObject("points");
-        assertTrue("Elevation should not be included!", cson.toString().indexOf("[7.421392,43.7307]") >= 0);
+        assertTrue("Elevation should not be included!", cson.toString().contains("[7.421392,43.7307]"));
     }
 }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java b/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
index 6b29124e4d..7a804e5ca0 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
@@ -20,36 +20,21 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.util.Downloader;
+
 import java.io.IOException;
 import java.io.InputStream;
+import java.net.HttpURLConnection;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GraphHopperWebTest
 {
-
-    @Test
-    public void testReadUnencoded() throws Exception
-    {
-        Downloader downloader = new Downloader("GraphHopper Test")
-        {
-            @Override
-            public InputStream fetch( String url ) throws IOException
-            {
-                return getClass().getResourceAsStream("test.json");
-            }
-        };
-        GraphHopperWeb instance = new GraphHopperWeb().setPointsEncoded(false);
-        instance.setDownloader(downloader);
-        GHResponse res = instance.route(new GHRequest(52.47379, 13.362808, 52.4736925, 13.3904394));
-        assertEquals(2138.3, res.getDistance(), 1e-1);
-        assertEquals(17, res.getPoints().getSize());
-        assertEquals(5, res.getInstructions().getSize());
-    }
+    // see also GraphHopperServletIT.testGraphHopperWeb for real routes against local jetty service    
 
     @Test
     public void testReadEncoded() throws Exception
@@ -57,12 +42,12 @@ public void testReadEncoded() throws Exception
         Downloader downloader = new Downloader("GraphHopper Test")
         {
             @Override
-            public InputStream fetch( String url ) throws IOException
+            public InputStream fetch( HttpURLConnection conn, boolean readErrorStreamNoException ) throws IOException
             {
                 return getClass().getResourceAsStream("test_encoded.json");
             }
         };
-        GraphHopperWeb instance = new GraphHopperWeb().setPointsEncoded(true);
+        GraphHopperWeb instance = new GraphHopperWeb();
         instance.setDownloader(downloader);
         GHResponse res = instance.route(new GHRequest(52.47379, 13.362808, 52.4736925, 13.3904394));
         assertEquals(2138.3, res.getDistance(), 1e-1);
diff --git a/web/src/test/java/com/graphhopper/http/IPFilterTest.java b/web/src/test/java/com/graphhopper/http/IPFilterTest.java
index dc2470b6f2..2b6b24ca23 100644
--- a/web/src/test/java/com/graphhopper/http/IPFilterTest.java
+++ b/web/src/test/java/com/graphhopper/http/IPFilterTest.java
@@ -1,10 +1,10 @@
 package com.graphhopper.http;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class IPFilterTest
diff --git a/web/src/test/java/com/graphhopper/http/NearestServletIT.java b/web/src/test/java/com/graphhopper/http/NearestServletIT.java
new file mode 100644
index 0000000000..3cb2a78760
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/NearestServletIT.java
@@ -0,0 +1,70 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import static com.graphhopper.http.BaseServletTester.shutdownJetty;
+
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Helper;
+
+import java.io.File;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author svantulden
+ */
+public class NearestServletIT extends BaseServletTester
+{
+    private static final String dir = "./target/andorra-gh/";
+
+    @AfterClass
+    public static void cleanUp()
+    {
+        Helper.removeDir(new File(dir));
+        shutdownJetty(true);
+    }
+
+    @Before
+    public void setUp()
+    {
+        CmdArgs args = new CmdArgs().
+                put("config", "../config-example.properties").
+                put("osmreader.osm", "../core/files/andorra.osm.pbf").
+                put("graph.location", dir);
+        setUpJetty(args);
+    }
+
+    @Test
+    public void testBasicNearestQuery() throws Exception
+    {
+        JSONObject json = nearestQuery("point=42.554851,1.536198");
+        assertFalse(json.has("error"));
+        JSONArray point = json.getJSONArray("coordinates");
+        assertTrue("returned point is not 2D: " + point, point.length() == 2);
+        double lon = point.getDouble(0);
+        double lat = point.getDouble(1);
+        assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon, lat == 42.55483907636756 && lon == 1.5363742288086868);
+    }
+}
diff --git a/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java b/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java
new file mode 100644
index 0000000000..cb8f5c2692
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java
@@ -0,0 +1,95 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import static com.graphhopper.http.BaseServletTester.shutdownJetty;
+
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Helper;
+
+import java.io.File;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author svantulden
+ */
+public class NearestServletWithEleIT extends BaseServletTester
+{
+    private static final String dir = "./target/monaco-gh/";
+
+    @AfterClass
+    public static void cleanUp()
+    {
+        Helper.removeDir(new File(dir));
+        shutdownJetty(true);
+    }
+
+    @Before
+    public void setUp()
+    {
+        CmdArgs args = new CmdArgs().
+                put("graph.elevation.provider", "srtm").
+                put("graph.elevation.cachedir", "../core/files/").
+                put("prepare.chWeighting", "no").
+                put("config", "../config-example.properties").
+                put("osmreader.osm", "../core/files/monaco.osm.gz").
+                put("graph.location", dir);
+        setUpJetty(args);
+    }
+
+    @Test
+    public void testWithEleQuery() throws Exception
+    {
+        JSONObject json = nearestQuery("point=43.730864,7.420771&elevation=true");
+        assertFalse(json.has("error"));
+        JSONArray point = json.getJSONArray("coordinates");
+        assertTrue("returned point is not 3D: " + point, point.length() == 3);
+        double lon = point.getDouble(0);
+        double lat = point.getDouble(1);
+        double ele = point.getDouble(2);
+        assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon + ", ele=" + ele, lat == 43.73070006215647 && lon == 7.421392181993846 && ele == 66.0);
+    }
+
+    @Test
+    public void testWithoutEleQuery() throws Exception
+    {
+        JSONObject json = nearestQuery("point=43.730864,7.420771&elevation=false");
+        assertFalse(json.has("error"));
+        JSONArray point = json.getJSONArray("coordinates");
+        assertTrue("returned point is not 2D: " + point, point.length() == 2);
+        double lon = point.getDouble(0);
+        double lat = point.getDouble(1);
+        assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon, lat == 43.73070006215647 && lon == 7.421392181993846);
+
+        // Default elevation is false        
+        json = nearestQuery("point=43.730864,7.420771");
+        assertFalse(json.has("error"));
+        point = json.getJSONArray("coordinates");
+        assertTrue("returned point is not 2D: " + point, point.length() == 2);
+        lon = point.getDouble(0);
+        lat = point.getDouble(1);
+        assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon, lat == 43.73070006215647 && lon == 7.421392181993846);
+    }
+}
diff --git a/web/src/test/java/com/graphhopper/http/WebHelperTest.java b/web/src/test/java/com/graphhopper/http/WebHelperTest.java
index 4276ca4ed5..1f75fbbb52 100644
--- a/web/src/test/java/com/graphhopper/http/WebHelperTest.java
+++ b/web/src/test/java/com/graphhopper/http/WebHelperTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class WebHelperTest
diff --git a/web/src/test/resources/com/graphhopper/http/test.json b/web/src/test/resources/com/graphhopper/http/test.json
deleted file mode 100644
index 734968699f..0000000000
--- a/web/src/test/resources/com/graphhopper/http/test.json
+++ /dev/null
@@ -1,139 +0,0 @@
-{
-  "info": {"took": 0.004322056192904711},
-  "paths": [{
-    "bbox": [
-      13.362853824187303,
-      52.469481955531585,
-      13.385836736460217,
-      52.473849308838446
-    ],
-    "distance": 2138.3027624572337,
-    "instructions": [
-      {
-        "distance": 1268.519329705091,
-        "interval": [
-          0,
-          10
-        ],
-        "sign": 0,
-        "text": "Geradeaus auf A 100",
-        "time": 65237
-      },
-      {
-        "distance": 379.74399999999997,
-        "interval": [
-          10,
-          11
-        ],
-        "sign": 0,
-        "text": "Geradeaus auf Strasse",
-        "time": 24855
-      },
-      {
-        "distance": 16.451,
-        "interval": [
-          11,
-          11
-        ],
-        "sign": 0,
-        "text": "Geradeaus auf Tempelhofer Damm",
-        "time": 1316
-      },
-      {
-        "distance": 473.58843275214315,
-        "interval": [
-          11,
-          12
-        ],
-        "sign": -2,
-        "text": "Links abbiegen auf Tempelhofer Damm, B 96",
-        "time": 37882
-      },
-      {
-        "distance": 0,
-        "interval": [
-          12,
-          12
-        ],
-        "sign": 4,
-        "text": "Ziel erreicht!",
-        "time": 0
-      }
-    ],
-    "points": {
-      "coordinates": [
-        [
-          13.362853824187303,
-          52.473849308838446
-        ],
-        [
-          13.36361795731525,
-          52.47361367509396
-        ],
-        [
-          13.365841769408624,
-          52.47262889458155
-        ],
-        [
-          13.368347585983893,
-          52.47146995674379
-        ],
-        [
-          13.369309455960455,
-          52.47115535597106
-        ],
-        [
-          13.370299824408438,
-          52.470938171541796
-        ],
-        [
-          13.372544498127949,
-          52.47050901808982
-        ],
-        [
-          13.373925277007936,
-          52.47029332377672
-        ],
-        [
-          13.374831267628773,
-          52.470171134252205
-        ],
-        [
-          13.375656233183806,
-          52.47009346194774
-        ],
-        [
-          13.378514089700149,
-          52.46991055019
-        ],
-        [
-          13.379928396193574,
-          52.46987162090551
-        ],
-        [
-          13.384775557773759,
-          52.46952423757742
-        ],
-        [
-          13.385498264107815,
-          52.46948735720264
-        ],
-        [
-          13.385740966776185,
-          52.469481955531585
-        ],
-        [
-          13.385832236390536,
-          52.47358033374504
-        ],
-        [
-          13.385836736460217,
-          52.47374048466245
-        ]
-      ],
-      "type": "LineString"
-    },
-    "points_encoded": false,
-    "time": 129290
-  }]
-}
\ No newline at end of file
diff --git a/web/src/test/webapp/spec/UtilsSpec.js b/web/src/test/webapp/spec/UtilsSpec.js
index 5babc0a48f..ac1dcc44f0 100644
--- a/web/src/test/webapp/spec/UtilsSpec.js
+++ b/web/src/test/webapp/spec/UtilsSpec.js
@@ -1,8 +1,8 @@
 /*
  * This software stands under the Apache 2 License
  */
-describe("utils", function() {
-    it("should format time string correctly", function() {
+describe("utils", function () {
+    it("should format time string correctly", function () {
         defaultTranslationMap = {};
         defaultTranslationMap["minabbr"] = 'min';
         defaultTranslationMap["hourabbr"] = 'h';
@@ -16,7 +16,7 @@ describe("utils", function() {
         expect(createTimeString(12000)).toBe("0min");
     });
 
-    it("should format translation string correctly", function() {
+    it("should format translation string correctly", function () {
         // toBe, toBeTruthy, toBeFalsy
         defaultTranslationMap = {};
         defaultTranslationMap["web.somekey1"] = "%s wow %s";
@@ -32,7 +32,7 @@ describe("utils", function() {
         expect(tr("key", [200, "km", "2min"])).toBe("200km werden 2min brauchen");
     });
 
-    it("should format location entry correctly", function() {
+    it("should format location entry correctly", function () {
         var res = formatLocationEntry({
             "state": "Berlin",
             "country": "Deutschland",
@@ -53,7 +53,7 @@ describe("utils", function() {
         expect(res).toEqual({postcode: undefined, city: "Rixdorf, Neuklln", country: "Deutschland", more: "Berlin, Europischen Union"});
     });
 
-    it("should decode the polyline", function() {
+    it("should decode the polyline", function () {
         var list = decodePath("_p~iF~ps|U", false);
         expect(list).toEqual([[-120.2, 38.5]]);
 
@@ -61,7 +61,7 @@ describe("utils", function() {
         expect(list).toEqual([[-120.2, 38.5], [-120.95, 40.7], [-126.45300000000002, 43.252]]);
     });
 
-    it("should decode the 3D polyline", function() {
+    it("should decode the 3D polyline", function () {
         var list = decodePath("_p~iF~ps|Uo}@", true);
         expect(list).toEqual([[-120.2, 38.5, 10]]);
 
@@ -69,52 +69,54 @@ describe("utils", function() {
         expect(list).toEqual([[-120.2, 38.5, 10], [-120.95, 40.7, 1234], [-126.45300000000002, 43.252, 1234]]);
     });
 
-    it("should parse URL correctly", function() {
-        var params = parseUrl("localhost:8989?test=pest&test2=true&test3=false&test4=2&test5=1.1");
+    it("should parse URL correctly", function () {
+        var params = parseUrl("localhost:8989?test=pest&test2=true&test3=false&test4=2&test5=1.1&test5=2.7");
         expect("pest").toEqual(params.test);
         expect(true).toEqual(params.test2);
         expect(false).toEqual(params.test3);
-        expect(2).toEqual(params.test4);
-        expect(1.1).toEqual(params.test5);
-        
-        params = parseUrl("blup?point=49.946505%2C11.571232&point=&");        
-        expect(params.point).toEqual("49.946505,11.571232");        
-        
+        expect("2").toEqual(params.test4);
+        expect(["1.1", "2.7"]).toEqual(params.test5);
+
+        // force array for point
+        // URLs with one point only should work: https://graphhopper.com/maps/?point=50.413331%2C11.699066
+        params = parseUrl("blup?point=49.946505%2C11.571232&point=&");
+        expect(params.point).toEqual(["49.946505,11.571232"]);
+
         params = parseUrl("blup?point=&point=49.946505%2C11.571232");
-        expect(params.point).toEqual("49.946505,11.571232");
+        expect(params.point).toEqual(["49.946505,11.571232"]);
     });
 
-    it("features should work", function() {
+    it("features should work", function () {
         var ghRequest = new GHRequest("http://test.de?vehicle=car");
         var params = {};
         params.elevation = true;
-        ghRequest.features = {"car":{}};
+        ghRequest.features = {"car": {}};
         ghRequest.init(params);
         expect(ghRequest.elevation).toEqual(false);
-        
-        ghRequest.features = {"car":{ elevation: true}};
+
+        ghRequest.features = {"car": {elevation: true}};
         ghRequest.init(params);
         expect(ghRequest.elevation).toEqual(true);
-        
+
         var params = {};
-        ghRequest.features = {"car":{ elevation: true}};
+        ghRequest.features = {"car": {elevation: true}};
         ghRequest.init(params);
         expect(ghRequest.elevation).toEqual(true);
-        
+
         var params = {};
         params.elevation = false;
-        ghRequest.features = {"car":{ elevation: true}};
+        ghRequest.features = {"car": {elevation: true}};
         ghRequest.init(params);
         expect(ghRequest.elevation).toEqual(false);
-        
+
         var params = {};
         params.elevation = true;
-        ghRequest.features = {"car":{ elevation: false}};
+        ghRequest.features = {"car": {elevation: false}};
         ghRequest.init(params);
         expect(ghRequest.elevation).toEqual(false);
     });
-    
-    it("ghrequest should init correctly from params", function() {
+
+    it("ghrequest should init correctly from params", function () {
         var ghRequest = new GHRequest("http://test.de");
         var params = {};
         params.do_zoom = true;
@@ -126,7 +128,7 @@ describe("utils", function() {
         expect(ghRequest.do_zoom).toEqual(params.do_zoom);
     });
 
-    it("input should accept 0 and no addresses", function() {
+    it("input should accept 0 and no addresses", function () {
         var input = new GHInput("12,0");
         expect(input.toString()).toEqual("12,0");
         var input = new GHInput("bluo,0");
@@ -138,19 +140,19 @@ describe("utils", function() {
         var input = new GHInput("");
         expect(input.toString()).toEqual(undefined);
     });
-    
-    it("GHInput should set to unresolved if new input string", function() {
+
+    it("GHInput should set to unresolved if new input string", function () {
         var input = new GHInput("12.44, 68.44");
         expect(input.isResolved()).toEqual(true);
         input.set("blup");
         expect(input.isResolved()).toEqual(false);
     });
 
-    it("point should be parsable", function() {
+    it("point should be parsable", function () {
         expect(new GHInput("12.44, 68.44").lat).toEqual(12.44);
         expect(new GHInput("12.44, 68.44").lng).toEqual(68.44);
         expect(new GHInput("12.44,68.44").lat).toEqual(12.44);
         expect(new GHInput("12.44,68.44").lng).toEqual(68.44);
         expect(new GHInput("london").lon).toEqual(undefined);
-    });    
+    });
 });
\ No newline at end of file
