diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/AlternativeRoutingExternalities.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/AlternativeRoutingExternalities.java
index 8dd43f049f..79ddf74111 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/AlternativeRoutingExternalities.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/AlternativeRoutingExternalities.java
@@ -25,38 +25,36 @@
  */
 public class AlternativeRoutingExternalities {
 
-    String city;
-    String route_type;
-    HashMap<String, FileWriter> outputFiles;
+    private GraphHopper hopper;
+    private MapMatching mapMatching;
+    private String city;
+    private String route_type;
+    private String bannedGridCellsFn;
+    private HashMap<String, FileWriter> outputFiles;
+    private HashMap<String, Integer> gvHeaderMap;
+    private HashMap<String, Float> gridBeauty;
+    private ArrayList<String> optimizations = new ArrayList<>();
+    private ArrayList<String> gridValuesFNs = new ArrayList<>();
+    private ArrayList<float[]> inputPoints = new ArrayList<>();
+    private ArrayList<String> id_to_points = new ArrayList<>();
     private String osmFile = "./reader-osm/files/";
     private String graphFolder = "./reader-osm/target/tmp/";
     private String inputPointsFN = "../data/intermediate/";
-    private String outputPointsFN = "../data/final/impacts/";
+    private String outputPointsFN = "../data/routes/";
     private String gvfnStem = "../data/intermediate/";
-    private String gctfnStem = "../geometries/";
-    private ArrayList<String> gridValuesFNs = new ArrayList<>();
-    private ArrayList<String> gridCTsFNs = new ArrayList<>();
-    private HashMap<String, Integer> gvHeaderMap;
-    private HashMap<String, Float> gridBeauty;
-    private HashMap<String, Integer> gridCT;
-    private GraphHopper hopper;
-    private MapMatching mapMatching;
-    private String outputheader = "ID,name,polyline_points,total_time_in_sec,total_distance_in_meters,number_of_steps,maneuvers,beauty,simplicity,pctNonHighwayTime,pctNonHighwayDist,pctNeiTime,pctNeiDist" +
+    private String gctfnStem = "../data/intermediate/";
+    private String outputheader = "ID,name,polyline_points,total_time_in_sec,total_distance_in_meters," +
+            "number_of_steps,maneuvers,beauty,simplicity,pctNonHighwayTime,pctNonHighwayDist,pctNeiTime,pctNeiDist" +
             System.getProperty("line.separator");
-    private ArrayList<float[]> inputPoints = new ArrayList<>();
-    private ArrayList<String> id_to_points = new ArrayList<>();
-    private ArrayList<String> optimizations = new ArrayList<>();
-    private String bannedGridCellsFn;
-
 
     public AlternativeRoutingExternalities(String city, String route_type) {
-
         this.city = city;
         this.route_type = route_type;
         this.outputFiles = new HashMap<>();
         optimizations.add("beauty");
         optimizations.add("simple");
         optimizations.add("fast");
+        optimizations.add("safety");
     }
 
     public void setCity(String city) {
@@ -67,6 +65,181 @@ public void setRouteType(String route_type) {
         this.route_type = route_type;
     }
 
+    public void setDataSources() throws Exception {
+        if (city.equals("sf")) {
+            osmFile = osmFile + "san-francisco-bay_california.osm.pbf";
+            graphFolder = graphFolder + "ghosm_sf_noch";
+            inputPointsFN = inputPointsFN + "sf_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "sf_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "06075_empath_grid.csv");
+            bannedGridCellsFn = gctfnStem + "06075_banned_grid_cells.csv";
+        } else if (city.equals("nyc")) {
+            osmFile = osmFile + "new-york_new-york.osm.pbf";
+            graphFolder = graphFolder + "ghosm_nyc_noch";
+            inputPointsFN = inputPointsFN + "nyc_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "nyc_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "36005_empath_grid.csv");
+            gridValuesFNs.add(gvfnStem + "36047_empath_grid.csv");
+            gridValuesFNs.add(gvfnStem + "36061_empath_grid.csv");
+            gridValuesFNs.add(gvfnStem + "36081_empath_grid.csv");
+            gridValuesFNs.add(gvfnStem + "36085_empath_grid.csv");
+            bannedGridCellsFn = gctfnStem + "nyc_banned_grid_cells.csv";
+        } else if (city.equals("lon")) {
+            osmFile = osmFile + "london_england.osm.pbf";
+            graphFolder = graphFolder + "ghosm_lon_noch";
+            inputPointsFN = inputPointsFN + "lon_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "lon_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "LONDON_logfractionempath_ft.csv");
+            bannedGridCellsFn = "";
+        } else if (city.equals("man")) {
+            osmFile = osmFile + "manila_philippines.osm.pbf";
+            graphFolder = graphFolder + "ghosm_man_noch";
+            inputPointsFN = inputPointsFN + "man_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "man_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "MANILA_logfractionempath_ft.csv");
+            bannedGridCellsFn = "";
+        } else {
+            throw new Exception("Invalid Parameters: city must be of 'sf','nyc', 'man', or 'sin' and route_type of 'rand' or 'taxi'");
+        }
+    }
+
+    public void getGridValues() throws Exception {
+        gvHeaderMap = new HashMap<>();
+        gridBeauty = new HashMap<>();
+
+        for (String fn : gridValuesFNs) {
+            try {
+                Scanner sc_in = new Scanner(new File(fn));
+                String[] gvHeader = sc_in.nextLine().split(",");
+                int i = 0;
+                for (String col : gvHeader) {
+                    gvHeaderMap.put(col, i);
+                    i++;
+                }
+                String line;
+                String[] vals;
+                String rc;
+                float beauty;
+                while (sc_in.hasNext()) {
+                    line = sc_in.nextLine();
+                    vals = line.split(",");
+                    try {
+                        rc = vals[gvHeaderMap.get("rid")] + "," + vals[gvHeaderMap.get("cid")];
+                        beauty = Float.valueOf(vals[gvHeaderMap.get("beauty")]);
+                        gridBeauty.put(rc, beauty);
+                    } catch (NullPointerException ex) {
+                        System.out.println(ex.getMessage());
+                        System.out.println(line);
+                        continue;
+                    }
+                }
+            } catch (IOException io) {
+                System.out.println(io + ": " + fn + " does not exist.");
+            }
+        }
+    }
+
+    public void setODPairs() throws Exception {
+        for (String optimization : optimizations) {
+            outputFiles.put(optimization, new FileWriter(outputPointsFN.replaceFirst(".csv", "_" + optimization + ".csv"), true));
+        }
+
+        for (FileWriter fw : outputFiles.values()) {
+            fw.write(outputheader);
+        }
+
+        // Bring in origin-destination pairs for processing
+        Scanner sc_in = new Scanner(new File(inputPointsFN));
+        String header = sc_in.nextLine();
+        String od_id;
+        float laF;
+        float loF;
+        float laT;
+        float loT;
+        float idx = 0;
+        System.out.println("Input data points header: " + header);
+        while (sc_in.hasNext()) {
+            idx = idx + 1;
+            String line = sc_in.nextLine();
+            String[] vals = line.split(",");
+            od_id = vals[0];
+            loF = Float.valueOf(vals[1]);
+            laF = Float.valueOf(vals[2]);
+            loT = Float.valueOf(vals[3]);
+            laT = Float.valueOf(vals[4]);
+            inputPoints.add(new float[]{laF, loF, laT, loT, idx});
+            id_to_points.add(od_id);
+        }
+        int numPairs = inputPoints.size();
+        System.out.println(numPairs + " origin-destination pairs.");
+
+    }
+
+    public String writeOutput(int i, String optimized, String name, String od_id, PathWrapper bestPath, float score) {
+
+        // points, distance in meters and time in seconds (convert from ms) of the full path
+        PointList pointList = bestPath.getPoints();
+        int simplicity = bestPath.getSimplicity();
+        double distance = Math.round(bestPath.getDistance() * 100) / 100;
+        double nonHighwayDistance = bestPath.getNonHighwayDistance();
+        double pctNHD = Math.round(1000.0 * (float) nonHighwayDistance / distance) / 1000.0;
+        long timeInSec = bestPath.getTime() / 1000;
+        long nonHighwayTimeInSec = bestPath.getNonHighwayTime() / 1000;
+        double pctNHT = Math.round(1000.0 * (float) nonHighwayTimeInSec / timeInSec) / 1000.0;
+        double smallNeiDistance = bestPath.getNeiHighwayDistance();
+        double pctNeiD = Math.round(1000.0 * (float) smallNeiDistance / distance) / 1000.0;
+        long neiHighwayTimeInSec = bestPath.getTimeSmallNeigh() / 1000;
+        double pctNeiT = Math.round(1000.0 * (float) neiHighwayTimeInSec / timeInSec) / 1000.0;
+        InstructionList il = bestPath.getInstructions();
+        int numDirections = il.getSize();
+        // iterate over every turn instruction
+        ArrayList<String> maneuvers = new ArrayList<>();
+        for (Instruction instruction : il) {
+            maneuvers.add(instruction.getSimpleTurnDescription());
+        }
+
+        System.out.println(i + " (" + optimized + "): Distance: " +
+                distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections +
+                ";\tSimplicity: " + simplicity + ";\tScore: " + score +
+                ";\tPctNHT: " + pctNHT + ";\tPctNeiT: " + pctNeiT);
+
+        return od_id + "," + name + "," +
+                "\"[" + pointList + "]\"," +
+                timeInSec + "," + distance + "," + numDirections +
+                ",\"" + maneuvers.toString() + "\"" + "," +
+                score + "," + simplicity + "," +
+                pctNHT + "," + pctNHD + "," +
+                pctNeiT + "," + pctNeiD +
+                System.getProperty("line.separator");
+
+
+    }
+
+    public float getBeauty(PathWrapper path) {
+        HashSet<String> roundedPoints = path.roundPoints();
+        float score = 0;
+        for (String pt : roundedPoints) {
+            if (gridBeauty.containsKey(pt)) {
+                score = score + gridBeauty.get(pt);
+            }
+        }
+        score = score / roundedPoints.size();
+        return score;
+    }
+
+    public void prepMapMatcher() {
+
+        // create MapMatching object, can and should be shared accross threads
+        AlgorithmOptions algoOpts = AlgorithmOptions.start().
+                algorithm(Parameters.Algorithms.DIJKSTRA).
+                traversalMode(hopper.getTraversalMode()).
+                hints(new HintsMap().put("weighting", "fastest").put("vehicle", "car")).
+                build();
+        mapMatching = new MapMatching(hopper, algoOpts);
+        mapMatching.setTransitionProbabilityBeta(0.00959442);
+        mapMatching.setMeasurementErrorSigma(100);
+    }
+
     public PathWrapper GPXToPath(ArrayList<GPXEntry> gpxEntries) {
         PathWrapper matchGHRsp = new PathWrapper();
         try {
@@ -182,7 +355,8 @@ else if (pointsList.size() > 0) {
         sc_out.close();
     }
 
-    public ConcurrentHashMap<String, String> getPaths(HashMap<String, ArrayList<GPXEntry>> pointLists, HashMap<String, String> routeNames, String optimized) {
+    public ConcurrentHashMap<String, String> getPaths(HashMap<String, ArrayList<GPXEntry>> pointLists,
+                                                      HashMap<String, String> routeNames, String optimized) {
 
         AtomicInteger num_processed = new AtomicInteger();
         int num_routes = pointLists.size();
@@ -206,138 +380,6 @@ else if (pointsList.size() > 0) {
         return results;
     }
 
-    public void setDataSources() throws Exception {
-        if (city.equals("sf")) {
-            osmFile = osmFile + "san-francisco-bay_california.osm.pbf";
-            graphFolder = graphFolder + "ghosm_sf_noch";
-            inputPointsFN = inputPointsFN + "sf_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "sf_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "06075_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "06075_ct_grid.csv");
-            bannedGridCellsFn = gctfnStem + "06075_banned_grid_cells.csv";
-        } else if (city.equals("nyc")) {
-            osmFile = osmFile + "new-york_new-york.osm.pbf";
-            graphFolder = graphFolder + "ghosm_nyc_noch";
-            inputPointsFN = inputPointsFN + "nyc_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "nyc_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "36005_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36047_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36061_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36081_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36085_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "nyc_ct_grid.csv");
-            bannedGridCellsFn = gctfnStem + "nyc_banned_grid_cells.csv";
-        } else if (city.equals("bos")) {
-            osmFile = osmFile + "boston_massachusetts.osm.pbf";
-            graphFolder = graphFolder + "ghosm_bos_noch";
-            inputPointsFN = inputPointsFN + "bos_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "bos_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "25025_beauty_twitter.csv");
-            gridCTsFNs.add(gctfnStem + "25025_ct_grid.csv");
-            bannedGridCellsFn = "";
-        } else if (city.equals("chi")) {
-            osmFile = osmFile + "chicago_illinois.osm.pbf";
-            graphFolder = graphFolder + "ghosm_chi_noch";
-            inputPointsFN = inputPointsFN + "chi_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "chi_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "17031_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "17031_ct_grid.csv");
-            bannedGridCellsFn = "";
-        } else if (city.equals("sin")) {
-            osmFile = osmFile + "singapore.osm.pbf";
-            graphFolder = graphFolder + "ghosm_sin_noch";
-            inputPointsFN = inputPointsFN + "sin_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "sin_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "SINGAPORE_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "");
-            bannedGridCellsFn = "";
-        } else if (city.equals("lon")) {
-            osmFile = osmFile + "london_england.osm.pbf";
-            graphFolder = graphFolder + "ghosm_lon_noch";
-            inputPointsFN = inputPointsFN + "lon_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "lon_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "LONDON_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "");
-            bannedGridCellsFn = "";
-        } else if (city.equals("man")) {
-            osmFile = osmFile + "manila_philippines.osm.pbf";
-            graphFolder = graphFolder + "ghosm_man_noch";
-            inputPointsFN = inputPointsFN + "man_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "man_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "MANILA_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "");
-            bannedGridCellsFn = "";
-        } else {
-            throw new Exception("Invalid Parameters: city must be of 'SF','NYC', or 'BOS' and route_type of 'grid' or 'rand'");
-        }
-    }
-
-    public void getGridValues() throws Exception {
-        gvHeaderMap = new HashMap<>();
-        gridBeauty = new HashMap<>();
-
-        for (String fn : gridValuesFNs) {
-            try {
-                Scanner sc_in = new Scanner(new File(fn));
-                String[] gvHeader = sc_in.nextLine().split(",");
-                int i = 0;
-                for (String col : gvHeader) {
-                    gvHeaderMap.put(col, i);
-                    i++;
-                }
-                String line;
-                String[] vals;
-                String rc;
-                float beauty;
-                while (sc_in.hasNext()) {
-                    line = sc_in.nextLine();
-                    vals = line.split(",");
-                    try {
-                        rc = vals[gvHeaderMap.get("rid")] + "," + vals[gvHeaderMap.get("cid")];
-                        beauty = Float.valueOf(vals[gvHeaderMap.get("beauty")]);
-                        gridBeauty.put(rc, beauty);
-                    } catch (NullPointerException ex) {
-                        System.out.println(ex.getMessage());
-                        System.out.println(line);
-                        continue;
-                    }
-                }
-            } catch (IOException io) {
-                System.out.println(io + ": " + fn + " does not exist.");
-            }
-        }
-    }
-
-    public void getGridCTs() throws Exception {
-        gridCT = new HashMap<>();
-        for (String fn : gridCTsFNs) {
-            try {
-                Scanner sc_in = new Scanner(new File(fn));
-                sc_in.nextLine();
-                String line;
-                String[] vals;
-                String rc;
-                int ct;
-                while (sc_in.hasNext()) {
-                    line = sc_in.nextLine();
-                    vals = line.split(",");
-                    try {
-                        rc = vals[1] + "," + vals[0];
-                        ct = Integer.valueOf(vals[2]);
-                        gridCT.put(rc, ct);
-                    } catch (NullPointerException ex) {
-                        System.out.println(ex.getMessage());
-                        System.out.println(line);
-                        continue;
-                    }
-                }
-
-            } catch (IOException io) {
-                System.out.println(io + ": " + fn + " does not exist.");
-            }
-        }
-    }
-
     public void prepareGraphHopper() {
         // create one GraphHopper instance
         hopper = new GraphHopperOSM().forDesktop().setCHEnabled(false);
@@ -345,116 +387,13 @@ public void prepareGraphHopper() {
         // where to store graphhopper files?
         hopper.setGraphHopperLocation(graphFolder);
         hopper.setEncodingManager(new EncodingManager("car"));
+        hopper.setBannedGridCellsFn(bannedGridCellsFn);
 
         // now this can take minutes if it imports or a few seconds for loading
         // of course this is dependent on the area you import
         hopper.importOrLoad();
     }
 
-    public void prepMapMatcher() {
-
-        // create MapMatching object, can and should be shared accross threads
-        AlgorithmOptions algoOpts = AlgorithmOptions.start().
-                algorithm(Parameters.Algorithms.DIJKSTRA).
-                traversalMode(hopper.getTraversalMode()).
-                hints(new HintsMap().put("weighting", "fastest").put("vehicle", "car")).
-                build();
-        mapMatching = new MapMatching(hopper, algoOpts);
-        mapMatching.setTransitionProbabilityBeta(0.00959442);
-//        mapMatching.setTransitionProbabilityBeta(0.000959442);
-        mapMatching.setMeasurementErrorSigma(100);
-    }
-
-
-    public String writeOutput(int i, String optimized, String name, String od_id, PathWrapper bestPath, float score) {
-
-        // points, distance in meters and time in seconds (convert from ms) of the full path
-        PointList pointList = bestPath.getPoints();
-        int simplicity = bestPath.getSimplicity();
-        double distance = Math.round(bestPath.getDistance() * 100) / 100;
-        double nonHighwayDistance = bestPath.getNonHighwayDistance();
-        double pctNHD = Math.round(1000.0 * (float) nonHighwayDistance / distance) / 1000.0;
-        long timeInSec = bestPath.getTime() / 1000;
-        long nonHighwayTimeInSec = bestPath.getNonHighwayTime() / 1000;
-        double pctNHT = Math.round(1000.0 * (float) nonHighwayTimeInSec / timeInSec) / 1000.0;
-        double smallNeiDistance = bestPath.getNeiHighwayDistance();
-        double pctNeiD = Math.round(1000.0 * (float) smallNeiDistance / distance) / 1000.0;
-        long neiHighwayTimeInSec = bestPath.getTimeSmallNeigh() / 1000;
-        double pctNeiT = Math.round(1000.0 * (float) neiHighwayTimeInSec / timeInSec) / 1000.0;
-        InstructionList il = bestPath.getInstructions();
-        int numDirections = il.getSize();
-        // iterate over every turn instruction
-        ArrayList<String> maneuvers = new ArrayList<>();
-        for (Instruction instruction : il) {
-            maneuvers.add(instruction.getSimpleTurnDescription());
-        }
-
-        System.out.println(i + " (" + optimized + "): Distance: " +
-                distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections +
-                ";\tSimplicity: " + simplicity + ";\tScore: " + score +
-                ";\tPctNHT: " + pctNHT + ";\tPctNeiT: " + pctNeiT);
-
-        return od_id + "," + name + "," +
-                "\"[" + pointList + "]\"," +
-                timeInSec + "," + distance + "," + numDirections +
-                ",\"" + maneuvers.toString() + "\"" + "," +
-                score + "," + simplicity + "," +
-                pctNHT + "," + pctNHD + "," +
-                pctNeiT + "," + pctNeiD +
-                System.getProperty("line.separator");
-
-
-    }
-
-    public float getBeauty(PathWrapper path) {
-        HashSet<String> roundedPoints = path.roundPoints();
-        float score = 0;
-        for (String pt : roundedPoints) {
-            if (gridBeauty.containsKey(pt)) {
-                score = score + gridBeauty.get(pt);
-            }
-        }
-        score = score / roundedPoints.size();
-        return score;
-    }
-
-    public void setODPairs() throws Exception {
-        // Prep Filewriters (Optimized, Worst-but-same-distance, Fastest, Simplest)
-        for (String optimization : optimizations) {
-            outputFiles.put(optimization, new FileWriter(outputPointsFN.replaceFirst(".csv", "_" + optimization + ".csv"), true));
-        }
-
-        for (FileWriter fw : outputFiles.values()) {
-            fw.write(outputheader);
-        }
-
-        // Bring in origin-destination pairs for processing
-        Scanner sc_in = new Scanner(new File(inputPointsFN));
-        String header = sc_in.nextLine();
-        String od_id;
-        float laF;
-        float loF;
-        float laT;
-        float loT;
-        float idx = 0;
-        System.out.println("Input data points header: " + header);
-        while (sc_in.hasNext()) {
-            idx = idx + 1;
-            String line = sc_in.nextLine();
-            String[] vals = line.split(",");
-            od_id = vals[0];
-            loF = Float.valueOf(vals[1]);
-            laF = Float.valueOf(vals[2]);
-            loT = Float.valueOf(vals[3]);
-            laT = Float.valueOf(vals[4]);
-            inputPoints.add(new float[]{laF, loF, laT, loT, idx});
-            id_to_points.add(od_id);
-        }
-        int numPairs = inputPoints.size();
-        System.out.println(numPairs + " origin-destination pairs.");
-
-    }
-
     public void process_routes() throws Exception {
 
         AtomicInteger num_processed = new AtomicInteger();
@@ -464,6 +403,19 @@ public void process_routes() throws Exception {
         for (String optimization : optimizations) {
             results.put(optimization, new ConcurrentHashMap<>());
         }
+
+        if (optimizations.contains("safety")) {
+            // initialize banned edges
+            GHRequest req = new GHRequest(inputPoints.get(0)[0], inputPoints.get(0)[1],
+                    inputPoints.get(0)[2], inputPoints.get(0)[3]).  // latFrom, lonFrom, latTo, lonTo
+                    setWeighting("safest_fastest").
+                    setVehicle("car").
+                    setLocale(Locale.US).
+                    setAlgorithm("dijkstrabi");
+            GHResponse rsp = hopper.route(req);
+        }
+
+
         id_to_points.parallelStream().forEach(od_id -> {
             System.out.println("Processing: " + od_id);
             int route = id_to_points.indexOf(od_id);
@@ -478,28 +430,6 @@ public void process_routes() throws Exception {
         }
         );
 
-        num_processed = new AtomicInteger();
-        // initialize banned edges
-        GHRequest req = new GHRequest(inputPoints.get(0)[0], inputPoints.get(0)[1], inputPoints.get(0)[2], inputPoints.get(0)[3]).  // latFrom, lonFrom, latTo, lonTo
-                setWeighting("safest_fastest").
-                setVehicle("car").
-                setLocale(Locale.US).
-                setAlgorithm("dijkstrabi");
-        GHResponse rsp = hopper.route(req);
-
-        optimizations.add("safety");
-        id_to_points.parallelStream().forEach(od_id -> {
-            System.out.println("Processing: " + od_id);
-            int route = id_to_points.indexOf(od_id);
-            HashMap<String, String> routes = process_route_safety(route);
-            results.get("safety").put(od_id, routes.getOrDefault("safety", "FAILURE"));
-            int i = num_processed.incrementAndGet();
-            if (i % 50 == 0) {
-                System.out.println(System.getProperty("line.separator") + i + " of " + num_odpairs + " o-d pairs processed." + System.getProperty("line.separator"));
-            }
-        }
-        );
-
         for (String optimization : optimizations) {
             for (String result : results.get(optimization).values()) {
                 outputFiles.get(optimization).write(result);
@@ -508,80 +438,6 @@ public void process_routes() throws Exception {
         }
     }
 
-
-    public void print_banned_edges() throws IOException {
-        // Bring in origin-destination pair for processing
-        Scanner sc_in = new Scanner(new File(inputPointsFN));
-        String line = sc_in.nextLine();
-        line = sc_in.nextLine();
-        String[] vals = line.split(",");
-        float loF = Float.valueOf(vals[1]);
-        float laF = Float.valueOf(vals[2]);
-        float loT = Float.valueOf(vals[3]);
-        float laT = Float.valueOf(vals[4]);
-
-        GHRequest req = new GHRequest(laF, loF, laT, loT).  // latFrom, lonFrom, latTo, lonTo
-                setWeighting("safest_fastest").
-                setVehicle("car").
-                setLocale(Locale.US).
-                setAlgorithm("dijkstrabi");
-
-        // print banned edges
-        hopper.route(req);
-    }
-
-
-    public HashMap<String, String> process_route_safety(int route) {
-        // Loop through origin-destination pairs, processing each one for beauty, non-beautiful matched, fastest, and simplest
-        float[] points;
-        String od_id;
-        HashMap<String, String> responses = new HashMap<>();
-
-        // Get Routes
-        points = inputPoints.get(route);
-        od_id = id_to_points.get(route);
-        GHRequest req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
-                setWeighting("safest_fastest").
-                setVehicle("car").
-                setLocale(Locale.US).
-                setAlgorithm("dijkstrabi");
-        GHResponse rsp = hopper.route(req);
-
-        String defaultRow = od_id + ",main," + "\"[(" + points[0] + "," + points[1] + "),(" + points[2] + "," + points[3]
-                + ")]\"," + "-1,-1,-1,[],-1,-1,-1,-1,-1,-1" + System.getProperty("line.separator");
-
-        // first check for errors
-        if (rsp.hasErrors()) {
-            // handle them!
-            System.out.println(rsp.getErrors().toString());
-            System.out.println(route + ": Error - skipping.");
-            for (String optimization : optimizations) {
-                responses.put(optimization, defaultRow);
-            }
-            return responses;
-        }
-
-        // Get All Routes (up to 10K right now)
-        List<PathWrapper> paths = rsp.getAll();
-
-        if (paths.size() == 0) {
-            System.out.println(route + ": No paths - skipping.");
-            for (String optimization : optimizations) {
-                responses.put(optimization, defaultRow);
-            }
-            return responses;
-        }
-
-        // Fastest Safest Route
-        PathWrapper bestPath = paths.get(0);
-        responses.put("safety", writeOutput(route, "Safe", "safe-fastest", od_id, bestPath, getBeauty(bestPath)));
-
-        return responses;
-    }
-
-
-
-
     public HashMap<String, String> process_route(int route) {
         // Loop through origin-destination pairs, processing each one for beauty, non-beautiful matched, fastest, and simplest
         float[] points;
@@ -655,6 +511,36 @@ public void print_banned_edges() throws IOException {
         PathWrapper bestPath = paths.get(0);
         responses.put("fast", writeOutput(route, "Fast", "fastest", od_id, bestPath, getBeauty(bestPath)));
 
+        // Safety Route
+        req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
+                setWeighting("safest_fastest").
+                setVehicle("car").
+                setLocale(Locale.US).
+                setAlgorithm("dijkstrabi");
+        rsp = hopper.route(req);
+
+        // first check for errors
+        if (rsp.hasErrors()) {
+            // handle them!
+            System.out.println(rsp.getErrors().toString());
+            System.out.println(route + ": Error - skipping.");
+            responses.put("safety", defaultRow);
+            return responses;
+        }
+
+        // Get paths (should be one)
+        paths = rsp.getAll();
+
+        if (paths.size() == 0) {
+            System.out.println(route + ": No paths - skipping.");
+            responses.put("safety", defaultRow);
+            return responses;
+        }
+
+        // Fastest Safest Route
+        bestPath = paths.get(0);
+        responses.put("safety", writeOutput(route, "Safe", "safe-fastest", od_id, bestPath, getBeauty(bestPath)));
+
         return responses;
     }
 
@@ -662,36 +548,36 @@ public static void main(String[] args) throws Exception {
 
         // PBFs from: https://mapzen.com/data/metro-extracts/
 
-        String city = "sf";  // sf, nyc, chi, lon, man, sin
-        String odtype = "grid";  // grid, rand
+        // For setting # of cores to use
         //System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "12");
-        //String city = args[0];
-        //String odtype = args[1];
-        AlternativeRoutingExternalities ksp = new AlternativeRoutingExternalities(city, odtype);
+
+        String city = "sf // args[0];  // sf, nyc, lon, man
+        String odtype = "rand"; // args[1];  // rand, taxi
         boolean matchexternal = false;
         boolean getghroutes = true;
 
+        AlternativeRoutingExternalities ksp = new AlternativeRoutingExternalities(city, odtype);
+
         if (matchexternal) {
             ksp.setDataSources();
             ksp.getGridValues();
             ksp.prepareGraphHopper();
-            ksp.getGridCTs();
-            ksp.prepMapMatcher();  // score external API routes
+            ksp.prepMapMatcher();
             String inputfolder = "../data/intermediate/";
-            String outputfolder = "../data/finalMatched/";
+            String outputfolder = "../data/routes/";
             ArrayList<String> platforms = new ArrayList<>();
             platforms.add("google");
             platforms.add("mapquest");
             ArrayList<String> conditions = new ArrayList<>();
             conditions.add("traffic");
-            //conditions.add("notraffic");
             ArrayList<String> routetypes = new ArrayList<>();
             routetypes.add("main");
-            //routetypes.add("alt");
             for (String platform : platforms) {
                 for (String condition : conditions) {
                     for (String routetype : routetypes) {
-                        ksp.PointsToPath(inputfolder + city + "_" + odtype + "_" + platform + "_" + condition + "_routes_" + routetype + "_gpx.csv", outputfolder + city + "_" + odtype + "_" + platform + "_" + condition + "_routes_" + routetype + "_ghenhanced_sigma100_transitionDefault.csv");
+                        ksp.PointsToPath(inputfolder + city + "_" + odtype + "_" + platform + "_" + condition +
+                                "_routes_" + routetype + "_gpx.csv", outputfolder + city + "_" + odtype + "_" +
+                                platform + "_" + condition + "_routes_" + routetype + "_ghenhanced_sigma100_transitionDefault.csv");
                     }
                 }
             }
@@ -702,7 +588,7 @@ public static void main(String[] args) throws Exception {
             ksp.getGridValues();
             ksp.prepareGraphHopper();
             ksp.setODPairs();
-            ksp.process_routes();  // get Graphhopper routes
+            ksp.process_routes();
         }
     }
 }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelFastest_safety.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelFastest_safety.java
deleted file mode 100644
index 2682b6d9b7..0000000000
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelFastest_safety.java
+++ /dev/null
@@ -1,436 +0,0 @@
-package com.graphhopper.reader.osm;
-
-import com.graphhopper.GHRequest;
-import com.graphhopper.GHResponse;
-import com.graphhopper.GraphHopper;
-import com.graphhopper.PathWrapper;
-import com.graphhopper.matching.MapMatching;
-import com.graphhopper.matching.MatchResult;
-import com.graphhopper.routing.AlgorithmOptions;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.HintsMap;
-import com.graphhopper.util.*;
-import com.graphhopper.util.shapes.BBox;
-
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.atomic.AtomicInteger;
-
-
-/**
- * Created by isaac on 09/14/16.
- */
-public class parallelFastest_safety {
-
-    String city;
-    String route_type;
-    HashMap<String, FileWriter> outputFiles;
-    private String osmFile = "./reader-osm/files/";
-    private String graphFolder = "./reader-osm/target/tmp/";
-    private String inputPointsFN = "../data/intermediate/";
-    private String outputPointsFN = "../data/final/impacts/";
-    private float crime_cutoff;
-    private String gvfnStem = "../data/intermediate/";
-    private String gctfnStem = "../geometries/";
-    private ArrayList<String> gridValuesFNs = new ArrayList<>();
-    private ArrayList<String> gridCTsFNs = new ArrayList<>();
-    private HashMap<String, Integer> gvHeaderMap;
-    private HashMap<String, Float> gridBeauty;
-    private HashMap<String, Integer> gridCT;
-    private GraphHopper hopper;
-    private MapMatching mapMatching;
-    private String outputheader = "ID,name,polyline_points,total_time_in_sec,total_distance_in_meters,number_of_steps,maneuvers,beauty,simplicity,pctNonHighwayTime,pctNonHighwayDist,pctNeiTime,pctNeiDist" +
-            System.getProperty("line.separator");
-    private ArrayList<float[]> inputPoints = new ArrayList<>();
-    private ArrayList<String> id_to_points = new ArrayList<>();
-    private ArrayList<String> optimizations = new ArrayList<>();
-    private String bannedGridCellsFn;
-
-
-    public parallelFastest_safety(String city, String route_type, float crime_cutoff) {
-
-        this.city = city;
-        this.route_type = route_type;
-        this.crime_cutoff = crime_cutoff;
-        this.outputFiles = new HashMap<>();
-        optimizations.add("safety");
-    }
-
-    public void setCity(String city) {
-        this.city = city;
-    }
-
-    public void setRouteType(String route_type) {
-        this.route_type = route_type;
-    }
-
-    public PathWrapper GPXToPath(ArrayList<GPXEntry> gpxEntries) {
-        PathWrapper matchGHRsp = new PathWrapper();
-        try {
-            MatchResult mr = mapMatching.doWork(gpxEntries);
-            Path path = mapMatching.calcPath(mr);
-            new PathMerger().doWork(matchGHRsp, Collections.singletonList(path), new TranslationMap().doImport().getWithFallBack(Locale.US));
-        }
-        catch (RuntimeException e) {
-            System.out.println("Broken GPX trace.");
-            System.out.println(e.getMessage());
-        }
-        return matchGHRsp;
-    }
-
-
-    public void setDataSources() throws Exception {
-        if (city.equals("sf")) {
-            osmFile = osmFile + "san-francisco-bay_california.osm.pbf";
-            graphFolder = graphFolder + "ghosm_sf_noch";
-            inputPointsFN = inputPointsFN + "sf_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "sf_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "06075_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "06075_ct_grid.csv");
-            bannedGridCellsFn = gctfnStem + "06075_banned_grid_cells_" + crime_cutoff + ".csv";
-        } else if (city.equals("nyc")) {
-            osmFile = osmFile + "new-york_new-york.osm.pbf";
-            graphFolder = graphFolder + "ghosm_nyc_noch";
-            inputPointsFN = inputPointsFN + "nyc_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "nyc_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "36005_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36047_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36061_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36081_logfractionempath_ft.csv");
-            gridValuesFNs.add(gvfnStem + "36085_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "nyc_ct_grid.csv");
-            bannedGridCellsFn = gctfnStem + "nyc_banned_grid_cells_" + crime_cutoff + ".csv";
-        } else if (city.equals("bos")) {
-            osmFile = osmFile + "boston_massachusetts.osm.pbf";
-            graphFolder = graphFolder + "ghosm_bos_noch";
-            inputPointsFN = inputPointsFN + "bos_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "bos_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "25025_beauty_twitter.csv");
-            gridCTsFNs.add(gctfnStem + "25025_ct_grid.csv");
-            bannedGridCellsFn = "";
-        } else if (city.equals("chi")) {
-            osmFile = osmFile + "chicago_illinois.osm.pbf";
-            graphFolder = graphFolder + "ghosm_chi_noch";
-            inputPointsFN = inputPointsFN + "chi_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "chi_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "17031_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "17031_ct_grid.csv");
-            bannedGridCellsFn = "";
-        } else if (city.equals("sin")) {
-            osmFile = osmFile + "singapore.osm.pbf";
-            graphFolder = graphFolder + "ghosm_sin_noch";
-            inputPointsFN = inputPointsFN + "sin_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "sin_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "SINGAPORE_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "");
-            bannedGridCellsFn = "";
-        } else if (city.equals("lon")) {
-            osmFile = osmFile + "london_england.osm.pbf";
-            graphFolder = graphFolder + "ghosm_lon_noch";
-            inputPointsFN = inputPointsFN + "lon_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "lon_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "LONDON_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "");
-            bannedGridCellsFn = "";
-        } else if (city.equals("man")) {
-            osmFile = osmFile + "manila_philippines.osm.pbf";
-            graphFolder = graphFolder + "ghosm_man_noch";
-            inputPointsFN = inputPointsFN + "man_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "man_" + route_type + "_gh_routes.csv";
-            gridValuesFNs.add(gvfnStem + "MANILA_logfractionempath_ft.csv");
-            gridCTsFNs.add(gctfnStem + "");
-            bannedGridCellsFn = "";
-        } else {
-            throw new Exception("Invalid Parameters: city must be of 'SF','NYC', or 'BOS' and route_type of 'grid' or 'rand'");
-        }
-    }
-
-    public void getGridValues() throws Exception {
-        gvHeaderMap = new HashMap<>();
-        gridBeauty = new HashMap<>();
-
-        for (String fn : gridValuesFNs) {
-            try {
-                Scanner sc_in = new Scanner(new File(fn));
-                String[] gvHeader = sc_in.nextLine().split(",");
-                int i = 0;
-                for (String col : gvHeader) {
-                    gvHeaderMap.put(col, i);
-                    i++;
-                }
-                String line;
-                String[] vals;
-                String rc;
-                float beauty;
-                while (sc_in.hasNext()) {
-                    line = sc_in.nextLine();
-                    vals = line.split(",");
-                    try {
-                        rc = vals[gvHeaderMap.get("rid")] + "," + vals[gvHeaderMap.get("cid")];
-                        beauty = Float.valueOf(vals[gvHeaderMap.get("beauty")]);
-                        gridBeauty.put(rc, beauty);
-                    } catch (NullPointerException ex) {
-                        System.out.println(ex.getMessage());
-                        System.out.println(line);
-                        continue;
-                    }
-                }
-            } catch (IOException io) {
-                System.out.println(io + ": " + fn + " does not exist.");
-            }
-        }
-    }
-
-
-    public void prepareGraphHopper() {
-        // create one GraphHopper instance
-        hopper = new GraphHopperOSM().forDesktop().setCHEnabled(false);
-        hopper.setDataReaderFile(osmFile);
-        // where to store graphhopper files?
-        hopper.setGraphHopperLocation(graphFolder);
-        hopper.setEncodingManager(new EncodingManager("car"));
-        hopper.setBannedGridCellsFn(bannedGridCellsFn);
-
-        // now this can take minutes if it imports or a few seconds for loading
-        // of course this is dependent on the area you import
-        hopper.importOrLoad();
-    }
-
-
-    public String writeOutput(int i, String optimized, String name, String od_id, PathWrapper bestPath, float score) {
-
-        // points, distance in meters and time in seconds (convert from ms) of the full path
-        PointList pointList = bestPath.getPoints();
-        int simplicity = bestPath.getSimplicity();
-        double distance = Math.round(bestPath.getDistance() * 100) / 100;
-        double nonHighwayDistance = bestPath.getNonHighwayDistance();
-        double smallNeiDistance = bestPath.getNeiHighwayDistance();
-        double pctNHD = Math.round(1000.0 * (float) nonHighwayDistance / distance) / 1000.0;
-        double pctNeiD = Math.round(1000.0 * (float) smallNeiDistance / distance) / 1000.0;
-        long timeInSec = bestPath.getTime() / 1000;
-        long nonHighwayTimeInSec = bestPath.getNonHighwayTime() / 1000;
-        long neiHighwayTimeInSec = bestPath.getTimeSmallNeigh() / 1000;
-        double pctNHT = Math.round(1000.0 * (float) nonHighwayTimeInSec / timeInSec) / 1000.0;
-        double pctNeiT = Math.round(1000.0 * (float) neiHighwayTimeInSec / timeInSec) / 1000.0;
-        InstructionList il = bestPath.getInstructions();
-        int numDirections = il.getSize();
-        // iterate over every turn instruction
-        ArrayList<String> maneuvers = new ArrayList<>();
-        for (Instruction instruction : il) {
-            maneuvers.add(instruction.getSimpleTurnDescription());
-        }
-
-        System.out.println(i + " (" + optimized + "): Distance: " + distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections + ";\tSimplicity: " + simplicity + ";\tScore: " + score + ";\tPctNHT: " + pctNHT + ";\tPctNeiT: " + pctNeiT);
-        return od_id + "," + name + "," +
-                "\"[" + pointList + "]\"," +
-                timeInSec + "," + distance + "," + numDirections +
-                ",\"" + maneuvers.toString() + "\"" + "," +
-                score + "," + simplicity + "," +
-                pctNHT + "," + pctNHD + "," +
-                pctNeiT + "," + pctNeiD +
-                System.getProperty("line.separator");
-    }
-
-
-    public void setODPairs() throws Exception {
-        // Prep Filewriters (Optimized, Worst-but-same-distance, Fastest, Simplest)
-        for (String optimization : optimizations) {
-            outputFiles.put(optimization, new FileWriter(outputPointsFN.replaceFirst(".csv", "_" + optimization + "_" + crime_cutoff + ".csv"), true));
-        }
-
-        for (FileWriter fw : outputFiles.values()) {
-            fw.write(outputheader);
-        }
-
-        // Bring in origin-destination pairs for processing
-        Scanner sc_in = new Scanner(new File(inputPointsFN));
-        String header = sc_in.nextLine();
-        String od_id;
-        float laF;
-        float loF;
-        float laT;
-        float loT;
-        float idx = 0;
-        System.out.println("Input data points header: " + header);
-        while (sc_in.hasNext()) {
-            idx = idx + 1;
-            String line = sc_in.nextLine();
-            String[] vals = line.split(",");
-            od_id = vals[0];
-            loF = Float.valueOf(vals[1]);
-            laF = Float.valueOf(vals[2]);
-            loT = Float.valueOf(vals[3]);
-            laT = Float.valueOf(vals[4]);
-            inputPoints.add(new float[]{laF, loF, laT, loT, idx});
-            id_to_points.add(od_id);
-        }
-        int numPairs = inputPoints.size();
-        System.out.println(numPairs + " origin-destination pairs.");
-
-    }
-
-
-    public float getBeauty(PathWrapper path) {
-        HashSet<String> roundedPoints = path.roundPoints();
-        float score = 0;
-        for (String pt : roundedPoints) {
-            if (gridBeauty.containsKey(pt)) {
-                score = score + gridBeauty.get(pt);
-            }
-        }
-        score = score / roundedPoints.size();
-        return score;
-    }
-
-    public void print_banned_edges() throws IOException {
-        // Bring in origin-destination pair for processing
-        Scanner sc_in = new Scanner(new File(inputPointsFN));
-        String line = sc_in.nextLine();
-        line = sc_in.nextLine();
-        String[] vals = line.split(",");
-        float loF = Float.valueOf(vals[1]);
-        float laF = Float.valueOf(vals[2]);
-        float loT = Float.valueOf(vals[3]);
-        float laT = Float.valueOf(vals[4]);
-
-        GHRequest req = new GHRequest(laF, loF, laT, loT).  // latFrom, lonFrom, latTo, lonTo
-                setWeighting("safest_fastest").
-                setVehicle("car").
-                setLocale(Locale.US).
-                setAlgorithm("dijkstrabi");
-
-        // print banned edges
-        hopper.route(req);
-    }
-
-
-    public void process_routes() throws Exception {
-
-        AtomicInteger num_processed = new AtomicInteger();
-        int num_odpairs = id_to_points.size();
-
-        ConcurrentHashMap<String, ConcurrentHashMap<String, String>> results = new ConcurrentHashMap<>();
-        for (String optimization : optimizations) {
-            results.put(optimization, new ConcurrentHashMap<>());
-        }
-
-        // initialize banned edges
-        GHRequest req = new GHRequest(inputPoints.get(0)[0], inputPoints.get(0)[1], inputPoints.get(0)[2], inputPoints.get(0)[3]).  // latFrom, lonFrom, latTo, lonTo
-                setWeighting("safest_fastest").
-                setVehicle("car").
-                setLocale(Locale.US).
-                setAlgorithm("dijkstrabi");
-        GHResponse rsp = hopper.route(req);
-
-        id_to_points.parallelStream().forEach(od_id -> {
-            System.out.println("Processing: " + od_id);
-            int route = id_to_points.indexOf(od_id);
-            HashMap<String, String> routes = process_route(route);
-            for (String optimization : optimizations) {
-                results.get(optimization).put(od_id, routes.getOrDefault(optimization, "FAILURE"));
-            }
-            int i = num_processed.incrementAndGet();
-            if (i % 50 == 0) {
-                System.out.println(System.getProperty("line.separator") + i + " of " + num_odpairs + " o-d pairs processed." + System.getProperty("line.separator"));
-            }
-        }
-        );
-
-        for (String optimization : optimizations) {
-            for (String result : results.get(optimization).values()) {
-                outputFiles.get(optimization).write(result);
-            }
-            outputFiles.get(optimization).close();
-        }
-    }
-
-
-    public HashMap<String, String> process_route(int route) {
-        // Loop through origin-destination pairs, processing each one for beauty, non-beautiful matched, fastest, and simplest
-        float[] points;
-        String od_id;
-        HashMap<String, String> responses = new HashMap<>();
-
-        // Get Routes
-        points = inputPoints.get(route);
-        od_id = id_to_points.get(route);
-        GHRequest req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
-                setWeighting("safest_fastest").
-                setVehicle("car").
-                setLocale(Locale.US).
-                setAlgorithm("dijkstrabi");
-        GHResponse rsp = hopper.route(req);
-
-        String defaultRow = od_id + ",main," + "\"[(" + points[0] + "," + points[1] + "),(" + points[2] + "," + points[3]
-                + ")]\"," + "-1,-1,-1,[],-1,-1,-1,-1,-1,-1" + System.getProperty("line.separator");
-
-        // first check for errors
-        if (rsp.hasErrors()) {
-            // handle them!
-            System.out.println(rsp.getErrors().toString());
-            System.out.println(route + ": Error - skipping.");
-            for (String optimization : optimizations) {
-                responses.put(optimization, defaultRow);
-            }
-            return responses;
-        }
-
-        // Get All Routes (up to 10K right now)
-        List<PathWrapper> paths = rsp.getAll();
-
-        if (paths.size() == 0) {
-            System.out.println(route + ": No paths - skipping.");
-            for (String optimization : optimizations) {
-                responses.put(optimization, defaultRow);
-            }
-            return responses;
-        }
-
-        // Fastest Safest Route
-        PathWrapper bestPath = paths.get(0);
-        responses.put("safety", writeOutput(route, "Safe", "safe-fastest", od_id, bestPath, getBeauty(bestPath)));
-
-        return responses;
-    }
-
-    public static void main(String[] args) throws Exception {
-
-        // PBFs from: https://mapzen.com/data/metro-extracts/
-
-        String city = "sf";  // sf, nyc, chi, lon, man, sin
-        String odtype = "grid";  // grid, rand
-        float[] crime_cutoffs = new float[5];
-        if (city.equalsIgnoreCase("nyc")) {
-            crime_cutoffs[0] = 2.7f;
-            crime_cutoffs[1] = 3.95f;
-            crime_cutoffs[2] = 4.95f;
-            crime_cutoffs[3] = 6.5f;
-            crime_cutoffs[4] = 10.5f;
-        } else if (city.equalsIgnoreCase("sf")) {
-            crime_cutoffs[0] = 4;
-            crime_cutoffs[1] = 5.5f;
-            crime_cutoffs[2] = 7.4f;
-            crime_cutoffs[3] = 15;
-            crime_cutoffs[4] = 50;
-        }
-
-
-        //System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "12");
-        //String city = args[0];
-        //String odtype = args[1];
-        for (int i=0; i < crime_cutoffs.length; i++) {
-            System.out.println(i);
-            parallelFastest_safety ksp = new parallelFastest_safety(city, odtype, crime_cutoffs[i]);
-            ksp.setDataSources();
-            ksp.getGridValues();
-            ksp.prepareGraphHopper();
-            ksp.print_banned_edges();
-//            ksp.setODPairs();
-//            ksp.process_routes();  // get Graphhopper routes
-        }
-    }
-}
