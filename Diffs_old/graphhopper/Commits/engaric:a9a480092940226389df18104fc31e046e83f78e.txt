diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index f1d7256b66..2456cf044b 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -95,7 +95,8 @@
  * @see GraphHopperAPI
  * @author Peter Karich
  */
-public class GraphHopper implements GraphHopperAPI {
+public class GraphHopper implements GraphHopperAPI
+{
 	private static final String READER_UNAVAILABLE = "DataReader implementation %s not available check your setting for reader.implementation.  Allowed options are OSM, OSITN or OSDPN";
 	private final Logger logger = LoggerFactory.getLogger(getClass());
 	// for graph:
@@ -144,18 +145,20 @@
 	private final AtomicLong visitedSum = new AtomicLong(0);
 
 	/**
-	 * Certain readers require additional arguments so this can be passed to
-	 * them as a constructor parameter
+	 * Certain readers require additional arguments so this can be passed to them as a constructor
+	 * parameter
 	 */
 	private CmdArgs args;
 
-	public GraphHopper() {
+	public GraphHopper()
+	{
 	}
 
 	/**
 	 * For testing only
 	 */
-	protected GraphHopper loadGraph(GraphStorage g) {
+	protected GraphHopper loadGraph( GraphStorage g )
+	{
 		this.graph = g;
 		fullyLoaded = true;
 		initLocationIndex();
@@ -163,11 +166,11 @@ protected GraphHopper loadGraph(GraphStorage g) {
 	}
 
 	/**
-	 * Specify which vehicles can be read by this GraphHopper instance. An
-	 * encoding manager defines how data from every vehicle is written (und
-	 * read) into edges of the graph.
+	 * Specify which vehicles can be read by this GraphHopper instance. An encoding manager defines
+	 * how data from every vehicle is written (und read) into edges of the graph.
 	 */
-	public GraphHopper setEncodingManager(EncodingManager em) {
+	public GraphHopper setEncodingManager( EncodingManager em )
+	{
 		ensureNotLoaded();
 		this.encodingManager = em;
 		if (em.needsTurnCostsSupport())
@@ -176,19 +179,23 @@ public GraphHopper setEncodingManager(EncodingManager em) {
 		return this;
 	}
 
-	FlagEncoder getDefaultVehicle() {
-		if (encodingManager == null) {
+	FlagEncoder getDefaultVehicle()
+	{
+		if (encodingManager == null)
+		{
 			throw new IllegalStateException("No encoding manager specified or loaded");
 		}
 
 		return encodingManager.fetchEdgeEncoders().get(0);
 	}
 
-	public EncodingManager getEncodingManager() {
+	public EncodingManager getEncodingManager()
+	{
 		return encodingManager;
 	}
 
-	public GraphHopper setElevationProvider(ElevationProvider eleProvider) {
+	public GraphHopper setElevationProvider( ElevationProvider eleProvider )
+	{
 		if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
 			setElevation(false);
 		else
@@ -200,24 +207,25 @@ public GraphHopper setElevationProvider(ElevationProvider eleProvider) {
 	/**
 	 * Threads for data reading.
 	 */
-	protected int getWorkerThreads() {
+	protected int getWorkerThreads()
+	{
 		return workerThreads;
 	}
 
 	/**
-	 * Return maximum distance (in meter) to reduce points via douglas peucker
-	 * while OSM import.
+	 * Return maximum distance (in meter) to reduce points via douglas peucker while OSM import.
 	 */
-	protected double getWayPointMaxDistance() {
+	protected double getWayPointMaxDistance()
+	{
 		return osmReaderWayPointMaxDistance;
 	}
 
 	/**
-	 * This parameter specifies how to reduce points via douglas peucker while
-	 * OSM import. Higher value means more details, unit is meter. Default is 1.
-	 * Disable via 0.
+	 * This parameter specifies how to reduce points via douglas peucker while OSM import. Higher
+	 * value means more details, unit is meter. Default is 1. Disable via 0.
 	 */
-	public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance) {
+	public GraphHopper setWayPointMaxDistance( double wayPointMaxDistance )
+	{
 		this.osmReaderWayPointMaxDistance = wayPointMaxDistance;
 		return this;
 	}
@@ -225,55 +233,61 @@ public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance) {
 	/**
 	 * Sets the default traversal mode used for the algorithms and preparation.
 	 */
-	public GraphHopper setTraversalMode(TraversalMode traversalMode) {
+	public GraphHopper setTraversalMode( TraversalMode traversalMode )
+	{
 		this.traversalMode = traversalMode;
 		return this;
 	}
 
-	public TraversalMode getTraversalMode() {
+	public TraversalMode getTraversalMode()
+	{
 		return traversalMode;
 	}
 
 	/**
-	 * Configures the underlying storage and response to be used on a well
-	 * equipped server. Result also optimized for usage in the web module i.e.
-	 * try reduce network IO.
+	 * Configures the underlying storage and response to be used on a well equipped server. Result
+	 * also optimized for usage in the web module i.e. try reduce network IO.
 	 */
-	public GraphHopper forServer() {
+	public GraphHopper forServer()
+	{
 		setSimplifyResponse(true);
 		return setInMemory();
 	}
 
 	/**
-	 * Configures the underlying storage to be used on a Desktop computer or
-	 * within another Java application with enough RAM but no network latency.
+	 * Configures the underlying storage to be used on a Desktop computer or within another Java
+	 * application with enough RAM but no network latency.
 	 */
-	public GraphHopper forDesktop() {
+	public GraphHopper forDesktop()
+	{
 		setSimplifyResponse(false);
 		return setInMemory();
 	}
 
 	/**
-	 * Configures the underlying storage to be used on a less powerful machine
-	 * like Android or Raspberry Pi with only few MB of RAM.
+	 * Configures the underlying storage to be used on a less powerful machine like Android or
+	 * Raspberry Pi with only few MB of RAM.
 	 */
-	public GraphHopper forMobile() {
+	public GraphHopper forMobile()
+	{
 		setSimplifyResponse(false);
 		return setMemoryMapped();
 	}
 
 	/**
-	 * Precise location resolution index means also more space (disc/RAM) could
-	 * be consumed and probably slower query times, which would be e.g. not
-	 * suitable for Android. The resolution specifies the tile width (in meter).
+	 * Precise location resolution index means also more space (disc/RAM) could be consumed and
+	 * probably slower query times, which would be e.g. not suitable for Android. The resolution
+	 * specifies the tile width (in meter).
 	 */
-	public GraphHopper setPreciseIndexResolution(int precision) {
+	public GraphHopper setPreciseIndexResolution( int precision )
+	{
 		ensureNotLoaded();
 		preciseIndexResolution = precision;
 		return this;
 	}
 
-	public void setMinNetworkSize(int minNetworkSize, int minOneWayNetworkSize) {
+	public void setMinNetworkSize( int minNetworkSize, int minOneWayNetworkSize )
+	{
 		this.minNetworkSize = minNetworkSize;
 		this.minOneWayNetworkSize = minOneWayNetworkSize;
 	}
@@ -281,23 +295,23 @@ public void setMinNetworkSize(int minNetworkSize, int minOneWayNetworkSize) {
 	/**
 	 * This method call results in an in-memory graph.
 	 */
-	public GraphHopper setInMemory() {
+	public GraphHopper setInMemory()
+	{
 		ensureNotLoaded();
 		dataAccessType = DAType.RAM_STORE;
 		return this;
 	}
 
 	/**
-	 * Only valid option for in-memory graph and if you e.g. want to disable
-	 * store on flush for unit tests. Specify storeOnFlush to true if you want
-	 * that existing data will be loaded FROM disc and all in-memory data will
-	 * be flushed TO disc after flush is called e.g. while OSM import.
+	 * Only valid option for in-memory graph and if you e.g. want to disable store on flush for unit
+	 * tests. Specify storeOnFlush to true if you want that existing data will be loaded FROM disc
+	 * and all in-memory data will be flushed TO disc after flush is called e.g. while OSM import.
 	 * <p>
-	 * 
-	 * @param storeOnFlush
-	 *            true by default
+	 *
+	 * @param storeOnFlush true by default
 	 */
-	public GraphHopper setStoreOnFlush(boolean storeOnFlush) {
+	public GraphHopper setStoreOnFlush( boolean storeOnFlush )
+	{
 		ensureNotLoaded();
 		if (storeOnFlush)
 			dataAccessType = DAType.RAM_STORE;
@@ -307,10 +321,10 @@ public GraphHopper setStoreOnFlush(boolean storeOnFlush) {
 	}
 
 	/**
-	 * Enable memory mapped configuration if not enough memory is available on
-	 * the target platform.
+	 * Enable memory mapped configuration if not enough memory is available on the target platform.
 	 */
-	public GraphHopper setMemoryMapped() {
+	public GraphHopper setMemoryMapped()
+	{
 		ensureNotLoaded();
 		dataAccessType = DAType.MMAP;
 		return this;
@@ -319,50 +333,52 @@ public GraphHopper setMemoryMapped() {
 	/**
 	 * Not yet stable enough to offer it for everyone
 	 */
-	private GraphHopper setUnsafeMemory() {
+	private GraphHopper setUnsafeMemory()
+	{
 		ensureNotLoaded();
 		dataAccessType = DAType.UNSAFE_STORE;
 		return this;
 	}
 
 	/**
-	 * Enables the use of contraction hierarchies to reduce query times. Enabled
-	 * by default.
+	 * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
 	 * <p/>
-	 * 
-	 * @param weighting
-	 *            can be "fastest", "shortest" or your own weight-calculation
-	 *            type.
+	 *
+	 * @param weighting can be "fastest", "shortest" or your own weight-calculation type.
 	 * @see #setCHEnable(boolean)
 	 */
-	public GraphHopper setCHWeighting(String weighting) {
+	public GraphHopper setCHWeighting( String weighting )
+	{
 		ensureNotLoaded();
 		chWeightingStr = weighting;
 		return this;
 	}
 
-	public String getCHWeighting() {
+	public String getCHWeighting()
+	{
 		return chWeightingStr;
 	}
 
 	/**
-	 * Disables the "CH-preparation" preparation only. Use only if you know what
-	 * you do. To disable the full usage of CH use setCHEnable(false) instead.
+	 * Disables the "CH-preparation" preparation only. Use only if you know what you do. To disable
+	 * the full usage of CH use setCHEnable(false) instead.
 	 */
-	public GraphHopper setDoPrepare(boolean doPrepare) {
+	public GraphHopper setDoPrepare( boolean doPrepare )
+	{
 		this.doPrepare = doPrepare;
 		return this;
 	}
 
 	/**
-	 * Enables or disables contraction hierarchies (CH). This speed-up mode is
-	 * enabled by default. Disabling CH is only recommended for short routes or
-	 * in combination with setDefaultWeightLimit and called flexibility mode
+	 * Enables or disables contraction hierarchies (CH). This speed-up mode is enabled by default.
+	 * Disabling CH is only recommended for short routes or in combination with
+	 * setDefaultWeightLimit and called flexibility mode
 	 * <p>
-	 * 
+	 *
 	 * @see #setDefaultWeightLimit(double)
 	 */
-	public GraphHopper setCHEnable(boolean enable) {
+	public GraphHopper setCHEnable( boolean enable )
+	{
 		ensureNotLoaded();
 		algoFactory = null;
 		chEnabled = enable;
@@ -370,60 +386,64 @@ public GraphHopper setCHEnable(boolean enable) {
 	}
 
 	/**
-	 * This methods stops the algorithm from searching further if the resulting
-	 * path would go over specified weight, important if CH is disabled. The
-	 * unit is defined by the used weighting created from createWeighting, e.g.
-	 * distance for shortest or seconds for the standard FastestWeighting
-	 * implementation.
+	 * This methods stops the algorithm from searching further if the resulting path would go over
+	 * specified weight, important if CH is disabled. The unit is defined by the used weighting
+	 * created from createWeighting, e.g. distance for shortest or seconds for the standard
+	 * FastestWeighting implementation.
 	 */
-	public void setDefaultWeightLimit(double defaultWeightLimit) {
+	public void setDefaultWeightLimit( double defaultWeightLimit )
+	{
 		this.defaultWeightLimit = defaultWeightLimit;
 	}
 
-	public boolean isCHEnabled() {
+	public boolean isCHEnabled()
+	{
 		return chEnabled;
 	}
 
 	/**
-	 * @return true if storing and fetching elevation data is enabled. Default
-	 *         is false
+	 * @return true if storing and fetching elevation data is enabled. Default is false
 	 */
-	public boolean hasElevation() {
+	public boolean hasElevation()
+	{
 		return elevation;
 	}
 
 	/**
 	 * Enable storing and fetching elevation data. Default is false
 	 */
-	public GraphHopper setElevation(boolean includeElevation) {
+	public GraphHopper setElevation( boolean includeElevation )
+	{
 		this.elevation = includeElevation;
 		return this;
 	}
 
 	/**
-	 * This method specifies if the import should include way names to be able
-	 * to return instructions for a route.
+	 * This method specifies if the import should include way names to be able to return
+	 * instructions for a route.
 	 */
-	public GraphHopper setEnableInstructions(boolean b) {
+	public GraphHopper setEnableInstructions( boolean b )
+	{
 		ensureNotLoaded();
 		enableInstructions = b;
 		return this;
 	}
 
 	/**
-	 * This methods enables gps point calculation. If disabled only distance
-	 * will be calculated.
+	 * This methods enables gps point calculation. If disabled only distance will be calculated.
 	 */
-	public GraphHopper setEnableCalcPoints(boolean b) {
+	public GraphHopper setEnableCalcPoints( boolean b )
+	{
 		calcPoints = b;
 		return this;
 	}
 
 	/**
-	 * This method specifies if the returned path should be simplified or not,
-	 * via douglas-peucker or similar algorithm.
+	 * This method specifies if the returned path should be simplified or not, via douglas-peucker
+	 * or similar algorithm.
 	 */
-	private GraphHopper setSimplifyResponse(boolean doSimplify) {
+	private GraphHopper setSimplifyResponse( boolean doSimplify )
+	{
 		this.simplifyResponse = doSimplify;
 		return this;
 	}
@@ -431,7 +451,8 @@ private GraphHopper setSimplifyResponse(boolean doSimplify) {
 	/**
 	 * Sets the graphhopper folder.
 	 */
-	public GraphHopper setGraphHopperLocation(String ghLocation) {
+	public GraphHopper setGraphHopperLocation( String ghLocation )
+	{
 		ensureNotLoaded();
 		if (ghLocation == null)
 			throw new IllegalArgumentException("graphhopper location cannot be null");
@@ -440,15 +461,17 @@ public GraphHopper setGraphHopperLocation(String ghLocation) {
 		return this;
 	}
 
-	public String getGraphHopperLocation() {
+	public String getGraphHopperLocation()
+	{
 		return ghLocation;
 	}
 
 	/**
-	 * This file can be an osm xml (.osm), a compressed xml (.osm.zip or
-	 * .osm.gz) or a protobuf file (.pbf).
+	 * This file can be an osm xml (.osm), a compressed xml (.osm.zip or .osm.gz) or a protobuf file
+	 * (.pbf).
 	 */
-	public GraphHopper setOSMFile(String osmFileStr) {
+	public GraphHopper setOSMFile( String osmFileStr )
+	{
 		ensureNotLoaded();
 		if (Helper.isEmpty(osmFileStr))
 			throw new IllegalArgumentException("OSM file cannot be empty.");
@@ -457,40 +480,43 @@ public GraphHopper setOSMFile(String osmFileStr) {
 		return this;
 	}
 
-	public String getOSMFile() {
+	public String getOSMFile()
+	{
 		return osmFile;
 	}
 
 	/**
 	 * The underlying graph used in algorithms.
 	 * <p>
-	 * 
-	 * @throws IllegalStateException
-	 *             if graph is not instantiated.
+	 *
+	 * @throws IllegalStateException if graph is not instantiated.
 	 */
-	public GraphStorage getGraph() {
+	public GraphStorage getGraph()
+	{
 		if (graph == null)
 			throw new IllegalStateException("Graph not initialized");
 
 		return graph;
 	}
 
-	public void setGraph(GraphStorage graph) {
+	public void setGraph( GraphStorage graph )
+	{
 		this.graph = graph;
 	}
 
-	protected void setLocationIndex(LocationIndex locationIndex) {
+	protected void setLocationIndex( LocationIndex locationIndex )
+	{
 		this.locationIndex = locationIndex;
 	}
 
 	/**
 	 * The location index created from the graph.
 	 * <p>
-	 * 
-	 * @throws IllegalStateException
-	 *             if index is not initialized
+	 *
+	 * @throws IllegalStateException if index is not initialized
 	 */
-	public LocationIndex getLocationIndex() {
+	public LocationIndex getLocationIndex()
+	{
 		if (locationIndex == null)
 			throw new IllegalStateException("Location index not initialized");
 
@@ -500,37 +526,40 @@ public LocationIndex getLocationIndex() {
 	/**
 	 * Sorts the graph which requires more RAM while import. See #12
 	 */
-	public GraphHopper setSortGraph(boolean sortGraph) {
+	public GraphHopper setSortGraph( boolean sortGraph )
+	{
 		ensureNotLoaded();
 		this.sortGraph = sortGraph;
 		return this;
 	}
 
 	/**
-	 * Specifies if it is allowed for GraphHopper to write. E.g. for read only
-	 * filesystems it is not possible to create a lock file and so we can avoid
-	 * write locks.
+	 * Specifies if it is allowed for GraphHopper to write. E.g. for read only filesystems it is not
+	 * possible to create a lock file and so we can avoid write locks.
 	 */
-	public GraphHopper setAllowWrites(boolean allowWrites) {
+	public GraphHopper setAllowWrites( boolean allowWrites )
+	{
 		this.allowWrites = allowWrites;
 		return this;
 	}
 
-	public boolean isAllowWrites() {
+	public boolean isAllowWrites()
+	{
 		return allowWrites;
 	}
 
-	public TranslationMap getTranslationMap() {
+	public TranslationMap getTranslationMap()
+	{
 		return trMap;
 	}
 
 	/**
-	 * Reads configuration from a CmdArgs object. Which can be manually filled,
-	 * or via main(String[] args) ala CmdArgs.read(args) or via configuration
-	 * file ala CmdArgs.readFromConfig("config.properties",
-	 * "graphhopper.config")
+	 * Reads configuration from a CmdArgs object. Which can be manually filled, or via main(String[]
+	 * args) ala CmdArgs.read(args) or via configuration file ala
+	 * CmdArgs.readFromConfig("config.properties", "graphhopper.config")
 	 */
-	public GraphHopper init(CmdArgs args) {
+	public GraphHopper init( CmdArgs args )
+	{
 		args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
 		this.args = args;
 		String tmpOsmFile = args.get("osmreader.osm", "");
@@ -540,7 +569,8 @@ public GraphHopper init(CmdArgs args) {
 		dataReader = args.get("reader.implementation", dataReader);
 
 		String graphHopperFolder = args.get("graph.location", "");
-		if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation)) {
+		if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation))
+		{
 			if (Helper.isEmpty(osmFile))
 				throw new IllegalArgumentException("You need to specify an OSM file.");
 
@@ -556,7 +586,7 @@ public GraphHopper init(CmdArgs args) {
 
 		sortGraph = args.getBool("graph.doSort", sortGraph);
 		removeZipped = args.getBool("graph.removeZipped", removeZipped);
-		int bytesForFlags = args.getInt("graph.bytesForFlags", 8);
+		int bytesForFlags = args.getInt("graph.bytesForFlags", 4);
 		if (args.get("graph.locktype", "native").equals("simple"))
 			lockFactory = new SimpleFSLockFactory();
 		else
@@ -569,11 +599,14 @@ public GraphHopper init(CmdArgs args) {
 		String baseURL = args.get("graph.elevation.baseurl", "");
 		DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
 		ElevationProvider tmpProvider = ElevationProvider.NOOP;
-		if (eleProviderStr.equalsIgnoreCase("srtm")) {
+		if (eleProviderStr.equalsIgnoreCase("srtm"))
+		{
 			tmpProvider = new SRTMProvider();
-		} else if (eleProviderStr.equalsIgnoreCase("cgiar")) {
+		} else if (eleProviderStr.equalsIgnoreCase("cgiar"))
+		{
 			CGIARProvider cgiarProvider = new CGIARProvider();
-            cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear", true));
+			cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear",
+					true));
 			tmpProvider = cgiarProvider;
 		}
 
@@ -601,7 +634,8 @@ public GraphHopper init(CmdArgs args) {
 		logMessages = args.getDouble("prepare.logmessages", logMessages);
 
 		// osm import
-        osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
+		osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance",
+				osmReaderWayPointMaxDistance);
 		String flagEncoders = args.get("graph.flagEncoders", "");
 		if (!flagEncoders.isEmpty())
 			setEncodingManager(new EncodingManager(flagEncoders, bytesForFlags));
@@ -618,23 +652,27 @@ public GraphHopper init(CmdArgs args) {
 		return this;
 	}
 
-	private void printInfo() {
-        logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
+	private void printInfo()
+	{
+		logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " ("
+				+ Constants.getVersions() + ")");
 		if (graph != null)
 			logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
 	}
 
 	/**
-	 * Imports provided data from disc and creates graph. Depending on the
-	 * settings the resulting graph will be stored to disc so on a second call
-	 * this method will only load the graph from disc which is usually a lot
-	 * faster.
+	 * Imports provided data from disc and creates graph. Depending on the settings the resulting
+	 * graph will be stored to disc so on a second call this method will only load the graph from
+	 * disc which is usually a lot faster.
 	 */
-	public GraphHopper importOrLoad() {
-		if (!load(ghLocation)) {
+	public GraphHopper importOrLoad()
+	{
+		if (!load(ghLocation))
+		{
 			printInfo();
 			process(ghLocation);
-		} else {
+		} else
+		{
 			printInfo();
 		}
 		return this;
@@ -643,11 +681,14 @@ public GraphHopper importOrLoad() {
 	/**
 	 * Creates the graph from OSM data.
 	 */
-	private GraphHopper process(String graphHopperLocation) {
+	private GraphHopper process( String graphHopperLocation )
+	{
 		setGraphHopperLocation(graphHopperLocation);
 		Lock lock = null;
-		try {
-			if (graph.getDirectory().getDefaultType().isStoring()) {
+		try
+		{
+			if (graph.getDirectory().getDefaultType().isStoring())
+			{
 				lockFactory.setLockDir(new File(graphHopperLocation));
 				lock = lockFactory.create(fileLockName, true);
 				if (!lock.tryLock())
@@ -656,24 +697,28 @@ private GraphHopper process(String graphHopperLocation) {
 									+ graphHopperLocation, lock.getObtainFailedReason());
 			}
 
-			try {
+			try
+			{
 				importData();
 				graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
-			} catch (IOException ex) {
+			} catch (IOException ex)
+			{
 				throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
 			}
 			cleanUp();
 			optimize();
 			postProcessing();
 			flush();
-		} finally {
+		} finally
+		{
 			if (lock != null)
 				lock.release();
 		}
 		return this;
 	}
 
-	protected DataReader importData() throws IOException {
+	protected DataReader importData() throws IOException
+	{
 		ensureWriteAccess();
 		if (graph == null)
 			throw new IllegalStateException("Load graph before importing OSM data");
@@ -689,7 +734,8 @@ protected DataReader importData() throws IOException {
 		return reader;
 	}
 
-	protected DataReader createReader(GraphStorage tmpGraph) {
+	protected DataReader createReader( GraphStorage tmpGraph )
+	{
 		DataReader reader;
 		if ("OSM".equals(dataReader))
 			reader = new OSMReader(tmpGraph);
@@ -699,54 +745,66 @@ else if ("OSDPN".equals(dataReader))
 			reader = new OsDpnReader(tmpGraph, args);
 		else if ("OSHN".equals(dataReader))
 			reader = new OsHnReader(tmpGraph);
-		else {
+		else
+		{
 			String exceptionMessage = String.format(READER_UNAVAILABLE, dataReader);
 			throw new IllegalArgumentException(exceptionMessage);
 		}
 		return initReader(reader);
 	}
 
-	protected DataReader initReader(DataReader reader) {
+	protected DataReader initReader( DataReader reader )
+	{
 		if (osmFile == null)
 			throw new IllegalArgumentException("No OSM file specified");
 
 		logger.info("start creating graph from " + osmFile);
 		File osmTmpFile = new File(osmFile);
-        return reader.setOSMFile(osmTmpFile).setElevationProvider(eleProvider).setWorkerThreads(workerThreads)
-                .setEncodingManager(encodingManager).setWayPointMaxDistance(osmReaderWayPointMaxDistance);
+		return reader.setOSMFile(osmTmpFile).setElevationProvider(eleProvider)
+				.setWorkerThreads(workerThreads).setEncodingManager(encodingManager)
+				.setWayPointMaxDistance(osmReaderWayPointMaxDistance);
 	}
 
 	/**
 	 * Opens existing graph.
 	 * <p/>
-	 * 
-	 * @param graphHopperFolder
-	 *            is the folder containing graphhopper files (which can be
-	 *            compressed too)
+	 *
+	 * @param graphHopperFolder is the folder containing graphhopper files (which can be compressed
+	 *            too)
 	 */
 	@Override
-	public boolean load(String graphHopperFolder) {
+	public boolean load( String graphHopperFolder )
+	{
 		if (Helper.isEmpty(graphHopperFolder))
-            throw new IllegalStateException("graphHopperLocation is not specified. call init before");
+			throw new IllegalStateException(
+					"graphHopperLocation is not specified. call init before");
 
 		if (fullyLoaded)
 			throw new IllegalStateException("graph is already successfully loaded");
 
-		if (graphHopperFolder.endsWith("-gh")) {
+		if (graphHopperFolder.endsWith("-gh"))
+		{
 			// do nothing
-		} else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml")) {
+		} else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml"))
+		{
 			throw new IllegalArgumentException("To import an osm file you need to use importOrLoad");
-		} else if (!graphHopperFolder.contains(".")) {
+		} else if (!graphHopperFolder.contains("."))
+		{
 			if (new File(graphHopperFolder + "-gh").exists())
 				graphHopperFolder += "-gh";
-		} else {
+		} else
+		{
 			File compressed = new File(graphHopperFolder + ".ghz");
-			if (compressed.exists() && !compressed.isDirectory()) {
-				try {
-                    new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder, removeZipped);
-				} catch (IOException ex) {
-                    throw new RuntimeException("Couldn't extract file " + compressed.getAbsolutePath() + " to "
-                            + graphHopperFolder, ex);
+			if (compressed.exists() && !compressed.isDirectory())
+			{
+				try
+				{
+					new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder,
+							removeZipped);
+				} catch (IOException ex)
+				{
+					throw new RuntimeException("Couldn't extract file "
+							+ compressed.getAbsolutePath() + " to " + graphHopperFolder, ex);
 				}
 			}
 		}
@@ -774,11 +832,13 @@ else if (encodingManager.needsAttributeStorageSupport())
 		graph.setSegmentSize(defaultSegmentSize);
 
 		Lock lock = null;
-		try {
+		try
+		{
 			// create locks only if writes are allowed, if they are not allowed
 			// a lock cannot be created
 			// (e.g. on a read only filesystem locks would fail)
-			if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites()) {
+			if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites())
+			{
 				lockFactory.setLockDir(new File(ghLocation));
 				lock = lockFactory.create(fileLockName, false);
 				if (!lock.tryLock())
@@ -793,27 +853,31 @@ else if (encodingManager.needsAttributeStorageSupport())
 			postProcessing();
 			fullyLoaded = true;
 			return true;
-		} finally {
+		} finally
+		{
 			if (lock != null)
 				lock.release();
 		}
 	}
 
-	public RoutingAlgorithmFactory getAlgorithmFactory() {
+	public RoutingAlgorithmFactory getAlgorithmFactory()
+	{
 		if (algoFactory == null)
 			this.algoFactory = new RoutingAlgorithmFactorySimple();
 
 		return algoFactory;
 	}
 
-	public void setAlgorithmFactory(RoutingAlgorithmFactory algoFactory) {
+	public void setAlgorithmFactory( RoutingAlgorithmFactory algoFactory )
+	{
 		this.algoFactory = algoFactory;
 	}
 
 	/**
 	 * Sets EncodingManager, does the preparation and creates the locationIndex
 	 */
-	protected void postProcessing() {
+	protected void postProcessing()
+	{
 		initLocationIndex();
 		if (chEnabled)
 			algoFactory = createPrepare();
@@ -824,68 +888,79 @@ protected void postProcessing() {
 			prepare();
 	}
 
-	private boolean isPrepared() {
+	private boolean isPrepared()
+	{
 		return "true".equals(graph.getProperties().get("prepare.done"));
 	}
 
-	protected RoutingAlgorithmFactory createPrepare() {
+	protected RoutingAlgorithmFactory createPrepare()
+	{
 		FlagEncoder defaultVehicle = getDefaultVehicle();
 		Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), defaultVehicle);
-        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(new GHDirectory("",
-                DAType.RAM_INT), (LevelGraph) graph, defaultVehicle, weighting, traversalMode);
+		PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(
+				new GHDirectory("", DAType.RAM_INT), (LevelGraph) graph, defaultVehicle, weighting,
+				traversalMode);
 		tmpPrepareCH.setPeriodicUpdates(periodicUpdates).setLazyUpdates(lazyUpdates)
-				.setNeighborUpdates(neighborUpdates).setLogMessages(logMessages);
+		.setNeighborUpdates(neighborUpdates).setLogMessages(logMessages);
 
 		return tmpPrepareCH;
 	}
 
 	/**
-	 * Based on the weightingParameters and the specified vehicle a Weighting
-	 * instance can be created. Note that all URL parameters are available in
-	 * the weightingParameters as String if you use the GraphHopper Web module.
+	 * Based on the weightingParameters and the specified vehicle a Weighting instance can be
+	 * created. Note that all URL parameters are available in the weightingParameters as String if
+	 * you use the GraphHopper Web module.
 	 * <p>
-	 * 
+	 *
 	 * @see WeightingMap
-	 * @param weightingMap
-	 *            all parameters influencing the weighting. E.g. parameters
-	 *            coming via GHRequest.getHints or directly via "&api.xy=" from
-	 *            the URL of the web UI
-	 * @param encoder
-	 *            the required vehicle
+	 * @param weightingMap all parameters influencing the weighting. E.g. parameters coming via
+	 *            GHRequest.getHints or directly via "&api.xy=" from the URL of the web UI
+	 * @param encoder the required vehicle
 	 * @return the weighting to be used for route calculation
 	 */
-	public Weighting createWeighting(WeightingMap weightingMap, FlagEncoder encoder) {
+	public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder )
+	{
 		String weighting = weightingMap.getWeighting();
 		Weighting result;
 
-		if ("shortest".equalsIgnoreCase(weighting)) {
+		if ("shortest".equalsIgnoreCase(weighting))
+		{
 			result = new ShortestWeighting();
-		} else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty()) {
+		} else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
+		{
 			if (encoder.supports(PriorityWeighting.class))
 				result = new PriorityWeighting(encoder);
 			else
 				result = new FastestWeighting(encoder);
-		} else if ("fastavoid".equalsIgnoreCase(weighting)) {
+		} else if ("fastavoid".equalsIgnoreCase(weighting))
+		{
 			String avoidanceString = weightingMap.get("avoidances", "cliff");
 			String[] avoidances = avoidanceString.split(",");
-			if (encoder.supports(PriorityWeighting.class)) {
+			if (encoder.supports(PriorityWeighting.class))
+			{
 				AvoidanceAttributeExtension avoidanceExtension = (AvoidanceAttributeExtension) graph
 						.getExtension();
 				result = new PriorityWithAvoidancesWeighting(encoder, avoidanceExtension,
 						avoidances);
-			} else {
+			} else
+			{
 				AvoidanceAttributeExtension avoidanceExtension = (AvoidanceAttributeExtension) graph
 						.getExtension();
 				result = new FastestWithAvoidancesWeighting(encoder, avoidanceExtension, avoidances);
 			}
-		} else if ("shortavoid".equalsIgnoreCase(weighting)) {
+		} else if ("shortavoid".equalsIgnoreCase(weighting))
+		{
 			AvoidanceAttributeExtension avoidanceExtension = (AvoidanceAttributeExtension) graph
 					.getExtension();
 			String avoidanceString = weightingMap.get("avoidances", "cliff");
 			String[] avoidances = avoidanceString.split(",");
 			result = new ShortestWithAvoidancesWeighting(encoder, avoidanceExtension, avoidances);
-		} else {
-			throw new UnsupportedOperationException("weighting " + weighting + " not supported");
+		} else
+		{
+			throw new UnsupportedOperationException(
+					"Weighting "
+							+ weighting
+							+ " not supported. Valid weightings are shorted, fastest, fastavoid, shortavoid");
 		}
 		return result;
 	}
@@ -893,61 +968,71 @@ public Weighting createWeighting(WeightingMap weightingMap, FlagEncoder encoder)
 	/**
 	 * Potentially wraps the specified weighting into a TurnWeighting instance.
 	 */
-	public Weighting createTurnWeighting(Weighting weighting, Graph graph, FlagEncoder encoder) {
+	public Weighting createTurnWeighting( Weighting weighting, Graph graph, FlagEncoder encoder )
+	{
 		if (encoder.supports(TurnWeighting.class))
 			return new TurnWeighting(weighting, encoder, (TurnCostExtension) graph.getExtension());
 		return weighting;
 	}
 
 	@Override
-	public GHResponse route(GHRequest request) {
+	public GHResponse route( GHRequest request )
+	{
 		GHResponse response = new GHResponse();
 		List<Path> paths = getPaths(request, response);
 		if (response.hasErrors())
 			return response;
 
-        boolean tmpEnableInstructions = request.getHints().getBool("instructions", enableInstructions);
+		boolean tmpEnableInstructions = request.getHints().getBool("instructions",
+				enableInstructions);
 		boolean tmpCalcPoints = request.getHints().getBool("calcPoints", calcPoints);
 		double wayPointMaxDistance = request.getHints().getDouble("wayPointMaxDistance", 1d);
 		Locale locale = request.getLocale();
 		DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
 
 		new PathMerger().setCalcPoints(tmpCalcPoints).setDouglasPeucker(peucker)
-				.setEnableInstructions(tmpEnableInstructions)
-				.setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0)
-				.doWork(response, paths, trMap.getWithFallBack(locale));
+		.setEnableInstructions(tmpEnableInstructions)
+		.setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0)
+		.doWork(response, paths, trMap.getWithFallBack(locale));
 		return response;
 	}
 
-	protected List<Path> getPaths(GHRequest request, GHResponse rsp) {
+	protected List<Path> getPaths( GHRequest request, GHResponse rsp )
+	{
 		if (graph == null || !fullyLoaded)
 			throw new IllegalStateException("Call load or importOrLoad before routing");
 
 		if (graph.isClosed())
-            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
+			throw new IllegalStateException(
+					"You need to create a new GraphHopper instance as it is already closed");
 
 		String vehicle = request.getVehicle();
 		if (vehicle.isEmpty())
 			vehicle = getDefaultVehicle().toString();
 
-		if (!encodingManager.supports(vehicle)) {
-            rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. " + "Supported are: "
-                    + getEncodingManager()));
+		if (!encodingManager.supports(vehicle))
+		{
+			rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. "
+					+ "Supported are: " + getEncodingManager()));
 			return Collections.emptyList();
 		}
 
 		TraversalMode tMode;
 		String tModeStr = request.getHints().get("traversal_mode", traversalMode.toString());
-		try {
+		try
+		{
 			tMode = TraversalMode.fromString(tModeStr);
-		} catch (Exception ex) {
+		} catch (Exception ex)
+		{
 			rsp.addError(ex);
 			return Collections.emptyList();
 		}
 
 		List<GHPoint> points = request.getPoints();
-		if (points.size() < 2) {
-            rsp.addError(new IllegalStateException("At least 2 points has to be specified, but was:" + points.size()));
+		if (points.size() < 2)
+		{
+			rsp.addError(new IllegalStateException(
+					"At least 2 points has to be specified, but was:" + points.size()));
 			return Collections.emptyList();
 		}
 
@@ -958,11 +1043,13 @@ public GHResponse route(GHRequest request) {
 
 		StopWatch sw = new StopWatch().start();
 		List<QueryResult> qResults = new ArrayList<QueryResult>(points.size());
-		for (int placeIndex = 0; placeIndex < points.size(); placeIndex++) {
+		for (int placeIndex = 0; placeIndex < points.size(); placeIndex++)
+		{
 			GHPoint point = points.get(placeIndex);
 			QueryResult res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
 			if (!res.isValid())
-                rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": " + point));
+				rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": "
+						+ point));
 
 			qResults.add(res);
 		}
@@ -974,11 +1061,13 @@ public GHResponse route(GHRequest request) {
 
 		QueryGraph queryGraph;
 		RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory();
-		if (chEnabled && !vehicle.equalsIgnoreCase(getDefaultVehicle().toString())) {
+		if (chEnabled && !vehicle.equalsIgnoreCase(getDefaultVehicle().toString()))
+		{
 			// fall back to normal traversing
 			tmpAlgoFactory = new RoutingAlgorithmFactorySimple();
 			queryGraph = new QueryGraph(graph.getBaseGraph());
-		} else {
+		} else
+		{
 			queryGraph = new QueryGraph(graph);
 		}
 
@@ -986,15 +1075,26 @@ public GHResponse route(GHRequest request) {
 
 		List<Path> paths = new ArrayList<Path>(points.size() - 1);
 		QueryResult fromQResult = qResults.get(0);
-		Weighting weighting = createWeighting(request.getHints(), encoder);
+		Weighting weighting = null;
+		try
+		{
+			weighting = createWeighting(request.getHints(), encoder);
+		} catch (UnsupportedOperationException e)
+		{
+			// Message will define what is acceptable.
+			rsp.addError(new IllegalArgumentException(e.getMessage()));
+			return Collections.emptyList();
+		}
 		weighting = createTurnWeighting(weighting, queryGraph, encoder);
 
 		double weightLimit = request.getHints().getDouble("defaultWeightLimit", defaultWeightLimit);
-        String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request.getAlgorithm();
-        AlgorithmOptions algoOpts = AlgorithmOptions.start().algorithm(algoStr).traversalMode(tMode)
-                .flagEncoder(encoder).weighting(weighting).build();
+		String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request
+				.getAlgorithm();
+		AlgorithmOptions algoOpts = AlgorithmOptions.start().algorithm(algoStr)
+				.traversalMode(tMode).flagEncoder(encoder).weighting(weighting).build();
 
-		for (int placeIndex = 1; placeIndex < points.size(); placeIndex++) {
+		for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
+		{
 			QueryResult toQResult = qResults.get(placeIndex);
 			sw = new StopWatch().start();
 			RoutingAlgorithm algo = tmpAlgoFactory.createAlgo(queryGraph, algoOpts);
@@ -1004,10 +1104,12 @@ public GHResponse route(GHRequest request) {
 			sw = new StopWatch().start();
 			Path path = algo.calcPath(fromQResult.getClosestNode(), toQResult.getClosestNode());
 			if (path.getTime() < 0)
-                throw new RuntimeException("Time was negative. Please report as bug and include:" + request);
+				throw new RuntimeException("Time was negative. Please report as bug and include:"
+						+ request);
 
 			paths.add(path);
-            debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, " + path.getDebugInfo();
+			debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, "
+					+ path.getDebugInfo();
 
 			visitedSum.addAndGet(algo.getVisitedNodes());
 			fromQResult = toQResult;
@@ -1017,18 +1119,21 @@ public GHResponse route(GHRequest request) {
 			return Collections.emptyList();
 
 		if (points.size() - 1 != paths.size())
-            throw new RuntimeException("There should be exactly one more places than paths. places:" + points.size()
-							+ ", paths:" + paths.size());
+			throw new RuntimeException(
+					"There should be exactly one more places than paths. places:" + points.size()
+					+ ", paths:" + paths.size());
 
 		rsp.setDebugInfo(debug);
 		return paths;
 	}
 
-	protected LocationIndex createLocationIndex(Directory dir) {
+	protected LocationIndex createLocationIndex( Directory dir )
+	{
 		LocationIndexTree tmpIndex = new LocationIndexTree(graph.getBaseGraph(), dir);
 		tmpIndex.setResolution(preciseIndexResolution);
 		tmpIndex.setMaxRegionSearch(maxRegionSearch);
-		if (!tmpIndex.loadExisting()) {
+		if (!tmpIndex.loadExisting())
+		{
 			ensureWriteAccess();
 			tmpIndex.prepareIndex();
 		}
@@ -1039,14 +1144,16 @@ protected LocationIndex createLocationIndex(Directory dir) {
 	/**
 	 * Initializes the location index after the import is done.
 	 */
-	protected void initLocationIndex() {
+	protected void initLocationIndex()
+	{
 		if (locationIndex != null)
 			throw new IllegalStateException("Cannot initialize locationIndex twice!");
 
 		locationIndex = createLocationIndex(graph.getDirectory());
 	}
 
-	protected void optimize() {
+	protected void optimize()
+	{
 		logger.info("optimizing ... (" + Helper.getMemInfo() + ")");
 		graph.optimize();
 		logger.info("finished optimize (" + Helper.getMemInfo() + ")");
@@ -1054,9 +1161,11 @@ protected void optimize() {
 		// Later: move this into the GraphStorage.optimize method
 		// Or: Doing it after preparation to optimize shortcuts too. But not
 		// possible yet #12
-		if (sortGraph) {
+		if (sortGraph)
+		{
 			if (graph instanceof LevelGraph && isPrepared())
-                throw new IllegalArgumentException("Sorting prepared LevelGraph is not possible yet. See #12");
+				throw new IllegalArgumentException(
+						"Sorting prepared LevelGraph is not possible yet. See #12");
 
 			GraphStorage newGraph = GHUtility.newStorage(graph);
 			GHUtility.sortDFS(graph, newGraph);
@@ -1065,20 +1174,25 @@ protected void optimize() {
 		}
 	}
 
-	protected void prepare() {
+	protected void prepare()
+	{
 		boolean tmpPrepare = doPrepare && algoFactory instanceof PrepareContractionHierarchies;
-		if (tmpPrepare) {
+		if (tmpPrepare)
+		{
 			ensureWriteAccess();
-            logger.info("calling prepare.doWork for " + getDefaultVehicle() + " ... (" + Helper.getMemInfo() + ")");
+			logger.info("calling prepare.doWork for " + getDefaultVehicle() + " ... ("
+					+ Helper.getMemInfo() + ")");
 			((PrepareContractionHierarchies) algoFactory).doWork();
 			graph.getProperties().put("prepare.date", formatDateTime(new Date()));
 		}
 		graph.getProperties().put("prepare.done", tmpPrepare);
 	}
 
-	protected void cleanUp() {
+	protected void cleanUp()
+	{
 		int prev = graph.getNodes();
-        PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
+		PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph,
+				encodingManager);
 		preparation.setMinNetworkSize(minNetworkSize);
 		preparation.setMinOneWayNetworkSize(minOneWayNetworkSize);
 		logger.info("start finding subnetworks, " + Helper.getMemInfo());
@@ -1091,40 +1205,45 @@ protected void cleanUp() {
 				+ " less nodes. Remaining subnetworks:" + remainingSubnetworks);
 	}
 
-	protected void flush() {
-        logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString() + ", "
-                + Helper.getMemInfo() + ")");
+	protected void flush()
+	{
+		logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString()
+				+ ", " + Helper.getMemInfo() + ")");
 		graph.flush();
 		fullyLoaded = true;
 	}
 
 	/**
-	 * Releases all associated resources like memory or files. But it does not
-	 * remove them. To remove the files created in graphhopperLocation you have
-	 * to call clean().
+	 * Releases all associated resources like memory or files. But it does not remove them. To
+	 * remove the files created in graphhopperLocation you have to call clean().
 	 */
-	public void close() {
+	public void close()
+	{
 		if (graph != null)
 			graph.close();
 
 		if (locationIndex != null)
 			locationIndex.close();
 
-		try {
+		try
+		{
 			lockFactory.forceRemove(fileLockName, true);
-		} catch (Exception ex) {
+		} catch (Exception ex)
+		{
 			// silently fail e.g. on Windows where we cannot remove an
 			// unreleased native lock
 		}
 	}
 
 	/**
-	 * Removes the on-disc routing files. Call only after calling close or
-	 * before importOrLoad or load
+	 * Removes the on-disc routing files. Call only after calling close or before importOrLoad or
+	 * load
 	 */
-	public void clean() {
+	public void clean()
+	{
 		if (getGraphHopperLocation().isEmpty())
-            throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
+			throw new IllegalStateException(
+					"Cannot clean GraphHopper without specified graphHopperLocation");
 
 		File folder = new File(getGraphHopperLocation());
 		Helper.removeDir(folder);
@@ -1132,44 +1251,53 @@ public void clean() {
 
 	// make sure this is identical to buildDate used in pom.xml
 	// <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ssZ</maven.build.timestamp.format>
-	private String formatDateTime(Date date) {
+	private String formatDateTime( Date date )
+	{
 		return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
 	}
 
-	protected void ensureNotLoaded() {
+	protected void ensureNotLoaded()
+	{
 		if (fullyLoaded)
-            throw new IllegalStateException("No configuration changes are possible after loading the graph");
+			throw new IllegalStateException(
+					"No configuration changes are possible after loading the graph");
 	}
 
-	protected void ensureWriteAccess() {
+	protected void ensureWriteAccess()
+	{
 		if (!allowWrites)
 			throw new IllegalStateException("Writes are not allowed!");
 	}
 
 	/**
-	 * Returns the current sum of the visited nodes while routing. Mainly for
-	 * statistic and debugging purposes.
+	 * Returns the current sum of the visited nodes while routing. Mainly for statistic and
+	 * debugging purposes.
 	 */
-	public long getVisitedSum() {
+	public long getVisitedSum()
+	{
 		return visitedSum.get();
 	}
 
-	public GraphHopper setAsOSMReader() {
+	public GraphHopper setAsOSMReader()
+	{
 		dataReader = "OSM";
 		return this;
 	}
 
-	public GraphHopper setAsItnReader() {
+	public GraphHopper setAsItnReader()
+	{
 		dataReader = "OSITN";
 		return this;
 	}
 
-	public GraphHopper setAsHnReader() {
+	public GraphHopper setAsHnReader()
+	{
 		dataReader = "OSHN";
 		return this;
 	}
 
-	public GraphHopper setAsDpnReader() {
+	public GraphHopper setAsDpnReader()
+	{
 		dataReader = "OSDPN";
 		return this;
 	}
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractAvoidanceDecorator.java b/core/src/main/java/com/graphhopper/routing/util/AbstractAvoidanceDecorator.java
index a1f166c0e1..29ca7faeec 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractAvoidanceDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractAvoidanceDecorator.java
@@ -7,16 +7,22 @@
 public abstract class AbstractAvoidanceDecorator implements EncoderDecorator {
 
 	protected EncodedValue wayTypeEncoder;
+	protected int originalShift;
 	public static final int KEY = 303;
 
 	protected abstract void defineEncoder(int shift);
 	protected abstract EdgeAttribute[] getEdgeAttributesOfInterest();
 
 	public int defineWayBits(int shift) {
+		originalShift = shift;
 		defineEncoder(shift);
 		shift += wayTypeEncoder.getBits();
 		return shift;
 	}
+	
+	public int getOriginalShift() {
+		return originalShift;
+	}
 
 	public InstructionAnnotation getAnnotation( long flags, Translation tr )
     {
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncoderDecorator.java b/core/src/main/java/com/graphhopper/routing/util/EncoderDecorator.java
index 84975c7e58..983f3db2f8 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncoderDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncoderDecorator.java
@@ -12,4 +12,5 @@
 	double getDouble(long flags);
 	long getLong(long flags);
 	boolean supports(int key);
+	int getOriginalShift();
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index 97cbc3953e..6f002c31f3 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -470,7 +470,8 @@ public void applyWayTags( Way way, EdgeIteratorState edge )
 	}
 
 	/**
-	 * Each encoder decorator should be used only once and in a defined order
+	 * Each encoder decorator should be used only once for storage and in a defined order.
+	 * However each encoder needs its decorator list to be configured the same way.
 	 */
 	private void configureDecoratorSet()
 	{
@@ -493,6 +494,20 @@ private void configureDecoratorSet()
 		{
 			shift = decorator.defineWayBits(shift);
 		}
+		for (AbstractFlagEncoder encoder : edgeEncoders)
+		{
+			List<EncoderDecorator> decoratorList = encoder.getEncoderDecorators();
+			if (null != decoratorList)
+			{
+				for (EncoderDecorator encoderDecorator : decoratorList)
+				{
+					EncoderDecorator configuredDecorator = decoratorMap.get(encoderDecorator.getClass());
+					if(configuredDecorator != encoderDecorator) {
+						encoderDecorator.defineWayBits(configuredDecorator.getOriginalShift());
+					}
+				}
+			}
+		}
 	}
 
 	public List<EncoderDecorator> getDecorators()
diff --git a/web/src/main/java/com/graphhopper/http/APIException.java b/web/src/main/java/com/graphhopper/http/APIException.java
new file mode 100644
index 0000000000..70f9634612
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/APIException.java
@@ -0,0 +1,26 @@
+package com.graphhopper.http;
+
+import org.eclipse.jetty.http.HttpStatus;
+import org.eclipse.jetty.http.HttpStatus.Code;
+
+public class APIException extends Exception {
+	/**
+	 * 
+	 */
+	private static final long serialVersionUID = 1L;
+	private HttpStatus.Code statusCode;
+
+	public APIException(Code statusCode, String message) {
+		super(message);
+		this.statusCode = statusCode;
+	}
+	
+	public HttpStatus.Code getStatusCode() {
+		return statusCode;
+	}
+	
+	public String getStatusMessage() {
+		return getMessage();
+	}
+
+}
diff --git a/web/src/main/java/com/graphhopper/http/ApiResource.java b/web/src/main/java/com/graphhopper/http/ApiResource.java
new file mode 100644
index 0000000000..24d654d8fe
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/ApiResource.java
@@ -0,0 +1,147 @@
+package com.graphhopper.http;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.servlet.http.HttpServletRequest;
+ 
+ 
+public enum ApiResource {
+	ROUTE("route", new String[]{"point","vehicle"}, new String[] { "point", "locale", "instructions", "vehicle", "weighting", "algorithm", "points_encoded", "debug", "calc_points","tye","avoidances" }),
+    NEAREST("nearest", new String[]{"point"}, new String[] { "point"}),
+	INFO("info", new String[]{}, new String[] { });
+	   
+	
+    public String[] getMandatoryValues() {
+        return mandatoryValues;
+    }
+ 
+ 
+    public String[] getValidValues() {
+        return validValues;
+    }
+ 
+ 
+    public String getResourceName() {
+        return resourceName;
+    }
+ 
+ 
+    private String resourceName;
+    private String[] mandatoryValues;
+    private String[] validValues;
+ 
+ 
+    private ApiResource(String resourceName, String[] mandatoryValues, String[] validValues) {
+        this.resourceName = resourceName;
+        this.mandatoryValues = mandatoryValues;
+        this.validValues = validValues;
+    }
+   
+    /**
+     * Scans through all the request parameters. Checks if the mandatory field
+     * exists for a resource. Checks if all the request parameters are valid for
+     * the resource. Throws appropriate exceptions if not
+     *
+     * @param HttpServletRequest
+     * @param APIResource
+     *
+     * @throws MissingParameterException
+     * @throws NoSuchParameterException
+     */
+    public void checkAllRequestParameters(HttpServletRequest request)
+            throws MissingParameterException, NoSuchParameterException, InvalidParameterException {
+        // Check if the mandatory parameter exists in the request
+        String value =  this.getMandatoryValues()[0];
+        boolean mandatoryValueExists = checkMandatoryValue(request, value);
+        if( mandatoryValueExists && this.getMandatoryValues().length > 1 )
+        {
+            value =  this.getMandatoryValues()[1];
+            mandatoryValueExists = checkMandatoryValue(request, value);
+        }
+        if(!mandatoryValueExists)
+        {
+            throw new MissingParameterException(value);
+        }
+       
+        // Now check for all the valid parameters for the resource
+        checkValidParameters(request);
+    }
+   
+    /**
+     * Checks if the given mandatory value exists in the request parameters
+     *
+     * @param parameters Enumeration<String>
+     * @param mandatoryValue
+     * @return
+     */
+    private boolean checkMandatoryValue(HttpServletRequest request, String mandatoryValue)
+    {
+        Set<String> keys = request.getParameterMap().keySet();
+        for(String key: keys)
+       {
+            if(mandatoryValue.equalsIgnoreCase(key))
+            {
+                return true;
+            }
+        }       
+        return false;
+    }
+   
+    /**
+     * Checks if all the valid parameters exist in the request for the resource
+     *
+     * @param request
+     * @throws NoSuchParameterException
+     * @throws InvalidParameterException
+     */
+    private void checkValidParameters(HttpServletRequest request) throws NoSuchParameterException, InvalidParameterException
+    {
+        // Now check for all the valid parameters for the resource
+        List<String> list = Arrays.asList(this.getValidValues());
+        Map<String, String[]> parameterMap = request.getParameterMap();
+        for (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {
+            String parameterName = entry.getKey().toLowerCase();
+            if (!list.contains(parameterName)) {
+                throw new NoSuchParameterException(getInvalidParameterMessage(
+                        parameterName, this.getResourceName(), this.getValidValues()));
+            }
+        }
+    }
+ 
+ 
+    /**
+     * Builds the message when the parameter provided is invalid
+     *
+     * @param invalid
+     * @param parameter
+     * @param validValues
+     * @return message String
+     */
+    private String getInvalidParameterMessage(String invalid, String parameter,
+            String[] validValues) {
+        StringBuilder sb = new StringBuilder();
+ 
+ 
+        sb.append("Parameter ").append(invalid)
+        .append(" is not a valid parameter for resource ")
+        .append(parameter)
+        .append(". Valid parameters for requested resource are ");
+ 
+ 
+        List<String> validList = Arrays.asList(validValues);
+        for (String valid : validList) {
+            sb.append(valid).append(", ");
+        }
+        String message = sb.substring(0, sb.length() - 2) + ".";
+ 
+ 
+        return message;
+    }
+ 
+ 
+ 
+ 
+}
\ No newline at end of file
diff --git a/web/src/main/java/com/graphhopper/http/InvalidParameterException.java b/web/src/main/java/com/graphhopper/http/InvalidParameterException.java
new file mode 100644
index 0000000000..526d4ce38e
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/InvalidParameterException.java
@@ -0,0 +1,17 @@
+package com.graphhopper.http;
+
+import org.eclipse.jetty.http.HttpStatus.Code;
+
+public class InvalidParameterException extends APIException {
+
+	public InvalidParameterException(String message )
+    {
+	    super(Code.BAD_REQUEST, message);
+    }
+
+	/**
+	 * 
+	 */
+    private static final long serialVersionUID = 1L;
+
+}
diff --git a/web/src/main/java/com/graphhopper/http/MissingParameterException.java b/web/src/main/java/com/graphhopper/http/MissingParameterException.java
new file mode 100644
index 0000000000..5300e9ba2f
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/MissingParameterException.java
@@ -0,0 +1,18 @@
+package com.graphhopper.http;
+
+import org.eclipse.jetty.http.HttpStatus;
+
+public class MissingParameterException extends APIException {
+
+	/**
+	 * 
+	 */
+	private static final long serialVersionUID = 1L;
+	
+	private static String message = "No %s parameter provided.";
+
+	public MissingParameterException(String parameter) {
+		super(HttpStatus.Code.BAD_REQUEST, String.format(message , parameter));
+	}
+
+}
diff --git a/web/src/main/java/com/graphhopper/http/NoSuchParameterException.java b/web/src/main/java/com/graphhopper/http/NoSuchParameterException.java
new file mode 100644
index 0000000000..aaf6cf4d18
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/NoSuchParameterException.java
@@ -0,0 +1,16 @@
+package com.graphhopper.http;
+
+import org.eclipse.jetty.http.HttpStatus.Code;
+
+public class NoSuchParameterException extends APIException {
+
+	public NoSuchParameterException(String message) {
+		super(Code.BAD_REQUEST, message);
+	}
+
+	/**
+	 * 
+	 */
+	private static final long serialVersionUID = 1L;
+
+}
